head	1.72;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.70
	gdb_7_6-2013-04-26-release:1.70
	gdb_7_6-branch:1.70.0.2
	gdb_7_6-2013-03-12-branchpoint:1.70
	gdb_7_5_1-2012-11-29-release:1.68
	gdb_7_5-2012-08-17-release:1.68
	gdb_7_5-branch:1.68.0.2
	gdb_7_5-2012-07-18-branchpoint:1.68
	gdb_7_4_1-2012-04-26-release:1.65.2.1
	gdb_7_4-2012-01-24-release:1.65.2.1
	gdb_7_4-branch:1.65.0.2
	gdb_7_4-2011-12-13-branchpoint:1.65
	gdb_7_3_1-2011-09-04-release:1.63
	gdb_7_3-2011-07-26-release:1.63
	gdb_7_3-branch:1.63.0.2
	gdb_7_3-2011-04-01-branchpoint:1.63
	gdb_7_2-2010-09-02-release:1.57
	gdb_7_2-branch:1.57.0.4
	gdb_7_2-2010-07-07-branchpoint:1.57
	gdb_7_1-2010-03-18-release:1.57
	gdb_7_1-branch:1.57.0.2
	gdb_7_1-2010-02-18-branchpoint:1.57
	gdb_7_0_1-2009-12-22-release:1.55.4.2
	gdb_7_0-2009-10-06-release:1.55.4.2
	gdb_7_0-branch:1.55.0.4
	gdb_7_0-2009-09-16-branchpoint:1.55
	arc-sim-20090309:1.48
	msnyder-checkpoint-072509-branch:1.55.0.2
	msnyder-checkpoint-072509-branchpoint:1.55
	arc-insight_6_8-branch:1.48.0.6
	arc-insight_6_8-branchpoint:1.48
	insight_6_8-branch:1.48.0.4
	insight_6_8-branchpoint:1.48
	reverse-20081226-branch:1.53.0.8
	reverse-20081226-branchpoint:1.53
	multiprocess-20081120-branch:1.53.0.6
	multiprocess-20081120-branchpoint:1.53
	reverse-20080930-branch:1.53.0.4
	reverse-20080930-branchpoint:1.53
	reverse-20080717-branch:1.53.0.2
	reverse-20080717-branchpoint:1.53
	msnyder-reverse-20080609-branch:1.52.0.2
	msnyder-reverse-20080609-branchpoint:1.52
	drow-reverse-20070409-branch:1.35.0.2
	drow-reverse-20070409-branchpoint:1.35
	gdb_6_8-2008-03-27-release:1.48
	gdb_6_8-branch:1.48.0.2
	gdb_6_8-2008-02-26-branchpoint:1.48
	gdb_6_7_1-2007-10-29-release:1.40
	gdb_6_7-2007-10-10-release:1.40
	gdb_6_7-branch:1.40.0.2
	gdb_6_7-2007-09-07-branchpoint:1.40
	insight_6_6-20070208-release:1.33
	gdb_6_6-2006-12-18-release:1.33
	gdb_6_6-branch:1.33.0.18
	gdb_6_6-2006-11-15-branchpoint:1.33
	insight_6_5-20061003-release:1.33
	gdb-csl-symbian-6_4_50_20060226-12:1.33
	gdb-csl-sourcerygxx-3_4_4-25:1.32
	nickrob-async-20060828-mergepoint:1.33
	gdb-csl-symbian-6_4_50_20060226-11:1.33
	gdb-csl-sourcerygxx-4_1-17:1.33
	gdb-csl-20060226-branch-local-2:1.33
	gdb-csl-sourcerygxx-4_1-14:1.33
	gdb-csl-sourcerygxx-4_1-13:1.33
	gdb-csl-sourcerygxx-4_1-12:1.33
	gdb-csl-sourcerygxx-3_4_4-21:1.33
	gdb_6_5-20060621-release:1.33
	gdb-csl-sourcerygxx-4_1-9:1.33
	gdb-csl-sourcerygxx-4_1-8:1.33
	gdb-csl-sourcerygxx-4_1-7:1.33
	gdb-csl-arm-2006q1-6:1.33
	gdb-csl-sourcerygxx-4_1-6:1.33
	gdb-csl-symbian-6_4_50_20060226-10:1.33
	gdb-csl-symbian-6_4_50_20060226-9:1.33
	gdb-csl-symbian-6_4_50_20060226-8:1.33
	gdb-csl-coldfire-4_1-11:1.33
	gdb-csl-sourcerygxx-3_4_4-19:1.33
	gdb-csl-coldfire-4_1-10:1.33
	gdb_6_5-branch:1.33.0.16
	gdb_6_5-2006-05-14-branchpoint:1.33
	gdb-csl-sourcerygxx-4_1-5:1.33
	nickrob-async-20060513-branch:1.33.0.14
	nickrob-async-20060513-branchpoint:1.33
	gdb-csl-sourcerygxx-4_1-4:1.33
	msnyder-reverse-20060502-branch:1.33.0.12
	msnyder-reverse-20060502-branchpoint:1.33
	gdb-csl-morpho-4_1-4:1.33
	gdb-csl-sourcerygxx-3_4_4-17:1.33
	readline_5_1-import-branch:1.33.0.10
	readline_5_1-import-branchpoint:1.33
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.33
	gdb-csl-symbian-20060226-branch:1.33.0.8
	gdb-csl-symbian-20060226-branchpoint:1.33
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.33
	msnyder-reverse-20060331-branch:1.33.0.6
	msnyder-reverse-20060331-branchpoint:1.33
	gdb-csl-available-20060303-branch:1.33.0.4
	gdb-csl-available-20060303-branchpoint:1.33
	gdb-csl-20060226-branch:1.33.0.2
	gdb-csl-20060226-branchpoint:1.33
	gdb_6_4-20051202-release:1.31.4.1
	msnyder-fork-checkpoint-branch:1.32.0.4
	msnyder-fork-checkpoint-branchpoint:1.32
	gdb-csl-gxxpro-6_3-branch:1.32.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.32
	gdb_6_4-branch:1.31.0.4
	gdb_6_4-2005-11-01-branchpoint:1.31
	gdb-csl-arm-20051020-branch:1.31.0.2
	gdb-csl-arm-20051020-branchpoint:1.31
	msnyder-tracepoint-checkpoint-branch:1.29.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.29
	gdb-csl-arm-20050325-2005-q1b:1.28
	gdb-csl-arm-20050325-2005-q1a:1.28
	csl-arm-20050325-branch:1.28.0.2
	csl-arm-20050325-branchpoint:1.28
	gdb-post-i18n-errorwarning-20050211:1.27
	gdb-pre-i18n-errorwarning-20050211:1.27
	gdb_6_3-20041109-release:1.24
	gdb_6_3-branch:1.24.0.4
	gdb_6_3-20041019-branchpoint:1.24
	drow_intercu-merge-20040921:1.24
	drow_intercu-merge-20040915:1.24
	jimb-gdb_6_2-e500-branch:1.24.0.6
	jimb-gdb_6_2-e500-branchpoint:1.24
	gdb_6_2-20040730-release:1.24
	gdb_6_2-branch:1.24.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.24
	gdb_6_1_1-20040616-release:1.21
	gdb_6_1-2004-04-05-release:1.21
	drow_intercu-merge-20040402:1.21
	drow_intercu-merge-20040327:1.21
	ezannoni_pie-20040323-branch:1.21.0.12
	ezannoni_pie-20040323-branchpoint:1.21
	cagney_tramp-20040321-mergepoint:1.21
	cagney_tramp-20040309-branch:1.21.0.10
	cagney_tramp-20040309-branchpoint:1.21
	gdb_6_1-branch:1.21.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.21
	drow_intercu-20040221-branch:1.21.0.6
	drow_intercu-20040221-branchpoint:1.21
	cagney_bfdfile-20040213-branch:1.21.0.4
	cagney_bfdfile-20040213-branchpoint:1.21
	drow-cplus-merge-20040208:1.21
	carlton_dictionary-20040126-merge:1.21
	cagney_bigcore-20040122-branch:1.21.0.2
	cagney_bigcore-20040122-branchpoint:1.21
	drow-cplus-merge-20040113:1.21
	drow-cplus-merge-20031224:1.21
	drow-cplus-merge-20031220:1.21
	carlton_dictionary-20031215-merge:1.21
	drow-cplus-merge-20031214:1.21
	carlton-dictionary-20031111-merge:1.20
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.11.0.2
	kettenis_sparc-20030918-branchpoint:1.11
	carlton_dictionary-20030917-merge:1.11
	ezannoni_pie-20030916-branchpoint:1.10
	ezannoni_pie-20030916-branch:1.10.0.2
	cagney_x86i386-20030821-branch:1.5.0.12
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.10
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.8
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.6
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.4.0.12
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.5.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.2
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.4.0.10
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.8
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.6
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.4
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.2
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.3.0.12
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.10
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.8
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.6
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030203-mergepoint:1.3
	interps-20030202-branch:1.3.0.4
	interps-20030202-branchpoint:1.3
	cagney-unwind-20030108-branch:1.3.0.2
	cagney-unwind-20030108-branchpoint:1.3
	carlton_dictionary-20021223-merge:1.3
	gdb_5_3-2002-12-12-release:1.1.10.1
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.2
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.1
	carlton_dictionary-20020927-merge:1.1
	carlton_dictionary-branch:1.1.0.12
	carlton_dictionary-20020920-branchpoint:1.1
	gdb_5_3-branch:1.1.0.10
	gdb_5_3-2002-09-04-branchpoint:1.1
	kseitz_interps-20020829-merge:1.1
	cagney_sysregs-20020825-branch:1.1.0.8
	cagney_sysregs-20020825-branchpoint:1.1
	readline_4_3-import-branch:1.1.0.6
	readline_4_3-import-branchpoint:1.1
	kseitz_interps-20020528-branch:1.1.0.4
	cagney_regbuf-20020515-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.72
date	2013.04.08.19.59.09;	author tromey;	state Exp;
branches;
next	1.71;

1.71
date	2013.04.01.04.05.35;	author tdaitx;	state Exp;
branches;
next	1.70;

1.70
date	2013.01.23.20.03.18;	author sergiodj;	state Exp;
branches;
next	1.69;

1.69
date	2013.01.01.06.32.49;	author brobecke;	state Exp;
branches;
next	1.68;

1.68
date	2012.05.18.21.02.49;	author sergiodj;	state Exp;
branches;
next	1.67;

1.67
date	2012.05.16.14.35.06;	author macro;	state Exp;
branches;
next	1.66;

1.66
date	2012.01.04.08.17.09;	author brobecke;	state Exp;
branches;
next	1.65;

1.65
date	2011.10.26.17.21.53;	author uweigand;	state Exp;
branches
	1.65.2.1;
next	1.64;

1.64
date	2011.10.24.16.51.36;	author brobecke;	state Exp;
branches;
next	1.63;

1.63
date	2011.03.15.14.42.33;	author uweigand;	state Exp;
branches;
next	1.62;

1.62
date	2011.02.08.13.30.08;	author uweigand;	state Exp;
branches;
next	1.61;

1.61
date	2011.02.08.13.25.00;	author uweigand;	state Exp;
branches;
next	1.60;

1.60
date	2011.01.11.15.10.01;	author msnyder;	state Exp;
branches;
next	1.59;

1.59
date	2011.01.10.20.38.50;	author msnyder;	state Exp;
branches;
next	1.58;

1.58
date	2011.01.01.15.33.12;	author brobecke;	state Exp;
branches;
next	1.57;

1.57
date	2010.01.01.07.31.38;	author brobecke;	state Exp;
branches;
next	1.56;

1.56
date	2009.09.29.00.48.32;	author uweigand;	state Exp;
branches;
next	1.55;

1.55
date	2009.07.02.17.25.58;	author uweigand;	state Exp;
branches
	1.55.4.1;
next	1.54;

1.54
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.53;

1.53
date	2008.06.26.15.38.39;	author jsm28;	state Exp;
branches;
next	1.52;

1.52
date	2008.05.16.12.49.47;	author uweigand;	state Exp;
branches;
next	1.51;

1.51
date	2008.05.03.23.24.17;	author bauermann;	state Exp;
branches;
next	1.50;

1.50
date	2008.05.02.23.24.44;	author uweigand;	state Exp;
branches;
next	1.49;

1.49
date	2008.04.22.11.03.42;	author corinna;	state Exp;
branches;
next	1.48;

1.48
date	2008.02.02.00.07.57;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2008.02.01.15.04.18;	author bauermann;	state Exp;
branches;
next	1.46;

1.46
date	2008.01.30.03.18.39;	author bauermann;	state Exp;
branches;
next	1.45;

1.45
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.16.04.53.46;	author deuling;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.08.00.10.06;	author jsm28;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.08.00.08.47;	author jsm28;	state Exp;
branches;
next	1.41;

1.41
date	2007.10.30.19.35.35;	author drow;	state Exp;
branches;
next	1.40;

1.40
date	2007.09.06.20.21.16;	author drow;	state Exp;
branches;
next	1.39;

1.39
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.15.22.34.13;	author uweigand;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.13.12.27.30;	author uweigand;	state Exp;
branches;
next	1.35;

1.35
date	2007.01.29.17.31.06;	author drow;	state Exp;
branches;
next	1.34;

1.34
date	2007.01.09.17.58.55;	author drow;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.07.20.37.58;	author pgilliam;	state Exp;
branches;
next	1.31;

1.31
date	2005.08.17.07.44.13;	author kettenis;	state Exp;
branches
	1.31.4.1;
next	1.30;

1.30
date	2005.08.16.17.12.35;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.25.03.12.13;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2005.02.11.18.13.52;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2005.02.09.16.51.43;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.07.00.09.54;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2004.11.12.21.45.06;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2004.06.07.02.02.52;	author tausq;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.07.20.48.43;	author jimb;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.05.01.46.55;	author jimb;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.14.14.34.30;	author cagney;	state Exp;
branches
	1.21.6.1;
next	1.20;

1.20
date	2003.11.10.22.47.28;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.07.20.44.51;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.31.16.37.03;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.20.15.38.02;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.10.21.32.47;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.10.18.29.13;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.06.22.23.47;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.03.21.11.39;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.19.16.22.39;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.16.23.33.17;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.12.18.55.24;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.11.19.27.25;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.09.22.41.47;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.09.20.22.37;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.09.18.29.26;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.13.19.27.28;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.17.18.27.07;	author cagney;	state Exp;
branches
	1.4.8.1
	1.4.12.1;
next	1.3;

1.3
date	2002.11.14.20.37.28;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.01.19.26.04;	author carlton;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2002.05.30.01.21.51;	author thorpej;	state Exp;
branches
	1.1.2.1
	1.1.4.1
	1.1.10.1
	1.1.12.1;
next	;

1.65.2.1
date	2012.01.06.04.43.22;	author brobecke;	state Exp;
branches;
next	;

1.55.4.1
date	2009.09.29.00.49.18;	author uweigand;	state Exp;
branches;
next	1.55.4.2;

1.55.4.2
date	2009.09.29.18.59.39;	author uweigand;	state Exp;
branches;
next	;

1.31.4.1
date	2005.11.14.22.15.57;	author pgilliam;	state Exp;
branches;
next	;

1.21.6.1
date	2004.09.16.17.01.16;	author drow;	state Exp;
branches;
next	;

1.4.8.1
date	2003.05.18.09.44.19;	author kettenis;	state Exp;
branches;
next	;

1.4.12.1
date	2003.06.03.20.54.38;	author cagney;	state Exp;
branches;
next	;

1.2.2.1
date	2003.12.14.20.27.27;	author drow;	state Exp;
branches;
next	;

1.1.2.1
date	2002.06.15.16.42.54;	author cagney;	state Exp;
branches;
next	;

1.1.4.1
date	2002.06.20.01.32.53;	author kseitz;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.11.04.00.17.32;	author ezannoni;	state Exp;
branches;
next	;

1.1.10.1
date	2002.11.25.22.05.39;	author cagney;	state Exp;
branches;
next	;

1.1.12.1
date	2002.09.30.22.57.22;	author carlton;	state Exp;
branches;
next	1.1.12.2;

1.1.12.2
date	2002.11.15.19.18.52;	author carlton;	state Exp;
branches;
next	1.1.12.3;

1.1.12.3
date	2003.04.16.19.56.53;	author carlton;	state Exp;
branches;
next	1.1.12.4;

1.1.12.4
date	2003.05.23.18.40.43;	author carlton;	state Exp;
branches;
next	1.1.12.5;

1.1.12.5
date	2003.09.17.21.28.27;	author carlton;	state Exp;
branches;
next	1.1.12.6;

1.1.12.6
date	2003.11.11.23.50.52;	author carlton;	state Exp;
branches;
next	1.1.12.7;

1.1.12.7
date	2003.12.16.00.00.45;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.72
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@/* Target-dependent code for PowerPC systems using the SVR4 ABI
   for GDB, the GNU debugger.

   Copyright (C) 2000-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdbcore.h"
#include "inferior.h"
#include "regcache.h"
#include "value.h"
#include "gdb_string.h"
#include "gdb_assert.h"
#include "ppc-tdep.h"
#include "target.h"
#include "objfiles.h"
#include "infcall.h"
#include "dwarf2.h"


/* Check whether FTPYE is a (pointer to) function type that should use
   the OpenCL vector ABI.  */

static int
ppc_sysv_use_opencl_abi (struct type *ftype)
{
  ftype = check_typedef (ftype);

  if (TYPE_CODE (ftype) == TYPE_CODE_PTR)
    ftype = check_typedef (TYPE_TARGET_TYPE (ftype));

  return (TYPE_CODE (ftype) == TYPE_CODE_FUNC
	  && TYPE_CALLING_CONVENTION (ftype) == DW_CC_GDB_IBM_OpenCL);
}

/* Pass the arguments in either registers, or in the stack.  Using the
   ppc sysv ABI, the first eight words of the argument list (that might
   be less than eight parameters if some parameters occupy more than one
   word) are passed in r3..r10 registers.  float and double parameters are
   passed in fpr's, in addition to that.  Rest of the parameters if any
   are passed in user stack.

   If the function is returning a structure, then the return address is passed
   in r3, then the first 7 words of the parametes can be passed in registers,
   starting from r4.  */

CORE_ADDR
ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
			      struct regcache *regcache, CORE_ADDR bp_addr,
			      int nargs, struct value **args, CORE_ADDR sp,
			      int struct_return, CORE_ADDR struct_addr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int opencl_abi = ppc_sysv_use_opencl_abi (value_type (function));
  ULONGEST saved_sp;
  int argspace = 0;		/* 0 is an initial wrong guess.  */
  int write_pass;

  gdb_assert (tdep->wordsize == 4);

  regcache_cooked_read_unsigned (regcache, gdbarch_sp_regnum (gdbarch),
				 &saved_sp);

  /* Go through the argument list twice.

     Pass 1: Figure out how much new stack space is required for
     arguments and pushed values.  Unlike the PowerOpen ABI, the SysV
     ABI doesn't reserve any extra space for parameters which are put
     in registers, but does always push structures and then pass their
     address.

     Pass 2: Replay the same computation but this time also write the
     values out to the target.  */

  for (write_pass = 0; write_pass < 2; write_pass++)
    {
      int argno;
      /* Next available floating point register for float and double
         arguments.  */
      int freg = 1;
      /* Next available general register for non-float, non-vector
         arguments.  */
      int greg = 3;
      /* Next available vector register for vector arguments.  */
      int vreg = 2;
      /* Arguments start above the "LR save word" and "Back chain".  */
      int argoffset = 2 * tdep->wordsize;
      /* Structures start after the arguments.  */
      int structoffset = argoffset + argspace;

      /* If the function is returning a `struct', then the first word
         (which will be passed in r3) is used for struct return
         address.  In that case we should advance one word and start
         from r4 register to copy parameters.  */
      if (struct_return)
	{
	  if (write_pass)
	    regcache_cooked_write_signed (regcache,
					  tdep->ppc_gp0_regnum + greg,
					  struct_addr);
	  greg++;
	}

      for (argno = 0; argno < nargs; argno++)
	{
	  struct value *arg = args[argno];
	  struct type *type = check_typedef (value_type (arg));
	  int len = TYPE_LENGTH (type);
	  const bfd_byte *val = value_contents (arg);

	  if (TYPE_CODE (type) == TYPE_CODE_FLT && len <= 8
	      && !tdep->soft_float)
	    {
	      /* Floating point value converted to "double" then
	         passed in an FP register, when the registers run out,
	         8 byte aligned stack is used.  */
	      if (freg <= 8)
		{
		  if (write_pass)
		    {
		      /* Always store the floating point value using
		         the register's floating-point format.  */
		      gdb_byte regval[MAX_REGISTER_SIZE];
		      struct type *regtype
			= register_type (gdbarch, tdep->ppc_fp0_regnum + freg);
		      convert_typed_floating (val, type, regval, regtype);
		      regcache_cooked_write (regcache,
                                             tdep->ppc_fp0_regnum + freg,
					     regval);
		    }
		  freg++;
		}
	      else
		{
		  /* The SysV ABI tells us to convert floats to
		     doubles before writing them to an 8 byte aligned
		     stack location.  Unfortunately GCC does not do
		     that, and stores floats into 4 byte aligned
		     locations without converting them to doubles.
		     Since there is no know compiler that actually
		     follows the ABI here, we implement the GCC
		     convention.  */

		  /* Align to 4 bytes or 8 bytes depending on the type of
		     the argument (float or double).  */
		  argoffset = align_up (argoffset, len);
		  if (write_pass)
		      write_memory (sp + argoffset, val, len);
		  argoffset += len;
		}
	    }
	  else if (TYPE_CODE (type) == TYPE_CODE_FLT
		   && len == 16
		   && !tdep->soft_float
		   && (gdbarch_long_double_format (gdbarch)
		       == floatformats_ibm_long_double))
	    {
	      /* IBM long double passed in two FP registers if
		 available, otherwise 8-byte aligned stack.  */
	      if (freg <= 7)
		{
		  if (write_pass)
		    {
		      regcache_cooked_write (regcache,
					     tdep->ppc_fp0_regnum + freg,
					     val);
		      regcache_cooked_write (regcache,
					     tdep->ppc_fp0_regnum + freg + 1,
					     val + 8);
		    }
		  freg += 2;
		}
	      else
		{
		  argoffset = align_up (argoffset, 8);
		  if (write_pass)
		    write_memory (sp + argoffset, val, len);
		  argoffset += 16;
		}
	    }
	  else if (len == 8
		   && (TYPE_CODE (type) == TYPE_CODE_INT	/* long long */
		       || TYPE_CODE (type) == TYPE_CODE_FLT	/* double */
		       || (TYPE_CODE (type) == TYPE_CODE_DECFLOAT
			   && tdep->soft_float)))
	    {
	      /* "long long" or soft-float "double" or "_Decimal64"
	         passed in an odd/even register pair with the low
	         addressed word in the odd register and the high
	         addressed word in the even register, or when the
	         registers run out an 8 byte aligned stack
	         location.  */
	      if (greg > 9)
		{
		  /* Just in case GREG was 10.  */
		  greg = 11;
		  argoffset = align_up (argoffset, 8);
		  if (write_pass)
		    write_memory (sp + argoffset, val, len);
		  argoffset += 8;
		}
	      else
		{
		  /* Must start on an odd register - r3/r4 etc.  */
		  if ((greg & 1) == 0)
		    greg++;
		  if (write_pass)
		    {
		      regcache_cooked_write (regcache,
					     tdep->ppc_gp0_regnum + greg + 0,
					     val + 0);
		      regcache_cooked_write (regcache,
					     tdep->ppc_gp0_regnum + greg + 1,
					     val + 4);
		    }
		  greg += 2;
		}
	    }
	  else if (len == 16
		   && ((TYPE_CODE (type) == TYPE_CODE_FLT
			&& (gdbarch_long_double_format (gdbarch)
			    == floatformats_ibm_long_double))
		       || (TYPE_CODE (type) == TYPE_CODE_DECFLOAT
			   && tdep->soft_float)))
	    {
	      /* Soft-float IBM long double or _Decimal128 passed in
		 four consecutive registers, or on the stack.  The
		 registers are not necessarily odd/even pairs.  */
	      if (greg > 7)
		{
		  greg = 11;
		  argoffset = align_up (argoffset, 8);
		  if (write_pass)
		    write_memory (sp + argoffset, val, len);
		  argoffset += 16;
		}
	      else
		{
		  if (write_pass)
		    {
		      regcache_cooked_write (regcache,
					     tdep->ppc_gp0_regnum + greg + 0,
					     val + 0);
		      regcache_cooked_write (regcache,
					     tdep->ppc_gp0_regnum + greg + 1,
					     val + 4);
		      regcache_cooked_write (regcache,
					     tdep->ppc_gp0_regnum + greg + 2,
					     val + 8);
		      regcache_cooked_write (regcache,
					     tdep->ppc_gp0_regnum + greg + 3,
					     val + 12);
		    }
		  greg += 4;
		}
	    }
	  else if (TYPE_CODE (type) == TYPE_CODE_DECFLOAT && len <= 8
		   && !tdep->soft_float)
	    {
	      /* 32-bit and 64-bit decimal floats go in f1 .. f8.  They can
	         end up in memory.  */

	      if (freg <= 8)
		{
		  if (write_pass)
		    {
		      gdb_byte regval[MAX_REGISTER_SIZE];
		      const gdb_byte *p;

		      /* 32-bit decimal floats are right aligned in the
			 doubleword.  */
		      if (TYPE_LENGTH (type) == 4)
		      {
			memcpy (regval + 4, val, 4);
			p = regval;
		      }
		      else
			p = val;

		      regcache_cooked_write (regcache,
			  tdep->ppc_fp0_regnum + freg, p);
		    }

		  freg++;
		}
	      else
		{
		  argoffset = align_up (argoffset, len);

		  if (write_pass)
		    /* Write value in the stack's parameter save area.  */
		    write_memory (sp + argoffset, val, len);

		  argoffset += len;
		}
	    }
	  else if (TYPE_CODE (type) == TYPE_CODE_DECFLOAT && len == 16
		   && !tdep->soft_float)
	    {
	      /* 128-bit decimal floats go in f2 .. f7, always in even/odd
		 pairs.  They can end up in memory, using two doublewords.  */

	      if (freg <= 6)
		{
		  /* Make sure freg is even.  */
		  freg += freg & 1;

		  if (write_pass)
		    {
		      regcache_cooked_write (regcache,
					     tdep->ppc_fp0_regnum + freg, val);
		      regcache_cooked_write (regcache,
			  tdep->ppc_fp0_regnum + freg + 1, val + 8);
		    }
		}
	      else
		{
		  argoffset = align_up (argoffset, 8);

		  if (write_pass)
		    write_memory (sp + argoffset, val, 16);

		  argoffset += 16;
		}

	      /* If a 128-bit decimal float goes to the stack because only f7
	         and f8 are free (thus there's no even/odd register pair
		 available), these registers should be marked as occupied.
		 Hence we increase freg even when writing to memory.  */
	      freg += 2;
	    }
	  else if (len < 16
		   && TYPE_CODE (type) == TYPE_CODE_ARRAY
		   && TYPE_VECTOR (type)
		   && opencl_abi)
	    {
	      /* OpenCL vectors shorter than 16 bytes are passed as if
		 a series of independent scalars.  */
	      struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type));
	      int i, nelt = TYPE_LENGTH (type) / TYPE_LENGTH (eltype);

	      for (i = 0; i < nelt; i++)
		{
		  const gdb_byte *elval = val + i * TYPE_LENGTH (eltype);

		  if (TYPE_CODE (eltype) == TYPE_CODE_FLT && !tdep->soft_float)
		    {
		      if (freg <= 8)
			{
			  if (write_pass)
			    {
			      int regnum = tdep->ppc_fp0_regnum + freg;
			      gdb_byte regval[MAX_REGISTER_SIZE];
			      struct type *regtype
				= register_type (gdbarch, regnum);
			      convert_typed_floating (elval, eltype,
						      regval, regtype);
			      regcache_cooked_write (regcache, regnum, regval);
			    }
			  freg++;
			}
		      else
			{
			  argoffset = align_up (argoffset, len);
			  if (write_pass)
			    write_memory (sp + argoffset, val, len);
			  argoffset += len;
			}
		    }
		  else if (TYPE_LENGTH (eltype) == 8)
		    {
		      if (greg > 9)
			{
			  /* Just in case GREG was 10.  */
			  greg = 11;
			  argoffset = align_up (argoffset, 8);
			  if (write_pass)
			    write_memory (sp + argoffset, elval,
					  TYPE_LENGTH (eltype));
			  argoffset += 8;
			}
		      else
			{
			  /* Must start on an odd register - r3/r4 etc.  */
			  if ((greg & 1) == 0)
			    greg++;
			  if (write_pass)
			    {
			      int regnum = tdep->ppc_gp0_regnum + greg;
			      regcache_cooked_write (regcache,
						     regnum + 0, elval + 0);
			      regcache_cooked_write (regcache,
						     regnum + 1, elval + 4);
			    }
			  greg += 2;
			}
		    }
		  else
		    {
		      gdb_byte word[MAX_REGISTER_SIZE];
		      store_unsigned_integer (word, tdep->wordsize, byte_order,
					      unpack_long (eltype, elval));

		      if (greg <= 10)
			{
			  if (write_pass)
			    regcache_cooked_write (regcache,
						   tdep->ppc_gp0_regnum + greg,
						   word);
			  greg++;
			}
		      else
			{
			  argoffset = align_up (argoffset, tdep->wordsize);
			  if (write_pass)
			    write_memory (sp + argoffset, word, tdep->wordsize);
			  argoffset += tdep->wordsize;
			}
		    }
		}
	    }
	  else if (len >= 16
		   && TYPE_CODE (type) == TYPE_CODE_ARRAY
		   && TYPE_VECTOR (type)
		   && opencl_abi)
	    {
	      /* OpenCL vectors 16 bytes or longer are passed as if
		 a series of AltiVec vectors.  */
	      int i;

	      for (i = 0; i < len / 16; i++)
		{
		  const gdb_byte *elval = val + i * 16;

		  if (vreg <= 13)
		    {
		      if (write_pass)
			regcache_cooked_write (regcache,
					       tdep->ppc_vr0_regnum + vreg,
					       elval);
		      vreg++;
		    }
		  else
		    {
		      argoffset = align_up (argoffset, 16);
		      if (write_pass)
			write_memory (sp + argoffset, elval, 16);
		      argoffset += 16;
		    }
		}
	    }
	  else if (len == 16
		   && TYPE_CODE (type) == TYPE_CODE_ARRAY
		   && TYPE_VECTOR (type)
		   && tdep->vector_abi == POWERPC_VEC_ALTIVEC)
	    {
	      /* Vector parameter passed in an Altivec register, or
	         when that runs out, 16 byte aligned stack location.  */
	      if (vreg <= 13)
		{
		  if (write_pass)
		    regcache_cooked_write (regcache,
					   tdep->ppc_vr0_regnum + vreg, val);
		  vreg++;
		}
	      else
		{
		  argoffset = align_up (argoffset, 16);
		  if (write_pass)
		    write_memory (sp + argoffset, val, 16);
		  argoffset += 16;
		}
	    }
	  else if (len == 8
		   && TYPE_CODE (type) == TYPE_CODE_ARRAY
		   && TYPE_VECTOR (type)
		   && tdep->vector_abi == POWERPC_VEC_SPE)
	    {
	      /* Vector parameter passed in an e500 register, or when
	         that runs out, 8 byte aligned stack location.  Note
	         that since e500 vector and general purpose registers
	         both map onto the same underlying register set, a
	         "greg" and not a "vreg" is consumed here.  A cooked
	         write stores the value in the correct locations
	         within the raw register cache.  */
	      if (greg <= 10)
		{
		  if (write_pass)
		    regcache_cooked_write (regcache,
					   tdep->ppc_ev0_regnum + greg, val);
		  greg++;
		}
	      else
		{
		  argoffset = align_up (argoffset, 8);
		  if (write_pass)
		    write_memory (sp + argoffset, val, 8);
		  argoffset += 8;
		}
	    }
	  else
	    {
	      /* Reduce the parameter down to something that fits in a
	         "word".  */
	      gdb_byte word[MAX_REGISTER_SIZE];
	      memset (word, 0, MAX_REGISTER_SIZE);
	      if (len > tdep->wordsize
		  || TYPE_CODE (type) == TYPE_CODE_STRUCT
		  || TYPE_CODE (type) == TYPE_CODE_UNION)
		{
		  /* Structs and large values are put in an
		     aligned stack slot ...  */
		  if (TYPE_CODE (type) == TYPE_CODE_ARRAY
		      && TYPE_VECTOR (type)
		      && len >= 16)
		    structoffset = align_up (structoffset, 16);
		  else
		    structoffset = align_up (structoffset, 8);

		  if (write_pass)
		    write_memory (sp + structoffset, val, len);
		  /* ... and then a "word" pointing to that address is
		     passed as the parameter.  */
		  store_unsigned_integer (word, tdep->wordsize, byte_order,
					  sp + structoffset);
		  structoffset += len;
		}
	      else if (TYPE_CODE (type) == TYPE_CODE_INT)
		/* Sign or zero extend the "int" into a "word".  */
		store_unsigned_integer (word, tdep->wordsize, byte_order,
					unpack_long (type, val));
	      else
		/* Always goes in the low address.  */
		memcpy (word, val, len);
	      /* Store that "word" in a register, or on the stack.
	         The words have "4" byte alignment.  */
	      if (greg <= 10)
		{
		  if (write_pass)
		    regcache_cooked_write (regcache,
					   tdep->ppc_gp0_regnum + greg, word);
		  greg++;
		}
	      else
		{
		  argoffset = align_up (argoffset, tdep->wordsize);
		  if (write_pass)
		    write_memory (sp + argoffset, word, tdep->wordsize);
		  argoffset += tdep->wordsize;
		}
	    }
	}

      /* Compute the actual stack space requirements.  */
      if (!write_pass)
	{
	  /* Remember the amount of space needed by the arguments.  */
	  argspace = argoffset;
	  /* Allocate space for both the arguments and the structures.  */
	  sp -= (argoffset + structoffset);
	  /* Ensure that the stack is still 16 byte aligned.  */
	  sp = align_down (sp, 16);
	}

      /* The psABI says that "A caller of a function that takes a
	 variable argument list shall set condition register bit 6 to
	 1 if it passes one or more arguments in the floating-point
	 registers.  It is strongly recommended that the caller set the
	 bit to 0 otherwise..."  Doing this for normal functions too
	 shouldn't hurt.  */
      if (write_pass)
	{
	  ULONGEST cr;

	  regcache_cooked_read_unsigned (regcache, tdep->ppc_cr_regnum, &cr);
	  if (freg > 1)
	    cr |= 0x02000000;
	  else
	    cr &= ~0x02000000;
	  regcache_cooked_write_unsigned (regcache, tdep->ppc_cr_regnum, cr);
	}
    }

  /* Update %sp.   */
  regcache_cooked_write_signed (regcache, gdbarch_sp_regnum (gdbarch), sp);

  /* Write the backchain (it occupies WORDSIZED bytes).  */
  write_memory_signed_integer (sp, tdep->wordsize, byte_order, saved_sp);

  /* Point the inferior function call's return address at the dummy's
     breakpoint.  */
  regcache_cooked_write_signed (regcache, tdep->ppc_lr_regnum, bp_addr);

  return sp;
}

/* Handle the return-value conventions for Decimal Floating Point values
   in both ppc32 and ppc64, which are the same.  */
static int
get_decimal_float_return_value (struct gdbarch *gdbarch, struct type *valtype,
				struct regcache *regcache, gdb_byte *readbuf,
				const gdb_byte *writebuf)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  gdb_assert (TYPE_CODE (valtype) == TYPE_CODE_DECFLOAT);

  /* 32-bit and 64-bit decimal floats in f1.  */
  if (TYPE_LENGTH (valtype) <= 8)
    {
      if (writebuf != NULL)
	{
	  gdb_byte regval[MAX_REGISTER_SIZE];
	  const gdb_byte *p;

	  /* 32-bit decimal float is right aligned in the doubleword.  */
	  if (TYPE_LENGTH (valtype) == 4)
	    {
	      memcpy (regval + 4, writebuf, 4);
	      p = regval;
	    }
	  else
	    p = writebuf;

	  regcache_cooked_write (regcache, tdep->ppc_fp0_regnum + 1, p);
	}
      if (readbuf != NULL)
	{
	  regcache_cooked_read (regcache, tdep->ppc_fp0_regnum + 1, readbuf);

	  /* Left align 32-bit decimal float.  */
	  if (TYPE_LENGTH (valtype) == 4)
	    memcpy (readbuf, readbuf + 4, 4);
	}
    }
  /* 128-bit decimal floats in f2,f3.  */
  else if (TYPE_LENGTH (valtype) == 16)
    {
      if (writebuf != NULL || readbuf != NULL)
	{
	  int i;

	  for (i = 0; i < 2; i++)
	    {
	      if (writebuf != NULL)
		regcache_cooked_write (regcache, tdep->ppc_fp0_regnum + 2 + i,
				       writebuf + i * 8);
	      if (readbuf != NULL)
		regcache_cooked_read (regcache, tdep->ppc_fp0_regnum + 2 + i,
				      readbuf + i * 8);
	    }
	}
    }
  else
    /* Can't happen.  */
    internal_error (__FILE__, __LINE__, _("Unknown decimal float size."));

  return RETURN_VALUE_REGISTER_CONVENTION;
}

/* Handle the return-value conventions specified by the SysV 32-bit
   PowerPC ABI (including all the supplements):

   no floating-point: floating-point values returned using 32-bit
   general-purpose registers.

   Altivec: 128-bit vectors returned using vector registers.

   e500: 64-bit vectors returned using the full full 64 bit EV
   register, floating-point values returned using 32-bit
   general-purpose registers.

   GCC (broken): Small struct values right (instead of left) aligned
   when returned in general-purpose registers.  */

static enum return_value_convention
do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,
			  struct type *type, struct regcache *regcache,
			  gdb_byte *readbuf, const gdb_byte *writebuf,
			  int broken_gcc)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int opencl_abi = func_type? ppc_sysv_use_opencl_abi (func_type) : 0;

  gdb_assert (tdep->wordsize == 4);

  if (TYPE_CODE (type) == TYPE_CODE_FLT
      && TYPE_LENGTH (type) <= 8
      && !tdep->soft_float)
    {
      if (readbuf)
	{
	  /* Floats and doubles stored in "f1".  Convert the value to
	     the required type.  */
	  gdb_byte regval[MAX_REGISTER_SIZE];
	  struct type *regtype = register_type (gdbarch,
                                                tdep->ppc_fp0_regnum + 1);
	  regcache_cooked_read (regcache, tdep->ppc_fp0_regnum + 1, regval);
	  convert_typed_floating (regval, regtype, readbuf, type);
	}
      if (writebuf)
	{
	  /* Floats and doubles stored in "f1".  Convert the value to
	     the register's "double" type.  */
	  gdb_byte regval[MAX_REGISTER_SIZE];
	  struct type *regtype = register_type (gdbarch, tdep->ppc_fp0_regnum);
	  convert_typed_floating (writebuf, type, regval, regtype);
	  regcache_cooked_write (regcache, tdep->ppc_fp0_regnum + 1, regval);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_CODE (type) == TYPE_CODE_FLT
      && TYPE_LENGTH (type) == 16
      && !tdep->soft_float
      && (gdbarch_long_double_format (gdbarch)
	  == floatformats_ibm_long_double))
    {
      /* IBM long double stored in f1 and f2.  */
      if (readbuf)
	{
	  regcache_cooked_read (regcache, tdep->ppc_fp0_regnum + 1, readbuf);
	  regcache_cooked_read (regcache, tdep->ppc_fp0_regnum + 2,
				readbuf + 8);
	}
      if (writebuf)
	{
	  regcache_cooked_write (regcache, tdep->ppc_fp0_regnum + 1, writebuf);
	  regcache_cooked_write (regcache, tdep->ppc_fp0_regnum + 2,
				 writebuf + 8);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_LENGTH (type) == 16
      && ((TYPE_CODE (type) == TYPE_CODE_FLT
	   && (gdbarch_long_double_format (gdbarch)
	       == floatformats_ibm_long_double))
	  || (TYPE_CODE (type) == TYPE_CODE_DECFLOAT && tdep->soft_float)))
    {
      /* Soft-float IBM long double or _Decimal128 stored in r3, r4,
	 r5, r6.  */
      if (readbuf)
	{
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 3, readbuf);
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 4,
				readbuf + 4);
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 5,
				readbuf + 8);
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 6,
				readbuf + 12);
	}
      if (writebuf)
	{
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 3, writebuf);
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 4,
				 writebuf + 4);
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 5,
				 writebuf + 8);
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 6,
				 writebuf + 12);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if ((TYPE_CODE (type) == TYPE_CODE_INT && TYPE_LENGTH (type) == 8)
      || (TYPE_CODE (type) == TYPE_CODE_FLT && TYPE_LENGTH (type) == 8)
      || (TYPE_CODE (type) == TYPE_CODE_DECFLOAT && TYPE_LENGTH (type) == 8
	  && tdep->soft_float))
    {
      if (readbuf)
	{
	  /* A long long, double or _Decimal64 stored in the 32 bit
	     r3/r4.  */
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 3,
				readbuf + 0);
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 4,
				readbuf + 4);
	}
      if (writebuf)
	{
	  /* A long long, double or _Decimal64 stored in the 32 bit
	     r3/r4.  */
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 3,
				 writebuf + 0);
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 4,
				 writebuf + 4);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_CODE (type) == TYPE_CODE_DECFLOAT && !tdep->soft_float)
    return get_decimal_float_return_value (gdbarch, type, regcache, readbuf,
					   writebuf);
  else if ((TYPE_CODE (type) == TYPE_CODE_INT
	    || TYPE_CODE (type) == TYPE_CODE_CHAR
	    || TYPE_CODE (type) == TYPE_CODE_BOOL
	    || TYPE_CODE (type) == TYPE_CODE_PTR
	    || TYPE_CODE (type) == TYPE_CODE_REF
	    || TYPE_CODE (type) == TYPE_CODE_ENUM)
	   && TYPE_LENGTH (type) <= tdep->wordsize)
    {
      if (readbuf)
	{
	  /* Some sort of integer stored in r3.  Since TYPE isn't
	     bigger than the register, sign extension isn't a problem
	     - just do everything unsigned.  */
	  ULONGEST regval;
	  regcache_cooked_read_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
					 &regval);
	  store_unsigned_integer (readbuf, TYPE_LENGTH (type), byte_order,
				  regval);
	}
      if (writebuf)
	{
	  /* Some sort of integer stored in r3.  Use unpack_long since
	     that should handle any required sign extension.  */
	  regcache_cooked_write_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
					  unpack_long (type, writebuf));
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  /* OpenCL vectors < 16 bytes are returned as distinct
     scalars in f1..f2 or r3..r10.  */
  if (TYPE_CODE (type) == TYPE_CODE_ARRAY
      && TYPE_VECTOR (type)
      && TYPE_LENGTH (type) < 16
      && opencl_abi)
    {
      struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type));
      int i, nelt = TYPE_LENGTH (type) / TYPE_LENGTH (eltype);

      for (i = 0; i < nelt; i++)
	{
	  int offset = i * TYPE_LENGTH (eltype);

	  if (TYPE_CODE (eltype) == TYPE_CODE_FLT)
	    {
	      int regnum = tdep->ppc_fp0_regnum + 1 + i;
	      gdb_byte regval[MAX_REGISTER_SIZE];
	      struct type *regtype = register_type (gdbarch, regnum);

	      if (writebuf != NULL)
		{
		  convert_typed_floating (writebuf + offset, eltype,
					  regval, regtype);
		  regcache_cooked_write (regcache, regnum, regval);
		}
	      if (readbuf != NULL)
		{
		  regcache_cooked_read (regcache, regnum, regval);
		  convert_typed_floating (regval, regtype,
					  readbuf + offset, eltype);
		}
	    }
	  else
	    {
	      int regnum = tdep->ppc_gp0_regnum + 3 + i;
	      ULONGEST regval;

	      if (writebuf != NULL)
		{
		  regval = unpack_long (eltype, writebuf + offset);
		  regcache_cooked_write_unsigned (regcache, regnum, regval);
		}
	      if (readbuf != NULL)
		{
		  regcache_cooked_read_unsigned (regcache, regnum, &regval);
		  store_unsigned_integer (readbuf + offset,
					  TYPE_LENGTH (eltype), byte_order,
					  regval);
		}
	    }
	}

      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  /* OpenCL vectors >= 16 bytes are returned in v2..v9.  */
  if (TYPE_CODE (type) == TYPE_CODE_ARRAY
      && TYPE_VECTOR (type)
      && TYPE_LENGTH (type) >= 16
      && opencl_abi)
    {
      int n_regs = TYPE_LENGTH (type) / 16;
      int i;

      for (i = 0; i < n_regs; i++)
	{
	  int offset = i * 16;
	  int regnum = tdep->ppc_vr0_regnum + 2 + i;

	  if (writebuf != NULL)
	    regcache_cooked_write (regcache, regnum, writebuf + offset);
	  if (readbuf != NULL)
	    regcache_cooked_read (regcache, regnum, readbuf + offset);
	}

      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_LENGTH (type) == 16
      && TYPE_CODE (type) == TYPE_CODE_ARRAY
      && TYPE_VECTOR (type)
      && tdep->vector_abi == POWERPC_VEC_ALTIVEC)
    {
      if (readbuf)
	{
	  /* Altivec places the return value in "v2".  */
	  regcache_cooked_read (regcache, tdep->ppc_vr0_regnum + 2, readbuf);
	}
      if (writebuf)
	{
	  /* Altivec places the return value in "v2".  */
	  regcache_cooked_write (regcache, tdep->ppc_vr0_regnum + 2, writebuf);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_LENGTH (type) == 16
      && TYPE_CODE (type) == TYPE_CODE_ARRAY
      && TYPE_VECTOR (type)
      && tdep->vector_abi == POWERPC_VEC_GENERIC)
    {
      /* GCC -maltivec -mabi=no-altivec returns vectors in r3/r4/r5/r6.
	 GCC without AltiVec returns them in memory, but it warns about
	 ABI risks in that case; we don't try to support it.  */
      if (readbuf)
	{
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 3,
				readbuf + 0);
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 4,
				readbuf + 4);
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 5,
				readbuf + 8);
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 6,
				readbuf + 12);
	}
      if (writebuf)
	{
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 3,
				 writebuf + 0);
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 4,
				 writebuf + 4);
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 5,
				 writebuf + 8);
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 6,
				 writebuf + 12);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_LENGTH (type) == 8
      && TYPE_CODE (type) == TYPE_CODE_ARRAY
      && TYPE_VECTOR (type)
      && tdep->vector_abi == POWERPC_VEC_SPE)
    {
      /* The e500 ABI places return values for the 64-bit DSP types
	 (__ev64_opaque__) in r3.  However, in GDB-speak, ev3
	 corresponds to the entire r3 value for e500, whereas GDB's r3
	 only corresponds to the least significant 32-bits.  So place
	 the 64-bit DSP type's value in ev3.  */
      if (readbuf)
	regcache_cooked_read (regcache, tdep->ppc_ev0_regnum + 3, readbuf);
      if (writebuf)
	regcache_cooked_write (regcache, tdep->ppc_ev0_regnum + 3, writebuf);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (broken_gcc && TYPE_LENGTH (type) <= 8)
    {
      /* GCC screwed up for structures or unions whose size is less
	 than or equal to 8 bytes..  Instead of left-aligning, it
	 right-aligns the data into the buffer formed by r3, r4.  */
      gdb_byte regvals[MAX_REGISTER_SIZE * 2];
      int len = TYPE_LENGTH (type);
      int offset = (2 * tdep->wordsize - len) % tdep->wordsize;

      if (readbuf)
	{
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 3,
				regvals + 0 * tdep->wordsize);
	  if (len > tdep->wordsize)
	    regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 4,
				  regvals + 1 * tdep->wordsize);
	  memcpy (readbuf, regvals + offset, len);
	}
      if (writebuf)
	{
	  memset (regvals, 0, sizeof regvals);
	  memcpy (regvals + offset, writebuf, len);
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 3,
				 regvals + 0 * tdep->wordsize);
	  if (len > tdep->wordsize)
	    regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 4,
				   regvals + 1 * tdep->wordsize);
	}

      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_LENGTH (type) <= 8)
    {
      if (readbuf)
	{
	  /* This matches SVr4 PPC, it does not match GCC.  */
	  /* The value is right-padded to 8 bytes and then loaded, as
	     two "words", into r3/r4.  */
	  gdb_byte regvals[MAX_REGISTER_SIZE * 2];
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 3,
				regvals + 0 * tdep->wordsize);
	  if (TYPE_LENGTH (type) > tdep->wordsize)
	    regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 4,
				  regvals + 1 * tdep->wordsize);
	  memcpy (readbuf, regvals, TYPE_LENGTH (type));
	}
      if (writebuf)
	{
	  /* This matches SVr4 PPC, it does not match GCC.  */
	  /* The value is padded out to 8 bytes and then loaded, as
	     two "words" into r3/r4.  */
	  gdb_byte regvals[MAX_REGISTER_SIZE * 2];
	  memset (regvals, 0, sizeof regvals);
	  memcpy (regvals, writebuf, TYPE_LENGTH (type));
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 3,
				 regvals + 0 * tdep->wordsize);
	  if (TYPE_LENGTH (type) > tdep->wordsize)
	    regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 4,
				   regvals + 1 * tdep->wordsize);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  return RETURN_VALUE_STRUCT_CONVENTION;
}

enum return_value_convention
ppc_sysv_abi_return_value (struct gdbarch *gdbarch, struct value *function,
			   struct type *valtype, struct regcache *regcache,
			   gdb_byte *readbuf, const gdb_byte *writebuf)
{
  return do_ppc_sysv_return_value (gdbarch,
				   function ? value_type (function) : NULL,
				   valtype, regcache, readbuf, writebuf, 0);
}

enum return_value_convention
ppc_sysv_abi_broken_return_value (struct gdbarch *gdbarch,
				  struct value *function,
				  struct type *valtype,
				  struct regcache *regcache,
				  gdb_byte *readbuf, const gdb_byte *writebuf)
{
  return do_ppc_sysv_return_value (gdbarch,
				   function ? value_type (function) : NULL,
				   valtype, regcache, readbuf, writebuf, 1);
}

/* The helper function for 64-bit SYSV push_dummy_call.  Converts the
   function's code address back into the function's descriptor
   address.

   Find a value for the TOC register.  Every symbol should have both
   ".FN" and "FN" in the minimal symbol table.  "FN" points at the
   FN's descriptor, while ".FN" points at the entry point (which
   matches FUNC_ADDR).  Need to reverse from FUNC_ADDR back to the
   FN's descriptor address (while at the same time being careful to
   find "FN" in the same object file as ".FN").  */

static int
convert_code_addr_to_desc_addr (CORE_ADDR code_addr, CORE_ADDR *desc_addr)
{
  struct obj_section *dot_fn_section;
  struct bound_minimal_symbol dot_fn;
  struct minimal_symbol *fn;

  /* Find the minimal symbol that corresponds to CODE_ADDR (should
     have a name of the form ".FN").  */
  dot_fn = lookup_minimal_symbol_by_pc (code_addr);
  if (dot_fn.minsym == NULL || SYMBOL_LINKAGE_NAME (dot_fn.minsym)[0] != '.')
    return 0;
  /* Get the section that contains CODE_ADDR.  Need this for the
     "objfile" that it contains.  */
  dot_fn_section = find_pc_section (code_addr);
  if (dot_fn_section == NULL || dot_fn_section->objfile == NULL)
    return 0;
  /* Now find the corresponding "FN" (dropping ".") minimal symbol's
     address.  Only look for the minimal symbol in ".FN"'s object file
     - avoids problems when two object files (i.e., shared libraries)
     contain a minimal symbol with the same name.  */
  fn = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (dot_fn.minsym) + 1, NULL,
			      dot_fn_section->objfile);
  if (fn == NULL)
    return 0;
  /* Found a descriptor.  */
  (*desc_addr) = SYMBOL_VALUE_ADDRESS (fn);
  return 1;
}

/* Push a float in either registers, or in the stack.  Using the ppc 64 bit
   SysV ABI.

   This implements a dumbed down version of the ABI.  It always writes
   values to memory, GPR and FPR, even when not necessary.  Doing this
   greatly simplifies the logic.  */

static void
ppc64_sysv_abi_push_float (struct gdbarch *gdbarch, struct regcache *regcache,
			   struct gdbarch_tdep *tdep, struct type *type, 
			   const bfd_byte *val, int freg, int greg,
			   CORE_ADDR gparam)
{
  gdb_byte regval[MAX_REGISTER_SIZE];
  const gdb_byte *p;

  if (TYPE_LENGTH (type) <= 8)
    {
      /* Version 1.7 of the 64-bit PowerPC ELF ABI says:

	 "Single precision floating point values are mapped to
	 the first word in a single doubleword."

	 And version 1.9 says:

	 "Single precision floating point values are mapped to
	 the second word in a single doubleword."

	 GDB then writes single precision floating point values
	 at both words in a doubleword, to support both ABIs.  */
      if (TYPE_LENGTH (type) == 4)
	{
	  memcpy (regval, val, 4);
	  memcpy (regval + 4, val, 4);
	  p = regval;
	}
      else
	p = val;

      /* Write value in the stack's parameter save area.  */
      write_memory (gparam, p, 8);

      /* Floats and Doubles go in f1 .. f13.  They also consume a left aligned
	 GREG, and can end up in memory.  */
      if (freg <= 13)
	{
	  struct type *regtype;

	  regtype = register_type (gdbarch, tdep->ppc_fp0_regnum + freg);
	  convert_typed_floating (val, type, regval, regtype);
	  regcache_cooked_write (regcache, tdep->ppc_fp0_regnum + freg, regval);
	}
      if (greg <= 10)
	regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + greg, regval);
    }
  else
    {
      /* IBM long double stored in two doublewords of the
	 parameter save area and corresponding registers.  */
      if (!tdep->soft_float && freg <= 13)
	{
	  regcache_cooked_write (regcache, tdep->ppc_fp0_regnum + freg, val);
	  if (freg <= 12)
	    regcache_cooked_write (regcache, tdep->ppc_fp0_regnum + freg + 1,
				   val + 8);
	}
      if (greg <= 10)
	{
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + greg, val);
	  if (greg <= 9)
	    regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + greg + 1,
				   val + 8);
	}
      write_memory (gparam, val, TYPE_LENGTH (type));
    }
}

/* Pass the arguments in either registers, or in the stack.  Using the
   ppc 64 bit SysV ABI.

   This implements a dumbed down version of the ABI.  It always writes
   values to memory, GPR and FPR, even when not necessary.  Doing this
   greatly simplifies the logic.  */

CORE_ADDR
ppc64_sysv_abi_push_dummy_call (struct gdbarch *gdbarch,
				struct value *function,
				struct regcache *regcache, CORE_ADDR bp_addr,
				int nargs, struct value **args, CORE_ADDR sp,
				int struct_return, CORE_ADDR struct_addr)
{
  CORE_ADDR func_addr = find_function_addr (function, NULL);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int opencl_abi = ppc_sysv_use_opencl_abi (value_type (function));
  ULONGEST back_chain;
  /* See for-loop comment below.  */
  int write_pass;
  /* Size of the by-reference parameter copy region, the final value is
     computed in the for-loop below.  */
  LONGEST refparam_size = 0;
  /* Size of the general parameter region, the final value is computed
     in the for-loop below.  */
  LONGEST gparam_size = 0;
  /* Kevin writes ... I don't mind seeing tdep->wordsize used in the
     calls to align_up(), align_down(), etc. because this makes it
     easier to reuse this code (in a copy/paste sense) in the future,
     but it is a 64-bit ABI and asserting that the wordsize is 8 bytes
     at some point makes it easier to verify that this function is
     correct without having to do a non-local analysis to figure out
     the possible values of tdep->wordsize.  */
  gdb_assert (tdep->wordsize == 8);

  /* This function exists to support a calling convention that
     requires floating-point registers.  It shouldn't be used on
     processors that lack them.  */
  gdb_assert (ppc_floating_point_unit_p (gdbarch));

  /* By this stage in the proceedings, SP has been decremented by "red
     zone size" + "struct return size".  Fetch the stack-pointer from
     before this and use that as the BACK_CHAIN.  */
  regcache_cooked_read_unsigned (regcache, gdbarch_sp_regnum (gdbarch),
				 &back_chain);

  /* Go through the argument list twice.

     Pass 1: Compute the function call's stack space and register
     requirements.

     Pass 2: Replay the same computation but this time also write the
     values out to the target.  */

  for (write_pass = 0; write_pass < 2; write_pass++)
    {
      int argno;
      /* Next available floating point register for float and double
         arguments.  */
      int freg = 1;
      /* Next available general register for non-vector (but possibly
         float) arguments.  */
      int greg = 3;
      /* Next available vector register for vector arguments.  */
      int vreg = 2;
      /* The address, at which the next general purpose parameter
         (integer, struct, float, vector, ...) should be saved.  */
      CORE_ADDR gparam;
      /* The address, at which the next by-reference parameter
	 (non-Altivec vector, variably-sized type) should be saved.  */
      CORE_ADDR refparam;

      if (!write_pass)
	{
	  /* During the first pass, GPARAM and REFPARAM are more like
	     offsets (start address zero) than addresses.  That way
	     they accumulate the total stack space each region
	     requires.  */
	  gparam = 0;
	  refparam = 0;
	}
      else
	{
	  /* Decrement the stack pointer making space for the Altivec
	     and general on-stack parameters.  Set refparam and gparam
	     to their corresponding regions.  */
	  refparam = align_down (sp - refparam_size, 16);
	  gparam = align_down (refparam - gparam_size, 16);
	  /* Add in space for the TOC, link editor double word,
	     compiler double word, LR save area, CR save area.  */
	  sp = align_down (gparam - 48, 16);
	}

      /* If the function is returning a `struct', then there is an
         extra hidden parameter (which will be passed in r3)
         containing the address of that struct..  In that case we
         should advance one word and start from r4 register to copy
         parameters.  This also consumes one on-stack parameter slot.  */
      if (struct_return)
	{
	  if (write_pass)
	    regcache_cooked_write_signed (regcache,
					  tdep->ppc_gp0_regnum + greg,
					  struct_addr);
	  greg++;
	  gparam = align_up (gparam + tdep->wordsize, tdep->wordsize);
	}

      for (argno = 0; argno < nargs; argno++)
	{
	  struct value *arg = args[argno];
	  struct type *type = check_typedef (value_type (arg));
	  const bfd_byte *val = value_contents (arg);

	  if (TYPE_CODE (type) == TYPE_CODE_FLT && TYPE_LENGTH (type) <= 8)
	    {
	      if (write_pass)
		  ppc64_sysv_abi_push_float (gdbarch, regcache, tdep, type,
					     val, freg, greg, gparam);

	      freg++;
	      greg++;
	      /* Always consume parameter stack space.  */
	      gparam = align_up (gparam + 8, tdep->wordsize);
	    }
	  else if (TYPE_CODE (type) == TYPE_CODE_FLT
		   && TYPE_LENGTH (type) == 16
		   && (gdbarch_long_double_format (gdbarch)
		       == floatformats_ibm_long_double))
	    {
	      if (write_pass)
		ppc64_sysv_abi_push_float (gdbarch, regcache, tdep, type,
					   val, freg, greg, gparam);
	      freg += 2;
	      greg += 2;
	      gparam = align_up (gparam + TYPE_LENGTH (type), tdep->wordsize);
	    }
	  else if (TYPE_CODE (type) == TYPE_CODE_COMPLEX
	      && (TYPE_LENGTH (type) == 8 || TYPE_LENGTH (type) == 16))
	    {
	      int i;

	      for (i = 0; i < 2; i++)
		{
		  if (write_pass)
		    {
		      struct type *target_type;

		      target_type = check_typedef (TYPE_TARGET_TYPE (type));
		      ppc64_sysv_abi_push_float (gdbarch, regcache, tdep,
						 target_type, val + i *
						 TYPE_LENGTH (target_type),
						 freg, greg, gparam);
		    }
		  freg++;
		  greg++;
		  /* Always consume parameter stack space.  */
		  gparam = align_up (gparam + 8, tdep->wordsize);
		}
	    }
	  else if (TYPE_CODE (type) == TYPE_CODE_COMPLEX
		   && TYPE_LENGTH (type) == 32
		   && (gdbarch_long_double_format (gdbarch)
		       == floatformats_ibm_long_double))
	    {
	      int i;

	      for (i = 0; i < 2; i++)
		{
		  struct type *target_type;

		  target_type = check_typedef (TYPE_TARGET_TYPE (type));
		  if (write_pass)
		    ppc64_sysv_abi_push_float (gdbarch, regcache, tdep,
					       target_type, val + i *
					       TYPE_LENGTH (target_type),
					       freg, greg, gparam);
		  freg += 2;
		  greg += 2;
		  gparam = align_up (gparam + TYPE_LENGTH (target_type),
				     tdep->wordsize);
		}
	    }
	  else if (TYPE_CODE (type) == TYPE_CODE_DECFLOAT
		   && TYPE_LENGTH (type) <= 8)
	    {
	      /* 32-bit and 64-bit decimal floats go in f1 .. f13.  They can
	         end up in memory.  */
	      if (write_pass)
		{
		  gdb_byte regval[MAX_REGISTER_SIZE];
		  const gdb_byte *p;

		  /* 32-bit decimal floats are right aligned in the
		     doubleword.  */
		  if (TYPE_LENGTH (type) == 4)
		    {
		      memcpy (regval + 4, val, 4);
		      p = regval;
		    }
		  else
		    p = val;

		  /* Write value in the stack's parameter save area.  */
		  write_memory (gparam, p, 8);

		  if (freg <= 13)
		    regcache_cooked_write (regcache,
					   tdep->ppc_fp0_regnum + freg, p);
		}

	      freg++;
	      greg++;
	      /* Always consume parameter stack space.  */
	      gparam = align_up (gparam + 8, tdep->wordsize);
	    }
	  else if (TYPE_CODE (type) == TYPE_CODE_DECFLOAT &&
		   TYPE_LENGTH (type) == 16)
	    {
	      /* 128-bit decimal floats go in f2 .. f12, always in even/odd
	         pairs.  They can end up in memory, using two doublewords.  */
	      if (write_pass)
		{
		  if (freg <= 12)
		    {
		      /* Make sure freg is even.  */
		      freg += freg & 1;
		      regcache_cooked_write (regcache,
                                             tdep->ppc_fp0_regnum + freg, val);
		      regcache_cooked_write (regcache,
			  tdep->ppc_fp0_regnum + freg + 1, val + 8);
		    }

		  write_memory (gparam, val, TYPE_LENGTH (type));
		}

	      freg += 2;
	      greg += 2;
	      gparam = align_up (gparam + TYPE_LENGTH (type), tdep->wordsize);
	    }
	  else if (TYPE_LENGTH (type) < 16
		   && TYPE_CODE (type) == TYPE_CODE_ARRAY
		   && TYPE_VECTOR (type)
		   && opencl_abi)
	    {
	      /* OpenCL vectors shorter than 16 bytes are passed as if
		 a series of independent scalars.  */
	      struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type));
	      int i, nelt = TYPE_LENGTH (type) / TYPE_LENGTH (eltype);

	      for (i = 0; i < nelt; i++)
		{
		  const gdb_byte *elval = val + i * TYPE_LENGTH (eltype);

		  if (TYPE_CODE (eltype) == TYPE_CODE_FLT)
		    {
		      if (write_pass)
			{
			  gdb_byte regval[MAX_REGISTER_SIZE];
			  const gdb_byte *p;

			  if (TYPE_LENGTH (eltype) == 4)
			    {
			      memcpy (regval, elval, 4);
			      memcpy (regval + 4, elval, 4);
			      p = regval;
			    }
			  else
			    p = elval;

			  write_memory (gparam, p, 8);

			  if (freg <= 13)
			    {
			      int regnum = tdep->ppc_fp0_regnum + freg;
			      struct type *regtype
				= register_type (gdbarch, regnum);

			      convert_typed_floating (elval, eltype,
						      regval, regtype);
			      regcache_cooked_write (regcache, regnum, regval);
			    }

			  if (greg <= 10)
			    regcache_cooked_write (regcache,
						   tdep->ppc_gp0_regnum + greg,
						   regval);
			}

		      freg++;
		      greg++;
		      gparam = align_up (gparam + 8, tdep->wordsize);
		    }
		  else
		    {
		      if (write_pass)
			{
			  ULONGEST word = unpack_long (eltype, elval);
			  if (greg <= 10)
			    regcache_cooked_write_unsigned
			      (regcache, tdep->ppc_gp0_regnum + greg, word);

			  write_memory_unsigned_integer
			    (gparam, tdep->wordsize, byte_order, word);
			}

		      greg++;
		      gparam = align_up (gparam + TYPE_LENGTH (eltype),
					 tdep->wordsize);
		    }
		}
	    }
	  else if (TYPE_LENGTH (type) >= 16
		   && TYPE_CODE (type) == TYPE_CODE_ARRAY
		   && TYPE_VECTOR (type)
		   && opencl_abi)
	    {
	      /* OpenCL vectors 16 bytes or longer are passed as if
		 a series of AltiVec vectors.  */
	      int i;

	      for (i = 0; i < TYPE_LENGTH (type) / 16; i++)
		{
		  const gdb_byte *elval = val + i * 16;

		  gparam = align_up (gparam, 16);
		  greg += greg & 1;

		  if (write_pass)
		    {
		      if (vreg <= 13)
			regcache_cooked_write (regcache,
					       tdep->ppc_vr0_regnum + vreg,
					       elval);

		      write_memory (gparam, elval, 16);
		    }

		  greg += 2;
		  vreg++;
		  gparam += 16;
		}
	    }
	  else if (TYPE_LENGTH (type) == 16 && TYPE_VECTOR (type)
		   && TYPE_CODE (type) == TYPE_CODE_ARRAY
		   && tdep->vector_abi == POWERPC_VEC_ALTIVEC)
	    {
	      /* In the Altivec ABI, vectors go in the vector registers
		 v2 .. v13, as well as the parameter area -- always at
		 16-byte aligned addresses.  */

	      gparam = align_up (gparam, 16);
	      greg += greg & 1;

	      if (write_pass)
		{
		  if (vreg <= 13)
		    regcache_cooked_write (regcache,
					   tdep->ppc_vr0_regnum + vreg, val);

		  write_memory (gparam, val, TYPE_LENGTH (type));
		}

	      greg += 2;
	      vreg++;
	      gparam += 16;
	    }
	  else if (TYPE_LENGTH (type) >= 16 && TYPE_VECTOR (type)
		   && TYPE_CODE (type) == TYPE_CODE_ARRAY)
	    {
	      /* Non-Altivec vectors are passed by reference.  */

	      /* Copy value onto the stack ...  */
	      refparam = align_up (refparam, 16);
	      if (write_pass)
		write_memory (refparam, val, TYPE_LENGTH (type));

	      /* ... and pass a pointer to the copy as parameter.  */
	      if (write_pass)
		{
		  if (greg <= 10)
		    regcache_cooked_write_unsigned (regcache,
						    tdep->ppc_gp0_regnum +
						    greg, refparam);
		  write_memory_unsigned_integer (gparam, tdep->wordsize,
						 byte_order, refparam);
		}
	      greg++;
	      gparam = align_up (gparam + tdep->wordsize, tdep->wordsize);
	      refparam = align_up (refparam + TYPE_LENGTH (type), tdep->wordsize);
	    }
	  else if ((TYPE_CODE (type) == TYPE_CODE_INT
		    || TYPE_CODE (type) == TYPE_CODE_ENUM
		    || TYPE_CODE (type) == TYPE_CODE_BOOL
		    || TYPE_CODE (type) == TYPE_CODE_CHAR
		    || TYPE_CODE (type) == TYPE_CODE_PTR
		    || TYPE_CODE (type) == TYPE_CODE_REF)
		   && TYPE_LENGTH (type) <= 8)
	    {
	      /* Scalars and Pointers get sign[un]extended and go in
	         gpr3 .. gpr10.  They can also end up in memory.  */
	      if (write_pass)
		{
		  /* Sign extend the value, then store it unsigned.  */
		  ULONGEST word = unpack_long (type, val);
		  /* Convert any function code addresses into
		     descriptors.  */
		  if (TYPE_CODE (type) == TYPE_CODE_PTR
		      || TYPE_CODE (type) == TYPE_CODE_REF)
		    {
		      struct type *target_type;
		      target_type = check_typedef (TYPE_TARGET_TYPE (type));

		      if (TYPE_CODE (target_type) == TYPE_CODE_FUNC
			  || TYPE_CODE (target_type) == TYPE_CODE_METHOD)
			{
			  CORE_ADDR desc = word;
			  convert_code_addr_to_desc_addr (word, &desc);
			  word = desc;
			}
		    }
		  if (greg <= 10)
		    regcache_cooked_write_unsigned (regcache,
						    tdep->ppc_gp0_regnum +
						    greg, word);
		  write_memory_unsigned_integer (gparam, tdep->wordsize,
						 byte_order, word);
		}
	      greg++;
	      gparam = align_up (gparam + TYPE_LENGTH (type), tdep->wordsize);
	    }
	  else
	    {
	      int byte;
	      for (byte = 0; byte < TYPE_LENGTH (type);
		   byte += tdep->wordsize)
		{
		  if (write_pass && greg <= 10)
		    {
		      gdb_byte regval[MAX_REGISTER_SIZE];
		      int len = TYPE_LENGTH (type) - byte;
		      if (len > tdep->wordsize)
			len = tdep->wordsize;
		      memset (regval, 0, sizeof regval);
		      /* The ABI (version 1.9) specifies that values
			 smaller than one doubleword are right-aligned
			 and those larger are left-aligned.  GCC
			 versions before 3.4 implemented this
			 incorrectly; see
			 <http://gcc.gnu.org/gcc-3.4/powerpc-abi.html>.  */
		      if (byte == 0)
			memcpy (regval + tdep->wordsize - len,
				val + byte, len);
		      else
			memcpy (regval, val + byte, len);
		      regcache_cooked_write (regcache, greg, regval);
		    }
		  greg++;
		}
	      if (write_pass)
		{
		  /* WARNING: cagney/2003-09-21: Strictly speaking, this
		     isn't necessary, unfortunately, GCC appears to get
		     "struct convention" parameter passing wrong putting
		     odd sized structures in memory instead of in a
		     register.  Work around this by always writing the
		     value to memory.  Fortunately, doing this
		     simplifies the code.  */
		  int len = TYPE_LENGTH (type);
		  if (len < tdep->wordsize)
		    write_memory (gparam + tdep->wordsize - len, val, len);
		  else
		    write_memory (gparam, val, len);
		}
	      if (freg <= 13
		  && TYPE_CODE (type) == TYPE_CODE_STRUCT
		  && TYPE_NFIELDS (type) == 1
		  && TYPE_LENGTH (type) <= 16)
		{
		  /* The ABI (version 1.9) specifies that structs
		     containing a single floating-point value, at any
		     level of nesting of single-member structs, are
		     passed in floating-point registers.  */
		  while (TYPE_CODE (type) == TYPE_CODE_STRUCT
			 && TYPE_NFIELDS (type) == 1)
		    type = check_typedef (TYPE_FIELD_TYPE (type, 0));
		  if (TYPE_CODE (type) == TYPE_CODE_FLT)
		    {
		      if (TYPE_LENGTH (type) <= 8)
			{
			  if (write_pass)
			    {
			      gdb_byte regval[MAX_REGISTER_SIZE];
			      struct type *regtype
				= register_type (gdbarch,
						 tdep->ppc_fp0_regnum);
			      convert_typed_floating (val, type, regval,
						      regtype);
			      regcache_cooked_write (regcache,
						     (tdep->ppc_fp0_regnum
						      + freg),
						     regval);
			    }
			  freg++;
			}
		      else if (TYPE_LENGTH (type) == 16
			       && (gdbarch_long_double_format (gdbarch)
				   == floatformats_ibm_long_double))
			{
			  if (write_pass)
			    {
			      regcache_cooked_write (regcache,
						     (tdep->ppc_fp0_regnum
						      + freg),
						     val);
			      if (freg <= 12)
				regcache_cooked_write (regcache,
						       (tdep->ppc_fp0_regnum
							+ freg + 1),
						       val + 8);
			    }
			  freg += 2;
			}
		    }
		}
	      /* Always consume parameter stack space.  */
	      gparam = align_up (gparam + TYPE_LENGTH (type), tdep->wordsize);
	    }
	}

      if (!write_pass)
	{
	  /* Save the true region sizes ready for the second pass.  */
	  refparam_size = refparam;
	  /* Make certain that the general parameter save area is at
	     least the minimum 8 registers (or doublewords) in size.  */
	  if (greg < 8)
	    gparam_size = 8 * tdep->wordsize;
	  else
	    gparam_size = gparam;
	}
    }

  /* Update %sp.   */
  regcache_cooked_write_signed (regcache, gdbarch_sp_regnum (gdbarch), sp);

  /* Write the backchain (it occupies WORDSIZED bytes).  */
  write_memory_signed_integer (sp, tdep->wordsize, byte_order, back_chain);

  /* Point the inferior function call's return address at the dummy's
     breakpoint.  */
  regcache_cooked_write_signed (regcache, tdep->ppc_lr_regnum, bp_addr);

  /* Use the func_addr to find the descriptor, and use that to find
     the TOC.  If we're calling via a function pointer, the pointer
     itself identifies the descriptor.  */
  {
    struct type *ftype = check_typedef (value_type (function));
    CORE_ADDR desc_addr = value_as_address (function);

    if (TYPE_CODE (ftype) == TYPE_CODE_PTR
	|| convert_code_addr_to_desc_addr (func_addr, &desc_addr))
      {
	/* The TOC is the second double word in the descriptor.  */
	CORE_ADDR toc =
	  read_memory_unsigned_integer (desc_addr + tdep->wordsize,
					tdep->wordsize, byte_order);
	regcache_cooked_write_unsigned (regcache,
					tdep->ppc_gp0_regnum + 2, toc);
      }
  }

  return sp;
}


/* The 64 bit ABI return value convention.

   Return non-zero if the return-value is stored in a register, return
   0 if the return-value is instead stored on the stack (a.k.a.,
   struct return convention).

   For a return-value stored in a register: when WRITEBUF is non-NULL,
   copy the buffer to the corresponding register return-value location
   location; when READBUF is non-NULL, fill the buffer from the
   corresponding register return-value location.  */
enum return_value_convention
ppc64_sysv_abi_return_value (struct gdbarch *gdbarch, struct value *function,
			     struct type *valtype, struct regcache *regcache,
			     gdb_byte *readbuf, const gdb_byte *writebuf)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct type *func_type = function ? value_type (function) : NULL;
  int opencl_abi = func_type? ppc_sysv_use_opencl_abi (func_type) : 0;

  /* This function exists to support a calling convention that
     requires floating-point registers.  It shouldn't be used on
     processors that lack them.  */
  gdb_assert (ppc_floating_point_unit_p (gdbarch));

  /* Floats and doubles in F1.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_FLT && TYPE_LENGTH (valtype) <= 8)
    {
      gdb_byte regval[MAX_REGISTER_SIZE];
      struct type *regtype = register_type (gdbarch, tdep->ppc_fp0_regnum);
      if (writebuf != NULL)
	{
	  convert_typed_floating (writebuf, valtype, regval, regtype);
	  regcache_cooked_write (regcache, tdep->ppc_fp0_regnum + 1, regval);
	}
      if (readbuf != NULL)
	{
	  regcache_cooked_read (regcache, tdep->ppc_fp0_regnum + 1, regval);
	  convert_typed_floating (regval, regtype, readbuf, valtype);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_CODE (valtype) == TYPE_CODE_DECFLOAT)
    return get_decimal_float_return_value (gdbarch, valtype, regcache, readbuf,
					   writebuf);
  /* Integers in r3.  */
  if ((TYPE_CODE (valtype) == TYPE_CODE_INT
       || TYPE_CODE (valtype) == TYPE_CODE_ENUM
       || TYPE_CODE (valtype) == TYPE_CODE_CHAR
       || TYPE_CODE (valtype) == TYPE_CODE_BOOL)
      && TYPE_LENGTH (valtype) <= 8)
    {
      if (writebuf != NULL)
	{
	  /* Be careful to sign extend the value.  */
	  regcache_cooked_write_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
					  unpack_long (valtype, writebuf));
	}
      if (readbuf != NULL)
	{
	  /* Extract the integer from r3.  Since this is truncating the
	     value, there isn't a sign extension problem.  */
	  ULONGEST regval;
	  regcache_cooked_read_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
					 &regval);
	  store_unsigned_integer (readbuf, TYPE_LENGTH (valtype), byte_order,
				  regval);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  /* All pointers live in r3.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_PTR
      || TYPE_CODE (valtype) == TYPE_CODE_REF)
    {
      /* All pointers live in r3.  */
      if (writebuf != NULL)
	regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 3, writebuf);
      if (readbuf != NULL)
	regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 3, readbuf);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  /* OpenCL vectors < 16 bytes are returned as distinct
     scalars in f1..f2 or r3..r10.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_ARRAY
      && TYPE_VECTOR (valtype)
      && TYPE_LENGTH (valtype) < 16
      && opencl_abi)
    {
      struct type *eltype = check_typedef (TYPE_TARGET_TYPE (valtype));
      int i, nelt = TYPE_LENGTH (valtype) / TYPE_LENGTH (eltype);

      for (i = 0; i < nelt; i++)
	{
	  int offset = i * TYPE_LENGTH (eltype);

	  if (TYPE_CODE (eltype) == TYPE_CODE_FLT)
	    {
	      int regnum = tdep->ppc_fp0_regnum + 1 + i;
	      gdb_byte regval[MAX_REGISTER_SIZE];
	      struct type *regtype = register_type (gdbarch, regnum);

	      if (writebuf != NULL)
		{
		  convert_typed_floating (writebuf + offset, eltype,
					  regval, regtype);
		  regcache_cooked_write (regcache, regnum, regval);
		}
	      if (readbuf != NULL)
		{
		  regcache_cooked_read (regcache, regnum, regval);
		  convert_typed_floating (regval, regtype,
					  readbuf + offset, eltype);
		}
	    }
	  else
	    {
	      int regnum = tdep->ppc_gp0_regnum + 3 + i;
	      ULONGEST regval;

	      if (writebuf != NULL)
		{
		  regval = unpack_long (eltype, writebuf + offset);
		  regcache_cooked_write_unsigned (regcache, regnum, regval);
		}
	      if (readbuf != NULL)
		{
		  regcache_cooked_read_unsigned (regcache, regnum, &regval);
		  store_unsigned_integer (readbuf + offset,
					  TYPE_LENGTH (eltype), byte_order,
					  regval);
		}
	    }
	}

      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  /* OpenCL vectors >= 16 bytes are returned in v2..v9.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_ARRAY
      && TYPE_VECTOR (valtype)
      && TYPE_LENGTH (valtype) >= 16
      && opencl_abi)
    {
      int n_regs = TYPE_LENGTH (valtype) / 16;
      int i;

      for (i = 0; i < n_regs; i++)
	{
	  int offset = i * 16;
	  int regnum = tdep->ppc_vr0_regnum + 2 + i;

	  if (writebuf != NULL)
	    regcache_cooked_write (regcache, regnum, writebuf + offset);
	  if (readbuf != NULL)
	    regcache_cooked_read (regcache, regnum, readbuf + offset);
	}

      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  /* Array type has more than one use.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_ARRAY)
    {
      /* Small character arrays are returned, right justified, in r3.  */
      if (TYPE_LENGTH (valtype) <= 8
        && TYPE_CODE (TYPE_TARGET_TYPE (valtype)) == TYPE_CODE_INT
        && TYPE_LENGTH (TYPE_TARGET_TYPE (valtype)) == 1)
        {
          int offset = (register_size (gdbarch, tdep->ppc_gp0_regnum + 3)
                       - TYPE_LENGTH (valtype));
          if (writebuf != NULL)
           regcache_cooked_write_part (regcache, tdep->ppc_gp0_regnum + 3,
                                      offset, TYPE_LENGTH (valtype), writebuf);
          if (readbuf != NULL)
           regcache_cooked_read_part (regcache, tdep->ppc_gp0_regnum + 3,
                                      offset, TYPE_LENGTH (valtype), readbuf);
          return RETURN_VALUE_REGISTER_CONVENTION;
	}
      /* A VMX vector is returned in v2.  */
      if (TYPE_CODE (valtype) == TYPE_CODE_ARRAY
	  && TYPE_VECTOR (valtype)
	  && tdep->vector_abi == POWERPC_VEC_ALTIVEC)
        {
          if (readbuf)
            regcache_cooked_read (regcache, tdep->ppc_vr0_regnum + 2, readbuf);
          if (writebuf)
            regcache_cooked_write (regcache, tdep->ppc_vr0_regnum + 2,
				   writebuf);
          return RETURN_VALUE_REGISTER_CONVENTION;
        }
    }
  /* Big floating point values get stored in adjacent floating
     point registers, starting with F1.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_FLT
      && (TYPE_LENGTH (valtype) == 16 || TYPE_LENGTH (valtype) == 32))
    {
      if (writebuf || readbuf != NULL)
	{
	  int i;
	  for (i = 0; i < TYPE_LENGTH (valtype) / 8; i++)
	    {
	      if (writebuf != NULL)
		regcache_cooked_write (regcache, tdep->ppc_fp0_regnum + 1 + i,
				       (const bfd_byte *) writebuf + i * 8);
	      if (readbuf != NULL)
		regcache_cooked_read (regcache, tdep->ppc_fp0_regnum + 1 + i,
				      (bfd_byte *) readbuf + i * 8);
	    }
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  /* Complex values get returned in f1:f2, need to convert.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_COMPLEX
      && (TYPE_LENGTH (valtype) == 8 || TYPE_LENGTH (valtype) == 16))
    {
      if (regcache != NULL)
	{
	  int i;
	  for (i = 0; i < 2; i++)
	    {
	      gdb_byte regval[MAX_REGISTER_SIZE];
	      struct type *regtype =
		register_type (gdbarch, tdep->ppc_fp0_regnum);
	      struct type *target_type;
	      target_type = check_typedef (TYPE_TARGET_TYPE (valtype));
	      if (writebuf != NULL)
		{
		  convert_typed_floating ((const bfd_byte *) writebuf +
					  i * TYPE_LENGTH (target_type), 
					  target_type, regval, regtype);
		  regcache_cooked_write (regcache,
                                         tdep->ppc_fp0_regnum + 1 + i,
					 regval);
		}
	      if (readbuf != NULL)
		{
		  regcache_cooked_read (regcache,
                                        tdep->ppc_fp0_regnum + 1 + i,
                                        regval);
		  convert_typed_floating (regval, regtype,
					  (bfd_byte *) readbuf +
					  i * TYPE_LENGTH (target_type),
					  target_type);
		}
	    }
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  /* Big complex values get stored in f1:f4.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_COMPLEX && TYPE_LENGTH (valtype) == 32)
    {
      if (regcache != NULL)
	{
	  int i;
	  for (i = 0; i < 4; i++)
	    {
	      if (writebuf != NULL)
		regcache_cooked_write (regcache, tdep->ppc_fp0_regnum + 1 + i,
				       (const bfd_byte *) writebuf + i * 8);
	      if (readbuf != NULL)
		regcache_cooked_read (regcache, tdep->ppc_fp0_regnum + 1 + i,
				      (bfd_byte *) readbuf + i * 8);
	    }
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  return RETURN_VALUE_STRUCT_CONVENTION;
}

@


1.71
log
@gdb/ChangeLog
2013-03-01  Tiago Stürmer Daitx  <tdaitx@@linux.vnet.ibm.com>

	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_float): New function.
	(ppc64_sysv_abi_push_dummy_call): Handle complex arguments.
@
text
@d1079 1
a1079 1
  struct minimal_symbol *dot_fn;
d1081 1
d1085 1
a1085 1
  if (dot_fn == NULL || SYMBOL_LINKAGE_NAME (dot_fn)[0] != '.')
d1096 1
a1096 1
  fn = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (dot_fn) + 1, NULL,
@


1.70
log
@2013-01-23  Tiago Stürmer Daitx  <tdaitx@@linux.vnet.ibm.com>

	* ppc-sysv-tdep.c (ppc64_sysv_abi_return_value): Set correct
	type on float conversion for complex type.
@
text
@d1104 77
a1297 3
	      /* Floats and Doubles go in f1 .. f13.  They also
	         consume a left aligned GREG,, and can end up in
	         memory.  */
d1299 2
a1300 43
		{
		  gdb_byte regval[MAX_REGISTER_SIZE];
		  const gdb_byte *p;

		  /* Version 1.7 of the 64-bit PowerPC ELF ABI says:

		     "Single precision floating point values are mapped to
		     the first word in a single doubleword."

		     And version 1.9 says:

		     "Single precision floating point values are mapped to
		     the second word in a single doubleword."

		     GDB then writes single precision floating point values
		     at both words in a doubleword, to support both ABIs.  */
		  if (TYPE_LENGTH (type) == 4)
		    {
		      memcpy (regval, val, 4);
		      memcpy (regval + 4, val, 4);
		      p = regval;
		    }
		  else
		    p = val;

		  /* Write value in the stack's parameter save area.  */
		  write_memory (gparam, p, 8);

		  if (freg <= 13)
		    {
		      struct type *regtype
                        = register_type (gdbarch, tdep->ppc_fp0_regnum);

		      convert_typed_floating (val, type, regval, regtype);
		      regcache_cooked_write (regcache,
                                             tdep->ppc_fp0_regnum + freg,
					     regval);
		    }
		  if (greg <= 10)
		    regcache_cooked_write (regcache,
					   tdep->ppc_gp0_regnum + greg,
					   regval);
		}
a1311 2
	      /* IBM long double stored in two doublewords of the
		 parameter save area and corresponding registers.  */
d1313 12
d1326 1
a1326 1
		  if (!tdep->soft_float && freg <= 13)
d1328 7
a1334 7
		      regcache_cooked_write (regcache,
                                             tdep->ppc_fp0_regnum + freg,
					     val);
		      if (freg <= 12)
			regcache_cooked_write (regcache,
					       tdep->ppc_fp0_regnum + freg + 1,
					       val + 8);
d1336 27
a1362 11
		  if (greg <= 10)
		    {
		      regcache_cooked_write (regcache,
					     tdep->ppc_gp0_regnum + greg,
					     val);
		      if (greg <= 9)
			regcache_cooked_write (regcache,
					       tdep->ppc_gp0_regnum + greg + 1,
					       val + 8);
		    }
		  write_memory (gparam, val, TYPE_LENGTH (type));
a1363 3
	      freg += 2;
	      greg += 2;
	      gparam = align_up (gparam + TYPE_LENGTH (type), tdep->wordsize);
@


1.69
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d1923 2
d1928 2
a1929 2
					  i * (TYPE_LENGTH (valtype) / 2),
					  valtype, regval, regtype);
d1941 2
a1942 2
					  i * (TYPE_LENGTH (valtype) / 2),
					  valtype);
@


1.68
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d4 1
a4 2
   Copyright (C) 2000-2003, 2005, 2007-2012 Free Software Foundation,
   Inc.
@


1.67
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@a1081 1
  CORE_ADDR toc;
@


1.66
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1044 1
a1044 1
ppc_sysv_abi_return_value (struct gdbarch *gdbarch, struct type *func_type,
d1048 3
a1050 2
  return do_ppc_sysv_return_value (gdbarch, func_type, valtype, regcache,
				   readbuf, writebuf, 0);
d1055 1
a1055 1
				  struct type *func_type,
d1060 3
a1062 2
  return do_ppc_sysv_return_value (gdbarch, func_type, valtype, regcache,
				   readbuf, writebuf, 1);
d1715 1
a1715 1
ppc64_sysv_abi_return_value (struct gdbarch *gdbarch, struct type *func_type,
d1721 1
@


1.65
log
@	* ppc-sysv-tdep.c (ppc_sysv_use_opencl_abi): New function.
	(ppc_sysv_abi_push_dummy_call): Use it.
	(do_ppc_sysv_return_value): Likewise.
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
@
text
@d4 2
a5 2
   Copyright (C) 2000, 2001, 2002, 2003, 2005, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.65.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d4 2
a5 2
   Copyright (C) 2000-2003, 2005, 2007-2012 Free Software Foundation,
   Inc.
@


1.64
log
@[powerpc] crash trying to allocate memory in inferior

Our testsuite noticed a crash when trying to call a function which
requires GDB to allocate memory in the inferior. Typically, this
happens when one of the parameters is a string.  For instance, our
testcase tries:

    (gdb) call debug.trace (me, "You")
    [1]    32737 segmentation fault /path/to/gdb

What happens is that GDB sees the string, and thus tries to allocate
memory for it in the inferior:

> /* Allocate NBYTES of space in the inferior using the inferior's
>    malloc and return a value that is a pointer to the allocated
>    space.  */
>
> struct value *
> value_allocate_space_in_inferior (int len)
> {
>   struct objfile *objf;
>   struct value *val = find_function_in_inferior ("malloc", &objf);

And find_function_in_inferior first searches the symtab in case
we have debug info.  But, in our case (bareboard powerpc), we don't,
so it gets "malloc"'s address from the minimal symbols, and builds
a value whose type is a TYPE_CODE_PTR, not a TYPE_CODE_FUNC.

As a result, when we later try to make the call to malloc, we end up
inside the powerpc tdep code that has:

> do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,
[...]
>   if (func_type
>       && TYPE_CALLING_CONVENTION (func_type) == DW_CC_GDB_IBM_OpenCL)

The problem is that func_type is not a TYPE_CODE_FUNC, and thus
the type-specific kind is not TYPE_SPECIFIC_FUNC, and so we do
TYPE_CALLING_CONVENTION is an invalid access.

Interestingly, the other call to TYPE_CALLING_CONVENTION is correctly
preceded by a check of the type's TYPE_CODE (making sure that it is
TYPE_CODE_FUNC).

gdb/ChangeLog:

        * ppc-sysv-tdep.c (do_ppc_sysv_return_value): Do not check
        FUNC_TYPE's calling convention if FUNC_TYPE is not a function.
@
text
@d35 16
d70 1
a70 2
  struct type *ftype;
  int opencl_abi = 0;
a79 7
  ftype = check_typedef (value_type (function));
  if (TYPE_CODE (ftype) == TYPE_CODE_PTR)
    ftype = check_typedef (TYPE_TARGET_TYPE (ftype));
  if (TYPE_CODE (ftype) == TYPE_CODE_FUNC
      && TYPE_CALLING_CONVENTION (ftype) == DW_CC_GDB_IBM_OpenCL)
    opencl_abi = 1;

d700 1
a700 6
  int opencl_abi = 0;

  if (func_type
      && TYPE_CODE (func_type) == TYPE_CODE_FUNC
      && TYPE_CALLING_CONVENTION (func_type) == DW_CC_GDB_IBM_OpenCL)
    opencl_abi = 1;
d1121 1
a1121 2
  struct type *ftype;
  int opencl_abi = 0;
a1150 7
  ftype = check_typedef (value_type (function));
  if (TYPE_CODE (ftype) == TYPE_CODE_PTR)
    ftype = check_typedef (TYPE_TARGET_TYPE (ftype));
  if (TYPE_CODE (ftype) == TYPE_CODE_FUNC
      && TYPE_CALLING_CONVENTION (ftype) == DW_CC_GDB_IBM_OpenCL)
    opencl_abi = 1;

d1719 1
a1719 5
  int opencl_abi = 0;

  if (func_type
      && TYPE_CALLING_CONVENTION (func_type) == DW_CC_GDB_IBM_OpenCL)
    opencl_abi = 1;
@


1.63
log
@gdb/
	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): Add support
	for the "generic" vector ABI used with GCC 4.3 and later.
	(ppc64_sysv_abi_return_value): Likewise.

gdb/testsuite:
	* gdb.arch/altivec-abi.exp: Skip "generic" tests on 64-bit when
	using a GCC 4.1 or 4.2 compiler.  Add an additional test variant
	"generic ABI, auto".
	(altivec_abi_tests): Accept vectors returned by reference.
@
text
@d695 1
@


1.62
log
@include/ChangeLog:

	* dwarf2.h (enum dwarf_calling_convention): Add DW_CC_GDB_IBM_OpenCL.

gdb/ChangeLog:

	* dwarf2read.c (read_subroutine_type): Set special calling
	convention flag for functions compiled by IBM XL C for OpenCL.
	* ppc-sysv-tdep.c: Include "dwarf2.h"
	(ppc_sysv_abi_push_dummy_call): Implement IBM OpenCL vector types
	calling convention.
	(do_ppc_sysv_return_value): Add FUNC_TYPE argument.  Implement
	IBM OpenCL vector types calling convention.
	(ppc_sysv_abi_return_value): Pass through FUNC_TYPE.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_push_dummy_call): Implement IBM OpenCL vector
	types calling convention.
	(ppc64_sysv_abi_return_value): Likewise.
	* spu-tdep.c: Include "dwarf2.h"
	(spu_return_value): Implement IBM OpenCL vector types calling
	convention.

gdb/testsuite/ChangeLog:

	* gdb.opencl/callfuncs.cl: New file.
	* gdb.opencl/callfuncs.exp: New test.
	* gdb.opencl/Makefile.in (EXECUTABLES): Add callfuncs.
@
text
@d1122 3
d1177 3
d1183 4
a1186 3
	  /* During the first pass, GPARAM is more like an offset
	     (start address zero) than an address.  That way it
	     accumulates the total stack space required.  */
d1188 1
d1192 5
a1196 3
	  /* Decrement the stack pointer making space for the on-stack
	     stack parameters.  Set gparam to that region.  */
	  gparam = align_down (sp - gparam_size, 16);
d1475 1
a1475 1
		   && tdep->ppc_vr0_regnum >= 0)
d1497 24
d1662 3
a1664 2
	  /* Save the true region sizes ready for the second pass.
	     Make certain that the general parameter save area is at
d1887 2
a1888 1
        && TYPE_VECTOR (valtype) && tdep->ppc_vr0_regnum >= 0)
@


1.61
log
@ChangeLog:

	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): Implement
	correct ABI for AltiVec vector arguments.

testsuite/ChangeLog:

	* gdb.arch/altivec-abi.c (vec_func): Make use of intv_on_stack_f
	when computing result.
	* gdb.arch/altivec-abi.exp: Update expected results.
@
text
@d33 1
d54 2
d65 7
d340 120
d685 4
a688 3
do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *type,
			  struct regcache *regcache, gdb_byte *readbuf,
			  const gdb_byte *writebuf, int broken_gcc)
d692 6
d699 1
d832 77
d1044 2
a1045 2
  return do_ppc_sysv_return_value (gdbarch, valtype, regcache, readbuf,
				   writebuf, 0);
d1055 2
a1056 2
  return do_ppc_sysv_return_value (gdbarch, valtype, regcache, readbuf,
				   writebuf, 1);
d1117 2
d1145 7
d1360 103
d1688 5
d1755 77
@


1.60
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Internationalization.
	* c-lang.c: Ditto.
	* charset.c: Ditto.
	* fork-child.c: Ditto.
	* nto-procfs.c: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* procfs.c: Ditto.
	* remote-mips.c: Ditto.
	* remote.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* target.c: Ditto.
	* valops.c: Ditto.
	* value.c: Ditto.
	* xml-support.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
@
text
@a904 3
  /* Size of the Altivec's vector parameter region, the final value is
     computed in the for-loop below.  */
  LONGEST vparam_size = 0;
d948 1
a948 1
         (integer, struct, float, ...) should be saved.  */
a949 3
      /* Address, at which the next Altivec vector parameter should be
         saved.  */
      CORE_ADDR vparam;
d953 3
a955 4
	  /* During the first pass, GPARAM and VPARAM are more like
	     offsets (start address zero) than addresses.  That way
	     they accumulate the total stack space each region
	     requires.  */
a956 1
	  vparam = 0;
d960 3
a962 5
	  /* Decrement the stack pointer making space for the Altivec
	     and general on-stack parameters.  Set vparam and gparam
	     to their corresponding regions.  */
	  vparam = align_down (sp - vparam_size, 16);
	  gparam = align_down (vparam - gparam_size, 16);
d1140 8
a1147 6
	      /* In the Altivec ABI, vectors go in the vector
	         registers v2 .. v13, or when that runs out, a vector
	         annex which goes above all the normal parameters.
	         NOTE: cagney/2003-09-21: This is a guess based on the
	         PowerOpen Altivec ABI.  */
	      if (vreg <= 13)
d1149 1
a1149 1
		  if (write_pass)
d1152 2
a1153 7
		  vreg++;
		}
	      else
		{
		  if (write_pass)
		    write_memory (vparam, val, TYPE_LENGTH (type));
		  vparam = align_up (vparam + TYPE_LENGTH (type), 16);
d1155 4
d1301 2
a1302 3
	  /* Save the true region sizes ready for the second pass.  */
	  vparam_size = vparam;
	  /* Make certain that the general parameter save area is at
@


1.59
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* nto-procfs.c: Comment cleanup, mostly periods and spaces.
	* nto-tdep.c: Ditto.
	* nto-tdep.h: Ditto.
	* objc-exp.y: Ditto.
	* objc-lang.c: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* observer.c: Ditto.
	* opencl-lang.c: Ditto.
	* osabi.c: Ditto.
	* parse.c: Ditto.
	* parser-defs.h: Ditto.
	* p-exp.y: Ditto.
	* p-lang.c: Ditto.
	* posix-hdep.c: Ditto.
	* ppcbug-rom.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* ppc-linux-tdep.h: Ditto.
	* ppcnbsd-tdep.c: Ditto.
	* ppcobsd-tdep.c: Ditto.
	* ppcobsd-tdep.h: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* ppc-tdep.h: Ditto.
	* printcmd.c: Ditto.
	* proc-abi.c: Ditto.
	* proc-flags.c: Ditto.
	* procfs.c: Ditto.
	* proc-utils.h: Ditto.
	* progspace.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* ravenscar-sparc-thread.c: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote.c: Ditto.
	* remote-fileio.c: Ditto.
	* remote-fileio.h: Ditto.
	* remote.h: Ditto.
	* remote-m32r-sdi.c: Ditto.
	* remote-mips.c: Ditto.
	* remote-sim.c: Ditto.
	* rs6000-aix-tdep.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
@
text
@d534 1
a534 1
    internal_error (__FILE__, __LINE__, "Unknown decimal float size.");
@


1.58
log
@run copyright.sh for 2011.
@
text
@d34 1
a34 1
/* Pass the arguments in either registers, or in the stack. Using the
d38 2
a39 2
   passed in fpr's, in addition to that. Rest of the parameters if any
   are passed in user stack. 
d43 1
a43 1
   starting from r4. */
d390 1
a390 1
		     aligned stack slot ... */
d446 1
a446 1
	 registers. It is strongly recommended that the caller set the
d590 2
a591 1
      && (gdbarch_long_double_format (gdbarch) == floatformats_ibm_long_double))
d610 2
a611 1
	   && (gdbarch_long_double_format (gdbarch) == floatformats_ibm_long_double))
d885 1
a885 1
/* Pass the arguments in either registers, or in the stack. Using the
d890 1
a890 1
   greatly simplifies the logic. */
d893 2
a894 1
ppc64_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
d912 1
a912 1
     calls to align_up(), align_down(), etc.  because this makes it
d1458 2
a1459 1
            regcache_cooked_write (regcache, tdep->ppc_vr0_regnum + 2, writebuf);
@


1.57
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d4 1
a4 1
   Copyright (C) 2000, 2001, 2002, 2003, 2005, 2007, 2008, 2009, 2010
@


1.56
log
@	* eval.c (evaluate_subexp_standard) [OP_OBJC_MSGCALL]: Support
	platforms that use function descriptors.  Prefer to use function
	pointer types instead of function types.
	* linespec.c (decode_objc): Support function descriptors.  Fully
	initialize SAL result.
	* objc-lang.c (find_methods): Support function descriptors.
	Do not require function symbol to point to text section.

	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): When calling
	via a function pointer, use the descriptor it points to.
@
text
@d4 1
a4 1
   Copyright (C) 2000, 2001, 2002, 2003, 2005, 2007, 2008, 2009
@


1.55
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d1329 2
a1330 1
     the TOC.  */
d1332 5
a1336 2
    CORE_ADDR desc_addr;
    if (convert_code_addr_to_desc_addr (func_addr, &desc_addr))
@


1.55.4.1
log
@	* eval.c (evaluate_subexp_standard) [OP_OBJC_MSGCALL]: Support
	platforms that use function descriptors.  Prefer to use function
	pointer types instead of function types.
	* linespec.c (decode_objc): Support function descriptors.  Fully
	initialize SAL result.
	* objc-lang.c (find_methods): Support function descriptors.
	Do not require function symbol to point to text section.

	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): When calling
	via a function pointer, use the descriptor it points to.
@
text
@d1329 1
a1329 2
     the TOC.  If we're calling via a function pointer, the pointer
     itself identifies the descriptor.  */
d1331 2
a1332 5
    struct type *ftype = check_typedef (value_type (function));
    CORE_ADDR desc_addr = value_as_address (function);

    if (TYPE_CODE (ftype) == TYPE_CODE_PTR
	|| convert_code_addr_to_desc_addr (func_addr, &desc_addr))
@


1.55.4.2
log
@	Revert 2009-09-28 commit:
	* eval.c (evaluate_subexp_standard) [OP_OBJC_MSGCALL]: Support
	platforms that use function descriptors.  Prefer to use function
	pointer types instead of function types.
	* linespec.c (decode_objc): Support function descriptors.  Fully
	initialize SAL result.
	* objc-lang.c (find_methods): Support function descriptors.
	Do not require function symbol to point to text section.

	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): When calling
	via a function pointer, use the descriptor it points to.
@
text
@d1329 2
a1330 1
     the TOC.  */
d1332 5
a1336 2
    CORE_ADDR desc_addr;
    if (convert_code_addr_to_desc_addr (func_addr, &desc_addr))
@


1.54
log
@        Updated copyright notices for most files.
@
text
@d52 1
d402 1
a402 1
		  store_unsigned_integer (word, tdep->wordsize,
d408 1
a408 1
		store_unsigned_integer (word, tdep->wordsize,
d466 1
a466 1
  write_memory_signed_integer (sp, tdep->wordsize, saved_sp);
d560 1
d680 2
a681 1
	  store_unsigned_integer (readbuf, TYPE_LENGTH (type), regval);
d898 1
d1201 1
a1201 1
						 word);
d1322 1
a1322 1
  write_memory_signed_integer (sp, tdep->wordsize, back_chain);
d1337 1
a1337 1
					tdep->wordsize);
d1363 1
d1410 2
a1411 1
	  store_unsigned_integer (readbuf, TYPE_LENGTH (valtype), regval);
@


1.53
log
@	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Handle passing
	decimal floating-point values in GPRs for soft-float.
	(do_ppc_sysv_return_value): Handle returning decimal
	floating-point values in GPRs for soft-float.
@
text
@d4 1
a4 1
   Copyright (C) 2000, 2001, 2002, 2003, 2005, 2007, 2008
@


1.52
log
@	* ppc-linux-tdep.c (ppc_linux_init_abi): Do not install
	ppc64_sysv_abi_adjust_breakpoint_address.
	* ppc-sysv-tdep.c (ppc64_sysv_abi_adjust_breakpoint_address): Remove.
	* ppc-tdep.h (ppc64_sysv_abi_adjust_breakpoint_address): Remove.
@
text
@d180 3
a182 1
		       || TYPE_CODE (type) == TYPE_CODE_FLT))	/* double */
d184 6
a189 5
	      /* "long long" or soft-float "double" passed in an odd/even
	         register pair with the low addressed word in the odd
	         register and the high addressed word in the even
	         register, or when the registers run out an 8 byte
	         aligned stack location.  */
d216 6
a221 3
	  else if (len == 16 && TYPE_CODE (type) == TYPE_CODE_FLT
		   && (gdbarch_long_double_format (gdbarch)
		       == floatformats_ibm_long_double))
d223 3
a225 3
	      /* Soft-float IBM long double passed in four consecutive
		 registers, or on the stack.  The registers are not
		 necessarily odd/even pairs.  */
d605 4
a608 3
  if (TYPE_CODE (type) == TYPE_CODE_FLT
      && TYPE_LENGTH (type) == 16
      && (gdbarch_long_double_format (gdbarch) == floatformats_ibm_long_double))
d610 2
a611 1
      /* Soft-float IBM long double stored in r3, r4, r5, r6.  */
d635 3
a637 1
      || (TYPE_CODE (type) == TYPE_CODE_FLT && TYPE_LENGTH (type) == 8))
d641 2
a642 1
	  /* A long long, or a double stored in the 32 bit r3/r4.  */
d650 2
a651 1
	  /* A long long, or a double stored in the 32 bit r3/r4.  */
@


1.51
log
@2008-05-03  Luis Machado  <luisgpm@@br.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* cli/cli-decode.c (lookup_cmd_1): Fix indentation.
	* doublest.c (convert_typed_floating): Fix typo in comment.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame-unwind.h (frame_sniffer_ftype): Likewise.
	* frame.c (frame_unwind_address_in_block): Likewise.
	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): Likewise.
	* symtab.h (struct symbol): Likewise.
	* tramp-frame.h (struct trad_frame_cache): Likewise.
	* value.c (allocate_repeat_value): Likewise.
@
text
@a1512 17
CORE_ADDR
ppc64_sysv_abi_adjust_breakpoint_address (struct gdbarch *gdbarch,
					  CORE_ADDR bpaddr)
{
  /* PPC64 SYSV specifies that the minimal-symbol "FN" should point at
     a function-descriptor while the corresponding minimal-symbol
     ".FN" should point at the entry point.  Consequently, a command
     like "break FN" applied to an object file with only minimal
     symbols, will insert the breakpoint into the descriptor at "FN"
     and not the function at ".FN".  Avoid this confusion by adjusting
     any attempt to set a descriptor breakpoint into a corresponding
     function breakpoint.  Note that GDB warns the user when this
     adjustment is applied - that's ok as otherwise the user will have
     no way of knowing why their breakpoint at "FN" resulted in the
     program stopping at ".FN".  */
  return gdbarch_convert_from_func_ptr_addr (gdbarch, bpaddr, &current_target);
}
@


1.50
log
@	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): Handle
	TYPE_CODE_BOOL and TYPE_CODE_CHAR the same as TYPE_CODE_INT.
	Handle TYPE_CODE_REF the same as TYPE_CODE_PTR.
	Handle TYPE_CODE_METHOD the same as TYPE_CODE_FUNC.
	Allow typedefs when checking for function pointer arguments.
	Right-align small structs passed on the stack.
	(ppc64_sysv_abi_return_value): Handle TYPE_CODE_BOOL and
	TYPE_CODE_CHAR the same as TYPE_CODE_INT.
	Handle TYPE_CODE_REF the same as TYPE_CODE_PTR.
@
text
@d942 1
a942 1
	     the accumulate the total stack space each region
@


1.49
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d1152 4
a1155 1
		    || TYPE_CODE (type) == TYPE_CODE_PTR)
d1167 1
a1167 1
		      && TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC)
d1169 10
a1178 3
		      CORE_ADDR desc = word;
		      convert_code_addr_to_desc_addr (word, &desc);
		      word = desc;
d1219 14
a1232 8
		/* WARNING: cagney/2003-09-21: Strictly speaking, this
		   isn't necessary, unfortunately, GCC appears to get
		   "struct convention" parameter passing wrong putting
		   odd sized structures in memory instead of in a
		   register.  Work around this by always writing the
		   value to memory.  Fortunately, doing this
		   simplifies the code.  */
		write_memory (gparam, val, TYPE_LENGTH (type));
d1375 3
a1377 1
       || TYPE_CODE (valtype) == TYPE_CODE_ENUM)
d1398 2
a1399 1
  if (TYPE_CODE (valtype) == TYPE_CODE_PTR)
@


1.48
log
@    Luis Machado  <luisgpm@@br.ibm.com>
    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Pass floats that
don't fit into registerson the stack the way GCC does.
@
text
@d808 3
a810 3
ppc_sysv_abi_return_value (struct gdbarch *gdbarch, struct type *valtype,
			   struct regcache *regcache, gdb_byte *readbuf,
			   const gdb_byte *writebuf)
d818 1
d1326 3
a1328 3
ppc64_sysv_abi_return_value (struct gdbarch *gdbarch, struct type *valtype,
			     struct regcache *regcache, gdb_byte *readbuf,
			     const gdb_byte *writebuf)
@


1.47
log
@	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): Write 32-bit
	float in both first and second word in the doubleword, to support
	old and new ABIs.
@
text
@d132 12
a143 3
		  /* SysV ABI converts floats to doubles before
		     writing them to an 8 byte aligned stack location.  */
		  argoffset = align_up (argoffset, 8);
a144 4
		    {
		      char memval[8];
		      convert_typed_floating (val, type, memval,
					      builtin_type_ieee_double);
d146 1
a146 2
		    }
		  argoffset += 8;
@


1.46
log
@	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Add support for
	TYPE_CODE_DECFLOAT arguments.
	(ppc64_sysv_abi_push_dummy_call) Likewise.
	(get_decimal_float_return_value): New function.
	(do_ppc_sysv_return_value): Add support for TYPE_CODE_DECFLOAT return
	values by calling get_decimal_float_return_value.
	(ppc64_sysv_abi_return_value): Likewise.
@
text
@d974 1
d982 27
a1010 1
		      gdb_byte regval[MAX_REGISTER_SIZE];
d1013 1
d1020 4
a1023 7
		    {
		      /* The ABI states "Single precision floating
		         point values are mapped to the first word in
		         a single doubleword" and "... floating point
		         values mapped to the first eight doublewords
		         of the parameter save area are also passed in
		         general registers").
a1024 12
		         This code interprets that to mean: store it,
		         left aligned, in the general register.  */
		      gdb_byte regval[MAX_REGISTER_SIZE];
		      memset (regval, 0, sizeof regval);
		      memcpy (regval, val, TYPE_LENGTH (type));
		      regcache_cooked_write (regcache,
					     tdep->ppc_gp0_regnum + greg,
					     regval);
		    }
		  write_memory (gparam, val, TYPE_LENGTH (type));
		}
	      /* Always consume parameter stack space.  */
d1027 2
a1028 1
	      gparam = align_up (gparam + TYPE_LENGTH (type), tdep->wordsize);
@


1.45
log
@	Updated copyright notices for most files.
@
text
@d244 75
d464 64
d643 3
d1051 57
d1335 3
@


1.44
log
@2007-11-16  Markus Deuling  <deuling@@de.ibm.com>

	* m32r-rom.c (m32r_supply_register): Use get_regcache_arch to get at
	the current architecture by regcache.
	* ppcnbsd-nat.c (ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, fetch_ppc_registers)
	(store_altivec_register, store_spe_register, store_register)
	(fill_vrregset, store_ppc_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Likewise.

	* trad-frame.c (trad_frame_alloc_saved_regs): Replace current_gdbarch by
	gdbarch.
	* user-regs.c (user_reg_map_name_to_regnum): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_return_value): Likewise.
	* m32c-tdep.c (m32c_register_reggroup_p): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* rs6000-tdep.c (ppc_dwarf2_frame_init_reg): Likewise.

	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Use get_frame_arch to
	get at the current architecture by frame_info.
	* gcore.c (derive_stack_segment): Likewise.

	* shnbsd-nat.c (GETREGS_SUPPLIES): Add gdbarch parameter.
	(shnbsd_fetch_inferior_registers, shnbsd_store_inferior_registers): Add
	gdbarch to GETREGS_SUPPLIES call.
@
text
@d4 1
a4 1
   Copyright (C) 2000, 2001, 2002, 2003, 2005, 2007
@


1.43
log
@2007-11-07  Joseph Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): Right-align
	struct values smaller than one doubleword; left-align those
	larger.  Pass structs containing a single floating-point value in
	registers.
@
text
@d51 1
a51 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d58 1
a58 2
  regcache_cooked_read_unsigned (regcache,
				 gdbarch_sp_regnum (current_gdbarch),
d148 1
a148 1
		   && (gdbarch_long_double_format (current_gdbarch)
d210 1
a210 1
		   && (gdbarch_long_double_format (current_gdbarch)
d377 1
a377 2
  regcache_cooked_write_signed (regcache,
				gdbarch_sp_regnum (current_gdbarch), sp);
d439 1
a439 2
      && (gdbarch_long_double_format (current_gdbarch)
	  == floatformats_ibm_long_double))
d458 1
a458 2
      && (gdbarch_long_double_format (current_gdbarch)
	  == floatformats_ibm_long_double))
d735 1
a735 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d762 1
a762 2
  regcache_cooked_read_unsigned (regcache,
				 gdbarch_sp_regnum (current_gdbarch),
d876 1
a876 1
		   && (gdbarch_long_double_format (current_gdbarch)
d1031 1
a1031 1
			       && (gdbarch_long_double_format (current_gdbarch)
d1069 1
a1069 2
  regcache_cooked_write_signed (regcache,
				gdbarch_sp_regnum (current_gdbarch), sp);
d1228 1
a1228 1
		register_type (current_gdbarch, tdep->ppc_fp0_regnum);
@


1.42
log
@include:
2007-11-07  Joseph Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* floatformat.h (struct floatformat): Add split_half field.
	(floatformat_ibm_long_double): New.

libiberty:
2007-11-07  Joseph Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* floatformat.c (mant_bits_set): New.
	(floatformat_to_double): Use it.  Note no special handling of
	split formats.
	(floatformat_from_double): Note no special handing of split
	formats.
	(floatformat_ibm_long_double_is_valid,
	floatformat_ibm_long_double): New.
	(floatformat_ieee_single_big, floatformat_ieee_single_little,
	floatformat_ieee_double_big, floatformat_ieee_double_little,
	floatformat_ieee_double_littlebyte_bigword, floatformat_vax_f,
	floatformat_vax_d, floatformat_vax_g, floatformat_i387_ext,
	floatformat_m68881_ext, floatformat_i960_ext,
	floatformat_m88110_ext, floatformat_m88110_harris_ext,
	floatformat_arm_ext_big, floatformat_arm_ext_littlebyte_bigword,
	floatformat_ia64_spill_big, floatformat_ia64_spill_little,
	floatformat_ia64_quad_big, floatformat_ia64_quad_little): Update
	for addition of split_half field.

gdb:
2007-11-07  Joseph Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdbtypes.c (floatformats_ibm_long_double): New.
	* gdbtypes.h (floatformats_ibm_long_double): Declare.
	* ia64-tdep.c (floatformat_ia64_ext): Update for addition of
	split_half field.
	* mips-tdep.c (n32n64_floatformat_always_valid,
	floatformat_n32n64_long_double_big, floatformats_n32n64_long):
	Remove.
	(mips_gdbarch_init): Use floatformats_ibm_long_double instead of
	floatformats_n32n64_long.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Use 128-bit IBM long
	double.
	* doublest.c (convert_floatformat_to_doublest,
	convert_doublest_to_floatformat): Handle split floating-point
	formats.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Handle IBM long
	double arguments.
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	(do_ppc_sysv_return_value): Handle IBM long double return.
@
text
@d980 7
a986 14
		      /* WARNING: cagney/2003-09-21: As best I can
		         tell, the ABI specifies that the value should
		         be left aligned.  Unfortunately, GCC doesn't
		         do this - it instead right aligns even sized
		         values and puts odd sized values on the
		         stack.  Work around that by putting both a
		         left and right aligned value into the
		         register (hopefully no one notices :-^).
		         Arrrgh!  */
		      /* Left aligned (8 byte values such as pointers
		         fill the buffer).  */
		      memcpy (regval, val + byte, len);
		      /* Right aligned (but only if even).  */
		      if (len == 1 || len == 2 || len == 4)
d989 2
d1004 51
a1054 5
	      if (write_pass)
		/* WARNING: cagney/2004-06-20: It appears that GCC
		   likes to put structures containing a single
		   floating-point member in an FP register instead of
		   general general purpose.  */
@


1.41
log
@	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Check the selected
	soft float and vector ABIs.  Support the generic vector ABI for
	AltiVec types.
	(do_ppc_sysv_return_value): Likewise.  Correct argument types and
	casts.
	(ppc64_sysv_abi_push_dummy_call): Assert that floating point is
	supported.
	* ppc-tdep.h (enum powerpc_vector_abi): New.
	(struct gdbarch_tdep): Add soft_float and vector_abi.
	* rs6000-tdep.c (setpowerpccmdlist, showpowerpccmdlist)
	(powerpc_soft_float_global, powerpc_vector_strings)
	(powerpc_vector_abi_global, powerpc_vector_abi_string): New.
	(rs6000_gdbarch_init): Check for soft-float and vector ABI markings.
	(set_powerpc_command, show_powerpc_command, powerpc_set_soft_float)
	(powerpc_set_vector_abi): New.
	(_initialize_rs6000_tdep): Register "set powerpc" and "show powerpc"
	commands.
	* Makefile.in (elf_ppc_h): New.
	(rs6000-tdep.o): Update.

	* gdb.texinfo (PowerPC): Document "set powerpc vector-abi" and "set
	powerpc soft-float".

	* gdb.arch/altivec-abi.exp: Run multiple times for GCC on GNU/Linux.
	Test "set powerpc vector-abi".  Skip auto-detection tests for old
	toolchains.
@
text
@d56 2
d146 29
a192 7
	      else if (tdep->wordsize == 8)
		{
		  if (write_pass)
		    regcache_cooked_write (regcache,
					   tdep->ppc_gp0_regnum + greg, val);
		  greg += 1;
		}
d210 35
d438 49
d879 35
@


1.40
log
@	* ppc-sysv-tdep.c (do_ppc_sysv_return_value): Handle other integer
	types.
@
text
@d107 2
a108 2
	  if (TYPE_CODE (type) == TYPE_CODE_FLT
	      && ppc_floating_point_unit_p (current_gdbarch) && len <= 8)
d144 3
a146 2
	  else if (len == 8 && (TYPE_CODE (type) == TYPE_CODE_INT	/* long long */
				|| (!ppc_floating_point_unit_p (current_gdbarch) && TYPE_CODE (type) == TYPE_CODE_FLT)))	/* double */
d148 1
a148 1
	      /* "long long" or "double" passed in an odd/even
d188 2
a189 1
		   && TYPE_VECTOR (type) && tdep->ppc_vr0_regnum >= 0)
d210 2
a211 1
		   && TYPE_VECTOR (type) && tdep->ppc_ev0_regnum >= 0)
d245 9
a253 3
		  /* Structs and large values are put on an 8 byte
		     aligned stack ... */
		  structoffset = align_up (structoffset, 8);
d349 2
a350 2
			  struct regcache *regcache, void *readbuf,
			  const void *writebuf, int broken_gcc)
d356 1
a356 1
      && ppc_floating_point_unit_p (gdbarch))
d386 1
a386 1
				(bfd_byte *) readbuf + 0);
d388 1
a388 1
				(bfd_byte *) readbuf + 4);
d394 1
a394 1
				 (const bfd_byte *) writebuf + 0);
d396 1
a396 1
				 (const bfd_byte *) writebuf + 4);
d429 2
a430 1
      && TYPE_VECTOR (type) && tdep->ppc_vr0_regnum >= 0)
d444 32
d478 2
a479 1
      && TYPE_VECTOR (type) && tdep->ppc_ev0_regnum >= 0)
d650 5
d736 1
a736 2
		  if (ppc_floating_point_unit_p (current_gdbarch)
		      && freg <= 13)
d919 1
a919 1
/* The 64 bit ABI retun value convention.
@


1.39
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d391 7
a397 2
  if (TYPE_CODE (type) == TYPE_CODE_INT
      && TYPE_LENGTH (type) <= tdep->wordsize)
@


1.38
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.37
log
@	* arm-tdep.c (arm_print_float_info): Use register value from FRAME
	instead of calling read_register.

	* avr-tdep.c (avr_push_dummy_call): Write to REGCACHE instead of
	calling write_register.

	* hppa-tdep.c (hppa32_push_dummy_call): Write to REGCACHE instead of
	calling write_register.

	* ia64-tdep.c (find_func_descr): Add REGCACHE parameter.  Use it
	instead of calling read_register.
	(ia64_push_dummy_call): Update call to find_func_descr.  Use REGCACHE
	instead of calling read_register and write_register.

	* m32r-tdep.c (m32r_linux_supply_gregset): Use REGCACHE parameter
	instead of current_regcache.

	* mn10300-tdep.c (mn10300_push_dummy_call): Write to REGCACHE instead
	of calling write_register.
	* mn10300-linux-tdep.c (am33_supply_fpregset_method): Use REGCACHE
	parameter instead of current_regcache.

	* mips-tdep.c (mips2_fp_compat): Add FRAME parameter.  Use it
	instead of calling read_register.
	(mips_read_fp_register_double, mips_print_fp_register): Update calls.
	(mips_eabi_push_dummy_call): Use REGCACHE instead of write_register.
	(mips_n32n64_push_dummy_call): Likewise.
	(mips_o32_push_dummy_call): Likewise.
	(mips_o64_push_dummy_call): Likewise.

	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Use REGCACHE
	parameter instead of current_regcache.

	* xtensa-tdep.c (xtensa_register_write_masked): Add REGCACHE parameter.
	Use it instead of read_register and write_register.
	(xtensa_register_read_masked): Likewise.
	(xtensa_pseudo_register_read): Update call.
	(xtensa_pseudo_register_write): Likewise.
	(xtensa_frame_cache): Use register values unwound from NEXT_FRAME
	instead of calling read_register.
	(xtensa_push_dummy_call): Update comment.
@
text
@d58 3
a60 1
  regcache_cooked_read_unsigned (regcache, SP_REGNUM, &saved_sp);
d312 2
a313 1
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);
d607 3
a609 1
  regcache_cooked_read_unsigned (regcache, SP_REGNUM, &back_chain);
d840 2
a841 1
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);
@


1.36
log
@	* inferior.h (read_sp): Remove prototype.
	* regcache.c (read_sp): Remove.
	* gcore.c (derive_stack_segment): Use get_frame_sp instead of read_sp.
	* infcall.c (call_function_by_hand): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Use regcache instead
	of calling read_sp.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
@
text
@d194 1
a194 1
		    regcache_cooked_write (current_regcache,
d220 1
a220 1
		    regcache_cooked_write (current_regcache,
@


1.35
log
@	* doublest.c (floatformat_from_length): Use the right element from
	gdbarch floatformats.
	(floatformat_from_type, extract_typed_floating)
	(store_typed_floating): Likewise.
	* doublest.h: Remove declarations for undefined floatformat arrays.
	* gdbarch.sh (float_format, double_format, long_double_format): Change
	to pairs.
	(pformat): Update for pairs.
	* gdbarch.c, gdbarch.h: Regenerated.
	* gdbtypes.c (floatformats_ieee_single, floatformats_ieee_double)
	(floatformats_ieee_double_littlebyte_bigword)
	(floatformats_i387_ext, floatformats_m68881_ext, floatformats_arm_ext)
	(floatformats_ia64_spill, floatformats_ia64_quad, floatformats_vax_f)
	(floatformats_vax_d): New variables.
	(builtin_type_ieee_single, builtin_type_ieee_double)
	(builtin_type_arm_ext, builtin_type_ia64_spill)
	(builtin_type_ia64_quad): Replace arrays with individual types.
	(builtin_type_ieee_single_big, builtin_type_ieee_single_little)
	(builtin_type_ieee_double_big, builtin_type_ieee_double_little)
	(builtin_type_ieee_double_littlebyte_bigword, builtin_type_i960_ext)
	(builtin_type_m88110_ext, builtin_type_m88110_harris_ext)
	(builtin_type_arm_ext_big, builtin_type_arm_ext_littlebyte_bigword)
	(builtin_type_ia64_spill_big, builtin_type_ia64_spill_little)
	(builtin_type_ia64_quad_big, builtin_type_ia64_quad_little): Delete
	unused and endian-specific types.
	(recursive_dump_type): Update for floatformat pairs.
	(build_flt): Move higher.  Handle bit == -1.  Take a floatformat pair.
	(build_gdbtypes): Use build_flt.
	(_initialize_gdbtypes): Update set of initialized types.
	* gdbtypes.h: Update declarations to match gdbtypes.c.
	(struct main_type): Store a pointer to two floatformats.
	* arch-utils.c (default_float_format, default_double_format): Delete.
	* arch-utils.h (default_float_format, default_double_format): Delete.

	* arm-tdep.c, avr-tdep.c, hppa-tdep.c, hppabsd-tdep.c, i386-tdep.c,
	ia64-tdep.c,  iq2000-tdep.c, m68k-tdep.c, m88k-tdep.c,
	mips-linux-tdep.c, mips-tdep.c, mt-tdep.c, ppcobsd-tdep.c,
	sparc-linux-tdep.c, sparc-tdep.c, sparcnbsd-tdep.c, spu-tdep.c,
	vax-tdep.c, alpha-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d54 1
a54 1
  const CORE_ADDR saved_sp = read_sp ();
d58 2
d583 1
a583 4
  /* By this stage in the proceedings, SP has been decremented by "red
     zone size" + "struct return size".  Fetch the stack-pointer from
     before this and use that as the BACK_CHAIN.  */
  const CORE_ADDR back_chain = read_sp ();
d601 5
@


1.34
log
@Copyright updates for 2007.
@
text
@d135 2
a136 13
		      struct type *memtype;
		      switch (TARGET_BYTE_ORDER)
			{
			case BFD_ENDIAN_BIG:
			  memtype = builtin_type_ieee_double_big;
			  break;
			case BFD_ENDIAN_LITTLE:
			  memtype = builtin_type_ieee_double_little;
			  break;
			default:
			  internal_error (__FILE__, __LINE__, _("bad switch"));
			}
		      convert_typed_floating (val, type, memval, memtype);
@


1.33
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d4 1
a4 1
   Copyright (C) 2000, 2001, 2002, 2003, 2005
@


1.32
log
@2005-10-24  Paul Gilliam  <pgilliam@@us.ibm.com

	* ppc-sysv-tdep.c (ppc64_sysv_abi_return_value): Copy code from
	ppc_sysv_abi_return_value() to handle a vector return value.
@
text
@d4 1
a4 1
   Copyright 2000, 2001, 2002, 2003, 2005
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.31
log
@* ppc-sysv-tdep.c (do_ppc_sysv_return_value): Fix the code that
deals with the broken GCC convention.
@
text
@d909 1
a913 1
      /* Integers in r3.  */
d941 2
a942 4
  if (TYPE_CODE (valtype) == TYPE_CODE_ARRAY
      && TYPE_LENGTH (valtype) <= 8
      && TYPE_CODE (TYPE_TARGET_TYPE (valtype)) == TYPE_CODE_INT
      && TYPE_LENGTH (TYPE_TARGET_TYPE (valtype)) == 1)
d945 24
a968 9
      int offset = (register_size (gdbarch, tdep->ppc_gp0_regnum + 3)
		    - TYPE_LENGTH (valtype));
      if (writebuf != NULL)
	regcache_cooked_write_part (regcache, tdep->ppc_gp0_regnum + 3,
				    offset, TYPE_LENGTH (valtype), writebuf);
      if (readbuf != NULL)
	regcache_cooked_read_part (regcache, tdep->ppc_gp0_regnum + 3,
				   offset, TYPE_LENGTH (valtype), readbuf);
      return RETURN_VALUE_REGISTER_CONVENTION;
d971 1
a971 1
     point registers.  */
@


1.31.4.1
log
@2005-11-14  Paul Gilliam  <pgilliam@@us.ibm.com>

        * ppc-sysv-tdep.c (ppc64_sysv_abi_return_value): Copy code from
        ppc_sysv_abi_return_value() to handle a vector return value.
@
text
@a908 1
  /* Integers in r3.  */
d913 1
d941 4
a944 2
  /* Array type has more than one use.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_ARRAY)
d947 9
a955 23
      if (TYPE_LENGTH (valtype) <= 8
        && TYPE_CODE (TYPE_TARGET_TYPE (valtype)) == TYPE_CODE_INT
        && TYPE_LENGTH (TYPE_TARGET_TYPE (valtype)) == 1)
        {
          int offset = (register_size (gdbarch, tdep->ppc_gp0_regnum + 3)
		        - TYPE_LENGTH (valtype));
          if (writebuf != NULL)
	    regcache_cooked_write_part (regcache, tdep->ppc_gp0_regnum + 3,
				       offset, TYPE_LENGTH (valtype), writebuf);
          if (readbuf != NULL)
	    regcache_cooked_read_part (regcache, tdep->ppc_gp0_regnum + 3,
				       offset, TYPE_LENGTH (valtype), readbuf);
          return RETURN_VALUE_REGISTER_CONVENTION;
        }
      /* A VMX vector is returned in v2.  */
      if (TYPE_VECTOR (valtype) && tdep->ppc_vr0_regnum >= 0)
	{
	  if (readbuf)
	    regcache_cooked_read (regcache, tdep->ppc_vr0_regnum + 2, readbuf);
	  if (writebuf)
	    regcache_cooked_write (regcache, tdep->ppc_vr0_regnum + 2, writebuf);
	  return RETURN_VALUE_REGISTER_CONVENTION;
	}
d958 1
a958 1
     point registers, starting with F1.  */
@


1.30
log
@* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Set condition
register appropriately for varargs functions.
@
text
@d454 7
d463 6
a468 20
	  /* GCC screwed up.  The last register isn't "left" aligned.
	     Need to extract the least significant part of each
	     register and then store that.  */
	  /* Transfer any full words.  */
	  int word = 0;
	  while (1)
	    {
	      ULONGEST reg;
	      int len = TYPE_LENGTH (type) - word * tdep->wordsize;
	      if (len <= 0)
		break;
	      if (len > tdep->wordsize)
		len = tdep->wordsize;
	      regcache_cooked_read_unsigned (regcache,
					     tdep->ppc_gp0_regnum + 3 + word,
					     &reg);
	      store_unsigned_integer (((bfd_byte *) readbuf
				       + word * tdep->wordsize), len, reg);
	      word++;
	    }
d472 7
a478 20
	  /* GCC screwed up.  The last register isn't "left" aligned.
	     Need to extract the least significant part of each
	     register and then store that.  */
	  /* Transfer any full words.  */
	  int word = 0;
	  while (1)
	    {
	      ULONGEST reg;
	      int len = TYPE_LENGTH (type) - word * tdep->wordsize;
	      if (len <= 0)
		break;
	      if (len > tdep->wordsize)
		len = tdep->wordsize;
	      reg = extract_unsigned_integer (((const bfd_byte *) writebuf
					       + word * tdep->wordsize), len);
	      regcache_cooked_write_unsigned (regcache,
					      tdep->ppc_gp0_regnum + 3 + word,
					      reg);
	      word++;
	    }
d480 1
@


1.29
log
@2005-05-24  Andrew Cagney  <cagney@@gnu.org>

	* rs6000-tdep.c (ppc_supply_reg, ppc_collect_reg): Use gdb_byte
	for byte buffers.
	(rs6000_fetch_pointer_argument): Use get_frame_register_unsigned.
	(rs6000_software_single_step, sstep_breaks, skip_prologue)
	(rs6000_push_dummy_call, rs6000_push_dummy_call)
	(rs6000_push_dummy_call, rs6000_push_dummy_call)
	(rs6000_register_to_value, e500_pseudo_register_read)
	(rs6000_store_return_value, e500_pseudo_register_write)
	(rs6000_frame_prev_register, rs6000_extract_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc_sysv_abi_push_dummy_call, do_ppc_sysv_return_value)
	(do_ppc_sysv_return_value, ppc_sysv_abi_return_value)
	(ppc_sysv_abi_broken_return_value)
	(ppc64_sysv_abi_push_dummy_call, ppc64_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call, ppc64_sysv_abi_return_value)
	(ppc64_sysv_abi_return_value, ppc64_sysv_abi_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_in_sigtramp)
	(ppc_linux_at_sigtramp_return_path)
	(ppc_linux_skip_trampoline_code)
	(ppc_linux_memory_remove_breakpoint, ppc_linux_return_value):
	* rs6000-tdep.c (rs6000_value_to_register)
	(rs6000_register_to_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value)
	(ppc64_sysv_abi_return_value, ppc_sysv_abi_broken_return_value)
	(ppc_linux_memory_remove_breakpoint): Ditto.
@
text
@d4 2
a5 2
   Copyright 2000, 2001, 2002, 2003, 2005 Free Software Foundation,
   Inc.
d298 18
@


1.28
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d117 1
a117 1
		      char regval[MAX_REGISTER_SIZE];
d245 1
a245 1
	      char word[MAX_REGISTER_SIZE];
d343 1
a343 1
	  char regval[MAX_REGISTER_SIZE];
d353 1
a353 1
	  char regval[MAX_REGISTER_SIZE];
d491 1
a491 1
	  char regvals[MAX_REGISTER_SIZE * 2];
d504 1
a504 1
	  char regvals[MAX_REGISTER_SIZE * 2];
d520 2
a521 2
			   struct regcache *regcache, void *readbuf,
			   const void *writebuf)
d531 1
a531 1
				  void *readbuf, const void *writebuf)
d691 1
a691 1
		      char regval[MAX_REGISTER_SIZE];
d710 1
a710 1
		      char regval[MAX_REGISTER_SIZE];
d785 1
a785 1
		      char regval[MAX_REGISTER_SIZE];
d883 2
a884 2
			     struct regcache *regcache, void *readbuf,
			     const void *writebuf)
d896 1
a896 1
      char regval[MAX_REGISTER_SIZE];
d987 1
a987 1
	      char regval[MAX_REGISTER_SIZE];
@


1.27
log
@2005-02-09  Andrew Cagney  <cagney@@gnu.org>

	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call)
	(convert_code_addr_to_desc_addr): Convert any function code
	address to the corresponding function's descriptor.
	(ppc64_sysv_abi_return_value): have TYPE_CODE_ENUM and
	TYPE_CODE_INT use the same code paths as TYPE_CODE_INT.  When
	writing, convert any function code address to the corresponding
	descriptor.
@
text
@d145 1
a145 1
			  internal_error (__FILE__, __LINE__, "bad switch");
@


1.26
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d537 41
d748 2
a749 1
		    || TYPE_CODE (type) == TYPE_CODE_ENUM)
d752 2
a753 2
	      /* Scalars get sign[un]extended and go in gpr3 .. gpr10.
	         They can also end up in memory.  */
d758 9
d819 5
d852 2
a853 6
  /* Find a value for the TOC register.  Every symbol should have both
     ".FN" and "FN" in the minimal symbol table.  "FN" points at the
     FN's descriptor, while ".FN" points at the entry point (which
     matches FUNC_ADDR).  Need to reverse from FUNC_ADDR back to the
     FN's descriptor address (while at the same time being careful to
     find "FN" in the same object file as ".FN").  */
d855 2
a856 4
    /* Find the minimal symbol that corresponds to FUNC_ADDR (should
       have the name ".FN").  */
    struct minimal_symbol *dot_fn = lookup_minimal_symbol_by_pc (func_addr);
    if (dot_fn != NULL && SYMBOL_LINKAGE_NAME (dot_fn)[0] == '.')
d858 6
a863 25
	/* Get the section that contains FUNC_ADR.  Need this for the
           "objfile" that it contains.  */
	struct obj_section *dot_fn_section = find_pc_section (func_addr);
	if (dot_fn_section != NULL && dot_fn_section->objfile != NULL)
	  {
	    /* Now find the corresponding "FN" (dropping ".") minimal
	       symbol's address.  Only look for the minimal symbol in
	       ".FN"'s object file - avoids problems when two object
	       files (i.e., shared libraries) contain a minimal symbol
	       with the same name.  */
	    struct minimal_symbol *fn =
	      lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (dot_fn) + 1, NULL,
				     dot_fn_section->objfile);
	    if (fn != NULL)
	      {
		/* Got the address of that descriptor.  The TOC is the
		   second double word.  */
		CORE_ADDR toc =
		  read_memory_unsigned_integer (SYMBOL_VALUE_ADDRESS (fn)
						+ tdep->wordsize,
						tdep->wordsize);
		regcache_cooked_write_unsigned (regcache,
						tdep->ppc_gp0_regnum + 2, toc);
	      }
	  }
d910 3
a912 1
  if (TYPE_CODE (valtype) == TYPE_CODE_INT && TYPE_LENGTH (valtype) <= 8)
@


1.25
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_TYPE, VALUE_NEXT, VALUE_OFFSET, VALUE_BITSIZE)
	(VALUE_BITPOS): Delete.
	(value_type, value_offset, value_bitsize, value_bitpos): Declare.
	* value.c (value_type, value_offset, value_bitpos)
	(value_bitsize): New functions.  Update references.
	* arm-tdep.c, gnu-v3-abi.c, hpacc-abi.c, gnu-v2-abi.c: Update.
	* f-valprint.c, cp-valprint.c, c-valprint.c: Update.
	* ada-valprint.c, typeprint.c, scm-valprint.c, scm-exp.c: Update.
	* p-valprint.c, jv-valprint.c, jv-lang.c, varobj.c: Update.
	* objc-lang.c, ada-lang.c, std-regs.c, stack.c: Update.
	* infcall.c, linespec.c, printcmd.c, valarith.c: Update.
	* valops.c, eval.c, findvar.c, breakpoint.c: Update.
	* tracepoint.c, ax-gdb.c, mi/mi-main.c, cli/cli-dump.c:
	* rs6000-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d4 2
a5 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d103 1
a103 1
	  char *val = VALUE_CONTENTS (arg);
d639 1
a639 1
	  char *val = VALUE_CONTENTS (arg);
@


1.24
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (PUSH_DUMMY_CALL): Change CORE_ADDR func_addr argument
	to struct value *function.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.
	* infcall.c (call_function_by_hand): Pass entire function value
	to push_dummy_call.

	* Makefile.in (alpha-tdep.o, frv-tdep.o, ia64-tdep.o, mips-tdep.o)
	(ppc-sysv-tdep.o, rs6000-tdep.o): Update dependencies.
	* alpha-tdep.c (alpha_push_dummy_call): Update call signature.
	* amd64-tdep.c (amd64_push_dummy_call): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* avr-tdep.c (avr_push_dummy_call): Likewise.
	* cris-tdep.c (cris_push_dummy_call): Likewise.
	* d10v-tdep.c (d10v_push_dummy_call): Likewise.
	* frv-tdep.c (frv_push_dummy_call): Likewise.
	* h8300-tdep.c (h8300_push_dummy_call): Likewise.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_push_dummy_call): Likewise.
	* i386-tdep.c (i386_push_dummy_call): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	* m68k-tdep.c (m68k_push_dummy_call): Likewise.
	* m88k-tdep.c (m88k_push_dummy_call): Likewise.
	* mips-tdep.c (mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
	* s390-tdep.c (s390_push_dummy_call): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu)
	(sh_push_dummy_call_nofpu): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_call): Likewise.
	* sparc64-tdep.c (sparc64_push_dummy_call): Likewise.
	* vax-tdep.c (vax_push_dummy_call): Likewise.
@
text
@d100 1
a100 1
	  struct type *type = check_typedef (VALUE_TYPE (arg));
d637 1
a637 1
	  struct type *type = check_typedef (VALUE_TYPE (arg));
@


1.23
log
@* ppc-sysv-tdep.c (ppc64_sysv_abi_return_value): Assert that
the given architecture has floating-point registers.
@
text
@d33 1
d47 1
a47 1
ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
d544 1
a544 1
ppc64_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
d549 1
@


1.22
log
@* config/rs6000/tm-rs6000.h (FP0_REGNUM): Document that this
should no longer be used in code specific to the RS6000 and its
derivatives.
* ppc-tdep.h (struct gdbarch_tdep): Add 'ppc_fp0_regnum' member.
* rs6000-tdep.c (rs6000_gdbarch_init): Initialize
tdep->ppc_fp0_regnum.
(ppc_supply_fpregset, ppc_collect_fpregset)
(rs6000_push_dummy_call, rs6000_extract_return_value)
(rs6000_dwarf2_stab_reg_to_regnum, rs6000_store_return_value)
(rs6000_frame_cache): Use tdep->ppc_fp0_regnum instead of
FP0_REGNUM.
* aix-thread.c (supply_fprs, fetch_regs_kernel_thread)
(fill_gprs64, fill_gprs32, fill_fprs, store_regs_kernel_thread):
Same.
* ppc-bdm.c (bdm_ppc_fetch_registers, bdm_ppc_fetch_registers,
bdm_ppc_store_registers): Same.
* ppc-linux-nat.c (ppc_register_u_addr, fetch_register)
(store_register, fill_fpregset): Same.
* ppc-linux-tdep.c (ppc_linux_sigtramp_cache)
(ppc_linux_supply_fpregset): Same.
* ppcnbsd-nat.c (getfpregs_supplies): Same.
* ppcnbsd-tdep.c (ppcnbsd_supply_fpreg, ppcnbsd_fill_fpreg):
Same.
* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
ppc64_sysv_abi_return_value): Same.
* rs6000-nat.c (regmap, fetch_inferior_registers)
(store_inferior_registers, fetch_core_registers): Same.
@
text
@d853 6
@


1.21
log
@2003-11-14  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (ppc-sysv-tdep.o): Update dependencies.
	* ppc-sysv-tdep.c: Include "objfiles.h".
	(ppc64_sysv_abi_push_dummy_call): Provide the
	the FN's objfile when looking for the descriptor.
@
text
@d117 1
a117 1
			= register_type (gdbarch, FP0_REGNUM + freg);
d119 2
a120 1
		      regcache_cooked_write (regcache, FP0_REGNUM + freg,
d342 3
a344 2
	  struct type *regtype = register_type (gdbarch, FP0_REGNUM + 1);
	  regcache_cooked_read (regcache, FP0_REGNUM + 1, regval);
d352 1
a352 1
	  struct type *regtype = register_type (gdbarch, FP0_REGNUM);
d354 1
a354 1
	  regcache_cooked_write (regcache, FP0_REGNUM + 1, regval);
d648 2
a649 2
		      struct type *regtype = register_type (gdbarch,
							    FP0_REGNUM);
d651 2
a652 1
		      regcache_cooked_write (regcache, FP0_REGNUM + freg,
d857 1
a857 1
      struct type *regtype = register_type (gdbarch, FP0_REGNUM);
d861 1
a861 1
	  regcache_cooked_write (regcache, FP0_REGNUM + 1, regval);
d865 1
a865 1
	  regcache_cooked_read (regcache, FP0_REGNUM + 1, regval);
d927 1
a927 1
		regcache_cooked_write (regcache, FP0_REGNUM + 1 + i,
d930 1
a930 1
		regcache_cooked_read (regcache, FP0_REGNUM + 1 + i,
d947 1
a947 1
		register_type (current_gdbarch, FP0_REGNUM);
d953 2
a954 1
		  regcache_cooked_write (regcache, FP0_REGNUM + 1 + i,
d959 3
a961 1
		  regcache_cooked_read (regcache, FP0_REGNUM + 1 + i, regval);
d980 1
a980 1
		regcache_cooked_write (regcache, FP0_REGNUM + 1 + i,
d983 1
a983 1
		regcache_cooked_read (regcache, FP0_REGNUM + 1 + i,
@


1.21.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a32 1
#include "infcall.h"
d46 1
a46 1
ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
d117 1
a117 1
			= register_type (gdbarch, tdep->ppc_fp0_regnum + freg);
d119 1
a119 2
		      regcache_cooked_write (regcache,
                                             tdep->ppc_fp0_regnum + freg,
d341 2
a342 3
	  struct type *regtype = register_type (gdbarch,
                                                tdep->ppc_fp0_regnum + 1);
	  regcache_cooked_read (regcache, tdep->ppc_fp0_regnum + 1, regval);
d350 1
a350 1
	  struct type *regtype = register_type (gdbarch, tdep->ppc_fp0_regnum);
d352 1
a352 1
	  regcache_cooked_write (regcache, tdep->ppc_fp0_regnum + 1, regval);
d541 1
a541 1
ppc64_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
a545 1
  CORE_ADDR func_addr = find_function_addr (function, NULL);
d646 2
a647 2
		      struct type *regtype
                        = register_type (gdbarch, tdep->ppc_fp0_regnum);
d649 1
a649 2
		      regcache_cooked_write (regcache,
                                             tdep->ppc_fp0_regnum + freg,
a849 6

  /* This function exists to support a calling convention that
     requires floating-point registers.  It shouldn't be used on
     processors that lack them.  */
  gdb_assert (ppc_floating_point_unit_p (gdbarch));

d854 1
a854 1
      struct type *regtype = register_type (gdbarch, tdep->ppc_fp0_regnum);
d858 1
a858 1
	  regcache_cooked_write (regcache, tdep->ppc_fp0_regnum + 1, regval);
d862 1
a862 1
	  regcache_cooked_read (regcache, tdep->ppc_fp0_regnum + 1, regval);
d924 1
a924 1
		regcache_cooked_write (regcache, tdep->ppc_fp0_regnum + 1 + i,
d927 1
a927 1
		regcache_cooked_read (regcache, tdep->ppc_fp0_regnum + 1 + i,
d944 1
a944 1
		register_type (current_gdbarch, tdep->ppc_fp0_regnum);
d950 1
a950 2
		  regcache_cooked_write (regcache,
                                         tdep->ppc_fp0_regnum + 1 + i,
d955 1
a955 3
		  regcache_cooked_read (regcache,
                                        tdep->ppc_fp0_regnum + 1 + i,
                                        regval);
d974 1
a974 1
		regcache_cooked_write (regcache, tdep->ppc_fp0_regnum + 1 + i,
d977 1
a977 1
		regcache_cooked_read (regcache, tdep->ppc_fp0_regnum + 1 + i,
@


1.20
log
@2003-11-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (return_value): Replace "inval" and "outval" with
	"readbuf" and "writebuf".
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* d10v-tdep.c (d10v_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-sysv-tdep.c (do_ppc_sysv_return_value): Ditto.
	(ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* values.c (register_value_being_returned): Update call.
	* stack.c (return_command): Update call.
	* gdbarch.h, gdbarch.c: Re-generate.

Index: gdb/doc/ChangeLog
2003-11-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace the
	return_value method's "inval" and "outval" parameters with
	"readbuf" and "writebuf".
@
text
@d32 1
d794 2
a795 1
     FN's descriptor address.  */
d802 4
a805 6
	/* Now find the corresponding "FN" (dropping ".") minimal
	   symbol's address.  */
	struct minimal_symbol *fn =
	  lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (dot_fn) + 1, NULL,
				 NULL);
	if (fn != NULL)
d807 19
a825 7
	    /* Got the address of that descriptor.  The TOC is the
	       second double word.  */
	    CORE_ADDR toc =
	      read_memory_unsigned_integer (SYMBOL_VALUE_ADDRESS (fn) +
					    tdep->wordsize, tdep->wordsize);
	    regcache_cooked_write_unsigned (regcache,
					    tdep->ppc_gp0_regnum + 2, toc);
@


1.19
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* ppc-linux-tdep.c (ppc_linux_init_abi): When 32-bit GNU/Linux,
	set "return_value" instead of "use_struct_convention".
	(ppc_linux_use_struct_convention): Delete function.
	(ppc_linux_return_value): New function.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): New function.
	(ppc_sysv_abi_broken_return_value): New function.
	(do_ppc_sysv_return_value): Add "gdbarch" parameter.
	(ppc64_sysv_abi_push_dummy_call): Add "gdbarch" parameter, drop
	static.
	(ppc_sysv_abi_extract_return_value): Delete function.
	(ppc_sysv_abi_broken_extract_return_value): Delete function.
	(ppc_sysv_abi_store_return_value): Delete function.
	(ppc_sysv_abi_broken_store_return_value): Delete function.
	(ppc_sysv_abi_use_struct_convention): Delete function.
	(ppc64_sysv_abi_use_struct_convention): Delete function.
	(ppc64_sysv_abi_extract_return_value): Delete function.
	(ppc64_sysv_abi_store_return_value): Delete function.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): New function.
	(ppcnbsd_init_abi): Set "return_value", instead of
	"use_struct_convention", "extract_return_value", and
	"store_return_value".
	(ppcnbsd_use_struct_convention): Delete function.
	* ppc-tdep.h (ppc64_sysv_abi_return_value): Declare.
	(ppc_sysv_abi_return_value): Declare.
	(ppc_sysv_abi_broken_return_value): Declare.
	(ppc_sysv_abi_use_struct_convention): Delete.
	(ppc_sysv_abi_store_return_value): Delete.
	(ppc_sysv_abi_extract_return_value): Delete.
	(ppc_sysv_abi_broken_store_return_value): Delete.
	(ppc_sysv_abi_broken_extract_return_value): Delete.
	(ppc64_sysv_abi_use_struct_convention): Delete.
	(ppc64_sysv_abi_extract_return_value): Delete.
	(ppc64_sysv_abi_store_return_value): Delete.
	* rs6000-tdep.c (rs6000_gdbarch_init): For 32-bit and 64-bit SYSV,
	set "return_value" instead of "extract_return_value",
	"store_return_value", and "use_struct_convention".
@
text
@d326 2
a327 2
			  struct regcache *regcache, const void *inval,
			  void *outval, int broken_gcc)
d335 1
a335 1
      if (outval)
d342 1
a342 1
	  convert_typed_floating (regval, regtype, outval, type);
d344 1
a344 1
      if (inval)
d350 1
a350 1
	  convert_typed_floating (inval, type, regval, regtype);
d358 1
a358 1
      if (outval)
d362 1
a362 1
				(bfd_byte *) outval + 0);
d364 1
a364 1
				(bfd_byte *) outval + 4);
d366 1
a366 1
      if (inval)
d370 1
a370 1
				 (bfd_byte *) inval + 0);
d372 1
a372 1
				 (bfd_byte *) inval + 4);
d379 1
a379 1
      if (outval)
d387 1
a387 1
	  store_unsigned_integer (outval, TYPE_LENGTH (type), regval);
d389 1
a389 1
      if (inval)
d394 1
a394 1
					  unpack_long (type, inval));
d402 1
a402 1
      if (outval)
d405 1
a405 1
	  regcache_cooked_read (regcache, tdep->ppc_vr0_regnum + 2, outval);
d407 1
a407 1
      if (inval)
d410 1
a410 1
	  regcache_cooked_write (regcache, tdep->ppc_vr0_regnum + 2, inval);
d423 4
a426 4
      if (outval)
	regcache_cooked_read (regcache, tdep->ppc_ev0_regnum + 3, outval);
      if (inval)
	regcache_cooked_write (regcache, tdep->ppc_ev0_regnum + 3, inval);
d431 1
a431 1
      if (outval)
d449 1
a449 1
	      store_unsigned_integer (((bfd_byte *) outval
d454 1
a454 1
      if (inval)
d469 1
a469 1
	      reg = extract_unsigned_integer (((bfd_byte *) inval
d481 1
a481 1
      if (outval)
d492 1
a492 1
	  memcpy (outval, regvals, TYPE_LENGTH (type));
d494 1
a494 1
      if (inval)
d501 1
a501 1
	  memcpy (regvals, inval, TYPE_LENGTH (type));
d515 2
a516 1
			   struct regcache *regcache, const void *inval, void *outval)
d518 2
a519 1
  return do_ppc_sysv_return_value (gdbarch, valtype, regcache, inval, outval, 0);
d523 4
a526 3
ppc_sysv_abi_broken_return_value (struct gdbarch *gdbarch, struct type *valtype,
				  struct regcache *regcache, const void *inval,
				  void *outval)
d528 2
a529 1
  return do_ppc_sysv_return_value (gdbarch, valtype, regcache, inval, outval, 1);
d828 1
a828 1
   For a return-value stored in a register: when INVAL is non-NULL,
d830 1
a830 1
   location; when OUTVAL is non-NULL, fill the buffer from the
d834 2
a835 2
			     struct regcache *regcache, const void *inval,
			     void *outval)
d843 1
a843 1
      if (inval != NULL)
d845 1
a845 1
	  convert_typed_floating (inval, valtype, regval, regtype);
d848 1
a848 1
      if (outval != NULL)
d851 1
a851 1
	  convert_typed_floating (regval, regtype, outval, valtype);
d858 1
a858 1
      if (inval != NULL)
d862 1
a862 1
					  unpack_long (valtype, inval));
d864 1
a864 1
      if (outval != NULL)
d871 1
a871 1
	  store_unsigned_integer (outval, TYPE_LENGTH (valtype), regval);
d879 4
a882 4
      if (inval != NULL)
	regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 3, inval);
      if (outval != NULL)
	regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 3, outval);
d893 1
a893 1
      if (inval != NULL)
d895 2
a896 2
				    offset, TYPE_LENGTH (valtype), inval);
      if (outval != NULL)
d898 1
a898 1
				   offset, TYPE_LENGTH (valtype), outval);
d906 1
a906 1
      if (inval || outval != NULL)
d911 1
a911 1
	      if (inval != NULL)
d913 2
a914 2
				       (const bfd_byte *) inval + i * 8);
	      if (outval != NULL)
d916 1
a916 1
				      (bfd_byte *) outval + i * 8);
d933 1
a933 1
	      if (inval != NULL)
d935 1
a935 1
		  convert_typed_floating ((const bfd_byte *) inval +
d941 1
a941 1
	      if (outval != NULL)
d945 1
a945 1
					  (bfd_byte *) outval +
d961 1
a961 1
	      if (inval != NULL)
d963 2
a964 2
				       (const bfd_byte *) inval + i * 8);
	      if (outval != NULL)
d966 1
a966 1
				      (bfd_byte *) outval + i * 8);
@


1.18
log
@2003-10-31  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): For 64-bit ABI, set
	adjust_breakpoint_address.
	* Makefile.in (ppc-sysv-tdep.o): Add $(target_h).
	* ppc-tdep.h (ppc64_sysv_abi_adjust_breakpoint_address): Declare.
	* ppc-sysv-tdep.c: Include "target.h".  Update copyright.
	(ppc64_sysv_abi_adjust_breakpoint_address): New function.
@
text
@d325 3
a327 2
do_ppc_sysv_return_value (struct type *type, struct regcache *regcache,
			  const void *inval, void *outval, int broken_gcc)
d329 1
a329 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d333 1
a333 1
      && ppc_floating_point_unit_p (current_gdbarch))
d340 1
a340 2
	  struct type *regtype = register_type (current_gdbarch,
						FP0_REGNUM + 1);
d349 1
a349 1
	  struct type *regtype = register_type (current_gdbarch, FP0_REGNUM);
d513 3
a515 26
void
ppc_sysv_abi_extract_return_value (struct type *type,
				   struct regcache *regcache, void *valbuf)
{
  do_ppc_sysv_return_value (type, regcache, NULL, valbuf, 0);
}

void
ppc_sysv_abi_broken_extract_return_value (struct type *type,
					  struct regcache *regcache,
					  void *valbuf)
{
  do_ppc_sysv_return_value (type, regcache, NULL, valbuf, 1);
}

void
ppc_sysv_abi_store_return_value (struct type *type, struct regcache *regcache,
				 const void *valbuf)
{
  do_ppc_sysv_return_value (type, regcache, valbuf, NULL, 0);
}

void
ppc_sysv_abi_broken_store_return_value (struct type *type,
					struct regcache *regcache,
					const void *valbuf)
d517 1
a517 1
  do_ppc_sysv_return_value (type, regcache, valbuf, NULL, 1);
d520 4
a523 4
/* Structures 8 bytes or less long are returned in the r3 & r4
   registers, according to the SYSV ABI. */
int
ppc_sysv_abi_use_struct_convention (int gcc_p, struct type *value_type)
d525 1
a525 2
  return (do_ppc_sysv_return_value (value_type, NULL, NULL, NULL, 0)
	  == RETURN_VALUE_STRUCT_CONVENTION);
d828 4
a831 3
static enum return_value_convention
ppc64_sysv_abi_return_value (struct type *valtype, struct regcache *regcache,
			     const void *inval, void *outval)
d833 1
a833 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d838 1
a838 1
      struct type *regtype = register_type (current_gdbarch, FP0_REGNUM);
d887 1
a887 1
      int offset = (register_size (current_gdbarch, tdep->ppc_gp0_regnum + 3)
a967 25
}

int
ppc64_sysv_abi_use_struct_convention (int gcc_p, struct type *value_type)
{
  return (ppc64_sysv_abi_return_value (value_type, NULL, NULL, NULL)
	  == RETURN_VALUE_STRUCT_CONVENTION);
}

void
ppc64_sysv_abi_extract_return_value (struct type *valtype,
				     struct regcache *regbuf, void *valbuf)
{
  if (ppc64_sysv_abi_return_value (valtype, regbuf, NULL, valbuf)
      != RETURN_VALUE_REGISTER_CONVENTION)
    error ("Function return value unknown");
}

void
ppc64_sysv_abi_store_return_value (struct type *valtype,
				   struct regcache *regbuf,
				   const void *valbuf)
{
  if (!ppc64_sysv_abi_return_value (valtype, regbuf, valbuf, NULL))
    error ("Function return value location unknown");
@


1.17
log
@2003-10-20  Andrew Cagney  <cagney@@redhat.com>

	* values.c (register_value_being_returned): Update comments.  Use
	"gdbarch_return_value" when available.
	(using_struct_return): Ditto.
	(set_return_value): Ditto.  Use "gdbarch_return_value" when
	available..  Print a warning, and not an error, when an unhandled
	return type is encountered.
	* infcmd.c: Include "gdb_assert.h".
	(print_return_value): When gdbarch_return_value_p, and using
	struct return, assume that the value is not available.
	* defs.h (return_value_convention): Define.
	* gdbarch.sh (gdbarch_return_value): New predicate method.
	* gdbarch.h, gdbarch.c: Re-generate
	* ppc-sysv-tdep.c (return_value_convention): Delete definition.

Index: doc/ChangeLog
2003-10-20  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Document
	gdbarch_return_value.  Add cross references from
	USE_STRUCT_CONVENTION, EXTRACT_RETURN_VALUE, and
	STORE_RETURN_VALUE, and from/to EXTRACT_STRUCT_VALUE_ADDRESS.
@
text
@d4 1
a4 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
d31 1
d1016 18
@


1.16
log
@2003-10-10  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (e500_store_return_value): Delete function.
	(e500_extract_return_value): Delete function.
	(rs6000_gdbarch_init): When SYSV, set "extract_return_value" and
	"restore_return_value" to "ppc_sysv_abi_extract_return_value" and
	"ppc_sysv_abi_restore_return_value" where applicable.
	* ppc-tdep.h: (ppc_sysv_abi_store_return_value): Declare.
	(ppc_sysv_abi_extract_return_value): Declare.
	(ppc_sysv_abi_broken_store_return_value): Declare.
	(ppc_sysv_abi_broken_extract_return_value): Declare.
	(ppc_sysv_abi_broken_use_struct_convention:) Delete declaration.
	* ppc-sysv-tdep.c (return_value_convention): Move definition to
	start of file.
	(do_ppc_sysv_return_value): New function.
	(ppc_sysv_abi_extract_return_value): New function.
	(ppc_sysv_abi_store_return_value): New function.
	(ppc_sysv_abi_broken_extract_return_value): New function.
	(ppc_sysv_abi_broken_store_return_value): New function.
	(ppc_sysv_abi_use_struct_convention): Call
	do_ppc_sysv_return_value.
@
text
@a307 15
/* Potential ways that a function can return a value of a given type.  */
enum return_value_convention
{
  /* Where the return value has been squeezed into one or more
     registers.  */
  RETURN_VALUE_REGISTER_CONVENTION,
  /* Commonly known as the "struct return convention".  The caller
     passes an additional hidden first parameter to the caller.  That
     parameter contains the address at which the value being returned
     should be stored.  While typically, and historically, used for
     large structs, this is convention is applied to values of many
     different types.  */
  RETURN_VALUE_STRUCT_CONVENTION
};

@


1.15
log
@2003-10-10  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (ppc-sysv-tdep.o): Add $(gdb_assert_h).
	* rs6000-tdep.c (rs6000_gdbarch_init): When 64 bit SysV ABI, set
	push_dummy_call to ppc64_sysv_abi_push_dummy_call.
	* ppc-sysv-tdep.c: Include "gdb_assert.h".
	(ppc64_sysv_abi_push_dummy_call): New function.
	(ppc64_sysv_abi_broken_push_dummy_call): New function.
	* ppc-tdep.h (ppc64_sysv_abi_push_dummy_call): Declare.
	(ppc64_sysv_abi_broken_push_dummy_call): Declare.
@
text
@d308 249
d562 2
a563 5
  if ((TYPE_LENGTH (value_type) == 16 || TYPE_LENGTH (value_type) == 8)
      && TYPE_VECTOR (value_type))
    return 0;

  return (TYPE_LENGTH (value_type) > 8);
a865 16

/* Potential ways that a function can return a value of a given type.  */
enum return_value_convention
{
  /* Where the return value has been squeezed into one or more
     registers.  */
  RETURN_VALUE_REGISTER_CONVENTION,
  /* Commonly known as the "struct return convention".  The caller
     passes an additional hidden first parameter to the caller.  That
     parameter contains the address at which the value being returned
     should be stored.  While typically, and historically, used for
     large structs, this is convention is applied to values of many
     different types.  */
  RETURN_VALUE_STRUCT_CONVENTION
};

@


1.14
log
@2003-10-06  Andrew Cagney  <cagney@@redhat.com>

	* ppc-sysv-tdep.c: Re-indent.
@
text
@d29 1
a29 1

d318 289
@


1.13
log
@2003-10-03  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): When the 64 bit SysV ABI,
	set extract_return_value, store_return_value and
	use_struct_convention to ppc64_sysv_abi_extract_return_value,
	ppc64_sysv_abi_store_return_value and
	ppc64_sysv_abi_use_struct_convention.
	* ppc-tdep.h (ppc64_sysv_abi_extract_return_value): Declare.
	(ppc64_sysv_abi_store_return_value): Declare.
	(ppc64_sysv_abi_use_struct_convention): Declare.
	* ppc-sysv-tdep.c (enum return_value_convention): Define.
	(ppc64_sysv_abi_extract_return_value): New function.
	(ppc64_sysv_abi_store_return_value): New function.
	(ppc64_sysv_abi_use_struct_convention): New function.
	(ppc64_sysv_abi_return_value): New function.
@
text
@d82 3
a84 3
	 (which will be passed in r3) is used for struct return
	 address.  In that case we should advance one word and start
	 from r4 register to copy parameters.  */
d102 1
a102 2
	      && ppc_floating_point_unit_p (current_gdbarch)
	      && len <= 8)
d105 2
a106 2
                 passed in an FP register, when the registers run out,
                 8 byte aligned stack is used.  */
d112 1
a112 1
                         the register's floating-point format.  */
d125 1
a125 1
                     writing them to an 8 byte aligned stack location.  */
d148 2
a149 4
	  else if (len == 8 
		   && (TYPE_CODE (type) == TYPE_CODE_INT /* long long */
		       || (!ppc_floating_point_unit_p (current_gdbarch)
			   && TYPE_CODE (type) == TYPE_CODE_FLT))) /* double */
d152 4
a155 4
                 register pair with the low addressed word in the odd
                 register and the high addressed word in the even
                 register, or when the registers run out an 8 byte
                 aligned stack location.  */
d169 1
a169 2
					   tdep->ppc_gp0_regnum + greg,
					   val);
d191 1
a191 2
		   && TYPE_VECTOR (type)
		   && tdep->ppc_vr0_regnum >= 0)
d194 1
a194 1
                 when that runs out, 16 byte aligned stack location.  */
d199 1
a199 2
					   tdep->ppc_vr0_regnum + vreg,
					   val);
d210 1
a210 1
          else if (len == 8 
d212 2
a213 3
		   && TYPE_VECTOR (type)
		   && tdep->ppc_ev0_regnum >= 0)
            {
d215 8
a222 8
                 that runs out, 8 byte aligned stack location.  Note
                 that since e500 vector and general purpose registers
                 both map onto the same underlying register set, a
                 "greg" and not a "vreg" is consumed here.  A cooked
                 write stores the value in the correct locations
                 within the raw register cache.  */
              if (greg <= 10)
                {
d225 5
a229 6
					   tdep->ppc_ev0_regnum + greg,
					   val);
                  greg++;
                }
              else
                {
d233 3
a235 3
                  argoffset += 8;
                }
            }
d239 1
a239 1
                 "word".  */
d247 1
a247 1
                     aligned stack ... */
d252 1
a252 1
                     passed as the parameter.  */
d265 1
a265 1
                 The words have "4" byte alignment.  */
d270 1
a270 2
					   tdep->ppc_gp0_regnum + greg,
					   word);
d318 1
a318 1
}   
d353 1
a353 2
  if (TYPE_CODE (valtype) == TYPE_CODE_FLT
      && TYPE_LENGTH (valtype) <= 8)
d369 1
a369 2
  if (TYPE_CODE (valtype) == TYPE_CODE_INT
      && TYPE_LENGTH (valtype) <= 8)
d418 1
a418 2
      && (TYPE_LENGTH (valtype) == 16
	  || TYPE_LENGTH (valtype) == 32))
d445 2
a446 1
	      struct type *regtype = register_type (current_gdbarch, FP0_REGNUM);
d449 2
a450 1
		  convert_typed_floating ((const bfd_byte *) inval + i * (TYPE_LENGTH (valtype) / 2),
d452 2
a453 1
		  regcache_cooked_write (regcache, FP0_REGNUM + 1 + i, regval);
d459 2
a460 1
					  (bfd_byte *) outval + i * (TYPE_LENGTH (valtype) / 2),
d468 1
a468 2
  if (TYPE_CODE (valtype) == TYPE_CODE_COMPLEX
      && TYPE_LENGTH (valtype) == 32)
d497 1
a497 2
				     struct regcache *regbuf,
				     void *valbuf)
@


1.12
log
@2003-09-19  Andrew Cagney  <cagney@@redhat.com>

	* utils.c (align_up, align_down): New functions.
	* defs.h (align_up, align_down): Declare.
	* ppc-sysv-tdep.c (align_up, align_down): Delete functions.
	* s390-tdep.c: Replace "round_up" and "round_down" with "align_up"
	and "align_down".
	(round_up, round_down): Delete functions.
	* mips-tdep.c: Replace ROUND_UP and ROUND_DOWN with "align_up" and
	"align_down".
	(ROUND_DOWN, ROUND_UP): Delete macros.
	(mips_dump_tdep): Do not print "ROUND_UP" or "ROUND_DOWN".
	* h8300-tdep.c: Replace "round_up" and "round_down" with
	"align_up" and "align_down".
	(round_up, round_down): Delete macros.
	* frv-tdep.c: Replace ROUND_UP and ROUND_DOWN with "align_up" and
	"align_down".
	(ROUND_UP, ROUND_DOWN): Delete macros.
@
text
@d328 194
@


1.11
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* ppc-linux-tdep.c (ppc_linux_init_abi): Set the 32 bit
	"use_struct_convention" to "ppc_linux_use_struct_convention".
	(ppc_linux_use_struct_convention): New function.
	* rs6000-tdep.c (rs6000_use_struct_convention): New function.
	(rs6000_gdbarch_init): For AIX, set "use_struct_convention" to
	"rs6000_use_struct_convention".
	* ppc-tdep.h (ppc_sysv_abi_broken_use_struct_convention): Delete
	declaration.
	* ppc-sysv-tdep.c (ppc_sysv_abi_broken_use_struct_convention):
	Delete function.
@
text
@a31 15
/* Ensure that X is aligned to an S byte boundary (assuming that S is
   a power of 2) rounding up/down where necessary.  */

static ULONGEST
align_up (ULONGEST x, int s)
{
  return (x + s - 1) & -s;
}

static ULONGEST
align_down (ULONGEST x, int s)
{
  return (x & -s);
}

@


1.10
log
@2003-09-12  Andrew Cagney  <cagney@@redhat.com>

	* ppc-sysv-tdep.c (align_up, align_down): Replace "round2" macro.
	(ppc_sysv_abi_push_dummy_call): Rewrite, use a two pass loop.
@
text
@a331 14
/* Until November 2001, gcc was not complying to the SYSV ABI for 
   returning structures less than or equal to 8 bytes in size.  It was
   returning everything in memory.  When this was corrected, it wasn't
   fixed for native platforms.  */
int     
ppc_sysv_abi_broken_use_struct_convention (int gcc_p, struct type *value_type)
{  
  if ((TYPE_LENGTH (value_type) == 16 || TYPE_LENGTH (value_type) == 8)
      && TYPE_VECTOR (value_type))
    return 0;                            

  return generic_use_struct_convention (gcc_p, value_type);
}

@


1.9
log
@2003-09-11  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_push_dummy_call): Use
	regcache_raw_write_signed to set SP_REGNUM, move the operation to
	near the function's end.
	(rs6000_gdbarch_init): Do not set "deprecated_dummy_write_sp".
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Use
	regcache_raw_write_signed to set SP_REGNUM.
@
text
@d32 2
a33 2
/* round2 rounds x up to the nearest multiple of s assuming that s is a
   power of 2 */
d35 11
a45 2
#undef round2
#define round2(x,s) ((((long) (x) - 1) & ~(long)((s)-1)) + (s))
a63 15
  int argno;
  /* Next available general register for non-float, non-vector arguments. */
  int greg;
  /* Next available floating point register for float arguments. */
  int freg;
  /* Next available vector register for vector arguments. */
  int vreg;
  int argstkspace;
  int structstkspace;
  int argoffset;
  int structoffset;
  struct type *type;
  int len;
  char old_sp_buf[4];
  CORE_ADDR saved_sp;
d65 11
d77 2
a78 16
  greg = 3;
  freg = 1;
  vreg = 2;
  argstkspace = 0;
  structstkspace = 0;

  /* If the function is returning a `struct', then the first word
     (which will be passed in r3) is used for struct return address.
     In that case we should advance one word and start from r4
     register to copy parameters.  */
  if (struct_return)
    {
      regcache_raw_write_signed (regcache, tdep->ppc_gp0_regnum + greg,
				 struct_addr);
      greg++;
    }
d80 1
a80 5
  /* Figure out how much new stack space is required for arguments
     which don't fit in registers.  Unlike the PowerOpen ABI, the
     SysV ABI doesn't reserve any extra space for parameters which
     are put in registers. */
  for (argno = 0; argno < nargs; argno++)
d82 19
a100 6
      struct value *arg = args[argno];
      type = check_typedef (VALUE_TYPE (arg));
      len = TYPE_LENGTH (type);

      if (TYPE_CODE (type) == TYPE_CODE_FLT
          && ppc_floating_point_unit_p (current_gdbarch))
d102 5
a106 10
	  if (freg <= 8)
	    freg++;
	  else
	    {
	      /* SysV ABI converts floats to doubles when placed in
	         memory and requires 8 byte alignment */
	      if (argstkspace & 0x4)
		argstkspace += 4;
	      argstkspace += 8;
	    }
d108 2
a109 4
      else if (len == 8 
               && (TYPE_CODE (type) == TYPE_CODE_INT /* long long */
                   || (!ppc_floating_point_unit_p (current_gdbarch)
                       && TYPE_CODE (type) == TYPE_CODE_FLT))) /* double */
d111 52
a162 6
	  if (greg > 9)
	    {
	      greg = 11;
	      if (argstkspace & 0x4)
		argstkspace += 4;
	      argstkspace += 8;
d164 27
a190 31
	  else
	    {
	      if ((greg & 1) == 0)
		greg++;
	      greg += 2;
	    }
	}
      else if (!TYPE_VECTOR (type))
        {
	  if (len > 4
	      || TYPE_CODE (type) == TYPE_CODE_STRUCT
	      || TYPE_CODE (type) == TYPE_CODE_UNION)
	    {
	      /* Rounding to the nearest multiple of 8 may not be necessary,
		 but it is safe.  Particularly since we don't know the
		 field types of the structure */
	      structstkspace += round2 (len, 8);
	    }
	  if (greg <= 10)
	    greg++;
	  else
	    argstkspace += 4;
    	}
      else
        {
          if (len == 16
	      && TYPE_CODE (type) == TYPE_CODE_ARRAY
	      && TYPE_VECTOR (type))
	    {
	      if (vreg <= 13)
		vreg++;
d193 13
a205 4
		  /* Vector arguments must be aligned to 16 bytes on
                     the stack. */
		  argstkspace += round2 (argstkspace, 16);
		  argstkspace += 16;
d208 4
a211 122
          else if (len == 8 
                   && TYPE_CODE (type) == TYPE_CODE_ARRAY
                   && TYPE_VECTOR (type))
            {
              if (greg <= 10)
                greg++;
              else
                {
                  /* Vector arguments must be aligned to 8 bytes on
                     the stack. */
                  argstkspace += round2 (argstkspace, 8);
                  argstkspace += 8;
                }
            }
	}
    }

  /* Get current SP location */
  saved_sp = read_sp ();

  sp -= argstkspace + structstkspace;

  /* Allocate space for backchain and callee's saved lr */
  sp -= 8;

  /* Make sure that we maintain 16 byte alignment */
  sp &= ~0x0f;

  /* Update %sp before proceeding any further.   */
  regcache_raw_write_signed (regcache, SP_REGNUM, sp);

  /* write the backchain */
  store_unsigned_integer (old_sp_buf, 4, saved_sp);
  write_memory (sp, old_sp_buf, 4);

  argoffset = 8;
  structoffset = argoffset + argstkspace;
  freg = 1;
  greg = 3;
  vreg = 2;

  /* Fill in r3 with the return structure, if any */
  if (struct_return)
    {
      write_register (tdep->ppc_gp0_regnum + greg, struct_addr);
      greg++;
    }

  /* Now fill in the registers and stack... */
  for (argno = 0; argno < nargs; argno++)
    {
      struct value *arg = args[argno];
      char *val = VALUE_CONTENTS (arg);
      type = check_typedef (VALUE_TYPE (arg));
      len = TYPE_LENGTH (type);

      if (TYPE_CODE (type) == TYPE_CODE_FLT
          && ppc_floating_point_unit_p (current_gdbarch))
	{
	  if (freg <= 8)
	    {
	      ULONGEST regval;
	      if (len > 8)
		printf_unfiltered (
				   "Fatal Error: a floating point parameter #%d with a size > 8 is found!\n", argno);
              regval = extract_unsigned_integer (val, len);
              write_register (FP0_REGNUM + freg, regval);
	      freg++;
	    }
	  else
	    {
	      /* SysV ABI converts floats to doubles when placed in
	         memory and requires 8 byte alignment */
	      /* FIXME: Convert floats to doubles */
	      if (argoffset & 0x4)
		argoffset += 4;
	      write_memory (sp + argoffset, val, len);
	      argoffset += 8;
	    }
	}
      else if (len == 8 
               && (TYPE_CODE (type) == TYPE_CODE_INT /* long long */
                   || (!ppc_floating_point_unit_p (current_gdbarch)
                        && TYPE_CODE (type) == TYPE_CODE_FLT))) /* double */
	{
	  if (greg > 9)
	    {
	      greg = 11;
	      if (argoffset & 0x4)
		argoffset += 4;
	      write_memory (sp + argoffset, val, len);
	      argoffset += 8;
	    }
	  else
	    {
	      ULONGEST regval;
	      if ((greg & 1) == 0)
		greg++;
              regval = extract_unsigned_integer (val, 4);
              write_register (tdep->ppc_gp0_regnum + greg, regval);
              regval = extract_unsigned_integer (val + 4, 4);
              write_register (tdep->ppc_gp0_regnum + greg + 1, regval);
	      greg += 2;
	    }
	}
      else if (!TYPE_VECTOR (type))
	{
	  char val_buf[4];
	  if (len > 4
	      || TYPE_CODE (type) == TYPE_CODE_STRUCT
	      || TYPE_CODE (type) == TYPE_CODE_UNION)
	    {
	      write_memory (sp + structoffset, val, len);
	      store_unsigned_integer (val_buf, 4, sp + structoffset);
	      structoffset += round2 (len, 8);
	    }
	  else
	    {
	      memset (val_buf, 0, 4);
	      memcpy (val_buf, val, len);
	    }
	  if (greg <= 10)
d213 2
a214 19
              ULONGEST regval = extract_unsigned_integer (val_buf, 4);
              write_register (tdep->ppc_gp0_regnum + greg, regval);
	      greg++;
	    }
	  else
	    {
	      write_memory (sp + argoffset, val_buf, 4);
	      argoffset += 4;
	    }
	}
      else
	{
	  if (len == 16
	      && TYPE_CODE (type) == TYPE_CODE_ARRAY
	      && TYPE_VECTOR (type))
	    {
	      char *v_val_buf = alloca (16);
	      memset (v_val_buf, 0, 16);
	      memcpy (v_val_buf, val, len);
d217 4
a220 3
		  regcache_cooked_write (current_regcache,
					 tdep->ppc_vr0_regnum + vreg,
					 v_val_buf);
d225 3
a227 1
		  write_memory (sp + argoffset, v_val_buf, 16);
d233 2
a234 1
		   && TYPE_VECTOR (type))
d236 7
a242 3
              char *v_val_buf = alloca (8);
              memset (v_val_buf, 0, 8);
              memcpy (v_val_buf, val, len);
d245 4
a248 3
		  regcache_cooked_write (current_regcache,
					 tdep->ppc_ev0_regnum + greg,
					 v_val_buf);
d253 3
a255 1
                  write_memory (sp + argoffset, v_val_buf, 8);
d259 58
a316 1
        }
d319 6
d327 1
a327 1
  regcache_raw_write_signed (regcache, tdep->ppc_lr_regnum, bp_addr);
a328 1
  target_store_registers (-1);
@


1.8
log
@2003-09-09  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (ppc_push_return_address): Delete function.
	(rs6000_push_dummy_call): Set LR to BP_ADDR.
	(rs6000_gdbarch_init): Do not set deprecated_push_return_address.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Ditto.
@
text
@d192 2
a193 2
  /* Update %sp before proceeding any further */
  write_register (SP_REGNUM, sp);
@


1.7
log
@2003-09-09  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (rs6000_store_struct_return): Delete function.
	(rs6000_push_dummy_call): Store the struct return address.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Ditto.
@
text
@d342 4
@


1.6
log
@2003-09-09  Andrew Cagney  <cagney@@redhat.com>

	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call): Replace
	"ppc_sysv_abi_push_arguments".
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Replace
	"ppc_sysv_abi_push_arguments".
	* rs6000-tdep.c (rs6000_gdbarch_init): Set "push_dummy_call"
	instead of "push_arguments".
	(rs6000_push_dummy_call): Replace "rs6000_push_arguments".
@
text
@d72 1
a72 1
  greg = struct_return ? 4 : 3;
d77 11
@


1.5
log
@2003-05-13  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (store_address): Delete declaration.
	findvar.c (store_address): Delete function.
	* arm-tdep.c (arm_push_dummy_call): Replace store_address with
	store_unsigned_integer.
	* xstormy16-tdep.c (xstormy16_address_to_pointer): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	* sparc-tdep.c (sparc_get_saved_register): Ditto.
	* sh-tdep.c (sh64_get_saved_register): Ditto.
	* rs6000-tdep.c (rs6000_push_arguments): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_arguments): Ditto.
	* mips-tdep.c (mips_eabi_push_arguments): Ditto.
	(mips_get_saved_register): Ditto.
	* ia64-tdep.c (ia64_get_saved_register): Ditto.
	(find_func_descr, ia64_push_arguments): Ditto.
	* i386-tdep.c (i386_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	* frv-tdep.c (frv_push_arguments): Ditto.
	* frame.c (legacy_saved_regs_prev_register): Ditto.
	(deprecated_generic_get_saved_register): Ditto.
	* findvar.c (unsigned_address_to_pointer): Ditto.
	* dwarf2read.c (dwarf2_const_value): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_push_arguments): Ditto.
@
text
@d50 4
a53 2
ppc_sysv_abi_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
			     int struct_return, CORE_ADDR struct_addr)
@


1.4
log
@2003-03-17  Andrew Cagney  <cagney@@redhat.com>

	* rs6000-tdep.c (ppc_floating_point_unit_p): New function.
	* ppc-tdep.h (ppc_floating_point_unit_p): Declare.

	From Elena Zannoni  <ezannoni@@redhat.com>
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_arguments): Handle e500
	vector and floating-point parameters.
	(ppc_sysv_abi_use_struct_convention): Handle e500 struct return
	convention.
	(ppc_sysv_abi_broken_use_struct_convention): Ditto.
@
text
@d183 1
a183 1
  store_address (old_sp_buf, 4, saved_sp);
d264 1
a264 1
	      store_address (val_buf, 4, sp + structoffset);
@


1.4.12.1
log
@Snap const char * mess.
@
text
@d183 1
a183 1
  store_unsigned_integer (old_sp_buf, 4, saved_sp);
d264 1
a264 1
	      store_unsigned_integer (val_buf, 4, sp + structoffset);
@


1.4.8.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d183 1
a183 1
  store_unsigned_integer (old_sp_buf, 4, saved_sp);
d264 1
a264 1
	      store_unsigned_integer (val_buf, 4, sp + structoffset);
@


1.3
log
@2002-11-14  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_registers): Rename registers.
	* a68v-nat.c, alpha-nat.c, arch-utils.c, core-sol2.c: Update.
	* hp300ux-nat.c, hppab-nat.c, hppah-nat.c: Update.
	* hppam3-nat.c, hpux-thread.c, i386gnu-nat.c: Update.
	* ia64-aix-nat.c, ia64-linux-nat.c, ia64-tdep.c: Update.
	* irix4-nat.c, irix5-nat.c, lynx-nat.c, m68k-tdep.c: Update.
	* m68knbsd-nat.c, mips-linux-tdep.c, mipsm3-nat.c: Update.
	* mipsv4-nat.c, ns32knbsd-nat.c, ppc-bdm.c: Update.
	* ppc-sysv-tdep.c, ptx4-nat.c, regcache.c, remote-es.c: Update.
	* remote-sds.c, remote-vx68.c, remote-vxmips.c: Update.
	* remote-vxsparc.c, rs6000-tdep.c, sol-thread.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, symm-nat.c: Update.
	* v850ice.c: Update.
@
text
@a63 1
  struct value *arg;
d68 1
d82 1
a82 1
      arg = args[argno];
d86 2
a87 1
      if (TYPE_CODE (type) == TYPE_CODE_FLT)
d100 4
a103 1
      else if (TYPE_CODE (type) == TYPE_CODE_INT && len == 8)	/* long long */
d151 14
d191 1
d195 1
a195 3
      char val_buf[4];
      store_address (val_buf, 4, struct_addr);
      memcpy (&deprecated_registers[REGISTER_BYTE (greg)], val_buf, 4);
d198 1
d202 2
a203 1
      arg = args[argno];
d207 2
a208 1
      if (TYPE_CODE (type) == TYPE_CODE_FLT)
d212 1
d216 2
a217 2
	      memcpy (&deprecated_registers[REGISTER_BYTE (FP0_REGNUM + freg)],
		      VALUE_CONTENTS (arg), len);
d227 1
a227 1
	      write_memory (sp + argoffset, (char *) VALUE_CONTENTS (arg), len);
d231 4
a234 1
      else if (TYPE_CODE (type) == TYPE_CODE_INT && len == 8)	/* long long */
d241 1
a241 1
	      write_memory (sp + argoffset, (char *) VALUE_CONTENTS (arg), len);
d246 1
d249 4
a252 5

	      memcpy (&deprecated_registers[REGISTER_BYTE (greg)],
		      VALUE_CONTENTS (arg), 4);
	      memcpy (&deprecated_registers[REGISTER_BYTE (greg + 1)],
		      VALUE_CONTENTS (arg) + 4, 4);
d263 1
a263 1
	      write_memory (sp + structoffset, VALUE_CONTENTS (arg), len);
d270 1
a270 1
	      memcpy (val_buf, VALUE_CONTENTS (arg), len);
d274 2
a275 1
	      memcpy (&deprecated_registers[REGISTER_BYTE (greg)], val_buf, 4);
a289 1
	      struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d292 1
a292 1
	      memcpy (v_val_buf, VALUE_CONTENTS (arg), len);
d295 3
a297 3
		  memcpy (&deprecated_registers[REGISTER_BYTE (tdep->ppc_vr0_regnum
						    + vreg)],
			  v_val_buf, 16);
d306 20
d340 1
a340 1
  if (TYPE_LENGTH (value_type) == 16 
d352 1
a352 1
  if (TYPE_LENGTH (value_type) == 16
@


1.2
log
@2002-09-30  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (ppc-sysv-tdep.o): Depend on gdb_string_h.
	* ppc-sysv-tdep.c: #include "gdb_string.h".
	* remote-sds.c (getmessage): Add semicolon after 'retry' label to
	pacify GCC.
@
text
@d178 1
a178 1
      memcpy (&registers[REGISTER_BYTE (greg)], val_buf, 4);
d195 1
a195 1
	      memcpy (&registers[REGISTER_BYTE (FP0_REGNUM + freg)],
d225 1
a225 1
	      memcpy (&registers[REGISTER_BYTE (greg)],
d227 1
a227 1
	      memcpy (&registers[REGISTER_BYTE (greg + 1)],
d250 1
a250 1
	      memcpy (&registers[REGISTER_BYTE (greg)], val_buf, 4);
d271 1
a271 1
		  memcpy (&registers[REGISTER_BYTE (tdep->ppc_vr0_regnum
@


1.2.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d4 1
a4 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d29 1
a29 1
#include "gdb_assert.h"
d31 6
a36 2
#include "target.h"
#include "objfiles.h"
d50 2
a51 4
ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			      struct regcache *regcache, CORE_ADDR bp_addr,
			      int nargs, struct value **args, CORE_ADDR sp,
			      int struct_return, CORE_ADDR struct_addr)
d53 32
a84 15
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  const CORE_ADDR saved_sp = read_sp ();
  int argspace = 0;		/* 0 is an initial wrong guess.  */
  int write_pass;

  /* Go through the argument list twice.

     Pass 1: Figure out how much new stack space is required for
     arguments and pushed values.  Unlike the PowerOpen ABI, the SysV
     ABI doesn't reserve any extra space for parameters which are put
     in registers, but does always push structures and then pass their
     address.

     Pass 2: Replay the same computation but this time also write the
     values out to the target.  */
d86 1
a86 21
  for (write_pass = 0; write_pass < 2; write_pass++)
    {
      int argno;
      /* Next available floating point register for float and double
         arguments.  */
      int freg = 1;
      /* Next available general register for non-float, non-vector
         arguments.  */
      int greg = 3;
      /* Next available vector register for vector arguments.  */
      int vreg = 2;
      /* Arguments start above the "LR save word" and "Back chain".  */
      int argoffset = 2 * tdep->wordsize;
      /* Structures start after the arguments.  */
      int structoffset = argoffset + argspace;

      /* If the function is returning a `struct', then the first word
         (which will be passed in r3) is used for struct return
         address.  In that case we should advance one word and start
         from r4 register to copy parameters.  */
      if (struct_return)
d88 10
a97 5
	  if (write_pass)
	    regcache_cooked_write_signed (regcache,
					  tdep->ppc_gp0_regnum + greg,
					  struct_addr);
	  greg++;
d99 1
a99 2

      for (argno = 0; argno < nargs; argno++)
d101 1
a101 54
	  struct value *arg = args[argno];
	  struct type *type = check_typedef (VALUE_TYPE (arg));
	  int len = TYPE_LENGTH (type);
	  char *val = VALUE_CONTENTS (arg);

	  if (TYPE_CODE (type) == TYPE_CODE_FLT
	      && ppc_floating_point_unit_p (current_gdbarch) && len <= 8)
	    {
	      /* Floating point value converted to "double" then
	         passed in an FP register, when the registers run out,
	         8 byte aligned stack is used.  */
	      if (freg <= 8)
		{
		  if (write_pass)
		    {
		      /* Always store the floating point value using
		         the register's floating-point format.  */
		      char regval[MAX_REGISTER_SIZE];
		      struct type *regtype
			= register_type (gdbarch, FP0_REGNUM + freg);
		      convert_typed_floating (val, type, regval, regtype);
		      regcache_cooked_write (regcache, FP0_REGNUM + freg,
					     regval);
		    }
		  freg++;
		}
	      else
		{
		  /* SysV ABI converts floats to doubles before
		     writing them to an 8 byte aligned stack location.  */
		  argoffset = align_up (argoffset, 8);
		  if (write_pass)
		    {
		      char memval[8];
		      struct type *memtype;
		      switch (TARGET_BYTE_ORDER)
			{
			case BFD_ENDIAN_BIG:
			  memtype = builtin_type_ieee_double_big;
			  break;
			case BFD_ENDIAN_LITTLE:
			  memtype = builtin_type_ieee_double_little;
			  break;
			default:
			  internal_error (__FILE__, __LINE__, "bad switch");
			}
		      convert_typed_floating (val, type, memval, memtype);
		      write_memory (sp + argoffset, val, len);
		    }
		  argoffset += 8;
		}
	    }
	  else if (len == 8 && (TYPE_CODE (type) == TYPE_CODE_INT	/* long long */
				|| (!ppc_floating_point_unit_p (current_gdbarch) && TYPE_CODE (type) == TYPE_CODE_FLT)))	/* double */
d103 4
a106 37
	      /* "long long" or "double" passed in an odd/even
	         register pair with the low addressed word in the odd
	         register and the high addressed word in the even
	         register, or when the registers run out an 8 byte
	         aligned stack location.  */
	      if (greg > 9)
		{
		  /* Just in case GREG was 10.  */
		  greg = 11;
		  argoffset = align_up (argoffset, 8);
		  if (write_pass)
		    write_memory (sp + argoffset, val, len);
		  argoffset += 8;
		}
	      else if (tdep->wordsize == 8)
		{
		  if (write_pass)
		    regcache_cooked_write (regcache,
					   tdep->ppc_gp0_regnum + greg, val);
		  greg += 1;
		}
	      else
		{
		  /* Must start on an odd register - r3/r4 etc.  */
		  if ((greg & 1) == 0)
		    greg++;
		  if (write_pass)
		    {
		      regcache_cooked_write (regcache,
					     tdep->ppc_gp0_regnum + greg + 0,
					     val + 0);
		      regcache_cooked_write (regcache,
					     tdep->ppc_gp0_regnum + greg + 1,
					     val + 4);
		    }
		  greg += 2;
		}
d108 1
a108 3
	  else if (len == 16
		   && TYPE_CODE (type) == TYPE_CODE_ARRAY
		   && TYPE_VECTOR (type) && tdep->ppc_vr0_regnum >= 0)
d110 15
a124 42
	      /* Vector parameter passed in an Altivec register, or
	         when that runs out, 16 byte aligned stack location.  */
	      if (vreg <= 13)
		{
		  if (write_pass)
		    regcache_cooked_write (current_regcache,
					   tdep->ppc_vr0_regnum + vreg, val);
		  vreg++;
		}
	      else
		{
		  argoffset = align_up (argoffset, 16);
		  if (write_pass)
		    write_memory (sp + argoffset, val, 16);
		  argoffset += 16;
		}
	    }
	  else if (len == 8
		   && TYPE_CODE (type) == TYPE_CODE_ARRAY
		   && TYPE_VECTOR (type) && tdep->ppc_ev0_regnum >= 0)
	    {
	      /* Vector parameter passed in an e500 register, or when
	         that runs out, 8 byte aligned stack location.  Note
	         that since e500 vector and general purpose registers
	         both map onto the same underlying register set, a
	         "greg" and not a "vreg" is consumed here.  A cooked
	         write stores the value in the correct locations
	         within the raw register cache.  */
	      if (greg <= 10)
		{
		  if (write_pass)
		    regcache_cooked_write (current_regcache,
					   tdep->ppc_ev0_regnum + greg, val);
		  greg++;
		}
	      else
		{
		  argoffset = align_up (argoffset, 8);
		  if (write_pass)
		    write_memory (sp + argoffset, val, 8);
		  argoffset += 8;
		}
d126 2
d129 7
d137 2
a138 35
	      /* Reduce the parameter down to something that fits in a
	         "word".  */
	      char word[MAX_REGISTER_SIZE];
	      memset (word, 0, MAX_REGISTER_SIZE);
	      if (len > tdep->wordsize
		  || TYPE_CODE (type) == TYPE_CODE_STRUCT
		  || TYPE_CODE (type) == TYPE_CODE_UNION)
		{
		  /* Structs and large values are put on an 8 byte
		     aligned stack ... */
		  structoffset = align_up (structoffset, 8);
		  if (write_pass)
		    write_memory (sp + structoffset, val, len);
		  /* ... and then a "word" pointing to that address is
		     passed as the parameter.  */
		  store_unsigned_integer (word, tdep->wordsize,
					  sp + structoffset);
		  structoffset += len;
		}
	      else if (TYPE_CODE (type) == TYPE_CODE_INT)
		/* Sign or zero extend the "int" into a "word".  */
		store_unsigned_integer (word, tdep->wordsize,
					unpack_long (type, val));
	      else
		/* Always goes in the low address.  */
		memcpy (word, val, len);
	      /* Store that "word" in a register, or on the stack.
	         The words have "4" byte alignment.  */
	      if (greg <= 10)
		{
		  if (write_pass)
		    regcache_cooked_write (regcache,
					   tdep->ppc_gp0_regnum + greg, word);
		  greg++;
		}
d141 4
a144 4
		  argoffset = align_up (argoffset, tdep->wordsize);
		  if (write_pass)
		    write_memory (sp + argoffset, word, tdep->wordsize);
		  argoffset += tdep->wordsize;
a147 11

      /* Compute the actual stack space requirements.  */
      if (!write_pass)
	{
	  /* Remember the amount of space needed by the arguments.  */
	  argspace = argoffset;
	  /* Allocate space for both the arguments and the structures.  */
	  sp -= (argoffset + structoffset);
	  /* Ensure that the stack is still 16 byte aligned.  */
	  sp = align_down (sp, 16);
	}
d150 2
a151 2
  /* Update %sp.   */
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);
d153 1
a153 2
  /* Write the backchain (it occupies WORDSIZED bytes).  */
  write_memory_signed_integer (sp, tdep->wordsize, saved_sp);
d155 2
a156 3
  /* Point the inferior function call's return address at the dummy's
     breakpoint.  */
  regcache_cooked_write_signed (regcache, tdep->ppc_lr_regnum, bp_addr);
d158 2
a159 2
  return sp;
}
d161 2
a162 2
/* Handle the return-value conventions specified by the SysV 32-bit
   PowerPC ABI (including all the supplements):
d164 3
a166 2
   no floating-point: floating-point values returned using 32-bit
   general-purpose registers.
d168 7
a174 19
   Altivec: 128-bit vectors returned using vector registers.

   e500: 64-bit vectors returned using the full full 64 bit EV
   register, floating-point values returned using 32-bit
   general-purpose registers.

   GCC (broken): Small struct values right (instead of left) aligned
   when returned in general-purpose registers.  */

static enum return_value_convention
do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *type,
			  struct regcache *regcache, void *readbuf,
			  const void *writebuf, int broken_gcc)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  gdb_assert (tdep->wordsize == 4);
  if (TYPE_CODE (type) == TYPE_CODE_FLT
      && TYPE_LENGTH (type) <= 8
      && ppc_floating_point_unit_p (gdbarch))
d176 4
a179 19
      if (readbuf)
	{
	  /* Floats and doubles stored in "f1".  Convert the value to
	     the required type.  */
	  char regval[MAX_REGISTER_SIZE];
	  struct type *regtype = register_type (gdbarch, FP0_REGNUM + 1);
	  regcache_cooked_read (regcache, FP0_REGNUM + 1, regval);
	  convert_typed_floating (regval, regtype, readbuf, type);
	}
      if (writebuf)
	{
	  /* Floats and doubles stored in "f1".  Convert the value to
	     the register's "double" type.  */
	  char regval[MAX_REGISTER_SIZE];
	  struct type *regtype = register_type (gdbarch, FP0_REGNUM);
	  convert_typed_floating (writebuf, type, regval, regtype);
	  regcache_cooked_write (regcache, FP0_REGNUM + 1, regval);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
d181 2
a182 2
  if ((TYPE_CODE (type) == TYPE_CODE_INT && TYPE_LENGTH (type) == 8)
      || (TYPE_CODE (type) == TYPE_CODE_FLT && TYPE_LENGTH (type) == 8))
d184 5
a188 1
      if (readbuf)
d190 8
a197 92
	  /* A long long, or a double stored in the 32 bit r3/r4.  */
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 3,
				(bfd_byte *) readbuf + 0);
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 4,
				(bfd_byte *) readbuf + 4);
	}
      if (writebuf)
	{
	  /* A long long, or a double stored in the 32 bit r3/r4.  */
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 3,
				 (const bfd_byte *) writebuf + 0);
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 4,
				 (const bfd_byte *) writebuf + 4);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_CODE (type) == TYPE_CODE_INT
      && TYPE_LENGTH (type) <= tdep->wordsize)
    {
      if (readbuf)
	{
	  /* Some sort of integer stored in r3.  Since TYPE isn't
	     bigger than the register, sign extension isn't a problem
	     - just do everything unsigned.  */
	  ULONGEST regval;
	  regcache_cooked_read_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
					 &regval);
	  store_unsigned_integer (readbuf, TYPE_LENGTH (type), regval);
	}
      if (writebuf)
	{
	  /* Some sort of integer stored in r3.  Use unpack_long since
	     that should handle any required sign extension.  */
	  regcache_cooked_write_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
					  unpack_long (type, writebuf));
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_LENGTH (type) == 16
      && TYPE_CODE (type) == TYPE_CODE_ARRAY
      && TYPE_VECTOR (type) && tdep->ppc_vr0_regnum >= 0)
    {
      if (readbuf)
	{
	  /* Altivec places the return value in "v2".  */
	  regcache_cooked_read (regcache, tdep->ppc_vr0_regnum + 2, readbuf);
	}
      if (writebuf)
	{
	  /* Altivec places the return value in "v2".  */
	  regcache_cooked_write (regcache, tdep->ppc_vr0_regnum + 2, writebuf);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_LENGTH (type) == 8
      && TYPE_CODE (type) == TYPE_CODE_ARRAY
      && TYPE_VECTOR (type) && tdep->ppc_ev0_regnum >= 0)
    {
      /* The e500 ABI places return values for the 64-bit DSP types
	 (__ev64_opaque__) in r3.  However, in GDB-speak, ev3
	 corresponds to the entire r3 value for e500, whereas GDB's r3
	 only corresponds to the least significant 32-bits.  So place
	 the 64-bit DSP type's value in ev3.  */
      if (readbuf)
	regcache_cooked_read (regcache, tdep->ppc_ev0_regnum + 3, readbuf);
      if (writebuf)
	regcache_cooked_write (regcache, tdep->ppc_ev0_regnum + 3, writebuf);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (broken_gcc && TYPE_LENGTH (type) <= 8)
    {
      if (readbuf)
	{
	  /* GCC screwed up.  The last register isn't "left" aligned.
	     Need to extract the least significant part of each
	     register and then store that.  */
	  /* Transfer any full words.  */
	  int word = 0;
	  while (1)
	    {
	      ULONGEST reg;
	      int len = TYPE_LENGTH (type) - word * tdep->wordsize;
	      if (len <= 0)
		break;
	      if (len > tdep->wordsize)
		len = tdep->wordsize;
	      regcache_cooked_read_unsigned (regcache,
					     tdep->ppc_gp0_regnum + 3 + word,
					     &reg);
	      store_unsigned_integer (((bfd_byte *) readbuf
				       + word * tdep->wordsize), len, reg);
	      word++;
d199 20
a218 22
	}
      if (writebuf)
	{
	  /* GCC screwed up.  The last register isn't "left" aligned.
	     Need to extract the least significant part of each
	     register and then store that.  */
	  /* Transfer any full words.  */
	  int word = 0;
	  while (1)
	    {
	      ULONGEST reg;
	      int len = TYPE_LENGTH (type) - word * tdep->wordsize;
	      if (len <= 0)
		break;
	      if (len > tdep->wordsize)
		len = tdep->wordsize;
	      reg = extract_unsigned_integer (((const bfd_byte *) writebuf
					       + word * tdep->wordsize), len);
	      regcache_cooked_write_unsigned (regcache,
					      tdep->ppc_gp0_regnum + 3 + word,
					      reg);
	      word++;
d220 4
a223 36
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_LENGTH (type) <= 8)
    {
      if (readbuf)
	{
	  /* This matches SVr4 PPC, it does not match GCC.  */
	  /* The value is right-padded to 8 bytes and then loaded, as
	     two "words", into r3/r4.  */
	  char regvals[MAX_REGISTER_SIZE * 2];
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 3,
				regvals + 0 * tdep->wordsize);
	  if (TYPE_LENGTH (type) > tdep->wordsize)
	    regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 4,
				  regvals + 1 * tdep->wordsize);
	  memcpy (readbuf, regvals, TYPE_LENGTH (type));
	}
      if (writebuf)
	{
	  /* This matches SVr4 PPC, it does not match GCC.  */
	  /* The value is padded out to 8 bytes and then loaded, as
	     two "words" into r3/r4.  */
	  char regvals[MAX_REGISTER_SIZE * 2];
	  memset (regvals, 0, sizeof regvals);
	  memcpy (regvals, writebuf, TYPE_LENGTH (type));
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 3,
				 regvals + 0 * tdep->wordsize);
	  if (TYPE_LENGTH (type) > tdep->wordsize)
	    regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 4,
				   regvals + 1 * tdep->wordsize);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  return RETURN_VALUE_STRUCT_CONVENTION;
}
d225 33
a257 88
enum return_value_convention
ppc_sysv_abi_return_value (struct gdbarch *gdbarch, struct type *valtype,
			   struct regcache *regcache, void *readbuf,
			   const void *writebuf)
{
  return do_ppc_sysv_return_value (gdbarch, valtype, regcache, readbuf,
				   writebuf, 0);
}

enum return_value_convention
ppc_sysv_abi_broken_return_value (struct gdbarch *gdbarch,
				  struct type *valtype,
				  struct regcache *regcache,
				  void *readbuf, const void *writebuf)
{
  return do_ppc_sysv_return_value (gdbarch, valtype, regcache, readbuf,
				   writebuf, 1);
}

/* Pass the arguments in either registers, or in the stack. Using the
   ppc 64 bit SysV ABI.

   This implements a dumbed down version of the ABI.  It always writes
   values to memory, GPR and FPR, even when not necessary.  Doing this
   greatly simplifies the logic. */

CORE_ADDR
ppc64_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
				struct regcache *regcache, CORE_ADDR bp_addr,
				int nargs, struct value **args, CORE_ADDR sp,
				int struct_return, CORE_ADDR struct_addr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  /* By this stage in the proceedings, SP has been decremented by "red
     zone size" + "struct return size".  Fetch the stack-pointer from
     before this and use that as the BACK_CHAIN.  */
  const CORE_ADDR back_chain = read_sp ();
  /* See for-loop comment below.  */
  int write_pass;
  /* Size of the Altivec's vector parameter region, the final value is
     computed in the for-loop below.  */
  LONGEST vparam_size = 0;
  /* Size of the general parameter region, the final value is computed
     in the for-loop below.  */
  LONGEST gparam_size = 0;
  /* Kevin writes ... I don't mind seeing tdep->wordsize used in the
     calls to align_up(), align_down(), etc.  because this makes it
     easier to reuse this code (in a copy/paste sense) in the future,
     but it is a 64-bit ABI and asserting that the wordsize is 8 bytes
     at some point makes it easier to verify that this function is
     correct without having to do a non-local analysis to figure out
     the possible values of tdep->wordsize.  */
  gdb_assert (tdep->wordsize == 8);

  /* Go through the argument list twice.

     Pass 1: Compute the function call's stack space and register
     requirements.

     Pass 2: Replay the same computation but this time also write the
     values out to the target.  */

  for (write_pass = 0; write_pass < 2; write_pass++)
    {
      int argno;
      /* Next available floating point register for float and double
         arguments.  */
      int freg = 1;
      /* Next available general register for non-vector (but possibly
         float) arguments.  */
      int greg = 3;
      /* Next available vector register for vector arguments.  */
      int vreg = 2;
      /* The address, at which the next general purpose parameter
         (integer, struct, float, ...) should be saved.  */
      CORE_ADDR gparam;
      /* Address, at which the next Altivec vector parameter should be
         saved.  */
      CORE_ADDR vparam;

      if (!write_pass)
	{
	  /* During the first pass, GPARAM and VPARAM are more like
	     offsets (start address zero) than addresses.  That way
	     the accumulate the total stack space each region
	     requires.  */
	  gparam = 0;
	  vparam = 0;
d261 8
a268 81
	  /* Decrement the stack pointer making space for the Altivec
	     and general on-stack parameters.  Set vparam and gparam
	     to their corresponding regions.  */
	  vparam = align_down (sp - vparam_size, 16);
	  gparam = align_down (vparam - gparam_size, 16);
	  /* Add in space for the TOC, link editor double word,
	     compiler double word, LR save area, CR save area.  */
	  sp = align_down (gparam - 48, 16);
	}

      /* If the function is returning a `struct', then there is an
         extra hidden parameter (which will be passed in r3)
         containing the address of that struct..  In that case we
         should advance one word and start from r4 register to copy
         parameters.  This also consumes one on-stack parameter slot.  */
      if (struct_return)
	{
	  if (write_pass)
	    regcache_cooked_write_signed (regcache,
					  tdep->ppc_gp0_regnum + greg,
					  struct_addr);
	  greg++;
	  gparam = align_up (gparam + tdep->wordsize, tdep->wordsize);
	}

      for (argno = 0; argno < nargs; argno++)
	{
	  struct value *arg = args[argno];
	  struct type *type = check_typedef (VALUE_TYPE (arg));
	  char *val = VALUE_CONTENTS (arg);
	  if (TYPE_CODE (type) == TYPE_CODE_FLT && TYPE_LENGTH (type) <= 8)
	    {
	      /* Floats and Doubles go in f1 .. f13.  They also
	         consume a left aligned GREG,, and can end up in
	         memory.  */
	      if (write_pass)
		{
		  if (ppc_floating_point_unit_p (current_gdbarch)
		      && freg <= 13)
		    {
		      char regval[MAX_REGISTER_SIZE];
		      struct type *regtype = register_type (gdbarch,
							    FP0_REGNUM);
		      convert_typed_floating (val, type, regval, regtype);
		      regcache_cooked_write (regcache, FP0_REGNUM + freg,
					     regval);
		    }
		  if (greg <= 10)
		    {
		      /* The ABI states "Single precision floating
		         point values are mapped to the first word in
		         a single doubleword" and "... floating point
		         values mapped to the first eight doublewords
		         of the parameter save area are also passed in
		         general registers").

		         This code interprets that to mean: store it,
		         left aligned, in the general register.  */
		      char regval[MAX_REGISTER_SIZE];
		      memset (regval, 0, sizeof regval);
		      memcpy (regval, val, TYPE_LENGTH (type));
		      regcache_cooked_write (regcache,
					     tdep->ppc_gp0_regnum + greg,
					     regval);
		    }
		  write_memory (gparam, val, TYPE_LENGTH (type));
		}
	      /* Always consume parameter stack space.  */
	      freg++;
	      greg++;
	      gparam = align_up (gparam + TYPE_LENGTH (type), tdep->wordsize);
	    }
	  else if (TYPE_LENGTH (type) == 16 && TYPE_VECTOR (type)
		   && TYPE_CODE (type) == TYPE_CODE_ARRAY
		   && tdep->ppc_vr0_regnum >= 0)
	    {
	      /* In the Altivec ABI, vectors go in the vector
	         registers v2 .. v13, or when that runs out, a vector
	         annex which goes above all the normal parameters.
	         NOTE: cagney/2003-09-21: This is a guess based on the
	         PowerOpen Altivec ABI.  */
d271 3
a273 3
		  if (write_pass)
		    regcache_cooked_write (regcache,
					   tdep->ppc_vr0_regnum + vreg, val);
d278 2
a279 3
		  if (write_pass)
		    write_memory (vparam, val, TYPE_LENGTH (type));
		  vparam = align_up (vparam + TYPE_LENGTH (type), 16);
d282 1
a282 78
	  else if ((TYPE_CODE (type) == TYPE_CODE_INT
		    || TYPE_CODE (type) == TYPE_CODE_ENUM)
		   && TYPE_LENGTH (type) <= 8)
	    {
	      /* Scalars get sign[un]extended and go in gpr3 .. gpr10.
	         They can also end up in memory.  */
	      if (write_pass)
		{
		  /* Sign extend the value, then store it unsigned.  */
		  ULONGEST word = unpack_long (type, val);
		  if (greg <= 10)
		    regcache_cooked_write_unsigned (regcache,
						    tdep->ppc_gp0_regnum +
						    greg, word);
		  write_memory_unsigned_integer (gparam, tdep->wordsize,
						 word);
		}
	      greg++;
	      gparam = align_up (gparam + TYPE_LENGTH (type), tdep->wordsize);
	    }
	  else
	    {
	      int byte;
	      for (byte = 0; byte < TYPE_LENGTH (type);
		   byte += tdep->wordsize)
		{
		  if (write_pass && greg <= 10)
		    {
		      char regval[MAX_REGISTER_SIZE];
		      int len = TYPE_LENGTH (type) - byte;
		      if (len > tdep->wordsize)
			len = tdep->wordsize;
		      memset (regval, 0, sizeof regval);
		      /* WARNING: cagney/2003-09-21: As best I can
		         tell, the ABI specifies that the value should
		         be left aligned.  Unfortunately, GCC doesn't
		         do this - it instead right aligns even sized
		         values and puts odd sized values on the
		         stack.  Work around that by putting both a
		         left and right aligned value into the
		         register (hopefully no one notices :-^).
		         Arrrgh!  */
		      /* Left aligned (8 byte values such as pointers
		         fill the buffer).  */
		      memcpy (regval, val + byte, len);
		      /* Right aligned (but only if even).  */
		      if (len == 1 || len == 2 || len == 4)
			memcpy (regval + tdep->wordsize - len,
				val + byte, len);
		      regcache_cooked_write (regcache, greg, regval);
		    }
		  greg++;
		}
	      if (write_pass)
		/* WARNING: cagney/2003-09-21: Strictly speaking, this
		   isn't necessary, unfortunately, GCC appears to get
		   "struct convention" parameter passing wrong putting
		   odd sized structures in memory instead of in a
		   register.  Work around this by always writing the
		   value to memory.  Fortunately, doing this
		   simplifies the code.  */
		write_memory (gparam, val, TYPE_LENGTH (type));
	      /* Always consume parameter stack space.  */
	      gparam = align_up (gparam + TYPE_LENGTH (type), tdep->wordsize);
	    }
	}

      if (!write_pass)
	{
	  /* Save the true region sizes ready for the second pass.  */
	  vparam_size = vparam;
	  /* Make certain that the general parameter save area is at
	     least the minimum 8 registers (or doublewords) in size.  */
	  if (greg < 8)
	    gparam_size = 8 * tdep->wordsize;
	  else
	    gparam_size = gparam;
	}
d285 1
a285 50
  /* Update %sp.   */
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);

  /* Write the backchain (it occupies WORDSIZED bytes).  */
  write_memory_signed_integer (sp, tdep->wordsize, back_chain);

  /* Point the inferior function call's return address at the dummy's
     breakpoint.  */
  regcache_cooked_write_signed (regcache, tdep->ppc_lr_regnum, bp_addr);

  /* Find a value for the TOC register.  Every symbol should have both
     ".FN" and "FN" in the minimal symbol table.  "FN" points at the
     FN's descriptor, while ".FN" points at the entry point (which
     matches FUNC_ADDR).  Need to reverse from FUNC_ADDR back to the
     FN's descriptor address (while at the same time being careful to
     find "FN" in the same object file as ".FN").  */
  {
    /* Find the minimal symbol that corresponds to FUNC_ADDR (should
       have the name ".FN").  */
    struct minimal_symbol *dot_fn = lookup_minimal_symbol_by_pc (func_addr);
    if (dot_fn != NULL && SYMBOL_LINKAGE_NAME (dot_fn)[0] == '.')
      {
	/* Get the section that contains FUNC_ADR.  Need this for the
           "objfile" that it contains.  */
	struct obj_section *dot_fn_section = find_pc_section (func_addr);
	if (dot_fn_section != NULL && dot_fn_section->objfile != NULL)
	  {
	    /* Now find the corresponding "FN" (dropping ".") minimal
	       symbol's address.  Only look for the minimal symbol in
	       ".FN"'s object file - avoids problems when two object
	       files (i.e., shared libraries) contain a minimal symbol
	       with the same name.  */
	    struct minimal_symbol *fn =
	      lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (dot_fn) + 1, NULL,
				     dot_fn_section->objfile);
	    if (fn != NULL)
	      {
		/* Got the address of that descriptor.  The TOC is the
		   second double word.  */
		CORE_ADDR toc =
		  read_memory_unsigned_integer (SYMBOL_VALUE_ADDRESS (fn)
						+ tdep->wordsize,
						tdep->wordsize);
		regcache_cooked_write_unsigned (regcache,
						tdep->ppc_gp0_regnum + 2, toc);
	      }
	  }
      }
  }

d289 10
d300 2
a301 1
/* The 64 bit ABI retun value convention.
d303 4
a306 12
   Return non-zero if the return-value is stored in a register, return
   0 if the return-value is instead stored on the stack (a.k.a.,
   struct return convention).

   For a return-value stored in a register: when WRITEBUF is non-NULL,
   copy the buffer to the corresponding register return-value location
   location; when READBUF is non-NULL, fill the buffer from the
   corresponding register return-value location.  */
enum return_value_convention
ppc64_sysv_abi_return_value (struct gdbarch *gdbarch, struct type *valtype,
			     struct regcache *regcache, void *readbuf,
			     const void *writebuf)
d308 3
a310 136
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  /* Floats and doubles in F1.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_FLT && TYPE_LENGTH (valtype) <= 8)
    {
      char regval[MAX_REGISTER_SIZE];
      struct type *regtype = register_type (gdbarch, FP0_REGNUM);
      if (writebuf != NULL)
	{
	  convert_typed_floating (writebuf, valtype, regval, regtype);
	  regcache_cooked_write (regcache, FP0_REGNUM + 1, regval);
	}
      if (readbuf != NULL)
	{
	  regcache_cooked_read (regcache, FP0_REGNUM + 1, regval);
	  convert_typed_floating (regval, regtype, readbuf, valtype);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_CODE (valtype) == TYPE_CODE_INT && TYPE_LENGTH (valtype) <= 8)
    {
      /* Integers in r3.  */
      if (writebuf != NULL)
	{
	  /* Be careful to sign extend the value.  */
	  regcache_cooked_write_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
					  unpack_long (valtype, writebuf));
	}
      if (readbuf != NULL)
	{
	  /* Extract the integer from r3.  Since this is truncating the
	     value, there isn't a sign extension problem.  */
	  ULONGEST regval;
	  regcache_cooked_read_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
					 &regval);
	  store_unsigned_integer (readbuf, TYPE_LENGTH (valtype), regval);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  /* All pointers live in r3.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_PTR)
    {
      /* All pointers live in r3.  */
      if (writebuf != NULL)
	regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 3, writebuf);
      if (readbuf != NULL)
	regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 3, readbuf);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_CODE (valtype) == TYPE_CODE_ARRAY
      && TYPE_LENGTH (valtype) <= 8
      && TYPE_CODE (TYPE_TARGET_TYPE (valtype)) == TYPE_CODE_INT
      && TYPE_LENGTH (TYPE_TARGET_TYPE (valtype)) == 1)
    {
      /* Small character arrays are returned, right justified, in r3.  */
      int offset = (register_size (gdbarch, tdep->ppc_gp0_regnum + 3)
		    - TYPE_LENGTH (valtype));
      if (writebuf != NULL)
	regcache_cooked_write_part (regcache, tdep->ppc_gp0_regnum + 3,
				    offset, TYPE_LENGTH (valtype), writebuf);
      if (readbuf != NULL)
	regcache_cooked_read_part (regcache, tdep->ppc_gp0_regnum + 3,
				   offset, TYPE_LENGTH (valtype), readbuf);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  /* Big floating point values get stored in adjacent floating
     point registers.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_FLT
      && (TYPE_LENGTH (valtype) == 16 || TYPE_LENGTH (valtype) == 32))
    {
      if (writebuf || readbuf != NULL)
	{
	  int i;
	  for (i = 0; i < TYPE_LENGTH (valtype) / 8; i++)
	    {
	      if (writebuf != NULL)
		regcache_cooked_write (regcache, FP0_REGNUM + 1 + i,
				       (const bfd_byte *) writebuf + i * 8);
	      if (readbuf != NULL)
		regcache_cooked_read (regcache, FP0_REGNUM + 1 + i,
				      (bfd_byte *) readbuf + i * 8);
	    }
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  /* Complex values get returned in f1:f2, need to convert.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_COMPLEX
      && (TYPE_LENGTH (valtype) == 8 || TYPE_LENGTH (valtype) == 16))
    {
      if (regcache != NULL)
	{
	  int i;
	  for (i = 0; i < 2; i++)
	    {
	      char regval[MAX_REGISTER_SIZE];
	      struct type *regtype =
		register_type (current_gdbarch, FP0_REGNUM);
	      if (writebuf != NULL)
		{
		  convert_typed_floating ((const bfd_byte *) writebuf +
					  i * (TYPE_LENGTH (valtype) / 2),
					  valtype, regval, regtype);
		  regcache_cooked_write (regcache, FP0_REGNUM + 1 + i,
					 regval);
		}
	      if (readbuf != NULL)
		{
		  regcache_cooked_read (regcache, FP0_REGNUM + 1 + i, regval);
		  convert_typed_floating (regval, regtype,
					  (bfd_byte *) readbuf +
					  i * (TYPE_LENGTH (valtype) / 2),
					  valtype);
		}
	    }
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  /* Big complex values get stored in f1:f4.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_COMPLEX && TYPE_LENGTH (valtype) == 32)
    {
      if (regcache != NULL)
	{
	  int i;
	  for (i = 0; i < 4; i++)
	    {
	      if (writebuf != NULL)
		regcache_cooked_write (regcache, FP0_REGNUM + 1 + i,
				       (const bfd_byte *) writebuf + i * 8);
	      if (readbuf != NULL)
		regcache_cooked_read (regcache, FP0_REGNUM + 1 + i,
				      (bfd_byte *) readbuf + i * 8);
	    }
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  return RETURN_VALUE_STRUCT_CONVENTION;
}
d312 2
a313 17
CORE_ADDR
ppc64_sysv_abi_adjust_breakpoint_address (struct gdbarch *gdbarch,
					  CORE_ADDR bpaddr)
{
  /* PPC64 SYSV specifies that the minimal-symbol "FN" should point at
     a function-descriptor while the corresponding minimal-symbol
     ".FN" should point at the entry point.  Consequently, a command
     like "break FN" applied to an object file with only minimal
     symbols, will insert the breakpoint into the descriptor at "FN"
     and not the function at ".FN".  Avoid this confusion by adjusting
     any attempt to set a descriptor breakpoint into a corresponding
     function breakpoint.  Note that GDB warns the user when this
     adjustment is applied - that's ok as otherwise the user will have
     no way of knowing why their breakpoint at "FN" resulted in the
     program stopping at ".FN".  */
  return gdbarch_convert_from_func_ptr_addr (gdbarch, bpaddr, &current_target);
}
@


1.1
log
@* Makefile.in (ppc_tdep_h): Define.
(ppc-linux-nat.o)
(ppc-linux-tdep.o)
(rs6000-tdep.o): Use $(ppc_tdep_h).
(ppc-sysv-tdep.o)
(ppcnbsd-nat.o)
(ppcnbsd-tdep.o): New dependency lists.
* ppc-tdep.h: Use generic OS ABI framework.
* ppc-linux-tdep.c (_initialize_ppc_linux_tdep,
ppc_linux_init_abi): New functions.
(ppc_sysv_abi_broken_use_struct_convention)
(ppc_sysv_abi_use_struct_convention)
(ppc_sysv_abi_push_arguments): Move to...
* ppc-sysv-tdep.c: ...here.
* ppcnbsd-nat.c: Don't include gdbcore.h and regcache.h.
* rs6000-tdep.c (process_note_abi_tag_sections)
(get_elfosabi): Remove.
(rs6000_gdbarch_init): Use generic OS ABI framework.
(rs6000_dump_tdep): New function.
(_initialize_rs6000_tdep): Use gdbarch_register.
* config/powerpc/linux.mt (TDEPFILES): Add ppc-sysv-tdep.o.
* config/powerpc/nbsd.mh (NATDEPFILES): Remove solib-legacy.o.
* config/powerpc/aix.mt (TDEPFILES): Use ppc-sysv-tdep.o instead
of ppc-linux-tdep.o.
* config/powerpc/nbsd.mt (TDEPFILES): Likewise.
* config/powerpc/ppc-eabi.mt (TDEPFILES): Likewise.
* config/powerpc/ppc-sim.mt (TDEPFILES): Likewise.
* config/powerpc/ppcle-eabi.mt (TDEPFILES): Likewise.
* config/powerpc/ppcle-sim.mt (TDEPFILES): Likewise.
* config/powerpc/vxworks.mt (TDEPFILES): Likewise.
@
text
@d28 1
@


1.1.10.1
log
@2002-11-25  Andrew Cagney  <cagney@@redhat.com>

	* ns32k-tdep.c: Include "gdb_string.h".
	* mcore-tdep.c, cris-tdep.c, vax-tdep.c: Ditto.
	* sh3-rom.c, ppc-sysv-tdep.c, ns32knbsd-tdep.c: Ditto.
	* Makefile.in (sh3-rom.o): Update dependencies.
	(ppc-sysv-tdep.o, ns32k-tdep.o, mcore-tdep.o): Ditto.
	(cris-tdep.o): Ditto.
@
text
@a27 1
#include "gdb_string.h"
@


1.1.12.1
log
@2002-09-30  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.h: Augment comment above dict_lookup.
	* dictionary.c (struct dict_vtbl): Delete 'lookup' member, and
	move add_symbol to precede the iterators.
	Make corresponding changes to dict_hashed_vtbl, dict_linear_vtbl,
	dict_linear_expandable_vtbl.
	(dict_lookup): Implement by means of dict_iterator_name_first.
	(iter_name_first_hashed): Don't use lookup_hashed to implement.
	(lookup_hashed): Delete.
	(lookup_linear): Delete.
	* symtab.c (lookup_symbol_aux_global_symtabs): Delete 'block'
	argument, rename local variable 'b' to 'block', and make it point
	to a const struct block.
	(lookup_symbol_aux_minsym_non_hpuxhppa): Ditto.
	(lookup_symbol_aux_global_psymtabs): Ditto.
	(lookup_symbol_aux_static_symtabs): Ditto.
	(lookup_symbol_aux_static_psymtabs): Ditto.
	(lookup_symbol_aux_minsym_hpuxhppa): Ditto.
	(lookup_symbol_aux): Correct calls to above functions.
	(lookup_symbol_aux_minsym_non_hpuxhppa): When recursively calling
	lookup_symbol_aux, pass 'NULL' as block argument.
	(lookup_symbol_aux_minsym_hpuxhppa): Ditto.
	(lookup_symbol_aux_global_symtabs): Don't initialize objfile and
	s.
	(lookup_symbol_aux_minsym_non_hpuxhppa): Don't initialize s.
	(lookup_symbol_aux_global_psymtabs): Ditto.
	(lookup_symbol_aux_static_symtabs): Ditto.
	(lookup_symbol_aux_static_psymtabs): Ditto.
	(lookup_symbol_aux_minsym_hpuxhppa): Ditto.
	(lookup_symbol_aux_global_psymtabs): Don't initialize objfile.
	(lookup_symbol_aux_static_symtabs): Ditto.
	(lookup_symbol_aux_static_psymtabs): Ditto.
	(lookup_symbol_aux_minsym_hpuxhppa): Delete local variable
	objfile.
	(lookup_symbol_aux_static_symtabs): Delete, to be replaced by
	lookup_symbol_aux_symtabs.
	(lookup_symbol_aux_global_symtabs): Ditto.
	(lookup_symbol_aux_symtabs): New function.
	(lookup_symbol_aux_psymtabs): New function.
	(lookup_symbol_aux_global_psymtabs): Delete, to be replaced by
	lookup_symbol_aux_psymtabs.
	(lookup_symbol_aux_static_psymtabs): Ditto.
	(lookup_symbol_aux_minsym_hpuxhppa): Delete, to be replaced by
	lookup_symbol_aux_minsyms.
	(lookup_symbol_aux_minsym_non_hpuxhppa): Ditto.
	(lookup_symbol_aux_minsyms): New function.
	(lookup_symbol_aux): Replace function calls by calls to functions
	with new names.
	(lookup_symbol_aux): Search global psymtabs before minimal
	symbols.
	* Makefile.in (ppc-sysv-tdep.o): Depend on gdb_string_h.
	* ppc-sysv-tdep.c: #include "gdb_string.h".

2002-09-27  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Run through gdb_indent.sh.
	(lookup_symbol_aux): Delete code that isn't called.
	(lookup_symbol_aux): Don't declare variables 'register'.
	(lookup_symbol_aux): Move each chunk of code into its own
	function.
	(lookup_symbol_aux_local): New function.
	(lookup_symbol_aux_global_symtabs): New function.
	(lookup_symbol_aux_minsym_non_hpuxhppa): New function.
	(lookup_symbol_aux_global_psymtabs): New function.
	(lookup_symbol_aux_static_symtabs): New function.
	(lookup_symbol_aux_static_psymtabs): New function.
	(lookup_symbol_aux_minsym_hpuxhppa): New function.
	(lookup_symbol_aux_global_psymtabs): Remove embedded newlines from
	strings because CC mode can't deal with them.
	(lookup_symbol_aux_static_psymtabs): Ditto.
	(lookup_symbol_aux): Delete local variables that are now
	obsolete.
	* remote-sds.c (getmessage): Add semicolon after 'retry' label to
	pacify GCC.

2002-09-27  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (cris-tdep.o): Depend on gdb_string_h.
	(mcore-tdep.o): Ditto.
	(ns32k-tdep.o): Ditto.
	(ns32knbsd-tdep.o): Ditto.
	(sh3-rom.o): Ditto.
	(vax-tdep.o): Ditto.
	* cris-tdep.c: #include "gdb_string.h"
	* mcore-tdep.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* ns32knbsd-tdep.c: Ditto.
	* sh3-rom.c: Ditto.
	* vax-tdep.c: Ditto.
@
text
@a27 1
#include "gdb_string.h"
@


1.1.12.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d178 1
a178 1
      memcpy (&deprecated_registers[REGISTER_BYTE (greg)], val_buf, 4);
d195 1
a195 1
	      memcpy (&deprecated_registers[REGISTER_BYTE (FP0_REGNUM + freg)],
d225 1
a225 1
	      memcpy (&deprecated_registers[REGISTER_BYTE (greg)],
d227 1
a227 1
	      memcpy (&deprecated_registers[REGISTER_BYTE (greg + 1)],
d250 1
a250 1
	      memcpy (&deprecated_registers[REGISTER_BYTE (greg)], val_buf, 4);
d271 1
a271 1
		  memcpy (&deprecated_registers[REGISTER_BYTE (tdep->ppc_vr0_regnum
@


1.1.12.3
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d64 1
a68 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d82 1
a82 1
      struct value *arg = args[argno];
d86 1
a86 2
      if (TYPE_CODE (type) == TYPE_CODE_FLT
          && ppc_floating_point_unit_p (current_gdbarch))
d99 1
a99 4
      else if (len == 8 
               && (TYPE_CODE (type) == TYPE_CODE_INT /* long long */
                   || (!ppc_floating_point_unit_p (current_gdbarch)
                       && TYPE_CODE (type) == TYPE_CODE_FLT))) /* double */
a146 14
          else if (len == 8 
                   && TYPE_CODE (type) == TYPE_CODE_ARRAY
                   && TYPE_VECTOR (type))
            {
              if (greg <= 10)
                greg++;
              else
                {
                  /* Vector arguments must be aligned to 8 bytes on
                     the stack. */
                  argstkspace += round2 (argstkspace, 8);
                  argstkspace += 8;
                }
            }
a172 1

d176 3
a178 1
      write_register (tdep->ppc_gp0_regnum + greg, struct_addr);
a180 1

d184 1
a184 2
      struct value *arg = args[argno];
      char *val = VALUE_CONTENTS (arg);
d188 1
a188 2
      if (TYPE_CODE (type) == TYPE_CODE_FLT
          && ppc_floating_point_unit_p (current_gdbarch))
a191 1
	      ULONGEST regval;
d195 2
a196 2
              regval = extract_unsigned_integer (val, len);
              write_register (FP0_REGNUM + freg, regval);
d206 1
a206 1
	      write_memory (sp + argoffset, val, len);
d210 1
a210 4
      else if (len == 8 
               && (TYPE_CODE (type) == TYPE_CODE_INT /* long long */
                   || (!ppc_floating_point_unit_p (current_gdbarch)
                        && TYPE_CODE (type) == TYPE_CODE_FLT))) /* double */
d217 1
a217 1
	      write_memory (sp + argoffset, val, len);
a221 1
	      ULONGEST regval;
d224 5
a228 4
              regval = extract_unsigned_integer (val, 4);
              write_register (tdep->ppc_gp0_regnum + greg, regval);
              regval = extract_unsigned_integer (val + 4, 4);
              write_register (tdep->ppc_gp0_regnum + greg + 1, regval);
d239 1
a239 1
	      write_memory (sp + structoffset, val, len);
d246 1
a246 1
	      memcpy (val_buf, val, len);
d250 1
a250 2
              ULONGEST regval = extract_unsigned_integer (val_buf, 4);
              write_register (tdep->ppc_gp0_regnum + greg, regval);
d265 1
d268 1
a268 1
	      memcpy (v_val_buf, val, len);
d271 3
a273 3
		  regcache_cooked_write (current_regcache,
					 tdep->ppc_vr0_regnum + vreg,
					 v_val_buf);
a281 20
          else if (len == 8 
		   && TYPE_CODE (type) == TYPE_CODE_ARRAY
		   && TYPE_VECTOR (type))
            {
              char *v_val_buf = alloca (8);
              memset (v_val_buf, 0, 8);
              memcpy (v_val_buf, val, len);
              if (greg <= 10)
                {
		  regcache_cooked_write (current_regcache,
					 tdep->ppc_ev0_regnum + greg,
					 v_val_buf);
                  greg++;
                }
              else
                {
                  write_memory (sp + argoffset, v_val_buf, 8);
                  argoffset += 8;
                }
            }
d296 1
a296 1
  if ((TYPE_LENGTH (value_type) == 16 || TYPE_LENGTH (value_type) == 8)
d308 1
a308 1
  if ((TYPE_LENGTH (value_type) == 16 || TYPE_LENGTH (value_type) == 8)
@


1.1.12.4
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d183 1
a183 1
  store_unsigned_integer (old_sp_buf, 4, saved_sp);
d264 1
a264 1
	      store_unsigned_integer (val_buf, 4, sp + structoffset);
@


1.1.12.5
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d32 2
a33 2
/* Ensure that X is aligned to an S byte boundary (assuming that S is
   a power of 2) rounding up/down where necessary.  */
d35 2
a36 11
static ULONGEST
align_up (ULONGEST x, int s)
{
  return (x + s - 1) & -s;
}

static ULONGEST
align_down (ULONGEST x, int s)
{
  return (x & -s);
}
d50 2
a51 4
ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
			      struct regcache *regcache, CORE_ADDR bp_addr,
			      int nargs, struct value **args, CORE_ADDR sp,
			      int struct_return, CORE_ADDR struct_addr)
d53 15
a68 11
  const CORE_ADDR saved_sp = read_sp ();
  int argspace = 0;		/* 0 is an initial wrong guess.  */
  int write_pass;

  /* Go through the argument list twice.

     Pass 1: Figure out how much new stack space is required for
     arguments and pushed values.  Unlike the PowerOpen ABI, the SysV
     ABI doesn't reserve any extra space for parameters which are put
     in registers, but does always push structures and then pass their
     address.
d70 15
a84 2
     Pass 2: Replay the same computation but this time also write the
     values out to the target.  */
d86 2
a87 21
  for (write_pass = 0; write_pass < 2; write_pass++)
    {
      int argno;
      /* Next available floating point register for float and double
         arguments.  */
      int freg = 1;
      /* Next available general register for non-float, non-vector
         arguments.  */
      int greg = 3;
      /* Next available vector register for vector arguments.  */
      int vreg = 2;
      /* Arguments start above the "LR save word" and "Back chain".  */
      int argoffset = 2 * tdep->wordsize;
      /* Structures start after the arguments.  */
      int structoffset = argoffset + argspace;

      /* If the function is returning a `struct', then the first word
	 (which will be passed in r3) is used for struct return
	 address.  In that case we should advance one word and start
	 from r4 register to copy parameters.  */
      if (struct_return)
d89 10
a98 5
	  if (write_pass)
	    regcache_cooked_write_signed (regcache,
					  tdep->ppc_gp0_regnum + greg,
					  struct_addr);
	  greg++;
d100 4
a103 2

      for (argno = 0; argno < nargs; argno++)
d105 38
a142 27
	  struct value *arg = args[argno];
	  struct type *type = check_typedef (VALUE_TYPE (arg));
	  int len = TYPE_LENGTH (type);
	  char *val = VALUE_CONTENTS (arg);

	  if (TYPE_CODE (type) == TYPE_CODE_FLT
	      && ppc_floating_point_unit_p (current_gdbarch)
	      && len <= 8)
	    {
	      /* Floating point value converted to "double" then
                 passed in an FP register, when the registers run out,
                 8 byte aligned stack is used.  */
	      if (freg <= 8)
		{
		  if (write_pass)
		    {
		      /* Always store the floating point value using
                         the register's floating-point format.  */
		      char regval[MAX_REGISTER_SIZE];
		      struct type *regtype
			= register_type (gdbarch, FP0_REGNUM + freg);
		      convert_typed_floating (val, type, regval, regtype);
		      regcache_cooked_write (regcache, FP0_REGNUM + freg,
					     regval);
		    }
		  freg++;
		}
d145 4
a148 22
		  /* SysV ABI converts floats to doubles before
                     writing them to an 8 byte aligned stack location.  */
		  argoffset = align_up (argoffset, 8);
		  if (write_pass)
		    {
		      char memval[8];
		      struct type *memtype;
		      switch (TARGET_BYTE_ORDER)
			{
			case BFD_ENDIAN_BIG:
			  memtype = builtin_type_ieee_double_big;
			  break;
			case BFD_ENDIAN_LITTLE:
			  memtype = builtin_type_ieee_double_little;
			  break;
			default:
			  internal_error (__FILE__, __LINE__, "bad switch");
			}
		      convert_typed_floating (val, type, memval, memtype);
		      write_memory (sp + argoffset, val, len);
		    }
		  argoffset += 8;
d151 131
a281 43
	  else if (len == 8 
		   && (TYPE_CODE (type) == TYPE_CODE_INT /* long long */
		       || (!ppc_floating_point_unit_p (current_gdbarch)
			   && TYPE_CODE (type) == TYPE_CODE_FLT))) /* double */
	    {
	      /* "long long" or "double" passed in an odd/even
                 register pair with the low addressed word in the odd
                 register and the high addressed word in the even
                 register, or when the registers run out an 8 byte
                 aligned stack location.  */
	      if (greg > 9)
		{
		  /* Just in case GREG was 10.  */
		  greg = 11;
		  argoffset = align_up (argoffset, 8);
		  if (write_pass)
		    write_memory (sp + argoffset, val, len);
		  argoffset += 8;
		}
	      else if (tdep->wordsize == 8)
		{
		  if (write_pass)
		    regcache_cooked_write (regcache,
					   tdep->ppc_gp0_regnum + greg,
					   val);
		  greg += 1;
		}
	      else
		{
		  /* Must start on an odd register - r3/r4 etc.  */
		  if ((greg & 1) == 0)
		    greg++;
		  if (write_pass)
		    {
		      regcache_cooked_write (regcache,
					     tdep->ppc_gp0_regnum + greg + 0,
					     val + 0);
		      regcache_cooked_write (regcache,
					     tdep->ppc_gp0_regnum + greg + 1,
					     val + 4);
		    }
		  greg += 2;
		}
d283 6
a288 4
	  else if (len == 16
		   && TYPE_CODE (type) == TYPE_CODE_ARRAY
		   && TYPE_VECTOR (type)
		   && tdep->ppc_vr0_regnum >= 0)
d290 3
a292 2
	      /* Vector parameter passed in an Altivec register, or
                 when that runs out, 16 byte aligned stack location.  */
d295 3
a297 4
		  if (write_pass)
		    regcache_cooked_write (current_regcache,
					   tdep->ppc_vr0_regnum + vreg,
					   val);
d302 1
a302 3
		  argoffset = align_up (argoffset, 16);
		  if (write_pass)
		    write_memory (sp + argoffset, val, 16);
d308 1
a308 2
		   && TYPE_VECTOR (type)
		   && tdep->ppc_ev0_regnum >= 0)
d310 3
a312 7
	      /* Vector parameter passed in an e500 register, or when
                 that runs out, 8 byte aligned stack location.  Note
                 that since e500 vector and general purpose registers
                 both map onto the same underlying register set, a
                 "greg" and not a "vreg" is consumed here.  A cooked
                 write stores the value in the correct locations
                 within the raw register cache.  */
d315 3
a317 4
		  if (write_pass)
		    regcache_cooked_write (current_regcache,
					   tdep->ppc_ev0_regnum + greg,
					   val);
d322 1
a322 3
		  argoffset = align_up (argoffset, 8);
		  if (write_pass)
		    write_memory (sp + argoffset, val, 8);
d326 1
a326 58
	  else
	    {
	      /* Reduce the parameter down to something that fits in a
                 "word".  */
	      char word[MAX_REGISTER_SIZE];
	      memset (word, 0, MAX_REGISTER_SIZE);
	      if (len > tdep->wordsize
		  || TYPE_CODE (type) == TYPE_CODE_STRUCT
		  || TYPE_CODE (type) == TYPE_CODE_UNION)
		{
		  /* Structs and large values are put on an 8 byte
                     aligned stack ... */
		  structoffset = align_up (structoffset, 8);
		  if (write_pass)
		    write_memory (sp + structoffset, val, len);
		  /* ... and then a "word" pointing to that address is
                     passed as the parameter.  */
		  store_unsigned_integer (word, tdep->wordsize,
					  sp + structoffset);
		  structoffset += len;
		}
	      else if (TYPE_CODE (type) == TYPE_CODE_INT)
		/* Sign or zero extend the "int" into a "word".  */
		store_unsigned_integer (word, tdep->wordsize,
					unpack_long (type, val));
	      else
		/* Always goes in the low address.  */
		memcpy (word, val, len);
	      /* Store that "word" in a register, or on the stack.
                 The words have "4" byte alignment.  */
	      if (greg <= 10)
		{
		  if (write_pass)
		    regcache_cooked_write (regcache,
					   tdep->ppc_gp0_regnum + greg,
					   word);
		  greg++;
		}
	      else
		{
		  argoffset = align_up (argoffset, tdep->wordsize);
		  if (write_pass)
		    write_memory (sp + argoffset, word, tdep->wordsize);
		  argoffset += tdep->wordsize;
		}
	    }
	}

      /* Compute the actual stack space requirements.  */
      if (!write_pass)
	{
	  /* Remember the amount of space needed by the arguments.  */
	  argspace = argoffset;
	  /* Allocate space for both the arguments and the structures.  */
	  sp -= (argoffset + structoffset);
	  /* Ensure that the stack is still 16 byte aligned.  */
	  sp = align_down (sp, 16);
	}
d329 3
a331 5
  /* Update %sp.   */
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);

  /* Write the backchain (it occupies WORDSIZED bytes).  */
  write_memory_signed_integer (sp, tdep->wordsize, saved_sp);
d333 10
a342 3
  /* Point the inferior function call's return address at the dummy's
     breakpoint.  */
  regcache_cooked_write_signed (regcache, tdep->ppc_lr_regnum, bp_addr);
d344 1
a344 1
  return sp;
@


1.1.12.6
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d4 1
a4 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d29 1
a29 1
#include "gdb_assert.h"
d31 15
a45 1
#include "target.h"
d97 3
a99 3
         (which will be passed in r3) is used for struct return
         address.  In that case we should advance one word and start
         from r4 register to copy parameters.  */
d117 2
a118 1
	      && ppc_floating_point_unit_p (current_gdbarch) && len <= 8)
d121 2
a122 2
	         passed in an FP register, when the registers run out,
	         8 byte aligned stack is used.  */
d128 1
a128 1
		         the register's floating-point format.  */
d141 1
a141 1
		     writing them to an 8 byte aligned stack location.  */
d164 4
a167 2
	  else if (len == 8 && (TYPE_CODE (type) == TYPE_CODE_INT	/* long long */
				|| (!ppc_floating_point_unit_p (current_gdbarch) && TYPE_CODE (type) == TYPE_CODE_FLT)))	/* double */
d170 4
a173 4
	         register pair with the low addressed word in the odd
	         register and the high addressed word in the even
	         register, or when the registers run out an 8 byte
	         aligned stack location.  */
d187 2
a188 1
					   tdep->ppc_gp0_regnum + greg, val);
d210 2
a211 1
		   && TYPE_VECTOR (type) && tdep->ppc_vr0_regnum >= 0)
d214 1
a214 1
	         when that runs out, 16 byte aligned stack location.  */
d219 2
a220 1
					   tdep->ppc_vr0_regnum + vreg, val);
d231 1
a231 1
	  else if (len == 8
d233 3
a235 2
		   && TYPE_VECTOR (type) && tdep->ppc_ev0_regnum >= 0)
	    {
d237 8
a244 8
	         that runs out, 8 byte aligned stack location.  Note
	         that since e500 vector and general purpose registers
	         both map onto the same underlying register set, a
	         "greg" and not a "vreg" is consumed here.  A cooked
	         write stores the value in the correct locations
	         within the raw register cache.  */
	      if (greg <= 10)
		{
d247 6
a252 5
					   tdep->ppc_ev0_regnum + greg, val);
		  greg++;
		}
	      else
		{
d256 3
a258 3
		  argoffset += 8;
		}
	    }
d262 1
a262 1
	         "word".  */
d270 1
a270 1
		     aligned stack ... */
d275 1
a275 1
		     passed as the parameter.  */
d288 1
a288 1
	         The words have "4" byte alignment.  */
d293 2
a294 1
					   tdep->ppc_gp0_regnum + greg, word);
d332 4
a335 208
/* Handle the return-value conventions specified by the SysV 32-bit
   PowerPC ABI (including all the supplements):

   no floating-point: floating-point values returned using 32-bit
   general-purpose registers.

   Altivec: 128-bit vectors returned using vector registers.

   e500: 64-bit vectors returned using the full full 64 bit EV
   register, floating-point values returned using 32-bit
   general-purpose registers.

   GCC (broken): Small struct values right (instead of left) aligned
   when returned in general-purpose registers.  */

static enum return_value_convention
do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *type,
			  struct regcache *regcache, void *readbuf,
			  const void *writebuf, int broken_gcc)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  gdb_assert (tdep->wordsize == 4);
  if (TYPE_CODE (type) == TYPE_CODE_FLT
      && TYPE_LENGTH (type) <= 8
      && ppc_floating_point_unit_p (gdbarch))
    {
      if (readbuf)
	{
	  /* Floats and doubles stored in "f1".  Convert the value to
	     the required type.  */
	  char regval[MAX_REGISTER_SIZE];
	  struct type *regtype = register_type (gdbarch, FP0_REGNUM + 1);
	  regcache_cooked_read (regcache, FP0_REGNUM + 1, regval);
	  convert_typed_floating (regval, regtype, readbuf, type);
	}
      if (writebuf)
	{
	  /* Floats and doubles stored in "f1".  Convert the value to
	     the register's "double" type.  */
	  char regval[MAX_REGISTER_SIZE];
	  struct type *regtype = register_type (gdbarch, FP0_REGNUM);
	  convert_typed_floating (writebuf, type, regval, regtype);
	  regcache_cooked_write (regcache, FP0_REGNUM + 1, regval);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if ((TYPE_CODE (type) == TYPE_CODE_INT && TYPE_LENGTH (type) == 8)
      || (TYPE_CODE (type) == TYPE_CODE_FLT && TYPE_LENGTH (type) == 8))
    {
      if (readbuf)
	{
	  /* A long long, or a double stored in the 32 bit r3/r4.  */
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 3,
				(bfd_byte *) readbuf + 0);
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 4,
				(bfd_byte *) readbuf + 4);
	}
      if (writebuf)
	{
	  /* A long long, or a double stored in the 32 bit r3/r4.  */
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 3,
				 (const bfd_byte *) writebuf + 0);
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 4,
				 (const bfd_byte *) writebuf + 4);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_CODE (type) == TYPE_CODE_INT
      && TYPE_LENGTH (type) <= tdep->wordsize)
    {
      if (readbuf)
	{
	  /* Some sort of integer stored in r3.  Since TYPE isn't
	     bigger than the register, sign extension isn't a problem
	     - just do everything unsigned.  */
	  ULONGEST regval;
	  regcache_cooked_read_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
					 &regval);
	  store_unsigned_integer (readbuf, TYPE_LENGTH (type), regval);
	}
      if (writebuf)
	{
	  /* Some sort of integer stored in r3.  Use unpack_long since
	     that should handle any required sign extension.  */
	  regcache_cooked_write_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
					  unpack_long (type, writebuf));
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_LENGTH (type) == 16
      && TYPE_CODE (type) == TYPE_CODE_ARRAY
      && TYPE_VECTOR (type) && tdep->ppc_vr0_regnum >= 0)
    {
      if (readbuf)
	{
	  /* Altivec places the return value in "v2".  */
	  regcache_cooked_read (regcache, tdep->ppc_vr0_regnum + 2, readbuf);
	}
      if (writebuf)
	{
	  /* Altivec places the return value in "v2".  */
	  regcache_cooked_write (regcache, tdep->ppc_vr0_regnum + 2, writebuf);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_LENGTH (type) == 8
      && TYPE_CODE (type) == TYPE_CODE_ARRAY
      && TYPE_VECTOR (type) && tdep->ppc_ev0_regnum >= 0)
    {
      /* The e500 ABI places return values for the 64-bit DSP types
	 (__ev64_opaque__) in r3.  However, in GDB-speak, ev3
	 corresponds to the entire r3 value for e500, whereas GDB's r3
	 only corresponds to the least significant 32-bits.  So place
	 the 64-bit DSP type's value in ev3.  */
      if (readbuf)
	regcache_cooked_read (regcache, tdep->ppc_ev0_regnum + 3, readbuf);
      if (writebuf)
	regcache_cooked_write (regcache, tdep->ppc_ev0_regnum + 3, writebuf);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (broken_gcc && TYPE_LENGTH (type) <= 8)
    {
      if (readbuf)
	{
	  /* GCC screwed up.  The last register isn't "left" aligned.
	     Need to extract the least significant part of each
	     register and then store that.  */
	  /* Transfer any full words.  */
	  int word = 0;
	  while (1)
	    {
	      ULONGEST reg;
	      int len = TYPE_LENGTH (type) - word * tdep->wordsize;
	      if (len <= 0)
		break;
	      if (len > tdep->wordsize)
		len = tdep->wordsize;
	      regcache_cooked_read_unsigned (regcache,
					     tdep->ppc_gp0_regnum + 3 + word,
					     &reg);
	      store_unsigned_integer (((bfd_byte *) readbuf
				       + word * tdep->wordsize), len, reg);
	      word++;
	    }
	}
      if (writebuf)
	{
	  /* GCC screwed up.  The last register isn't "left" aligned.
	     Need to extract the least significant part of each
	     register and then store that.  */
	  /* Transfer any full words.  */
	  int word = 0;
	  while (1)
	    {
	      ULONGEST reg;
	      int len = TYPE_LENGTH (type) - word * tdep->wordsize;
	      if (len <= 0)
		break;
	      if (len > tdep->wordsize)
		len = tdep->wordsize;
	      reg = extract_unsigned_integer (((const bfd_byte *) writebuf
					       + word * tdep->wordsize), len);
	      regcache_cooked_write_unsigned (regcache,
					      tdep->ppc_gp0_regnum + 3 + word,
					      reg);
	      word++;
	    }
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_LENGTH (type) <= 8)
    {
      if (readbuf)
	{
	  /* This matches SVr4 PPC, it does not match GCC.  */
	  /* The value is right-padded to 8 bytes and then loaded, as
	     two "words", into r3/r4.  */
	  char regvals[MAX_REGISTER_SIZE * 2];
	  regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 3,
				regvals + 0 * tdep->wordsize);
	  if (TYPE_LENGTH (type) > tdep->wordsize)
	    regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 4,
				  regvals + 1 * tdep->wordsize);
	  memcpy (readbuf, regvals, TYPE_LENGTH (type));
	}
      if (writebuf)
	{
	  /* This matches SVr4 PPC, it does not match GCC.  */
	  /* The value is padded out to 8 bytes and then loaded, as
	     two "words" into r3/r4.  */
	  char regvals[MAX_REGISTER_SIZE * 2];
	  memset (regvals, 0, sizeof regvals);
	  memcpy (regvals, writebuf, TYPE_LENGTH (type));
	  regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 3,
				 regvals + 0 * tdep->wordsize);
	  if (TYPE_LENGTH (type) > tdep->wordsize)
	    regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 4,
				   regvals + 1 * tdep->wordsize);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  return RETURN_VALUE_STRUCT_CONVENTION;
}

enum return_value_convention
ppc_sysv_abi_return_value (struct gdbarch *gdbarch, struct type *valtype,
			   struct regcache *regcache, void *readbuf,
			   const void *writebuf)
d337 3
a339 3
  return do_ppc_sysv_return_value (gdbarch, valtype, regcache, readbuf,
				   writebuf, 0);
}
d341 2
a342 469
enum return_value_convention
ppc_sysv_abi_broken_return_value (struct gdbarch *gdbarch,
				  struct type *valtype,
				  struct regcache *regcache,
				  void *readbuf, const void *writebuf)
{
  return do_ppc_sysv_return_value (gdbarch, valtype, regcache, readbuf,
				   writebuf, 1);
}

/* Pass the arguments in either registers, or in the stack. Using the
   ppc 64 bit SysV ABI.

   This implements a dumbed down version of the ABI.  It always writes
   values to memory, GPR and FPR, even when not necessary.  Doing this
   greatly simplifies the logic. */

CORE_ADDR
ppc64_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
				struct regcache *regcache, CORE_ADDR bp_addr,
				int nargs, struct value **args, CORE_ADDR sp,
				int struct_return, CORE_ADDR struct_addr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  /* By this stage in the proceedings, SP has been decremented by "red
     zone size" + "struct return size".  Fetch the stack-pointer from
     before this and use that as the BACK_CHAIN.  */
  const CORE_ADDR back_chain = read_sp ();
  /* See for-loop comment below.  */
  int write_pass;
  /* Size of the Altivec's vector parameter region, the final value is
     computed in the for-loop below.  */
  LONGEST vparam_size = 0;
  /* Size of the general parameter region, the final value is computed
     in the for-loop below.  */
  LONGEST gparam_size = 0;
  /* Kevin writes ... I don't mind seeing tdep->wordsize used in the
     calls to align_up(), align_down(), etc.  because this makes it
     easier to reuse this code (in a copy/paste sense) in the future,
     but it is a 64-bit ABI and asserting that the wordsize is 8 bytes
     at some point makes it easier to verify that this function is
     correct without having to do a non-local analysis to figure out
     the possible values of tdep->wordsize.  */
  gdb_assert (tdep->wordsize == 8);

  /* Go through the argument list twice.

     Pass 1: Compute the function call's stack space and register
     requirements.

     Pass 2: Replay the same computation but this time also write the
     values out to the target.  */

  for (write_pass = 0; write_pass < 2; write_pass++)
    {
      int argno;
      /* Next available floating point register for float and double
         arguments.  */
      int freg = 1;
      /* Next available general register for non-vector (but possibly
         float) arguments.  */
      int greg = 3;
      /* Next available vector register for vector arguments.  */
      int vreg = 2;
      /* The address, at which the next general purpose parameter
         (integer, struct, float, ...) should be saved.  */
      CORE_ADDR gparam;
      /* Address, at which the next Altivec vector parameter should be
         saved.  */
      CORE_ADDR vparam;

      if (!write_pass)
	{
	  /* During the first pass, GPARAM and VPARAM are more like
	     offsets (start address zero) than addresses.  That way
	     the accumulate the total stack space each region
	     requires.  */
	  gparam = 0;
	  vparam = 0;
	}
      else
	{
	  /* Decrement the stack pointer making space for the Altivec
	     and general on-stack parameters.  Set vparam and gparam
	     to their corresponding regions.  */
	  vparam = align_down (sp - vparam_size, 16);
	  gparam = align_down (vparam - gparam_size, 16);
	  /* Add in space for the TOC, link editor double word,
	     compiler double word, LR save area, CR save area.  */
	  sp = align_down (gparam - 48, 16);
	}

      /* If the function is returning a `struct', then there is an
         extra hidden parameter (which will be passed in r3)
         containing the address of that struct..  In that case we
         should advance one word and start from r4 register to copy
         parameters.  This also consumes one on-stack parameter slot.  */
      if (struct_return)
	{
	  if (write_pass)
	    regcache_cooked_write_signed (regcache,
					  tdep->ppc_gp0_regnum + greg,
					  struct_addr);
	  greg++;
	  gparam = align_up (gparam + tdep->wordsize, tdep->wordsize);
	}

      for (argno = 0; argno < nargs; argno++)
	{
	  struct value *arg = args[argno];
	  struct type *type = check_typedef (VALUE_TYPE (arg));
	  char *val = VALUE_CONTENTS (arg);
	  if (TYPE_CODE (type) == TYPE_CODE_FLT && TYPE_LENGTH (type) <= 8)
	    {
	      /* Floats and Doubles go in f1 .. f13.  They also
	         consume a left aligned GREG,, and can end up in
	         memory.  */
	      if (write_pass)
		{
		  if (ppc_floating_point_unit_p (current_gdbarch)
		      && freg <= 13)
		    {
		      char regval[MAX_REGISTER_SIZE];
		      struct type *regtype = register_type (gdbarch,
							    FP0_REGNUM);
		      convert_typed_floating (val, type, regval, regtype);
		      regcache_cooked_write (regcache, FP0_REGNUM + freg,
					     regval);
		    }
		  if (greg <= 10)
		    {
		      /* The ABI states "Single precision floating
		         point values are mapped to the first word in
		         a single doubleword" and "... floating point
		         values mapped to the first eight doublewords
		         of the parameter save area are also passed in
		         general registers").

		         This code interprets that to mean: store it,
		         left aligned, in the general register.  */
		      char regval[MAX_REGISTER_SIZE];
		      memset (regval, 0, sizeof regval);
		      memcpy (regval, val, TYPE_LENGTH (type));
		      regcache_cooked_write (regcache,
					     tdep->ppc_gp0_regnum + greg,
					     regval);
		    }
		  write_memory (gparam, val, TYPE_LENGTH (type));
		}
	      /* Always consume parameter stack space.  */
	      freg++;
	      greg++;
	      gparam = align_up (gparam + TYPE_LENGTH (type), tdep->wordsize);
	    }
	  else if (TYPE_LENGTH (type) == 16 && TYPE_VECTOR (type)
		   && TYPE_CODE (type) == TYPE_CODE_ARRAY
		   && tdep->ppc_vr0_regnum >= 0)
	    {
	      /* In the Altivec ABI, vectors go in the vector
	         registers v2 .. v13, or when that runs out, a vector
	         annex which goes above all the normal parameters.
	         NOTE: cagney/2003-09-21: This is a guess based on the
	         PowerOpen Altivec ABI.  */
	      if (vreg <= 13)
		{
		  if (write_pass)
		    regcache_cooked_write (regcache,
					   tdep->ppc_vr0_regnum + vreg, val);
		  vreg++;
		}
	      else
		{
		  if (write_pass)
		    write_memory (vparam, val, TYPE_LENGTH (type));
		  vparam = align_up (vparam + TYPE_LENGTH (type), 16);
		}
	    }
	  else if ((TYPE_CODE (type) == TYPE_CODE_INT
		    || TYPE_CODE (type) == TYPE_CODE_ENUM)
		   && TYPE_LENGTH (type) <= 8)
	    {
	      /* Scalars get sign[un]extended and go in gpr3 .. gpr10.
	         They can also end up in memory.  */
	      if (write_pass)
		{
		  /* Sign extend the value, then store it unsigned.  */
		  ULONGEST word = unpack_long (type, val);
		  if (greg <= 10)
		    regcache_cooked_write_unsigned (regcache,
						    tdep->ppc_gp0_regnum +
						    greg, word);
		  write_memory_unsigned_integer (gparam, tdep->wordsize,
						 word);
		}
	      greg++;
	      gparam = align_up (gparam + TYPE_LENGTH (type), tdep->wordsize);
	    }
	  else
	    {
	      int byte;
	      for (byte = 0; byte < TYPE_LENGTH (type);
		   byte += tdep->wordsize)
		{
		  if (write_pass && greg <= 10)
		    {
		      char regval[MAX_REGISTER_SIZE];
		      int len = TYPE_LENGTH (type) - byte;
		      if (len > tdep->wordsize)
			len = tdep->wordsize;
		      memset (regval, 0, sizeof regval);
		      /* WARNING: cagney/2003-09-21: As best I can
		         tell, the ABI specifies that the value should
		         be left aligned.  Unfortunately, GCC doesn't
		         do this - it instead right aligns even sized
		         values and puts odd sized values on the
		         stack.  Work around that by putting both a
		         left and right aligned value into the
		         register (hopefully no one notices :-^).
		         Arrrgh!  */
		      /* Left aligned (8 byte values such as pointers
		         fill the buffer).  */
		      memcpy (regval, val + byte, len);
		      /* Right aligned (but only if even).  */
		      if (len == 1 || len == 2 || len == 4)
			memcpy (regval + tdep->wordsize - len,
				val + byte, len);
		      regcache_cooked_write (regcache, greg, regval);
		    }
		  greg++;
		}
	      if (write_pass)
		/* WARNING: cagney/2003-09-21: Strictly speaking, this
		   isn't necessary, unfortunately, GCC appears to get
		   "struct convention" parameter passing wrong putting
		   odd sized structures in memory instead of in a
		   register.  Work around this by always writing the
		   value to memory.  Fortunately, doing this
		   simplifies the code.  */
		write_memory (gparam, val, TYPE_LENGTH (type));
	      /* Always consume parameter stack space.  */
	      gparam = align_up (gparam + TYPE_LENGTH (type), tdep->wordsize);
	    }
	}

      if (!write_pass)
	{
	  /* Save the true region sizes ready for the second pass.  */
	  vparam_size = vparam;
	  /* Make certain that the general parameter save area is at
	     least the minimum 8 registers (or doublewords) in size.  */
	  if (greg < 8)
	    gparam_size = 8 * tdep->wordsize;
	  else
	    gparam_size = gparam;
	}
    }

  /* Update %sp.   */
  regcache_cooked_write_signed (regcache, SP_REGNUM, sp);

  /* Write the backchain (it occupies WORDSIZED bytes).  */
  write_memory_signed_integer (sp, tdep->wordsize, back_chain);

  /* Point the inferior function call's return address at the dummy's
     breakpoint.  */
  regcache_cooked_write_signed (regcache, tdep->ppc_lr_regnum, bp_addr);

  /* Find a value for the TOC register.  Every symbol should have both
     ".FN" and "FN" in the minimal symbol table.  "FN" points at the
     FN's descriptor, while ".FN" points at the entry point (which
     matches FUNC_ADDR).  Need to reverse from FUNC_ADDR back to the
     FN's descriptor address.  */
  {
    /* Find the minimal symbol that corresponds to FUNC_ADDR (should
       have the name ".FN").  */
    struct minimal_symbol *dot_fn = lookup_minimal_symbol_by_pc (func_addr);
    if (dot_fn != NULL && SYMBOL_LINKAGE_NAME (dot_fn)[0] == '.')
      {
	/* Now find the corresponding "FN" (dropping ".") minimal
	   symbol's address.  */
	struct minimal_symbol *fn =
	  lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (dot_fn) + 1, NULL,
				 NULL);
	if (fn != NULL)
	  {
	    /* Got the address of that descriptor.  The TOC is the
	       second double word.  */
	    CORE_ADDR toc =
	      read_memory_unsigned_integer (SYMBOL_VALUE_ADDRESS (fn) +
					    tdep->wordsize, tdep->wordsize);
	    regcache_cooked_write_unsigned (regcache,
					    tdep->ppc_gp0_regnum + 2, toc);
	  }
      }
  }

  return sp;
}


/* The 64 bit ABI retun value convention.

   Return non-zero if the return-value is stored in a register, return
   0 if the return-value is instead stored on the stack (a.k.a.,
   struct return convention).

   For a return-value stored in a register: when WRITEBUF is non-NULL,
   copy the buffer to the corresponding register return-value location
   location; when READBUF is non-NULL, fill the buffer from the
   corresponding register return-value location.  */
enum return_value_convention
ppc64_sysv_abi_return_value (struct gdbarch *gdbarch, struct type *valtype,
			     struct regcache *regcache, void *readbuf,
			     const void *writebuf)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  /* Floats and doubles in F1.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_FLT && TYPE_LENGTH (valtype) <= 8)
    {
      char regval[MAX_REGISTER_SIZE];
      struct type *regtype = register_type (gdbarch, FP0_REGNUM);
      if (writebuf != NULL)
	{
	  convert_typed_floating (writebuf, valtype, regval, regtype);
	  regcache_cooked_write (regcache, FP0_REGNUM + 1, regval);
	}
      if (readbuf != NULL)
	{
	  regcache_cooked_read (regcache, FP0_REGNUM + 1, regval);
	  convert_typed_floating (regval, regtype, readbuf, valtype);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_CODE (valtype) == TYPE_CODE_INT && TYPE_LENGTH (valtype) <= 8)
    {
      /* Integers in r3.  */
      if (writebuf != NULL)
	{
	  /* Be careful to sign extend the value.  */
	  regcache_cooked_write_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
					  unpack_long (valtype, writebuf));
	}
      if (readbuf != NULL)
	{
	  /* Extract the integer from r3.  Since this is truncating the
	     value, there isn't a sign extension problem.  */
	  ULONGEST regval;
	  regcache_cooked_read_unsigned (regcache, tdep->ppc_gp0_regnum + 3,
					 &regval);
	  store_unsigned_integer (readbuf, TYPE_LENGTH (valtype), regval);
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  /* All pointers live in r3.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_PTR)
    {
      /* All pointers live in r3.  */
      if (writebuf != NULL)
	regcache_cooked_write (regcache, tdep->ppc_gp0_regnum + 3, writebuf);
      if (readbuf != NULL)
	regcache_cooked_read (regcache, tdep->ppc_gp0_regnum + 3, readbuf);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  if (TYPE_CODE (valtype) == TYPE_CODE_ARRAY
      && TYPE_LENGTH (valtype) <= 8
      && TYPE_CODE (TYPE_TARGET_TYPE (valtype)) == TYPE_CODE_INT
      && TYPE_LENGTH (TYPE_TARGET_TYPE (valtype)) == 1)
    {
      /* Small character arrays are returned, right justified, in r3.  */
      int offset = (register_size (gdbarch, tdep->ppc_gp0_regnum + 3)
		    - TYPE_LENGTH (valtype));
      if (writebuf != NULL)
	regcache_cooked_write_part (regcache, tdep->ppc_gp0_regnum + 3,
				    offset, TYPE_LENGTH (valtype), writebuf);
      if (readbuf != NULL)
	regcache_cooked_read_part (regcache, tdep->ppc_gp0_regnum + 3,
				   offset, TYPE_LENGTH (valtype), readbuf);
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  /* Big floating point values get stored in adjacent floating
     point registers.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_FLT
      && (TYPE_LENGTH (valtype) == 16 || TYPE_LENGTH (valtype) == 32))
    {
      if (writebuf || readbuf != NULL)
	{
	  int i;
	  for (i = 0; i < TYPE_LENGTH (valtype) / 8; i++)
	    {
	      if (writebuf != NULL)
		regcache_cooked_write (regcache, FP0_REGNUM + 1 + i,
				       (const bfd_byte *) writebuf + i * 8);
	      if (readbuf != NULL)
		regcache_cooked_read (regcache, FP0_REGNUM + 1 + i,
				      (bfd_byte *) readbuf + i * 8);
	    }
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  /* Complex values get returned in f1:f2, need to convert.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_COMPLEX
      && (TYPE_LENGTH (valtype) == 8 || TYPE_LENGTH (valtype) == 16))
    {
      if (regcache != NULL)
	{
	  int i;
	  for (i = 0; i < 2; i++)
	    {
	      char regval[MAX_REGISTER_SIZE];
	      struct type *regtype =
		register_type (current_gdbarch, FP0_REGNUM);
	      if (writebuf != NULL)
		{
		  convert_typed_floating ((const bfd_byte *) writebuf +
					  i * (TYPE_LENGTH (valtype) / 2),
					  valtype, regval, regtype);
		  regcache_cooked_write (regcache, FP0_REGNUM + 1 + i,
					 regval);
		}
	      if (readbuf != NULL)
		{
		  regcache_cooked_read (regcache, FP0_REGNUM + 1 + i, regval);
		  convert_typed_floating (regval, regtype,
					  (bfd_byte *) readbuf +
					  i * (TYPE_LENGTH (valtype) / 2),
					  valtype);
		}
	    }
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  /* Big complex values get stored in f1:f4.  */
  if (TYPE_CODE (valtype) == TYPE_CODE_COMPLEX && TYPE_LENGTH (valtype) == 32)
    {
      if (regcache != NULL)
	{
	  int i;
	  for (i = 0; i < 4; i++)
	    {
	      if (writebuf != NULL)
		regcache_cooked_write (regcache, FP0_REGNUM + 1 + i,
				       (const bfd_byte *) writebuf + i * 8);
	      if (readbuf != NULL)
		regcache_cooked_read (regcache, FP0_REGNUM + 1 + i,
				      (bfd_byte *) readbuf + i * 8);
	    }
	}
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
  return RETURN_VALUE_STRUCT_CONVENTION;
}

CORE_ADDR
ppc64_sysv_abi_adjust_breakpoint_address (struct gdbarch *gdbarch,
					  CORE_ADDR bpaddr)
{
  /* PPC64 SYSV specifies that the minimal-symbol "FN" should point at
     a function-descriptor while the corresponding minimal-symbol
     ".FN" should point at the entry point.  Consequently, a command
     like "break FN" applied to an object file with only minimal
     symbols, will insert the breakpoint into the descriptor at "FN"
     and not the function at ".FN".  Avoid this confusion by adjusting
     any attempt to set a descriptor breakpoint into a corresponding
     function breakpoint.  Note that GDB warns the user when this
     adjustment is applied - that's ok as otherwise the user will have
     no way of knowing why their breakpoint at "FN" resulted in the
     program stopping at ".FN".  */
  return gdbarch_convert_from_func_ptr_addr (gdbarch, bpaddr, &current_target);
}
@


1.1.12.7
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@a31 1
#include "objfiles.h"
d793 1
a793 2
     FN's descriptor address (while at the same time being careful to
     find "FN" in the same object file as ".FN").  */
d800 6
a805 4
	/* Get the section that contains FUNC_ADR.  Need this for the
           "objfile" that it contains.  */
	struct obj_section *dot_fn_section = find_pc_section (func_addr);
	if (dot_fn_section != NULL && dot_fn_section->objfile != NULL)
d807 7
a813 19
	    /* Now find the corresponding "FN" (dropping ".") minimal
	       symbol's address.  Only look for the minimal symbol in
	       ".FN"'s object file - avoids problems when two object
	       files (i.e., shared libraries) contain a minimal symbol
	       with the same name.  */
	    struct minimal_symbol *fn =
	      lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (dot_fn) + 1, NULL,
				     dot_fn_section->objfile);
	    if (fn != NULL)
	      {
		/* Got the address of that descriptor.  The TOC is the
		   second double word.  */
		CORE_ADDR toc =
		  read_memory_unsigned_integer (SYMBOL_VALUE_ADDRESS (fn)
						+ tdep->wordsize,
						tdep->wordsize);
		regcache_cooked_write_unsigned (regcache,
						tdep->ppc_gp0_regnum + 2, toc);
	      }
@


1.1.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@@


1.1.4.2
log
@merge from mainline
@
text
@a27 1
#include "gdb_string.h"
@


1.1.2.1
log
@merge from trunk
@
text
@@

