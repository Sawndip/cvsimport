head	1.58;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.57
	gdb_7_6-2013-04-26-release:1.57
	gdb_7_6-branch:1.57.0.2
	gdb_7_6-2013-03-12-branchpoint:1.57
	gdb_7_5_1-2012-11-29-release:1.47
	gdb_7_5-2012-08-17-release:1.47
	gdb_7_5-branch:1.47.0.2
	gdb_7_5-2012-07-18-branchpoint:1.47
	gdb_7_4_1-2012-04-26-release:1.45.4.1
	gdb_7_4-2012-01-24-release:1.45.4.1
	gdb_7_4-branch:1.45.0.4
	gdb_7_4-2011-12-13-branchpoint:1.45
	gdb_7_3_1-2011-09-04-release:1.45
	gdb_7_3-2011-07-26-release:1.45
	gdb_7_3-branch:1.45.0.2
	gdb_7_3-2011-04-01-branchpoint:1.45
	gdb_7_2-2010-09-02-release:1.40
	gdb_7_2-branch:1.40.0.4
	gdb_7_2-2010-07-07-branchpoint:1.40
	gdb_7_1-2010-03-18-release:1.40
	gdb_7_1-branch:1.40.0.2
	gdb_7_1-2010-02-18-branchpoint:1.40
	gdb_7_0_1-2009-12-22-release:1.39
	gdb_7_0-2009-10-06-release:1.39
	gdb_7_0-branch:1.39.0.4
	gdb_7_0-2009-09-16-branchpoint:1.39
	arc-sim-20090309:1.35
	msnyder-checkpoint-072509-branch:1.39.0.2
	msnyder-checkpoint-072509-branchpoint:1.39
	arc-insight_6_8-branch:1.35.0.16
	arc-insight_6_8-branchpoint:1.35
	insight_6_8-branch:1.35.0.14
	insight_6_8-branchpoint:1.35
	reverse-20081226-branch:1.35.0.12
	reverse-20081226-branchpoint:1.35
	multiprocess-20081120-branch:1.35.0.10
	multiprocess-20081120-branchpoint:1.35
	reverse-20080930-branch:1.35.0.8
	reverse-20080930-branchpoint:1.35
	reverse-20080717-branch:1.35.0.6
	reverse-20080717-branchpoint:1.35
	msnyder-reverse-20080609-branch:1.35.0.4
	msnyder-reverse-20080609-branchpoint:1.35
	drow-reverse-20070409-branch:1.28.0.2
	drow-reverse-20070409-branchpoint:1.28
	gdb_6_8-2008-03-27-release:1.35
	gdb_6_8-branch:1.35.0.2
	gdb_6_8-2008-02-26-branchpoint:1.35
	gdb_6_7_1-2007-10-29-release:1.31
	gdb_6_7-2007-10-10-release:1.31
	gdb_6_7-branch:1.31.0.2
	gdb_6_7-2007-09-07-branchpoint:1.31
	insight_6_6-20070208-release:1.27
	gdb_6_6-2006-12-18-release:1.27
	gdb_6_6-branch:1.27.0.10
	gdb_6_6-2006-11-15-branchpoint:1.27
	insight_6_5-20061003-release:1.27
	gdb-csl-symbian-6_4_50_20060226-12:1.26
	gdb-csl-sourcerygxx-3_4_4-25:1.25
	nickrob-async-20060828-mergepoint:1.27
	gdb-csl-symbian-6_4_50_20060226-11:1.26
	gdb-csl-sourcerygxx-4_1-17:1.26
	gdb-csl-20060226-branch-local-2:1.26
	gdb-csl-sourcerygxx-4_1-14:1.26
	gdb-csl-sourcerygxx-4_1-13:1.26
	gdb-csl-sourcerygxx-4_1-12:1.26
	gdb-csl-sourcerygxx-3_4_4-21:1.26
	gdb_6_5-20060621-release:1.27
	gdb-csl-sourcerygxx-4_1-9:1.26
	gdb-csl-sourcerygxx-4_1-8:1.26
	gdb-csl-sourcerygxx-4_1-7:1.26
	gdb-csl-arm-2006q1-6:1.26
	gdb-csl-sourcerygxx-4_1-6:1.26
	gdb-csl-symbian-6_4_50_20060226-10:1.26
	gdb-csl-symbian-6_4_50_20060226-9:1.26
	gdb-csl-symbian-6_4_50_20060226-8:1.26
	gdb-csl-coldfire-4_1-11:1.26
	gdb-csl-sourcerygxx-3_4_4-19:1.26
	gdb-csl-coldfire-4_1-10:1.26
	gdb_6_5-branch:1.27.0.8
	gdb_6_5-2006-05-14-branchpoint:1.27
	gdb-csl-sourcerygxx-4_1-5:1.26
	nickrob-async-20060513-branch:1.27.0.6
	nickrob-async-20060513-branchpoint:1.27
	gdb-csl-sourcerygxx-4_1-4:1.26
	msnyder-reverse-20060502-branch:1.27.0.4
	msnyder-reverse-20060502-branchpoint:1.27
	gdb-csl-morpho-4_1-4:1.26
	gdb-csl-sourcerygxx-3_4_4-17:1.26
	readline_5_1-import-branch:1.27.0.2
	readline_5_1-import-branchpoint:1.27
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.26
	gdb-csl-symbian-20060226-branch:1.26.0.8
	gdb-csl-symbian-20060226-branchpoint:1.26
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.26
	msnyder-reverse-20060331-branch:1.26.0.6
	msnyder-reverse-20060331-branchpoint:1.26
	gdb-csl-available-20060303-branch:1.26.0.4
	gdb-csl-available-20060303-branchpoint:1.26
	gdb-csl-20060226-branch:1.26.0.2
	gdb-csl-20060226-branchpoint:1.26
	gdb_6_4-20051202-release:1.25
	msnyder-fork-checkpoint-branch:1.25.0.8
	msnyder-fork-checkpoint-branchpoint:1.25
	gdb-csl-gxxpro-6_3-branch:1.25.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.25
	gdb_6_4-branch:1.25.0.4
	gdb_6_4-2005-11-01-branchpoint:1.25
	gdb-csl-arm-20051020-branch:1.25.0.2
	gdb-csl-arm-20051020-branchpoint:1.25
	msnyder-tracepoint-checkpoint-branch:1.24.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.24
	gdb-csl-arm-20050325-2005-q1b:1.24
	gdb-csl-arm-20050325-2005-q1a:1.24
	csl-arm-20050325-branch:1.24.0.2
	csl-arm-20050325-branchpoint:1.24
	gdb-post-i18n-errorwarning-20050211:1.20
	gdb-pre-i18n-errorwarning-20050211:1.19
	gdb_6_3-20041109-release:1.17
	gdb_6_3-branch:1.17.0.2
	gdb_6_3-20041019-branchpoint:1.17
	drow_intercu-merge-20040921:1.17
	drow_intercu-merge-20040915:1.17
	jimb-gdb_6_2-e500-branch:1.14.0.16
	jimb-gdb_6_2-e500-branchpoint:1.14
	gdb_6_2-20040730-release:1.14
	gdb_6_2-branch:1.14.0.12
	gdb_6_2-2004-07-10-gmt-branchpoint:1.14
	gdb_6_1_1-20040616-release:1.14
	gdb_6_1-2004-04-05-release:1.14
	drow_intercu-merge-20040402:1.14
	drow_intercu-merge-20040327:1.14
	ezannoni_pie-20040323-branch:1.14.0.10
	ezannoni_pie-20040323-branchpoint:1.14
	cagney_tramp-20040321-mergepoint:1.14
	cagney_tramp-20040309-branch:1.14.0.8
	cagney_tramp-20040309-branchpoint:1.14
	gdb_6_1-branch:1.14.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.14
	drow_intercu-20040221-branch:1.14.0.4
	drow_intercu-20040221-branchpoint:1.14
	cagney_bfdfile-20040213-branch:1.14.0.2
	cagney_bfdfile-20040213-branchpoint:1.14
	drow-cplus-merge-20040208:1.14
	carlton_dictionary-20040126-merge:1.13
	cagney_bigcore-20040122-branch:1.13.0.8
	cagney_bigcore-20040122-branchpoint:1.13
	drow-cplus-merge-20040113:1.13
	drow-cplus-merge-20031224:1.13
	drow-cplus-merge-20031220:1.13
	carlton_dictionary-20031215-merge:1.13
	drow-cplus-merge-20031214:1.13
	carlton-dictionary-20031111-merge:1.13
	gdb_6_0-2003-10-04-release:1.10.30.1
	kettenis_sparc-20030918-branch:1.13.0.6
	kettenis_sparc-20030918-branchpoint:1.13
	carlton_dictionary-20030917-merge:1.13
	ezannoni_pie-20030916-branchpoint:1.13
	ezannoni_pie-20030916-branch:1.13.0.4
	cagney_x86i386-20030821-branch:1.13.0.2
	cagney_x86i386-20030821-branchpoint:1.13
	carlton_dictionary-20030805-merge:1.13
	carlton_dictionary-20030627-merge:1.10
	gdb_6_0-branch:1.10.0.30
	gdb_6_0-2003-06-23-branchpoint:1.10
	jimb-ppc64-linux-20030613-branch:1.10.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.10
	cagney_convert-20030606-branch:1.10.0.26
	cagney_convert-20030606-branchpoint:1.10
	cagney_writestrings-20030508-branch:1.10.0.24
	cagney_writestrings-20030508-branchpoint:1.10
	jimb-ppc64-linux-20030528-branch:1.10.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.10
	carlton_dictionary-20030523-merge:1.10
	cagney_fileio-20030521-branch:1.10.0.20
	cagney_fileio-20030521-branchpoint:1.10
	kettenis_i386newframe-20030517-mergepoint:1.10
	jimb-ppc64-linux-20030509-branch:1.10.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.10
	kettenis_i386newframe-20030504-mergepoint:1.10
	carlton_dictionary-20030430-merge:1.10
	kettenis_i386newframe-20030419-branch:1.10.0.16
	kettenis_i386newframe-20030419-branchpoint:1.10
	carlton_dictionary-20030416-merge:1.10
	cagney_frameaddr-20030409-mergepoint:1.10
	kettenis_i386newframe-20030406-branch:1.10.0.14
	kettenis_i386newframe-20030406-branchpoint:1.10
	cagney_frameaddr-20030403-branchpoint:1.10
	cagney_frameaddr-20030403-branch:1.10.0.12
	cagney_framebase-20030330-mergepoint:1.10
	cagney_framebase-20030326-branch:1.10.0.10
	cagney_framebase-20030326-branchpoint:1.10
	cagney_lazyid-20030317-branch:1.10.0.8
	cagney_lazyid-20030317-branchpoint:1.10
	kettenis-i386newframe-20030316-mergepoint:1.10
	offbyone-20030313-branch:1.10.0.6
	offbyone-20030313-branchpoint:1.10
	kettenis-i386newframe-20030308-branch:1.10.0.4
	kettenis-i386newframe-20030308-branchpoint:1.10
	carlton_dictionary-20030305-merge:1.10
	cagney_offbyone-20030303-branch:1.10.0.2
	cagney_offbyone-20030303-branchpoint:1.10
	carlton_dictionary-20030207-merge:1.10
	interps-20030203-mergepoint:1.9
	interps-20030202-branch:1.9.0.30
	interps-20030202-branchpoint:1.9
	cagney-unwind-20030108-branch:1.9.0.28
	cagney-unwind-20030108-branchpoint:1.9
	carlton_dictionary-20021223-merge:1.9
	gdb_5_3-2002-12-12-release:1.9
	carlton_dictionary-20021115-merge:1.9
	kseitz_interps-20021105-merge:1.9
	kseitz_interps-20021103-merge:1.9
	drow-cplus-merge-20021020:1.9
	drow-cplus-merge-20021025:1.9
	carlton_dictionary-20021025-merge:1.9
	carlton_dictionary-20021011-merge:1.9
	drow-cplus-branch:1.9.0.26
	drow-cplus-branchpoint:1.9
	kseitz_interps-20020930-merge:1.9
	carlton_dictionary-20020927-merge:1.9
	carlton_dictionary-branch:1.9.0.24
	carlton_dictionary-20020920-branchpoint:1.9
	gdb_5_3-branch:1.9.0.22
	gdb_5_3-2002-09-04-branchpoint:1.9
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.20
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.9.0.18
	readline_4_3-import-branchpoint:1.9
	gdb_5_2_1-2002-07-23-release:1.9
	kseitz_interps-20020528-branch:1.9.0.16
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.14
	cagney_regbuf-20020515-branchpoint:1.9
	jimb-macro-020506-branch:1.9.0.12
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	gdb_5_2-branch:1.9.0.10
	gdb_5_2-2002-03-03-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.9
	gdb_5_1_0_1-2002-01-03-release:1.9
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.9.0.8
	gdb_5_1-2001-11-21-release:1.9
	gdb_s390-2001-09-26-branch:1.9.0.6
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.4
	gdb_5_1-2001-07-29-branchpoint:1.9
	dberlin-typesystem-branch:1.9.0.2
	dberlin-typesystem-branchpoint:1.9
	gdb-post-ptid_t-2001-05-03:1.8
	gdb-pre-ptid_t-2001-05-03:1.7
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.3
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.4
	gdb-1999-10-25:1.1.1.4
	gdb-1999-10-18:1.1.1.4
	gdb-1999-10-11:1.1.1.4
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.4
	gdb-1999-09-21:1.1.1.4
	gdb-1999-09-13:1.1.1.4
	gdb-1999-09-08:1.1.1.4
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.58
date	2013.05.30.17.05.32;	author tromey;	state Exp;
branches;
next	1.57;

1.57
date	2013.03.07.21.57.29;	author kseitz;	state Exp;
branches;
next	1.56;

1.56
date	2013.02.19.19.41.28;	author palves;	state Exp;
branches;
next	1.55;

1.55
date	2013.01.01.06.32.46;	author brobecke;	state Exp;
branches;
next	1.54;

1.54
date	2012.11.09.19.57.59;	author tromey;	state Exp;
branches;
next	1.53;

1.53
date	2012.08.22.16.24.38;	author tromey;	state Exp;
branches;
next	1.52;

1.52
date	2012.07.23.14.57.54;	author tromey;	state Exp;
branches;
next	1.51;

1.51
date	2012.07.23.14.56.10;	author tromey;	state Exp;
branches;
next	1.50;

1.50
date	2012.07.18.19.42.26;	author tromey;	state Exp;
branches;
next	1.49;

1.49
date	2012.07.18.19.38.39;	author tromey;	state Exp;
branches;
next	1.48;

1.48
date	2012.07.18.19.33.34;	author tromey;	state Exp;
branches;
next	1.47;

1.47
date	2012.05.18.21.02.48;	author sergiodj;	state Exp;
branches;
next	1.46;

1.46
date	2012.01.04.08.17.05;	author brobecke;	state Exp;
branches;
next	1.45;

1.45
date	2011.01.10.02.43.30;	author msnyder;	state Exp;
branches
	1.45.4.1;
next	1.44;

1.44
date	2011.01.09.03.20.33;	author msnyder;	state Exp;
branches;
next	1.43;

1.43
date	2011.01.01.15.33.10;	author brobecke;	state Exp;
branches;
next	1.42;

1.42
date	2010.10.17.17.45.16;	author jkratoch;	state Exp;
branches;
next	1.41;

1.41
date	2010.09.14.08.01.12;	author muller;	state Exp;
branches;
next	1.40;

1.40
date	2010.01.01.07.31.37;	author brobecke;	state Exp;
branches;
next	1.39;

1.39
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.38;

1.38
date	2009.05.05.13.24.49;	author uweigand;	state Exp;
branches;
next	1.37;

1.37
date	2009.02.22.01.02.17;	author palves;	state Exp;
branches;
next	1.36;

1.36
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.35;

1.35
date	2008.01.11.13.34.14;	author deuling;	state Exp;
branches;
next	1.34;

1.34
date	2008.01.01.22.53.11;	author drow;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.17.00.55.28;	author uweigand;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.16.04.53.46;	author deuling;	state Exp;
branches;
next	1.31;

1.31
date	2007.08.23.18.08.35;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.06.14.31.30;	author uweigand;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.09.17.58.51;	author drow;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.19.06.36.37;	author ksakamot;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.02.03.02.05;	author drow;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.17.13.49.53;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2005.02.15.15.49.12;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.14.16.18.41;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.14.14.37.37;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.11.04.05.56;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.10.17.32.49;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.12.18.31.32;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.28.19.42.00;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.28.17.26.27;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.22.01.31.49;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.27.23.19.51;	author cagney;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2003.08.01.21.14.33;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.27.15.38.16;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.21.18.56.05;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.04.23.26.43;	author cagney;	state Exp;
branches
	1.10.30.1;
next	1.9;

1.9
date	2001.06.10.16.25.51;	author cgf;	state Exp;
branches
	1.9.24.1
	1.9.26.1;
next	1.8;

1.8
date	2001.05.04.04.15.25;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.06.08.21.09;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.31.01.24.01;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.02.13.43.26;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.28;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.45.4.1
date	2012.01.06.04.43.19;	author brobecke;	state Exp;
branches;
next	;

1.14.4.1
date	2004.09.16.17.01.12;	author drow;	state Exp;
branches;
next	;

1.10.30.1
date	2003.08.01.21.56.58;	author cagney;	state Exp;
branches;
next	;

1.9.24.1
date	2003.02.07.19.17.50;	author carlton;	state Exp;
branches;
next	1.9.24.2;

1.9.24.2
date	2003.08.05.17.13.10;	author carlton;	state Exp;
branches;
next	;

1.9.26.1
date	2003.12.14.20.27.20;	author drow;	state Exp;
branches;
next	1.9.26.2;

1.9.26.2
date	2004.02.09.19.43.43;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.39;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.07.45;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.09.08.23.59.19;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.58
log
@fix cleanup handling in m32r_load

m32r_load is missing a call to do_cleanups along one return path.

	* m32r-rom.c (m32r_load): Call do_cleanups at all returns.
@
text
@/* Remote debugging interface to m32r and mon2000 ROM monitors for GDB, 
   the GNU debugger.

   Copyright (C) 1996-2013 Free Software Foundation, Inc.

   Adapted by Michael Snyder of Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This module defines communication with the Renesas m32r monitor.  */

#include "defs.h"
#include "gdbcore.h"
#include "target.h"
#include "exceptions.h"
#include "monitor.h"
#include "serial.h"
#include "symtab.h"
#include "command.h"
#include "gdbcmd.h"
#include "symfile.h"		/* for generic load */
#include <sys/time.h>
#include <time.h>		/* for time_t */
#include "gdb_string.h"
#include "objfiles.h"		/* for ALL_OBJFILES etc.  */
#include "inferior.h"
#include <ctype.h>
#include "regcache.h"
#include "gdb_bfd.h"
#include "cli/cli-utils.h"

/*
 * All this stuff just to get my host computer's IP address!
 */
#ifdef __MINGW32__
#include <winsock2.h>
#else
#include <sys/types.h>
#include <netdb.h>		/* for hostent */
#include <netinet/in.h>		/* for struct in_addr */
#if 1
#include <arpa/inet.h>		/* for inet_ntoa */
#endif
#endif

static char *board_addr;	/* user-settable IP address for M32R-EVA */
static char *server_addr;	/* user-settable IP address for gdb host */
static char *download_path;	/* user-settable path for SREC files     */


/* REGNUM */
#define PSW_REGNUM      16
#define SPI_REGNUM      18
#define SPU_REGNUM      19
#define ACCL_REGNUM     22
#define ACCH_REGNUM     23


/* 
 * Function: m32r_load_1 (helper function)
 */

static void
m32r_load_section (bfd *abfd, asection *s, void *obj)
{
  unsigned int *data_count = obj;
  if (s->flags & SEC_LOAD)
    {
      int addr_size = gdbarch_addr_bit (target_gdbarch ()) / 8;
      bfd_size_type section_size = bfd_section_size (abfd, s);
      bfd_vma section_base = bfd_section_lma (abfd, s);
      unsigned int buffer, i;

      *data_count += section_size;

      printf_filtered ("Loading section %s, size 0x%lx lma ",
		       bfd_section_name (abfd, s),
		       (unsigned long) section_size);
      fputs_filtered (paddress (target_gdbarch (), section_base), gdb_stdout);
      printf_filtered ("\n");
      gdb_flush (gdb_stdout);
      monitor_printf ("%s mw\r", phex_nz (section_base, addr_size));
      for (i = 0; i < section_size; i += 4)
	{
	  QUIT;
	  monitor_expect (" -> ", NULL, 0);
	  bfd_get_section_contents (abfd, s, (char *) &buffer, i, 4);
	  monitor_printf ("%x\n", buffer);
	}
      monitor_expect (" -> ", NULL, 0);
      monitor_printf ("q\n");
      monitor_expect_prompt (NULL, 0);
    }
}

static int
m32r_load_1 (void *dummy)
{
  int data_count = 0;

  bfd_map_over_sections ((bfd *) dummy, m32r_load_section, &data_count);
  return data_count;
}

/* 
 * Function: m32r_load (an alternate way to load) 
 */

static void
m32r_load (char *filename, int from_tty)
{
  bfd *abfd;
  unsigned int data_count = 0;
  struct timeval start_time, end_time;
  struct cleanup *cleanup;

  if (filename == NULL || filename[0] == 0)
    filename = get_exec_file (1);

  abfd = gdb_bfd_open (filename, NULL, -1);
  if (!abfd)
    error (_("Unable to open file %s."), filename);
  cleanup = make_cleanup_bfd_unref (abfd);
  if (bfd_check_format (abfd, bfd_object) == 0)
    error (_("File is not an object file."));
  gettimeofday (&start_time, NULL);
#if 0
  for (s = abfd->sections; s; s = s->next)
    if (s->flags & SEC_LOAD)
      {
	bfd_size_type section_size = bfd_section_size (abfd, s);
	bfd_vma section_base = bfd_section_vma (abfd, s);
	unsigned int buffer;

	data_count += section_size;

	printf_filtered ("Loading section %s, size 0x%lx vma ",
			 bfd_section_name (abfd, s), section_size);
	fputs_filtered (paddress (target_gdbarch (), section_base), gdb_stdout);
	printf_filtered ("\n");
	gdb_flush (gdb_stdout);
	monitor_printf ("%x mw\r", section_base);
	for (i = 0; i < section_size; i += 4)
	  {
	    monitor_expect (" -> ", NULL, 0);
	    bfd_get_section_contents (abfd, s, (char *) &buffer, i, 4);
	    monitor_printf ("%x\n", buffer);
	  }
	monitor_expect (" -> ", NULL, 0);
	monitor_printf ("q\n");
	monitor_expect_prompt (NULL, 0);
      }
#else
  if (!(catch_errors (m32r_load_1, abfd, "Load aborted!\n", RETURN_MASK_ALL)))
    {
      monitor_printf ("q\n");
      do_cleanups (cleanup);
      return;
    }
#endif
  gettimeofday (&end_time, NULL);
  printf_filtered ("Start address 0x%lx\n",
		   (unsigned long) bfd_get_start_address (abfd));
  print_transfer_performance (gdb_stdout, data_count, 0, &start_time,
			      &end_time);

  /* Finally, make the PC point at the start address.  */
  if (exec_bfd)
    regcache_write_pc (get_current_regcache (),
		       bfd_get_start_address (exec_bfd));

  inferior_ptid = null_ptid;	/* No process now.  */

  /* This is necessary because many things were based on the PC at the
     time that we attached to the monitor, which is no longer valid
     now that we have loaded new code (and just changed the PC).
     Another way to do this might be to call normal_stop, except that
     the stack may not be valid, and things would get horribly
     confused...  */

  clear_symtab_users (0);
  do_cleanups (cleanup);
}

static void
m32r_load_gen (char *filename, int from_tty)
{
  generic_load (filename, from_tty);
}

static void m32r_open (char *args, int from_tty);
static void mon2000_open (char *args, int from_tty);

/* This array of registers needs to match the indexes used by GDB.  The
   whole reason this exists is because the various ROM monitors use
   different names than GDB does, and don't support all the registers
   either.  So, typing "info reg sp" becomes an "A7".  */

static char *m32r_regnames[] =
  { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
  "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
  "psw", "cbr", "spi", "spu", "bpc", "pc", "accl", "acch",
};

static void
m32r_supply_register (struct regcache *regcache, char *regname,
		      int regnamelen, char *val, int vallen)
{
  int regno;
  int num_regs = sizeof (m32r_regnames) / sizeof (m32r_regnames[0]);
  struct gdbarch *gdbarch = get_regcache_arch (regcache);

  for (regno = 0; regno < num_regs; regno++)
    if (strncmp (regname, m32r_regnames[regno], regnamelen) == 0)
      break;

  if (regno >= num_regs)
    return;			/* no match */

  if (regno == ACCL_REGNUM)
    {				/* Special handling for 64-bit acc reg.  */
      monitor_supply_register (regcache, ACCH_REGNUM, val);
      val = strchr (val, ':');	/* Skip past ':' to get 2nd word.  */
      if (val != NULL)
	monitor_supply_register (regcache, ACCL_REGNUM, val + 1);
    }
  else
    {
      monitor_supply_register (regcache, regno, val);
      if (regno == PSW_REGNUM)
	{
#if (defined SM_REGNUM || defined BSM_REGNUM || defined IE_REGNUM \
     || defined BIE_REGNUM || defined COND_REGNUM  || defined CBR_REGNUM \
     || defined BPC_REGNUM || defined BCARRY_REGNUM)
	  unsigned long psw = strtoul (val, NULL, 16);
	  char *zero = "00000000", *one = "00000001";
#endif

#ifdef SM_REGNUM
	  /* Stack mode bit */
	  monitor_supply_register (regcache, SM_REGNUM,
				   (psw & 0x80) ? one : zero);
#endif
#ifdef BSM_REGNUM
	  /* Backup stack mode bit */
	  monitor_supply_register (regcache, BSM_REGNUM,
				   (psw & 0x8000) ? one : zero);
#endif
#ifdef IE_REGNUM
	  /* Interrupt enable bit */
	  monitor_supply_register (regcache, IE_REGNUM,
				   (psw & 0x40) ? one : zero);
#endif
#ifdef BIE_REGNUM
	  /* Backup interrupt enable bit */
	  monitor_supply_register (regcache, BIE_REGNUM,
				   (psw & 0x4000) ? one : zero);
#endif
#ifdef COND_REGNUM
	  /* Condition bit (carry etc.) */
	  monitor_supply_register (regcache, COND_REGNUM,
				   (psw & 0x1) ? one : zero);
#endif
#ifdef CBR_REGNUM
	  monitor_supply_register (regcache, CBR_REGNUM,
				   (psw & 0x1) ? one : zero);
#endif
#ifdef BPC_REGNUM
	  monitor_supply_register (regcache, BPC_REGNUM,
				   zero);	/* KLUDGE:   (???????) */
#endif
#ifdef BCARRY_REGNUM
	  monitor_supply_register (regcache, BCARRY_REGNUM,
				   zero);	/* KLUDGE: (??????) */
#endif
	}

      if (regno == SPI_REGNUM || regno == SPU_REGNUM)
	{	/* special handling for stack pointer (spu or spi).  */
	  ULONGEST stackmode, psw;
	  regcache_cooked_read_unsigned (regcache, PSW_REGNUM, &psw);
	  stackmode = psw & 0x80;

	  if (regno == SPI_REGNUM && !stackmode)	/* SP == SPI */
	    monitor_supply_register (regcache,
				     gdbarch_sp_regnum (gdbarch), val);
	  else if (regno == SPU_REGNUM && stackmode)	/* SP == SPU */
	    monitor_supply_register (regcache,
				     gdbarch_sp_regnum (gdbarch), val);
	}
    }
}

/* m32r RevC board monitor */

static struct target_ops m32r_ops;

static char *m32r_inits[] = { "\r", NULL };

static struct monitor_ops m32r_cmds;

static void
init_m32r_cmds (void)
{
  m32r_cmds.flags = MO_CLR_BREAK_USES_ADDR | MO_REGISTER_VALUE_FIRST;
  m32r_cmds.init = m32r_inits;	/* Init strings */
  m32r_cmds.cont = "go\r";	/* continue command */
  m32r_cmds.step = "step\r";	/* single step */
  m32r_cmds.stop = NULL;	/* interrupt command */
  m32r_cmds.set_break = "%x +bp\r";	/* set a breakpoint */
  m32r_cmds.clr_break = "%x -bp\r";	/* clear a breakpoint */
  m32r_cmds.clr_all_break = "bpoff\r";	/* clear all breakpoints */
  m32r_cmds.fill = "%x %x %x fill\r";	/* fill (start length val) */
  m32r_cmds.setmem.cmdb = "%x 1 %x fill\r";	/* setmem.cmdb (addr, value) */
  m32r_cmds.setmem.cmdw = "%x 1 %x fillh\r";	/* setmem.cmdw (addr, value) */
  m32r_cmds.setmem.cmdl = "%x 1 %x fillw\r";	/* setmem.cmdl (addr, value) */
  m32r_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
  m32r_cmds.setmem.resp_delim = NULL;	/* setmem.resp_delim */
  m32r_cmds.setmem.term = NULL;	/* setmem.term */
  m32r_cmds.setmem.term_cmd = NULL;	/* setmem.term_cmd */
  m32r_cmds.getmem.cmdb = "%x %x dump\r";	/* getmem.cmdb (addr, len) */
  m32r_cmds.getmem.cmdw = NULL;	/* getmem.cmdw (addr, len) */
  m32r_cmds.getmem.cmdl = NULL;	/* getmem.cmdl (addr, len) */
  m32r_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, len) */
  m32r_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
  m32r_cmds.getmem.term = NULL;	/* getmem.term */
  m32r_cmds.getmem.term_cmd = NULL;	/* getmem.term_cmd */
  m32r_cmds.setreg.cmd = "%x to %%%s\r";	/* setreg.cmd (name, value) */
  m32r_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
  m32r_cmds.setreg.term = NULL;	/* setreg.term */
  m32r_cmds.setreg.term_cmd = NULL;	/* setreg.term_cmd */
  m32r_cmds.getreg.cmd = NULL;	/* getreg.cmd (name) */
  m32r_cmds.getreg.resp_delim = NULL;	/* getreg.resp_delim */
  m32r_cmds.getreg.term = NULL;	/* getreg.term */
  m32r_cmds.getreg.term_cmd = NULL;	/* getreg.term_cmd */
  m32r_cmds.dump_registers = ".reg\r";	/* dump_registers */
  					/* register_pattern */
  m32r_cmds.register_pattern = "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)";
  m32r_cmds.supply_register = m32r_supply_register;
  m32r_cmds.load = NULL;	/* download command */
  m32r_cmds.loadresp = NULL;	/* load response */
  m32r_cmds.prompt = "ok ";	/* monitor command prompt */
  m32r_cmds.line_term = "\r";	/* end-of-line terminator */
  m32r_cmds.cmd_end = NULL;	/* optional command terminator */
  m32r_cmds.target = &m32r_ops;	/* target operations */
  m32r_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
  m32r_cmds.regnames = m32r_regnames;	/* registers names */
  m32r_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
}				/* init_m32r_cmds */

static void
m32r_open (char *args, int from_tty)
{
  monitor_open (args, &m32r_cmds, from_tty);
}

/* Mon2000 monitor (MSA2000 board) */

static struct target_ops mon2000_ops;
static struct monitor_ops mon2000_cmds;

static void
init_mon2000_cmds (void)
{
  mon2000_cmds.flags = MO_CLR_BREAK_USES_ADDR | MO_REGISTER_VALUE_FIRST;
  mon2000_cmds.init = m32r_inits;	/* Init strings */
  mon2000_cmds.cont = "go\r";	/* continue command */
  mon2000_cmds.step = "step\r";	/* single step */
  mon2000_cmds.stop = NULL;	/* interrupt command */
  mon2000_cmds.set_break = "%x +bp\r";	/* set a breakpoint */
  mon2000_cmds.clr_break = "%x -bp\r";	/* clear a breakpoint */
  mon2000_cmds.clr_all_break = "bpoff\r";	/* clear all breakpoints */
  mon2000_cmds.fill = "%x %x %x fill\r";	/* fill (start length val) */
  mon2000_cmds.setmem.cmdb = "%x 1 %x fill\r";	/* setmem.cmdb (addr, value) */
  mon2000_cmds.setmem.cmdw = "%x 1 %x fillh\r";	/* setmem.cmdw (addr, value) */
  mon2000_cmds.setmem.cmdl = "%x 1 %x fillw\r";	/* setmem.cmdl (addr, value) */
  mon2000_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
  mon2000_cmds.setmem.resp_delim = NULL;	/* setmem.resp_delim */
  mon2000_cmds.setmem.term = NULL;	/* setmem.term */
  mon2000_cmds.setmem.term_cmd = NULL;	/* setmem.term_cmd */
  mon2000_cmds.getmem.cmdb = "%x %x dump\r";	/* getmem.cmdb (addr, len) */
  mon2000_cmds.getmem.cmdw = NULL;	/* getmem.cmdw (addr, len) */
  mon2000_cmds.getmem.cmdl = NULL;	/* getmem.cmdl (addr, len) */
  mon2000_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, len) */
  mon2000_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
  mon2000_cmds.getmem.term = NULL;	/* getmem.term */
  mon2000_cmds.getmem.term_cmd = NULL;	/* getmem.term_cmd */
  mon2000_cmds.setreg.cmd = "%x to %%%s\r";	/* setreg.cmd (name, value) */
  mon2000_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
  mon2000_cmds.setreg.term = NULL;	/* setreg.term */
  mon2000_cmds.setreg.term_cmd = NULL;	/* setreg.term_cmd */
  mon2000_cmds.getreg.cmd = NULL;	/* getreg.cmd (name) */
  mon2000_cmds.getreg.resp_delim = NULL;	/* getreg.resp_delim */
  mon2000_cmds.getreg.term = NULL;	/* getreg.term */
  mon2000_cmds.getreg.term_cmd = NULL;	/* getreg.term_cmd */
  mon2000_cmds.dump_registers = ".reg\r";	/* dump_registers */
						/* register_pattern */
  mon2000_cmds.register_pattern = "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)";
  mon2000_cmds.supply_register = m32r_supply_register;
  mon2000_cmds.load = NULL;	/* download command */
  mon2000_cmds.loadresp = NULL;	/* load response */
  mon2000_cmds.prompt = "Mon2000>";	/* monitor command prompt */
  mon2000_cmds.line_term = "\r";	/* end-of-line terminator */
  mon2000_cmds.cmd_end = NULL;	/* optional command terminator */
  mon2000_cmds.target = &mon2000_ops;	/* target operations */
  mon2000_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
  mon2000_cmds.regnames = m32r_regnames;	/* registers names */
  mon2000_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
}				/* init_mon2000_cmds */

static void
mon2000_open (char *args, int from_tty)
{
  monitor_open (args, &mon2000_cmds, from_tty);
}

static void
m32r_upload_command (char *args, int from_tty)
{
  bfd *abfd;
  asection *s;
  struct timeval start_time, end_time;
  int resp_len, data_count = 0;
  char buf[1024];
  struct hostent *hostent;
  struct in_addr inet_addr;
  struct cleanup *cleanup;

  /* First check to see if there's an ethernet port!  */
  monitor_printf ("ust\r");
  resp_len = monitor_expect_prompt (buf, sizeof (buf));
  if (!strchr (buf, ':'))
    error (_("No ethernet connection!"));

  if (board_addr == 0)
    {
      /* Scan second colon in the output from the "ust" command.  */
      char *myIPaddress = strchr (strchr (buf, ':') + 1, ':') + 1;

      myIPaddress = skip_spaces (myIPaddress);

      if (!strncmp (myIPaddress, "0.0.", 4))	/* empty */
	error (_("Please use 'set board-address' to "
		 "set the M32R-EVA board's IP address."));
      if (strchr (myIPaddress, '('))
	*(strchr (myIPaddress, '(')) = '\0';	/* delete trailing junk */
      board_addr = xstrdup (myIPaddress);
    }
  if (server_addr == 0)
    {
#ifdef __MINGW32__
      WSADATA wd;
      /* Winsock initialization.  */
      if (WSAStartup (MAKEWORD (1, 1), &wd))
	error (_("Couldn't initialize WINSOCK."));
#endif

      buf[0] = 0;
      gethostname (buf, sizeof (buf));
      if (buf[0] != 0)
	{
	  hostent = gethostbyname (buf);
	  if (hostent != 0)
	    {
#if 1
	      memcpy (&inet_addr.s_addr, hostent->h_addr,
		      sizeof (inet_addr.s_addr));
	      server_addr = (char *) inet_ntoa (inet_addr);
#else
	      server_addr = (char *) inet_ntoa (hostent->h_addr);
#endif
	    }
	}
      if (server_addr == 0)	/* failed?  */
	error (_("Need to know gdb host computer's "
		 "IP address (use 'set server-address')"));
    }

  if (args == 0 || args[0] == 0)	/* No args: upload the current
					   file.  */
    args = get_exec_file (1);

  if (args[0] != '/' && download_path == 0)
    {
      if (current_directory)
	download_path = xstrdup (current_directory);
      else
	error (_("Need to know default download "
		 "path (use 'set download-path')"));
    }

  gettimeofday (&start_time, NULL);
  monitor_printf ("uhip %s\r", server_addr);
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result?  */
  monitor_printf ("ulip %s\r", board_addr);
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result?  */
  if (args[0] != '/')
    monitor_printf ("up %s\r", download_path);	/* use default path */
  else
    monitor_printf ("up\r");	/* rooted filename/path */
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result?  */

  if (strrchr (args, '.') && !strcmp (strrchr (args, '.'), ".srec"))
    monitor_printf ("ul %s\r", args);
  else				/* add ".srec" suffix */
    monitor_printf ("ul %s.srec\r", args);
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result?  */

  if (buf[0] == 0 || strstr (buf, "complete") == 0)
    error (_("Upload file not found: %s.srec\n"
	     "Check IP addresses and download path."),
	   args);
  else
    printf_filtered (" -- Ethernet load complete.\n");

  gettimeofday (&end_time, NULL);
  abfd = gdb_bfd_open (args, NULL, -1);
  cleanup = make_cleanup_bfd_unref (abfd);
  if (abfd != NULL)
    {		/* Download is done -- print section statistics.  */
      if (bfd_check_format (abfd, bfd_object) == 0)
	{
	  printf_filtered ("File is not an object file\n");
	}
      for (s = abfd->sections; s; s = s->next)
	if (s->flags & SEC_LOAD)
	  {
	    bfd_size_type section_size = bfd_section_size (abfd, s);
	    bfd_vma section_base = bfd_section_lma (abfd, s);

	    data_count += section_size;

	    printf_filtered ("Loading section %s, size 0x%lx lma ",
			     bfd_section_name (abfd, s),
			     (unsigned long) section_size);
	    fputs_filtered (paddress (target_gdbarch (), section_base),
			    gdb_stdout);
	    printf_filtered ("\n");
	    gdb_flush (gdb_stdout);
	  }
      /* Finally, make the PC point at the start address.  */
      regcache_write_pc (get_current_regcache (),
			 bfd_get_start_address (abfd));
      printf_filtered ("Start address 0x%lx\n", 
		       (unsigned long) bfd_get_start_address (abfd));
      print_transfer_performance (gdb_stdout, data_count, 0, &start_time,
				  &end_time);
    }
  inferior_ptid = null_ptid;	/* No process now.  */

  /* This is necessary because many things were based on the PC at the
     time that we attached to the monitor, which is no longer valid
     now that we have loaded new code (and just changed the PC).
     Another way to do this might be to call normal_stop, except that
     the stack may not be valid, and things would get horribly
     confused...  */

  clear_symtab_users (0);
  do_cleanups (cleanup);
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_m32r_rom;

void
_initialize_m32r_rom (void)
{
  /* Initialize m32r RevC monitor target.  */
  init_m32r_cmds ();
  init_monitor_ops (&m32r_ops);

  m32r_ops.to_shortname = "m32r";
  m32r_ops.to_longname = "m32r monitor";
  m32r_ops.to_load = m32r_load_gen;	/* Monitor lacks a download
					   command.  */
  m32r_ops.to_doc = "Debug via the m32r monitor.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  m32r_ops.to_open = m32r_open;
  add_target (&m32r_ops);

  /* Initialize mon2000 monitor target */
  init_mon2000_cmds ();
  init_monitor_ops (&mon2000_ops);

  mon2000_ops.to_shortname = "mon2000";
  mon2000_ops.to_longname = "Mon2000 monitor";
  mon2000_ops.to_load = m32r_load_gen;	/* Monitor lacks a download
					   command.  */
  mon2000_ops.to_doc = "Debug via the Mon2000 monitor.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  mon2000_ops.to_open = mon2000_open;
  add_target (&mon2000_ops);

  add_setshow_string_cmd ("download-path", class_obscure, &download_path, _("\
Set the default path for downloadable SREC files."), _("\
Show the default path for downloadable SREC files."), _("\
Determines the default path for downloadable SREC files."),
			  NULL,
			  NULL, /* FIXME: i18n: The default path for
				   downloadable SREC files is %s.  */
			  &setlist, &showlist);

  add_setshow_string_cmd ("board-address", class_obscure, &board_addr, _("\
Set IP address for M32R-EVA target board."), _("\
Show IP address for M32R-EVA target board."), _("\
Determine the IP address for M32R-EVA target board."),
			  NULL,
			  NULL, /* FIXME: i18n: IP address for
				   M32R-EVA target board is %s.  */
			  &setlist, &showlist);

  add_setshow_string_cmd ("server-address", class_obscure, &server_addr, _("\
Set IP address for download server (GDB's host computer)."), _("\
Show IP address for download server (GDB's host computer)."), _("\
Determine the IP address for download server (GDB's host computer)."),
			  NULL,
			  NULL, /* FIXME: i18n: IP address for
				   download server (GDB's host
				   computer) is %s.  */
			  &setlist, &showlist);

  add_com ("upload", class_obscure, m32r_upload_command, _("\
Upload the srec file via the monitor's Ethernet upload capability."));

  add_com ("tload", class_obscure, m32r_load, _("test upload command."));
}
@


1.57
log
@	* breakpoint.c (catch_syscall_split_args): Use skip_spaces.
	(trace_pass_command): Likewise.
	* cli/cli-cmds.c: Include cli/cli-utils.h.
	(source_command): Use skip-spaces.
	(disassemble_command): Likewise.
	* findcmd.c: Include cli/cli-utils.h.
	(parse_find_args): Use skip_spaces.
	* go32-nat.c: Include cli/cli-utils.h.
	(go32_sldt): Use skip_spaces.
	(go32_sgdt): Likewise.
	(go32_sidt): Likewise.
	(go32_pde): Likewise.
	(go32_pte): Likewise.
	(go32_pte_for_address): Likewise.
	* infcmd.c: Include cli/cli-utils.h.
	(registers_info): Use skip_spaces.
	* linux-tdep.c (read_mapping): Use skip_spaces_const.
	(linux_info_proc): Likewise.
	* linux-thread-db.c: Include cli/cli-utils.h.
	(info_auto_load_libthread_db): Use skip_spaces_const.
	* m32r-rom.c: Include cli/cli-utils.h.
	(m32r_upload_command): Use skip_spaces.
	* maint.c: Include cli/cli-utils.h.
	(maintenance_translate_address): Use skip_spaces.
	* mi/mi-parse.c: Include cli/cli-utils.h.
	(mi_parse_argv): Use skip_spaces.
	(mi_parse): Likewise.
	* minsyms.c: Include cli/cli-utils.h.
	(msymbol_hash_iw): Use skip_spaces_const.
	* objc-lang.c: Include cli/cli-utils.h.
	(parse_selector): Use skip_spaces.
	(parse_method): Likewise.
	* python/python.c: Include cli/cli-utils.h.
	(python_interactive_command)[HAVE_PYTHON]: Use skip_spaces.
	(python_command)[HAVE_PYTHON]: Likewise.
	(python_interactive_command)[!HAVE_PYTHON]: Likewise.
	* remote-m32r-sdi.c: Include cli/cli-utils.h.
	(m32r_load): Use skip_spaces.
	* serial.c: Include cli/cli-utils.h.
	(serial_open): Use skip_spaces_const.
	* stack.c: Include cli/cli-utils.h.
	(parse_frame_specification_1): Use skip_spaces_const.
	* symfile.c: Include cli/cli-utils.h.
	(set_ext_lang_command): Use skip_spaces.
	* symtab.c: Include cli/cli-utils.h.
	(rbreak_command): Use skip_spaces.
	* thread.c (thread_name_command): Use skip_spaces.
	* tracepoint.c (validate_actionline): Use skip_spaces.
	(encode_actions_1): Likewise.
	(trace_find_range_command): Likewise.
	(trace_find_outside_command): Likewise.
	(trace_dump_actions): Likewise.
@
text
@d170 1
@


1.56
log
@Garbage collect struct monitor_ops::load_routine.

While touching monitor_load in a previous patch, I noticed this method
is no longer set to anything other than NULL in the tree, so we can
remove it.

Tested by building with --enable-targets=all.

2013-02-19  Pedro Alves  <palves@@redhat.com>

	Garbage collect 'struct monitor_ops'::load_routine.

	* monitor.h (struct monitor_ops) <load_routine>: Remove field.
	* monitor.c (monitor_load): No longer call
	current_monitor->load_routine.
	* dbug-rom.c (init_dbug_cmds): Don't set 'load_routine'.
	* m32r-rom.c (init_m32r_cmds): Don't set 'load_routine'.
	* ppcbug-rom.c (init_ppc_cmds): Don't set 'load_routine'.
@
text
@d43 1
d452 1
a452 2
      while (isspace (*myIPaddress))
	myIPaddress++;
@


1.55
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a350 1
  m32r_cmds.load_routine = NULL;	/* load_routine (defaults to SRECs) */
a410 1
  mon2000_cmds.load_routine = NULL;	/* load_routine (defaults to SRECs) */
@


1.54
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d4 1
a4 2
   Copyright (C) 1996-2001, 2004-2005, 2007-2012 Free Software
   Foundation, Inc.
@


1.53
log
@	* windows-nat.c (windows_make_so): Use gdb_bfd_open.
	* symfile.c (bfd_open_maybe_remote): Use gdb_bfd_open.
	(symfile_bfd_open): Likewise.
	(generic_load): Likewise.
	* solib.c (solib_bfd_fopen): Use gdb_bfd_open.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use
	gdb_bfd_open.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use gdb_bfd_open.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_open.
	* remote-mips.c (mips_load_srec): Use gdb_bfd_open.
	(pmon_load_fast): Likewise.
	* remote-m32r-sdi.c (m32r_load): Use gdb_bfd_open.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_open.
	* machoread.c (macho_symfile_read_all_oso): Use gdb_bfd_open.
	(macho_check_dsym): Likewise.
	* m32r-rom.c (m32r_load): Use gdb_bfd_open.
	(m32r_upload_command): Likewise.
	* gdb_bfd.h (gdb_bfd_cache): Declare.
	* gdb_bfd.c (struct gdb_bfd_data): New.
	(gdb_bfd_cache): New global.
	(struct gdb_bfd_cache_search): New.
	(hash_bfd): New function.
	(eq_bfd): Likewise.
	(gdb_bfd_open): Likewise.
	(gdb_bfd_ref): Allocate a gdb_bfd_data and attach to the BFD.
	(gdb_bfd_unref): Remove closed BFD from cache.  Update for
	gdb_bfd_data.
	* exec.c (exec_file_attach): Use gdb_bfd_open.
	* dsrec.c (load_srec): Use gdb_bfd_open.
@
text
@d82 1
a82 1
      int addr_size = gdbarch_addr_bit (target_gdbarch) / 8;
d92 1
a92 1
      fputs_filtered (paddress (target_gdbarch, section_base), gdb_stdout);
d152 1
a152 1
	fputs_filtered (paddress (target_gdbarch, section_base), gdb_stdout);
d551 1
a551 1
	    fputs_filtered (paddress (target_gdbarch, section_base),
@


1.52
log
@	* cli/cli-dump.c (bfd_openr_with_cleanup): Use gdb_bfd_openr.
	(bfd_openw_with_cleanup): Use gdb_bfd_openw.
	* corelow.c (core_open): Use gdb_bfd_fopen.
	* dsrec.c (load_srec): Use gdb_bfd_openr.
	* exec.c (exec_file_attach): Use gdb_bfd_fopen.
	* gcore.c (gcore_memory_sections): Use gdb_bfd_openw.
	* gdb_bfd.c (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): New functions.
	* gdb_bfd.h (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): Declare.
	* jit.c (bfd_open_from_target_memory): Use gdb_bfd_openr_iovec.
	* m32-rom.c (m32r_load, m32r_upload_command): Use gdb_bfd_openr.
	* machoread.c (macho_symfile_read_all_oso): Use gdb_bfd_openr,
	gdb_bfd_openr_next_archived_file.
	(macho_check_dsym): Use gdb_bfd_openr.
	(macho_add_oso_symfile): Don't call gdb_bfd_stash_filename.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_fdopenr.
	* remote-m32r-sdi.c (m32r_load): Use gdb_bfd_openr.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Use
	gdb_bfd_openr.
	* remote.c (remote_bfd_open): Use gdb_bfd_openr_iovec.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_openr, gdb_bfd_fdopenr,
	gdb_bfd_openr_next_archived_file.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use gdb_bfd_openr.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use
	gdb_bfd_openr.
	* solib-spu.c (spu_bfd_fopen): Use gdb_bfd_openr_iovec.
	* solib.c (solib_bfd_fopen): Use gdb_bfd_fopen.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_openr_iovec.
	* symfile.c (bfd_open_maybe_remote): Use gdb_bfd_openr.
	(symfile_bfd_open): Use gdb_bfd_fopen.
	(generic_load): Use gdb_bfd_openr.
	* windows-nat.c (windows_make_so): Use gdb_bfd_openr.
@
text
@d133 1
a133 1
  abfd = gdb_bfd_openr (filename, 0);
d532 1
a532 1
  abfd = gdb_bfd_openr (args, 0);
@


1.51
log
@	* bfd-target.c (target_bfd_reopen): Update.
	* cli/cli-dump.c (bfd_openr_with_cleanup)
	(bfd_openw_with_cleanup): Update.
	* corelow.c (core_open): Update.
	* dsrec.c (load_srec): Update.
	* exec.c (exec_file_attach): Update.
	* gcore.c (create_gcore_bfd): Update.
	* gdb_bfd.c (gdb_bfd_ref): Return void.
	(gdb_bfd_open): Update.
	* gdb_bfd.h (gdb_bfd_ref): Return void.
	Update comments.
	* jit.c (jit_bfd_try_read_symtab): Update.
	* m32r-rom.c (m32r_load, m32r_upload_command): Update.
	* machoread.c (macho_symfile_read_all_oso): Update.
	(macho_check_dsym): Update.
	* procfs.c (insert_dbx_link_bpt_in_file): Update.
	* remote-m32r-sdi.c (m32r_load): Update.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Update.
	* rs6000-nat.c (add_vmap): Update.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-spu.c (spu_bfd_open): Update.
	* solib.c (solib_bfd_fopen, solib_read_symbols): Update.
	* spu-linux-nat.c (spu_bfd_open): Update.
	* symfile.c (bfd_open_maybe_remote, symfile_bfd_open)
	(generic_load): Update.
	* windows-nat.c (windows_make_so): Update.
@
text
@d133 1
a133 2
  abfd = bfd_openr (filename, 0);
  gdb_bfd_ref (abfd);
d532 1
a532 2
  abfd = bfd_openr (args, 0);
  gdb_bfd_ref (abfd);
@


1.50
log
@	* utils.c (make_cleanup_bfd_unref): Rename from
	make_cleanup_bfd_close.
	* defs.h (make_cleanup_bfd_unref): Rename from
	make_cleanup_bfd_close.
	* cli/cli-dump.c (bfd_openr_with_cleanup): Update.
	(bfd_openw_with_cleanup): Update.
	* corelow.c (core_open): Update.
	* dsrec.c (load_srec): Update.
	* m32r-rom.c (m32r_load, m32r_upload_command): Update.
	* remote-m32r-sdi.c (m32r_load): Update.
	* remote-mips.c (mips_load_srec): Update.
	(pmon_load_fast): Update.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Update.
	(darwin_bfd_open): Update.
	* solib.c (solib_bfd_fopen): Update.
	* symfile-mem.c (symbol_file_add_from_memory): Update.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Update.
	(symfile_bfd_open): Update.
	(generic_load): Update.
@
text
@d133 2
a134 1
  abfd = gdb_bfd_ref (bfd_openr (filename, 0));
d533 2
a534 1
  abfd = gdb_bfd_ref (bfd_openr (args, 0));
@


1.49
log
@	* remote-mips.c (mips_load_srec): Use make_cleanup_bfd_close.
	(pmon_load_fast): Likewise.
	* m32r-rom.c (m32r_load): Use make_cleanup_bfd_close.
	(m32r_upload_command): Likewise.
	* dsrec.c (load_srec): Use make_cleanup_bfd_close.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use make_cleanup_bfd_close.
@
text
@d136 1
a136 1
  cleanup = make_cleanup_bfd_close (abfd);
d533 1
a533 1
  cleanup = make_cleanup_bfd_close (abfd);
@


1.48
log
@	* dwarf2read.c (try_open_dwo_file): Use gdb_bfd_ref and
	gdb_bfd_unref.
	(free_dwo_file): Use gdb_bfd_unref.
	* cli/cli-dump.c: Include gdb_bfd.h.
	(bfd_openw_with_cleanup): Use gdb_bfd_ref.
	(bfd_openr_with_cleanup): Likewise.
	* windows-nat.c (windows_make_so): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* utils.c: Include gdb_bfd.h.
	(do_bfd_close_cleanup): Use gdb_bfd_unref.
	* symfile.c: Include gdb_bfd.h.
	(separate_debug_file_exists): Use gdb_bfd_unref.
	(bfd_open_maybe_remote): Use gdb_bfd_ref.
	(symfile_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	(generic_load): Use gdb_bfd_ref.
	(reread_symbols): Use gdb_bfd_unref.
	* symfile-mem.c: Include gdb_bfd.h.
	(symbol_file_add_from_memory): Use make_cleanup_bfd_close.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib.c: Include gdb_bfd.h.
	(solib_bfd_fopen): Use gdb_bfd_ref.
	(solib_bfd_open): Use gdb_bfd_unref.
	(free_so_symbols): Use gdb_bfd_unref.
	(reload_shared_libraries_1): Use gdb_bfd_unref.
	* solib-spu.c: Include gdb_bfd.h.
	(spu_bfd_fopen): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* solib-frv.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-dsbt.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-darwin.c: Include gdb_bfd.h.
	(darwin_solib_get_all_image_info_addr_at_init): Use gdb_bfd_ref,
	gdb_bfd_unref.
	(darwin_bfd_open): Use gdb_bfd_unref.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_ref, gdb_bfd_unref.
	* remote-mips.c: Include gdb_bfd.h.
	(mips_load_srec): Use gdb_bfd_ref.
	(pmon_load_fast): Use gdb_bfd_ref.
	* remote-m32r-sdi.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	* record.c: Include gdb_bfd.h.
	(record_save_cleanups): Use gdb_bfd_unref.
	(cmd_record_save): Use gdb_bfd_unref.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* objfiles.h (gdb_bfd_close_or_warn): Remove.
	(gdb_bfd_ref, gdb_bfd_unref): Move to gdb_bfd.h.
	* objfiles.c: Include gdb_bfd.h.
	(free_objfile): Use gdb_bfd_unref.
	(gdb_bfd_close_or_warn, gdb_bfd_ref, gdb_bfd_unref): Move to
	gdb_bfd.c.
	* machoread.c (macho_add_oso_symfile): Use gdb_bfd_unref.
	(macho_symfile_read_all_oso): Use gdb_bfd_ref, gdb_bfd_unref.
	(macho_check_dsym): Likewise.
	* m32r-rom.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	(m32r_upload_command): Use gdb_bfd_ref.
	* jit.c: Include gdb_bfd.h.
	(jit_bfd_try_read_symtab): Use gdb_bfd_ref, gdb_bfd_unref.
	* gdb_bfd.h: New file.
	* gdb_bfd.c: New file.
	* gcore.c: Include gdb_bfd.h.
	(create_gcore_bfd): Use gdb_bfd_ref.
	(do_bfd_delete_cleanup): Use gdb_bfd_unref.
	(gcore_command): Use gdb_bfd_unref.
	* exec.c: Include gdb_bfd.h.
	(exec_close): Use gdb_bfd_unref.
	(exec_close_1): Use gdb_bfd_unref.
	(exec_file_attach): Use gdb_bfd_ref.
	* elfread.c: Include gdb_bfd.h.
	(build_id_verify): Use gdb_bfd_unref.
	* dsrec.c: Include gdb_bfd.h.
	(load_srec): Use gdb_bfd_ref.
	* corelow.c: Include gdb_bfd.h.
	(core_close): Use gdb_bfd_unref.
	(core_open): Use gdb_bfd_ref.
	* bfd-target.c: Include gdb_bfd.h.
	(target_bfd_xclose): Use gdb_bfd_unref.
	(target_bfd_reopen): Use gdb_bfd_ref.
	* Makefile.in (SFILES): Add gdb_bfd.c.
	(HFILES_NO_SRCDIR): Add gdb_bfd.h.
	(COMMON_OBS): Add gdb_bfd.o.
@
text
@d128 1
d136 1
d194 1
d441 1
d533 1
d574 1
@


1.47
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d43 1
d132 1
a132 1
  abfd = bfd_openr (filename, 0);
d528 1
a528 1
  abfd = bfd_openr (args, 0);
@


1.46
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d125 1
a125 2
  asection *s;
  unsigned int i, data_count = 0;
d240 3
d245 1
a538 1
	    unsigned int buffer;
@


1.45
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* m32r-rom.c (m32r_upload_command): Fix up ARI warnings for _
	markup.
@
text
@d4 2
a5 2
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2004, 2005, 2007, 2008,
   2009, 2010, 2011 Free Software Foundation, Inc.
@


1.45.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d4 2
a5 2
   Copyright (C) 1996-2001, 2004-2005, 2007-2012 Free Software
   Foundation, Inc.
@


1.44
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* m2-exp.y: Comment cleanup, mostly periods and spaces.
	* m2-lang.c: Ditto.
	* m2-typeprint.c: Ditto.
	* m2-valprint.c: Ditto.
	* m32c-tdep.c: Ditto.
	* m32r-linux-nat.c: Ditto.
	* m32r-rom.c: Ditto.
	* m32r-tdep.c: Ditto.
	* m32r-tdep.h: Ditto.
	* m68hc11-tdep.c: Ditto.
	* m58klinux-nat.c: Ditto.
	* m68k-tdep.c: Ditto.
	* m88k-tdep.c: Ditto.
	* m88k-tdep.h: Ditto.
	* machoread.c: Ditto.
	* macrocmd.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* mdebugread.h: Ditto.
	* memattr.c: Ditto.
	* memattr.h: Ditto.
	* memory-map.h: Ditto.
	* mep-tdep.c: Ditto.
	* microblaze-rom.c: Ditto.
	* microblaze-tdep.c: Ditto.
	* minsyms.c: Ditto.
	* mips-irix-tdep.c: Ditto.
	* mips-linux-nat.c: Ditto.
	* mips-linux-tdep.c: Ditto.
	* mips-linux-tdep.h: Ditto.
	* mipsnbsd-nat.c: Ditto.
	* mipsnbsd-tdep.c: Ditto.
	* mipsread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mips-tdep.h: Ditto.
	* mn10300-linux-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* mn10300-tdep.h: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* moxie-tdep.c: Ditto.
	* moxie-tdep.h: Ditto.
	* mt-tdep.c: Ditto.
@
text
@d450 2
a451 2
	error ("Please use 'set board-address' to "
	       "set the M32R-EVA board's IP address.");
d482 2
a483 2
	error ("Need to know gdb host computer's "
	       "IP address (use 'set server-address')");
d495 2
a496 2
	error ("Need to know default download "
	       "path (use 'set download-path')");
d517 3
a519 3
    error ("Upload file not found: %s.srec\n"
	   "Check IP addresses and download path.",
       args);
@


1.43
log
@run copyright.sh for 2011.
@
text
@d24 1
a24 1
/* This module defines communication with the Renesas m32r monitor */
d39 1
a39 1
#include "objfiles.h"		/* for ALL_OBJFILES etc. */
d177 1
a177 1
  /* Finally, make the PC point at the start address */
d182 1
a182 1
  inferior_ptid = null_ptid;	/* No process now */
d189 1
a189 1
     confused... */
d203 1
a203 1
/* This array of registers needs to match the indexes used by GDB. The
d206 1
a206 1
   either. So, typing "info reg sp" becomes an "A7". */
d230 1
a230 1
    {				/* special handling for 64-bit acc reg */
d232 1
a232 1
      val = strchr (val, ':');	/* skip past ':' to get 2nd word */
d246 2
a247 1
	  monitor_supply_register (regcache, SM_REGNUM, (psw & 0x80) ? one : zero);
d251 2
a252 1
	  monitor_supply_register (regcache, BSM_REGNUM, (psw & 0x8000) ? one : zero);
d256 2
a257 1
	  monitor_supply_register (regcache, IE_REGNUM, (psw & 0x40) ? one : zero);
d261 2
a262 1
	  monitor_supply_register (regcache, BIE_REGNUM, (psw & 0x4000) ? one : zero);
d266 2
a267 1
	  monitor_supply_register (regcache, COND_REGNUM, (psw & 0x1) ? one : zero);
d270 2
a271 1
	  monitor_supply_register (regcache, CBR_REGNUM, (psw & 0x1) ? one : zero);
d274 2
a275 1
	  monitor_supply_register (regcache, BPC_REGNUM, zero);	/* KLUDGE:   (???????) */
d278 2
a279 1
	  monitor_supply_register (regcache, BCARRY_REGNUM, zero);	/* KLUDGE: (??????) */
d284 1
a284 1
	{			/* special handling for stack pointer (spu or spi) */
d342 2
a343 1
  m32r_cmds.register_pattern = "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)";	/* register_pattern */
d403 2
a404 1
  mon2000_cmds.register_pattern = "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)";	/* register_pattern */
d435 1
a435 1
  /* first check to see if there's an ethernet port! */
d443 1
a443 1
      /* scan second colon in the output from the "ust" command */
d450 2
a451 2
	error
	  ("Please use 'set board-address' to set the M32R-EVA board's IP address.");
d460 1
a460 1
      /* Winsock initialization. */
d481 3
a483 3
      if (server_addr == 0)	/* failed? */
	error
	  ("Need to know gdb host computer's IP address (use 'set server-address')");
d486 2
a487 1
  if (args == 0 || args[0] == 0)	/* no args: upload the current file */
d495 2
a496 2
	error
	  ("Need to know default download path (use 'set download-path')");
d501 1
a501 1
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result? */
d503 1
a503 1
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result? */
d508 1
a508 1
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result? */
d514 1
a514 1
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result? */
d517 2
a518 2
    error
      ("Upload file not found: %s.srec\nCheck IP addresses and download path.",
d526 1
a526 1
    {				/* Download is done -- print section statistics */
d548 1
a548 1
      /* Finally, make the PC point at the start address */
d556 1
a556 1
  inferior_ptid = null_ptid;	/* No process now */
d563 1
a563 1
     confused... */
d574 1
a574 1
  /* Initialize m32r RevC monitor target */
d580 2
a581 1
  m32r_ops.to_load = m32r_load_gen;	/* monitor lacks a download command */
d593 2
a594 1
  mon2000_ops.to_load = m32r_load_gen;	/* monitor lacks a download command */
d605 2
a606 1
			  NULL, /* FIXME: i18n: The default path for downloadable SREC files is %s.  */
d614 2
a615 1
			  NULL, /* FIXME: i18n: IP address for M32R-EVA target board is %s.  */
d623 3
a625 1
			  NULL, /* FIXME: i18n: IP address for download server (GDB's host computer) is %s.  */
@


1.42
log
@gdb/
	* infrun.c (follow_exec): Replace symbol_file_add_main by
	symbol_file_add with SYMFILE_DEFER_BP_RESET, set_initial_language and
	breakpoint_re_set.
	* m32r-rom.c (m32r_load, m32r_upload_command): Use parameter 0 for
	clear_symtab_users.
	* objfiles.c (free_all_objfiles): Likewise.
	* remote-m32r-sdi.c (m32r_load): Likewise.
	* solib-som.c (som_solib_create_inferior_hook): Likewise.
	* symfile.c (new_symfile_objfile): New comment for add_flags.  Call
	clear_symtab_users with ADD_FLAGS.
	(reread_symbols): Use parameter 0 for clear_symtab_users.
	(clear_symtab_users): New parameter add_flags.  Do not call
	breakpoint_re_set if SYMFILE_DEFER_BP_RESET.
	(clear_symtab_users_cleanup): Use parameter 0 for clear_symtab_users.
	* symtab.h (clear_symtab_users): New parameter add_flags.

gdb/testsuite/
	* gdb.base/pie-execl.exp: New file.
	* gdb.base/pie-execl.c: New file.
@
text
@d5 1
a5 1
   2009, 2010 Free Software Foundation, Inc.
@


1.41
log
@	* m32r-rom.c: Replace winsock.h with winsock2.h header.
	* remote-m32r-sdi.c: Replace winsock.h by winsock2.h.
@
text
@d191 1
a191 1
  clear_symtab_users ();
d554 1
a554 1
  clear_symtab_users ();
@


1.40
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d48 1
a48 1
#include <winsock.h>
@


1.39
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d5 1
a5 1
   2009 Free Software Foundation, Inc.
@


1.38
log
@	* inferior.h (read_pc, write_pc): Remove.
	* regcache.c (read_pc, write_pc): Remove.

	* infrun.c (displaced_step_fixup): Use regcache_read_pc instead
	of read_pc.
	(handle_inferior_event): Use regcache_read_pc instead of read_pc
	when determining value of stop_pc.  Replace subsequent uses of
	read_pc by inspecting already-retrieved stop_pc value.
	(keep_going): Use regcache_read_pc instead of read_pc.

	* breakpoint.c (watchpoint_check): Use current frame architecture
	and PC instead of current_gdbarch and read_pc ().
	* tracepoint.c (set_traceframe_context): Replace PC argument
	with FRAME argument.
	(trace_start_command, finish_tfind_command): Update calls.
	(finish_tfind_command): Compare frame IDs to identify transitions
	between frames.
	(trace_find_pc_command): Use regcache_read_pc instead of read_pc.
	* rs6000-nat.c (exec_one_dummy_insn): Pass in regcache instead
	of gdbarch.  Use regcache_read_pc and regcache_write_pc instead
	of read_pc and write_pc.
	(store_register): Make regcache argument non-const.  Update call
	to exec_one_dummy_insn.

	* thread.c (switch_to_thread): Use regcache_read_pc instead of read_pc.
	* infcmd.c (post_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (enable_break, svr4_relocate_main_executable): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Likewise.
	* record.c (record_wait): Likewise.
	* procfs.c (procfs_wait): Likewise.
	* remote-mips.c (common_open, mips_wait): Likewise.
	* remote-m32r-sdi.c (m32r_resume): Likewise.

	* symfile.c (generic_load): Use regcache_write_pc instead of write_pc.
	* monitor.c (monitor_create_inferior, monitor_load): Likewise.
	* m32r-rom.c (m32r_load, m32r_upload_command): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior, m32r_load): Likewise.
	* remote-mips.c (mips_create_inferior, mips_load): Likewise.

	* solib-darwin.c: Include "regcache.h".
	* solib-pa64.c: Include "regcache.h".
	* solib-svr4.c: Include "regcache.h.".

	* symfile.c: Do not mention read_pc or write_pc in comments.
	* dink32-rom.c: Likewise.
	* m32r-rom.c: Likewise.
	* mips-tdep.c: Likewise.
@
text
@d81 1
d91 1
a91 1
      fputs_filtered (paddress (section_base), gdb_stdout);
d94 1
a94 1
      monitor_printf ("%s mw\r", paddr_nz (section_base));
d150 1
a150 1
	fputs_filtered (paddress (section_base), gdb_stdout);
d532 2
a533 1
	    fputs_filtered (paddress (section_base), gdb_stdout);
@


1.37
log
@	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
        * alpha-linux-tdep.c (alpha_linux_regset_from_core_section): Make
	it static.
        * alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Declare.
        * amd64fbsd-tdep.c (amd64fbsd_init_abi): Make it static.
        * amd64nbsd-tdep.c (_initialize_amd64nbsd_ndep): Rename to ...
	(_initialize_amd64nbsd_tdep): ... this.
	* arm-linux-tdep.c (arm_linux_software_single_step): Make it static.
	(_initialize_arm_linux_tdep): Declare.
	* armbsd-tdep.c (armbsd_fpreg_offset): Make it static.
	* armnbsd-tdep.c (_initialize_arm_netbsd_tdep): Declare.
	* armobsd-tdep.c (_initialize_armobsd_tdep): Declare.
	* avr-tdep.c (avr_return_value): Make it static.
	(avr_frame_unwind_cache): Ditto.
	* bsd-uthread.c (bsd_uthread_inferior_created): Ditto.
	(bsd_uthread_solib_loaded): Ditto.
	(bsd_uthread_solib_unloaded): Ditto.
	(bsd_uthread_target): Ditto.
	(_initialize_bsd_uthread): Declare.
	* cris-tdep.c (crisv32_single_step_through_delay): Make it static.
	(cris_frame_unwind_cache): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_use_struct_convention): Ditto.
	(h8300h_use_struct_convention): Ditto.
	* hppa-tdep.c (hppa_sign_extend, hppa_low_hppa_sign_extend):
	Ditto.
	* hppa-tdep.h (hppa_low_sign_extend, hppa_sign_extend): Delete
	declarations.
	* hppabsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_find_global_pointer): Make it static.
	* hppabsd-tdep.h: New.
	* hppanbsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Remove declaration.
	(_initialize_hppabsd_tdep): Remove declaration.
	(_initialize_hppanbsd_tdep): Declare.
	* hppaobsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Delete declaration.
	(hppaobsd_init_abi): Make it static.
	* i386-nto-tdep.c (_initialize_i386nto_tdep): Declare.
	* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Declare.
	* ia64-linux-tdep.c (_initialize_ia64_linux_tdep): Declare.
	* ia64-tdep.c (ia64_register_reggroup_p): Make it static.
	* iq2000-tdep.c (_initialize_iq2000_tdep): Declare.
	* m32c-tdep.c (m32c_register_reggroup_p): Make it static.
	(m32c_analyze_prologue, m32c_virtual_frame_pointer): Ditto.
	(_initialize_m32c_tdep): Declare.
	* m32r-rom.c (_initialize_m32r_rom): Declare.
	* m32r-tdep.c (m32r_skip_prologue): Make it static.
	(m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Make it static.
	(m68hc11_return_value): Ditto.
	* m68klinux-tdep.c (_initialize_m68k_linux_tdep): Declare.
	* m88k-tdep.c (m88k_frame_cache): Make it static.
	* mep-tdep.c (mep_gdb_print_insn): Ditto.
	(mep_return_value): Ditto.
	(_initialize_mep_tdep): Declare.
	* mips-irix-tdep.c (_initialize_mips_irix_tdep): Declare.
	* mips-linux-tdep.c (supply_64bit_reg): Make it static.
	(mips_linux_syscall_next_pc): Ditto.
	(_initialize_mips_linux_tdep): Declare.
	* mips-tdep.c (mips_single_step_through_delay): Make it static.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Declare.
	* mn10300-linux-tdep.c (_initialize_mn10300_linux_tdep): Declare.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Declare.
	* mt-tdep.c (_initialize_mt_tdep): Declare.
	* nbsd-tdep.c: Include nbsd-tdep.h.
	* nto-tdep.c (find_load_phdr): Make it static.
	(_initialize_nto_tdep): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Make it
	static.
	(_initialize_ppc_linux_tdep): Declare.
	* remote-m32r-sdi.c (m32r_can_use_hw_watchpoint)
	(m32r_insert_watchpoint, m32r_remove_watchpoint)
	(m32r_stopped_data_address, m32r_stopped_by_watchpoint): Make
	static.
	* rs6000-aix-tdep.c (_initialize_rs6000_aix_tdep): Declare.
	* rs6000-nat.c: Include xcoffread.h.
	(find_toc_address): Don't extern declare get_toc_offset.  Adjust
	to call xcoff_get_to_offset.
	* rs6000-tdep.c (ppc_vsx_support_p, ppc_displaced_step_fixup)
	(rs6000_skip_main_prologue, rs6000_in_solib_return_trampoline)
	(rs6000_skip_trampoline_code): Make static.
	* s390-tdep.c (s390_regset_from_core_section): Ditto.
	* sh-tdep.c (sh_register_reggroup_p): Ditto.
	* shnbsd-tdep.c (shnbsd_regset_from_core_section): Ditto.
	(_initialize_shnbsd_tdep): Declare.
	* solib-frv.c (displacement_from_map): Make static.
	(_initialize_frv_solib): Declare.
	* solib-irix.c (fetch_lm_info): Make static.
	(_initialize_irix_solib): Declare.
	* solib-som.c: Include solib-som.h.
	(som_solib_select): Line break.
	* sparc-tdep.c (sparc_regset_from_core_section): Make static.
	* sparcnbsd-tdep.c (_initialize_sparnbsd_tdep): Rename to ...
	(_initialize_sparcnbsd_tdep): ... this.
	* spu-tdep.c (spu_software_single_step): Make it static.
	(_initialize_spu_tdep): Declare.
	* vax-tdep.c (vax_frame_cache): Make it static.
	* xcoffread.c: Include xcoffread.h.
	(get_toc_offset): Rename to ...
	(xcoff_get_toc_offset): ... this.
	(_initialize_xcoffread): Declare.
	* xcoffread.h: New.
	* xtensa-linux-tdep.c (_initialize_xtensa_linux_tdep): Declare.
	* xtensa-tdep.c (xtensa_skip_prologue, xtensa_derive_tdep): Make
	static.
	(_initialize_xtensa_tdep): Declare.
@
text
@d40 1
a40 1
#include "inferior.h"		/* for write_pc() */
d178 2
a179 1
    write_pc (bfd_get_start_address (exec_bfd));
d536 2
a537 1
      write_pc (bfd_get_start_address (abfd));
@


1.36
log
@        Updated copyright notices for most files.
@
text
@d553 3
@


1.35
log
@	* exec.c: #include "arch-utils.h"
	 (print_section_info): Use gdbarch_from_bfd to get at the
	current architecture. Replace current_gdbarch. Fix indention.
	Replace deprecated_print_address_numeric by paddress.
	* Makefile.in (exec.o) Add dependency to arch-utils.h.

	* valprint.c (val_print_string): Replace
	deprecated_print_address_numeric.
	* tracepoint.c (trace_mention, scope_info): Likewise.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1, print_symbol)
	(print_symbol, print_partial_symbols, maintenance_info_psymtabs)
	(maintenance_check_symtabs): Likewise.
	* symfile.c (list_overlays_command): Likewise.
	* stack.c (frame_info, print_block_frame_labels): Likewise.
	* printcmd.c (print_address, print_address_demangle)
	(address_info): Likewise.
	* corefile.c (memory_error): Likewise.
	* infcmd.c (jump_command): Likewise.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints)
	(mention, delete_breakpoint): Likewise.
	* c-valprint.c (print_function_pointer_address, c_val_print): Likewise.
	* dwarf2read.c (dump_die): Likewise.
	* ada-valprint.c (ada_val_print_1): Likewise.
	* f-valprint.c (f_val_print): Likewise.
	* linux-fork.c (info_forks_command): Likewise.
	* m32r-com.c (m32r_load_section, m32r_load)
	(m32r_upload_command): Likewise.

	* ui-out.c (ui_out_field_core_addr): Remove unnecessary comment.
@
text
@d4 2
a5 2
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2004, 2005, 2007, 2008
   Free Software Foundation, Inc.
@


1.34
log
@	Updated copyright notices for most files.
@
text
@d90 1
a90 1
      deprecated_print_address_numeric (section_base, 1, gdb_stdout);
d149 1
a149 1
	deprecated_print_address_numeric (section_base, 1, gdb_stdout);
d530 1
a530 1
	    deprecated_print_address_numeric (section_base, 1, gdb_stdout);
@


1.33
log
@	* amd64fsdb-tdep.c (amd64fbsd_sigtramp_start_addr): Use ULL suffix.
	(amd64fbsd_sigtramp_end_addr): Likewise.

	* iq2000-tdep.c (iq2000_pointer_to_address): Fix argument type.
	(iq2000_address_to_pointer): Likewise.
	(iq2000_frame_prev_register): Likewise.
	(iq2000_extract_return_value): Use regcache_cooked_read_unsigned
	instead of regcache_cooked_read into CORE_ADDR variable.
	(iq2000_return_value): Fix argument types.

	* m32r-rom.c (m32r_load_section): Fix printf argument type.
	(m32r_load): Likewise.

	* m68kbsd-tdep.c: Include "gdbtypes.h".
	* Makefile.in: Update dependencies.

	* mn10300-tdep.c (mn10300_frame_unwind_cache): Fix aliasing violation.

	* nto-tdep.c (LM_ADDR): Do not refer to no-longer-existing
	lmo->l_addr_size element.

	* remote-m32r-sdi.c (m32r_xfer_memory): Use paddr to print address.
	(m32r_insert_breakpoint): Likewise.
	(m32r_remove_breakpoint): Likewise.
	(m32r_insert_watchpoint): Likewise.
	(m32r_remove_watchpoint): Likewise.
	(m32r_load): Fix printf argument type.

	* xtensa-tdep.c (xtensa_regset_from_core_section): Fix printf
	argument type.
	(xtensa_frame_this_id): Do not cast pointers to "int" for output.
	(xtensa_frame_prev_register): Likewise.
	(xtensa_push_dummy_call): Likewise.
@
text
@d4 1
a4 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2004, 2005, 2007
@


1.32
log
@2007-11-16  Markus Deuling  <deuling@@de.ibm.com>

	* m32r-rom.c (m32r_supply_register): Use get_regcache_arch to get at
	the current architecture by regcache.
	* ppcnbsd-nat.c (ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, fetch_ppc_registers)
	(store_altivec_register, store_spe_register, store_register)
	(fill_vrregset, store_ppc_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Likewise.

	* trad-frame.c (trad_frame_alloc_saved_regs): Replace current_gdbarch by
	gdbarch.
	* user-regs.c (user_reg_map_name_to_regnum): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_return_value): Likewise.
	* m32c-tdep.c (m32c_register_reggroup_p): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* rs6000-tdep.c (ppc_dwarf2_frame_init_reg): Likewise.

	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Use get_frame_arch to
	get at the current architecture by frame_info.
	* gcore.c (derive_stack_segment): Likewise.

	* shnbsd-nat.c (GETREGS_SUPPLIES): Add gdbarch parameter.
	(shnbsd_fetch_inferior_registers, shnbsd_store_inferior_registers): Add
	gdbarch to GETREGS_SUPPLIES call.
@
text
@d88 2
a89 1
		       bfd_section_name (abfd, s), section_size);
d171 2
a172 1
  printf_filtered ("Start address 0x%lx\n", bfd_get_start_address (abfd));
d528 2
a529 1
			     bfd_section_name (abfd, s), section_size);
d536 2
a537 1
      printf_filtered ("Start address 0x%lx\n", bfd_get_start_address (abfd));
@


1.31
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d216 1
d279 1
a279 1
				     gdbarch_sp_regnum (current_gdbarch), val);
d282 1
a282 1
				     gdbarch_sp_regnum (current_gdbarch), val);
@


1.30
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d13 1
a13 1
   the Free Software Foundation; either version 2 of the License, or
d22 1
a22 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.29
log
@	* monitor.c (monitor_supply_register): Add REGCACHE parameter, use
	it instead of current_regcache.
	(parse_register_dump): Add REGCACHE parameter, pass it to
	supply_register callback.
	(monitor_dump_reg_block): Add REGCACHE parameter, pass it to
	parse_register_dump.
	(monitor_dump_regs): Add REGCACHE parameter, pass it to
	parse_register_dump and dumpregs callback.
	(monitor_wait): Pass current_regcache to parse_register_dump and
	monitor_dump_regs.
	(monitor_fetch_register): Pass current_regcache to
	monitor_supply_register.
	(monitor_fetch_registers): Pass current_regcache to
	monitor_dump_regs.
	* monitor.h (struct monitor_ops): Add REGCACHE parameter to
	supply_register and dumpregs callbacks.
	(monitor_supply_register, monitor_dump_reg_block): Update
	prototypes.
	* dbug-rom.c (dbug_supply_register): Add REGCACHE parameter.  Pass
	it to monitor_supply_register.
	* dink32-rom.c (dink32_supply_register): Likewise.
	* ppcbug-rom.c (ppcbug_supply_register): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.  Also, use REGCACHE
	instead of current_regcache.
@
text
@d279 2
a280 1
	    monitor_supply_register (regcache, SP_REGNUM, val);
d282 2
a283 1
	    monitor_supply_register (regcache, SP_REGNUM, val);
@


1.28
log
@Copyright updates for 2007.
@
text
@d213 2
a214 1
m32r_supply_register (char *regname, int regnamelen, char *val, int vallen)
d228 1
a228 1
      monitor_supply_register (ACCH_REGNUM, val);
d231 1
a231 1
	monitor_supply_register (ACCL_REGNUM, val + 1);
d235 1
a235 1
      monitor_supply_register (regno, val);
d243 1
a243 1
	  monitor_supply_register (SM_REGNUM, (psw & 0x80) ? one : zero);
d247 1
a247 1
	  monitor_supply_register (BSM_REGNUM, (psw & 0x8000) ? one : zero);
d251 1
a251 1
	  monitor_supply_register (IE_REGNUM, (psw & 0x40) ? one : zero);
d255 1
a255 1
	  monitor_supply_register (BIE_REGNUM, (psw & 0x4000) ? one : zero);
d259 1
a259 1
	  monitor_supply_register (COND_REGNUM, (psw & 0x1) ? one : zero);
d262 1
a262 1
	  monitor_supply_register (CBR_REGNUM, (psw & 0x1) ? one : zero);
d265 1
a265 1
	  monitor_supply_register (BPC_REGNUM, zero);	/* KLUDGE:   (???????) */
d268 1
a268 1
	  monitor_supply_register (BCARRY_REGNUM, zero);	/* KLUDGE: (??????) */
d275 1
a275 1
	  regcache_cooked_read_unsigned (current_regcache, PSW_REGNUM, &psw);
d279 1
a279 1
	    monitor_supply_register (SP_REGNUM, val);
d281 1
a281 1
	    monitor_supply_register (SP_REGNUM, val);
@


1.27
log
@2006-04-19  Masaki Muranaka  <monaka@@monami-software.com>

        * m32r-rom.c: On MinGW, include winsock.h instead of sys/types.h,
        netdb.h, netinet/in.h.
        (m32r_upload_command); Add calls WSAStartup().
        * remote-m32r-sdi.c: On MinGW, include winsock.h instead of
        netinet/in.h.
@
text
@d4 1
a4 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2004, 2005
@


1.26
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d49 3
d58 1
d442 7
@


1.25
log
@	Suggested by Shaun Jackman <sjackman@@gmail.com>:
	* defs.h (print_transfer_performance): Update prototype.
	* m32r-rom.c (m32r_load, m32r_upload_command): Use gettimeofday
	for print_transfer_performance.
	* remote-m32r-sdi.c (m32r_load): Likewise.
	* symfile.c (generic_load): Likewise.
	(report_transfer_performance): Create a dummy struct timeval.
	(print_transfer_performance): Use a more accurate measure
	of performance.
@
text
@d4 1
a4 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2004, 2005
d23 2
a24 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.24
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* command.h (fprint_setshow_ftype): Delete.
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* complaints.c, cris-tdep.c, dwarf2read.c, frame.c: Update.
	* hppa-tdep.c, infcall.c, m32r-rom.c, maint.c: Update.
	* mips-tdep.c, nto-tdep.c, observer.c, remote-rdi.c: Update
	* remote.c, target.c, cli/cli-logging.c: Update.
@
text
@d4 2
a5 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2004 Free Software
   Foundation, Inc.
d38 1
d123 1
a123 1
  time_t start_time, end_time;	/* for timing of download */
d133 1
a133 1
  start_time = time (NULL);
d167 1
a167 1
  end_time = time (NULL);
d169 2
a170 2
  print_transfer_performance (gdb_stdout, data_count, 0,
			      end_time - start_time);
d409 1
a409 1
  time_t start_time, end_time;	/* for timing of download */
d471 1
a471 1
  start_time = time (NULL);
d495 1
a495 1
  end_time = time (NULL);
d521 2
a522 2
      print_transfer_performance (gdb_stdout, data_count, 0,
				  end_time - start_time);
@


1.23
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d566 1
d568 1
a568 1
			  NULL, NULL, &setlist, &showlist);
d574 1
d576 1
a576 1
			  NULL, NULL, &setlist, &showlist);
d582 1
d584 1
a584 1
			  NULL, NULL, &setlist, &showlist);
@


1.22
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_setshow functions, replace "PRINT:" comment prefix
	with "FIXME: i18n:".
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* cris-tdep.c, dwarf2read.c, frame.c, hppa-tdep.c: Update.
	* infcall.c, m32r-rom.c, maint.c, mips-tdep.c: Update.
	* nto-tdep.c, observer.c, remote-rdi.c, remote.c: Update.
	* target.c, cli/cli-logging.c: Update.
@
text
@d583 2
a584 2
  add_com ("upload", class_obscure, m32r_upload_command,
	   "Upload the srec file via the monitor's Ethernet upload capability.");
d586 1
a586 1
  add_com ("tload", class_obscure, m32r_load, "test upload command.");
@


1.21
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	* utils.c (paddress): New function.
	* defs.h (paddress): Declare.
	* printcmd.c (deprecated_print_address_numeric): Rename
	print_address_numeric, call paddress.
	* valprint.c, ui-out.c, tui/tui-stack.c, tracepoint.c: Update.
	* symmisc.c, symfile.c stack.c, p-valprint.c, printcmd.c: Update.
	* maint.c, m32r-rom.c, infcmd.c, f-valprint.c, exec.c: Update.
	* dwarf2read.c, dve3900-rom.c, defs.h, c-valprint.c: Update.
	* corefile.c, cli/cli-cmds.c, breakpoint.c, annotate.c: Update.
	* ada-valprint.c: Update.
@
text
@d562 6
a567 6
  add_setshow_string_cmd ("download-path", class_obscure, &download_path, "\
Set the default path for downloadable SREC files.", "\
Show the default path for downloadable SREC files.", "\
Determines the default path for downloadable SREC files.",
			  NULL, /* PRINT: The default path for downloadable SREC files is %s.  */
		   NULL, NULL, &setlist, &showlist);
d569 6
a574 6
  add_setshow_string_cmd ("board-address", class_obscure, &board_addr, "\
Set IP address for M32R-EVA target board.", "\
Show IP address for M32R-EVA target board.", "\
Determine the IP address for M32R-EVA target board.",
			  NULL, /* PRINT: IP address for M32R-EVA target board is %s.  */
		   NULL, NULL, &setlist, &showlist);
d576 6
a581 6
  add_setshow_string_cmd ("server-address", class_obscure, &server_addr, "\
Set IP address for download server (GDB's host computer).", "\
Show IP address for download server (GDB's host computer).", "\
Determine the IP address for download server (GDB's host computer).",
			  NULL, /* PRINT: IP address for download server (GDB's host computer) is %s.  */
		   NULL, NULL, &setlist, &showlist);
@


1.20
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d86 1
a86 1
      print_address_numeric (section_base, 1, gdb_stdout);
d145 1
a145 1
	print_address_numeric (section_base, 1, gdb_stdout);
d513 1
a513 1
	    print_address_numeric (section_base, 1, gdb_stdout);
@


1.19
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_enum_cmd, add_setshow_cmd_full)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Replace
	print string parameter with fprint_setshow function.
	* command.h (fprint_setshow_ftype): Define.  Update declarations.
	* cli/cli-setshow.c (do_setshow_command): When fprint_setshow is
	available, use that.
	* cli/cli-decode.h (struct cmd_list_element): Add field
	fprint_setshow.
	* complaints.c (fprint_setshow_complaints): New function.
	(_initialize_complaints): Pass to add_setshow_zinteger_cmd.
	* hppa-tdep.c (_initialize_hppa_tdep): Replace "print" parameter
	with NULL.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* cris-tdep.c (_initialize_cris_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* target.c (initialize_targets): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* breakpoint.c (_initialize_breakpoint): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
@
text
@d129 1
a129 1
    error ("Unable to open file %s\n", filename);
d131 1
a131 1
    error ("File is not an object file\n");
d418 1
a418 1
    error ("No ethernet connection!");
@


1.18
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d565 2
a566 2
Determines the default path for downloadable SREC files.", "\
The default path for downloadable SREC files is %s.",
d572 2
a573 2
Determine the IP address for M32R-EVA target board.", "\
IP address for M32R-EVA target board is %s",
d579 2
a580 2
Determine the IP address for download server (GDB's host computer).", "\
IP address for download server (GDB's host computer) is %s.",
@


1.17
log
@2004-07-28  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd): Delete function.
	(add_setshow_cmd_full): Make static.
	* command.h (add_setshow_cmd, add_setshow_cmd_full): Delete.
	(add_setshow_filename_cmd, add_setshow_string_cmd): Declare.
	* cli/cli-decode.c (add_setshow_filename_cmd)
	(add_setshow_string_cmd): New functions.
	* nto-tdep.c (_initialize_nto_tdep): Update.  Fix parameters.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* m32r-rom.c (_initialize_m32r_rom): Update.  Update copyright.
	* cli/cli-logging.c (_initialize_cli_logging): Update.
	* complaints.c (_initialize_complaints): Update.
	* remote.c (_initialize_remote): Update.
@
text
@d31 1
@


1.16
log
@2004-07-28  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_zinteger_cmd)
	(add_setshow_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_cmd_full): Add help_doc and
	print parameters.  Make string parameters constant.
	* command.h: Update.  Update copyright.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* complaints.c (_initialize_complaints): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* target.c (initialize_targets): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* d10v-tdep.c (_initialize_d10v_tdep): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
@
text
@d561 1
a561 2
  add_setshow_cmd ("download-path", class_obscure,
		   var_string, &download_path, "\
d568 1
a568 2
  add_setshow_cmd ("board-address", class_obscure,
		   var_string, &board_addr, "\
d575 1
a575 2
  add_setshow_cmd ("server-address", class_obscure,
		   var_string, &server_addr, "\
@


1.15
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d3 3
a5 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d562 5
a566 3
		   var_string, &download_path,
		   "Set the default path for downloadable SREC files.",
		   "Show the default path for downloadable SREC files.",
d570 5
a574 3
		   var_string, &board_addr,
		   "Set IP address for M32R-EVA target board.",
		   "Show IP address for M32R-EVA target board.",
d578 5
a582 3
		   var_string, &server_addr,
		   "Set IP address for download server (GDB's host computer).",
		   "Show IP address for download server (GDB's host computer).",
@


1.14
log
@2004-01-27  Andrew Cagney  <cagney@@redhat.com>

	* source.c (ambiguous_line_spec): Delete undefined declaration.
	* m32r-rom.c (m32r_set_board_address): Delete unused function.
	(m32r_set_server_address, m32r_set_download_path): Ditto.
	* remote-fileio.c (remote_fileio_to_fio_int): Ditto.
@
text
@d322 1
a322 1
  m32r_cmds.supply_register = m32r_supply_register;	/* supply_register */
d382 1
a382 1
  mon2000_cmds.supply_register = m32r_supply_register;	/* supply_register */
@


1.14.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 2
a4 3

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2004 Free Software
   Foundation, Inc.
d322 1
a322 1
  m32r_cmds.supply_register = m32r_supply_register;
d382 1
a382 1
  mon2000_cmds.supply_register = m32r_supply_register;
d560 4
a563 5
  add_setshow_string_cmd ("download-path", class_obscure, &download_path, "\
Set the default path for downloadable SREC files.", "\
Show the default path for downloadable SREC files.", "\
Determines the default path for downloadable SREC files.", "\
The default path for downloadable SREC files is %s.",
d566 4
a569 5
  add_setshow_string_cmd ("board-address", class_obscure, &board_addr, "\
Set IP address for M32R-EVA target board.", "\
Show IP address for M32R-EVA target board.", "\
Determine the IP address for M32R-EVA target board.", "\
IP address for M32R-EVA target board is %s",
d572 4
a575 5
  add_setshow_string_cmd ("server-address", class_obscure, &server_addr, "\
Set IP address for download server (GDB's host computer).", "\
Show IP address for download server (GDB's host computer).", "\
Determine the IP address for download server (GDB's host computer).", "\
IP address for download server (GDB's host computer) is %s.",
@


1.13
log
@2003-08-01  Andrew Cagney  <cagney@@redhat.com>

	* NEWS: Mention that m32r is multi-arch.
	From 2003-07-28 Kei Sakamoto <sakamoto.kei@@renesas.com>:
	* configure.tgt: Recognize m32r-*-*.
	* config/m32r/tm-m32r.h: Delete file.
	* config/m32r/m32r.mt: New file.
	* m32r-rom.c (m32r_upload_command): Use hostent only when
        gethostname succeeds, in order to avoid a compilation
        warning.
	* m32r-tdep.c (m32r_store_return_value): Add a cast to remove a
	compiler warning.
@
text
@a400 57
/* Function: set_board_address
   Tell the BootOne monitor what it's ethernet IP address is. */

static void
m32r_set_board_address (char *args, int from_tty)
{
  int resp_len;
  char buf[1024];

  if (args && *args)
    {
      monitor_printf ("ulip %s\n", args);
      resp_len = monitor_expect_prompt (buf, sizeof (buf));
      /* now parse the result for success */
    }
  else
    error ("Requires argument (IP address for M32R-EVA board)");
}

/* Function: set_server_address
   Tell the BootOne monitor what gdb's ethernet IP address is. */

static void
m32r_set_server_address (char *args, int from_tty)
{
  int resp_len;
  char buf[1024];

  if (args && *args)
    {
      monitor_printf ("uhip %s\n", args);
      resp_len = monitor_expect_prompt (buf, sizeof (buf));
      /* now parse the result for success */
    }
  else
    error ("Requires argument (IP address of GDB's host computer)");
}

/* Function: set_download_path
   Tell the BootOne monitor the default path for downloadable SREC files. */

static void
m32r_set_download_path (char *args, int from_tty)
{
  int resp_len;
  char buf[1024];

  if (args && *args)
    {
      monitor_printf ("up %s\n", args);
      resp_len = monitor_expect_prompt (buf, sizeof (buf));
      /* now parse the result for success */
    }
  else
    error ("Requires argument (default path for downloadable SREC files)");
}

@


1.12
log
@2003-07-27  Andrew Cagney  <cagney@@redhat.com>

	Patch from 2003-07-22 Kei Sakamoto <sakamoto.kei@@renesas.com>:
	* m32r-tdep.c (m32r_memory_insert_breakpoint): Fix code style -
	operator at start and not end of line.
	(decode_prologue): Ditto.
	(m32r_frame_unwind_cache, m32r_unwind_sp, m32r_unwind_pc): Use
	frame_unwind_register_unsigned instead of
	frame_unwind_unsigned_register.
	(m32r_read_pc): Use regcache_cooked_read_unsigned instead of
	read_register.
	(m32r_push_dummy_call): Use register_size instead of
	REGISTER_RAW_SIZE.
	(m32r_frame_sniffer): Replace m32r_frame_p.
	(m32r_gdbarch_init): Call frame_unwind_append_sniffer.
	* m32r-rom.c (report_transfer_performance): Delete extern
	declaration.
	(m32r_load, m32r_upload_command): Use print_transfer_performance
	instead of report_transfer_performance.
	(_initialize_m32r_rom): Use add_setshow_cmd instead of add_set_cmd
	/ add_show_from_set.
@
text
@a494 2
	hostent = gethostbyname (buf);
      if (hostent != 0)
d496 3
d500 3
a502 3
	  memcpy (&inet_addr.s_addr, hostent->h_addr,
		  sizeof (inet_addr.s_addr));
	  server_addr = (char *) inet_ntoa (inet_addr);
d504 1
a504 1
	  server_addr = (char *) inet_ntoa (hostent->h_addr);
d506 1
@


1.11
log
@2003-07-21  Andrew Cagney  <cagney@@redhat.com>

	From 2003-07-04 Kei Sakamoto <sakamoto.kei@@renesas.com>:
	* m32r-tdep.c, m32r-stub.c, m32r-tdep.c: Rewrite.
@
text
@a42 2
extern void report_transfer_performance (unsigned long, time_t, time_t);

d166 2
a167 1
  report_transfer_performance (data_count, start_time, end_time);
d266 3
a268 1
	  unsigned long stackmode = read_register (PSW_REGNUM) & 0x80;
a571 1
      report_transfer_performance (data_count, start_time, end_time);
d573 2
d615 17
a631 17
  add_show_from_set
    (add_set_cmd ("download-path", class_obscure, var_string,
		  (char *) &download_path,
		  "Set the default path for downloadable SREC files.",
		  &setlist), &showlist);

  add_show_from_set
    (add_set_cmd ("board-address", class_obscure, var_string,
		  (char *) &board_addr,
		  "Set IP address for M32R-EVA target board.",
		  &setlist), &showlist);

  add_show_from_set
    (add_set_cmd ("server-address", class_obscure, var_string,
		  (char *) &server_addr,
		  "Set IP address for download server (GDB's host computer).",
		  &setlist), &showlist);
@


1.10
log
@2003-02-04  Andrew Cagney  <ac131313@@redhat.com>

	* NEWS: Note that the m32r-*-elf* is obsolete.
	* monitor.c (monitor_expect): Obsolete reference to m32r.
	* configure.tgt: Mark m32r-*-elf* as obsolete.
	* MAINTAINERS: Mark m32k as obsolete.
	* m32r-rom.c: Obsolete file.
	* config/m32r/m32r.mt: Obsolete file.
	* config/m32r/tm-m32r.h: Obsolete file.
	* m32r-stub.c: Obsolete file.
	* m32r-tdep.c: Obsolete file.
@
text
@d1 635
a635 626
// OBSOLETE /* Remote debugging interface to m32r and mon2000 ROM monitors for GDB, 
// OBSOLETE    the GNU debugger.
// OBSOLETE    Copyright 1996, 1997, 1998, 1999, 2000, 2001
// OBSOLETE    Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    Adapted by Michael Snyder of Cygnus Support.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /* This module defines communication with the Mitsubishi m32r monitor */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "monitor.h"
// OBSOLETE #include "serial.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "command.h"
// OBSOLETE #include "gdbcmd.h"
// OBSOLETE #include "symfile.h"		/* for generic load */
// OBSOLETE #include <time.h>		/* for time_t */
// OBSOLETE #include "gdb_string.h"
// OBSOLETE #include "objfiles.h"		/* for ALL_OBJFILES etc. */
// OBSOLETE #include "inferior.h"		/* for write_pc() */
// OBSOLETE #include <ctype.h>
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE extern void report_transfer_performance (unsigned long, time_t, time_t);
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * All this stuff just to get my host computer's IP address!
// OBSOLETE  */
// OBSOLETE #include <sys/types.h>
// OBSOLETE #include <netdb.h>		/* for hostent */
// OBSOLETE #include <netinet/in.h>		/* for struct in_addr */
// OBSOLETE #if 1
// OBSOLETE #include <arpa/inet.h>		/* for inet_ntoa */
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE static char *board_addr;	/* user-settable IP address for M32R-EVA */
// OBSOLETE static char *server_addr;	/* user-settable IP address for gdb host */
// OBSOLETE static char *download_path;	/* user-settable path for SREC files     */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* 
// OBSOLETE  * Function: m32r_load_1 (helper function)
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_load_section (bfd *abfd, asection *s, void *obj)
// OBSOLETE {
// OBSOLETE   unsigned int *data_count = obj;
// OBSOLETE   if (s->flags & SEC_LOAD)
// OBSOLETE     {
// OBSOLETE       bfd_size_type section_size = bfd_section_size (abfd, s);
// OBSOLETE       bfd_vma section_base = bfd_section_lma (abfd, s);
// OBSOLETE       unsigned int buffer, i;
// OBSOLETE 
// OBSOLETE       *data_count += section_size;
// OBSOLETE 
// OBSOLETE       printf_filtered ("Loading section %s, size 0x%lx lma ",
// OBSOLETE 		       bfd_section_name (abfd, s), section_size);
// OBSOLETE       print_address_numeric (section_base, 1, gdb_stdout);
// OBSOLETE       printf_filtered ("\n");
// OBSOLETE       gdb_flush (gdb_stdout);
// OBSOLETE       monitor_printf ("%s mw\r", paddr_nz (section_base));
// OBSOLETE       for (i = 0; i < section_size; i += 4)
// OBSOLETE 	{
// OBSOLETE 	  QUIT;
// OBSOLETE 	  monitor_expect (" -> ", NULL, 0);
// OBSOLETE 	  bfd_get_section_contents (abfd, s, (char *) &buffer, i, 4);
// OBSOLETE 	  monitor_printf ("%x\n", buffer);
// OBSOLETE 	}
// OBSOLETE       monitor_expect (" -> ", NULL, 0);
// OBSOLETE       monitor_printf ("q\n");
// OBSOLETE       monitor_expect_prompt (NULL, 0);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE m32r_load_1 (void *dummy)
// OBSOLETE {
// OBSOLETE   int data_count = 0;
// OBSOLETE 
// OBSOLETE   bfd_map_over_sections ((bfd *) dummy, m32r_load_section, &data_count);
// OBSOLETE   return data_count;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* 
// OBSOLETE  * Function: m32r_load (an alternate way to load) 
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_load (char *filename, int from_tty)
// OBSOLETE {
// OBSOLETE   bfd *abfd;
// OBSOLETE   asection *s;
// OBSOLETE   unsigned int i, data_count = 0;
// OBSOLETE   time_t start_time, end_time;	/* for timing of download */
// OBSOLETE 
// OBSOLETE   if (filename == NULL || filename[0] == 0)
// OBSOLETE     filename = get_exec_file (1);
// OBSOLETE 
// OBSOLETE   abfd = bfd_openr (filename, 0);
// OBSOLETE   if (!abfd)
// OBSOLETE     error ("Unable to open file %s\n", filename);
// OBSOLETE   if (bfd_check_format (abfd, bfd_object) == 0)
// OBSOLETE     error ("File is not an object file\n");
// OBSOLETE   start_time = time (NULL);
// OBSOLETE #if 0
// OBSOLETE   for (s = abfd->sections; s; s = s->next)
// OBSOLETE     if (s->flags & SEC_LOAD)
// OBSOLETE       {
// OBSOLETE 	bfd_size_type section_size = bfd_section_size (abfd, s);
// OBSOLETE 	bfd_vma section_base = bfd_section_vma (abfd, s);
// OBSOLETE 	unsigned int buffer;
// OBSOLETE 
// OBSOLETE 	data_count += section_size;
// OBSOLETE 
// OBSOLETE 	printf_filtered ("Loading section %s, size 0x%lx vma ",
// OBSOLETE 			 bfd_section_name (abfd, s), section_size);
// OBSOLETE 	print_address_numeric (section_base, 1, gdb_stdout);
// OBSOLETE 	printf_filtered ("\n");
// OBSOLETE 	gdb_flush (gdb_stdout);
// OBSOLETE 	monitor_printf ("%x mw\r", section_base);
// OBSOLETE 	for (i = 0; i < section_size; i += 4)
// OBSOLETE 	  {
// OBSOLETE 	    monitor_expect (" -> ", NULL, 0);
// OBSOLETE 	    bfd_get_section_contents (abfd, s, (char *) &buffer, i, 4);
// OBSOLETE 	    monitor_printf ("%x\n", buffer);
// OBSOLETE 	  }
// OBSOLETE 	monitor_expect (" -> ", NULL, 0);
// OBSOLETE 	monitor_printf ("q\n");
// OBSOLETE 	monitor_expect_prompt (NULL, 0);
// OBSOLETE       }
// OBSOLETE #else
// OBSOLETE   if (!(catch_errors (m32r_load_1, abfd, "Load aborted!\n", RETURN_MASK_ALL)))
// OBSOLETE     {
// OBSOLETE       monitor_printf ("q\n");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE #endif
// OBSOLETE   end_time = time (NULL);
// OBSOLETE   printf_filtered ("Start address 0x%lx\n", bfd_get_start_address (abfd));
// OBSOLETE   report_transfer_performance (data_count, start_time, end_time);
// OBSOLETE 
// OBSOLETE   /* Finally, make the PC point at the start address */
// OBSOLETE   if (exec_bfd)
// OBSOLETE     write_pc (bfd_get_start_address (exec_bfd));
// OBSOLETE 
// OBSOLETE   inferior_ptid = null_ptid;	/* No process now */
// OBSOLETE 
// OBSOLETE   /* This is necessary because many things were based on the PC at the
// OBSOLETE      time that we attached to the monitor, which is no longer valid
// OBSOLETE      now that we have loaded new code (and just changed the PC).
// OBSOLETE      Another way to do this might be to call normal_stop, except that
// OBSOLETE      the stack may not be valid, and things would get horribly
// OBSOLETE      confused... */
// OBSOLETE 
// OBSOLETE   clear_symtab_users ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_load_gen (char *filename, int from_tty)
// OBSOLETE {
// OBSOLETE   generic_load (filename, from_tty);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void m32r_open (char *args, int from_tty);
// OBSOLETE static void mon2000_open (char *args, int from_tty);
// OBSOLETE 
// OBSOLETE /* This array of registers needs to match the indexes used by GDB. The
// OBSOLETE    whole reason this exists is because the various ROM monitors use
// OBSOLETE    different names than GDB does, and don't support all the registers
// OBSOLETE    either. So, typing "info reg sp" becomes an "A7". */
// OBSOLETE 
// OBSOLETE static char *m32r_regnames[] =
// OBSOLETE {"r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
// OBSOLETE  "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
// OBSOLETE  "psw", "cbr", "spi", "spu", "bpc", "pc", "accl", "acch",
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_supply_register (char *regname, int regnamelen, char *val, int vallen)
// OBSOLETE {
// OBSOLETE   int regno;
// OBSOLETE   int num_regs = sizeof (m32r_regnames) / sizeof (m32r_regnames[0]);
// OBSOLETE 
// OBSOLETE   for (regno = 0; regno < num_regs; regno++)
// OBSOLETE     if (strncmp (regname, m32r_regnames[regno], regnamelen) == 0)
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE   if (regno >= num_regs)
// OBSOLETE     return;			/* no match */
// OBSOLETE 
// OBSOLETE   if (regno == ACCL_REGNUM)
// OBSOLETE     {				/* special handling for 64-bit acc reg */
// OBSOLETE       monitor_supply_register (ACCH_REGNUM, val);
// OBSOLETE       val = strchr (val, ':');	/* skip past ':' to get 2nd word */
// OBSOLETE       if (val != NULL)
// OBSOLETE 	monitor_supply_register (ACCL_REGNUM, val + 1);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       monitor_supply_register (regno, val);
// OBSOLETE       if (regno == PSW_REGNUM)
// OBSOLETE 	{
// OBSOLETE 	  unsigned long psw = strtoul (val, NULL, 16);
// OBSOLETE 	  char *zero = "00000000", *one = "00000001";
// OBSOLETE 
// OBSOLETE #ifdef SM_REGNUM
// OBSOLETE 	  /* Stack mode bit */
// OBSOLETE 	  monitor_supply_register (SM_REGNUM, (psw & 0x80) ? one : zero);
// OBSOLETE #endif
// OBSOLETE #ifdef BSM_REGNUM
// OBSOLETE 	  /* Backup stack mode bit */
// OBSOLETE 	  monitor_supply_register (BSM_REGNUM, (psw & 0x8000) ? one : zero);
// OBSOLETE #endif
// OBSOLETE #ifdef IE_REGNUM
// OBSOLETE 	  /* Interrupt enable bit */
// OBSOLETE 	  monitor_supply_register (IE_REGNUM, (psw & 0x40) ? one : zero);
// OBSOLETE #endif
// OBSOLETE #ifdef BIE_REGNUM
// OBSOLETE 	  /* Backup interrupt enable bit */
// OBSOLETE 	  monitor_supply_register (BIE_REGNUM, (psw & 0x4000) ? one : zero);
// OBSOLETE #endif
// OBSOLETE #ifdef COND_REGNUM
// OBSOLETE 	  /* Condition bit (carry etc.) */
// OBSOLETE 	  monitor_supply_register (COND_REGNUM, (psw & 0x1) ? one : zero);
// OBSOLETE #endif
// OBSOLETE #ifdef CBR_REGNUM
// OBSOLETE 	  monitor_supply_register (CBR_REGNUM, (psw & 0x1) ? one : zero);
// OBSOLETE #endif
// OBSOLETE #ifdef BPC_REGNUM
// OBSOLETE 	  monitor_supply_register (BPC_REGNUM, zero);	/* KLUDGE:   (???????) */
// OBSOLETE #endif
// OBSOLETE #ifdef BCARRY_REGNUM
// OBSOLETE 	  monitor_supply_register (BCARRY_REGNUM, zero);	/* KLUDGE: (??????) */
// OBSOLETE #endif
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (regno == SPI_REGNUM || regno == SPU_REGNUM)
// OBSOLETE 	{			/* special handling for stack pointer (spu or spi) */
// OBSOLETE 	  unsigned long stackmode = read_register (PSW_REGNUM) & 0x80;
// OBSOLETE 
// OBSOLETE 	  if (regno == SPI_REGNUM && !stackmode)	/* SP == SPI */
// OBSOLETE 	    monitor_supply_register (SP_REGNUM, val);
// OBSOLETE 	  else if (regno == SPU_REGNUM && stackmode)	/* SP == SPU */
// OBSOLETE 	    monitor_supply_register (SP_REGNUM, val);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* m32r RevC board monitor */
// OBSOLETE 
// OBSOLETE static struct target_ops m32r_ops;
// OBSOLETE 
// OBSOLETE static char *m32r_inits[] =
// OBSOLETE {"\r", NULL};
// OBSOLETE 
// OBSOLETE static struct monitor_ops m32r_cmds;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_m32r_cmds (void)
// OBSOLETE {
// OBSOLETE   m32r_cmds.flags = MO_CLR_BREAK_USES_ADDR | MO_REGISTER_VALUE_FIRST;
// OBSOLETE   m32r_cmds.init = m32r_inits;	/* Init strings */
// OBSOLETE   m32r_cmds.cont = "go\r";	/* continue command */
// OBSOLETE   m32r_cmds.step = "step\r";	/* single step */
// OBSOLETE   m32r_cmds.stop = NULL;	/* interrupt command */
// OBSOLETE   m32r_cmds.set_break = "%x +bp\r";	/* set a breakpoint */
// OBSOLETE   m32r_cmds.clr_break = "%x -bp\r";	/* clear a breakpoint */
// OBSOLETE   m32r_cmds.clr_all_break = "bpoff\r";	/* clear all breakpoints */
// OBSOLETE   m32r_cmds.fill = "%x %x %x fill\r";	/* fill (start length val) */
// OBSOLETE   m32r_cmds.setmem.cmdb = "%x 1 %x fill\r";	/* setmem.cmdb (addr, value) */
// OBSOLETE   m32r_cmds.setmem.cmdw = "%x 1 %x fillh\r";	/* setmem.cmdw (addr, value) */
// OBSOLETE   m32r_cmds.setmem.cmdl = "%x 1 %x fillw\r";	/* setmem.cmdl (addr, value) */
// OBSOLETE   m32r_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
// OBSOLETE   m32r_cmds.setmem.resp_delim = NULL;	/* setmem.resp_delim */
// OBSOLETE   m32r_cmds.setmem.term = NULL;	/* setmem.term */
// OBSOLETE   m32r_cmds.setmem.term_cmd = NULL;	/* setmem.term_cmd */
// OBSOLETE   m32r_cmds.getmem.cmdb = "%x %x dump\r";	/* getmem.cmdb (addr, len) */
// OBSOLETE   m32r_cmds.getmem.cmdw = NULL;	/* getmem.cmdw (addr, len) */
// OBSOLETE   m32r_cmds.getmem.cmdl = NULL;	/* getmem.cmdl (addr, len) */
// OBSOLETE   m32r_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, len) */
// OBSOLETE   m32r_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
// OBSOLETE   m32r_cmds.getmem.term = NULL;	/* getmem.term */
// OBSOLETE   m32r_cmds.getmem.term_cmd = NULL;	/* getmem.term_cmd */
// OBSOLETE   m32r_cmds.setreg.cmd = "%x to %%%s\r";	/* setreg.cmd (name, value) */
// OBSOLETE   m32r_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
// OBSOLETE   m32r_cmds.setreg.term = NULL;	/* setreg.term */
// OBSOLETE   m32r_cmds.setreg.term_cmd = NULL;	/* setreg.term_cmd */
// OBSOLETE   m32r_cmds.getreg.cmd = NULL;	/* getreg.cmd (name) */
// OBSOLETE   m32r_cmds.getreg.resp_delim = NULL;	/* getreg.resp_delim */
// OBSOLETE   m32r_cmds.getreg.term = NULL;	/* getreg.term */
// OBSOLETE   m32r_cmds.getreg.term_cmd = NULL;	/* getreg.term_cmd */
// OBSOLETE   m32r_cmds.dump_registers = ".reg\r";	/* dump_registers */
// OBSOLETE   m32r_cmds.register_pattern = "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)";	/* register_pattern */
// OBSOLETE   m32r_cmds.supply_register = m32r_supply_register;	/* supply_register */
// OBSOLETE   m32r_cmds.load_routine = NULL;	/* load_routine (defaults to SRECs) */
// OBSOLETE   m32r_cmds.load = NULL;	/* download command */
// OBSOLETE   m32r_cmds.loadresp = NULL;	/* load response */
// OBSOLETE   m32r_cmds.prompt = "ok ";	/* monitor command prompt */
// OBSOLETE   m32r_cmds.line_term = "\r";	/* end-of-line terminator */
// OBSOLETE   m32r_cmds.cmd_end = NULL;	/* optional command terminator */
// OBSOLETE   m32r_cmds.target = &m32r_ops;	/* target operations */
// OBSOLETE   m32r_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
// OBSOLETE   m32r_cmds.regnames = m32r_regnames;	/* registers names */
// OBSOLETE   m32r_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
// OBSOLETE }				/* init_m32r_cmds */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_open (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   monitor_open (args, &m32r_cmds, from_tty);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Mon2000 monitor (MSA2000 board) */
// OBSOLETE 
// OBSOLETE static struct target_ops mon2000_ops;
// OBSOLETE static struct monitor_ops mon2000_cmds;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_mon2000_cmds (void)
// OBSOLETE {
// OBSOLETE   mon2000_cmds.flags = MO_CLR_BREAK_USES_ADDR | MO_REGISTER_VALUE_FIRST;
// OBSOLETE   mon2000_cmds.init = m32r_inits;	/* Init strings */
// OBSOLETE   mon2000_cmds.cont = "go\r";	/* continue command */
// OBSOLETE   mon2000_cmds.step = "step\r";	/* single step */
// OBSOLETE   mon2000_cmds.stop = NULL;	/* interrupt command */
// OBSOLETE   mon2000_cmds.set_break = "%x +bp\r";	/* set a breakpoint */
// OBSOLETE   mon2000_cmds.clr_break = "%x -bp\r";	/* clear a breakpoint */
// OBSOLETE   mon2000_cmds.clr_all_break = "bpoff\r";	/* clear all breakpoints */
// OBSOLETE   mon2000_cmds.fill = "%x %x %x fill\r";	/* fill (start length val) */
// OBSOLETE   mon2000_cmds.setmem.cmdb = "%x 1 %x fill\r";	/* setmem.cmdb (addr, value) */
// OBSOLETE   mon2000_cmds.setmem.cmdw = "%x 1 %x fillh\r";		/* setmem.cmdw (addr, value) */
// OBSOLETE   mon2000_cmds.setmem.cmdl = "%x 1 %x fillw\r";		/* setmem.cmdl (addr, value) */
// OBSOLETE   mon2000_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
// OBSOLETE   mon2000_cmds.setmem.resp_delim = NULL;	/* setmem.resp_delim */
// OBSOLETE   mon2000_cmds.setmem.term = NULL;	/* setmem.term */
// OBSOLETE   mon2000_cmds.setmem.term_cmd = NULL;	/* setmem.term_cmd */
// OBSOLETE   mon2000_cmds.getmem.cmdb = "%x %x dump\r";	/* getmem.cmdb (addr, len) */
// OBSOLETE   mon2000_cmds.getmem.cmdw = NULL;	/* getmem.cmdw (addr, len) */
// OBSOLETE   mon2000_cmds.getmem.cmdl = NULL;	/* getmem.cmdl (addr, len) */
// OBSOLETE   mon2000_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, len) */
// OBSOLETE   mon2000_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
// OBSOLETE   mon2000_cmds.getmem.term = NULL;	/* getmem.term */
// OBSOLETE   mon2000_cmds.getmem.term_cmd = NULL;	/* getmem.term_cmd */
// OBSOLETE   mon2000_cmds.setreg.cmd = "%x to %%%s\r";	/* setreg.cmd (name, value) */
// OBSOLETE   mon2000_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
// OBSOLETE   mon2000_cmds.setreg.term = NULL;	/* setreg.term */
// OBSOLETE   mon2000_cmds.setreg.term_cmd = NULL;	/* setreg.term_cmd */
// OBSOLETE   mon2000_cmds.getreg.cmd = NULL;	/* getreg.cmd (name) */
// OBSOLETE   mon2000_cmds.getreg.resp_delim = NULL;	/* getreg.resp_delim */
// OBSOLETE   mon2000_cmds.getreg.term = NULL;	/* getreg.term */
// OBSOLETE   mon2000_cmds.getreg.term_cmd = NULL;	/* getreg.term_cmd */
// OBSOLETE   mon2000_cmds.dump_registers = ".reg\r";	/* dump_registers */
// OBSOLETE   mon2000_cmds.register_pattern = "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)";	/* register_pattern */
// OBSOLETE   mon2000_cmds.supply_register = m32r_supply_register;	/* supply_register */
// OBSOLETE   mon2000_cmds.load_routine = NULL;	/* load_routine (defaults to SRECs) */
// OBSOLETE   mon2000_cmds.load = NULL;	/* download command */
// OBSOLETE   mon2000_cmds.loadresp = NULL;	/* load response */
// OBSOLETE   mon2000_cmds.prompt = "Mon2000>";	/* monitor command prompt */
// OBSOLETE   mon2000_cmds.line_term = "\r";	/* end-of-line terminator */
// OBSOLETE   mon2000_cmds.cmd_end = NULL;	/* optional command terminator */
// OBSOLETE   mon2000_cmds.target = &mon2000_ops;	/* target operations */
// OBSOLETE   mon2000_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
// OBSOLETE   mon2000_cmds.regnames = m32r_regnames;	/* registers names */
// OBSOLETE   mon2000_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
// OBSOLETE }				/* init_mon2000_cmds */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE mon2000_open (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   monitor_open (args, &mon2000_cmds, from_tty);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: set_board_address
// OBSOLETE    Tell the BootOne monitor what it's ethernet IP address is. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_set_board_address (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int resp_len;
// OBSOLETE   char buf[1024];
// OBSOLETE 
// OBSOLETE   if (args && *args)
// OBSOLETE     {
// OBSOLETE       monitor_printf ("ulip %s\n", args);
// OBSOLETE       resp_len = monitor_expect_prompt (buf, sizeof (buf));
// OBSOLETE       /* now parse the result for success */
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     error ("Requires argument (IP address for M32R-EVA board)");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: set_server_address
// OBSOLETE    Tell the BootOne monitor what gdb's ethernet IP address is. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_set_server_address (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int resp_len;
// OBSOLETE   char buf[1024];
// OBSOLETE 
// OBSOLETE   if (args && *args)
// OBSOLETE     {
// OBSOLETE       monitor_printf ("uhip %s\n", args);
// OBSOLETE       resp_len = monitor_expect_prompt (buf, sizeof (buf));
// OBSOLETE       /* now parse the result for success */
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     error ("Requires argument (IP address of GDB's host computer)");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: set_download_path
// OBSOLETE    Tell the BootOne monitor the default path for downloadable SREC files. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_set_download_path (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int resp_len;
// OBSOLETE   char buf[1024];
// OBSOLETE 
// OBSOLETE   if (args && *args)
// OBSOLETE     {
// OBSOLETE       monitor_printf ("up %s\n", args);
// OBSOLETE       resp_len = monitor_expect_prompt (buf, sizeof (buf));
// OBSOLETE       /* now parse the result for success */
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     error ("Requires argument (default path for downloadable SREC files)");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_upload_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   bfd *abfd;
// OBSOLETE   asection *s;
// OBSOLETE   time_t start_time, end_time;	/* for timing of download */
// OBSOLETE   int resp_len, data_count = 0;
// OBSOLETE   char buf[1024];
// OBSOLETE   struct hostent *hostent;
// OBSOLETE   struct in_addr inet_addr;
// OBSOLETE 
// OBSOLETE   /* first check to see if there's an ethernet port! */
// OBSOLETE   monitor_printf ("ust\r");
// OBSOLETE   resp_len = monitor_expect_prompt (buf, sizeof (buf));
// OBSOLETE   if (!strchr (buf, ':'))
// OBSOLETE     error ("No ethernet connection!");
// OBSOLETE 
// OBSOLETE   if (board_addr == 0)
// OBSOLETE     {
// OBSOLETE       /* scan second colon in the output from the "ust" command */
// OBSOLETE       char *myIPaddress = strchr (strchr (buf, ':') + 1, ':') + 1;
// OBSOLETE 
// OBSOLETE       while (isspace (*myIPaddress))
// OBSOLETE 	myIPaddress++;
// OBSOLETE 
// OBSOLETE       if (!strncmp (myIPaddress, "0.0.", 4))	/* empty */
// OBSOLETE 	error ("Please use 'set board-address' to set the M32R-EVA board's IP address.");
// OBSOLETE       if (strchr (myIPaddress, '('))
// OBSOLETE 	*(strchr (myIPaddress, '(')) = '\0';	/* delete trailing junk */
// OBSOLETE       board_addr = xstrdup (myIPaddress);
// OBSOLETE     }
// OBSOLETE   if (server_addr == 0)
// OBSOLETE     {
// OBSOLETE       buf[0] = 0;
// OBSOLETE       gethostname (buf, sizeof (buf));
// OBSOLETE       if (buf[0] != 0)
// OBSOLETE 	hostent = gethostbyname (buf);
// OBSOLETE       if (hostent != 0)
// OBSOLETE 	{
// OBSOLETE #if 1
// OBSOLETE 	  memcpy (&inet_addr.s_addr, hostent->h_addr,
// OBSOLETE 		  sizeof (inet_addr.s_addr));
// OBSOLETE 	  server_addr = (char *) inet_ntoa (inet_addr);
// OBSOLETE #else
// OBSOLETE 	  server_addr = (char *) inet_ntoa (hostent->h_addr);
// OBSOLETE #endif
// OBSOLETE 	}
// OBSOLETE       if (server_addr == 0)	/* failed? */
// OBSOLETE 	error ("Need to know gdb host computer's IP address (use 'set server-address')");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (args == 0 || args[0] == 0)	/* no args: upload the current file */
// OBSOLETE     args = get_exec_file (1);
// OBSOLETE 
// OBSOLETE   if (args[0] != '/' && download_path == 0)
// OBSOLETE     {
// OBSOLETE       if (current_directory)
// OBSOLETE 	download_path = xstrdup (current_directory);
// OBSOLETE       else
// OBSOLETE 	error ("Need to know default download path (use 'set download-path')");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   start_time = time (NULL);
// OBSOLETE   monitor_printf ("uhip %s\r", server_addr);
// OBSOLETE   resp_len = monitor_expect_prompt (buf, sizeof (buf));		/* parse result? */
// OBSOLETE   monitor_printf ("ulip %s\r", board_addr);
// OBSOLETE   resp_len = monitor_expect_prompt (buf, sizeof (buf));		/* parse result? */
// OBSOLETE   if (args[0] != '/')
// OBSOLETE     monitor_printf ("up %s\r", download_path);	/* use default path */
// OBSOLETE   else
// OBSOLETE     monitor_printf ("up\r");	/* rooted filename/path */
// OBSOLETE   resp_len = monitor_expect_prompt (buf, sizeof (buf));		/* parse result? */
// OBSOLETE 
// OBSOLETE   if (strrchr (args, '.') && !strcmp (strrchr (args, '.'), ".srec"))
// OBSOLETE     monitor_printf ("ul %s\r", args);
// OBSOLETE   else				/* add ".srec" suffix */
// OBSOLETE     monitor_printf ("ul %s.srec\r", args);
// OBSOLETE   resp_len = monitor_expect_prompt (buf, sizeof (buf));		/* parse result? */
// OBSOLETE 
// OBSOLETE   if (buf[0] == 0 || strstr (buf, "complete") == 0)
// OBSOLETE     error ("Upload file not found: %s.srec\nCheck IP addresses and download path.", args);
// OBSOLETE   else
// OBSOLETE     printf_filtered (" -- Ethernet load complete.\n");
// OBSOLETE 
// OBSOLETE   end_time = time (NULL);
// OBSOLETE   abfd = bfd_openr (args, 0);
// OBSOLETE   if (abfd != NULL)
// OBSOLETE     {				/* Download is done -- print section statistics */
// OBSOLETE       if (bfd_check_format (abfd, bfd_object) == 0)
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered ("File is not an object file\n");
// OBSOLETE 	}
// OBSOLETE       for (s = abfd->sections; s; s = s->next)
// OBSOLETE 	if (s->flags & SEC_LOAD)
// OBSOLETE 	  {
// OBSOLETE 	    bfd_size_type section_size = bfd_section_size (abfd, s);
// OBSOLETE 	    bfd_vma section_base = bfd_section_lma (abfd, s);
// OBSOLETE 	    unsigned int buffer;
// OBSOLETE 
// OBSOLETE 	    data_count += section_size;
// OBSOLETE 
// OBSOLETE 	    printf_filtered ("Loading section %s, size 0x%lx lma ",
// OBSOLETE 			     bfd_section_name (abfd, s), section_size);
// OBSOLETE 	    print_address_numeric (section_base, 1, gdb_stdout);
// OBSOLETE 	    printf_filtered ("\n");
// OBSOLETE 	    gdb_flush (gdb_stdout);
// OBSOLETE 	  }
// OBSOLETE       /* Finally, make the PC point at the start address */
// OBSOLETE       write_pc (bfd_get_start_address (abfd));
// OBSOLETE       report_transfer_performance (data_count, start_time, end_time);
// OBSOLETE       printf_filtered ("Start address 0x%lx\n", bfd_get_start_address (abfd));
// OBSOLETE     }
// OBSOLETE   inferior_ptid = null_ptid;	/* No process now */
// OBSOLETE 
// OBSOLETE   /* This is necessary because many things were based on the PC at the
// OBSOLETE      time that we attached to the monitor, which is no longer valid
// OBSOLETE      now that we have loaded new code (and just changed the PC).
// OBSOLETE      Another way to do this might be to call normal_stop, except that
// OBSOLETE      the stack may not be valid, and things would get horribly
// OBSOLETE      confused... */
// OBSOLETE 
// OBSOLETE   clear_symtab_users ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_m32r_rom (void)
// OBSOLETE {
// OBSOLETE   /* Initialize m32r RevC monitor target */
// OBSOLETE   init_m32r_cmds ();
// OBSOLETE   init_monitor_ops (&m32r_ops);
// OBSOLETE 
// OBSOLETE   m32r_ops.to_shortname = "m32r";
// OBSOLETE   m32r_ops.to_longname = "m32r monitor";
// OBSOLETE   m32r_ops.to_load = m32r_load_gen;	/* monitor lacks a download command */
// OBSOLETE   m32r_ops.to_doc = "Debug via the m32r monitor.\n\
// OBSOLETE Specify the serial device it is connected to (e.g. /dev/ttya).";
// OBSOLETE   m32r_ops.to_open = m32r_open;
// OBSOLETE   add_target (&m32r_ops);
// OBSOLETE 
// OBSOLETE   /* Initialize mon2000 monitor target */
// OBSOLETE   init_mon2000_cmds ();
// OBSOLETE   init_monitor_ops (&mon2000_ops);
// OBSOLETE 
// OBSOLETE   mon2000_ops.to_shortname = "mon2000";
// OBSOLETE   mon2000_ops.to_longname = "Mon2000 monitor";
// OBSOLETE   mon2000_ops.to_load = m32r_load_gen;	/* monitor lacks a download command */
// OBSOLETE   mon2000_ops.to_doc = "Debug via the Mon2000 monitor.\n\
// OBSOLETE Specify the serial device it is connected to (e.g. /dev/ttya).";
// OBSOLETE   mon2000_ops.to_open = mon2000_open;
// OBSOLETE   add_target (&mon2000_ops);
// OBSOLETE 
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("download-path", class_obscure, var_string,
// OBSOLETE 		  (char *) &download_path,
// OBSOLETE 		  "Set the default path for downloadable SREC files.",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("board-address", class_obscure, var_string,
// OBSOLETE 		  (char *) &board_addr,
// OBSOLETE 		  "Set IP address for M32R-EVA target board.",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("server-address", class_obscure, var_string,
// OBSOLETE 		  (char *) &server_addr,
// OBSOLETE 		"Set IP address for download server (GDB's host computer).",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE 
// OBSOLETE   add_com ("upload", class_obscure, m32r_upload_command,
// OBSOLETE       "Upload the srec file via the monitor's Ethernet upload capability.");
// OBSOLETE 
// OBSOLETE   add_com ("tload", class_obscure, m32r_load, "test upload command.");
// OBSOLETE }
@


1.10.30.1
log
@2003-08-01  Andrew Cagney  <cagney@@redhat.com>

	Import mainline multi-arch changes from Kei Sakamoto.
	* gdb/NEWS: Mention that m32r is multi-arch.
	* configure.tgt: Recognize m32r-*-*.
	* config/m32r/m32r.mt: New file.
	* m32r-rom.c, m32r-stub.c, m32r-tdep.c: Import
@
text
@d1 626
a626 639
/* Remote debugging interface to m32r and mon2000 ROM monitors for GDB, 
   the GNU debugger.
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.

   Adapted by Michael Snyder of Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* This module defines communication with the Renesas m32r monitor */

#include "defs.h"
#include "gdbcore.h"
#include "target.h"
#include "monitor.h"
#include "serial.h"
#include "symtab.h"
#include "command.h"
#include "gdbcmd.h"
#include "symfile.h"		/* for generic load */
#include <time.h>		/* for time_t */
#include "gdb_string.h"
#include "objfiles.h"		/* for ALL_OBJFILES etc. */
#include "inferior.h"		/* for write_pc() */
#include <ctype.h>
#include "regcache.h"

/*
 * All this stuff just to get my host computer's IP address!
 */
#include <sys/types.h>
#include <netdb.h>		/* for hostent */
#include <netinet/in.h>		/* for struct in_addr */
#if 1
#include <arpa/inet.h>		/* for inet_ntoa */
#endif

static char *board_addr;	/* user-settable IP address for M32R-EVA */
static char *server_addr;	/* user-settable IP address for gdb host */
static char *download_path;	/* user-settable path for SREC files     */


/* REGNUM */
#define PSW_REGNUM      16
#define SPI_REGNUM      18
#define SPU_REGNUM      19
#define ACCL_REGNUM     22
#define ACCH_REGNUM     23


/* 
 * Function: m32r_load_1 (helper function)
 */

static void
m32r_load_section (bfd *abfd, asection *s, void *obj)
{
  unsigned int *data_count = obj;
  if (s->flags & SEC_LOAD)
    {
      bfd_size_type section_size = bfd_section_size (abfd, s);
      bfd_vma section_base = bfd_section_lma (abfd, s);
      unsigned int buffer, i;

      *data_count += section_size;

      printf_filtered ("Loading section %s, size 0x%lx lma ",
		       bfd_section_name (abfd, s), section_size);
      print_address_numeric (section_base, 1, gdb_stdout);
      printf_filtered ("\n");
      gdb_flush (gdb_stdout);
      monitor_printf ("%s mw\r", paddr_nz (section_base));
      for (i = 0; i < section_size; i += 4)
	{
	  QUIT;
	  monitor_expect (" -> ", NULL, 0);
	  bfd_get_section_contents (abfd, s, (char *) &buffer, i, 4);
	  monitor_printf ("%x\n", buffer);
	}
      monitor_expect (" -> ", NULL, 0);
      monitor_printf ("q\n");
      monitor_expect_prompt (NULL, 0);
    }
}

static int
m32r_load_1 (void *dummy)
{
  int data_count = 0;

  bfd_map_over_sections ((bfd *) dummy, m32r_load_section, &data_count);
  return data_count;
}

/* 
 * Function: m32r_load (an alternate way to load) 
 */

static void
m32r_load (char *filename, int from_tty)
{
  bfd *abfd;
  asection *s;
  unsigned int i, data_count = 0;
  time_t start_time, end_time;	/* for timing of download */

  if (filename == NULL || filename[0] == 0)
    filename = get_exec_file (1);

  abfd = bfd_openr (filename, 0);
  if (!abfd)
    error ("Unable to open file %s\n", filename);
  if (bfd_check_format (abfd, bfd_object) == 0)
    error ("File is not an object file\n");
  start_time = time (NULL);
#if 0
  for (s = abfd->sections; s; s = s->next)
    if (s->flags & SEC_LOAD)
      {
	bfd_size_type section_size = bfd_section_size (abfd, s);
	bfd_vma section_base = bfd_section_vma (abfd, s);
	unsigned int buffer;

	data_count += section_size;

	printf_filtered ("Loading section %s, size 0x%lx vma ",
			 bfd_section_name (abfd, s), section_size);
	print_address_numeric (section_base, 1, gdb_stdout);
	printf_filtered ("\n");
	gdb_flush (gdb_stdout);
	monitor_printf ("%x mw\r", section_base);
	for (i = 0; i < section_size; i += 4)
	  {
	    monitor_expect (" -> ", NULL, 0);
	    bfd_get_section_contents (abfd, s, (char *) &buffer, i, 4);
	    monitor_printf ("%x\n", buffer);
	  }
	monitor_expect (" -> ", NULL, 0);
	monitor_printf ("q\n");
	monitor_expect_prompt (NULL, 0);
      }
#else
  if (!(catch_errors (m32r_load_1, abfd, "Load aborted!\n", RETURN_MASK_ALL)))
    {
      monitor_printf ("q\n");
      return;
    }
#endif
  end_time = time (NULL);
  printf_filtered ("Start address 0x%lx\n", bfd_get_start_address (abfd));
  print_transfer_performance (gdb_stdout, data_count, 0,
			      end_time - start_time);

  /* Finally, make the PC point at the start address */
  if (exec_bfd)
    write_pc (bfd_get_start_address (exec_bfd));

  inferior_ptid = null_ptid;	/* No process now */

  /* This is necessary because many things were based on the PC at the
     time that we attached to the monitor, which is no longer valid
     now that we have loaded new code (and just changed the PC).
     Another way to do this might be to call normal_stop, except that
     the stack may not be valid, and things would get horribly
     confused... */

  clear_symtab_users ();
}

static void
m32r_load_gen (char *filename, int from_tty)
{
  generic_load (filename, from_tty);
}

static void m32r_open (char *args, int from_tty);
static void mon2000_open (char *args, int from_tty);

/* This array of registers needs to match the indexes used by GDB. The
   whole reason this exists is because the various ROM monitors use
   different names than GDB does, and don't support all the registers
   either. So, typing "info reg sp" becomes an "A7". */

static char *m32r_regnames[] =
  { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
  "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
  "psw", "cbr", "spi", "spu", "bpc", "pc", "accl", "acch",
};

static void
m32r_supply_register (char *regname, int regnamelen, char *val, int vallen)
{
  int regno;
  int num_regs = sizeof (m32r_regnames) / sizeof (m32r_regnames[0]);

  for (regno = 0; regno < num_regs; regno++)
    if (strncmp (regname, m32r_regnames[regno], regnamelen) == 0)
      break;

  if (regno >= num_regs)
    return;			/* no match */

  if (regno == ACCL_REGNUM)
    {				/* special handling for 64-bit acc reg */
      monitor_supply_register (ACCH_REGNUM, val);
      val = strchr (val, ':');	/* skip past ':' to get 2nd word */
      if (val != NULL)
	monitor_supply_register (ACCL_REGNUM, val + 1);
    }
  else
    {
      monitor_supply_register (regno, val);
      if (regno == PSW_REGNUM)
	{
	  unsigned long psw = strtoul (val, NULL, 16);
	  char *zero = "00000000", *one = "00000001";

#ifdef SM_REGNUM
	  /* Stack mode bit */
	  monitor_supply_register (SM_REGNUM, (psw & 0x80) ? one : zero);
#endif
#ifdef BSM_REGNUM
	  /* Backup stack mode bit */
	  monitor_supply_register (BSM_REGNUM, (psw & 0x8000) ? one : zero);
#endif
#ifdef IE_REGNUM
	  /* Interrupt enable bit */
	  monitor_supply_register (IE_REGNUM, (psw & 0x40) ? one : zero);
#endif
#ifdef BIE_REGNUM
	  /* Backup interrupt enable bit */
	  monitor_supply_register (BIE_REGNUM, (psw & 0x4000) ? one : zero);
#endif
#ifdef COND_REGNUM
	  /* Condition bit (carry etc.) */
	  monitor_supply_register (COND_REGNUM, (psw & 0x1) ? one : zero);
#endif
#ifdef CBR_REGNUM
	  monitor_supply_register (CBR_REGNUM, (psw & 0x1) ? one : zero);
#endif
#ifdef BPC_REGNUM
	  monitor_supply_register (BPC_REGNUM, zero);	/* KLUDGE:   (???????) */
#endif
#ifdef BCARRY_REGNUM
	  monitor_supply_register (BCARRY_REGNUM, zero);	/* KLUDGE: (??????) */
#endif
	}

      if (regno == SPI_REGNUM || regno == SPU_REGNUM)
	{			/* special handling for stack pointer (spu or spi) */
	  ULONGEST stackmode, psw;
	  regcache_cooked_read_unsigned (current_regcache, PSW_REGNUM, &psw);
	  stackmode = psw & 0x80;

	  if (regno == SPI_REGNUM && !stackmode)	/* SP == SPI */
	    monitor_supply_register (SP_REGNUM, val);
	  else if (regno == SPU_REGNUM && stackmode)	/* SP == SPU */
	    monitor_supply_register (SP_REGNUM, val);
	}
    }
}

/* m32r RevC board monitor */

static struct target_ops m32r_ops;

static char *m32r_inits[] = { "\r", NULL };

static struct monitor_ops m32r_cmds;

static void
init_m32r_cmds (void)
{
  m32r_cmds.flags = MO_CLR_BREAK_USES_ADDR | MO_REGISTER_VALUE_FIRST;
  m32r_cmds.init = m32r_inits;	/* Init strings */
  m32r_cmds.cont = "go\r";	/* continue command */
  m32r_cmds.step = "step\r";	/* single step */
  m32r_cmds.stop = NULL;	/* interrupt command */
  m32r_cmds.set_break = "%x +bp\r";	/* set a breakpoint */
  m32r_cmds.clr_break = "%x -bp\r";	/* clear a breakpoint */
  m32r_cmds.clr_all_break = "bpoff\r";	/* clear all breakpoints */
  m32r_cmds.fill = "%x %x %x fill\r";	/* fill (start length val) */
  m32r_cmds.setmem.cmdb = "%x 1 %x fill\r";	/* setmem.cmdb (addr, value) */
  m32r_cmds.setmem.cmdw = "%x 1 %x fillh\r";	/* setmem.cmdw (addr, value) */
  m32r_cmds.setmem.cmdl = "%x 1 %x fillw\r";	/* setmem.cmdl (addr, value) */
  m32r_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
  m32r_cmds.setmem.resp_delim = NULL;	/* setmem.resp_delim */
  m32r_cmds.setmem.term = NULL;	/* setmem.term */
  m32r_cmds.setmem.term_cmd = NULL;	/* setmem.term_cmd */
  m32r_cmds.getmem.cmdb = "%x %x dump\r";	/* getmem.cmdb (addr, len) */
  m32r_cmds.getmem.cmdw = NULL;	/* getmem.cmdw (addr, len) */
  m32r_cmds.getmem.cmdl = NULL;	/* getmem.cmdl (addr, len) */
  m32r_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, len) */
  m32r_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
  m32r_cmds.getmem.term = NULL;	/* getmem.term */
  m32r_cmds.getmem.term_cmd = NULL;	/* getmem.term_cmd */
  m32r_cmds.setreg.cmd = "%x to %%%s\r";	/* setreg.cmd (name, value) */
  m32r_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
  m32r_cmds.setreg.term = NULL;	/* setreg.term */
  m32r_cmds.setreg.term_cmd = NULL;	/* setreg.term_cmd */
  m32r_cmds.getreg.cmd = NULL;	/* getreg.cmd (name) */
  m32r_cmds.getreg.resp_delim = NULL;	/* getreg.resp_delim */
  m32r_cmds.getreg.term = NULL;	/* getreg.term */
  m32r_cmds.getreg.term_cmd = NULL;	/* getreg.term_cmd */
  m32r_cmds.dump_registers = ".reg\r";	/* dump_registers */
  m32r_cmds.register_pattern = "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)";	/* register_pattern */
  m32r_cmds.supply_register = m32r_supply_register;	/* supply_register */
  m32r_cmds.load_routine = NULL;	/* load_routine (defaults to SRECs) */
  m32r_cmds.load = NULL;	/* download command */
  m32r_cmds.loadresp = NULL;	/* load response */
  m32r_cmds.prompt = "ok ";	/* monitor command prompt */
  m32r_cmds.line_term = "\r";	/* end-of-line terminator */
  m32r_cmds.cmd_end = NULL;	/* optional command terminator */
  m32r_cmds.target = &m32r_ops;	/* target operations */
  m32r_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
  m32r_cmds.regnames = m32r_regnames;	/* registers names */
  m32r_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
}				/* init_m32r_cmds */

static void
m32r_open (char *args, int from_tty)
{
  monitor_open (args, &m32r_cmds, from_tty);
}

/* Mon2000 monitor (MSA2000 board) */

static struct target_ops mon2000_ops;
static struct monitor_ops mon2000_cmds;

static void
init_mon2000_cmds (void)
{
  mon2000_cmds.flags = MO_CLR_BREAK_USES_ADDR | MO_REGISTER_VALUE_FIRST;
  mon2000_cmds.init = m32r_inits;	/* Init strings */
  mon2000_cmds.cont = "go\r";	/* continue command */
  mon2000_cmds.step = "step\r";	/* single step */
  mon2000_cmds.stop = NULL;	/* interrupt command */
  mon2000_cmds.set_break = "%x +bp\r";	/* set a breakpoint */
  mon2000_cmds.clr_break = "%x -bp\r";	/* clear a breakpoint */
  mon2000_cmds.clr_all_break = "bpoff\r";	/* clear all breakpoints */
  mon2000_cmds.fill = "%x %x %x fill\r";	/* fill (start length val) */
  mon2000_cmds.setmem.cmdb = "%x 1 %x fill\r";	/* setmem.cmdb (addr, value) */
  mon2000_cmds.setmem.cmdw = "%x 1 %x fillh\r";	/* setmem.cmdw (addr, value) */
  mon2000_cmds.setmem.cmdl = "%x 1 %x fillw\r";	/* setmem.cmdl (addr, value) */
  mon2000_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
  mon2000_cmds.setmem.resp_delim = NULL;	/* setmem.resp_delim */
  mon2000_cmds.setmem.term = NULL;	/* setmem.term */
  mon2000_cmds.setmem.term_cmd = NULL;	/* setmem.term_cmd */
  mon2000_cmds.getmem.cmdb = "%x %x dump\r";	/* getmem.cmdb (addr, len) */
  mon2000_cmds.getmem.cmdw = NULL;	/* getmem.cmdw (addr, len) */
  mon2000_cmds.getmem.cmdl = NULL;	/* getmem.cmdl (addr, len) */
  mon2000_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, len) */
  mon2000_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
  mon2000_cmds.getmem.term = NULL;	/* getmem.term */
  mon2000_cmds.getmem.term_cmd = NULL;	/* getmem.term_cmd */
  mon2000_cmds.setreg.cmd = "%x to %%%s\r";	/* setreg.cmd (name, value) */
  mon2000_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
  mon2000_cmds.setreg.term = NULL;	/* setreg.term */
  mon2000_cmds.setreg.term_cmd = NULL;	/* setreg.term_cmd */
  mon2000_cmds.getreg.cmd = NULL;	/* getreg.cmd (name) */
  mon2000_cmds.getreg.resp_delim = NULL;	/* getreg.resp_delim */
  mon2000_cmds.getreg.term = NULL;	/* getreg.term */
  mon2000_cmds.getreg.term_cmd = NULL;	/* getreg.term_cmd */
  mon2000_cmds.dump_registers = ".reg\r";	/* dump_registers */
  mon2000_cmds.register_pattern = "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)";	/* register_pattern */
  mon2000_cmds.supply_register = m32r_supply_register;	/* supply_register */
  mon2000_cmds.load_routine = NULL;	/* load_routine (defaults to SRECs) */
  mon2000_cmds.load = NULL;	/* download command */
  mon2000_cmds.loadresp = NULL;	/* load response */
  mon2000_cmds.prompt = "Mon2000>";	/* monitor command prompt */
  mon2000_cmds.line_term = "\r";	/* end-of-line terminator */
  mon2000_cmds.cmd_end = NULL;	/* optional command terminator */
  mon2000_cmds.target = &mon2000_ops;	/* target operations */
  mon2000_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
  mon2000_cmds.regnames = m32r_regnames;	/* registers names */
  mon2000_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
}				/* init_mon2000_cmds */

static void
mon2000_open (char *args, int from_tty)
{
  monitor_open (args, &mon2000_cmds, from_tty);
}

/* Function: set_board_address
   Tell the BootOne monitor what it's ethernet IP address is. */

static void
m32r_set_board_address (char *args, int from_tty)
{
  int resp_len;
  char buf[1024];

  if (args && *args)
    {
      monitor_printf ("ulip %s\n", args);
      resp_len = monitor_expect_prompt (buf, sizeof (buf));
      /* now parse the result for success */
    }
  else
    error ("Requires argument (IP address for M32R-EVA board)");
}

/* Function: set_server_address
   Tell the BootOne monitor what gdb's ethernet IP address is. */

static void
m32r_set_server_address (char *args, int from_tty)
{
  int resp_len;
  char buf[1024];

  if (args && *args)
    {
      monitor_printf ("uhip %s\n", args);
      resp_len = monitor_expect_prompt (buf, sizeof (buf));
      /* now parse the result for success */
    }
  else
    error ("Requires argument (IP address of GDB's host computer)");
}

/* Function: set_download_path
   Tell the BootOne monitor the default path for downloadable SREC files. */

static void
m32r_set_download_path (char *args, int from_tty)
{
  int resp_len;
  char buf[1024];

  if (args && *args)
    {
      monitor_printf ("up %s\n", args);
      resp_len = monitor_expect_prompt (buf, sizeof (buf));
      /* now parse the result for success */
    }
  else
    error ("Requires argument (default path for downloadable SREC files)");
}

static void
m32r_upload_command (char *args, int from_tty)
{
  bfd *abfd;
  asection *s;
  time_t start_time, end_time;	/* for timing of download */
  int resp_len, data_count = 0;
  char buf[1024];
  struct hostent *hostent;
  struct in_addr inet_addr;

  /* first check to see if there's an ethernet port! */
  monitor_printf ("ust\r");
  resp_len = monitor_expect_prompt (buf, sizeof (buf));
  if (!strchr (buf, ':'))
    error ("No ethernet connection!");

  if (board_addr == 0)
    {
      /* scan second colon in the output from the "ust" command */
      char *myIPaddress = strchr (strchr (buf, ':') + 1, ':') + 1;

      while (isspace (*myIPaddress))
	myIPaddress++;

      if (!strncmp (myIPaddress, "0.0.", 4))	/* empty */
	error
	  ("Please use 'set board-address' to set the M32R-EVA board's IP address.");
      if (strchr (myIPaddress, '('))
	*(strchr (myIPaddress, '(')) = '\0';	/* delete trailing junk */
      board_addr = xstrdup (myIPaddress);
    }
  if (server_addr == 0)
    {
      buf[0] = 0;
      gethostname (buf, sizeof (buf));
      if (buf[0] != 0)
	{
	  hostent = gethostbyname (buf);
	  if (hostent != 0)
	    {
#if 1
	      memcpy (&inet_addr.s_addr, hostent->h_addr,
		      sizeof (inet_addr.s_addr));
	      server_addr = (char *) inet_ntoa (inet_addr);
#else
	      server_addr = (char *) inet_ntoa (hostent->h_addr);
#endif
	    }
	}
      if (server_addr == 0)	/* failed? */
	error
	  ("Need to know gdb host computer's IP address (use 'set server-address')");
    }

  if (args == 0 || args[0] == 0)	/* no args: upload the current file */
    args = get_exec_file (1);

  if (args[0] != '/' && download_path == 0)
    {
      if (current_directory)
	download_path = xstrdup (current_directory);
      else
	error
	  ("Need to know default download path (use 'set download-path')");
    }

  start_time = time (NULL);
  monitor_printf ("uhip %s\r", server_addr);
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result? */
  monitor_printf ("ulip %s\r", board_addr);
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result? */
  if (args[0] != '/')
    monitor_printf ("up %s\r", download_path);	/* use default path */
  else
    monitor_printf ("up\r");	/* rooted filename/path */
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result? */

  if (strrchr (args, '.') && !strcmp (strrchr (args, '.'), ".srec"))
    monitor_printf ("ul %s\r", args);
  else				/* add ".srec" suffix */
    monitor_printf ("ul %s.srec\r", args);
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result? */

  if (buf[0] == 0 || strstr (buf, "complete") == 0)
    error
      ("Upload file not found: %s.srec\nCheck IP addresses and download path.",
       args);
  else
    printf_filtered (" -- Ethernet load complete.\n");

  end_time = time (NULL);
  abfd = bfd_openr (args, 0);
  if (abfd != NULL)
    {				/* Download is done -- print section statistics */
      if (bfd_check_format (abfd, bfd_object) == 0)
	{
	  printf_filtered ("File is not an object file\n");
	}
      for (s = abfd->sections; s; s = s->next)
	if (s->flags & SEC_LOAD)
	  {
	    bfd_size_type section_size = bfd_section_size (abfd, s);
	    bfd_vma section_base = bfd_section_lma (abfd, s);
	    unsigned int buffer;

	    data_count += section_size;

	    printf_filtered ("Loading section %s, size 0x%lx lma ",
			     bfd_section_name (abfd, s), section_size);
	    print_address_numeric (section_base, 1, gdb_stdout);
	    printf_filtered ("\n");
	    gdb_flush (gdb_stdout);
	  }
      /* Finally, make the PC point at the start address */
      write_pc (bfd_get_start_address (abfd));
      printf_filtered ("Start address 0x%lx\n", bfd_get_start_address (abfd));
      print_transfer_performance (gdb_stdout, data_count, 0,
				  end_time - start_time);
    }
  inferior_ptid = null_ptid;	/* No process now */

  /* This is necessary because many things were based on the PC at the
     time that we attached to the monitor, which is no longer valid
     now that we have loaded new code (and just changed the PC).
     Another way to do this might be to call normal_stop, except that
     the stack may not be valid, and things would get horribly
     confused... */

  clear_symtab_users ();
}

void
_initialize_m32r_rom (void)
{
  /* Initialize m32r RevC monitor target */
  init_m32r_cmds ();
  init_monitor_ops (&m32r_ops);

  m32r_ops.to_shortname = "m32r";
  m32r_ops.to_longname = "m32r monitor";
  m32r_ops.to_load = m32r_load_gen;	/* monitor lacks a download command */
  m32r_ops.to_doc = "Debug via the m32r monitor.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  m32r_ops.to_open = m32r_open;
  add_target (&m32r_ops);

  /* Initialize mon2000 monitor target */
  init_mon2000_cmds ();
  init_monitor_ops (&mon2000_ops);

  mon2000_ops.to_shortname = "mon2000";
  mon2000_ops.to_longname = "Mon2000 monitor";
  mon2000_ops.to_load = m32r_load_gen;	/* monitor lacks a download command */
  mon2000_ops.to_doc = "Debug via the Mon2000 monitor.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  mon2000_ops.to_open = mon2000_open;
  add_target (&mon2000_ops);

  add_setshow_cmd ("download-path", class_obscure,
		   var_string, &download_path,
		   "Set the default path for downloadable SREC files.",
		   "Show the default path for downloadable SREC files.",
		   NULL, NULL, &setlist, &showlist);

  add_setshow_cmd ("board-address", class_obscure,
		   var_string, &board_addr,
		   "Set IP address for M32R-EVA target board.",
		   "Show IP address for M32R-EVA target board.",
		   NULL, NULL, &setlist, &showlist);

  add_setshow_cmd ("server-address", class_obscure,
		   var_string, &server_addr,
		   "Set IP address for download server (GDB's host computer).",
		   "Show IP address for download server (GDB's host computer).",
		   NULL, NULL, &setlist, &showlist);

  add_com ("upload", class_obscure, m32r_upload_command,
	   "Upload the srec file via the monitor's Ethernet upload capability.");

  add_com ("tload", class_obscure, m32r_load, "test upload command.");
}
@


1.9
log
@* gnu-regex.c: Eliminate obsolete check for _MSC_VER.
* utils.c (notice_quit): Remove dummy function only used for _MSC_VER.
* values.c (unpack_double): Remove obsolete check for _MSC_VER.
* defs.h: Ditto.
* m32r-rom.c: Ditto.
* p-exp.y: Ditto.
* ser-e7kpc.c: Ditto.  Define WIN32_LEAN_AND_MEAN under _WIN32, for faster
compilation.
(get_ds_base): Remove _MSC_VER version of this function.
* nindy-share/ttyflush.c: Ditto.  X
* rdi-share/host.h: Ditto.  X
* ser-go32.c (dos_readchar): Remove call to obsolete function.
* remote-sim.c (gdb_os_poll_quit): Ditto.
* remote-e7000.c (expect): Remove obsolete #if 0'ed code.
* main.c (captured_main): Eliminate special Cygwin checks.
* ser-tcp.c: Remove unneeded __CYGWIN__ guard against system include.
@
text
@d1 626
a626 626
/* Remote debugging interface to m32r and mon2000 ROM monitors for GDB, 
   the GNU debugger.
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.

   Adapted by Michael Snyder of Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* This module defines communication with the Mitsubishi m32r monitor */

#include "defs.h"
#include "gdbcore.h"
#include "target.h"
#include "monitor.h"
#include "serial.h"
#include "symtab.h"
#include "command.h"
#include "gdbcmd.h"
#include "symfile.h"		/* for generic load */
#include <time.h>		/* for time_t */
#include "gdb_string.h"
#include "objfiles.h"		/* for ALL_OBJFILES etc. */
#include "inferior.h"		/* for write_pc() */
#include <ctype.h>
#include "regcache.h"

extern void report_transfer_performance (unsigned long, time_t, time_t);

/*
 * All this stuff just to get my host computer's IP address!
 */
#include <sys/types.h>
#include <netdb.h>		/* for hostent */
#include <netinet/in.h>		/* for struct in_addr */
#if 1
#include <arpa/inet.h>		/* for inet_ntoa */
#endif

static char *board_addr;	/* user-settable IP address for M32R-EVA */
static char *server_addr;	/* user-settable IP address for gdb host */
static char *download_path;	/* user-settable path for SREC files     */


/* 
 * Function: m32r_load_1 (helper function)
 */

static void
m32r_load_section (bfd *abfd, asection *s, void *obj)
{
  unsigned int *data_count = obj;
  if (s->flags & SEC_LOAD)
    {
      bfd_size_type section_size = bfd_section_size (abfd, s);
      bfd_vma section_base = bfd_section_lma (abfd, s);
      unsigned int buffer, i;

      *data_count += section_size;

      printf_filtered ("Loading section %s, size 0x%lx lma ",
		       bfd_section_name (abfd, s), section_size);
      print_address_numeric (section_base, 1, gdb_stdout);
      printf_filtered ("\n");
      gdb_flush (gdb_stdout);
      monitor_printf ("%s mw\r", paddr_nz (section_base));
      for (i = 0; i < section_size; i += 4)
	{
	  QUIT;
	  monitor_expect (" -> ", NULL, 0);
	  bfd_get_section_contents (abfd, s, (char *) &buffer, i, 4);
	  monitor_printf ("%x\n", buffer);
	}
      monitor_expect (" -> ", NULL, 0);
      monitor_printf ("q\n");
      monitor_expect_prompt (NULL, 0);
    }
}

static int
m32r_load_1 (void *dummy)
{
  int data_count = 0;

  bfd_map_over_sections ((bfd *) dummy, m32r_load_section, &data_count);
  return data_count;
}

/* 
 * Function: m32r_load (an alternate way to load) 
 */

static void
m32r_load (char *filename, int from_tty)
{
  bfd *abfd;
  asection *s;
  unsigned int i, data_count = 0;
  time_t start_time, end_time;	/* for timing of download */

  if (filename == NULL || filename[0] == 0)
    filename = get_exec_file (1);

  abfd = bfd_openr (filename, 0);
  if (!abfd)
    error ("Unable to open file %s\n", filename);
  if (bfd_check_format (abfd, bfd_object) == 0)
    error ("File is not an object file\n");
  start_time = time (NULL);
#if 0
  for (s = abfd->sections; s; s = s->next)
    if (s->flags & SEC_LOAD)
      {
	bfd_size_type section_size = bfd_section_size (abfd, s);
	bfd_vma section_base = bfd_section_vma (abfd, s);
	unsigned int buffer;

	data_count += section_size;

	printf_filtered ("Loading section %s, size 0x%lx vma ",
			 bfd_section_name (abfd, s), section_size);
	print_address_numeric (section_base, 1, gdb_stdout);
	printf_filtered ("\n");
	gdb_flush (gdb_stdout);
	monitor_printf ("%x mw\r", section_base);
	for (i = 0; i < section_size; i += 4)
	  {
	    monitor_expect (" -> ", NULL, 0);
	    bfd_get_section_contents (abfd, s, (char *) &buffer, i, 4);
	    monitor_printf ("%x\n", buffer);
	  }
	monitor_expect (" -> ", NULL, 0);
	monitor_printf ("q\n");
	monitor_expect_prompt (NULL, 0);
      }
#else
  if (!(catch_errors (m32r_load_1, abfd, "Load aborted!\n", RETURN_MASK_ALL)))
    {
      monitor_printf ("q\n");
      return;
    }
#endif
  end_time = time (NULL);
  printf_filtered ("Start address 0x%lx\n", bfd_get_start_address (abfd));
  report_transfer_performance (data_count, start_time, end_time);

  /* Finally, make the PC point at the start address */
  if (exec_bfd)
    write_pc (bfd_get_start_address (exec_bfd));

  inferior_ptid = null_ptid;	/* No process now */

  /* This is necessary because many things were based on the PC at the
     time that we attached to the monitor, which is no longer valid
     now that we have loaded new code (and just changed the PC).
     Another way to do this might be to call normal_stop, except that
     the stack may not be valid, and things would get horribly
     confused... */

  clear_symtab_users ();
}

static void
m32r_load_gen (char *filename, int from_tty)
{
  generic_load (filename, from_tty);
}

static void m32r_open (char *args, int from_tty);
static void mon2000_open (char *args, int from_tty);

/* This array of registers needs to match the indexes used by GDB. The
   whole reason this exists is because the various ROM monitors use
   different names than GDB does, and don't support all the registers
   either. So, typing "info reg sp" becomes an "A7". */

static char *m32r_regnames[] =
{"r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
 "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
 "psw", "cbr", "spi", "spu", "bpc", "pc", "accl", "acch",
};

static void
m32r_supply_register (char *regname, int regnamelen, char *val, int vallen)
{
  int regno;
  int num_regs = sizeof (m32r_regnames) / sizeof (m32r_regnames[0]);

  for (regno = 0; regno < num_regs; regno++)
    if (strncmp (regname, m32r_regnames[regno], regnamelen) == 0)
      break;

  if (regno >= num_regs)
    return;			/* no match */

  if (regno == ACCL_REGNUM)
    {				/* special handling for 64-bit acc reg */
      monitor_supply_register (ACCH_REGNUM, val);
      val = strchr (val, ':');	/* skip past ':' to get 2nd word */
      if (val != NULL)
	monitor_supply_register (ACCL_REGNUM, val + 1);
    }
  else
    {
      monitor_supply_register (regno, val);
      if (regno == PSW_REGNUM)
	{
	  unsigned long psw = strtoul (val, NULL, 16);
	  char *zero = "00000000", *one = "00000001";

#ifdef SM_REGNUM
	  /* Stack mode bit */
	  monitor_supply_register (SM_REGNUM, (psw & 0x80) ? one : zero);
#endif
#ifdef BSM_REGNUM
	  /* Backup stack mode bit */
	  monitor_supply_register (BSM_REGNUM, (psw & 0x8000) ? one : zero);
#endif
#ifdef IE_REGNUM
	  /* Interrupt enable bit */
	  monitor_supply_register (IE_REGNUM, (psw & 0x40) ? one : zero);
#endif
#ifdef BIE_REGNUM
	  /* Backup interrupt enable bit */
	  monitor_supply_register (BIE_REGNUM, (psw & 0x4000) ? one : zero);
#endif
#ifdef COND_REGNUM
	  /* Condition bit (carry etc.) */
	  monitor_supply_register (COND_REGNUM, (psw & 0x1) ? one : zero);
#endif
#ifdef CBR_REGNUM
	  monitor_supply_register (CBR_REGNUM, (psw & 0x1) ? one : zero);
#endif
#ifdef BPC_REGNUM
	  monitor_supply_register (BPC_REGNUM, zero);	/* KLUDGE:   (???????) */
#endif
#ifdef BCARRY_REGNUM
	  monitor_supply_register (BCARRY_REGNUM, zero);	/* KLUDGE: (??????) */
#endif
	}

      if (regno == SPI_REGNUM || regno == SPU_REGNUM)
	{			/* special handling for stack pointer (spu or spi) */
	  unsigned long stackmode = read_register (PSW_REGNUM) & 0x80;

	  if (regno == SPI_REGNUM && !stackmode)	/* SP == SPI */
	    monitor_supply_register (SP_REGNUM, val);
	  else if (regno == SPU_REGNUM && stackmode)	/* SP == SPU */
	    monitor_supply_register (SP_REGNUM, val);
	}
    }
}

/* m32r RevC board monitor */

static struct target_ops m32r_ops;

static char *m32r_inits[] =
{"\r", NULL};

static struct monitor_ops m32r_cmds;

static void
init_m32r_cmds (void)
{
  m32r_cmds.flags = MO_CLR_BREAK_USES_ADDR | MO_REGISTER_VALUE_FIRST;
  m32r_cmds.init = m32r_inits;	/* Init strings */
  m32r_cmds.cont = "go\r";	/* continue command */
  m32r_cmds.step = "step\r";	/* single step */
  m32r_cmds.stop = NULL;	/* interrupt command */
  m32r_cmds.set_break = "%x +bp\r";	/* set a breakpoint */
  m32r_cmds.clr_break = "%x -bp\r";	/* clear a breakpoint */
  m32r_cmds.clr_all_break = "bpoff\r";	/* clear all breakpoints */
  m32r_cmds.fill = "%x %x %x fill\r";	/* fill (start length val) */
  m32r_cmds.setmem.cmdb = "%x 1 %x fill\r";	/* setmem.cmdb (addr, value) */
  m32r_cmds.setmem.cmdw = "%x 1 %x fillh\r";	/* setmem.cmdw (addr, value) */
  m32r_cmds.setmem.cmdl = "%x 1 %x fillw\r";	/* setmem.cmdl (addr, value) */
  m32r_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
  m32r_cmds.setmem.resp_delim = NULL;	/* setmem.resp_delim */
  m32r_cmds.setmem.term = NULL;	/* setmem.term */
  m32r_cmds.setmem.term_cmd = NULL;	/* setmem.term_cmd */
  m32r_cmds.getmem.cmdb = "%x %x dump\r";	/* getmem.cmdb (addr, len) */
  m32r_cmds.getmem.cmdw = NULL;	/* getmem.cmdw (addr, len) */
  m32r_cmds.getmem.cmdl = NULL;	/* getmem.cmdl (addr, len) */
  m32r_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, len) */
  m32r_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
  m32r_cmds.getmem.term = NULL;	/* getmem.term */
  m32r_cmds.getmem.term_cmd = NULL;	/* getmem.term_cmd */
  m32r_cmds.setreg.cmd = "%x to %%%s\r";	/* setreg.cmd (name, value) */
  m32r_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
  m32r_cmds.setreg.term = NULL;	/* setreg.term */
  m32r_cmds.setreg.term_cmd = NULL;	/* setreg.term_cmd */
  m32r_cmds.getreg.cmd = NULL;	/* getreg.cmd (name) */
  m32r_cmds.getreg.resp_delim = NULL;	/* getreg.resp_delim */
  m32r_cmds.getreg.term = NULL;	/* getreg.term */
  m32r_cmds.getreg.term_cmd = NULL;	/* getreg.term_cmd */
  m32r_cmds.dump_registers = ".reg\r";	/* dump_registers */
  m32r_cmds.register_pattern = "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)";	/* register_pattern */
  m32r_cmds.supply_register = m32r_supply_register;	/* supply_register */
  m32r_cmds.load_routine = NULL;	/* load_routine (defaults to SRECs) */
  m32r_cmds.load = NULL;	/* download command */
  m32r_cmds.loadresp = NULL;	/* load response */
  m32r_cmds.prompt = "ok ";	/* monitor command prompt */
  m32r_cmds.line_term = "\r";	/* end-of-line terminator */
  m32r_cmds.cmd_end = NULL;	/* optional command terminator */
  m32r_cmds.target = &m32r_ops;	/* target operations */
  m32r_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
  m32r_cmds.regnames = m32r_regnames;	/* registers names */
  m32r_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
}				/* init_m32r_cmds */

static void
m32r_open (char *args, int from_tty)
{
  monitor_open (args, &m32r_cmds, from_tty);
}

/* Mon2000 monitor (MSA2000 board) */

static struct target_ops mon2000_ops;
static struct monitor_ops mon2000_cmds;

static void
init_mon2000_cmds (void)
{
  mon2000_cmds.flags = MO_CLR_BREAK_USES_ADDR | MO_REGISTER_VALUE_FIRST;
  mon2000_cmds.init = m32r_inits;	/* Init strings */
  mon2000_cmds.cont = "go\r";	/* continue command */
  mon2000_cmds.step = "step\r";	/* single step */
  mon2000_cmds.stop = NULL;	/* interrupt command */
  mon2000_cmds.set_break = "%x +bp\r";	/* set a breakpoint */
  mon2000_cmds.clr_break = "%x -bp\r";	/* clear a breakpoint */
  mon2000_cmds.clr_all_break = "bpoff\r";	/* clear all breakpoints */
  mon2000_cmds.fill = "%x %x %x fill\r";	/* fill (start length val) */
  mon2000_cmds.setmem.cmdb = "%x 1 %x fill\r";	/* setmem.cmdb (addr, value) */
  mon2000_cmds.setmem.cmdw = "%x 1 %x fillh\r";		/* setmem.cmdw (addr, value) */
  mon2000_cmds.setmem.cmdl = "%x 1 %x fillw\r";		/* setmem.cmdl (addr, value) */
  mon2000_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
  mon2000_cmds.setmem.resp_delim = NULL;	/* setmem.resp_delim */
  mon2000_cmds.setmem.term = NULL;	/* setmem.term */
  mon2000_cmds.setmem.term_cmd = NULL;	/* setmem.term_cmd */
  mon2000_cmds.getmem.cmdb = "%x %x dump\r";	/* getmem.cmdb (addr, len) */
  mon2000_cmds.getmem.cmdw = NULL;	/* getmem.cmdw (addr, len) */
  mon2000_cmds.getmem.cmdl = NULL;	/* getmem.cmdl (addr, len) */
  mon2000_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, len) */
  mon2000_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
  mon2000_cmds.getmem.term = NULL;	/* getmem.term */
  mon2000_cmds.getmem.term_cmd = NULL;	/* getmem.term_cmd */
  mon2000_cmds.setreg.cmd = "%x to %%%s\r";	/* setreg.cmd (name, value) */
  mon2000_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
  mon2000_cmds.setreg.term = NULL;	/* setreg.term */
  mon2000_cmds.setreg.term_cmd = NULL;	/* setreg.term_cmd */
  mon2000_cmds.getreg.cmd = NULL;	/* getreg.cmd (name) */
  mon2000_cmds.getreg.resp_delim = NULL;	/* getreg.resp_delim */
  mon2000_cmds.getreg.term = NULL;	/* getreg.term */
  mon2000_cmds.getreg.term_cmd = NULL;	/* getreg.term_cmd */
  mon2000_cmds.dump_registers = ".reg\r";	/* dump_registers */
  mon2000_cmds.register_pattern = "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)";	/* register_pattern */
  mon2000_cmds.supply_register = m32r_supply_register;	/* supply_register */
  mon2000_cmds.load_routine = NULL;	/* load_routine (defaults to SRECs) */
  mon2000_cmds.load = NULL;	/* download command */
  mon2000_cmds.loadresp = NULL;	/* load response */
  mon2000_cmds.prompt = "Mon2000>";	/* monitor command prompt */
  mon2000_cmds.line_term = "\r";	/* end-of-line terminator */
  mon2000_cmds.cmd_end = NULL;	/* optional command terminator */
  mon2000_cmds.target = &mon2000_ops;	/* target operations */
  mon2000_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
  mon2000_cmds.regnames = m32r_regnames;	/* registers names */
  mon2000_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
}				/* init_mon2000_cmds */

static void
mon2000_open (char *args, int from_tty)
{
  monitor_open (args, &mon2000_cmds, from_tty);
}

/* Function: set_board_address
   Tell the BootOne monitor what it's ethernet IP address is. */

static void
m32r_set_board_address (char *args, int from_tty)
{
  int resp_len;
  char buf[1024];

  if (args && *args)
    {
      monitor_printf ("ulip %s\n", args);
      resp_len = monitor_expect_prompt (buf, sizeof (buf));
      /* now parse the result for success */
    }
  else
    error ("Requires argument (IP address for M32R-EVA board)");
}

/* Function: set_server_address
   Tell the BootOne monitor what gdb's ethernet IP address is. */

static void
m32r_set_server_address (char *args, int from_tty)
{
  int resp_len;
  char buf[1024];

  if (args && *args)
    {
      monitor_printf ("uhip %s\n", args);
      resp_len = monitor_expect_prompt (buf, sizeof (buf));
      /* now parse the result for success */
    }
  else
    error ("Requires argument (IP address of GDB's host computer)");
}

/* Function: set_download_path
   Tell the BootOne monitor the default path for downloadable SREC files. */

static void
m32r_set_download_path (char *args, int from_tty)
{
  int resp_len;
  char buf[1024];

  if (args && *args)
    {
      monitor_printf ("up %s\n", args);
      resp_len = monitor_expect_prompt (buf, sizeof (buf));
      /* now parse the result for success */
    }
  else
    error ("Requires argument (default path for downloadable SREC files)");
}

static void
m32r_upload_command (char *args, int from_tty)
{
  bfd *abfd;
  asection *s;
  time_t start_time, end_time;	/* for timing of download */
  int resp_len, data_count = 0;
  char buf[1024];
  struct hostent *hostent;
  struct in_addr inet_addr;

  /* first check to see if there's an ethernet port! */
  monitor_printf ("ust\r");
  resp_len = monitor_expect_prompt (buf, sizeof (buf));
  if (!strchr (buf, ':'))
    error ("No ethernet connection!");

  if (board_addr == 0)
    {
      /* scan second colon in the output from the "ust" command */
      char *myIPaddress = strchr (strchr (buf, ':') + 1, ':') + 1;

      while (isspace (*myIPaddress))
	myIPaddress++;

      if (!strncmp (myIPaddress, "0.0.", 4))	/* empty */
	error ("Please use 'set board-address' to set the M32R-EVA board's IP address.");
      if (strchr (myIPaddress, '('))
	*(strchr (myIPaddress, '(')) = '\0';	/* delete trailing junk */
      board_addr = xstrdup (myIPaddress);
    }
  if (server_addr == 0)
    {
      buf[0] = 0;
      gethostname (buf, sizeof (buf));
      if (buf[0] != 0)
	hostent = gethostbyname (buf);
      if (hostent != 0)
	{
#if 1
	  memcpy (&inet_addr.s_addr, hostent->h_addr,
		  sizeof (inet_addr.s_addr));
	  server_addr = (char *) inet_ntoa (inet_addr);
#else
	  server_addr = (char *) inet_ntoa (hostent->h_addr);
#endif
	}
      if (server_addr == 0)	/* failed? */
	error ("Need to know gdb host computer's IP address (use 'set server-address')");
    }

  if (args == 0 || args[0] == 0)	/* no args: upload the current file */
    args = get_exec_file (1);

  if (args[0] != '/' && download_path == 0)
    {
      if (current_directory)
	download_path = xstrdup (current_directory);
      else
	error ("Need to know default download path (use 'set download-path')");
    }

  start_time = time (NULL);
  monitor_printf ("uhip %s\r", server_addr);
  resp_len = monitor_expect_prompt (buf, sizeof (buf));		/* parse result? */
  monitor_printf ("ulip %s\r", board_addr);
  resp_len = monitor_expect_prompt (buf, sizeof (buf));		/* parse result? */
  if (args[0] != '/')
    monitor_printf ("up %s\r", download_path);	/* use default path */
  else
    monitor_printf ("up\r");	/* rooted filename/path */
  resp_len = monitor_expect_prompt (buf, sizeof (buf));		/* parse result? */

  if (strrchr (args, '.') && !strcmp (strrchr (args, '.'), ".srec"))
    monitor_printf ("ul %s\r", args);
  else				/* add ".srec" suffix */
    monitor_printf ("ul %s.srec\r", args);
  resp_len = monitor_expect_prompt (buf, sizeof (buf));		/* parse result? */

  if (buf[0] == 0 || strstr (buf, "complete") == 0)
    error ("Upload file not found: %s.srec\nCheck IP addresses and download path.", args);
  else
    printf_filtered (" -- Ethernet load complete.\n");

  end_time = time (NULL);
  abfd = bfd_openr (args, 0);
  if (abfd != NULL)
    {				/* Download is done -- print section statistics */
      if (bfd_check_format (abfd, bfd_object) == 0)
	{
	  printf_filtered ("File is not an object file\n");
	}
      for (s = abfd->sections; s; s = s->next)
	if (s->flags & SEC_LOAD)
	  {
	    bfd_size_type section_size = bfd_section_size (abfd, s);
	    bfd_vma section_base = bfd_section_lma (abfd, s);
	    unsigned int buffer;

	    data_count += section_size;

	    printf_filtered ("Loading section %s, size 0x%lx lma ",
			     bfd_section_name (abfd, s), section_size);
	    print_address_numeric (section_base, 1, gdb_stdout);
	    printf_filtered ("\n");
	    gdb_flush (gdb_stdout);
	  }
      /* Finally, make the PC point at the start address */
      write_pc (bfd_get_start_address (abfd));
      report_transfer_performance (data_count, start_time, end_time);
      printf_filtered ("Start address 0x%lx\n", bfd_get_start_address (abfd));
    }
  inferior_ptid = null_ptid;	/* No process now */

  /* This is necessary because many things were based on the PC at the
     time that we attached to the monitor, which is no longer valid
     now that we have loaded new code (and just changed the PC).
     Another way to do this might be to call normal_stop, except that
     the stack may not be valid, and things would get horribly
     confused... */

  clear_symtab_users ();
}

void
_initialize_m32r_rom (void)
{
  /* Initialize m32r RevC monitor target */
  init_m32r_cmds ();
  init_monitor_ops (&m32r_ops);

  m32r_ops.to_shortname = "m32r";
  m32r_ops.to_longname = "m32r monitor";
  m32r_ops.to_load = m32r_load_gen;	/* monitor lacks a download command */
  m32r_ops.to_doc = "Debug via the m32r monitor.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  m32r_ops.to_open = m32r_open;
  add_target (&m32r_ops);

  /* Initialize mon2000 monitor target */
  init_mon2000_cmds ();
  init_monitor_ops (&mon2000_ops);

  mon2000_ops.to_shortname = "mon2000";
  mon2000_ops.to_longname = "Mon2000 monitor";
  mon2000_ops.to_load = m32r_load_gen;	/* monitor lacks a download command */
  mon2000_ops.to_doc = "Debug via the Mon2000 monitor.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  mon2000_ops.to_open = mon2000_open;
  add_target (&mon2000_ops);

  add_show_from_set
    (add_set_cmd ("download-path", class_obscure, var_string,
		  (char *) &download_path,
		  "Set the default path for downloadable SREC files.",
		  &setlist),
     &showlist);

  add_show_from_set
    (add_set_cmd ("board-address", class_obscure, var_string,
		  (char *) &board_addr,
		  "Set IP address for M32R-EVA target board.",
		  &setlist),
     &showlist);

  add_show_from_set
    (add_set_cmd ("server-address", class_obscure, var_string,
		  (char *) &server_addr,
		"Set IP address for download server (GDB's host computer).",
		  &setlist),
     &showlist);

  add_com ("upload", class_obscure, m32r_upload_command,
      "Upload the srec file via the monitor's Ethernet upload capability.");

  add_com ("tload", class_obscure, m32r_load, "test upload command.");
}
@


1.9.26.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d25 1
a25 1
/* This module defines communication with the Renesas m32r monitor */
d43 2
a59 8
/* REGNUM */
#define PSW_REGNUM      16
#define SPI_REGNUM      18
#define SPU_REGNUM      19
#define ACCL_REGNUM     22
#define ACCH_REGNUM     23


d160 1
a160 2
  print_transfer_performance (gdb_stdout, data_count, 0,
			      end_time - start_time);
d193 3
a195 3
  { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
  "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
  "psw", "cbr", "spi", "spu", "bpc", "pc", "accl", "acch",
d259 1
a259 3
	  ULONGEST stackmode, psw;
	  regcache_cooked_read_unsigned (current_regcache, PSW_REGNUM, &psw);
	  stackmode = psw & 0x80;
d273 2
a274 1
static char *m32r_inits[] = { "\r", NULL };
d351 2
a352 2
  mon2000_cmds.setmem.cmdw = "%x 1 %x fillh\r";	/* setmem.cmdw (addr, value) */
  mon2000_cmds.setmem.cmdl = "%x 1 %x fillw\r";	/* setmem.cmdl (addr, value) */
d476 1
a476 2
	error
	  ("Please use 'set board-address' to set the M32R-EVA board's IP address.");
d486 2
a488 3
	  hostent = gethostbyname (buf);
	  if (hostent != 0)
	    {
d490 3
a492 3
	      memcpy (&inet_addr.s_addr, hostent->h_addr,
		      sizeof (inet_addr.s_addr));
	      server_addr = (char *) inet_ntoa (inet_addr);
d494 1
a494 1
	      server_addr = (char *) inet_ntoa (hostent->h_addr);
a495 1
	    }
d498 1
a498 2
	error
	  ("Need to know gdb host computer's IP address (use 'set server-address')");
d509 1
a509 2
	error
	  ("Need to know default download path (use 'set download-path')");
d514 1
a514 1
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result? */
d516 1
a516 1
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result? */
d521 1
a521 1
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result? */
d527 1
a527 1
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result? */
d530 1
a530 3
    error
      ("Upload file not found: %s.srec\nCheck IP addresses and download path.",
       args);
d559 1
a560 2
      print_transfer_performance (gdb_stdout, data_count, 0,
				  end_time - start_time);
d601 20
a620 17
  add_setshow_cmd ("download-path", class_obscure,
		   var_string, &download_path,
		   "Set the default path for downloadable SREC files.",
		   "Show the default path for downloadable SREC files.",
		   NULL, NULL, &setlist, &showlist);

  add_setshow_cmd ("board-address", class_obscure,
		   var_string, &board_addr,
		   "Set IP address for M32R-EVA target board.",
		   "Show IP address for M32R-EVA target board.",
		   NULL, NULL, &setlist, &showlist);

  add_setshow_cmd ("server-address", class_obscure,
		   var_string, &server_addr,
		   "Set IP address for download server (GDB's host computer).",
		   "Show IP address for download server (GDB's host computer).",
		   NULL, NULL, &setlist, &showlist);
d623 1
a623 1
	   "Upload the srec file via the monitor's Ethernet upload capability.");
@


1.9.26.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d401 57
@


1.9.24.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d1 626
a626 626
// OBSOLETE /* Remote debugging interface to m32r and mon2000 ROM monitors for GDB, 
// OBSOLETE    the GNU debugger.
// OBSOLETE    Copyright 1996, 1997, 1998, 1999, 2000, 2001
// OBSOLETE    Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    Adapted by Michael Snyder of Cygnus Support.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE /* This module defines communication with the Mitsubishi m32r monitor */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "target.h"
// OBSOLETE #include "monitor.h"
// OBSOLETE #include "serial.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "command.h"
// OBSOLETE #include "gdbcmd.h"
// OBSOLETE #include "symfile.h"		/* for generic load */
// OBSOLETE #include <time.h>		/* for time_t */
// OBSOLETE #include "gdb_string.h"
// OBSOLETE #include "objfiles.h"		/* for ALL_OBJFILES etc. */
// OBSOLETE #include "inferior.h"		/* for write_pc() */
// OBSOLETE #include <ctype.h>
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE extern void report_transfer_performance (unsigned long, time_t, time_t);
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * All this stuff just to get my host computer's IP address!
// OBSOLETE  */
// OBSOLETE #include <sys/types.h>
// OBSOLETE #include <netdb.h>		/* for hostent */
// OBSOLETE #include <netinet/in.h>		/* for struct in_addr */
// OBSOLETE #if 1
// OBSOLETE #include <arpa/inet.h>		/* for inet_ntoa */
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE static char *board_addr;	/* user-settable IP address for M32R-EVA */
// OBSOLETE static char *server_addr;	/* user-settable IP address for gdb host */
// OBSOLETE static char *download_path;	/* user-settable path for SREC files     */
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* 
// OBSOLETE  * Function: m32r_load_1 (helper function)
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_load_section (bfd *abfd, asection *s, void *obj)
// OBSOLETE {
// OBSOLETE   unsigned int *data_count = obj;
// OBSOLETE   if (s->flags & SEC_LOAD)
// OBSOLETE     {
// OBSOLETE       bfd_size_type section_size = bfd_section_size (abfd, s);
// OBSOLETE       bfd_vma section_base = bfd_section_lma (abfd, s);
// OBSOLETE       unsigned int buffer, i;
// OBSOLETE 
// OBSOLETE       *data_count += section_size;
// OBSOLETE 
// OBSOLETE       printf_filtered ("Loading section %s, size 0x%lx lma ",
// OBSOLETE 		       bfd_section_name (abfd, s), section_size);
// OBSOLETE       print_address_numeric (section_base, 1, gdb_stdout);
// OBSOLETE       printf_filtered ("\n");
// OBSOLETE       gdb_flush (gdb_stdout);
// OBSOLETE       monitor_printf ("%s mw\r", paddr_nz (section_base));
// OBSOLETE       for (i = 0; i < section_size; i += 4)
// OBSOLETE 	{
// OBSOLETE 	  QUIT;
// OBSOLETE 	  monitor_expect (" -> ", NULL, 0);
// OBSOLETE 	  bfd_get_section_contents (abfd, s, (char *) &buffer, i, 4);
// OBSOLETE 	  monitor_printf ("%x\n", buffer);
// OBSOLETE 	}
// OBSOLETE       monitor_expect (" -> ", NULL, 0);
// OBSOLETE       monitor_printf ("q\n");
// OBSOLETE       monitor_expect_prompt (NULL, 0);
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE m32r_load_1 (void *dummy)
// OBSOLETE {
// OBSOLETE   int data_count = 0;
// OBSOLETE 
// OBSOLETE   bfd_map_over_sections ((bfd *) dummy, m32r_load_section, &data_count);
// OBSOLETE   return data_count;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* 
// OBSOLETE  * Function: m32r_load (an alternate way to load) 
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_load (char *filename, int from_tty)
// OBSOLETE {
// OBSOLETE   bfd *abfd;
// OBSOLETE   asection *s;
// OBSOLETE   unsigned int i, data_count = 0;
// OBSOLETE   time_t start_time, end_time;	/* for timing of download */
// OBSOLETE 
// OBSOLETE   if (filename == NULL || filename[0] == 0)
// OBSOLETE     filename = get_exec_file (1);
// OBSOLETE 
// OBSOLETE   abfd = bfd_openr (filename, 0);
// OBSOLETE   if (!abfd)
// OBSOLETE     error ("Unable to open file %s\n", filename);
// OBSOLETE   if (bfd_check_format (abfd, bfd_object) == 0)
// OBSOLETE     error ("File is not an object file\n");
// OBSOLETE   start_time = time (NULL);
// OBSOLETE #if 0
// OBSOLETE   for (s = abfd->sections; s; s = s->next)
// OBSOLETE     if (s->flags & SEC_LOAD)
// OBSOLETE       {
// OBSOLETE 	bfd_size_type section_size = bfd_section_size (abfd, s);
// OBSOLETE 	bfd_vma section_base = bfd_section_vma (abfd, s);
// OBSOLETE 	unsigned int buffer;
// OBSOLETE 
// OBSOLETE 	data_count += section_size;
// OBSOLETE 
// OBSOLETE 	printf_filtered ("Loading section %s, size 0x%lx vma ",
// OBSOLETE 			 bfd_section_name (abfd, s), section_size);
// OBSOLETE 	print_address_numeric (section_base, 1, gdb_stdout);
// OBSOLETE 	printf_filtered ("\n");
// OBSOLETE 	gdb_flush (gdb_stdout);
// OBSOLETE 	monitor_printf ("%x mw\r", section_base);
// OBSOLETE 	for (i = 0; i < section_size; i += 4)
// OBSOLETE 	  {
// OBSOLETE 	    monitor_expect (" -> ", NULL, 0);
// OBSOLETE 	    bfd_get_section_contents (abfd, s, (char *) &buffer, i, 4);
// OBSOLETE 	    monitor_printf ("%x\n", buffer);
// OBSOLETE 	  }
// OBSOLETE 	monitor_expect (" -> ", NULL, 0);
// OBSOLETE 	monitor_printf ("q\n");
// OBSOLETE 	monitor_expect_prompt (NULL, 0);
// OBSOLETE       }
// OBSOLETE #else
// OBSOLETE   if (!(catch_errors (m32r_load_1, abfd, "Load aborted!\n", RETURN_MASK_ALL)))
// OBSOLETE     {
// OBSOLETE       monitor_printf ("q\n");
// OBSOLETE       return;
// OBSOLETE     }
// OBSOLETE #endif
// OBSOLETE   end_time = time (NULL);
// OBSOLETE   printf_filtered ("Start address 0x%lx\n", bfd_get_start_address (abfd));
// OBSOLETE   report_transfer_performance (data_count, start_time, end_time);
// OBSOLETE 
// OBSOLETE   /* Finally, make the PC point at the start address */
// OBSOLETE   if (exec_bfd)
// OBSOLETE     write_pc (bfd_get_start_address (exec_bfd));
// OBSOLETE 
// OBSOLETE   inferior_ptid = null_ptid;	/* No process now */
// OBSOLETE 
// OBSOLETE   /* This is necessary because many things were based on the PC at the
// OBSOLETE      time that we attached to the monitor, which is no longer valid
// OBSOLETE      now that we have loaded new code (and just changed the PC).
// OBSOLETE      Another way to do this might be to call normal_stop, except that
// OBSOLETE      the stack may not be valid, and things would get horribly
// OBSOLETE      confused... */
// OBSOLETE 
// OBSOLETE   clear_symtab_users ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_load_gen (char *filename, int from_tty)
// OBSOLETE {
// OBSOLETE   generic_load (filename, from_tty);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void m32r_open (char *args, int from_tty);
// OBSOLETE static void mon2000_open (char *args, int from_tty);
// OBSOLETE 
// OBSOLETE /* This array of registers needs to match the indexes used by GDB. The
// OBSOLETE    whole reason this exists is because the various ROM monitors use
// OBSOLETE    different names than GDB does, and don't support all the registers
// OBSOLETE    either. So, typing "info reg sp" becomes an "A7". */
// OBSOLETE 
// OBSOLETE static char *m32r_regnames[] =
// OBSOLETE {"r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
// OBSOLETE  "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
// OBSOLETE  "psw", "cbr", "spi", "spu", "bpc", "pc", "accl", "acch",
// OBSOLETE };
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_supply_register (char *regname, int regnamelen, char *val, int vallen)
// OBSOLETE {
// OBSOLETE   int regno;
// OBSOLETE   int num_regs = sizeof (m32r_regnames) / sizeof (m32r_regnames[0]);
// OBSOLETE 
// OBSOLETE   for (regno = 0; regno < num_regs; regno++)
// OBSOLETE     if (strncmp (regname, m32r_regnames[regno], regnamelen) == 0)
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE   if (regno >= num_regs)
// OBSOLETE     return;			/* no match */
// OBSOLETE 
// OBSOLETE   if (regno == ACCL_REGNUM)
// OBSOLETE     {				/* special handling for 64-bit acc reg */
// OBSOLETE       monitor_supply_register (ACCH_REGNUM, val);
// OBSOLETE       val = strchr (val, ':');	/* skip past ':' to get 2nd word */
// OBSOLETE       if (val != NULL)
// OBSOLETE 	monitor_supply_register (ACCL_REGNUM, val + 1);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       monitor_supply_register (regno, val);
// OBSOLETE       if (regno == PSW_REGNUM)
// OBSOLETE 	{
// OBSOLETE 	  unsigned long psw = strtoul (val, NULL, 16);
// OBSOLETE 	  char *zero = "00000000", *one = "00000001";
// OBSOLETE 
// OBSOLETE #ifdef SM_REGNUM
// OBSOLETE 	  /* Stack mode bit */
// OBSOLETE 	  monitor_supply_register (SM_REGNUM, (psw & 0x80) ? one : zero);
// OBSOLETE #endif
// OBSOLETE #ifdef BSM_REGNUM
// OBSOLETE 	  /* Backup stack mode bit */
// OBSOLETE 	  monitor_supply_register (BSM_REGNUM, (psw & 0x8000) ? one : zero);
// OBSOLETE #endif
// OBSOLETE #ifdef IE_REGNUM
// OBSOLETE 	  /* Interrupt enable bit */
// OBSOLETE 	  monitor_supply_register (IE_REGNUM, (psw & 0x40) ? one : zero);
// OBSOLETE #endif
// OBSOLETE #ifdef BIE_REGNUM
// OBSOLETE 	  /* Backup interrupt enable bit */
// OBSOLETE 	  monitor_supply_register (BIE_REGNUM, (psw & 0x4000) ? one : zero);
// OBSOLETE #endif
// OBSOLETE #ifdef COND_REGNUM
// OBSOLETE 	  /* Condition bit (carry etc.) */
// OBSOLETE 	  monitor_supply_register (COND_REGNUM, (psw & 0x1) ? one : zero);
// OBSOLETE #endif
// OBSOLETE #ifdef CBR_REGNUM
// OBSOLETE 	  monitor_supply_register (CBR_REGNUM, (psw & 0x1) ? one : zero);
// OBSOLETE #endif
// OBSOLETE #ifdef BPC_REGNUM
// OBSOLETE 	  monitor_supply_register (BPC_REGNUM, zero);	/* KLUDGE:   (???????) */
// OBSOLETE #endif
// OBSOLETE #ifdef BCARRY_REGNUM
// OBSOLETE 	  monitor_supply_register (BCARRY_REGNUM, zero);	/* KLUDGE: (??????) */
// OBSOLETE #endif
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       if (regno == SPI_REGNUM || regno == SPU_REGNUM)
// OBSOLETE 	{			/* special handling for stack pointer (spu or spi) */
// OBSOLETE 	  unsigned long stackmode = read_register (PSW_REGNUM) & 0x80;
// OBSOLETE 
// OBSOLETE 	  if (regno == SPI_REGNUM && !stackmode)	/* SP == SPI */
// OBSOLETE 	    monitor_supply_register (SP_REGNUM, val);
// OBSOLETE 	  else if (regno == SPU_REGNUM && stackmode)	/* SP == SPU */
// OBSOLETE 	    monitor_supply_register (SP_REGNUM, val);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* m32r RevC board monitor */
// OBSOLETE 
// OBSOLETE static struct target_ops m32r_ops;
// OBSOLETE 
// OBSOLETE static char *m32r_inits[] =
// OBSOLETE {"\r", NULL};
// OBSOLETE 
// OBSOLETE static struct monitor_ops m32r_cmds;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_m32r_cmds (void)
// OBSOLETE {
// OBSOLETE   m32r_cmds.flags = MO_CLR_BREAK_USES_ADDR | MO_REGISTER_VALUE_FIRST;
// OBSOLETE   m32r_cmds.init = m32r_inits;	/* Init strings */
// OBSOLETE   m32r_cmds.cont = "go\r";	/* continue command */
// OBSOLETE   m32r_cmds.step = "step\r";	/* single step */
// OBSOLETE   m32r_cmds.stop = NULL;	/* interrupt command */
// OBSOLETE   m32r_cmds.set_break = "%x +bp\r";	/* set a breakpoint */
// OBSOLETE   m32r_cmds.clr_break = "%x -bp\r";	/* clear a breakpoint */
// OBSOLETE   m32r_cmds.clr_all_break = "bpoff\r";	/* clear all breakpoints */
// OBSOLETE   m32r_cmds.fill = "%x %x %x fill\r";	/* fill (start length val) */
// OBSOLETE   m32r_cmds.setmem.cmdb = "%x 1 %x fill\r";	/* setmem.cmdb (addr, value) */
// OBSOLETE   m32r_cmds.setmem.cmdw = "%x 1 %x fillh\r";	/* setmem.cmdw (addr, value) */
// OBSOLETE   m32r_cmds.setmem.cmdl = "%x 1 %x fillw\r";	/* setmem.cmdl (addr, value) */
// OBSOLETE   m32r_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
// OBSOLETE   m32r_cmds.setmem.resp_delim = NULL;	/* setmem.resp_delim */
// OBSOLETE   m32r_cmds.setmem.term = NULL;	/* setmem.term */
// OBSOLETE   m32r_cmds.setmem.term_cmd = NULL;	/* setmem.term_cmd */
// OBSOLETE   m32r_cmds.getmem.cmdb = "%x %x dump\r";	/* getmem.cmdb (addr, len) */
// OBSOLETE   m32r_cmds.getmem.cmdw = NULL;	/* getmem.cmdw (addr, len) */
// OBSOLETE   m32r_cmds.getmem.cmdl = NULL;	/* getmem.cmdl (addr, len) */
// OBSOLETE   m32r_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, len) */
// OBSOLETE   m32r_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
// OBSOLETE   m32r_cmds.getmem.term = NULL;	/* getmem.term */
// OBSOLETE   m32r_cmds.getmem.term_cmd = NULL;	/* getmem.term_cmd */
// OBSOLETE   m32r_cmds.setreg.cmd = "%x to %%%s\r";	/* setreg.cmd (name, value) */
// OBSOLETE   m32r_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
// OBSOLETE   m32r_cmds.setreg.term = NULL;	/* setreg.term */
// OBSOLETE   m32r_cmds.setreg.term_cmd = NULL;	/* setreg.term_cmd */
// OBSOLETE   m32r_cmds.getreg.cmd = NULL;	/* getreg.cmd (name) */
// OBSOLETE   m32r_cmds.getreg.resp_delim = NULL;	/* getreg.resp_delim */
// OBSOLETE   m32r_cmds.getreg.term = NULL;	/* getreg.term */
// OBSOLETE   m32r_cmds.getreg.term_cmd = NULL;	/* getreg.term_cmd */
// OBSOLETE   m32r_cmds.dump_registers = ".reg\r";	/* dump_registers */
// OBSOLETE   m32r_cmds.register_pattern = "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)";	/* register_pattern */
// OBSOLETE   m32r_cmds.supply_register = m32r_supply_register;	/* supply_register */
// OBSOLETE   m32r_cmds.load_routine = NULL;	/* load_routine (defaults to SRECs) */
// OBSOLETE   m32r_cmds.load = NULL;	/* download command */
// OBSOLETE   m32r_cmds.loadresp = NULL;	/* load response */
// OBSOLETE   m32r_cmds.prompt = "ok ";	/* monitor command prompt */
// OBSOLETE   m32r_cmds.line_term = "\r";	/* end-of-line terminator */
// OBSOLETE   m32r_cmds.cmd_end = NULL;	/* optional command terminator */
// OBSOLETE   m32r_cmds.target = &m32r_ops;	/* target operations */
// OBSOLETE   m32r_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
// OBSOLETE   m32r_cmds.regnames = m32r_regnames;	/* registers names */
// OBSOLETE   m32r_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
// OBSOLETE }				/* init_m32r_cmds */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_open (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   monitor_open (args, &m32r_cmds, from_tty);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Mon2000 monitor (MSA2000 board) */
// OBSOLETE 
// OBSOLETE static struct target_ops mon2000_ops;
// OBSOLETE static struct monitor_ops mon2000_cmds;
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE init_mon2000_cmds (void)
// OBSOLETE {
// OBSOLETE   mon2000_cmds.flags = MO_CLR_BREAK_USES_ADDR | MO_REGISTER_VALUE_FIRST;
// OBSOLETE   mon2000_cmds.init = m32r_inits;	/* Init strings */
// OBSOLETE   mon2000_cmds.cont = "go\r";	/* continue command */
// OBSOLETE   mon2000_cmds.step = "step\r";	/* single step */
// OBSOLETE   mon2000_cmds.stop = NULL;	/* interrupt command */
// OBSOLETE   mon2000_cmds.set_break = "%x +bp\r";	/* set a breakpoint */
// OBSOLETE   mon2000_cmds.clr_break = "%x -bp\r";	/* clear a breakpoint */
// OBSOLETE   mon2000_cmds.clr_all_break = "bpoff\r";	/* clear all breakpoints */
// OBSOLETE   mon2000_cmds.fill = "%x %x %x fill\r";	/* fill (start length val) */
// OBSOLETE   mon2000_cmds.setmem.cmdb = "%x 1 %x fill\r";	/* setmem.cmdb (addr, value) */
// OBSOLETE   mon2000_cmds.setmem.cmdw = "%x 1 %x fillh\r";		/* setmem.cmdw (addr, value) */
// OBSOLETE   mon2000_cmds.setmem.cmdl = "%x 1 %x fillw\r";		/* setmem.cmdl (addr, value) */
// OBSOLETE   mon2000_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
// OBSOLETE   mon2000_cmds.setmem.resp_delim = NULL;	/* setmem.resp_delim */
// OBSOLETE   mon2000_cmds.setmem.term = NULL;	/* setmem.term */
// OBSOLETE   mon2000_cmds.setmem.term_cmd = NULL;	/* setmem.term_cmd */
// OBSOLETE   mon2000_cmds.getmem.cmdb = "%x %x dump\r";	/* getmem.cmdb (addr, len) */
// OBSOLETE   mon2000_cmds.getmem.cmdw = NULL;	/* getmem.cmdw (addr, len) */
// OBSOLETE   mon2000_cmds.getmem.cmdl = NULL;	/* getmem.cmdl (addr, len) */
// OBSOLETE   mon2000_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, len) */
// OBSOLETE   mon2000_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
// OBSOLETE   mon2000_cmds.getmem.term = NULL;	/* getmem.term */
// OBSOLETE   mon2000_cmds.getmem.term_cmd = NULL;	/* getmem.term_cmd */
// OBSOLETE   mon2000_cmds.setreg.cmd = "%x to %%%s\r";	/* setreg.cmd (name, value) */
// OBSOLETE   mon2000_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
// OBSOLETE   mon2000_cmds.setreg.term = NULL;	/* setreg.term */
// OBSOLETE   mon2000_cmds.setreg.term_cmd = NULL;	/* setreg.term_cmd */
// OBSOLETE   mon2000_cmds.getreg.cmd = NULL;	/* getreg.cmd (name) */
// OBSOLETE   mon2000_cmds.getreg.resp_delim = NULL;	/* getreg.resp_delim */
// OBSOLETE   mon2000_cmds.getreg.term = NULL;	/* getreg.term */
// OBSOLETE   mon2000_cmds.getreg.term_cmd = NULL;	/* getreg.term_cmd */
// OBSOLETE   mon2000_cmds.dump_registers = ".reg\r";	/* dump_registers */
// OBSOLETE   mon2000_cmds.register_pattern = "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)";	/* register_pattern */
// OBSOLETE   mon2000_cmds.supply_register = m32r_supply_register;	/* supply_register */
// OBSOLETE   mon2000_cmds.load_routine = NULL;	/* load_routine (defaults to SRECs) */
// OBSOLETE   mon2000_cmds.load = NULL;	/* download command */
// OBSOLETE   mon2000_cmds.loadresp = NULL;	/* load response */
// OBSOLETE   mon2000_cmds.prompt = "Mon2000>";	/* monitor command prompt */
// OBSOLETE   mon2000_cmds.line_term = "\r";	/* end-of-line terminator */
// OBSOLETE   mon2000_cmds.cmd_end = NULL;	/* optional command terminator */
// OBSOLETE   mon2000_cmds.target = &mon2000_ops;	/* target operations */
// OBSOLETE   mon2000_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
// OBSOLETE   mon2000_cmds.regnames = m32r_regnames;	/* registers names */
// OBSOLETE   mon2000_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
// OBSOLETE }				/* init_mon2000_cmds */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE mon2000_open (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   monitor_open (args, &mon2000_cmds, from_tty);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: set_board_address
// OBSOLETE    Tell the BootOne monitor what it's ethernet IP address is. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_set_board_address (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int resp_len;
// OBSOLETE   char buf[1024];
// OBSOLETE 
// OBSOLETE   if (args && *args)
// OBSOLETE     {
// OBSOLETE       monitor_printf ("ulip %s\n", args);
// OBSOLETE       resp_len = monitor_expect_prompt (buf, sizeof (buf));
// OBSOLETE       /* now parse the result for success */
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     error ("Requires argument (IP address for M32R-EVA board)");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: set_server_address
// OBSOLETE    Tell the BootOne monitor what gdb's ethernet IP address is. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_set_server_address (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int resp_len;
// OBSOLETE   char buf[1024];
// OBSOLETE 
// OBSOLETE   if (args && *args)
// OBSOLETE     {
// OBSOLETE       monitor_printf ("uhip %s\n", args);
// OBSOLETE       resp_len = monitor_expect_prompt (buf, sizeof (buf));
// OBSOLETE       /* now parse the result for success */
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     error ("Requires argument (IP address of GDB's host computer)");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Function: set_download_path
// OBSOLETE    Tell the BootOne monitor the default path for downloadable SREC files. */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_set_download_path (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   int resp_len;
// OBSOLETE   char buf[1024];
// OBSOLETE 
// OBSOLETE   if (args && *args)
// OBSOLETE     {
// OBSOLETE       monitor_printf ("up %s\n", args);
// OBSOLETE       resp_len = monitor_expect_prompt (buf, sizeof (buf));
// OBSOLETE       /* now parse the result for success */
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     error ("Requires argument (default path for downloadable SREC files)");
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE m32r_upload_command (char *args, int from_tty)
// OBSOLETE {
// OBSOLETE   bfd *abfd;
// OBSOLETE   asection *s;
// OBSOLETE   time_t start_time, end_time;	/* for timing of download */
// OBSOLETE   int resp_len, data_count = 0;
// OBSOLETE   char buf[1024];
// OBSOLETE   struct hostent *hostent;
// OBSOLETE   struct in_addr inet_addr;
// OBSOLETE 
// OBSOLETE   /* first check to see if there's an ethernet port! */
// OBSOLETE   monitor_printf ("ust\r");
// OBSOLETE   resp_len = monitor_expect_prompt (buf, sizeof (buf));
// OBSOLETE   if (!strchr (buf, ':'))
// OBSOLETE     error ("No ethernet connection!");
// OBSOLETE 
// OBSOLETE   if (board_addr == 0)
// OBSOLETE     {
// OBSOLETE       /* scan second colon in the output from the "ust" command */
// OBSOLETE       char *myIPaddress = strchr (strchr (buf, ':') + 1, ':') + 1;
// OBSOLETE 
// OBSOLETE       while (isspace (*myIPaddress))
// OBSOLETE 	myIPaddress++;
// OBSOLETE 
// OBSOLETE       if (!strncmp (myIPaddress, "0.0.", 4))	/* empty */
// OBSOLETE 	error ("Please use 'set board-address' to set the M32R-EVA board's IP address.");
// OBSOLETE       if (strchr (myIPaddress, '('))
// OBSOLETE 	*(strchr (myIPaddress, '(')) = '\0';	/* delete trailing junk */
// OBSOLETE       board_addr = xstrdup (myIPaddress);
// OBSOLETE     }
// OBSOLETE   if (server_addr == 0)
// OBSOLETE     {
// OBSOLETE       buf[0] = 0;
// OBSOLETE       gethostname (buf, sizeof (buf));
// OBSOLETE       if (buf[0] != 0)
// OBSOLETE 	hostent = gethostbyname (buf);
// OBSOLETE       if (hostent != 0)
// OBSOLETE 	{
// OBSOLETE #if 1
// OBSOLETE 	  memcpy (&inet_addr.s_addr, hostent->h_addr,
// OBSOLETE 		  sizeof (inet_addr.s_addr));
// OBSOLETE 	  server_addr = (char *) inet_ntoa (inet_addr);
// OBSOLETE #else
// OBSOLETE 	  server_addr = (char *) inet_ntoa (hostent->h_addr);
// OBSOLETE #endif
// OBSOLETE 	}
// OBSOLETE       if (server_addr == 0)	/* failed? */
// OBSOLETE 	error ("Need to know gdb host computer's IP address (use 'set server-address')");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (args == 0 || args[0] == 0)	/* no args: upload the current file */
// OBSOLETE     args = get_exec_file (1);
// OBSOLETE 
// OBSOLETE   if (args[0] != '/' && download_path == 0)
// OBSOLETE     {
// OBSOLETE       if (current_directory)
// OBSOLETE 	download_path = xstrdup (current_directory);
// OBSOLETE       else
// OBSOLETE 	error ("Need to know default download path (use 'set download-path')");
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   start_time = time (NULL);
// OBSOLETE   monitor_printf ("uhip %s\r", server_addr);
// OBSOLETE   resp_len = monitor_expect_prompt (buf, sizeof (buf));		/* parse result? */
// OBSOLETE   monitor_printf ("ulip %s\r", board_addr);
// OBSOLETE   resp_len = monitor_expect_prompt (buf, sizeof (buf));		/* parse result? */
// OBSOLETE   if (args[0] != '/')
// OBSOLETE     monitor_printf ("up %s\r", download_path);	/* use default path */
// OBSOLETE   else
// OBSOLETE     monitor_printf ("up\r");	/* rooted filename/path */
// OBSOLETE   resp_len = monitor_expect_prompt (buf, sizeof (buf));		/* parse result? */
// OBSOLETE 
// OBSOLETE   if (strrchr (args, '.') && !strcmp (strrchr (args, '.'), ".srec"))
// OBSOLETE     monitor_printf ("ul %s\r", args);
// OBSOLETE   else				/* add ".srec" suffix */
// OBSOLETE     monitor_printf ("ul %s.srec\r", args);
// OBSOLETE   resp_len = monitor_expect_prompt (buf, sizeof (buf));		/* parse result? */
// OBSOLETE 
// OBSOLETE   if (buf[0] == 0 || strstr (buf, "complete") == 0)
// OBSOLETE     error ("Upload file not found: %s.srec\nCheck IP addresses and download path.", args);
// OBSOLETE   else
// OBSOLETE     printf_filtered (" -- Ethernet load complete.\n");
// OBSOLETE 
// OBSOLETE   end_time = time (NULL);
// OBSOLETE   abfd = bfd_openr (args, 0);
// OBSOLETE   if (abfd != NULL)
// OBSOLETE     {				/* Download is done -- print section statistics */
// OBSOLETE       if (bfd_check_format (abfd, bfd_object) == 0)
// OBSOLETE 	{
// OBSOLETE 	  printf_filtered ("File is not an object file\n");
// OBSOLETE 	}
// OBSOLETE       for (s = abfd->sections; s; s = s->next)
// OBSOLETE 	if (s->flags & SEC_LOAD)
// OBSOLETE 	  {
// OBSOLETE 	    bfd_size_type section_size = bfd_section_size (abfd, s);
// OBSOLETE 	    bfd_vma section_base = bfd_section_lma (abfd, s);
// OBSOLETE 	    unsigned int buffer;
// OBSOLETE 
// OBSOLETE 	    data_count += section_size;
// OBSOLETE 
// OBSOLETE 	    printf_filtered ("Loading section %s, size 0x%lx lma ",
// OBSOLETE 			     bfd_section_name (abfd, s), section_size);
// OBSOLETE 	    print_address_numeric (section_base, 1, gdb_stdout);
// OBSOLETE 	    printf_filtered ("\n");
// OBSOLETE 	    gdb_flush (gdb_stdout);
// OBSOLETE 	  }
// OBSOLETE       /* Finally, make the PC point at the start address */
// OBSOLETE       write_pc (bfd_get_start_address (abfd));
// OBSOLETE       report_transfer_performance (data_count, start_time, end_time);
// OBSOLETE       printf_filtered ("Start address 0x%lx\n", bfd_get_start_address (abfd));
// OBSOLETE     }
// OBSOLETE   inferior_ptid = null_ptid;	/* No process now */
// OBSOLETE 
// OBSOLETE   /* This is necessary because many things were based on the PC at the
// OBSOLETE      time that we attached to the monitor, which is no longer valid
// OBSOLETE      now that we have loaded new code (and just changed the PC).
// OBSOLETE      Another way to do this might be to call normal_stop, except that
// OBSOLETE      the stack may not be valid, and things would get horribly
// OBSOLETE      confused... */
// OBSOLETE 
// OBSOLETE   clear_symtab_users ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_m32r_rom (void)
// OBSOLETE {
// OBSOLETE   /* Initialize m32r RevC monitor target */
// OBSOLETE   init_m32r_cmds ();
// OBSOLETE   init_monitor_ops (&m32r_ops);
// OBSOLETE 
// OBSOLETE   m32r_ops.to_shortname = "m32r";
// OBSOLETE   m32r_ops.to_longname = "m32r monitor";
// OBSOLETE   m32r_ops.to_load = m32r_load_gen;	/* monitor lacks a download command */
// OBSOLETE   m32r_ops.to_doc = "Debug via the m32r monitor.\n\
// OBSOLETE Specify the serial device it is connected to (e.g. /dev/ttya).";
// OBSOLETE   m32r_ops.to_open = m32r_open;
// OBSOLETE   add_target (&m32r_ops);
// OBSOLETE 
// OBSOLETE   /* Initialize mon2000 monitor target */
// OBSOLETE   init_mon2000_cmds ();
// OBSOLETE   init_monitor_ops (&mon2000_ops);
// OBSOLETE 
// OBSOLETE   mon2000_ops.to_shortname = "mon2000";
// OBSOLETE   mon2000_ops.to_longname = "Mon2000 monitor";
// OBSOLETE   mon2000_ops.to_load = m32r_load_gen;	/* monitor lacks a download command */
// OBSOLETE   mon2000_ops.to_doc = "Debug via the Mon2000 monitor.\n\
// OBSOLETE Specify the serial device it is connected to (e.g. /dev/ttya).";
// OBSOLETE   mon2000_ops.to_open = mon2000_open;
// OBSOLETE   add_target (&mon2000_ops);
// OBSOLETE 
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("download-path", class_obscure, var_string,
// OBSOLETE 		  (char *) &download_path,
// OBSOLETE 		  "Set the default path for downloadable SREC files.",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("board-address", class_obscure, var_string,
// OBSOLETE 		  (char *) &board_addr,
// OBSOLETE 		  "Set IP address for M32R-EVA target board.",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE 
// OBSOLETE   add_show_from_set
// OBSOLETE     (add_set_cmd ("server-address", class_obscure, var_string,
// OBSOLETE 		  (char *) &server_addr,
// OBSOLETE 		"Set IP address for download server (GDB's host computer).",
// OBSOLETE 		  &setlist),
// OBSOLETE      &showlist);
// OBSOLETE 
// OBSOLETE   add_com ("upload", class_obscure, m32r_upload_command,
// OBSOLETE       "Upload the srec file via the monitor's Ethernet upload capability.");
// OBSOLETE 
// OBSOLETE   add_com ("tload", class_obscure, m32r_load, "test upload command.");
// OBSOLETE }
@


1.9.24.2
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d1 626
a626 639
/* Remote debugging interface to m32r and mon2000 ROM monitors for GDB, 
   the GNU debugger.
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.

   Adapted by Michael Snyder of Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* This module defines communication with the Renesas m32r monitor */

#include "defs.h"
#include "gdbcore.h"
#include "target.h"
#include "monitor.h"
#include "serial.h"
#include "symtab.h"
#include "command.h"
#include "gdbcmd.h"
#include "symfile.h"		/* for generic load */
#include <time.h>		/* for time_t */
#include "gdb_string.h"
#include "objfiles.h"		/* for ALL_OBJFILES etc. */
#include "inferior.h"		/* for write_pc() */
#include <ctype.h>
#include "regcache.h"

/*
 * All this stuff just to get my host computer's IP address!
 */
#include <sys/types.h>
#include <netdb.h>		/* for hostent */
#include <netinet/in.h>		/* for struct in_addr */
#if 1
#include <arpa/inet.h>		/* for inet_ntoa */
#endif

static char *board_addr;	/* user-settable IP address for M32R-EVA */
static char *server_addr;	/* user-settable IP address for gdb host */
static char *download_path;	/* user-settable path for SREC files     */


/* REGNUM */
#define PSW_REGNUM      16
#define SPI_REGNUM      18
#define SPU_REGNUM      19
#define ACCL_REGNUM     22
#define ACCH_REGNUM     23


/* 
 * Function: m32r_load_1 (helper function)
 */

static void
m32r_load_section (bfd *abfd, asection *s, void *obj)
{
  unsigned int *data_count = obj;
  if (s->flags & SEC_LOAD)
    {
      bfd_size_type section_size = bfd_section_size (abfd, s);
      bfd_vma section_base = bfd_section_lma (abfd, s);
      unsigned int buffer, i;

      *data_count += section_size;

      printf_filtered ("Loading section %s, size 0x%lx lma ",
		       bfd_section_name (abfd, s), section_size);
      print_address_numeric (section_base, 1, gdb_stdout);
      printf_filtered ("\n");
      gdb_flush (gdb_stdout);
      monitor_printf ("%s mw\r", paddr_nz (section_base));
      for (i = 0; i < section_size; i += 4)
	{
	  QUIT;
	  monitor_expect (" -> ", NULL, 0);
	  bfd_get_section_contents (abfd, s, (char *) &buffer, i, 4);
	  monitor_printf ("%x\n", buffer);
	}
      monitor_expect (" -> ", NULL, 0);
      monitor_printf ("q\n");
      monitor_expect_prompt (NULL, 0);
    }
}

static int
m32r_load_1 (void *dummy)
{
  int data_count = 0;

  bfd_map_over_sections ((bfd *) dummy, m32r_load_section, &data_count);
  return data_count;
}

/* 
 * Function: m32r_load (an alternate way to load) 
 */

static void
m32r_load (char *filename, int from_tty)
{
  bfd *abfd;
  asection *s;
  unsigned int i, data_count = 0;
  time_t start_time, end_time;	/* for timing of download */

  if (filename == NULL || filename[0] == 0)
    filename = get_exec_file (1);

  abfd = bfd_openr (filename, 0);
  if (!abfd)
    error ("Unable to open file %s\n", filename);
  if (bfd_check_format (abfd, bfd_object) == 0)
    error ("File is not an object file\n");
  start_time = time (NULL);
#if 0
  for (s = abfd->sections; s; s = s->next)
    if (s->flags & SEC_LOAD)
      {
	bfd_size_type section_size = bfd_section_size (abfd, s);
	bfd_vma section_base = bfd_section_vma (abfd, s);
	unsigned int buffer;

	data_count += section_size;

	printf_filtered ("Loading section %s, size 0x%lx vma ",
			 bfd_section_name (abfd, s), section_size);
	print_address_numeric (section_base, 1, gdb_stdout);
	printf_filtered ("\n");
	gdb_flush (gdb_stdout);
	monitor_printf ("%x mw\r", section_base);
	for (i = 0; i < section_size; i += 4)
	  {
	    monitor_expect (" -> ", NULL, 0);
	    bfd_get_section_contents (abfd, s, (char *) &buffer, i, 4);
	    monitor_printf ("%x\n", buffer);
	  }
	monitor_expect (" -> ", NULL, 0);
	monitor_printf ("q\n");
	monitor_expect_prompt (NULL, 0);
      }
#else
  if (!(catch_errors (m32r_load_1, abfd, "Load aborted!\n", RETURN_MASK_ALL)))
    {
      monitor_printf ("q\n");
      return;
    }
#endif
  end_time = time (NULL);
  printf_filtered ("Start address 0x%lx\n", bfd_get_start_address (abfd));
  print_transfer_performance (gdb_stdout, data_count, 0,
			      end_time - start_time);

  /* Finally, make the PC point at the start address */
  if (exec_bfd)
    write_pc (bfd_get_start_address (exec_bfd));

  inferior_ptid = null_ptid;	/* No process now */

  /* This is necessary because many things were based on the PC at the
     time that we attached to the monitor, which is no longer valid
     now that we have loaded new code (and just changed the PC).
     Another way to do this might be to call normal_stop, except that
     the stack may not be valid, and things would get horribly
     confused... */

  clear_symtab_users ();
}

static void
m32r_load_gen (char *filename, int from_tty)
{
  generic_load (filename, from_tty);
}

static void m32r_open (char *args, int from_tty);
static void mon2000_open (char *args, int from_tty);

/* This array of registers needs to match the indexes used by GDB. The
   whole reason this exists is because the various ROM monitors use
   different names than GDB does, and don't support all the registers
   either. So, typing "info reg sp" becomes an "A7". */

static char *m32r_regnames[] =
  { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
  "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
  "psw", "cbr", "spi", "spu", "bpc", "pc", "accl", "acch",
};

static void
m32r_supply_register (char *regname, int regnamelen, char *val, int vallen)
{
  int regno;
  int num_regs = sizeof (m32r_regnames) / sizeof (m32r_regnames[0]);

  for (regno = 0; regno < num_regs; regno++)
    if (strncmp (regname, m32r_regnames[regno], regnamelen) == 0)
      break;

  if (regno >= num_regs)
    return;			/* no match */

  if (regno == ACCL_REGNUM)
    {				/* special handling for 64-bit acc reg */
      monitor_supply_register (ACCH_REGNUM, val);
      val = strchr (val, ':');	/* skip past ':' to get 2nd word */
      if (val != NULL)
	monitor_supply_register (ACCL_REGNUM, val + 1);
    }
  else
    {
      monitor_supply_register (regno, val);
      if (regno == PSW_REGNUM)
	{
	  unsigned long psw = strtoul (val, NULL, 16);
	  char *zero = "00000000", *one = "00000001";

#ifdef SM_REGNUM
	  /* Stack mode bit */
	  monitor_supply_register (SM_REGNUM, (psw & 0x80) ? one : zero);
#endif
#ifdef BSM_REGNUM
	  /* Backup stack mode bit */
	  monitor_supply_register (BSM_REGNUM, (psw & 0x8000) ? one : zero);
#endif
#ifdef IE_REGNUM
	  /* Interrupt enable bit */
	  monitor_supply_register (IE_REGNUM, (psw & 0x40) ? one : zero);
#endif
#ifdef BIE_REGNUM
	  /* Backup interrupt enable bit */
	  monitor_supply_register (BIE_REGNUM, (psw & 0x4000) ? one : zero);
#endif
#ifdef COND_REGNUM
	  /* Condition bit (carry etc.) */
	  monitor_supply_register (COND_REGNUM, (psw & 0x1) ? one : zero);
#endif
#ifdef CBR_REGNUM
	  monitor_supply_register (CBR_REGNUM, (psw & 0x1) ? one : zero);
#endif
#ifdef BPC_REGNUM
	  monitor_supply_register (BPC_REGNUM, zero);	/* KLUDGE:   (???????) */
#endif
#ifdef BCARRY_REGNUM
	  monitor_supply_register (BCARRY_REGNUM, zero);	/* KLUDGE: (??????) */
#endif
	}

      if (regno == SPI_REGNUM || regno == SPU_REGNUM)
	{			/* special handling for stack pointer (spu or spi) */
	  ULONGEST stackmode, psw;
	  regcache_cooked_read_unsigned (current_regcache, PSW_REGNUM, &psw);
	  stackmode = psw & 0x80;

	  if (regno == SPI_REGNUM && !stackmode)	/* SP == SPI */
	    monitor_supply_register (SP_REGNUM, val);
	  else if (regno == SPU_REGNUM && stackmode)	/* SP == SPU */
	    monitor_supply_register (SP_REGNUM, val);
	}
    }
}

/* m32r RevC board monitor */

static struct target_ops m32r_ops;

static char *m32r_inits[] = { "\r", NULL };

static struct monitor_ops m32r_cmds;

static void
init_m32r_cmds (void)
{
  m32r_cmds.flags = MO_CLR_BREAK_USES_ADDR | MO_REGISTER_VALUE_FIRST;
  m32r_cmds.init = m32r_inits;	/* Init strings */
  m32r_cmds.cont = "go\r";	/* continue command */
  m32r_cmds.step = "step\r";	/* single step */
  m32r_cmds.stop = NULL;	/* interrupt command */
  m32r_cmds.set_break = "%x +bp\r";	/* set a breakpoint */
  m32r_cmds.clr_break = "%x -bp\r";	/* clear a breakpoint */
  m32r_cmds.clr_all_break = "bpoff\r";	/* clear all breakpoints */
  m32r_cmds.fill = "%x %x %x fill\r";	/* fill (start length val) */
  m32r_cmds.setmem.cmdb = "%x 1 %x fill\r";	/* setmem.cmdb (addr, value) */
  m32r_cmds.setmem.cmdw = "%x 1 %x fillh\r";	/* setmem.cmdw (addr, value) */
  m32r_cmds.setmem.cmdl = "%x 1 %x fillw\r";	/* setmem.cmdl (addr, value) */
  m32r_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
  m32r_cmds.setmem.resp_delim = NULL;	/* setmem.resp_delim */
  m32r_cmds.setmem.term = NULL;	/* setmem.term */
  m32r_cmds.setmem.term_cmd = NULL;	/* setmem.term_cmd */
  m32r_cmds.getmem.cmdb = "%x %x dump\r";	/* getmem.cmdb (addr, len) */
  m32r_cmds.getmem.cmdw = NULL;	/* getmem.cmdw (addr, len) */
  m32r_cmds.getmem.cmdl = NULL;	/* getmem.cmdl (addr, len) */
  m32r_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, len) */
  m32r_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
  m32r_cmds.getmem.term = NULL;	/* getmem.term */
  m32r_cmds.getmem.term_cmd = NULL;	/* getmem.term_cmd */
  m32r_cmds.setreg.cmd = "%x to %%%s\r";	/* setreg.cmd (name, value) */
  m32r_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
  m32r_cmds.setreg.term = NULL;	/* setreg.term */
  m32r_cmds.setreg.term_cmd = NULL;	/* setreg.term_cmd */
  m32r_cmds.getreg.cmd = NULL;	/* getreg.cmd (name) */
  m32r_cmds.getreg.resp_delim = NULL;	/* getreg.resp_delim */
  m32r_cmds.getreg.term = NULL;	/* getreg.term */
  m32r_cmds.getreg.term_cmd = NULL;	/* getreg.term_cmd */
  m32r_cmds.dump_registers = ".reg\r";	/* dump_registers */
  m32r_cmds.register_pattern = "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)";	/* register_pattern */
  m32r_cmds.supply_register = m32r_supply_register;	/* supply_register */
  m32r_cmds.load_routine = NULL;	/* load_routine (defaults to SRECs) */
  m32r_cmds.load = NULL;	/* download command */
  m32r_cmds.loadresp = NULL;	/* load response */
  m32r_cmds.prompt = "ok ";	/* monitor command prompt */
  m32r_cmds.line_term = "\r";	/* end-of-line terminator */
  m32r_cmds.cmd_end = NULL;	/* optional command terminator */
  m32r_cmds.target = &m32r_ops;	/* target operations */
  m32r_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
  m32r_cmds.regnames = m32r_regnames;	/* registers names */
  m32r_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
}				/* init_m32r_cmds */

static void
m32r_open (char *args, int from_tty)
{
  monitor_open (args, &m32r_cmds, from_tty);
}

/* Mon2000 monitor (MSA2000 board) */

static struct target_ops mon2000_ops;
static struct monitor_ops mon2000_cmds;

static void
init_mon2000_cmds (void)
{
  mon2000_cmds.flags = MO_CLR_BREAK_USES_ADDR | MO_REGISTER_VALUE_FIRST;
  mon2000_cmds.init = m32r_inits;	/* Init strings */
  mon2000_cmds.cont = "go\r";	/* continue command */
  mon2000_cmds.step = "step\r";	/* single step */
  mon2000_cmds.stop = NULL;	/* interrupt command */
  mon2000_cmds.set_break = "%x +bp\r";	/* set a breakpoint */
  mon2000_cmds.clr_break = "%x -bp\r";	/* clear a breakpoint */
  mon2000_cmds.clr_all_break = "bpoff\r";	/* clear all breakpoints */
  mon2000_cmds.fill = "%x %x %x fill\r";	/* fill (start length val) */
  mon2000_cmds.setmem.cmdb = "%x 1 %x fill\r";	/* setmem.cmdb (addr, value) */
  mon2000_cmds.setmem.cmdw = "%x 1 %x fillh\r";	/* setmem.cmdw (addr, value) */
  mon2000_cmds.setmem.cmdl = "%x 1 %x fillw\r";	/* setmem.cmdl (addr, value) */
  mon2000_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
  mon2000_cmds.setmem.resp_delim = NULL;	/* setmem.resp_delim */
  mon2000_cmds.setmem.term = NULL;	/* setmem.term */
  mon2000_cmds.setmem.term_cmd = NULL;	/* setmem.term_cmd */
  mon2000_cmds.getmem.cmdb = "%x %x dump\r";	/* getmem.cmdb (addr, len) */
  mon2000_cmds.getmem.cmdw = NULL;	/* getmem.cmdw (addr, len) */
  mon2000_cmds.getmem.cmdl = NULL;	/* getmem.cmdl (addr, len) */
  mon2000_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, len) */
  mon2000_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
  mon2000_cmds.getmem.term = NULL;	/* getmem.term */
  mon2000_cmds.getmem.term_cmd = NULL;	/* getmem.term_cmd */
  mon2000_cmds.setreg.cmd = "%x to %%%s\r";	/* setreg.cmd (name, value) */
  mon2000_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
  mon2000_cmds.setreg.term = NULL;	/* setreg.term */
  mon2000_cmds.setreg.term_cmd = NULL;	/* setreg.term_cmd */
  mon2000_cmds.getreg.cmd = NULL;	/* getreg.cmd (name) */
  mon2000_cmds.getreg.resp_delim = NULL;	/* getreg.resp_delim */
  mon2000_cmds.getreg.term = NULL;	/* getreg.term */
  mon2000_cmds.getreg.term_cmd = NULL;	/* getreg.term_cmd */
  mon2000_cmds.dump_registers = ".reg\r";	/* dump_registers */
  mon2000_cmds.register_pattern = "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)";	/* register_pattern */
  mon2000_cmds.supply_register = m32r_supply_register;	/* supply_register */
  mon2000_cmds.load_routine = NULL;	/* load_routine (defaults to SRECs) */
  mon2000_cmds.load = NULL;	/* download command */
  mon2000_cmds.loadresp = NULL;	/* load response */
  mon2000_cmds.prompt = "Mon2000>";	/* monitor command prompt */
  mon2000_cmds.line_term = "\r";	/* end-of-line terminator */
  mon2000_cmds.cmd_end = NULL;	/* optional command terminator */
  mon2000_cmds.target = &mon2000_ops;	/* target operations */
  mon2000_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
  mon2000_cmds.regnames = m32r_regnames;	/* registers names */
  mon2000_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
}				/* init_mon2000_cmds */

static void
mon2000_open (char *args, int from_tty)
{
  monitor_open (args, &mon2000_cmds, from_tty);
}

/* Function: set_board_address
   Tell the BootOne monitor what it's ethernet IP address is. */

static void
m32r_set_board_address (char *args, int from_tty)
{
  int resp_len;
  char buf[1024];

  if (args && *args)
    {
      monitor_printf ("ulip %s\n", args);
      resp_len = monitor_expect_prompt (buf, sizeof (buf));
      /* now parse the result for success */
    }
  else
    error ("Requires argument (IP address for M32R-EVA board)");
}

/* Function: set_server_address
   Tell the BootOne monitor what gdb's ethernet IP address is. */

static void
m32r_set_server_address (char *args, int from_tty)
{
  int resp_len;
  char buf[1024];

  if (args && *args)
    {
      monitor_printf ("uhip %s\n", args);
      resp_len = monitor_expect_prompt (buf, sizeof (buf));
      /* now parse the result for success */
    }
  else
    error ("Requires argument (IP address of GDB's host computer)");
}

/* Function: set_download_path
   Tell the BootOne monitor the default path for downloadable SREC files. */

static void
m32r_set_download_path (char *args, int from_tty)
{
  int resp_len;
  char buf[1024];

  if (args && *args)
    {
      monitor_printf ("up %s\n", args);
      resp_len = monitor_expect_prompt (buf, sizeof (buf));
      /* now parse the result for success */
    }
  else
    error ("Requires argument (default path for downloadable SREC files)");
}

static void
m32r_upload_command (char *args, int from_tty)
{
  bfd *abfd;
  asection *s;
  time_t start_time, end_time;	/* for timing of download */
  int resp_len, data_count = 0;
  char buf[1024];
  struct hostent *hostent;
  struct in_addr inet_addr;

  /* first check to see if there's an ethernet port! */
  monitor_printf ("ust\r");
  resp_len = monitor_expect_prompt (buf, sizeof (buf));
  if (!strchr (buf, ':'))
    error ("No ethernet connection!");

  if (board_addr == 0)
    {
      /* scan second colon in the output from the "ust" command */
      char *myIPaddress = strchr (strchr (buf, ':') + 1, ':') + 1;

      while (isspace (*myIPaddress))
	myIPaddress++;

      if (!strncmp (myIPaddress, "0.0.", 4))	/* empty */
	error
	  ("Please use 'set board-address' to set the M32R-EVA board's IP address.");
      if (strchr (myIPaddress, '('))
	*(strchr (myIPaddress, '(')) = '\0';	/* delete trailing junk */
      board_addr = xstrdup (myIPaddress);
    }
  if (server_addr == 0)
    {
      buf[0] = 0;
      gethostname (buf, sizeof (buf));
      if (buf[0] != 0)
	{
	  hostent = gethostbyname (buf);
	  if (hostent != 0)
	    {
#if 1
	      memcpy (&inet_addr.s_addr, hostent->h_addr,
		      sizeof (inet_addr.s_addr));
	      server_addr = (char *) inet_ntoa (inet_addr);
#else
	      server_addr = (char *) inet_ntoa (hostent->h_addr);
#endif
	    }
	}
      if (server_addr == 0)	/* failed? */
	error
	  ("Need to know gdb host computer's IP address (use 'set server-address')");
    }

  if (args == 0 || args[0] == 0)	/* no args: upload the current file */
    args = get_exec_file (1);

  if (args[0] != '/' && download_path == 0)
    {
      if (current_directory)
	download_path = xstrdup (current_directory);
      else
	error
	  ("Need to know default download path (use 'set download-path')");
    }

  start_time = time (NULL);
  monitor_printf ("uhip %s\r", server_addr);
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result? */
  monitor_printf ("ulip %s\r", board_addr);
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result? */
  if (args[0] != '/')
    monitor_printf ("up %s\r", download_path);	/* use default path */
  else
    monitor_printf ("up\r");	/* rooted filename/path */
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result? */

  if (strrchr (args, '.') && !strcmp (strrchr (args, '.'), ".srec"))
    monitor_printf ("ul %s\r", args);
  else				/* add ".srec" suffix */
    monitor_printf ("ul %s.srec\r", args);
  resp_len = monitor_expect_prompt (buf, sizeof (buf));	/* parse result? */

  if (buf[0] == 0 || strstr (buf, "complete") == 0)
    error
      ("Upload file not found: %s.srec\nCheck IP addresses and download path.",
       args);
  else
    printf_filtered (" -- Ethernet load complete.\n");

  end_time = time (NULL);
  abfd = bfd_openr (args, 0);
  if (abfd != NULL)
    {				/* Download is done -- print section statistics */
      if (bfd_check_format (abfd, bfd_object) == 0)
	{
	  printf_filtered ("File is not an object file\n");
	}
      for (s = abfd->sections; s; s = s->next)
	if (s->flags & SEC_LOAD)
	  {
	    bfd_size_type section_size = bfd_section_size (abfd, s);
	    bfd_vma section_base = bfd_section_lma (abfd, s);
	    unsigned int buffer;

	    data_count += section_size;

	    printf_filtered ("Loading section %s, size 0x%lx lma ",
			     bfd_section_name (abfd, s), section_size);
	    print_address_numeric (section_base, 1, gdb_stdout);
	    printf_filtered ("\n");
	    gdb_flush (gdb_stdout);
	  }
      /* Finally, make the PC point at the start address */
      write_pc (bfd_get_start_address (abfd));
      printf_filtered ("Start address 0x%lx\n", bfd_get_start_address (abfd));
      print_transfer_performance (gdb_stdout, data_count, 0,
				  end_time - start_time);
    }
  inferior_ptid = null_ptid;	/* No process now */

  /* This is necessary because many things were based on the PC at the
     time that we attached to the monitor, which is no longer valid
     now that we have loaded new code (and just changed the PC).
     Another way to do this might be to call normal_stop, except that
     the stack may not be valid, and things would get horribly
     confused... */

  clear_symtab_users ();
}

void
_initialize_m32r_rom (void)
{
  /* Initialize m32r RevC monitor target */
  init_m32r_cmds ();
  init_monitor_ops (&m32r_ops);

  m32r_ops.to_shortname = "m32r";
  m32r_ops.to_longname = "m32r monitor";
  m32r_ops.to_load = m32r_load_gen;	/* monitor lacks a download command */
  m32r_ops.to_doc = "Debug via the m32r monitor.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  m32r_ops.to_open = m32r_open;
  add_target (&m32r_ops);

  /* Initialize mon2000 monitor target */
  init_mon2000_cmds ();
  init_monitor_ops (&mon2000_ops);

  mon2000_ops.to_shortname = "mon2000";
  mon2000_ops.to_longname = "Mon2000 monitor";
  mon2000_ops.to_load = m32r_load_gen;	/* monitor lacks a download command */
  mon2000_ops.to_doc = "Debug via the Mon2000 monitor.\n\
Specify the serial device it is connected to (e.g. /dev/ttya).";
  mon2000_ops.to_open = mon2000_open;
  add_target (&mon2000_ops);

  add_setshow_cmd ("download-path", class_obscure,
		   var_string, &download_path,
		   "Set the default path for downloadable SREC files.",
		   "Show the default path for downloadable SREC files.",
		   NULL, NULL, &setlist, &showlist);

  add_setshow_cmd ("board-address", class_obscure,
		   var_string, &board_addr,
		   "Set IP address for M32R-EVA target board.",
		   "Show IP address for M32R-EVA target board.",
		   NULL, NULL, &setlist, &showlist);

  add_setshow_cmd ("server-address", class_obscure,
		   var_string, &server_addr,
		   "Set IP address for download server (GDB's host computer).",
		   "Show IP address for download server (GDB's host computer).",
		   NULL, NULL, &setlist, &showlist);

  add_com ("upload", class_obscure, m32r_upload_command,
	   "Upload the srec file via the monitor's Ethernet upload capability.");

  add_com ("tload", class_obscure, m32r_load, "test upload command.");
}
@


1.8
log
@Phase 1 of the ptid_t changes.
@
text
@a44 1
#ifndef _MSC_VER
a53 1
#endif
a392 2
#ifndef _MSC_VER

a573 2
#endif /* ! _MSC_VER */

a600 1
#ifndef _MSC_VER
a625 1
#endif
@


1.7
log
@Update/correct copyright notices.
@
text
@a112 1
  extern int inferior_pid;
d168 1
a168 1
  inferior_pid = 0;		/* No process now */
a459 1
  extern int inferior_pid;
d566 1
a566 1
  inferior_pid = 0;		/* No process now */
@


1.6
log
@Create new file regcache.h.  Update all uses.
@
text
@d3 2
a4 1
   Copyright 1996, 2001 Free Software Foundation, Inc.
@


1.5
log
@Replace strsave() with xstrdup().
@
text
@d40 1
@


1.4
log
@* m32r-rom.c (m32r_load_section): Update to match
bfd_map_over_sections's ``func'' arg.
@
text
@d3 1
a3 1
   Copyright 1996 Free Software Foundation, Inc.
d483 1
a483 1
      board_addr = strsave (myIPaddress);
d511 1
a511 1
	download_path = strsave (current_directory);
@


1.3
log
@Protoization.
@
text
@d65 1
a65 1
m32r_load_section (bfd *abfd, asection *s, unsigned int *data_count)
d67 1
@


1.2
log
@PARAMS removal.
@
text
@d65 1
a65 4
m32r_load_section (abfd, s, data_count)
     bfd *abfd;
     asection *s;
     unsigned int *data_count;
d95 1
a95 2
m32r_load_1 (dummy)
     void *dummy;
d108 1
a108 3
m32r_load (filename, from_tty)
     char *filename;
     int from_tty;
d179 1
a179 3
m32r_load_gen (filename, from_tty)
     char *filename;
     int from_tty;
d199 1
a199 5
m32r_supply_register (regname, regnamelen, val, vallen)
     char *regname;
     int regnamelen;
     char *val;
     int vallen;
d328 1
a328 3
m32r_open (args, from_tty)
     char *args;
     int from_tty;
d388 1
a388 3
mon2000_open (args, from_tty)
     char *args;
     int from_tty;
d399 1
a399 3
m32r_set_board_address (args, from_tty)
     char *args;
     int from_tty;
d418 1
a418 3
m32r_set_server_address (args, from_tty)
     char *args;
     int from_tty;
d437 1
a437 3
m32r_set_download_path (args, from_tty)
     char *args;
     int from_tty;
d453 1
a453 3
m32r_upload_command (args, from_tty)
     char *args;
     int from_tty;
d580 1
a580 1
_initialize_m32r_rom ()
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
This file is part of GDB.
d9 14
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d34 2
a35 2
#include "symfile.h"	/* for generic load */
#include <time.h>	/* for time_t */
d37 3
a39 1
#include "objfiles.h"	/* for ALL_OBJFILES etc. */
d41 1
a41 2

extern void report_transfer_performance PARAMS ((unsigned long, time_t, time_t));
d48 2
a49 2
#include <netdb.h>	/* for hostent */
#include <netinet/in.h>	/* for struct in_addr */
d51 1
a51 1
#include <arpa/inet.h>	/* for inet_ntoa */
d66 1
a66 1
     bfd      *abfd;
d73 2
a74 2
      bfd_vma       section_base = bfd_section_lma  (abfd, s);
      unsigned int  buffer, i;
d83 1
a83 1
      monitor_printf ("%x mw\r" , section_base);
d97 1
a97 1
static int 
d112 3
a114 3
m32r_load (filename, from_tty) 
    char *filename;
    int from_tty;
d136 2
a137 2
	bfd_vma       section_base = bfd_section_vma  (abfd, s);
	unsigned int  buffer;
d145 2
a146 2
 	gdb_flush (gdb_stdout);
	monitor_printf ("%x mw\r" , section_base);
d172 1
a172 1
  inferior_pid = 0;             /* No process now */
d185 3
a187 3
m32r_load_gen (filename, from_tty) 
    char *filename;
    int from_tty;
d192 2
a193 2
static void m32r_open PARAMS ((char *args, int from_tty));
static void mon2000_open PARAMS ((char *args, int from_tty));
d200 4
a203 4
static char *m32r_regnames[] = 
{ "r0",  "r1",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7", 
  "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15", 
  "psw", "cbr", "spi", "spu", "bpc", "pc",  "accl", "acch", 
d214 1
a214 1
  int num_regs = sizeof(m32r_regnames) / sizeof(m32r_regnames[0]);
d217 1
a217 1
    if (strncmp(regname, m32r_regnames[regno], regnamelen) == 0)
d221 1
a221 1
    return;		/* no match */
d224 1
a224 1
    { /* special handling for 64-bit acc reg */
d226 2
a227 1
      if (val = (char *) strchr(val, ':'))  /* skip past ':' to get 2nd word */
d262 1
a262 1
	  monitor_supply_register (BPC_REGNUM, zero); /* KLUDGE:   (???????) */
d265 1
a265 1
	  monitor_supply_register (BCARRY_REGNUM, zero); /* KLUDGE: (??????) */
d267 1
a267 1
	}	  
d269 2
a270 2
      if (regno == SPI_REGNUM || regno == SPU_REGNUM)	
	{ /* special handling for stack pointer (spu or spi) */
d285 2
a286 1
static char *m32r_inits[] = {"\r", NULL};
d288 1
a288 1
static struct monitor_ops m32r_cmds ;
d290 2
a291 2
static void 
init_m32r_cmds(void)
d293 45
a337 45
  m32r_cmds.flags =   MO_CLR_BREAK_USES_ADDR | MO_REGISTER_VALUE_FIRST;
  m32r_cmds.init =   m32r_inits;		/* Init strings */
  m32r_cmds.cont =   "go\r";			/* continue command */
  m32r_cmds.step =   "step\r";			/* single step */
  m32r_cmds.stop =   NULL;			/* interrupt command */
  m32r_cmds.set_break =   "%x +bp\r";		/* set a breakpoint */
  m32r_cmds.clr_break =   "%x -bp\r";		/* clear a breakpoint */
  m32r_cmds.clr_all_break =   "bpoff\r";	/* clear all breakpoints */
  m32r_cmds.fill =   "%x %x %x fill\r";		/* fill (start length val) */
  m32r_cmds.setmem.cmdb =     "%x 1 %x fill\r";	/* setmem.cmdb (addr, value) */
  m32r_cmds.setmem.cmdw =     "%x 1 %x fillh\r";/* setmem.cmdw (addr, value) */
  m32r_cmds.setmem.cmdl =     "%x 1 %x fillw\r";/* setmem.cmdl (addr, value) */
  m32r_cmds.setmem.cmdll =     NULL;		/* setmem.cmdll (addr, value) */
  m32r_cmds.setmem.resp_delim =     NULL;	/* setmem.resp_delim */
  m32r_cmds.setmem.term =     NULL;		/* setmem.term */
  m32r_cmds.setmem.term_cmd =     NULL;		/* setmem.term_cmd */
  m32r_cmds.getmem.cmdb =     "%x %x dump\r";	/* getmem.cmdb (addr, len) */
  m32r_cmds.getmem.cmdw =     NULL;		/* getmem.cmdw (addr, len) */
  m32r_cmds.getmem.cmdl =     NULL;		/* getmem.cmdl (addr, len) */
  m32r_cmds.getmem.cmdll =     NULL;		/* getmem.cmdll (addr, len) */
  m32r_cmds.getmem.resp_delim =     ": ";	/* getmem.resp_delim */
  m32r_cmds.getmem.term =     NULL;		/* getmem.term */
  m32r_cmds.getmem.term_cmd =     NULL	;	/* getmem.term_cmd */
  m32r_cmds.setreg.cmd =     "%x to %%%s\r";	/* setreg.cmd (name, value) */
  m32r_cmds.setreg.resp_delim =     NULL;	/* setreg.resp_delim */
  m32r_cmds.setreg.term =     NULL;		/* setreg.term */
  m32r_cmds.setreg.term_cmd =     NULL	;	/* setreg.term_cmd */
  m32r_cmds.getreg.cmd =     NULL;		/* getreg.cmd (name) */
  m32r_cmds.getreg.resp_delim =     NULL;	/* getreg.resp_delim */
  m32r_cmds.getreg.term =     NULL;		/* getreg.term */
  m32r_cmds.getreg.term_cmd =     NULL	;	/* getreg.term_cmd */
  m32r_cmds.dump_registers =   ".reg\r";	/* dump_registers */
  m32r_cmds.register_pattern =   "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)"; /* register_pattern */
  m32r_cmds.supply_register =   m32r_supply_register;	/* supply_register */
  m32r_cmds.load_routine =   NULL;		/* load_routine (defaults to SRECs) */
  m32r_cmds.load =   NULL;			/* download command */
  m32r_cmds.loadresp =   NULL;			/* load response */
  m32r_cmds.prompt =   "ok ";			/* monitor command prompt */
  m32r_cmds.line_term =   "\r";			/* end-of-line terminator */
  m32r_cmds.cmd_end =   NULL;			/* optional command terminator */
  m32r_cmds.target =   &m32r_ops;		/* target operations */
  m32r_cmds.stopbits =   SERIAL_1_STOPBITS;	/* number of stop bits */
  m32r_cmds.regnames =   m32r_regnames;		/* registers names */
  m32r_cmds.magic =   MONITOR_OPS_MAGIC	;	/* magic */
} /* init_m32r_cmds */
d340 1
a340 1
m32r_open(args, from_tty)
d352 2
a353 2
static void 
init_mon2000_cmds(void)
d355 45
a399 45
  mon2000_cmds.flags =   MO_CLR_BREAK_USES_ADDR | MO_REGISTER_VALUE_FIRST;
  mon2000_cmds.init =   m32r_inits;		/* Init strings */
  mon2000_cmds.cont =   "go\r";			/* continue command */
  mon2000_cmds.step =   "step\r";			/* single step */
  mon2000_cmds.stop =   NULL;			/* interrupt command */
  mon2000_cmds.set_break =   "%x +bp\r";		/* set a breakpoint */
  mon2000_cmds.clr_break =   "%x -bp\r";		/* clear a breakpoint */
  mon2000_cmds.clr_all_break =   "bpoff\r";	/* clear all breakpoints */
  mon2000_cmds.fill =   "%x %x %x fill\r";		/* fill (start length val) */
  mon2000_cmds.setmem.cmdb =     "%x 1 %x fill\r";	/* setmem.cmdb (addr, value) */
  mon2000_cmds.setmem.cmdw =     "%x 1 %x fillh\r";/* setmem.cmdw (addr, value) */
  mon2000_cmds.setmem.cmdl =     "%x 1 %x fillw\r";/* setmem.cmdl (addr, value) */
  mon2000_cmds.setmem.cmdll =     NULL;		/* setmem.cmdll (addr, value) */
  mon2000_cmds.setmem.resp_delim =     NULL;	/* setmem.resp_delim */
  mon2000_cmds.setmem.term =     NULL;		/* setmem.term */
  mon2000_cmds.setmem.term_cmd =     NULL;		/* setmem.term_cmd */
  mon2000_cmds.getmem.cmdb =     "%x %x dump\r";	/* getmem.cmdb (addr, len) */
  mon2000_cmds.getmem.cmdw =     NULL;		/* getmem.cmdw (addr, len) */
  mon2000_cmds.getmem.cmdl =     NULL;		/* getmem.cmdl (addr, len) */
  mon2000_cmds.getmem.cmdll =     NULL;		/* getmem.cmdll (addr, len) */
  mon2000_cmds.getmem.resp_delim =     ": ";	/* getmem.resp_delim */
  mon2000_cmds.getmem.term =     NULL;		/* getmem.term */
  mon2000_cmds.getmem.term_cmd =     NULL	;	/* getmem.term_cmd */
  mon2000_cmds.setreg.cmd =     "%x to %%%s\r";	/* setreg.cmd (name, value) */
  mon2000_cmds.setreg.resp_delim =     NULL;	/* setreg.resp_delim */
  mon2000_cmds.setreg.term =     NULL;		/* setreg.term */
  mon2000_cmds.setreg.term_cmd =     NULL	;	/* setreg.term_cmd */
  mon2000_cmds.getreg.cmd =     NULL;		/* getreg.cmd (name) */
  mon2000_cmds.getreg.resp_delim =     NULL;	/* getreg.resp_delim */
  mon2000_cmds.getreg.term =     NULL;		/* getreg.term */
  mon2000_cmds.getreg.term_cmd =     NULL	;	/* getreg.term_cmd */
  mon2000_cmds.dump_registers =   ".reg\r";	/* dump_registers */
  mon2000_cmds.register_pattern =   "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)"; /* register_pattern */
  mon2000_cmds.supply_register =   m32r_supply_register;	/* supply_register */
  mon2000_cmds.load_routine =   NULL;		/* load_routine (defaults to SRECs) */
  mon2000_cmds.load =   NULL;			/* download command */
  mon2000_cmds.loadresp =   NULL;			/* load response */
  mon2000_cmds.prompt =   "Mon2000>";			/* monitor command prompt */
  mon2000_cmds.line_term =   "\r";			/* end-of-line terminator */
  mon2000_cmds.cmd_end =   NULL;			/* optional command terminator */
  mon2000_cmds.target =   &mon2000_ops;		/* target operations */
  mon2000_cmds.stopbits =   SERIAL_1_STOPBITS;	/* number of stop bits */
  mon2000_cmds.regnames =   m32r_regnames;		/* registers names */
  mon2000_cmds.magic =   MONITOR_OPS_MAGIC	;	/* magic */
} /* init_mon2000_cmds */
d402 1
a402 1
mon2000_open(args, from_tty)
d417 1
a417 1
     int  from_tty;
d425 1
a425 1
      resp_len = monitor_expect_prompt (buf, sizeof(buf));
d438 1
a438 1
     int  from_tty;
d446 1
a446 1
      resp_len = monitor_expect_prompt (buf, sizeof(buf));
d459 1
a459 1
     int  from_tty;
d467 1
a467 1
      resp_len = monitor_expect_prompt (buf, sizeof(buf));
d490 1
a490 1
  resp_len = monitor_expect_prompt (buf, sizeof(buf));
d497 1
a497 1
      char * myIPaddress = strchr (strchr (buf, ':') + 1, ':') + 1;
d499 1
a499 1
      while (isspace(*myIPaddress))
d502 1
a502 1
      if (!strncmp (myIPaddress, "0.0.", 4))    /* empty */
d505 1
a505 1
	*(strchr (myIPaddress, '(')) = '\0';    /* delete trailing junk */
d511 1
a511 1
      gethostname (buf, sizeof(buf));
d517 2
a518 2
	  memcpy (&inet_addr.s_addr, hostent->h_addr, 
		  sizeof(inet_addr.s_addr));
d532 6
a537 4
    if (current_directory)
      download_path = strsave (current_directory);
    else
      error ("Need to know default download path (use 'set download-path')");
d541 1
a541 1
  resp_len = monitor_expect_prompt (buf, sizeof(buf));  /* parse result? */
d543 1
a543 1
  resp_len = monitor_expect_prompt (buf, sizeof(buf));  /* parse result? */
d547 2
a548 2
    monitor_printf ("up\r");			/* rooted filename/path */
  resp_len = monitor_expect_prompt (buf, sizeof(buf));  /* parse result? */
d552 1
a552 1
  else					/* add ".srec" suffix */
d554 1
a554 1
  resp_len = monitor_expect_prompt (buf, sizeof(buf));  /* parse result? */
d556 2
a557 2
  if (buf[0] == 0 || strstr(buf, "complete") == 0)
    error("Upload file not found: %s.srec\nCheck IP addresses and download path.", args);
d562 3
a564 2
  if (abfd = bfd_openr (args, 0))
    { /* Download is done -- print section statistics */
d573 2
a574 2
	    bfd_vma       section_base = bfd_section_lma  (abfd, s);
	    unsigned int  buffer;
d589 1
a589 1
  inferior_pid = 0;             /* No process now */
d607 1
a607 1
  init_m32r_cmds () ;
d648 1
a648 1
		  "Set IP address for download server (GDB's host computer).",
d653 1
a653 1
	   "Upload the srec file via the monitor's Ethernet upload capability."); 
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d224 1
a224 2
      val = strchr (val, ':'); /* skip past ':' to get 2nd word */
      if (val != NULL)
d528 4
a531 6
    {
      if (current_directory)
	download_path = strsave (current_directory);
      else
	error ("Need to know default download path (use 'set download-path')");
    }
d556 1
a556 2
  abfd = bfd_openr (args, 0);
  if (abfd != NULL)
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d7 1
a7 1
   This file is part of GDB.
d9 13
a21 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d33 2
a34 2
#include "symfile.h"		/* for generic load */
#include <time.h>		/* for time_t */
d36 1
a36 1
#include "objfiles.h"		/* for ALL_OBJFILES etc. */
d46 2
a47 2
#include <netdb.h>		/* for hostent */
#include <netinet/in.h>		/* for struct in_addr */
d49 1
a49 1
#include <arpa/inet.h>		/* for inet_ntoa */
d64 1
a64 1
     bfd *abfd;
d71 2
a72 2
      bfd_vma section_base = bfd_section_lma (abfd, s);
      unsigned int buffer, i;
d81 1
a81 1
      monitor_printf ("%x mw\r", section_base);
d95 1
a95 1
static int
d110 3
a112 3
m32r_load (filename, from_tty)
     char *filename;
     int from_tty;
d134 2
a135 2
	bfd_vma section_base = bfd_section_vma (abfd, s);
	unsigned int buffer;
d143 2
a144 2
	gdb_flush (gdb_stdout);
	monitor_printf ("%x mw\r", section_base);
d170 1
a170 1
  inferior_pid = 0;		/* No process now */
d183 3
a185 3
m32r_load_gen (filename, from_tty)
     char *filename;
     int from_tty;
d198 4
a201 4
static char *m32r_regnames[] =
{"r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
 "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
 "psw", "cbr", "spi", "spu", "bpc", "pc", "accl", "acch",
d212 1
a212 1
  int num_regs = sizeof (m32r_regnames) / sizeof (m32r_regnames[0]);
d215 1
a215 1
    if (strncmp (regname, m32r_regnames[regno], regnamelen) == 0)
d219 1
a219 1
    return;			/* no match */
d222 1
a222 1
    {				/* special handling for 64-bit acc reg */
d224 1
a224 1
      val = strchr (val, ':');	/* skip past ':' to get 2nd word */
d260 1
a260 1
	  monitor_supply_register (BPC_REGNUM, zero);	/* KLUDGE:   (???????) */
d263 1
a263 1
	  monitor_supply_register (BCARRY_REGNUM, zero);	/* KLUDGE: (??????) */
d265 1
a265 1
	}
d267 2
a268 2
      if (regno == SPI_REGNUM || regno == SPU_REGNUM)
	{			/* special handling for stack pointer (spu or spi) */
d283 1
a283 2
static char *m32r_inits[] =
{"\r", NULL};
d285 1
a285 1
static struct monitor_ops m32r_cmds;
d287 2
a288 2
static void
init_m32r_cmds (void)
d290 45
a334 45
  m32r_cmds.flags = MO_CLR_BREAK_USES_ADDR | MO_REGISTER_VALUE_FIRST;
  m32r_cmds.init = m32r_inits;	/* Init strings */
  m32r_cmds.cont = "go\r";	/* continue command */
  m32r_cmds.step = "step\r";	/* single step */
  m32r_cmds.stop = NULL;	/* interrupt command */
  m32r_cmds.set_break = "%x +bp\r";	/* set a breakpoint */
  m32r_cmds.clr_break = "%x -bp\r";	/* clear a breakpoint */
  m32r_cmds.clr_all_break = "bpoff\r";	/* clear all breakpoints */
  m32r_cmds.fill = "%x %x %x fill\r";	/* fill (start length val) */
  m32r_cmds.setmem.cmdb = "%x 1 %x fill\r";	/* setmem.cmdb (addr, value) */
  m32r_cmds.setmem.cmdw = "%x 1 %x fillh\r";	/* setmem.cmdw (addr, value) */
  m32r_cmds.setmem.cmdl = "%x 1 %x fillw\r";	/* setmem.cmdl (addr, value) */
  m32r_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
  m32r_cmds.setmem.resp_delim = NULL;	/* setmem.resp_delim */
  m32r_cmds.setmem.term = NULL;	/* setmem.term */
  m32r_cmds.setmem.term_cmd = NULL;	/* setmem.term_cmd */
  m32r_cmds.getmem.cmdb = "%x %x dump\r";	/* getmem.cmdb (addr, len) */
  m32r_cmds.getmem.cmdw = NULL;	/* getmem.cmdw (addr, len) */
  m32r_cmds.getmem.cmdl = NULL;	/* getmem.cmdl (addr, len) */
  m32r_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, len) */
  m32r_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
  m32r_cmds.getmem.term = NULL;	/* getmem.term */
  m32r_cmds.getmem.term_cmd = NULL;	/* getmem.term_cmd */
  m32r_cmds.setreg.cmd = "%x to %%%s\r";	/* setreg.cmd (name, value) */
  m32r_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
  m32r_cmds.setreg.term = NULL;	/* setreg.term */
  m32r_cmds.setreg.term_cmd = NULL;	/* setreg.term_cmd */
  m32r_cmds.getreg.cmd = NULL;	/* getreg.cmd (name) */
  m32r_cmds.getreg.resp_delim = NULL;	/* getreg.resp_delim */
  m32r_cmds.getreg.term = NULL;	/* getreg.term */
  m32r_cmds.getreg.term_cmd = NULL;	/* getreg.term_cmd */
  m32r_cmds.dump_registers = ".reg\r";	/* dump_registers */
  m32r_cmds.register_pattern = "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)";	/* register_pattern */
  m32r_cmds.supply_register = m32r_supply_register;	/* supply_register */
  m32r_cmds.load_routine = NULL;	/* load_routine (defaults to SRECs) */
  m32r_cmds.load = NULL;	/* download command */
  m32r_cmds.loadresp = NULL;	/* load response */
  m32r_cmds.prompt = "ok ";	/* monitor command prompt */
  m32r_cmds.line_term = "\r";	/* end-of-line terminator */
  m32r_cmds.cmd_end = NULL;	/* optional command terminator */
  m32r_cmds.target = &m32r_ops;	/* target operations */
  m32r_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
  m32r_cmds.regnames = m32r_regnames;	/* registers names */
  m32r_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
}				/* init_m32r_cmds */
d337 1
a337 1
m32r_open (args, from_tty)
d349 2
a350 2
static void
init_mon2000_cmds (void)
d352 45
a396 45
  mon2000_cmds.flags = MO_CLR_BREAK_USES_ADDR | MO_REGISTER_VALUE_FIRST;
  mon2000_cmds.init = m32r_inits;	/* Init strings */
  mon2000_cmds.cont = "go\r";	/* continue command */
  mon2000_cmds.step = "step\r";	/* single step */
  mon2000_cmds.stop = NULL;	/* interrupt command */
  mon2000_cmds.set_break = "%x +bp\r";	/* set a breakpoint */
  mon2000_cmds.clr_break = "%x -bp\r";	/* clear a breakpoint */
  mon2000_cmds.clr_all_break = "bpoff\r";	/* clear all breakpoints */
  mon2000_cmds.fill = "%x %x %x fill\r";	/* fill (start length val) */
  mon2000_cmds.setmem.cmdb = "%x 1 %x fill\r";	/* setmem.cmdb (addr, value) */
  mon2000_cmds.setmem.cmdw = "%x 1 %x fillh\r";		/* setmem.cmdw (addr, value) */
  mon2000_cmds.setmem.cmdl = "%x 1 %x fillw\r";		/* setmem.cmdl (addr, value) */
  mon2000_cmds.setmem.cmdll = NULL;	/* setmem.cmdll (addr, value) */
  mon2000_cmds.setmem.resp_delim = NULL;	/* setmem.resp_delim */
  mon2000_cmds.setmem.term = NULL;	/* setmem.term */
  mon2000_cmds.setmem.term_cmd = NULL;	/* setmem.term_cmd */
  mon2000_cmds.getmem.cmdb = "%x %x dump\r";	/* getmem.cmdb (addr, len) */
  mon2000_cmds.getmem.cmdw = NULL;	/* getmem.cmdw (addr, len) */
  mon2000_cmds.getmem.cmdl = NULL;	/* getmem.cmdl (addr, len) */
  mon2000_cmds.getmem.cmdll = NULL;	/* getmem.cmdll (addr, len) */
  mon2000_cmds.getmem.resp_delim = ": ";	/* getmem.resp_delim */
  mon2000_cmds.getmem.term = NULL;	/* getmem.term */
  mon2000_cmds.getmem.term_cmd = NULL;	/* getmem.term_cmd */
  mon2000_cmds.setreg.cmd = "%x to %%%s\r";	/* setreg.cmd (name, value) */
  mon2000_cmds.setreg.resp_delim = NULL;	/* setreg.resp_delim */
  mon2000_cmds.setreg.term = NULL;	/* setreg.term */
  mon2000_cmds.setreg.term_cmd = NULL;	/* setreg.term_cmd */
  mon2000_cmds.getreg.cmd = NULL;	/* getreg.cmd (name) */
  mon2000_cmds.getreg.resp_delim = NULL;	/* getreg.resp_delim */
  mon2000_cmds.getreg.term = NULL;	/* getreg.term */
  mon2000_cmds.getreg.term_cmd = NULL;	/* getreg.term_cmd */
  mon2000_cmds.dump_registers = ".reg\r";	/* dump_registers */
  mon2000_cmds.register_pattern = "\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)";	/* register_pattern */
  mon2000_cmds.supply_register = m32r_supply_register;	/* supply_register */
  mon2000_cmds.load_routine = NULL;	/* load_routine (defaults to SRECs) */
  mon2000_cmds.load = NULL;	/* download command */
  mon2000_cmds.loadresp = NULL;	/* load response */
  mon2000_cmds.prompt = "Mon2000>";	/* monitor command prompt */
  mon2000_cmds.line_term = "\r";	/* end-of-line terminator */
  mon2000_cmds.cmd_end = NULL;	/* optional command terminator */
  mon2000_cmds.target = &mon2000_ops;	/* target operations */
  mon2000_cmds.stopbits = SERIAL_1_STOPBITS;	/* number of stop bits */
  mon2000_cmds.regnames = m32r_regnames;	/* registers names */
  mon2000_cmds.magic = MONITOR_OPS_MAGIC;	/* magic */
}				/* init_mon2000_cmds */
d399 1
a399 1
mon2000_open (args, from_tty)
d414 1
a414 1
     int from_tty;
d422 1
a422 1
      resp_len = monitor_expect_prompt (buf, sizeof (buf));
d435 1
a435 1
     int from_tty;
d443 1
a443 1
      resp_len = monitor_expect_prompt (buf, sizeof (buf));
d456 1
a456 1
     int from_tty;
d464 1
a464 1
      resp_len = monitor_expect_prompt (buf, sizeof (buf));
d487 1
a487 1
  resp_len = monitor_expect_prompt (buf, sizeof (buf));
d494 1
a494 1
      char *myIPaddress = strchr (strchr (buf, ':') + 1, ':') + 1;
d496 1
a496 1
      while (isspace (*myIPaddress))
d499 1
a499 1
      if (!strncmp (myIPaddress, "0.0.", 4))	/* empty */
d502 1
a502 1
	*(strchr (myIPaddress, '(')) = '\0';	/* delete trailing junk */
d508 1
a508 1
      gethostname (buf, sizeof (buf));
d514 2
a515 2
	  memcpy (&inet_addr.s_addr, hostent->h_addr,
		  sizeof (inet_addr.s_addr));
d538 1
a538 1
  resp_len = monitor_expect_prompt (buf, sizeof (buf));		/* parse result? */
d540 1
a540 1
  resp_len = monitor_expect_prompt (buf, sizeof (buf));		/* parse result? */
d544 2
a545 2
    monitor_printf ("up\r");	/* rooted filename/path */
  resp_len = monitor_expect_prompt (buf, sizeof (buf));		/* parse result? */
d549 1
a549 1
  else				/* add ".srec" suffix */
d551 1
a551 1
  resp_len = monitor_expect_prompt (buf, sizeof (buf));		/* parse result? */
d553 2
a554 2
  if (buf[0] == 0 || strstr (buf, "complete") == 0)
    error ("Upload file not found: %s.srec\nCheck IP addresses and download path.", args);
d561 1
a561 1
    {				/* Download is done -- print section statistics */
d570 2
a571 2
	    bfd_vma section_base = bfd_section_lma (abfd, s);
	    unsigned int buffer;
d586 1
a586 1
  inferior_pid = 0;		/* No process now */
d604 1
a604 1
  init_m32r_cmds ();
d645 1
a645 1
		"Set IP address for download server (GDB's host computer).",
d650 1
a650 1
      "Upload the srec file via the monitor's Ethernet upload capability.");
@


1.1.1.4
log
@import gdb-1999-09-08 snapshot
@
text
@d38 1
a38 2
#include "inferior.h"		/* for write_pc() */
#include <ctype.h>
d82 1
a82 1
      monitor_printf ("%s mw\r", paddr_nz (section_base));
@


