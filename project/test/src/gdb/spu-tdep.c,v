head	1.90;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.86
	gdb_7_6-2013-04-26-release:1.86
	gdb_7_6-branch:1.86.0.2
	gdb_7_6-2013-03-12-branchpoint:1.86
	gdb_7_5_1-2012-11-29-release:1.81
	gdb_7_5-2012-08-17-release:1.81
	gdb_7_5-branch:1.81.0.2
	gdb_7_5-2012-07-18-branchpoint:1.81
	gdb_7_4_1-2012-04-26-release:1.76.2.2
	gdb_7_4-2012-01-24-release:1.76.2.1
	gdb_7_4-branch:1.76.0.2
	gdb_7_4-2011-12-13-branchpoint:1.76
	gdb_7_3_1-2011-09-04-release:1.72.2.1
	gdb_7_3-2011-07-26-release:1.72.2.1
	gdb_7_3-branch:1.72.0.2
	gdb_7_3-2011-04-01-branchpoint:1.72
	gdb_7_2-2010-09-02-release:1.62
	gdb_7_2-branch:1.62.0.2
	gdb_7_2-2010-07-07-branchpoint:1.62
	gdb_7_1-2010-03-18-release:1.55
	gdb_7_1-branch:1.55.0.2
	gdb_7_1-2010-02-18-branchpoint:1.55
	gdb_7_0_1-2009-12-22-release:1.53
	gdb_7_0-2009-10-06-release:1.53
	gdb_7_0-branch:1.53.0.2
	gdb_7_0-2009-09-16-branchpoint:1.53
	arc-sim-20090309:1.27
	msnyder-checkpoint-072509-branch:1.49.0.2
	msnyder-checkpoint-072509-branchpoint:1.49
	arc-insight_6_8-branch:1.27.0.6
	arc-insight_6_8-branchpoint:1.27
	insight_6_8-branch:1.27.0.4
	insight_6_8-branchpoint:1.27
	reverse-20081226-branch:1.41.0.6
	reverse-20081226-branchpoint:1.41
	multiprocess-20081120-branch:1.41.0.4
	multiprocess-20081120-branchpoint:1.41
	reverse-20080930-branch:1.41.0.2
	reverse-20080930-branchpoint:1.41
	reverse-20080717-branch:1.31.0.2
	reverse-20080717-branchpoint:1.31
	msnyder-reverse-20080609-branch:1.30.0.2
	msnyder-reverse-20080609-branchpoint:1.30
	drow-reverse-20070409-branch:1.10.0.2
	drow-reverse-20070409-branchpoint:1.10
	gdb_6_8-2008-03-27-release:1.27
	gdb_6_8-branch:1.27.0.2
	gdb_6_8-2008-02-26-branchpoint:1.27
	gdb_6_7_1-2007-10-29-release:1.21.2.1
	gdb_6_7-2007-10-10-release:1.21.2.1
	gdb_6_7-branch:1.21.0.2
	gdb_6_7-2007-09-07-branchpoint:1.21
	insight_6_6-20070208-release:1.1.2.1
	gdb_6_6-2006-12-18-release:1.1.2.1
	gdb_6_6-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.90
date	2013.04.19.15.10.53;	author palves;	state Exp;
branches;
next	1.89;

1.89
date	2013.04.19.15.09.46;	author palves;	state Exp;
branches;
next	1.88;

1.88
date	2013.04.15.13.04.05;	author brobecke;	state Exp;
branches;
next	1.87;

1.87
date	2013.04.08.20.18.11;	author tromey;	state Exp;
branches;
next	1.86;

1.86
date	2013.01.01.06.32.51;	author brobecke;	state Exp;
branches;
next	1.85;

1.85
date	2012.11.09.19.58.01;	author tromey;	state Exp;
branches;
next	1.84;

1.84
date	2012.09.27.10.40.01;	author siddhesh;	state Exp;
branches;
next	1.83;

1.83
date	2012.09.26.07.52.48;	author siddhesh;	state Exp;
branches;
next	1.82;

1.82
date	2012.09.17.08.52.18;	author siddhesh;	state Exp;
branches;
next	1.81;

1.81
date	2012.05.18.21.02.50;	author sergiodj;	state Exp;
branches;
next	1.80;

1.80
date	2012.05.16.14.35.07;	author macro;	state Exp;
branches;
next	1.79;

1.79
date	2012.05.15.04.08.47;	author jkratoch;	state Exp;
branches;
next	1.78;

1.78
date	2012.03.13.13.30.42;	author palves;	state Exp;
branches;
next	1.77;

1.77
date	2012.01.04.08.17.12;	author brobecke;	state Exp;
branches;
next	1.76;

1.76
date	2011.11.16.18.30.09;	author uweigand;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2011.10.26.17.26.29;	author uweigand;	state Exp;
branches;
next	1.74;

1.74
date	2011.08.05.01.46.13;	author jkratoch;	state Exp;
branches;
next	1.73;

1.73
date	2011.05.06.20.48.48;	author uweigand;	state Exp;
branches;
next	1.72;

1.72
date	2011.03.18.18.52.32;	author palves;	state Exp;
branches
	1.72.2.1;
next	1.71;

1.71
date	2011.03.18.18.42.41;	author palves;	state Exp;
branches;
next	1.70;

1.70
date	2011.03.18.18.38.44;	author palves;	state Exp;
branches;
next	1.69;

1.69
date	2011.02.26.02.07.08;	author msnyder;	state Exp;
branches;
next	1.68;

1.68
date	2011.02.08.13.30.08;	author uweigand;	state Exp;
branches;
next	1.67;

1.67
date	2011.01.11.21.53.24;	author msnyder;	state Exp;
branches;
next	1.66;

1.66
date	2011.01.10.17.14.13;	author msnyder;	state Exp;
branches;
next	1.65;

1.65
date	2011.01.01.15.33.15;	author brobecke;	state Exp;
branches;
next	1.64;

1.64
date	2010.11.12.12.38.39;	author jkratoch;	state Exp;
branches;
next	1.63;

1.63
date	2010.11.11.14.11.52;	author pmuldoon;	state Exp;
branches;
next	1.62;

1.62
date	2010.07.02.08.04.03;	author jkratoch;	state Exp;
branches;
next	1.61;

1.61
date	2010.06.23.12.46.35;	author uweigand;	state Exp;
branches;
next	1.60;

1.60
date	2010.06.19.17.59.06;	author uweigand;	state Exp;
branches;
next	1.59;

1.59
date	2010.06.19.17.36.50;	author uweigand;	state Exp;
branches;
next	1.58;

1.58
date	2010.03.17.13.38.56;	author jkratoch;	state Exp;
branches;
next	1.57;

1.57
date	2010.03.09.18.09.07;	author kseitz;	state Exp;
branches;
next	1.56;

1.56
date	2010.03.02.20.21.08;	author uweigand;	state Exp;
branches;
next	1.55;

1.55
date	2010.01.01.07.31.42;	author brobecke;	state Exp;
branches;
next	1.54;

1.54
date	2009.10.19.09.51.42;	author palves;	state Exp;
branches;
next	1.53;

1.53
date	2009.07.31.15.35.37;	author uweigand;	state Exp;
branches;
next	1.52;

1.52
date	2009.07.31.15.33.50;	author uweigand;	state Exp;
branches;
next	1.51;

1.51
date	2009.07.31.15.31.08;	author uweigand;	state Exp;
branches;
next	1.50;

1.50
date	2009.07.31.15.28.27;	author uweigand;	state Exp;
branches;
next	1.49;

1.49
date	2009.07.02.17.25.58;	author uweigand;	state Exp;
branches;
next	1.48;

1.48
date	2009.07.02.17.12.27;	author uweigand;	state Exp;
branches;
next	1.47;

1.47
date	2009.07.02.12.55.30;	author uweigand;	state Exp;
branches;
next	1.46;

1.46
date	2009.07.02.12.46.19;	author uweigand;	state Exp;
branches;
next	1.45;

1.45
date	2009.06.22.17.14.43;	author uweigand;	state Exp;
branches;
next	1.44;

1.44
date	2009.06.17.18.50.31;	author uweigand;	state Exp;
branches;
next	1.43;

1.43
date	2009.02.22.01.02.20;	author palves;	state Exp;
branches;
next	1.42;

1.42
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.40;

1.40
date	2008.09.05.15.19.59;	author uweigand;	state Exp;
branches;
next	1.39;

1.39
date	2008.09.05.11.37.17;	author uweigand;	state Exp;
branches;
next	1.38;

1.38
date	2008.09.03.21.27.05;	author uweigand;	state Exp;
branches;
next	1.37;

1.37
date	2008.09.03.19.19.42;	author uweigand;	state Exp;
branches;
next	1.36;

1.36
date	2008.08.24.16.39.57;	author tromey;	state Exp;
branches;
next	1.35;

1.35
date	2008.08.22.15.32.43;	author uweigand;	state Exp;
branches;
next	1.34;

1.34
date	2008.08.13.13.38.01;	author uweigand;	state Exp;
branches;
next	1.33;

1.33
date	2008.08.07.21.25.28;	author uweigand;	state Exp;
branches;
next	1.32;

1.32
date	2008.08.06.18.28.26;	author uweigand;	state Exp;
branches;
next	1.31;

1.31
date	2008.07.12.22.42.52;	author uweigand;	state Exp;
branches;
next	1.30;

1.30
date	2008.05.01.00.08.28;	author uweigand;	state Exp;
branches;
next	1.29;

1.29
date	2008.04.22.11.03.42;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2008.03.10.12.36.08;	author uweigand;	state Exp;
branches;
next	1.27;

1.27
date	2008.01.11.13.20.02;	author deuling;	state Exp;
branches;
next	1.26;

1.26
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.25;

1.25
date	2007.11.07.06.58.31;	author deuling;	state Exp;
branches;
next	1.24;

1.24
date	2007.11.07.06.33.01;	author deuling;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.02.14.27.15;	author uweigand;	state Exp;
branches;
next	1.22;

1.22
date	2007.10.02.17.34.32;	author uweigand;	state Exp;
branches;
next	1.21;

1.21
date	2007.08.27.14.31.36;	author uweigand;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2007.08.23.18.08.38;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.16.17.25.59;	author uweigand;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.15.22.44.56;	author uweigand;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.15.22.37.35;	author uweigand;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.12.14.35.25;	author uweigand;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.01.19.31.08;	author uweigand;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.11.20.09.29;	author uweigand;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.11.19.58.38;	author uweigand;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.14.18.10.54;	author uweigand;	state Exp;
branches;
next	1.11;

1.11
date	2007.04.12.14.52.20;	author uweigand;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.09.03.51.04;	author uweigand;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.08.21.32.22;	author uweigand;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.08.21.18.01;	author uweigand;	state Exp;
branches;
next	1.7;

1.7
date	2007.02.27.20.17.19;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.29.17.31.06;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.11.20.48.50;	author uweigand;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.09.17.58.58;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.08.20.03.49;	author uweigand;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.13.14.17.53;	author uweigand;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.22.13.49.53;	author uweigand;	state Exp;
branches
	1.1.2.1;
next	;

1.76.2.1
date	2012.01.06.04.43.30;	author brobecke;	state Exp;
branches;
next	1.76.2.2;

1.76.2.2
date	2012.03.13.22.18.19;	author palves;	state Exp;
branches;
next	;

1.72.2.1
date	2011.05.06.20.51.00;	author uweigand;	state Exp;
branches;
next	;

1.21.2.1
date	2007.10.02.17.35.17;	author uweigand;	state Exp;
branches;
next	;

1.1.2.1
date	2006.11.24.19.54.16;	author uweigand;	state Exp;
branches;
next	;


desc
@@


1.90
log
@-Wpointer-sign: gdb_byte -> char.

This is sort of the opposite of the previous patch.  Places that
manipulate strings or interfaces that return strings are changed to
use char* instead of gdb_byte*.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* avr-tdep.c (avr_io_reg_read_command): New local 'bufstr'.  Use
	it to get a string view of the byte buffer.
	* i386-cygwin-tdep.c (core_process_module_section): Change local 'buf'
	type to gdb_byte *.  Adjust.
	* linux-tdep.c (linux_info_proc, linux_find_memory_regions_full):
	Change local to char *.
	* solib-darwin.c (find_program_interpreter): Change return type to
	char *.  Adjust.
	(darwin_solib_get_all_image_info_addr_at_init): Adjust.
	* solib-dsbt.c (enable_break2): Change local 'buf' to char *.
	* solib-frv.c (enable_break2): Change local 'buf' to char *.
	* solib-spu.c (spu_current_sos): Add gdb_byte * cast.
	* solib-svr4.c (find_program_interpreter): Change return type to
	char *.  Adjust.
	(enable_break): Change local 'interp_name' to char *.
	* spu-multiarch.c (spu_xfer_partial): Add cast to 'char *'.
	* spu-tdep.c (spu_pseudo_register_read_spu): Add cast to 'char *'.
	(spu_pseudo_register_write_spu): Use char for string buffer.
	Adjust.
	(info_spu_event_command, info_spu_signal_command): Add casts to
	'char *'.
@
text
@/* SPU target-dependent code for GDB, the GNU debugger.
   Copyright (C) 2006-2013 Free Software Foundation, Inc.

   Contributed by Ulrich Weigand <uweigand@@de.ibm.com>.
   Based on a port by Sid Manning <sid@@us.ibm.com>.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "gdbtypes.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "gdb_string.h"
#include "gdb_assert.h"
#include "frame.h"
#include "frame-unwind.h"
#include "frame-base.h"
#include "trad-frame.h"
#include "symtab.h"
#include "symfile.h"
#include "value.h"
#include "inferior.h"
#include "dis-asm.h"
#include "objfiles.h"
#include "language.h"
#include "regcache.h"
#include "reggroups.h"
#include "floatformat.h"
#include "block.h"
#include "observer.h"
#include "infcall.h"
#include "dwarf2.h"
#include "exceptions.h"
#include "spu-tdep.h"


/* The list of available "set spu " and "show spu " commands.  */
static struct cmd_list_element *setspucmdlist = NULL;
static struct cmd_list_element *showspucmdlist = NULL;

/* Whether to stop for new SPE contexts.  */
static int spu_stop_on_load_p = 0;
/* Whether to automatically flush the SW-managed cache.  */
static int spu_auto_flush_cache_p = 1;


/* The tdep structure.  */
struct gdbarch_tdep
{
  /* The spufs ID identifying our address space.  */
  int id;

  /* SPU-specific vector type.  */
  struct type *spu_builtin_type_vec128;
};


/* SPU-specific vector type.  */
static struct type *
spu_builtin_type_vec128 (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->spu_builtin_type_vec128)
    {
      const struct builtin_type *bt = builtin_type (gdbarch);
      struct type *t;

      t = arch_composite_type (gdbarch,
			       "__spu_builtin_type_vec128", TYPE_CODE_UNION);
      append_composite_type_field (t, "uint128", bt->builtin_int128);
      append_composite_type_field (t, "v2_int64",
				   init_vector_type (bt->builtin_int64, 2));
      append_composite_type_field (t, "v4_int32",
				   init_vector_type (bt->builtin_int32, 4));
      append_composite_type_field (t, "v8_int16",
				   init_vector_type (bt->builtin_int16, 8));
      append_composite_type_field (t, "v16_int8",
				   init_vector_type (bt->builtin_int8, 16));
      append_composite_type_field (t, "v2_double",
				   init_vector_type (bt->builtin_double, 2));
      append_composite_type_field (t, "v4_float",
				   init_vector_type (bt->builtin_float, 4));

      TYPE_VECTOR (t) = 1;
      TYPE_NAME (t) = "spu_builtin_type_vec128";

      tdep->spu_builtin_type_vec128 = t;
    }

  return tdep->spu_builtin_type_vec128;
}


/* The list of available "info spu " commands.  */
static struct cmd_list_element *infospucmdlist = NULL;

/* Registers.  */

static const char *
spu_register_name (struct gdbarch *gdbarch, int reg_nr)
{
  static char *register_names[] = 
    {
      "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
      "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
      "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
      "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",
      "r32", "r33", "r34", "r35", "r36", "r37", "r38", "r39",
      "r40", "r41", "r42", "r43", "r44", "r45", "r46", "r47",
      "r48", "r49", "r50", "r51", "r52", "r53", "r54", "r55",
      "r56", "r57", "r58", "r59", "r60", "r61", "r62", "r63",
      "r64", "r65", "r66", "r67", "r68", "r69", "r70", "r71",
      "r72", "r73", "r74", "r75", "r76", "r77", "r78", "r79",
      "r80", "r81", "r82", "r83", "r84", "r85", "r86", "r87",
      "r88", "r89", "r90", "r91", "r92", "r93", "r94", "r95",
      "r96", "r97", "r98", "r99", "r100", "r101", "r102", "r103",
      "r104", "r105", "r106", "r107", "r108", "r109", "r110", "r111",
      "r112", "r113", "r114", "r115", "r116", "r117", "r118", "r119",
      "r120", "r121", "r122", "r123", "r124", "r125", "r126", "r127",
      "id", "pc", "sp", "fpscr", "srr0", "lslr", "decr", "decr_status"
    };

  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= sizeof register_names / sizeof *register_names)
    return NULL;

  return register_names[reg_nr];
}

static struct type *
spu_register_type (struct gdbarch *gdbarch, int reg_nr)
{
  if (reg_nr < SPU_NUM_GPRS)
    return spu_builtin_type_vec128 (gdbarch);

  switch (reg_nr)
    {
    case SPU_ID_REGNUM:
      return builtin_type (gdbarch)->builtin_uint32;

    case SPU_PC_REGNUM:
      return builtin_type (gdbarch)->builtin_func_ptr;

    case SPU_SP_REGNUM:
      return builtin_type (gdbarch)->builtin_data_ptr;

    case SPU_FPSCR_REGNUM:
      return builtin_type (gdbarch)->builtin_uint128;

    case SPU_SRR0_REGNUM:
      return builtin_type (gdbarch)->builtin_uint32;

    case SPU_LSLR_REGNUM:
      return builtin_type (gdbarch)->builtin_uint32;

    case SPU_DECR_REGNUM:
      return builtin_type (gdbarch)->builtin_uint32;

    case SPU_DECR_STATUS_REGNUM:
      return builtin_type (gdbarch)->builtin_uint32;

    default:
      internal_error (__FILE__, __LINE__, _("invalid regnum"));
    }
}

/* Pseudo registers for preferred slots - stack pointer.  */

static enum register_status
spu_pseudo_register_read_spu (struct regcache *regcache, const char *regname,
			      gdb_byte *buf)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  enum register_status status;
  gdb_byte reg[32];
  char annex[32];
  ULONGEST id;
  ULONGEST ul;

  status = regcache_raw_read_unsigned (regcache, SPU_ID_REGNUM, &id);
  if (status != REG_VALID)
    return status;
  xsnprintf (annex, sizeof annex, "%d/%s", (int) id, regname);
  memset (reg, 0, sizeof reg);
  target_read (&current_target, TARGET_OBJECT_SPU, annex,
	       reg, 0, sizeof reg);

  ul = strtoulst ((char *) reg, NULL, 16);
  store_unsigned_integer (buf, 4, byte_order, ul);
  return REG_VALID;
}

static enum register_status
spu_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
                          int regnum, gdb_byte *buf)
{
  gdb_byte reg[16];
  char annex[32];
  ULONGEST id;
  enum register_status status;

  switch (regnum)
    {
    case SPU_SP_REGNUM:
      status = regcache_raw_read (regcache, SPU_RAW_SP_REGNUM, reg);
      if (status != REG_VALID)
	return status;
      memcpy (buf, reg, 4);
      return status;

    case SPU_FPSCR_REGNUM:
      status = regcache_raw_read_unsigned (regcache, SPU_ID_REGNUM, &id);
      if (status != REG_VALID)
	return status;
      xsnprintf (annex, sizeof annex, "%d/fpcr", (int) id);
      target_read (&current_target, TARGET_OBJECT_SPU, annex, buf, 0, 16);
      return status;

    case SPU_SRR0_REGNUM:
      return spu_pseudo_register_read_spu (regcache, "srr0", buf);

    case SPU_LSLR_REGNUM:
      return spu_pseudo_register_read_spu (regcache, "lslr", buf);

    case SPU_DECR_REGNUM:
      return spu_pseudo_register_read_spu (regcache, "decr", buf);

    case SPU_DECR_STATUS_REGNUM:
      return spu_pseudo_register_read_spu (regcache, "decr_status", buf);

    default:
      internal_error (__FILE__, __LINE__, _("invalid regnum"));
    }
}

static void
spu_pseudo_register_write_spu (struct regcache *regcache, const char *regname,
			       const gdb_byte *buf)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  char reg[32];
  char annex[32];
  ULONGEST id;

  regcache_raw_read_unsigned (regcache, SPU_ID_REGNUM, &id);
  xsnprintf (annex, sizeof annex, "%d/%s", (int) id, regname);
  xsnprintf (reg, sizeof reg, "0x%s",
	     phex_nz (extract_unsigned_integer (buf, 4, byte_order), 4));
  target_write (&current_target, TARGET_OBJECT_SPU, annex,
		(gdb_byte *) reg, 0, strlen (reg));
}

static void
spu_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
                           int regnum, const gdb_byte *buf)
{
  gdb_byte reg[16];
  char annex[32];
  ULONGEST id;

  switch (regnum)
    {
    case SPU_SP_REGNUM:
      regcache_raw_read (regcache, SPU_RAW_SP_REGNUM, reg);
      memcpy (reg, buf, 4);
      regcache_raw_write (regcache, SPU_RAW_SP_REGNUM, reg);
      break;

    case SPU_FPSCR_REGNUM:
      regcache_raw_read_unsigned (regcache, SPU_ID_REGNUM, &id);
      xsnprintf (annex, sizeof annex, "%d/fpcr", (int) id);
      target_write (&current_target, TARGET_OBJECT_SPU, annex, buf, 0, 16);
      break;

    case SPU_SRR0_REGNUM:
      spu_pseudo_register_write_spu (regcache, "srr0", buf);
      break;

    case SPU_LSLR_REGNUM:
      spu_pseudo_register_write_spu (regcache, "lslr", buf);
      break;

    case SPU_DECR_REGNUM:
      spu_pseudo_register_write_spu (regcache, "decr", buf);
      break;

    case SPU_DECR_STATUS_REGNUM:
      spu_pseudo_register_write_spu (regcache, "decr_status", buf);
      break;

    default:
      internal_error (__FILE__, __LINE__, _("invalid regnum"));
    }
}

/* Value conversion -- access scalar values at the preferred slot.  */

static struct value *
spu_value_from_register (struct type *type, int regnum,
			 struct frame_info *frame)
{
  struct value *value = default_value_from_register (type, regnum, frame);
  int len = TYPE_LENGTH (type);

  if (regnum < SPU_NUM_GPRS && len < 16)
    {
      int preferred_slot = len < 4 ? 4 - len : 0;
      set_value_offset (value, preferred_slot);
    }

  return value;
}

/* Register groups.  */

static int
spu_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			 struct reggroup *group)
{
  /* Registers displayed via 'info regs'.  */
  if (group == general_reggroup)
    return 1;

  /* Registers displayed via 'info float'.  */
  if (group == float_reggroup)
    return 0;

  /* Registers that need to be saved/restored in order to
     push or pop frames.  */
  if (group == save_reggroup || group == restore_reggroup)
    return 1;

  return default_register_reggroup_p (gdbarch, regnum, group);
}


/* Address handling.  */

static int
spu_gdbarch_id (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int id = tdep->id;

  /* The objfile architecture of a standalone SPU executable does not
     provide an SPU ID.  Retrieve it from the objfile's relocated
     address range in this special case.  */
  if (id == -1
      && symfile_objfile && symfile_objfile->obfd
      && bfd_get_arch (symfile_objfile->obfd) == bfd_arch_spu
      && symfile_objfile->sections != symfile_objfile->sections_end)
    id = SPUADDR_SPU (obj_section_addr (symfile_objfile->sections));

  return id;
}

static int
spu_address_class_type_flags (int byte_size, int dwarf2_addr_class)
{
  if (dwarf2_addr_class == 1)
    return TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1;
  else
    return 0;
}

static const char *
spu_address_class_type_flags_to_name (struct gdbarch *gdbarch, int type_flags)
{
  if (type_flags & TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1)
    return "__ea";
  else
    return NULL;
}

static int
spu_address_class_name_to_type_flags (struct gdbarch *gdbarch,
				      const char *name, int *type_flags_ptr)
{
  if (strcmp (name, "__ea") == 0)
    {
      *type_flags_ptr = TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1;
      return 1;
    }
  else
   return 0;
}

static void
spu_address_to_pointer (struct gdbarch *gdbarch,
			struct type *type, gdb_byte *buf, CORE_ADDR addr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  store_unsigned_integer (buf, TYPE_LENGTH (type), byte_order,
			  SPUADDR_ADDR (addr));
}

static CORE_ADDR
spu_pointer_to_address (struct gdbarch *gdbarch,
			struct type *type, const gdb_byte *buf)
{
  int id = spu_gdbarch_id (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  ULONGEST addr
    = extract_unsigned_integer (buf, TYPE_LENGTH (type), byte_order);

  /* Do not convert __ea pointers.  */
  if (TYPE_ADDRESS_CLASS_1 (type))
    return addr;

  return addr? SPUADDR (id, addr) : 0;
}

static CORE_ADDR
spu_integer_to_address (struct gdbarch *gdbarch,
			struct type *type, const gdb_byte *buf)
{
  int id = spu_gdbarch_id (gdbarch);
  ULONGEST addr = unpack_long (type, buf);

  return SPUADDR (id, addr);
}


/* Decoding SPU instructions.  */

enum
  {
    op_lqd   = 0x34,
    op_lqx   = 0x3c4,
    op_lqa   = 0x61,
    op_lqr   = 0x67,
    op_stqd  = 0x24,
    op_stqx  = 0x144,
    op_stqa  = 0x41,
    op_stqr  = 0x47,

    op_il    = 0x081,
    op_ila   = 0x21,
    op_a     = 0x0c0,
    op_ai    = 0x1c,

    op_selb  = 0x8,

    op_br    = 0x64,
    op_bra   = 0x60,
    op_brsl  = 0x66,
    op_brasl = 0x62,
    op_brnz  = 0x42,
    op_brz   = 0x40,
    op_brhnz = 0x46,
    op_brhz  = 0x44,
    op_bi    = 0x1a8,
    op_bisl  = 0x1a9,
    op_biz   = 0x128,
    op_binz  = 0x129,
    op_bihz  = 0x12a,
    op_bihnz = 0x12b,
  };

static int
is_rr (unsigned int insn, int op, int *rt, int *ra, int *rb)
{
  if ((insn >> 21) == op)
    {
      *rt = insn & 127;
      *ra = (insn >> 7) & 127;
      *rb = (insn >> 14) & 127;
      return 1;
    }

  return 0;
}

static int
is_rrr (unsigned int insn, int op, int *rt, int *ra, int *rb, int *rc)
{
  if ((insn >> 28) == op)
    {
      *rt = (insn >> 21) & 127;
      *ra = (insn >> 7) & 127;
      *rb = (insn >> 14) & 127;
      *rc = insn & 127;
      return 1;
    }

  return 0;
}

static int
is_ri7 (unsigned int insn, int op, int *rt, int *ra, int *i7)
{
  if ((insn >> 21) == op)
    {
      *rt = insn & 127;
      *ra = (insn >> 7) & 127;
      *i7 = (((insn >> 14) & 127) ^ 0x40) - 0x40;
      return 1;
    }

  return 0;
}

static int
is_ri10 (unsigned int insn, int op, int *rt, int *ra, int *i10)
{
  if ((insn >> 24) == op)
    {
      *rt = insn & 127;
      *ra = (insn >> 7) & 127;
      *i10 = (((insn >> 14) & 0x3ff) ^ 0x200) - 0x200;
      return 1;
    }

  return 0;
}

static int
is_ri16 (unsigned int insn, int op, int *rt, int *i16)
{
  if ((insn >> 23) == op)
    {
      *rt = insn & 127;
      *i16 = (((insn >> 7) & 0xffff) ^ 0x8000) - 0x8000;
      return 1;
    }

  return 0;
}

static int
is_ri18 (unsigned int insn, int op, int *rt, int *i18)
{
  if ((insn >> 25) == op)
    {
      *rt = insn & 127;
      *i18 = (((insn >> 7) & 0x3ffff) ^ 0x20000) - 0x20000;
      return 1;
    }

  return 0;
}

static int
is_branch (unsigned int insn, int *offset, int *reg)
{
  int rt, i7, i16;

  if (is_ri16 (insn, op_br, &rt, &i16)
      || is_ri16 (insn, op_brsl, &rt, &i16)
      || is_ri16 (insn, op_brnz, &rt, &i16)
      || is_ri16 (insn, op_brz, &rt, &i16)
      || is_ri16 (insn, op_brhnz, &rt, &i16)
      || is_ri16 (insn, op_brhz, &rt, &i16))
    {
      *reg = SPU_PC_REGNUM;
      *offset = i16 << 2;
      return 1;
    }

  if (is_ri16 (insn, op_bra, &rt, &i16)
      || is_ri16 (insn, op_brasl, &rt, &i16))
    {
      *reg = -1;
      *offset = i16 << 2;
      return 1;
    }

  if (is_ri7 (insn, op_bi, &rt, reg, &i7)
      || is_ri7 (insn, op_bisl, &rt, reg, &i7)
      || is_ri7 (insn, op_biz, &rt, reg, &i7)
      || is_ri7 (insn, op_binz, &rt, reg, &i7)
      || is_ri7 (insn, op_bihz, &rt, reg, &i7)
      || is_ri7 (insn, op_bihnz, &rt, reg, &i7))
    {
      *offset = 0;
      return 1;
    }

  return 0;
}


/* Prolog parsing.  */

struct spu_prologue_data
  {
    /* Stack frame size.  -1 if analysis was unsuccessful.  */
    int size;

    /* How to find the CFA.  The CFA is equal to SP at function entry.  */
    int cfa_reg;
    int cfa_offset;

    /* Offset relative to CFA where a register is saved.  -1 if invalid.  */
    int reg_offset[SPU_NUM_GPRS];
  };

static CORE_ADDR
spu_analyze_prologue (struct gdbarch *gdbarch,
		      CORE_ADDR start_pc, CORE_ADDR end_pc,
                      struct spu_prologue_data *data)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int found_sp = 0;
  int found_fp = 0;
  int found_lr = 0;
  int found_bc = 0;
  int reg_immed[SPU_NUM_GPRS];
  gdb_byte buf[16];
  CORE_ADDR prolog_pc = start_pc;
  CORE_ADDR pc;
  int i;


  /* Initialize DATA to default values.  */
  data->size = -1;

  data->cfa_reg = SPU_RAW_SP_REGNUM;
  data->cfa_offset = 0;

  for (i = 0; i < SPU_NUM_GPRS; i++)
    data->reg_offset[i] = -1;

  /* Set up REG_IMMED array.  This is non-zero for a register if we know its
     preferred slot currently holds this immediate value.  */
  for (i = 0; i < SPU_NUM_GPRS; i++)
      reg_immed[i] = 0;

  /* Scan instructions until the first branch.

     The following instructions are important prolog components:

	- The first instruction to set up the stack pointer.
	- The first instruction to set up the frame pointer.
	- The first instruction to save the link register.
	- The first instruction to save the backchain.

     We return the instruction after the latest of these four,
     or the incoming PC if none is found.  The first instruction
     to set up the stack pointer also defines the frame size.

     Note that instructions saving incoming arguments to their stack
     slots are not counted as important, because they are hard to
     identify with certainty.  This should not matter much, because
     arguments are relevant only in code compiled with debug data,
     and in such code the GDB core will advance until the first source
     line anyway, using SAL data.

     For purposes of stack unwinding, we analyze the following types
     of instructions in addition:

      - Any instruction adding to the current frame pointer.
      - Any instruction loading an immediate constant into a register.
      - Any instruction storing a register onto the stack.

     These are used to compute the CFA and REG_OFFSET output.  */

  for (pc = start_pc; pc < end_pc; pc += 4)
    {
      unsigned int insn;
      int rt, ra, rb, rc, immed;

      if (target_read_memory (pc, buf, 4))
	break;
      insn = extract_unsigned_integer (buf, 4, byte_order);

      /* AI is the typical instruction to set up a stack frame.
         It is also used to initialize the frame pointer.  */
      if (is_ri10 (insn, op_ai, &rt, &ra, &immed))
	{
	  if (rt == data->cfa_reg && ra == data->cfa_reg)
	    data->cfa_offset -= immed;

	  if (rt == SPU_RAW_SP_REGNUM && ra == SPU_RAW_SP_REGNUM
	      && !found_sp)
	    {
	      found_sp = 1;
	      prolog_pc = pc + 4;

	      data->size = -immed;
	    }
	  else if (rt == SPU_FP_REGNUM && ra == SPU_RAW_SP_REGNUM
		   && !found_fp)
	    {
	      found_fp = 1;
	      prolog_pc = pc + 4;

	      data->cfa_reg = SPU_FP_REGNUM;
	      data->cfa_offset -= immed;
	    }
	}

      /* A is used to set up stack frames of size >= 512 bytes.
         If we have tracked the contents of the addend register,
         we can handle this as well.  */
      else if (is_rr (insn, op_a, &rt, &ra, &rb))
	{
	  if (rt == data->cfa_reg && ra == data->cfa_reg)
	    {
	      if (reg_immed[rb] != 0)
		data->cfa_offset -= reg_immed[rb];
	      else
		data->cfa_reg = -1;  /* We don't know the CFA any more.  */
	    }

	  if (rt == SPU_RAW_SP_REGNUM && ra == SPU_RAW_SP_REGNUM
	      && !found_sp)
	    {
	      found_sp = 1;
	      prolog_pc = pc + 4;

	      if (reg_immed[rb] != 0)
		data->size = -reg_immed[rb];
	    }
	}

      /* We need to track IL and ILA used to load immediate constants
         in case they are later used as input to an A instruction.  */
      else if (is_ri16 (insn, op_il, &rt, &immed))
	{
	  reg_immed[rt] = immed;

	  if (rt == SPU_RAW_SP_REGNUM && !found_sp)
	    found_sp = 1;
	}

      else if (is_ri18 (insn, op_ila, &rt, &immed))
	{
	  reg_immed[rt] = immed & 0x3ffff;

	  if (rt == SPU_RAW_SP_REGNUM && !found_sp)
	    found_sp = 1;
	}

      /* STQD is used to save registers to the stack.  */
      else if (is_ri10 (insn, op_stqd, &rt, &ra, &immed))
	{
	  if (ra == data->cfa_reg)
	    data->reg_offset[rt] = data->cfa_offset - (immed << 4);

	  if (ra == data->cfa_reg && rt == SPU_LR_REGNUM
              && !found_lr)
	    {
	      found_lr = 1;
	      prolog_pc = pc + 4;
	    }

	  if (ra == SPU_RAW_SP_REGNUM
	      && (found_sp? immed == 0 : rt == SPU_RAW_SP_REGNUM)
	      && !found_bc)
	    {
	      found_bc = 1;
	      prolog_pc = pc + 4;
	    }
	}

      /* _start uses SELB to set up the stack pointer.  */
      else if (is_rrr (insn, op_selb, &rt, &ra, &rb, &rc))
	{
	  if (rt == SPU_RAW_SP_REGNUM && !found_sp)
	    found_sp = 1;
	}

      /* We terminate if we find a branch.  */
      else if (is_branch (insn, &immed, &ra))
	break;
    }


  /* If we successfully parsed until here, and didn't find any instruction
     modifying SP, we assume we have a frameless function.  */
  if (!found_sp)
    data->size = 0;

  /* Return cooked instead of raw SP.  */
  if (data->cfa_reg == SPU_RAW_SP_REGNUM)
    data->cfa_reg = SPU_SP_REGNUM;

  return prolog_pc;
}

/* Return the first instruction after the prologue starting at PC.  */
static CORE_ADDR
spu_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  struct spu_prologue_data data;
  return spu_analyze_prologue (gdbarch, pc, (CORE_ADDR)-1, &data);
}

/* Return the frame pointer in use at address PC.  */
static void
spu_virtual_frame_pointer (struct gdbarch *gdbarch, CORE_ADDR pc,
			   int *reg, LONGEST *offset)
{
  struct spu_prologue_data data;
  spu_analyze_prologue (gdbarch, pc, (CORE_ADDR)-1, &data);

  if (data.size != -1 && data.cfa_reg != -1)
    {
      /* The 'frame pointer' address is CFA minus frame size.  */
      *reg = data.cfa_reg;
      *offset = data.cfa_offset - data.size;
    }
  else
    {
      /* ??? We don't really know ...  */
      *reg = SPU_SP_REGNUM;
      *offset = 0;
    }
}

/* Return true if we are in the function's epilogue, i.e. after the
   instruction that destroyed the function's stack frame.

   1) scan forward from the point of execution:
       a) If you find an instruction that modifies the stack pointer
          or transfers control (except a return), execution is not in
          an epilogue, return.
       b) Stop scanning if you find a return instruction or reach the
          end of the function or reach the hard limit for the size of
          an epilogue.
   2) scan backward from the point of execution:
        a) If you find an instruction that modifies the stack pointer,
            execution *is* in an epilogue, return.
        b) Stop scanning if you reach an instruction that transfers
           control or the beginning of the function or reach the hard
           limit for the size of an epilogue.  */

static int
spu_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR scan_pc, func_start, func_end, epilogue_start, epilogue_end;
  bfd_byte buf[4];
  unsigned int insn;
  int rt, ra, rb, immed;

  /* Find the search limits based on function boundaries and hard limit.
     We assume the epilogue can be up to 64 instructions long.  */

  const int spu_max_epilogue_size = 64 * 4;

  if (!find_pc_partial_function (pc, NULL, &func_start, &func_end))
    return 0;

  if (pc - func_start < spu_max_epilogue_size)
    epilogue_start = func_start;
  else
    epilogue_start = pc - spu_max_epilogue_size;

  if (func_end - pc < spu_max_epilogue_size)
    epilogue_end = func_end;
  else
    epilogue_end = pc + spu_max_epilogue_size;

  /* Scan forward until next 'bi $0'.  */

  for (scan_pc = pc; scan_pc < epilogue_end; scan_pc += 4)
    {
      if (target_read_memory (scan_pc, buf, 4))
	return 0;
      insn = extract_unsigned_integer (buf, 4, byte_order);

      if (is_branch (insn, &immed, &ra))
	{
	  if (immed == 0 && ra == SPU_LR_REGNUM)
	    break;

	  return 0;
	}

      if (is_ri10 (insn, op_ai, &rt, &ra, &immed)
	  || is_rr (insn, op_a, &rt, &ra, &rb)
	  || is_ri10 (insn, op_lqd, &rt, &ra, &immed))
	{
	  if (rt == SPU_RAW_SP_REGNUM)
	    return 0;
	}
    }

  if (scan_pc >= epilogue_end)
    return 0;

  /* Scan backward until adjustment to stack pointer (R1).  */

  for (scan_pc = pc - 4; scan_pc >= epilogue_start; scan_pc -= 4)
    {
      if (target_read_memory (scan_pc, buf, 4))
	return 0;
      insn = extract_unsigned_integer (buf, 4, byte_order);

      if (is_branch (insn, &immed, &ra))
	return 0;

      if (is_ri10 (insn, op_ai, &rt, &ra, &immed)
	  || is_rr (insn, op_a, &rt, &ra, &rb)
	  || is_ri10 (insn, op_lqd, &rt, &ra, &immed))
	{
	  if (rt == SPU_RAW_SP_REGNUM)
	    return 1;
	}
    }

  return 0;
}


/* Normal stack frames.  */

struct spu_unwind_cache
{
  CORE_ADDR func;
  CORE_ADDR frame_base;
  CORE_ADDR local_base;

  struct trad_frame_saved_reg *saved_regs;
};

static struct spu_unwind_cache *
spu_frame_unwind_cache (struct frame_info *this_frame,
			void **this_prologue_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct spu_unwind_cache *info;
  struct spu_prologue_data data;
  CORE_ADDR id = tdep->id;
  gdb_byte buf[16];

  if (*this_prologue_cache)
    return *this_prologue_cache;

  info = FRAME_OBSTACK_ZALLOC (struct spu_unwind_cache);
  *this_prologue_cache = info;
  info->saved_regs = trad_frame_alloc_saved_regs (this_frame);
  info->frame_base = 0;
  info->local_base = 0;

  /* Find the start of the current function, and analyze its prologue.  */
  info->func = get_frame_func (this_frame);
  if (info->func == 0)
    {
      /* Fall back to using the current PC as frame ID.  */
      info->func = get_frame_pc (this_frame);
      data.size = -1;
    }
  else
    spu_analyze_prologue (gdbarch, info->func, get_frame_pc (this_frame),
			  &data);

  /* If successful, use prologue analysis data.  */
  if (data.size != -1 && data.cfa_reg != -1)
    {
      CORE_ADDR cfa;
      int i;

      /* Determine CFA via unwound CFA_REG plus CFA_OFFSET.  */
      get_frame_register (this_frame, data.cfa_reg, buf);
      cfa = extract_unsigned_integer (buf, 4, byte_order) + data.cfa_offset;
      cfa = SPUADDR (id, cfa);

      /* Call-saved register slots.  */
      for (i = 0; i < SPU_NUM_GPRS; i++)
	if (i == SPU_LR_REGNUM
	    || (i >= SPU_SAVED1_REGNUM && i <= SPU_SAVEDN_REGNUM))
	  if (data.reg_offset[i] != -1)
	    info->saved_regs[i].addr = cfa - data.reg_offset[i];

      /* Frame bases.  */
      info->frame_base = cfa;
      info->local_base = cfa - data.size;
    }

  /* Otherwise, fall back to reading the backchain link.  */
  else
    {
      CORE_ADDR reg;
      LONGEST backchain;
      ULONGEST lslr;
      int status;

      /* Get local store limit.  */
      lslr = get_frame_register_unsigned (this_frame, SPU_LSLR_REGNUM);
      if (!lslr)
	lslr = (ULONGEST) -1;

      /* Get the backchain.  */
      reg = get_frame_register_unsigned (this_frame, SPU_SP_REGNUM);
      status = safe_read_memory_integer (SPUADDR (id, reg), 4, byte_order,
					 &backchain);

      /* A zero backchain terminates the frame chain.  Also, sanity
         check against the local store size limit.  */
      if (status && backchain > 0 && backchain <= lslr)
	{
	  /* Assume the link register is saved into its slot.  */
	  if (backchain + 16 <= lslr)
	    info->saved_regs[SPU_LR_REGNUM].addr = SPUADDR (id,
							    backchain + 16);

          /* Frame bases.  */
	  info->frame_base = SPUADDR (id, backchain);
	  info->local_base = SPUADDR (id, reg);
	}
    }

  /* If we didn't find a frame, we cannot determine SP / return address.  */
  if (info->frame_base == 0)
    return info;

  /* The previous SP is equal to the CFA.  */
  trad_frame_set_value (info->saved_regs, SPU_SP_REGNUM,
			SPUADDR_ADDR (info->frame_base));

  /* Read full contents of the unwound link register in order to
     be able to determine the return address.  */
  if (trad_frame_addr_p (info->saved_regs, SPU_LR_REGNUM))
    target_read_memory (info->saved_regs[SPU_LR_REGNUM].addr, buf, 16);
  else
    get_frame_register (this_frame, SPU_LR_REGNUM, buf);

  /* Normally, the return address is contained in the slot 0 of the
     link register, and slots 1-3 are zero.  For an overlay return,
     slot 0 contains the address of the overlay manager return stub,
     slot 1 contains the partition number of the overlay section to
     be returned to, and slot 2 contains the return address within
     that section.  Return the latter address in that case.  */
  if (extract_unsigned_integer (buf + 8, 4, byte_order) != 0)
    trad_frame_set_value (info->saved_regs, SPU_PC_REGNUM,
			  extract_unsigned_integer (buf + 8, 4, byte_order));
  else
    trad_frame_set_value (info->saved_regs, SPU_PC_REGNUM,
			  extract_unsigned_integer (buf, 4, byte_order));
 
  return info;
}

static void
spu_frame_this_id (struct frame_info *this_frame,
		   void **this_prologue_cache, struct frame_id *this_id)
{
  struct spu_unwind_cache *info =
    spu_frame_unwind_cache (this_frame, this_prologue_cache);

  if (info->frame_base == 0)
    return;

  *this_id = frame_id_build (info->frame_base, info->func);
}

static struct value *
spu_frame_prev_register (struct frame_info *this_frame,
			 void **this_prologue_cache, int regnum)
{
  struct spu_unwind_cache *info
    = spu_frame_unwind_cache (this_frame, this_prologue_cache);

  /* Special-case the stack pointer.  */
  if (regnum == SPU_RAW_SP_REGNUM)
    regnum = SPU_SP_REGNUM;

  return trad_frame_get_prev_register (this_frame, info->saved_regs, regnum);
}

static const struct frame_unwind spu_frame_unwind = {
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  spu_frame_this_id,
  spu_frame_prev_register,
  NULL,
  default_frame_sniffer
};

static CORE_ADDR
spu_frame_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct spu_unwind_cache *info
    = spu_frame_unwind_cache (this_frame, this_cache);
  return info->local_base;
}

static const struct frame_base spu_frame_base = {
  &spu_frame_unwind,
  spu_frame_base_address,
  spu_frame_base_address,
  spu_frame_base_address
};

static CORE_ADDR
spu_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  CORE_ADDR pc = frame_unwind_register_unsigned (next_frame, SPU_PC_REGNUM);
  /* Mask off interrupt enable bit.  */
  return SPUADDR (tdep->id, pc & -4);
}

static CORE_ADDR
spu_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  CORE_ADDR sp = frame_unwind_register_unsigned (next_frame, SPU_SP_REGNUM);
  return SPUADDR (tdep->id, sp);
}

static CORE_ADDR
spu_read_pc (struct regcache *regcache)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  ULONGEST pc;
  regcache_cooked_read_unsigned (regcache, SPU_PC_REGNUM, &pc);
  /* Mask off interrupt enable bit.  */
  return SPUADDR (tdep->id, pc & -4);
}

static void
spu_write_pc (struct regcache *regcache, CORE_ADDR pc)
{
  /* Keep interrupt enabled state unchanged.  */
  ULONGEST old_pc;

  regcache_cooked_read_unsigned (regcache, SPU_PC_REGNUM, &old_pc);
  regcache_cooked_write_unsigned (regcache, SPU_PC_REGNUM,
				  (SPUADDR_ADDR (pc) & -4) | (old_pc & 3));
}


/* Cell/B.E. cross-architecture unwinder support.  */

struct spu2ppu_cache
{
  struct frame_id frame_id;
  struct regcache *regcache;
};

static struct gdbarch *
spu2ppu_prev_arch (struct frame_info *this_frame, void **this_cache)
{
  struct spu2ppu_cache *cache = *this_cache;
  return get_regcache_arch (cache->regcache);
}

static void
spu2ppu_this_id (struct frame_info *this_frame,
		 void **this_cache, struct frame_id *this_id)
{
  struct spu2ppu_cache *cache = *this_cache;
  *this_id = cache->frame_id;
}

static struct value *
spu2ppu_prev_register (struct frame_info *this_frame,
		       void **this_cache, int regnum)
{
  struct spu2ppu_cache *cache = *this_cache;
  struct gdbarch *gdbarch = get_regcache_arch (cache->regcache);
  gdb_byte *buf;

  buf = alloca (register_size (gdbarch, regnum));
  regcache_cooked_read (cache->regcache, regnum, buf);
  return frame_unwind_got_bytes (this_frame, regnum, buf);
}

static int
spu2ppu_sniffer (const struct frame_unwind *self,
		 struct frame_info *this_frame, void **this_prologue_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR base, func, backchain;
  gdb_byte buf[4];

  if (gdbarch_bfd_arch_info (target_gdbarch ())->arch == bfd_arch_spu)
    return 0;

  base = get_frame_sp (this_frame);
  func = get_frame_pc (this_frame);
  if (target_read_memory (base, buf, 4))
    return 0;
  backchain = extract_unsigned_integer (buf, 4, byte_order);

  if (!backchain)
    {
      struct frame_info *fi;

      struct spu2ppu_cache *cache
	= FRAME_OBSTACK_CALLOC (1, struct spu2ppu_cache);

      cache->frame_id = frame_id_build (base + 16, func);

      for (fi = get_next_frame (this_frame); fi; fi = get_next_frame (fi))
	if (gdbarch_bfd_arch_info (get_frame_arch (fi))->arch != bfd_arch_spu)
	  break;

      if (fi)
	{
	  cache->regcache = frame_save_as_regcache (fi);
	  *this_prologue_cache = cache;
	  return 1;
	}
      else
	{
	  struct regcache *regcache;
	  regcache = get_thread_arch_regcache (inferior_ptid, target_gdbarch ());
	  cache->regcache = regcache_dup (regcache);
	  *this_prologue_cache = cache;
	  return 1;
	}
    }

  return 0;
}

static void
spu2ppu_dealloc_cache (struct frame_info *self, void *this_cache)
{
  struct spu2ppu_cache *cache = this_cache;
  regcache_xfree (cache->regcache);
}

static const struct frame_unwind spu2ppu_unwind = {
  ARCH_FRAME,
  default_frame_unwind_stop_reason,
  spu2ppu_this_id,
  spu2ppu_prev_register,
  NULL,
  spu2ppu_sniffer,
  spu2ppu_dealloc_cache,
  spu2ppu_prev_arch,
};


/* Function calling convention.  */

static CORE_ADDR
spu_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  return sp & ~15;
}

static CORE_ADDR
spu_push_dummy_code (struct gdbarch *gdbarch, CORE_ADDR sp, CORE_ADDR funaddr,
		     struct value **args, int nargs, struct type *value_type,
		     CORE_ADDR *real_pc, CORE_ADDR *bp_addr,
		     struct regcache *regcache)
{
  /* Allocate space sufficient for a breakpoint, keeping the stack aligned.  */
  sp = (sp - 4) & ~15;
  /* Store the address of that breakpoint */
  *bp_addr = sp;
  /* The call starts at the callee's entry point.  */
  *real_pc = funaddr;

  return sp;
}

static int
spu_scalar_value_p (struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_RANGE:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_PTR:
    case TYPE_CODE_REF:
      return TYPE_LENGTH (type) <= 16;

    default:
      return 0;
    }
}

static void
spu_value_to_regcache (struct regcache *regcache, int regnum,
		       struct type *type, const gdb_byte *in)
{
  int len = TYPE_LENGTH (type);

  if (spu_scalar_value_p (type))
    {
      int preferred_slot = len < 4 ? 4 - len : 0;
      regcache_cooked_write_part (regcache, regnum, preferred_slot, len, in);
    }
  else
    {
      while (len >= 16)
	{
	  regcache_cooked_write (regcache, regnum++, in);
	  in += 16;
	  len -= 16;
	}

      if (len > 0)
	regcache_cooked_write_part (regcache, regnum, 0, len, in);
    }
}

static void
spu_regcache_to_value (struct regcache *regcache, int regnum,
		       struct type *type, gdb_byte *out)
{
  int len = TYPE_LENGTH (type);

  if (spu_scalar_value_p (type))
    {
      int preferred_slot = len < 4 ? 4 - len : 0;
      regcache_cooked_read_part (regcache, regnum, preferred_slot, len, out);
    }
  else
    {
      while (len >= 16)
	{
	  regcache_cooked_read (regcache, regnum++, out);
	  out += 16;
	  len -= 16;
	}

      if (len > 0)
	regcache_cooked_read_part (regcache, regnum, 0, len, out);
    }
}

static CORE_ADDR
spu_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
		     struct regcache *regcache, CORE_ADDR bp_addr,
		     int nargs, struct value **args, CORE_ADDR sp,
		     int struct_return, CORE_ADDR struct_addr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR sp_delta;
  int i;
  int regnum = SPU_ARG1_REGNUM;
  int stack_arg = -1;
  gdb_byte buf[16];

  /* Set the return address.  */
  memset (buf, 0, sizeof buf);
  store_unsigned_integer (buf, 4, byte_order, SPUADDR_ADDR (bp_addr));
  regcache_cooked_write (regcache, SPU_LR_REGNUM, buf);

  /* If STRUCT_RETURN is true, then the struct return address (in
     STRUCT_ADDR) will consume the first argument-passing register.
     Both adjust the register count and store that value.  */
  if (struct_return)
    {
      memset (buf, 0, sizeof buf);
      store_unsigned_integer (buf, 4, byte_order, SPUADDR_ADDR (struct_addr));
      regcache_cooked_write (regcache, regnum++, buf);
    }

  /* Fill in argument registers.  */
  for (i = 0; i < nargs; i++)
    {
      struct value *arg = args[i];
      struct type *type = check_typedef (value_type (arg));
      const gdb_byte *contents = value_contents (arg);
      int n_regs = align_up (TYPE_LENGTH (type), 16) / 16;

      /* If the argument doesn't wholly fit into registers, it and
	 all subsequent arguments go to the stack.  */
      if (regnum + n_regs - 1 > SPU_ARGN_REGNUM)
	{
	  stack_arg = i;
	  break;
	}

      spu_value_to_regcache (regcache, regnum, type, contents);
      regnum += n_regs;
    }

  /* Overflow arguments go to the stack.  */
  if (stack_arg != -1)
    {
      CORE_ADDR ap;

      /* Allocate all required stack size.  */
      for (i = stack_arg; i < nargs; i++)
	{
	  struct type *type = check_typedef (value_type (args[i]));
	  sp -= align_up (TYPE_LENGTH (type), 16);
	}

      /* Fill in stack arguments.  */
      ap = sp;
      for (i = stack_arg; i < nargs; i++)
	{
	  struct value *arg = args[i];
	  struct type *type = check_typedef (value_type (arg));
	  int len = TYPE_LENGTH (type);
	  int preferred_slot;
	  
	  if (spu_scalar_value_p (type))
	    preferred_slot = len < 4 ? 4 - len : 0;
	  else
	    preferred_slot = 0;

	  target_write_memory (ap + preferred_slot, value_contents (arg), len);
	  ap += align_up (TYPE_LENGTH (type), 16);
	}
    }

  /* Allocate stack frame header.  */
  sp -= 32;

  /* Store stack back chain.  */
  regcache_cooked_read (regcache, SPU_RAW_SP_REGNUM, buf);
  target_write_memory (sp, buf, 16);

  /* Finally, update all slots of the SP register.  */
  sp_delta = sp - extract_unsigned_integer (buf, 4, byte_order);
  for (i = 0; i < 4; i++)
    {
      CORE_ADDR sp_slot = extract_unsigned_integer (buf + 4*i, 4, byte_order);
      store_unsigned_integer (buf + 4*i, 4, byte_order, sp_slot + sp_delta);
    }
  regcache_cooked_write (regcache, SPU_RAW_SP_REGNUM, buf);

  return sp;
}

static struct frame_id
spu_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  CORE_ADDR pc = get_frame_register_unsigned (this_frame, SPU_PC_REGNUM);
  CORE_ADDR sp = get_frame_register_unsigned (this_frame, SPU_SP_REGNUM);
  return frame_id_build (SPUADDR (tdep->id, sp), SPUADDR (tdep->id, pc & -4));
}

/* Function return value access.  */

static enum return_value_convention
spu_return_value (struct gdbarch *gdbarch, struct value *function,
		  struct type *type, struct regcache *regcache,
		  gdb_byte *out, const gdb_byte *in)
{
  struct type *func_type = function ? value_type (function) : NULL;
  enum return_value_convention rvc;
  int opencl_vector = 0;

  if (func_type)
    {
      func_type = check_typedef (func_type);

      if (TYPE_CODE (func_type) == TYPE_CODE_PTR)
	func_type = check_typedef (TYPE_TARGET_TYPE (func_type));

      if (TYPE_CODE (func_type) == TYPE_CODE_FUNC
	  && TYPE_CALLING_CONVENTION (func_type) == DW_CC_GDB_IBM_OpenCL
	  && TYPE_CODE (type) == TYPE_CODE_ARRAY
	  && TYPE_VECTOR (type))
	opencl_vector = 1;
    }

  if (TYPE_LENGTH (type) <= (SPU_ARGN_REGNUM - SPU_ARG1_REGNUM + 1) * 16)
    rvc = RETURN_VALUE_REGISTER_CONVENTION;
  else
    rvc = RETURN_VALUE_STRUCT_CONVENTION;

  if (in)
    {
      switch (rvc)
	{
	case RETURN_VALUE_REGISTER_CONVENTION:
	  if (opencl_vector && TYPE_LENGTH (type) == 2)
	    regcache_cooked_write_part (regcache, SPU_ARG1_REGNUM, 2, 2, in);
	  else
	    spu_value_to_regcache (regcache, SPU_ARG1_REGNUM, type, in);
	  break;

	case RETURN_VALUE_STRUCT_CONVENTION:
	  error (_("Cannot set function return value."));
	  break;
	}
    }
  else if (out)
    {
      switch (rvc)
	{
	case RETURN_VALUE_REGISTER_CONVENTION:
	  if (opencl_vector && TYPE_LENGTH (type) == 2)
	    regcache_cooked_read_part (regcache, SPU_ARG1_REGNUM, 2, 2, out);
	  else
	    spu_regcache_to_value (regcache, SPU_ARG1_REGNUM, type, out);
	  break;

	case RETURN_VALUE_STRUCT_CONVENTION:
	  error (_("Function return value unknown."));
	  break;
	}
    }

  return rvc;
}


/* Breakpoints.  */

static const gdb_byte *
spu_breakpoint_from_pc (struct gdbarch *gdbarch,
			CORE_ADDR * pcptr, int *lenptr)
{
  static const gdb_byte breakpoint[] = { 0x00, 0x00, 0x3f, 0xff };

  *lenptr = sizeof breakpoint;
  return breakpoint;
}

static int
spu_memory_remove_breakpoint (struct gdbarch *gdbarch,
			      struct bp_target_info *bp_tgt)
{
  /* We work around a problem in combined Cell/B.E. debugging here.  Consider
     that in a combined application, we have some breakpoints inserted in SPU
     code, and now the application forks (on the PPU side).  GDB common code
     will assume that the fork system call copied all breakpoints into the new
     process' address space, and that all those copies now need to be removed
     (see breakpoint.c:detach_breakpoints).

     While this is certainly true for PPU side breakpoints, it is not true
     for SPU side breakpoints.  fork will clone the SPU context file
     descriptors, so that all the existing SPU contexts are in accessible
     in the new process.  However, the contents of the SPU contexts themselves
     are *not* cloned.  Therefore the effect of detach_breakpoints is to
     remove SPU breakpoints from the *original* SPU context's local store
     -- this is not the correct behaviour.

     The workaround is to check whether the PID we are asked to remove this
     breakpoint from (i.e. ptid_get_pid (inferior_ptid)) is different from the
     PID of the current inferior (i.e. current_inferior ()->pid).  This is only
     true in the context of detach_breakpoints.  If so, we simply do nothing.
     [ Note that for the fork child process, it does not matter if breakpoints
     remain inserted, because those SPU contexts are not runnable anyway --
     the Linux kernel allows only the original process to invoke spu_run.  */

  if (ptid_get_pid (inferior_ptid) != current_inferior ()->pid) 
    return 0;

  return default_memory_remove_breakpoint (gdbarch, bp_tgt);
}


/* Software single-stepping support.  */

static int
spu_software_single_step (struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct address_space *aspace = get_frame_address_space (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR pc, next_pc;
  unsigned int insn;
  int offset, reg;
  gdb_byte buf[4];
  ULONGEST lslr;

  pc = get_frame_pc (frame);

  if (target_read_memory (pc, buf, 4))
    return 1;
  insn = extract_unsigned_integer (buf, 4, byte_order);

  /* Get local store limit.  */
  lslr = get_frame_register_unsigned (frame, SPU_LSLR_REGNUM);
  if (!lslr)
    lslr = (ULONGEST) -1;

  /* Next sequential instruction is at PC + 4, except if the current
     instruction is a PPE-assisted call, in which case it is at PC + 8.
     Wrap around LS limit to be on the safe side.  */
  if ((insn & 0xffffff00) == 0x00002100)
    next_pc = (SPUADDR_ADDR (pc) + 8) & lslr;
  else
    next_pc = (SPUADDR_ADDR (pc) + 4) & lslr;

  insert_single_step_breakpoint (gdbarch,
				 aspace, SPUADDR (SPUADDR_SPU (pc), next_pc));

  if (is_branch (insn, &offset, &reg))
    {
      CORE_ADDR target = offset;

      if (reg == SPU_PC_REGNUM)
	target += SPUADDR_ADDR (pc);
      else if (reg != -1)
	{
	  int optim, unavail;

	  if (get_frame_register_bytes (frame, reg, 0, 4, buf,
					 &optim, &unavail))
	    target += extract_unsigned_integer (buf, 4, byte_order) & -4;
	  else
	    {
	      if (optim)
		error (_("Could not determine address of "
			 "single-step breakpoint."));
	      if (unavail)
		throw_error (NOT_AVAILABLE_ERROR,
			     _("Could not determine address of "
			       "single-step breakpoint."));
	    }
	}

      target = target & lslr;
      if (target != next_pc)
	insert_single_step_breakpoint (gdbarch, aspace,
				       SPUADDR (SPUADDR_SPU (pc), target));
    }

  return 1;
}


/* Longjmp support.  */

static int
spu_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[4];
  CORE_ADDR jb_addr;
  int optim, unavail;

  /* Jump buffer is pointed to by the argument register $r3.  */
  if (!get_frame_register_bytes (frame, SPU_ARG1_REGNUM, 0, 4, buf,
				 &optim, &unavail))
    return 0;

  jb_addr = extract_unsigned_integer (buf, 4, byte_order);
  if (target_read_memory (SPUADDR (tdep->id, jb_addr), buf, 4))
    return 0;

  *pc = extract_unsigned_integer (buf, 4, byte_order);
  *pc = SPUADDR (tdep->id, *pc);
  return 1;
}


/* Disassembler.  */

struct spu_dis_asm_data
{
  struct gdbarch *gdbarch;
  int id;
};

static void
spu_dis_asm_print_address (bfd_vma addr, struct disassemble_info *info)
{
  struct spu_dis_asm_data *data = info->application_data;
  print_address (data->gdbarch, SPUADDR (data->id, addr), info->stream);
}

static int
gdb_print_insn_spu (bfd_vma memaddr, struct disassemble_info *info)
{
  /* The opcodes disassembler does 18-bit address arithmetic.  Make
     sure the SPU ID encoded in the high bits is added back when we
     call print_address.  */
  struct disassemble_info spu_info = *info;
  struct spu_dis_asm_data data;
  data.gdbarch = info->application_data;
  data.id = SPUADDR_SPU (memaddr);

  spu_info.application_data = &data;
  spu_info.print_address_func = spu_dis_asm_print_address;
  return print_insn_spu (memaddr, &spu_info);
}


/* Target overlays for the SPU overlay manager.

   See the documentation of simple_overlay_update for how the
   interface is supposed to work.

   Data structures used by the overlay manager:

   struct ovly_table
     {
        u32 vma;
        u32 size;
        u32 pos;
        u32 buf;
     } _ovly_table[];   -- one entry per overlay section

   struct ovly_buf_table
     {
        u32 mapped;
     } _ovly_buf_table[];  -- one entry per overlay buffer

   _ovly_table should never change.

   Both tables are aligned to a 16-byte boundary, the symbols
   _ovly_table and _ovly_buf_table are of type STT_OBJECT and their
   size set to the size of the respective array. buf in _ovly_table is
   an index into _ovly_buf_table.

   mapped is an index into _ovly_table.  Both the mapped and buf indices start
   from one to reference the first entry in their respective tables.  */

/* Using the per-objfile private data mechanism, we store for each
   objfile an array of "struct spu_overlay_table" structures, one
   for each obj_section of the objfile.  This structure holds two
   fields, MAPPED_PTR and MAPPED_VAL.  If MAPPED_PTR is zero, this
   is *not* an overlay section.  If it is non-zero, it represents
   a target address.  The overlay section is mapped iff the target
   integer at this location equals MAPPED_VAL.  */

static const struct objfile_data *spu_overlay_data;

struct spu_overlay_table
  {
    CORE_ADDR mapped_ptr;
    CORE_ADDR mapped_val;
  };

/* Retrieve the overlay table for OBJFILE.  If not already cached, read
   the _ovly_table data structure from the target and initialize the
   spu_overlay_table data structure from it.  */
static struct spu_overlay_table *
spu_get_overlay_table (struct objfile *objfile)
{
  enum bfd_endian byte_order = bfd_big_endian (objfile->obfd)?
		   BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;
  struct minimal_symbol *ovly_table_msym, *ovly_buf_table_msym;
  CORE_ADDR ovly_table_base, ovly_buf_table_base;
  unsigned ovly_table_size, ovly_buf_table_size;
  struct spu_overlay_table *tbl;
  struct obj_section *osect;
  gdb_byte *ovly_table;
  int i;

  tbl = objfile_data (objfile, spu_overlay_data);
  if (tbl)
    return tbl;

  ovly_table_msym = lookup_minimal_symbol ("_ovly_table", NULL, objfile);
  if (!ovly_table_msym)
    return NULL;

  ovly_buf_table_msym = lookup_minimal_symbol ("_ovly_buf_table",
					       NULL, objfile);
  if (!ovly_buf_table_msym)
    return NULL;

  ovly_table_base = SYMBOL_VALUE_ADDRESS (ovly_table_msym);
  ovly_table_size = MSYMBOL_SIZE (ovly_table_msym);

  ovly_buf_table_base = SYMBOL_VALUE_ADDRESS (ovly_buf_table_msym);
  ovly_buf_table_size = MSYMBOL_SIZE (ovly_buf_table_msym);

  ovly_table = xmalloc (ovly_table_size);
  read_memory (ovly_table_base, ovly_table, ovly_table_size);

  tbl = OBSTACK_CALLOC (&objfile->objfile_obstack,
			objfile->sections_end - objfile->sections,
			struct spu_overlay_table);

  for (i = 0; i < ovly_table_size / 16; i++)
    {
      CORE_ADDR vma  = extract_unsigned_integer (ovly_table + 16*i + 0,
						 4, byte_order);
      CORE_ADDR size = extract_unsigned_integer (ovly_table + 16*i + 4,
						 4, byte_order);
      CORE_ADDR pos  = extract_unsigned_integer (ovly_table + 16*i + 8,
						 4, byte_order);
      CORE_ADDR buf  = extract_unsigned_integer (ovly_table + 16*i + 12,
						 4, byte_order);

      if (buf == 0 || (buf - 1) * 4 >= ovly_buf_table_size)
	continue;

      ALL_OBJFILE_OSECTIONS (objfile, osect)
	if (vma == bfd_section_vma (objfile->obfd, osect->the_bfd_section)
	    && pos == osect->the_bfd_section->filepos)
	  {
	    int ndx = osect - objfile->sections;
	    tbl[ndx].mapped_ptr = ovly_buf_table_base + (buf - 1) * 4;
	    tbl[ndx].mapped_val = i + 1;
	    break;
	  }
    }

  xfree (ovly_table);
  set_objfile_data (objfile, spu_overlay_data, tbl);
  return tbl;
}

/* Read _ovly_buf_table entry from the target to dermine whether
   OSECT is currently mapped, and update the mapped state.  */
static void
spu_overlay_update_osect (struct obj_section *osect)
{
  enum bfd_endian byte_order = bfd_big_endian (osect->objfile->obfd)?
		   BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;
  struct spu_overlay_table *ovly_table;
  CORE_ADDR id, val;

  ovly_table = spu_get_overlay_table (osect->objfile);
  if (!ovly_table)
    return;

  ovly_table += osect - osect->objfile->sections;
  if (ovly_table->mapped_ptr == 0)
    return;

  id = SPUADDR_SPU (obj_section_addr (osect));
  val = read_memory_unsigned_integer (SPUADDR (id, ovly_table->mapped_ptr),
				      4, byte_order);
  osect->ovly_mapped = (val == ovly_table->mapped_val);
}

/* If OSECT is NULL, then update all sections' mapped state.
   If OSECT is non-NULL, then update only OSECT's mapped state.  */
static void
spu_overlay_update (struct obj_section *osect)
{
  /* Just one section.  */
  if (osect)
    spu_overlay_update_osect (osect);

  /* All sections.  */
  else
    {
      struct objfile *objfile;

      ALL_OBJSECTIONS (objfile, osect)
	if (section_is_overlay (osect))
	  spu_overlay_update_osect (osect);
    }
}

/* Whenever a new objfile is loaded, read the target's _ovly_table.
   If there is one, go through all sections and make sure for non-
   overlay sections LMA equals VMA, while for overlay sections LMA
   is larger than SPU_OVERLAY_LMA.  */
static void
spu_overlay_new_objfile (struct objfile *objfile)
{
  struct spu_overlay_table *ovly_table;
  struct obj_section *osect;

  /* If we've already touched this file, do nothing.  */
  if (!objfile || objfile_data (objfile, spu_overlay_data) != NULL)
    return;

  /* Consider only SPU objfiles.  */
  if (bfd_get_arch (objfile->obfd) != bfd_arch_spu)
    return;

  /* Check if this objfile has overlays.  */
  ovly_table = spu_get_overlay_table (objfile);
  if (!ovly_table)
    return;

  /* Now go and fiddle with all the LMAs.  */
  ALL_OBJFILE_OSECTIONS (objfile, osect)
    {
      bfd *obfd = objfile->obfd;
      asection *bsect = osect->the_bfd_section;
      int ndx = osect - objfile->sections;

      if (ovly_table[ndx].mapped_ptr == 0)
	bfd_section_lma (obfd, bsect) = bfd_section_vma (obfd, bsect);
      else
	bfd_section_lma (obfd, bsect) = SPU_OVERLAY_LMA + bsect->filepos;
    }
}


/* Insert temporary breakpoint on "main" function of newly loaded
   SPE context OBJFILE.  */
static void
spu_catch_start (struct objfile *objfile)
{
  struct minimal_symbol *minsym;
  struct symtab *symtab;
  CORE_ADDR pc;
  char buf[32];

  /* Do this only if requested by "set spu stop-on-load on".  */
  if (!spu_stop_on_load_p)
    return;

  /* Consider only SPU objfiles.  */
  if (!objfile || bfd_get_arch (objfile->obfd) != bfd_arch_spu)
    return;

  /* The main objfile is handled differently.  */
  if (objfile == symfile_objfile)
    return;

  /* There can be multiple symbols named "main".  Search for the
     "main" in *this* objfile.  */
  minsym = lookup_minimal_symbol ("main", NULL, objfile);
  if (!minsym)
    return;

  /* If we have debugging information, try to use it -- this
     will allow us to properly skip the prologue.  */
  pc = SYMBOL_VALUE_ADDRESS (minsym);
  symtab = find_pc_sect_symtab (pc, SYMBOL_OBJ_SECTION (objfile, minsym));
  if (symtab != NULL)
    {
      struct blockvector *bv = BLOCKVECTOR (symtab);
      struct block *block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
      struct symbol *sym;
      struct symtab_and_line sal;

      sym = lookup_block_symbol (block, "main", VAR_DOMAIN);
      if (sym)
	{
	  fixup_symbol_section (sym, objfile);
	  sal = find_function_start_sal (sym, 1);
	  pc = sal.pc;
	}
    }

  /* Use a numerical address for the set_breakpoint command to avoid having
     the breakpoint re-set incorrectly.  */
  xsnprintf (buf, sizeof buf, "*%s", core_addr_to_string (pc));
  create_breakpoint (get_objfile_arch (objfile), buf /* arg */,
		     NULL /* cond_string */, -1 /* thread */,
		     NULL /* extra_string */,
		     0 /* parse_condition_and_thread */, 1 /* tempflag */,
		     bp_breakpoint /* type_wanted */,
		     0 /* ignore_count */,
		     AUTO_BOOLEAN_FALSE /* pending_break_support */,
		     &bkpt_breakpoint_ops /* ops */, 0 /* from_tty */,
		     1 /* enabled */, 0 /* internal  */, 0);
}


/* Look up OBJFILE loaded into FRAME's SPU context.  */
static struct objfile *
spu_objfile_from_frame (struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  struct objfile *obj;

  if (gdbarch_bfd_arch_info (gdbarch)->arch != bfd_arch_spu)
    return NULL;

  ALL_OBJFILES (obj)
    {
      if (obj->sections != obj->sections_end
	  && SPUADDR_SPU (obj_section_addr (obj->sections)) == tdep->id)
	return obj;
    }

  return NULL;
}

/* Flush cache for ea pointer access if available.  */
static void
flush_ea_cache (void)
{
  struct minimal_symbol *msymbol;
  struct objfile *obj;

  if (!has_stack_frames ())
    return;

  obj = spu_objfile_from_frame (get_current_frame ());
  if (obj == NULL)
    return;

  /* Lookup inferior function __cache_flush.  */
  msymbol = lookup_minimal_symbol ("__cache_flush", NULL, obj);
  if (msymbol != NULL)
    {
      struct type *type;
      CORE_ADDR addr;

      type = objfile_type (obj)->builtin_void;
      type = lookup_function_type (type);
      type = lookup_pointer_type (type);
      addr = SYMBOL_VALUE_ADDRESS (msymbol);

      call_function_by_hand (value_from_pointer (type, addr), 0, NULL);
    }
}

/* This handler is called when the inferior has stopped.  If it is stopped in
   SPU architecture then flush the ea cache if used.  */
static void
spu_attach_normal_stop (struct bpstats *bs, int print_frame)
{
  if (!spu_auto_flush_cache_p)
    return;

  /* Temporarily reset spu_auto_flush_cache_p to avoid recursively
     re-entering this function when __cache_flush stops.  */
  spu_auto_flush_cache_p = 0;
  flush_ea_cache ();
  spu_auto_flush_cache_p = 1;
}


/* "info spu" commands.  */

static void
info_spu_event_command (char *args, int from_tty)
{
  struct frame_info *frame = get_selected_frame (NULL);
  ULONGEST event_status = 0;
  ULONGEST event_mask = 0;
  struct cleanup *chain;
  gdb_byte buf[100];
  char annex[32];
  LONGEST len;
  int id;

  if (gdbarch_bfd_arch_info (get_frame_arch (frame))->arch != bfd_arch_spu)
    error (_("\"info spu\" is only supported on the SPU architecture."));

  id = get_frame_register_unsigned (frame, SPU_ID_REGNUM);

  xsnprintf (annex, sizeof annex, "%d/event_status", id);
  len = target_read (&current_target, TARGET_OBJECT_SPU, annex,
		     buf, 0, (sizeof (buf) - 1));
  if (len <= 0)
    error (_("Could not read event_status."));
  buf[len] = '\0';
  event_status = strtoulst ((char *) buf, NULL, 16);
 
  xsnprintf (annex, sizeof annex, "%d/event_mask", id);
  len = target_read (&current_target, TARGET_OBJECT_SPU, annex,
		     buf, 0, (sizeof (buf) - 1));
  if (len <= 0)
    error (_("Could not read event_mask."));
  buf[len] = '\0';
  event_mask = strtoulst ((char *) buf, NULL, 16);
 
  chain = make_cleanup_ui_out_tuple_begin_end (current_uiout, "SPUInfoEvent");

  if (ui_out_is_mi_like_p (current_uiout))
    {
      ui_out_field_fmt (current_uiout, "event_status",
			"0x%s", phex_nz (event_status, 4));
      ui_out_field_fmt (current_uiout, "event_mask",
			"0x%s", phex_nz (event_mask, 4));
    }
  else
    {
      printf_filtered (_("Event Status 0x%s\n"), phex (event_status, 4));
      printf_filtered (_("Event Mask   0x%s\n"), phex (event_mask, 4));
    }

  do_cleanups (chain);
}

static void
info_spu_signal_command (char *args, int from_tty)
{
  struct frame_info *frame = get_selected_frame (NULL);
  struct gdbarch *gdbarch = get_frame_arch (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  ULONGEST signal1 = 0;
  ULONGEST signal1_type = 0;
  int signal1_pending = 0;
  ULONGEST signal2 = 0;
  ULONGEST signal2_type = 0;
  int signal2_pending = 0;
  struct cleanup *chain;
  char annex[32];
  gdb_byte buf[100];
  LONGEST len;
  int id;

  if (gdbarch_bfd_arch_info (gdbarch)->arch != bfd_arch_spu)
    error (_("\"info spu\" is only supported on the SPU architecture."));

  id = get_frame_register_unsigned (frame, SPU_ID_REGNUM);

  xsnprintf (annex, sizeof annex, "%d/signal1", id);
  len = target_read (&current_target, TARGET_OBJECT_SPU, annex, buf, 0, 4);
  if (len < 0)
    error (_("Could not read signal1."));
  else if (len == 4)
    {
      signal1 = extract_unsigned_integer (buf, 4, byte_order);
      signal1_pending = 1;
    }
    
  xsnprintf (annex, sizeof annex, "%d/signal1_type", id);
  len = target_read (&current_target, TARGET_OBJECT_SPU, annex,
		     buf, 0, (sizeof (buf) - 1));
  if (len <= 0)
    error (_("Could not read signal1_type."));
  buf[len] = '\0';
  signal1_type = strtoulst ((char *) buf, NULL, 16);

  xsnprintf (annex, sizeof annex, "%d/signal2", id);
  len = target_read (&current_target, TARGET_OBJECT_SPU, annex, buf, 0, 4);
  if (len < 0)
    error (_("Could not read signal2."));
  else if (len == 4)
    {
      signal2 = extract_unsigned_integer (buf, 4, byte_order);
      signal2_pending = 1;
    }
    
  xsnprintf (annex, sizeof annex, "%d/signal2_type", id);
  len = target_read (&current_target, TARGET_OBJECT_SPU, annex,
		     buf, 0, (sizeof (buf) - 1));
  if (len <= 0)
    error (_("Could not read signal2_type."));
  buf[len] = '\0';
  signal2_type = strtoulst ((char *) buf, NULL, 16);

  chain = make_cleanup_ui_out_tuple_begin_end (current_uiout, "SPUInfoSignal");

  if (ui_out_is_mi_like_p (current_uiout))
    {
      ui_out_field_int (current_uiout, "signal1_pending", signal1_pending);
      ui_out_field_fmt (current_uiout, "signal1", "0x%s", phex_nz (signal1, 4));
      ui_out_field_int (current_uiout, "signal1_type", signal1_type);
      ui_out_field_int (current_uiout, "signal2_pending", signal2_pending);
      ui_out_field_fmt (current_uiout, "signal2", "0x%s", phex_nz (signal2, 4));
      ui_out_field_int (current_uiout, "signal2_type", signal2_type);
    }
  else
    {
      if (signal1_pending)
	printf_filtered (_("Signal 1 control word 0x%s "), phex (signal1, 4));
      else
	printf_filtered (_("Signal 1 not pending "));

      if (signal1_type)
	printf_filtered (_("(Type Or)\n"));
      else
	printf_filtered (_("(Type Overwrite)\n"));

      if (signal2_pending)
	printf_filtered (_("Signal 2 control word 0x%s "), phex (signal2, 4));
      else
	printf_filtered (_("Signal 2 not pending "));

      if (signal2_type)
	printf_filtered (_("(Type Or)\n"));
      else
	printf_filtered (_("(Type Overwrite)\n"));
    }

  do_cleanups (chain);
}

static void
info_spu_mailbox_list (gdb_byte *buf, int nr, enum bfd_endian byte_order,
		       const char *field, const char *msg)
{
  struct cleanup *chain;
  int i;

  if (nr <= 0)
    return;

  chain = make_cleanup_ui_out_table_begin_end (current_uiout, 1, nr, "mbox");

  ui_out_table_header (current_uiout, 32, ui_left, field, msg);
  ui_out_table_body (current_uiout);

  for (i = 0; i < nr; i++)
    {
      struct cleanup *val_chain;
      ULONGEST val;
      val_chain = make_cleanup_ui_out_tuple_begin_end (current_uiout, "mbox");
      val = extract_unsigned_integer (buf + 4*i, 4, byte_order);
      ui_out_field_fmt (current_uiout, field, "0x%s", phex (val, 4));
      do_cleanups (val_chain);

      if (!ui_out_is_mi_like_p (current_uiout))
	printf_filtered ("\n");
    }

  do_cleanups (chain);
}

static void
info_spu_mailbox_command (char *args, int from_tty)
{
  struct frame_info *frame = get_selected_frame (NULL);
  struct gdbarch *gdbarch = get_frame_arch (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct cleanup *chain;
  char annex[32];
  gdb_byte buf[1024];
  LONGEST len;
  int id;

  if (gdbarch_bfd_arch_info (gdbarch)->arch != bfd_arch_spu)
    error (_("\"info spu\" is only supported on the SPU architecture."));

  id = get_frame_register_unsigned (frame, SPU_ID_REGNUM);

  chain = make_cleanup_ui_out_tuple_begin_end (current_uiout, "SPUInfoMailbox");

  xsnprintf (annex, sizeof annex, "%d/mbox_info", id);
  len = target_read (&current_target, TARGET_OBJECT_SPU, annex,
		     buf, 0, sizeof buf);
  if (len < 0)
    error (_("Could not read mbox_info."));

  info_spu_mailbox_list (buf, len / 4, byte_order,
			 "mbox", "SPU Outbound Mailbox");

  xsnprintf (annex, sizeof annex, "%d/ibox_info", id);
  len = target_read (&current_target, TARGET_OBJECT_SPU, annex,
		     buf, 0, sizeof buf);
  if (len < 0)
    error (_("Could not read ibox_info."));

  info_spu_mailbox_list (buf, len / 4, byte_order,
			 "ibox", "SPU Outbound Interrupt Mailbox");

  xsnprintf (annex, sizeof annex, "%d/wbox_info", id);
  len = target_read (&current_target, TARGET_OBJECT_SPU, annex,
		     buf, 0, sizeof buf);
  if (len < 0)
    error (_("Could not read wbox_info."));

  info_spu_mailbox_list (buf, len / 4, byte_order,
			 "wbox", "SPU Inbound Mailbox");

  do_cleanups (chain);
}

static ULONGEST
spu_mfc_get_bitfield (ULONGEST word, int first, int last)
{
  ULONGEST mask = ~(~(ULONGEST)0 << (last - first + 1));
  return (word >> (63 - last)) & mask;
}

static void
info_spu_dma_cmdlist (gdb_byte *buf, int nr, enum bfd_endian byte_order)
{
  static char *spu_mfc_opcode[256] =
    {
    /* 00 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    /* 10 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    /* 20 */ "put", "putb", "putf", NULL, "putl", "putlb", "putlf", NULL,
             "puts", "putbs", "putfs", NULL, NULL, NULL, NULL, NULL,
    /* 30 */ "putr", "putrb", "putrf", NULL, "putrl", "putrlb", "putrlf", NULL,
             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    /* 40 */ "get", "getb", "getf", NULL, "getl", "getlb", "getlf", NULL,
             "gets", "getbs", "getfs", NULL, NULL, NULL, NULL, NULL,
    /* 50 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    /* 60 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    /* 70 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    /* 80 */ "sdcrt", "sdcrtst", NULL, NULL, NULL, NULL, NULL, NULL,
             NULL, "sdcrz", NULL, NULL, NULL, "sdcrst", NULL, "sdcrf",
    /* 90 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    /* a0 */ "sndsig", "sndsigb", "sndsigf", NULL, NULL, NULL, NULL, NULL,
             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    /* b0 */ "putlluc", NULL, NULL, NULL, "putllc", NULL, NULL, NULL,
             "putqlluc", NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    /* c0 */ "barrier", NULL, NULL, NULL, NULL, NULL, NULL, NULL,
             "mfceieio", NULL, NULL, NULL, "mfcsync", NULL, NULL, NULL,
    /* d0 */ "getllar", NULL, NULL, NULL, NULL, NULL, NULL, NULL,
             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    /* e0 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    /* f0 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    };

  int *seq = alloca (nr * sizeof (int));
  int done = 0;
  struct cleanup *chain;
  int i, j;


  /* Determine sequence in which to display (valid) entries.  */
  for (i = 0; i < nr; i++)
    {
      /* Search for the first valid entry all of whose
	 dependencies are met.  */
      for (j = 0; j < nr; j++)
	{
          ULONGEST mfc_cq_dw3;
	  ULONGEST dependencies;

	  if (done & (1 << (nr - 1 - j)))
	    continue;

	  mfc_cq_dw3
	    = extract_unsigned_integer (buf + 32*j + 24,8, byte_order);
	  if (!spu_mfc_get_bitfield (mfc_cq_dw3, 16, 16))
	    continue;

	  dependencies = spu_mfc_get_bitfield (mfc_cq_dw3, 0, nr - 1);
	  if ((dependencies & done) != dependencies)
	    continue;

	  seq[i] = j;
	  done |= 1 << (nr - 1 - j);
	  break;
	}

      if (j == nr)
	break;
    }

  nr = i;


  chain = make_cleanup_ui_out_table_begin_end (current_uiout, 10, nr,
					       "dma_cmd");

  ui_out_table_header (current_uiout, 7, ui_left, "opcode", "Opcode");
  ui_out_table_header (current_uiout, 3, ui_left, "tag", "Tag");
  ui_out_table_header (current_uiout, 3, ui_left, "tid", "TId");
  ui_out_table_header (current_uiout, 3, ui_left, "rid", "RId");
  ui_out_table_header (current_uiout, 18, ui_left, "ea", "EA");
  ui_out_table_header (current_uiout, 7, ui_left, "lsa", "LSA");
  ui_out_table_header (current_uiout, 7, ui_left, "size", "Size");
  ui_out_table_header (current_uiout, 7, ui_left, "lstaddr", "LstAddr");
  ui_out_table_header (current_uiout, 7, ui_left, "lstsize", "LstSize");
  ui_out_table_header (current_uiout, 1, ui_left, "error_p", "E");

  ui_out_table_body (current_uiout);

  for (i = 0; i < nr; i++)
    {
      struct cleanup *cmd_chain;
      ULONGEST mfc_cq_dw0;
      ULONGEST mfc_cq_dw1;
      ULONGEST mfc_cq_dw2;
      int mfc_cmd_opcode, mfc_cmd_tag, rclass_id, tclass_id;
      int list_lsa, list_size, mfc_lsa, mfc_size;
      ULONGEST mfc_ea;
      int list_valid_p, noop_valid_p, qw_valid_p, ea_valid_p, cmd_error_p;

      /* Decode contents of MFC Command Queue Context Save/Restore Registers.
	 See "Cell Broadband Engine Registers V1.3", section 3.3.2.1.  */

      mfc_cq_dw0
	= extract_unsigned_integer (buf + 32*seq[i], 8, byte_order);
      mfc_cq_dw1
	= extract_unsigned_integer (buf + 32*seq[i] + 8, 8, byte_order);
      mfc_cq_dw2
	= extract_unsigned_integer (buf + 32*seq[i] + 16, 8, byte_order);

      list_lsa = spu_mfc_get_bitfield (mfc_cq_dw0, 0, 14);
      list_size = spu_mfc_get_bitfield (mfc_cq_dw0, 15, 26);
      mfc_cmd_opcode = spu_mfc_get_bitfield (mfc_cq_dw0, 27, 34);
      mfc_cmd_tag = spu_mfc_get_bitfield (mfc_cq_dw0, 35, 39);
      list_valid_p = spu_mfc_get_bitfield (mfc_cq_dw0, 40, 40);
      rclass_id = spu_mfc_get_bitfield (mfc_cq_dw0, 41, 43);
      tclass_id = spu_mfc_get_bitfield (mfc_cq_dw0, 44, 46);

      mfc_ea = spu_mfc_get_bitfield (mfc_cq_dw1, 0, 51) << 12
		| spu_mfc_get_bitfield (mfc_cq_dw2, 25, 36);

      mfc_lsa = spu_mfc_get_bitfield (mfc_cq_dw2, 0, 13);
      mfc_size = spu_mfc_get_bitfield (mfc_cq_dw2, 14, 24);
      noop_valid_p = spu_mfc_get_bitfield (mfc_cq_dw2, 37, 37);
      qw_valid_p = spu_mfc_get_bitfield (mfc_cq_dw2, 38, 38);
      ea_valid_p = spu_mfc_get_bitfield (mfc_cq_dw2, 39, 39);
      cmd_error_p = spu_mfc_get_bitfield (mfc_cq_dw2, 40, 40);

      cmd_chain = make_cleanup_ui_out_tuple_begin_end (current_uiout, "cmd");

      if (spu_mfc_opcode[mfc_cmd_opcode])
	ui_out_field_string (current_uiout, "opcode", spu_mfc_opcode[mfc_cmd_opcode]);
      else
	ui_out_field_int (current_uiout, "opcode", mfc_cmd_opcode);

      ui_out_field_int (current_uiout, "tag", mfc_cmd_tag);
      ui_out_field_int (current_uiout, "tid", tclass_id);
      ui_out_field_int (current_uiout, "rid", rclass_id);

      if (ea_valid_p)
	ui_out_field_fmt (current_uiout, "ea", "0x%s", phex (mfc_ea, 8));
      else
	ui_out_field_skip (current_uiout, "ea");

      ui_out_field_fmt (current_uiout, "lsa", "0x%05x", mfc_lsa << 4);
      if (qw_valid_p)
	ui_out_field_fmt (current_uiout, "size", "0x%05x", mfc_size << 4);
      else
	ui_out_field_fmt (current_uiout, "size", "0x%05x", mfc_size);

      if (list_valid_p)
	{
	  ui_out_field_fmt (current_uiout, "lstaddr", "0x%05x", list_lsa << 3);
	  ui_out_field_fmt (current_uiout, "lstsize", "0x%05x", list_size << 3);
	}
      else
	{
	  ui_out_field_skip (current_uiout, "lstaddr");
	  ui_out_field_skip (current_uiout, "lstsize");
	}

      if (cmd_error_p)
	ui_out_field_string (current_uiout, "error_p", "*");
      else
	ui_out_field_skip (current_uiout, "error_p");

      do_cleanups (cmd_chain);

      if (!ui_out_is_mi_like_p (current_uiout))
	printf_filtered ("\n");
    }

  do_cleanups (chain);
}

static void
info_spu_dma_command (char *args, int from_tty)
{
  struct frame_info *frame = get_selected_frame (NULL);
  struct gdbarch *gdbarch = get_frame_arch (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  ULONGEST dma_info_type;
  ULONGEST dma_info_mask;
  ULONGEST dma_info_status;
  ULONGEST dma_info_stall_and_notify;
  ULONGEST dma_info_atomic_command_status;
  struct cleanup *chain;
  char annex[32];
  gdb_byte buf[1024];
  LONGEST len;
  int id;

  if (gdbarch_bfd_arch_info (get_frame_arch (frame))->arch != bfd_arch_spu)
    error (_("\"info spu\" is only supported on the SPU architecture."));

  id = get_frame_register_unsigned (frame, SPU_ID_REGNUM);

  xsnprintf (annex, sizeof annex, "%d/dma_info", id);
  len = target_read (&current_target, TARGET_OBJECT_SPU, annex,
		     buf, 0, 40 + 16 * 32);
  if (len <= 0)
    error (_("Could not read dma_info."));

  dma_info_type
    = extract_unsigned_integer (buf, 8, byte_order);
  dma_info_mask
    = extract_unsigned_integer (buf + 8, 8, byte_order);
  dma_info_status
    = extract_unsigned_integer (buf + 16, 8, byte_order);
  dma_info_stall_and_notify
    = extract_unsigned_integer (buf + 24, 8, byte_order);
  dma_info_atomic_command_status
    = extract_unsigned_integer (buf + 32, 8, byte_order);
  
  chain = make_cleanup_ui_out_tuple_begin_end (current_uiout, "SPUInfoDMA");

  if (ui_out_is_mi_like_p (current_uiout))
    {
      ui_out_field_fmt (current_uiout, "dma_info_type", "0x%s",
			phex_nz (dma_info_type, 4));
      ui_out_field_fmt (current_uiout, "dma_info_mask", "0x%s",
			phex_nz (dma_info_mask, 4));
      ui_out_field_fmt (current_uiout, "dma_info_status", "0x%s",
			phex_nz (dma_info_status, 4));
      ui_out_field_fmt (current_uiout, "dma_info_stall_and_notify", "0x%s",
			phex_nz (dma_info_stall_and_notify, 4));
      ui_out_field_fmt (current_uiout, "dma_info_atomic_command_status", "0x%s",
			phex_nz (dma_info_atomic_command_status, 4));
    }
  else
    {
      const char *query_msg = _("no query pending");

      if (dma_info_type & 4)
	switch (dma_info_type & 3)
	  {
	    case 1: query_msg = _("'any' query pending"); break;
	    case 2: query_msg = _("'all' query pending"); break;
	    default: query_msg = _("undefined query type"); break;
	  }

      printf_filtered (_("Tag-Group Status  0x%s\n"),
		       phex (dma_info_status, 4));
      printf_filtered (_("Tag-Group Mask    0x%s (%s)\n"),
		       phex (dma_info_mask, 4), query_msg);
      printf_filtered (_("Stall-and-Notify  0x%s\n"),
		       phex (dma_info_stall_and_notify, 4));
      printf_filtered (_("Atomic Cmd Status 0x%s\n"),
		       phex (dma_info_atomic_command_status, 4));
      printf_filtered ("\n");
    }

  info_spu_dma_cmdlist (buf + 40, 16, byte_order);
  do_cleanups (chain);
}

static void
info_spu_proxydma_command (char *args, int from_tty)
{
  struct frame_info *frame = get_selected_frame (NULL);
  struct gdbarch *gdbarch = get_frame_arch (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  ULONGEST dma_info_type;
  ULONGEST dma_info_mask;
  ULONGEST dma_info_status;
  struct cleanup *chain;
  char annex[32];
  gdb_byte buf[1024];
  LONGEST len;
  int id;

  if (gdbarch_bfd_arch_info (gdbarch)->arch != bfd_arch_spu)
    error (_("\"info spu\" is only supported on the SPU architecture."));

  id = get_frame_register_unsigned (frame, SPU_ID_REGNUM);

  xsnprintf (annex, sizeof annex, "%d/proxydma_info", id);
  len = target_read (&current_target, TARGET_OBJECT_SPU, annex,
		     buf, 0, 24 + 8 * 32);
  if (len <= 0)
    error (_("Could not read proxydma_info."));

  dma_info_type = extract_unsigned_integer (buf, 8, byte_order);
  dma_info_mask = extract_unsigned_integer (buf + 8, 8, byte_order);
  dma_info_status = extract_unsigned_integer (buf + 16, 8, byte_order);
  
  chain = make_cleanup_ui_out_tuple_begin_end (current_uiout,
					       "SPUInfoProxyDMA");

  if (ui_out_is_mi_like_p (current_uiout))
    {
      ui_out_field_fmt (current_uiout, "proxydma_info_type", "0x%s",
			phex_nz (dma_info_type, 4));
      ui_out_field_fmt (current_uiout, "proxydma_info_mask", "0x%s",
			phex_nz (dma_info_mask, 4));
      ui_out_field_fmt (current_uiout, "proxydma_info_status", "0x%s",
			phex_nz (dma_info_status, 4));
    }
  else
    {
      const char *query_msg;

      switch (dma_info_type & 3)
	{
	case 0: query_msg = _("no query pending"); break;
	case 1: query_msg = _("'any' query pending"); break;
	case 2: query_msg = _("'all' query pending"); break;
	default: query_msg = _("undefined query type"); break;
	}

      printf_filtered (_("Tag-Group Status  0x%s\n"),
		       phex (dma_info_status, 4));
      printf_filtered (_("Tag-Group Mask    0x%s (%s)\n"),
		       phex (dma_info_mask, 4), query_msg);
      printf_filtered ("\n");
    }

  info_spu_dma_cmdlist (buf + 24, 8, byte_order);
  do_cleanups (chain);
}

static void
info_spu_command (char *args, int from_tty)
{
  printf_unfiltered (_("\"info spu\" must be followed by "
		       "the name of an SPU facility.\n"));
  help_list (infospucmdlist, "info spu ", -1, gdb_stdout);
}


/* Root of all "set spu "/"show spu " commands.  */

static void
show_spu_command (char *args, int from_tty)
{
  help_list (showspucmdlist, "show spu ", all_commands, gdb_stdout);
}

static void
set_spu_command (char *args, int from_tty)
{
  help_list (setspucmdlist, "set spu ", all_commands, gdb_stdout);
}

static void
show_spu_stop_on_load (struct ui_file *file, int from_tty,
                       struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Stopping for new SPE threads is %s.\n"),
                    value);
}

static void
show_spu_auto_flush_cache (struct ui_file *file, int from_tty,
			   struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Automatic software-cache flush is %s.\n"),
                    value);
}


/* Set up gdbarch struct.  */

static struct gdbarch *
spu_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;
  int id = -1;

  /* Which spufs ID was requested as address space?  */
  if (info.tdep_info)
    id = *(int *)info.tdep_info;
  /* For objfile architectures of SPU solibs, decode the ID from the name.
     This assumes the filename convention employed by solib-spu.c.  */
  else if (info.abfd)
    {
      char *name = strrchr (info.abfd->filename, '@@');
      if (name)
	sscanf (name, "@@0x%*x <%d>", &id);
    }

  /* Find a candidate among extant architectures.  */
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      tdep = gdbarch_tdep (arches->gdbarch);
      if (tdep && tdep->id == id)
	return arches->gdbarch;
    }

  /* None found, so create a new architecture.  */
  tdep = XCALLOC (1, struct gdbarch_tdep);
  tdep->id = id;
  gdbarch = gdbarch_alloc (&info, tdep);

  /* Disassembler.  */
  set_gdbarch_print_insn (gdbarch, gdb_print_insn_spu);

  /* Registers.  */
  set_gdbarch_num_regs (gdbarch, SPU_NUM_REGS);
  set_gdbarch_num_pseudo_regs (gdbarch, SPU_NUM_PSEUDO_REGS);
  set_gdbarch_sp_regnum (gdbarch, SPU_SP_REGNUM);
  set_gdbarch_pc_regnum (gdbarch, SPU_PC_REGNUM);
  set_gdbarch_read_pc (gdbarch, spu_read_pc);
  set_gdbarch_write_pc (gdbarch, spu_write_pc);
  set_gdbarch_register_name (gdbarch, spu_register_name);
  set_gdbarch_register_type (gdbarch, spu_register_type);
  set_gdbarch_pseudo_register_read (gdbarch, spu_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, spu_pseudo_register_write);
  set_gdbarch_value_from_register (gdbarch, spu_value_from_register);
  set_gdbarch_register_reggroup_p (gdbarch, spu_register_reggroup_p);

  /* Data types.  */
  set_gdbarch_char_signed (gdbarch, 0);
  set_gdbarch_ptr_bit (gdbarch, 32);
  set_gdbarch_addr_bit (gdbarch, 32);
  set_gdbarch_short_bit (gdbarch, 16);
  set_gdbarch_int_bit (gdbarch, 32);
  set_gdbarch_long_bit (gdbarch, 32);
  set_gdbarch_long_long_bit (gdbarch, 64);
  set_gdbarch_float_bit (gdbarch, 32);
  set_gdbarch_double_bit (gdbarch, 64);
  set_gdbarch_long_double_bit (gdbarch, 64);
  set_gdbarch_float_format (gdbarch, floatformats_ieee_single);
  set_gdbarch_double_format (gdbarch, floatformats_ieee_double);
  set_gdbarch_long_double_format (gdbarch, floatformats_ieee_double);

  /* Address handling.  */
  set_gdbarch_address_to_pointer (gdbarch, spu_address_to_pointer);
  set_gdbarch_pointer_to_address (gdbarch, spu_pointer_to_address);
  set_gdbarch_integer_to_address (gdbarch, spu_integer_to_address);
  set_gdbarch_address_class_type_flags (gdbarch, spu_address_class_type_flags);
  set_gdbarch_address_class_type_flags_to_name
    (gdbarch, spu_address_class_type_flags_to_name);
  set_gdbarch_address_class_name_to_type_flags
    (gdbarch, spu_address_class_name_to_type_flags);


  /* Inferior function calls.  */
  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
  set_gdbarch_frame_align (gdbarch, spu_frame_align);
  set_gdbarch_frame_red_zone_size (gdbarch, 2000);
  set_gdbarch_push_dummy_code (gdbarch, spu_push_dummy_code);
  set_gdbarch_push_dummy_call (gdbarch, spu_push_dummy_call);
  set_gdbarch_dummy_id (gdbarch, spu_dummy_id);
  set_gdbarch_return_value (gdbarch, spu_return_value);

  /* Frame handling.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  frame_unwind_append_unwinder (gdbarch, &spu_frame_unwind);
  frame_base_set_default (gdbarch, &spu_frame_base);
  set_gdbarch_unwind_pc (gdbarch, spu_unwind_pc);
  set_gdbarch_unwind_sp (gdbarch, spu_unwind_sp);
  set_gdbarch_virtual_frame_pointer (gdbarch, spu_virtual_frame_pointer);
  set_gdbarch_frame_args_skip (gdbarch, 0);
  set_gdbarch_skip_prologue (gdbarch, spu_skip_prologue);
  set_gdbarch_in_function_epilogue_p (gdbarch, spu_in_function_epilogue_p);

  /* Cell/B.E. cross-architecture unwinder support.  */
  frame_unwind_prepend_unwinder (gdbarch, &spu2ppu_unwind);

  /* Breakpoints.  */
  set_gdbarch_decr_pc_after_break (gdbarch, 4);
  set_gdbarch_breakpoint_from_pc (gdbarch, spu_breakpoint_from_pc);
  set_gdbarch_memory_remove_breakpoint (gdbarch, spu_memory_remove_breakpoint);
  set_gdbarch_cannot_step_breakpoint (gdbarch, 1);
  set_gdbarch_software_single_step (gdbarch, spu_software_single_step);
  set_gdbarch_get_longjmp_target (gdbarch, spu_get_longjmp_target);

  /* Overlays.  */
  set_gdbarch_overlay_update (gdbarch, spu_overlay_update);

  return gdbarch;
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_spu_tdep;

void
_initialize_spu_tdep (void)
{
  register_gdbarch_init (bfd_arch_spu, spu_gdbarch_init);

  /* Add ourselves to objfile event chain.  */
  observer_attach_new_objfile (spu_overlay_new_objfile);
  spu_overlay_data = register_objfile_data ();

  /* Install spu stop-on-load handler.  */
  observer_attach_new_objfile (spu_catch_start);

  /* Add ourselves to normal_stop event chain.  */
  observer_attach_normal_stop (spu_attach_normal_stop);

  /* Add root prefix command for all "set spu"/"show spu" commands.  */
  add_prefix_cmd ("spu", no_class, set_spu_command,
		  _("Various SPU specific commands."),
		  &setspucmdlist, "set spu ", 0, &setlist);
  add_prefix_cmd ("spu", no_class, show_spu_command,
		  _("Various SPU specific commands."),
		  &showspucmdlist, "show spu ", 0, &showlist);

  /* Toggle whether or not to add a temporary breakpoint at the "main"
     function of new SPE contexts.  */
  add_setshow_boolean_cmd ("stop-on-load", class_support,
                          &spu_stop_on_load_p, _("\
Set whether to stop for new SPE threads."),
                           _("\
Show whether to stop for new SPE threads."),
                           _("\
Use \"on\" to give control to the user when a new SPE thread\n\
enters its \"main\" function.\n\
Use \"off\" to disable stopping for new SPE threads."),
                          NULL,
                          show_spu_stop_on_load,
                          &setspucmdlist, &showspucmdlist);

  /* Toggle whether or not to automatically flush the software-managed
     cache whenever SPE execution stops.  */
  add_setshow_boolean_cmd ("auto-flush-cache", class_support,
                          &spu_auto_flush_cache_p, _("\
Set whether to automatically flush the software-managed cache."),
                           _("\
Show whether to automatically flush the software-managed cache."),
                           _("\
Use \"on\" to automatically flush the software-managed cache\n\
whenever SPE execution stops.\n\
Use \"off\" to never automatically flush the software-managed cache."),
                          NULL,
                          show_spu_auto_flush_cache,
                          &setspucmdlist, &showspucmdlist);

  /* Add root prefix command for all "info spu" commands.  */
  add_prefix_cmd ("spu", class_info, info_spu_command,
		  _("Various SPU specific commands."),
		  &infospucmdlist, "info spu ", 0, &infolist);

  /* Add various "info spu" commands.  */
  add_cmd ("event", class_info, info_spu_event_command,
	   _("Display SPU event facility status.\n"),
	   &infospucmdlist);
  add_cmd ("signal", class_info, info_spu_signal_command,
	   _("Display SPU signal notification facility status.\n"),
	   &infospucmdlist);
  add_cmd ("mailbox", class_info, info_spu_mailbox_command,
	   _("Display SPU mailbox facility status.\n"),
	   &infospucmdlist);
  add_cmd ("dma", class_info, info_spu_dma_command,
	   _("Display MFC DMA status.\n"),
	   &infospucmdlist);
  add_cmd ("proxydma", class_info, info_spu_proxydma_command,
	   _("Display MFC Proxy-DMA status.\n"),
	   &infospucmdlist);
}
@


1.89
log
@-Wpointer-sign: char -> gdb_byte.

-Wpointer-sign catches all these cases across the codebase that should
be using gdb_byte for raw target bytes.  I think these are all
obvious, hence I've collapsed into a single patch.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* aarch64-tdep.c (aarch64_default_breakpoint): Change type to
	gdb_byte[].
	(aarch64_breakpoint_from_pc): Change return type to gdb_byte *.
	* ada-lang.c (ada_value_assign): Use gdb_byte.
	* alphanbsd-tdep.c (sigtramp_retcode): Change type to gdb_byte[].
	(alphanbsd_sigtramp_offset): Use gdb_byte.
	* arm-linux-tdep.c (arm_linux_arm_le_breakpoint)
	(arm_linux_arm_be_breakpoint, eabi_linux_arm_le_breakpoint)
	(eabi_linux_arm_be_breakpoint, arm_linux_thumb_be_breakpoint)
	(arm_linux_thumb_le_breakpoint, arm_linux_thumb2_be_breakpoint)
	(arm_linux_thumb2_le_breakpoint): Change type to gdb_byte[].
	* arm-tdep.c (arm_stub_unwind_sniffer)
	(arm_displaced_init_closure): Use gdb_byte.
	(arm_default_arm_le_breakpoint, arm_default_arm_be_breakpoint)
	(arm_default_thumb_le_breakpoint)
	(arm_default_thumb_be_breakpoint): Change type to gdb_byte[].
	* arm-tdep.h (struct gdbarch_tdep) <arm_breakpoint,
	thumb_breakpoint, thumb2_breakpoint>: Change type to gdb_byte *.
	* arm-wince-tdep.c (arm_wince_le_breakpoint)
	(arm_wince_thumb_le_breakpoint): Change type to gdb_byte[].
	* armnbsd-tdep.c (arm_nbsd_arm_le_breakpoint)
	(arm_nbsd_arm_be_breakpoint, arm_nbsd_thumb_le_breakpoint)
	(arm_nbsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* armobsd-tdep.c (arm_obsd_thumb_le_breakpoint)
	(arm_obsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* cris-tdep.c (push_stack_item, cris_push_dummy_call)
	(cris_store_return_value, cris_extract_return_value): Use
	gdb_byte.
	(constraint): Change type of parameter to char * from signed
	char*.  Use gdb_byte.
	* dwarf2loc.c (read_pieced_value, write_pieced_value): Change type
	of local buffer to gdb_byte *.
	* dwarf2read.c (read_index_from_section): Use gdb_byte.
	(create_dwp_hash_table): Change type of locals to gdb_byte *.
	(add_address_entry): Change type of local buffer to gdb_byte[].
	* frv-tdep.c (frv_adjust_breakpoint_address, find_func_descr)
	(frv_push_dummy_call): Use gdb_byte.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code)
	(hppa_hpux_supply_ss_fpblock, hppa_hpux_supply_ss_wide)
	(hppa_hpux_supply_save_state): Use gdb_byte.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_convert_code_addr_to_fptr): Use gdb_byte.
	* ia64-tdep.c (extract_bit_field, replace_bit_field)
	(slotN_contents, replace_slotN_contents): Change type of parameter
	to gdb_byte *.
	(fetch_instruction, ia64_pseudo_register_write)
	(ia64_register_to_value, ia64_value_to_register)
	(ia64_extract_return_value, ia64_store_return_value)
	(ia64_push_dummy_call): Use gdb_byte.
	* m32c-tdep.c (m32c_return_value): Remove cast.
	* m68hc11-tdep.c (m68hc11_pseudo_register_write)
	(m68hc11_push_dummy_call, m68hc11_store_return_value): Use
	gdb_byte.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Use gdb_byte.
	* mn10300-tdep.c (mn10300_store_return_value)
	(mn10300_breakpoint_from_pc, mn10300_push_dummy_call): Use
	gdb_byte.
	* moxie-tdep.c (moxie_process_readu): Use gdb_byte.
	(moxie_process_record): Remove casts.
	* ppc-ravenscar-thread.c (supply_register_at_address)
	(ppc_ravenscar_generic_store_registers): Use gdb_byte.
	* ravenscar-thread.c (get_running_thread_id): Use gdb_byte.
	* remote-m32r-sdi.c (m32r_fetch_register): Use gdb_byte.
	* remote-mips.c (mips_xfer_memory): Use gdb_byte.
	* remote.c (compare_sections_command): Use gdb_byte.
	* score-tdep.c (score7_free_memblock): Change type of parameter to
	gdb_byte *.
	* sh-tdep.c (sh_justify_value_in_reg): Change return type to
	gdb_byte *.  Use gdb_byte.
	(sh_push_dummy_call_fpu): Use gdb_byte.
	(sh_extract_return_value_nofpu, sh_extract_return_value_fpu)
	(sh_store_return_value_nofpu, sh_store_return_value_fpu)
	(sh_register_convert_to_virtual, sh_register_convert_to_raw):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh_pseudo_register_read, sh_pseudo_register_write): Use gdb_byte.
	* sh64-tdep.c (sh64_push_dummy_call): Use gdb_byte.
	(sh64_store_return_value, sh64_register_convert_to_virtual):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh64_pseudo_register_write): Use gdb_byte.
	* solib-darwin.c (darwin_current_sos): Add casts to 'gdb_byte *'.
	* solib-irix.c (fetch_lm_info): Likewise.  Use gdb_byte for byte
	buffer.
	(irix_current_sos): Use gdb_byte.
	* solib-som.c (som_current_sos): Use gdb_byte.
	* sparc-ravenscar-thread.c (supply_register_at_address)
	(sparc_ravenscar_generic_store_registers): Use gdb_byte.
	* spu-multiarch.c (spu_xfer_partial): Add cast to 'char *'.
	* spu-tdep.c (spu_get_overlay_table): Use gdb_byte.
	* tic6x-tdep.c (tic6x_breakpoint_from_pc): Change return type to
	'gdb_byte *'.
	* tic6x-tdep.h (struct gdbarch_tdep) <breakpoint>: Change type to
	'gdb_byte *'.
	* tracepoint.c (tfile_fetch_registers): Use gdb_byte.
	* xstormy16-tdep.c (xstormy16_extract_return_value)
	(xstormy16_store_return_value): Change parameter type to
	'gdb_byte *'.  Adjust.
	(xstormy16_push_dummy_call): Use gdb_byte.
	* xtensa-tdep.c (xtensa_scan_prologue, call0_ret)
	(call0_analyze_prologue, execute_code): Use gdb_byte.
@
text
@d195 1
d205 2
a206 1
  store_unsigned_integer (buf, 4, byte_order, strtoulst (reg, NULL, 16));
d259 1
a259 1
  gdb_byte reg[32];
d268 1
a268 1
		reg, 0, strlen (reg));
d2050 1
a2050 1
  event_status = strtoulst (buf, NULL, 16);
d2058 1
a2058 1
  event_mask = strtoulst (buf, NULL, 16);
d2117 1
a2117 1
  signal1_type = strtoulst (buf, NULL, 16);
d2135 1
a2135 1
  signal2_type = strtoulst (buf, NULL, 16);
@


1.88
log
@Add missing empty line in spu_write_pc.

gdb/ChangeLog:

        * spu-tdep.c (spu_write_pc): Add empty line after local variable
        declarations.
@
text
@d1752 1
a1752 1
  char *ovly_table;
@


1.87
log
@	PR symtab/8424:
	* blockframe.c (find_pc_partial_function_gnu_ifunc): Check
	SYMBOL_SECTION, not SYMBOL_OBJ_SECTION.
	* breakpoint.c (resolve_sal_pc): Update.
	* elfread.c (elf_gnu_ifunc_record_cache): Update.
	* findvar.c (struct minsym_lookup_data) <objfile>: New field.
	(minsym_lookup_iterator_cb): Use it.
	(default_read_var_value): Update.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline):
	Update.
	* infcmd.c (jump_command): Update.
	* linespec.c (minsym_found): Update.
	* maint.c (maintenance_translate_address): Update.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Update.
	(prim_record_minimal_symbol_full): Don't set SYMBOL_OBJ_SECTION.
	* parse.c (write_exp_msymbol): Update.
	* printcmd.c (address_info): Update.
	* psymtab.c (find_pc_sect_psymbol): Update.
	(fixup_psymbol_section): Check SYMBOL_SECTION, not
	SYMBOL_OBJ_SECTION.
	(add_psymbol_to_bcache): Correctly initialize SYMBOL_SECTION.
	Don't initialize SYMBOL_OBJ_SECTION.
	* spu-tdep.c (spu_catch_start): Update.
	* stabsread.c (define_symbol): Don't set SYMBOL_SECTION.
	* symmisc.c (dump_msymbols, print_symbol): Update.
	* symtab.c (fixup_section): Don't set 'obj_section'.  Change
	how fallback section is computed.
	(fixup_symbol_section): Update.
	(find_pc_sect_symtab, find_function_start_sal, skip_prologue_sal):
	Update.
	(allocate_symbol, initialize_symbol, allocate_template_symbol):
	Initialize SYMBOL_SECTION.
	* symtab.h (struct general_symbol_info) <section>: Update comment.
	<obj_section>: Remove.
	(SYMBOL_OBJ_SECTION): Add 'objfile' argument.  Rewrite.
	(SYMBOL_OBJFILE): New macro.
@
text
@d1138 1
@


1.86
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d1923 1
a1923 1
  symtab = find_pc_sect_symtab (pc, SYMBOL_OBJ_SECTION (minsym));
@


1.85
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d2 1
a2 1
   Copyright (C) 2006-2012 Free Software Foundation, Inc.
@


1.84
log
@        * amd64-tdep.c (amd64_return_value): Revert previous change
        that used TYPE_LENGTH directly.
        * bfin-tdep.c (bfin_extract_return_value): Likewise.
        (bfin_store_return_value): Likewise.
        * cris-tdep.c (cris_store_return_value): Likewise.
        (cris_extract_return_value): Likewise.
        * h8300-tdep.c (h8300_extract_return_value): Likewise.
        * hppa-tdep.c (hppa64_return_value): Likewise.
        * lm32-tdep.c (lm32_store_return_value): Likewise.
        * microblaze-tdep.c (microblaze_store_return_value): Likewise.
        * spu-tdep.c (spu_value_from_register): Likewise.
        * vax-tdep.c (vax_return_value): Likewise.
@
text
@d1189 1
a1189 1
  if (gdbarch_bfd_arch_info (target_gdbarch)->arch == bfd_arch_spu)
d1220 1
a1220 1
	  regcache = get_thread_arch_regcache (inferior_ptid, target_gdbarch);
@


1.83
log
@        * amd64-tdep.c (amd64_return_value): Use TYPE_LENGTH directly.
        * bfin-tdep.c (bfin_extract_return_value): Likewise.
        (bfin_store_return_value): Likewise.
        * cris-tdep.c (cris_store_return_value): Likewise.
        (cris_extract_return_value): Likewise.
        * h8300-tdep.c (h8300_extract_return_value): Likewise.
        * hppa-tdep.c (hppa64_return_value): Likewise.
        * lm32-tdep.c (lm32_store_return_value): Likewise.
        * microblaze-tdep.c (microblaze_store_return_value): Likewise.
        * spu-tdep.c (spu_value_from_register): Likewise.
        * vax-tdep.c (vax_return_value): Likewise.
@
text
@d319 1
d321 1
a321 1
  if (regnum < SPU_NUM_GPRS && TYPE_LENGTH (type) < 16)
d323 1
a323 1
      int preferred_slot = TYPE_LENGTH (type) < 4 ? 4 - TYPE_LENGTH (type) : 0;
@


1.82
log
@	* m2-valprint.c (m2_print_array_contents): Eliminate variable
	ELTLEN and use TYPE_LENGTH directly.
	(m2_val_print): Likewise.
	* m68k-tdep.c (m68k_svr4_extract_return_value): Eliminate
	variable LEN and use TYPE_LENGTH directly.
	(m68k_svr4_store_return_value): Likewise.
	* mips-tdep.c (mips_o32_push_dummy_call): Eliminate variable
	ARGLEN and use TYPE_LENGTH directly.
	(mips_o64_push_dummy_call): Likewise.
	* s390-tdep (s390_function_arg_pass_by_reference): Eliminate
	variable LENGTH and use TYPE_LENGTH directly.
	(s390_function_arg_float): Likewise.
	(s390_function_arg_integer): Likewise.
	(s390_push_dummy_call): Likewise.
	(s390_return_value_convention): Likewise.
	* spu-tdep.c (spu_push_dummy_call): Eliminate LEN and use
	TYPE_LENGTH directly.
@
text
@a318 1
  int len = TYPE_LENGTH (type);
d320 1
a320 1
  if (regnum < SPU_NUM_GPRS && len < 16)
d322 1
a322 1
      int preferred_slot = len < 4 ? 4 - len : 0;
@


1.81
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d1376 1
a1376 2
      int len = TYPE_LENGTH (type);
      int n_regs = align_up (len, 16) / 16;
@


1.80
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@d852 1
a852 1
  int rt, ra, rb, rc, immed;
d2035 1
a2035 1
  int rc, id;
d2092 1
a2092 1
  int rc, id;
d2213 1
a2213 1
  int i, id;
d2361 1
a2361 1
      int lsa, size, list_lsa, list_size, mfc_lsa, mfc_size;
d2455 1
a2455 1
  int i, id;
d2534 1
a2534 1
  int i, id;
@


1.79
log
@gdb/
	* spu-tdep.c (spu_catch_start): Update create_breakpoint caller
	parameters.
@
text
@d1453 1
a1453 1
spu_return_value (struct gdbarch *gdbarch, struct type *func_type,
d1457 1
@


1.78
log
@2012-03-13  Hui Zhu  <teawater@@gmail.com>
	    Pedro Alves  <palves@@redhat.com>

	* breakpoint.c (init_breakpoint_sal): New flags parameter.  Handle
	CREATE_BREAKPOINT_FLAGS_INSERTED.
	(create_breakpoint_sal, create_breakpoints_sal)
	(base_breakpoint_create_breakpoints_sal)
	(tracepoint_create_breakpoints_sal)
	(strace_marker_create_breakpoints_sal): New flags parameter.  Pass
	down.
	(break_command_1, handle_gnu_v3_exceptions, trace_command)
	(ftrace_command, strace_command): Adjust.
	(create_tracepoint_from_upload): Pass
	CREATE_BREAKPOINT_FLAGS_INSERTED.
	* breakpoint.h (enum breakpoint_create_flags): New.
	(create_breakpoint): New flags parameter.
	* mi/mi-cmd-break.c (mi_cmd_break_insert): Adjust.
	* python/py-breakpoint.c (bppy_init): Adjust.
	* python/py-finishbreakpoint.c (bpfinishpy_init): Adjust.
	* spu-tdep.c (spu_catch_start): Adjust.
@
text
@d1945 1
@


1.77
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1950 1
a1950 1
		     1 /* enabled */, 0 /* internal  */);
@


1.76
log
@	* spu-tdep.c (spu_return_value): Fix handling of
	TYPE_CALLING_CONVENTION annotation.
@
text
@d2 1
a2 2
   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.76.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright (C) 2006-2012 Free Software Foundation, Inc.
@


1.76.2.2
log
@2012-03-13  Hui Zhu  <teawater@@gmail.com>
	    Pedro Alves  <palves@@redhat.com>

	* breakpoint.c (init_breakpoint_sal): New flags parameter.  Handle
	CREATE_BREAKPOINT_FLAGS_INSERTED.
	(create_breakpoint_sal, create_breakpoints_sal)
	(create_breakpoint): New flags parameter.  Pass it down.
	(break_command_1, handle_gnu_v3_exceptions, trace_command)
	(ftrace_command, strace_command): Adjust.
	(create_tracepoint_from_upload): Pass
	CREATE_BREAKPOINT_FLAGS_INSERTED.
	* breakpoint.h (enum breakpoint_create_flags): New.
	(create_breakpoint): New flags parameter.
	* mi/mi-cmd-break.c (mi_cmd_break_insert): Adjust.
	* python/py-breakpoint.c (bppy_init): Adjust.
	* python/py-finishbreakpoint.c (bpfinishpy_init): Adjust.
	* spu-tdep.c (spu_catch_start): Adjust.
@
text
@d1950 1
a1950 1
		     1 /* enabled */, 0 /* internal  */, 0);
@


1.75
log
@	* spu-tdep.c (spu_catch_start): Pass non-NULL breakpoint ops
	to create_breakpoint.
@
text
@d1461 13
a1473 5
  if (func_type
      && TYPE_CALLING_CONVENTION (func_type) == DW_CC_GDB_IBM_OpenCL
      && TYPE_CODE (type) == TYPE_CODE_ARRAY
      && TYPE_VECTOR (type))
    opencl_vector = 1;
@


1.74
log
@gdb/
	* spu-tdep.c (info_spu_event_command, info_spu_signal_command)
	(info_spu_mailbox_list, info_spu_mailbox_command, info_spu_dma_cmdlist)
	(info_spu_dma_command, info_spu_proxydma_command): Rename uiout
	references to current_uiout.
@
text
@d1942 2
a1943 2
		     NULL /* ops */, 0 /* from_tty */, 1 /* enabled */,
		     0 /* internal  */);
@


1.73
log
@ChangeLog:

	* ppc-linux-tdep.c (ppu2spu_prev_register): Handle pseudo registers.
	(ppu2spu_unwind_register): Mark pseudo registers unavailable.
	* spu-tdep.c (op_selb): Use correct value.

testsuite/ChangeLog:

	* gdb.cell/bt.exp: Delete breakpoints before running to signal
	to avoid race condition.
	* gdb.cell/coremaker.c: Use small stack size.
	* gdb.cell/ea-standalone.exp: Use file name without path as
	argument to c_to.
	* gdb.cell/fork.exp: Allow other output when continuing to end.
@
text
@d2049 1
a2049 1
  chain = make_cleanup_ui_out_tuple_begin_end (uiout, "SPUInfoEvent");
d2051 1
a2051 1
  if (ui_out_is_mi_like_p (uiout))
d2053 1
a2053 1
      ui_out_field_fmt (uiout, "event_status",
d2055 1
a2055 1
      ui_out_field_fmt (uiout, "event_mask",
d2126 1
a2126 1
  chain = make_cleanup_ui_out_tuple_begin_end (uiout, "SPUInfoSignal");
d2128 1
a2128 1
  if (ui_out_is_mi_like_p (uiout))
d2130 6
a2135 6
      ui_out_field_int (uiout, "signal1_pending", signal1_pending);
      ui_out_field_fmt (uiout, "signal1", "0x%s", phex_nz (signal1, 4));
      ui_out_field_int (uiout, "signal1_type", signal1_type);
      ui_out_field_int (uiout, "signal2_pending", signal2_pending);
      ui_out_field_fmt (uiout, "signal2", "0x%s", phex_nz (signal2, 4));
      ui_out_field_int (uiout, "signal2_type", signal2_type);
d2173 1
a2173 1
  chain = make_cleanup_ui_out_table_begin_end (uiout, 1, nr, "mbox");
d2175 2
a2176 2
  ui_out_table_header (uiout, 32, ui_left, field, msg);
  ui_out_table_body (uiout);
d2182 1
a2182 1
      val_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "mbox");
d2184 1
a2184 1
      ui_out_field_fmt (uiout, field, "0x%s", phex (val, 4));
d2187 1
a2187 1
      if (!ui_out_is_mi_like_p (uiout))
d2211 1
a2211 1
  chain = make_cleanup_ui_out_tuple_begin_end (uiout, "SPUInfoMailbox");
d2329 2
a2330 1
  chain = make_cleanup_ui_out_table_begin_end (uiout, 10, nr, "dma_cmd");
d2332 10
a2341 10
  ui_out_table_header (uiout, 7, ui_left, "opcode", "Opcode");
  ui_out_table_header (uiout, 3, ui_left, "tag", "Tag");
  ui_out_table_header (uiout, 3, ui_left, "tid", "TId");
  ui_out_table_header (uiout, 3, ui_left, "rid", "RId");
  ui_out_table_header (uiout, 18, ui_left, "ea", "EA");
  ui_out_table_header (uiout, 7, ui_left, "lsa", "LSA");
  ui_out_table_header (uiout, 7, ui_left, "size", "Size");
  ui_out_table_header (uiout, 7, ui_left, "lstaddr", "LstAddr");
  ui_out_table_header (uiout, 7, ui_left, "lstsize", "LstSize");
  ui_out_table_header (uiout, 1, ui_left, "error_p", "E");
d2343 1
a2343 1
  ui_out_table_body (uiout);
d2384 1
a2384 1
      cmd_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "cmd");
d2387 1
a2387 1
	ui_out_field_string (uiout, "opcode", spu_mfc_opcode[mfc_cmd_opcode]);
d2389 1
a2389 1
	ui_out_field_int (uiout, "opcode", mfc_cmd_opcode);
d2391 3
a2393 3
      ui_out_field_int (uiout, "tag", mfc_cmd_tag);
      ui_out_field_int (uiout, "tid", tclass_id);
      ui_out_field_int (uiout, "rid", rclass_id);
d2396 1
a2396 1
	ui_out_field_fmt (uiout, "ea", "0x%s", phex (mfc_ea, 8));
d2398 1
a2398 1
	ui_out_field_skip (uiout, "ea");
d2400 1
a2400 1
      ui_out_field_fmt (uiout, "lsa", "0x%05x", mfc_lsa << 4);
d2402 1
a2402 1
	ui_out_field_fmt (uiout, "size", "0x%05x", mfc_size << 4);
d2404 1
a2404 1
	ui_out_field_fmt (uiout, "size", "0x%05x", mfc_size);
d2408 2
a2409 2
	  ui_out_field_fmt (uiout, "lstaddr", "0x%05x", list_lsa << 3);
	  ui_out_field_fmt (uiout, "lstsize", "0x%05x", list_size << 3);
d2413 2
a2414 2
	  ui_out_field_skip (uiout, "lstaddr");
	  ui_out_field_skip (uiout, "lstsize");
d2418 1
a2418 1
	ui_out_field_string (uiout, "error_p", "*");
d2420 1
a2420 1
	ui_out_field_skip (uiout, "error_p");
d2424 1
a2424 1
      if (!ui_out_is_mi_like_p (uiout))
d2470 1
a2470 1
  chain = make_cleanup_ui_out_tuple_begin_end (uiout, "SPUInfoDMA");
d2472 1
a2472 1
  if (ui_out_is_mi_like_p (uiout))
d2474 1
a2474 1
      ui_out_field_fmt (uiout, "dma_info_type", "0x%s",
d2476 1
a2476 1
      ui_out_field_fmt (uiout, "dma_info_mask", "0x%s",
d2478 1
a2478 1
      ui_out_field_fmt (uiout, "dma_info_status", "0x%s",
d2480 1
a2480 1
      ui_out_field_fmt (uiout, "dma_info_stall_and_notify", "0x%s",
d2482 1
a2482 1
      ui_out_field_fmt (uiout, "dma_info_atomic_command_status", "0x%s",
d2542 2
a2543 1
  chain = make_cleanup_ui_out_tuple_begin_end (uiout, "SPUInfoProxyDMA");
d2545 1
a2545 1
  if (ui_out_is_mi_like_p (uiout))
d2547 1
a2547 1
      ui_out_field_fmt (uiout, "proxydma_info_type", "0x%s",
d2549 1
a2549 1
      ui_out_field_fmt (uiout, "proxydma_info_mask", "0x%s",
d2551 1
a2551 1
      ui_out_field_fmt (uiout, "proxydma_info_status", "0x%s",
@


1.72
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d459 1
a459 1
    op_selb  = 0x4,
@


1.72.2.1
log
@ChangeLog:

	* ppc-linux-tdep.c (ppu2spu_prev_register): Handle pseudo registers.
	(ppu2spu_unwind_register): Mark pseudo registers unavailable.
	* spu-tdep.c (op_selb): Use correct value.

testsuite/ChangeLog:

	* gdb.cell/bt.exp: Delete breakpoints before running to signal
	to avoid race condition.
	* gdb.cell/coremaker.c: Use small stack size.
	* gdb.cell/ea-standalone.exp: Use file name without path as
	argument to c_to.
	* gdb.cell/fork.exp: Allow other output when continuing to end.
@
text
@d459 1
a459 1
    op_selb  = 0x8,
@


1.71
log
@	gdb/
	* dwarf2loc.c (read_pieced_value): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	(write_pieced_value): Handle get_frame_register_bytes returning
	that the register piece is unavailable/optimized out when doing a
	read-modify write of a bitfield.
	* findvar.c (value_from_register): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	* frame.c (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.  Throw error on bad debug info.  Use
	frame_register instead of frame_register_read, to fill in the new
	arguments.
	* frame.h (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.
	* valops.c: (value_assign): Adjust, and handle
	get_frame_register_bytes failing.
	* spu-tdep.c: Include exceptions.h.
	(spu_software_single_step): Adjust, and handle
	get_frame_register_bytes failing.
	(spu_get_longjmp_target): Ditto.
	* gdbarch.sh (register_to_value): Change to return int.  New
	parameters `optimizedp' and `unavailablep'.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.c (i386_register_to_value): Adjust to new
	gdbarch_register_to_value interface.
	* i387-tdep.c (i387_register_to_value): Ditto.
	* i387-tdep.h (i387_register_to_value): Ditto.
	* alpha-tdep.c (alpha_register_to_value): Ditto.
	* ia64-tdep.c (ia64_register_to_value): Ditto.
	* m68k-tdep.c (m68k_register_to_value): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* rs6000-tdep.c (rs6000_register_to_value): Ditto.
@
text
@d1085 1
d1240 1
@


1.70
log
@	gdb/
	* regcache.h (regcache_raw_read, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_part)
	(regcache_cooked_read, regcache_cooked_read_signed)
	(regcache_cooked_read_unsigned, regcache_cooked_read_part)
	(regcache_cooked_read_ftype): Change return to enum
	register_status.
	* regcache.c: Include exceptions.h
	(regcache_save): Adjust to handle REG_UNAVAILABLE registers.
	(do_cooked_read): Change return to enum register_status.  Always
	forward to regcache_cooked_read.
	(regcache_raw_read): Change return to enum register_status.  If
	the register is not REG_VALID, memset the buffer.  Return the
	register's status.
	(regcache_raw_read_signed): Handle non-REG_VALID registers and
	return the register's status.
	(regcache_raw_read_unsigned): Ditto.
	(regcache_cooked_read): Change return to enum register_status.
	Assert that with read-only regcaches, the register's status must
	be known.  If the regcache is read-only, and the register is not
	REG_VALID, memset the buffer.  Return the register's status.
	(regcache_cooked_read_signed): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_cooked_read_unsigned): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_xfer_part, regcache_raw_read_part)
	(regcache_cooked_read_part): Change return to enum
	register_status.  Return the register's status.
	(regcache_read_pc): Throw NOT_AVAILABLE_ERROR if the register is
	unavailable.
	(regcache_dump): Handle unavailable cooked registers.
	* frame.c (do_frame_register_read): Adjust interface to match
	regcache_cooked_read_ftype.
	* gdbarch.sh (pseudo_register_read): Change return to enum
	register_status.
	* gdbarch.h, gdbarch.c: Regenerate.

	* i386-tdep.h (i386_pseudo_register_read): Change return to enum
	register_status.
	* i386-tdep.c (i386_pseudo_register_read): Change return to enum
	register_status.  If reading a raw register indicates the raw
	register is not valid, return the raw register's status,
	otherwise, return REG_VALID.
	* amd64-tdep.c (amd64_pseudo_register_read): Change return to enum
	register_status.  Handle non-REG_VALID raw registers and return
	the register's status.
	* arm-tdep.c (arm_neon_quad_read)
	(arm_pseudo_read): Change return to enum register_status.  Handle
	non-REG_VALID raw registers and return the register's status.
	* avr-tdep.c (avr_pseudo_register_read): Ditto.
	* frv-tdep.c (frv_pseudo_register_read): Ditto.
	* h8300-tdep.c (h8300_pseudo_register_read): Ditto.
	* hppa-tdep.c (hppa_pseudo_register_read): Ditto.
	* m32c-tdep.c (m32c_move_reg_t): Change return to enum
	register_status.
	(m32c_raw_read, m32c_raw_write, m32c_banked_read)
	(m32c_banked_write, m32c_sb_read, m32c_sb_write, m32c_part_read)
	(m32c_part_write, m32c_cat_read, m32c_cat_write)
	(m32c_r3r2r1r0_read, m32c_r3r2r1r0_write)
	(m32c_pseudo_register_read): Change return to enum
	register_status.  Adjust.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* mep-tdep.c (mep_pseudo_cr32_read): Change return to enum
	register_status.  Return the register's status.
	(mep_pseudo_cr64_read, mep_pseudo_register_read): Ditto.
	* mips-tdep.c (mips_pseudo_register_read): Ditto.
	* mt-tdep.c (mt_pseudo_register_read): Ditto.
	* rs6000-tdep.c (move_ev_register_func): New typedef.
	(e500_move_ev_register): Use it.  Change return to enum
	register_status.  Return the register's status.
	(do_regcache_raw_read): New function.
	(do_regcache_raw_write): New function.
	(e500_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.  Use
	do_regcache_raw_read.
	(e500_pseudo_register_write): Adjust.  Use do_regcache_raw_write.
	(dfp_pseudo_register_read): Change return to enum register_status.
	Return the register's status.
	(vsx_pseudo_register_read): Ditto.
	(efpr_pseudo_register_read): Ditto.
	(rs6000_pseudo_register_read): Ditto.
	* s390-tdep.c (s390_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh64-tdep.c (pseudo_register_read_portions): New function.
	(sh64_pseudo_register_read): Change return to enum
	register_status.  Use pseudo_register_read_portions.  Return the
	register's status.
	* ia64-tdep.c (ia64_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh-tdep.c (pseudo_register_read_portions): New function.
	(sh_pseudo_register_read): Change return to enum register_status.
	Use pseudo_register_read_portions.  Return the register's status.
	* sparc-tdep.c (sparc32_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* sparc64-tdep.c (sparc64_pseudo_register_read): Ditto.
	* spu-tdep.c (spu_pseudo_register_read_spu)
	(spu_pseudo_register_read): Ditto.
	* xtensa-tdep.c (xtensa_register_read_masked)
	(xtensa_pseudo_register_read): Ditto.
	* bfin-tdep.c (bfin_pseudo_register_read): Ditto.
@
text
@d48 1
a48 1

d1597 15
a1611 2
	  get_frame_register_bytes (frame, reg, 0, 4, buf);
	  target += extract_unsigned_integer (buf, 4, byte_order) & -4;
d1634 1
d1637 4
a1640 1
  get_frame_register_bytes (frame, SPU_ARG1_REGNUM, 0, 4, buf);
@


1.69
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@d186 1
a186 1
static void
d192 1
d197 3
a199 1
  regcache_raw_read_unsigned (regcache, SPU_ID_REGNUM, &id);
d206 1
d209 1
a209 1
static void
d216 1
d221 3
a223 1
      regcache_raw_read (regcache, SPU_RAW_SP_REGNUM, reg);
d225 1
a225 1
      break;
d228 3
a230 1
      regcache_raw_read_unsigned (regcache, SPU_ID_REGNUM, &id);
d233 1
a233 1
      break;
d236 1
a236 2
      spu_pseudo_register_read_spu (regcache, "srr0", buf);
      break;
d239 1
a239 2
      spu_pseudo_register_read_spu (regcache, "lslr", buf);
      break;
d242 1
a242 2
      spu_pseudo_register_read_spu (regcache, "decr", buf);
      break;
d245 1
a245 2
      spu_pseudo_register_read_spu (regcache, "decr_status", buf);
      break;
@


1.68
log
@include/ChangeLog:

	* dwarf2.h (enum dwarf_calling_convention): Add DW_CC_GDB_IBM_OpenCL.

gdb/ChangeLog:

	* dwarf2read.c (read_subroutine_type): Set special calling
	convention flag for functions compiled by IBM XL C for OpenCL.
	* ppc-sysv-tdep.c: Include "dwarf2.h"
	(ppc_sysv_abi_push_dummy_call): Implement IBM OpenCL vector types
	calling convention.
	(do_ppc_sysv_return_value): Add FUNC_TYPE argument.  Implement
	IBM OpenCL vector types calling convention.
	(ppc_sysv_abi_return_value): Pass through FUNC_TYPE.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_push_dummy_call): Implement IBM OpenCL vector
	types calling convention.
	(ppc64_sysv_abi_return_value): Likewise.
	* spu-tdep.c: Include "dwarf2.h"
	(spu_return_value): Implement IBM OpenCL vector types calling
	convention.

gdb/testsuite/ChangeLog:

	* gdb.opencl/callfuncs.cl: New file.
	* gdb.opencl/callfuncs.exp: New test.
	* gdb.opencl/Makefile.in (EXECUTABLES): Add callfuncs.
@
text
@d358 1
a358 1
     provide an SPU ID.  Retrieve it from the the objfile's relocated
@


1.67
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d47 1
d1452 7
d1470 4
a1473 1
	  spu_value_to_regcache (regcache, SPU_ARG1_REGNUM, type, in);
d1486 4
a1489 1
	  spu_regcache_to_value (regcache, SPU_ARG1_REGNUM, type, out);
@


1.66
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* charset.c (validate): Internationalization.
	* coffread.c (read_one_sym): Ditto.
	* dwarf2read.c (dwarf2_attach_fields_to_type): Ditto.
	* h8300-tdep.c (H8300_extract_return_value): Ditto.
	* inflow.c (new_tty): Ditto.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* mep-tdep.c (mep_store_return_value): Ditto.
	* score-tdep.c (score7_fetch_insn): Ditto.
	* ser-mingw.c (pipe_windows_open): Ditto.
	* sh64-tdep.c (sh64_extract_return_value): Ditto.
	* spu-tdep.c (spu_register_type): Ditto.
	* tracepoint.c (trace_find_command): Ditto.
	* valarith.c (value_pos): Ditto.
@
text
@d817 1
a817 1
      /* ??? We don't really know ... */
d1010 2
a1011 1
	    info->saved_regs[SPU_LR_REGNUM].addr = SPUADDR (id, backchain + 16);
d1491 2
a1492 1
spu_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR * pcptr, int *lenptr)
d1633 3
a1635 2
  /* The opcodes disassembler does 18-bit address arithmetic.  Make sure the
     SPU ID encoded in the high bits is added back when we call print_address.  */
d1669 4
a1672 3
   Both tables are aligned to a 16-byte boundary, the symbols _ovly_table
   and _ovly_buf_table are of type STT_OBJECT and their size set to the size
   of the respective array. buf in _ovly_table is an index into _ovly_buf_table.
d1674 1
a1674 1
   mapped is an index into _ovly_table. Both the mapped and buf indices start
d1717 2
a1718 1
  ovly_buf_table_msym = lookup_minimal_symbol ("_ovly_buf_table", NULL, objfile);
d2540 2
a2541 1
  printf_unfiltered (_("\"info spu\" must be followed by the name of an SPU facility.\n"));
@


1.65
log
@run copyright.sh for 2011.
@
text
@d179 1
a179 1
      internal_error (__FILE__, __LINE__, "invalid regnum");
d1465 1
a1465 1
	  error ("Cannot set function return value.");
d1478 1
a1478 1
	  error ("Function return value unknown.");
@


1.64
log
@gdb/
	* spu-tdep.c (spu_catch_start): Fix compilation error typo.
@
text
@d2 2
a3 1
   Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.63
log
@2010-11-11  Phil Muldoon  <pmuldoon@@redhat.com>

	* python/py-breakpoint.c (BPPY_REQUIRE_VALID): Check if bp is
	NULL.
	(BPPY_SET_REQUIRE_VALID): Ditto.
	(bpnum_is_valid): Delete function.
	(bppy_get_visibility): New function.
	(bppy_new): Parse for, and validate internal keyword.  Pass
	internal keyword to breakpoint or watchpoint functions.
	(build_bp_list): New function.
	(gdbpy_breakpoints): Rewrite.  Use build_bp_list and
	iterate_over_breakpoints.
	(gdbpy_breakpoint_created): Rewrite.  Do not store breakpoints in a
	look-aside vector.
	(gdbpy_breakpoint_deleted): Rewrite, defer breakpoint management
	to internal breakpoint chain.

	* breakpoint.c (set_breakpoint_number): New function.
	(breakpoint_1): Check if breakpoint number is more than zero.
	(set_raw_breakpoint_without_location): Set py_bp_object to NULL.
	(create_breakpoint_sal): Take a new parameter called internal.
	Call set_breakpoint_number with internal parameter.  Do not
	mention internal breakpoints.  All callers updated.
	(create_breakpoint): Ditto.
	(create_breakpoints_sal): Ditto.
	(watch_command_1): Ditto.
	(watch_command_wrapper): Take a new parameter called internal.
	All callers updated.
	(rwatch_command_wrapper): Ditto.
	(awatch_command_wrapper): Ditto.
	(save_breakpoints): Update breakpoint save condition check.
	(iterate_over_breakpoints): New function.
	* breakpoint.h: Add conditional python includes.  Add py_bp_object
	and comment to struct breakpoint.  Update all callers.
	* defs.h: Add PyObject definition for GDB builds without Python.

2010-11-11  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.texinfo (Breakpoints In Python): Document "internal"
	parameter, and visible attribute.


2010-11-11  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.python/py-breakpoint.exp: Add internal watchpoint and
	breakpoint tests.
@
text
@d1899 1
a1899 1
		     0 /* internal  */););
@


1.62
log
@gdb/
	* spu-tdep.c (spu_catch_start): Adjust the caller of changed
	create_breakpoint prototype.
@
text
@d1898 2
a1899 1
		     NULL /* ops */, 0 /* from_tty */, 1 /* enabled */);
@


1.61
log
@ChangeLog:

	* infrun.c (handle_inferior_event): Handle presence of single-step
	breakpoints for TARGET_WAITKIND_FORKED and TARGET_WAITKIND_VFORKED.
	Cancel single-step breakpoints for TARGET_WAITKIND_EXITED,
	TARGET_WAITKIND_SIGNALED, and TARGET_WAITKIND_EXECD.
	* breakpoint.c (detach_single_step_breakpoints): New function.
	(detach_breakpoints): Call it.
	(cancel_single_step_breakpoints): New function.
	* breakpoint.h (cancel_single_step_breakpoints): Add prototype.

	* spu-tdep.c (spu_memory_remove_breakpoint): New function.
	(spu_gdbarch_init): Install it.

testsuite/ChangeLog:

	* gdb.cell/fork.exp: New file.
	* gdb.cell/fork.c: Likewise.
	* gdb.cell/fork-spu.c: Likewise.
@
text
@d1895 1
a1895 1
		     0 /* hardwareflag */, 0 /* traceflag */,
@


1.60
log
@	* spu-tdep.c (spu_frame_unwind_cache): Use LSLR register
	value instead of hard-coded SPU_LS_SIZE.
	(spu_software_single_step): Likewise.
	* spu-tdep.h (SPU_LS_SIZE): Remove.
@
text
@d1497 33
d2674 1
@


1.59
log
@ChangeLog:

	* spu-multiarch.c (spu_xfer_partial): Wrap around local store
	limit on local store memory accesses.
	* spu-linux-nat.c (spu_xfer_partial): Likewise.
	* spu-tdep.c (spu_lslr): Remove.
	(spu_pointer_to_address): Do not truncate addresses.
	(spu_integer_to_address): Likewise.
	(spu_overlay_new_objfile): Use SPU_OVERLAY_LMA.
	* spu-tdep.h: Add comments.
	(SPUADDR_SPU): Respect SPU_OVERLAY_LMA bit.
	(SPU_OVERLAY_LMA): Define.

gdbserver/ChangeLog:

	* spu-low.c (spu_read_memory): Wrap around local store limit.
	(spu_write_memory): Likewise.

testsuite/ChangeLog:

	* gdb.arch/spu-ls.exp: New file.
	* gdb.arch/spu-ls.c: Likewise.
@
text
@d990 1
d993 5
d1005 1
a1005 1
      if (status && backchain > 0 && backchain < SPU_LS_SIZE)
d1008 1
a1008 1
	  if (backchain + 16 < SPU_LS_SIZE)
d1510 1
d1518 5
d1527 1
a1527 1
    next_pc = (SPUADDR_ADDR (pc) + 8) & (SPU_LS_SIZE - 1);
d1529 1
a1529 1
    next_pc = (SPUADDR_ADDR (pc) + 4) & (SPU_LS_SIZE - 1);
d1546 1
a1546 1
      target = target & (SPU_LS_SIZE - 1);
@


1.58
log
@gdb/
	* spu-tdep.c (spu_catch_start): Replace set_breakpoint call with the
	create_breakpoint call, adjust the parameters.
@
text
@a366 17
static ULONGEST
spu_lslr (int id)
{
  gdb_byte buf[32];
  char annex[32];

  if (id == -1)
    return SPU_LS_SIZE - 1;

  xsnprintf (annex, sizeof annex, "%d/lslr", id);
  memset (buf, 0, sizeof buf);
  target_read (&current_target, TARGET_OBJECT_SPU, annex,
	       buf, 0, sizeof buf);

  return strtoulst (buf, NULL, 16);
}

a411 1
  ULONGEST lslr = spu_lslr (id);
d420 1
a420 1
  return addr? SPUADDR (id, addr & lslr) : 0;
a427 1
  ULONGEST lslr = spu_lslr (id);
d430 1
a430 1
  return SPUADDR (id, addr & lslr);
d1761 1
a1761 1
   is larger than local store size.  */
d1791 1
a1791 1
	bfd_section_lma (obfd, bsect) = bsect->filepos + SPU_LS_SIZE;
@


1.57
log
@dwarf2_physname patchset:

	Based on work from Daniel Jacobowitz  <dan@@codesourcery.com>
	* c-typeprint.c (cp_type_print_method_args): For non-static methods,
	print out const or volatile qualifiers, too.
	(c_type_print_args): Add parameters show_artificial and language.
	Skip artificial parameters when requested.
	Use the appropriate language printer.
	(c_type_print_varspec): Tell c_type_print_args to skip artificial
	parameters and pass language_c.
	* dwarf2read.c (die_list): New file global.
	(struct partial_die_info): Update comments for name field.
	(pdi_needs_namespace): Renamed to ...
	(die_needs_namespace): ... this. Rewrite.
	(dwarf2_linkage_name): Remove.
	(add_partial_symbol): Do not predicate the call to
	partial_die_full_name based on pdi_needs_namespace.
	Remove call to cp_check_possible_namespace_symbols and associated
	outdated comments.
	(guess_structure_name): Do not inspect child subprogram DIEs.
	(dwarf2_fullname): Update comments.
	Use die_needs_namespace to assist in computing the name.
	(read_func_scope): Use dwarf2_name to get the DIE's name.
	Use dwarf2_physname to get the "linkage name" of the DIE.
	(dwarf2_add_member_field): Use dwarf2_physname instead of
	dwarf2_linkage_name.
	(read_structure_type): For structs and classes, set TYPE_NAME, too.
	(determine_class): Remove.
	(read_partial_die): Ignore DW_AT_MIPS_linkage_name for all languages
	except Ada.
	(new_symbol): Unconditionally call dwarf2_name.
	Compute the "linkage name" using dwarf2_physname.
	Use dwarf2_name instead of dwarf2_full_name for enumerator DIEs.
	When determining to scan for anonymous C++ namespaces, ignore
	the linkage name.
	(dwarf2_physname): New function.
	(dwarf2_full_name): Move content to new function and call
	that.
	(dwarf2_compute_name): "New" function.
	(_initialize_dwarf2_read): Initialize die_list.
	* gnu-v3-eabi.c (gnu_v3_find_method_in): Remove unused variable
	physname.
	(gnu_v3_print_method_ptr): Use the physname for virtual methods
	without a demangled name.
	Print out type information for non-virtual methods.
        * linespec.c (decode_line_1): Force ANY string using "::" (or
	"." for java) to use decode_compound, and clean up any stray quoting.
        If we found a file symtab, re-evaluate whether the remainder is_quoted.
        (decode_compound): Stop consuming at an open parenthesis.
        Keep template parameters.
        Keep any overload information.
        Keep keywords like "const".
        Remove paren_pointer.
        Move is_quoted check from set_flags to here.
        Remove #if 0 code from 2000. Ten years is long enough.
        (find_method): Before comparing symbol names, canonicalize the string
        from the user.
        If a specific overload is requested, find it. Otherwise throw an error.
	(find_method_overload_end): New function.
	(set_flags): Remove.
        (decode_compound): Assume that parentheses are matched.
        It's a lot easier.
	* symtab.c (symbol_find_demangled_name): Add DMGL_VERBOSE flag
	to cplus_demangle.
	* linespec.c (decode_line_1): Keep important keywords like
	"const" and "volatile".
	* symtab.h (SYMBOL_CPLUS_DEMANGLED_NAME): Remove.
	* typeprint.h (c_type_print_args): Add declaration.
	* ui-file.c (do_ui_file_obsavestring): New function.
	(ui_file_obsavestring): New function.
	* ui-file.h (ui_file_obsavestring): Add declaration.
	* valops.c (find_overload_match): Resolve the object to
	a non-pointer type.
	If the object is a data member, search the object for the member
	and return with staticp set.
	Use SYMBOL_NATURAL_NAME instead of SYMBOL_CPLUS_DEMANGLED_NAME.
	Do not attempt to extract a function name from non-function types.
	If the extracted function name and the original name are the same,
	we don't have a C++ method.

	From Jan Kratochvil  <jan.kratochvil@@redhat.com>:
    	* dwarf2read.c (new_symbol <DW_TAG_enumerator>): Call dwarf2_full_name.

	* ada-lang.c (ada_lookup_symbol): Remove linkage_name parameters
	and arguments from symbol lookups.
	* ax-gdb.c (gen_expr): Likewise.
	* cp-namespace.c (cp_lookup_symbol_nonlocal, lookup_namespace_scope,
	cp_lookup_symbol_namespace, lookup_symbol_file, lookup_nested_type,
	lookup_possible_namespace_symbol): Likewise.
	* cp-support.c (read_in_psymtabs): Likewise.
	* cp-support.h (cp_lookup_symbol_nonlocal): Likewise.
	* language.h (la_lookup_symbol_nonlocal): Likewise.
	* scm-valprint.c (scm_inferior_print): Likewise.
	* solib-darwin.c (darwin_relocate_section_addresses): Likewise.
	* solib-svr.c (elf_lookup_lib): Likewise.
	* solib.c (show_auto_solib_add): Likewise.
	* solist.h (lookup_lib_global, solib_global_lookup): Likewise.
	* symmisc.c (maintenance_check_symtabs): Likewise.
	* symtab.c (lookup_symbol_in_language, lookup_symbol_aux,
	lookup_symbol_aux_local, lookup_symbol_aux_block,
	lookup_symbol_from_objfile, lookup_symbol_aux_symtabs,
	lookup_symbol_aux_psymtabs,basic_lookup_symbol_nonlocal,
	lookup_symbol_static, lookup_symbol_global, symbol_matches_domain,
	basic_lookup_transparent_type, find_main_psymtab,
	lookup_block_symbol): Likewise.
	* symtab.h (basic_lookp_symbol_nonlocal, lookup_symbol_static,
	lookup_symbol_global, lookup_symbol_aux_block,
	lookup_symbol_partial_symbol, lookup_block_symbol,
	lookup_global_symbol, value_maybe_namespace_elt): Likewise.
@
text
@d1866 7
a1872 5
  set_breakpoint (get_objfile_arch (objfile),
		  buf, NULL /* condition */,
		  0 /* hardwareflag */, 1 /* tempflag */,
		  -1 /* thread */, 0 /* ignore_count */,
		  0 /* pending */, 1 /* enabled */);
@


1.56
log
@	* spu-tdep.c (spu_analyze_prologue): Track instruction to
	store backchain as part of prologue.
@
text
@d1854 1
a1854 1
      sym = lookup_block_symbol (block, "main", NULL, VAR_DOMAIN);
@


1.55
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d636 1
d665 1
d667 1
a667 1
     We return the instruction after the latest of these three,
d776 8
@


1.54
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d2 1
a2 1
   Copyright (C) 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.53
log
@ChangeLog:

	* spu-tdep.c: Include "infcall.h".
	(spu_address_class_type_flags): New function.
	(spu_address_class_type_flags_to_name): Likewise.
	(spu_address_class_name_to_type_flags): Likewise.
	(spu_pointer_to_address): Handle __ea pointers.
	(spu_auto_flush_cache_p): New static variable.
	(spu_objfile_from_frame): New function.
	(flush_ea_cache, spu_attach_normal_stop): Likewise.
	(show_spu_auto_flush_cache): Likewise.
	(spu_gdbarch_init): Install address class handlers.
	(_initialize_spu_tdep): Attach to normal_stop observer.
	Install "set spu auto-flush-cache" / "show spu auto-flush-cache"
	commands.

	* NEWS: Mention "set/show spu auto-flush-cache" commands.

doc/ChangeLog:

	* gdb.texinfo (Cell Broadband Engine SPU architecture): Document the
	"set spu auto-flush-cache" and "show spu auto-flush-cache" commands.
@
text
@d1507 1
d1528 2
a1529 1
  insert_single_step_breakpoint (gdbarch, SPUADDR (SPUADDR_SPU (pc), next_pc));
d1545 1
a1545 1
	insert_single_step_breakpoint (gdbarch,
@


1.52
log
@ChangeLog:

	* spu-tdep.c: Include "block.h".
	(setspucmdlist, showspucmdlist): New static variables.
	(spu_stop_on_load_p): Likewise.
	(spu_catch_start): New function.
	(show_spu_command, set_spu_command): New functions.
	(show_spu_stop_on_load): Likewise.
	(_initialize_spu_tdep): Attach spu_catch_start to new_objfile observer.
	Install "set spu" / "show spu" prefix command handler.
	Install "set spu stop-on-load" / "show spu stop-on-load" command.

	* NEWS: Mention "set/show spu stop-on-load" commands.

doc/ChangeLog:

	* gdb.texinfo (Cell Broadband Engine SPU architecture): Document the
	"set spu stop-on-load" and "show spu stop-on-load" commands.
@
text
@d45 1
d56 2
d346 2
a347 1
/* Address conversion.  */
d384 31
d434 4
d1862 67
d2520 8
d2597 1
a2597 1
  /* Address conversion.  */
d2601 6
d2659 3
d2685 15
@


1.51
log
@	* ppc-linux-tdep.c: Include "solib.h", "solist.h", "exceptions.h",
	"arch-utils.h", and "spu-tdep.h".
	(spu_context_objfile, spe_context_lm_addr, spe_context_offset):
	New static variables.
	(spe_context_cache_ptid, spe_context_cache_address): Likewise.
	(ppc_linux_spe_context_lookup): New function.
	(ppc_linux_spe_context_inferior_created): Likewise.
	(ppc_linux_spe_context_solib_loaded): Likewise.
	(ppc_linux_spe_context_solib_unloaded): Likewise.
	(ppc_linux_spe_context): Likewise.
	(struct ppu2spu_cache, struct ppu2spu_data): New data types.
	(ppu2spu_prev_arch, ppu2spu_this_id, ppu2spu_prev_register,
	ppu2spu_unwind_register, ppu2spu_sniffer,
	ppu2spu_dealloc_cache): New functions.
	(ppu2spu_unwind): New static variable.
	(ppc_linux_init_abi): Install cross-architecture unwinder.
	(_initialize_ppc_linux_tdep): Attach to observers.

	* spu-tdep.c (struct spu2ppu_cache): New data type.
	(spu2ppu_prev_arch, spu2ppu_this_id, spu2ppu_prev_register,
	spu2ppu_sniffer, spu2ppu_dealloc_cache): New functions.
	(spu2ppu_unwind): New static variable.
	(spu_gdbarch_init): Install cross-architecture unwinder.
@
text
@d43 1
d49 8
d1764 59
d2392 23
d2536 26
@


1.50
log
@ChangeLog:

	* target.h (enum strata): New value arch_stratum.
	* target.c (target_require_runnable): Skip arch_stratum targets.

	* configure.tgt (powerpc-*-linux* | powerpc64-*-linux*): Add
	solib-spu.o and spu-multiarch.o to gdb_target_obs.
	* Makefile.in (ALL_TARGET_OBS): Add solib-spu.o and spu-multiarch.o.
	(ALLDEPFILES): Add solib-spu.c and spu-multiarch.c.

	* solib-spu.c: New file.
	* solib-spu.h: New file.
	* spu-multiarch.c: New file.

	* spu-tdep.h (SPUADDR, SPUADDR_SPU, SPUADDR_ADDR): New macros.

	* spu-tdep.c (struct gdbarch_tdep): New member id.
	(spu_gdbarch_id): New function.
	(spu_lslr): New function.

	(spu_address_to_pointer): New function.
	(spu_pointer_to_address): Support SPU ID address encoding.  Use
	spu_gdbarch_id and spu_lslr.
	(spu_integer_to_address): Likewise.
	(spu_frame_unwind_cache): Update for encoded addresses.
	(spu_unwind_pc, spu_unwind_sp): Likewise.
	(spu_read_pc, spu_write_pc): Likewise.
	(spu_push_dummy_call): Likewise.
	(spu_software_single_step): Likewise.
	(spu_get_longjmp_target): Likewise.
	(spu_overlay_update_osect): Likewise.

	(spu_dis_asm_print_address): New function.
	(gdb_print_insn_spu): Likewise.

	(spu_gdbarch_init): Store SPU ID in tdep structure.
	Install spu_address_to_pointer and gdb_print_insn_spu.

	* ppc-linux-tdep.c: Include "observer.h", "auxv.h", "elf/common.h"
	and "solib-spu.h".
	(ppc_linux_entry_point_addr): New static variable.
	(ppc_linux_inferior_created): New function.
	(ppc_linux_displaced_step_location): Likewise.
	(ppc_linux_init_abi): Enable Cell/B.E. support if supported
	by the target.
	(_initialize_ppc_linux_tdep): Attach to inferior_created observer.

	* NEWS: Mention multi-architecture and Cell/B.E. debugging
	capabilities.

testsuite/ChangeLog:

	* gdb.xml/tdesc-regs.exp: Skip for SPU targets.
@
text
@d1091 104
d2417 3
@


1.49
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d51 3
d336 44
d384 2
a388 5
  ULONGEST lslr = SPU_LS_SIZE - 1; /* Hard-wired LS size.  */

  if (target_has_registers && target_has_stack && target_has_memory)
    lslr = get_frame_register_unsigned (get_selected_frame (NULL),
					SPU_LSLR_REGNUM);
d390 1
a390 1
  return addr & lslr;
d397 2
a399 5
  ULONGEST lslr = SPU_LS_SIZE - 1; /* Hard-wired LS size.  */

  if (target_has_registers && target_has_stack && target_has_memory)
    lslr = get_frame_register_unsigned (get_selected_frame (NULL),
					SPU_LSLR_REGNUM);
d401 1
a401 1
  return addr & lslr;
d895 1
d899 1
d932 1
d955 2
a956 1
      status = safe_read_memory_integer (reg, 4, byte_order, &backchain);
d964 1
a964 1
	    info->saved_regs[SPU_LR_REGNUM].addr = backchain + 16;
d967 2
a968 2
	  info->frame_base = backchain;
	  info->local_base = reg;
d977 2
a978 1
  trad_frame_set_value (info->saved_regs, SPU_SP_REGNUM, info->frame_base);
d1056 1
d1059 1
a1059 1
  return pc & -4;
d1065 3
a1067 1
  return frame_unwind_register_unsigned (next_frame, SPU_SP_REGNUM);
d1073 1
d1077 1
a1077 1
  return pc & -4;
d1087 1
a1087 1
				  (pc & -4) | (old_pc & 3));
d1199 1
a1199 1
  store_unsigned_integer (buf, 4, byte_order, bp_addr);
d1208 1
a1208 1
      store_unsigned_integer (buf, 4, byte_order, struct_addr);
d1286 1
d1289 1
a1289 1
  return frame_id_build (sp, pc & -4);
d1371 1
a1371 1
    next_pc = (pc + 8) & (SPU_LS_SIZE - 1);
d1373 1
a1373 1
    next_pc = (pc + 4) & (SPU_LS_SIZE - 1);
d1375 1
a1375 1
  insert_single_step_breakpoint (gdbarch, next_pc);
d1382 1
a1382 1
	target += pc;
d1391 2
a1392 1
	insert_single_step_breakpoint (gdbarch, target);
d1405 1
d1413 1
a1413 1
  if (target_read_memory (jb_addr, buf, 4))
d1417 1
d1422 31
d1577 1
a1577 1
  CORE_ADDR val;
d1587 3
a1589 1
  val = read_memory_unsigned_integer (ovly_table->mapped_ptr, 4, byte_order);
d2227 1
d2229 11
a2239 4
  /* Find a candidate among the list of pre-declared architectures.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d2241 9
a2249 3
  /* Is is for us?  */
  if (info.bfd_arch_info->mach != bfd_mach_spu)
    return NULL;
d2251 1
a2251 1
  /* Yes, create a new architecture.  */
d2253 1
d2257 1
a2257 1
  set_gdbarch_print_insn (gdbarch, print_insn_spu);
d2289 1
@


1.48
log
@	* breakpoint.h (struct breakpoint): New member GDBARCH.
	* breakpoint.c: Include "arch-utils.h".
	(set_raw_breakpoint_without_location): Add GDBARCH parameter.
	Use it to set breakpoint architecture.
	(set_raw_breakpoint): Add GDBARCH parameter.
	(create_internal_breakpoint): Likewise.
	(create_catchpoint): Likewise.
	(create_fork_vfork_event_catchpoint): Likewise.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise.
	(break_command_really): Likewise.
	(create_ada_exception_breakpoint): Likewise.
	Update local callers to pass architecture:
	(create_internal_breakpoint): Update.
	(create_overlay_event_breakpoint): Update.
	(create_longjmp_master_breakpoint): Update.
	(create_thread_event_breakpoint): Update.
	(create_solib_event_breakpoint): Update.
	(create_catchpoint): Update.
	(create_fork_vfork_event_catchpoint): Update.
	(set_momentary_breakpoint): Update.
	(clone_momentary_breakpoint): Update.
	(create_breakpoint): Update.
	(create_breakpoints): Update.
	(break_command_really): Update.
	(break_command_1): Update.
	(set_breakpoint): Update.
	(watch_command_1): Update.
	(catch_fork_command_1): Update.
	(catch_exec_commnd_1): Update.
	(handle_gnu_v3_exceptions): Update.
	(create_ada_exception_breakpoint): Update.
	(catch_ada_exception_command): Update.
	(catch_assert_command): Update.
	(trace_command): Update.

	* breakpoint.h (struct bp_location): New member GDBARCH.
	* breakpoint.c (get_sal_arch): New function.
	(set_raw_breakpoint): Set location architecture.
	(add_location_to_breakpoint): Likewise.
	(clone_momentary_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(update_watchpoint): Likewise.
	(bp_loc_is_permanent): Use location architecture instead of
	current_gdbarch.
	(adjust_breakpoint_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	Update callers of adjust_breakpoint_address to pass
	breakpoint location architecture:
	(set_raw_breakpoint): Update.
	(watch_command_1): Update.

        * tracepoint.c: (collect_symbol): Add GDBARCH parameter, use instead
	of current_gdbarch.
	(add_local_symbols): Add GDBARCH parameter.  Pass to collect_symbol.
	(encode_actions): Pass tracepoint architecture to add_local_symbols
	(encode_actions): Use tracepoint architecture instead of
	current_gdbarch.  Pass it to add_local_symbols and collect_symbol.

	* breakpoint.h (struct breakpoint_ops): Replace last_addr parameter
	of print_one callback with last_loc.
	* breakpoint.c (print_one_breakpoint_location): Replace last_addr
	parameter with last_loc.
	(print_one_breakpoint): Likewise.
	(do_captured_breakpoint_query): Update call.
	(breakpoint_1): Pass last_loc instead of last_addr to
	print_one_breakpoint.  Pass last location architecture instead of
	current_gdbarch to set_next_address.
	Update all implementations of the print_one callback:
	* breakpoint.c (print_one_catch_fork): Update.
	(print_one_catch_vfork): Update.
	(print_one_catch_exec): Update.
	(print_one_exception_catchpoint): Update.
	* ada-lang.c (print_one_exception): Update.
	(print_one_catch_exception): Update.
	(print_one_catch_exception_unhandled): Update.
	(print_one_catch_assert): Update.

	* breakpoint.c (print_one_breakpoint_location): Add PRINT_ADDRESS_BITS
	parameter.  Use it instead of gdbarch_addr_bit (current_gdbarch).
	(print_one_breakpoint): Add PRINT_ADDRESS_BITS parameter and pass it
	to print_one_breakpoint_location.
	(breakpoint_address_bits): New function.
	(do_captured_breakpoint_query): Compute number of address bits to print
	and pass it to print_one_breakpoint.
	(breakpoint_1): Likewise.  Use it instead of current_gdbarch.

	* breakpoint.h (create_thread_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_thread_event_breakpoint): Likewise.
	Update callers to create_thread_event_breakpoint:
	* aix-thread.c (pd_enable): Update.
	* linux-thread-db.c (enable_thread_event): Update.

	* breakpoint.h (create_solib_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_solib_event_breakpoint): Likewise.
	Update callers to create_solib_event_breakpoint:
	* solib-frv.c (enable_break, enable_break2): Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-som.c (som_solib_create_inferior_hook): Update.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Update.
	* solib-svr4.c (enable_break): Update.

	* breakpoint.h (insert_single_step_breakpoint): Add GDBARCH.
	* breakpoint.c (insert_single_step_breakpoint): Likewise.
	Update callers to insert_single_step_breakpoint:
	* alpha-tdep.c (alpha_software_single_step): Update.
	* arm-linux-tdep.c (arm_linux_software_single_step): Update.
	* arm-tdep.c (arm_software_single_step): Update.
	* cris-tdep.c (cris_software_single_step): Update.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Update.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Update.
	* sparc-tdep.c (sparc_software_single_step): Update.
	* spu-tdep.c (spu_software_single_step): Update.
	* mips-tdep.c (deal_with_atomic_sequence): Add GDBARCH parameter.
	Pass it to insert_single_step_breakpoint.
	(mips_software_single_step): Pass architecture to
	deal_with_atomic_sequence and insert_single_step_breakpoint.

	* breakpoint.h (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	* breakpoint.c (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	Update callers to deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint:
	* breakpoint.c (single_step_gdbarch): New static variable.
	(insert_single_step_breakpoint): Pass GDBARCH parameter to
	deprecated_insert_raw_breakpoint.  Store it in single_step_gdbarch.
	(remove_single_step_breakpoints): Pass architecture stored in
	single_step_gdbarch to deprecated_remove_raw_breakpoint.
	* rs6000-nat.c (exec_one_dummy_insn): Update.
	* solib-irix.c (enable_break, disable_break): Update.
	* procfs.c (procfs_mourn_inferior): Update.
	(remove_dbx_link_breakpoint): Update.

	* breakpoint.h (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	* breakpoint.c (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	Update callers to set_breakpoint, set_momentary_breakpoint and
	set_momentary_breakpoint_at_pc:
	* breakpoint.c (set_momentary_breakpoint_at_pc): Update.
	(until_break_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* infcmd.c (finish_backward, finish_forward): Update.
	* infrun.c (insert_step_resume_breakpoint_at_sal): Add GDBARCH
	parameter.  Pass it to set_momentary_breakpoint.
	(insert_longjmp_resume_breakpoint): Add GDBARCH parameter.
	Pass it to set_momentary_breakpoint_at_pc.
	(handle_inferior_event): Update.
	(insert_step_resume_breakpoint_at_frame): Update.
	(insert_step_resume_breakpoint_at_caller): Update..
	* mi/mi-cmd-break.c: Include "arch-utils.h".
	(mi_cmd_break_insert): Update.

	* target.h (struct target_ops): Add GDBARCH parameter to
	to_insert_breakpoint, to_remove_breakpoint, to_insert_hw_breakpoint,
	and to_remove_hw_breakpoint members.
	(target_insert_breakpoint, target_remove_breakpoint,
	target_insert_hw_breakpoint, target_remove_hw_breakpoint): Add GDBARCH
	parameter, pass to target routine.
	(memory_remove_breakpoint, memory_insert_breakpoint): Add GDBARCH
	parameter.
	* target.c (debug_to_insert_breakpoint, debug_to_remove_breakpoint,
	debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint): Add
	GDBARCH parameter, pass to target routine.
	(update_current_target): Update function signature.
	* breakpoint.c (insert_bp_location, remove_breakpoint,
	deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint):
	Pass architecture to target_ routines.
	Update all implementations of the target breakpoint routines to take
	GDBARCH parameter and use it instead of GDBARCH as appropriate:
	* corelow.c (ignore): Update.
	* exec.c (ignore): Update.
	* mem-break.c (memory_insert_breakpoint): Update.
	(memory_remove_breakpoint): Update.
	* monitor.c (monitor_insert_breakpoint): Update.
	(monitor_remove_breakpoint): Update.
	* record.c (record_insert_breakpoint): Update.
	(record_beneath_to_insert_breakpoint): Update.
	(record_remove_breakpoint): Update.
	(record_beneath_to_remove_breakpoint): Update.
	* remote.c (remote_insert_breakpoint): Update.
	(remote_remove_breakpoint): Update.
	(remote_insert_hw_breakpoint): Update.
	(remote_remove_hw_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_insert_breakpoint): Update.
	(m32r_remove_breakpoint): Update.
	* remote-mips.c (mips_insert_breakpoint): Update.
	(mips_remove_breakpoint): Update.
	* i386-nat.c (i386_insert_hw_breakpoint): Update.
	(i386_remove_hw_breakpoint): Update.
	* nto-procfs.c (procfs_insert_breakpoint):  Update.
	(procfs_remove_breakpoint): Update.
	(procfs_insert_hw_breakpoint): Update.
	(procfs_remove_hw_breakpoint): Update.

doc/ChangeLog:

	* gdbint.texi (Examples of Use of @@code{ui_out} functions):
	Update example code extrated from breakpoint.c.
@
text
@d173 2
d185 1
a185 1
  store_unsigned_integer (buf, 4, strtoulst (reg, NULL, 16));
d234 2
d243 1
a243 1
	     phex_nz (extract_unsigned_integer (buf, 4), 4));
d337 3
a339 1
  ULONGEST addr = extract_unsigned_integer (buf, TYPE_LENGTH (type));
d539 2
a540 1
spu_analyze_prologue (CORE_ADDR start_pc, CORE_ADDR end_pc,
d543 1
d603 1
a603 1
      insn = extract_unsigned_integer (buf, 4);
d717 1
a717 1
  return spu_analyze_prologue (pc, (CORE_ADDR)-1, &data);
d726 1
a726 1
  spu_analyze_prologue (pc, (CORE_ADDR)-1, &data);
d762 1
d792 1
a792 1
      insn = extract_unsigned_integer (buf, 4);
d820 1
a820 1
      insn = extract_unsigned_integer (buf, 4);
d853 2
d877 2
a878 2
    spu_analyze_prologue (info->func, get_frame_pc (this_frame), &data);

d888 1
a888 1
      cfa = extract_unsigned_integer (buf, 4) + data.cfa_offset;
d911 1
a911 1
      status = safe_read_memory_integer (reg, 4, &backchain);
d947 1
a947 1
  if (extract_unsigned_integer (buf + 8, 4) != 0)
d949 1
a949 1
			  extract_unsigned_integer (buf + 8, 4));
d952 1
a952 1
			  extract_unsigned_integer (buf, 4));
d1140 1
d1149 1
a1149 1
  store_unsigned_integer (buf, 4, bp_addr);
d1158 1
a1158 1
      store_unsigned_integer (buf, 4, struct_addr);
d1222 1
a1222 1
  sp_delta = sp - extract_unsigned_integer (buf, 4);
d1225 2
a1226 2
      CORE_ADDR sp_slot = extract_unsigned_integer (buf + 4*i, 4);
      store_unsigned_integer (buf + 4*i, 4, sp_slot + sp_delta);
d1304 1
d1314 1
a1314 1
  insn = extract_unsigned_integer (buf, 4);
d1335 1
a1335 1
	  target += extract_unsigned_integer (buf, 4) & -4;
d1352 2
d1359 1
a1359 1
  jb_addr = extract_unsigned_integer (buf, 4);
d1363 1
a1363 1
  *pc = extract_unsigned_integer (buf, 4);
d1419 2
d1456 8
a1463 4
      CORE_ADDR vma  = extract_unsigned_integer (ovly_table + 16*i + 0, 4);
      CORE_ADDR size = extract_unsigned_integer (ovly_table + 16*i + 4, 4);
      CORE_ADDR pos  = extract_unsigned_integer (ovly_table + 16*i + 8, 4);
      CORE_ADDR buf  = extract_unsigned_integer (ovly_table + 16*i + 12, 4);
d1489 2
d1502 1
a1502 1
  val = read_memory_unsigned_integer (ovly_table->mapped_ptr, 4);
d1621 2
d1635 1
a1635 1
  if (gdbarch_bfd_arch_info (get_frame_arch (frame))->arch != bfd_arch_spu)
d1646 1
a1646 1
      signal1 = extract_unsigned_integer (buf, 4);
d1664 1
a1664 1
      signal2 = extract_unsigned_integer (buf, 4);
d1714 1
a1714 1
info_spu_mailbox_list (gdb_byte *buf, int nr,
d1733 1
a1733 1
      val = extract_unsigned_integer (buf + 4*i, 4);
d1748 2
d1756 1
a1756 1
  if (gdbarch_bfd_arch_info (get_frame_arch (frame))->arch != bfd_arch_spu)
d1769 2
a1770 1
  info_spu_mailbox_list (buf, len / 4, "mbox", "SPU Outbound Mailbox");
d1778 2
a1779 1
  info_spu_mailbox_list (buf, len / 4, "ibox", "SPU Outbound Interrupt Mailbox");
d1787 2
a1788 1
  info_spu_mailbox_list (buf, len / 4, "wbox", "SPU Inbound Mailbox");
d1801 1
a1801 1
info_spu_dma_cmdlist (gdb_byte *buf, int nr)
d1858 2
a1859 1
	  mfc_cq_dw3 = extract_unsigned_integer (buf + 32*j + 24, 8);
d1908 6
a1913 3
      mfc_cq_dw0 = extract_unsigned_integer (buf + 32*seq[i], 8);
      mfc_cq_dw1 = extract_unsigned_integer (buf + 32*seq[i] + 8, 8);
      mfc_cq_dw2 = extract_unsigned_integer (buf + 32*seq[i] + 16, 8);
d1984 2
d2008 10
a2017 5
  dma_info_type = extract_unsigned_integer (buf, 8);
  dma_info_mask = extract_unsigned_integer (buf + 8, 8);
  dma_info_status = extract_unsigned_integer (buf + 16, 8);
  dma_info_stall_and_notify = extract_unsigned_integer (buf + 24, 8);
  dma_info_atomic_command_status = extract_unsigned_integer (buf + 32, 8);
d2057 1
a2057 1
  info_spu_dma_cmdlist (buf + 40, 16);
d2065 2
d2076 1
a2076 1
  if (gdbarch_bfd_arch_info (get_frame_arch (frame))->arch != bfd_arch_spu)
d2087 3
a2089 3
  dma_info_type = extract_unsigned_integer (buf, 8);
  dma_info_mask = extract_unsigned_integer (buf + 8, 8);
  dma_info_status = extract_unsigned_integer (buf + 16, 8);
d2121 1
a2121 1
  info_spu_dma_cmdlist (buf + 24, 8);
@


1.47
log
@	* gdbtypes.h (TYPE_OBJFILE_OWNED, TYPE_OWNER): New macros.
	(TYPE_OBJFILE, TYPE_ALLOC, TYPE_ZALLOC): Reimplement.
	(alloc_type_arch): Add prototype.
	(alloc_type_copy): Likewise.
	(get_type_arch): Likewise.
	(arch_type): Likewise.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.

	* gdbtypes.c (alloc_type): No longer support NULL objfile.
	(init_type): Likewise.
	(alloc_type_arch): New function.
	(alloc_type_copy): New function.
	(get_type_arch): New function.

	(smash_type): Preserve type ownership information.
	(make_pointer_type, make_reference_type, make_function_type,
	smash_to_memberptr_type, smash_to_method_type): No longer
	preserve OBJFILE across smash_type calls.
	(make_pointer_type, make_reference_type, make_function_type,
	lookup_memberptr_type, lookup_methodptr_type, allocate_stub_method,
	create_range_type, create_array_type, create_set_type, copy_type):
	Use alloc_type_copy when allocating types.
	(check_typedef): Use alloc_type_arch.
	(copy_type_recursive): Likewise.  Preserve type ownership data
	after copying type.
	(recursive_dump_type): Dump type ownership data.
	(alloc_type_instance): Update type ownership check.
	(copy_type, copy_type_recursive): Likewise.

	(arch_type): New function.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(append_flags_type_flag): Move down.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.
	(append_composite_type_field_aligned,
	append_composite_type_field): Move down.

	* gdbarch.c (gdbtypes_post_init): Allocate all types
	using per-architecture routines.
	* ada-lang.c (ada_language_arch_info): Likewise.
	* f-lang.c (build_fortran_types): Likewise.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* scm-lang.c (build_scm_types): Likewise.

	* ada-lang.c (ada_type_of_array): Use alloc_type_copy.
	(packed_array_type): Likewise.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_variant_branch_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_fixed_range_type): Likewise.
	(empty_record): Use type instead of objfile argument.
	Use alloc_type_copy.
	(to_fixed_variant_branch_type): Update call to empty_record.
	* jv-lang.c (type_from_class): Use alloc_type_arch.

	* arm-tdep.c (arm_ext_type): Allocate per-architecture type.
	* i386-tdep.c (i386_eflags_type, i386_mxcsr_type, i387_ext_type,
	i386_mmx_type, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_ext_type): Likewise.
	* m32c-tdep.c (make_types): Likewise.
	* m68k-tdep.c (m68k_ps_type, m68881_ext_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* sparc-tdep.c (sparc_psr_type, sparc_fsr_type): Likewise.
	* sparc64-tdep.c (sparc64_pstate_type, sparc64_fsr_type,
	sparc64_fprs_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* target-descriptions.c (tdesc_gdb_type): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
@
text
@d1291 1
d1311 1
a1311 1
  insert_single_step_breakpoint (next_pc);
d1327 1
a1327 1
	insert_single_step_breakpoint (target);
@


1.46
log
@	* gdbtypes.h (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(struct builtin_type): New members builtin_int0, builtin_int8,
	builtin_uint8, builtin_int16, builtin_uint16, builtin_int32,
	builtin_uint32, builtin_int64, builtin_uint64, builtin_int128,
	and builtin_uint128.
	* gdbtypes.c (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(gdbtypes_post_init): Initialize fixed-size integer types.

	* dwarf2expr.c (unsigned_address_type, signed_address_type): Add
	GDBARCH argument.  Return platform-specific type.
	(dwarf2_read_address, execute_stack_op): Update calls.

	* target-descriptions.c (tdesc_gdb_type): Use platform-specific types
	instead of global builtin_int_... variables.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	* printcmd.c (do_examine): Likewise.
	* jv-exp.y (parse_number): Likewise.

	* alpha-tdep.c (alpha_register_type, alpha_push_dummy_call,
	alpha_store_return_value): Likewise.
	* amd64-linux-tdep.c (amd64_linux_register_type): Likewise.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c h8300_register_type): Likewise.
	* hppa-tdep.c (hppa64_push_dummy_call, hppa32_register_type,
	hppa64_register_type): Likewise.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Likewise.
	* iq2000-tdep.c (iq2000_register_type): Likewise.
	* lm32-tdep.c (lm32_register_type, lm32_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68hc11-tdep.c (m68hc11_register_type, m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m88k-tdep.c (m88k_register_type, m88k_store_arguments): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_register_type, mips_pseudo_register_type,
	mips_print_fp_register): Likewise.
	* moxie-tdep.c (moxie_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type, mt_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* score-tdep.c (score_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type, sparc32_store_arguments):
	Likewise.
	* sparc64-tdep.c (sparc64_register_type, sparc64_store_arguments):
	Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* xstormy16-tdep.c (xstormy16_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.

	* mt-tdep.c (struct gdbarch_tdep): New data structure.
	(mt_gdbarch_init): Alloc TDEP structures.
	(mt_register_type): Cache coprocessor type in TDEP instead of
	static global variable.

	* xtensa-tdep.h (struct gdbarch_tdep): Add type_entries member.
	* xtensa-tdep.c (type_entries): Remove.
	(xtensa_register_type): Cache fixed-size types in TDEP instead
	of in global variable.
@
text
@d67 2
a68 1
      t = init_composite_type ("__spu_builtin_type_vec128", TYPE_CODE_UNION);
@


1.45
log
@	* spu-tdep.c (spu_get_longjmp_target): New function.
	(spu_gdbarch_init): Install it.
@
text
@d64 1
d68 1
a68 1
      append_composite_type_field (t, "uint128", builtin_type_int128);
d70 1
a70 1
				   init_vector_type (builtin_type_int64, 2));
d72 1
a72 1
				   init_vector_type (builtin_type_int32, 4));
d74 1
a74 1
				   init_vector_type (builtin_type_int16, 8));
d76 1
a76 1
				   init_vector_type (builtin_type_int8, 16));
d78 1
a78 2
				   init_vector_type (builtin_type (gdbarch)
						     ->builtin_double, 2));
d80 1
a80 2
				   init_vector_type (builtin_type (gdbarch)
						     ->builtin_float, 4));
d138 1
a138 1
      return builtin_type_uint32;
d147 1
a147 1
      return builtin_type_uint128;
d150 1
a150 1
      return builtin_type_uint32;
d153 1
a153 1
      return builtin_type_uint32;
d156 1
a156 1
      return builtin_type_uint32;
d159 1
a159 1
      return builtin_type_uint32;
@


1.44
log
@	* gdbarch.sh (pointer_to_address): Change to type 'm'.
	(address_to_pointer): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.

	* inferior.h (unsigned_pointer_to_address): Add GDBARCH argument.
	(signed_pointer_to_address): Likewise.
	(unsigned_address_to_pointer, address_to_signed_pointer): Likewise.
	* findvar.c (unsigned_pointer_to_address): Likewise.
	(signed_pointer_to_address): Likewise.
	(unsigned_address_to_pointer, address_to_signed_pointer): Likewise.

	* avr-tdep.c (avr_address_to_pointer): Likewise.
	(avr_pointer_to_address): Likewise.
	* iq2000-tdep.c (iq2000_pointer_to_address): Likewise.
	(iq2000_address_to_pointer): Likewise.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Likewise.
	(m32c_m16c_pointer_to_address): Likewise.
	* spu-tdep.c (spu_pointer_to_address): Likewise.
	* xstormy16-tdep.c (xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Likewise.
@
text
@d1332 20
d2171 1
@


1.43
log
@	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
        * alpha-linux-tdep.c (alpha_linux_regset_from_core_section): Make
	it static.
        * alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Declare.
        * amd64fbsd-tdep.c (amd64fbsd_init_abi): Make it static.
        * amd64nbsd-tdep.c (_initialize_amd64nbsd_ndep): Rename to ...
	(_initialize_amd64nbsd_tdep): ... this.
	* arm-linux-tdep.c (arm_linux_software_single_step): Make it static.
	(_initialize_arm_linux_tdep): Declare.
	* armbsd-tdep.c (armbsd_fpreg_offset): Make it static.
	* armnbsd-tdep.c (_initialize_arm_netbsd_tdep): Declare.
	* armobsd-tdep.c (_initialize_armobsd_tdep): Declare.
	* avr-tdep.c (avr_return_value): Make it static.
	(avr_frame_unwind_cache): Ditto.
	* bsd-uthread.c (bsd_uthread_inferior_created): Ditto.
	(bsd_uthread_solib_loaded): Ditto.
	(bsd_uthread_solib_unloaded): Ditto.
	(bsd_uthread_target): Ditto.
	(_initialize_bsd_uthread): Declare.
	* cris-tdep.c (crisv32_single_step_through_delay): Make it static.
	(cris_frame_unwind_cache): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_use_struct_convention): Ditto.
	(h8300h_use_struct_convention): Ditto.
	* hppa-tdep.c (hppa_sign_extend, hppa_low_hppa_sign_extend):
	Ditto.
	* hppa-tdep.h (hppa_low_sign_extend, hppa_sign_extend): Delete
	declarations.
	* hppabsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_find_global_pointer): Make it static.
	* hppabsd-tdep.h: New.
	* hppanbsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Remove declaration.
	(_initialize_hppabsd_tdep): Remove declaration.
	(_initialize_hppanbsd_tdep): Declare.
	* hppaobsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Delete declaration.
	(hppaobsd_init_abi): Make it static.
	* i386-nto-tdep.c (_initialize_i386nto_tdep): Declare.
	* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Declare.
	* ia64-linux-tdep.c (_initialize_ia64_linux_tdep): Declare.
	* ia64-tdep.c (ia64_register_reggroup_p): Make it static.
	* iq2000-tdep.c (_initialize_iq2000_tdep): Declare.
	* m32c-tdep.c (m32c_register_reggroup_p): Make it static.
	(m32c_analyze_prologue, m32c_virtual_frame_pointer): Ditto.
	(_initialize_m32c_tdep): Declare.
	* m32r-rom.c (_initialize_m32r_rom): Declare.
	* m32r-tdep.c (m32r_skip_prologue): Make it static.
	(m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Make it static.
	(m68hc11_return_value): Ditto.
	* m68klinux-tdep.c (_initialize_m68k_linux_tdep): Declare.
	* m88k-tdep.c (m88k_frame_cache): Make it static.
	* mep-tdep.c (mep_gdb_print_insn): Ditto.
	(mep_return_value): Ditto.
	(_initialize_mep_tdep): Declare.
	* mips-irix-tdep.c (_initialize_mips_irix_tdep): Declare.
	* mips-linux-tdep.c (supply_64bit_reg): Make it static.
	(mips_linux_syscall_next_pc): Ditto.
	(_initialize_mips_linux_tdep): Declare.
	* mips-tdep.c (mips_single_step_through_delay): Make it static.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Declare.
	* mn10300-linux-tdep.c (_initialize_mn10300_linux_tdep): Declare.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Declare.
	* mt-tdep.c (_initialize_mt_tdep): Declare.
	* nbsd-tdep.c: Include nbsd-tdep.h.
	* nto-tdep.c (find_load_phdr): Make it static.
	(_initialize_nto_tdep): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Make it
	static.
	(_initialize_ppc_linux_tdep): Declare.
	* remote-m32r-sdi.c (m32r_can_use_hw_watchpoint)
	(m32r_insert_watchpoint, m32r_remove_watchpoint)
	(m32r_stopped_data_address, m32r_stopped_by_watchpoint): Make
	static.
	* rs6000-aix-tdep.c (_initialize_rs6000_aix_tdep): Declare.
	* rs6000-nat.c: Include xcoffread.h.
	(find_toc_address): Don't extern declare get_toc_offset.  Adjust
	to call xcoff_get_to_offset.
	* rs6000-tdep.c (ppc_vsx_support_p, ppc_displaced_step_fixup)
	(rs6000_skip_main_prologue, rs6000_in_solib_return_trampoline)
	(rs6000_skip_trampoline_code): Make static.
	* s390-tdep.c (s390_regset_from_core_section): Ditto.
	* sh-tdep.c (sh_register_reggroup_p): Ditto.
	* shnbsd-tdep.c (shnbsd_regset_from_core_section): Ditto.
	(_initialize_shnbsd_tdep): Declare.
	* solib-frv.c (displacement_from_map): Make static.
	(_initialize_frv_solib): Declare.
	* solib-irix.c (fetch_lm_info): Make static.
	(_initialize_irix_solib): Declare.
	* solib-som.c: Include solib-som.h.
	(som_solib_select): Line break.
	* sparc-tdep.c (sparc_regset_from_core_section): Make static.
	* sparcnbsd-tdep.c (_initialize_sparnbsd_tdep): Rename to ...
	(_initialize_sparcnbsd_tdep): ... this.
	* spu-tdep.c (spu_software_single_step): Make it static.
	(_initialize_spu_tdep): Declare.
	* vax-tdep.c (vax_frame_cache): Make it static.
	* xcoffread.c: Include xcoffread.h.
	(get_toc_offset): Rename to ...
	(xcoff_get_toc_offset): ... this.
	(_initialize_xcoffread): Declare.
	* xcoffread.h: New.
	* xtensa-linux-tdep.c (_initialize_xtensa_linux_tdep): Declare.
	* xtensa-tdep.c (xtensa_skip_prologue, xtensa_derive_tdep): Make
	static.
	(_initialize_xtensa_tdep): Declare.
@
text
@d330 2
a331 1
spu_pointer_to_address (struct type *type, const gdb_byte *buf)
@


1.42
log
@        Updated copyright notices for most files.
@
text
@d1287 1
a1287 1
int
d2157 3
@


1.41
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.40
log
@	* spu-tdep.c (spu_push_dummy_code): New function.
	(spu_gdbarch_init): Install it.
@
text
@d77 2
a78 1
				   init_vector_type (builtin_type_double, 2));
d80 2
a81 1
				   init_vector_type (builtin_type_float, 4));
d142 1
a142 1
      return builtin_type_void_func_ptr;
d145 1
a145 1
      return builtin_type_void_data_ptr;
@


1.39
log
@	* breakpoint.h (struct bp_location): Change type of section
	member to "struct obj_section *".
	* tracepoint.h (struct tracepoint): Likewise.
	* symtab.h (struct general_symbol_info): Replace bfd_section
	member with obj_section.
	(struct symtab_and_line): Change type of section member to
	"struct obj_section *".
	(SYMBOL_BFD_SECTION): Remove macro, replace by ...
	(SYMBOL_OBJ_SECTION): ... this.

	* minsym.c (prim_record_minimal_symbol_and_info): Record symbol
	section as obj_section instead of bfd_section.

	* ada-lang.c (ada_decode_symbol): Use gsymbol->obj_section
	directly instead of looking of obj_section from bfd_section.

	* objfiles.h (find_pc_sect_section): Remove.
	* objfiles.c (find_pc_sect_section): Remove.
	(find_pc_section): Inline find_pc_sect_section code.

	* symfile.h (find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(section_is_overlay, section_is_mapped): Change type of section
	argument to struct obj_section *.
	(pc_in_mapped_range, pc_in_unmapped_range): Likewise.
	(overlay_mapped_address, overlay_unmapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	* symtab.h (symbol_overlayed_address): Likewise.
	* symfile.c (overlay_is_mapped): Remove.
	(section_is_mapped): Inline overlay_is_mapped code.  Update.
	(overlay_invalidate_all): Update.
	(section_is_overlay): Change section argument to type
	"struct obj_section *".  Use bfd_ methods.
	(pc_in_unmapped_range): Likewise.  Handle relocated sections.
	(pc_in_mapped_range): Likewise.  Handle relocated sections.
	(sections_overlap): Likewise.
	(overlay_unmapped_address): Likewise.
	(overlay_mapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	(find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(list_overlays_command): Update.
	(map_overlay_command, unmap_overlay_command): Update.
	(simple_overlay_update): Update.

	* block.h (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* block.c (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* symtab.h (find_pc_sect_function, find_pc_sect_psymtab,
	find_pc_sect_symtab, find_pc_sect_psymbol, find_pc_sect_line,
	lookup_minimal_symbol_by_pc_section, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.
	* blockframe.c (find_pc_sect_function): Likewise.
	* breakpoint.c (describe_other_breakpoints): Likewise.
	(breakpoint_has_pc, check_duplicates_for): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_minimal_symbol_by_pc_section): Likewise.
	* symtab.c (find_pc_sect_psymtab_closer): Likewise.
	(find_pc_sect_psymtab, find_pc_sect_psymbol, find_pc_sect_symtab,
	find_pc_sect_line, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.

	* blockframe.c (find_pc_partial_function): Update to section
	type changes.  No longer call find_pc_sect_section.
	(cache_pc_function_section): Change to type "struct obj_section *".
	* breakpoint.c (resolve_sal_pc): Update to section type changes.
	* exec.c (xfer_memory): Likewise.
	* findvar.c (read_var_value): Likewise.
	* infcmd.c (jump_command): Likewise.
	* linespec.c (minsym_found): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_solib_trampoline_symbol_by_pc): Likewise.
	* parse.c (write_exp_msymbol): Likewise.
	* printcmd.c (build_address_symbolic): Likewise.
	(address_info, sym_info): Likewise.
	* symmisc.c (dump_msymbols, print_symbol): Likewise.
	* symtab.c (fixup_section): Likewise.
	(fixup_symbol_section, fixup_psymbol_section): Likewise.
	(find_pc_line, find_function_start_sal): Likewise.
	* target.c (memory_xfer_partial): Likewise.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline): Likewise.
	* spu-tdep.c (spu_overlay_update): Likewise.
@
text
@d1035 16
d2127 1
@


1.38
log
@	* spu-tdep.c (spu_push_dummy_call): Update all stack pointer slots
	when allocating stack frame for inferior call.
@
text
@d1458 1
a1458 1
	if (section_is_overlay (osect->the_bfd_section))
@


1.37
log
@	* spu-tdep.c (spu_frame_unwind_cache): Do not attempt to unwind
	SP or return address if we failed to find a valid frame.
@
text
@d1110 1
d1190 8
a1197 2
  /* Finally, update the SP register.  */
  regcache_cooked_write_unsigned (regcache, SPU_SP_REGNUM, sp);
@


1.36
log
@gdb:
	* xml-tdesc.c (tdesc_end_union): Update.
	* stabsread.c (define_symbol): Update.
	(read_type): Update.
	(read_struct_type): Update.
	(read_enum_type): Update.
	* spu-tdep.c (spu_builtin_type_vec128): Update.
	* sh-tdep.c (sh_push_dummy_call_fpu): Update.
	(sh_push_dummy_call_nofpu): Update.
	* mdebugread.c (parse_symbol): Update.
	(parse_symbol): Update.
	(parse_symbol): Update.
	(upgrade_type): Update.
	* jv-lang.c (java_lookup_class): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address): Update.
	* i386-tdep.c (i386_mmx_type): Update.
	(i386_sse_type): Update.
	* gdbtypes.h (enum type_flag_value): New enum.
	(enum type_instance_flag_value): New enum.
	(TYPE_FLAG_UNSIGNED, TYPE_FLAG_NOSIGN, TYPE_FLAG_STUB,
	TYPE_FLAG_TARGET_STUB, TYPE_FLAG_STATIC, TYPE_FLAG_PROTOTYPED,
	TYPE_FLAG_INCOMPLETE, TYPE_FLAG_VARARGS, TYPE_FLAG_VECTOR,
	TYPE_FLAG_FIXED_INSTANCE, TYPE_FLAG_STUB_SUPPORTED,
	TYPE_FLAG_NOTTEXT): Now enum constants.
	(TYPE_FLAG_CONST, TYPE_FLAG_VOLATILE, TYPE_FLAG_CODE_SPACE,
	TYPE_FLAG_DATA_SPACE, TYPE_FLAG_ADDRESS_CLASS_1,
	TYPE_FLAG_ADDRESS_CLASS_2): Remove.
	(TYPE_INSTANCE_FLAG_CONST, TYPE_INSTANCE_FLAG_VOLATILE,
	TYPE_INSTANCE_FLAG_CODE_SPACE, TYPE_INSTANCE_FLAG_DATA_SPACE,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_2): New constants.
	(TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB, TYPE_TARGET_STUB,
	TYPE_STATIC, TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_VARARGS,
	TYPE_VECTOR, TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED,
	TYPE_NOTTEXT): Update.
	(TYPE_FLAG_ADDRESS_CLASS_ALL): Remove.
	(TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL): New define.
	(TYPE_VOLATILE, TYPE_CODE_SPACE, TYPE_DATA_SPACE,
	TYPE_ADDRESS_CLASS_1, TYPE_ADDRESS_CLASS_2,
	TYPE_ADDRESS_CLASS_ALL): Update.
	(struct main_type) <flags>: Remove.
	<flag_unsigned, flag_nosign, flag_stub, flag_target_stub,
	flag_static, flag_prototyped, flag_incomplete, flag_varargs,
	flag_vector, flag_stub_supported, flag_nottext,
	flag_fixed_instance>: New fields.
	<nfields, vptr_fieldno>: Move earlier.
	(TYPE_FLAGS): Remove.
	* gdbtypes.c (make_pointer_type): Update.
	(address_space_name_to_int): Update.
	(address_space_int_to_name): Update.
	(make_type_with_address_space): Update.
	(make_cv_type): Update.
	(create_range_type): Update.
	(get_discrete_bounds): Update.
	(create_set_type): Update.
	(make_vector_type): Update.
	(smash_to_method_type): Update.
	(check_typedef): Update.
	(check_stub_method): Update.
	(init_type): Individually assign flag fields.
	(recursive_dump_type): Don't print entire TYPE_FLAGS field.  Do
	print TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED, and TYPE_NOTTEXT.
	(copy_type_recursive): Copy the entire main type.  Don't use
	TYPE_FLAGS.
	* features/rs6000/powerpc-altivec64l.c
	(initialize_tdesc_powerpc_altivec64l): Update.
	* features/rs6000/powerpc-altivec64.c
	(initialize_tdesc_powerpc_altivec64): Update.
	* features/rs6000/powerpc-altivec32l.c
	(initialize_tdesc_powerpc_altivec32l): Update.
	* features/rs6000/powerpc-altivec32.c
	(initialize_tdesc_powerpc_altivec32): Update.
	* features/rs6000/powerpc-7400.c (initialize_tdesc_powerpc_7400):
	Update.
	* features/arm-with-iwmmxt.c (initialize_tdesc_arm_with_iwmmxt):
	Update.
	* dwarf2read.c (read_structure_type): Update.
	(read_enumeration_type): Likewise.
	(process_enumeration_scope): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_base_type): Likewise.
	* coffread.c (coff_read_enum_type): Update.
	* ada-valprint.c (adjust_type_signedness): Update.
	* ada-typeprint.c (print_record_field_types): Update.
	* ada-lang.c (packed_array_type): Update.
	(empty_record): Don't reset TYPE_FLAGS.
	(ada_template_to_fixed_record_type_1): Update.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_record_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_static_fixed_type): Likewise.
gdb/testsuite:
	* gdb.base/maint.exp: Update "maint print type".
@
text
@d913 4
@


1.35
log
@	* spu-tdep.c (spu_overlay_new_objfile): Only consider SPU objfiles.
	(info_spu_event_command): Command only supported on SPU architecture.
	(info_spu_signal_command): Likewise.
	(info_spu_mailbox_command): Likewise.
	(info_spu_dma_command): Likewise.
	(info_spu_proxydma_command): Likewise.
@
text
@d81 1
a81 1
      TYPE_FLAGS (t) |= TYPE_FLAG_VECTOR;
@


1.34
log
@	* spu-tdep.c (info_spu_dma_command): Respect TSQV (tag status
	query valid) bit.  Ignore bits outside the condition field.
	(info_spu_proxydma_command): Ignore bits outside the field.
@
text
@d1466 4
d1504 3
d1559 3
d1678 3
d1910 3
d1982 3
@


1.33
log
@ChangeLog:

	* spu-tdep.c (info_spu_dma_cmdlist): Only show entries with
	the valid bit set.  Ensure display order respects partial
	order defined by dependency bits.

testsuite/ChangeLog:

	* gdb.arch/spu-info.exp: Updated for "info spu dma" changes.
@
text
@d1928 1
a1928 1
      const char *query_msg;
d1930 7
a1936 7
      switch (dma_info_type)
	{
	case 0: query_msg = _("no query pending"); break;
	case 1: query_msg = _("'any' query pending"); break;
	case 2: query_msg = _("'all' query pending"); break;
	default: query_msg = _("undefined query type"); break;
	}
d1993 1
a1993 1
      switch (dma_info_type)
@


1.32
log
@	* spu-tdep.c (spu_gdbarch_init): Call set_gdbarch_frame_red_zone_size.
@
text
@d1745 2
d1748 35
a1782 1
  int i;
a1804 1
      ULONGEST mfc_cq_dw3;
d1813 3
a1815 4
      mfc_cq_dw0 = extract_unsigned_integer (buf + 32*i, 8);
      mfc_cq_dw1 = extract_unsigned_integer (buf + 32*i + 8, 8);
      mfc_cq_dw2 = extract_unsigned_integer (buf + 32*i + 16, 8);
      mfc_cq_dw3 = extract_unsigned_integer (buf + 32*i + 24, 8);
@


1.31
log
@	* spu-tdep.c (spu_frame_unwind_cache): Do not error if
	backchain is unreadable.
@
text
@d2046 1
@


1.30
log
@	* spu-tdep.c: Update for unwinder changes.
@
text
@d891 3
a893 1
      CORE_ADDR reg, backchain;
d897 1
a897 1
      backchain = read_memory_unsigned_integer (reg, 4);
d901 1
a901 1
      if (backchain != 0 && backchain < SPU_LS_SIZE)
@


1.29
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d838 1
a838 1
spu_frame_unwind_cache (struct frame_info *next_frame,
d850 1
a850 1
  info->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d855 1
a855 1
  info->func = frame_func_unwind (next_frame, NORMAL_FRAME);
d859 1
a859 1
      info->func = frame_pc_unwind (next_frame);
d863 1
a863 1
    spu_analyze_prologue (info->func, frame_pc_unwind (next_frame), &data);
d873 1
a873 1
      frame_unwind_register (next_frame, data.cfa_reg, buf);
d894 1
a894 1
      reg = frame_unwind_register_unsigned (next_frame, SPU_SP_REGNUM);
d919 1
a919 1
    frame_unwind_register (next_frame, SPU_LR_REGNUM, buf);
d938 1
a938 1
spu_frame_this_id (struct frame_info *next_frame,
d942 1
a942 1
    spu_frame_unwind_cache (next_frame, this_prologue_cache);
d950 3
a952 6
static void
spu_frame_prev_register (struct frame_info *next_frame,
			 void **this_prologue_cache,
			 int regnum, int *optimizedp,
			 enum lval_type *lvalp, CORE_ADDR * addrp,
			 int *realnump, gdb_byte *bufferp)
d955 1
a955 1
    = spu_frame_unwind_cache (next_frame, this_prologue_cache);
d961 1
a961 2
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, bufferp);
d967 3
a969 1
  spu_frame_prev_register
a971 6
const struct frame_unwind *
spu_frame_sniffer (struct frame_info *next_frame)
{
  return &spu_frame_unwind;
}

d973 1
a973 1
spu_frame_base_address (struct frame_info *next_frame, void **this_cache)
d976 1
a976 1
    = spu_frame_unwind_cache (next_frame, this_cache);
d1190 1
a1190 1
spu_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d1192 3
a1194 2
  return frame_id_build (spu_unwind_sp (gdbarch, next_frame),
			 spu_unwind_pc (gdbarch, next_frame));
d2045 1
a2045 1
  set_gdbarch_unwind_dummy_id (gdbarch, spu_unwind_dummy_id);
d2050 1
a2050 1
  frame_unwind_append_sniffer (gdbarch, spu_frame_sniffer);
@


1.28
log
@2008-03-10  Hidetaka Takano  <hidetaka.takano@@glb.toshiba.co.jp>

	* spu-tdep.c (info_spu_event_command): Insert a '\0' to the end
	of the data passing to strtoulst function.
	(info_spu_signal_command): Likewise.
@
text
@d1207 3
a1209 2
spu_return_value (struct gdbarch *gdbarch, struct type *type,
                  struct regcache *regcache, gdb_byte *out, const gdb_byte *in)
@


1.27
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d1508 1
a1508 1
		     buf, 0, sizeof buf);
d1511 1
d1516 1
a1516 1
		     buf, 0, sizeof buf);
d1519 1
d1570 1
a1570 1
		     buf, 0, sizeof buf);
d1573 1
d1588 1
a1588 1
		     buf, 0, sizeof buf);
d1591 1
@


1.26
log
@	Updated copyright notices for most files.
@
text
@d703 1
a703 1
spu_skip_prologue (CORE_ADDR pc)
@


1.25
log
@2007-11-07  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (legacy_virtual_frame_pointer): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.
	* arch-utils.c (legacy_virtual_frame_pointer): Add gdbarch parameter.
	Replace current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* mips-tdep.c (mips_virtual_frame_pointer): Likewise.
	* spu-tdep.c (spu_virtual_frame_pointer): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
@


1.24
log
@*** empty log message ***
@
text
@d711 2
a712 1
spu_virtual_frame_pointer (CORE_ADDR pc, int *reg, LONGEST *offset)
@


1.23
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d1250 1
a1250 1
spu_breakpoint_from_pc (CORE_ADDR * pcptr, int *lenptr)
@


1.22
log
@2007-10-02  Markus Deuling  <deuling@@de.ibm.com>

	* spu-tdep.c (info_spu_signal_command): Fix output for SPU signal.
@
text
@d97 1
a97 1
spu_register_name (int reg_nr)
@


1.21
log
@ChangeLog gdb/:

	* spu-tdep.c (spu_pointer_to_address): New function.
	(spu_integer_to_address): Likewise.
	(spu_gdbarch_init): Add spu_pointer_to_address and
	spu_integer_to_address to gdbarch.


ChangeLog gdb/testsuite/:

	* gdb.cp/cp-relocate.exp (add-symbol-file): Change addresses
	to fit into SPU Local Store memory.
@
text
@d1608 2
a1610 2
      else
	printf_filtered (_("(Type Or)\n"));
d1618 2
a1620 2
      else
	printf_filtered (_("(Type Or)\n"));
@


1.21.2.1
log
@2007-10-02  Markus Deuling  <deuling@@de.ibm.com>

	* spu-tdep.c (info_spu_signal_command): Fix output for SPU signal.
@
text
@d1608 2
a1610 2
      else
	printf_filtered (_("(Type Overwrite)\n"));
d1618 2
a1620 2
      else
	printf_filtered (_("(Type Overwrite)\n"));
@


1.20
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d325 29
d2038 4
@


1.19
log
@	* gdbtypes.c (builtin_type_v2_double, builtin_type_v4_float,
	builtin_type_v2_int64, builtin_type_v4_int32, builtin_type_v8_int16,
	builtin_type_v16_int8, builtin_type_v2_float, builtin_type_v2_int32,
	builtin_type_v4_int16, builtin_type_v8_int8, builtin_type_v4sf,
	builtin_type_v4si, builtin_type_v16qi, builtin_type_v8qi,
	builtin_type_v8hi, builtin_type_v4hi, builtin_type_v2si,
	builtin_type_vec64, builtin_type_vec128): Remove.
	(init_simd_type): Remove.
	(init_vector_type): Make global.
	(build_builtin_type_vec64, build_builtin_type_vec128): Remove.
	(build_gdbtypes): Do not build vector types.
	(_initialize_gdbtypes): Do not swap vector types.
	* gdbtypes.h (builtin_type_v2_double, builtin_type_v4_float,
	builtin_type_v2_int64, builtin_type_v4_int32, builtin_type_v8_int16,
	builtin_type_v16_int8, builtin_type_v2_float, builtin_type_v2_int32,
	builtin_type_v4_int16, builtin_type_v8_int8, builtin_type_v4sf,
	builtin_type_v4si, builtin_type_v16qi, builtin_type_v8qi,
	builtin_type_v8hi, builtin_type_v4hi, builtin_type_v2si,
	builtin_type_vec64, builtin_type_vec128): Remove declarations.
	(init_vector_type): Add prototype.

	* i386-tdep.h (struct gdbarch_tdep): Add i386_mmx_type and
	i386_sse_type members.
	(i386_mmx_type, i386_sse_type): Change from variables to functions.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Remove variables.
	(i386_init_types): Do not build vector types.
	(i386_mmx_type, i386_sse_type): New functions.
	(i386_register_type): Call them instead of using global variables.
	(i386_gdbarch_init): Use XCALLOC to allocate tdep structure.
	* amd64-tdep.c (amd64_register_type): Call i386_sse_type instead
	of using global variable.

	* rs6000-tdep.h (struct gdbarch_tdep): Add ppc_builtin_type_vec64
	and ppc_builtin_type_vec128 members.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): New function.
	(rs6000_builtin_type_vec128): Likewise.
	(rs6000_register_type): Call them instead of using builtin_type_vec64
	and builtin_type_vec128.
	(rs6000_gdbarch_init): Use XCALLOC to allocate tdep structure.

	* spu-tdep.c (struct gdbarch_tdep): New data type.
	(spu_builtin_type_vec128): Remove variable.
	(spu_builtin_type_vec128): New function.
	(spu_register_type): Call it instead of using global variable.
	(spu_gdbarch_init): Allocate tdep structure.
	(spu_init_vector_type): Remove function.
	(_initialize_spu_tdep): Do not call it.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.18
log
@	* gdbarch.sh (read_pc): Add REGCACHE argument.  Remove PTID argument.
	(write_pc): Likewise.  Remove default implementation, add predicate.
	* gdbarch.c, gdbarch.h: Regenerate.
	* regcache.c (read_pc_pid): Use current regcache instead of calling
	read_register_pid.
	(write_pc_pid): Check gdbarch_write_pc predicate, implement default
	case inline.
	(generic_target_write_pc): Remove.
	* inferior.h (generic_target_write_pc): Remove.
	* frv-tdep.c (frv_gdbarch_init): Do not install it.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Likewise.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	* sh64-tdep.c (sh64_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.

	* avr-tdep.c (avr_read_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling read_register_pid.
	* hppa-hpux-tdep.c (hppa_hpux_read_pc): Likewise.
	* hppa-tdep.c (hppa_read_pc): Likewise.
	* hppa-tdep.h (hppa_read_pc): Likewise.
	* ia64-tdep.c (ia64_read_pc): Likewise.
	* m32r-tdep.c (m32r_read_pc): Likewise.
	* mep-tdep.c (mep_read_pc): Likewise.
	* mn10300-tdep.c (mn10300_read_pc): Likewise.
	* spu-tdep.c (spu_read_pc): Likewise.

	* arm-tdep.c (arm_write_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling write_register_pid.
	* avr-tdep.c (avr_write_pc): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_write_pc): Likewise.
	* hppa-tdep.c (hppa_write_pc): Likewise.
	* hppa-tdep.h (hppa_write_pc): Likewise.
	* i386-linux-tdep.c (i386_linux_write_pc): Likewise.
	* amd64-linux-tdep.c (amd64_linux_write_pc): Likewise.
	* ia64-linux-tdep.c (ia64_linux_write_pc): Likewise.
	* ia64-tdep.c (ia64_write_pc): Likewise.
	* ia64-tdep.h (ia64_write_pc): Likewise.
	* m32r-tdep.c (m32r_write_pc): Likewise.
	* m88k-tdep.c (m88k_write_pc): Likewise.
	* mep-tdep.c (mep_write_pc): Likewise.
	* mips-tdep.c (mips_write_pc): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.
	* mn10300-tdep.c (mn10300_write_pc): Likewise.
	* sparc-tdep.c (sparc_write_pc): Likewise.
	* spu-tdep.c (spu_write_pc): Likewise.

	* mips-tdep.c (read_signed_register): Remove.
	(read_signed_register_pid): Likewise.
	(mips_read_pc): Add REGCACHE argument.  Remove PTID argument.
	Use REGCACHE instead of calling read_signed_register_pid.
@
text
@d49 9
d59 33
a91 1
struct type *spu_builtin_type_vec128;
d134 1
a134 1
    return spu_builtin_type_vec128;
d1964 1
d1976 2
a1977 1
  gdbarch = gdbarch_alloc (&info, NULL);
a2040 21
/* Implement a SPU-specific vector type as replacement
   for __gdb_builtin_type_vec128.  */
static void
spu_init_vector_type (void)
{
  struct type *type;

  type = init_composite_type ("__spu_builtin_type_vec128", TYPE_CODE_UNION);
  append_composite_type_field (type, "uint128", builtin_type_int128);
  append_composite_type_field (type, "v2_int64", builtin_type_v2_int64);
  append_composite_type_field (type, "v4_int32", builtin_type_v4_int32);
  append_composite_type_field (type, "v8_int16", builtin_type_v8_int16);
  append_composite_type_field (type, "v16_int8", builtin_type_v16_int8);
  append_composite_type_field (type, "v2_double", builtin_type_v2_double);
  append_composite_type_field (type, "v4_float", builtin_type_v4_float);

  TYPE_FLAGS (type) |= TYPE_FLAG_VECTOR;
  TYPE_NAME (type) = "spu_builtin_type_vec128";
  spu_builtin_type_vec128 = type;
}

a2045 2
  spu_init_vector_type ();

@


1.17
log
@	* gdbarch.sh (software_single_step): Replace REGCACHE argument by
	FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* infrun.c (resume): Pass current frame to SOFTWARE_SINGLE_STEP.

	* alpha-tdep.c (alpha_next_pc): Add FRAME argument.  Retrieve
	registers from FRAME instead of using read_register.
	(alpha_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to alpha_next_pc.  Use get_frame_pc instead of read_pc.
	* alpha-tdep.h (alpha_software_single_step): Replace REGCACHE
	argument by FRAME.

	* arm-tdep.c (shifted_reg_val): Add FRAME argument.  Read registers
	from FRAME instead of using read_register.
	(thumb_get_next_pc): Likewise.
	(arm_get_next_pc): Likewise.
	(arm_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to arm_get_next_pc.  Use get_frame_pc instead of read_register.
	* arm-tdep.h (arm_software_single_step): Replace REGCACHE
	argument by FRAME.

	* cris-tdep.c (find_step_target): Add FRAME argument.  Read registers
	from FRAME instead of using read_register.
	(cris_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to find_step_target.

	* mips-tdep.c (mips32_next_pc): Add FRAME argument.  Read registers
	from FRAME instead of using read_register / read_signed_register.
	(extended_mips16_next_pc): Likewise.
	(mips16_next_pc): Likewise.
	(mips_next_pc): Likewise.
	(mips_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to mips_next_pc.  Use get_frame_pc instead of read_pc.
	* mips-tdep.h (mips_software_single_step): Replace REGCACHE
	argument by FRAME.

	* rs6000-tdep.c (branch_dest): Add FRAME argument.  Use it instead
	of current frame.  Read registers from FRAME.
	(deal_with_atomic_sequence): Add FRAME argument.  Pass it to
	branch_dest.  Use get_frame_pc instead of read_pc.
	(rs6000_software_single_step): Likewise.
	(bl_to_blrl_insn_p): Do not call branch_dest.
	* rs6000-tdep.h (rs6000_software_single_step): Replace REGCACHE
	argument by FRAME.

	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Add FRAME argument.
	Read registers from FRAME instead of current regcache.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Likewise.
	* sparcnbsd-tdep.c (sparcnbsd_step_trap): Likewise.
	* sparc-tdep.c (sparc_address_from_register): Remove.
	(sparc_analyze_control_transfer): Pass FRAME argument instead of
	GDBARCH.  Pass FRAME to step_trap callback.
	(sparc_step_trap): Add FRAME argument.
	(space_software_single_step): Replace REGCACHE by FRAME.  Pass FRAME
	to sparc_analyze_control_transfer.  Read registers from FRAME instead
	of calling sparc_address_from_register.
	* sparc-tdep.h (struct gdbarch_tdep): Add FRAME argument to
	step_trap callback.
	(sparc_address_from_register): Remove prototype.
	(sparc_software_single_step): Replace REGCACHE argument by FRAME.
	(sparcnbsd_step_trap): Add FRAME argument.

	* spu-tdep.c (spu_software_single_step): Replace REGCACHE argument
	by FRAME.  Read registers from FRAME instead of REGCACHE.
@
text
@d941 1
a941 1
spu_read_pc (ptid_t ptid)
d943 2
a944 1
  CORE_ADDR pc = read_register_pid (SPU_PC_REGNUM, ptid);
d950 1
a950 1
spu_write_pc (CORE_ADDR pc, ptid_t ptid)
d953 4
a956 2
  CORE_ADDR old_pc = read_register_pid (SPU_PC_REGNUM, ptid);
  write_register_pid (SPU_PC_REGNUM, (pc & -4) | (old_pc & 3), ptid);
@


1.16
log
@
	* target.h (enum target_object): Add TARGET_OBJECT_SPU.
	* spu-linux-nat.c (spu_xfer_partial): Handle TARGET_OBJECT_SPU.

	* spu-tdep.h (SPU_NUM_PSEUDO_REGS): Add 5 pseudo registers.
	(enum spu_regnum): Add SPU_FPSCR_REGNUM, SPU_SRR0_REGNUM,
	SPU_LSLR_REGNUM, SPU_DECR_REGNUM, SPU_DECR_STATUS_REGNUM.
	* spu-tdep.c (infospucmdlist): New variable.
	(spu_register_name): Handle additional pseudo registers.
	(spu_register_type): Likewise.
	(spu_pseudo_register_read): Likewise.
	(spu_pseudo_register_write): Likewise.
	(spu_pseudo_register_read_spu): New function.
	(spu_pseudo_register_write_spu): Likewise.
	(info_spu_event_command): New function.
	(info_spu_signal_command): Likewise.
	(info_spu_mailbox_list): Likewise.
	(info_spu_mailbox_command): Likewise.
	(spu_mfc_get_bitfield): Likewise.
	(info_spu_dma_cmdlist): Likewise.
	(info_spu_dma_command): Likewise.
	(info_spu_proxydma_command): Likewise.
	(info_spu_command): Likewise.
	(_initialize_spu_tdep): Install "info spu" commands.

testsuite/ChangeLog:

	* gdb.arch/spu-info.exp: New testcase.
	* gdb.arch/spu-info.c: New file.

doc/ChangeLog:

	* gdb.texinfo (Architectures): Add new SPU section to document
	Cell Broadband Engine SPU architecture specific commands.
@
text
@d1191 1
a1191 1
spu_software_single_step (struct regcache *regcache)
d1198 1
a1198 3
  regcache_cooked_read (regcache, SPU_PC_REGNUM, buf);
  /* Mask off interrupt enable bit.  */
  pc = extract_unsigned_integer (buf, 4) & -4;
d1222 1
a1222 1
	  regcache_cooked_read_part (regcache, reg, 0, 4, buf);
@


1.15
log
@	* spu-tdep.c (spu_push_dummy_call): Store stack back chain.
@
text
@d52 3
d78 1
a78 1
      "id", "pc", "sp"
d106 15
d129 17
d150 2
d160 22
d188 16
d208 2
d219 22
d1420 496
d2028 22
@


1.14
log
@	* spu-tdep.c (spu_frame_unwind_cache): Add comment.
@
text
@d1016 4
@


1.13
log
@	* spu-tdep.c: Include "observer.h".
	(spu_frame_unwind_cache): Unwind PC through overlay return stubs.
	(spu_overlay_data): New variable.
	(struct spu_overlay_table): New type.
	(spu_get_overlay_table, spu_overlay_update_osect, spu_overlay_update,
	spu_overlay_new_objfile): New functions.
	(spu_gdbarch_init): Install spu_overlay_update.
	(_initialize_spu_tdep): Register spu_overlay_new_objfile,
	allocate spu_overlay_data objfile data.
@
text
@d746 2
a747 2
  /* The previous PC comes from the link register.  In the case
     of overlay return stubs, we unwind to the real return address.  */
d753 6
@


1.12
log
@	* gdbarch.sh (software_single_step): Remove "insert_breakpoints_p" and
	"sig" arguments, add "regcache" argument.
	* gdbarch.c, gdbarch.h: Regenerate.

	* infrun.c (resume): Update SOFTWARE_SINGLE_STEP call arguments.
	(handle_inferior_event): Call remove_single_step_breakpoints directly
	instead of calling SOFTWARE_SINGLE_STEP to remove breakpoints.

	* alpha-tdep.c (alpha_software_single_step): Update argument list.
	Remove handling of !insert_breakpoints_p case.
	* arm-tdep.c (arm_software_single_step): Likewise.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* spu-tdep.c (spu_software_single_step): Likewise.

	* alpha-tdep.h (alpha_software_single_step): Update prototype.
	* mips-tdep.h (mips_software_single_step): Likewise.
	* rs6000-tdep.h (rs6000_software_single_step): Likewise.
	* sparc-tdep.h (sparc_software_single_step): Likewise.
@
text
@d45 1
d675 1
a702 1
      gdb_byte buf[16];
a714 9
      /* The previous PC comes from the link register.  */
      if (trad_frame_addr_p (info->saved_regs, SPU_LR_REGNUM))
	info->saved_regs[SPU_PC_REGNUM] = info->saved_regs[SPU_LR_REGNUM];
      else
	info->saved_regs[SPU_PC_REGNUM].realreg = SPU_LR_REGNUM;

      /* The previous SP is equal to the CFA.  */
      trad_frame_set_value (info->saved_regs, SPU_SP_REGNUM, cfa);

a736 9
	  /* This will also be the previous PC.  */
	  if (trad_frame_addr_p (info->saved_regs, SPU_LR_REGNUM))
	    info->saved_regs[SPU_PC_REGNUM] = info->saved_regs[SPU_LR_REGNUM];
	  else
	    info->saved_regs[SPU_PC_REGNUM].realreg = SPU_LR_REGNUM;

	  /* The previous SP will equal the backchain value.  */
	  trad_frame_set_value (info->saved_regs, SPU_SP_REGNUM, backchain);

d742 17
d1127 183
d1386 3
d1419 4
@


1.11
log
@2007-04-12  Luis Machado  <luisgpm@@br.ibm.com>

	* gdbarch.sh (software_single_step): Change the return type
	from void to int and reformatted some comments to <= 80
	columns.
	* gdbarch.c, gdbarch.h: Regenerated.
	* alpha-tdep.c (alpha_software_single_step): Likewise.
	* alpha-tdep.h (alpha_software_single_step): Likewise.
	* arm-tdep.c (arm_software_single_step): Likewise.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* mips-tdep.h (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* rs6000-tdep.h (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* sparc-tdep.h (sparc_software_single_step): Likewise.
	* spu-tdep.c (spu_software_single_step): Likewise.
	* infrun.c (resume): Check the return value from SOFTWARE_SINGLE_STEP
	and act accordingly.
@
text
@d1082 1
a1082 1
spu_software_single_step (enum target_signal signal, int insert_breakpoints_p)
d1084 24
a1107 1
  if (insert_breakpoints_p)
d1109 1
a1109 22
      CORE_ADDR pc, next_pc;
      unsigned int insn;
      int offset, reg;
      gdb_byte buf[4];

      regcache_cooked_read (current_regcache, SPU_PC_REGNUM, buf);
      /* Mask off interrupt enable bit.  */
      pc = extract_unsigned_integer (buf, 4) & -4;

      if (target_read_memory (pc, buf, 4))
	return 1;
      insn = extract_unsigned_integer (buf, 4);

       /* Next sequential instruction is at PC + 4, except if the current
	  instruction is a PPE-assisted call, in which case it is at PC + 8.
	  Wrap around LS limit to be on the safe side.  */
      if ((insn & 0xffffff00) == 0x00002100)
	next_pc = (pc + 8) & (SPU_LS_SIZE - 1);
      else
	next_pc = (pc + 4) & (SPU_LS_SIZE - 1);

      insert_single_step_breakpoint (next_pc);
d1111 3
a1113 1
      if (is_branch (insn, &offset, &reg))
d1115 3
a1117 1
	  CORE_ADDR target = offset;
d1119 3
a1121 12
	  if (reg == SPU_PC_REGNUM)
	    target += pc;
	  else if (reg != -1)
	    {
	      regcache_cooked_read_part (current_regcache, reg, 0, 4, buf);
	      target += extract_unsigned_integer (buf, 4) & -4;
	    }

	  target = target & (SPU_LS_SIZE - 1);
	  if (target != next_pc)
	    insert_single_step_breakpoint (target);
	}
a1122 2
  else
    remove_single_step_breakpoints ();
@


1.10
log
@	* spu-tdep.c (spu_in_function_epilogue_p): New function.
	(spu_gdbarch_init): Install it.
@
text
@d1081 1
a1081 1
void
d1096 1
a1096 1
	return;
d1128 2
@


1.9
log
@	* spu-tdep.c (spu_frame_align): New function.
	(spu_gdbarch_init): Install it.  Set call dummy location to ON_STACK.
@
text
@d562 95
d1198 1
@


1.8
log
@	* spu-tdep.c (spu_unwind_pc): Mask off interrupt enable bit.
	(spu_software_single_step): Likewise.
	(spu_read_pc, spu_write_pc): New functions.
	(spu_gdbarch_init): Install them.
@
text
@d759 6
d1088 2
@


1.7
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@d729 3
a731 1
  return frame_unwind_register_unsigned (next_frame, SPU_PC_REGNUM);
d740 16
d991 2
a992 1
      pc = extract_unsigned_integer (buf, 4);
d1002 1
a1002 1
	next_pc = (pc + 8) & (SPU_LS_SIZE - 1) & -4;
d1004 1
a1004 1
	next_pc = (pc + 4) & (SPU_LS_SIZE - 1) & -4;
d1017 1
a1017 1
	      target += extract_unsigned_integer (buf, 4);
d1020 1
a1020 1
	  target = target & (SPU_LS_SIZE - 1) & -4;
d1057 2
@


1.6
log
@	* doublest.c (floatformat_from_length): Use the right element from
	gdbarch floatformats.
	(floatformat_from_type, extract_typed_floating)
	(store_typed_floating): Likewise.
	* doublest.h: Remove declarations for undefined floatformat arrays.
	* gdbarch.sh (float_format, double_format, long_double_format): Change
	to pairs.
	(pformat): Update for pairs.
	* gdbarch.c, gdbarch.h: Regenerated.
	* gdbtypes.c (floatformats_ieee_single, floatformats_ieee_double)
	(floatformats_ieee_double_littlebyte_bigword)
	(floatformats_i387_ext, floatformats_m68881_ext, floatformats_arm_ext)
	(floatformats_ia64_spill, floatformats_ia64_quad, floatformats_vax_f)
	(floatformats_vax_d): New variables.
	(builtin_type_ieee_single, builtin_type_ieee_double)
	(builtin_type_arm_ext, builtin_type_ia64_spill)
	(builtin_type_ia64_quad): Replace arrays with individual types.
	(builtin_type_ieee_single_big, builtin_type_ieee_single_little)
	(builtin_type_ieee_double_big, builtin_type_ieee_double_little)
	(builtin_type_ieee_double_littlebyte_bigword, builtin_type_i960_ext)
	(builtin_type_m88110_ext, builtin_type_m88110_harris_ext)
	(builtin_type_arm_ext_big, builtin_type_arm_ext_littlebyte_bigword)
	(builtin_type_ia64_spill_big, builtin_type_ia64_spill_little)
	(builtin_type_ia64_quad_big, builtin_type_ia64_quad_little): Delete
	unused and endian-specific types.
	(recursive_dump_type): Update for floatformat pairs.
	(build_flt): Move higher.  Handle bit == -1.  Take a floatformat pair.
	(build_gdbtypes): Use build_flt.
	(_initialize_gdbtypes): Update set of initialized types.
	* gdbtypes.h: Update declarations to match gdbtypes.c.
	(struct main_type): Store a pointer to two floatformats.
	* arch-utils.c (default_float_format, default_double_format): Delete.
	* arch-utils.h (default_float_format, default_double_format): Delete.

	* arm-tdep.c, avr-tdep.c, hppa-tdep.c, hppabsd-tdep.c, i386-tdep.c,
	ia64-tdep.c,  iq2000-tdep.c, m68k-tdep.c, m88k-tdep.c,
	mips-linux-tdep.c, mips-tdep.c, mt-tdep.c, ppcobsd-tdep.c,
	sparc-linux-tdep.c, sparc-tdep.c, sparcnbsd-tdep.c, spu-tdep.c,
	vax-tdep.c, alpha-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d590 1
a590 1
  info->func = frame_func_unwind (next_frame);
@


1.5
log
@	* spu-tdep.c (spu_analyze_prologue): Fix erroneous backtrace
	past entry function with recent newlib.
@
text
@d1056 3
a1058 3
  set_gdbarch_float_format (gdbarch, &floatformat_ieee_single_big);
  set_gdbarch_double_format (gdbarch, &floatformat_ieee_double_big);
  set_gdbarch_long_double_format (gdbarch, &floatformat_ieee_double_big);
@


1.4
log
@Copyright updates for 2007.
@
text
@d481 3
d489 3
@


1.3
log
@	* gdbarch.sh (value_from_register): New gdbarch function.
	* gdbarch.c, gdbarch.h: Regenerate.
	* findvar.c (default_value_from_register): New function.
	(value_from_register): Use gdbarch_value_from_register.
	* value.h (default_value_from_register): Declare.
	* spu-tdep.c (spu_convert_register_p, spu_register_to_value,
	spu_value_to_register): Remove.
	(spu_value_from_register): New function.
	(spu_gdbarch_init): Do not call set_gdbarch_convert_register_p,
	set_gdbarch_register_to_value, set_gdbarch_value_to_register.
	Call set_gdbarch_value_from_register.
	* s390-tdep.c (s390_convert_register_p, s390_register_to_value,
	s390_value_to_register): Remove.
	(s390_value_from_register): New function.
	(s390_gdbarch_init): Do not call set_gdbarch_convert_register_p,
	set_gdbarch_register_to_value, set_gdbarch_value_to_register.
	Call set_gdbarch_value_from_register.
@
text
@d2 1
a2 1
   Copyright (C) 2006 Free Software Foundation, Inc.
@


1.2
log
@2006-12-13  Markus Deuling  <deuling@@de.ibm.com>

	* spu-tdep.c (spu_init_vector_type): New function.
	(spu_builtin_type_vec128.): New static variable.
	(spu_register_type): Return spu_builtin_type_vec128 as default.
	(_initialize_spu_tdep): Call spu_init_vector_type.
@
text
@d148 3
a150 2
static int
spu_convert_register_p (int regno, struct type *type)
d152 2
a153 2
  return regno < SPU_NUM_GPRS && TYPE_LENGTH (type) < 16;
}
d155 5
a159 12
static void
spu_register_to_value (struct frame_info *frame, int regnum,
                       struct type *valtype, gdb_byte *out)
{
  gdb_byte in[16];
  int len = TYPE_LENGTH (valtype);
  int preferred_slot = len < 4 ? 4 - len : 0;
  gdb_assert (len < 16);

  get_frame_register (frame, regnum, in);
  memcpy (out, in + preferred_slot, len);
}
d161 1
a161 12
static void
spu_value_to_register (struct frame_info *frame, int regnum,
                       struct type *valtype, const gdb_byte *in)
{
  gdb_byte out[16];
  int len = TYPE_LENGTH (valtype);
  int preferred_slot = len < 4 ? 4 - len : 0;
  gdb_assert (len < 16);

  memset (out, 0, 16);
  memcpy (out + preferred_slot, in, len);
  put_frame_register (frame, regnum, out);
d1036 1
a1036 3
  set_gdbarch_convert_register_p (gdbarch, spu_convert_register_p);
  set_gdbarch_register_to_value (gdbarch, spu_register_to_value);
  set_gdbarch_value_to_register (gdbarch, spu_value_to_register);
@


1.1
log
@	* config/powerpc/spu-linux.mh: New file.
	* config/spu/spu.mt: New file.
	* configure.ac: Provide gdb_native configuration variable.
	* configure: Regenerate.
	* configure.host: Support powerpc64 to spu 'pseudo-native' mode.
	* configure.tgt: Add "spu" target_cpu and "spu*-*-*" target.
	* Makefile.in (spu_tdep_h): New variable.
	(ALLDEPFILES): Add spu-linux-nat.c and spu-tdep.c
	(spu-linux-nat.o, spu-tdep.o): Add dependencies.
	* spu-linux-nat.c: New file.
	* spu-tdep.c: New file.
	* spu-tdep.h: New file.
@
text
@d48 2
d89 1
a89 1
    return builtin_type_vec128;
d1097 21
d1122 2
@


1.1.2.1
log
@	* config/powerpc/spu-linux.mh: New file.
	* config/spu/spu.mt: New file.
	* configure.ac: Provide gdb_native configuration variable.
	* configure: Regenerate.
	* configure.host: Support powerpc64 to spu 'pseudo-native' mode.
	* configure.tgt: Add "spu" target_cpu and "spu*-*-*" target.
	* Makefile.in (spu_tdep_h): New variable.
	(ALLDEPFILES): Add spu-linux-nat.c and spu-tdep.c
	(spu-linux-nat.o, spu-tdep.o): Add dependencies.
	* spu-linux-nat.c: New file.
	* spu-tdep.c: New file.
	* spu-tdep.h: New file.
@
text
@@

