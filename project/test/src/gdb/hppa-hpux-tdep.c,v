head	1.92;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.87
	gdb_7_6-2013-04-26-release:1.87
	gdb_7_6-branch:1.87.0.2
	gdb_7_6-2013-03-12-branchpoint:1.87
	gdb_7_5_1-2012-11-29-release:1.85
	gdb_7_5-2012-08-17-release:1.85
	gdb_7_5-branch:1.85.0.2
	gdb_7_5-2012-07-18-branchpoint:1.85
	gdb_7_4_1-2012-04-26-release:1.81.4.1
	gdb_7_4-2012-01-24-release:1.81.4.1
	gdb_7_4-branch:1.81.0.4
	gdb_7_4-2011-12-13-branchpoint:1.81
	gdb_7_3_1-2011-09-04-release:1.81
	gdb_7_3-2011-07-26-release:1.81
	gdb_7_3-branch:1.81.0.2
	gdb_7_3-2011-04-01-branchpoint:1.81
	gdb_7_2-2010-09-02-release:1.77
	gdb_7_2-branch:1.77.0.4
	gdb_7_2-2010-07-07-branchpoint:1.77
	gdb_7_1-2010-03-18-release:1.77
	gdb_7_1-branch:1.77.0.2
	gdb_7_1-2010-02-18-branchpoint:1.77
	gdb_7_0_1-2009-12-22-release:1.76
	gdb_7_0-2009-10-06-release:1.76
	gdb_7_0-branch:1.76.0.4
	gdb_7_0-2009-09-16-branchpoint:1.76
	arc-sim-20090309:1.68
	msnyder-checkpoint-072509-branch:1.76.0.2
	msnyder-checkpoint-072509-branchpoint:1.76
	arc-insight_6_8-branch:1.68.0.6
	arc-insight_6_8-branchpoint:1.68
	insight_6_8-branch:1.68.0.4
	insight_6_8-branchpoint:1.68
	reverse-20081226-branch:1.72.0.6
	reverse-20081226-branchpoint:1.72
	multiprocess-20081120-branch:1.72.0.4
	multiprocess-20081120-branchpoint:1.72
	reverse-20080930-branch:1.72.0.2
	reverse-20080930-branchpoint:1.72
	reverse-20080717-branch:1.69.0.4
	reverse-20080717-branchpoint:1.69
	msnyder-reverse-20080609-branch:1.69.0.2
	msnyder-reverse-20080609-branchpoint:1.69
	drow-reverse-20070409-branch:1.53.0.2
	drow-reverse-20070409-branchpoint:1.53
	gdb_6_8-2008-03-27-release:1.68
	gdb_6_8-branch:1.68.0.2
	gdb_6_8-2008-02-26-branchpoint:1.68
	gdb_6_7_1-2007-10-29-release:1.62
	gdb_6_7-2007-10-10-release:1.62
	gdb_6_7-branch:1.62.0.2
	gdb_6_7-2007-09-07-branchpoint:1.62
	insight_6_6-20070208-release:1.52
	gdb_6_6-2006-12-18-release:1.52
	gdb_6_6-branch:1.52.0.6
	gdb_6_6-2006-11-15-branchpoint:1.52
	insight_6_5-20061003-release:1.52
	gdb-csl-symbian-6_4_50_20060226-12:1.50
	gdb-csl-sourcerygxx-3_4_4-25:1.43
	nickrob-async-20060828-mergepoint:1.52
	gdb-csl-symbian-6_4_50_20060226-11:1.50
	gdb-csl-sourcerygxx-4_1-17:1.50
	gdb-csl-20060226-branch-local-2:1.50
	gdb-csl-sourcerygxx-4_1-14:1.50
	gdb-csl-sourcerygxx-4_1-13:1.50
	gdb-csl-sourcerygxx-4_1-12:1.50
	gdb-csl-sourcerygxx-3_4_4-21:1.50
	gdb_6_5-20060621-release:1.52
	gdb-csl-sourcerygxx-4_1-9:1.50
	gdb-csl-sourcerygxx-4_1-8:1.50
	gdb-csl-sourcerygxx-4_1-7:1.50
	gdb-csl-arm-2006q1-6:1.50
	gdb-csl-sourcerygxx-4_1-6:1.50
	gdb-csl-symbian-6_4_50_20060226-10:1.50
	gdb-csl-symbian-6_4_50_20060226-9:1.50
	gdb-csl-symbian-6_4_50_20060226-8:1.50
	gdb-csl-coldfire-4_1-11:1.50
	gdb-csl-sourcerygxx-3_4_4-19:1.50
	gdb-csl-coldfire-4_1-10:1.50
	gdb_6_5-branch:1.52.0.4
	gdb_6_5-2006-05-14-branchpoint:1.52
	gdb-csl-sourcerygxx-4_1-5:1.50
	nickrob-async-20060513-branch:1.52.0.2
	nickrob-async-20060513-branchpoint:1.52
	gdb-csl-sourcerygxx-4_1-4:1.50
	msnyder-reverse-20060502-branch:1.51.0.8
	msnyder-reverse-20060502-branchpoint:1.51
	gdb-csl-morpho-4_1-4:1.50
	gdb-csl-sourcerygxx-3_4_4-17:1.50
	readline_5_1-import-branch:1.51.0.6
	readline_5_1-import-branchpoint:1.51
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.50
	gdb-csl-symbian-20060226-branch:1.50.0.4
	gdb-csl-symbian-20060226-branchpoint:1.50
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.50
	msnyder-reverse-20060331-branch:1.51.0.4
	msnyder-reverse-20060331-branchpoint:1.51
	gdb-csl-available-20060303-branch:1.51.0.2
	gdb-csl-available-20060303-branchpoint:1.51
	gdb-csl-20060226-branch:1.50.0.2
	gdb-csl-20060226-branchpoint:1.50
	gdb_6_4-20051202-release:1.43
	msnyder-fork-checkpoint-branch:1.45.0.2
	msnyder-fork-checkpoint-branchpoint:1.45
	gdb-csl-gxxpro-6_3-branch:1.43.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.43
	gdb_6_4-branch:1.43.0.2
	gdb_6_4-2005-11-01-branchpoint:1.43
	gdb-csl-arm-20051020-branch:1.42.0.2
	gdb-csl-arm-20051020-branchpoint:1.42
	msnyder-tracepoint-checkpoint-branch:1.41.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.41
	gdb-csl-arm-20050325-2005-q1b:1.41
	gdb-csl-arm-20050325-2005-q1a:1.41
	csl-arm-20050325-branch:1.41.0.2
	csl-arm-20050325-branchpoint:1.41
	gdb-post-i18n-errorwarning-20050211:1.41
	gdb-pre-i18n-errorwarning-20050211:1.40
	gdb_6_3-20041109-release:1.23
	gdb_6_3-branch:1.23.0.2
	gdb_6_3-20041019-branchpoint:1.23
	drow_intercu-merge-20040921:1.23
	drow_intercu-merge-20040915:1.23
	jimb-gdb_6_2-e500-branch:1.21.0.6
	jimb-gdb_6_2-e500-branchpoint:1.21
	gdb_6_2-20040730-release:1.21
	gdb_6_2-branch:1.21.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.21
	gdb_6_1_1-20040616-release:1.11
	gdb_6_1-2004-04-05-release:1.11
	drow_intercu-merge-20040402:1.12
	drow_intercu-merge-20040327:1.12
	ezannoni_pie-20040323-branch:1.12.0.2
	ezannoni_pie-20040323-branchpoint:1.12
	cagney_tramp-20040321-mergepoint:1.11
	cagney_tramp-20040309-branch:1.11.0.12
	cagney_tramp-20040309-branchpoint:1.11
	gdb_6_1-branch:1.11.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.11
	drow_intercu-20040221-branch:1.11.0.8
	drow_intercu-20040221-branchpoint:1.11
	cagney_bfdfile-20040213-branch:1.11.0.6
	cagney_bfdfile-20040213-branchpoint:1.11
	drow-cplus-merge-20040208:1.11
	carlton_dictionary-20040126-merge:1.11
	cagney_bigcore-20040122-branch:1.11.0.4
	cagney_bigcore-20040122-branchpoint:1.11
	drow-cplus-merge-20040113:1.11
	drow-cplus-merge-20031224:1.11
	drow-cplus-merge-20031220:1.11
	carlton_dictionary-20031215-merge:1.11
	drow-cplus-branch:1.11.0.2
	drow-cplus-merge-20031214:1.11
	carlton-dictionary-20031111-merge:1.11
	gdb_6_0-2003-10-04-release:1.7.6.1
	kettenis_sparc-20030918-branch:1.10.0.6
	kettenis_sparc-20030918-branchpoint:1.10
	carlton_dictionary-20030917-merge:1.10
	ezannoni_pie-20030916-branchpoint:1.10
	ezannoni_pie-20030916-branch:1.10.0.4
	cagney_x86i386-20030821-branch:1.10.0.2
	cagney_x86i386-20030821-branchpoint:1.10
	carlton_dictionary-20030805-merge:1.8
	carlton_dictionary-20030627-merge:1.7
	gdb_6_0-branch:1.7.0.6
	gdb_6_0-2003-06-23-branchpoint:1.7
	jimb-ppc64-linux-20030613-branch:1.7.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.7
	cagney_convert-20030606-branch:1.7.0.2
	cagney_convert-20030606-branchpoint:1.7
	cagney_writestrings-20030508-branch:1.6.0.10
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.8
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.6
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.2
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.2
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.2
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.3.0.14
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.12
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.10
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.8
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.6
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030203-mergepoint:1.3
	interps-20030202-branch:1.3.0.4
	interps-20030202-branchpoint:1.3
	cagney-unwind-20030108-branch:1.3.0.2
	cagney-unwind-20030108-branchpoint:1.3
	carlton_dictionary-branch:1.2.0.2
	carlton_dictionary-20021223-merge:1.2;
locks; strict;
comment	@ * @;


1.92
date	2013.06.24.22.18.31;	author macro;	state Exp;
branches;
next	1.91;

1.91
date	2013.04.19.15.09.45;	author palves;	state Exp;
branches;
next	1.90;

1.90
date	2013.04.08.20.18.11;	author tromey;	state Exp;
branches;
next	1.89;

1.89
date	2013.04.08.19.59.08;	author tromey;	state Exp;
branches;
next	1.88;

1.88
date	2013.03.22.14.43.28;	author palves;	state Exp;
branches;
next	1.87;

1.87
date	2013.03.01.15.38.24;	author palves;	state Exp;
branches;
next	1.86;

1.86
date	2013.01.01.06.32.44;	author brobecke;	state Exp;
branches;
next	1.85;

1.85
date	2012.05.18.21.02.48;	author sergiodj;	state Exp;
branches;
next	1.84;

1.84
date	2012.02.02.20.19.14;	author devans;	state Exp;
branches;
next	1.83;

1.83
date	2012.01.04.08.17.03;	author brobecke;	state Exp;
branches;
next	1.82;

1.82
date	2011.12.21.21.34.25;	author tromey;	state Exp;
branches;
next	1.81;

1.81
date	2011.03.18.18.52.30;	author palves;	state Exp;
branches
	1.81.4.1;
next	1.80;

1.80
date	2011.02.27.16.25.37;	author msnyder;	state Exp;
branches;
next	1.79;

1.79
date	2011.01.09.03.08.54;	author msnyder;	state Exp;
branches;
next	1.78;

1.78
date	2011.01.01.15.33.05;	author brobecke;	state Exp;
branches;
next	1.77;

1.77
date	2010.01.01.07.31.33;	author brobecke;	state Exp;
branches;
next	1.76;

1.76
date	2009.07.02.17.25.54;	author uweigand;	state Exp;
branches;
next	1.75;

1.75
date	2009.05.05.13.24.48;	author uweigand;	state Exp;
branches;
next	1.74;

1.74
date	2009.01.18.01.24.12;	author palves;	state Exp;
branches;
next	1.73;

1.73
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.72;

1.72
date	2008.09.05.11.37.17;	author uweigand;	state Exp;
branches;
next	1.71;

1.71
date	2008.08.21.18.14.39;	author drow;	state Exp;
branches;
next	1.70;

1.70
date	2008.08.21.13.19.18;	author palves;	state Exp;
branches;
next	1.69;

1.69
date	2008.05.08.04.21.45;	author brobecke;	state Exp;
branches;
next	1.68;

1.68
date	2008.02.18.16.11.21;	author deuling;	state Exp;
branches;
next	1.67;

1.67
date	2008.01.16.11.21.42;	author deuling;	state Exp;
branches;
next	1.66;

1.66
date	2008.01.01.22.53.10;	author drow;	state Exp;
branches;
next	1.65;

1.65
date	2007.10.24.21.14.17;	author uweigand;	state Exp;
branches;
next	1.64;

1.64
date	2007.10.12.15.34.45;	author uweigand;	state Exp;
branches;
next	1.63;

1.63
date	2007.10.08.12.50.56;	author uweigand;	state Exp;
branches;
next	1.62;

1.62
date	2007.08.23.18.08.33;	author brobecke;	state Exp;
branches;
next	1.61;

1.61
date	2007.06.15.22.44.55;	author uweigand;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.15.22.42.22;	author uweigand;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.15.22.39.52;	author uweigand;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.13.17.30.01;	author uweigand;	state Exp;
branches;
next	1.57;

1.57
date	2007.06.05.22.47.50;	author uweigand;	state Exp;
branches;
next	1.56;

1.56
date	2007.05.14.21.35.25;	author uweigand;	state Exp;
branches;
next	1.55;

1.55
date	2007.05.13.13.02.54;	author uweigand;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.07.18.20.18;	author uweigand;	state Exp;
branches;
next	1.53;

1.53
date	2007.01.09.17.58.51;	author drow;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.10.20.30.02;	author sje;	state Exp;
branches;
next	1.51;

1.51
date	2006.03.01.05.19.12;	author tausq;	state Exp;
branches;
next	1.50;

1.50
date	2006.02.24.23.52.04;	author tausq;	state Exp;
branches;
next	1.49;

1.49
date	2005.12.17.22.34.00;	author eliz;	state Exp;
branches;
next	1.48;

1.48
date	2005.12.13.10.24.35;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2005.12.13.10.17.09;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2005.12.09.11.25.04;	author tausq;	state Exp;
branches;
next	1.45;

1.45
date	2005.11.19.12.55.55;	author tausq;	state Exp;
branches;
next	1.44;

1.44
date	2005.11.19.12.47.21;	author tausq;	state Exp;
branches;
next	1.43;

1.43
date	2005.10.29.21.31.45;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2005.07.18.20.34.09;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2005.02.11.04.05.50;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2005.01.14.00.23.41;	author msnyder;	state Exp;
branches;
next	1.39;

1.39
date	2005.01.12.18.31.31;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2004.12.19.22.09.26;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2004.12.17.19.21.20;	author tausq;	state Exp;
branches;
next	1.36;

1.36
date	2004.12.17.19.09.53;	author tausq;	state Exp;
branches;
next	1.35;

1.35
date	2004.12.13.08.47.07;	author tausq;	state Exp;
branches;
next	1.34;

1.34
date	2004.12.13.08.43.17;	author tausq;	state Exp;
branches;
next	1.33;

1.33
date	2004.12.13.04.06.15;	author tausq;	state Exp;
branches;
next	1.32;

1.32
date	2004.12.10.15.48.21;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2004.12.10.10.45.33;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.10.09.42.08;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.08.01.48.01;	author tausq;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.07.18.04.11;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.05.15.48.14;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.03.18.03.09;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2004.11.12.18.38.33;	author tausq;	state Exp;
branches;
next	1.24;

1.24
date	2004.10.31.21.09.28;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.12.17.09.58;	author brobecke;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.11.06.51.41;	author tausq;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.14.20.40.40;	author tausq;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.07.02.17.29;	author tausq;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.26.05.31.39;	author tausq;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.07.05.48.48;	author tausq;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.01.16.52.29;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.23.02.54.21;	author tausq;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.17.17.41.10;	author tausq;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.08.21.18.12;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.06.15.30.18;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.23.14.47.56;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.19.06.14.27;	author brobecke;	state Exp;
branches
	1.11.2.1
	1.11.8.1;
next	1.10;

1.10
date	2003.08.15.23.02.03;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.14.00.23.51;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.27.17.27.17;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.06.00.21.42;	author brobecke;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	2003.04.13.15.54.58;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.06.01.13.59;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.29.23.29.47;	author cagney;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2002.12.26.09.36.41;	author brobecke;	state Exp;
branches
	1.3.14.1;
next	1.2;

1.2
date	2002.12.21.19.58.07;	author kettenis;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2002.12.16.16.51.45;	author brobecke;	state Exp;
branches;
next	;

1.81.4.1
date	2012.01.06.04.43.15;	author brobecke;	state Exp;
branches;
next	;

1.11.2.1
date	2003.12.14.20.27.16;	author drow;	state Exp;
branches;
next	;

1.11.8.1
date	2004.03.27.17.37.49;	author drow;	state Exp;
branches;
next	1.11.8.2;

1.11.8.2
date	2004.09.16.17.01.07;	author drow;	state Exp;
branches;
next	;

1.7.6.1
date	2003.07.27.17.19.57;	author cagney;	state Exp;
branches;
next	;

1.4.2.1
date	2003.04.10.21.33.48;	author cagney;	state Exp;
branches;
next	;

1.3.14.1
date	2003.03.30.16.35.20;	author cagney;	state Exp;
branches;
next	;

1.2.2.1
date	2002.12.23.19.38.26;	author carlton;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2003.02.07.19.17.49;	author carlton;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2003.04.16.19.56.52;	author carlton;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2003.06.27.21.49.57;	author carlton;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2003.08.05.17.13.10;	author carlton;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2003.09.17.21.28.20;	author carlton;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	2003.11.11.23.50.44;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.92
log
@	* objfiles.h (pc_in_section): New prototype.
	(in_plt_section): Remove name argument, replace prototype with
	static inline function.
	* mips-tdep.h: Include "objfiles.h".
	(in_mips_stubs_section): New function.
	* hppa-tdep.h (gdbarch_tdep): Remove name argument of
	in_solib_call_trampoline member.
	(hppa_in_solib_call_trampoline): Remove name argument.
	* objfiles.c (pc_in_section): New function.
	(in_plt_section): Remove function.
	* mips-linux-tdep.c: Include "objfiles.h".
	(mips_linux_in_dynsym_stub): Call in_mips_stubs_section.  Remove
	name argument.  Return 1 rather than the low 16-bit halfword of
	any instruction examined.
	(mips_linux_in_dynsym_resolve_code): Update
	mips_linux_in_dynsym_stub call accordingly.
	* mips-tdep.c (mips_stub_frame_sniffer): Use in_mips_stubs_section
	rather than an equivalent hand-coded sequence.
	* hppa-hpux-tdep.c (in_opd_section): Remove function.
	(hppa32_hpux_in_solib_call_trampoline): Remove name argument.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.
	(hppa64_hpux_find_global_pointer): Use pc_in_section rather than
	in_opd_section.
	* hppa-tdep.c (hppa_stub_unwind_sniffer): Remove name argument
	on call to tdep->in_solib_call_trampoline.
	(hppa_in_solib_call_trampoline): Remove name argument, update
	according to in_plt_section change.
	(hppa_skip_trampoline_code): Update according to in_plt_section
	change.
	* aarch64-tdep.c (aarch64_stub_unwind_sniffer): Likewise.
	* arm-symbian-tdep.c (arm_symbian_skip_trampoline_code):
	Likewise.
	* arm-tdep.c (arm_stub_unwind_sniffer): Likewise.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): Likewise.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Likewise.
	* nios2-tdep.c (nios2_stub_frame_sniffer): Likewise.
	* nto-tdep.c (nto_relocate_section_addresses): Likewise.
	* s390-tdep.c (s390_stub_frame_sniffer): Likewise.
	* sh-tdep.c (sh_stub_unwind_sniffer): Likewise.
	* solib-dsbt.c (dsbt_in_dynsym_resolve_code): Likewise.
	* solib-frv.c (frv_in_dynsym_resolve_code): Likewise.
	* solib-svr4.c (svr4_in_dynsym_resolve_code): Likewise.
	* solib-target.c (solib_target_in_dynsym_resolve_code): Likewise.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise.
	* tic6x-tdep.c (tic6x_stub_unwind_sniffer): Likewise.
@
text
@/* Target-dependent code for HP-UX on PA-RISC.

   Copyright (C) 2002-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "gdbcore.h"
#include "osabi.h"
#include "frame.h"
#include "frame-unwind.h"
#include "trad-frame.h"
#include "symtab.h"
#include "objfiles.h"
#include "inferior.h"
#include "infcall.h"
#include "observer.h"
#include "hppa-tdep.h"
#include "solib-som.h"
#include "solib-pa64.h"
#include "regset.h"
#include "regcache.h"
#include "exceptions.h"

#include "gdb_string.h"

#define IS_32BIT_TARGET(_gdbarch) \
	((gdbarch_tdep (_gdbarch))->bytes_per_address == 4)

/* Bit in the `ss_flag' member of `struct save_state' that indicates
   that the 64-bit register values are live.  From
   <machine/save_state.h>.  */
#define HPPA_HPUX_SS_WIDEREGS		0x40

/* Offsets of various parts of `struct save_state'.  From
   <machine/save_state.h>.  */
#define HPPA_HPUX_SS_FLAGS_OFFSET	0
#define HPPA_HPUX_SS_NARROW_OFFSET	4
#define HPPA_HPUX_SS_FPBLOCK_OFFSET 	256
#define HPPA_HPUX_SS_WIDE_OFFSET        640

/* The size of `struct save_state.  */
#define HPPA_HPUX_SAVE_STATE_SIZE	1152

/* The size of `struct pa89_save_state', which corresponds to PA-RISC
   1.1, the lowest common denominator that we support.  */
#define HPPA_HPUX_PA89_SAVE_STATE_SIZE	512


/* Forward declarations.  */
extern void _initialize_hppa_hpux_tdep (void);
extern initialize_file_ftype _initialize_hppa_hpux_tdep;

/* Return one if PC is in the call path of a trampoline, else return zero.

   Note we return one for *any* call trampoline (long-call, arg-reloc), not
   just shared library trampolines (import, export).  */

static int
hppa32_hpux_in_solib_call_trampoline (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct bound_minimal_symbol minsym;
  struct unwind_table_entry *u;

  /* First see if PC is in one of the two C-library trampolines.  */
  if (pc == hppa_symbol_address("$$dyncall") 
      || pc == hppa_symbol_address("_sr4export"))
    return 1;

  minsym = lookup_minimal_symbol_by_pc (pc);
  if (minsym.minsym
      && strcmp (SYMBOL_LINKAGE_NAME (minsym.minsym), ".stub") == 0)
    return 1;

  /* Get the unwind descriptor corresponding to PC, return zero
     if no unwind was found.  */
  u = find_unwind_entry (pc);
  if (!u)
    return 0;

  /* If this isn't a linker stub, then return now.  */
  if (u->stub_unwind.stub_type == 0)
    return 0;

  /* By definition a long-branch stub is a call stub.  */
  if (u->stub_unwind.stub_type == LONG_BRANCH)
    return 1;

  /* The call and return path execute the same instructions within
     an IMPORT stub!  So an IMPORT stub is both a call and return
     trampoline.  */
  if (u->stub_unwind.stub_type == IMPORT)
    return 1;

  /* Parameter relocation stubs always have a call path and may have a
     return path.  */
  if (u->stub_unwind.stub_type == PARAMETER_RELOCATION
      || u->stub_unwind.stub_type == EXPORT)
    {
      CORE_ADDR addr;

      /* Search forward from the current PC until we hit a branch
         or the end of the stub.  */
      for (addr = pc; addr <= u->region_end; addr += 4)
	{
	  unsigned long insn;

	  insn = read_memory_integer (addr, 4, byte_order);

	  /* Does it look like a bl?  If so then it's the call path, if
	     we find a bv or be first, then we're on the return path.  */
	  if ((insn & 0xfc00e000) == 0xe8000000)
	    return 1;
	  else if ((insn & 0xfc00e001) == 0xe800c000
		   || (insn & 0xfc000000) == 0xe0000000)
	    return 0;
	}

      /* Should never happen.  */
      warning (_("Unable to find branch in parameter relocation stub."));
      return 0;
    }

  /* Unknown stub type.  For now, just return zero.  */
  return 0;
}

static int
hppa64_hpux_in_solib_call_trampoline (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  /* PA64 has a completely different stub/trampoline scheme.  Is it
     better?  Maybe.  It's certainly harder to determine with any
     certainty that we are in a stub because we can not refer to the
     unwinders to help.

     The heuristic is simple.  Try to lookup the current PC value in th
     minimal symbol table.  If that fails, then assume we are not in a
     stub and return.

     Then see if the PC value falls within the section bounds for the
     section containing the minimal symbol we found in the first
     step.  If it does, then assume we are not in a stub and return.

     Finally peek at the instructions to see if they look like a stub.  */
  struct bound_minimal_symbol minsym;
  asection *sec;
  CORE_ADDR addr;
  int insn;

  minsym = lookup_minimal_symbol_by_pc (pc);
  if (! minsym.minsym)
    return 0;

  sec = SYMBOL_OBJ_SECTION (minsym.objfile, minsym.minsym)->the_bfd_section;

  if (bfd_get_section_vma (sec->owner, sec) <= pc
      && pc < (bfd_get_section_vma (sec->owner, sec)
		 + bfd_section_size (sec->owner, sec)))
      return 0;

  /* We might be in a stub.  Peek at the instructions.  Stubs are 3
     instructions long.  */
  insn = read_memory_integer (pc, 4, byte_order);

  /* Find out where we think we are within the stub.  */
  if ((insn & 0xffffc00e) == 0x53610000)
    addr = pc;
  else if ((insn & 0xffffffff) == 0xe820d000)
    addr = pc - 4;
  else if ((insn & 0xffffc00e) == 0x537b0000)
    addr = pc - 8;
  else
    return 0;

  /* Now verify each insn in the range looks like a stub instruction.  */
  insn = read_memory_integer (addr, 4, byte_order);
  if ((insn & 0xffffc00e) != 0x53610000)
    return 0;
	
  /* Now verify each insn in the range looks like a stub instruction.  */
  insn = read_memory_integer (addr + 4, 4, byte_order);
  if ((insn & 0xffffffff) != 0xe820d000)
    return 0;
    
  /* Now verify each insn in the range looks like a stub instruction.  */
  insn = read_memory_integer (addr + 8, 4, byte_order);
  if ((insn & 0xffffc00e) != 0x537b0000)
    return 0;

  /* Looks like a stub.  */
  return 1;
}

/* Return one if PC is in the return path of a trampoline, else return zero.

   Note we return one for *any* call trampoline (long-call, arg-reloc), not
   just shared library trampolines (import, export).  */

static int
hppa_hpux_in_solib_return_trampoline (struct gdbarch *gdbarch,
				      CORE_ADDR pc, const char *name)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct unwind_table_entry *u;

  /* Get the unwind descriptor corresponding to PC, return zero
     if no unwind was found.  */
  u = find_unwind_entry (pc);
  if (!u)
    return 0;

  /* If this isn't a linker stub or it's just a long branch stub, then
     return zero.  */
  if (u->stub_unwind.stub_type == 0 || u->stub_unwind.stub_type == LONG_BRANCH)
    return 0;

  /* The call and return path execute the same instructions within
     an IMPORT stub!  So an IMPORT stub is both a call and return
     trampoline.  */
  if (u->stub_unwind.stub_type == IMPORT)
    return 1;

  /* Parameter relocation stubs always have a call path and may have a
     return path.  */
  if (u->stub_unwind.stub_type == PARAMETER_RELOCATION
      || u->stub_unwind.stub_type == EXPORT)
    {
      CORE_ADDR addr;

      /* Search forward from the current PC until we hit a branch
         or the end of the stub.  */
      for (addr = pc; addr <= u->region_end; addr += 4)
	{
	  unsigned long insn;

	  insn = read_memory_integer (addr, 4, byte_order);

	  /* Does it look like a bl?  If so then it's the call path, if
	     we find a bv or be first, then we're on the return path.  */
	  if ((insn & 0xfc00e000) == 0xe8000000)
	    return 0;
	  else if ((insn & 0xfc00e001) == 0xe800c000
		   || (insn & 0xfc000000) == 0xe0000000)
	    return 1;
	}

      /* Should never happen.  */
      warning (_("Unable to find branch in parameter relocation stub."));
      return 0;
    }

  /* Unknown stub type.  For now, just return zero.  */
  return 0;

}

/* Figure out if PC is in a trampoline, and if so find out where
   the trampoline will jump to.  If not in a trampoline, return zero.

   Simple code examination probably is not a good idea since the code
   sequences in trampolines can also appear in user code.

   We use unwinds and information from the minimal symbol table to
   determine when we're in a trampoline.  This won't work for ELF
   (yet) since it doesn't create stub unwind entries.  Whether or
   not ELF will create stub unwinds or normal unwinds for linker
   stubs is still being debated.

   This should handle simple calls through dyncall or sr4export,
   long calls, argument relocation stubs, and dyncall/sr4export
   calling an argument relocation stub.  It even handles some stubs
   used in dynamic executables.  */

static CORE_ADDR
hppa_hpux_skip_trampoline_code (struct frame_info *frame, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int word_size = gdbarch_ptr_bit (gdbarch) / 8;
  long orig_pc = pc;
  long prev_inst, curr_inst, loc;
  struct bound_minimal_symbol msym;
  struct unwind_table_entry *u;

  /* Addresses passed to dyncall may *NOT* be the actual address
     of the function.  So we may have to do something special.  */
  if (pc == hppa_symbol_address("$$dyncall"))
    {
      pc = (CORE_ADDR) get_frame_register_unsigned (frame, 22);

      /* If bit 30 (counting from the left) is on, then pc is the address of
         the PLT entry for this function, not the address of the function
         itself.  Bit 31 has meaning too, but only for MPE.  */
      if (pc & 0x2)
	pc = (CORE_ADDR) read_memory_integer (pc & ~0x3, word_size,
					      byte_order);
    }
  if (pc == hppa_symbol_address("$$dyncall_external"))
    {
      pc = (CORE_ADDR) get_frame_register_unsigned (frame, 22);
      pc = (CORE_ADDR) read_memory_integer (pc & ~0x3, word_size, byte_order);
    }
  else if (pc == hppa_symbol_address("_sr4export"))
    pc = (CORE_ADDR) get_frame_register_unsigned (frame, 22);

  /* Get the unwind descriptor corresponding to PC, return zero
     if no unwind was found.  */
  u = find_unwind_entry (pc);
  if (!u)
    return 0;

  /* If this isn't a linker stub, then return now.  */
  /* elz: attention here! (FIXME) because of a compiler/linker 
     error, some stubs which should have a non zero stub_unwind.stub_type 
     have unfortunately a value of zero.  So this function would return here
     as if we were not in a trampoline.  To fix this, we go look at the partial
     symbol information, which reports this guy as a stub.
     (FIXME): Unfortunately, we are not that lucky: it turns out that the 
     partial symbol information is also wrong sometimes.  This is because 
     when it is entered (somread.c::som_symtab_read()) it can happen that
     if the type of the symbol (from the som) is Entry, and the symbol is
     in a shared library, then it can also be a trampoline.  This would be OK,
     except that I believe the way they decide if we are ina shared library
     does not work.  SOOOO..., even if we have a regular function w/o
     trampolines its minimal symbol can be assigned type mst_solib_trampoline.
     Also, if we find that the symbol is a real stub, then we fix the unwind
     descriptor, and define the stub type to be EXPORT.
     Hopefully this is correct most of the times.  */
  if (u->stub_unwind.stub_type == 0)
    {

/* elz: NOTE (FIXME!) once the problem with the unwind information is fixed
   we can delete all the code which appears between the lines.  */
/*--------------------------------------------------------------------------*/
      msym = lookup_minimal_symbol_by_pc (pc);

      if (msym.minsym == NULL
	  || MSYMBOL_TYPE (msym.minsym) != mst_solib_trampoline)
	return orig_pc == pc ? 0 : pc & ~0x3;

      else if (msym.minsym != NULL
	       && MSYMBOL_TYPE (msym.minsym) == mst_solib_trampoline)
	{
	  struct objfile *objfile;
	  struct minimal_symbol *msymbol;
	  int function_found = 0;

	  /* Go look if there is another minimal symbol with the same name as 
	     this one, but with type mst_text.  This would happen if the msym
	     is an actual trampoline, in which case there would be another
	     symbol with the same name corresponding to the real function.  */

	  ALL_MSYMBOLS (objfile, msymbol)
	  {
	    if (MSYMBOL_TYPE (msymbol) == mst_text
		&& strcmp (SYMBOL_LINKAGE_NAME (msymbol),
			    SYMBOL_LINKAGE_NAME (msym.minsym)) == 0)
	      {
		function_found = 1;
		break;
	      }
	  }

	  if (function_found)
	    /* The type of msym is correct (mst_solib_trampoline), but
	       the unwind info is wrong, so set it to the correct value.  */
	    u->stub_unwind.stub_type = EXPORT;
	  else
	    /* The stub type info in the unwind is correct (this is not a
	       trampoline), but the msym type information is wrong, it
	       should be mst_text.  So we need to fix the msym, and also
	       get out of this function.  */
	    {
	      MSYMBOL_TYPE (msym.minsym) = mst_text;
	      return orig_pc == pc ? 0 : pc & ~0x3;
	    }
	}

/*--------------------------------------------------------------------------*/
    }

  /* It's a stub.  Search for a branch and figure out where it goes.
     Note we have to handle multi insn branch sequences like ldil;ble.
     Most (all?) other branches can be determined by examining the contents
     of certain registers and the stack.  */

  loc = pc;
  curr_inst = 0;
  prev_inst = 0;
  while (1)
    {
      /* Make sure we haven't walked outside the range of this stub.  */
      if (u != find_unwind_entry (loc))
	{
	  warning (_("Unable to find branch in linker stub"));
	  return orig_pc == pc ? 0 : pc & ~0x3;
	}

      prev_inst = curr_inst;
      curr_inst = read_memory_integer (loc, 4, byte_order);

      /* Does it look like a branch external using %r1?  Then it's the
         branch from the stub to the actual function.  */
      if ((curr_inst & 0xffe0e000) == 0xe0202000)
	{
	  /* Yup.  See if the previous instruction loaded
	     a value into %r1.  If so compute and return the jump address.  */
	  if ((prev_inst & 0xffe00000) == 0x20200000)
	    return (hppa_extract_21 (prev_inst) 
		    + hppa_extract_17 (curr_inst)) & ~0x3;
	  else
	    {
	      warning (_("Unable to find ldil X,%%r1 "
			 "before ble Y(%%sr4,%%r1)."));
	      return orig_pc == pc ? 0 : pc & ~0x3;
	    }
	}

      /* Does it look like a be 0(sr0,%r21)? OR 
         Does it look like a be, n 0(sr0,%r21)? OR 
         Does it look like a bve (r21)? (this is on PA2.0)
         Does it look like a bve, n(r21)? (this is also on PA2.0)
         That's the branch from an
         import stub to an export stub.

         It is impossible to determine the target of the branch via
         simple examination of instructions and/or data (consider
         that the address in the plabel may be the address of the
         bind-on-reference routine in the dynamic loader).

         So we have try an alternative approach.

         Get the name of the symbol at our current location; it should
         be a stub symbol with the same name as the symbol in the
         shared library.

         Then lookup a minimal symbol with the same name; we should
         get the minimal symbol for the target routine in the shared
         library as those take precedence of import/export stubs.  */
      if ((curr_inst == 0xe2a00000) ||
	  (curr_inst == 0xe2a00002) ||
	  (curr_inst == 0xeaa0d000) ||
	  (curr_inst == 0xeaa0d002))
	{
	  struct bound_minimal_symbol stubsym;
	  struct minimal_symbol *libsym;

	  stubsym = lookup_minimal_symbol_by_pc (loc);
	  if (stubsym.minsym == NULL)
	    {
	      warning (_("Unable to find symbol for 0x%lx"), loc);
	      return orig_pc == pc ? 0 : pc & ~0x3;
	    }

	  libsym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (stubsym.minsym),
					  NULL, NULL);
	  if (libsym == NULL)
	    {
	      warning (_("Unable to find library symbol for %s."),
		       SYMBOL_PRINT_NAME (stubsym.minsym));
	      return orig_pc == pc ? 0 : pc & ~0x3;
	    }

	  return SYMBOL_VALUE (libsym);
	}

      /* Does it look like bl X,%rp or bl X,%r0?  Another way to do a
         branch from the stub to the actual function.  */
      /*elz */
      else if ((curr_inst & 0xffe0e000) == 0xe8400000
	       || (curr_inst & 0xffe0e000) == 0xe8000000
	       || (curr_inst & 0xffe0e000) == 0xe800A000)
	return (loc + hppa_extract_17 (curr_inst) + 8) & ~0x3;

      /* Does it look like bv (rp)?   Note this depends on the
         current stack pointer being the same as the stack
         pointer in the stub itself!  This is a branch on from the
         stub back to the original caller.  */
      /*else if ((curr_inst & 0xffe0e000) == 0xe840c000) */
      else if ((curr_inst & 0xffe0f000) == 0xe840c000)
	{
	  /* Yup.  See if the previous instruction loaded
	     rp from sp - 8.  */
	  if (prev_inst == 0x4bc23ff1)
	    {
	      CORE_ADDR sp;
	      sp = get_frame_register_unsigned (frame, HPPA_SP_REGNUM);
	      return read_memory_integer (sp - 8, 4, byte_order) & ~0x3;
	    }
	  else
	    {
	      warning (_("Unable to find restore of %%rp before bv (%%rp)."));
	      return orig_pc == pc ? 0 : pc & ~0x3;
	    }
	}

      /* elz: added this case to capture the new instruction
         at the end of the return part of an export stub used by
         the PA2.0: BVE, n (rp) */
      else if ((curr_inst & 0xffe0f000) == 0xe840d000)
	{
	  return (read_memory_integer
		  (get_frame_register_unsigned (frame, HPPA_SP_REGNUM) - 24,
		   word_size, byte_order)) & ~0x3;
	}

      /* What about be,n 0(sr0,%rp)?  It's just another way we return to
         the original caller from the stub.  Used in dynamic executables.  */
      else if (curr_inst == 0xe0400002)
	{
	  /* The value we jump to is sitting in sp - 24.  But that's
	     loaded several instructions before the be instruction.
	     I guess we could check for the previous instruction being
	     mtsp %r1,%sr0 if we want to do sanity checking.  */
	  return (read_memory_integer
		  (get_frame_register_unsigned (frame, HPPA_SP_REGNUM) - 24,
		   word_size, byte_order)) & ~0x3;
	}

      /* Haven't found the branch yet, but we're still in the stub.
         Keep looking.  */
      loc += 4;
    }
}

static void
hppa_skip_permanent_breakpoint (struct regcache *regcache)
{
  /* To step over a breakpoint instruction on the PA takes some
     fiddling with the instruction address queue.

     When we stop at a breakpoint, the IA queue front (the instruction
     we're executing now) points at the breakpoint instruction, and
     the IA queue back (the next instruction to execute) points to
     whatever instruction we would execute after the breakpoint, if it
     were an ordinary instruction.  This is the case even if the
     breakpoint is in the delay slot of a branch instruction.

     Clearly, to step past the breakpoint, we need to set the queue
     front to the back.  But what do we put in the back?  What
     instruction comes after that one?  Because of the branch delay
     slot, the next insn is always at the back + 4.  */

  ULONGEST pcoq_tail, pcsq_tail;
  regcache_cooked_read_unsigned (regcache, HPPA_PCOQ_TAIL_REGNUM, &pcoq_tail);
  regcache_cooked_read_unsigned (regcache, HPPA_PCSQ_TAIL_REGNUM, &pcsq_tail);

  regcache_cooked_write_unsigned (regcache, HPPA_PCOQ_HEAD_REGNUM, pcoq_tail);
  regcache_cooked_write_unsigned (regcache, HPPA_PCSQ_HEAD_REGNUM, pcsq_tail);

  regcache_cooked_write_unsigned (regcache,
				  HPPA_PCOQ_TAIL_REGNUM, pcoq_tail + 4);
  /* We can leave the tail's space the same, since there's no jump.  */
}


/* Signal frames.  */
struct hppa_hpux_sigtramp_unwind_cache
{
  CORE_ADDR base;
  struct trad_frame_saved_reg *saved_regs;
};

static int hppa_hpux_tramp_reg[] = {
  HPPA_SAR_REGNUM,
  HPPA_PCOQ_HEAD_REGNUM,
  HPPA_PCSQ_HEAD_REGNUM,
  HPPA_PCOQ_TAIL_REGNUM,
  HPPA_PCSQ_TAIL_REGNUM,
  HPPA_EIEM_REGNUM,
  HPPA_IIR_REGNUM,
  HPPA_ISR_REGNUM,
  HPPA_IOR_REGNUM,
  HPPA_IPSW_REGNUM,
  -1,
  HPPA_SR4_REGNUM,
  HPPA_SR4_REGNUM + 1,
  HPPA_SR4_REGNUM + 2,
  HPPA_SR4_REGNUM + 3,
  HPPA_SR4_REGNUM + 4,
  HPPA_SR4_REGNUM + 5,
  HPPA_SR4_REGNUM + 6,
  HPPA_SR4_REGNUM + 7,
  HPPA_RCR_REGNUM,
  HPPA_PID0_REGNUM,
  HPPA_PID1_REGNUM,
  HPPA_CCR_REGNUM,
  HPPA_PID2_REGNUM,
  HPPA_PID3_REGNUM,
  HPPA_TR0_REGNUM,
  HPPA_TR0_REGNUM + 1,
  HPPA_TR0_REGNUM + 2,
  HPPA_CR27_REGNUM
};

static struct hppa_hpux_sigtramp_unwind_cache *
hppa_hpux_sigtramp_frame_unwind_cache (struct frame_info *this_frame,
				       void **this_cache)

{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct hppa_hpux_sigtramp_unwind_cache *info;
  unsigned int flag;
  CORE_ADDR sp, scptr, off;
  int i, incr, szoff;

  if (*this_cache)
    return *this_cache;

  info = FRAME_OBSTACK_ZALLOC (struct hppa_hpux_sigtramp_unwind_cache);
  *this_cache = info;
  info->saved_regs = trad_frame_alloc_saved_regs (this_frame);

  sp = get_frame_register_unsigned (this_frame, HPPA_SP_REGNUM);

  if (IS_32BIT_TARGET (gdbarch))
    scptr = sp - 1352;
  else
    scptr = sp - 1520;

  off = scptr;

  /* See /usr/include/machine/save_state.h for the structure of the
     save_state_t structure.  */
  
  flag = read_memory_unsigned_integer (scptr + HPPA_HPUX_SS_FLAGS_OFFSET,
				       4, byte_order);

  if (!(flag & HPPA_HPUX_SS_WIDEREGS))
    {
      /* Narrow registers.  */
      off = scptr + HPPA_HPUX_SS_NARROW_OFFSET;
      incr = 4;
      szoff = 0;
    }
  else
    {
      /* Wide registers.  */
      off = scptr + HPPA_HPUX_SS_WIDE_OFFSET + 8;
      incr = 8;
      szoff = (tdep->bytes_per_address == 4 ? 4 : 0);
    }

  for (i = 1; i < 32; i++)
    {
      info->saved_regs[HPPA_R0_REGNUM + i].addr = off + szoff;
      off += incr;
    }

  for (i = 0; i < ARRAY_SIZE (hppa_hpux_tramp_reg); i++)
    {
      if (hppa_hpux_tramp_reg[i] > 0)
        info->saved_regs[hppa_hpux_tramp_reg[i]].addr = off + szoff;

      off += incr;
    }

  /* TODO: fp regs */

  info->base = get_frame_register_unsigned (this_frame, HPPA_SP_REGNUM);

  return info;
}

static void
hppa_hpux_sigtramp_frame_this_id (struct frame_info *this_frame,
				   void **this_prologue_cache,
				   struct frame_id *this_id)
{
  struct hppa_hpux_sigtramp_unwind_cache *info
    = hppa_hpux_sigtramp_frame_unwind_cache (this_frame, this_prologue_cache);

  *this_id = frame_id_build (info->base, get_frame_pc (this_frame));
}

static struct value *
hppa_hpux_sigtramp_frame_prev_register (struct frame_info *this_frame,
					void **this_prologue_cache,
					int regnum)
{
  struct hppa_hpux_sigtramp_unwind_cache *info
    = hppa_hpux_sigtramp_frame_unwind_cache (this_frame, this_prologue_cache);

  return hppa_frame_prev_register_helper (this_frame,
					  info->saved_regs, regnum);
}

static int
hppa_hpux_sigtramp_unwind_sniffer (const struct frame_unwind *self,
                                   struct frame_info *this_frame,
                                   void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct unwind_table_entry *u;
  CORE_ADDR pc = get_frame_pc (this_frame);

  u = find_unwind_entry (pc);

  /* If this is an export stub, try to get the unwind descriptor for
     the actual function itself.  */
  if (u && u->stub_unwind.stub_type == EXPORT)
    {
      gdb_byte buf[HPPA_INSN_SIZE];
      unsigned long insn;

      if (!safe_frame_unwind_memory (this_frame, u->region_start,
				     buf, sizeof buf))
	return 0;

      insn = extract_unsigned_integer (buf, sizeof buf, byte_order);
      if ((insn & 0xffe0e000) == 0xe8400000)
	u = find_unwind_entry(u->region_start + hppa_extract_17 (insn) + 8);
    }

  if (u && u->HP_UX_interrupt_marker)
    return 1;

  return 0;
}

static const struct frame_unwind hppa_hpux_sigtramp_frame_unwind = {
  SIGTRAMP_FRAME,
  default_frame_unwind_stop_reason,
  hppa_hpux_sigtramp_frame_this_id,
  hppa_hpux_sigtramp_frame_prev_register,
  NULL,
  hppa_hpux_sigtramp_unwind_sniffer
};

static CORE_ADDR
hppa32_hpux_find_global_pointer (struct gdbarch *gdbarch,
				 struct value *function)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR faddr;
  
  faddr = value_as_address (function);

  /* Is this a plabel? If so, dereference it to get the gp value.  */
  if (faddr & 2)
    {
      int status;
      gdb_byte buf[4];

      faddr &= ~3;

      status = target_read_memory (faddr + 4, buf, sizeof (buf));
      if (status == 0)
	return extract_unsigned_integer (buf, sizeof (buf), byte_order);
    }

  return gdbarch_tdep (gdbarch)->solib_get_got_by_pc (faddr);
}

static CORE_ADDR
hppa64_hpux_find_global_pointer (struct gdbarch *gdbarch,
				 struct value *function)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR faddr;
  gdb_byte buf[32];

  faddr = value_as_address (function);

  if (pc_in_section (faddr, ".opd"))
    {
      target_read_memory (faddr, buf, sizeof (buf));
      return extract_unsigned_integer (&buf[24], 8, byte_order);
    }
  else
    {
      return gdbarch_tdep (gdbarch)->solib_get_got_by_pc (faddr);
    }
}

static unsigned int ldsid_pattern[] = {
  0x000010a0, /* ldsid (rX),rY */
  0x00001820, /* mtsp rY,sr0 */
  0xe0000000  /* be,n (sr0,rX) */
};

static CORE_ADDR
hppa_hpux_search_pattern (struct gdbarch *gdbarch,
			  CORE_ADDR start, CORE_ADDR end,
			  unsigned int *patterns, int count)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int num_insns = (end - start + HPPA_INSN_SIZE) / HPPA_INSN_SIZE;
  unsigned int *insns;
  gdb_byte *buf;
  int offset, i;

  buf = alloca (num_insns * HPPA_INSN_SIZE);
  insns = alloca (num_insns * sizeof (unsigned int));

  read_memory (start, buf, num_insns * HPPA_INSN_SIZE);
  for (i = 0; i < num_insns; i++, buf += HPPA_INSN_SIZE)
    insns[i] = extract_unsigned_integer (buf, HPPA_INSN_SIZE, byte_order);

  for (offset = 0; offset <= num_insns - count; offset++)
    {
      for (i = 0; i < count; i++)
        {
	  if ((insns[offset + i] & patterns[i]) != patterns[i])
	    break;
	}
      if (i == count)
        break;
    }

  if (offset <= num_insns - count)
    return start + offset * HPPA_INSN_SIZE;
  else
    return 0;
}

static CORE_ADDR
hppa32_hpux_search_dummy_call_sequence (struct gdbarch *gdbarch, CORE_ADDR pc,
					int *argreg)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct objfile *obj;
  struct obj_section *sec;
  struct hppa_objfile_private *priv;
  struct frame_info *frame;
  struct unwind_table_entry *u;
  CORE_ADDR addr, rp;
  gdb_byte buf[4];
  unsigned int insn;

  sec = find_pc_section (pc);
  obj = sec->objfile;
  priv = objfile_data (obj, hppa_objfile_priv_data);

  if (!priv)
    priv = hppa_init_objfile_priv_data (obj);
  if (!priv)
    error (_("Internal error creating objfile private data."));

  /* Use the cached value if we have one.  */
  if (priv->dummy_call_sequence_addr != 0)
    {
      *argreg = priv->dummy_call_sequence_reg;
      return priv->dummy_call_sequence_addr;
    }

  /* First try a heuristic; if we are in a shared library call, our return
     pointer is likely to point at an export stub.  */
  frame = get_current_frame ();
  rp = frame_unwind_register_unsigned (frame, 2);
  u = find_unwind_entry (rp);
  if (u && u->stub_unwind.stub_type == EXPORT)
    {
      addr = hppa_hpux_search_pattern (gdbarch,
				       u->region_start, u->region_end,
				       ldsid_pattern, 
				       ARRAY_SIZE (ldsid_pattern));
      if (addr)
	goto found_pattern;
    }

  /* Next thing to try is to look for an export stub.  */
  if (priv->unwind_info)
    {
      int i;

      for (i = 0; i < priv->unwind_info->last; i++)
        {
	  struct unwind_table_entry *u;
	  u = &priv->unwind_info->table[i];
	  if (u->stub_unwind.stub_type == EXPORT)
	    {
	      addr = hppa_hpux_search_pattern (gdbarch,
					       u->region_start, u->region_end,
					       ldsid_pattern, 
					       ARRAY_SIZE (ldsid_pattern));
	      if (addr)
	        {
		  goto found_pattern;
		}
	    }
	}
    }

  /* Finally, if this is the main executable, try to locate a sequence 
     from noshlibs */
  addr = hppa_symbol_address ("noshlibs");
  sec = find_pc_section (addr);

  if (sec && sec->objfile == obj)
    {
      CORE_ADDR start, end;

      find_pc_partial_function (addr, NULL, &start, &end);
      if (start != 0 && end != 0)
        {
	  addr = hppa_hpux_search_pattern (gdbarch, start, end, ldsid_pattern,
					   ARRAY_SIZE (ldsid_pattern));
	  if (addr)
	    goto found_pattern;
        }
    }

  /* Can't find a suitable sequence.  */
  return 0;

found_pattern:
  target_read_memory (addr, buf, sizeof (buf));
  insn = extract_unsigned_integer (buf, sizeof (buf), byte_order);
  priv->dummy_call_sequence_addr = addr;
  priv->dummy_call_sequence_reg = (insn >> 21) & 0x1f;

  *argreg = priv->dummy_call_sequence_reg;
  return priv->dummy_call_sequence_addr;
}

static CORE_ADDR
hppa64_hpux_search_dummy_call_sequence (struct gdbarch *gdbarch, CORE_ADDR pc,
					int *argreg)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct objfile *obj;
  struct obj_section *sec;
  struct hppa_objfile_private *priv;
  CORE_ADDR addr;
  struct minimal_symbol *msym;

  sec = find_pc_section (pc);
  obj = sec->objfile;
  priv = objfile_data (obj, hppa_objfile_priv_data);

  if (!priv)
    priv = hppa_init_objfile_priv_data (obj);
  if (!priv)
    error (_("Internal error creating objfile private data."));

  /* Use the cached value if we have one.  */
  if (priv->dummy_call_sequence_addr != 0)
    {
      *argreg = priv->dummy_call_sequence_reg;
      return priv->dummy_call_sequence_addr;
    }

  /* FIXME: Without stub unwind information, locating a suitable sequence is
     fairly difficult.  For now, we implement a very naive and inefficient
     scheme; try to read in blocks of code, and look for a "bve,n (rp)" 
     instruction.  These are likely to occur at the end of functions, so
     we only look at the last two instructions of each function.  */
  ALL_OBJFILE_MSYMBOLS (obj, msym)
    {
      CORE_ADDR begin, end;
      const char *name;
      gdb_byte buf[2 * HPPA_INSN_SIZE];
      int offset;

      find_pc_partial_function (SYMBOL_VALUE_ADDRESS (msym), &name,
      				&begin, &end);

      if (name == NULL || begin == 0 || end == 0)
        continue;

      if (target_read_memory (end - sizeof (buf), buf, sizeof (buf)) == 0)
        {
	  for (offset = 0; offset < sizeof (buf); offset++)
	    {
	      unsigned int insn;

	      insn = extract_unsigned_integer (buf + offset,
					       HPPA_INSN_SIZE, byte_order);
	      if (insn == 0xe840d002) /* bve,n (rp) */
	        {
		  addr = (end - sizeof (buf)) + offset;
		  goto found_pattern;
		}
	    }
	}
    }

  /* Can't find a suitable sequence.  */
  return 0;

found_pattern:
  priv->dummy_call_sequence_addr = addr;
  /* Right now we only look for a "bve,l (rp)" sequence, so the register is 
     always HPPA_RP_REGNUM.  */
  priv->dummy_call_sequence_reg = HPPA_RP_REGNUM;

  *argreg = priv->dummy_call_sequence_reg;
  return priv->dummy_call_sequence_addr;
}

static CORE_ADDR
hppa_hpux_find_import_stub_for_addr (CORE_ADDR funcaddr)
{
  struct objfile *objfile;
  struct bound_minimal_symbol funsym;
  struct minimal_symbol *stubsym;
  CORE_ADDR stubaddr;

  funsym = lookup_minimal_symbol_by_pc (funcaddr);
  stubaddr = 0;

  ALL_OBJFILES (objfile)
    {
      stubsym = lookup_minimal_symbol_solib_trampoline
	(SYMBOL_LINKAGE_NAME (funsym.minsym), objfile);

      if (stubsym)
	{
	  struct unwind_table_entry *u;

	  u = find_unwind_entry (SYMBOL_VALUE (stubsym));
	  if (u == NULL 
	      || (u->stub_unwind.stub_type != IMPORT
		  && u->stub_unwind.stub_type != IMPORT_SHLIB))
	    continue;

          stubaddr = SYMBOL_VALUE (stubsym);

	  /* If we found an IMPORT stub, then we can stop searching;
	     if we found an IMPORT_SHLIB, we want to continue the search
	     in the hopes that we will find an IMPORT stub.  */
	  if (u->stub_unwind.stub_type == IMPORT)
	    break;
	}
    }

  return stubaddr;
}

static int
hppa_hpux_sr_for_addr (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  int sr;
  /* The space register to use is encoded in the top 2 bits of the address.  */
  sr = addr >> (gdbarch_tdep (gdbarch)->bytes_per_address * 8 - 2);
  return sr + 4;
}

static CORE_ADDR
hppa_hpux_find_dummy_bpaddr (CORE_ADDR addr)
{
  /* In order for us to restore the space register to its starting state, 
     we need the dummy trampoline to return to an instruction address in 
     the same space as where we started the call.  We used to place the 
     breakpoint near the current pc, however, this breaks nested dummy calls 
     as the nested call will hit the breakpoint address and terminate 
     prematurely.  Instead, we try to look for an address in the same space to 
     put the breakpoint.  
     
     This is similar in spirit to putting the breakpoint at the "entry point"
     of an executable.  */

  struct obj_section *sec;
  struct unwind_table_entry *u;
  struct minimal_symbol *msym;
  CORE_ADDR func;

  sec = find_pc_section (addr);
  if (sec)
    {
      /* First try the lowest address in the section; we can use it as long
         as it is "regular" code (i.e. not a stub).  */
      u = find_unwind_entry (obj_section_addr (sec));
      if (!u || u->stub_unwind.stub_type == 0)
        return obj_section_addr (sec);

      /* Otherwise, we need to find a symbol for a regular function.  We
         do this by walking the list of msymbols in the objfile.  The symbol
	 we find should not be the same as the function that was passed in.  */

      /* FIXME: this is broken, because we can find a function that will be
         called by the dummy call target function, which will still not 
	 work.  */

      find_pc_partial_function (addr, NULL, &func, NULL);
      ALL_OBJFILE_MSYMBOLS (sec->objfile, msym)
	{
	  u = find_unwind_entry (SYMBOL_VALUE_ADDRESS (msym));
	  if (func != SYMBOL_VALUE_ADDRESS (msym) 
	      && (!u || u->stub_unwind.stub_type == 0))
	    return SYMBOL_VALUE_ADDRESS (msym);
	}
    }

  warning (_("Cannot find suitable address to place dummy breakpoint; nested "
	     "calls may fail."));
  return addr - 4;
}

static CORE_ADDR
hppa_hpux_push_dummy_code (struct gdbarch *gdbarch, CORE_ADDR sp,
			   CORE_ADDR funcaddr,
			   struct value **args, int nargs,
			   struct type *value_type,
			   CORE_ADDR *real_pc, CORE_ADDR *bp_addr,
			   struct regcache *regcache)
{
  CORE_ADDR pc, stubaddr;
  int argreg = 0;

  pc = regcache_read_pc (regcache);

  /* Note: we don't want to pass a function descriptor here; push_dummy_call
     fills in the PIC register for us.  */
  funcaddr = gdbarch_convert_from_func_ptr_addr (gdbarch, funcaddr, NULL);

  /* The simple case is where we call a function in the same space that we are
     currently in; in that case we don't really need to do anything.  */
  if (hppa_hpux_sr_for_addr (gdbarch, pc)
      == hppa_hpux_sr_for_addr (gdbarch, funcaddr))
    {
      /* Intraspace call.  */
      *bp_addr = hppa_hpux_find_dummy_bpaddr (pc);
      *real_pc = funcaddr;
      regcache_cooked_write_unsigned (regcache, HPPA_RP_REGNUM, *bp_addr);

      return sp;
    }

  /* In order to make an interspace call, we need to go through a stub.
     gcc supplies an appropriate stub called "__gcc_plt_call", however, if
     an application is compiled with HP compilers then this stub is not
     available.  We used to fallback to "__d_plt_call", however that stub
     is not entirely useful for us because it doesn't do an interspace
     return back to the caller.  Also, on hppa64-hpux, there is no 
     __gcc_plt_call available.  In order to keep the code uniform, we
     instead don't use either of these stubs, but instead write our own
     onto the stack.

     A problem arises since the stack is located in a different space than
     code, so in order to branch to a stack stub, we will need to do an
     interspace branch.  Previous versions of gdb did this by modifying code
     at the current pc and doing single-stepping to set the pcsq.  Since this
     is highly undesirable, we use a different scheme:

     All we really need to do the branch to the stub is a short instruction
     sequence like this:
      
     PA1.1:
      		ldsid (rX),r1
		mtsp r1,sr0
		be,n (sr0,rX)

     PA2.0:
      		bve,n (sr0,rX)

     Instead of writing these sequences ourselves, we can find it in
     the instruction stream that belongs to the current space.  While this
     seems difficult at first, we are actually guaranteed to find the sequences
     in several places:

     For 32-bit code:
     - in export stubs for shared libraries
     - in the "noshlibs" routine in the main module

     For 64-bit code:
     - at the end of each "regular" function

     We cache the address of these sequences in the objfile's private data
     since these operations can potentially be quite expensive.

     So, what we do is:
     - write a stack trampoline
     - look for a suitable instruction sequence in the current space
     - point the sequence at the trampoline
     - set the return address of the trampoline to the current space 
       (see hppa_hpux_find_dummy_call_bpaddr)
     - set the continuing address of the "dummy code" as the sequence.  */

  if (IS_32BIT_TARGET (gdbarch))
    {
#define INSN(I1, I2, I3, I4) 0x ## I1, 0x ## I2, 0x ## I3, 0x ## I4
     static const gdb_byte hppa32_tramp[] = {
	INSN(0f,df,12,91), /* stw r31,-8(,sp) */
	INSN(02,c0,10,a1), /* ldsid (,r22),r1 */
	INSN(00,01,18,20), /* mtsp r1,sr0 */
	INSN(e6,c0,00,00), /* be,l 0(sr0,r22),%sr0,%r31 */
	INSN(08,1f,02,42), /* copy r31,rp */
	INSN(0f,d1,10,82), /* ldw -8(,sp),rp */
	INSN(00,40,10,a1), /* ldsid (,rp),r1 */
	INSN(00,01,18,20), /* mtsp r1,sr0 */
	INSN(e0,40,00,00), /* be 0(sr0,rp) */
	INSN(08,00,02,40)  /* nop */
      };

      /* for hppa32, we must call the function through a stub so that on
         return it can return to the space of our trampoline.  */
      stubaddr = hppa_hpux_find_import_stub_for_addr (funcaddr);
      if (stubaddr == 0)
        error (_("Cannot call external function not referenced by application "
	       "(no import stub).\n"));
      regcache_cooked_write_unsigned (regcache, 22, stubaddr);

      write_memory (sp, hppa32_tramp, sizeof (hppa32_tramp));

      *bp_addr = hppa_hpux_find_dummy_bpaddr (pc);
      regcache_cooked_write_unsigned (regcache, 31, *bp_addr);

      *real_pc = hppa32_hpux_search_dummy_call_sequence (gdbarch, pc, &argreg);
      if (*real_pc == 0)
        error (_("Cannot make interspace call from here."));

      regcache_cooked_write_unsigned (regcache, argreg, sp);

      sp += sizeof (hppa32_tramp);
    }
  else
    {
      static const gdb_byte hppa64_tramp[] = {
	INSN(ea,c0,f0,00), /* bve,l (r22),%r2 */
	INSN(0f,df,12,d1), /* std r31,-8(,sp) */
	INSN(0f,d1,10,c2), /* ldd -8(,sp),rp */
	INSN(e8,40,d0,02), /* bve,n (rp) */
	INSN(08,00,02,40)  /* nop */
      };
#undef INSN

      /* for hppa64, we don't need to call through a stub; all functions
         return via a bve.  */
      regcache_cooked_write_unsigned (regcache, 22, funcaddr);
      write_memory (sp, hppa64_tramp, sizeof (hppa64_tramp));

      *bp_addr = pc - 4;
      regcache_cooked_write_unsigned (regcache, 31, *bp_addr);

      *real_pc = hppa64_hpux_search_dummy_call_sequence (gdbarch, pc, &argreg);
      if (*real_pc == 0)
        error (_("Cannot make interspace call from here."));

      regcache_cooked_write_unsigned (regcache, argreg, sp);

      sp += sizeof (hppa64_tramp);
    }

  sp = gdbarch_frame_align (gdbarch, sp);

  return sp;
}



static void
hppa_hpux_supply_ss_narrow (struct regcache *regcache,
			    int regnum, const gdb_byte *save_state)
{
  const gdb_byte *ss_narrow = save_state + HPPA_HPUX_SS_NARROW_OFFSET;
  int i, offset = 0;

  for (i = HPPA_R1_REGNUM; i < HPPA_FP0_REGNUM; i++)
    {
      if (regnum == i || regnum == -1)
	regcache_raw_supply (regcache, i, ss_narrow + offset);

      offset += 4;
    }
}

static void
hppa_hpux_supply_ss_fpblock (struct regcache *regcache,
			     int regnum, const gdb_byte *save_state)
{
  const gdb_byte *ss_fpblock = save_state + HPPA_HPUX_SS_FPBLOCK_OFFSET;
  int i, offset = 0;

  /* FIXME: We view the floating-point state as 64 single-precision
     registers for 32-bit code, and 32 double-precision register for
     64-bit code.  This distinction is artificial and should be
     eliminated.  If that ever happens, we should remove the if-clause
     below.  */

  if (register_size (get_regcache_arch (regcache), HPPA_FP0_REGNUM) == 4)
    {
      for (i = HPPA_FP0_REGNUM; i < HPPA_FP0_REGNUM + 64; i++)
	{
	  if (regnum == i || regnum == -1)
	    regcache_raw_supply (regcache, i, ss_fpblock + offset);

	  offset += 4;
	}
    }
  else
    {
      for (i = HPPA_FP0_REGNUM; i < HPPA_FP0_REGNUM + 32; i++)
	{
	  if (regnum == i || regnum == -1)
	    regcache_raw_supply (regcache, i, ss_fpblock + offset);

	  offset += 8;
	}
    }
}

static void
hppa_hpux_supply_ss_wide (struct regcache *regcache,
			  int regnum, const gdb_byte *save_state)
{
  const gdb_byte *ss_wide = save_state + HPPA_HPUX_SS_WIDE_OFFSET;
  int i, offset = 8;

  if (register_size (get_regcache_arch (regcache), HPPA_R1_REGNUM) == 4)
    offset += 4;

  for (i = HPPA_R1_REGNUM; i < HPPA_FP0_REGNUM; i++)
    {
      if (regnum == i || regnum == -1)
	regcache_raw_supply (regcache, i, ss_wide + offset);

      offset += 8;
    }
}

static void
hppa_hpux_supply_save_state (const struct regset *regset,
			     struct regcache *regcache,
			     int regnum, const void *regs, size_t len)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  const gdb_byte *proc_info = regs;
  const gdb_byte *save_state = proc_info + 8;
  ULONGEST flags;

  flags = extract_unsigned_integer (save_state + HPPA_HPUX_SS_FLAGS_OFFSET,
				    4, byte_order);
  if (regnum == -1 || regnum == HPPA_FLAGS_REGNUM)
    {
      size_t size = register_size (gdbarch, HPPA_FLAGS_REGNUM);
      gdb_byte buf[8];

      store_unsigned_integer (buf, size, byte_order, flags);
      regcache_raw_supply (regcache, HPPA_FLAGS_REGNUM, buf);
    }

  /* If the SS_WIDEREGS flag is set, we really do need the full
     `struct save_state'.  */
  if (flags & HPPA_HPUX_SS_WIDEREGS && len < HPPA_HPUX_SAVE_STATE_SIZE)
    error (_("Register set contents too small"));

  if (flags & HPPA_HPUX_SS_WIDEREGS)
    hppa_hpux_supply_ss_wide (regcache, regnum, save_state);
  else
    hppa_hpux_supply_ss_narrow (regcache, regnum, save_state);

  hppa_hpux_supply_ss_fpblock (regcache, regnum, save_state);
}

/* HP-UX register set.  */

static struct regset hppa_hpux_regset =
{
  NULL,
  hppa_hpux_supply_save_state
};

static const struct regset *
hppa_hpux_regset_from_core_section (struct gdbarch *gdbarch,
				    const char *sect_name, size_t sect_size)
{
  if (strcmp (sect_name, ".reg") == 0
      && sect_size >= HPPA_HPUX_PA89_SAVE_STATE_SIZE + 8)
    return &hppa_hpux_regset;

  return NULL;
}


/* Bit in the `ss_flag' member of `struct save_state' that indicates
   the state was saved from a system call.  From
   <machine/save_state.h>.  */
#define HPPA_HPUX_SS_INSYSCALL	0x02

static CORE_ADDR
hppa_hpux_read_pc (struct regcache *regcache)
{
  ULONGEST flags;

  /* If we're currently in a system call return the contents of %r31.  */
  regcache_cooked_read_unsigned (regcache, HPPA_FLAGS_REGNUM, &flags);
  if (flags & HPPA_HPUX_SS_INSYSCALL)
    {
      ULONGEST pc;
      regcache_cooked_read_unsigned (regcache, HPPA_R31_REGNUM, &pc);
      return pc & ~0x3;
    }

  return hppa_read_pc (regcache);
}

static void
hppa_hpux_write_pc (struct regcache *regcache, CORE_ADDR pc)
{
  ULONGEST flags;

  /* If we're currently in a system call also write PC into %r31.  */
  regcache_cooked_read_unsigned (regcache, HPPA_FLAGS_REGNUM, &flags);
  if (flags & HPPA_HPUX_SS_INSYSCALL)
    regcache_cooked_write_unsigned (regcache, HPPA_R31_REGNUM, pc | 0x3);

  hppa_write_pc (regcache, pc);
}

static CORE_ADDR
hppa_hpux_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  ULONGEST flags;

  /* If we're currently in a system call return the contents of %r31.  */
  flags = frame_unwind_register_unsigned (next_frame, HPPA_FLAGS_REGNUM);
  if (flags & HPPA_HPUX_SS_INSYSCALL)
    return frame_unwind_register_unsigned (next_frame, HPPA_R31_REGNUM) & ~0x3;

  return hppa_unwind_pc (gdbarch, next_frame);
}


/* Given the current value of the pc, check to see if it is inside a stub, and
   if so, change the value of the pc to point to the caller of the stub.
   THIS_FRAME is the current frame in the current list of frames.
   BASE contains to stack frame base of the current frame.
   SAVE_REGS is the register file stored in the frame cache.  */
static void
hppa_hpux_unwind_adjust_stub (struct frame_info *this_frame, CORE_ADDR base,
			      struct trad_frame_saved_reg *saved_regs)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int word_size = gdbarch_ptr_bit (gdbarch) / 8;
  struct value *pcoq_head_val;
  ULONGEST pcoq_head;
  CORE_ADDR stubpc;
  struct unwind_table_entry *u;

  pcoq_head_val = trad_frame_get_prev_register (this_frame, saved_regs, 
				                HPPA_PCOQ_HEAD_REGNUM);
  pcoq_head =
    extract_unsigned_integer (value_contents_all (pcoq_head_val),
			      register_size (gdbarch, HPPA_PCOQ_HEAD_REGNUM),
			      byte_order);

  u = find_unwind_entry (pcoq_head);
  if (u && u->stub_unwind.stub_type == EXPORT)
    {
      stubpc = read_memory_integer (base - 24, word_size, byte_order);
      trad_frame_set_value (saved_regs, HPPA_PCOQ_HEAD_REGNUM, stubpc);
    }
  else if (hppa_symbol_address ("__gcc_plt_call") 
           == get_pc_function_start (pcoq_head))
    {
      stubpc = read_memory_integer (base - 8, word_size, byte_order);
      trad_frame_set_value (saved_regs, HPPA_PCOQ_HEAD_REGNUM, stubpc);
    }
}

static void
hppa_hpux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (IS_32BIT_TARGET (gdbarch))
    tdep->in_solib_call_trampoline = hppa32_hpux_in_solib_call_trampoline;
  else
    tdep->in_solib_call_trampoline = hppa64_hpux_in_solib_call_trampoline;

  tdep->unwind_adjust_stub = hppa_hpux_unwind_adjust_stub;

  set_gdbarch_in_solib_return_trampoline
    (gdbarch, hppa_hpux_in_solib_return_trampoline);
  set_gdbarch_skip_trampoline_code (gdbarch, hppa_hpux_skip_trampoline_code);

  set_gdbarch_push_dummy_code (gdbarch, hppa_hpux_push_dummy_code);
  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);

  set_gdbarch_read_pc (gdbarch, hppa_hpux_read_pc);
  set_gdbarch_write_pc (gdbarch, hppa_hpux_write_pc);
  set_gdbarch_unwind_pc (gdbarch, hppa_hpux_unwind_pc);
  set_gdbarch_skip_permanent_breakpoint
    (gdbarch, hppa_skip_permanent_breakpoint);

  set_gdbarch_regset_from_core_section
    (gdbarch, hppa_hpux_regset_from_core_section);

  frame_unwind_append_unwinder (gdbarch, &hppa_hpux_sigtramp_frame_unwind);
}

static void
hppa_hpux_som_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  tdep->is_elf = 0;

  tdep->find_global_pointer = hppa32_hpux_find_global_pointer;

  hppa_hpux_init_abi (info, gdbarch);
  som_solib_select (gdbarch);
}

static void
hppa_hpux_elf_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  tdep->is_elf = 1;
  tdep->find_global_pointer = hppa64_hpux_find_global_pointer;

  hppa_hpux_init_abi (info, gdbarch);
  pa64_solib_select (gdbarch);
}

static enum gdb_osabi
hppa_hpux_core_osabi_sniffer (bfd *abfd)
{
  if (strcmp (bfd_get_target (abfd), "hpux-core") == 0)
    return GDB_OSABI_HPUX_SOM;
  else if (strcmp (bfd_get_target (abfd), "elf64-hppa") == 0)
    {
      asection *section;
      
      section = bfd_get_section_by_name (abfd, ".kernel");
      if (section)
        {
	  bfd_size_type size;
	  char *contents;

	  size = bfd_section_size (abfd, section);
	  contents = alloca (size);
 	  if (bfd_get_section_contents (abfd, section, contents, 
	  				(file_ptr) 0, size)
	      && strcmp (contents, "HP-UX") == 0)
	    return GDB_OSABI_HPUX_ELF;
	}
    }

  return GDB_OSABI_UNKNOWN;
}

void
_initialize_hppa_hpux_tdep (void)
{
  /* BFD doesn't set a flavour for HP-UX style core files.  It doesn't
     set the architecture either.  */
  gdbarch_register_osabi_sniffer (bfd_arch_unknown,
				  bfd_target_unknown_flavour,
				  hppa_hpux_core_osabi_sniffer);
  gdbarch_register_osabi_sniffer (bfd_arch_hppa,
                                  bfd_target_elf_flavour,
				  hppa_hpux_core_osabi_sniffer);

  gdbarch_register_osabi (bfd_arch_hppa, 0, GDB_OSABI_HPUX_SOM,
                          hppa_hpux_som_init_abi);
  gdbarch_register_osabi (bfd_arch_hppa, bfd_mach_hppa20w, GDB_OSABI_HPUX_ELF,
                          hppa_hpux_elf_init_abi);
}
@


1.91
log
@-Wpointer-sign: char -> gdb_byte.

-Wpointer-sign catches all these cases across the codebase that should
be using gdb_byte for raw target bytes.  I think these are all
obvious, hence I've collapsed into a single patch.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* aarch64-tdep.c (aarch64_default_breakpoint): Change type to
	gdb_byte[].
	(aarch64_breakpoint_from_pc): Change return type to gdb_byte *.
	* ada-lang.c (ada_value_assign): Use gdb_byte.
	* alphanbsd-tdep.c (sigtramp_retcode): Change type to gdb_byte[].
	(alphanbsd_sigtramp_offset): Use gdb_byte.
	* arm-linux-tdep.c (arm_linux_arm_le_breakpoint)
	(arm_linux_arm_be_breakpoint, eabi_linux_arm_le_breakpoint)
	(eabi_linux_arm_be_breakpoint, arm_linux_thumb_be_breakpoint)
	(arm_linux_thumb_le_breakpoint, arm_linux_thumb2_be_breakpoint)
	(arm_linux_thumb2_le_breakpoint): Change type to gdb_byte[].
	* arm-tdep.c (arm_stub_unwind_sniffer)
	(arm_displaced_init_closure): Use gdb_byte.
	(arm_default_arm_le_breakpoint, arm_default_arm_be_breakpoint)
	(arm_default_thumb_le_breakpoint)
	(arm_default_thumb_be_breakpoint): Change type to gdb_byte[].
	* arm-tdep.h (struct gdbarch_tdep) <arm_breakpoint,
	thumb_breakpoint, thumb2_breakpoint>: Change type to gdb_byte *.
	* arm-wince-tdep.c (arm_wince_le_breakpoint)
	(arm_wince_thumb_le_breakpoint): Change type to gdb_byte[].
	* armnbsd-tdep.c (arm_nbsd_arm_le_breakpoint)
	(arm_nbsd_arm_be_breakpoint, arm_nbsd_thumb_le_breakpoint)
	(arm_nbsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* armobsd-tdep.c (arm_obsd_thumb_le_breakpoint)
	(arm_obsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* cris-tdep.c (push_stack_item, cris_push_dummy_call)
	(cris_store_return_value, cris_extract_return_value): Use
	gdb_byte.
	(constraint): Change type of parameter to char * from signed
	char*.  Use gdb_byte.
	* dwarf2loc.c (read_pieced_value, write_pieced_value): Change type
	of local buffer to gdb_byte *.
	* dwarf2read.c (read_index_from_section): Use gdb_byte.
	(create_dwp_hash_table): Change type of locals to gdb_byte *.
	(add_address_entry): Change type of local buffer to gdb_byte[].
	* frv-tdep.c (frv_adjust_breakpoint_address, find_func_descr)
	(frv_push_dummy_call): Use gdb_byte.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code)
	(hppa_hpux_supply_ss_fpblock, hppa_hpux_supply_ss_wide)
	(hppa_hpux_supply_save_state): Use gdb_byte.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_convert_code_addr_to_fptr): Use gdb_byte.
	* ia64-tdep.c (extract_bit_field, replace_bit_field)
	(slotN_contents, replace_slotN_contents): Change type of parameter
	to gdb_byte *.
	(fetch_instruction, ia64_pseudo_register_write)
	(ia64_register_to_value, ia64_value_to_register)
	(ia64_extract_return_value, ia64_store_return_value)
	(ia64_push_dummy_call): Use gdb_byte.
	* m32c-tdep.c (m32c_return_value): Remove cast.
	* m68hc11-tdep.c (m68hc11_pseudo_register_write)
	(m68hc11_push_dummy_call, m68hc11_store_return_value): Use
	gdb_byte.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Use gdb_byte.
	* mn10300-tdep.c (mn10300_store_return_value)
	(mn10300_breakpoint_from_pc, mn10300_push_dummy_call): Use
	gdb_byte.
	* moxie-tdep.c (moxie_process_readu): Use gdb_byte.
	(moxie_process_record): Remove casts.
	* ppc-ravenscar-thread.c (supply_register_at_address)
	(ppc_ravenscar_generic_store_registers): Use gdb_byte.
	* ravenscar-thread.c (get_running_thread_id): Use gdb_byte.
	* remote-m32r-sdi.c (m32r_fetch_register): Use gdb_byte.
	* remote-mips.c (mips_xfer_memory): Use gdb_byte.
	* remote.c (compare_sections_command): Use gdb_byte.
	* score-tdep.c (score7_free_memblock): Change type of parameter to
	gdb_byte *.
	* sh-tdep.c (sh_justify_value_in_reg): Change return type to
	gdb_byte *.  Use gdb_byte.
	(sh_push_dummy_call_fpu): Use gdb_byte.
	(sh_extract_return_value_nofpu, sh_extract_return_value_fpu)
	(sh_store_return_value_nofpu, sh_store_return_value_fpu)
	(sh_register_convert_to_virtual, sh_register_convert_to_raw):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh_pseudo_register_read, sh_pseudo_register_write): Use gdb_byte.
	* sh64-tdep.c (sh64_push_dummy_call): Use gdb_byte.
	(sh64_store_return_value, sh64_register_convert_to_virtual):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh64_pseudo_register_write): Use gdb_byte.
	* solib-darwin.c (darwin_current_sos): Add casts to 'gdb_byte *'.
	* solib-irix.c (fetch_lm_info): Likewise.  Use gdb_byte for byte
	buffer.
	(irix_current_sos): Use gdb_byte.
	* solib-som.c (som_current_sos): Use gdb_byte.
	* sparc-ravenscar-thread.c (supply_register_at_address)
	(sparc_ravenscar_generic_store_registers): Use gdb_byte.
	* spu-multiarch.c (spu_xfer_partial): Add cast to 'char *'.
	* spu-tdep.c (spu_get_overlay_table): Use gdb_byte.
	* tic6x-tdep.c (tic6x_breakpoint_from_pc): Change return type to
	'gdb_byte *'.
	* tic6x-tdep.h (struct gdbarch_tdep) <breakpoint>: Change type to
	'gdb_byte *'.
	* tracepoint.c (tfile_fetch_registers): Use gdb_byte.
	* xstormy16-tdep.c (xstormy16_extract_return_value)
	(xstormy16_store_return_value): Change parameter type to
	'gdb_byte *'.  Adjust.
	(xstormy16_push_dummy_call): Use gdb_byte.
	* xtensa-tdep.c (xtensa_scan_prologue, call0_ret)
	(call0_analyze_prologue, execute_code): Use gdb_byte.
@
text
@a67 14
static int
in_opd_section (CORE_ADDR pc)
{
  struct obj_section *s;
  int retval = 0;

  s = find_pc_section (pc);

  retval = (s != NULL
	    && s->the_bfd_section->name != NULL
	    && strcmp (s->the_bfd_section->name, ".opd") == 0);
  return (retval);
}

d74 1
a74 2
hppa32_hpux_in_solib_call_trampoline (struct gdbarch *gdbarch,
				      CORE_ADDR pc, char *name)
d144 1
a144 2
hppa64_hpux_in_solib_call_trampoline (struct gdbarch *gdbarch,
				      CORE_ADDR pc, char *name)
d785 1
a785 1
  if (in_opd_section (faddr))
@


1.90
log
@	PR symtab/8424:
	* blockframe.c (find_pc_partial_function_gnu_ifunc): Check
	SYMBOL_SECTION, not SYMBOL_OBJ_SECTION.
	* breakpoint.c (resolve_sal_pc): Update.
	* elfread.c (elf_gnu_ifunc_record_cache): Update.
	* findvar.c (struct minsym_lookup_data) <objfile>: New field.
	(minsym_lookup_iterator_cb): Use it.
	(default_read_var_value): Update.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline):
	Update.
	* infcmd.c (jump_command): Update.
	* linespec.c (minsym_found): Update.
	* maint.c (maintenance_translate_address): Update.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Update.
	(prim_record_minimal_symbol_full): Don't set SYMBOL_OBJ_SECTION.
	* parse.c (write_exp_msymbol): Update.
	* printcmd.c (address_info): Update.
	* psymtab.c (find_pc_sect_psymbol): Update.
	(fixup_psymbol_section): Check SYMBOL_SECTION, not
	SYMBOL_OBJ_SECTION.
	(add_psymbol_to_bcache): Correctly initialize SYMBOL_SECTION.
	Don't initialize SYMBOL_OBJ_SECTION.
	* spu-tdep.c (spu_catch_start): Update.
	* stabsread.c (define_symbol): Don't set SYMBOL_SECTION.
	* symmisc.c (dump_msymbols, print_symbol): Update.
	* symtab.c (fixup_section): Don't set 'obj_section'.  Change
	how fallback section is computed.
	(fixup_symbol_section): Update.
	(find_pc_sect_symtab, find_function_start_sal, skip_prologue_sal):
	Update.
	(allocate_symbol, initialize_symbol, allocate_template_symbol):
	Initialize SYMBOL_SECTION.
	* symtab.h (struct general_symbol_info) <section>: Update comment.
	<obj_section>: Remove.
	(SYMBOL_OBJ_SECTION): Add 'objfile' argument.  Rewrite.
	(SYMBOL_OBJFILE): New macro.
@
text
@d1281 1
a1281 1
			    int regnum, const char *save_state)
d1283 1
a1283 1
  const char *ss_narrow = save_state + HPPA_HPUX_SS_NARROW_OFFSET;
d1297 1
a1297 1
			     int regnum, const char *save_state)
d1299 1
a1299 1
  const char *ss_fpblock = save_state + HPPA_HPUX_SS_FPBLOCK_OFFSET;
d1332 1
a1332 1
			  int regnum, const char *save_state)
d1334 1
a1334 1
  const char *ss_wide = save_state + HPPA_HPUX_SS_WIDE_OFFSET;
d1356 2
a1357 2
  const char *proc_info = regs;
  const char *save_state = proc_info + 8;
@


1.89
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@d187 1
a187 1
  sec = SYMBOL_OBJ_SECTION (minsym.minsym)->the_bfd_section;
@


1.88
log
@hppa-hpux-tdep.c: Fix host dependency.

$ make WERROR_CFLAGS="-Wpointer-sign -Werror" hppa-hpux-tdep.o -k 2>&1 1>/dev/null
../../src/gdb/hppa-hpux-tdep.c: In function ‘hppa_hpux_push_dummy_code’:
../../src/gdb/hppa-hpux-tdep.c:1225:7: error: pointer targets in passing argument 2 of ‘write_memory’ differ in signedness [-Werror=pointer-sign]
In file included from ../../src/gdb/hppa-hpux-tdep.c:22:0:
../../src/gdb/gdbcore.h:85:13: note: expected ‘const gdb_byte *’ but argument is of type ‘char *’
../../src/gdb/hppa-hpux-tdep.c:1251:7: error: pointer targets in passing argument 2 of ‘write_memory’ differ in signedness [-Werror=pointer-sign]
In file included from ../../src/gdb/hppa-hpux-tdep.c:22:0:
../../src/gdb/gdbcore.h:85:13: note: expected ‘const gdb_byte *’ but argument is of type ‘char *’
../../src/gdb/hppa-hpux-tdep.c: In function ‘hppa_hpux_supply_save_state’:
../../src/gdb/hppa-hpux-tdep.c:1354:9: error: pointer targets in passing argument 1 of ‘extract_unsigned_integer’ differ in signedness [-Werror=pointer-sign]
In file included from ../../src/gdb/hppa-hpux-tdep.c:20:0:
../../src/gdb/defs.h:675:22: note: expected ‘const gdb_byte *’ but argument is of type ‘const char *’

Casting to gdb_byte would fix it, however, writing an
unsigned int array like this

      static unsigned int hppa64_tramp[] = {
        0xeac0f000, /* bve,l (r22),%r2 */
        0x0fdf12d1, /* std r31,-8(,sp) */
        0x0fd110c2, /* ldd -8(,sp),rp */
        0xe840d002, /* bve,n (rp) */
        0x08000240  /* nop */
        ...

directly to target memory assumes the host endianness is the same as
the target's.  hppa is big endian, so I believe this patch should be
correct -- it defines the array as a gdb_byte array.  It uses a macro
to make the insn bytes a little more readable.  I thought of using
write_memory_unsigned_integer once for each element of the unsigned
int array, but this way keeps issuing a single target memory write /
roundtrip for the whole trampoline.

gdb/
2013-03-22  Pedro Alves  <palves@@redhat.com>

	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Define INSN macro,
	use it to rewrite the trampoline buffers with type gdb_byte[], and
	undefine the macro.  Remove char* cast.
@
text
@d92 1
a92 1
  struct minimal_symbol *minsym;
d101 2
a102 1
  if (minsym && strcmp (SYMBOL_LINKAGE_NAME (minsym), ".stub") == 0)
d178 1
a178 1
  struct minimal_symbol *minsym;
d184 1
a184 1
  if (! minsym)
d187 1
a187 1
  sec = SYMBOL_OBJ_SECTION (minsym)->the_bfd_section;
d315 1
a315 1
  struct minimal_symbol *msym;
d370 2
a371 1
      if (msym == NULL || MSYMBOL_TYPE (msym) != mst_solib_trampoline)
d374 2
a375 1
      else if (msym != NULL && MSYMBOL_TYPE (msym) == mst_solib_trampoline)
d390 1
a390 1
			    SYMBOL_LINKAGE_NAME (msym)) == 0)
d407 1
a407 1
	      MSYMBOL_TYPE (msym) = mst_text;
d478 2
a479 1
	  struct minimal_symbol *stubsym, *libsym;
d482 1
a482 1
	  if (stubsym == NULL)
d488 1
a488 1
	  libsym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (stubsym),
d493 1
a493 1
		       SYMBOL_PRINT_NAME (stubsym));
d1032 2
a1033 1
  struct minimal_symbol *funsym, *stubsym;
d1042 1
a1042 1
	(SYMBOL_LINKAGE_NAME (funsym), objfile);
@


1.87
log
@Use gdb_byte for bytes from the program being debugged.

gdb_byte should be used for bytes from the program being debugged.  We
have many places using char or unsigned char instead all over the
existing ports, and more ends up added over time due to copy/paste as
new code is based on old code.

I've greped the tree for "char buf[", and fixed all I found.

Tested by building with --enable-targets=all.

2013-03-01  Pedro Alves  <palves@@redhat.com>

	Use gdb_byte for bytes from the program being debugged.

	* arm-tdep.c (arm_store_return_value, arm_get_longjmp_target):
	Change type of local 'buf' to gdb_byte.
	* avr-tdep.c (avr_frame_prev_register, avr_push_dummy_call): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* cris-tdep.c (cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache): Likewise.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp)
	(frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Likewise.
	* frv-tdep.c (frv_pseudo_register_write, frv_analyze_prologue): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_find_global_pointer)
	(hppa32_hpux_search_dummy_call_sequence)
	(hppa_hpux_supply_save_state): Likewise.
	* hppa-linux-tdep.c (insns_match_pattern)
	(hppa_linux_find_global_pointer): Likewise.
	* hppa-tdep.c (hppa_in_function_epilogue_p)
	(skip_prologue_hard_way, hppa_frame_cache): Likewise.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Likewise.
	* i386fbsd-tdep.c (i386fbsd_supply_uthread)
	(i386fbsd_collect_uthread): Likewise.
	* ia64-hpux-tdep.c (ia64_hpux_push_dummy_code): Likewise.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Likewise.
	* ia64-tdep.c (examine_prologue, ia64_frame_cache)
	(ia64_frame_prev_register, ia64_sigtramp_frame_cache)
	(ia64_sigtramp_frame_prev_register, ia64_access_reg)
	(ia64_access_rse_reg, ia64_libunwind_frame_this_id)
	(ia64_libunwind_frame_prev_register)
	(ia64_libunwind_sigtramp_frame_this_id)
	(ia64_find_global_pointer_from_dynamic_section)
	(find_extant_func_descr, find_func_descr, ia64_dummy_id)
	(ia64_unwind_pc): Likewise.
	* iq2000-tdep.c (iq2000_store_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call)
	(m68hc11_extract_return_value): Likewise.
	* m68klinux-nat.c (fetch_register, store_register): Likewise.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_cr32_write)
	(mep_get_insn, mep_push_dummy_call): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips_linux_in_dynsym_stub): Likewise.
	* mn10300-tdep.c (mep_pseudo_cr32_write): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* regcache.c (dump_endian_bytes): Change type of parameter 'buf'
	to gdb_byte.
	* remote-mips.c (mips_set_register): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* score-tdep.c (score7_fetch_inst): Change type of parameter
	'memblock' and local 'buf' to gdb_byte.
	(score7_malloc_and_get_memblock): Change return type to gdb_byte.
	Change type of local 'buf' to gdb_byte.  Adjust.
	(score7_adjust_memblock_ptr): Change type of parameter 'memblock'
	to gdb_byte**.
	(score7_analyze_prologue): Change type of 'memblock' and
	'memblock_ptr' locals to gdb_byte*.
	* sh64-tdep.c (sh64_extract_return_value)
	(sh64_store_return_value): Change type of local 'buf' to gdb_byte.
	* solib-darwin.c (darwin_current_sos, darwin_read_exec_load_addr):
	* solib-pa64.c (pa64_solib_create_inferior_hook)
	(pa64_open_symbol_file_object): Remove local 'buf'.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start)
	(som_open_symbol_file_object): Likewise.
	* solib-spu.c (spu_current_sos): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	* spu-multiarch.c (parse_spufs_run, spu_fetch_registers)
	(spu_store_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	* tic6x-tdep.c (tic6x_get_longjmp_target): Likewise.
	* xstormy16-tdep.c (xstormy16_store_return_value)
	(xstormy16_push_dummy_call, xstormy16_resolve_jmp_table_entry)
	(xstormy16_find_jmp_table_entry): Likewise.
@
text
@d1204 12
a1215 11
      static unsigned int hppa32_tramp[] = {
        0x0fdf1291, /* stw r31,-8(,sp) */
        0x02c010a1, /* ldsid (,r22),r1 */
        0x00011820, /* mtsp r1,sr0 */
        0xe6c00000, /* be,l 0(sr0,r22),%sr0,%r31 */
        0x081f0242, /* copy r31,rp */
        0x0fd11082, /* ldw -8(,sp),rp */
        0x004010a1, /* ldsid (,rp),r1 */
        0x00011820, /* mtsp r1,sr0 */
        0xe0400000, /* be 0(sr0,rp) */
        0x08000240  /* nop */
d1226 1
a1226 1
      write_memory (sp, (char *)&hppa32_tramp, sizeof (hppa32_tramp));
d1241 6
a1246 6
      static unsigned int hppa64_tramp[] = {
        0xeac0f000, /* bve,l (r22),%r2 */
        0x0fdf12d1, /* std r31,-8(,sp) */
        0x0fd110c2, /* ldd -8(,sp),rp */
        0xe840d002, /* bve,n (rp) */
        0x08000240  /* nop */
d1248 1
d1253 1
a1253 1
      write_memory (sp, (char *)&hppa64_tramp, sizeof (hppa64_tramp));
@


1.86
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d775 1
a775 1
      char buf[4];
d793 1
a793 1
  char buf[32];
d860 1
a860 1
  char buf[4];
d1358 1
a1358 1
      char buf[8];
@


1.85
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d3 1
a3 1
   Copyright (C) 2002-2005, 2007-2012 Free Software Foundation, Inc.
@


1.84
log
@	* blockframe.c (find_pc_partial_function_gnu_ifunc): Change type of
	"name" parameter to const char ** from char **.  All callers updated.
	(find_pc_partial_function): Ditto.
	(cache_pc_function_name): Change type to const char * from char *.
	* symtab.h ((find_pc_partial_function_gnu_ifunc): Update.
	(find_pc_partial_function): Update.
	* alpha-tdep.h (struct gdbarch_tdep, member pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	All uses updated.
	* arch-utils.c (generic_in_solib_return_trampoline): Change
	type of "name" parameter to const char * from char *.
	* arch-utils.h (generic_in_solib_return_trampoline): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* gdbarch.sh (in_solib_return_trampoline): Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Update.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Update.
	* m32r-linux-tdep.c (m32r_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* skip.c (skip_function_pc): Ditto.
	* sparc-sol2-tdep.c (sparc_sol2_pc_in_sigtramp): Ditto.
	* sparc-tdep.h (sparc_sol2_pc_in_sigtramp): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_pc_in_sigtramp): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_pc_in_sigtramp): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_pc_in_sigtramp): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_pc_in_sigtramp): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_pc_in_sigtramp): Ditto.
	* nbsd-tdep.c (nbsd_pc_in_sigtramp): Similary for "func_name".
	* nbsd-tdep.h (nbsd_pc_in_sigtramp): Update.
@
text
@d180 1
a180 1
  int insn, i;
@


1.83
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d233 1
a233 1
				      CORE_ADDR pc, char *name)
d984 1
a984 1
      char *name;
@


1.82
log
@	* hppa-hpux-tdep.c (hppa64_hpux_search_dummy_call_sequence): Use
	ALL_OBJFILE_MSYMBOLS.
	(hppa_hpux_find_dummy_bpaddr): Likewise.
	* jit.c (jit_object_close_impl): Use
	terminate_minimal_symbol_table.
@
text
@d3 1
a3 2
   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.81
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@a959 1
  int i;
d982 1
a982 1
  for (i = 0, msym = obj->msymbols; i < obj->minimal_symbol_count; i++, msym++)
a1089 1
  int i;
d1109 1
a1109 3
      for (i = 0, msym = sec->objfile->msymbols;
      	   i < sec->objfile->minimal_symbol_count;
	   i++, msym++)
@


1.81.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2002-2005, 2007-2012 Free Software Foundation, Inc.
@


1.80
log
@2011-02-27  Michael Snyder  <msnyder@@vmware.com>

	* darwin-nat-info.c: Fix comment typo.
	* dwarf2expr.h: Ditto.
	* fbsd-nat.c: Ditto.
	* fbsd-nat.h: Ditto.
	* frame-unwind.h: Ditto.
	* frame.h: Ditto.
	* hppa-hpux-tdep.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* linux-nat.c: Ditto.
	* nbsd-nat.c: Ditto.
	* nbsd-nat.h: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* serial.c: Ditto.
	* ui-file.h: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d756 1
@


1.79
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* h8300-tdep.c: Comment cleanup, mostly periods and spaces.
	* hppa-hpux-tdep.c: Ditto.
	* hppa-linux-nat.c: Ditto.
	* hppa-linux-tdep.c: Ditto.
	* hppanbsd-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* hppa-tdep.h: Ditto.
	* hpux-thread.c: Ditto.
	* i386-cygwin-tdep.c: Ditto.
	* i386-darwin-nat.c: Ditto.
	* i386gnu-nat.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* i386-linux-tdep.c: Ditto.
	* i386-nat.c: Ditto.
	* i386-nat.h: Ditto.
	* i386nbsd-tdep.c: Ditto.
	* i386-sol2-nat.c: Ditto.
	* i386-stub.c: Ditto.
	* i386-tdep.c: Ditto.
	* i386-tdep.h: Ditto.
	* i387-tdep.c: Ditto.
	* ia64-linux-nat.c: Ditto.
	* ia64-linux-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* infcall.c: Ditto.
	* infcall.h: Ditto.
	* infcmd.c: Ditto.
	* inferior.c: Ditto.
	* inferior.h: Ditto.
	* infloop.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* interps.c: Ditto.
	* interps.h: Ditto.
	* iq2000-tdep.c: Ditto.
	* irix5-nat.c: Ditto.
	* jit.c: Ditto.
	* jit.h: Ditto.
	* jv-exp.y: Ditto.
	* jv-lang.c: Ditto.
	* jv-lang.h: Ditto.
	* jv-typeprint.c: Ditto.
	* jv-valprint.c: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* linespec.c: Ditto.
	* linux-fork.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-thread-db.c: Ditto.
	* lm32-tdep.c: Ditto.
@
text
@d1076 1
a1076 1
     we need the dummy trampoline to return to the an instruction address in 
@


1.78
log
@run copyright.sh for 2011.
@
text
@d167 1
a167 1
     unwinders to help. 
d195 1
a195 1
     instructions long. */
d328 2
a329 1
	pc = (CORE_ADDR) read_memory_integer (pc & ~0x3, word_size, byte_order);
d348 2
a349 2
     have unfortunately a value of zero. So this function would return here
     as if we were not in a trampoline. To fix this, we go look at the partial
d352 1
a352 1
     partial symbol information is also wrong sometimes. This is because 
d355 4
a358 4
     in a shared library, then it can also be a trampoline.  This would
     be OK, except that I believe the way they decide if we are ina shared library
     does not work. SOOOO..., even if we have a regular function w/o trampolines
     its minimal symbol can be assigned type mst_solib_trampoline.
d361 1
a361 1
     Hopefully this is correct most of the times. */
d366 1
a366 1
   we can delete all the code which appears between the lines */
d379 2
a380 2
	  /* go look if there is another minimal symbol with the same name as 
	     this one, but with type mst_text. This would happen if the msym
d382 1
a382 1
	     symbol with the same name corresponding to the real function */
d396 2
a397 2
	    /* the type of msym is correct (mst_solib_trampoline), but
	       the unwind info is wrong, so set it to the correct value */
d400 1
a400 1
	    /* the stub type info in the unwind is correct (this is not a
d402 2
a403 2
	       should be mst_text. So we need to fix the msym, and also
	       get out of this function */
d440 2
a441 1
	    return (hppa_extract_21 (prev_inst) + hppa_extract_17 (curr_inst)) & ~0x3;
d444 2
a445 1
	      warning (_("Unable to find ldil X,%%r1 before ble Y(%%sr4,%%r1)."));
d485 2
a486 1
	  libsym = lookup_minimal_symbol (SYMBOL_LINKAGE_NAME (stubsym), NULL, NULL);
d581 2
a582 1
  regcache_cooked_write_unsigned (regcache, HPPA_PCOQ_TAIL_REGNUM, pcoq_tail + 4);
d655 2
a656 2
  /* See /usr/include/machine/save_state.h for the structure of the save_state_t
     structure. */
d663 1
a663 1
      /* Narrow registers. */
d670 1
a670 1
      /* Wide registers. */
d716 2
a717 1
  return hppa_frame_prev_register_helper (this_frame, info->saved_regs, regnum);
d1096 1
a1096 1
         as it is "regular" code (i.e. not a stub) */
d1204 1
a1204 3
     - set the continuing address of the "dummy code" as the sequence.

*/
d1453 2
a1454 2
   BASE contains to stack frame base of the current frame. 
   SAVE_REGS is the register file stored in the frame cache. */
@


1.77
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d3 1
a3 1
   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010
@


1.76
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009
@


1.75
log
@	* inferior.h (read_pc, write_pc): Remove.
	* regcache.c (read_pc, write_pc): Remove.

	* infrun.c (displaced_step_fixup): Use regcache_read_pc instead
	of read_pc.
	(handle_inferior_event): Use regcache_read_pc instead of read_pc
	when determining value of stop_pc.  Replace subsequent uses of
	read_pc by inspecting already-retrieved stop_pc value.
	(keep_going): Use regcache_read_pc instead of read_pc.

	* breakpoint.c (watchpoint_check): Use current frame architecture
	and PC instead of current_gdbarch and read_pc ().
	* tracepoint.c (set_traceframe_context): Replace PC argument
	with FRAME argument.
	(trace_start_command, finish_tfind_command): Update calls.
	(finish_tfind_command): Compare frame IDs to identify transitions
	between frames.
	(trace_find_pc_command): Use regcache_read_pc instead of read_pc.
	* rs6000-nat.c (exec_one_dummy_insn): Pass in regcache instead
	of gdbarch.  Use regcache_read_pc and regcache_write_pc instead
	of read_pc and write_pc.
	(store_register): Make regcache argument non-const.  Update call
	to exec_one_dummy_insn.

	* thread.c (switch_to_thread): Use regcache_read_pc instead of read_pc.
	* infcmd.c (post_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (enable_break, svr4_relocate_main_executable): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Likewise.
	* record.c (record_wait): Likewise.
	* procfs.c (procfs_wait): Likewise.
	* remote-mips.c (common_open, mips_wait): Likewise.
	* remote-m32r-sdi.c (m32r_resume): Likewise.

	* symfile.c (generic_load): Use regcache_write_pc instead of write_pc.
	* monitor.c (monitor_create_inferior, monitor_load): Likewise.
	* m32r-rom.c (m32r_load, m32r_upload_command): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior, m32r_load): Likewise.
	* remote-mips.c (mips_create_inferior, mips_load): Likewise.

	* solib-darwin.c: Include "regcache.h".
	* solib-pa64.c: Include "regcache.h".
	* solib-svr4.c: Include "regcache.h.".

	* symfile.c: Do not mention read_pc or write_pc in comments.
	* dink32-rom.c: Likewise.
	* m32r-rom.c: Likewise.
	* mips-tdep.c: Likewise.
@
text
@d89 2
a90 1
hppa32_hpux_in_solib_call_trampoline (CORE_ADDR pc, char *name)
d92 1
d138 1
a138 1
	  insn = read_memory_integer (addr, 4);
d159 2
a160 1
hppa64_hpux_in_solib_call_trampoline (CORE_ADDR pc, char *name)
d162 2
d196 1
a196 1
  insn = read_memory_integer (pc, 4);
d209 1
a209 1
  insn = read_memory_integer (addr, 4);
d214 1
a214 1
  insn = read_memory_integer (addr + 4, 4);
d219 1
a219 1
  insn = read_memory_integer (addr + 8, 4);
d233 2
a234 1
hppa_hpux_in_solib_return_trampoline (CORE_ADDR pc, char *name)
d236 1
d269 1
a269 1
	  insn = read_memory_integer (addr, 4);
d311 2
d328 1
a328 2
	pc = (CORE_ADDR) read_memory_integer
			   (pc & ~0x3, gdbarch_ptr_bit (gdbarch) / 8);
d333 1
a333 2
      pc = (CORE_ADDR) read_memory_integer
			 (pc & ~0x3, gdbarch_ptr_bit (gdbarch) / 8);
d430 1
a430 1
      curr_inst = read_memory_integer (loc, 4);
d514 1
a514 1
	      return read_memory_integer (sp - 8, 4) & ~0x3;
d530 1
a530 1
		   gdbarch_ptr_bit (gdbarch) / 8)) & ~0x3;
d543 1
a543 1
		   gdbarch_ptr_bit (gdbarch) / 8)) & ~0x3;
d628 1
d653 2
a654 1
  flag = read_memory_unsigned_integer(scptr + HPPA_HPUX_SS_FLAGS_OFFSET, 4);
d719 2
d737 1
a737 1
      insn = extract_unsigned_integer (buf, sizeof buf);
d760 1
d775 1
a775 1
	return extract_unsigned_integer (buf, sizeof (buf));
d785 1
d794 1
a794 1
      return extract_unsigned_integer (&buf[24], 8);
d809 2
a810 1
hppa_hpux_search_pattern (CORE_ADDR start, CORE_ADDR end, 
d813 1
d824 1
a824 1
    insns[i] = extract_unsigned_integer (buf, HPPA_INSN_SIZE);
d847 1
d880 2
a881 1
      addr = hppa_hpux_search_pattern (u->region_start, u->region_end, 
d899 2
a900 1
	      addr = hppa_hpux_search_pattern (u->region_start, u->region_end, 
d923 1
a923 1
	  addr = hppa_hpux_search_pattern (start, end, ldsid_pattern,
d935 1
a935 1
  insn = extract_unsigned_integer (buf, sizeof (buf));
d947 1
d995 2
a996 1
	      insn = extract_unsigned_integer (buf + offset, HPPA_INSN_SIZE);
d1347 2
d1353 2
a1354 1
  flags = extract_unsigned_integer (save_state + HPPA_HPUX_SS_FLAGS_OFFSET, 4);
d1357 1
a1357 2
      struct gdbarch *arch = get_regcache_arch (regcache);
      size_t size = register_size (arch, HPPA_FLAGS_REGNUM);
d1360 1
a1360 1
      store_unsigned_integer (buf, size, flags);
d1456 2
d1467 2
a1468 1
			      register_size (gdbarch, HPPA_PCOQ_HEAD_REGNUM));
d1473 1
a1473 1
      stubpc = read_memory_integer (base - 24, gdbarch_ptr_bit (gdbarch) / 8);
d1479 1
a1479 2
      stubpc = read_memory_integer
		 (base - 8, gdbarch_ptr_bit (gdbarch) / 8);
@


1.74
log
@	* hppa-hpux-tdep.c (hppa_hpux_write_pc): Remove 'return'.
@
text
@d1111 1
a1111 1
  pc = read_pc ();
@


1.73
log
@        Updated copyright notices for most files.
@
text
@d1407 1
a1407 1
  return hppa_write_pc (regcache, pc);
@


1.72
log
@	* breakpoint.h (struct bp_location): Change type of section
	member to "struct obj_section *".
	* tracepoint.h (struct tracepoint): Likewise.
	* symtab.h (struct general_symbol_info): Replace bfd_section
	member with obj_section.
	(struct symtab_and_line): Change type of section member to
	"struct obj_section *".
	(SYMBOL_BFD_SECTION): Remove macro, replace by ...
	(SYMBOL_OBJ_SECTION): ... this.

	* minsym.c (prim_record_minimal_symbol_and_info): Record symbol
	section as obj_section instead of bfd_section.

	* ada-lang.c (ada_decode_symbol): Use gsymbol->obj_section
	directly instead of looking of obj_section from bfd_section.

	* objfiles.h (find_pc_sect_section): Remove.
	* objfiles.c (find_pc_sect_section): Remove.
	(find_pc_section): Inline find_pc_sect_section code.

	* symfile.h (find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(section_is_overlay, section_is_mapped): Change type of section
	argument to struct obj_section *.
	(pc_in_mapped_range, pc_in_unmapped_range): Likewise.
	(overlay_mapped_address, overlay_unmapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	* symtab.h (symbol_overlayed_address): Likewise.
	* symfile.c (overlay_is_mapped): Remove.
	(section_is_mapped): Inline overlay_is_mapped code.  Update.
	(overlay_invalidate_all): Update.
	(section_is_overlay): Change section argument to type
	"struct obj_section *".  Use bfd_ methods.
	(pc_in_unmapped_range): Likewise.  Handle relocated sections.
	(pc_in_mapped_range): Likewise.  Handle relocated sections.
	(sections_overlap): Likewise.
	(overlay_unmapped_address): Likewise.
	(overlay_mapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	(find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(list_overlays_command): Update.
	(map_overlay_command, unmap_overlay_command): Update.
	(simple_overlay_update): Update.

	* block.h (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* block.c (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* symtab.h (find_pc_sect_function, find_pc_sect_psymtab,
	find_pc_sect_symtab, find_pc_sect_psymbol, find_pc_sect_line,
	lookup_minimal_symbol_by_pc_section, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.
	* blockframe.c (find_pc_sect_function): Likewise.
	* breakpoint.c (describe_other_breakpoints): Likewise.
	(breakpoint_has_pc, check_duplicates_for): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_minimal_symbol_by_pc_section): Likewise.
	* symtab.c (find_pc_sect_psymtab_closer): Likewise.
	(find_pc_sect_psymtab, find_pc_sect_psymbol, find_pc_sect_symtab,
	find_pc_sect_line, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.

	* blockframe.c (find_pc_partial_function): Update to section
	type changes.  No longer call find_pc_sect_section.
	(cache_pc_function_section): Change to type "struct obj_section *".
	* breakpoint.c (resolve_sal_pc): Update to section type changes.
	* exec.c (xfer_memory): Likewise.
	* findvar.c (read_var_value): Likewise.
	* infcmd.c (jump_command): Likewise.
	* linespec.c (minsym_found): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_solib_trampoline_symbol_by_pc): Likewise.
	* parse.c (write_exp_msymbol): Likewise.
	* printcmd.c (build_address_symbolic): Likewise.
	(address_info, sym_info): Likewise.
	* symmisc.c (dump_msymbols, print_symbol): Likewise.
	* symtab.c (fixup_section): Likewise.
	(fixup_symbol_section, fixup_psymbol_section): Likewise.
	(find_pc_line, find_function_start_sal): Likewise.
	* target.c (memory_xfer_partial): Likewise.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline): Likewise.
	* spu-tdep.c (spu_overlay_update): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008
@


1.71
log
@	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME.
	* blockframe.c (find_pc_partial_function): Likewise.
	* buildsym.c (find_symbol_in_list): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* coffread.c (patch_opaque_types, process_coff_symbol): Likewise.
	(coff_read_enum_type): Likewise.  Use SYMBOL_SET_LINKAGE_NAME.
	* cp-support.c (cp_remove_params): Renamed from remove_params and
	made global.
	(overload_list_add_symbol): Update call to remove_params.
	* cp-support.h (cp_remove_params): Declare.
	* dwarf2read.c (process_enumeration_scope): Use SYMBOL_LINKAGE_NAME.
	(dwarf2_const_value): Use SYMBOL_PRINT_NAME.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* f-valprint.c (info_common_command, there_is_a_visible_common_named):
	Use SYMBOL_LINKAGE_NAME to find symbols and SYMBOL_PRINT_NAME
	for messages.
	* findvar.c (read_var_value): Use SYMBOL_LINKAGE_NAME.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa_hpux_skip_trampoline_code): Use SYMBOL_LINKAGE_NAME to find
	symbols and SYMBOL_PRINT_NAME for messages.
	* jv-lang.c (add_class_symbol): Use SYMBOL_SET_LINKAGE_NAME.
	* linespec.c (decode_line_2): Use SYMBOL_LINKAGE_NAME.
	* mdebugread.c (parse_symbol): Use SYMBOL_LINKAGE_NAME and
	SYMBOL_SET_LINKAGE_NAME.
	(mylookup_symbol): Use SYMBOL_LINKAGE_NAME.
	* minsyms.c (add_minsym_to_demangled_hash_table): Use
	SYMBOL_SEARCH_NAME.
	(lookup_minimal_symbol): Use SYMBOL_LINKAGE_NAME or
	SYMBOL_MATCHES_SEARCH_NAME, depending on the pass.
	* objfiles.h (ALL_OBJFILE_MSYMBOLS): Use SYMBOL_LINKAGE_NAME.
	* printcmd.c (build_address_symbolic): Use SYMBOL_LINKAGE_NAME.
	(address_info): Use SYMBOL_PRINT_NAME for messages and
	SYMBOL_LINKAGE_NAME for lookups.
	* sol-thread.c (info_cb): Use SYMBOL_PRINT_NAME for messages.
	* stabsread.c (patch_block_stabs, define_symbol)
	(read_type, read_enum_type, common_block_end)
	(cleanup_undefined_types_1, scan_file_globals): Use
	SYMBOL_LINKAGE_NAME, SYMBOL_SET_LINKAGE_NAME, ALL_OBJFILE_MSYMBOLS,
	and SYMBOL_PRINT_NAME.
	* stack.c (print_frame_args): Use SYMBOL_LINKAGE_NAME.
	(print_frame, frame_info): Use SYMBOL_PRINT_NAME for output.  Use
	cp_remove_params instead of cplus_demangle.
	(print_block_frame_labels, print_frame_arg_vars): Use
	SYMBOL_LINKAGE_NAME.
	* symmisc.c (dump_msymbols): Use ALL_OBJFILE_MSYMBOLS and
	SYMBOL_LINKAGE_NAME.
	(dump_symtab_1, print_symbol, print_partial_symbols)
	(maintenance_check_symtabs): Use SYMBOL_LINKAGE_NAME.
	* symtab.h (DEPRECATED_SYMBOL_NAME): Delete.
	(SYMBOL_SET_LINKAGE_NAME): New.
	(SYMBOL_SET_NAMES): Add a comment.
	* tracepoint.c (set_traceframe_context, validate_actionline)
	(collect_symbol, scope_info): Use SYMBOL_LINKAGE_NAME for
	lookups and SYMBOL_PRINT_NAME for output.
	* typeprint.c (typedef_print): Use SYMBOL_LINKAGE_NAME.
	* xcoffread.c (process_xcoff_symbol): Use SYMBOL_SET_LINKAGE_NAME.
@
text
@d182 1
a182 1
  sec = SYMBOL_BFD_SECTION (minsym);
@


1.70
log
@	* arm-tdep.c (arm_pc_is_thumb): Use obj_section_addr.
	* hppa-hpux-tdep.c (hppa_hpux_find_dummy_bpaddr): Likewise.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): Use
	obj_section_addr and obj_section_endaddr.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Likewise.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Likewise.
	* ia64-tdep.c (ia64_find_global_pointer): Likewise.
	(find_extant_func_descr): Likewise.
	* solib-frv.c (frv_relocate_main_executable): Use
	obj_section_addr.
	* xstormy16-tdep.c (xstormy16_find_jmp_table_entry): Use
	obj_section_addr and obj_section_endaddr.
@
text
@d100 1
a100 1
  if (minsym && strcmp (DEPRECATED_SYMBOL_NAME (minsym), ".stub") == 0)
d379 2
a380 2
		&& strcmp (DEPRECATED_SYMBOL_NAME (msymbol),
			    DEPRECATED_SYMBOL_NAME (msym)) == 0)
d475 1
a475 1
	  libsym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (stubsym), NULL, NULL);
d479 1
a479 1
		       DEPRECATED_SYMBOL_NAME (stubsym));
@


1.69
log
@        * hppa-tdep.h, hppa-tdep.c, hppa-hpux-tdep.c: Update for unwinder
        changes.
@
text
@d1071 1
a1071 1
      u = find_unwind_entry (sec->addr);
d1073 1
a1073 1
        return sec->addr;
@


1.68
log
@
	* hppa-tdep.h (find_global_pointer): Add gdbarch as parameter.

	* hppa-hpux-tdep.c (hppa32_hpux_find_global_pointer): Likewise. Replace
	current_gdbarch by gdbarch.
	(hppa64_hpux_find_global_pointer): Likewise.
	* hppa-tdep.c (hppa_find_global_pointer): Likewise.
	(hppa32_push_dummy_call, hppa64_push_dummy_call): Update call for
	find_global_pointer.

	* hppabsd-tdep.c (hppabsd_find_global_pointer): Add gdbarch as
	parameter.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): Likewise.

	* hppa-linux-nat.c (hppa_linux_register_addr): Use ARRAY_SIZE instead
	of gdbarch_num_regs.

	* hppa-hpux-tdep.c (hppa_hpux_sr_for_addr): Add gdbarch as parameter and
	replace current_gdbarch by gdbarch.
	(hppa_hpux_push_dummy_code): Update call for hppa_hpux_sr_for_addr.
@
text
@d615 1
a615 1
hppa_hpux_sigtramp_frame_unwind_cache (struct frame_info *next_frame,
d619 1
a619 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d631 1
a631 1
  info->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d633 1
a633 1
  sp = frame_unwind_register_unsigned (next_frame, HPPA_SP_REGNUM);
d678 1
a678 1
  info->base = frame_unwind_register_unsigned (next_frame, HPPA_SP_REGNUM);
d684 1
a684 1
hppa_hpux_sigtramp_frame_this_id (struct frame_info *next_frame,
d689 3
a691 2
    = hppa_hpux_sigtramp_frame_unwind_cache (next_frame, this_prologue_cache);
  *this_id = frame_id_build (info->base, frame_pc_unwind (next_frame));
d694 2
a695 2
static void
hppa_hpux_sigtramp_frame_prev_register (struct frame_info *next_frame,
d697 1
a697 4
					int regnum, int *optimizedp,
					enum lval_type *lvalp, 
					CORE_ADDR *addrp,
					int *realnump, gdb_byte *valuep)
d700 3
a702 3
    = hppa_hpux_sigtramp_frame_unwind_cache (next_frame, this_prologue_cache);
  hppa_frame_prev_register_helper (next_frame, info->saved_regs, regnum,
		                   optimizedp, lvalp, addrp, realnump, valuep);
d705 4
a708 8
static const struct frame_unwind hppa_hpux_sigtramp_frame_unwind = {
  SIGTRAMP_FRAME,
  hppa_hpux_sigtramp_frame_this_id,
  hppa_hpux_sigtramp_frame_prev_register
};

static const struct frame_unwind *
hppa_hpux_sigtramp_unwind_sniffer (struct frame_info *next_frame)
d711 1
a711 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
d722 1
a722 1
      if (!safe_frame_unwind_memory (next_frame, u->region_start,
d724 1
a724 1
	return NULL;
d732 1
a732 1
    return &hppa_hpux_sigtramp_frame_unwind;
d734 1
a734 1
  return NULL;
d737 8
d1426 1
a1426 1
   NEXT_FRAME is the next frame in the current list of frames.
d1430 1
a1430 1
hppa_hpux_unwind_adjust_stub (struct frame_info *next_frame, CORE_ADDR base,
d1433 3
a1435 6
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  int optimized, realreg;
  enum lval_type lval;
  CORE_ADDR addr;
  char buffer[sizeof(ULONGEST)];
  ULONGEST val;
d1439 5
a1443 6
  trad_frame_get_prev_register (next_frame, saved_regs, 
				HPPA_PCOQ_HEAD_REGNUM, 
				&optimized, &lval, &addr, &realreg, buffer);
  val = extract_unsigned_integer (buffer, 
				  register_size (get_frame_arch (next_frame), 
      				  		 HPPA_PCOQ_HEAD_REGNUM));
d1445 1
a1445 1
  u = find_unwind_entry (val);
d1448 1
a1448 2
      stubpc = read_memory_integer
		 (base - 24, gdbarch_ptr_bit (gdbarch) / 8);
d1452 1
a1452 1
           == get_pc_function_start (val))
d1488 1
a1488 1
  frame_unwind_append_sniffer (gdbarch, hppa_hpux_sigtramp_unwind_sniffer);
@


1.67
log
@
	* rs6000-nat.c (add_vmap, vmap_ldinfo, vmap_exec): Replace
	DEPRECATED_STREQ by its expression.
	* coffread.c (coff_locate_sections, coff_symtab_read): Likewise.
	* xcoffread.c (read_xcoff_symtab, read_symbol_lineno, find_linenos)
	(scan_xcoff_symtab): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code): Likewise.
	* f-lang.c (find_common_for_function): Likewise.
	* objc-exp.y (parse_number): Likewise.

	* defs.h (DEPRECATED_STREQ): Remove.
@
text
@d744 2
a745 1
hppa32_hpux_find_global_pointer (struct value *function)
d764 1
a764 1
  return gdbarch_tdep (current_gdbarch)->solib_get_got_by_pc (faddr);
d768 2
a769 1
hppa64_hpux_find_global_pointer (struct value *function)
d783 1
a783 1
      return gdbarch_tdep (current_gdbarch)->solib_get_got_by_pc (faddr);
d1036 1
a1036 1
hppa_hpux_sr_for_addr (CORE_ADDR addr)
d1040 1
a1040 1
  sr = addr >> (gdbarch_tdep (current_gdbarch)->bytes_per_address * 8 - 2);
d1117 2
a1118 1
  if (hppa_hpux_sr_for_addr (pc) == hppa_hpux_sr_for_addr (funcaddr))
@


1.66
log
@	Updated copyright notices for most files.
@
text
@d379 2
a380 1
		&& DEPRECATED_STREQ (DEPRECATED_SYMBOL_NAME (msymbol), DEPRECATED_SYMBOL_NAME (msym)))
@


1.65
log
@	* configure.tgt: Remove hppa*64*-*-hpux11* special case.
	* config/pa/hppa64.mt: Delete file.
	* config/pa/hppahpux.mt (MT_CFLAGS): Remove.
	(TDEPFILES): Move somread.o to ...
	* config/pa/hpux.mh (NATDEPFILES): ... here.

	* configure.ac: Add check for elf_hp.h header.
	Search libdl and libxpdl for dlgetmodinfo.
	* config.in, configure: Regenerate.
	* solib-pa64.c: Conditionalize compilation on #ifdef HAVE_ELF_HP_H
	instead of #ifndef PA_SOM_ONLY.  Include "solib.h".
	(pa64_solib_select): Take gdbarch instead of tdep argument.  Call
	set_solib_ops instead of modifying current_target_so_ops.
	* solib-pa64.h (pa64_solib_select): Update prototype.
	* solib-som.c: Remove include of "som.h".  Include "solib.h".
	(som_solib_select): Take gdbarch instead of tdep argument.  Call
	set_solib_ops instead of modifying current_target_so_ops.
	* solib-som.h (som_solib_select): Update prototype.
	* hppa-hpux-tdep.c (hppa_hpux_som_init_abi): Pass gdbarch instead
	of tdep to som_solib_select call.
	(hppa_hpux_elf_init_abi): Pass gdbarch instead of tdep to
	pa64_solib_select call.
	* Makefile.in: Update dependencies.
@
text
@d3 2
a4 1
   Copyright (C) 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.64
log
@	* block.h (struct block): Remove "gcc_compile_flag" member.
	(BLOCK_GCC_COMPILED): Remove.
	* block.c (allocate_block): Do not clear BLOCK_GCC_COMPILED.
	* buildsym.c (finish_block): Do not set it.
	* symmisc.c (dump_symtab_1): Do not dump it.

	* value.h (using_struct_return): Remove "gcc_p" argument.
	* value.c (using_struct_return): Likewise.
	* eval.c (evaluate_subexp_standard): Adapt callers.
	* infcall.c (call_function_by_hand): Likewise.
	* stack.c (return_command): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.

	* gdbarch.sh (push_dummy_code): Remove "using_gcc" parameter.
	* gdbarch.c, gdbarch.h: Regenerate.
	* cris-tdep.c (cris_push_dummy_code): Adapt prototype.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.
	* infcall.c (generic_push_dummy_code, push_dummy_code): Likewise.
	(push_dummy_code, call_function_by_hand): Adapt callers.
@
text
@d1499 1
a1499 1
  som_solib_select (tdep);
d1511 1
a1511 1
  pa64_solib_select (tdep);
@


1.63
log
@2007-10-08  Markus Deuling  <deuling@@de.ibm.com>

	* hppa-tdep.c (hppa_stub_unwind_sniffer, hppa_dump_tdep): Replace
	current_gdbarch by gdbarch.
	* hppa-linux-nat.c (fetch_register, store_register)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Use get_regcache_arch or
	get_frame_arch to get at the current architecture by regcache or by
	frame, respectively.
	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code
	(hppa_hpux_unwind_adjust_stub): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register)
	(hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
@
text
@d1096 1
a1096 1
			   CORE_ADDR funcaddr, int using_gcc,
@


1.62
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d302 1
d319 1
a319 1
			   (pc & ~0x3, gdbarch_ptr_bit (current_gdbarch) / 8);
d325 1
a325 1
			 (pc & ~0x3, gdbarch_ptr_bit (current_gdbarch) / 8);
d521 1
a521 1
		   gdbarch_ptr_bit (current_gdbarch) / 8)) & ~0x3;
d534 1
a534 1
		   gdbarch_ptr_bit (current_gdbarch) / 8)) & ~0x3;
d1426 1
d1446 1
a1446 1
		 (base - 24, gdbarch_ptr_bit (current_gdbarch) / 8);
d1453 1
a1453 1
		 (base - 8, gdbarch_ptr_bit (current_gdbarch) / 8);
@


1.61
log
@	* gdbarch.sh (read_pc): Add REGCACHE argument.  Remove PTID argument.
	(write_pc): Likewise.  Remove default implementation, add predicate.
	* gdbarch.c, gdbarch.h: Regenerate.
	* regcache.c (read_pc_pid): Use current regcache instead of calling
	read_register_pid.
	(write_pc_pid): Check gdbarch_write_pc predicate, implement default
	case inline.
	(generic_target_write_pc): Remove.
	* inferior.h (generic_target_write_pc): Remove.
	* frv-tdep.c (frv_gdbarch_init): Do not install it.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Likewise.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	* sh64-tdep.c (sh64_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.

	* avr-tdep.c (avr_read_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling read_register_pid.
	* hppa-hpux-tdep.c (hppa_hpux_read_pc): Likewise.
	* hppa-tdep.c (hppa_read_pc): Likewise.
	* hppa-tdep.h (hppa_read_pc): Likewise.
	* ia64-tdep.c (ia64_read_pc): Likewise.
	* m32r-tdep.c (m32r_read_pc): Likewise.
	* mep-tdep.c (mep_read_pc): Likewise.
	* mn10300-tdep.c (mn10300_read_pc): Likewise.
	* spu-tdep.c (spu_read_pc): Likewise.

	* arm-tdep.c (arm_write_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling write_register_pid.
	* avr-tdep.c (avr_write_pc): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_write_pc): Likewise.
	* hppa-tdep.c (hppa_write_pc): Likewise.
	* hppa-tdep.h (hppa_write_pc): Likewise.
	* i386-linux-tdep.c (i386_linux_write_pc): Likewise.
	* amd64-linux-tdep.c (amd64_linux_write_pc): Likewise.
	* ia64-linux-tdep.c (ia64_linux_write_pc): Likewise.
	* ia64-tdep.c (ia64_write_pc): Likewise.
	* ia64-tdep.h (ia64_write_pc): Likewise.
	* m32r-tdep.c (m32r_write_pc): Likewise.
	* m88k-tdep.c (m88k_write_pc): Likewise.
	* mep-tdep.c (mep_write_pc): Likewise.
	* mips-tdep.c (mips_write_pc): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.
	* mn10300-tdep.c (mn10300_write_pc): Likewise.
	* sparc-tdep.c (sparc_write_pc): Likewise.
	* spu-tdep.c (spu_write_pc): Likewise.

	* mips-tdep.c (read_signed_register): Remove.
	(read_signed_register_pid): Likewise.
	(mips_read_pc): Add REGCACHE argument.  Remove PTID argument.
	Use REGCACHE instead of calling read_signed_register_pid.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.60
log
@	* gdbarch.sh (push_dummy_code): Add REGCACHE argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* infcall.c (generic_push_dummy_code): Add REGCACHE argument.
	(push_dummy_code): Likewise.  Pass it to callee.
	(call_function_by_hand): Pass current regcache to push_dummy_code.

	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Add REGCACHE
	argument.  Use it instead of current_regcache.

	* cris-tdep.c (cris_push_dummy_code): Add REGCACHE argument.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.
@
text
@d1375 1
a1375 1
hppa_hpux_read_pc (ptid_t ptid)
d1380 1
a1380 1
  flags = read_register_pid (HPPA_FLAGS_REGNUM, ptid);
d1382 5
a1386 1
    return read_register_pid (HPPA_R31_REGNUM, ptid) & ~0x3;
d1388 1
a1388 1
  return hppa_read_pc (ptid);
d1392 1
a1392 1
hppa_hpux_write_pc (CORE_ADDR pc, ptid_t ptid)
d1397 1
a1397 1
  flags = read_register_pid (HPPA_FLAGS_REGNUM, ptid);
d1399 1
a1399 1
    write_register_pid (HPPA_R31_REGNUM, pc | 0x3, ptid);
d1401 1
a1401 1
  return hppa_write_pc (pc, ptid);
@


1.59
log
@	* gdbarch.sh (skip_trampoline_code): Add FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c (generic_skip_trampoline_code): Add FRAME argument.
	* arch-utils.h (generic_skip_trampoline_code): Likewise.
	* infrun.c (handle_inferior_event): Pass current frame to
	gdbarch_skip_trampoline_code and skip_language_trampoline.

	* language.c (unk_lang_trampoline): Add FRAME argument.
	(skip_language_trampoline): Add FRAME argument.  Pass it to
	skip_trampoline callback.
	* language.h: Add forward declaration of struct frame_info.
	(struct language_defn): Add FRAME argument to skip_trampoline.
	(skip_language_trampoline): Add FRAME argument.
	* cp-abi.c (cplus_skip_trampoline): Add FRAME argument.  Pass it
	to skip_trampoline callback.
	* cp-abi.h: Add forward declaration of struct frame_info.
	(cplus_skip_trampoline): Add FRAME argument.
	(struct cp_abi_ops): Add FRAME argument to skip_trampoline callback.
	* gnu-v3-abi.c (gnuv3_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.
	* objc-lang.c (objc_skip_trampoline): Add FRAME argument.  Pass it
	to gdbarch_skip_trampoline_code.

	* minsyms.c (find_solib_trampoline_target): Add FRAME argument.
	* symtab.h (find_solib_trampoline_target): Likewise.
	* obsd-tdep.c (obsd_skip_solib_resolver): Pass current frame to
	find_solib_trampoline_target.

	* arm-tdep.c (arm_skip_stub): Add FRAME argument.  Read registers
	from FRAME instead of calling read_register.

	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code): Add FRAME
	argument.  Read registers from FRAME instead of using read_register.
	* hppa-tdep.c (hppa_skip_trampoline_code): Likewise.
	* hppa-tdep.h (hppa_skip_trampoline_code): Add FRAME argument.

	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Add FRAME
	argument.

	* m32c-tdep.c (m32c_skip_trampoline_code): Add FRAME argument.

	* mips-tdep.c (mips_skip_trampoline_code): Add FRAME argument.  Read
	registers from FRAME instead of using read_signed_register.

	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Add FRAME
	argument.
	(ppc64_standard_linkage_target): Likewise.  Read registers from FRAME
	instead of using read_register.
	(ppc64_skip_trampoline_code): Add FRAME argument.  Pass it to
	ppc64_standard_linkage_target.
	* rs6000-tdep.c (rs6000_skip_trampoline_code): Add FRAME argument.
	Pass it to find_solib_trampoline_target.  Read registers from FRAME
	instead of using read_register.

	* xstormy16-tdep.c (xstormy16_skip_trampoline_code): Add FRAME
	argument.
@
text
@d1100 2
a1101 1
			   CORE_ADDR *real_pc, CORE_ADDR *bp_addr)
d1119 1
a1119 1
      regcache_cooked_write_unsigned (current_regcache, HPPA_RP_REGNUM, *bp_addr);
d1197 1
a1197 1
      regcache_cooked_write_unsigned (current_regcache, 22, stubaddr);
d1202 1
a1202 1
      regcache_cooked_write_unsigned (current_regcache, 31, *bp_addr);
d1208 1
a1208 1
      regcache_cooked_write_unsigned (current_regcache, argreg, sp);
d1224 1
a1224 1
      regcache_cooked_write_unsigned (current_regcache, 22, funcaddr);
d1228 1
a1228 1
      regcache_cooked_write_unsigned (current_regcache, 31, *bp_addr);
d1234 1
a1234 1
      regcache_cooked_write_unsigned (current_regcache, argreg, sp);
@


1.58
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_PTR_BIT): Replace with gdbarch_ptr_bit.
	* solib-svr4.c (svr4_truncate_ptr): Likewise.
	* solib-pa64.c (read_dynamic_info): Likewise.
	* solib-legacy.c (legacy_svr4_fetch_link_map_offsets): Likewise.
	* solib.c (info_sharedlibrary_command): Likewise.
	* s390-nat.c (SUBOFF): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	* procfs.c (info_proc_mappings): Likewise.
	* printcmd.c (decode_format): Likewise.
	* nto-tdep.c (nto_truncate_ptr): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips64_linux_get_longjmp_target): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* jv-valprint.c (java_value_print): Likewise.
	* jv-lang.c (get_java_object_header_size): Likewise.
	* hppa-tdep.c (skip_prologue_hard_way, hppa_frame_cache): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code)
	(hppa_hpux_unwind_adjust_stub): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
	* gdbtypes.c (make_pointer_type, make_reference_type)
	(smash_to_memberptr_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d302 1
a302 1
hppa_hpux_skip_trampoline_code (CORE_ADDR pc)
d313 1
a313 1
      pc = (CORE_ADDR) read_register (22);
d324 1
a324 1
      pc = (CORE_ADDR) read_register (22);
d329 1
a329 1
    pc = (CORE_ADDR) (read_register (22));
d503 5
a507 2
	    return (read_memory_integer
		    (read_register (HPPA_SP_REGNUM) - 8, 4)) & ~0x3;
d521 1
a521 1
		  (read_register (HPPA_SP_REGNUM) - 24,
d534 1
a534 1
		  (read_register (HPPA_SP_REGNUM) - 24,
@


1.57
log
@	* hppa-hpux-tdep.c (args_for_find_stub, HP_ACC_EH_notify_hook,
	HP_ACC_EH_set_hook_value, HP_ACC_EH_notify_callback, HP_ACC_EH_break,
	HP_ACC_EH_catch_throw, HP_ACC_EH_catch_catch, __eh_notification,
	hp_cxx_exception_support, hp_cxx_exception_support_initialized,
	eh_notify_hook_addr, eh_notify_callback_addr, eh_break_addr,
	eh_catch_throw_addr, break_callback_sal, setup_d_pid_in_inferior,
	find_stub_with_shl_get, cover_find_stub_with_shl_get,
	initialize_hp_cxx_exception_support, child_enable_exception_callback,
	current_ex_event, child_get_current_exception_event): Remove.
	(hppa_hpux_inferior_created): Remove.
	(hppa_hpux_init_abi): Do not install hppa_hpux_inferior_created.

	* breakpoint.h (deprecated_exception_catchpoints_are_fragile): Remove.
	(deprecated_exception_support_initialized): Remove.
	* breakpoint.c (deprecated_exception_catchpoints_are_fragile): Remove.
	(deprecated_exception_support_initialized): Remove.
	(breakpoint_init_inferior): Remove handling of non-zero
	deprecated_exception_catchpoints_are_fragile.

	* symtab.h (deprecated_hp_som_som_object_present): Remove.
	* symtab.c (deprecated_hp_som_som_object_present): Remove.
	* c-typeprint.c (c_type_print_base): Remove handling of non-zero
	deprecated_hp_som_som_object_present.
	* eval.c (evaluate_subexp_standard): Likewise.
	* valops.c (value_cast): Likewise.

	* parse.c (parse_nested_classes_for_hpacc, coloncolon): Remove.
	* parser-defs.h (parse_nested_classes_for_hpacc): Remove.
	* c-exp.y (yylex): Do not call parse_nested_classes_for_hpacc.
@
text
@d319 2
a320 1
	pc = (CORE_ADDR) read_memory_integer (pc & ~0x3, TARGET_PTR_BIT / 8);
d325 2
a326 1
      pc = (CORE_ADDR) read_memory_integer (pc & ~0x3, TARGET_PTR_BIT / 8);
d518 2
a519 1
		  (read_register (HPPA_SP_REGNUM) - 24, TARGET_PTR_BIT / 8)) & ~0x3;
d531 2
a532 1
		  (read_register (HPPA_SP_REGNUM) - 24, TARGET_PTR_BIT / 8)) & ~0x3;
d1437 2
a1438 1
      stubpc = read_memory_integer (base - 24, TARGET_PTR_BIT / 8);
d1444 2
a1445 1
      stubpc = read_memory_integer (base - 8, TARGET_PTR_BIT / 8);
@


1.56
log
@	* hppa-hpux-tdep.c: Do not include <dl.h> or <machine/save_state.h>.
	(offsetof): Do not define.
	(find_stub_with_shl_get): Use numerical value 3 instead of
	symbolic value TYPE_PROCEDURE.
@
text
@a69 8
typedef struct
  {
    struct minimal_symbol *msym;
    CORE_ADDR solib_handle;
    CORE_ADDR return_val;
  }
args_for_find_stub;

a565 556
/* Exception handling support for the HP-UX ANSI C++ compiler.
   The compiler (aCC) provides a callback for exception events;
   GDB can set a breakpoint on this callback and find out what
   exception event has occurred. */

/* The name of the hook to be set to point to the callback function.  */
static char HP_ACC_EH_notify_hook[] = "__eh_notify_hook";
/* The name of the function to be used to set the hook value.  */
static char HP_ACC_EH_set_hook_value[] = "__eh_set_hook_value";
/* The name of the callback function in end.o */
static char HP_ACC_EH_notify_callback[] = "__d_eh_notify_callback";
/* Name of function in end.o on which a break is set (called by above).  */
static char HP_ACC_EH_break[] = "__d_eh_break";
/* Name of flag (in end.o) that enables catching throws.  */
static char HP_ACC_EH_catch_throw[] = "__d_eh_catch_throw";
/* Name of flag (in end.o) that enables catching catching.  */
static char HP_ACC_EH_catch_catch[] = "__d_eh_catch_catch";
/* The enum used by aCC.  */
typedef enum
  {
    __EH_NOTIFY_THROW,
    __EH_NOTIFY_CATCH
  }
__eh_notification;

/* Is exception-handling support available with this executable? */
static int hp_cxx_exception_support = 0;
/* Has the initialize function been run? */
static int hp_cxx_exception_support_initialized = 0;
/* Address of __eh_notify_hook */
static CORE_ADDR eh_notify_hook_addr = 0;
/* Address of __d_eh_notify_callback */
static CORE_ADDR eh_notify_callback_addr = 0;
/* Address of __d_eh_break */
static CORE_ADDR eh_break_addr = 0;
/* Address of __d_eh_catch_catch */
static CORE_ADDR eh_catch_catch_addr = 0;
/* Address of __d_eh_catch_throw */
static CORE_ADDR eh_catch_throw_addr = 0;
/* Sal for __d_eh_break */
static struct symtab_and_line *break_callback_sal = 0;

/* Code in end.c expects __d_pid to be set in the inferior,
   otherwise __d_eh_notify_callback doesn't bother to call
   __d_eh_break!  So we poke the pid into this symbol
   ourselves.
   0 => success
   1 => failure  */
static int
setup_d_pid_in_inferior (void)
{
  CORE_ADDR anaddr;
  struct minimal_symbol *msymbol;
  char buf[4];			/* FIXME 32x64? */

  /* Slam the pid of the process into __d_pid; failing is only a warning!  */
  msymbol = lookup_minimal_symbol ("__d_pid", NULL, symfile_objfile);
  if (msymbol == NULL)
    {
      warning (_("Unable to find __d_pid symbol in object file.\n"
		 "Suggest linking executable with -g (links in /opt/langtools/lib/end.o)."));
      return 1;
    }

  anaddr = SYMBOL_VALUE_ADDRESS (msymbol);
  store_unsigned_integer (buf, 4, PIDGET (inferior_ptid)); /* FIXME 32x64? */
  if (target_write_memory (anaddr, buf, 4))	/* FIXME 32x64? */
    {
      warning (_("Unable to write __d_pid.\n"
		 "Suggest linking executable with -g (links in /opt/langtools/lib/end.o)."));
      return 1;
    }
  return 0;
}

/* elz: Used to lookup a symbol in the shared libraries.
   This function calls shl_findsym, indirectly through a
   call to __d_shl_get. __d_shl_get is in end.c, which is always
   linked in by the hp compilers/linkers. 
   The call to shl_findsym cannot be made directly because it needs
   to be active in target address space. 
   inputs: - minimal symbol pointer for the function we want to look up
   - address in target space of the descriptor for the library
   where we want to look the symbol up.
   This address is retrieved using the 
   som_solib_get_solib_by_pc function (somsolib.c). 
   output: - real address in the library of the function.          
   note: the handle can be null, in which case shl_findsym will look for
   the symbol in all the loaded shared libraries.
   files to look at if you need reference on this stuff:
   dld.c, dld_shl_findsym.c
   end.c
   man entry for shl_findsym */

static CORE_ADDR
find_stub_with_shl_get (struct minimal_symbol *function, CORE_ADDR handle)
{
  struct symbol *get_sym, *symbol2;
  struct minimal_symbol *buff_minsym, *msymbol;
  struct type *ftype;
  struct value **args;
  struct value *funcval;
  struct value *val;

  int x, namelen, err_value, tmp = -1;
  CORE_ADDR endo_buff_addr, value_return_addr, errno_return_addr;
  CORE_ADDR stub_addr;


  args = alloca (sizeof (struct value *) * 8);		/* 6 for the arguments and one null one??? */
  funcval = find_function_in_inferior ("__d_shl_get");
  get_sym = lookup_symbol ("__d_shl_get", NULL, VAR_DOMAIN, NULL, NULL);
  buff_minsym = lookup_minimal_symbol ("__buffer", NULL, NULL);
  msymbol = lookup_minimal_symbol ("__shldp", NULL, NULL);
  symbol2 = lookup_symbol ("__shldp", NULL, VAR_DOMAIN, NULL, NULL);
  endo_buff_addr = SYMBOL_VALUE_ADDRESS (buff_minsym);
  namelen = strlen (DEPRECATED_SYMBOL_NAME (function));
  value_return_addr = endo_buff_addr + namelen;
  ftype = check_typedef (SYMBOL_TYPE (get_sym));

  /* do alignment */
  if ((x = value_return_addr % 64) != 0)
    value_return_addr = value_return_addr + 64 - x;

  errno_return_addr = value_return_addr + 64;


  /* set up stuff needed by __d_shl_get in buffer in end.o */

  target_write_memory (endo_buff_addr, DEPRECATED_SYMBOL_NAME (function), namelen);

  target_write_memory (value_return_addr, (char *) &tmp, 4);

  target_write_memory (errno_return_addr, (char *) &tmp, 4);

  target_write_memory (SYMBOL_VALUE_ADDRESS (msymbol),
		       (char *) &handle, 4);

  /* now prepare the arguments for the call */

  args[0] = value_from_longest (TYPE_FIELD_TYPE (ftype, 0), 12);
  args[1] = value_from_pointer (TYPE_FIELD_TYPE (ftype, 1), SYMBOL_VALUE_ADDRESS (msymbol));
  args[2] = value_from_pointer (TYPE_FIELD_TYPE (ftype, 2), endo_buff_addr);
  args[3] = value_from_longest (TYPE_FIELD_TYPE (ftype, 3), 3 /* TYPE_PROCEDURE */);
  args[4] = value_from_pointer (TYPE_FIELD_TYPE (ftype, 4), value_return_addr);
  args[5] = value_from_pointer (TYPE_FIELD_TYPE (ftype, 5), errno_return_addr);

  /* now call the function */

  val = call_function_by_hand (funcval, 6, args);

  /* now get the results */

  target_read_memory (errno_return_addr, (char *) &err_value, sizeof (err_value));

  target_read_memory (value_return_addr, (char *) &stub_addr, sizeof (stub_addr));
  if (stub_addr <= 0)
    error (_("call to __d_shl_get failed, error code is %d"), err_value);

  return (stub_addr);
}

/* Cover routine for find_stub_with_shl_get to pass to catch_errors */
static int
cover_find_stub_with_shl_get (void *args_untyped)
{
  args_for_find_stub *args = args_untyped;
  args->return_val = find_stub_with_shl_get (args->msym, args->solib_handle);
  return 0;
}

/* Initialize exception catchpoint support by looking for the
   necessary hooks/callbacks in end.o, etc., and set the hook value
   to point to the required debug function.

   Return 0 => failure
   1 => success          */

static int
initialize_hp_cxx_exception_support (void)
{
  struct symtabs_and_lines sals;
  struct cleanup *old_chain;
  struct cleanup *canonical_strings_chain = NULL;
  int i;
  char *addr_start;
  char *addr_end = NULL;
  char **canonical = (char **) NULL;
  int thread = -1;
  struct symbol *sym = NULL;
  struct minimal_symbol *msym = NULL;
  struct objfile *objfile;
  asection *shlib_info;

  /* Detect and disallow recursion.  On HP-UX with aCC, infinite
     recursion is a possibility because finding the hook for exception
     callbacks involves making a call in the inferior, which means
     re-inserting breakpoints which can re-invoke this code.  */

  static int recurse = 0;
  if (recurse > 0)
    {
      hp_cxx_exception_support_initialized = 0;
      deprecated_exception_support_initialized = 0;
      return 0;
    }

  hp_cxx_exception_support = 0;

  /* First check if we have seen any HP compiled objects; if not,
     it is very unlikely that HP's idiosyncratic callback mechanism
     for exception handling debug support will be available!
     This will percolate back up to breakpoint.c, where our callers
     will decide to try the g++ exception-handling support instead. */
  if (!deprecated_hp_som_som_object_present)
    return 0;

  /* We have a SOM executable with SOM debug info; find the hooks.  */

  /* First look for the notify hook provided by aCC runtime libs */
  /* If we find this symbol, we conclude that the executable must
     have HP aCC exception support built in.  If this symbol is not
     found, even though we're a HP SOM-SOM file, we may have been
     built with some other compiler (not aCC).  This results percolates
     back up to our callers in breakpoint.c which can decide to
     try the g++ style of exception support instead.
     If this symbol is found but the other symbols we require are
     not found, there is something weird going on, and g++ support
     should *not* be tried as an alternative.

     ASSUMPTION: Only HP aCC code will have __eh_notify_hook defined.  
     ASSUMPTION: HP aCC and g++ modules cannot be linked together.  */

  /* libCsup has this hook; it'll usually be non-debuggable */
  msym = lookup_minimal_symbol (HP_ACC_EH_notify_hook, NULL, NULL);
  if (msym)
    {
      eh_notify_hook_addr = SYMBOL_VALUE_ADDRESS (msym);
      hp_cxx_exception_support = 1;
    }
  else
    {
      warning (_("\
Unable to find exception callback hook (%s).\n\
Executable may not have been compiled debuggable with HP aCC.\n\
GDB will be unable to intercept exception events."),
	       HP_ACC_EH_notify_hook);
      eh_notify_hook_addr = 0;
      hp_cxx_exception_support = 0;
      return 0;
    }

  /* Next look for the notify callback routine in end.o */
  /* This is always available in the SOM symbol dictionary if end.o is
     linked in. */
  msym = lookup_minimal_symbol (HP_ACC_EH_notify_callback, NULL, NULL);
  if (msym)
    {
      eh_notify_callback_addr = SYMBOL_VALUE_ADDRESS (msym);
      hp_cxx_exception_support = 1;
    }
  else
    {
      warning (_("\
Unable to find exception callback routine (%s).\n\
Suggest linking executable with -g (links in /opt/langtools/lib/end.o).\n\
GDB will be unable to intercept exception events."),
	       HP_ACC_EH_notify_callback);
      eh_notify_callback_addr = 0;
      return 0;
    }

  if (!gdbarch_tdep (current_gdbarch)->is_elf)
    {
    /* Check whether the executable is dynamically linked or archive bound */
    /* With an archive-bound executable we can use the raw addresses we find
       for the callback function, etc. without modification. For an executable
       with shared libraries, we have to do more work to find the plabel, which
       can be the target of a call through $$dyncall from the aCC runtime 
       support library (libCsup) which is linked shared by default by aCC. */
    /* This test below was copied from somsolib.c/somread.c.  It may not be a very
       reliable one to test that an executable is linked shared. 
       pai/1997-07-18 */
    shlib_info = bfd_get_section_by_name (symfile_objfile->obfd, "$SHLIB_INFO$");
    if (shlib_info && (bfd_section_size (symfile_objfile->obfd, shlib_info) != 0))
      {
        /* The minsym we have has the local code address, but that's not
           the plabel that can be used by an inter-load-module call.  */
        /* Find solib handle for main image (which has end.o), and use
           that and the min sym as arguments to __d_shl_get() (which
           does the equivalent of shl_findsym()) to find the plabel.  */

        args_for_find_stub args;

        args.solib_handle = gdbarch_tdep (current_gdbarch)->solib_get_solib_by_pc (eh_notify_callback_addr);
        args.msym = msym;
        args.return_val = 0;

        recurse++;
        catch_errors (cover_find_stub_with_shl_get, &args,
		      _("Error while finding exception callback hook:\n"),
		      RETURN_MASK_ALL);
        eh_notify_callback_addr = args.return_val;
        recurse--;

        deprecated_exception_catchpoints_are_fragile = 1;

        if (!eh_notify_callback_addr)
	  {
	    /* We can get here either if there is no plabel in the export list
	       for the main image, or if something strange happened (?) */
	    warning (_("\
Couldn't find a plabel (indirect function label) for the exception callback.\n\
GDB will not be able to intercept exception events."));
	    return 0;
	  }
      }
    else
      deprecated_exception_catchpoints_are_fragile = 0;
    }

  /* Now, look for the breakpointable routine in end.o */
  /* This should also be available in the SOM symbol dict. if end.o linked in */
  msym = lookup_minimal_symbol (HP_ACC_EH_break, NULL, NULL);
  if (msym)
    {
      eh_break_addr = SYMBOL_VALUE_ADDRESS (msym);
      hp_cxx_exception_support = 1;
    }
  else
    {
      warning (_("\
Unable to find exception callback routine to set breakpoint (%s).\n\
Suggest linking executable with -g (link in /opt/langtools/lib/end.o).\n\
GDB will be unable to intercept exception events."),
	       HP_ACC_EH_break);
      eh_break_addr = 0;
      return 0;
    }

  /* Next look for the catch enable flag provided in end.o */
  sym = lookup_symbol (HP_ACC_EH_catch_catch, (struct block *) NULL,
		       VAR_DOMAIN, 0, (struct symtab **) NULL);
  if (sym)			/* sometimes present in debug info */
    {
      eh_catch_catch_addr = SYMBOL_VALUE_ADDRESS (sym);
      hp_cxx_exception_support = 1;
    }
  else
    /* otherwise look in SOM symbol dict. */
    {
      msym = lookup_minimal_symbol (HP_ACC_EH_catch_catch, NULL, NULL);
      if (msym)
	{
	  eh_catch_catch_addr = SYMBOL_VALUE_ADDRESS (msym);
	  hp_cxx_exception_support = 1;
	}
      else
	{
	  warning (_("\
Unable to enable interception of exception catches.\n\
Executable may not have been compiled debuggable with HP aCC.\n\
Suggest linking executable with -g (link in /opt/langtools/lib/end.o)."));
	  return 0;
	}
    }

  /* Next look for the catch enable flag provided end.o */
  sym = lookup_symbol (HP_ACC_EH_catch_catch, (struct block *) NULL,
		       VAR_DOMAIN, 0, (struct symtab **) NULL);
  if (sym)			/* sometimes present in debug info */
    {
      eh_catch_throw_addr = SYMBOL_VALUE_ADDRESS (sym);
      hp_cxx_exception_support = 1;
    }
  else
    /* otherwise look in SOM symbol dict. */
    {
      msym = lookup_minimal_symbol (HP_ACC_EH_catch_throw, NULL, NULL);
      if (msym)
	{
	  eh_catch_throw_addr = SYMBOL_VALUE_ADDRESS (msym);
	  hp_cxx_exception_support = 1;
	}
      else
	{
	  warning (_("\
Unable to enable interception of exception throws.\n\
Executable may not have been compiled debuggable with HP aCC.\n\
Suggest linking executable with -g (link in /opt/langtools/lib/end.o)."));
	  return 0;
	}
    }

  /* Set the flags */
  hp_cxx_exception_support = 2;	/* everything worked so far */
  hp_cxx_exception_support_initialized = 1;
  deprecated_exception_support_initialized = 1;

  return 1;
}

/* Target operation for enabling or disabling interception of
   exception events.
   KIND is either EX_EVENT_THROW or EX_EVENT_CATCH
   ENABLE is either 0 (disable) or 1 (enable).
   Return value is NULL if no support found;
   -1 if something went wrong,
   or a pointer to a symtab/line struct if the breakpointable
   address was found. */

struct symtab_and_line *
child_enable_exception_callback (enum exception_event_kind kind, int enable)
{
  char buf[4];

  if (!deprecated_exception_support_initialized
      || !hp_cxx_exception_support_initialized)
    if (!initialize_hp_cxx_exception_support ())
      return NULL;

  switch (hp_cxx_exception_support)
    {
    case 0:
      /* Assuming no HP support at all */
      return NULL;
    case 1:
      /* HP support should be present, but something went wrong */
      return (struct symtab_and_line *) -1;	/* yuck! */
      /* there may be other cases in the future */
    }

  /* Set the EH hook to point to the callback routine.  */
  store_unsigned_integer (buf, 4, enable ? eh_notify_callback_addr : 0);	/* FIXME 32x64 problem */
  /* pai: (temp) FIXME should there be a pack operation first? */
  if (target_write_memory (eh_notify_hook_addr, buf, 4))	/* FIXME 32x64 problem */
    {
      warning (_("\
Could not write to target memory for exception event callback.\n\
Interception of exception events may not work."));
      return (struct symtab_and_line *) -1;
    }
  if (enable)
    {
      /* Ensure that __d_pid is set up correctly -- end.c code checks this. :-( */
      if (PIDGET (inferior_ptid) > 0)
	{
	  if (setup_d_pid_in_inferior ())
	    return (struct symtab_and_line *) -1;
	}
      else
	{
	  warning (_("Internal error: Invalid inferior pid?  Cannot intercept exception events."));
	  return (struct symtab_and_line *) -1;
	}
    }

  switch (kind)
    {
    case EX_EVENT_THROW:
      store_unsigned_integer (buf, 4, enable ? 1 : 0);
      if (target_write_memory (eh_catch_throw_addr, buf, 4))	/* FIXME 32x64? */
	{
	  warning (_("Couldn't enable exception throw interception."));
	  return (struct symtab_and_line *) -1;
	}
      break;
    case EX_EVENT_CATCH:
      store_unsigned_integer (buf, 4, enable ? 1 : 0);
      if (target_write_memory (eh_catch_catch_addr, buf, 4))	/* FIXME 32x64? */
	{
	  warning (_("Couldn't enable exception catch interception."));
	  return (struct symtab_and_line *) -1;
	}
      break;
    default:
      error (_("Request to enable unknown or unsupported exception event."));
    }

  /* Copy break address into new sal struct, malloc'ing if needed.  */
  if (!break_callback_sal)
    break_callback_sal = XMALLOC (struct symtab_and_line);
  init_sal (break_callback_sal);
  break_callback_sal->symtab = NULL;
  break_callback_sal->pc = eh_break_addr;
  break_callback_sal->line = 0;
  break_callback_sal->end = eh_break_addr;

  return break_callback_sal;
}

/* Record some information about the current exception event */
static struct exception_event_record current_ex_event;

/* Report current exception event.  Returns a pointer to a record
   that describes the kind of the event, where it was thrown from,
   and where it will be caught.  More information may be reported
   in the future */
struct exception_event_record *
child_get_current_exception_event (void)
{
  CORE_ADDR event_kind;
  CORE_ADDR throw_addr;
  CORE_ADDR catch_addr;
  struct frame_info *fi, *curr_frame;
  int level = 1;

  curr_frame = get_current_frame ();
  if (!curr_frame)
    return (struct exception_event_record *) NULL;

  /* Go up one frame to __d_eh_notify_callback, because at the
     point when this code is executed, there's garbage in the
     arguments of __d_eh_break. */
  fi = find_relative_frame (curr_frame, &level);
  if (level != 0)
    return (struct exception_event_record *) NULL;

  select_frame (fi);

  /* Read in the arguments */
  /* __d_eh_notify_callback() is called with 3 arguments:
     1. event kind catch or throw
     2. the target address if known
     3. a flag -- not sure what this is. pai/1997-07-17 */
  event_kind = read_register (HPPA_ARG0_REGNUM);
  catch_addr = read_register (HPPA_ARG1_REGNUM);

  /* Now go down to a user frame */
  /* For a throw, __d_eh_break is called by
     __d_eh_notify_callback which is called by
     __notify_throw which is called
     from user code.
     For a catch, __d_eh_break is called by
     __d_eh_notify_callback which is called by
     <stackwalking stuff> which is called by
     __throw__<stuff> or __rethrow_<stuff> which is called
     from user code. */
  /* FIXME: Don't use such magic numbers; search for the frames */
  level = (event_kind == EX_EVENT_THROW) ? 3 : 4;
  fi = find_relative_frame (curr_frame, &level);
  if (level != 0)
    return (struct exception_event_record *) NULL;

  select_frame (fi);
  throw_addr = get_frame_pc (fi);

  /* Go back to original (top) frame */
  select_frame (curr_frame);

  current_ex_event.kind = (enum exception_event_kind) event_kind;
  current_ex_event.throw_sal = find_pc_line (throw_addr, 1);
  current_ex_event.catch_sal = find_pc_line (catch_addr, 1);

  return &current_ex_event;
}
a1405 9
static void
hppa_hpux_inferior_created (struct target_ops *objfile, int from_tty)
{
  /* Some HP-UX related globals to clear when a new "main"
     symbol file is loaded.  HP-specific.  */
  deprecated_hp_som_som_object_present = 0;
  hp_cxx_exception_support_initialized = 0;
}

a1472 2

  observer_attach_inferior_created (hppa_hpux_inferior_created);
@


1.55
log
@	* hppa-hpux-tdep.c: Include "regcache.h".
	* hppa-linux-tdep.c: Likewise.
	* hppa-tdep.c: Include "gdb_stdint.h".
	(find_unwind_entry): Cast host pointer to uintptr_t before passing
	it to paddr_nz.
	* Makefile.in: Update dependencies.
@
text
@a42 7
#include <dl.h>
#include <machine/save_state.h>

#ifndef offsetof
#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
#endif

d717 1
a717 1
  args[3] = value_from_longest (TYPE_FIELD_TYPE (ftype, 3), TYPE_PROCEDURE);
@


1.54
log
@	* gdbarch.sh: Add skip_permanent_breakpoint callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* infrun.c (SKIP_PERMANENT_BREAKPOINT): Remove default definition.
	(resume): Call gdbarch_skip_permanent_breakpoint instead of
	SKIP_PERMANENT_BREAKPOINT.  Inline default case.

	* hppa-hpux-tdep.c (hppa_skip_permanent_breakpoint): Make static.
	Add REGCACHE argument.  Use it instead of read/write_register.
	(hppa_hpux_init_abi): Install hppa_skip_permanent_breakpoint.

	* config/pa/tm-hppah.h: Delete file.
	* config/pa/hppa64.mt (DEPRECATED_TM_FILE): Set to tm-hppa.h.
	* config/pa/hppahpux.mt (DEPRECATED_TM_FILE): Likewise.
@
text
@d38 1
@


1.53
log
@Copyright updates for 2007.
@
text
@d551 2
a552 2
void
hppa_skip_permanent_breakpoint (void)
a567 2
  write_register (HPPA_PCOQ_HEAD_REGNUM, read_register (HPPA_PCOQ_TAIL_REGNUM));
  write_register (HPPA_PCSQ_HEAD_REGNUM, read_register (HPPA_PCSQ_TAIL_REGNUM));
d569 8
a576 1
  write_register (HPPA_PCOQ_TAIL_REGNUM, read_register (HPPA_PCOQ_TAIL_REGNUM) + 4);
d2045 2
@


1.52
log
@	* hppa-hpux-tdep.c (initialize_hp_cxx_exception_support): Remove
	message.
@
text
@d3 1
a3 1
   Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
@


1.51
log
@2006-03-01  Randolph Chung  <tausq@@debian.org>

	* hppa-hpux-tdep.c (initialize_hp_cxx_exception_support): Use
	TDEP->is_elf to determine if we are working with a SOM binary.
	(null_symtab_and_line): Remove unused variable.
	* config/pa/hppa64.mt: Use tm-hppa.h.
	* config/pa/tm-hppa64.h: Remove file.
@
text
@a867 1
        static char message[] = _("Error while finding exception callback hook:\n");
d874 2
a875 1
        catch_errors (cover_find_stub_with_shl_get, &args, message,
@


1.50
log
@2006-02-24  Randolph Chung  <tausq@@debian.org>

        * hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Initialize
	argreg.
        * solib-som.c (som_solib_remove_inferior_hook): Remove unused
	function.
@
text
@d847 40
a886 38
#ifndef GDB_TARGET_IS_HPPA_20W
  /* Check whether the executable is dynamically linked or archive bound */
  /* With an archive-bound executable we can use the raw addresses we find
     for the callback function, etc. without modification. For an executable
     with shared libraries, we have to do more work to find the plabel, which
     can be the target of a call through $$dyncall from the aCC runtime support
     library (libCsup) which is linked shared by default by aCC. */
  /* This test below was copied from somsolib.c/somread.c.  It may not be a very
     reliable one to test that an executable is linked shared. pai/1997-07-18 */
  shlib_info = bfd_get_section_by_name (symfile_objfile->obfd, "$SHLIB_INFO$");
  if (shlib_info && (bfd_section_size (symfile_objfile->obfd, shlib_info) != 0))
    {
      /* The minsym we have has the local code address, but that's not
         the plabel that can be used by an inter-load-module call.  */
      /* Find solib handle for main image (which has end.o), and use
         that and the min sym as arguments to __d_shl_get() (which
         does the equivalent of shl_findsym()) to find the plabel.  */

      args_for_find_stub args;
      static char message[] = "Error while finding exception callback hook:\n";

      args.solib_handle = gdbarch_tdep (current_gdbarch)->solib_get_solib_by_pc (eh_notify_callback_addr);
      args.msym = msym;
      args.return_val = 0;

      recurse++;
      catch_errors (cover_find_stub_with_shl_get, &args, message,
		    RETURN_MASK_ALL);
      eh_notify_callback_addr = args.return_val;
      recurse--;

      deprecated_exception_catchpoints_are_fragile = 1;

      if (!eh_notify_callback_addr)
	{
	  /* We can get here either if there is no plabel in the export list
	     for the main image, or if something strange happened (?) */
	  warning (_("\
d889 5
a893 2
	  return 0;
	}
a894 3
  else
    deprecated_exception_catchpoints_are_fragile = 0;
#endif
a1067 3
/* Convenience struct */
static struct symtab_and_line null_symtab_and_line =
{NULL, 0, 0, 0};
@


1.49
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d1662 1
a1662 1
  int argreg;
@


1.48
log
@* hppa-hpux-tdep.c (hppa_hpux_sigtramp_unwind_sniffer): Detect
export stub for signal trampoline as a signal trampoline too.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.47
log
@* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind_cache): Don't
set pcoqh to rp.
@
text
@d1279 16
@


1.46
log
@2005-12-09  Randolph Chung  <tausq@@debian.org>

	PR corefiles/2026
	* hppa-hpux-tdep.c (hppa_hpux_core_osabi_sniffer): Check for HPUX ELF
	core files.
	(_initialize_hppa_hpux_tdep): Install sniffer for ELF core files.
	* config/pa/hpux.mh: Compile corelow.o.
@
text
@a1235 3
  info->saved_regs[HPPA_PCOQ_HEAD_REGNUM].addr = 
    info->saved_regs[HPPA_RP_REGNUM].addr;

@


1.45
log
@2005-11-19  Randolph Chung  <tausq@@debian.org>

	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind_cache): Use
	HPPA_HPUX_SS_* constants.  Ensure "off" is large enough to hold
	64-bit offset.  Set proper signal context offset for 64-bit
	programs.  Set pc properly for signal frames.
@
text
@d2067 18
d2097 3
@


1.44
log
@2005-11-19  Randolph Chung  <tausq@@debian.org>

	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_unwind_sniffer): Rely on the
	unwind record to determine a signal frame, instead of hardcoding
	a function name.
@
text
@d52 20
d1181 2
a1182 2
  CORE_ADDR sp, scptr;
  int i, incr, off, szoff;
d1193 5
a1197 1
  scptr = sp - 1352;
d1203 3
a1205 3
  flag = read_memory_unsigned_integer(scptr, 4);
    
  if (!(flag & 0x40))
d1208 1
a1208 1
      off = scptr + offsetof (save_state_t, ss_narrow);
d1215 1
a1215 1
      off = scptr + offsetof (save_state_t, ss_wide) + 8;
d1230 1
d1236 3
a1790 19
/* Bit in the `ss_flag' member of `struct save_state' that indicates
   that the 64-bit register values are live.  From
   <machine/save_state.h>.  */
#define HPPA_HPUX_SS_WIDEREGS		0x40

/* Offsets of various parts of `struct save_state'.  From
   <machine/save_state.h>.  */
#define HPPA_HPUX_SS_FLAGS_OFFSET	0
#define HPPA_HPUX_SS_NARROW_OFFSET	4
#define HPPA_HPUX_SS_FPBLOCK_OFFSET 	256
#define HPPA_HPUX_SS_WIDE_OFFSET        640

/* The size of `struct save_state.  */
#define HPPA_HPUX_SAVE_STATE_SIZE	1152

/* The size of `struct pa89_save_state', which corresponds to PA-RISC
   1.1, the lowest common denominator that we support.  */
#define HPPA_HPUX_PA89_SAVE_STATE_SIZE	512

@


1.43
log
@* hppa-tdep.h (HPPA_INSN_SIZE): New define.
* hppa-hpux-tdep.c (hppa_hpux_search_pattern)
(hppa64_hpux_search_dummy_call_sequence): Rewrite to avoid
assumption on sizeof(unsigned).
@
text
@d1249 1
a1250 1
  char *name;
d1252 1
a1252 1
  find_pc_partial_function (pc, &name, NULL, NULL);
d1254 1
a1254 1
  if (name && strcmp(name, "_sigreturn") == 0)
@


1.42
log
@* hppa-tdep.h (hppa_frame_prev_register_helper): Change types of
last argument to `gdb_byte *'.
* hppa-tdep.c (hppa32_convert_from_func_ptr_addr): Rewrite.
(hppa_frame_prev_register_helper): Change types of last argument
to `gdb_byte *'.
* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_prev_register):
Change types of last argument to `gdb_byte *'.
@
text
@d3 1
a3 1
   Copyright 2002, 2003, 2004 Free Software Foundation, Inc.
d1312 3
a1314 1
  unsigned int *buf;
a1315 1
  int region, insns;
d1317 2
a1318 3
  region = end - start + 4;
  insns = region / 4;
  buf = (unsigned int *) alloca (region);
d1320 3
a1322 1
  read_memory (start, (char *) buf, region);
d1324 1
a1324 4
  for (i = 0; i < insns; i++)
    buf[i] = extract_unsigned_integer (&buf[i], 4);

  for (offset = 0; offset <= insns - count; offset++)
d1328 1
a1328 1
	  if ((buf[offset + i] & patterns[i]) != patterns[i])
d1334 3
a1336 3
    
  if (offset <= insns - count)
    return start + offset * 4;
d1474 1
a1474 1
      unsigned int insns[2];
d1483 1
a1483 1
      if (target_read_memory (end - sizeof (insns), (char *)insns, sizeof (insns)) == 0)
d1485 1
a1485 1
	  for (offset = 0; offset < ARRAY_SIZE (insns); offset++)
d1489 1
a1489 1
	      insn = extract_unsigned_integer (&insns[offset], 4);
d1492 1
a1492 1
		  addr = (end - sizeof (insns)) + (offset * 4);
@


1.41
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d1228 5
a1232 5
					 void **this_prologue_cache,
					 int regnum, int *optimizedp,
					 enum lval_type *lvalp, 
					 CORE_ADDR *addrp,
					 int *realnump, void *valuep)
@


1.40
log
@2005-01-13  Michael Snyder  <msnyder@@redhat.com>

	* hppa-hpux-tdep.c: Whitespace tweaks.
@
text
@d143 1
a143 1
      warning ("Unable to find branch in parameter relocation stub.\n");
d269 1
a269 1
      warning ("Unable to find branch in parameter relocation stub.\n");
d409 1
a409 1
	  warning ("Unable to find branch in linker stub");
d426 1
a426 1
	      warning ("Unable to find ldil X,%%r1 before ble Y(%%sr4,%%r1).");
d462 1
a462 1
	      warning ("Unable to find symbol for 0x%lx", loc);
d469 1
a469 1
	      warning ("Unable to find library symbol for %s\n",
d499 1
a499 1
	      warning ("Unable to find restore of %%rp before bv (%%rp).");
d614 2
a615 2
      warning ("Unable to find __d_pid symbol in object file.");
      warning ("Suggest linking executable with -g (links in /opt/langtools/lib/end.o).");
d623 2
a624 2
      warning ("Unable to write __d_pid");
      warning ("Suggest linking executable with -g (links in /opt/langtools/lib/end.o).");
d712 1
a712 1
    error ("call to __d_shl_get failed, error code is %d", err_value);
d797 4
a800 1
      warning ("Unable to find exception callback hook (%s).", 
a801 2
      warning ("Executable may not have been compiled debuggable with HP aCC.");
      warning ("GDB will be unable to intercept exception events.");
d818 4
a821 1
      warning ("Unable to find exception callback routine (%s).", 
a822 2
      warning ("Suggest linking executable with -g (links in /opt/langtools/lib/end.o).");
      warning ("GDB will be unable to intercept exception events.");
d864 3
a866 2
	  warning ("Couldn't find a plabel (indirect function label) for the exception callback.");
	  warning ("GDB will not be able to intercept exception events.");
d884 5
a888 3
      warning ("Unable to find exception callback routine to set breakpoint (%s).", HP_ACC_EH_break);
      warning ("Suggest linking executable with -g (link in /opt/langtools/lib/end.o).");
      warning ("GDB will be unable to intercept exception events.");
d912 4
a915 3
	  warning ("Unable to enable interception of exception catches.");
	  warning ("Executable may not have been compiled debuggable with HP aCC.");
	  warning ("Suggest linking executable with -g (link in /opt/langtools/lib/end.o).");
d939 4
a942 3
	  warning ("Unable to enable interception of exception throws.");
	  warning ("Executable may not have been compiled debuggable with HP aCC.");
	  warning ("Suggest linking executable with -g (link in /opt/langtools/lib/end.o).");
d990 3
a992 2
      warning ("Could not write to target memory for exception event callback.");
      warning ("Interception of exception events may not work.");
d1005 1
a1005 1
	  warning ("Internal error: Invalid inferior pid?  Cannot intercept exception events.");
d1016 1
a1016 1
	  warning ("Couldn't enable exception throw interception.");
d1024 1
a1024 1
	  warning ("Couldn't enable exception catch interception.");
d1029 1
a1029 1
      error ("Request to enable unknown or unsupported exception event.");
d1362 1
a1362 1
    error ("Internal error creating objfile private data.\n");
d1457 1
a1457 1
    error ("Internal error creating objfile private data.\n");
d1609 2
a1610 2
  warning ("Cannot find suitable address to place dummy breakpoint; nested "
	   "calls may fail.\n");
d1713 2
a1714 2
        error ("Cannot call external function not referenced by application "
	       "(no import stub).\n");
d1724 1
a1724 1
        error ("Cannot make interspace call from here.\n");
d1750 1
a1750 1
        error ("Cannot make interspace call from here.\n");
d1876 1
a1876 1
    error ("Register set contents too small");
@


1.39
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d560 1
a560 1
/* The name of the hook to be set to point to the callback function */
d562 1
a562 1
/* The name of the function to be used to set the hook value */
d566 1
a566 1
/* Name of function in end.o on which a break is set (called by above) */
d568 1
a568 1
/* Name of flag (in end.o) that enables catching throws */
d570 1
a570 1
/* Name of flag (in end.o) that enables catching catching */
d572 1
a572 1
/* The enum used by aCC */
d727 2
a728 2
   necessary hooks/callbacks in end.o, etc., and set the hook value to
   point to the required debug function
d752 1
a752 1
     re-inserting breakpoints which can re-invoke this code */
d772 1
a772 1
  /* We have a SOM executable with SOM debug info; find the hooks */
d786 1
a786 1
     ASSUMPTION: HP aCC and g++ modules cannot be linked together. */
d797 2
a798 1
      warning ("Unable to find exception callback hook (%s).", HP_ACC_EH_notify_hook);
d807 2
a808 1
  /* This is always available in the SOM symbol dictionary if end.o is linked in */
d817 2
a818 1
      warning ("Unable to find exception callback routine (%s).", HP_ACC_EH_notify_callback);
d837 5
a841 5
      /* The minsym we have has the local code address, but that's not the
         plabel that can be used by an inter-load-module call. */
      /* Find solib handle for main image (which has end.o), and use that
         and the min sym as arguments to __d_shl_get() (which does the equivalent
         of shl_findsym()) to find the plabel. */
d978 1
a978 1
  /* Set the EH hook to point to the callback routine */
@


1.38
log
@* hppa-hpux-tdep.c (hppa64_hpux_search_dummy_call_sequence): Check
whether the name returned by find_pc_partial_function is a null
pointer, not whether it is an empty string.
@
text
@d38 1
@


1.37
log
@2004-12-17  Randolph Chung  <tausq@@debian.org>

	* hppa-hpux-tdep.c (setup_d_pid_in_inferior): Make static.
	(find_stub_with_shl_get): Make static.
@
text
@d1469 1
a1469 1
      if (*name == 0 || begin == 0 || end == 0)
@


1.36
log
@2004-12-17  Randolph Chung  <tausq@@debian.org>

	* hppa-hpux-tdep.c (IS_32BIT_TARGET): New.
	(in_opd_section): New.
	(hppa32_hpux_find_global_pointer): Rename from
	hppa_hpux_som_find_global_pointer.
	(hppa64_hpux_find_global_pointer): New.
	(ldsid_pattern): New.
	(hppa_hpux_search_pattern): New.
	(hppa32_hpux_search_dummy_call_sequence): New.
	(hppa64_hpux_search_dummy_call_sequence): New.
	(hppa_hpux_find_import_stub_for_addr): New.
	(hppa_hpux_sr_for_addr): New.
	(hppa_hpux_find_dummy_bpaddr): New.
	(hppa_hpux_init_abi): Use IS_32BIT_TARGET predicate.
	(hppa_hpux_som_init_abi): Set find_global_pointer method to
	hppa32_hpux_find_global_pointer instead of
	hppa_hpux_som_find_global_pointer.
	(hppa_hpux_elf_init_abi): Set find_global_pointer method.
	* hppa-tdep.c (hppa_init_objfile_priv_data): New.
	(read_unwind_info): Use function to initialize objfile-private data.
	(hppa32_push_dummy_call): Don't automatically set the RP if there is
	a push_dummy_code method.
	(hppa64_push_dummy_call): Retrieve and set the global pointer.
	Don't automatically set the RP if there is a push_dummy_code method.
	* hppa-tdep.h (hppa_objfile_private): Add dummy_call_sequence_reg and
	dummy_call_sequence_addr members.
	(hppa_init_objfile_priv_data): New prototype.
@
text
@d602 1
a602 1
int
d648 1
a648 1
CORE_ADDR
@


1.35
log
@2004-12-13  Randolph Chung  <tausq@@debian.org>

	* hppa-hpux-tdep.c (internalize_hp_cxx_exception_support): Call
	solib_get_solib_by_pc method through target vector.
	(hppa_hpux_som_find_global_pointer): Call solib_get_got_by_pc
	method through target vector.
@
text
@d48 3
d63 14
d1249 1
a1249 1
hppa_hpux_som_find_global_pointer (struct value *function)
d1272 27
a1298 5
hppa_hpux_push_dummy_code (struct gdbarch *gdbarch, CORE_ADDR sp,
			   CORE_ADDR funcaddr, int using_gcc,
			   struct value **args, int nargs,
			   struct type *value_type,
			   CORE_ADDR *real_pc, CORE_ADDR *bp_addr)
d1300 3
a1302 72
  /* FIXME: tausq/2004-06-09: This needs much more testing.  It is broken
     for pa64, but we should be able to get it to work with a little bit
     of work. gdb-6.1 has a lot of code to handle various cases; I've tried to
     simplify it and avoid compile-time conditionals.  */

  /* On HPUX, functions in the main executable and in libraries can be located
     in different spaces.  In order for us to be able to select the right 
     space for the function call, we need to go through an instruction seqeunce
     to select the right space for the target function, call it, and then
     restore the space on return.

     There are two helper routines that can be used for this task -- if
     an application is linked with gcc, it will contain a __gcc_plt_call
     helper function.  __gcc_plt_call, when passed the entry point of an
     import stub, will do the necessary space setting/restoration for the
     target function.

     For programs that are compiled/linked with the HP compiler, a similar
     function called __d_plt_call exists; __d_plt_call expects a PLABEL instead
     of an import stub as an argument.

     // *INDENT-OFF*
     To summarize, the call flow is:
       current function -> dummy frame -> __gcc_plt_call (import stub) 
                        -> target function
     or
       current function -> dummy frame -> __d_plt_call (plabel)
                        -> target function
     // *INDENT-ON*

     In general the "funcaddr" argument passed to push_dummy_code is the actual
     entry point of the target function.  For __gcc_plt_call, we need to 
     locate the import stub for the corresponding function.  Failing that,
     we construct a dummy "import stub" on the stack to pass as an argument.
     For __d_plt_call, we similarly synthesize a PLABEL on the stack to
     pass to the helper function.

     An additional twist is that, in order for us to restore the space register
     to its starting state, we need __gcc_plt_call/__d_plt_call to return
     to the instruction where we started the call.  However, if we put
     the breakpoint there, gdb will complain because it will find two 
     frames on the stack with the same (sp, pc) (with the dummy frame in 
     between).  Currently, we set the return pointer to (pc - 4) of the 
     current function.  FIXME: This is not an ideal solution; possibly if the 
     current pc is at the beginning of a page, this will cause a page fault. 
     Need to understand this better and figure out a better way to fix it.  */

  struct minimal_symbol *sym;

  /* Nonzero if we will use GCC's PLT call routine.  This routine must be
     passed an import stub, not a PLABEL.  It is also necessary to get %r19
     before performing the call.  (This is done by push_dummy_call.)  */
  int use_gcc_plt_call = 1;

  /* See if __gcc_plt_call is available; if not we will use the HP version
     instead.  */
  sym = lookup_minimal_symbol ("__gcc_plt_call", NULL, NULL);
  if (sym == NULL)
    use_gcc_plt_call = 0;

  /* If using __gcc_plt_call, we need to make sure we pass in an import
     stub.  funcaddr can be pointing to an export stub or a real function,
     so we try to resolve it to the import stub.  */
  if (use_gcc_plt_call)
    {
      struct objfile *objfile;
      struct minimal_symbol *funsym, *stubsym;
      CORE_ADDR stubaddr = 0;

      funsym = lookup_minimal_symbol_by_pc (funcaddr);
      if (!funsym)
        error ("Unable to find symbol for target function.\n");
d1304 12
a1315 1
      ALL_OBJFILES (objfile)
d1317 41
a1357 2
	  stubsym = lookup_minimal_symbol_solib_trampoline
	    (SYMBOL_LINKAGE_NAME (funsym), objfile);
d1359 24
a1382 1
          if (stubsym)
d1384 7
a1390 15
	      struct unwind_table_entry *u;

	      u = find_unwind_entry (SYMBOL_VALUE (stubsym));
	      if (u == NULL 
	          || (u->stub_unwind.stub_type != IMPORT
		      && u->stub_unwind.stub_type != IMPORT_SHLIB))
	        continue;

              stubaddr = SYMBOL_VALUE (stubsym);

	      /* If we found an IMPORT stub, then we can stop searching;
	         if we found an IMPORT_SHLIB, we want to continue the search
		 in the hopes that we will find an IMPORT stub.  */
	      if (u->stub_unwind.stub_type == IMPORT)
	        break;
d1393 10
d1404 2
a1405 1
      if (stubaddr != 0)
d1407 4
a1410 2
          /* Argument to __gcc_plt_call is passed in r22.  */
          regcache_cooked_write_unsigned (current_regcache, 22, stubaddr);
d1412 61
a1472 1
      else
d1474 64
a1537 1
	  /* No import stub found; let's synthesize one.  */
d1539 169
a1707 19
	  /* ldsid %r21, %r1 */
	  write_memory_unsigned_integer (sp, 4, 0x02a010a1);
	  /* mtsp %r1,%sr0 */
	  write_memory_unsigned_integer (sp + 4, 4, 0x00011820);
	  /* be 0(%sr0, %r21) */
	  write_memory_unsigned_integer (sp + 8, 4, 0xe2a00000);
          /* nop */
          write_memory_unsigned_integer (sp + 12, 4, 0x08000240);

          regcache_cooked_write_unsigned (current_regcache, 21, funcaddr);
          regcache_cooked_write_unsigned (current_regcache, 22, sp);
	}

      /* We set the breakpoint address and r31 to (close to) where the current
         pc is; when __gcc_plt_call returns, it will restore pcsqh to the
	 current value based on this.  The -4 is needed for frame unwinding
	 to work properly -- we need to land in a different function than
	 the current function.  */
      *bp_addr = (read_register (HPPA_PCOQ_HEAD_REGNUM) & ~3) - 4;
d1710 7
a1716 2
      /* Continue from __gcc_plt_call.  */
      *real_pc = SYMBOL_VALUE (sym);
d1720 12
a1731 1
      ULONGEST gp;
d1733 2
a1734 2
      /* Use __d_plt_call as a fallback; __d_plt_call expects to be called 
         with a plabel, so we need to build one.  */
d1736 3
a1738 5
      sym = lookup_minimal_symbol ("__d_plt_call", NULL, NULL);
      if (sym == NULL)
        error("Can't find an address for __d_plt_call or __gcc_plt_call "
	      "trampoline\nSuggest linking executable with -g or compiling "
	      "with gcc.");
d1740 1
a1740 3
      gp = gdbarch_tdep (gdbarch)->find_global_pointer (funcaddr);
      write_memory_unsigned_integer (sp, 4, funcaddr);
      write_memory_unsigned_integer (sp + 4, 4, gp);
d1742 1
a1742 2
      /* plabel is passed in r22 */
      regcache_cooked_write_unsigned (current_regcache, 22, sp);
d1745 1
a1745 2
  /* Pushed one stack frame, which has to be 64-byte aligned.  */
  sp += 64;
d1749 1
d1991 1
a1991 1
  if (tdep->bytes_per_address == 4)
d2024 2
a2025 1
  tdep->find_global_pointer = hppa_hpux_som_find_global_pointer;
d2036 2
@


1.34
log
@2004-12-13  Randolph Chung  <tausq@@debian.org>

	* hppa-hpux-tdep.c (internalize_hp_cxx_exception_support): Call
	solib_get_solib_by_pc method through target vector.
@
text
@d1251 1
a1251 1
  return som_solib_get_got_by_pc (faddr);
@


1.33
log
@2004-12-13  Randolph Chung  <tausq@@debian.org>

	* Makefile.in (pa64solib_h, somsolib_h): Delete.
	(solib_pa64_h, solib_som_h): New.
	(HFILES_NO_SRCDIR, ALLDEPFILES): Replace somsolib.h with solib-som.h.
	(hppa-hpux-tdep.o, hpread.o): Update dependencies.
	(pa64solib.o, somsolib.o): Delete.
	(solib-pa64.o, solib-som.o): New.
	* hppa-hpux-tdep.c: Include new solib interfaces.
	(hppa_hpux_som_init_abi): Attach to SOM solib interface.
	(hppa_hpux_elf_init_abi): Attach to PA64 ELF solib interface.
	* hppa-tdep.c (internalize_unwinds): If solib_get_text_base method
	is available, use it to determine the base of unwind records.
	* hppa-tdep.h (gdbarch_tdep): Add new solib methods.
	* hpread.c: Replace somsolib.h with solib-som.h.
	(hpread_process_one_debug_symbol): Use target vector to get thread
	start address.
	* config/pa/hppa64.mt (TDEPFILES): Use new solib interface.
	* config/pa/hppahpux.mt (TDEPFILES): Likewise.
	* config/pa/hpux.mh (NATDEPFILES): Delete references to target objects.
	* config/pa/tm-hppah.h: Use new solib interface.
@
text
@d825 1
a825 1
      args.solib_handle = som_solib_get_solib_by_pc (eh_notify_callback_addr);
@


1.32
log
@* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind_cache): Fix
typo.
@
text
@d34 3
a43 2
#include "hppa-tdep.h"

d1694 1
d1704 1
@


1.31
log
@* hppa-hpux-tdep.c (child_enable_exception_callback): Use XMALLOC.
(hppa_hpux_sigtramp_frame_unwind_cache): Use ARRAY_SIZE.
(hppa_hpux_init_abi): Reformat long line.
@
text
@d1172 1
a1172 1
  for (i = 0; ARRAY_SIZE (hppa_hpux_tramp_reg); i++)
@


1.30
log
@* hppa-hpux-tdep.c: Include "regset.h".
(HPPA_HPUX_SS_WIDEREGS, HPPA_HPUX_SS_FLAGS_OFFSET)
(HPPA_HPUX_SS_NARROW_OFFSET, HPPA_HPUX_SS_FPBLOCK_OFFSET)
(HPPA_HPUX_SS_WIDE_OFFSET, HPPA_HPUX_SAVE_STATE_SIZE)
(HPPA_HPUX_PA89_SAVE_STATE_SIZE): New defines.
(hppa_hpux_supply_ss_narrow, hppa_hpux_supply_ss_fpblock)
(hppa_hpux_supply_ss_wide, hppa_hpux_supply_save_state): New
functions.
(hppa_hpux_regset): New variable.
(hppa_hpux_regset_from_core_section): New function.
(hppa_hpux_init_abi): Set regset_from_core_section.
(hppa_hpux_core_osabi_sniffer): New function.
(_initialize_hppa_hpux_tdep): Register
hppa_hpux_core_osabi_sniffer.
* Makefile.in (hppa-hpux-tdep.o): Update dependencies.
* config/pa/hppahpux.mt (TDEPFILES): Add corelow.o.
@
text
@d1002 1
a1002 1
  /* Copy break address into new sal struct, malloc'ing if needed. */
d1004 1
a1004 3
    {
      break_callback_sal = (struct symtab_and_line *) xmalloc (sizeof (struct symtab_and_line));
    }
d1172 1
a1172 3
  for (i = 0; 
       i < sizeof(hppa_hpux_tramp_reg) / sizeof(hppa_hpux_tramp_reg[0]);
       i++)
d1665 2
a1666 2
  set_gdbarch_in_solib_return_trampoline (gdbarch,
					  hppa_hpux_in_solib_return_trampoline);
@


1.29
log
@2004-12-07  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.h (gdbarch_tdep): Add unwind_adjust_stub method.
	* hppa-hpux-tdep.c (hppa_hpux_unwind_adjust_stub): New function.
	(hppa_hpux_init_abi) Set unwind_adjust_stub method.
	* hppa-tdep.c (hppa_frame_cache): Call unwind_adjust_stub method
    	if defined.
@
text
@a25 1
#include "gdb_string.h"
d34 3
a36 1
#include "hppa-tdep.h"
d41 2
d1424 142
d1680 3
d1708 9
d1720 6
@


1.28
log
@* hppa-tdep.h (hppa_read_pc, hppa_write_pc, hppa_unwind_pc): New
prototypes.
* hppa-tdep.c (hppa_read_pc): Rename from hppa_target_read_pc.
Make global.  Remove HP-UX specific code.  Use
frame_unwind_register_unsigned instead of
frame_unwind_register_signed.
(hppa_write_pc): Rename from hppa_target_write_pc.  Make global.
Remove HP-UX specific code.
(hppa_unwind_pc): Make global.  Remove HP-UX specific code.
(hppa_frame_prev_register_helper): Set "flags" register to zero
for all unwound frames.
(hppa_gdbarch_init): Adjust.
* hppa-hpux-tdep.c (HPPA_HPUX_SS_INSYSCALL): New define.
(hppa_hpux_read_pc, hppa_hpux_write_pc)
(hppa_hpux_unwind_pc): New functions.
(hppa_hpux_init_abi): Set read_pc, write_pc and unwind_pc.
@
text
@d1474 38
d1522 2
@


1.27
log
@* hppa-hpux-tdep.c: Update copyright notice and year.
@
text
@d1418 46
d1491 4
@


1.26
log
@* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Use ULONGEST as
type of `gp' variable.
@
text
@d1 1
a1 1
/* Target-dependent code for HPUX running on PA-RISC, for GDB.
d3 1
a3 1
   Copyright 2002, 2003 Free Software Foundation, Inc.
d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.25
log
@2004-11-12  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_skip_permanent_breakpoint): Move definition ...
	* hppa-hpux-tdep.c (hppa_skip_permanent_breakpoint): ... to here.
	* config/pa/tm-hppa.h (SKIP_PERMANENT_BREAKPOINT): Move definition ...
	* config/pa/tm-hppah.h (SKIP_PERMANENT_BREAKPOINT): ... to here.
@
text
@d1393 1
a1393 1
      unsigned int gp;
@


1.24
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* hppa-tdep.c (hppa_stub_unwind_sniffer): Replace
	IN_SOLIB_CALL_TRAMPOLINE with tdep.in_solib_call_trampoline.
	* hppa-tdep.h (struct gdbarch_tdep): Add in_solib_call_trampoline.
	* hppa-hpux-tdep.c (hppa_hpux_init_abi): Set same.
	* hppa-linux-tdep.c (hppa_linux_init_abi): Ditto.
@
text
@d508 23
@


1.23
log
@        * hppa-hpux-tdep.c: Fix a compilation failure due to a comment
        that was inserted inside a comment.
@
text
@d1410 1
a1410 2
    set_gdbarch_in_solib_call_trampoline (gdbarch, 
					  hppa32_hpux_in_solib_call_trampoline);
d1412 1
a1412 2
    set_gdbarch_in_solib_call_trampoline (gdbarch, 
					  hppa64_hpux_in_solib_call_trampoline);
@


1.22
log
@2004-07-10  Randolph Chung  <tausq@@debian.org>

	* hppa-hpux-tdep.c (hppa_hpux_som_find_global_pointer): New
	function.
	(hppa_hpux_push_dummy_code): New function.
	(hppa_hpux_init_abi): Set push_dummy_code and call_dummy_location.
	Set find_global_pointer method.
@
text
@d1258 1
a1258 1
     /* *INDENT-OFF* */
d1265 1
a1265 1
     /* *INDENT-ON* */
@


1.21
log
@2004-06-14  Randolph Chung  <tausq@@debian.org>

	* Makefile.in (hppa-hpux-tdep.o): Update dependency.
	* hppa-hpux-tdep.c (hp_cxx_exception_support_initialized): Make
	static.
	(hppa_hpux_inferior_created): New function.
	(hppa_hpux_init_abi): Register observer.
	* symfile.c (hp_cxx_exception_support_initialized)
	(RESET_HP_UX_GLOBALS): Remove HPUXHPPA specific hacks.
	(symbol_file_add_main_1, symbol_file_clear): Likewise.
@
text
@d1207 188
d1420 3
d1434 2
@


1.20
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa_hpux_skip_trampoline_code): Don't cache symbol values.
	* hppa-linux-tdep.c (hppa_linux_in_dyncall): Likewise.
	* hppa-tdep.c (hppa_symbol_address): New function definition.
	* hppa-tdep.h (hppa_symbol_address): New function declaration.
@
text
@d33 1
d537 1
a537 1
int hp_cxx_exception_support_initialized = 0;
d1208 9
d1233 2
@


1.19
log
@2004-05-25  Randolph Chung  <tausq@@debian.org>

	* hppa-hpux-tdep.c (offsetof): Define.
	(hppa_hpux_pc_in_sigtramp, hppa32_hpux_frame_saved_pc_in_sigtramp)
	(hppa32_hpux_frame_base_before_sigtramp)
	(hppa32_hpux_frame_find_saved_regs_in_sigtramp)
	(hppa64_hpux_frame_saved_pc_in_sigtramp)
	(hppa64_hpux_frame_base_before_sigtramp)
	(hppa64_hpux_frame_find_saved_regs_in_sigtramp): Remove unused
	functions.
	(struct hppa_hpux_sigtramp_unwind_cache, hppa_hpux_tramp_reg)
	(hppa_hpux_sigtramp_frame_unwind_cache)
	(hppa_hpux_sigtramp_frame_this_id)
	(hppa_hpux_sigtramp_frame_prev_register)
	(hppa_hpux_sigtramp_frame_unwind)
	(hppa_hpux_sigtramp_unwind_sniffer): New signal trampoline unwinder.
	(hppa_hpux_init_abi): Register sigtramp unwinder.
	* Makefile.in (hppa-hpux-tdep.o): Update dependencies.
@
text
@a63 5
  static CORE_ADDR dyncall = 0;
  static CORE_ADDR sr4export = 0;

  /* FIXME XXX - dyncall and sr4export must be initialized whenever we get a
     new exec file */
d66 2
a67 19
  if (!dyncall)
    {
      minsym = lookup_minimal_symbol ("$$dyncall", NULL, NULL);
      if (minsym)
	dyncall = SYMBOL_VALUE_ADDRESS (minsym);
      else
	dyncall = -1;
    }

  if (!sr4export)
    {
      minsym = lookup_minimal_symbol ("_sr4export", NULL, NULL);
      if (minsym)
	sr4export = SYMBOL_VALUE_ADDRESS (minsym);
      else
	sr4export = -1;
    }

  if (pc == dyncall || pc == sr4export)
a275 3
  static CORE_ADDR dyncall = 0;
  static CORE_ADDR dyncall_external = 0;
  static CORE_ADDR sr4export = 0;
a278 30
  /* FIXME XXX - dyncall and sr4export must be initialized whenever we get a
     new exec file */

  if (!dyncall)
    {
      msym = lookup_minimal_symbol ("$$dyncall", NULL, NULL);
      if (msym)
	dyncall = SYMBOL_VALUE_ADDRESS (msym);
      else
	dyncall = -1;
    }

  if (!dyncall_external)
    {
      msym = lookup_minimal_symbol ("$$dyncall_external", NULL, NULL);
      if (msym)
	dyncall_external = SYMBOL_VALUE_ADDRESS (msym);
      else
	dyncall_external = -1;
    }

  if (!sr4export)
    {
      msym = lookup_minimal_symbol ("_sr4export", NULL, NULL);
      if (msym)
	sr4export = SYMBOL_VALUE_ADDRESS (msym);
      else
	sr4export = -1;
    }

d281 1
a281 1
  if (pc == dyncall)
d291 1
a291 1
  if (pc == dyncall_external)
d296 1
a296 1
  else if (pc == sr4export)
@


1.18
log
@2004-05-06  Randolph Chung  <tausq@@debian.org>

	* config/pa/tm-hppa.h (RO_REGNUM, FLAGS_REGNUM, RP_REGNUM)
	(HPPA_FP_REGNUM, HPPA_SP_REGNUM, SAR_REGNUM, IPSW_REGNUM)
	(PCOQ_HEAD_REGNUM, PCSQ_HEAD_REGNUM, PCOQ_TAIL_REGNUM, PCSQ_TAIL_REGNUM)
	(EIEM_REGNUM, IIR_REGNUM, ISR_REGNUM, IOR_REGNUM, SR4_REGNUM)
	(RCR_REGNUM, PID0_REGNUM, PID1_REGNUM, PID2_REGNUM, PID3_REGNUM)
	(CCR_REGNUM, TR0_REGNUM, CR27_REGNUM, HPPA_FP0_REGNUM, FP4_REGNUM)
	(ARG0_REGNUM, ARG1_REGNUM, ARG2_REGNUM, ARG3_REGNUM): Move *_REGNUM
	definitions ...
	* hppa-tdep.h: ... to here, with HPPA_ prefix.
	* Makefile.in (hppah-nat.o): Add $(hppa_tdep_h)
	* hppa-hpux-tdep.c (hppa32_hpux_frame_find_saved_regs_in_sig)
	(hppa64_hpux_frame_find_saved_regs_in_sig)
	(child_get_current_exception_event): Add HPPA_ prefix to *_REGNUM usage.
	* hppa-linux-nat.c (GR_REGNUM, TR_REGNUM, greg_map): Likewise.
	* hppa-linux-tdep.c (hppa_dwarf_reg_to_regnum)
	(hppa_linux_target_write_pc, hppa_linux_sigtramp_frame_unwind_cache)
	(hppa_linux_sigtramp_frame_prev_register): Likewise.
	* hppa-tdep.c (hppa32_return_value, hppa64_return_value)
	(hppa32_push_dummy_call, hppa64_push_dummy_call, hppa64_frame_align)
	(hppa_target_read_pc, hppa_target_write_pc, hppa_frame_cache)
	(hppa_frame_prev_register, hppa_stub_frame_unwind_cache)
	(hppa_stub_frame_prev_register, hppa_unwind_dummy_id)
	(hppa_skip_permanent_breakpoint, hppa_instruction_nullified)
	(hppa32_register_type, hppa_cannot_store_register)
	(hppa_fetch_pointer_argument, hppa_pseudo_register_read): Likewise.
	* hppah-nat.c (store_inferior_registers, fetch_register): Likewise.
	* hpread.c (hpread_process_one_debug_symbol): Likewise.
	* pa64solib.c (pa64_solib_have_load_event)
	(pa64_solib_have_unload_event, pa64_solib_loaded_library_pathname)
	(pa64_solib_unloaded_library_pathname): Likewise.
	* somsolib.c (som_solib_have_load_event, som_solib_have_unload_event)
	(som_solib_library_pathname): Likewise.
@
text
@d27 2
d38 4
a53 119
/* FIXME: brobecker 2002-12-25.  The following functions will eventually
   become static, after the multiarching conversion is done.  */
int hppa_hpux_pc_in_sigtramp (CORE_ADDR pc, char *name);
void hppa32_hpux_frame_saved_pc_in_sigtramp (struct frame_info *fi,
                                             CORE_ADDR *tmp);
void hppa32_hpux_frame_base_before_sigtramp (struct frame_info *fi,
                                             CORE_ADDR *tmp);
void hppa32_hpux_frame_find_saved_regs_in_sigtramp (struct frame_info *fi,
                                                    CORE_ADDR *fsr);
void hppa64_hpux_frame_saved_pc_in_sigtramp (struct frame_info *fi,
                                             CORE_ADDR *tmp);
void hppa64_hpux_frame_base_before_sigtramp (struct frame_info *fi,
                                             CORE_ADDR *tmp);
void hppa64_hpux_frame_find_saved_regs_in_sigtramp (struct frame_info *fi,
                                                    CORE_ADDR *fsr);

int
hppa_hpux_pc_in_sigtramp (CORE_ADDR pc, char *name)
{
  /* Actually, for a PA running HPUX the kernel calls the signal handler
     without an intermediate trampoline.  Luckily the kernel always sets
     the return pointer for the signal handler to point to _sigreturn.  */
  return (name && (strcmp ("_sigreturn", name) == 0));
}

/* For hppa32_hpux_frame_saved_pc_in_sigtramp, 
   hppa32_hpux_frame_base_before_sigtramp and
   hppa32_hpux_frame_find_saved_regs_in_sigtramp:

   The signal context structure pointer is always saved at the base
   of the frame which "calls" the signal handler.  We only want to find
   the hardware save state structure, which lives 10 32bit words into
   sigcontext structure.

   Within the hardware save state structure, registers are found in the
   same order as the register numbers in GDB.

   At one time we peeked at %r31 rather than the PC queues to determine
   what instruction took the fault.  This was done on purpose, but I don't
   remember why.  Looking at the PC queues is really the right way, and
   I don't remember why that didn't work when this code was originally
   written.  */

void
hppa32_hpux_frame_saved_pc_in_sigtramp (struct frame_info *fi, CORE_ADDR *tmp)
{
  *tmp = read_memory_integer (get_frame_base (fi) + (43 * 4), 4);
}

void
hppa32_hpux_frame_base_before_sigtramp (struct frame_info *fi,
                                        CORE_ADDR *tmp)
{
  *tmp = read_memory_integer (get_frame_base (fi) + (40 * 4), 4);
}

void
hppa32_hpux_frame_find_saved_regs_in_sigtramp (struct frame_info *fi,
					       CORE_ADDR *fsr)
{
  int i;
  const CORE_ADDR tmp = get_frame_base (fi) + (10 * 4);

  for (i = 0; i < NUM_REGS; i++)
    {
      if (i == HPPA_SP_REGNUM)
	fsr[HPPA_SP_REGNUM] = read_memory_integer (tmp + HPPA_SP_REGNUM * 4, 4);
      else
	fsr[i] = tmp + i * 4;
    }
}

/* For hppa64_hpux_frame_saved_pc_in_sigtramp, 
   hppa64_hpux_frame_base_before_sigtramp and
   hppa64_hpux_frame_find_saved_regs_in_sigtramp:

   These functions are the PA64 ABI equivalents of the 32bits counterparts
   above. See the comments there.

   For PA64, the save_state structure is at an offset of 24 32-bit words
   from the sigcontext structure. The 64 bit general registers are at an
   offset of 640 bytes from the beginning of the save_state structure,
   and the floating pointer register are at an offset of 256 bytes from
   the beginning of the save_state structure.  */

void
hppa64_hpux_frame_saved_pc_in_sigtramp (struct frame_info *fi, CORE_ADDR *tmp)
{
  *tmp = read_memory_integer
           (get_frame_base (fi) + (24 * 4) + 640 + (33 * 8), 8);
}

void
hppa64_hpux_frame_base_before_sigtramp (struct frame_info *fi,
                                        CORE_ADDR *tmp)
{
  *tmp = read_memory_integer
           (get_frame_base (fi) + (24 * 4) + 640 + (30 * 8), 8);
}

void
hppa64_hpux_frame_find_saved_regs_in_sigtramp (struct frame_info *fi,
					       CORE_ADDR *fsr)
{
  int i;
  const CORE_ADDR tmp1 = get_frame_base (fi) + (24 * 4) + 640;
  const CORE_ADDR tmp2 = get_frame_base (fi) + (24 * 4) + 256;

  for (i = 0; i < NUM_REGS; i++)
    {
      if (i == HPPA_SP_REGNUM)
        fsr[HPPA_SP_REGNUM] = read_memory_integer (tmp1 + HPPA_SP_REGNUM * 8, 8);
      else if (i >= HPPA_FP0_REGNUM)
        fsr[i] = tmp2 + (i - HPPA_FP0_REGNUM) * 8;
      else
        fsr[i] = tmp1 + i * 8;
    }
}

d1112 149
d1276 2
@


1.17
log
@2004-05-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_SIGTRAMP): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* shnbsd-tdep.c (shnbsd_init_abi): Do not set pc_in_sigtramp.
	(shnbsd_pc_in_sigtramp): Delete.
	* i386-interix-tdep.c (i386_interix_init_abi): Do not set
	pc_in_sigtramp.
	* hppa-hpux-tdep.c (hppa_hpux_init_abi): Do not set
	pc_in_sigtramp.
	* frame.h: Update comments.
	* ppc-linux-tdep.c: Update comments.
	* breakpoint.c (bpstat_what): Update comments.

Index: doc/ChangeLog
2004-05-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	description of DEPRECATED_PC_IN_SIGTRAMP.
@
text
@d113 2
a114 2
      if (i == SP_REGNUM)
	fsr[SP_REGNUM] = read_memory_integer (tmp + SP_REGNUM * 4, 4);
d158 4
a161 4
      if (i == SP_REGNUM)
        fsr[SP_REGNUM] = read_memory_integer (tmp1 + SP_REGNUM * 8, 8);
      else if (i >= FP0_REGNUM)
        fsr[i] = tmp2 + (i - FP0_REGNUM) * 8;
d1193 2
a1194 2
  event_kind = read_register (ARG0_REGNUM);
  catch_addr = read_register (ARG1_REGNUM);
@


1.16
log
@2004-04-22  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.h (find_unwind_entry, hppa_get_field, hppa_extract_5_load)
	(hppa_extract_5R_store, hppa_extract_5r_store, hppa_extract_17)
	(hppa_extract_21, hppa_extract_14, hppa_low_sign_extend)
	(hppa_sign_extend): Add prototype.
	* hppa-tdep.c (get_field, extract_5_load, extract_5R_store)
	(extract_5r_store, extract_17, extract_21, extract_14, low_sign_extend)
	(sign_extend): Rename with hppa_ prefix and make non-static.  Other
	hppa targets will also use these functions.
	(find_unwind_entry): Remove prototype (moved to hppa-tdep.h).
	(hppa_in_solib_call_trampoline, hppa_in_solib_return_trampoline)
	(hppa_skip_trampoline_code): Move to hppa-hpux-tdep.c
	(hppa_gdbarch_init): Remove gdbarch setting of
	skip_trampoline_code, in_solib_call_trampoline and
	in_solib_return_trampoline.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa64_hpux_in_solib_call_trampoline): New functions, split from
	hppa_in_solib_call_trampoline.
	(hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code):
	Moved from hppa-tdep.c.
 	(hppa_hpux_init_abi): Set gdbarch for skip_trampoline_code,
	in_solib_call_trampoline and in_solib_return_trampoline.
@
text
@a1229 2
  set_gdbarch_deprecated_pc_in_sigtramp (gdbarch, hppa_hpux_pc_in_sigtramp);

@


1.15
log
@2004-04-17  Randolph Chung  <tausq@@debian.org>

	* Makefile.in (hppa-hpux-tdep.o): Add $(hppa_tdep_h).
	* hppa-hpux-tdep.c (hppa-tdep.h): Include.
 	(hppa_hpux_som_init_abi): Set is_elf to 0.
 	(hppa_hpux_elf_init_abi): Set is_elf to 1.
	* hppa-tdep.c (low_text_segment_address): Remove global.
	(record_text_segment_lowaddr): Pass in low address as parameter. Use
	section offset to calculate segment address.
	(internalize_unwinds): Define low_text_segment_address as local and
	pass to record_text_segment_lowaddr for ELF targets.
	(hppa_gdbarch_init): Zero fill tdep structure.
	(hppa_dump_tdep): Print tdep structure.
	* hppa-tdep.h (gdbarch_tdep): Add is_elf member to tdep structure.
@
text
@d167 509
d1228 2
d1231 11
@


1.14
log
@2004-04-08  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.h (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Declare.
	* hppa-hpux-tdep.c (initialize_hp_cxx_exception_support)
	(initialize_hp_cxx_exception_support)
	(child_enable_exception_callback): Update.
	* breakpoint.c (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Rename
	deprecated_exception_catchpoints_are_fragile and
	deprecated_exception_support_initialized.
	(breakpoint_init_inferior, breakpoint_init_inferior): Update.

	* symtab.c (deprecated_hp_som_som_object_present): Rename
	hp_som_som_object_present.
	* symtab.h (deprecated_hp_som_som_object_present): Declare.
	* symfile.c (hp_som_som_object_present, RESET_HP_UX_GLOBALS):
	Update.  Delete extern declaration.
	* valops.c (hp_som_som_object_present): Ditto.
	* parse.c (deprecated_hp_som_som_object_present)
	(parse_nested_classes_for_hpacc): Ditto.
	* hpread.c (hp_som_som_object_present, hpread_expand_symtab): Ditto.
	* hppa-hpux-tdep.c (hp_som_som_object_present)
	(initialize_hp_cxx_exception_support): Ditto.
	* eval.c (hp_som_som_object_present, evaluate_subexp_standard): Ditto.
	* cp-valprint.c (hp_som_som_object_present)
	(cp_print_class_method): Ditto.
	* c-typeprint.c (hp_som_som_object_present):
	(c_type_print_base): Ditto.
	* c-exp.y (hp_som_som_object_present): Ditto.
@
text
@d31 1
d725 3
d734 3
@


1.13
log
@2004-04-06  Randolph Chung  <tausq@@debian.org>

	Committed by Andrew Cagney (mechanical change).
	* hppa-tdep.c: (args_for_find_stub, hp_som_som_object_present,
	exception_catchpoints_are_fragile, find_stub_with_shl_get,
	cover_find_stub_with_shl_get, initialize_hp_cxx_exception_support,
	child_enable_exception_callback, current_ex_event,
	null_symtab_and_line, child_get_current_exception_event,
	HP_ACC_EH_notify_hook, HP_ACC_EH_set_hook_value,
	HP_ACC_EH_notify_callback, HP_ACC_EH_break, HP_ACC_EH_catch_throw,
	HP_ACC_EH_catch_catch, __eh_notification, hp_cxx_exception_support,
	hp_cxx_exception_support_initialized, eh_notify_hook_addr,
	eh_notify_callback_addr, eh_break_addr, eh_catch_catch_addr,
	eh_catch_throw_addr, break_callback_sal, setup_d_pid_in_inferior):
	Move hpux-specific definitions ...
	* hppa-hpux-tdep.c: ... to here.
@
text
@a46 6
/* This is declared in symtab.c; set to 1 in hp-symtab-read.c */
extern int hp_som_som_object_present;

/* In breakpoint.c */
extern int exception_catchpoints_are_fragile;

a194 2
/* Similar to above, but imported from breakpoint.c -- non-target-specific */
extern int exception_support_initialized;
d369 1
a369 1
      exception_support_initialized = 0;
d380 1
a380 1
  if (!hp_som_som_object_present)
d464 1
a464 1
      exception_catchpoints_are_fragile = 1;
d476 1
a476 1
    exception_catchpoints_are_fragile = 0;
d551 1
a551 1
  exception_support_initialized = 1;
d570 2
a571 1
  if (!exception_support_initialized || !hp_cxx_exception_support_initialized)
@


1.12
log
@2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PC_IN_SIGTRAMP): Change to a function with
	predicate, deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-linux-tdep.c (alpha_linux_init_abi): Update.
	* alpha-osf1-tdep.c (alpha_osf1_init_abi): Update.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Update.
	* alphafbsd-tdep.c (alphafbsd_init_abi): Update.
	* alphanbsd-tdep.c (alphanbsd_init_abi): Update.
	* amd64-linux-tdep.c (amd64_linux_init_abi): Update.
	* amd64-tdep.c (amd64_sigtramp_frame_sniffer): Update.
	* amd64nbsd-tdep.c (amd64nbsd_init_abi): Update.
	* amd64obsd-tdep.c (amd64obsd_init_abi): Update.
	* arm-tdep.c (arm_sigtramp_unwind_sniffer): Update.
	* blockframe.c (find_pc_partial_function): Update.
	* breakpoint.c (bpstat_what): Update.
	* frame.c (frame_type_from_pc, legacy_get_prev_frame): Update.
	* frv-linux-tdep.c (frv_linux_init_abi): Update.
	* frv-tdep.c (frv_sigtramp_frame_sniffer): Update.
	* hppa-hpux-tdep.c (hppa_hpux_init_abi): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* i386-nto-tdep.c (i386nto_init_abi): Update.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Update.
	* i386-tdep.c (i386_sigtramp_frame_sniffer)
	(i386_svr4_init_abi, i386_go32_init_abi, i386_gdbarch_init): Update.
	* i386bsd-tdep.c (i386bsd_init_abi): Update.
	* i386nbsd-tdep.c (i386nbsd_init_abi): Update.
	* i386obsd-tdep.c (i386obsd_init_abi): Update.
	* ia64-tdep.c (ia64_sigtramp_frame_sniffer): Update.
	* infrun.c (pc_in_sigtramp): Update.
	* m68k-tdep.c (m68k_sigtramp_frame_sniffer): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mipsnbsd-tdep.c (mipsnbsd_init_abi): Update.
	* ppc-linux-tdep.c: Update comment.
	* ppcnbsd-tdep.c (ppcnbsd_init_abi): Update.
	* shnbsd-tdep.c (shnbsd_init_abi): Update.
	* sparc-linux-tdep.c (sparc32_linux_init_abi): Update.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_init_abi): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Update.
	* sparc64obsd-tdep.c (sparc64obsd_init_abi): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_init_abi): Update.
	* sparcobsd-tdep.c (sparc32obsd_init_abi): Update.

Index: doc/ChangeLog
2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	references to PC_IN_SIGTRAMP.
@
text
@d27 7
d39 14
d170 550
@


1.11
log
@        * hppa-hpux-tdep.c (_initialize_hppa_hpux_tdep): Remove a
        hard-coded constant. Use the proper machine name instead.
@
text
@d154 1
a154 1
  set_gdbarch_pc_in_sigtramp (gdbarch, hppa_hpux_pc_in_sigtramp);
@


1.11.8.1
log
@Merge mainline to intercu branch.
@
text
@d154 1
a154 1
  set_gdbarch_deprecated_pc_in_sigtramp (gdbarch, hppa_hpux_pc_in_sigtramp);
@


1.11.8.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a26 15
#include "frame-unwind.h"
#include "trad-frame.h"
#include "symtab.h"
#include "objfiles.h"
#include "inferior.h"
#include "infcall.h"
#include "observer.h"
#include "hppa-tdep.h"

#include <dl.h>
#include <machine/save_state.h>

#ifndef offsetof
#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
#endif
d32 15
a46 7
typedef struct
  {
    struct minimal_symbol *msym;
    CORE_ADDR solib_handle;
    CORE_ADDR return_val;
  }
args_for_find_stub;
a47 502
/* Return one if PC is in the call path of a trampoline, else return zero.

   Note we return one for *any* call trampoline (long-call, arg-reloc), not
   just shared library trampolines (import, export).  */

static int
hppa32_hpux_in_solib_call_trampoline (CORE_ADDR pc, char *name)
{
  struct minimal_symbol *minsym;
  struct unwind_table_entry *u;

  /* First see if PC is in one of the two C-library trampolines.  */
  if (pc == hppa_symbol_address("$$dyncall") 
      || pc == hppa_symbol_address("_sr4export"))
    return 1;

  minsym = lookup_minimal_symbol_by_pc (pc);
  if (minsym && strcmp (DEPRECATED_SYMBOL_NAME (minsym), ".stub") == 0)
    return 1;

  /* Get the unwind descriptor corresponding to PC, return zero
     if no unwind was found.  */
  u = find_unwind_entry (pc);
  if (!u)
    return 0;

  /* If this isn't a linker stub, then return now.  */
  if (u->stub_unwind.stub_type == 0)
    return 0;

  /* By definition a long-branch stub is a call stub.  */
  if (u->stub_unwind.stub_type == LONG_BRANCH)
    return 1;

  /* The call and return path execute the same instructions within
     an IMPORT stub!  So an IMPORT stub is both a call and return
     trampoline.  */
  if (u->stub_unwind.stub_type == IMPORT)
    return 1;

  /* Parameter relocation stubs always have a call path and may have a
     return path.  */
  if (u->stub_unwind.stub_type == PARAMETER_RELOCATION
      || u->stub_unwind.stub_type == EXPORT)
    {
      CORE_ADDR addr;

      /* Search forward from the current PC until we hit a branch
         or the end of the stub.  */
      for (addr = pc; addr <= u->region_end; addr += 4)
	{
	  unsigned long insn;

	  insn = read_memory_integer (addr, 4);

	  /* Does it look like a bl?  If so then it's the call path, if
	     we find a bv or be first, then we're on the return path.  */
	  if ((insn & 0xfc00e000) == 0xe8000000)
	    return 1;
	  else if ((insn & 0xfc00e001) == 0xe800c000
		   || (insn & 0xfc000000) == 0xe0000000)
	    return 0;
	}

      /* Should never happen.  */
      warning ("Unable to find branch in parameter relocation stub.\n");
      return 0;
    }

  /* Unknown stub type.  For now, just return zero.  */
  return 0;
}

static int
hppa64_hpux_in_solib_call_trampoline (CORE_ADDR pc, char *name)
{
  /* PA64 has a completely different stub/trampoline scheme.  Is it
     better?  Maybe.  It's certainly harder to determine with any
     certainty that we are in a stub because we can not refer to the
     unwinders to help. 

     The heuristic is simple.  Try to lookup the current PC value in th
     minimal symbol table.  If that fails, then assume we are not in a
     stub and return.

     Then see if the PC value falls within the section bounds for the
     section containing the minimal symbol we found in the first
     step.  If it does, then assume we are not in a stub and return.

     Finally peek at the instructions to see if they look like a stub.  */
  struct minimal_symbol *minsym;
  asection *sec;
  CORE_ADDR addr;
  int insn, i;

  minsym = lookup_minimal_symbol_by_pc (pc);
  if (! minsym)
    return 0;

  sec = SYMBOL_BFD_SECTION (minsym);

  if (bfd_get_section_vma (sec->owner, sec) <= pc
      && pc < (bfd_get_section_vma (sec->owner, sec)
		 + bfd_section_size (sec->owner, sec)))
      return 0;

  /* We might be in a stub.  Peek at the instructions.  Stubs are 3
     instructions long. */
  insn = read_memory_integer (pc, 4);

  /* Find out where we think we are within the stub.  */
  if ((insn & 0xffffc00e) == 0x53610000)
    addr = pc;
  else if ((insn & 0xffffffff) == 0xe820d000)
    addr = pc - 4;
  else if ((insn & 0xffffc00e) == 0x537b0000)
    addr = pc - 8;
  else
    return 0;

  /* Now verify each insn in the range looks like a stub instruction.  */
  insn = read_memory_integer (addr, 4);
  if ((insn & 0xffffc00e) != 0x53610000)
    return 0;
	
  /* Now verify each insn in the range looks like a stub instruction.  */
  insn = read_memory_integer (addr + 4, 4);
  if ((insn & 0xffffffff) != 0xe820d000)
    return 0;
    
  /* Now verify each insn in the range looks like a stub instruction.  */
  insn = read_memory_integer (addr + 8, 4);
  if ((insn & 0xffffc00e) != 0x537b0000)
    return 0;

  /* Looks like a stub.  */
  return 1;
}

/* Return one if PC is in the return path of a trampoline, else return zero.

   Note we return one for *any* call trampoline (long-call, arg-reloc), not
   just shared library trampolines (import, export).  */

static int
hppa_hpux_in_solib_return_trampoline (CORE_ADDR pc, char *name)
{
  struct unwind_table_entry *u;

  /* Get the unwind descriptor corresponding to PC, return zero
     if no unwind was found.  */
  u = find_unwind_entry (pc);
  if (!u)
    return 0;

  /* If this isn't a linker stub or it's just a long branch stub, then
     return zero.  */
  if (u->stub_unwind.stub_type == 0 || u->stub_unwind.stub_type == LONG_BRANCH)
    return 0;

  /* The call and return path execute the same instructions within
     an IMPORT stub!  So an IMPORT stub is both a call and return
     trampoline.  */
  if (u->stub_unwind.stub_type == IMPORT)
    return 1;

  /* Parameter relocation stubs always have a call path and may have a
     return path.  */
  if (u->stub_unwind.stub_type == PARAMETER_RELOCATION
      || u->stub_unwind.stub_type == EXPORT)
    {
      CORE_ADDR addr;

      /* Search forward from the current PC until we hit a branch
         or the end of the stub.  */
      for (addr = pc; addr <= u->region_end; addr += 4)
	{
	  unsigned long insn;

	  insn = read_memory_integer (addr, 4);

	  /* Does it look like a bl?  If so then it's the call path, if
	     we find a bv or be first, then we're on the return path.  */
	  if ((insn & 0xfc00e000) == 0xe8000000)
	    return 0;
	  else if ((insn & 0xfc00e001) == 0xe800c000
		   || (insn & 0xfc000000) == 0xe0000000)
	    return 1;
	}

      /* Should never happen.  */
      warning ("Unable to find branch in parameter relocation stub.\n");
      return 0;
    }

  /* Unknown stub type.  For now, just return zero.  */
  return 0;

}

/* Figure out if PC is in a trampoline, and if so find out where
   the trampoline will jump to.  If not in a trampoline, return zero.

   Simple code examination probably is not a good idea since the code
   sequences in trampolines can also appear in user code.

   We use unwinds and information from the minimal symbol table to
   determine when we're in a trampoline.  This won't work for ELF
   (yet) since it doesn't create stub unwind entries.  Whether or
   not ELF will create stub unwinds or normal unwinds for linker
   stubs is still being debated.

   This should handle simple calls through dyncall or sr4export,
   long calls, argument relocation stubs, and dyncall/sr4export
   calling an argument relocation stub.  It even handles some stubs
   used in dynamic executables.  */

static CORE_ADDR
hppa_hpux_skip_trampoline_code (CORE_ADDR pc)
{
  long orig_pc = pc;
  long prev_inst, curr_inst, loc;
  struct minimal_symbol *msym;
  struct unwind_table_entry *u;

  /* Addresses passed to dyncall may *NOT* be the actual address
     of the function.  So we may have to do something special.  */
  if (pc == hppa_symbol_address("$$dyncall"))
    {
      pc = (CORE_ADDR) read_register (22);

      /* If bit 30 (counting from the left) is on, then pc is the address of
         the PLT entry for this function, not the address of the function
         itself.  Bit 31 has meaning too, but only for MPE.  */
      if (pc & 0x2)
	pc = (CORE_ADDR) read_memory_integer (pc & ~0x3, TARGET_PTR_BIT / 8);
    }
  if (pc == hppa_symbol_address("$$dyncall_external"))
    {
      pc = (CORE_ADDR) read_register (22);
      pc = (CORE_ADDR) read_memory_integer (pc & ~0x3, TARGET_PTR_BIT / 8);
    }
  else if (pc == hppa_symbol_address("_sr4export"))
    pc = (CORE_ADDR) (read_register (22));

  /* Get the unwind descriptor corresponding to PC, return zero
     if no unwind was found.  */
  u = find_unwind_entry (pc);
  if (!u)
    return 0;

  /* If this isn't a linker stub, then return now.  */
  /* elz: attention here! (FIXME) because of a compiler/linker 
     error, some stubs which should have a non zero stub_unwind.stub_type 
     have unfortunately a value of zero. So this function would return here
     as if we were not in a trampoline. To fix this, we go look at the partial
     symbol information, which reports this guy as a stub.
     (FIXME): Unfortunately, we are not that lucky: it turns out that the 
     partial symbol information is also wrong sometimes. This is because 
     when it is entered (somread.c::som_symtab_read()) it can happen that
     if the type of the symbol (from the som) is Entry, and the symbol is
     in a shared library, then it can also be a trampoline.  This would
     be OK, except that I believe the way they decide if we are ina shared library
     does not work. SOOOO..., even if we have a regular function w/o trampolines
     its minimal symbol can be assigned type mst_solib_trampoline.
     Also, if we find that the symbol is a real stub, then we fix the unwind
     descriptor, and define the stub type to be EXPORT.
     Hopefully this is correct most of the times. */
  if (u->stub_unwind.stub_type == 0)
    {

/* elz: NOTE (FIXME!) once the problem with the unwind information is fixed
   we can delete all the code which appears between the lines */
/*--------------------------------------------------------------------------*/
      msym = lookup_minimal_symbol_by_pc (pc);

      if (msym == NULL || MSYMBOL_TYPE (msym) != mst_solib_trampoline)
	return orig_pc == pc ? 0 : pc & ~0x3;

      else if (msym != NULL && MSYMBOL_TYPE (msym) == mst_solib_trampoline)
	{
	  struct objfile *objfile;
	  struct minimal_symbol *msymbol;
	  int function_found = 0;

	  /* go look if there is another minimal symbol with the same name as 
	     this one, but with type mst_text. This would happen if the msym
	     is an actual trampoline, in which case there would be another
	     symbol with the same name corresponding to the real function */

	  ALL_MSYMBOLS (objfile, msymbol)
	  {
	    if (MSYMBOL_TYPE (msymbol) == mst_text
		&& DEPRECATED_STREQ (DEPRECATED_SYMBOL_NAME (msymbol), DEPRECATED_SYMBOL_NAME (msym)))
	      {
		function_found = 1;
		break;
	      }
	  }

	  if (function_found)
	    /* the type of msym is correct (mst_solib_trampoline), but
	       the unwind info is wrong, so set it to the correct value */
	    u->stub_unwind.stub_type = EXPORT;
	  else
	    /* the stub type info in the unwind is correct (this is not a
	       trampoline), but the msym type information is wrong, it
	       should be mst_text. So we need to fix the msym, and also
	       get out of this function */
	    {
	      MSYMBOL_TYPE (msym) = mst_text;
	      return orig_pc == pc ? 0 : pc & ~0x3;
	    }
	}

/*--------------------------------------------------------------------------*/
    }

  /* It's a stub.  Search for a branch and figure out where it goes.
     Note we have to handle multi insn branch sequences like ldil;ble.
     Most (all?) other branches can be determined by examining the contents
     of certain registers and the stack.  */

  loc = pc;
  curr_inst = 0;
  prev_inst = 0;
  while (1)
    {
      /* Make sure we haven't walked outside the range of this stub.  */
      if (u != find_unwind_entry (loc))
	{
	  warning ("Unable to find branch in linker stub");
	  return orig_pc == pc ? 0 : pc & ~0x3;
	}

      prev_inst = curr_inst;
      curr_inst = read_memory_integer (loc, 4);

      /* Does it look like a branch external using %r1?  Then it's the
         branch from the stub to the actual function.  */
      if ((curr_inst & 0xffe0e000) == 0xe0202000)
	{
	  /* Yup.  See if the previous instruction loaded
	     a value into %r1.  If so compute and return the jump address.  */
	  if ((prev_inst & 0xffe00000) == 0x20200000)
	    return (hppa_extract_21 (prev_inst) + hppa_extract_17 (curr_inst)) & ~0x3;
	  else
	    {
	      warning ("Unable to find ldil X,%%r1 before ble Y(%%sr4,%%r1).");
	      return orig_pc == pc ? 0 : pc & ~0x3;
	    }
	}

      /* Does it look like a be 0(sr0,%r21)? OR 
         Does it look like a be, n 0(sr0,%r21)? OR 
         Does it look like a bve (r21)? (this is on PA2.0)
         Does it look like a bve, n(r21)? (this is also on PA2.0)
         That's the branch from an
         import stub to an export stub.

         It is impossible to determine the target of the branch via
         simple examination of instructions and/or data (consider
         that the address in the plabel may be the address of the
         bind-on-reference routine in the dynamic loader).

         So we have try an alternative approach.

         Get the name of the symbol at our current location; it should
         be a stub symbol with the same name as the symbol in the
         shared library.

         Then lookup a minimal symbol with the same name; we should
         get the minimal symbol for the target routine in the shared
         library as those take precedence of import/export stubs.  */
      if ((curr_inst == 0xe2a00000) ||
	  (curr_inst == 0xe2a00002) ||
	  (curr_inst == 0xeaa0d000) ||
	  (curr_inst == 0xeaa0d002))
	{
	  struct minimal_symbol *stubsym, *libsym;

	  stubsym = lookup_minimal_symbol_by_pc (loc);
	  if (stubsym == NULL)
	    {
	      warning ("Unable to find symbol for 0x%lx", loc);
	      return orig_pc == pc ? 0 : pc & ~0x3;
	    }

	  libsym = lookup_minimal_symbol (DEPRECATED_SYMBOL_NAME (stubsym), NULL, NULL);
	  if (libsym == NULL)
	    {
	      warning ("Unable to find library symbol for %s\n",
		       DEPRECATED_SYMBOL_NAME (stubsym));
	      return orig_pc == pc ? 0 : pc & ~0x3;
	    }

	  return SYMBOL_VALUE (libsym);
	}

      /* Does it look like bl X,%rp or bl X,%r0?  Another way to do a
         branch from the stub to the actual function.  */
      /*elz */
      else if ((curr_inst & 0xffe0e000) == 0xe8400000
	       || (curr_inst & 0xffe0e000) == 0xe8000000
	       || (curr_inst & 0xffe0e000) == 0xe800A000)
	return (loc + hppa_extract_17 (curr_inst) + 8) & ~0x3;

      /* Does it look like bv (rp)?   Note this depends on the
         current stack pointer being the same as the stack
         pointer in the stub itself!  This is a branch on from the
         stub back to the original caller.  */
      /*else if ((curr_inst & 0xffe0e000) == 0xe840c000) */
      else if ((curr_inst & 0xffe0f000) == 0xe840c000)
	{
	  /* Yup.  See if the previous instruction loaded
	     rp from sp - 8.  */
	  if (prev_inst == 0x4bc23ff1)
	    return (read_memory_integer
		    (read_register (HPPA_SP_REGNUM) - 8, 4)) & ~0x3;
	  else
	    {
	      warning ("Unable to find restore of %%rp before bv (%%rp).");
	      return orig_pc == pc ? 0 : pc & ~0x3;
	    }
	}

      /* elz: added this case to capture the new instruction
         at the end of the return part of an export stub used by
         the PA2.0: BVE, n (rp) */
      else if ((curr_inst & 0xffe0f000) == 0xe840d000)
	{
	  return (read_memory_integer
		  (read_register (HPPA_SP_REGNUM) - 24, TARGET_PTR_BIT / 8)) & ~0x3;
	}

      /* What about be,n 0(sr0,%rp)?  It's just another way we return to
         the original caller from the stub.  Used in dynamic executables.  */
      else if (curr_inst == 0xe0400002)
	{
	  /* The value we jump to is sitting in sp - 24.  But that's
	     loaded several instructions before the be instruction.
	     I guess we could check for the previous instruction being
	     mtsp %r1,%sr0 if we want to do sanity checking.  */
	  return (read_memory_integer
		  (read_register (HPPA_SP_REGNUM) - 24, TARGET_PTR_BIT / 8)) & ~0x3;
	}

      /* Haven't found the branch yet, but we're still in the stub.
         Keep looking.  */
      loc += 4;
    }
}


/* Exception handling support for the HP-UX ANSI C++ compiler.
   The compiler (aCC) provides a callback for exception events;
   GDB can set a breakpoint on this callback and find out what
   exception event has occurred. */

/* The name of the hook to be set to point to the callback function */
static char HP_ACC_EH_notify_hook[] = "__eh_notify_hook";
/* The name of the function to be used to set the hook value */
static char HP_ACC_EH_set_hook_value[] = "__eh_set_hook_value";
/* The name of the callback function in end.o */
static char HP_ACC_EH_notify_callback[] = "__d_eh_notify_callback";
/* Name of function in end.o on which a break is set (called by above) */
static char HP_ACC_EH_break[] = "__d_eh_break";
/* Name of flag (in end.o) that enables catching throws */
static char HP_ACC_EH_catch_throw[] = "__d_eh_catch_throw";
/* Name of flag (in end.o) that enables catching catching */
static char HP_ACC_EH_catch_catch[] = "__d_eh_catch_catch";
/* The enum used by aCC */
typedef enum
  {
    __EH_NOTIFY_THROW,
    __EH_NOTIFY_CATCH
  }
__eh_notification;

/* Is exception-handling support available with this executable? */
static int hp_cxx_exception_support = 0;
/* Has the initialize function been run? */
static int hp_cxx_exception_support_initialized = 0;
/* Address of __eh_notify_hook */
static CORE_ADDR eh_notify_hook_addr = 0;
/* Address of __d_eh_notify_callback */
static CORE_ADDR eh_notify_callback_addr = 0;
/* Address of __d_eh_break */
static CORE_ADDR eh_break_addr = 0;
/* Address of __d_eh_catch_catch */
static CORE_ADDR eh_catch_catch_addr = 0;
/* Address of __d_eh_catch_throw */
static CORE_ADDR eh_catch_throw_addr = 0;
/* Sal for __d_eh_break */
static struct symtab_and_line *break_callback_sal = 0;

/* Code in end.c expects __d_pid to be set in the inferior,
   otherwise __d_eh_notify_callback doesn't bother to call
   __d_eh_break!  So we poke the pid into this symbol
   ourselves.
   0 => success
   1 => failure  */
d49 1
a49 1
setup_d_pid_in_inferior (void)
d51 23
a73 12
  CORE_ADDR anaddr;
  struct minimal_symbol *msymbol;
  char buf[4];			/* FIXME 32x64? */

  /* Slam the pid of the process into __d_pid; failing is only a warning!  */
  msymbol = lookup_minimal_symbol ("__d_pid", NULL, symfile_objfile);
  if (msymbol == NULL)
    {
      warning ("Unable to find __d_pid symbol in object file.");
      warning ("Suggest linking executable with -g (links in /opt/langtools/lib/end.o).");
      return 1;
    }
d75 2
a76 32
  anaddr = SYMBOL_VALUE_ADDRESS (msymbol);
  store_unsigned_integer (buf, 4, PIDGET (inferior_ptid)); /* FIXME 32x64? */
  if (target_write_memory (anaddr, buf, 4))	/* FIXME 32x64? */
    {
      warning ("Unable to write __d_pid");
      warning ("Suggest linking executable with -g (links in /opt/langtools/lib/end.o).");
      return 1;
    }
  return 0;
}

/* elz: Used to lookup a symbol in the shared libraries.
   This function calls shl_findsym, indirectly through a
   call to __d_shl_get. __d_shl_get is in end.c, which is always
   linked in by the hp compilers/linkers. 
   The call to shl_findsym cannot be made directly because it needs
   to be active in target address space. 
   inputs: - minimal symbol pointer for the function we want to look up
   - address in target space of the descriptor for the library
   where we want to look the symbol up.
   This address is retrieved using the 
   som_solib_get_solib_by_pc function (somsolib.c). 
   output: - real address in the library of the function.          
   note: the handle can be null, in which case shl_findsym will look for
   the symbol in all the loaded shared libraries.
   files to look at if you need reference on this stuff:
   dld.c, dld_shl_findsym.c
   end.c
   man entry for shl_findsym */

CORE_ADDR
find_stub_with_shl_get (struct minimal_symbol *function, CORE_ADDR handle)
d78 1
a78 63
  struct symbol *get_sym, *symbol2;
  struct minimal_symbol *buff_minsym, *msymbol;
  struct type *ftype;
  struct value **args;
  struct value *funcval;
  struct value *val;

  int x, namelen, err_value, tmp = -1;
  CORE_ADDR endo_buff_addr, value_return_addr, errno_return_addr;
  CORE_ADDR stub_addr;


  args = alloca (sizeof (struct value *) * 8);		/* 6 for the arguments and one null one??? */
  funcval = find_function_in_inferior ("__d_shl_get");
  get_sym = lookup_symbol ("__d_shl_get", NULL, VAR_DOMAIN, NULL, NULL);
  buff_minsym = lookup_minimal_symbol ("__buffer", NULL, NULL);
  msymbol = lookup_minimal_symbol ("__shldp", NULL, NULL);
  symbol2 = lookup_symbol ("__shldp", NULL, VAR_DOMAIN, NULL, NULL);
  endo_buff_addr = SYMBOL_VALUE_ADDRESS (buff_minsym);
  namelen = strlen (DEPRECATED_SYMBOL_NAME (function));
  value_return_addr = endo_buff_addr + namelen;
  ftype = check_typedef (SYMBOL_TYPE (get_sym));

  /* do alignment */
  if ((x = value_return_addr % 64) != 0)
    value_return_addr = value_return_addr + 64 - x;

  errno_return_addr = value_return_addr + 64;


  /* set up stuff needed by __d_shl_get in buffer in end.o */

  target_write_memory (endo_buff_addr, DEPRECATED_SYMBOL_NAME (function), namelen);

  target_write_memory (value_return_addr, (char *) &tmp, 4);

  target_write_memory (errno_return_addr, (char *) &tmp, 4);

  target_write_memory (SYMBOL_VALUE_ADDRESS (msymbol),
		       (char *) &handle, 4);

  /* now prepare the arguments for the call */

  args[0] = value_from_longest (TYPE_FIELD_TYPE (ftype, 0), 12);
  args[1] = value_from_pointer (TYPE_FIELD_TYPE (ftype, 1), SYMBOL_VALUE_ADDRESS (msymbol));
  args[2] = value_from_pointer (TYPE_FIELD_TYPE (ftype, 2), endo_buff_addr);
  args[3] = value_from_longest (TYPE_FIELD_TYPE (ftype, 3), TYPE_PROCEDURE);
  args[4] = value_from_pointer (TYPE_FIELD_TYPE (ftype, 4), value_return_addr);
  args[5] = value_from_pointer (TYPE_FIELD_TYPE (ftype, 5), errno_return_addr);

  /* now call the function */

  val = call_function_by_hand (funcval, 6, args);

  /* now get the results */

  target_read_memory (errno_return_addr, (char *) &err_value, sizeof (err_value));

  target_read_memory (value_return_addr, (char *) &stub_addr, sizeof (stub_addr));
  if (stub_addr <= 0)
    error ("call to __d_shl_get failed, error code is %d", err_value);

  return (stub_addr);
d81 3
a83 3
/* Cover routine for find_stub_with_shl_get to pass to catch_errors */
static int
cover_find_stub_with_shl_get (void *args_untyped)
d85 1
a85 3
  args_for_find_stub *args = args_untyped;
  args->return_val = find_stub_with_shl_get (args->msym, args->solib_handle);
  return 0;
d88 3
a90 9
/* Initialize exception catchpoint support by looking for the
   necessary hooks/callbacks in end.o, etc., and set the hook value to
   point to the required debug function

   Return 0 => failure
   1 => success          */

static int
initialize_hp_cxx_exception_support (void)
a91 3
  struct symtabs_and_lines sals;
  struct cleanup *old_chain;
  struct cleanup *canonical_strings_chain = NULL;
d93 1
a93 23
  char *addr_start;
  char *addr_end = NULL;
  char **canonical = (char **) NULL;
  int thread = -1;
  struct symbol *sym = NULL;
  struct minimal_symbol *msym = NULL;
  struct objfile *objfile;
  asection *shlib_info;

  /* Detect and disallow recursion.  On HP-UX with aCC, infinite
     recursion is a possibility because finding the hook for exception
     callbacks involves making a call in the inferior, which means
     re-inserting breakpoints which can re-invoke this code */

  static int recurse = 0;
  if (recurse > 0)
    {
      hp_cxx_exception_support_initialized = 0;
      deprecated_exception_support_initialized = 0;
      return 0;
    }

  hp_cxx_exception_support = 0;
d95 1
a95 32
  /* First check if we have seen any HP compiled objects; if not,
     it is very unlikely that HP's idiosyncratic callback mechanism
     for exception handling debug support will be available!
     This will percolate back up to breakpoint.c, where our callers
     will decide to try the g++ exception-handling support instead. */
  if (!deprecated_hp_som_som_object_present)
    return 0;

  /* We have a SOM executable with SOM debug info; find the hooks */

  /* First look for the notify hook provided by aCC runtime libs */
  /* If we find this symbol, we conclude that the executable must
     have HP aCC exception support built in.  If this symbol is not
     found, even though we're a HP SOM-SOM file, we may have been
     built with some other compiler (not aCC).  This results percolates
     back up to our callers in breakpoint.c which can decide to
     try the g++ style of exception support instead.
     If this symbol is found but the other symbols we require are
     not found, there is something weird going on, and g++ support
     should *not* be tried as an alternative.

     ASSUMPTION: Only HP aCC code will have __eh_notify_hook defined.  
     ASSUMPTION: HP aCC and g++ modules cannot be linked together. */

  /* libCsup has this hook; it'll usually be non-debuggable */
  msym = lookup_minimal_symbol (HP_ACC_EH_notify_hook, NULL, NULL);
  if (msym)
    {
      eh_notify_hook_addr = SYMBOL_VALUE_ADDRESS (msym);
      hp_cxx_exception_support = 1;
    }
  else
d97 2
a98 131
      warning ("Unable to find exception callback hook (%s).", HP_ACC_EH_notify_hook);
      warning ("Executable may not have been compiled debuggable with HP aCC.");
      warning ("GDB will be unable to intercept exception events.");
      eh_notify_hook_addr = 0;
      hp_cxx_exception_support = 0;
      return 0;
    }

  /* Next look for the notify callback routine in end.o */
  /* This is always available in the SOM symbol dictionary if end.o is linked in */
  msym = lookup_minimal_symbol (HP_ACC_EH_notify_callback, NULL, NULL);
  if (msym)
    {
      eh_notify_callback_addr = SYMBOL_VALUE_ADDRESS (msym);
      hp_cxx_exception_support = 1;
    }
  else
    {
      warning ("Unable to find exception callback routine (%s).", HP_ACC_EH_notify_callback);
      warning ("Suggest linking executable with -g (links in /opt/langtools/lib/end.o).");
      warning ("GDB will be unable to intercept exception events.");
      eh_notify_callback_addr = 0;
      return 0;
    }

#ifndef GDB_TARGET_IS_HPPA_20W
  /* Check whether the executable is dynamically linked or archive bound */
  /* With an archive-bound executable we can use the raw addresses we find
     for the callback function, etc. without modification. For an executable
     with shared libraries, we have to do more work to find the plabel, which
     can be the target of a call through $$dyncall from the aCC runtime support
     library (libCsup) which is linked shared by default by aCC. */
  /* This test below was copied from somsolib.c/somread.c.  It may not be a very
     reliable one to test that an executable is linked shared. pai/1997-07-18 */
  shlib_info = bfd_get_section_by_name (symfile_objfile->obfd, "$SHLIB_INFO$");
  if (shlib_info && (bfd_section_size (symfile_objfile->obfd, shlib_info) != 0))
    {
      /* The minsym we have has the local code address, but that's not the
         plabel that can be used by an inter-load-module call. */
      /* Find solib handle for main image (which has end.o), and use that
         and the min sym as arguments to __d_shl_get() (which does the equivalent
         of shl_findsym()) to find the plabel. */

      args_for_find_stub args;
      static char message[] = "Error while finding exception callback hook:\n";

      args.solib_handle = som_solib_get_solib_by_pc (eh_notify_callback_addr);
      args.msym = msym;
      args.return_val = 0;

      recurse++;
      catch_errors (cover_find_stub_with_shl_get, &args, message,
		    RETURN_MASK_ALL);
      eh_notify_callback_addr = args.return_val;
      recurse--;

      deprecated_exception_catchpoints_are_fragile = 1;

      if (!eh_notify_callback_addr)
	{
	  /* We can get here either if there is no plabel in the export list
	     for the main image, or if something strange happened (?) */
	  warning ("Couldn't find a plabel (indirect function label) for the exception callback.");
	  warning ("GDB will not be able to intercept exception events.");
	  return 0;
	}
    }
  else
    deprecated_exception_catchpoints_are_fragile = 0;
#endif

  /* Now, look for the breakpointable routine in end.o */
  /* This should also be available in the SOM symbol dict. if end.o linked in */
  msym = lookup_minimal_symbol (HP_ACC_EH_break, NULL, NULL);
  if (msym)
    {
      eh_break_addr = SYMBOL_VALUE_ADDRESS (msym);
      hp_cxx_exception_support = 1;
    }
  else
    {
      warning ("Unable to find exception callback routine to set breakpoint (%s).", HP_ACC_EH_break);
      warning ("Suggest linking executable with -g (link in /opt/langtools/lib/end.o).");
      warning ("GDB will be unable to intercept exception events.");
      eh_break_addr = 0;
      return 0;
    }

  /* Next look for the catch enable flag provided in end.o */
  sym = lookup_symbol (HP_ACC_EH_catch_catch, (struct block *) NULL,
		       VAR_DOMAIN, 0, (struct symtab **) NULL);
  if (sym)			/* sometimes present in debug info */
    {
      eh_catch_catch_addr = SYMBOL_VALUE_ADDRESS (sym);
      hp_cxx_exception_support = 1;
    }
  else
    /* otherwise look in SOM symbol dict. */
    {
      msym = lookup_minimal_symbol (HP_ACC_EH_catch_catch, NULL, NULL);
      if (msym)
	{
	  eh_catch_catch_addr = SYMBOL_VALUE_ADDRESS (msym);
	  hp_cxx_exception_support = 1;
	}
      else
	{
	  warning ("Unable to enable interception of exception catches.");
	  warning ("Executable may not have been compiled debuggable with HP aCC.");
	  warning ("Suggest linking executable with -g (link in /opt/langtools/lib/end.o).");
	  return 0;
	}
    }

  /* Next look for the catch enable flag provided end.o */
  sym = lookup_symbol (HP_ACC_EH_catch_catch, (struct block *) NULL,
		       VAR_DOMAIN, 0, (struct symtab **) NULL);
  if (sym)			/* sometimes present in debug info */
    {
      eh_catch_throw_addr = SYMBOL_VALUE_ADDRESS (sym);
      hp_cxx_exception_support = 1;
    }
  else
    /* otherwise look in SOM symbol dict. */
    {
      msym = lookup_minimal_symbol (HP_ACC_EH_catch_throw, NULL, NULL);
      if (msym)
	{
	  eh_catch_throw_addr = SYMBOL_VALUE_ADDRESS (msym);
	  hp_cxx_exception_support = 1;
	}
d100 1
a100 6
	{
	  warning ("Unable to enable interception of exception throws.");
	  warning ("Executable may not have been compiled debuggable with HP aCC.");
	  warning ("Suggest linking executable with -g (link in /opt/langtools/lib/end.o).");
	  return 0;
	}
a101 7

  /* Set the flags */
  hp_cxx_exception_support = 2;	/* everything worked so far */
  hp_cxx_exception_support_initialized = 1;
  deprecated_exception_support_initialized = 1;

  return 1;
d104 3
a106 8
/* Target operation for enabling or disabling interception of
   exception events.
   KIND is either EX_EVENT_THROW or EX_EVENT_CATCH
   ENABLE is either 0 (disable) or 1 (enable).
   Return value is NULL if no support found;
   -1 if something went wrong,
   or a pointer to a symtab/line struct if the breakpointable
   address was found. */
d108 2
a109 4
struct symtab_and_line *
child_enable_exception_callback (enum exception_event_kind kind, int enable)
{
  char buf[4];
d111 5
a115 4
  if (!deprecated_exception_support_initialized
      || !hp_cxx_exception_support_initialized)
    if (!initialize_hp_cxx_exception_support ())
      return NULL;
d117 2
a118 83
  switch (hp_cxx_exception_support)
    {
    case 0:
      /* Assuming no HP support at all */
      return NULL;
    case 1:
      /* HP support should be present, but something went wrong */
      return (struct symtab_and_line *) -1;	/* yuck! */
      /* there may be other cases in the future */
    }

  /* Set the EH hook to point to the callback routine */
  store_unsigned_integer (buf, 4, enable ? eh_notify_callback_addr : 0);	/* FIXME 32x64 problem */
  /* pai: (temp) FIXME should there be a pack operation first? */
  if (target_write_memory (eh_notify_hook_addr, buf, 4))	/* FIXME 32x64 problem */
    {
      warning ("Could not write to target memory for exception event callback.");
      warning ("Interception of exception events may not work.");
      return (struct symtab_and_line *) -1;
    }
  if (enable)
    {
      /* Ensure that __d_pid is set up correctly -- end.c code checks this. :-( */
      if (PIDGET (inferior_ptid) > 0)
	{
	  if (setup_d_pid_in_inferior ())
	    return (struct symtab_and_line *) -1;
	}
      else
	{
	  warning ("Internal error: Invalid inferior pid?  Cannot intercept exception events.");
	  return (struct symtab_and_line *) -1;
	}
    }

  switch (kind)
    {
    case EX_EVENT_THROW:
      store_unsigned_integer (buf, 4, enable ? 1 : 0);
      if (target_write_memory (eh_catch_throw_addr, buf, 4))	/* FIXME 32x64? */
	{
	  warning ("Couldn't enable exception throw interception.");
	  return (struct symtab_and_line *) -1;
	}
      break;
    case EX_EVENT_CATCH:
      store_unsigned_integer (buf, 4, enable ? 1 : 0);
      if (target_write_memory (eh_catch_catch_addr, buf, 4))	/* FIXME 32x64? */
	{
	  warning ("Couldn't enable exception catch interception.");
	  return (struct symtab_and_line *) -1;
	}
      break;
    default:
      error ("Request to enable unknown or unsupported exception event.");
    }

  /* Copy break address into new sal struct, malloc'ing if needed. */
  if (!break_callback_sal)
    {
      break_callback_sal = (struct symtab_and_line *) xmalloc (sizeof (struct symtab_and_line));
    }
  init_sal (break_callback_sal);
  break_callback_sal->symtab = NULL;
  break_callback_sal->pc = eh_break_addr;
  break_callback_sal->line = 0;
  break_callback_sal->end = eh_break_addr;

  return break_callback_sal;
}

/* Record some information about the current exception event */
static struct exception_event_record current_ex_event;
/* Convenience struct */
static struct symtab_and_line null_symtab_and_line =
{NULL, 0, 0, 0};

/* Report current exception event.  Returns a pointer to a record
   that describes the kind of the event, where it was thrown from,
   and where it will be caught.  More information may be reported
   in the future */
struct exception_event_record *
child_get_current_exception_event (void)
d120 2
a121 54
  CORE_ADDR event_kind;
  CORE_ADDR throw_addr;
  CORE_ADDR catch_addr;
  struct frame_info *fi, *curr_frame;
  int level = 1;

  curr_frame = get_current_frame ();
  if (!curr_frame)
    return (struct exception_event_record *) NULL;

  /* Go up one frame to __d_eh_notify_callback, because at the
     point when this code is executed, there's garbage in the
     arguments of __d_eh_break. */
  fi = find_relative_frame (curr_frame, &level);
  if (level != 0)
    return (struct exception_event_record *) NULL;

  select_frame (fi);

  /* Read in the arguments */
  /* __d_eh_notify_callback() is called with 3 arguments:
     1. event kind catch or throw
     2. the target address if known
     3. a flag -- not sure what this is. pai/1997-07-17 */
  event_kind = read_register (HPPA_ARG0_REGNUM);
  catch_addr = read_register (HPPA_ARG1_REGNUM);

  /* Now go down to a user frame */
  /* For a throw, __d_eh_break is called by
     __d_eh_notify_callback which is called by
     __notify_throw which is called
     from user code.
     For a catch, __d_eh_break is called by
     __d_eh_notify_callback which is called by
     <stackwalking stuff> which is called by
     __throw__<stuff> or __rethrow_<stuff> which is called
     from user code. */
  /* FIXME: Don't use such magic numbers; search for the frames */
  level = (event_kind == EX_EVENT_THROW) ? 3 : 4;
  fi = find_relative_frame (curr_frame, &level);
  if (level != 0)
    return (struct exception_event_record *) NULL;

  select_frame (fi);
  throw_addr = get_frame_pc (fi);

  /* Go back to original (top) frame */
  select_frame (curr_frame);

  current_ex_event.kind = (enum exception_event_kind) event_kind;
  current_ex_event.throw_sal = find_pc_line (throw_addr, 1);
  current_ex_event.catch_sal = find_pc_line (catch_addr, 1);

  return &current_ex_event;
d124 3
a126 109
/* Signal frames.  */
struct hppa_hpux_sigtramp_unwind_cache
{
  CORE_ADDR base;
  struct trad_frame_saved_reg *saved_regs;
};

static int hppa_hpux_tramp_reg[] = {
  HPPA_SAR_REGNUM,
  HPPA_PCOQ_HEAD_REGNUM,
  HPPA_PCSQ_HEAD_REGNUM,
  HPPA_PCOQ_TAIL_REGNUM,
  HPPA_PCSQ_TAIL_REGNUM,
  HPPA_EIEM_REGNUM,
  HPPA_IIR_REGNUM,
  HPPA_ISR_REGNUM,
  HPPA_IOR_REGNUM,
  HPPA_IPSW_REGNUM,
  -1,
  HPPA_SR4_REGNUM,
  HPPA_SR4_REGNUM + 1,
  HPPA_SR4_REGNUM + 2,
  HPPA_SR4_REGNUM + 3,
  HPPA_SR4_REGNUM + 4,
  HPPA_SR4_REGNUM + 5,
  HPPA_SR4_REGNUM + 6,
  HPPA_SR4_REGNUM + 7,
  HPPA_RCR_REGNUM,
  HPPA_PID0_REGNUM,
  HPPA_PID1_REGNUM,
  HPPA_CCR_REGNUM,
  HPPA_PID2_REGNUM,
  HPPA_PID3_REGNUM,
  HPPA_TR0_REGNUM,
  HPPA_TR0_REGNUM + 1,
  HPPA_TR0_REGNUM + 2,
  HPPA_CR27_REGNUM
};

static struct hppa_hpux_sigtramp_unwind_cache *
hppa_hpux_sigtramp_frame_unwind_cache (struct frame_info *next_frame,
				       void **this_cache)

{
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  struct hppa_hpux_sigtramp_unwind_cache *info;
  unsigned int flag;
  CORE_ADDR sp, scptr;
  int i, incr, off, szoff;

  if (*this_cache)
    return *this_cache;

  info = FRAME_OBSTACK_ZALLOC (struct hppa_hpux_sigtramp_unwind_cache);
  *this_cache = info;
  info->saved_regs = trad_frame_alloc_saved_regs (next_frame);

  sp = frame_unwind_register_unsigned (next_frame, HPPA_SP_REGNUM);

  scptr = sp - 1352;
  off = scptr;

  /* See /usr/include/machine/save_state.h for the structure of the save_state_t
     structure. */
  
  flag = read_memory_unsigned_integer(scptr, 4);
    
  if (!(flag & 0x40))
    {
      /* Narrow registers. */
      off = scptr + offsetof (save_state_t, ss_narrow);
      incr = 4;
      szoff = 0;
    }
  else
    {
      /* Wide registers. */
      off = scptr + offsetof (save_state_t, ss_wide) + 8;
      incr = 8;
      szoff = (tdep->bytes_per_address == 4 ? 4 : 0);
    }

  for (i = 1; i < 32; i++)
    {
      info->saved_regs[HPPA_R0_REGNUM + i].addr = off + szoff;
      off += incr;
    }

  for (i = 0; 
       i < sizeof(hppa_hpux_tramp_reg) / sizeof(hppa_hpux_tramp_reg[0]);
       i++)
    {
      if (hppa_hpux_tramp_reg[i] > 0)
        info->saved_regs[hppa_hpux_tramp_reg[i]].addr = off + szoff;
      off += incr;
    }

  /* TODO: fp regs */

  info->base = frame_unwind_register_unsigned (next_frame, HPPA_SP_REGNUM);

  return info;
}

static void
hppa_hpux_sigtramp_frame_this_id (struct frame_info *next_frame,
				   void **this_prologue_cache,
				   struct frame_id *this_id)
d128 2
a129 3
  struct hppa_hpux_sigtramp_unwind_cache *info
    = hppa_hpux_sigtramp_frame_unwind_cache (next_frame, this_prologue_cache);
  *this_id = frame_id_build (info->base, frame_pc_unwind (next_frame));
d132 3
a134 7
static void
hppa_hpux_sigtramp_frame_prev_register (struct frame_info *next_frame,
					 void **this_prologue_cache,
					 int regnum, int *optimizedp,
					 enum lval_type *lvalp, 
					 CORE_ADDR *addrp,
					 int *realnump, void *valuep)
d136 3
a138 17
  struct hppa_hpux_sigtramp_unwind_cache *info
    = hppa_hpux_sigtramp_frame_unwind_cache (next_frame, this_prologue_cache);
  hppa_frame_prev_register_helper (next_frame, info->saved_regs, regnum,
		                   optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind hppa_hpux_sigtramp_frame_unwind = {
  SIGTRAMP_FRAME,
  hppa_hpux_sigtramp_frame_this_id,
  hppa_hpux_sigtramp_frame_prev_register
};

static const struct frame_unwind *
hppa_hpux_sigtramp_unwind_sniffer (struct frame_info *next_frame)
{
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  char *name;
d140 1
a140 17
  find_pc_partial_function (pc, &name, NULL, NULL);

  if (name && strcmp(name, "_sigreturn") == 0)
    return &hppa_hpux_sigtramp_frame_unwind;

  return NULL;
}

static CORE_ADDR
hppa_hpux_som_find_global_pointer (struct value *function)
{
  CORE_ADDR faddr;
  
  faddr = value_as_address (function);

  /* Is this a plabel? If so, dereference it to get the gp value.  */
  if (faddr & 2)
d142 4
a145 123
      int status;
      char buf[4];

      faddr &= ~3;

      status = target_read_memory (faddr + 4, buf, sizeof (buf));
      if (status == 0)
	return extract_unsigned_integer (buf, sizeof (buf));
    }

  return som_solib_get_got_by_pc (faddr);
}

static CORE_ADDR
hppa_hpux_push_dummy_code (struct gdbarch *gdbarch, CORE_ADDR sp,
			   CORE_ADDR funcaddr, int using_gcc,
			   struct value **args, int nargs,
			   struct type *value_type,
			   CORE_ADDR *real_pc, CORE_ADDR *bp_addr)
{
  /* FIXME: tausq/2004-06-09: This needs much more testing.  It is broken
     for pa64, but we should be able to get it to work with a little bit
     of work. gdb-6.1 has a lot of code to handle various cases; I've tried to
     simplify it and avoid compile-time conditionals.  */

  /* On HPUX, functions in the main executable and in libraries can be located
     in different spaces.  In order for us to be able to select the right 
     space for the function call, we need to go through an instruction seqeunce
     to select the right space for the target function, call it, and then
     restore the space on return.

     There are two helper routines that can be used for this task -- if
     an application is linked with gcc, it will contain a __gcc_plt_call
     helper function.  __gcc_plt_call, when passed the entry point of an
     import stub, will do the necessary space setting/restoration for the
     target function.

     For programs that are compiled/linked with the HP compiler, a similar
     function called __d_plt_call exists; __d_plt_call expects a PLABEL instead
     of an import stub as an argument.

     // *INDENT-OFF*
     To summarize, the call flow is:
       current function -> dummy frame -> __gcc_plt_call (import stub) 
                        -> target function
     or
       current function -> dummy frame -> __d_plt_call (plabel)
                        -> target function
     // *INDENT-ON*

     In general the "funcaddr" argument passed to push_dummy_code is the actual
     entry point of the target function.  For __gcc_plt_call, we need to 
     locate the import stub for the corresponding function.  Failing that,
     we construct a dummy "import stub" on the stack to pass as an argument.
     For __d_plt_call, we similarly synthesize a PLABEL on the stack to
     pass to the helper function.

     An additional twist is that, in order for us to restore the space register
     to its starting state, we need __gcc_plt_call/__d_plt_call to return
     to the instruction where we started the call.  However, if we put
     the breakpoint there, gdb will complain because it will find two 
     frames on the stack with the same (sp, pc) (with the dummy frame in 
     between).  Currently, we set the return pointer to (pc - 4) of the 
     current function.  FIXME: This is not an ideal solution; possibly if the 
     current pc is at the beginning of a page, this will cause a page fault. 
     Need to understand this better and figure out a better way to fix it.  */

  struct minimal_symbol *sym;

  /* Nonzero if we will use GCC's PLT call routine.  This routine must be
     passed an import stub, not a PLABEL.  It is also necessary to get %r19
     before performing the call.  (This is done by push_dummy_call.)  */
  int use_gcc_plt_call = 1;

  /* See if __gcc_plt_call is available; if not we will use the HP version
     instead.  */
  sym = lookup_minimal_symbol ("__gcc_plt_call", NULL, NULL);
  if (sym == NULL)
    use_gcc_plt_call = 0;

  /* If using __gcc_plt_call, we need to make sure we pass in an import
     stub.  funcaddr can be pointing to an export stub or a real function,
     so we try to resolve it to the import stub.  */
  if (use_gcc_plt_call)
    {
      struct objfile *objfile;
      struct minimal_symbol *funsym, *stubsym;
      CORE_ADDR stubaddr = 0;

      funsym = lookup_minimal_symbol_by_pc (funcaddr);
      if (!funsym)
        error ("Unable to find symbol for target function.\n");

      ALL_OBJFILES (objfile)
        {
	  stubsym = lookup_minimal_symbol_solib_trampoline
	    (SYMBOL_LINKAGE_NAME (funsym), objfile);

          if (stubsym)
	    {
	      struct unwind_table_entry *u;

	      u = find_unwind_entry (SYMBOL_VALUE (stubsym));
	      if (u == NULL 
	          || (u->stub_unwind.stub_type != IMPORT
		      && u->stub_unwind.stub_type != IMPORT_SHLIB))
	        continue;

              stubaddr = SYMBOL_VALUE (stubsym);

	      /* If we found an IMPORT stub, then we can stop searching;
	         if we found an IMPORT_SHLIB, we want to continue the search
		 in the hopes that we will find an IMPORT stub.  */
	      if (u->stub_unwind.stub_type == IMPORT)
	        break;
	    }
	}

      if (stubaddr != 0)
        {
          /* Argument to __gcc_plt_call is passed in r22.  */
          regcache_cooked_write_unsigned (current_regcache, 22, stubaddr);
        }
d147 1
a147 46
        {
	  /* No import stub found; let's synthesize one.  */

	  /* ldsid %r21, %r1 */
	  write_memory_unsigned_integer (sp, 4, 0x02a010a1);
	  /* mtsp %r1,%sr0 */
	  write_memory_unsigned_integer (sp + 4, 4, 0x00011820);
	  /* be 0(%sr0, %r21) */
	  write_memory_unsigned_integer (sp + 8, 4, 0xe2a00000);
          /* nop */
          write_memory_unsigned_integer (sp + 12, 4, 0x08000240);

          regcache_cooked_write_unsigned (current_regcache, 21, funcaddr);
          regcache_cooked_write_unsigned (current_regcache, 22, sp);
	}

      /* We set the breakpoint address and r31 to (close to) where the current
         pc is; when __gcc_plt_call returns, it will restore pcsqh to the
	 current value based on this.  The -4 is needed for frame unwinding
	 to work properly -- we need to land in a different function than
	 the current function.  */
      *bp_addr = (read_register (HPPA_PCOQ_HEAD_REGNUM) & ~3) - 4;
      regcache_cooked_write_unsigned (current_regcache, 31, *bp_addr);

      /* Continue from __gcc_plt_call.  */
      *real_pc = SYMBOL_VALUE (sym);
    }
  else
    {
      unsigned int gp;

      /* Use __d_plt_call as a fallback; __d_plt_call expects to be called 
         with a plabel, so we need to build one.  */

      sym = lookup_minimal_symbol ("__d_plt_call", NULL, NULL);
      if (sym == NULL)
        error("Can't find an address for __d_plt_call or __gcc_plt_call "
	      "trampoline\nSuggest linking executable with -g or compiling "
	      "with gcc.");

      gp = gdbarch_tdep (gdbarch)->find_global_pointer (funcaddr);
      write_memory_unsigned_integer (sp, 4, funcaddr);
      write_memory_unsigned_integer (sp + 4, 4, gp);

      /* plabel is passed in r22 */
      regcache_cooked_write_unsigned (current_regcache, 22, sp);
a148 14

  /* Pushed one stack frame, which has to be 64-byte aligned.  */
  sp += 64;

  return sp;
}

static void
hppa_hpux_inferior_created (struct target_ops *objfile, int from_tty)
{
  /* Some HP-UX related globals to clear when a new "main"
     symbol file is loaded.  HP-specific.  */
  deprecated_hp_som_som_object_present = 0;
  hp_cxx_exception_support_initialized = 0;
d154 1
a154 19
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (tdep->bytes_per_address == 4)
    set_gdbarch_in_solib_call_trampoline (gdbarch, 
					  hppa32_hpux_in_solib_call_trampoline);
  else
    set_gdbarch_in_solib_call_trampoline (gdbarch, 
					  hppa64_hpux_in_solib_call_trampoline);

  set_gdbarch_in_solib_return_trampoline (gdbarch,
					  hppa_hpux_in_solib_return_trampoline);
  set_gdbarch_skip_trampoline_code (gdbarch, hppa_hpux_skip_trampoline_code);

  set_gdbarch_push_dummy_code (gdbarch, hppa_hpux_push_dummy_code);
  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);

  frame_unwind_append_sniffer (gdbarch, hppa_hpux_sigtramp_unwind_sniffer);

  observer_attach_inferior_created (hppa_hpux_inferior_created);
a159 5
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  tdep->is_elf = 0;

  tdep->find_global_pointer = hppa_hpux_som_find_global_pointer;
a165 3
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  tdep->is_elf = 1;
@


1.11.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.10
log
@        Further multiarching work mostly for hppa64-*-hpux11:
        * hppa-tdep.h: New file.
        * hppa-tdep.c: #include hppa-tdep.c.
        (hppa32_num_regs): Renamed from hppa_num_regs.
        (hppa64_num_regs): New constant.
        (hppa64_call_dummy_breakpoint_offset): New constant.
        (hppa32_call_dummy_length): New constant.
        (hppa64_call_dummy_length): New constant.
        (hppa32_stack_align): Make name 32bit explicit.
        (hppa32_register_virtual_type): Likewise.
        (hppa32_extract_return_value): Likewise.
        (hppa32_use_struct_convention): Likewise.
        (hppa32_store_return_value): Likewise.
        (hppa64_register_virtual_type): New function.
        (hppa64_extract_return_value): New function.
        (hppa64_use_struct_convention): New function.
        (hppa64_store_return_value): New function.
        (hppa_frame_locals_address): Remove declaration, function does
        not exist anymore.
        (hppa_register_byte): Add support for PA64 ABI.
        (hppa_gdbarch_init): Add support for PA64 ABI.
        * hppa-hpux-tdep.c (hppa32_hpux_frame_saved_pc_in_sigtramp):
        Make name 32bit explicit.
        (hppa32_hpux_frame_base_before_sigtramp): Likewise.
        (hppa32_hpux_frame_find_saved_regs_in_sigtramp): Likewise.
        (hppa64_hpux_frame_saved_pc_in_sigtramp): New function.
        (hppa64_hpux_frame_base_before_sigtramp): New function.
        (hppa64_hpux_frame_find_saved_regs_in_sigtramp): New function.
        * config/pa/tm-hppa64.h: Remove macros that are no longer
        necessary now that the gdbarch vector is properly setup.
        Transform some macros into function calls. Some minor cleanup.
        * config/pa/tm-hppah.h: Update function calls in macros
        following the function renaming in hppa-hpux-tdep.c.
        * Makefile.in (hppa_tdep_h): New variable.
        (hppa-tdep.o): Add dependency over hppa_tdep_h.
@
text
@d174 1
a174 4
  /* FIXME brobecker 2003-08-13: The machine number 25 corresponds to
     the hppa2.0w bfd arch_info. A #define should probably be defined
     in bfd, instead of using this hard-coded number.  */
  gdbarch_register_osabi (bfd_arch_hppa, 25, GDB_OSABI_HPUX_ELF,
@


1.9
log
@       * hppa-hpux-tdep.c (_initialize_hppa_hpux_tdep): Use the correct
       bfd arch_info when registering the GDB_OSABI_HPUX_ELF initialization
       routine.
@
text
@d35 12
a46 6
void hppa_hpux_frame_saved_pc_in_sigtramp (struct frame_info *fi,
                                           CORE_ADDR *tmp);
void hppa_hpux_frame_base_before_sigtramp (struct frame_info *fi,
                                           CORE_ADDR *tmp);
void hppa_hpux_frame_find_saved_regs_in_sigtramp
      (struct frame_info *fi, CORE_ADDR *fsr);
d57 3
a59 3
/* For hppa_hpux_frame_saved_pc_in_sigtramp, 
   hppa_hpux_frame_base_before_sigtramp and
   hppa_hpux_frame_find_saved_regs_in_sigtramp:
d76 1
a76 1
hppa_hpux_frame_saved_pc_in_sigtramp (struct frame_info *fi, CORE_ADDR *tmp)
d82 2
a83 2
hppa_hpux_frame_base_before_sigtramp (struct frame_info *fi,
                                      CORE_ADDR *tmp)
d89 2
a90 2
hppa_hpux_frame_find_saved_regs_in_sigtramp (struct frame_info *fi,
					     CORE_ADDR *fsr)
d101 47
@


1.8
log
@2003-07-27  Andrew Cagney  <cagney@@redhat.com>

	* config/pa/tm-hppa.h (init_frame_pc_default): Declare.
	* infcall.c (legacy_push_dummy_code) [GDB_TARGET_IS_HPPA]: Update
	REAL_PC and not the pointer.
	* hppa-hpux-tdep.c: Include frame.h
@
text
@d121 4
a124 1
  gdbarch_register_osabi (bfd_arch_hppa, 0, GDB_OSABI_HPUX_ELF,
@


1.7
log
@        * hppa-hpux-tdep.c (hppa_hpux_init_abi): New function, setting
        pc_in_sigtramp multiarch method.
        (hppa_hpux_som_init_abi): Use it.
        (hppa_hpux_elf_init_abi): Likewise.
        * config/pa/tm-hppah.h (PC_IN_SIGTRAMP): Remove, now that this
        macro has been multiarched.
        * config/pa/tm-hppa64.h (PC_IN_SIGTRAMP): Temporarily set this
        macro here, as hppa64 isn't multiarched yet.
@
text
@d26 1
@


1.7.6.1
log
@2003-07-27  Andrew Cagney  <cagney@@redhat.com>

	Sync HP/UX with mainline:
	* config/pa/tm-hppa.h (init_frame_pc_default): Declare.
	* infcall.c (legacy_push_dummy_code) [GDB_TARGET_IS_HPPA]: Update
	REAL_PC and not the pointer.
	* hppa-hpux-tdep.c: Include frame.h
	* config/pa/tm-hppa64.h (GDB_MULTI_ARCH): Set to
	GDB_MULTI_ACH_PARTIAL.
	* config/pa/tm-hppa64.h (FRAME_SAVED_PC_IN_SIGTRAMP): Use
	get_frame_base.
	(FRAME_BASE_BEFORE_SIGTRAMP): Ditto.
	(FRAME_FIND_SAVED_REGS_IN_SIGTRAMP): Ditto.
	(struct value): Add opaque declaration.
	(DEPRECATED_FRAME_ARGS_ADDRESS): Delete.
	* config/pa/tm-hppa64.h (REGISTER_NAMES): Delete macro.
	(REGISTER_NAME): Define.
	(hppa64_register_name): Declare.
	* config/pa/tm-hppa.h (REGISTER_NAMES): Delete macro.
	* hppa-tdep.c (hppa_gdbarch_init): Set hppa_register_name.
	(hppa64_register_name): New function.
	(hppa_register_name): New function.
@
text
@a25 1
#include "frame.h"
@


1.6
log
@2003-04-13  Andrew Cagney  <cagney@@redhat.com>

	* frame.h: Mention what replaced what in "struct frame_info".
	* hppa-hpux-tdep.c: Use get_frame_base, get_frame_pc and
	deprecated_update_frame_base_hack and
	deprecated_update_frame_pc_hack.
	* hppa-tdep.c: Ditto.
@
text
@d97 5
d106 1
d112 1
@


1.5
log
@2003-04-05  Andrew Cagney  <cagney@@redhat.com>

	Eliminate FRAME_FIND_SAVED_REGS.
	* config/pa/tm-hppah.h (hppa_hpux_frame_find_saved_regs_in_sigtramp):
	Change FSR parameter to a pointer.
	* config/pa/tm-hppa64.h (FRAME_FIND_SAVED_REGS_IN_SIGTRAMP):
	Assume FSR parameter is a pointer.
	* hppa-hpux-tdep.c (hppa_hpux_frame_find_saved_regs_in_sigtramp):
	Make fsr a pointer.
	* hppa-tdep.c (hppa_frame_find_saved_regs): New function.
	(hppa_frame_saved_pc): Call hppa_frame_init_saved_regs.  Make
	saved_regs a pointer.
	(hppa_frame_saved_pc): Ditto.
	(find_dummy_frame_regs): Make frame_saved_regs a pointer
	(hppa_pop_frame): Call hppa_frame_init_saved_regs.  Make fsr a
	pointer.
	(restore_pc_queue): Make fsr a pointer.
	(hppa_frame_find_saved_regs): Make frame_saved_regs a pointer.
	(hppa_frame_chain): Make saved_regs a pointer, call
	hppa_frame_init_saved_regs.
	* sparc-tdep.c: Include "gdb_assert.h".
	(sparc_frame_find_saved_regs): Replace internal_error with
	gdb_assert.
	* remote-vxsparc.c (vx_read_register): Delete reference to
	FRAME_FIND_SAVED_REGS.
	* gdbarch.sh: Delete check for FRAME_FIND_SAVED_REGS.
	* gdbarch.h: Regenerate.
	* frame.h (DEPRECATED_FRAME_INIT_SAVED_REGS): Delete macro.
	(deprecated_get_frame_saved_regs): Delete declaration.
	(struct frame_saved_regs): Delete definition.
	* frame.c (deprecated_get_frame_saved_regs): Delete function.
	* config/pa/tm-hppa.h (hppa_frame_init_saved_regs): Declare.
	(hppa_frame_find_saved_regs): Delete declaration.
	(FRAME_FIND_SAVED_REGS): Delete macro.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Define.
	* config/i386/tm-ptx.h (FRAME_FIND_SAVED_REGS): Delete
	FRAME_FIND_SAVED_REGS in comment.
@
text
@d2 2
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d71 1
a71 1
  *tmp = read_memory_integer (fi->frame + (43 * 4), 4);
d78 1
a78 1
  *tmp = read_memory_integer (fi->frame + (40 * 4), 4);
d86 1
a86 1
  const CORE_ADDR tmp = (fi)->frame + (10 * 4);
@


1.4
log
@2003-03-29  Andrew Cagney  <cagney@@redhat.com>

	* infttrace.h: New file.
	* hpread.c: Include "gdb_assert.h" and "somsolib.h".
	(hpread_get_textlow): Detect an uninitialized dn_bufp.
	(hpread_read_doc_function_type): Detect an initialized type1.
	(hpread_quick_traverse): Initialize mod_name_string.
	* somsolib.h: Add #ifdef SOMSOLIB_H wrapper.
	(som_solib_get_solib_by_pc): Declare.
	(so_lib_thread_start_addr): Declare.
	(no_shared_libraries): Declare.
	* somread.c (init_import_symbols): Make static.  Add forward
	declaration.
	* config/pa/nm-hppah.h: Include "infttrace.h" for
	parent_attach_all.
	(hppa_insert_hw_watchpoint): Declare.
	(hppa_can_use_hw_watchpoint, hppa_remove_hw_watchpoint): Declare.
	* hppah-nat.c: Include "gdb_string.h".
	(parent_attach_all): Delete extern declaration, moved to
	"infttrace.h".
	(hppa_can_use_hw_watchpoint): Change type of "type" parameter to
	int.
	(hppa_remove_hw_watchpoint, hppa_insert_hw_watchpoint): Ditto.
	* Makefile.in (infttrace_h): Define.
	(hpread.o): Update dependencies.
	(hppah-nat.o, hppa-hpux-tdep.o, hppa-tdep.o): Ditto.
	* hppa-hpux-tdep.c: Include "gdb_string.h".
	* hppa-tdep.c (hppa_frame_saved_pc): Initialize "old_pc".
	* infrun.c (handle_inferior_event): Always initialize
	stepped_after_stopped_by_watchpoint.  Add default and remove
	fallthrough in switch statement.
	* infttrace.c (hppa_can_use_hw_watchpoint): Change type of "type"
	parameter to int.
	(hppa_remove_hw_watchpoint): Ditto.
@
text
@d38 1
a38 1
      (struct frame_info *fi, struct frame_saved_regs *fsr);
d82 1
a82 1
                                             struct frame_saved_regs *fsr)
d90 1
a90 1
	(fsr)->regs[SP_REGNUM] = read_memory_integer (tmp + SP_REGNUM * 4, 4);
d92 1
a92 1
	(fsr)->regs[i] = tmp + i * 4;
@


1.4.2.1
log
@Merge with mainline.
@
text
@d38 1
a38 1
      (struct frame_info *fi, CORE_ADDR *fsr);
d82 1
a82 1
					     CORE_ADDR *fsr)
d90 1
a90 1
	fsr[SP_REGNUM] = read_memory_integer (tmp + SP_REGNUM * 4, 4);
d92 1
a92 1
	fsr[i] = tmp + i * 4;
@


1.3
log
@       Continuing work to convert the hppa targets to multiarch partial.

       * hppa-tdep.c: (hppa_register_raw_size): New function replacing
       the body of macro REGISTER_RAW_SIZE.
       * hppa-hpux-tdep.c: Add new functions replacing macro bodies from
       config/pa/tm-hppah.h. These functions will be used to initialize
       the gdbarch structure.
       (hppa_hpux_pc_in_sigtramp): New function.
       (hppa_hpux_frame_saved_pc_in_sigtramp): New function.
       (hppa_hpux_frame_base_before_sigtramp): New function.
       (hppa_hpux_frame_find_saved_regs_in_sigtramp): New function.
       Add gdbcore.h #include.
       * config/pa/tm-hppa.h (REGISTER_RAW_SIZE): Change the definition
       of this gdbarch-eligible macro to a call to the new associated
       function.
       * config/pa/tm-hppah.h (PC_IN_SIGTRAMP): Likewise.
       (FRAME_SAVED_PC_IN_SIGTRAMP): Change the definition of this macro
       into a call to the new associated function.
       (FRAME_BASE_BEFORE_SIGTRAMP): Likewise.
       (FRAME_FIND_SAVED_REGS_IN_SIGTRAMP): Likewise.
       * Makefile.in (hppa-hpux-tdep.o): Add dependency on gdbcore.h.
@
text
@d24 1
@


1.3.14.1
log
@Merge with mainline.
@
text
@a23 1
#include "gdb_string.h"
@


1.2
log
@* osabi.c: Include "gdb_assert.h" and "gdb_string.h".
(struct gdb_osabi_handler): Remove member `arch'.  Add member
`arch_info'.
(gdbarch_register_osabi): Add new argument `machine'.  Use ot to
construct a `struct bfd_arch_info' and store it in the `struct
gdb_osabi_handler' that is created.
(gdbarch_init_osabi): Check for compatibility based on machine
type and architecture.
* osabi.h (gdbarch_register_osabi): Adjust prototype and update
comment.
* alpha-linux-tdep.c (_initialize_alpha_linux_tdep): Add 0 as
second argument in call to gdbarch_register_osabi.
* alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Likewise.
* alphafbsd-tdep.c (_initialize_alphafbsd_tdep): Likewise.
* alphanbsd-tdep.c (_initialize_alphanbsd_tdep): Likewise.
* arm-linux-tdep.c (_initialize_arm_linux_tdep): Likewise.
* arm-tdep.c (_initialize_arm_tdep): Likewise.
* armnbsd-tdep.c (_initialize_armnbsd_tdep): Likewise.
* hppa-hpux-tdep.c (_initialize_hppa_hpux_tdep): Likewise.
* i386-interix-tdep.c (_initialize_i386_interix_tdep): Likewise.
* i386-linux-tdep.c (_initialize_i386_linux_tdep): Likewise.
* i386-sol2-tdep.c (_initialize_i386_sol2_tdep): Likewise.
* i386-tdep.c (_initialize_i386_tdep): Likewise.
* i386bsd-tdep.c (_initialize_i386bsd_tdep): Likewise.
* i386gnu-tdep.c (_initialize_i386gnu_tdep): Likewise.
* i386ly-tdep.c (_initialize_i386lynx_tdep): Renamed from
_initialize_i386bsd_tdep and updated likewise.
* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Likewise.
* i386obsd-tdep.c (_initialize_i386obsd_tdep): Likewise.
* mips-irix-tdep.c (_initialize_mips_irix_tdep): Likewise.
* mips-linux-tdep.c (_initialize_mips_linux_tdep): Likewise.
* mipsnbsd-tdep.c (_initialize_mipsnbsd__tdep): Likewise.
* ns32knbsd-tdep.c (_initialize_ns32kmnsd_tdep): Likewise.
* ppc-linux-tdep.c (_initialize_ppc_linux_tdep): Likewise.
* ppcnbsd-tdep.c (_initialize_ppcnbsd_tdep): Likewise.
* shnbsd-tdep.c (_initialize_shnbsd_tdep): Likewise.
* sparcnbsd-tdep.c (_initialize_sparcnbsd_tdep): Likewise.
@
text
@d22 1
d28 67
@


1.2.2.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.2.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a21 1
#include "gdbcore.h"
a26 67

/* FIXME: brobecker 2002-12-25.  The following functions will eventually
   become static, after the multiarching conversion is done.  */
int hppa_hpux_pc_in_sigtramp (CORE_ADDR pc, char *name);
void hppa_hpux_frame_saved_pc_in_sigtramp (struct frame_info *fi,
                                           CORE_ADDR *tmp);
void hppa_hpux_frame_base_before_sigtramp (struct frame_info *fi,
                                           CORE_ADDR *tmp);
void hppa_hpux_frame_find_saved_regs_in_sigtramp
      (struct frame_info *fi, struct frame_saved_regs *fsr);

int
hppa_hpux_pc_in_sigtramp (CORE_ADDR pc, char *name)
{
  /* Actually, for a PA running HPUX the kernel calls the signal handler
     without an intermediate trampoline.  Luckily the kernel always sets
     the return pointer for the signal handler to point to _sigreturn.  */
  return (name && (strcmp ("_sigreturn", name) == 0));
}

/* For hppa_hpux_frame_saved_pc_in_sigtramp, 
   hppa_hpux_frame_base_before_sigtramp and
   hppa_hpux_frame_find_saved_regs_in_sigtramp:

   The signal context structure pointer is always saved at the base
   of the frame which "calls" the signal handler.  We only want to find
   the hardware save state structure, which lives 10 32bit words into
   sigcontext structure.

   Within the hardware save state structure, registers are found in the
   same order as the register numbers in GDB.

   At one time we peeked at %r31 rather than the PC queues to determine
   what instruction took the fault.  This was done on purpose, but I don't
   remember why.  Looking at the PC queues is really the right way, and
   I don't remember why that didn't work when this code was originally
   written.  */

void
hppa_hpux_frame_saved_pc_in_sigtramp (struct frame_info *fi, CORE_ADDR *tmp)
{
  *tmp = read_memory_integer (fi->frame + (43 * 4), 4);
}

void
hppa_hpux_frame_base_before_sigtramp (struct frame_info *fi,
                                      CORE_ADDR *tmp)
{
  *tmp = read_memory_integer (fi->frame + (40 * 4), 4);
}

void
hppa_hpux_frame_find_saved_regs_in_sigtramp (struct frame_info *fi,
                                             struct frame_saved_regs *fsr)
{
  int i;
  const CORE_ADDR tmp = (fi)->frame + (10 * 4);

  for (i = 0; i < NUM_REGS; i++)
    {
      if (i == SP_REGNUM)
	(fsr)->regs[SP_REGNUM] = read_memory_integer (tmp + SP_REGNUM * 4, 4);
      else
	(fsr)->regs[i] = tmp + i * 4;
    }
}

@


1.2.2.3
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d2 1
a2 2

   Copyright 2002, 2003 Free Software Foundation, Inc.
a23 1
#include "gdb_string.h"
d37 1
a37 1
      (struct frame_info *fi, CORE_ADDR *fsr);
d69 1
a69 1
  *tmp = read_memory_integer (get_frame_base (fi) + (43 * 4), 4);
d76 1
a76 1
  *tmp = read_memory_integer (get_frame_base (fi) + (40 * 4), 4);
d81 1
a81 1
					     CORE_ADDR *fsr)
d84 1
a84 1
  const CORE_ADDR tmp = get_frame_base (fi) + (10 * 4);
d89 1
a89 1
	fsr[SP_REGNUM] = read_memory_integer (tmp + SP_REGNUM * 4, 4);
d91 1
a91 1
	fsr[i] = tmp + i * 4;
@


1.2.2.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a96 5
static void
hppa_hpux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  set_gdbarch_pc_in_sigtramp (gdbarch, hppa_hpux_pc_in_sigtramp);
}
a100 1
  hppa_hpux_init_abi (info, gdbarch);
a105 1
  hppa_hpux_init_abi (info, gdbarch);
@


1.2.2.5
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a25 1
#include "frame.h"
@


1.2.2.6
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d35 6
a40 12
void hppa32_hpux_frame_saved_pc_in_sigtramp (struct frame_info *fi,
                                             CORE_ADDR *tmp);
void hppa32_hpux_frame_base_before_sigtramp (struct frame_info *fi,
                                             CORE_ADDR *tmp);
void hppa32_hpux_frame_find_saved_regs_in_sigtramp (struct frame_info *fi,
                                                    CORE_ADDR *fsr);
void hppa64_hpux_frame_saved_pc_in_sigtramp (struct frame_info *fi,
                                             CORE_ADDR *tmp);
void hppa64_hpux_frame_base_before_sigtramp (struct frame_info *fi,
                                             CORE_ADDR *tmp);
void hppa64_hpux_frame_find_saved_regs_in_sigtramp (struct frame_info *fi,
                                                    CORE_ADDR *fsr);
d51 3
a53 3
/* For hppa32_hpux_frame_saved_pc_in_sigtramp, 
   hppa32_hpux_frame_base_before_sigtramp and
   hppa32_hpux_frame_find_saved_regs_in_sigtramp:
d70 1
a70 1
hppa32_hpux_frame_saved_pc_in_sigtramp (struct frame_info *fi, CORE_ADDR *tmp)
d76 2
a77 2
hppa32_hpux_frame_base_before_sigtramp (struct frame_info *fi,
                                        CORE_ADDR *tmp)
d83 2
a84 2
hppa32_hpux_frame_find_saved_regs_in_sigtramp (struct frame_info *fi,
					       CORE_ADDR *fsr)
a97 47
/* For hppa64_hpux_frame_saved_pc_in_sigtramp, 
   hppa64_hpux_frame_base_before_sigtramp and
   hppa64_hpux_frame_find_saved_regs_in_sigtramp:

   These functions are the PA64 ABI equivalents of the 32bits counterparts
   above. See the comments there.

   For PA64, the save_state structure is at an offset of 24 32-bit words
   from the sigcontext structure. The 64 bit general registers are at an
   offset of 640 bytes from the beginning of the save_state structure,
   and the floating pointer register are at an offset of 256 bytes from
   the beginning of the save_state structure.  */

void
hppa64_hpux_frame_saved_pc_in_sigtramp (struct frame_info *fi, CORE_ADDR *tmp)
{
  *tmp = read_memory_integer
           (get_frame_base (fi) + (24 * 4) + 640 + (33 * 8), 8);
}

void
hppa64_hpux_frame_base_before_sigtramp (struct frame_info *fi,
                                        CORE_ADDR *tmp)
{
  *tmp = read_memory_integer
           (get_frame_base (fi) + (24 * 4) + 640 + (30 * 8), 8);
}

void
hppa64_hpux_frame_find_saved_regs_in_sigtramp (struct frame_info *fi,
					       CORE_ADDR *fsr)
{
  int i;
  const CORE_ADDR tmp1 = get_frame_base (fi) + (24 * 4) + 640;
  const CORE_ADDR tmp2 = get_frame_base (fi) + (24 * 4) + 256;

  for (i = 0; i < NUM_REGS; i++)
    {
      if (i == SP_REGNUM)
        fsr[SP_REGNUM] = read_memory_integer (tmp1 + SP_REGNUM * 8, 8);
      else if (i >= FP0_REGNUM)
        fsr[i] = tmp2 + (i - FP0_REGNUM) * 8;
      else
        fsr[i] = tmp1 + i * 8;
    }
}

d121 1
a121 4
  /* FIXME brobecker 2003-08-13: The machine number 25 corresponds to
     the hppa2.0w bfd arch_info. A #define should probably be defined
     in bfd, instead of using this hard-coded number.  */
  gdbarch_register_osabi (bfd_arch_hppa, 25, GDB_OSABI_HPUX_ELF,
@


1.2.2.7
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d174 4
a177 1
  gdbarch_register_osabi (bfd_arch_hppa, bfd_mach_hppa20w, GDB_OSABI_HPUX_ELF,
@


1.1
log
@        * hppa-hpux-tdep.c: New file.
        * hppa-tdep.c (hppa_gdbarch_init): call the registered osabi-
        specific initialization routines.
        * Makefile.in (ALLDEPFILES): Add hppa-hpux-tdep.c.
        (hppa-hpux-tdep.o): Add rule.
        * config/pa/hppahpux.mt (TDEPFILES): Add hppa-hpux-tdep.o.
        * config/pa/hppa64.mt (TDEPFILES): Likewise.
@
text
@d41 1
a41 1
  gdbarch_register_osabi (bfd_arch_hppa, GDB_OSABI_HPUX_SOM,
d43 1
a43 1
  gdbarch_register_osabi (bfd_arch_hppa, GDB_OSABI_HPUX_ELF,
a45 1

@

