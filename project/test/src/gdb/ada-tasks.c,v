head	1.60;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.56
	gdb_7_6-2013-04-26-release:1.56
	gdb_7_6-branch:1.56.0.2
	gdb_7_6-2013-03-12-branchpoint:1.56
	gdb_7_5_1-2012-11-29-release:1.54
	gdb_7_5-2012-08-17-release:1.54
	gdb_7_5-branch:1.54.0.2
	gdb_7_5-2012-07-18-branchpoint:1.54
	gdb_7_4_1-2012-04-26-release:1.50.2.1
	gdb_7_4-2012-01-24-release:1.50.2.1
	gdb_7_4-branch:1.50.0.2
	gdb_7_4-2011-12-13-branchpoint:1.50
	gdb_7_3_1-2011-09-04-release:1.37
	gdb_7_3-2011-07-26-release:1.37
	gdb_7_3-branch:1.37.0.2
	gdb_7_3-2011-04-01-branchpoint:1.37
	gdb_7_2-2010-09-02-release:1.30
	gdb_7_2-branch:1.30.0.2
	gdb_7_2-2010-07-07-branchpoint:1.30
	gdb_7_1-2010-03-18-release:1.28
	gdb_7_1-branch:1.28.0.2
	gdb_7_1-2010-02-18-branchpoint:1.28
	gdb_7_0_1-2009-12-22-release:1.26
	gdb_7_0-2009-10-06-release:1.26
	gdb_7_0-branch:1.26.0.4
	gdb_7_0-2009-09-16-branchpoint:1.26
	msnyder-checkpoint-072509-branch:1.26.0.2
	msnyder-checkpoint-072509-branchpoint:1.26
	reverse-20081226-branch:1.13.0.4
	reverse-20081226-branchpoint:1.13
	multiprocess-20081120-branch:1.13.0.2
	multiprocess-20081120-branchpoint:1.13
	gdb_6_1_1-20040616-release:1.7
	gdb_6_1-2004-04-05-release:1.7
	drow_intercu-merge-20040402:1.7
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.20
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.18
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.16
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.14
	drow_intercu-20040221-branchpoint:1.7
	cagney_bfdfile-20040213-branch:1.7.0.12
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.7
	cagney_bigcore-20040122-branch:1.7.0.10
	cagney_bigcore-20040122-branchpoint:1.7
	drow-cplus-merge-20040113:1.7
	drow-cplus-merge-20031224:1.7
	drow-cplus-merge-20031220:1.7
	carlton_dictionary-20031215-merge:1.7
	drow-cplus-merge-20031214:1.7
	carlton-dictionary-20031111-merge:1.7
	gdb_6_0-2003-10-04-release:1.7
	kettenis_sparc-20030918-branch:1.7.0.8
	kettenis_sparc-20030918-branchpoint:1.7
	carlton_dictionary-20030917-merge:1.7
	ezannoni_pie-20030916-branchpoint:1.7
	ezannoni_pie-20030916-branch:1.7.0.6
	cagney_x86i386-20030821-branch:1.7.0.4
	cagney_x86i386-20030821-branchpoint:1.7
	carlton_dictionary-20030805-merge:1.7
	carlton_dictionary-20030627-merge:1.7
	gdb_6_0-branch:1.7.0.2
	gdb_6_0-2003-06-23-branchpoint:1.7
	jimb-ppc64-linux-20030613-branch:1.6.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.30
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.28
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.24
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.20
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.18
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.16
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.14
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.12
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.10
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.8
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.6
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030203-mergepoint:1.6
	interps-20030202-branch:1.6.0.4
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.2
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.4.6.1
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.4
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.2
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.4.0.6
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.4
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.2
	readline_4_3-import-branchpoint:1.4
	kseitz_interps-20020528-branch:1.1.0.4
	cagney_regbuf-20020515-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.60
date	2013.09.17.18.26.39;	author palves;	state Exp;
branches;
next	1.59;

1.59
date	2013.08.30.15.28.40;	author palves;	state Exp;
branches;
next	1.58;

1.58
date	2013.04.19.15.35.58;	author palves;	state Exp;
branches;
next	1.57;

1.57
date	2013.04.08.19.59.08;	author tromey;	state Exp;
branches;
next	1.56;

1.56
date	2013.01.01.06.32.37;	author brobecke;	state Exp;
branches;
next	1.55;

1.55
date	2012.11.09.19.57.57;	author tromey;	state Exp;
branches;
next	1.54;

1.54
date	2012.05.18.21.02.46;	author sergiodj;	state Exp;
branches;
next	1.53;

1.53
date	2012.02.28.16.30.42;	author brobecke;	state Exp;
branches;
next	1.52;

1.52
date	2012.02.23.11.15.06;	author gingold;	state Exp;
branches;
next	1.51;

1.51
date	2012.01.04.08.16.55;	author brobecke;	state Exp;
branches;
next	1.50;

1.50
date	2011.10.21.18.46.05;	author brobecke;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2011.10.05.07.41.13;	author gingold;	state Exp;
branches;
next	1.48;

1.48
date	2011.10.03.21.38.39;	author brobecke;	state Exp;
branches;
next	1.47;

1.47
date	2011.10.03.21.38.31;	author brobecke;	state Exp;
branches;
next	1.46;

1.46
date	2011.09.16.19.09.56;	author brobecke;	state Exp;
branches;
next	1.45;

1.45
date	2011.09.16.19.09.43;	author brobecke;	state Exp;
branches;
next	1.44;

1.44
date	2011.09.16.19.09.34;	author brobecke;	state Exp;
branches;
next	1.43;

1.43
date	2011.09.16.19.09.26;	author brobecke;	state Exp;
branches;
next	1.42;

1.42
date	2011.09.16.19.09.17;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2011.09.16.19.09.07;	author brobecke;	state Exp;
branches;
next	1.40;

1.40
date	2011.09.16.19.08.50;	author brobecke;	state Exp;
branches;
next	1.39;

1.39
date	2011.07.04.19.32.07;	author brobecke;	state Exp;
branches;
next	1.38;

1.38
date	2011.07.04.19.31.49;	author brobecke;	state Exp;
branches;
next	1.37;

1.37
date	2011.03.17.13.19.23;	author brobecke;	state Exp;
branches;
next	1.36;

1.36
date	2011.01.07.19.36.14;	author msnyder;	state Exp;
branches;
next	1.35;

1.35
date	2011.01.06.14.43.37;	author brobecke;	state Exp;
branches;
next	1.34;

1.34
date	2011.01.01.15.32.56;	author brobecke;	state Exp;
branches;
next	1.33;

1.33
date	2010.11.23.01.04.54;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2010.09.28.21.39.03;	author brobecke;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.22.22.50.54;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2010.05.06.23.36.39;	author msnyder;	state Exp;
branches;
next	1.29;

1.29
date	2010.03.16.18.47.15;	author brobecke;	state Exp;
branches;
next	1.28;

1.28
date	2010.01.01.07.31.29;	author brobecke;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.01.06.06.48;	author brobecke;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.02.17.21.05;	author uweigand;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.29.13.24.41;	author uweigand;	state Exp;
branches;
next	1.24;

1.24
date	2009.06.17.18.44.23;	author uweigand;	state Exp;
branches;
next	1.23;

1.23
date	2009.05.28.00.53.51;	author tromey;	state Exp;
branches;
next	1.22;

1.22
date	2009.04.23.18.55.20;	author brobecke;	state Exp;
branches;
next	1.21;

1.21
date	2009.03.31.16.44.17;	author brobecke;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.31.16.31.23;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.13.01.51.17;	author brobecke;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.12.22.53.38;	author brobecke;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.03.02.10.08;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2009.02.21.16.14.47;	author palves;	state Exp;
branches;
next	1.15;

1.15
date	2009.02.14.15.24.42;	author vprus;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.03.05.57.50;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2008.10.23.15.42.19;	author jkratoch;	state Exp;
branches;
next	1.12;

1.12
date	2008.10.22.19.45.05;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.09.19.36.17;	author hilfingr;	state dead;
branches;
next	1.10;

1.10
date	2004.06.16.08.18.06;	author hilfingr;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.02.09.55.36;	author hilfingr;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.28.16.36.25;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.17.20.58.32;	author ciceron;	state Exp;
branches
	1.7.14.1;
next	1.6;

1.6
date	2002.11.29.19.15.14;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.08.17.43.40;	author aidan;	state Exp;
branches
	1.5.2.1
	1.5.4.1;
next	1.4;

1.4
date	2002.08.18.18.07.22;	author aidan;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	2002.07.20.16.08.19;	author aidan;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.13.12.24.05;	author aidan;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.04.15.28.48;	author aidan;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.50.2.1
date	2012.01.06.04.43.03;	author brobecke;	state Exp;
branches;
next	;

1.7.14.1
date	2004.09.16.17.00.52;	author drow;	state dead;
branches;
next	;

1.5.2.1
date	2002.12.23.19.38.11;	author carlton;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2003.06.27.21.49.44;	author carlton;	state Exp;
branches;
next	;

1.5.4.1
date	2003.12.14.20.27.04;	author drow;	state Exp;
branches;
next	;

1.4.6.1
date	2002.09.18.22.54.11;	author cagney;	state Exp;
branches;
next	;

1.1.2.1
date	2002.06.15.16.42.50;	author cagney;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.06.21.16.46.51;	author cagney;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.06.25.20.02.37;	author cagney;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.06.28.23.19.25;	author cagney;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2002.07.03.18.43.57;	author cagney;	state Exp;
branches;
next	;

1.1.4.1
date	2002.06.20.01.32.08;	author kseitz;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.07.22.21.46.55;	author kseitz;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.08.30.22.52.42;	author kseitz;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2002.10.01.00.46.01;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.60
log
@PR gdb/15911: "info threads" changes the default source and line (for "break", "list")

"info threads" changes the default source for "break" and "list", to
whatever the location of the first/bottom thread in the thread list
is...

 (gdb) b start
 (gdb) c
 ...
 (gdb) list
 *lists "start"*
 (gdb) b 23
 Breakpoint 3 at 0x400614: file test.c, line 23.
 (gdb) info threads
   Id   Target Id         Frame
 * 2    Thread 0x7ffff7fcb700 (LWP 1760) "test" start (arg=0x0) at test.c:23
   1    Thread 0x7ffff7fcc740 (LWP 1748) "test" 0x000000323dc08e60 in pthread_join (threadid=140737353922304, thread_return=0x0) at pthread_join.c:93
 (gdb) b 23
 Breakpoint 4 at 0x323dc08d90: file pthread_join.c, line 23.
                                    ^^^^^^^^^^^^^^^
 (gdb) list
 93          lll_wait_tid (pd->tid);
 94
 95
 96        /* Restore cancellation mode.  */
 97        CANCEL_RESET (oldtype);
 98
 99        /* Remove the handler.  */
 100       pthread_cleanup_pop (0);
 101
 102

The issue is that print_stack_frame always sets the current sal to the
frame's sal.  print_frame_info (which print_stack_frame calls to do
most of the work) also sets the last displayed sal, but only if
print_what isn't LOCATION.  Now the call in question, from within
thread.c:print_thread_info, does pass in LOCATION as print_what, but
print_stack_frame doesn't have the same check print_frame_info has.
We could consider adding it, but setting these globals depending on
print_what isn't very clean, IMO.  What we have is two logically
distinct operations mixed in the same function(s):

  #1 - print frame, in the format specified by {print_what,
    print_level and print_args}.

  #2 - We're displaying a frame to the user, and I want the default
    sal to point here, because the program stopped here, or the user
    did some context-changing command (up, down, etc.).

So I added a new parameter to print_stack_frame & friends for point
#2, and went through all calls in the tree adjusting as necessary.

Tested on x86_64 Fedora 17.

gdb/
2013-09-17  Pedro Alves  <palves@@redhat.com>

	PR gdb/15911
	* ada-tasks.c (task_command_1): Adjust call to print_stack_frame.
	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd):
	* corelow.c (core_open):
	* frame.h (print_stack_frame, print_frame_info): New
	'set_current_sal' parameter.
	* infcmd.c (finish_command, kill_command): Adjust call to
	print_stack_frame.
	* inferior.c (inferior_command): Likewise.
	* infrun.c (normal_stop): Likewise.
	* linux-fork.c (linux_fork_context): Likewise.
	* record-full.c (record_full_goto_entry, record_full_restore):
	Likewise.
	* remote-mips.c (common_open): Likewise.
	* stack.c (print_stack_frame): New 'set_current_sal' parameter.
	Use it.
	(print_frame_info): New 'set_current_sal' parameter.  Set the last
	displayed sal depending on the new paremeter instead of looking at
	print_what.
	(backtrace_command_1, select_and_print_frame, frame_command)
	(current_frame_command, up_command, down_command): Adjust call to
	print_stack_frame.
	* thread.c (print_thread_info, restore_selected_frame)
	(do_captured_thread_select): Adjust call to print_stack_frame.
	* tracepoint.c (tfind_1): Likewise.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_frame): Likewise.
	* mi/mi-interp.c (mi_on_normal_stop): Likewise.
	* mi/mi-main.c (mi_cmd_exec_return, mi_cmd_trace_find): Likewise.

	gdb/testsuite/
	* gdb.threads/info-threads-cur-sal-2.c: New file.
	* gdb.threads/info-threads-cur-sal.c: New file.
	* gdb.threads/info-threads-cur-sal.exp: New file.
@
text
@/* Copyright (C) 1992-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "observer.h"
#include "gdbcmd.h"
#include "target.h"
#include "ada-lang.h"
#include "gdbcore.h"
#include "inferior.h"
#include "gdbthread.h"
#include "progspace.h"
#include "objfiles.h"

/* The name of the array in the GNAT runtime where the Ada Task Control
   Block of each task is stored.  */
#define KNOWN_TASKS_NAME "system__tasking__debug__known_tasks"

/* The maximum number of tasks known to the Ada runtime.  */
static const int MAX_NUMBER_OF_KNOWN_TASKS = 1000;

/* The name of the variable in the GNAT runtime where the head of a task
   chain is saved.  This is an alternate mechanism to find the list of known
   tasks.  */
#define KNOWN_TASKS_LIST "system__tasking__debug__first_task"

enum task_states
{
  Unactivated,
  Runnable,
  Terminated,
  Activator_Sleep,
  Acceptor_Sleep,
  Entry_Caller_Sleep,
  Async_Select_Sleep,
  Delay_Sleep,
  Master_Completion_Sleep,
  Master_Phase_2_Sleep,
  Interrupt_Server_Idle_Sleep,
  Interrupt_Server_Blocked_Interrupt_Sleep,
  Timer_Server_Sleep,
  AST_Server_Sleep,
  Asynchronous_Hold,
  Interrupt_Server_Blocked_On_Event_Flag,
  Activating,
  Acceptor_Delay_Sleep
};

/* A short description corresponding to each possible task state.  */
static const char *task_states[] = {
  N_("Unactivated"),
  N_("Runnable"),
  N_("Terminated"),
  N_("Child Activation Wait"),
  N_("Accept or Select Term"),
  N_("Waiting on entry call"),
  N_("Async Select Wait"),
  N_("Delay Sleep"),
  N_("Child Termination Wait"),
  N_("Wait Child in Term Alt"),
  "",
  "",
  "",
  "",
  N_("Asynchronous Hold"),
  "",
  N_("Activating"),
  N_("Selective Wait")
};

/* A longer description corresponding to each possible task state.  */
static const char *long_task_states[] = {
  N_("Unactivated"),
  N_("Runnable"),
  N_("Terminated"),
  N_("Waiting for child activation"),
  N_("Blocked in accept or select with terminate"),
  N_("Waiting on entry call"),
  N_("Asynchronous Selective Wait"),
  N_("Delay Sleep"),
  N_("Waiting for children termination"),
  N_("Waiting for children in terminate alternative"),
  "",
  "",
  "",
  "",
  N_("Asynchronous Hold"),
  "",
  N_("Activating"),
  N_("Blocked in selective wait statement")
};

/* The index of certain important fields in the Ada Task Control Block
   record and sub-records.  */

struct atcb_fieldnos
{
  /* Fields in record Ada_Task_Control_Block.  */
  int common;
  int entry_calls;
  int atc_nesting_level;

  /* Fields in record Common_ATCB.  */
  int state;
  int parent;
  int priority;
  int image;
  int image_len;     /* This field may be missing.  */
  int activation_link;
  int call;
  int ll;

  /* Fields in Task_Primitives.Private_Data.  */
  int ll_thread;
  int ll_lwp;        /* This field may be missing.  */

  /* Fields in Common_ATCB.Call.all.  */
  int call_self;
};

/* This module's per-program-space data.  */

struct ada_tasks_pspace_data
{
  /* Nonzero if the data has been initialized.  If set to zero,
     it means that the data has either not been initialized, or
     has potentially become stale.  */
  int initialized_p;

  /* The ATCB record type.  */
  struct type *atcb_type;

  /* The ATCB "Common" component type.  */
  struct type *atcb_common_type;

  /* The type of the "ll" field, from the atcb_common_type.  */
  struct type *atcb_ll_type;

  /* The type of the "call" field, from the atcb_common_type.  */
  struct type *atcb_call_type;

  /* The index of various fields in the ATCB record and sub-records.  */
  struct atcb_fieldnos atcb_fieldno;
};

/* Key to our per-program-space data.  */
static const struct program_space_data *ada_tasks_pspace_data_handle;

typedef struct ada_task_info ada_task_info_s;
DEF_VEC_O(ada_task_info_s);

/* The kind of data structure used by the runtime to store the list
   of Ada tasks.  */

enum ada_known_tasks_kind
{
  /* Use this value when we haven't determined which kind of structure
     is being used, or when we need to recompute it.

     We set the value of this enumerate to zero on purpose: This allows
     us to use this enumerate in a structure where setting all fields
     to zero will result in this kind being set to unknown.  */
  ADA_TASKS_UNKNOWN = 0,

  /* This value means that we did not find any task list.  Unless
     there is a bug somewhere, this means that the inferior does not
     use tasking.  */
  ADA_TASKS_NOT_FOUND,

  /* This value means that the task list is stored as an array.
     This is the usual method, as it causes very little overhead.
     But this method is not always used, as it does use a certain
     amount of memory, which might be scarse in certain environments.  */
  ADA_TASKS_ARRAY,

  /* This value means that the task list is stored as a linked list.
     This has more runtime overhead than the array approach, but
     also require less memory when the number of tasks is small.  */
  ADA_TASKS_LIST,
};

/* This module's per-inferior data.  */

struct ada_tasks_inferior_data
{
  /* The type of data structure used by the runtime to store
     the list of Ada tasks.  The value of this field influences
     the interpretation of the known_tasks_addr field below:
       - ADA_TASKS_UNKNOWN: The value of known_tasks_addr hasn't
         been determined yet;
       - ADA_TASKS_NOT_FOUND: The program probably does not use tasking
         and the known_tasks_addr is irrelevant;
       - ADA_TASKS_ARRAY: The known_tasks is an array;
       - ADA_TASKS_LIST: The known_tasks is a list.  */
  enum ada_known_tasks_kind known_tasks_kind;

  /* The address of the known_tasks structure.  This is where
     the runtime stores the information for all Ada tasks.
     The interpretation of this field depends on KNOWN_TASKS_KIND
     above.  */
  CORE_ADDR known_tasks_addr;

  /* Type of elements of the known task.  Usually a pointer.  */
  struct type *known_tasks_element;

  /* Number of elements in the known tasks array.  */
  unsigned int known_tasks_length;

  /* When nonzero, this flag indicates that the task_list field
     below is up to date.  When set to zero, the list has either
     not been initialized, or has potentially become stale.  */
  int task_list_valid_p;

  /* The list of Ada tasks.

     Note: To each task we associate a number that the user can use to
     reference it - this number is printed beside each task in the tasks
     info listing displayed by "info tasks".  This number is equal to
     its index in the vector + 1.  Reciprocally, to compute the index
     of a task in the vector, we need to substract 1 from its number.  */
  VEC(ada_task_info_s) *task_list;
};

/* Key to our per-inferior data.  */
static const struct inferior_data *ada_tasks_inferior_data_handle;

/* Return the ada-tasks module's data for the given program space (PSPACE).
   If none is found, add a zero'ed one now.

   This function always returns a valid object.  */

static struct ada_tasks_pspace_data *
get_ada_tasks_pspace_data (struct program_space *pspace)
{
  struct ada_tasks_pspace_data *data;

  data = program_space_data (pspace, ada_tasks_pspace_data_handle);
  if (data == NULL)
    {
      data = XZALLOC (struct ada_tasks_pspace_data);
      set_program_space_data (pspace, ada_tasks_pspace_data_handle, data);
    }

  return data;
}

/* Return the ada-tasks module's data for the given inferior (INF).
   If none is found, add a zero'ed one now.

   This function always returns a valid object.

   Note that we could use an observer of the inferior-created event
   to make sure that the ada-tasks per-inferior data always exists.
   But we prefered this approach, as it avoids this entirely as long
   as the user does not use any of the tasking features.  This is
   quite possible, particularly in the case where the inferior does
   not use tasking.  */

static struct ada_tasks_inferior_data *
get_ada_tasks_inferior_data (struct inferior *inf)
{
  struct ada_tasks_inferior_data *data;

  data = inferior_data (inf, ada_tasks_inferior_data_handle);
  if (data == NULL)
    {
      data = XZALLOC (struct ada_tasks_inferior_data);
      set_inferior_data (inf, ada_tasks_inferior_data_handle, data);
    }

  return data;
}

/* Return the task number of the task whose ptid is PTID, or zero
   if the task could not be found.  */

int
ada_get_task_number (ptid_t ptid)
{
  int i;
  struct inferior *inf = find_inferior_pid (ptid_get_pid (ptid));
  struct ada_tasks_inferior_data *data;

  gdb_assert (inf != NULL);
  data = get_ada_tasks_inferior_data (inf);

  for (i = 0; i < VEC_length (ada_task_info_s, data->task_list); i++)
    if (ptid_equal (VEC_index (ada_task_info_s, data->task_list, i)->ptid,
		    ptid))
      return i + 1;

  return 0;  /* No matching task found.  */
}

/* Return the task number of the task running in inferior INF which
   matches TASK_ID , or zero if the task could not be found.  */
 
static int
get_task_number_from_id (CORE_ADDR task_id, struct inferior *inf)
{
  struct ada_tasks_inferior_data *data = get_ada_tasks_inferior_data (inf);
  int i;

  for (i = 0; i < VEC_length (ada_task_info_s, data->task_list); i++)
    {
      struct ada_task_info *task_info =
        VEC_index (ada_task_info_s, data->task_list, i);

      if (task_info->task_id == task_id)
        return i + 1;
    }

  /* Task not found.  Return 0.  */
  return 0;
}

/* Return non-zero if TASK_NUM is a valid task number.  */

int
valid_task_id (int task_num)
{
  struct ada_tasks_inferior_data *data;

  ada_build_task_list ();
  data = get_ada_tasks_inferior_data (current_inferior ());
  return (task_num > 0
          && task_num <= VEC_length (ada_task_info_s, data->task_list));
}

/* Return non-zero iff the task STATE corresponds to a non-terminated
   task state.  */

static int
ada_task_is_alive (struct ada_task_info *task_info)
{
  return (task_info->state != Terminated);
}

/* Call the ITERATOR function once for each Ada task that hasn't been
   terminated yet.  */

void
iterate_over_live_ada_tasks (ada_task_list_iterator_ftype *iterator)
{
  int i, nb_tasks;
  struct ada_task_info *task;
  struct ada_tasks_inferior_data *data;

  ada_build_task_list ();
  data = get_ada_tasks_inferior_data (current_inferior ());
  nb_tasks = VEC_length (ada_task_info_s, data->task_list);

  for (i = 0; i < nb_tasks; i++)
    {
      task = VEC_index (ada_task_info_s, data->task_list, i);
      if (!ada_task_is_alive (task))
        continue;
      iterator (task);
    }
}

/* Extract the contents of the value as a string whose length is LENGTH,
   and store the result in DEST.  */

static void
value_as_string (char *dest, struct value *val, int length)
{
  memcpy (dest, value_contents (val), length);
  dest[length] = '\0';
}

/* Extract the string image from the fat string corresponding to VAL,
   and store it in DEST.  If the string length is greater than MAX_LEN,
   then truncate the result to the first MAX_LEN characters of the fat
   string.  */

static void
read_fat_string_value (char *dest, struct value *val, int max_len)
{
  struct value *array_val;
  struct value *bounds_val;
  int len;

  /* The following variables are made static to avoid recomputing them
     each time this function is called.  */
  static int initialize_fieldnos = 1;
  static int array_fieldno;
  static int bounds_fieldno;
  static int upper_bound_fieldno;

  /* Get the index of the fields that we will need to read in order
     to extract the string from the fat string.  */
  if (initialize_fieldnos)
    {
      struct type *type = value_type (val);
      struct type *bounds_type;

      array_fieldno = ada_get_field_index (type, "P_ARRAY", 0);
      bounds_fieldno = ada_get_field_index (type, "P_BOUNDS", 0);

      bounds_type = TYPE_FIELD_TYPE (type, bounds_fieldno);
      if (TYPE_CODE (bounds_type) == TYPE_CODE_PTR)
        bounds_type = TYPE_TARGET_TYPE (bounds_type);
      if (TYPE_CODE (bounds_type) != TYPE_CODE_STRUCT)
        error (_("Unknown task name format. Aborting"));
      upper_bound_fieldno = ada_get_field_index (bounds_type, "UB0", 0);

      initialize_fieldnos = 0;
    }

  /* Get the size of the task image by checking the value of the bounds.
     The lower bound is always 1, so we only need to read the upper bound.  */
  bounds_val = value_ind (value_field (val, bounds_fieldno));
  len = value_as_long (value_field (bounds_val, upper_bound_fieldno));

  /* Make sure that we do not read more than max_len characters...  */
  if (len > max_len)
    len = max_len;

  /* Extract LEN characters from the fat string.  */
  array_val = value_ind (value_field (val, array_fieldno));
  read_memory (value_address (array_val), (gdb_byte *) dest, len);

  /* Add the NUL character to close the string.  */
  dest[len] = '\0';
}

/* Get from the debugging information the type description of all types
   related to the Ada Task Control Block that will be needed in order to
   read the list of known tasks in the Ada runtime.  Also return the
   associated ATCB_FIELDNOS.

   Error handling:  Any data missing from the debugging info will cause
   an error to be raised, and none of the return values to be set.
   Users of this function can depend on the fact that all or none of the
   return values will be set.  */

static void
get_tcb_types_info (void)
{
  struct type *type;
  struct type *common_type;
  struct type *ll_type;
  struct type *call_type;
  struct atcb_fieldnos fieldnos;
  struct ada_tasks_pspace_data *pspace_data;

  const char *atcb_name = "system__tasking__ada_task_control_block___XVE";
  const char *atcb_name_fixed = "system__tasking__ada_task_control_block";
  const char *common_atcb_name = "system__tasking__common_atcb";
  const char *private_data_name = "system__task_primitives__private_data";
  const char *entry_call_record_name = "system__tasking__entry_call_record";

  /* ATCB symbols may be found in several compilation units.  As we
     are only interested in one instance, use standard (literal,
     C-like) lookups to get the first match.  */

  struct symbol *atcb_sym =
    lookup_symbol_in_language (atcb_name, NULL, VAR_DOMAIN,
			       language_c, NULL);
  const struct symbol *common_atcb_sym =
    lookup_symbol_in_language (common_atcb_name, NULL, VAR_DOMAIN,
			       language_c, NULL);
  const struct symbol *private_data_sym =
    lookup_symbol_in_language (private_data_name, NULL, VAR_DOMAIN,
			       language_c, NULL);
  const struct symbol *entry_call_record_sym =
    lookup_symbol_in_language (entry_call_record_name, NULL, VAR_DOMAIN,
			       language_c, NULL);

  if (atcb_sym == NULL || atcb_sym->type == NULL)
    {
      /* In Ravenscar run-time libs, the  ATCB does not have a dynamic
         size, so the symbol name differs.  */
      atcb_sym = lookup_symbol_in_language (atcb_name_fixed, NULL, VAR_DOMAIN,
					    language_c, NULL);

      if (atcb_sym == NULL || atcb_sym->type == NULL)
        error (_("Cannot find Ada_Task_Control_Block type. Aborting"));

      type = atcb_sym->type;
    }
  else
    {
      /* Get a static representation of the type record
         Ada_Task_Control_Block.  */
      type = atcb_sym->type;
      type = ada_template_to_fixed_record_type_1 (type, NULL, 0, NULL, 0);
    }

  if (common_atcb_sym == NULL || common_atcb_sym->type == NULL)
    error (_("Cannot find Common_ATCB type. Aborting"));
  if (private_data_sym == NULL || private_data_sym->type == NULL)
    error (_("Cannot find Private_Data type. Aborting"));
  if (entry_call_record_sym == NULL || entry_call_record_sym->type == NULL)
    error (_("Cannot find Entry_Call_Record type. Aborting"));

  /* Get the type for Ada_Task_Control_Block.Common.  */
  common_type = common_atcb_sym->type;

  /* Get the type for Ada_Task_Control_Bloc.Common.Call.LL.  */
  ll_type = private_data_sym->type;

  /* Get the type for Common_ATCB.Call.all.  */
  call_type = entry_call_record_sym->type;

  /* Get the field indices.  */
  fieldnos.common = ada_get_field_index (type, "common", 0);
  fieldnos.entry_calls = ada_get_field_index (type, "entry_calls", 1);
  fieldnos.atc_nesting_level =
    ada_get_field_index (type, "atc_nesting_level", 1);
  fieldnos.state = ada_get_field_index (common_type, "state", 0);
  fieldnos.parent = ada_get_field_index (common_type, "parent", 1);
  fieldnos.priority = ada_get_field_index (common_type, "base_priority", 0);
  fieldnos.image = ada_get_field_index (common_type, "task_image", 1);
  fieldnos.image_len = ada_get_field_index (common_type, "task_image_len", 1);
  fieldnos.activation_link = ada_get_field_index (common_type,
                                                  "activation_link", 1);
  fieldnos.call = ada_get_field_index (common_type, "call", 1);
  fieldnos.ll = ada_get_field_index (common_type, "ll", 0);
  fieldnos.ll_thread = ada_get_field_index (ll_type, "thread", 0);
  fieldnos.ll_lwp = ada_get_field_index (ll_type, "lwp", 1);
  fieldnos.call_self = ada_get_field_index (call_type, "self", 0);

  /* On certain platforms such as x86-windows, the "lwp" field has been
     named "thread_id".  This field will likely be renamed in the future,
     but we need to support both possibilities to avoid an unnecessary
     dependency on a recent compiler.  We therefore try locating the
     "thread_id" field in place of the "lwp" field if we did not find
     the latter.  */
  if (fieldnos.ll_lwp < 0)
    fieldnos.ll_lwp = ada_get_field_index (ll_type, "thread_id", 1);

  /* Set all the out parameters all at once, now that we are certain
     that there are no potential error() anymore.  */
  pspace_data = get_ada_tasks_pspace_data (current_program_space);
  pspace_data->initialized_p = 1;
  pspace_data->atcb_type = type;
  pspace_data->atcb_common_type = common_type;
  pspace_data->atcb_ll_type = ll_type;
  pspace_data->atcb_call_type = call_type;
  pspace_data->atcb_fieldno = fieldnos;
}

/* Build the PTID of the task from its COMMON_VALUE, which is the "Common"
   component of its ATCB record.  This PTID needs to match the PTID used
   by the thread layer.  */

static ptid_t
ptid_from_atcb_common (struct value *common_value)
{
  long thread = 0;
  CORE_ADDR lwp = 0;
  struct value *ll_value;
  ptid_t ptid;
  const struct ada_tasks_pspace_data *pspace_data
    = get_ada_tasks_pspace_data (current_program_space);

  ll_value = value_field (common_value, pspace_data->atcb_fieldno.ll);

  if (pspace_data->atcb_fieldno.ll_lwp >= 0)
    lwp = value_as_address (value_field (ll_value,
					 pspace_data->atcb_fieldno.ll_lwp));
  thread = value_as_long (value_field (ll_value,
				       pspace_data->atcb_fieldno.ll_thread));

  ptid = target_get_ada_task_ptid (lwp, thread);

  return ptid;
}

/* Read the ATCB data of a given task given its TASK_ID (which is in practice
   the address of its assocated ATCB record), and store the result inside
   TASK_INFO.  */

static void
read_atcb (CORE_ADDR task_id, struct ada_task_info *task_info)
{
  struct value *tcb_value;
  struct value *common_value;
  struct value *atc_nesting_level_value;
  struct value *entry_calls_value;
  struct value *entry_calls_value_element;
  int called_task_fieldno = -1;
  static const char ravenscar_task_name[] = "Ravenscar task";
  const struct ada_tasks_pspace_data *pspace_data
    = get_ada_tasks_pspace_data (current_program_space);

  if (!pspace_data->initialized_p)
    get_tcb_types_info ();

  tcb_value = value_from_contents_and_address (pspace_data->atcb_type,
					       NULL, task_id);
  common_value = value_field (tcb_value, pspace_data->atcb_fieldno.common);

  /* Fill in the task_id.  */

  task_info->task_id = task_id;

  /* Compute the name of the task.

     Depending on the GNAT version used, the task image is either a fat
     string, or a thin array of characters.  Older versions of GNAT used
     to use fat strings, and therefore did not need an extra field in
     the ATCB to store the string length.  For efficiency reasons, newer
     versions of GNAT replaced the fat string by a static buffer, but this
     also required the addition of a new field named "Image_Len" containing
     the length of the task name.  The method used to extract the task name
     is selected depending on the existence of this field.

     In some run-time libs (e.g. Ravenscar), the name is not in the ATCB;
     we may want to get it from the first user frame of the stack.  For now,
     we just give a dummy name.  */

  if (pspace_data->atcb_fieldno.image_len == -1)
    {
      if (pspace_data->atcb_fieldno.image >= 0)
        read_fat_string_value (task_info->name,
                               value_field (common_value,
					    pspace_data->atcb_fieldno.image),
                               sizeof (task_info->name) - 1);
      else
	{
	  struct bound_minimal_symbol msym;

	  msym = lookup_minimal_symbol_by_pc (task_id);
	  if (msym.minsym)
	    {
	      const char *full_name = SYMBOL_LINKAGE_NAME (msym.minsym);
	      const char *task_name = full_name;
	      const char *p;

	      /* Strip the prefix.  */
	      for (p = full_name; *p; p++)
		if (p[0] == '_' && p[1] == '_')
		  task_name = p + 2;

	      /* Copy the task name.  */
	      strncpy (task_info->name, task_name, sizeof (task_info->name));
	      task_info->name[sizeof (task_info->name) - 1] = 0;
	    }
	  else
	    {
	      /* No symbol found.  Use a default name.  */
	      strcpy (task_info->name, ravenscar_task_name);
	    }
	}
    }
  else
    {
      int len = value_as_long
		  (value_field (common_value,
				pspace_data->atcb_fieldno.image_len));

      value_as_string (task_info->name,
                       value_field (common_value,
				    pspace_data->atcb_fieldno.image),
		       len);
    }

  /* Compute the task state and priority.  */

  task_info->state =
    value_as_long (value_field (common_value,
				pspace_data->atcb_fieldno.state));
  task_info->priority =
    value_as_long (value_field (common_value,
				pspace_data->atcb_fieldno.priority));

  /* If the ATCB contains some information about the parent task,
     then compute it as well.  Otherwise, zero.  */

  if (pspace_data->atcb_fieldno.parent >= 0)
    task_info->parent =
      value_as_address (value_field (common_value,
				     pspace_data->atcb_fieldno.parent));
  else
    task_info->parent = 0;
  

  /* If the ATCB contains some information about entry calls, then
     compute the "called_task" as well.  Otherwise, zero.  */

  if (pspace_data->atcb_fieldno.atc_nesting_level > 0
      && pspace_data->atcb_fieldno.entry_calls > 0)
    {
      /* Let My_ATCB be the Ada task control block of a task calling the
         entry of another task; then the Task_Id of the called task is
         in My_ATCB.Entry_Calls (My_ATCB.ATC_Nesting_Level).Called_Task.  */
      atc_nesting_level_value =
        value_field (tcb_value, pspace_data->atcb_fieldno.atc_nesting_level);
      entry_calls_value =
        ada_coerce_to_simple_array_ptr
	  (value_field (tcb_value, pspace_data->atcb_fieldno.entry_calls));
      entry_calls_value_element =
        value_subscript (entry_calls_value,
			 value_as_long (atc_nesting_level_value));
      called_task_fieldno =
        ada_get_field_index (value_type (entry_calls_value_element),
                             "called_task", 0);
      task_info->called_task =
        value_as_address (value_field (entry_calls_value_element,
                                       called_task_fieldno));
    }
  else
    {
      task_info->called_task = 0;
    }

  /* If the ATCB cotnains some information about RV callers,
     then compute the "caller_task".  Otherwise, zero.  */

  task_info->caller_task = 0;
  if (pspace_data->atcb_fieldno.call >= 0)
    {
      /* Get the ID of the caller task from Common_ATCB.Call.all.Self.
         If Common_ATCB.Call is null, then there is no caller.  */
      const CORE_ADDR call =
        value_as_address (value_field (common_value,
				       pspace_data->atcb_fieldno.call));
      struct value *call_val;

      if (call != 0)
        {
          call_val =
            value_from_contents_and_address (pspace_data->atcb_call_type,
					     NULL, call);
          task_info->caller_task =
            value_as_address
	      (value_field (call_val, pspace_data->atcb_fieldno.call_self));
        }
    }

  /* And finally, compute the task ptid.  Note that there are situations
     where this cannot be determined:
       - The task is no longer alive - the ptid is irrelevant;
       - We are debugging a core file - the thread is not always
         completely preserved for us to link back a task to its
         underlying thread.  Since we do not support task switching
         when debugging core files anyway, we don't need to compute
         that task ptid.
     In either case, we don't need that ptid, and it is just good enough
     to set it to null_ptid.  */

  if (target_has_execution && ada_task_is_alive (task_info))
    task_info->ptid = ptid_from_atcb_common (common_value);
  else
    task_info->ptid = null_ptid;
}

/* Read the ATCB info of the given task (identified by TASK_ID), and
   add the result to the given inferior's TASK_LIST.  */

static void
add_ada_task (CORE_ADDR task_id, struct inferior *inf)
{
  struct ada_task_info task_info;
  struct ada_tasks_inferior_data *data = get_ada_tasks_inferior_data (inf);

  read_atcb (task_id, &task_info);
  VEC_safe_push (ada_task_info_s, data->task_list, &task_info);
}

/* Read the Known_Tasks array from the inferior memory, and store
   it in the current inferior's TASK_LIST.  Return non-zero upon success.  */

static int
read_known_tasks_array (struct ada_tasks_inferior_data *data)
{
  const int target_ptr_byte = TYPE_LENGTH (data->known_tasks_element);
  const int known_tasks_size = target_ptr_byte * data->known_tasks_length;
  gdb_byte *known_tasks = alloca (known_tasks_size);
  int i;

  /* Build a new list by reading the ATCBs from the Known_Tasks array
     in the Ada runtime.  */
  read_memory (data->known_tasks_addr, known_tasks, known_tasks_size);
  for (i = 0; i < data->known_tasks_length; i++)
    {
      CORE_ADDR task_id =
        extract_typed_address (known_tasks + i * target_ptr_byte,
			       data->known_tasks_element);

      if (task_id != 0)
        add_ada_task (task_id, current_inferior ());
    }

  return 1;
}

/* Read the known tasks from the inferior memory, and store it in
   the current inferior's TASK_LIST.  Return non-zero upon success.  */

static int
read_known_tasks_list (struct ada_tasks_inferior_data *data)
{
  const int target_ptr_byte = TYPE_LENGTH (data->known_tasks_element);
  gdb_byte *known_tasks = alloca (target_ptr_byte);
  CORE_ADDR task_id;
  const struct ada_tasks_pspace_data *pspace_data
    = get_ada_tasks_pspace_data (current_program_space);

  /* Sanity check.  */
  if (pspace_data->atcb_fieldno.activation_link < 0)
    return 0;

  /* Build a new list by reading the ATCBs.  Read head of the list.  */
  read_memory (data->known_tasks_addr, known_tasks, target_ptr_byte);
  task_id = extract_typed_address (known_tasks, data->known_tasks_element);
  while (task_id != 0)
    {
      struct value *tcb_value;
      struct value *common_value;

      add_ada_task (task_id, current_inferior ());

      /* Read the chain.  */
      tcb_value = value_from_contents_and_address (pspace_data->atcb_type,
						   NULL, task_id);
      common_value = value_field (tcb_value, pspace_data->atcb_fieldno.common);
      task_id = value_as_address
		  (value_field (common_value,
                                pspace_data->atcb_fieldno.activation_link));
    }

  return 1;
}

/* Set all fields of the current inferior ada-tasks data pointed by DATA.
   Do nothing if those fields are already set and still up to date.  */

static void
ada_tasks_inferior_data_sniffer (struct ada_tasks_inferior_data *data)
{
  struct minimal_symbol *msym;
  struct symbol *sym;

  /* Return now if already set.  */
  if (data->known_tasks_kind != ADA_TASKS_UNKNOWN)
    return;

  /* Try array.  */

  msym = lookup_minimal_symbol (KNOWN_TASKS_NAME, NULL, NULL);
  if (msym != NULL)
    {
      data->known_tasks_kind = ADA_TASKS_ARRAY;
      data->known_tasks_addr = SYMBOL_VALUE_ADDRESS (msym);

      /* Try to get pointer type and array length from the symtab.  */
      sym = lookup_symbol_in_language (KNOWN_TASKS_NAME, NULL, VAR_DOMAIN,
				       language_c, NULL);
      if (sym != NULL)
	{
	  /* Validate.  */
	  struct type *type = check_typedef (SYMBOL_TYPE (sym));
	  struct type *eltype = NULL;
	  struct type *idxtype = NULL;

	  if (TYPE_CODE (type) == TYPE_CODE_ARRAY)
	    eltype = check_typedef (TYPE_TARGET_TYPE (type));
	  if (eltype != NULL
	      && TYPE_CODE (eltype) == TYPE_CODE_PTR)
	    idxtype = check_typedef (TYPE_INDEX_TYPE (type));
	  if (idxtype != NULL
	      && !TYPE_LOW_BOUND_UNDEFINED (idxtype)
	      && !TYPE_HIGH_BOUND_UNDEFINED (idxtype))
	    {
	      data->known_tasks_element = eltype;
	      data->known_tasks_length =
		TYPE_HIGH_BOUND (idxtype) - TYPE_LOW_BOUND (idxtype) + 1;
	      return;
	    }
	}

      /* Fallback to default values.  The runtime may have been stripped (as
	 in some distributions), but it is likely that the executable still
	 contains debug information on the task type (due to implicit with of
	 Ada.Tasking).  */
      data->known_tasks_element =
	builtin_type (target_gdbarch ())->builtin_data_ptr;
      data->known_tasks_length = MAX_NUMBER_OF_KNOWN_TASKS;
      return;
    }


  /* Try list.  */

  msym = lookup_minimal_symbol (KNOWN_TASKS_LIST, NULL, NULL);
  if (msym != NULL)
    {
      data->known_tasks_kind = ADA_TASKS_LIST;
      data->known_tasks_addr = SYMBOL_VALUE_ADDRESS (msym);
      data->known_tasks_length = 1;

      sym = lookup_symbol_in_language (KNOWN_TASKS_LIST, NULL, VAR_DOMAIN,
				       language_c, NULL);
      if (sym != NULL && SYMBOL_VALUE_ADDRESS (sym) != 0)
	{
	  /* Validate.  */
	  struct type *type = check_typedef (SYMBOL_TYPE (sym));

	  if (TYPE_CODE (type) == TYPE_CODE_PTR)
	    {
	      data->known_tasks_element = type;
	      return;
	    }
	}

      /* Fallback to default values.  */
      data->known_tasks_element =
	builtin_type (target_gdbarch ())->builtin_data_ptr;
      data->known_tasks_length = 1;
      return;
    }

  /* Can't find tasks.  */

  data->known_tasks_kind = ADA_TASKS_NOT_FOUND;
  data->known_tasks_addr = 0;
}

/* Read the known tasks from the current inferior's memory, and store it
   in the current inferior's data TASK_LIST.
   Return non-zero upon success.  */

static int
read_known_tasks (void)
{
  struct ada_tasks_inferior_data *data =
    get_ada_tasks_inferior_data (current_inferior ());

  /* Step 1: Clear the current list, if necessary.  */
  VEC_truncate (ada_task_info_s, data->task_list, 0);

  /* Step 2: do the real work.
     If the application does not use task, then no more needs to be done.
     It is important to have the task list cleared (see above) before we
     return, as we don't want a stale task list to be used...  This can
     happen for instance when debugging a non-multitasking program after
     having debugged a multitasking one.  */
  ada_tasks_inferior_data_sniffer (data);
  gdb_assert (data->known_tasks_kind != ADA_TASKS_UNKNOWN);

  switch (data->known_tasks_kind)
    {
      case ADA_TASKS_NOT_FOUND: /* Tasking not in use in inferior.  */
        return 0;
      case ADA_TASKS_ARRAY:
        return read_known_tasks_array (data);
      case ADA_TASKS_LIST:
        return read_known_tasks_list (data);
    }

  /* Step 3: Set task_list_valid_p, to avoid re-reading the Known_Tasks
     array unless needed.  Then report a success.  */
  data->task_list_valid_p = 1;

  return 1;
}

/* Build the task_list by reading the Known_Tasks array from
   the inferior, and return the number of tasks in that list
   (zero means that the program is not using tasking at all).  */

int
ada_build_task_list (void)
{
  struct ada_tasks_inferior_data *data;

  if (!target_has_stack)
    error (_("Cannot inspect Ada tasks when program is not running"));

  data = get_ada_tasks_inferior_data (current_inferior ());
  if (!data->task_list_valid_p)
    read_known_tasks ();

  return VEC_length (ada_task_info_s, data->task_list);
}

/* Print a table providing a short description of all Ada tasks
   running inside inferior INF.  If ARG_STR is set, it will be
   interpreted as a task number, and the table will be limited to
   that task only.  */

void
print_ada_task_info (struct ui_out *uiout,
		     char *arg_str,
		     struct inferior *inf)
{
  struct ada_tasks_inferior_data *data;
  int taskno, nb_tasks;
  int taskno_arg = 0;
  struct cleanup *old_chain;
  int nb_columns;

  if (ada_build_task_list () == 0)
    {
      ui_out_message (uiout, 0,
		      _("Your application does not use any Ada tasks.\n"));
      return;
    }

  if (arg_str != NULL && arg_str[0] != '\0')
    taskno_arg = value_as_long (parse_and_eval (arg_str));

  if (ui_out_is_mi_like_p (uiout))
    /* In GDB/MI mode, we want to provide the thread ID corresponding
       to each task.  This allows clients to quickly find the thread
       associated to any task, which is helpful for commands that
       take a --thread argument.  However, in order to be able to
       provide that thread ID, the thread list must be up to date
       first.  */
    target_find_new_threads ();

  data = get_ada_tasks_inferior_data (inf);

  /* Compute the number of tasks that are going to be displayed
     in the output.  If an argument was given, there will be
     at most 1 entry.  Otherwise, there will be as many entries
     as we have tasks.  */
  if (taskno_arg)
    {
      if (taskno_arg > 0
	  && taskno_arg <= VEC_length (ada_task_info_s, data->task_list))
	nb_tasks = 1;
      else
	nb_tasks = 0;
    }
  else
    nb_tasks = VEC_length (ada_task_info_s, data->task_list);

  nb_columns = ui_out_is_mi_like_p (uiout) ? 8 : 7;
  old_chain = make_cleanup_ui_out_table_begin_end (uiout, nb_columns,
						   nb_tasks, "tasks");
  ui_out_table_header (uiout, 1, ui_left, "current", "");
  ui_out_table_header (uiout, 3, ui_right, "id", "ID");
  ui_out_table_header (uiout, 9, ui_right, "task-id", "TID");
  /* The following column is provided in GDB/MI mode only because
     it is only really useful in that mode, and also because it
     allows us to keep the CLI output shorter and more compact.  */
  if (ui_out_is_mi_like_p (uiout))
    ui_out_table_header (uiout, 4, ui_right, "thread-id", "");
  ui_out_table_header (uiout, 4, ui_right, "parent-id", "P-ID");
  ui_out_table_header (uiout, 3, ui_right, "priority", "Pri");
  ui_out_table_header (uiout, 22, ui_left, "state", "State");
  /* Use ui_noalign for the last column, to prevent the CLI uiout
     from printing an extra space at the end of each row.  This
     is a bit of a hack, but does get the job done.  */
  ui_out_table_header (uiout, 1, ui_noalign, "name", "Name");
  ui_out_table_body (uiout);

  for (taskno = 1;
       taskno <= VEC_length (ada_task_info_s, data->task_list);
       taskno++)
    {
      const struct ada_task_info *const task_info =
	VEC_index (ada_task_info_s, data->task_list, taskno - 1);
      int parent_id;
      struct cleanup *chain2;

      gdb_assert (task_info != NULL);

      /* If the user asked for the output to be restricted
	 to one task only, and this is not the task, skip
	 to the next one.  */
      if (taskno_arg && taskno != taskno_arg)
        continue;

      chain2 = make_cleanup_ui_out_tuple_begin_end (uiout, NULL);

      /* Print a star if this task is the current task (or the task
         currently selected).  */
      if (ptid_equal (task_info->ptid, inferior_ptid))
	ui_out_field_string (uiout, "current", "*");
      else
	ui_out_field_skip (uiout, "current");

      /* Print the task number.  */
      ui_out_field_int (uiout, "id", taskno);

      /* Print the Task ID.  */
      ui_out_field_fmt (uiout, "task-id", "%9lx", (long) task_info->task_id);

      /* Print the associated Thread ID.  */
      if (ui_out_is_mi_like_p (uiout))
        {
	  const int thread_id = pid_to_thread_id (task_info->ptid);

	  if (thread_id != 0)
	    ui_out_field_int (uiout, "thread-id", thread_id);
	  else
	    /* This should never happen unless there is a bug somewhere,
	       but be resilient when that happens.  */
	    ui_out_field_skip (uiout, "thread-id");
	}

      /* Print the ID of the parent task.  */
      parent_id = get_task_number_from_id (task_info->parent, inf);
      if (parent_id)
        ui_out_field_int (uiout, "parent-id", parent_id);
      else
        ui_out_field_skip (uiout, "parent-id");

      /* Print the base priority of the task.  */
      ui_out_field_int (uiout, "priority", task_info->priority);

      /* Print the task current state.  */
      if (task_info->caller_task)
	ui_out_field_fmt (uiout, "state",
			  _("Accepting RV with %-4d"),
			  get_task_number_from_id (task_info->caller_task,
						   inf));
      else if (task_info->state == Entry_Caller_Sleep
	       && task_info->called_task)
	ui_out_field_fmt (uiout, "state",
			  _("Waiting on RV with %-3d"),
			  get_task_number_from_id (task_info->called_task,
						   inf));
      else
	ui_out_field_string (uiout, "state", task_states[task_info->state]);

      /* Finally, print the task name.  */
      ui_out_field_fmt (uiout, "name",
			"%s",
			task_info->name[0] != '\0' ? task_info->name
						   : _("<no name>"));

      ui_out_text (uiout, "\n");
      do_cleanups (chain2);
    }

  do_cleanups (old_chain);
}

/* Print a detailed description of the Ada task whose ID is TASKNO_STR
   for the given inferior (INF).  */

static void
info_task (struct ui_out *uiout, char *taskno_str, struct inferior *inf)
{
  const int taskno = value_as_long (parse_and_eval (taskno_str));
  struct ada_task_info *task_info;
  int parent_taskno = 0;
  struct ada_tasks_inferior_data *data = get_ada_tasks_inferior_data (inf);

  if (ada_build_task_list () == 0)
    {
      ui_out_message (uiout, 0,
		      _("Your application does not use any Ada tasks.\n"));
      return;
    }

  if (taskno <= 0 || taskno > VEC_length (ada_task_info_s, data->task_list))
    error (_("Task ID %d not known.  Use the \"info tasks\" command to\n"
             "see the IDs of currently known tasks"), taskno);
  task_info = VEC_index (ada_task_info_s, data->task_list, taskno - 1);

  /* Print the Ada task ID.  */
  printf_filtered (_("Ada Task: %s\n"),
		   paddress (target_gdbarch (), task_info->task_id));

  /* Print the name of the task.  */
  if (task_info->name[0] != '\0')
    printf_filtered (_("Name: %s\n"), task_info->name);
  else
    printf_filtered (_("<no name>\n"));

  /* Print the TID and LWP.  */
  printf_filtered (_("Thread: %#lx\n"), ptid_get_tid (task_info->ptid));
  printf_filtered (_("LWP: %#lx\n"), ptid_get_lwp (task_info->ptid));

  /* Print who is the parent (if any).  */
  if (task_info->parent != 0)
    parent_taskno = get_task_number_from_id (task_info->parent, inf);
  if (parent_taskno)
    {
      struct ada_task_info *parent =
        VEC_index (ada_task_info_s, data->task_list, parent_taskno - 1);

      printf_filtered (_("Parent: %d"), parent_taskno);
      if (parent->name[0] != '\0')
        printf_filtered (" (%s)", parent->name);
      printf_filtered ("\n");
    }
  else
    printf_filtered (_("No parent\n"));

  /* Print the base priority.  */
  printf_filtered (_("Base Priority: %d\n"), task_info->priority);

  /* print the task current state.  */
  {
    int target_taskno = 0;

    if (task_info->caller_task)
      {
        target_taskno = get_task_number_from_id (task_info->caller_task, inf);
        printf_filtered (_("State: Accepting rendezvous with %d"),
                         target_taskno);
      }
    else if (task_info->state == Entry_Caller_Sleep && task_info->called_task)
      {
        target_taskno = get_task_number_from_id (task_info->called_task, inf);
        printf_filtered (_("State: Waiting on task %d's entry"),
                         target_taskno);
      }
    else
      printf_filtered (_("State: %s"), _(long_task_states[task_info->state]));

    if (target_taskno)
      {
        struct ada_task_info *target_task_info =
          VEC_index (ada_task_info_s, data->task_list, target_taskno - 1);

        if (target_task_info->name[0] != '\0')
          printf_filtered (" (%s)", target_task_info->name);
      }

    printf_filtered ("\n");
  }
}

/* If ARG is empty or null, then print a list of all Ada tasks.
   Otherwise, print detailed information about the task whose ID
   is ARG.
   
   Does nothing if the program doesn't use Ada tasking.  */

static void
info_tasks_command (char *arg, int from_tty)
{
  struct ui_out *uiout = current_uiout;

  if (arg == NULL || *arg == '\0')
    print_ada_task_info (uiout, NULL, current_inferior ());
  else
    info_task (uiout, arg, current_inferior ());
}

/* Print a message telling the user id of the current task.
   This function assumes that tasking is in use in the inferior.  */

static void
display_current_task_id (void)
{
  const int current_task = ada_get_task_number (inferior_ptid);

  if (current_task == 0)
    printf_filtered (_("[Current task is unknown]\n"));
  else
    printf_filtered (_("[Current task is %d]\n"), current_task);
}

/* Parse and evaluate TIDSTR into a task id, and try to switch to
   that task.  Print an error message if the task switch failed.  */

static void
task_command_1 (char *taskno_str, int from_tty, struct inferior *inf)
{
  const int taskno = value_as_long (parse_and_eval (taskno_str));
  struct ada_task_info *task_info;
  struct ada_tasks_inferior_data *data = get_ada_tasks_inferior_data (inf);

  if (taskno <= 0 || taskno > VEC_length (ada_task_info_s, data->task_list))
    error (_("Task ID %d not known.  Use the \"info tasks\" command to\n"
             "see the IDs of currently known tasks"), taskno);
  task_info = VEC_index (ada_task_info_s, data->task_list, taskno - 1);

  if (!ada_task_is_alive (task_info))
    error (_("Cannot switch to task %d: Task is no longer running"), taskno);
   
  /* On some platforms, the thread list is not updated until the user
     performs a thread-related operation (by using the "info threads"
     command, for instance).  So this thread list may not be up to date
     when the user attempts this task switch.  Since we cannot switch
     to the thread associated to our task if GDB does not know about
     that thread, we need to make sure that any new threads gets added
     to the thread list.  */
  target_find_new_threads ();

  /* Verify that the ptid of the task we want to switch to is valid
     (in other words, a ptid that GDB knows about).  Otherwise, we will
     cause an assertion failure later on, when we try to determine
     the ptid associated thread_info data.  We should normally never
     encounter such an error, but the wrong ptid can actually easily be
     computed if target_get_ada_task_ptid has not been implemented for
     our target (yet).  Rather than cause an assertion error in that case,
     it's nicer for the user to just refuse to perform the task switch.  */
  if (!find_thread_ptid (task_info->ptid))
    error (_("Unable to compute thread ID for task %d.\n"
             "Cannot switch to this task."),
           taskno);

  switch_to_thread (task_info->ptid);
  ada_find_printable_frame (get_selected_frame (NULL));
  printf_filtered (_("[Switching to task %d]\n"), taskno);
  print_stack_frame (get_selected_frame (NULL),
                     frame_relative_level (get_selected_frame (NULL)),
		     SRC_AND_LOC, 1);
}


/* Print the ID of the current task if TASKNO_STR is empty or NULL.
   Otherwise, switch to the task indicated by TASKNO_STR.  */

static void
task_command (char *taskno_str, int from_tty)
{
  struct ui_out *uiout = current_uiout;

  if (ada_build_task_list () == 0)
    {
      ui_out_message (uiout, 0,
		      _("Your application does not use any Ada tasks.\n"));
      return;
    }

  if (taskno_str == NULL || taskno_str[0] == '\0')
    display_current_task_id ();
  else
    {
      /* Task switching in core files doesn't work, either because:
           1. Thread support is not implemented with core files
           2. Thread support is implemented, but the thread IDs created
              after having read the core file are not the same as the ones
              that were used during the program life, before the crash.
              As a consequence, there is no longer a way for the debugger
              to find the associated thead ID of any given Ada task.
         So, instead of attempting a task switch without giving the user
         any clue as to what might have happened, just error-out with
         a message explaining that this feature is not supported.  */
      if (!target_has_execution)
        error (_("\
Task switching not supported when debugging from core files\n\
(use thread support instead)"));
      task_command_1 (taskno_str, from_tty, current_inferior ());
    }
}

/* Indicate that the given inferior's task list may have changed,
   so invalidate the cache.  */

static void
ada_task_list_changed (struct inferior *inf)
{
  struct ada_tasks_inferior_data *data = get_ada_tasks_inferior_data (inf);

  data->task_list_valid_p = 0;
}

/* Invalidate the per-program-space data.  */

static void
ada_tasks_invalidate_pspace_data (struct program_space *pspace)
{
  get_ada_tasks_pspace_data (pspace)->initialized_p = 0;
}

/* Invalidate the per-inferior data.  */

static void
ada_tasks_invalidate_inferior_data (struct inferior *inf)
{
  struct ada_tasks_inferior_data *data = get_ada_tasks_inferior_data (inf);

  data->known_tasks_kind = ADA_TASKS_UNKNOWN;
  data->task_list_valid_p = 0;
}

/* The 'normal_stop' observer notification callback.  */

static void
ada_normal_stop_observer (struct bpstats *unused_args, int unused_args2)
{
  /* The inferior has been resumed, and just stopped. This means that
     our task_list needs to be recomputed before it can be used again.  */
  ada_task_list_changed (current_inferior ());
}

/* A routine to be called when the objfiles have changed.  */

static void
ada_new_objfile_observer (struct objfile *objfile)
{
  struct inferior *inf;

  /* Invalidate the relevant data in our program-space data.  */

  if (objfile == NULL)
    {
      /* All objfiles are being cleared, so we should clear all
	 our caches for all program spaces.  */
      struct program_space *pspace;

      for (pspace = program_spaces; pspace != NULL; pspace = pspace->next)
        ada_tasks_invalidate_pspace_data (pspace);
    }
  else
    {
      /* The associated program-space data might have changed after
	 this objfile was added.  Invalidate all cached data.  */
      ada_tasks_invalidate_pspace_data (objfile->pspace);
    }

  /* Invalidate the per-inferior cache for all inferiors using
     this objfile (or, in other words, for all inferiors who have
     the same program-space as the objfile's program space).
     If all objfiles are being cleared (OBJFILE is NULL), then
     clear the caches for all inferiors.  */

  for (inf = inferior_list; inf != NULL; inf = inf->next)
    if (objfile == NULL || inf->pspace == objfile->pspace)
      ada_tasks_invalidate_inferior_data (inf);
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_tasks;

void
_initialize_tasks (void)
{
  ada_tasks_pspace_data_handle = register_program_space_data ();
  ada_tasks_inferior_data_handle = register_inferior_data ();

  /* Attach various observers.  */
  observer_attach_normal_stop (ada_normal_stop_observer);
  observer_attach_new_objfile (ada_new_objfile_observer);

  /* Some new commands provided by this module.  */
  add_info ("tasks", info_tasks_command,
            _("Provide information about all known Ada tasks"));
  add_cmd ("task", class_run, task_command,
           _("Use this command to switch between Ada tasks.\n\
Without argument, this command simply prints the current task ID"),
           &cmdlist);
}

@


1.59
log
@ada-tasks.c: write SRC_AND_LOC instead '1'.

1 is SRC_AND_LOC.

2013-08-30  Pedro Alves  <palves@@redhat.com>

	* ada-tasks.c (task_command_1): Write SRC_AND_LOC instead '1'.
@
text
@d1314 1
a1314 1
		     SRC_AND_LOC);
@


1.58
log
@-Wpointer-sign: ada-lang.c, ada-tasks.c.

We're reading strings using the target memory access routines, which
work with raw bytes, so we need a couple casts.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (print_it_exception): Add cast to gdb_byte *.
	* ada-tasks.c (read_fat_string_value): Likewise.
@
text
@d1313 2
a1314 1
                     frame_relative_level (get_selected_frame (NULL)), 1);
@


1.57
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@d436 1
a436 1
  read_memory (value_address (array_val), dest, len);
@


1.56
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d638 1
a638 1
	  struct minimal_symbol *msym;
d641 1
a641 1
	  if (msym)
d643 1
a643 1
	      const char *full_name = SYMBOL_LINKAGE_NAME (msym);
@


1.55
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d1 1
a1 2
/* Copyright (C) 1992-1994, 1997-2000, 2003-2005, 2007-2012 Free
   Software Foundation, Inc.
@


1.54
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d896 1
a896 1
	builtin_type (target_gdbarch)->builtin_data_ptr;
d927 1
a927 1
	builtin_type (target_gdbarch)->builtin_data_ptr;
d1176 1
a1176 1
		   paddress (target_gdbarch, task_info->task_id));
@


1.53
log
@Fix ARI violation in ada_tasks_inferior_data_sniffer.

This patch removes some variable assignments inside condition
expressions.

gdb/ChangeLog:

        * ada-tasks.c (ada_tasks_inferior_data_sniffer): Rework code to
        avoid variable assignments inside condition.
@
text
@a849 1
  const char *name;
@


1.52
log
@2012-02-23  Tristan Gingold  <gingold@@adacore.com>

       * ada-tasks.c (struct ada_tasks_inferior_data): Add
        known_tasks_element and known_tasks_length fields.
        (read_known_tasks_array): Change argument type.  Use pointer type
        and number of elements from DATA.  Adjust.
        (read_known_tasks_list): Likewise.
        (get_known_tasks_addr): Remove.
        (ada_set_current_inferior_known_tasks_addr): Renamed to ...
        (ada_tasks_inferior_data_sniffer): ... this.  Use symtab for element
        type and array length.  Merge former get_known_tasks_addr code.
@
text
@d873 2
a874 2
	  struct type *eltype;
	  struct type *idxtype;
d876 6
a881 4
	  if (TYPE_CODE (type) == TYPE_CODE_ARRAY
	      && (eltype = check_typedef (TYPE_TARGET_TYPE (type)))
	      && TYPE_CODE (eltype) == TYPE_CODE_PTR
	      && (idxtype = check_typedef (TYPE_INDEX_TYPE (type)))
@


1.51
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d218 6
d783 1
a783 1
read_known_tasks_array (CORE_ADDR known_tasks_addr)
d785 2
a786 3
  const int target_ptr_byte =
    gdbarch_ptr_bit (target_gdbarch) / TARGET_CHAR_BIT;
  const int known_tasks_size = target_ptr_byte * MAX_NUMBER_OF_KNOWN_TASKS;
d792 2
a793 2
  read_memory (known_tasks_addr, known_tasks, known_tasks_size);
  for (i = 0; i < MAX_NUMBER_OF_KNOWN_TASKS; i++)
a794 2
      struct type *data_ptr_type =
        builtin_type (target_gdbarch)->builtin_data_ptr;
d797 1
a797 1
			       data_ptr_type);
d810 1
a810 1
read_known_tasks_list (CORE_ADDR known_tasks_addr)
d812 1
a812 2
  const int target_ptr_byte =
    gdbarch_ptr_bit (target_gdbarch) / TARGET_CHAR_BIT;
a813 2
  struct type *data_ptr_type =
    builtin_type (target_gdbarch)->builtin_data_ptr;
d823 2
a824 2
  read_memory (known_tasks_addr, known_tasks, target_ptr_byte);
  task_id = extract_typed_address (known_tasks, data_ptr_type);
d844 2
a845 4
/* Return the address of the variable NAME that contains all the known
   tasks maintained in the Ada Runtime.  Return NULL if the variable
   could not be found, meaning that the inferior program probably does
   not use tasking.  */
d847 2
a848 2
static CORE_ADDR
get_known_tasks_addr (const char *name)
d850 1
d852 1
d854 1
a854 16
  msym = lookup_minimal_symbol (name, NULL, NULL);
  if (msym == NULL)
    return 0;

  return SYMBOL_VALUE_ADDRESS (msym);
}

/* Assuming DATA is the ada-tasks' data for the current inferior,
   set the known_tasks_kind and known_tasks_addr fields.  Do nothing
   if those fields are already set and still up to date.  */

static void
ada_set_current_inferior_known_tasks_addr (struct ada_tasks_inferior_data *data)
{
  CORE_ADDR known_tasks_addr;

d858 4
a861 2
  known_tasks_addr = get_known_tasks_addr (KNOWN_TASKS_NAME);
  if (known_tasks_addr != 0)
d864 33
a896 1
      data->known_tasks_addr = known_tasks_addr;
d900 5
a904 2
  known_tasks_addr = get_known_tasks_addr (KNOWN_TASKS_LIST);
  if (known_tasks_addr != 0)
d907 21
a927 1
      data->known_tasks_addr = known_tasks_addr;
d931 2
d956 1
a956 1
  ada_set_current_inferior_known_tasks_addr (data);
d964 1
a964 1
        return read_known_tasks_array (data->known_tasks_addr);
d966 1
a966 1
        return read_known_tasks_list (data->known_tasks_addr);
@


1.50
log
@[Ada] Fix number of lines in -ada-task-info output

When using the new -ada-task-info command with an argument,
the output would say that there are N entries in the returned
table, (where N is the total number of tasks present in the inferior).
But, in fact, the table would only contain at most 1 entry.

This patch fixes this by properly computing the number of
tasks being displayed before giving it to the uiout.

gdb/ChangeLog:

        * ada-tasks.c (print_ada_task_info): Fix computation of
        number of tasks displayed in command output.

gdb/testsuite/ChangeLog:

        * gdb.ada/mi_task_info/task_switch.adb: New file.
        * gdb.ada/mi_task_info.exp: New file.
@
text
@d1 2
a2 2
/* Copyright (C) 1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003, 2004, 2005,
   2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.50.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1 2
a2 2
/* Copyright (C) 1992-1994, 1997-2000, 2003-2005, 2007-2012 Free
   Software Foundation, Inc.
@


1.49
log
@2011-10-05  Tristan Gingold  <gingold@@adacore.com>

        * ada-tasks.c (read_atcb): Make ravenscar_task_name static.
        Extract the ravenscar task name from the symbol for the atcb.
@
text
@d987 15
a1001 1
  nb_tasks = VEC_length (ada_task_info_s, data->task_list);
d1023 3
a1025 1
  for (taskno = 1; taskno <= nb_tasks; taskno++)
@


1.48
log
@[Ada] Add field "thread-id" in -ada-task-info output

This patch enhances the -ada-task-info command, adding a new
field called "thread-id" in the command output.  This field
provides the ID of the task's corresponding thread (if that
information could not be determined, the field is omitted).

This field is useful in the context of GDB/MI users, because
it allows a quick translation from Ada task to thread, and
thus easy use of all the commands that take a --thread argument.

gdb/ChangeLog:

        * ada-tasks.c (print_ada_task_info): Add "thread-id" field
        in output of -ada-task-info GDB/MI command.
@
text
@d594 1
a594 1
  const char ravenscar_task_name[] = "Ravenscar task";
d632 25
a656 1
        strcpy (task_info->name, ravenscar_task_name);
@


1.47
log
@[Ada] New GDB/MI command: -ada-tasks-info

This patch introduces a new GDB/MI command: -ada-tasks-info,
which is meant to be the MI equivalent of the CLI `info tasks'
command.

This new command returns an array, with each row corresponding
to one task.  For now, the columns of the array corresponds to
the columns displayed in the CLI output.

gdb/ChangeLog:

        * ada-lang.h (struct inferior): Declare.
        (print_ada_task_info): Add declaration.
        * ada-tasks.c (print_ada_task_info): Make non-static.
        * mi/mi-cmds.c (mi_cmds): Add "ada-task-info".
        * mi/mi-cmds.h (mi_cmd_ada_task_info): Add declaration.
        * mi/mi-main.c: #include "ada-lang.h".
        (mi_cmd_list_features): Add "ada-task-info" to the list
        of supported features.
        (mi_cmd_ada_task_info): New function.
@
text
@d941 1
d953 9
d965 3
a967 2
  old_chain = make_cleanup_ui_out_table_begin_end (uiout, 7, nb_tasks,
                                                   "tasks");
d971 5
d1015 13
@


1.46
log
@[Ada] Re-implement `info tasks' command using ui-out

This is in preparation for providing a GDB/MI equivalent of
the `info tasks' command.  The previous implementation was using
various printf commands to generate the command output, which
does not work at all if we want to use that same code to generate
the result for that new GDB/MI command.

This patch thus re-implements the `info tasks' command (with no
arguments) in a way that makes it GDB/MI friendly.

There is an additional hicup, which is the fact that the `info tasks'
command displays a completely different type of output when a task
ID is given. For instance:

    (gdb) info task 2
    Ada Task: 0x644d20
    Name: my_callee
    Thread: 0
    LWP: 0x5809
    Parent: 1 (main_task)
    Base Priority: 48
    State: Blocked in accept or select with terminate

The above output is better when in CLI mode, but really not
what we want when in GDB/MI mode. In GDB/MI mode, we want to
follow what the `-thread-info' command does when a task-id
is given as an argument, which is to produce the same table,
but with only one element/task in it.

For compatibility as well as practical reasons, we do not want
to change the output of the `info task TASKNO' command when in
CLI mode.  But it's easy to preserve this behavior while providing
the desirable output when in GDB/MI mode.  For this, the function
used to generated the `info tasks' output has been enhanced to take
an argument interpreted as a string. The CLI command knows to never
provide that argument, while the GDB/MI command will pass one if
provided by the user.

gdb/ChangeLog:

        * ada-tasks.c (print_ada_task_info): New function, merging
        short_task_info and info_tasks together.  Reimplement using
        ui-out instead of printing to stdout directly.  Move the code
        building and checking the task list here, instead of leaving it
        in info_tasks_command.
        (info_task): Move the code building and checking the task
        list here, instead of leaving it in info_tasks_command.
        (info_tasks_command): Delete code building and checking
        the task list - moved elsewhere.  Update calls to info_tasks
        and info_task.

One of the minor changes the switch caused is the introduction
of a space between the "current" column, and the task "ID"
column, which wasn't there before.  This matches what we do
in the "info threads" command, so I kept that change.  This
required an adjustment in the testsuite, however...

gdb/testsuite/ChangeLog:

        * gdb.ada/tasks.exp: Make the expected output for
        the `info tasks' tests more resilient to spacing
        changes.
@
text
@d932 1
a932 1
static void
@


1.45
log
@[Ada] Remove `from_tty' parameter from ada-tasks.c:info_task

This parameter is unused, and probably will never be useful.

gdb/ChangeLog:

        * ada-tasks.c (info_task): Delete parameter `from_tty'.
@
text
@d927 4
a930 4
/* Print a one-line description of the task running in inferior INF
   whose number is TASKNO.

   The formatting should fit the "info tasks" array.  */
d933 8
a940 17
short_task_info (int taskno, struct inferior *inf)
{
  struct ada_tasks_inferior_data *data = get_ada_tasks_inferior_data (inf);
  const struct ada_task_info *const task_info =
    VEC_index (ada_task_info_s, data->task_list, taskno - 1);
  int active_task_p;

  gdb_assert (task_info != NULL);

  /* Print a star if this task is the current task (or the task currently
     selected).  */

  active_task_p = ptid_equal (task_info->ptid, inferior_ptid);
  if (active_task_p)
    printf_filtered ("*");
  else
    printf_filtered (" ");
d942 6
a947 2
  /* Print the task number.  */
  printf_filtered ("%3d", taskno);
d949 2
a950 2
  /* Print the Task ID.  */
  printf_filtered (" %9lx", (long) task_info->task_id);
d952 2
a953 15
  /* Print the Task ID of the task parent.  */
  printf_filtered (" %4d", get_task_number_from_id (task_info->parent, inf));

  /* Print the base priority of the task.  */
  printf_filtered (" %3d", task_info->priority);

  /* Print the task current state.  */
  if (task_info->caller_task)
    printf_filtered (_(" Accepting RV with %-4d"),
                     get_task_number_from_id (task_info->caller_task, inf));
  else if (task_info->state == Entry_Caller_Sleep && task_info->called_task)
    printf_filtered (_(" Waiting on RV with %-3d"),
                     get_task_number_from_id (task_info->called_task, inf));
  else
    printf_filtered (" %-22s", _(task_states[task_info->state]));
d955 13
a967 6
  /* Finally, print the task name.  */
  if (task_info->name[0] != '\0')
    printf_filtered (" %s\n", task_info->name);
  else
    printf_filtered (_(" <no name>\n"));
}
d969 60
a1028 3
/* Print a list containing a short description of all Ada tasks
   running inside inferior INF.  */
/* FIXME: Shouldn't we be using ui_out???  */
d1030 3
a1032 6
static void
info_tasks (struct inferior *inf)
{
  struct ada_tasks_inferior_data *data = get_ada_tasks_inferior_data (inf);
  int taskno;
  const int nb_tasks = VEC_length (ada_task_info_s, data->task_list);
d1034 1
a1034 4
  printf_filtered (_("  ID       TID P-ID Pri State                  Name\n"));
  
  for (taskno = 1; taskno <= nb_tasks; taskno++)
    short_task_info (taskno, inf);
d1041 1
a1041 1
info_task (char *taskno_str, struct inferior *inf)
d1048 7
a1135 7
  if (ada_build_task_list () == 0)
    {
      ui_out_message (uiout, 0,
		      _("Your application does not use any Ada tasks.\n"));
      return;
    }

d1137 1
a1137 1
    info_tasks (current_inferior ());
d1139 1
a1139 1
    info_task (arg, current_inferior ());
@


1.44
log
@[Ada] Remove `from_tty' parameter from ada-tasks.c:info_tasks

This parameter is unused, and probably will never be useful.

gdb/ChangeLog:

        * ada-tasks.c (info_tasks): Delete parameter `from_tty'.
@
text
@d1001 1
a1001 1
info_task (char *taskno_str, int from_tty, struct inferior *inf)
d1099 1
a1099 1
    info_task (arg, from_tty, current_inferior ());
@


1.43
log
@[Ada] Adjust ada-tasks.c:ada_build_task_list

Originally, this function had a parameter called `warn_if_null'
which would trigger a message to be printed on stdout if the
program was found to not use Ada tasking.  It used one of the printf_
functions for that, which is wrong when considering the context of
GDB/MI interpreters.

So, this patch changes this function to stop printing the message,
and leaves that part to the callers instead.  It also changes the
semantics slightly to return the number of tasks found, rather than
a yes/no answer.  Not strictly needed, but simple enough to do, and
potentially useful later.

gdb/ChangeLog:

        * ada-lang.h (ada_build_task_list): Remove parameter
        `warn_if_null'.
        * ada-tasks.c (ada_build_task_list): Remove parameter
        `warn_if_null'.  Adjust implementation and documentation.
        (valid_task_id, ada_get_environment_task)
        iterate_over_live_ada_tasks): Adjust call to ada_build_task_list.
        (info_tasks_command): Adjust implementation.
        (task_command): Likewise.
        * ravenscar-thread.c (ravenscar_find_new_threads): Fix call
        to ada_build_task_list.
@
text
@d985 1
a985 1
info_tasks (int from_tty, struct inferior *inf)
d1097 1
a1097 1
    info_tasks (from_tty, current_inferior ());
@


1.42
log
@[Ada] Store the Ada task list in per-inferior data

Instead of storing "the" Ada task list using a static global
in ada-tasks, this patch stores that information inside
per-inferior data.

We also add in the per-inferior data the location and type of
data used in the runtime to store that task list.  Previously,
this information was saved as a static variable in one of the
functions, but this approach has the major flaw that it does
not handle multi-inferior debugging.

gdb/ChangeLog:

        * ada-tasks.c (ada_tasks_check_symbol_table, task_list): Delete.
        (enum ada_known_tasks_kind, struct ada_tasks_inferior_data): New.
        (ada_tasks_inferior_data_handle): New static global.
        (get_ada_tasks_inferior_data): New function.
        (ada_get_task_number, get_task_number_from_id, valid_task_id)
        (ada_get_environment_task, iterate_over_live_ada_tasks)
        (add_ada_task, read_known_tasks_array, read_known_tasks_list):
        Adjust.
        (ada_set_current_inferior_known_tasks_addr): New function.
        (read_known_tasks, ada_build_task_list, short_task_info)
        (info_tasks, info_task, info_tasks_command, task_command_1)
        (task_command, ada_task_list_changed): Adjust.
        (ada_tasks_invalidate_inferior_data): New function.
        (ada_normal_stop_observer, ada_new_objfile_observer): Adjust.
        (_initialize_tasks): Set ada_tasks_inferior_data_handle.
        * ada-lang.h (struct inferior): Add declaration.
        (ada_task_list_changed): Update profile.
        * remote-wtx-pd.c: #include "inferior.h".
        (switch_to_pd_internal): Update call to ada_task_list_changed.
@
text
@d333 1
a333 1
  ada_build_task_list (0);
d358 1
a358 1
  ada_build_task_list (0);
d908 3
a910 3
/* Builds the task_list by reading the Known_Tasks array from
   the inferior.  Prints an appropriate message and returns non-zero
   if it failed to build this list.  */
d913 1
a913 1
ada_build_task_list (int warn_if_null)
d924 1
a924 8
  if (data->task_list == NULL)
    {
      if (warn_if_null)
        printf_filtered (_("Your application does not use any Ada tasks.\n"));
      return 0;
    }

  return 1;
d1087 1
a1087 1
  const int task_list_built = ada_build_task_list (1);
d1089 6
a1094 2
  if (!task_list_built)
    return;
d1170 1
a1170 1
  const int task_list_built = ada_build_task_list (1);
d1172 6
a1177 2
  if (!task_list_built)
    return;
@


1.41
log
@[Ada] Make the ATCB type info program-space-specific

This module caches the type description of various elements of
the Ada Task Control Block (ATCB). This cache was implemented
as static globals, which is wrong in the case where we have
multiple inferiors. This change cleans things up a bit by moving
some of these static globals to a per-program-space area.

gdb/ChangeLog:

        * ada-tasks.c: #include "progspace.h" and "objfiles.h".
        (atcb_type, atcb_common_type, atcb_ll_type, atcb_call_type)
        (atcb_fieldno): Delete these static globals.
        (struct ada_tasks_pspace_data): New struct.
        (ada_tasks_pspace_data_handle): New static global.
        (get_ada_tasks_pspace_data): New function.
        (ada_tasks_invalidate_pspace_data): New function.
        (get_tcb_types_info, ptid_from_atcb_common, read_atcb)
        (read_known_tasks_list, ada_new_objfile_observer): Adjust.
        (_initialize_tasks): Create this module's per-progspace
        data handle.
@
text
@a163 11
/* Set to 1 when the cached address of System.Tasking.Debug.Known_Tasks
   might be stale and so needs to be recomputed.  */
static int ada_tasks_check_symbol_table = 1;

/* The list of Ada tasks.
 
   Note: To each task we associate a number that the user can use to
   reference it - this number is printed beside each task in the tasks
   info listing displayed by "info tasks".  This number is equal to
   its index in the vector + 1.  Reciprocally, to compute the index
   of a task in the vector, we need to substract 1 from its number.  */
a165 1
static VEC(ada_task_info_s) *task_list = NULL;
d167 68
a234 3
/* When non-zero, this flag indicates that the current task_list
   is obsolete, and should be recomputed before it is accessed.  */
static int stale_task_list_p = 1;
d256 27
d290 2
d293 6
a298 2
  for (i = 0; i < VEC_length (ada_task_info_s, task_list); i++)
    if (ptid_equal (VEC_index (ada_task_info_s, task_list, i)->ptid, ptid))
d304 2
a305 2
/* Return the task number of the task that matches TASK_ID, or zero
   if the task could not be found.  */
d308 1
a308 1
get_task_number_from_id (CORE_ADDR task_id)
d310 1
d313 1
a313 1
  for (i = 0; i < VEC_length (ada_task_info_s, task_list); i++)
d316 1
a316 1
        VEC_index (ada_task_info_s, task_list, i);
d331 2
d334 1
d336 1
a336 1
          && task_num <= VEC_length (ada_task_info_s, task_list));
d356 1
d359 2
a360 1
  nb_tasks = VEC_length (ada_task_info_s, task_list);
d364 1
a364 1
      task = VEC_index (ada_task_info_s, task_list, i);
d737 1
a737 1
   add the result to the TASK_LIST.  */
d740 1
a740 1
add_ada_task (CORE_ADDR task_id)
d743 1
d746 1
a746 1
  VEC_safe_push (ada_task_info_s, task_list, &task_info);
d750 1
a750 1
   it in TASK_LIST.  Return non-zero upon success.  */
d773 1
a773 1
        add_ada_task (task_id);
d780 1
a780 1
   TASK_LIST.  Return non-zero upon success.  */
d806 1
a806 1
      add_ada_task (task_id);
d837 35
a871 2
/* Read the known tasks from the inferior memory, and store it in
   TASK_LIST.  Return non-zero upon success.  */
d876 2
a877 4
  /* In order to provide a fast response time, this function caches the
     known tasks addresses after the lookup during the first call. */
  static CORE_ADDR known_tasks_array_addr;
  static CORE_ADDR known_tasks_list_addr;
d880 1
a880 1
  VEC_truncate (ada_task_info_s, task_list, 0);
d888 4
a891 1
  if (ada_tasks_check_symbol_table)
d893 7
a899 32
      known_tasks_array_addr = get_known_tasks_addr (KNOWN_TASKS_NAME);
      known_tasks_list_addr = get_known_tasks_addr (KNOWN_TASKS_LIST);

      /* FIXME: brobecker 2003-03-05: Here would be a much better place
         to attach the ada-tasks observers, instead of doing this
         unconditionaly in _initialize_tasks. This would avoid an
         unecessary notification when the inferior does not use tasking
         or as long as the user does not use the ada-tasks commands.
         Unfortunately, this is not possible for the moment: the current
         code resets ada__tasks_check_symbol_table back to 1 whenever
         symbols for a new program are being loaded. If we place the
         observers intialization here, we will end up adding new observers
         everytime we do the check for Ada tasking-related symbols
         above. This would currently have benign effects, but is still
         undesirable. The cleanest approach is probably to create a new
         observer to notify us when the user is debugging a new program.
         We would then reset ada__tasks_check_symbol_table back to 1
         during the notification, but also detach all observers.
         BTW: observers are probably not reentrant, so detaching during
         a notification may not be the safest thing to do... Sigh...
         But creating the new observer would be a good idea in any case,
         since this allow us to make ada__tasks_check_symbol_table
         static, which is a good bonus.  */
      ada_tasks_check_symbol_table = 0;
    }

  /* Try both mechanisms.  */
  if ((known_tasks_array_addr == 0
       || read_known_tasks_array (known_tasks_array_addr) == 0)
      && (known_tasks_list_addr == 0
          || read_known_tasks_list (known_tasks_list_addr) == 0))
    return 0;
d901 1
a901 1
  /* Step 3: Unset stale_task_list_p, to avoid re-reading the Known_Tasks
d903 1
a903 1
  stale_task_list_p = 0;
d915 2
d920 2
a921 1
  if (stale_task_list_p)
d924 1
a924 1
  if (task_list == NULL)
d934 3
a936 1
/* Print a one-line description of the task whose number is TASKNO.
d940 1
a940 1
short_task_info (int taskno)
d942 1
d944 1
a944 1
    VEC_index (ada_task_info_s, task_list, taskno - 1);
d965 1
a965 1
  printf_filtered (" %4d", get_task_number_from_id (task_info->parent));
d973 1
a973 1
                     get_task_number_from_id (task_info->caller_task));
d976 1
a976 1
                     get_task_number_from_id (task_info->called_task));
d987 2
a988 1
/* Print a list containing a short description of all Ada tasks.  */
d992 1
a992 1
info_tasks (int from_tty)
d994 1
d996 1
a996 1
  const int nb_tasks = VEC_length (ada_task_info_s, task_list);
d1001 1
a1001 1
    short_task_info (taskno);
d1004 2
a1005 1
/* Print a detailed description of the Ada task whose ID is TASKNO_STR.  */
d1008 1
a1008 1
info_task (char *taskno_str, int from_tty)
d1013 1
d1015 1
a1015 1
  if (taskno <= 0 || taskno > VEC_length (ada_task_info_s, task_list))
d1018 1
a1018 1
  task_info = VEC_index (ada_task_info_s, task_list, taskno - 1);
d1036 1
a1036 1
    parent_taskno = get_task_number_from_id (task_info->parent);
d1040 1
a1040 1
        VEC_index (ada_task_info_s, task_list, parent_taskno - 1);
d1059 1
a1059 1
        target_taskno = get_task_number_from_id (task_info->caller_task);
d1065 1
a1065 1
        target_taskno = get_task_number_from_id (task_info->called_task);
d1075 1
a1075 1
          VEC_index (ada_task_info_s, task_list, target_taskno - 1);
d1100 1
a1100 1
    info_tasks (from_tty);
d1102 1
a1102 1
    info_task (arg, from_tty);
d1123 1
a1123 1
task_command_1 (char *taskno_str, int from_tty)
d1127 1
d1129 1
a1129 1
  if (taskno <= 0 || taskno > VEC_length (ada_task_info_s, task_list))
d1132 1
a1132 1
  task_info = VEC_index (ada_task_info_s, task_list, taskno - 1);
d1196 1
a1196 1
      task_command_1 (taskno_str, from_tty);
d1200 2
a1201 1
/* Indicate that the task list may have changed, so invalidate the cache.  */
d1204 1
a1204 1
ada_task_list_changed (void)
d1206 3
a1208 1
  stale_task_list_p = 1;  
d1219 11
d1237 1
a1237 1
  ada_task_list_changed ();
d1245 1
a1245 1
  ada_tasks_check_symbol_table = 1;
d1264 10
d1283 1
@


1.40
log
@[Ada] Rename struct tcb_fieldnos into atcb_fieldnos.

`atcb' is clearer than `tcb', as it stands for Ada Task Control
Block. This is also consistent with the rest of the code, which
uses atcb...

gdb/ChangeLog:

        * ada-tasks.c (struct atcb_fieldnos): Renames struct tcb_fieldnos.
@
text
@d27 2
d136 27
a162 12
/* The type description for the ATCB record and subrecords, and
   the associated atcb_fieldnos.  For efficiency reasons, these are made
   static globals so that we can compute them only once the first time
   and reuse them later.  Set to NULL if the types haven't been computed
   yet, or if they may be obsolete (for instance after having loaded
   a new binary).  */

static struct type *atcb_type = NULL;
static struct type *atcb_common_type = NULL;
static struct type *atcb_ll_type = NULL;
static struct type *atcb_call_type = NULL;
static struct atcb_fieldnos atcb_fieldno;
d183 20
d363 1
d453 7
a459 5
  atcb_type = type;
  atcb_common_type = common_type;
  atcb_ll_type = ll_type;
  atcb_call_type = call_type;
  atcb_fieldno = fieldnos;
d473 2
d476 1
a476 1
  ll_value = value_field (common_value, atcb_fieldno.ll);
d478 5
a482 3
  if (atcb_fieldno.ll_lwp >= 0)
    lwp = value_as_address (value_field (ll_value, atcb_fieldno.ll_lwp));
  thread = value_as_long (value_field (ll_value, atcb_fieldno.ll_thread));
d503 2
d506 1
a506 1
  if (atcb_type == NULL)
d509 3
a511 2
  tcb_value = value_from_contents_and_address (atcb_type, NULL, task_id);
  common_value = value_field (tcb_value, atcb_fieldno.common);
d532 1
a532 1
  if (atcb_fieldno.image_len == -1)
d534 1
a534 1
      if (atcb_fieldno.image >= 0)
d536 2
a537 1
                               value_field (common_value, atcb_fieldno.image),
d544 3
a546 2
      int len = value_as_long (value_field (common_value,
                                            atcb_fieldno.image_len));
d549 3
a551 1
                       value_field (common_value, atcb_fieldno.image), len);
d557 2
a558 1
    value_as_long (value_field (common_value, atcb_fieldno.state));
d560 2
a561 1
    value_as_long (value_field (common_value, atcb_fieldno.priority));
d566 1
a566 1
  if (atcb_fieldno.parent >= 0)
d568 2
a569 1
      value_as_address (value_field (common_value, atcb_fieldno.parent));
d577 2
a578 1
  if (atcb_fieldno.atc_nesting_level > 0 && atcb_fieldno.entry_calls > 0)
d583 2
a584 2
      atc_nesting_level_value = value_field (tcb_value,
                                             atcb_fieldno.atc_nesting_level);
d586 2
a587 2
        ada_coerce_to_simple_array_ptr (value_field (tcb_value,
                                                     atcb_fieldno.entry_calls));
d607 1
a607 1
  if (atcb_fieldno.call >= 0)
d612 2
a613 1
        value_as_address (value_field (common_value, atcb_fieldno.call));
d619 2
a620 1
            value_from_contents_and_address (atcb_call_type, NULL, call);
d622 2
a623 1
            value_as_address (value_field (call_val, atcb_fieldno.call_self));
d698 2
d702 1
a702 1
  if (atcb_fieldno.activation_link < 0)
d716 6
a721 4
      tcb_value = value_from_contents_and_address (atcb_type, NULL, task_id);
      common_value = value_field (tcb_value, atcb_fieldno.common);
      task_id = value_as_address (value_field (common_value,
                                               atcb_fieldno.activation_link));
d1095 8
d1118 1
a1118 1
  /* Invalidate all cached data that were extracted from an objfile.  */
d1120 1
a1120 4
  atcb_type = NULL;
  atcb_common_type = NULL;
  atcb_ll_type = NULL;
  atcb_call_type = NULL;
d1122 15
a1136 1
  ada_tasks_check_symbol_table = 1;
d1145 2
@


1.39
log
@ada-tasks.c: handle known tasks maintained by a simply-linked list.

The mapping between Ada tasks, and the underlying threads is
normally maintained by the GNAT runtime under the known_tasks
array.  For performance reasons, this array is just a static
array with 10_000 entries in it. However, this is not very
practical in certain environments where memory is limited.
For those environments, the runtime has been enhanced to use
an alternate scheme with a linked list.

This change enhances the Ada tasking support to recognize this
situation and use the correct way of reading the tasks info
based on the the situation.

gdb/ChangeLog  (Tristan Gingold)

	* ada-tasks.c (KNOWN_TASKS_LIST): New macro.
	(tcb_fieldno): Add activation_link field.
	(get_known_tasks_addr): Moved and rewritten.
	(get_tcb_types_info): Set activation_link field.
	(read_known_tasks_array): Add parameter.  Rewritten.
	(read_known_tasks_list): New function.
	(read_known_tasks): New function.
	(ada_build_task_list): Call read_known_tasks instead of
	read_known_tasks_array.
	* ravenscar-thread.c: Add first_task_name constant.
	(has_ravenscar_runtime): Check for task list too.
@
text
@d109 1
a109 1
struct tcb_fieldnos
d135 1
a135 1
   the associated tcb_fieldnos.  For efficiency reasons, these are made
d145 1
a145 1
static struct tcb_fieldnos atcb_fieldno;
d325 1
a325 1
  struct tcb_fieldnos fieldnos;
@


1.38
log
@Minor changes in ada-tasks.c

Just some minor cleanup changes in preparation for an upcoming
change...

gdb/ChangeLog  (Tristan Gingold)

	* ada-tasks.c: Renames fieldno to actb_fieldno.
	(ada_get_task_number): Indentation.
	(get_tcb_types_info): Remove all parameters.  Write directly
	the globals.
	(ptid_from_atcb_common): Adjust.
	(read_atcb): Adjust.
@
text
@d35 5
d122 1
a307 48
/* Return the address of the Known_Tasks array maintained in
   the Ada Runtime.  Return zero if the array could not be found,
   meaning that the inferior program probably does not use tasking.

   In order to provide a fast response time, this function caches
   the Known_Tasks array address after the lookup during the first
   call.  Subsequent calls will simply return this cached address.  */

static CORE_ADDR
get_known_tasks_addr (void)
{
  static CORE_ADDR known_tasks_addr = 0;

  if (ada_tasks_check_symbol_table)
    {
      struct minimal_symbol *msym;

      msym = lookup_minimal_symbol (KNOWN_TASKS_NAME, NULL, NULL);
      if (msym == NULL)
        return 0;
      known_tasks_addr = SYMBOL_VALUE_ADDRESS (msym);

      /* FIXME: brobecker 2003-03-05: Here would be a much better place
         to attach the ada-tasks observers, instead of doing this
         unconditionaly in _initialize_tasks.  This would avoid an
         unecessary notification when the inferior does not use tasking
         or as long as the user does not use the ada-tasks commands.
         Unfortunately, this is not possible for the moment: the current
         code resets ada__tasks_check_symbol_table back to 1 whenever
         symbols for a new program are being loaded.  If we place the
         observers intialization here, we will end up adding new observers
         everytime we do the check for Ada tasking-related symbols
         above.  This would currently have benign effects, but is still
         undesirable.  The cleanest approach is probably to create a new
         observer to notify us when the user is debugging a new program.
         We would then reset ada__tasks_check_symbol_table back to 1
         during the notification, but also detach all observers.
         BTW: observers are probably not reentrant, so detaching during
         a notification may not be the safest thing to do...  Sigh...
         But creating the new observer would be a good idea in any case,
         since this allow us to make ada__tasks_check_symbol_table
         static, which is a good bonus.  */
      ada_tasks_check_symbol_table = 0;
    }

  return known_tasks_addr;
}

d396 2
d602 1
a602 1
read_known_tasks_array (void)
a605 1
  const CORE_ADDR known_tasks_addr = get_known_tasks_addr ();
d610 2
a611 13
  /* Step 1: Clear the current list, if necessary.  */
  VEC_truncate (ada_task_info_s, task_list, 0);

  /* If the application does not use task, then no more needs to be done.
     It is important to have the task list cleared (see above) before we
     return, as we don't want a stale task list to be used...  This can
     happen for instance when debugging a non-multitasking program after
     having debugged a multitasking one.  */
  if (known_tasks_addr == 0)
    return 0;

  /* Step 2: Build a new list by reading the ATCBs from the Known_Tasks
     array in the Ada runtime.  */
d625 112
d755 1
a755 1
    read_known_tasks_array ();
@


1.37
log
@delete target_ops.to_lookup_symbol

gdb/ChangeLog:

        * target.h (struct target_ops): Remove to_lookup_symbol field.
        (target_lookup_symbol): Delete macro.
        * target.c (nosymbol, debug_to_lookup_symbol): Delete.
        (update_current_target, setup_target_debug): Remove handling
        of to_lookup_symbol target_ops field.
        * ada-tasks.c (get_known_tasks_addr): Remove use of
        target_lookup_symbol.
        * coffread.c (coff_symtab_read): Likewise.
        * dbxread.c (read_dbx_symtab): Ditto.
@
text
@d139 1
a139 1
static struct tcb_fieldnos fieldno;
d168 1
a168 1
  for (i=0; i < VEC_length (ada_task_info_s, task_list); i++)
d361 1
a361 5
get_tcb_types_info (struct type **atcb_type,
                    struct type **atcb_common_type,
                    struct type **atcb_ll_type,
                    struct type **atcb_call_type,
                    struct tcb_fieldnos *atcb_fieldnos)
d455 5
a459 5
  *atcb_type = type;
  *atcb_common_type = common_type;
  *atcb_ll_type = ll_type;
  *atcb_call_type = call_type;
  *atcb_fieldnos = fieldnos;
d474 1
a474 1
  ll_value = value_field (common_value, fieldno.ll);
d476 3
a478 3
  if (fieldno.ll_lwp >= 0)
    lwp = value_as_address (value_field (ll_value, fieldno.ll_lwp));
  thread = value_as_long (value_field (ll_value, fieldno.ll_thread));
d501 1
a501 2
    get_tcb_types_info (&atcb_type, &atcb_common_type, &atcb_ll_type,
                        &atcb_call_type, &fieldno);
d504 1
a504 1
  common_value = value_field (tcb_value, fieldno.common);
d525 1
a525 1
  if (fieldno.image_len == -1)
d527 1
a527 1
      if (fieldno.image >= 0)
d529 1
a529 1
                               value_field (common_value, fieldno.image),
d536 2
a537 1
      int len = value_as_long (value_field (common_value, fieldno.image_len));
d540 1
a540 1
                       value_field (common_value, fieldno.image), len);
d545 2
a546 1
  task_info->state = value_as_long (value_field (common_value, fieldno.state));
d548 1
a548 1
    value_as_long (value_field (common_value, fieldno.priority));
d553 1
a553 1
  if (fieldno.parent >= 0)
d555 1
a555 1
      value_as_address (value_field (common_value, fieldno.parent));
d563 1
a563 1
  if (fieldno.atc_nesting_level > 0 && fieldno.entry_calls > 0) 
d569 1
a569 1
                                             fieldno.atc_nesting_level);
d572 1
a572 1
                                                     fieldno.entry_calls));
d592 1
a592 1
  if (fieldno.call >= 0)
d597 1
a597 1
        value_as_address (value_field (common_value, fieldno.call));
d605 1
a605 1
            value_as_address (value_field (call_val, fieldno.call_self));
@


1.36
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d303 1
a303 1
   the Ada Runtime.  Return NULL if the array could not be found,
d320 3
a322 7
      if (msym != NULL)
        known_tasks_addr = SYMBOL_VALUE_ADDRESS (msym);
      else
        {
          if (target_lookup_symbol (KNOWN_TASKS_NAME, &known_tasks_addr) != 0)
            return 0;
        }
@


1.35
log
@fix style violation in ada-tasks.c comment

gdb/ChangeLog:

       * ada-tasks.c: Fix style violation in comment.
@
text
@d129 1
a129 1
   the associated tcb_fieldnos. For efficiency reasons, these are made
d308 1
a308 1
   call. Subsequent calls will simply return this cached address.  */
d330 1
a330 1
         unconditionaly in _initialize_tasks. This would avoid an
d335 1
a335 1
         symbols for a new program are being loaded. If we place the
d338 2
a339 2
         above. This would currently have benign effects, but is still
         undesirable. The cleanest approach is probably to create a new
d344 1
a344 1
         a notification may not be the safest thing to do... Sigh...
d383 1
a383 1
  /* ATCB symbols may be found in several compilation units. As we
d524 1
a524 1
     the ATCB to store the string length. For efficiency reasons, newer
d527 1
a527 1
     the length of the task name. The method used to extract the task name
d531 1
a531 1
     we may want to get it from the first user frame of the stack. For now,
d765 1
a765 1
/* FIXME: Shouldn't we be using ui_out??? */
@


1.34
log
@run copyright.sh for 2011.
@
text
@d32 1
a32 1
/* The maximum number of tasks known to the Ada runtime */
@


1.33
log
@[Ada/tasks] Optimize ATCB lookups

Type symbols that are used to decode the Ada task control block may be
duplicated in any unit that uses a tasking feature; an Ada lookup of
these symbols would collect all the duplicated instances and could
provoke the load of a huge amount of debug symbols in the process.

However, when decoding the task information, we are only interested in
one instance; and we have the full name of the symbol anyway. So use
a C lookup instead of an Ada lookup.

2010-11-05  Jerome Guitton  <guitton@@adacore.com>

	* ada-tasks.c (get_tcb_types_info): Use C lookups to get
	ATCB symbols.
@
text
@d2 1
a2 1
   2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.32
log
@[Ada] Add ada-tasks.c:iterate_over_live_ada_tasks

This new function is needed by the ravenscar-thread layer.

gdb/ChangeLog:

        * ada-tasks.c (iterate_over_live_ada_tasks): New function.
        * ada-lang.h (iterate_over_live_ada_tasks): Declare.
@
text
@d383 4
d388 2
a389 1
    lookup_symbol (atcb_name, NULL, VAR_DOMAIN, NULL);
d391 2
a392 1
    lookup_symbol (common_atcb_name, NULL, VAR_DOMAIN, NULL);
d394 2
a395 1
    lookup_symbol (private_data_name, NULL, VAR_DOMAIN, NULL);
d397 2
a398 1
    lookup_symbol (entry_call_record_name, NULL, VAR_DOMAIN, NULL);
d404 2
a405 1
      atcb_sym = lookup_symbol (atcb_name_fixed, NULL, VAR_DOMAIN, NULL);
@


1.31
log
@[Ada] Do not compute task ptid when debugging core file

After thread support over core files was added for GNU/Linux was added,
we started noticing the following type of crash when trying to perform
task switches (this is a bit accademic, since task switching is not
supported when debugging core files - this is what our testcase was
verifying).

(please check out the comment inside ada-tasks.c:task_command for
more details on this topic)

The reason for the crash comes from the fact that the GNU/Linux thread
layer now gets pushed on the target stack, causing the associated
to_get_ada_task_ptid target method to be activated.  This routine
makes the assumption that, for all threads, the private area is not
NULL.  This is incorrect in the case of core files, as the core layer
creates some threads with no private data.

But, taking a step back, we don't need to try to compute the task ptid,
as we'll never be using it anyways (we only use it for task switching).
So the fix is to avoid the ptid computation altogether when debugging
a core file.

gdb/ChangeLog:

        * ada-tasks.c (read_atcb): Do not compute the task ptid when
        debugging a core file.
@
text
@d215 21
@


1.30
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c (add_defn_to_vec): Delete unused variable.
	(decode_constrained_packed_array_type): Delete unused variable.
	(add_defn_to_vec): Delete unused variable.
	(symbol_completion_match): Delete unused variable.
	(value_tag_from_contents_and_address): Delete unused variable.
	(ada_evaluate_subexp): Delete unused variable.
	* c-lang.c (classify_type): Delete unused variable.
	* f-lang.c (f_printstr): Delete unused variable.
	* objc-lang.c (objc_printstr): Delete unused variable.
	* ada-tasks.c (get_known_tasks_addr): Delete unused variable.
	* jv-lang.c (type_from_class): ifdef unused variable.
	(java_class_name_from_physname): Delete unused variable.
	* m2-lang.c (m2_printstr): Delete unused variable.
@
text
@d586 10
a595 1
  /* And finally, compute the task ptid.  */
d597 1
a597 1
  if (ada_task_is_alive (task_info))
@


1.29
log
@Avoid switch to invalid ptid during Ada task switch.

This is to prevent an internal error during an Ada task switch. A task
switch is simply a thread switch under the hood. What we do is collect
the info from the Ada Task Control Block, deduce the associated thread
ptid, and then switch to that thread.  If the thread ptid computation
routine has not been implemented for the target, of if there is a bug,
then we end up computing a bogus ptid which GDB does not know about,
which eventually leads to an assertion failure:

    (gdb) task 1
    [New Thread 5715]
    /[...]/gdb/thread.c:595: internal-error: is_thread_state:
     Assertion `tp' failed.
    A problem internal to GDB has been detected,
    further debugging may prove unreliable.
    Quit this debugging session? (y or n)

When this happens, it's just nicer for the user to print an error
message, and cancel the task switch. After this patch is applied,
this is what we get:

    (gdb) task 1
    [New Thread 10250]
    Unable to compute thread ID for task 1.
    Cannot switch to this task.

gdb/ChangeLog:

        * ada-tasks.c (task_command_1): Check that the task ptid is valid
        before doing the associated thread switch.
@
text
@a295 1
      struct symbol *sym;
@


1.28
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d880 13
@


1.27
log
@Fix break *FUN'address task NUM.

        * ada-lex.l (task): New rule.
        * ada-lang.c (valid_task_id): Make sure the Ada task list has
        been built before using it.
@
text
@d2 1
a2 1
   2007, 2008, 2009 Free Software Foundation, Inc.
@


1.26
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d201 1
@


1.25
log
@	* value.h (value_subscript, value_subscripted_rvalue,
	value_bitstring_subscript, value_ptradd): Use LONGEST instead
	of value as type of the index argument.
	(value_ptrsub): Remove.
	* valarith.c (value_subscript, value_subscripted_rvalue,
	value_bitstring_subscript, value_ptradd): Use LONGEST instead
	of value as type of the index argument.
	(value_ptrsub): Remove.

	* wrapper.h (gdb_value_subscript): Use LONGEST instead of
	value as type of the index argument.
	* wrapper.c (gdb_value_subscript): Likewise.

	Update calls to gdb_value_subscript, value_subscript,
	value_subscripted_rvalue, value_bitstring_subscript and
	value_ptradd to use LONGEST instead of value as index
	argument type.  Use value_ptradd instead of value_ptrsub.
	* ada-lang.c (ada_value_subscript, ada_value_ptr_subscript,
	ada_tag_name_2): Update.
	* ada-tasks.c (read_atcb): Update.
	* eval.c (evaluate_subexp_standard): Update.
	* valarith.c (value_subscript): Update.
	* gnu-v2-abi.c (gnuv2_virtual_fn_field): Update.
	* gnu-v3-abi.c (gnuv3_get_virtual_fn, gnuv3_baseclass_offset,
	gnuv3_method_ptr_to_value): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* m2-lang.c (evaluate_subexp_modula2): Update.
	* python/python-value.c (valpy_getitem, valpy_binop): Update.
	* wrapper.c (gdb_value_subscript): Update.
	* varobj.c (c_describe_child): Update.
@
text
@d755 2
a756 1
  printf_filtered (_("Ada Task: %s\n"), paddr_nz (task_info->task_id));
@


1.24
log
@	* ada-tasks.c (read_known_tasks_array): Use target_gdbarch instead
	of current_gdbarch.
	* aix-thread.c (pd_enable): Likewise.
	* amd64-linux-nat.c (ps_get_thread_area): Likewise.
	* bsd-uthread.c (bsd_uthread_activate): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* linux-thread-db.c (enable_thread_event): Likewise.
	* monitor.c (monitor_write_memory, monitor_read_memory): Likewise.
	* nto-procfs.c (procfs_open): Likewise.
	* procfs.c (invalidate_cache, procfs_insert_watchpoint,
	info_proc_mappings, info_mappings_callback): Likewise.
	* record.c (record_open): Likewise.
	* rs6000-nat.c (ARCH64): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	(darwin_bfd_open): Likewise.
	* memattr.c (mem_info_command): Likewise.

	* windows-nat.c (win32_resume): Use current regcache architecture
	instead of current_gdbarch.

	* dbug-rom.c (dbug_regname): Remove check against number of
	registers in current_gdbarch.
	* solib-pa64.c (read_dynamic_info): Remove unused variable.
@
text
@d551 2
a552 1
        value_subscript (entry_calls_value, atc_nesting_level_value);
@


1.23
log
@2009-05-27  Tom Tromey  <tromey@@redhat.com>
	    Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* mi/mi-main.c (mi_cmd_data_evaluate_expression): Use
	value_address.
	* cli/cli-dump.c (dump_value_to_file): Use value_address.
	* valprint.c (common_val_print): Likewise.
	* v850-tdep.c (v850_push_dummy_call): Use value_address.
	* tracepoint.c (encode_actions): Use value_address.
	* printcmd.c (print_formatted): Use value_address.
	(x_command): Likewise.
	* p-valprint.c (pascal_object_print_static_field): Use
	value_address.
	* mn10300-tdep.c (mn10300_push_dummy_call): Use value_address.
	* mips-tdep.c (mips_eabi_push_dummy_call): Use value_address.
	* m32r-tdep.c (m32r_push_dummy_call): Use value_address.
	* jv-valprint.c (java_value_print): Use value_address.
	* infcall.c (find_function_addr): Use value_address.
	* gnu-v3-abi.c (gnuv3_rtti_type): Use value_address.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Use value_address.
	* frv-tdep.c (frv_push_dummy_call): Use value_address.
	* frame.c (frame_register_unwind): Use value_address.
	(frame_unwind_register_value): Likewise.
	* darwin-nat-info.c (info_mach_region_command): Use
	value_address.
	* cp-valprint.c (cp_print_static_field): Use value_address.
	* c-valprint.c (c_value_print): Use value_address.
	* breakpoint.c (update_watchpoint): Use value_address.
	(can_use_hardware_watchpoint): Likewise.
	* ada-valprint.c (ada_val_print_1): Use value_address.
	(ada_value_print): Likewise.
	* ada-tasks.c (read_fat_string_value): Use value_address.
	* jv-lang.c (java_link_class_type): Use set_value_address.
	(java_link_class_type): Likewise.
	(get_java_utf8_name): Use value_address.
	(type_from_class): Likewise.
	(java_link_class_type): Likewise.
	* findvar.c (value_of_register): Use set_value_address.
	(read_var_value): Likewise.
	(read_var_value): Likewise.
	* eval.c (evaluate_subexp_standard): Use set_value_address.
	(evaluate_subexp_standard): Use value_address.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Use set_value_address.
	* ada-lang.c (coerce_unspec_val_to_type): Use set_value_address.
	(ada_value_primitive_packed_val): Likewise.
	(ensure_lval): Likewise.
	(thin_data_pntr): Use value_address.
	(desc_bounds): Likewise.
	(ada_value_primitive_packed_val): Likewise.
	(value_assign_to_component): Likewise.
	(ensure_lval): Likewise.
	(make_array_descriptor): Likewise.
	(ada_to_fixed_value): Likewise.
	(unwrap_value): Likewise.
	* value.c (deprecated_value_address_hack): Remove.
	(value_address): New function.
	(value_raw_address): Likewise.
	(set_value_address): Likewise.
	(value_fn_field): Use set_value_address.
	(value_from_contents_and_address): Likewise.
	(value_fn_field): Likewise.
	(allocate_value_lazy): Don't use VALUE_ADDRESS.
	(value_as_address): Use value_address.
	(value_static_field): Likewise.
	* valops.c (search_struct_field): Use set_value_address.
	(value_at): Likewise.
	(value_at_lazy): Likewise.
	(value_repeat): Likewise.
	(value_cast_structs): Use value_address.
	(value_cast): Likewise.
	(value_fetch_lazy): Likewise.
	(value_assign): Likewise.
	(value_repeat): Likewise.
	(address_of_variable): Likewise.
	(value_coerce_array): Likewise.
	(value_coerce_function): Likewise.
	(value_addr): Likewise.
	(search_struct_field): Likewise.
	(search_struct_method): Likewise.
	(find_method_list): Likewise.
	(value_struct_elt_for_reference): Likewise.
	(value_full_object): Likewise.
	* jv-valprint.c (java_value_print): Use set_value_address.
	* value.h (deprecated_value_address_hack): Remove.
	(VALUE_ADDRESS): Remove.
	(value_address): Declare.
	(value_raw_address): Declare.
	(set_value_address): Declare.
@
text
@d612 1
a612 1
    gdbarch_ptr_bit (current_gdbarch) / TARGET_CHAR_BIT;
d635 1
a635 1
        builtin_type (current_gdbarch)->builtin_data_ptr;
@


1.22
log
@        * ada-tasks (task_command_1): Call target_find_new_threads.
@
text
@d274 1
a274 1
  read_memory (VALUE_ADDRESS (array_val), dest, len);
@


1.21
log
@        Provide support for (Ada) task-specific breakpoints.

        * ada-lang.h (ada_get_task_number): Add declaration.
        (breakpoint_ada_task_match): Delete declaration.
        * ada-tasks.c (ada_get_task_number): Make non-static.
        * breakpoint.h (struct breakpoint): Add field "task".
        * breakpoint.c (print_one_breakpoint_location): Add handling of
        task-specific breakpoints.
        (create_breakpoint, create_breakpoints, find_condition_and_thread):
        New parameter "task".
        (break_command_really): Update calls to find_condition_and_thread
        and create_breakpoints.
        (breakpoint_re_set_one): Update call to find_condition_and_thread.
        Set b->task.
@
text
@d868 9
@


1.20
log
@        * ada-tasks.c (short_task_info): Eliminate the "Running" task state.
@
text
@d163 1
a163 1
static int
@


1.19
log
@        * ada-tasks.c (ada_task_is_alive): Move up and make static.
        * ada-lang.h (ada_task_is_alive): Remove declaration.
@
text
@a713 3
  else if (task_info->state == Runnable && active_task_p)
    /* Replace "Runnable" by "Running" since this is the active task.  */
    printf_filtered (" %-22s", _("Running"));
@


1.18
log
@            * ada-tasks.c (task_states,long_task_states): Add new states
            Activating and Acceptor_Delay_Sleep.  Update the description
            of state Acceptor_Sleep.
@
text
@d205 9
a673 9
/* Return non-zero iff the task STATE corresponds to a non-terminated
   task state.  */

int
ada_task_is_alive (struct ada_task_info *task_info)
{
  return (task_info->state != Terminated);
}

@


1.17
log
@        Remove some unused routines.

        * ada-lang.c (is_suppressed_name, ada_suppress_symbol_printing):
        Delete.
        * ada-lang.c (ada_task_list_iterator_ftype)
        (iterate_over_live_ada_tasks): Delete.
        * ada-tasks.c (ada_get_environment_task, iterate_over_live_ada_tasks):
        Delete.
@
text
@d52 3
a54 1
  Interrupt_Server_Blocked_On_Event_Flag
d63 1
a63 1
  N_("Accept Statement"),
d74 3
a76 1
  ""
d85 1
a85 1
  N_("Blocked in accept statement"),
d96 3
a98 1
  ""
@


1.16
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@a198 37
/* Return the task info associated to the Environment Task.
   This function assumes that the inferior does in fact use tasking.  */

static struct ada_task_info *
ada_get_environment_task (void)
{
  ada_build_task_list (0);
  gdb_assert (VEC_length (ada_task_info_s, task_list) > 0);

  /* We use a little bit of insider knowledge to determine which task
     is the Environment Task:  We know that this task is created first,
     and thus should always be task #1, which is at index 0 of the
     TASK_LIST.  */
  return (VEC_index (ada_task_info_s, task_list, 0));
}

/* Call the ITERATOR function once for each Ada task that hasn't been
   terminated yet.  */

void
iterate_over_live_ada_tasks (ada_task_list_iterator_ftype *iterator)
{
  int i, nb_tasks;
  struct ada_task_info *task;

  ada_build_task_list (0);
  nb_tasks = VEC_length (ada_task_info_s, task_list);

  for (i = 0; i < nb_tasks; i++)
    {
      task = VEC_index (ada_task_info_s, task_list, i);
      if (!ada_task_is_alive (task))
        continue;
      iterator (task);
    }
}

@


1.15
log
@        Include frame information for *stopped due to CLI commands.

        * ada-tasks.c (ada_normal_stop_observer): Adjust prototype.
        * infcmd.c (finish_command_continuation): Pass '1' for
        'print_frame' parameter to the observer.
        * infrun.c (normal_stop): Don't print mi-specific information
        here. Pass 'stop_print_frame' to the 'print_frame' parameter
        of the observer.
        * mi/mi-interp.c (mi_on_normal_stop): Adjust prototype.
        If we need to print frame, and current uiout is not the MI one,
        print frame again.
@
text
@d157 1
a157 1
int
d202 1
a202 1
struct ada_task_info *
d945 1
a945 1
void
d963 1
a963 1
void
d976 3
@


1.14
log
@        Updated copyright notices for most files.
@
text
@d954 1
a954 1
ada_normal_stop_observer (struct bpstats *unused_args)
@


1.13
log
@	* ada-tasks.c (task_states, long_task_states): Use constant N_()
	initializer.  Define the strings as const.
	(short_task_info, info_task): Translate the strings above.
@
text
@d1 2
a2 2
/* Copyright (C) 1992, 1993, 1994, 1997, 1998, 1999, 2000, 2003, 2004,
   2005, 2007, 2008 Free Software Foundation, Inc.
@


1.12
log
@        * target.h (struct target_ops): Add new field to_get_ada_task_ptid.
        (target_get_ada_task_ptid): New macro.
        * target.c (default_get_ada_task_ptid): New function.
        (update_current_target): Inherit field default_get_ada_task_ptid.
        (update_current_target): Make default_get_ada_task_ptid the default
        value for field to_get_ada_task_ptid.
        * ada-lang.h (struct task_control_block): Delete. Never used.
        (struct task_ptid, task_ptid_t, struct task_entry, task_list):
        Likewise.
        (struct ada_task_info): New.
        (ada_task_is_alive, ada_find_printable_frame)
        (ada_task_list_iterator_ftype, iterate_over_live_ada_tasks): Add
        declarations.
        (ada_build_task_list): Update prototype.
        (init_task_list, ada_is_exception_breakpoint): Remove prototypes.
        * ada-lang.c (ada_find_printable_frame): Make non-static.
        * ada-tasks.c: New file.
        * Makefile.in (SFILES): Add ada-tasks.c.
        (COMMON_OBS): Add ada-tasks.o.
        * linux-thread-db.c (thread_db_find_thread_from_tid)
        (thread_db_get_ada_task_ptid): New functions.
        (init_thread_db_ops): Set thread_db_ops.to_get_ada_task_ptid.
@
text
@d56 11
a66 11
static char *task_states[] = {
  _("Unactivated"),
  _("Runnable"),
  _("Terminated"),
  _("Child Activation Wait"),
  _("Accept Statement"),
  _("Waiting on entry call"),
  _("Async Select Wait"),
  _("Delay Sleep"),
  _("Child Termination Wait"),
  _("Wait Child in Term Alt"),
d71 1
a71 1
  _("Asynchronous Hold"),
d76 11
a86 11
static char *long_task_states[] = {
  _("Unactivated"),
  _("Runnable"),
  _("Terminated"),
  _("Waiting for child activation"),
  _("Blocked in accept statement"),
  _("Waiting on entry call"),
  _("Asynchronous Selective Wait"),
  _("Delay Sleep"),
  _("Waiting for children termination"),
  _("Waiting for children in terminate alternative"),
d91 1
a91 1
  _("Asynchronous Hold"),
d747 1
a747 1
    printf_filtered (" %-22s", "Running");
d749 1
a749 1
    printf_filtered (" %-22s", task_states[task_info->state]);
d836 1
a836 1
      printf_filtered ("State: %s", long_task_states[task_info->state]);
@


1.11
log
@Removed ada-tasks.c, as ACT plans to rewrite it extensively before
submission.
@
text
@d1 2
a2 4
/* File ada-tasks.c: Ada tasking control for GDB
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
   Contributed by Ada Core Technologies, Inc.
a5 2
   Authors: Roch-Alexandre Nomine Beguin, Arnaud Charlet <charlet@@gnat.com>

d8 1
a8 1
   the Free Software Foundation; either version 2 of the License, or
d11 7
a17 1
*/
a18 2
#include <ctype.h>
#include <gdb_string.h>
d20 2
a21 5
#include "command.h"
#include "value.h"
#include "language.h"
#include "inferior.h"
#include "symtab.h"
d23 1
d25 1
a26 1
#include "regcache.h"       /* for registers_changed */
d28 3
a30 17
#if defined (__fsu__) || defined (HAVE_SPYTHREAD) \
    || (defined(__alpha__) && defined(__osf__) && !defined(__alpha_vxworks))
#include <sys/procfs.h>
#endif

#if defined (__fsu__) || defined (HAVE_SPYTHREAD) \
    || (defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET))
#include "gregset.h"
#endif

#ifdef I386_GNULINUX_TARGET
#include "gdb_thread_db.h"
#endif

#if defined (HAVE_SPYTHREAD)
#include "irix6-spyThread.h"
#endif
d32 2
a33 2
#include "ada-lang.h"
#include "observer.h"
d46 47
a92 1
  Master_Phase_2_Sleep
d102 2
d117 3
d122 27
a148 170
#if defined (linux)
#define TASK_LWP(atcb) 0L
#else
#define TASK_LWP(atcb) extract_unsigned_integer (&(atcb).lwp, sizeof ((atcb).lwp))
#endif

/* FIXME: move all this conditional compilation in description
   files or in configure.in */

#if defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET)
#define SPECIAL_THREAD_SUPPORT_ACTIVE() thread_support
#define SAVE_TASK_REGISTERS(task) \
  do { fill_gregset (&gregset_saved, -1); \
       fill_fpregset (&fpregset_saved, -1); \
  } while (0)
#define RESTORE_TASK_REGISTERS(task) \
  do { supply_gregset (&gregset_saved); \
       supply_fpregset (&fpregset_saved); \
  } while (0)

#define THREAD_FETCH_REGISTERS dec_thread_fetch_registers
#define GET_CURRENT_THREAD(PTID) dec_thread_get_current_thread ()
extern unsigned long dec_thread_get_current_thread (void);
extern int dec_thread_get_registers (gdb_gregset_t *, gdb_fpregset_t *);
extern int dec_thread_fetch_registers (void);
#endif

#ifdef __fsu__
#define SPECIAL_THREAD_SUPPORT_ACTIVE() \
   (thread_support && pthread_kern_addr != 0)
#define SAVE_TASK_REGISTERS(task) \
  do { \
    if (pthread_kern_addr != 0) \
      { \
        fill_gregset (&gregset_saved, -1); \
        fill_fpregset (&fpregset_saved, -1); \
      } \
  } while (0)
#define RESTORE_TASK_REGISTERS(task) \
  do { \
    if (pthread_kern_addr != 0) \
      { \
        supply_gregset (&gregset_saved); \
        supply_fpregset (&fpregset_saved); \
      } \
  } while (0)

extern int fsu_thread_fetch_registers (void);
extern unsigned long fsu_thread_get_current_thread (void);
static int fsu_or_linux_thread_fetch_registers (void);
static long fsu_or_linux_thread_get_current_thread (ptid_t);
#define THREAD_FETCH_REGISTERS fsu_or_linux_thread_fetch_registers
#define GET_CURRENT_THREAD(PTID) fsu_or_linux_thread_get_current_thread (PTID)
#define PTHREAD_KERN "pthread_kern"
#endif

#ifdef I386_GNULINUX_TARGET
extern td_thrinfo_t thread_db_pid_to_thread_info (int pid);
extern int thread_db_tid_to_pid (void *tid);
#endif

#if defined(VXWORKS_TARGET)
#define GET_CURRENT_THREAD(PTID) (unsigned long) ptid_get_pid (PTID)
#define THREAD_FETCH_REGISTERS() (-1)

#elif defined (__WIN32__) || defined (__CYGWIN__) || defined (hpux)
#define GET_CURRENT_THREAD(PTID) ptid_get_pid (PTID)
#define THREAD_FETCH_REGISTERS() (-1)
#endif

#if defined (HAVE_SPYTHREAD)
#define GET_CURRENT_THREAD(PTID) (unsigned long) TIDGET (PTID)
#endif

#if !defined(GET_CURRENT_THREAD)
#define GET_CURRENT_THREAD(PTID) (unsigned long) ptid_get_tid (PTID)
#endif

#if !defined(THREAD_FETCH_REGISTERS)
#define THREAD_FETCH_REGISTERS() (target_fetch_registers (-1), 0)
#endif

#if !defined(SAVE_TASK_REGISTERS)
#define SAVE_TASK_REGISTERS(task)
#define RESTORE_TASK_REGISTERS(task)
#endif

#if !defined(SPECIAL_THREAD_SUPPORT_ACTIVE)
#define SPECIAL_THREAD_SUPPORT_ACTIVE() 0
#endif

#define KNOWN_TASKS_NAME "system__tasking__debug__known_tasks"

#define READ_MEMORY(addr, var) read_memory (addr, (char *) &var, sizeof (var))

/* If defined to 1, means that the thread ptids maintained by core GDB
   follow this format : first field (pid) contains the tid
                       second field (lwp) contains 0
                       third field (tid) contains 0 */
#ifndef THREAD_PTID_CONTAINS_TID_NULL_NULL
#define THREAD_PTID_CONTAINS_TID_NULL_NULL (0)
#endif

/* If defined to 1, means that the thread ptids maintained by core GDB
   follow this format: first field (pid) contains the LWP id
                       second field (lwp) contains 0
                       third field (tid) contains 0 */
#ifndef THREAD_PTID_CONTAINS_LWP_NULL_NULL
#define THREAD_PTID_CONTAINS_LWP_NULL_NULL (0)
#endif

/* If defined to 1, means that the thread ptids maintained by core GDB
   follow this format: first field (pid) contains the PID
                       second field (lwp) contains 0
                       third field (tid) contains the TID */
#ifndef THREAD_PTID_CONTAINS_PID_NULL_TID
#define THREAD_PTID_CONTAINS_PID_NULL_TID (0)
#endif

/* If defined to 1, means that the thread ptids maintained by core GDB
   follow this format: first field (pid) contains the PID
                       second field (lwp) contains the TID
                       third field (tid) contains the 0 */

#ifndef THREAD_PTID_CONTAINS_PID_TID_NULL
#define THREAD_PTID_CONTAINS_PID_TID_NULL (0)
#endif

/* If defined to 1, means that the thread id is not stored in the tid
   field of the task_ptid, but rather in the lwp field.  */
#ifndef ADA_THREAD_ID_IN_LWP
#define ADA_THREAD_ID_IN_LWP (0)
#endif

static int task_ptid_get_pid (task_ptid_t task_ptid);
static long task_ptid_get_lwp (task_ptid_t task_ptid);
static long task_ptid_get_tid (task_ptid_t task_ptid);
static task_ptid_t task_ptid_build (int pid, long lwp, long tid);
static ptid_t task_ptid_get_ptid (task_ptid_t task_ptid);
static long task_ptid_get_thread_id (task_ptid_t task_ptid);

static int task_is_alive (enum task_states state);
static CORE_ADDR get_self_id (ptid_t);
static int get_entry_number (CORE_ADDR);
static void get_tcb_types_info (struct type **atcb_type,
                                struct type **atcb_common_type,
                                struct type **atcb_ll_type,
                                struct tcb_fieldnos *atcb_fieldnos);
static void get_tcb_call_type_info (struct type **atcb_call_type,
                                    int *atcb_call_self_fieldno);
static CORE_ADDR get_known_tasks_addr (void);
static int read_known_tasks_array (void);
static void value_as_string (char *dest, struct value *val, int length);
static struct task_control_block read_atcb (CORE_ADDR atcb_addr);
static CORE_ADDR read_caller (const CORE_ADDR call);
static void display_current_task_id (void);
static void task_command_1 (char *tidstr, int from_tty);

/* Ada-tasks observers.  */

static void normal_stop_notification (void);
static void ada_tasks_attach_observers (void);

/* Global visible variables */

int ada__tasks_check_symbol_table = 1;
CORE_ADDR pthread_kern_addr = 0;
struct task_entry *task_list = NULL;

/* Local global variables.  */
d154 2
a155 4
#if defined (__fsu__) || (defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET))
gdb_gregset_t gregset_saved;
gdb_fpregset_t fpregset_saved;
#endif
d157 2
a158 62
/* The maximum number of tasks known to the Ada runtime */
static const int MAX_NUMBER_OF_KNOWN_TASKS = 1000;

/* the current task, as seen by the user. Modified everytime the user
   does a task switch.  */
static int current_task = -1;

unsigned long current_thread;

/* The task where the debugger stopped, giving control back to the user.
   Not affected by task switching. Used to restore the registers before
   continuing the inferior.  */
int current_task_id = -1;

static char *task_states[] = {
  "Unactivated",
  "Runnable",
  "Terminated",
  "Child Activation Wait",
  "Accept Statement",
  "Waiting on entry call",
  "Async Select Wait",
  "Delay Sleep",
  "Child Termination Wait",
  "Wait Child in Term Alt",
  "",
  "",
  "",
  "",
  "Asynchronous Hold"
};

/* Global internal types */

static char *long_task_states[] = {
  "Unactivated",
  "Runnable",
  "Terminated",
  "Waiting for child activation",
  "Blocked in accept statement",
  "Waiting on entry call",
  "Asynchronous Selective Wait",
  "Delay Sleep",
  "Waiting for children termination",
  "Waiting for children in terminate alternative",
  "",
  "",
  "",
  "",
  "Asynchronous Hold"
};

/* Global internal variables */

static int highest_task_num = 0;
static int thread_support = 0;  /* 1 if the thread library in use is
                                   supported. FIXME: Not reinitialized
                                   properly when program reloaded.
                                 */
#ifdef __fsu__
static int
fsu_or_linux_thread_fetch_registers (void)
d160 1
a160 2
  if (pthread_kern_addr != 0)
    return fsu_thread_fetch_registers ();
d162 3
a164 9
  target_fetch_registers (-1);
  return 0L;
}

static long
fsu_or_linux_thread_get_current_thread (ptid_t ptid)
{
  if (pthread_kern_addr != 0)
    return fsu_thread_get_current_thread ();
d166 1
a166 1
  return ptid_get_tid (ptid);
d169 3
a171 2
#endif /* __fsu__ */

d173 1
a173 1
add_task_entry (CORE_ADDR p_task_id, int index)
d175 1
a175 2
  struct task_entry *new_task_entry = NULL;
  struct task_entry *pt;
d177 1
a177 13
  highest_task_num++;
  new_task_entry = xmalloc (sizeof (struct task_entry));
  new_task_entry->task_num = highest_task_num;
  new_task_entry->task_id = p_task_id;
  new_task_entry->atcb = read_atcb (p_task_id);
  new_task_entry->known_tasks_index = index;
  new_task_entry->task_ptid =
    task_ptid_build (ptid_get_pid (inferior_ptid), /* ? */
                                   TASK_LWP (new_task_entry->atcb),
                                   new_task_entry->atcb.thread);
  new_task_entry->next_task = NULL;
  pt = task_list;
  if (pt)
d179 5
a183 4
      while (pt->next_task)
        pt = pt->next_task;
      pt->next_task = new_task_entry;
      pt->stack_per = 0;
a184 9
  else
    task_list = new_task_entry;
  return new_task_entry->task_num;
}

static int
get_entry_number (CORE_ADDR p_task_id)
{
  struct task_entry *pt;
d186 1
a186 7
  pt = task_list;
  while (pt != NULL)
    {
      if (pt->task_id == p_task_id)
        return pt->task_num;
      pt = pt->next_task;
    }
d190 4
a193 2
static struct task_entry *
get_thread_entry_vptr (long thread)
d195 3
a197 1
  struct task_entry *pt;
d199 2
a200 9
  pt = task_list;
  while (pt != NULL)
    {
      if (task_ptid_get_thread_id (pt->task_ptid) == thread)
        return pt;
      pt = pt->next_task;
    }
  return 0;
}
d202 2
a203 2
static struct task_entry *
get_entry_vptr (int p_task_num)
d205 2
a206 1
  struct task_entry *pt;
d208 5
a212 8
  pt = task_list;
  while (pt)
    {
      if (pt->task_num == p_task_num)
        return pt;
      pt = pt->next_task;
    }
  return NULL;
d215 3
d219 1
a219 1
init_task_list (void)
d221 2
a222 1
  struct task_entry *pt, *old_pt;
d224 2
a225 1
  target_find_new_threads ();
d227 1
a227 2
  pt = task_list;
  while (pt)
d229 5
a233 6
      old_pt = pt;
      pt = pt->next_task;
      xfree (old_pt);
    };
  task_list = NULL;
  highest_task_num = 0;
d236 2
a237 5
int
valid_task_id (int task)
{
  return get_entry_vptr (task) != NULL;
}
d239 2
a240 4
/* Return the pid of a given task ptid.  */

static int
task_ptid_get_pid (task_ptid_t task_ptid)
d242 2
a243 1
  return task_ptid.pid;
d246 4
a249 1
/* Return the lwp of a given task ptid.  */
d251 2
a252 2
static long
task_ptid_get_lwp (task_ptid_t task_ptid)
d254 3
a256 2
  return task_ptid.lwp;
}
d258 6
a263 1
/* Return the tid of a given task ptid.  */
d265 6
a270 5
static long
task_ptid_get_tid (task_ptid_t task_ptid)
{
  return task_ptid.tid;
}
d272 2
a273 1
/* Build a task ptid from the associated pid, lwp, and tid.  */
d275 6
a280 4
static task_ptid_t
task_ptid_build (int pid, long lwp, long tid)
{
  task_ptid_t task_ptid;
d282 2
a283 5
  task_ptid.pid = pid;
  task_ptid.lwp = lwp;
  task_ptid.tid = tid;
  return task_ptid;
}
d285 4
a288 1
/* Translate a task ptid into a ptid (the ptid maintained by core GDB).
d290 3
a292 5
   On most platforms, they are equivalent, and this function can be
   regarded as the identity. However, there are other platforms where
   the task ptid and the ptid are not equivalent. For instance, the task
   LWP value is sometimes stored by GDB-core as a pid! This translation
   therefore becomes necessary before invoking the GDB thread services.  */
d294 3
a296 4
static ptid_t
task_ptid_get_ptid (task_ptid_t task_ptid)
{
  ptid_t ptid;
d298 2
a299 16
  if (THREAD_PTID_CONTAINS_TID_NULL_NULL)
    ptid = ptid_build (task_ptid_get_tid (task_ptid), 0, 0);
  else if (THREAD_PTID_CONTAINS_LWP_NULL_NULL)
    ptid = ptid_build (task_ptid_get_lwp (task_ptid), 0, 0);
  else if (THREAD_PTID_CONTAINS_PID_NULL_TID)
    ptid = ptid_build (task_ptid_get_pid (task_ptid),
                       0, task_ptid_get_tid (task_ptid));
  else if (THREAD_PTID_CONTAINS_PID_TID_NULL)
    ptid = ptid_build (task_ptid_get_pid (task_ptid),
                       task_ptid_get_tid (task_ptid), 0);
  else
    ptid = ptid_build (task_ptid_get_pid (task_ptid),
                       task_ptid_get_lwp (task_ptid),
                       task_ptid_get_tid (task_ptid));

  return ptid;
d302 3
a304 1
/* Extract and return the thread_id for the given TASK_PTID.  */
d306 3
a308 20
static long
task_ptid_get_thread_id (task_ptid_t task_ptid)
{
  /* On most platforms, the thread_id is stored in task_ptid.tid.
     Unfortunately, some other platforms store it as the task_ptid.lwp...  */

  if (ADA_THREAD_ID_IN_LWP)
    return task_ptid_get_lwp (task_ptid);
  else
    return task_ptid_get_tid (task_ptid);
}

/* Return non-zero iff the task STATE corresponds to a non-terminated
   task state.  */

static int
task_is_alive (enum task_states state)
{
  return (state != Terminated);
}
d311 1
a311 1
get_self_id (ptid_t ptid)
d313 1
a313 2
#ifdef GNAT_GDB
  struct task_entry *ent;
d315 1
a315 3
#if !((defined(sun) && defined(__SVR4)) || defined(VXWORKS_TARGET) || defined(__WIN32__))
  if (thread_support)
#endif
d317 2
a318 4
      ent = get_thread_entry_vptr (GET_CURRENT_THREAD (ptid));
      return ent ? ent->task_id : 0;
    }
#endif
d320 8
a327 5
  /* FIXME: calling a function in the inferior with a multithreaded application
     is not reliable, so return a null address if there is no safe way to
     get the current task */
  return 0;
}
d329 22
a350 4
int
ada_get_current_task (ptid_t ptid)
{
  int result;
d352 1
a352 7
  if (current_language->la_language != language_ada)
    return -1;

  result = get_entry_number (get_self_id (ptid));

  /* return -1 if not found */
  return result == 0 ? -1 : result;
d369 1
d375 1
a377 1
#ifndef ADA_RETAIN_DOTS
d379 1
d382 1
a382 5
#else
  const char *atcb_name = "system.tasking.ada_task_control_block___XVE";
  const char *common_atcb_name = "system.tasking.common_atcb";
  const char *private_data_name = "system.task_primitives.private_data";
#endif
d384 2
a385 2
  const struct symbol *atcb_sym =
    lookup_symbol (atcb_name, NULL, VAR_DOMAIN, NULL, NULL);
d387 1
a387 1
    lookup_symbol (common_atcb_name, NULL, VAR_DOMAIN, NULL, NULL);
d389 3
a391 1
    lookup_symbol (private_data_name, NULL, VAR_DOMAIN, NULL, NULL);
d394 18
a411 1
    error ("Can not find Ada_Task_Control_Block type. Aborting");
d413 1
a413 1
    error ("Can not find Common_ATCB type. Aborting");
d415 3
a417 5
    error ("Can not find Private_Data type. Aborting");

  /* Get a static representation of the type record Ada_Task_Control_Block.  */
  type = atcb_sym->type;
  type = ada_template_to_fixed_record_type_1 (type, NULL, 0, NULL, 0);
d425 3
d430 3
d434 1
a434 1
  fieldnos.parent = ada_get_field_index (common_type, "parent", 0);
d436 1
a436 1
  fieldnos.image = ada_get_field_index (common_type, "task_image", 0);
d438 1
a438 1
  fieldnos.call = ada_get_field_index (common_type, "call", 0);
d442 1
d458 1
d462 19
a480 4
/* Get from the debugging information the type description of the
   record type Entry_Call_Record (this is the type of the field
   Call.all in the Common_ATCB record type). Also return the index
   of the field "Self" in Entry_Call_Record.
d482 6
a487 4
   Error handling:  Any data missing from the debugging info will cause
   an error to be raised, and none of the return values to be set.
   Users of this function can depend on the fact that all or none of the
   return values will be set.  */
d490 1
a490 2
get_tcb_call_type_info (struct type **atcb_call_type,
                        int *atcb_call_self_fieldno)
d492 46
a537 2
  struct type *call_type;
  int call_self_fieldno;
d539 3
a541 5
#ifndef ADA_RETAIN_DOTS
  const char *entry_call_record_name = "system__tasking__entry_call_record";
#else
  const char *entry_call_record_name = "system.tasking.entry_call_record";
#endif
d543 1
a543 2
  const struct symbol *entry_call_record_sym =
    lookup_symbol (entry_call_record_name, NULL, VAR_DOMAIN, NULL, NULL);
d545 3
a547 2
  if (entry_call_record_sym == NULL || entry_call_record_sym->type == NULL)
    error ("Can not find Entry_Call_Record type. Aborting");
d549 2
a550 2
  call_type = entry_call_record_sym->type;
  call_self_fieldno = ada_get_field_index (call_type, "self", 0);
d552 6
a557 5
  /* Set all the out parameters all at once, now that we are certain
     that there are no potential error() anymore.  */
  *atcb_call_type = call_type;
  *atcb_call_self_fieldno = call_self_fieldno;
}
d559 2
a560 3
/* Return the address of the Known_Tasks array maintained in
   the Ada Runtime.  Return NULL if the array could not be found,
   meaning that the inferior program probably does not use tasking.
d562 23
a584 3
   In order to provide a fast response time, this function caches
   the Known_Tasks array address after the lookup during the first
   call. Subsequent calls will simply return this cached address.  */
d586 2
a587 4
static CORE_ADDR
get_known_tasks_addr (void)
{
  static CORE_ADDR known_tasks_addr = 0;
d589 2
a590 1
  if (ada__tasks_check_symbol_table)
d592 5
a596 2
      struct symbol *sym;
      struct minimal_symbol *msym;
d598 1
a598 7
      thread_support = 0;
#if (defined(__alpha__) && defined(__osf__) & !defined(VXWORKS_TARGET)) \
    || defined (_AIX) || defined (__CYGWIN__)
      thread_support = 1;
#elif defined (__fsu__)
      msym = lookup_minimal_symbol (PTHREAD_KERN, NULL, NULL);
      if (msym != NULL)
d600 4
a603 2
          pthread_kern_addr = SYMBOL_VALUE_ADDRESS (msym);
          thread_support = 1;
d605 3
a607 8
#elif defined (HAVE_SPYTHREAD)
      thread_support = libspy_enabled;
#endif

#ifdef I386_GNULINUX_TARGET
      /* We support threads via the Linux Threads...  */
      thread_support = 1;
#endif
d609 8
a616 12
      msym = lookup_minimal_symbol (KNOWN_TASKS_NAME, NULL, NULL);
      if (msym != NULL)
        known_tasks_addr = SYMBOL_VALUE_ADDRESS (msym);
      else
#ifndef VXWORKS_TARGET
        return 0;
#else
        {
          if (target_lookup_symbol (KNOWN_TASKS_NAME, &known_tasks_addr) != 0)
            return 0;
        }
#endif
d618 4
a621 22
      /* FIXME: brobecker 2003-03-05: Here would be a much better place
         to attach the ada-tasks observers, instead of doing this
         unconditionaly in _initialize_tasks. This would avoid an
         unecessary notification when the inferior does not use tasking
         or as long as the user does not use the ada-tasks commands.
         Unfortunately, this is not possible for the moment: the current
         code resets ada__tasks_check_symbol_table back to 1 whenever
         symbols for a new program are being loaded. If we place the
         observers intialization here, we will end up adding new observers
         everytime we do the check for Ada tasking-related symbols
         above. This would currently have benign effects, but is still
         undesirable. The cleanest approach is probably to create a new
         observer to notify us when the user is debugging a new program.
         We would then reset ada__tasks_check_symbol_table back to 1
         during the notification, but also detach all observers.
         BTW: observers are probably not reentrant, so detaching during
         a notification may not be the safest thing to do... Sigh...
         But creating the new observer would be a good idea in any case,
         since this allow us to make ada__tasks_check_symbol_table
         static, which is a good bonus.  */
      ada__tasks_check_symbol_table = 0;
    }
d623 2
a624 1
  return known_tasks_addr;
d628 1
a628 1
   it in task_list.  Return non-zero upon success.  */
d633 2
a634 2
  const int target_ptr_byte = TARGET_PTR_BIT / TARGET_CHAR_BIT;
  const int temp_tasks_size = target_ptr_byte * MAX_NUMBER_OF_KNOWN_TASKS;
d636 2
a637 2
  char *temp_tasks = (char *) alloca (temp_tasks_size);
  CORE_ADDR temp_task;
d640 2
a641 2
  /* Step 1: Clear the current list, if any.  */
  init_task_list ();
d653 1
a653 1
  read_memory (known_tasks_addr, temp_tasks, temp_tasks_size);
d656 5
a660 2
      temp_task = extract_typed_address (temp_tasks + i * target_ptr_byte,
					 builtin_type_void_data_ptr);
d662 2
a663 5
      if (temp_task != 0)
        {
          if (get_entry_number (temp_task) == 0)
            add_task_entry (temp_task, i);
        }
d669 1
d678 1
a678 1
ada_build_task_list (void)
d681 1
a681 1
    error ("No stack");
d688 2
a689 1
      printf_filtered ("Your application does not use any Ada task.\n");
d696 2
a697 2
/* Extract the contents of the value as a string whose length is LENGTH,
   and store the result in DEST.  */
d699 2
a700 2
static void
value_as_string (char *dest, struct value *val, int length)
d702 1
a702 1
  memcpy (dest, VALUE_CONTENTS (val), length);
d705 2
a706 4
/* Extract the string image from the fat string corresponding to VAL,
   and store it in DEST. The length of the string is stored in LEN.  If
   the string length is greater than MAX_LEN, then truncate the result
   to the first MAX_LEN characters of the fat string.  */
d709 1
a709 1
read_fat_string_value (char *dest, int *len, struct value *val, int max_len)
d711 3
a713 2
  struct value *array_val;
  struct value *bounds_val;
d715 1
a715 6
  /* The following variables are made static to avoid recomputing them
     each time this function is called.  */
  static int initialize_fieldnos = 1;
  static int array_fieldno;
  static int bounds_fieldno;
  static int upper_bound_fieldno;
d717 2
a718 6
  /* Get the index of the fields that we will need to read in order
     to extract the string from the fat string.  */
  if (initialize_fieldnos)
    {
      struct type *type = VALUE_TYPE (val);
      struct type *bounds_type;
d720 5
a724 17
      array_fieldno = ada_get_field_index (type, "P_ARRAY", 0);
      bounds_fieldno = ada_get_field_index (type, "P_BOUNDS", 0);

      bounds_type = TYPE_FIELD_TYPE (type, bounds_fieldno);
      if (TYPE_CODE (bounds_type) == TYPE_CODE_PTR)
        bounds_type = TYPE_TARGET_TYPE (bounds_type);
      if (TYPE_CODE (bounds_type) != TYPE_CODE_STRUCT)
        error ("Unknown task name format. Aborting");
      upper_bound_fieldno = ada_get_field_index (bounds_type, "UB0", 0);

      initialize_fieldnos = 0;
    }

  /* Get the size of the task image by checking the value of the bounds.
     The lower bound is always 1, so we only need to read the upper bound.  */
  bounds_val = value_ind (value_field (val, bounds_fieldno));
  *len = value_as_long (value_field (bounds_val, upper_bound_fieldno));
d726 2
a727 8
  /* Make sure that we do not read more than max_len characters...  */
  if (*len > max_len)
    *len = max_len;

  /* Extract LEN characters from the fat string.  */
  array_val = value_ind (value_field (val, array_fieldno));
  read_memory (VALUE_ADDRESS (array_val), dest, *len);
}
d729 2
a730 1
/* Read the ATCB stored at ATCB_ADDR from the inferior memory.  */
d732 2
a733 11
static struct task_control_block
read_atcb (CORE_ADDR atcb_addr)
{
  /* The type description for the ATCB record and subrecords, and
     the associated tcb_fieldnos. For efficiency reasons, these are made
     static so that we can compute them only once the first time and
     reuse them later.  */
  static struct type *atcb_type = NULL;
  static struct type *atcb_common_type = NULL;
  static struct type *atcb_ll_type = NULL;
  static struct tcb_fieldnos fieldno;
d735 2
a736 3
  struct task_control_block result;
  struct value *tcb_value;
  struct value *ll_value;
d738 10
a747 24
  if (atcb_type == NULL)
    get_tcb_types_info (&atcb_type, &atcb_common_type, &atcb_ll_type, &fieldno);

  tcb_value = value_from_contents_and_address (atcb_type, NULL, atcb_addr);
  tcb_value = value_field (tcb_value, fieldno.common);

  result.state = value_as_long (value_field (tcb_value, fieldno.state));
  result.parent = value_as_address (value_field (tcb_value, fieldno.parent));
  result.priority = value_as_long (value_field (tcb_value, fieldno.priority));

  /* Depending on the GNAT version used, the task image is either a fat
     string, or a thin array of characters.  Older versions of GNAT used
     to use fat strings, and therefore did not need an extra field in
     the ATCB to store the string length. For efficiency reasons, newer
     versions of GNAT replaced the fat string by a static buffer, but this
     also required the addition of a new field named "Image_Len" containing
     the length of the task name. The method used to extract the task name
     is selected depending on the existence of this field.  */
  if (fieldno.image_len == -1)
    {
      read_fat_string_value (result.image, &result.image_len,
                             value_field (tcb_value, fieldno.image),
                             sizeof (result.image));
    }
d749 1
a749 6
    {
      value_as_string (result.image, value_field (tcb_value, fieldno.image),
                       sizeof (result.image));
      result.image_len =
        value_as_long (value_field (tcb_value, fieldno.image_len));
    }
d751 3
a753 6
  result.call = value_as_address (value_field (tcb_value, fieldno.call));

  ll_value = value_field (tcb_value, fieldno.ll);
  result.thread = value_as_address (value_field (ll_value, fieldno.ll_thread));
  if (fieldno.ll_lwp >= 0)
    result.lwp = value_as_address (value_field (ll_value, fieldno.ll_lwp));
d755 1
a755 3
    result.lwp = 0;

  return result;
d758 2
a759 3
/*  Read the ID of the task with which a task is attempting a rendez-vous
    from the address of its Entry_Call_Record in the Ada TCB.
    If the address of the Entry_Call_Record is null, then return null.  */
d761 2
a762 29
static CORE_ADDR
read_caller (const CORE_ADDR call)
{
  /* The type description for the Entry_Call_Record, and the index of
     the field "Self".  For efficiency reasons, these are made static
     so that we can compute them only once the first time and reuse them
     later.  */
  static struct type *atcb_call_type;
  static int self_fieldno = -1;

  struct value *call_value;

  if (call == 0)
    return 0;

  if (atcb_call_type == NULL)
    get_tcb_call_type_info (&atcb_call_type, &self_fieldno);

  call_value = value_from_contents_and_address (atcb_call_type, NULL, call);
  return value_as_address (value_field (call_value, self_fieldno));
}

#if 0
/* FIXME: Now modified and back in breakpoint.c */
/* breakpoint_task_match (PC) returns true if the breakpoint at PC
   is valid for current task.  */

int
breakpoint_task_match (CORE_ADDR pc)
d764 2
a765 3
  const int this_task = get_current_task ();
  const struct breakpoint *breakpoints = get_breakpoint_chain ();
  const struct breakpoint *b;
d767 4
a770 12
  for (b = breakpoints; b; b = b->next)
    {
      if (b->enable_state != bp_disabled
          && b->enable_state != bp_shlib_disabled
          && (b->address == 0 || b->address == pc)
          && (b->task == 0 || b->task == this_task))
        {
          return 1;
        }
    }

  return 0;
a771 1
#endif
d773 1
a773 1
/* Print detailed information about specified task */
d776 1
a776 1
info_task (char *arg, int from_tty)
d778 3
a780 10
#ifdef GNAT_GDB
  struct task_entry *pt, *pt2;
  CORE_ADDR caller;
  int num;

  if (current_language->la_language != language_ada)
    {
      printf_filtered ("The current language does not support tasks.\n");
      return;
    }
d782 4
a785 8
  target_find_new_threads ();

  pt = get_entry_vptr (atoi (arg));
  if (pt == NULL)
    {
      printf_filtered ("Task %s not found.\n", arg);
      return;
    }
d787 2
a788 2
  /* print the Ada task id */
  printf_filtered ("Ada Task: %s\n", paddr_nz (pt->task_id));
d790 3
a792 3
  /* print the name of the task */
  if (pt->atcb.image_len != 0)
    printf_filtered ("Name: %.*s\n", pt->atcb.image_len, pt->atcb.image);
d794 1
a794 3
    printf_filtered ("<no name>\n");

  /* print the thread id */
d796 3
a798 6
  if (task_ptid_get_tid (pt->task_ptid) < 65536)
    printf_filtered
      ("Thread: %ld\n", (long int) task_ptid_get_tid (pt->task_ptid));
  else
    printf_filtered
      ("Thread: %#lx\n", (long int) task_ptid_get_tid (pt->task_ptid));
d800 4
a803 1
  if (task_ptid_get_lwp (pt->task_ptid) != 0)
d805 2
a806 14
      if ((long) task_ptid_get_lwp (pt->task_ptid) < 65536)
        printf_filtered
          ("LWP: %ld\n", (long int) task_ptid_get_lwp (pt->task_ptid));
      else
        printf_filtered
          ("LWP: %#lx\n", (long int) task_ptid_get_lwp (pt->task_ptid));
    }

  /* print the parent gdb task id */
  num = get_entry_number (pt->atcb.parent);
  if (num != 0)
    {
      printf_filtered ("Parent: %d", num);
      pt2 = get_entry_vptr (num);
d808 4
a811 5
      /* print the name of the task */
      if (pt2->atcb.image_len != 0)
	printf_filtered (" (%.*s)\n", pt2->atcb.image_len, pt2->atcb.image);
      else
	printf_filtered ("\n");
d814 1
a814 1
    printf_filtered ("No parent\n");
d816 2
a817 2
  /* print the base priority of the task */
  printf_filtered ("Base Priority: %d\n", pt->atcb.priority);
d819 3
a821 1
  /* print the current state of the task */
d823 14
a836 92
  /* check if this task is accepting a rendezvous */
  caller = read_caller (pt->atcb.call);
  if (caller != 0)
    {
      num = get_entry_number (caller);
      printf_filtered ("Accepting rendezvous with %d", num);

      if (num != 0)
	{
	  pt2 = get_entry_vptr (num);

	  /* print the name of the task */
	  if (pt2->atcb.image_len != 0) {
	    printf_filtered (" (%.*s)\n", pt2->atcb.image_len, pt2->atcb.image);
	  }
	  else
	    printf_filtered ("\n");
	}
      else
        printf_filtered ("\n");
    }
  else
    printf_filtered ("State: %s\n", long_task_states[pt->atcb.state]);
#endif
}

/* Print information about currently known tasks */

static void
info_tasks (char *arg, int from_tty)
{
#ifdef GNAT_GDB
  struct task_entry *pt;
  CORE_ADDR caller;
  long thread_id = 0L;
  int size;
  char car;
  ptid_t current_ptid;

#if defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET)
  pthreadTeb_t thr;
  gdb_gregset_t regs;
#endif

  current_ptid = inferior_ptid;

#if !((defined(sun) && defined(__SVR4)) || defined(VXWORKS_TARGET) || defined(__WIN32__) || defined (hpux))
  if (thread_support)
#endif
    thread_id = GET_CURRENT_THREAD (inferior_ptid);

  /* print the header */

#if defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET)
  printf_filtered
    ("  ID       TID P-ID Pri Stack  %% State                  Name\n");
#else
  printf_filtered ("  ID       TID P-ID Pri State                  Name\n");
#endif

  /* Now that we have a list of task id's, we can print them */
  pt = task_list;
  while (pt)
    {
      /* print a star if this task is the current one */
      if (thread_id)
#if defined (__WIN32__) || defined (SGI) || defined (hpux)
        printf_filtered
          (task_ptid_get_lwp (pt->task_ptid) == thread_id ? "*" : " ");
#else
        printf_filtered
          (task_ptid_get_thread_id (pt->task_ptid) == thread_id ? "*" : " ");
#endif

      /* print the gdb task id */
      printf_filtered ("%3d", pt->task_num);

      /* print the Ada task id */
      printf_filtered (" %9lx", (long) pt->task_id);

      /* print the parent gdb task id */
      printf_filtered (" %4d", get_entry_number (pt->atcb.parent));

      /* print the base priority of the task */
      printf_filtered (" %3d", pt->atcb.priority);

#if defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET)
      if (pt->task_num == 1 || pt->atcb.state == Terminated)
        {
          printf_filtered ("  Unknown");
          goto next;
        }
d838 4
a841 77
      READ_MEMORY (pt->atcb.thread, thr);
      switch_to_thread (task_ptid_get_ptid (pt->task_ptid));
      /* ??? Brobecker 2003-03-13: Not sure what the next line is used for.
         And even if useful, it should probably be replaced by call to
         task_ptid_get_thread_id.  */
      current_thread = task_ptid_get_tid (pt->task_ptid);
      regs.regs[SP_REGNUM] = 0;
      if (dec_thread_get_registers (&regs, NULL) == 0)
        {
          pt->stack_per = (100 * ((long) thr.__stack_base -
                                  regs.regs[SP_REGNUM])) / thr.__stack_size;
          /* if the thread is terminated but still there, the
             stack_base/size values are erroneous. Try to patch it */
          if (pt->stack_per < 0 || pt->stack_per > 100)
            pt->stack_per = 0;
        }
      else
        {
          /* Set stack_per to an invalid value to signal that we did not
             manage to compute its value.  */
          pt->stack_per = -1;
        }

      /* print information about stack space used in the thread */
      if (thr.__stack_size < 1024 * 1024)
        {
          size = thr.__stack_size / 1024;
          car = 'K';
        }
      else if (thr.__stack_size < 1024 * 1024 * 1024)
        {
          size = thr.__stack_size / 1024 / 1024;
          car = 'M';
        }
      else                      /* Who knows... */
        {
          size = thr.__stack_size / 1024 / 1024 / 1024;
          car = 'G';
        }

      /* print the stack usage in percent, if available.  */
      if (pt->stack_per != -1)
        printf_filtered (" %4d%c %2d", size, car, pt->stack_per);
      else
        {
          /* This error is not serious enough that we should raise
             an internal error, but print '???' to make it unambiguous
             that we failed to compute this value.  */
          printf_filtered (" ???");
        }

    next:
#endif

      /* print the current state of the task */

      /* check if this task is accepting a rendezvous */
      caller = read_caller (pt->atcb.call);
      if (caller != 0)
        printf_filtered (" Accepting RV with %-4d",
                         get_entry_number (caller));
      else
        {
#if defined (__WIN32__) || defined (SGI) || defined (hpux)
          if (pt->atcb.state == Runnable
              && (thread_id
                  && task_ptid_get_lwp (pt->task_ptid) == thread_id))
#else
          if (pt->atcb.state == Runnable
              && (thread_id
                  && task_ptid_get_thread_id (pt->task_ptid) == thread_id))
#endif
            /* Replace "Runnable" by "Running" if this is the current task */
            printf_filtered (" %-22s", "Running");
          else
            printf_filtered (" %-22s", task_states[pt->atcb.state]);
        }
d843 2
a844 3
      /* finally, print the name of the task */
      if (pt->atcb.image_len != 0) {
        printf_filtered (" %.*s\n", pt->atcb.image_len, pt->atcb.image);
a845 2
      else
	printf_filtered (" <no name>\n");
d847 2
a848 5
      pt = pt->next_task;
    }
  if (!ptid_equal (inferior_ptid, current_ptid))
    switch_to_thread (current_ptid);
#endif
d851 6
d860 1
a860 1
  const int task_list_built = ada_build_task_list ();
d865 2
a866 2
  if (arg == NULL || *arg == '\000')
    info_tasks (arg, from_tty);
a870 47
/* Switch to task indicated by NEW_TASK.  Return 0 iff successful.  */

static int
switch_to_task (struct task_entry *new_task)
{
#ifdef GNAT_GDB
  /* Raise an error if task-switching is currently not allowed.  */
  if (!THREAD_SWITCH_ALLOWED ())
    error ("Task switching is currently not allowed.");

  if (!task_is_alive (new_task->atcb.state))
    error ("Can not switch to task %d: Task is no longer running",
           new_task->task_num);

  current_task = new_task->task_num;
  current_thread = task_ptid_get_thread_id (new_task->task_ptid);

  if (current_task_id == -1)
    {
      SAVE_TASK_REGISTERS (new_task);
      current_task_id = ada_get_current_task (inferior_ptid);
    }

  if (SPECIAL_THREAD_SUPPORT_ACTIVE ())
    {
      /* FIXME: Integrate with switch_to_thread */
      int ret_code;
      flush_cached_frames ();
      registers_changed ();
      if (current_task == current_task_id)
        {
          RESTORE_TASK_REGISTERS (new_task);
          ret_code = 0;
        }
      else
        ret_code = THREAD_FETCH_REGISTERS ();
      if (ret_code == 0)
        stop_pc = read_pc ();
      select_frame (get_current_frame ());
      return ret_code;
    }

  switch_to_thread (task_ptid_get_ptid (new_task->task_ptid));
#endif
  return 0;
}

d872 1
a872 2
   Print an error message if the application does not appear to
   be using any Ada task.  */
d875 1
a875 1
display_current_task_id (void) 
d877 1
a877 1
  const int current_task = ada_get_current_task (inferior_ptid);
d879 2
a880 2
  if (current_task == -1)
    printf_filtered ("[Current task is unknown]\n");
d882 1
a882 1
    printf_filtered ("[Current task is %d]\n", current_task);
d889 1
a889 1
task_command_1 (char *tidstr, int from_tty)
d891 2
a892 2
  const int num = value_as_long (parse_and_eval (tidstr));
  struct task_entry *e = get_entry_vptr (num);
d894 4
a897 3
  if (e == NULL)
    error ("Task ID %d not known.  Use the \"info tasks\" command to\n"
           "see the IDs of currently known tasks", num);
d899 8
a906 9
  if (switch_to_task (e) == 0)
    {
      ada_find_printable_frame (get_selected_frame ());
      printf_filtered ("[Switching to task %d]\n", num);
      print_stack_frame (get_selected_frame (),
                         frame_relative_level (get_selected_frame ()), 1);
    }
  else
    printf_filtered ("Unable to switch to task %d\n", num);
d909 3
a911 2
/* Switch to task indicated in TIDSTR.  Simply print the current task
   if TIDSTR is empty or NULL.  */
d914 1
a914 1
task_command (char *tidstr, int from_tty)
d916 1
a916 1
  const int task_list_built = ada_build_task_list ();
d921 1
a921 1
  if (tidstr == NULL || tidstr[0] == '\0')
a923 9
    task_command_1 (tidstr, from_tty);
}

#if defined (__fsu__) || (defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET))
/* Restore saved registers if there was a task switch.  */
void
ada_reset_thread_registers (void)
{
  if (current_task_id != -1 && SPECIAL_THREAD_SUPPORT_ACTIVE ())
d925 15
a939 4
      supply_gregset (&gregset_saved);
      supply_fpregset (&fpregset_saved);
      reinit_frame_cache ();
      stop_pc = read_pc ();
a940 1
  current_task_id = -1;
d942 3
a944 1
#else
d946 1
a946 1
ada_reset_thread_registers (void)
d948 1
a949 1
#endif
d954 1
a954 1
normal_stop_notification (void)
d958 1
a958 1
  stale_task_list_p = 1;
d961 1
a961 1
/* Attach all the observers needed by the ada-tasks module.  */
d963 2
a964 2
static void
ada_tasks_attach_observers (void)
d966 8
a973 1
  observer_attach_normal_stop (&normal_stop_notification);
d979 3
a981 4
#ifdef GNAT_GDB
  extern struct cmd_list_element *cmdlist;

  ada_tasks_attach_observers ();
d983 1
d985 1
a985 3
            "Without argument: list all known Ada tasks, with status information.\n"
            "info tasks n: print detailed information of task n.");

d987 2
a988 2
           "Without argument: print the current task ID.\n"
           "task n: Use this command to switch to task n.",
a989 1
#endif
d991 1
@


1.10
log
@	* ada-tasks.c: Rename build_task_list to ada_build_task_list, and
	make it non-static.
	* ada-lang.h (task_control_block): declaration moved from ada-task.c
	to ada-lang.h; this is needed to be able to implement the kill command
	in multi-task mode.
	(task_ptid): Ditto.
	(task_entry): Ditto.
	(task_list): Ditto.
	(ada_build_task_list): Ditto.

	* ada-lang.c: Conditionalize routines and data structures related
	to breakpoints, exceptions, completion, and symbol caching on
	GNAT_GDB, since these are not yet used in the submitted public sources.
	(ada_main_name): Editorial: Move definition out of exception-related
	code.
@
text
@@


1.9
log
@ada-exp.y: Synchronize with current ACT sources.
ada-lang.c: Ditto.
ada-lang.h: Ditto.
ada-lex.l: Ditto.
ada-tasks.c: Ditto.
ada-typeprint.c: Ditto.
ada-valprint.c: Ditto.
@
text
@a64 12
struct task_control_block
{
  char state;
  CORE_ADDR parent;
  int priority;
  char image [32];
  int image_len;    /* This field is not always present in the ATCB.  */
  CORE_ADDR call;
  CORE_ADDR thread;
  CORE_ADDR lwp;    /* This field is not always present in the ATCB.  */
};

a92 19
struct task_ptid
{
  int pid;                      /* The Process id */
  long lwp;                     /* The Light Weight Process id */
  long tid;                     /* The Thread id */
};
typedef struct task_ptid task_ptid_t;

struct task_entry
{
  CORE_ADDR task_id;
  struct task_control_block atcb;
  int task_num;
  int known_tasks_index;
  struct task_entry *next_task;
  task_ptid_t task_ptid;
  int stack_per;
};

a238 1
static int build_task_list (void);
d254 1
a256 1
static struct task_entry *task_list = NULL;
d821 2
a822 2
static int
build_task_list (void)
d1277 1
a1277 1
  const int task_list_built = build_task_list ();
d1329 2
a1330 5
  else if (task_ptid_get_pid (new_task->task_ptid) != 0)        /* ?? */
    {
      switch_to_thread (task_ptid_get_ptid (new_task->task_ptid));
      return 0;
    }
d1332 1
a1332 1
  return -1;
d1380 1
a1380 1
  const int task_list_built = build_task_list ();
@


1.8
log
@2004-04-28  Andrew Cagney  <cagney@@redhat.com>

	* stack.c (print_stack_frame_stub): Delete declaration.
	(struct print_stack_frame_args, print_stack_frame)
	(print_frame_info, print_frame): Replace "source" with print what.
	Replace "print" with "print_level".  Replace "args" with
	"print_args".
	* frame.h (show_and_print_stack_frame, print_stack_frame)
	(print_frame_info): Update declarations.
	* stack.c (select_and_print_frame, frame_command)
	(current_frame_command, up_command, down_command): Update calls -
	use get_selected_frame, pass "enum print_what" for source, do not
	call frame_relative_level.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames): Ditto.
	* remote-rdp.c (remote_rdp_open): Ditto.
	* remote-mips.c (common_open): Ditto.
	* remote-e7000.c (e7000_start_remote): Ditto.
	* ocd.c (ocd_start_remote): Ditto.
	* mi/mi-main.c (mi_cmd_exec_return): Ditto.
	* infrun.c (normal_stop): Ditto.
	* inflow.c (kill_command): Ditto.
	* infcmd.c (finish_command): Ditto.
	* corelow.c (core_open): Ditto.
	* tracepoint.c (finish_tfind_command): Ditto.
	* thread.c (info_threads_command, info_threads_command)
	(restore_current_thread, do_captured_thread_select): Ditto.
	* ada-tasks.c (task_command): Ditto.
@
text
@d1 5
a5 4
/* file ada-tasks.c: Ada tasking control for GDB
   Copyright 1997 Free Software Foundation, Inc.
   Contributed by Ada Core Technologies, Inc
.
a7 1
   [$Id: ada-tasks.c,v 1.7 2003/06/17 20:58:32 ciceron Exp $]
d18 1
a25 1
#include "regcache.h"
d27 2
d30 2
a31 1
#if (defined(__alpha__) && defined(__osf__) && !defined(__alpha_vxworks))
d35 2
a36 1
#if (defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET))
d40 8
d49 1
d51 13
a63 2
/* FIXME: move all this conditional compilation in description
   files or in configure.in */
d65 11
a75 2
#if defined (VXWORKS_TARGET)
#define THREAD_TO_PID(tid,lwpid) (tid)
d77 2
a78 2
#elif defined (linux)
#define THREAD_TO_PID(tid,lwpid) (0)
d80 4
a83 2
#elif (defined (sun) && defined (__SVR4))
#define THREAD_TO_PID thread_to_pid
d85 13
a97 2
#elif defined (sgi) || defined (__WIN32__) || defined (hpux)
#define THREAD_TO_PID(tid,lwpid) ((int)lwpid)
d99 2
d102 1
a102 1
#define THREAD_TO_PID(tid,lwpid) (0)
d105 22
d128 10
d139 2
a140 1
#define GET_CURRENT_THREAD dec_thread_get_current_thread
d142 1
d145 32
a176 3
#if defined (_AIX)
#define THREAD_FETCH_REGISTERS aix_thread_fetch_registers
#define GET_CURRENT_THREAD aix_thread_get_current_thread
d180 1
a180 1
#define GET_CURRENT_THREAD() ((void*)inferior_pid)
d183 2
a184 2
#elif defined (sun) && defined (__SVR4)
#define GET_CURRENT_THREAD solaris_thread_get_current_thread
d186 5
a190 1
extern void *GET_CURRENT_THREAD ();
d192 7
a198 2
#elif defined (_AIX) || (defined(__alpha__) && defined(__osf__))
extern void *GET_CURRENT_THREAD ();
d200 4
a203 3
#elif defined (__WIN32__) || defined (hpux)
#define GET_CURRENT_THREAD() (inferior_pid)
#define THREAD_FETCH_REGISTERS() (-1)
d205 2
a206 3
#else
#define GET_CURRENT_THREAD() (NULL)
#define THREAD_FETCH_REGISTERS() (-1)
d211 70
a280 2
#define READ_MEMORY(addr, var) read_memory (addr, (char*) &var, sizeof (var))
/* external declarations */
a283 1
struct task_entry *task_list = NULL;
d285 8
a292 1
void *pthread_kern_addr = NULL;
d294 1
a294 1
#if (defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET))
d300 1
a300 1
const int MAX_NUMBER_OF_KNOWN_TASKS = 1000;
d302 3
a304 3
/* the current task */
int current_task = -1, current_task_id = -1, current_task_index;
void *current_thread, *current_lwp;
d306 8
a313 1
char *ada_task_states[] = {
d333 1
a333 1
static char *ada_long_task_states[] = {
d354 25
a378 2
int thread_support = 0;		/* 1 if the thread library in use is supported */
static int gdbtk_task_initialization = 0;
d381 1
a381 1
add_task_entry (void *p_task_id, int index)
d390 1
d392 4
d401 1
a401 1
	pt = pt->next_task;
d410 2
a411 2
int
get_entry_number (void *p_task_id)
d419 1
a419 1
	return pt->task_num;
d426 1
a426 1
get_thread_entry_vptr (void *thread)
d433 2
a434 2
      if (pt->thread == thread)
	return pt;
d449 1
a449 1
	return pt;
d460 2
d479 93
a571 2
void *
get_self_id (void)
d573 1
a573 3
  struct value *val;
  void *self_id;
  int result;
a574 1
  extern int do_not_insert_breakpoints;
d580 1
a580 1
      ent = get_thread_entry_vptr (GET_CURRENT_THREAD ());
d583 1
d586 3
a588 3
     is not reliable, so return NULL if there is no safe way to get the current
     task */
  return NULL;
d592 1
a592 1
get_current_task (void)
d596 2
a597 2
  /* FIXME: language_ada should be defined in defs.h */
  /*  if (current_language->la_language != language_ada) return -1; */
d599 1
a599 1
  result = get_entry_number (get_self_id ());
d605 442
d1052 1
a1052 1
  void *temp_task;
d1054 1
a1054 5
  void *self_id, *caller;
  struct task_fields atcb, atcb2;
  struct entry_call call;
  int bounds[2];
  char image[256];
d1057 8
a1064 7
  /* FIXME: language_ada should be defined in defs.h */
  /*  if (current_language->la_language != language_ada) 
     { 
     printf_filtered ("The current language does not support tasks.\n"); 
     return; 
     } 
   */
a1071 5
  temp_task = pt->task_id;

  /* read the atcb in the inferior */
  READ_MEMORY ((CORE_ADDR) temp_task, atcb);

d1073 1
a1073 1
  printf_filtered ("Ada Task: %p\n", temp_task);
d1076 2
a1077 8
  if (atcb.image.P_ARRAY != NULL)
    {
      READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb.image.P_BOUNDS), bounds);
      bounds[1] = EXTRACT_INT (bounds[1]);
      read_memory ((CORE_ADDR) EXTRACT_ADDRESS (atcb.image.P_ARRAY),
		   (char *) &image, bounds[1]);
      printf_filtered ("Name: %.*s\n", bounds[1], image);
    }
d1083 3
a1085 2
  if ((long) pt->thread < 65536)
    printf_filtered ("Thread: %ld\n", (long int) pt->thread);
d1087 2
a1088 1
    printf_filtered ("Thread: %p\n", pt->thread);
d1090 1
a1090 1
  if ((long) pt->lwp != 0)
d1092 3
a1094 2
      if ((long) pt->lwp < 65536)
	printf_filtered ("LWP: %ld\n", (long int) pt->lwp);
d1096 2
a1097 1
	printf_filtered ("LWP: %p\n", pt->lwp);
d1101 1
a1101 1
  num = get_entry_number (EXTRACT_ADDRESS (atcb.parent));
a1105 1
      READ_MEMORY ((CORE_ADDR) pt2->task_id, atcb2);
d1108 2
a1109 9
      if (atcb2.image.P_ARRAY != NULL)
	{
	  READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb2.image.P_BOUNDS),
		       bounds);
	  bounds[1] = EXTRACT_INT (bounds[1]);
	  read_memory ((CORE_ADDR) EXTRACT_ADDRESS (atcb2.image.P_ARRAY),
		       (char *) &image, bounds[1]);
	  printf_filtered (" (%.*s)\n", bounds[1], image);
	}
d1117 1
a1117 1
  printf_filtered ("Base Priority: %d\n", EXTRACT_INT (atcb.priority));
d1122 2
a1123 9
  if (atcb.call == NULL)
    caller = NULL;
  else
    {
      READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb.call), call);
      caller = EXTRACT_ADDRESS (call.self);
    }

  if (caller != NULL)
a1130 1
	  READ_MEMORY ((CORE_ADDR) pt2->task_id, atcb2);
d1133 3
a1135 9
	  if (atcb2.image.P_ARRAY != NULL)
	    {
	      READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb2.image.P_BOUNDS),
			   bounds);
	      bounds[1] = EXTRACT_INT (bounds[1]);
	      read_memory ((CORE_ADDR) EXTRACT_ADDRESS (atcb2.image.P_ARRAY),
			   (char *) &image, bounds[1]);
	      printf_filtered (" (%.*s)\n", bounds[1], image);
	    }
d1140 1
a1140 1
	printf_filtered ("\n");
d1143 2
a1144 43
    printf_filtered ("State: %s\n", ada_long_task_states[atcb.state]);
}

#if 0

/* A useful function that shows the alignment of all the fields in the
   tasks_fields structure
 */

print_align (void)
{
  struct task_fields tf;
  void *tf_base = &(tf);
  void *tf_state = &(tf.state);
  void *tf_entry_num = &(tf.entry_num);
  void *tf_parent = &(tf.parent);
  void *tf_priority = &(tf.priority);
  void *tf_current_priority = &(tf.current_priority);
  void *tf_image = &(tf.image);
  void *tf_call = &(tf.call);
  void *tf_thread = &(tf.thread);
  void *tf_lwp = &(tf.lwp);
  printf_filtered ("\n");
  printf_filtered ("(tf_base = 0x%x)\n", tf_base);
  printf_filtered ("task_fields.entry_num        at %3d (0x%x)\n",
		   tf_entry_num - tf_base, tf_entry_num);
  printf_filtered ("task_fields.state            at %3d (0x%x)\n",
		   tf_state - tf_base, tf_state);
  printf_filtered ("task_fields.parent           at %3d (0x%x)\n",
		   tf_parent - tf_base, tf_parent);
  printf_filtered ("task_fields.priority         at %3d (0x%x)\n",
		   tf_priority - tf_base, tf_priority);
  printf_filtered ("task_fields.current_priority at %3d (0x%x)\n",
		   tf_current_priority - tf_base, tf_current_priority);
  printf_filtered ("task_fields.image            at %3d (0x%x)\n",
		   tf_image - tf_base, tf_image);
  printf_filtered ("task_fields.call             at %3d (0x%x)\n",
		   tf_call - tf_base, tf_call);
  printf_filtered ("task_fields.thread           at %3d (0x%x)\n",
		   tf_thread - tf_base, tf_thread);
  printf_filtered ("task_fields.lwp              at %3d (0x%x)\n",
		   tf_lwp - tf_base, tf_lwp);
  printf_filtered ("\n");
a1145 1
#endif
d1152 1
a1152 3
  struct value *val;
  int i, task_number, state;
  void *temp_task, *temp_tasks[MAX_NUMBER_OF_KNOWN_TASKS];
d1154 2
a1155 5
  void *self_id, *caller, *thread_id = NULL;
  struct task_fields atcb;
  struct entry_call call;
  int bounds[2];
  char image[256];
d1158 1
d1165 1
a1165 42
  static struct symbol *sym;
  static struct minimal_symbol *msym;
  static void *known_tasks_addr = NULL;

  int init_only = gdbtk_task_initialization;
  gdbtk_task_initialization = 0;

  task_number = 0;

  if (PIDGET (inferior_ptid) == 0)
    {
      printf_filtered ("The program is not being run under gdb. ");
      printf_filtered ("Use 'run' or 'attach' first.\n");
      return;
    }

  if (ada__tasks_check_symbol_table)
    {
      thread_support = 0;
#if (defined(__alpha__) && defined(__osf__) & !defined(VXWORKS_TARGET)) || \
    defined (_AIX)
      thread_support = 1;
#endif

      msym = lookup_minimal_symbol (KNOWN_TASKS_NAME, NULL, NULL);
      if (msym != NULL)
	known_tasks_addr = (void *) SYMBOL_VALUE_ADDRESS (msym);
      else
#ifndef VXWORKS_TARGET
	return;
#else
	{
	  if (target_lookup_symbol (KNOWN_TASKS_NAME, &known_tasks_addr) != 0)
	    return;
	}
#endif

      ada__tasks_check_symbol_table = 0;
    }

  if (known_tasks_addr == NULL)
    return;
d1170 1
a1170 25
    thread_id = GET_CURRENT_THREAD ();

  /* then we get a list of tasks created */

  init_task_list ();

  READ_MEMORY ((CORE_ADDR) known_tasks_addr, temp_tasks);

  for (i = 0; i < MAX_NUMBER_OF_KNOWN_TASKS; i++)
    {
      temp_task = EXTRACT_ADDRESS (temp_tasks[i]);

      if (temp_task != NULL)
	{
	  task_number = get_entry_number (temp_task);
	  if (task_number == 0)
	    task_number = add_task_entry (temp_task, i);
	}
    }

  /* Return without printing anything if this function was called in
     order to init GDBTK tasking. */

  if (init_only)
    return;
a1184 14
      temp_task = pt->task_id;

      /* read the atcb in the inferior */
      READ_MEMORY ((CORE_ADDR) temp_task, atcb);

      /* store the thread id for future use */
      pt->thread = EXTRACT_ADDRESS (atcb.thread);

#if defined (linux)
      pt->lwp = (void *) THREAD_TO_PID (atcb.thread, 0);
#else
      pt->lwp = EXTRACT_ADDRESS (atcb.lwp);
#endif

d1188 2
a1189 1
	printf_filtered (pt->lwp == thread_id ? "*" : " ");
d1191 2
a1192 1
	printf_filtered (pt->thread == thread_id ? "*" : " ");
d1199 1
a1199 9
#ifndef VXWORKS_TARGET
      printf_filtered (" %9lx", (long) temp_task);
#else
#ifdef TARGET_64
      printf_filtered (" %#9lx", (unsigned long) pt->thread & 0x3ffffffffff);
#else
      printf_filtered (" %#9lx", (long) pt->thread);
#endif
#endif
d1202 1
a1202 2
      printf_filtered
	(" %4d", get_entry_number (EXTRACT_ADDRESS (atcb.parent)));
d1205 1
a1205 1
      printf_filtered (" %3d", EXTRACT_INT (atcb.priority));
d1208 12
a1219 8
      if (pt->task_num == 1 || atcb.state == Terminated)
	{
	  printf_filtered ("  Unknown");
	  goto next;
	}

      read_memory ((CORE_ADDR) atcb.thread, &thr, sizeof (thr));
      current_thread = atcb.thread;
d1222 14
a1235 8
	{
	  pt->stack_per = (100 * ((long) thr.__stack_base -
				  regs.regs[SP_REGNUM])) / thr.__stack_size;
	  /* if the thread is terminated but still there, the
	     stack_base/size values are erroneous. Try to patch it */
	  if (pt->stack_per < 0 || pt->stack_per > 100)
	    pt->stack_per = 0;
	}
d1239 4
a1242 4
	{
	  size = thr.__stack_size / 1024;
	  car = 'K';
	}
d1244 21
a1264 10
	{
	  size = thr.__stack_size / 1024 / 1024;
	  car = 'M';
	}
      else			/* Who knows... */
	{
	  size = thr.__stack_size / 1024 / 1024 / 1024;
	  car = 'G';
	}
      printf_filtered (" %4d%c %2d", size, car, pt->stack_per);
d1271 4
a1274 11
      if (atcb.call == NULL)
	caller = NULL;
      else
	{
	  READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb.call), call);
	  caller = EXTRACT_ADDRESS (call.self);
	}

      if (caller != NULL)
	printf_filtered (" Accepting RV with %-4d",
			 get_entry_number (caller));
d1276 1
a1276 2
	{
	  state = atcb.state;
d1278 3
a1280 1
	  if (state == Runnable && (thread_id && pt->lwp == thread_id))
d1282 9
a1290 7
	  if (state == Runnable && (thread_id && pt->thread == thread_id))
#endif
	    /* Replace "Runnable" by "Running" if this is the current task */
	    printf_filtered (" %-22s", "Running");
	  else
	    printf_filtered (" %-22s", ada_task_states[state]);
	}
d1293 3
a1295 9
      if (atcb.image.P_ARRAY != NULL)
	{
	  READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb.image.P_BOUNDS),
		       bounds);
	  bounds[1] = EXTRACT_INT (bounds[1]);
	  read_memory ((CORE_ADDR) EXTRACT_ADDRESS (atcb.image.P_ARRAY),
		       (char *) &image, bounds[1]);
	  printf_filtered (" %.*s\n", bounds[1], image);
	}
d1301 3
d1306 2
a1307 6
/* Task list initialization for GDB-Tk.  We basically use info_tasks()
   to initialize our variables, but abort that function before we
   actually print anything. */

int
gdbtk_tcl_tasks_initialize (void)
d1309 1
a1309 2
  gdbtk_task_initialization = 1;
  info_tasks ("", gdb_stdout);
d1311 2
a1312 2
  return (task_list != NULL);
}
a1313 3
static void
info_tasks_command (char *arg, int from_tty)
{
d1320 1
a1320 1
/* Switch from one thread to another. */
d1322 2
a1323 2
static void
switch_to_thread (ptid_t ptid)
d1325 8
a1332 2
  if (ptid_equal (ptid, inferior_ptid))
    return;
d1334 2
a1335 6
  inferior_ptid = ptid;
  flush_cached_frames ();
  registers_changed ();
  stop_pc = read_pc ();
  select_frame (get_current_frame ());
}
d1337 5
a1341 6
/* Switch to a specified task. */

static int
task_switch (void *tid, void *lwpid)
{
  int res = 0, pid;
d1343 1
a1343 1
  if (thread_support)
d1345 2
d1348 6
a1353 5

      if (current_task != current_task_id)
	{
	  res = THREAD_FETCH_REGISTERS ();
	}
d1355 3
a1357 9
	{
#if (defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET))
	  supply_gregset (&gregset_saved);
	  supply_fpregset (&fpregset_saved);
#endif
	}

      if (res == 0)
	stop_pc = read_pc ();
d1359 6
a1364 1
      return res;
d1366 1
a1366 1

d1370 4
d1375 1
a1375 1
task_command (char *tidstr, int from_tty)
d1377 7
a1383 2
  int num;
  struct task_entry *e;
d1385 2
a1386 3
  if (!tidstr)
    error ("Please specify a task ID.  Use the \"info tasks\" command to\n"
	   "see the IDs of currently known tasks.");
d1388 5
a1392 2
  num = atoi (tidstr);
  e = get_entry_vptr (num);
d1396 1
a1396 1
	   "see the IDs of currently known tasks.", num);
d1398 1
a1398 1
  if (current_task_id == -1)
d1400 4
a1403 5
#if (defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET))
      fill_gregset (&gregset_saved, -1);
      fill_fpregset (&fpregset_saved, -1);
#endif
      current_task_id = get_current_task ();
d1405 20
d1426 6
a1431 5
  current_task = num;
  current_task_index = e->known_tasks_index;
  current_thread = e->thread;
  current_lwp = e->lwp;
  if (task_switch (e->thread, e->lwp) == 0)
d1433 4
a1436 4
      /* FIXME: find_printable_frame should be defined in frame.h, and
         implemented in ada-lang.c */
      printf_filtered ("[Switching to task %d]\n", num);
      print_stack_frame (get_selected_frame (), 1, SRC_AND_LOC);
d1438 25
a1462 2
  else
    printf_filtered ("Unable to switch to task %d\n", num);
d1468 1
a1468 1
  static struct cmd_list_element *task_cmd_list = NULL;
d1471 2
d1474 2
a1475 2
	    "Without argument: list all known Ada tasks, with status information.\n"
	    "info tasks n: print detailed information of task n.\n");
d1477 5
a1481 3
  add_prefix_cmd ("task", class_run, task_command,
		  "Use this command to switch between tasks.\n\
 The new task ID must be currently known.", &task_cmd_list, "task ", 1, &cmdlist);
@


1.7
log
@	* ada-tasks.c (find_function_in_inferior): Don't declare it.
	("regcache.h"): Include it.
	* ada-lex.l (block_lookup): Replace VAR_NAMESPACE with VAR_DOMAIN.
@
text
@d7 1
a7 1
   [$Id: ada-tasks.c,v 1.6 2002/11/29 19:15:14 cagney Exp $]
a796 1
      /*      find_printable_frame (deprecated_selected_frame, frame_relative_level (deprecated_selected_frame)); */
d798 1
a798 2
      print_stack_frame (deprecated_selected_frame,
			 frame_relative_level (deprecated_selected_frame), 1);
@


1.7.14.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d7 1
a7 1
   [$Id: ada-tasks.c,v 1.7 2003/06/17 20:58:32 ciceron Exp $]
@


1.6
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d7 1
a7 1
   [$Id: ada-tasks.c,v 1.5 2002/09/08 17:43:40 aidan Exp $]
d25 1
a92 2

extern struct value *find_function_in_inferior (char *);
@


1.5
log
@	* ada-lang.c (ada_array_bound, ada_type_match,
	_initialize_ada_language): Fix K&R definitions.
	* ada-tasks.c (get_current_task): Fix K&R definitions.
	* ada-valprint.c (adjust_type_signedness): Fix K&R definitions.
@
text
@d7 1
a7 1
   [$Id: ada-tasks.c,v 1.4 2002/08/18 18:07:22 aidan Exp $]
d798 1
a798 1
      /*      find_printable_frame (selected_frame, frame_relative_level (selected_frame)); */
d800 2
a801 2
      print_stack_frame (selected_frame,
			 frame_relative_level (selected_frame), 1);
@


1.5.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d7 1
a7 1
   [$Id: ada-tasks.c,v 1.7 2003/06/17 20:58:32 ciceron Exp $]
a24 1
#include "regcache.h"
d93 2
d798 1
a798 1
      /*      find_printable_frame (deprecated_selected_frame, frame_relative_level (deprecated_selected_frame)); */
d800 2
a801 2
      print_stack_frame (deprecated_selected_frame,
			 frame_relative_level (deprecated_selected_frame), 1);
@


1.5.2.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d7 1
a7 1
   [$Id: ada-tasks.c,v 1.5 2002/09/08 17:43:40 aidan Exp $]
d798 1
a798 1
      /*      find_printable_frame (deprecated_selected_frame, frame_relative_level (deprecated_selected_frame)); */
d800 2
a801 2
      print_stack_frame (deprecated_selected_frame,
			 frame_relative_level (deprecated_selected_frame), 1);
@


1.5.2.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d7 1
a7 1
   [$Id$]
a24 1
#include "regcache.h"
d92 2
@


1.4
log
@        * ada-lang.c: run through gdb_indent.sh
        * ada-lang.h: run through gdb_indent.sh
        * ada-tasks.c: run through gdb_indent.sh
        * ada-typeprint.c: run through gdb_indent.sh
        * ada-valprint.c: run through gdb_indent.sh
@
text
@d7 1
a7 1
   [$Id: ada-tasks.c,v 1.3 2002/07/20 16:08:19 aidan Exp $]
d273 1
a273 1
get_current_task ()
@


1.4.6.1
log
@Import ada-lang.c, ada-tasks.c and ada-valprint.c from mainline.
@
text
@d7 1
a7 1
   [$Id: ada-tasks.c,v 1.5 2002/09/08 17:43:40 aidan Exp $]
d273 1
a273 1
get_current_task (void)
@


1.3
log
@2002-07-20  Aidan Skinner <aidan@@velvet.net>

	* ada-tasks.c: Change k&r style function definitions to prototyped
	form.
@
text
@d7 1
a7 1
   [$Id: ada-tasks.c,v 1.2 2002/07/13 12:24:05 aidan Exp $]
d17 3
a19 3
#include <ctype.h> 
#include "defs.h" 
#include "command.h" 
d33 1
a33 1
#endif 
d74 1
a74 1
extern void *GET_CURRENT_THREAD();
d77 1
a77 1
extern void *GET_CURRENT_THREAD();
d93 1
a93 1
extern struct value* find_function_in_inferior (char *);
d113 1
a113 2
char *ada_task_states[] =
{
d133 1
a133 2
static char *ada_long_task_states[] =
{
d154 1
a154 1
int thread_support = 0; /* 1 if the thread library in use is supported */
d157 1
a157 1
static int 
d177 2
a178 1
  else task_list = new_task_entry;
d182 1
a182 1
int 
d206 1
a206 1
      return pt;
d252 1
a252 1
  struct value* val;
d272 2
a273 1
int get_current_task ()
d276 1
a276 1
  
d296 2
a297 2
  int bounds [2];
  char image [256];
d302 5
a306 5
    { 
      printf_filtered ("The current language does not support tasks.\n"); 
      return; 
    } 
  */
d310 2
a311 2
      printf_filtered ("Task %s not found.\n", arg); 
      return; 
d323 10
a332 8
  if (atcb.image.P_ARRAY != NULL) {
    READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb.image.P_BOUNDS), bounds);
    bounds [1] = EXTRACT_INT (bounds [1]);
    read_memory ((CORE_ADDR) EXTRACT_ADDRESS (atcb.image.P_ARRAY),
                 (char*) &image, bounds [1]);
    printf_filtered ("Name: %.*s\n", bounds [1], image);
  }
  else printf_filtered ("<no name>\n");
d344 1
a344 1
        printf_filtered ("LWP: %ld\n", (long int) pt->lwp);
d346 1
a346 1
        printf_filtered ("LWP: %p\n", pt->lwp);
d358 9
a366 8
      if (atcb2.image.P_ARRAY != NULL) {
        READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb2.image.P_BOUNDS),
                     bounds);
        bounds [1] = EXTRACT_INT (bounds [1]);
        read_memory ((CORE_ADDR) EXTRACT_ADDRESS (atcb2.image.P_ARRAY),
                     (char*) &image, bounds [1]);
        printf_filtered (" (%.*s)\n", bounds [1], image);
      }
d368 1
a368 1
        printf_filtered ("\n");
d381 6
a386 5
  else {
    READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb.call), call);
    caller = EXTRACT_ADDRESS (call.self);
  }
 
d398 9
a406 8
	  if (atcb2.image.P_ARRAY != NULL) {
	    READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb2.image.P_BOUNDS),
                         bounds);
            bounds [1] = EXTRACT_INT (bounds [1]);
	    read_memory ((CORE_ADDR) EXTRACT_ADDRESS (atcb2.image.P_ARRAY),
                         (char*) &image, bounds [1]);
	    printf_filtered (" (%.*s)\n", bounds [1], image);
	  }
d414 1
a414 1
    printf_filtered ("State: %s\n", ada_long_task_states [atcb.state]);
d426 5
a430 5
  void *tf_base             = &(tf);
  void *tf_state            = &(tf.state);
  void *tf_entry_num        = &(tf.entry_num);
  void *tf_parent           = &(tf.parent);
  void *tf_priority         = &(tf.priority);
d432 4
a435 4
  void *tf_image            = &(tf.image);
  void *tf_call             = &(tf.call);
  void *tf_thread           = &(tf.thread);
  void *tf_lwp              = &(tf.lwp);
d438 19
a456 10
  printf_filtered ("task_fields.entry_num        at %3d (0x%x)\n", tf_entry_num - tf_base, tf_entry_num);
  printf_filtered ("task_fields.state            at %3d (0x%x)\n", tf_state - tf_base, tf_state);
  printf_filtered ("task_fields.parent           at %3d (0x%x)\n", tf_parent - tf_base, tf_parent);
  printf_filtered ("task_fields.priority         at %3d (0x%x)\n", tf_priority - tf_base, tf_priority);
  printf_filtered ("task_fields.current_priority at %3d (0x%x)\n", tf_current_priority - tf_base, tf_current_priority);
  printf_filtered ("task_fields.image            at %3d (0x%x)\n", tf_image - tf_base, tf_image);
  printf_filtered ("task_fields.call             at %3d (0x%x)\n", tf_call - tf_base, tf_call);
  printf_filtered ("task_fields.thread           at %3d (0x%x)\n", tf_thread - tf_base, tf_thread);
  printf_filtered ("task_fields.lwp              at %3d (0x%x)\n", tf_lwp - tf_base, tf_lwp);
  printf_filtered ("\n"); 
d465 1
a465 1
  struct value* val;
d467 1
a467 1
  void *temp_task, *temp_tasks [MAX_NUMBER_OF_KNOWN_TASKS];
d469 1
a469 1
  void *self_id, *caller, *thread_id=NULL;
d472 2
a473 2
  int bounds [2];
  char image [256];
d491 1
a491 1
  if (PIDGET(inferior_ptid) == 0)
d511 1
a511 1
	return; 
d536 1
a536 1
  for (i=0; i<MAX_NUMBER_OF_KNOWN_TASKS; i++)
d541 3
a543 3
        {
          task_number = get_entry_number (temp_task);
          if (task_number == 0)
d545 2
a546 2
        }
    }      
d551 2
a552 1
  if (init_only) return;
d558 1
a558 1
   ("  ID       TID P-ID Pri Stack  %% State                  Name\n");
d597 1
a597 1
      printf_filtered (" %#9lx", (unsigned long)pt->thread & 0x3ffffffffff);
d599 1
a599 1
      printf_filtered (" %#9lx", (long)pt->thread);
d605 1
a605 1
        (" %4d", get_entry_number (EXTRACT_ADDRESS (atcb.parent)));
d613 1
a613 1
          printf_filtered ("  Unknown");
d617 1
a617 1
      read_memory ((CORE_ADDR)atcb.thread, &thr, sizeof (thr));
d619 10
a628 8
      regs.regs [SP_REGNUM] = 0;
      if (dec_thread_get_registers (&regs, NULL) == 0) {
	pt->stack_per = (100 * ((long)thr.__stack_base -
	regs.regs [SP_REGNUM])) / thr.__stack_size;
	/* if the thread is terminated but still there, the
	stack_base/size values are erroneous. Try to patch it */
	if (pt->stack_per < 0 || pt->stack_per > 100) pt->stack_per = 0;
      }
d631 1
a631 1
      if (thr.__stack_size < 1024*1024)
d636 1
a636 1
      else if (thr.__stack_size < 1024*1024*1024)
d641 1
a641 1
      else /* Who knows... */
d647 1
a647 1
next:
d655 6
a660 5
      else {
	READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb.call), call);
	caller = EXTRACT_ADDRESS (call.self);
      }
 
d662 2
a663 1
	printf_filtered (" Accepting RV with %-4d", get_entry_number (caller));
d675 1
a675 1
	    printf_filtered (" %-22s", ada_task_states [state]);
d679 11
a689 8
      if (atcb.image.P_ARRAY != NULL) {
        READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb.image.P_BOUNDS), bounds);
        bounds [1] = EXTRACT_INT (bounds [1]);
        read_memory ((CORE_ADDR) EXTRACT_ADDRESS (atcb.image.P_ARRAY),
                     (char*)&image, bounds [1]);
        printf_filtered (" %.*s\n", bounds [1], image);
      }
      else printf_filtered (" <no name>\n");
d711 4
a714 4
   if (arg == NULL || *arg == '\000')
      info_tasks (arg, from_tty);
   else
      info_task (arg, from_tty);
d755 2
a756 1
      if (res == 0) stop_pc = read_pc();
d772 1
a772 1
           "see the IDs of currently known tasks.");
d779 1
a779 1
           "see the IDs of currently known tasks.", num);
d797 2
a798 2
	 implemented in ada-lang.c */
      /*      find_printable_frame (selected_frame, frame_relative_level (selected_frame));*/
d800 2
a801 1
      print_stack_frame (selected_frame, frame_relative_level (selected_frame), 1);
d813 3
a815 4
  add_info (
        "tasks", info_tasks_command,
	"Without argument: list all known Ada tasks, with status information.\n"
	"info tasks n: print detailed information of task n.\n");
d818 2
a819 3
                  "Use this command to switch between tasks.\n\
 The new task ID must be currently known.", &task_cmd_list, "task ", 1,
                  &cmdlist);
@


1.2
log
@	* ada-tasks.c (add_task_entry): replace calls to
	malloc() with xmalloc
	* ada-tasks.c (init_task_list): replace calls to free with xfree()

	* ada-lang.c (replace_operator_with_call, fill_in_ada_prototype,
	ada_finish_decode_line_1, all_sals_for_line
	ada_breakpoint_rewrite): replace calls to free() with xfree()
@
text
@d7 1
a7 1
   [$Id: ada-tasks.c,v 1.1 2002/06/04 15:28:48 aidan Exp $]
d159 2
a160 3
static int add_task_entry (p_task_id, index)
     void *p_task_id;
     int index;
d184 1
a184 2
get_entry_number (p_task_id)
     void *p_task_id;
d198 2
a199 2
static struct task_entry *get_thread_entry_vptr (thread)
     void *thread;
d213 2
a214 2
static struct task_entry *get_entry_vptr (p_task_num)
     int p_task_num;
d228 2
a229 1
void init_task_list ()
d244 2
a245 2
int valid_task_id (task)
     int task;
d250 2
a251 1
void *get_self_id ()
d289 1
a289 3
info_task (arg, from_tty)
     char *arg;
     int from_tty;
d418 1
a418 1
print_align ()
d449 1
a449 3
info_tasks (arg, from_tty)
     char *arg;
     int from_tty;
d678 1
a678 1
gdbtk_tcl_tasks_initialize ()
d687 1
a687 3
info_tasks_command (arg, from_tty)
     char *arg;
     int from_tty;
a698 1

d712 2
a713 2
static int task_switch (tid, lwpid)
     void *tid, *lwpid;
d741 2
a742 3
static void task_command (tidstr, from_tty)
     char *tidstr;
     int from_tty;
d784 1
a784 1
_initialize_tasks ()
@


1.1
log
@Add base ada language files
@
text
@d7 1
a7 1
   [$Id: ada-tasks.c,v 1.1.2.13 2001/11/05 19:01:03 brobecke Exp $]
d167 1
a167 1
  new_task_entry = malloc (sizeof (struct task_entry));
d239 1
a239 1
      free (old_pt);
@


1.1.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d7 1
a7 1
   [$Id: ada-tasks.c,v 1.1 2002/06/04 15:28:48 aidan Exp $]
@


1.1.4.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d7 1
a7 1
   [$Id: ada-tasks.c,v 1.3 2002/07/20 16:08:19 aidan Exp $]
d159 3
a161 2
static int 
add_task_entry (void *p_task_id, int index)
d167 1
a167 1
  new_task_entry = xmalloc (sizeof (struct task_entry));
d185 2
a186 1
get_entry_number (void *p_task_id)
d200 2
a201 2
static struct task_entry *
get_thread_entry_vptr (void *thread)
d215 2
a216 2
static struct task_entry *
get_entry_vptr (int p_task_num)
d230 1
a230 2
void
init_task_list (void)
d239 1
a239 1
      xfree (old_pt);
d245 2
a246 2
int
valid_task_id (int task)
d251 1
a251 2
void *
get_self_id (void)
d289 3
a291 1
info_task (char *arg, int from_tty)
d420 1
a420 1
print_align (void)
d451 3
a453 1
info_tasks (char *arg, int from_tty)
d682 1
a682 1
gdbtk_tcl_tasks_initialize (void)
d691 3
a693 1
info_tasks_command (char *arg, int from_tty)
d705 1
d719 2
a720 2
static int
task_switch (void *tid, void *lwpid)
d748 3
a750 2
static void
task_command (char *tidstr, int from_tty)
d792 1
a792 1
_initialize_tasks (void)
@


1.1.4.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d7 1
a7 1
   [$Id: ada-tasks.c,v 1.4 2002/08/18 18:07:22 aidan Exp $]
d17 3
a19 3
#include <ctype.h>
#include "defs.h"
#include "command.h"
d33 1
a33 1
#endif
d74 1
a74 1
extern void *GET_CURRENT_THREAD ();
d77 1
a77 1
extern void *GET_CURRENT_THREAD ();
d93 1
a93 1
extern struct value *find_function_in_inferior (char *);
d113 2
a114 1
char *ada_task_states[] = {
d134 2
a135 1
static char *ada_long_task_states[] = {
d156 1
a156 1
int thread_support = 0;		/* 1 if the thread library in use is supported */
d159 1
a159 1
static int
d179 1
a179 2
  else
    task_list = new_task_entry;
d183 1
a183 1
int
d207 1
a207 1
	return pt;
d253 1
a253 1
  struct value *val;
d273 1
a273 2
int
get_current_task ()
d276 1
a276 1

d296 2
a297 2
  int bounds[2];
  char image[256];
d302 5
a306 5
     { 
     printf_filtered ("The current language does not support tasks.\n"); 
     return; 
     } 
   */
d310 2
a311 2
      printf_filtered ("Task %s not found.\n", arg);
      return;
d323 8
a330 10
  if (atcb.image.P_ARRAY != NULL)
    {
      READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb.image.P_BOUNDS), bounds);
      bounds[1] = EXTRACT_INT (bounds[1]);
      read_memory ((CORE_ADDR) EXTRACT_ADDRESS (atcb.image.P_ARRAY),
		   (char *) &image, bounds[1]);
      printf_filtered ("Name: %.*s\n", bounds[1], image);
    }
  else
    printf_filtered ("<no name>\n");
d342 1
a342 1
	printf_filtered ("LWP: %ld\n", (long int) pt->lwp);
d344 1
a344 1
	printf_filtered ("LWP: %p\n", pt->lwp);
d356 8
a363 9
      if (atcb2.image.P_ARRAY != NULL)
	{
	  READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb2.image.P_BOUNDS),
		       bounds);
	  bounds[1] = EXTRACT_INT (bounds[1]);
	  read_memory ((CORE_ADDR) EXTRACT_ADDRESS (atcb2.image.P_ARRAY),
		       (char *) &image, bounds[1]);
	  printf_filtered (" (%.*s)\n", bounds[1], image);
	}
d365 1
a365 1
	printf_filtered ("\n");
d378 5
a382 6
  else
    {
      READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb.call), call);
      caller = EXTRACT_ADDRESS (call.self);
    }

d394 8
a401 9
	  if (atcb2.image.P_ARRAY != NULL)
	    {
	      READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb2.image.P_BOUNDS),
			   bounds);
	      bounds[1] = EXTRACT_INT (bounds[1]);
	      read_memory ((CORE_ADDR) EXTRACT_ADDRESS (atcb2.image.P_ARRAY),
			   (char *) &image, bounds[1]);
	      printf_filtered (" (%.*s)\n", bounds[1], image);
	    }
d409 1
a409 1
    printf_filtered ("State: %s\n", ada_long_task_states[atcb.state]);
d421 5
a425 5
  void *tf_base = &(tf);
  void *tf_state = &(tf.state);
  void *tf_entry_num = &(tf.entry_num);
  void *tf_parent = &(tf.parent);
  void *tf_priority = &(tf.priority);
d427 4
a430 4
  void *tf_image = &(tf.image);
  void *tf_call = &(tf.call);
  void *tf_thread = &(tf.thread);
  void *tf_lwp = &(tf.lwp);
d433 10
a442 19
  printf_filtered ("task_fields.entry_num        at %3d (0x%x)\n",
		   tf_entry_num - tf_base, tf_entry_num);
  printf_filtered ("task_fields.state            at %3d (0x%x)\n",
		   tf_state - tf_base, tf_state);
  printf_filtered ("task_fields.parent           at %3d (0x%x)\n",
		   tf_parent - tf_base, tf_parent);
  printf_filtered ("task_fields.priority         at %3d (0x%x)\n",
		   tf_priority - tf_base, tf_priority);
  printf_filtered ("task_fields.current_priority at %3d (0x%x)\n",
		   tf_current_priority - tf_base, tf_current_priority);
  printf_filtered ("task_fields.image            at %3d (0x%x)\n",
		   tf_image - tf_base, tf_image);
  printf_filtered ("task_fields.call             at %3d (0x%x)\n",
		   tf_call - tf_base, tf_call);
  printf_filtered ("task_fields.thread           at %3d (0x%x)\n",
		   tf_thread - tf_base, tf_thread);
  printf_filtered ("task_fields.lwp              at %3d (0x%x)\n",
		   tf_lwp - tf_base, tf_lwp);
  printf_filtered ("\n");
d451 1
a451 1
  struct value *val;
d453 1
a453 1
  void *temp_task, *temp_tasks[MAX_NUMBER_OF_KNOWN_TASKS];
d455 1
a455 1
  void *self_id, *caller, *thread_id = NULL;
d458 2
a459 2
  int bounds[2];
  char image[256];
d477 1
a477 1
  if (PIDGET (inferior_ptid) == 0)
d497 1
a497 1
	return;
d522 1
a522 1
  for (i = 0; i < MAX_NUMBER_OF_KNOWN_TASKS; i++)
d527 3
a529 3
	{
	  task_number = get_entry_number (temp_task);
	  if (task_number == 0)
d531 2
a532 2
	}
    }
d537 1
a537 2
  if (init_only)
    return;
d543 1
a543 1
    ("  ID       TID P-ID Pri Stack  %% State                  Name\n");
d582 1
a582 1
      printf_filtered (" %#9lx", (unsigned long) pt->thread & 0x3ffffffffff);
d584 1
a584 1
      printf_filtered (" %#9lx", (long) pt->thread);
d590 1
a590 1
	(" %4d", get_entry_number (EXTRACT_ADDRESS (atcb.parent)));
d598 1
a598 1
	  printf_filtered ("  Unknown");
d602 1
a602 1
      read_memory ((CORE_ADDR) atcb.thread, &thr, sizeof (thr));
d604 8
a611 10
      regs.regs[SP_REGNUM] = 0;
      if (dec_thread_get_registers (&regs, NULL) == 0)
	{
	  pt->stack_per = (100 * ((long) thr.__stack_base -
				  regs.regs[SP_REGNUM])) / thr.__stack_size;
	  /* if the thread is terminated but still there, the
	     stack_base/size values are erroneous. Try to patch it */
	  if (pt->stack_per < 0 || pt->stack_per > 100)
	    pt->stack_per = 0;
	}
d614 1
a614 1
      if (thr.__stack_size < 1024 * 1024)
d619 1
a619 1
      else if (thr.__stack_size < 1024 * 1024 * 1024)
d624 1
a624 1
      else			/* Who knows... */
d630 1
a630 1
    next:
d638 5
a642 6
      else
	{
	  READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb.call), call);
	  caller = EXTRACT_ADDRESS (call.self);
	}

d644 1
a644 2
	printf_filtered (" Accepting RV with %-4d",
			 get_entry_number (caller));
d656 1
a656 1
	    printf_filtered (" %-22s", ada_task_states[state]);
d660 8
a667 11
      if (atcb.image.P_ARRAY != NULL)
	{
	  READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb.image.P_BOUNDS),
		       bounds);
	  bounds[1] = EXTRACT_INT (bounds[1]);
	  read_memory ((CORE_ADDR) EXTRACT_ADDRESS (atcb.image.P_ARRAY),
		       (char *) &image, bounds[1]);
	  printf_filtered (" %.*s\n", bounds[1], image);
	}
      else
	printf_filtered (" <no name>\n");
d689 4
a692 4
  if (arg == NULL || *arg == '\000')
    info_tasks (arg, from_tty);
  else
    info_task (arg, from_tty);
d733 1
a733 2
      if (res == 0)
	stop_pc = read_pc ();
d749 1
a749 1
	   "see the IDs of currently known tasks.");
d756 1
a756 1
	   "see the IDs of currently known tasks.", num);
d774 2
a775 2
         implemented in ada-lang.c */
      /*      find_printable_frame (selected_frame, frame_relative_level (selected_frame)); */
d777 1
a777 2
      print_stack_frame (selected_frame,
			 frame_relative_level (selected_frame), 1);
d789 4
a792 3
  add_info ("tasks", info_tasks_command,
	    "Without argument: list all known Ada tasks, with status information.\n"
	    "info tasks n: print detailed information of task n.\n");
d795 3
a797 2
		  "Use this command to switch between tasks.\n\
 The new task ID must be currently known.", &task_cmd_list, "task ", 1, &cmdlist);
@


1.1.4.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d7 1
a7 1
   [$Id: ada-tasks.c,v 1.5 2002/09/08 17:43:40 aidan Exp $]
d273 1
a273 1
get_current_task (void)
@


1.1.2.1
log
@merge from trunk
@
text
@d7 1
a7 1
   [$Id: ada-tasks.c,v 1.1 2002/06/04 15:28:48 aidan Exp $]
@


1.1.2.2
log
@More merging.
@
text
@@


1.1.2.3
log
@merge with trunk
@
text
@@


1.1.2.4
log
@merge with trunk
@
text
@@


1.1.2.5
log
@merge with trunk.
@
text
@@


