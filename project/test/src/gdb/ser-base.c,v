head	1.27;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.26
	gdb_7_6-2013-04-26-release:1.26
	gdb_7_6-branch:1.26.0.2
	gdb_7_6-2013-03-12-branchpoint:1.26
	gdb_7_5_1-2012-11-29-release:1.24
	gdb_7_5-2012-08-17-release:1.24
	gdb_7_5-branch:1.24.0.2
	gdb_7_5-2012-07-18-branchpoint:1.24
	gdb_7_4_1-2012-04-26-release:1.22.4.1
	gdb_7_4-2012-01-24-release:1.22.4.1
	gdb_7_4-branch:1.22.0.4
	gdb_7_4-2011-12-13-branchpoint:1.22
	gdb_7_3_1-2011-09-04-release:1.22
	gdb_7_3-2011-07-26-release:1.22
	gdb_7_3-branch:1.22.0.2
	gdb_7_3-2011-04-01-branchpoint:1.22
	gdb_7_2-2010-09-02-release:1.19
	gdb_7_2-branch:1.19.0.2
	gdb_7_2-2010-07-07-branchpoint:1.19
	gdb_7_1-2010-03-18-release:1.15
	gdb_7_1-branch:1.15.0.2
	gdb_7_1-2010-02-18-branchpoint:1.15
	gdb_7_0_1-2009-12-22-release:1.14
	gdb_7_0-2009-10-06-release:1.14
	gdb_7_0-branch:1.14.0.4
	gdb_7_0-2009-09-16-branchpoint:1.14
	arc-sim-20090309:1.13
	msnyder-checkpoint-072509-branch:1.14.0.2
	msnyder-checkpoint-072509-branchpoint:1.14
	arc-insight_6_8-branch:1.13.0.16
	arc-insight_6_8-branchpoint:1.13
	insight_6_8-branch:1.13.0.14
	insight_6_8-branchpoint:1.13
	reverse-20081226-branch:1.13.0.12
	reverse-20081226-branchpoint:1.13
	multiprocess-20081120-branch:1.13.0.10
	multiprocess-20081120-branchpoint:1.13
	reverse-20080930-branch:1.13.0.8
	reverse-20080930-branchpoint:1.13
	reverse-20080717-branch:1.13.0.6
	reverse-20080717-branchpoint:1.13
	msnyder-reverse-20080609-branch:1.13.0.4
	msnyder-reverse-20080609-branchpoint:1.13
	drow-reverse-20070409-branch:1.10.0.2
	drow-reverse-20070409-branchpoint:1.10
	gdb_6_8-2008-03-27-release:1.13
	gdb_6_8-branch:1.13.0.2
	gdb_6_8-2008-02-26-branchpoint:1.13
	gdb_6_7_1-2007-10-29-release:1.11
	gdb_6_7-2007-10-10-release:1.11
	gdb_6_7-branch:1.11.0.2
	gdb_6_7-2007-09-07-branchpoint:1.11
	insight_6_6-20070208-release:1.8
	gdb_6_6-2006-12-18-release:1.8
	gdb_6_6-branch:1.8.0.18
	gdb_6_6-2006-11-15-branchpoint:1.8
	insight_6_5-20061003-release:1.8
	gdb-csl-symbian-6_4_50_20060226-12:1.8
	gdb-csl-sourcerygxx-3_4_4-25:1.6
	nickrob-async-20060828-mergepoint:1.8
	gdb-csl-symbian-6_4_50_20060226-11:1.8
	gdb-csl-sourcerygxx-4_1-17:1.8
	gdb-csl-20060226-branch-local-2:1.8
	gdb-csl-sourcerygxx-4_1-14:1.8
	gdb-csl-sourcerygxx-4_1-13:1.8
	gdb-csl-sourcerygxx-4_1-12:1.8
	gdb-csl-sourcerygxx-3_4_4-21:1.8
	gdb_6_5-20060621-release:1.8
	gdb-csl-sourcerygxx-4_1-9:1.8
	gdb-csl-sourcerygxx-4_1-8:1.8
	gdb-csl-sourcerygxx-4_1-7:1.8
	gdb-csl-arm-2006q1-6:1.8
	gdb-csl-sourcerygxx-4_1-6:1.8
	gdb-csl-symbian-6_4_50_20060226-10:1.8
	gdb-csl-symbian-6_4_50_20060226-9:1.8
	gdb-csl-symbian-6_4_50_20060226-8:1.8
	gdb-csl-coldfire-4_1-11:1.8
	gdb-csl-sourcerygxx-3_4_4-19:1.8
	gdb-csl-coldfire-4_1-10:1.8
	gdb_6_5-branch:1.8.0.16
	gdb_6_5-2006-05-14-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-5:1.8
	nickrob-async-20060513-branch:1.8.0.14
	nickrob-async-20060513-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-4:1.8
	msnyder-reverse-20060502-branch:1.8.0.12
	msnyder-reverse-20060502-branchpoint:1.8
	gdb-csl-morpho-4_1-4:1.8
	gdb-csl-sourcerygxx-3_4_4-17:1.8
	readline_5_1-import-branch:1.8.0.10
	readline_5_1-import-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.8
	gdb-csl-symbian-20060226-branch:1.8.0.8
	gdb-csl-symbian-20060226-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.8
	msnyder-reverse-20060331-branch:1.8.0.6
	msnyder-reverse-20060331-branchpoint:1.8
	gdb-csl-available-20060303-branch:1.8.0.4
	gdb-csl-available-20060303-branchpoint:1.8
	gdb-csl-20060226-branch:1.8.0.2
	gdb-csl-20060226-branchpoint:1.8
	gdb_6_4-20051202-release:1.6
	msnyder-fork-checkpoint-branch:1.6.0.10
	msnyder-fork-checkpoint-branchpoint:1.6
	gdb-csl-gxxpro-6_3-branch:1.6.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.6
	gdb_6_4-branch:1.6.0.6
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb-csl-arm-20051020-branch:1.6.0.4
	gdb-csl-arm-20051020-branchpoint:1.6
	msnyder-tracepoint-checkpoint-branch:1.6.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb-csl-arm-20050325-2005-q1b:1.2.2.1
	gdb-csl-arm-20050325-2005-q1a:1.2.2.1
	csl-arm-20050325-branch:1.2.0.2;
locks; strict;
comment	@ * @;


1.27
date	2013.04.19.15.26.17;	author palves;	state Exp;
branches;
next	1.26;

1.26
date	2013.01.01.06.32.50;	author brobecke;	state Exp;
branches;
next	1.25;

1.25
date	2012.07.18.04.36.24;	author xguo;	state Exp;
branches;
next	1.24;

1.24
date	2012.06.11.20.36.53;	author palves;	state Exp;
branches;
next	1.23;

1.23
date	2012.01.04.08.17.10;	author brobecke;	state Exp;
branches;
next	1.22;

1.22
date	2011.03.04.19.23.42;	author uweigand;	state Exp;
branches
	1.22.4.1;
next	1.21;

1.21
date	2011.01.11.21.53.23;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.01.15.33.14;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.16.23.49.58;	author msnyder;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.29.22.51.04;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2010.04.20.06.06.38;	author devans;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.20.05.52.07;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2010.01.01.07.31.41;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.12.20.14.57;	author jimb;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.23.18.08.37;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.08.15.20.07;	author vprus;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.09.17.58.58;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.10.22.01.43;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.17.22.34.02;	author eliz;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.22.21.23.28;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.22.20.32.01;	author mmitchel;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.21.21.23.25;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.21.05.34.33;	author mmitchel;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.25.20.06.36;	author mmitchel;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2005.03.25.19.47.23;	author mmitchel;	state Exp;
branches;
next	;

1.22.4.1
date	2012.01.06.04.43.29;	author brobecke;	state Exp;
branches;
next	;

1.2.2.1
date	2005.03.28.19.08.58;	author mmitchel;	state Exp;
branches;
next	;


desc
@@


1.27
log
@serial_write: change prototype to take a void-pointer buffer.

While remote.c works with "char *" buffers most of the time, other
remote targets have binary-ish-er protocols, and choose to use
"unsigned char" throughout, like e.g., remote-mips.c or
remote-m32r-sdi.c.  That results in -Wpointer-sign warnings in those
targets, unless we add casts in calls to serial_write.  Since
serial_write is only concerned about sending raw host bytes out, and
serial_ops->write_prim already works with "void *"/"size_t", a similar
interface to the "write" or "send" system calls, I find it natural to
change serial_write's prototype accordingly, avoiding the need for
casts.

Tested on x86_64 Fedora 17, and also by building x86_64-mingw32
and DJGPP/go32 -hosted gdbs.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* ser-base.c (ser_base_write): Change prototype -- take 'void *'
	buffer and size_t size.  Adjust.
	* ser-base.h (ser_base_write): Adjust.
	* ser-go32.c (cnts): Change type to size_t.
	(dos_write): Change prototype -- take 'void *'
	buffer and size_t size.  Adjust.
	(dos_info): Print elements of 'cnts' as unsigned long.
	* serial.c (serial_write): Likewise.
	* serial.h (serial_write): Adjust.
	(struct serial_ops) <write>: Change prototype -- take 'void *'
	buffer and size_t size.  Adjust.
@
text
@/* Generic serial interface functions.

   Copyright (C) 1992-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "serial.h"
#include "ser-base.h"
#include "event-loop.h"

#include "gdb_select.h"
#include "gdb_string.h"
#include "gdb_assert.h"
#include <sys/time.h>
#ifdef USE_WIN32API
#include <winsock2.h>
#endif


static timer_handler_func push_event;
static handler_func fd_event;

/* Event handling for ASYNC serial code.

   At any time the SERIAL device either: has an empty FIFO and is
   waiting on a FD event; or has a non-empty FIFO/error condition and
   is constantly scheduling timer events.

   ASYNC only stops pestering its client when it is de-async'ed or it
   is told to go away.  */

/* Value of scb->async_state: */
enum {
  /* >= 0 (TIMER_SCHEDULED) */
  /* The ID of the currently scheduled timer event.  This state is
     rarely encountered.  Timer events are one-off so as soon as the
     event is delivered the state is shanged to NOTHING_SCHEDULED.  */
  FD_SCHEDULED = -1,
  /* The fd_event() handler is scheduled.  It is called when ever the
     file descriptor becomes ready.  */
  NOTHING_SCHEDULED = -2
  /* Either no task is scheduled (just going into ASYNC mode) or a
     timer event has just gone off and the current state has been
     forced into nothing scheduled.  */
};

/* Identify and schedule the next ASYNC task based on scb->async_state
   and scb->buf* (the input FIFO).  A state machine is used to avoid
   the need to make redundant calls into the event-loop - the next
   scheduled task is only changed when needed.  */

static void
reschedule (struct serial *scb)
{
  if (serial_is_async_p (scb))
    {
      int next_state;

      switch (scb->async_state)
	{
	case FD_SCHEDULED:
	  if (scb->bufcnt == 0)
	    next_state = FD_SCHEDULED;
	  else
	    {
	      delete_file_handler (scb->fd);
	      next_state = create_timer (0, push_event, scb);
	    }
	  break;
	case NOTHING_SCHEDULED:
	  if (scb->bufcnt == 0)
	    {
	      add_file_handler (scb->fd, fd_event, scb);
	      next_state = FD_SCHEDULED;
	    }
	  else
	    {
	      next_state = create_timer (0, push_event, scb);
	    }
	  break;
	default: /* TIMER SCHEDULED */
	  if (scb->bufcnt == 0)
	    {
	      delete_timer (scb->async_state);
	      add_file_handler (scb->fd, fd_event, scb);
	      next_state = FD_SCHEDULED;
	    }
	  else
	    next_state = scb->async_state;
	  break;
	}
      if (serial_debug_p (scb))
	{
	  switch (next_state)
	    {
	    case FD_SCHEDULED:
	      if (scb->async_state != FD_SCHEDULED)
		fprintf_unfiltered (gdb_stdlog, "[fd%d->fd-scheduled]\n",
				    scb->fd);
	      break;
	    default: /* TIMER SCHEDULED */
	      if (scb->async_state == FD_SCHEDULED)
		fprintf_unfiltered (gdb_stdlog, "[fd%d->timer-scheduled]\n",
				    scb->fd);
	      break;
	    }
	}
      scb->async_state = next_state;
    }
}

/* Run the SCB's async handle, and reschedule, if the handler doesn't
   close SCB.  */

static void
run_async_handler_and_reschedule (struct serial *scb)
{
  int is_open;

  /* Take a reference, so a serial_close call within the handler
     doesn't make SCB a dangling pointer.  */
  serial_ref (scb);

  /* Run the handler.  */
  scb->async_handler (scb, scb->async_context);

  is_open = serial_is_open (scb);
  serial_unref (scb);

  /* Get ready for more, if not already closed.  */
  if (is_open)
    reschedule (scb);
}

/* FD_EVENT: This is scheduled when the input FIFO is empty (and there
   is no pending error).  As soon as data arrives, it is read into the
   input FIFO and the client notified.  The client should then drain
   the FIFO using readchar().  If the FIFO isn't immediatly emptied,
   push_event() is used to nag the client until it is.  */

static void
fd_event (int error, void *context)
{
  struct serial *scb = context;
  if (error != 0)
    {
      scb->bufcnt = SERIAL_ERROR;
    }
  else if (scb->bufcnt == 0)
    {
      /* Prime the input FIFO.  The readchar() function is used to
         pull characters out of the buffer.  See also
         generic_readchar().  */
      int nr;
      nr = scb->ops->read_prim (scb, BUFSIZ);
      if (nr == 0)
	{
	  scb->bufcnt = SERIAL_EOF;
	}
      else if (nr > 0)
	{
	  scb->bufcnt = nr;
	  scb->bufp = scb->buf;
	}
      else
	{
	  scb->bufcnt = SERIAL_ERROR;
	}
    }
  run_async_handler_and_reschedule (scb);
}

/* PUSH_EVENT: The input FIFO is non-empty (or there is a pending
   error).  Nag the client until all the data has been read.  In the
   case of errors, the client will need to close or de-async the
   device before naging stops.  */

static void
push_event (void *context)
{
  struct serial *scb = context;

  scb->async_state = NOTHING_SCHEDULED; /* Timers are one-off */
  run_async_handler_and_reschedule (scb);
}

/* Wait for input on scb, with timeout seconds.  Returns 0 on success,
   otherwise SERIAL_TIMEOUT or SERIAL_ERROR.  */

static int
ser_base_wait_for (struct serial *scb, int timeout)
{
  while (1)
    {
      int numfds;
      struct timeval tv;
      fd_set readfds, exceptfds;

      /* NOTE: Some OS's can scramble the READFDS when the select()
         call fails (ex the kernel with Red Hat 5.2).  Initialize all
         arguments before each call.  */

      tv.tv_sec = timeout;
      tv.tv_usec = 0;

      FD_ZERO (&readfds);
      FD_ZERO (&exceptfds);
      FD_SET (scb->fd, &readfds);
      FD_SET (scb->fd, &exceptfds);

      if (timeout >= 0)
	numfds = gdb_select (scb->fd + 1, &readfds, 0, &exceptfds, &tv);
      else
	numfds = gdb_select (scb->fd + 1, &readfds, 0, &exceptfds, 0);

      if (numfds <= 0)
	{
	  if (numfds == 0)
	    return SERIAL_TIMEOUT;
	  else if (errno == EINTR)
	    continue;
	  else
	    return SERIAL_ERROR;	/* Got an error from select or
					   poll.  */
	}

      return 0;
    }
}

/* Read any error output we might have.  */

static void
ser_base_read_error_fd (struct serial *scb, int close_fd)
{
  if (scb->error_fd != -1)
    {
      ssize_t s;
      char buf[GDB_MI_MSG_WIDTH + 1];

      for (;;)
	{
	  char *current;
	  char *newline;
	  int to_read = GDB_MI_MSG_WIDTH;
	  int num_bytes = -1;

	  if (scb->ops->avail)
	    num_bytes = (scb->ops->avail)(scb, scb->error_fd);

	  if (num_bytes != -1)
	    to_read = (num_bytes < to_read) ? num_bytes : to_read;

	  if (to_read == 0)
	    break;

	  s = read (scb->error_fd, &buf, to_read);
	  if ((s == -1) || (s == 0 && !close_fd))
	    break;

	  if (s == 0 && close_fd)
	    {
	      /* End of file.  */
	      close (scb->error_fd);
	      scb->error_fd = -1;
	      break;
	    }

	  /* In theory, embedded newlines are not a problem.
	     But for MI, we want each output line to have just
	     one newline for legibility.  So output things
	     in newline chunks.  */
	  gdb_assert (s > 0 && s <= GDB_MI_MSG_WIDTH);
	  buf[s] = '\0';
	  current = buf;
	  while ((newline = strstr (current, "\n")) != NULL)
	    {
	      *newline = '\0';
	      fputs_unfiltered (current, gdb_stderr);
	      fputs_unfiltered ("\n", gdb_stderr);
	      current = newline + 1;
	    }

	  fputs_unfiltered (current, gdb_stderr);
       }
    }
}

/* Read a character with user-specified timeout.  TIMEOUT is number of seconds
   to wait, or -1 to wait forever.  Use timeout of 0 to effect a poll.  Returns
   char if successful.  Returns -2 if timeout expired, EOF if line dropped
   dead, or -3 for any other error (see errno in that case).  */

static int
do_ser_base_readchar (struct serial *scb, int timeout)
{
  int status;
  int delta;

  /* We have to be able to keep the GUI alive here, so we break the
     original timeout into steps of 1 second, running the "keep the
     GUI alive" hook each time through the loop.

     Also, timeout = 0 means to poll, so we just set the delta to 0,
     so we will only go through the loop once.  */

  delta = (timeout == 0 ? 0 : 1);
  while (1)
    {
      /* N.B. The UI may destroy our world (for instance by calling
         remote_stop,) in which case we want to get out of here as
         quickly as possible.  It is not safe to touch scb, since
         someone else might have freed it.  The
         deprecated_ui_loop_hook signals that we should exit by
         returning 1.  */

      if (deprecated_ui_loop_hook)
	{
	  if (deprecated_ui_loop_hook (0))
	    return SERIAL_TIMEOUT;
	}

      status = ser_base_wait_for (scb, delta);
      if (timeout > 0)
        timeout -= delta;

      /* If we got a character or an error back from wait_for, then we can 
         break from the loop before the timeout is completed.  */
      if (status != SERIAL_TIMEOUT)
	break;

      /* If we have exhausted the original timeout, then generate
         a SERIAL_TIMEOUT, and pass it out of the loop.  */
      else if (timeout == 0)
	{
	  status = SERIAL_TIMEOUT;
	  break;
	}

      /* We also need to check and consume the stderr because it could
	 come before the stdout for some stubs.  If we just sit and wait
	 for stdout, we would hit a deadlock for that case.  */
      ser_base_read_error_fd (scb, 0);
    }

  if (status < 0)
    return status;

  status = scb->ops->read_prim (scb, BUFSIZ);

  if (status <= 0)
    {
      if (status == 0)
        return SERIAL_EOF;
      else
	/* Got an error from read.  */
	return SERIAL_ERROR;	
    }

  scb->bufcnt = status;
  scb->bufcnt--;
  scb->bufp = scb->buf;
  return *scb->bufp++;
}

/* Perform operations common to both old and new readchar.  */

/* Return the next character from the input FIFO.  If the FIFO is
   empty, call the SERIAL specific routine to try and read in more
   characters.

   Initially data from the input FIFO is returned (fd_event()
   pre-reads the input into that FIFO.  Once that has been emptied,
   further data is obtained by polling the input FD using the device
   specific readchar() function.  Note: reschedule() is called after
   every read.  This is because there is no guarentee that the lower
   level fd_event() poll_event() code (which also calls reschedule())
   will be called.  */

int
generic_readchar (struct serial *scb, int timeout,
		  int (do_readchar) (struct serial *scb, int timeout))
{
  int ch;
  if (scb->bufcnt > 0)
    {
      ch = *scb->bufp;
      scb->bufcnt--;
      scb->bufp++;
    }
  else if (scb->bufcnt < 0)
    {
      /* Some errors/eof are are sticky.  */
      ch = scb->bufcnt;
    }
  else
    {
      ch = do_readchar (scb, timeout);
      if (ch < 0)
	{
	  switch ((enum serial_rc) ch)
	    {
	    case SERIAL_EOF:
	    case SERIAL_ERROR:
	      /* Make the error/eof stick.  */
	      scb->bufcnt = ch;
	      break;
	    case SERIAL_TIMEOUT:
	      scb->bufcnt = 0;
	      break;
	    }
	}
    }

  /* Read any error output we might have.  */
  ser_base_read_error_fd (scb, 1);

  reschedule (scb);
  return ch;
}

int
ser_base_readchar (struct serial *scb, int timeout)
{
  return generic_readchar (scb, timeout, do_ser_base_readchar);
}

int
ser_base_write (struct serial *scb, const void *buf, size_t count)
{
  const char *str = buf;
  int cc;

  while (count > 0)
    {
      cc = scb->ops->write_prim (scb, str, count);

      if (cc < 0)
	return 1;
      count -= cc;
      str += cc;
    }
  return 0;
}

int
ser_base_flush_output (struct serial *scb)
{
  return 0;
}

int
ser_base_flush_input (struct serial *scb)
{
  if (scb->bufcnt >= 0)
    {
      scb->bufcnt = 0;
      scb->bufp = scb->buf;
      return 0;
    }
  else
    return SERIAL_ERROR;
}

int
ser_base_send_break (struct serial *scb)
{
  return 0;
}

int
ser_base_drain_output (struct serial *scb)
{
  return 0;
}

void
ser_base_raw (struct serial *scb)
{
  return;			/* Always in raw mode.  */
}

serial_ttystate
ser_base_get_tty_state (struct serial *scb)
{
  /* Allocate a dummy.  */
  return (serial_ttystate) XMALLOC (int);
}

serial_ttystate
ser_base_copy_tty_state (struct serial *scb, serial_ttystate ttystate)
{
  /* Allocate another dummy.  */
  return (serial_ttystate) XMALLOC (int);
}

int
ser_base_set_tty_state (struct serial *scb, serial_ttystate ttystate)
{
  return 0;
}

int
ser_base_noflush_set_tty_state (struct serial *scb,
				serial_ttystate new_ttystate,
				serial_ttystate old_ttystate)
{
  return 0;
}

void
ser_base_print_tty_state (struct serial *scb, 
			  serial_ttystate ttystate,
			  struct ui_file *stream)
{
  /* Nothing to print.  */
  return;
}

int
ser_base_setbaudrate (struct serial *scb, int rate)
{
  return 0;			/* Never fails!  */
}

int
ser_base_setstopbits (struct serial *scb, int num)
{
  return 0;			/* Never fails!  */
}

/* Put the SERIAL device into/out-of ASYNC mode.  */

void
ser_base_async (struct serial *scb,
		int async_p)
{
  if (async_p)
    {
      /* Force a re-schedule.  */
      scb->async_state = NOTHING_SCHEDULED;
      if (serial_debug_p (scb))
	fprintf_unfiltered (gdb_stdlog, "[fd%d->asynchronous]\n",
			    scb->fd);
      reschedule (scb);
    }
  else
    {
      if (serial_debug_p (scb))
	fprintf_unfiltered (gdb_stdlog, "[fd%d->synchronous]\n",
			    scb->fd);
      /* De-schedule whatever tasks are currently scheduled.  */
      switch (scb->async_state)
	{
	case FD_SCHEDULED:
	  delete_file_handler (scb->fd);
	  break;
	case NOTHING_SCHEDULED:
	  break;
	default: /* TIMER SCHEDULED */
	  delete_timer (scb->async_state);
	  break;
	}
    }
}
@


1.26
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d443 1
a443 1
ser_base_write (struct serial *scb, const char *str, int len)
d445 1
d448 1
a448 1
  while (len > 0)
d450 1
a450 1
      cc = scb->ops->write_prim (scb, str, len); 
d454 1
a454 1
      len -= cc;
@


1.25
log
@2012-07-18  Terry Guo  <terry.guo@@arm.com>

        PR 14329
        * defs.h (GDB_MI_MSG_WIDTH): New.
        * ser_base (ser_base_read_error_fd): New function.
        (do_ser_base_readchar): Poll error file descriptor as well as
        standard output.
        (generic_readchar): Refactor error handling.
@
text
@d3 1
a3 2
   Copyright (C) 1992-1996, 1998-2001, 2003-2012 Free Software
   Foundation, Inc.
@


1.24
log
@2012-06-11  Pedro Alves  <palves@@redhat.com>

	* ser-base.c (run_async_handler_and_reschedule): New.
	(fd_event, push_event): Use it.
	* serial.c (serial_open, serial_fdopen_ops): Set the initial
	reference count to 1.
	(do_serial_close): Set the bufp field to NULL.  Use serial_unref
	instead of xfree.
	(serial_is_open, serial_ref, serial_unref): New.
	* serial.h (serial_open): Adjust comment.
	(serial_is_open): Declare.
	(serial_close): Adjust comment.
	(serial_ref, serial_unref) Declare.
	(struct serial): New field 'refcnt'.
@
text
@d28 1
d246 58
d354 5
d429 1
d431 1
a431 47
  if (scb->error_fd != -1)
    {
      ssize_t s;
      char buf[81];

      for (;;)
        {
 	  char *current;
 	  char *newline;
	  int to_read = 80;

	  int num_bytes = -1;
	  if (scb->ops->avail)
	    num_bytes = (scb->ops->avail)(scb, scb->error_fd);
	  if (num_bytes != -1)
	    to_read = (num_bytes < to_read) ? num_bytes : to_read;

	  if (to_read == 0)
	    break;

	  s = read (scb->error_fd, &buf, to_read);
	  if (s == -1)
	    break;
	  if (s == 0)
	    {
	      /* EOF */
	      close (scb->error_fd);
	      scb->error_fd = -1;
	      break;
	    }

	  /* In theory, embedded newlines are not a problem.
	     But for MI, we want each output line to have just
	     one newline for legibility.  So output things
	     in newline chunks.  */
	  buf[s] = '\0';
	  current = buf;
	  while ((newline = strstr (current, "\n")) != NULL)
	    {
	      *newline = '\0';
	      fputs_unfiltered (current, gdb_stderr);
	      fputs_unfiltered ("\n", gdb_stderr);
	      current = newline + 1;
	    }
	  fputs_unfiltered (current, gdb_stderr);
	}
    }
@


1.23
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d126 23
d184 1
a184 2
  scb->async_handler (scb, scb->async_context);
  reschedule (scb);
d198 1
a198 3
  scb->async_handler (scb, scb->async_context);
  /* re-schedule */
  reschedule (scb);
@


1.22
log
@	* inflow.c (terminal_init_inferior_with_pgrp): Copy ttystate.
	(terminal_save_ours): Remove misleading comment.
	(inflow_inferior_data_cleanup): Free ttystate.
	(inflow_inferior_exit): Likewise.
	(copy_terminal_info): Copy ttystate.

	* serial.c (serial_copy_tty_state): New function.
	* serial.h (serial_copy_tty_state): Add prototype.
	(struct serial_ops): Add copy_tty_state callback.
	* ser-base.c (ser_base_copy_tty_state): New function.
	* ser-base.h (ser_base_copy_tty_state): Add prototype.
	* ser-go32.c (dos_copy_tty_state): New function.
	(dos_ops): Install copy_tty_state callback.
	* ser-mingw.c (_initialize_ser_windows): Likewise.
	* ser-pipe.c (_initialize_ser_pipe): Likewise.
	* ser-unix.c (hardwire_copy_tty_state): New function.
	(_initialize_ser_hardwire): Install it.
@
text
@d3 2
a4 3
   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2003,
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.22.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 2
   Copyright (C) 1992-1996, 1998-2001, 2003-2012 Free Software
   Foundation, Inc.
@


1.21
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d466 7
@


1.20
log
@run copyright.sh for 2011.
@
text
@d45 1
a45 1
   is told to go away. */
d50 1
a50 1
  /* The ID of the currently scheduled timer event. This state is
d52 1
a52 1
     event is delivered the state is shanged to NOTHING_SCHEDULED. */
d55 1
a55 1
     file descriptor becomes ready. */
d59 1
a59 1
     forced into nothing scheduled. */
d65 1
a65 1
   scheduled task is only changed when needed. */
d131 1
a131 1
   push_event() is used to nag the client until it is. */
d145 1
a145 1
         generic_readchar(). */
d169 1
a169 1
   device before naging stops. */
d183 1
a183 1
   otherwise SERIAL_TIMEOUT or SERIAL_ERROR. */
d196 1
a196 1
         arguments before each call. */
d218 2
a219 1
	    return SERIAL_ERROR;	/* Got an error from select or poll */
d229 1
a229 1
   dead, or -3 for any other error (see errno in that case). */
d265 1
a265 1
         break from the loop before the timeout is completed. */
d270 1
a270 1
         a SERIAL_TIMEOUT, and pass it out of the loop. */
d298 1
a298 1
/* Perform operations common to both old and new readchar. */
d310 1
a310 1
   will be called. */
d325 1
a325 1
      /* Some errors/eof are are sticky. */
d337 1
a337 1
	      /* Make the error/eof stick. */
d456 1
a456 1
  return;			/* Always in raw mode */
d462 1
a462 1
  /* allocate a dummy */
d492 1
a492 1
  return 0;			/* Never fails! */
d498 1
a498 1
  return 0;			/* Never fails! */
d509 1
a509 1
      /* Force a re-schedule. */
d521 1
a521 1
      /* De-schedule whatever tasks are currently scheduled. */
@


1.19
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* scm-exp.c: White space.
	* scm-lang.c: White space.
	* scm-valprint.c: White space.
	* sentinel-frame.c: White space.
	* ser-base.c: White space.
	* ser-go32.c: White space.
	* serial.c: White space.
	* ser-mingw.c: White space.
	* ser-pipe.c: White space.
	* ser-tcp.c: White space.
	* ser-unix.c: White space.
	* solib.c: White space.
	* solib-darwin.c: White space.
	* solib-frv.c: White space.
	* solib-irix.c: White space.
	* solib-osf.c: White space.
	* solib-pa64.c: White space.
	* solib-som.c: White space.
	* solib-spu.c: White space.
	* solib-svr4.c: White space.
	* solib-target.c: White space.
	* source.c: White space.
	* stabsread.c: White space.
	* stack.c: White space.
	* std-regs.c: White space.
	* symfile.c: White space.
	* symmisc.c: White space.
	* symtab.c: White space.
@
text
@d4 2
a5 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.18
log
@	* ser-base.h (reschedule): Delete prototype.
	* ser-base.c (reschedule): Make static.
@
text
@d72 1
d174 1
@


1.17
log
@(generic_readchar): Tweak previous checkin, close error_fd if EOF.
@
text
@d66 1
a66 1
void
@


1.16
log
@	* ser-base.c (generic_readchar): Watch for EOF in read of error_fd.
	* ser-pipe.c (pipe_open): Fix file descriptor leaks.
	(pipe_close): Ditto.
@
text
@d364 1
a364 1
	  if (s <= 0)
d366 7
@


1.15
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d364 1
a364 1
	  if (s == -1)
@


1.14
log
@        Updated copyright notices for most files.
@
text
@d4 1
a4 1
   2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.13
log
@	Updated copyright notices for most files.
@
text
@d4 1
a4 1
   2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.12
log
@* serial.h (struct serial_ops): Document read_prim to return zero
at EOF.
* ser-base.c (do_ser_base_readchar): Return SERIAL_EOF when
read_prim returns zero, not SERIAL_TIMEOUT.
@
text
@d4 1
a4 1
   2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.11
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d282 1
a282 3
	/* 0 chars means timeout.  (We may need to distinguish between EOF
	   & timeouts someday.)  */
	return SERIAL_TIMEOUT;	
@


1.10
log
@        Pass stderr of program run with "target remote |"
        via gdb_stderr.
        * serial.c (serial_open): Set error_fd to -1.
        * serial.h (struct serial): New field error_fd.
        (struct serial_opts): New field avail.
        * ser-pipe.c (pipe_open): Create another pair
        of sockets.  Pass stderr to gdb.
        * ser-mingw.c (pipe_windows_open): Pass
        PEX_STDERR_TO_PIPE to pex_run.  Initialize
        sd->error_fd.
        (pipe_avail): New.
        (_initialize_ser_windows): Hook pipe_avail.
        * ser-base.c (generic_readchar): Check if there's
        anything in stderr channel and route that to gdb_stderr.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.9
log
@Copyright updates for 2007.
@
text
@d346 42
@


1.8
log
@	* NEWS: Mention native Windows support.
	* Makefile.in (gdb_select_h, ser_tcp_h): New.
	(ALLDEPFILES): Add ser-mingw.c.
	(event-loop.o, inflow.o, mingw-hdep.o, posix-hdep.o, ser-base.o)
	(ser-tcp.o, ser-unix.o): Update.
	(ser-mingw.o): New rule.
	* configure: Regenerated.
	* configure.ac: Add ser-mingw.o for mingw32.
	* ser-mingw.c: New file.
	* event-loop.c: Include "gdb_select.h".
	(gdb_select): Remove, moved to mingw-hdep.c and posix-hdep.c.
	* ser-base.c: Include "gdb_select.h".
	(ser_base_wait_for): Use gdb_select.
	* serial.c (serial_for_fd): New function.
	(serial_fdopen): Try "terminal" before "hardwire".  Initialize
	the allocated struct serial.
	(serial_wait_handle): New function.
	* serial.h (serial_for_fd, serial_wait_handle): New prototypes.
	(struct serial_ops) [USE_WIN32API]: Add wait_handle.
	* gdb_select.h: New file.
	* ser-tcp.c: Include "ser-tcp.h".  Remove unused "ser-unix.h" include.
	(net_close, net_read_prim, net_write_prim): Make global.
	(net_open): Likewise.  Pass an exception set to select.  Whitespace fix.
	Document why we can not use gdb_select.
	(_initialize_ser_tcp) [USE_WIN32API]: Do not register TCP support here.
	* ser-tcp.h: New file.
	* inflow.c (gdb_has_a_terminal): Don't initialize stdin_serial here.
	(handle_sigio): Use gdb_select.
	(initialize_stdin_serial): New function.
	* terminal.h (initialize_stdin_serial): New prototype.
	* top.c (gdb_init): Call initialize_stdin_serial.
	* mingw-hdep.c (gdb_select): New function, moved from gdb_select in
	event-loop.c.  Add exception condition support.  Use serial_for_fd
	and serial_wait_handle.  Fix timeout handling.
	* posix-hdep.c: Include "gdb_select.h".
	(gdb_select): New function.
	* remote-st.c (connect_command): Use gdb_select.
	* ser-unix.c: Include "gdb_select.h".
	(hardwire_send_break, wait_for): Use gdb_select.
@
text
@d3 2
a4 2
   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
   2003, 2004, 2005, 2006 Free Software Foundation, Inc.
@


1.7
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d4 1
a4 1
   2003, 2004, 2005 Free Software Foundation, Inc.
d28 1
d206 1
a206 1
	numfds = select (scb->fd + 1, &readfds, 0, &exceptfds, &tv);
d208 1
a208 1
	numfds = select (scb->fd + 1, &readfds, 0, &exceptfds, 0);
@


1.6
log
@* ser-base.c: Include "ser-base.h" instead of "ser-unix.h".
@
text
@d3 1
a3 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.5
log
@	* ser-base.c (<sys/time.h>): Include.
@
text
@d25 1
a25 1
#include "ser-unix.h"
d27 2
a33 1
#include "gdb_string.h"
@


1.4
log
@* ser-base.c: Include "gdb_string.h".
* Makefile.in (ser-base.o): Update dependencies.
@
text
@d27 1
@


1.3
log
@	* configure.ac: On MinGW, define USE_WIN32API and link with
	-lws2_32.
	* ser-tcp.c (<winsock2.h>): Include, for Windows.
	(ETIMEDOUT): Define, for Windows.
	(ioctl): Likewise.
	(closesocket): Define, for POSIX.
	(net_open): Adjust for differences in socket functions between
	Windows and UNIX.
	(net_close): Likweise.
	(net_read_prim): New function.
	(net_write_prim): Likewise.
	(_initialize_ser_tcp): Initialize winsock.  Fill in read_prim and
	write_prim.
	* ser-unix.h (ser_unix_readcchar): Remove.
	(ser_unix_read_prim): Declare.
	(ser_unix_write_prim): Likewise.
	* ser-unix.c (generic_readchar): Move to ser-base.c.
	(ser_unix_wait_for): Likewise.
	(do_unix_readchar): Likewise.
	(ser_unix_readchar): Likewise.
	(_initialize_ser_hardwire): Initialize read_prim and write_prim.
	(ser_unix_read_prim): New function.
	(ser_unix_write_prim): Likewise.
	* ser-base.h (generic_readchar): Declare.
	(ser_base_readchar): Likewise.
	* ser-base.c (<winsock2.h>): Include, for windows.
	(fd_event): Use the read primitive specified by the serial
	interface.
	(ser_base_wait_for): Moved from ser-unix.c
	(do_ser_base_read_char): Likewise.
	(generic_readchar): Likewise.
	(ser_base_readchar): Likewise.
	(ser_base_write): Use the write primitive specified by the serial
	interface.
	* ser-pipe.c (_initialize_ser_pipe): Use ser_base_readchar, not
	ser_unix_readchar.  Initialize read_prim and write_prim.
	* serial.c (struct serial_ops): Add read_prim and write_prim.
	* configure: Regenerate.
@
text
@d31 2
@


1.2
log
@	* ser-base.c (ser_unix_write): Rename to ...
	(ser_base_write): ... this.
	(ser_unix_nop_flush_output): Rename to ...
	(ser_base_flush_output): ... this.
	(ser_unix_flush_input): Rename to ...
	(ser_base_flush_input): ... this.
	(ser_unix_nop_send_break): Rename to ...
	(ser_base_send_break): ... this.
	(ser_unix_nop_drain_output): Rename to ...
	(ser_base_drain_output): ... this.
	(ser_unix_nop_raw): Rename to ...
	(ser_base_raw): ... this.
	(ser_unix_nop_get_tty_state): Rename to ...
	(ser_base_set_tty_state): ... this.
	(ser_unix_nop_noflush_set_tty_state): Rename to ...
	(ser_base_noflush_set_tty_state): ... this.
	(ser_unix_nop_print_tty_state): Rename to ...
	(ser_base_print_tty_state): ... this.
	(ser_unix_nop_setbaudrate): Rename to ...
	(ser_base_setbaudrate): ... this.
	(ser_unix_nop_setstopbits): Rename to ...
	(ser_base_setstopbits): ... this.
	(ser_unix_async): Rename to ...
	(ser_base_async): ... this.
	* ser-base.h (ser_unix_write): Rename to ...
	(ser_base_write): ... this.
	(ser_unix_nop_flush_output): Rename to ...
	(ser_base_flush_output): ... this.
	(ser_unix_flush_input): Rename to ...
	(ser_base_flush_input): ... this.
	(ser_unix_nop_send_break): Rename to ...
	(ser_base_send_break): ... this.
	(ser_unix_nop_drain_output): Rename to ...
	(ser_base_drain_output): ... this.
	(ser_unix_nop_raw): Rename to ...
	(ser_base_raw): ... this.
	(ser_unix_nop_get_tty_state): Rename to ...
	(ser_base_set_tty_state): ... this.
	(ser_unix_nop_noflush_set_tty_state): Rename to ...
	(ser_base_noflush_set_tty_state): ... this.
	(ser_unix_nop_print_tty_state): Rename to ...
	(ser_base_print_tty_state): ... this.
	(ser_unix_nop_setbaudrate): Rename to ...
	(ser_base_setbaudrate): ... this.
	(ser_unix_nop_setstopbits): Rename to ...
	(ser_base_setstopbits): ... this.
	(ser_unix_async): Rename to ...
	(ser_base_async): ... this.
	* ser-pipe.c (_initialize_ser_pipe): Update accordingly.
	* ser-tcp.c (_initialize_ser_tcp): Likewise.
	* ser-unix.c (hardwire_flush_input): Likewise.
	(_initializer_ser_hardwire): Likewise.
@
text
@d27 3
d142 1
a142 5
      do
	{
	  nr = read (scb->fd, scb->buf, BUFSIZ);
	}
      while (nr == -1 && errno == EINTR);
d176 175
d358 1
a358 1
      cc = write (scb->fd, str, len);
@


1.2.2.1
log
@Add missing files
@
text
@a26 3
#ifdef WINAPI
#include <winsock2.h>
#endif
d139 5
a143 1
      nr = scb->ops->read_prim (scb, BUFSIZ);
a176 179
/* Wait for input on scb, with timeout seconds.  Returns 0 on success,
   otherwise SERIAL_TIMEOUT or SERIAL_ERROR. */

static int
ser_base_wait_for (struct serial *scb, int timeout)
{
  while (1)
    {
      int numfds;
      struct timeval tv;
      fd_set readfds, exceptfds;

      /* NOTE: Some OS's can scramble the READFDS when the select()
         call fails (ex the kernel with Red Hat 5.2).  Initialize all
         arguments before each call. */

      tv.tv_sec = timeout;
      tv.tv_usec = 0;

      FD_ZERO (&readfds);
      FD_ZERO (&exceptfds);
      FD_SET (scb->fd, &readfds);
      FD_SET (scb->fd, &exceptfds);

      if (timeout >= 0)
	numfds = select (scb->fd + 1, &readfds, 0, &exceptfds, &tv);
      else
	numfds = select (scb->fd + 1, &readfds, 0, &exceptfds, 0);

      if (numfds <= 0)
	{
	  if (numfds == 0)
	    return SERIAL_TIMEOUT;
	  else if (errno == EINTR)
	    continue;
	  else
	    return SERIAL_ERROR;	/* Got an error from select or poll */
	}

      return 0;
    }
}

/* Read a character with user-specified timeout.  TIMEOUT is number of seconds
   to wait, or -1 to wait forever.  Use timeout of 0 to effect a poll.  Returns
   char if successful.  Returns -2 if timeout expired, EOF if line dropped
   dead, or -3 for any other error (see errno in that case). */

static int
do_ser_base_readchar (struct serial *scb, int timeout)
{
  int status;
  int delta;

  /* We have to be able to keep the GUI alive here, so we break the
     original timeout into steps of 1 second, running the "keep the
     GUI alive" hook each time through the loop.

     Also, timeout = 0 means to poll, so we just set the delta to 0,
     so we will only go through the loop once.  */

  delta = (timeout == 0 ? 0 : 1);
  while (1)
    {

      /* N.B. The UI may destroy our world (for instance by calling
         remote_stop,) in which case we want to get out of here as
         quickly as possible.  It is not safe to touch scb, since
         someone else might have freed it.  The
         deprecated_ui_loop_hook signals that we should exit by
         returning 1.  */

      if (deprecated_ui_loop_hook)
	{
	  if (deprecated_ui_loop_hook (0))
	    return SERIAL_TIMEOUT;
	}

      status = ser_base_wait_for (scb, delta);
      if (timeout > 0)
        timeout -= delta;

      /* If we got a character or an error back from wait_for, then we can 
         break from the loop before the timeout is completed. */

      if (status != SERIAL_TIMEOUT)
	{
	  break;
	}

      /* If we have exhausted the original timeout, then generate
         a SERIAL_TIMEOUT, and pass it out of the loop. */

      else if (timeout == 0)
	{
	  status = SERIAL_TIMEOUT;
	  break;
	}
    }

  if (status < 0)
    return status;

  status = scb->ops->read_prim (scb, BUFSIZ);

  if (status <= 0)
    {
      if (status == 0)
	return SERIAL_TIMEOUT;	/* 0 chars means timeout [may need to
				   distinguish between EOF & timeouts
				   someday] */
      else
	return SERIAL_ERROR;	/* Got an error from read */
    }

  scb->bufcnt = status;
  scb->bufcnt--;
  scb->bufp = scb->buf;
  return *scb->bufp++;
}

/* Perform operations common to both old and new readchar. */

/* Return the next character from the input FIFO.  If the FIFO is
   empty, call the SERIAL specific routine to try and read in more
   characters.

   Initially data from the input FIFO is returned (fd_event()
   pre-reads the input into that FIFO.  Once that has been emptied,
   further data is obtained by polling the input FD using the device
   specific readchar() function.  Note: reschedule() is called after
   every read.  This is because there is no guarentee that the lower
   level fd_event() poll_event() code (which also calls reschedule())
   will be called. */

int
generic_readchar (struct serial *scb, int timeout,
		  int (do_readchar) (struct serial *scb, int timeout))
{
  int ch;
  if (scb->bufcnt > 0)
    {
      ch = *scb->bufp;
      scb->bufcnt--;
      scb->bufp++;
    }
  else if (scb->bufcnt < 0)
    {
      /* Some errors/eof are are sticky. */
      ch = scb->bufcnt;
    }
  else
    {
      ch = do_readchar (scb, timeout);
      if (ch < 0)
	{
	  switch ((enum serial_rc) ch)
	    {
	    case SERIAL_EOF:
	    case SERIAL_ERROR:
	      /* Make the error/eof stick. */
	      scb->bufcnt = ch;
	      break;
	    case SERIAL_TIMEOUT:
	      scb->bufcnt = 0;
	      break;
	    }
	}
    }
  reschedule (scb);
  return ch;
}

int
ser_base_readchar (struct serial *scb, int timeout)
{
  return generic_readchar (scb, timeout, do_ser_base_readchar);
}

d184 1
a184 1
      cc = scb->ops->write_prim (scb, str, len); 
@


1.1
log
@	* Makefile.in (SFILES): Add ser-base.c.
	(ser_base_h): New variable.
	(ser-base.o): New target.
	(ser-pipe.o): Depend on $(ser_base_h).
	(ser-tcp.o): Likewise.
	(ser-unix.o): Likewise.  Do not depend on $(event_loop_h).
	* configure.ac (SER_HARDWIRE): Include ser-base.o where
	appropriate.
	* ser-base.c: New file.
	(push_event): Move from ser-unix.c.
	(fd_event): Likewise.
	(reschedule): Likewise.
	(ser_unix_write): Likewise.
	(ser_unix_nop_flush_output): Likewise.
	(ser_unix_flush_input): Likewise.
	(ser_unix_nop_send_break): Likewise.
	(ser_unix_nop_drain_output): Likewise.
	(ser_unix_nop_raw): Likewise.
	(ser_unix_nop_get_tty_state): Likewise.
	(ser_unix_nop_set_tty_state): Likewise.
	(ser_unix_nop_noflush_set_tty_state): Likewise.
	(ser_unix_nop_print_tty_state): Likewise.
	(ser_unix_nop_setbaudrate): Likewise.
	(ser_unix_nop_setstopbits): Likewise.
	(ser_unix_async): Likewise.
	* ser-base.h: New file.
	* ser-pipe.c (ser-base.h): Include it.
	* ser-tcp.c (ser-base.h): Likewise.
	* ser-unix.h (ser_unix_nop_flush_output): Remove.
	(ser_unix_flush_input): Likewise.
	(ser_unix_nop_send_break): Likewise.
	(ser_unix_nop_raw): Likewise.
	(ser_unix_nop_get_tty_state): Likewise.
	(ser_unix_nop_set_tty_state): Likewise.
	(ser_unix_nop_print_tty_state): Likewise.
	(ser_unix_nop_noflush_set_tty_state): Likewise.
	(ser_unix_nop_setbaudrate): Likewise.
	(ser_unix_nop_setstopbits): Likewise.
	(ser_unix_nop_drain_output): Likewise.
	(ser_unix_wait_for): Likewise.
	(ser_unix_write): Likewise.
	(ser_unix_async): Likewise.
	* ser-unix.c (event-loop.h): Do not include it.
	(push_event): Move to ser-base.c.
	(fd_event): Likewise.
	(reschedule): Likewise.
	(ser_unix_write): Likewise.
	(ser_unix_nop_flush_output): Likewise.
	(ser_unix_flush_input): Likewise.
	(ser_unix_nop_send_break): Likewise.
	(ser_unix_nop_drain_output): Likewise.
	(ser_unix_nop_raw): Likewise.
	(ser_unix_nop_get_tty_state): Likewise.
	(ser_unix_nop_set_tty_state): Likewise.
	(ser_unix_nop_noflush_set_tty_state): Likewise.
	(ser_unix_nop_print_tty_state): Likewise.
	(ser_unix_nop_setbaudrate): Likewise.
	(ser_unix_nop_setstopbits): Likewise.
	(ser_unix_async): Likewise.
	(ser_unix_wait_for): Make it static.
	* configure: Regenerated.
@
text
@d178 1
a178 1
ser_unix_write (struct serial *scb, const char *str, int len)
d195 1
a195 1
ser_unix_nop_flush_output (struct serial *scb)
d201 1
a201 1
ser_unix_flush_input (struct serial *scb)
d214 1
a214 1
ser_unix_nop_send_break (struct serial *scb)
d220 1
a220 1
ser_unix_nop_drain_output (struct serial *scb)
d226 1
a226 1
ser_unix_nop_raw (struct serial *scb)
d232 1
a232 1
ser_unix_nop_get_tty_state (struct serial *scb)
d239 1
a239 1
ser_unix_nop_set_tty_state (struct serial *scb, serial_ttystate ttystate)
d245 3
a247 3
ser_unix_nop_noflush_set_tty_state (struct serial *scb,
				    serial_ttystate new_ttystate,
				    serial_ttystate old_ttystate)
d253 3
a255 3
ser_unix_nop_print_tty_state (struct serial *scb, 
			      serial_ttystate ttystate,
			      struct ui_file *stream)
d262 1
a262 1
ser_unix_nop_setbaudrate (struct serial *scb, int rate)
d268 1
a268 1
ser_unix_nop_setstopbits (struct serial *scb, int num)
d276 1
a276 1
ser_unix_async (struct serial *scb,
@

