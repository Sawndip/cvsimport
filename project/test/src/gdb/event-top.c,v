head	1.97;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.92
	gdb_7_6-2013-04-26-release:1.92
	gdb_7_6-branch:1.92.0.2
	gdb_7_6-2013-03-12-branchpoint:1.92
	gdb_7_5_1-2012-11-29-release:1.85
	gdb_7_5-2012-08-17-release:1.85
	gdb_7_5-branch:1.85.0.2
	gdb_7_5-2012-07-18-branchpoint:1.85
	gdb_7_4_1-2012-04-26-release:1.84.2.1
	gdb_7_4-2012-01-24-release:1.84.2.1
	gdb_7_4-branch:1.84.0.2
	gdb_7_4-2011-12-13-branchpoint:1.84
	gdb_7_3_1-2011-09-04-release:1.77
	gdb_7_3-2011-07-26-release:1.77
	gdb_7_3-branch:1.77.0.2
	gdb_7_3-2011-04-01-branchpoint:1.77
	gdb_7_2-2010-09-02-release:1.72
	gdb_7_2-branch:1.72.0.2
	gdb_7_2-2010-07-07-branchpoint:1.72
	gdb_7_1-2010-03-18-release:1.70
	gdb_7_1-branch:1.70.0.2
	gdb_7_1-2010-02-18-branchpoint:1.70
	gdb_7_0_1-2009-12-22-release:1.68.4.1
	gdb_7_0-2009-10-06-release:1.68.4.1
	gdb_7_0-branch:1.68.0.4
	gdb_7_0-2009-09-16-branchpoint:1.68
	arc-sim-20090309:1.56
	msnyder-checkpoint-072509-branch:1.68.0.2
	msnyder-checkpoint-072509-branchpoint:1.68
	arc-insight_6_8-branch:1.56.0.6
	arc-insight_6_8-branchpoint:1.56
	insight_6_8-branch:1.56.0.4
	insight_6_8-branchpoint:1.56
	reverse-20081226-branch:1.64.0.6
	reverse-20081226-branchpoint:1.64
	multiprocess-20081120-branch:1.64.0.4
	multiprocess-20081120-branchpoint:1.64
	reverse-20080930-branch:1.64.0.2
	reverse-20080930-branchpoint:1.64
	reverse-20080717-branch:1.62.0.2
	reverse-20080717-branchpoint:1.62
	msnyder-reverse-20080609-branch:1.60.0.2
	msnyder-reverse-20080609-branchpoint:1.60
	drow-reverse-20070409-branch:1.50.0.2
	drow-reverse-20070409-branchpoint:1.50
	gdb_6_8-2008-03-27-release:1.56
	gdb_6_8-branch:1.56.0.2
	gdb_6_8-2008-02-26-branchpoint:1.56
	gdb_6_7_1-2007-10-29-release:1.55
	gdb_6_7-2007-10-10-release:1.55
	gdb_6_7-branch:1.55.0.2
	gdb_6_7-2007-09-07-branchpoint:1.55
	insight_6_6-20070208-release:1.46.2.1
	gdb_6_6-2006-12-18-release:1.46.2.1
	gdb_6_6-branch:1.46.0.2
	gdb_6_6-2006-11-15-branchpoint:1.46
	insight_6_5-20061003-release:1.45
	gdb-csl-symbian-6_4_50_20060226-12:1.45
	gdb-csl-sourcerygxx-3_4_4-25:1.42
	nickrob-async-20060828-mergepoint:1.46
	gdb-csl-symbian-6_4_50_20060226-11:1.45
	gdb-csl-sourcerygxx-4_1-17:1.45
	gdb-csl-20060226-branch-local-2:1.45
	gdb-csl-sourcerygxx-4_1-14:1.45
	gdb-csl-sourcerygxx-4_1-13:1.45
	gdb-csl-sourcerygxx-4_1-12:1.45
	gdb-csl-sourcerygxx-3_4_4-21:1.45
	gdb_6_5-20060621-release:1.45
	gdb-csl-sourcerygxx-4_1-9:1.45
	gdb-csl-sourcerygxx-4_1-8:1.45
	gdb-csl-sourcerygxx-4_1-7:1.45
	gdb-csl-arm-2006q1-6:1.45
	gdb-csl-sourcerygxx-4_1-6:1.45
	gdb-csl-symbian-6_4_50_20060226-10:1.45
	gdb-csl-symbian-6_4_50_20060226-9:1.45
	gdb-csl-symbian-6_4_50_20060226-8:1.45
	gdb-csl-coldfire-4_1-11:1.45
	gdb-csl-sourcerygxx-3_4_4-19:1.45
	gdb-csl-coldfire-4_1-10:1.45
	gdb_6_5-branch:1.45.0.16
	gdb_6_5-2006-05-14-branchpoint:1.45
	gdb-csl-sourcerygxx-4_1-5:1.45
	nickrob-async-20060513-branch:1.45.0.14
	nickrob-async-20060513-branchpoint:1.45
	gdb-csl-sourcerygxx-4_1-4:1.45
	msnyder-reverse-20060502-branch:1.45.0.12
	msnyder-reverse-20060502-branchpoint:1.45
	gdb-csl-morpho-4_1-4:1.45
	gdb-csl-sourcerygxx-3_4_4-17:1.45
	readline_5_1-import-branch:1.45.0.10
	readline_5_1-import-branchpoint:1.45
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.45
	gdb-csl-symbian-20060226-branch:1.45.0.8
	gdb-csl-symbian-20060226-branchpoint:1.45
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.45
	msnyder-reverse-20060331-branch:1.45.0.6
	msnyder-reverse-20060331-branchpoint:1.45
	gdb-csl-available-20060303-branch:1.45.0.4
	gdb-csl-available-20060303-branchpoint:1.45
	gdb-csl-20060226-branch:1.45.0.2
	gdb-csl-20060226-branchpoint:1.45
	gdb_6_4-20051202-release:1.41
	msnyder-fork-checkpoint-branch:1.42.0.4
	msnyder-fork-checkpoint-branchpoint:1.42
	gdb-csl-gxxpro-6_3-branch:1.42.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.42
	gdb_6_4-branch:1.41.0.2
	gdb_6_4-2005-11-01-branchpoint:1.41
	gdb-csl-arm-20051020-branch:1.40.0.6
	gdb-csl-arm-20051020-branchpoint:1.40
	msnyder-tracepoint-checkpoint-branch:1.40.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.40
	gdb-csl-arm-20050325-2005-q1b:1.40.2.2
	gdb-csl-arm-20050325-2005-q1a:1.40.2.1
	csl-arm-20050325-branch:1.40.0.2
	csl-arm-20050325-branchpoint:1.40
	gdb-post-i18n-errorwarning-20050211:1.38
	gdb-pre-i18n-errorwarning-20050211:1.37
	gdb_6_3-20041109-release:1.35
	gdb_6_3-branch:1.35.0.2
	gdb_6_3-20041019-branchpoint:1.35
	drow_intercu-merge-20040921:1.34
	drow_intercu-merge-20040915:1.34
	jimb-gdb_6_2-e500-branch:1.33.0.12
	jimb-gdb_6_2-e500-branchpoint:1.33
	gdb_6_2-20040730-release:1.33
	gdb_6_2-branch:1.33.0.8
	gdb_6_2-2004-07-10-gmt-branchpoint:1.33
	gdb_6_1_1-20040616-release:1.33
	gdb_6_1-2004-04-05-release:1.33
	drow_intercu-merge-20040402:1.33
	drow_intercu-merge-20040327:1.33
	ezannoni_pie-20040323-branch:1.33.0.6
	ezannoni_pie-20040323-branchpoint:1.33
	cagney_tramp-20040321-mergepoint:1.33
	cagney_tramp-20040309-branch:1.33.0.4
	cagney_tramp-20040309-branchpoint:1.33
	gdb_6_1-branch:1.33.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.33
	drow_intercu-20040221-branch:1.32.0.2
	drow_intercu-20040221-branchpoint:1.32
	cagney_bfdfile-20040213-branch:1.31.0.4
	cagney_bfdfile-20040213-branchpoint:1.31
	drow-cplus-merge-20040208:1.31
	carlton_dictionary-20040126-merge:1.31
	cagney_bigcore-20040122-branch:1.31.0.2
	cagney_bigcore-20040122-branchpoint:1.31
	drow-cplus-merge-20040113:1.31
	drow-cplus-merge-20031224:1.31
	drow-cplus-merge-20031220:1.31
	carlton_dictionary-20031215-merge:1.31
	drow-cplus-merge-20031214:1.31
	carlton-dictionary-20031111-merge:1.31
	gdb_6_0-2003-10-04-release:1.27
	kettenis_sparc-20030918-branch:1.29.0.4
	kettenis_sparc-20030918-branchpoint:1.29
	carlton_dictionary-20030917-merge:1.29
	ezannoni_pie-20030916-branchpoint:1.29
	ezannoni_pie-20030916-branch:1.29.0.2
	cagney_x86i386-20030821-branch:1.28.0.2
	cagney_x86i386-20030821-branchpoint:1.28
	carlton_dictionary-20030805-merge:1.28
	carlton_dictionary-20030627-merge:1.27
	gdb_6_0-branch:1.27.0.6
	gdb_6_0-2003-06-23-branchpoint:1.27
	jimb-ppc64-linux-20030613-branch:1.27.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.27
	cagney_convert-20030606-branch:1.27.0.2
	cagney_convert-20030606-branchpoint:1.27
	cagney_writestrings-20030508-branch:1.26.0.24
	cagney_writestrings-20030508-branchpoint:1.26
	jimb-ppc64-linux-20030528-branch:1.26.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.26
	carlton_dictionary-20030523-merge:1.26
	cagney_fileio-20030521-branch:1.26.0.20
	cagney_fileio-20030521-branchpoint:1.26
	kettenis_i386newframe-20030517-mergepoint:1.26
	jimb-ppc64-linux-20030509-branch:1.26.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.26
	kettenis_i386newframe-20030504-mergepoint:1.26
	carlton_dictionary-20030430-merge:1.26
	kettenis_i386newframe-20030419-branch:1.26.0.16
	kettenis_i386newframe-20030419-branchpoint:1.26
	carlton_dictionary-20030416-merge:1.26
	cagney_frameaddr-20030409-mergepoint:1.26
	kettenis_i386newframe-20030406-branch:1.26.0.14
	kettenis_i386newframe-20030406-branchpoint:1.26
	cagney_frameaddr-20030403-branchpoint:1.26
	cagney_frameaddr-20030403-branch:1.26.0.12
	cagney_framebase-20030330-mergepoint:1.26
	cagney_framebase-20030326-branch:1.26.0.10
	cagney_framebase-20030326-branchpoint:1.26
	cagney_lazyid-20030317-branch:1.26.0.8
	cagney_lazyid-20030317-branchpoint:1.26
	kettenis-i386newframe-20030316-mergepoint:1.26
	offbyone-20030313-branch:1.26.0.6
	offbyone-20030313-branchpoint:1.26
	kettenis-i386newframe-20030308-branch:1.26.0.4
	kettenis-i386newframe-20030308-branchpoint:1.26
	carlton_dictionary-20030305-merge:1.26
	cagney_offbyone-20030303-branch:1.26.0.2
	cagney_offbyone-20030303-branchpoint:1.26
	carlton_dictionary-20030207-merge:1.25
	interps-20030203-mergepoint:1.24
	interps-20030202-branch:1.24.0.4
	interps-20030202-branchpoint:1.24
	cagney-unwind-20030108-branch:1.24.0.2
	cagney-unwind-20030108-branchpoint:1.24
	carlton_dictionary-20021223-merge:1.24
	gdb_5_3-2002-12-12-release:1.22
	carlton_dictionary-20021115-merge:1.24
	kseitz_interps-20021105-merge:1.23
	kseitz_interps-20021103-merge:1.23
	drow-cplus-merge-20021020:1.23
	drow-cplus-merge-20021025:1.23
	carlton_dictionary-20021025-merge:1.23
	carlton_dictionary-20021011-merge:1.23
	drow-cplus-branch:1.23.0.2
	drow-cplus-branchpoint:1.23
	kseitz_interps-20020930-merge:1.22
	carlton_dictionary-20020927-merge:1.22
	carlton_dictionary-branch:1.22.0.8
	carlton_dictionary-20020920-branchpoint:1.22
	gdb_5_3-branch:1.22.0.6
	gdb_5_3-2002-09-04-branchpoint:1.22
	kseitz_interps-20020829-merge:1.22
	cagney_sysregs-20020825-branch:1.22.0.4
	cagney_sysregs-20020825-branchpoint:1.22
	readline_4_3-import-branch:1.22.0.2
	readline_4_3-import-branchpoint:1.22
	gdb_5_2_1-2002-07-23-release:1.19.2.1
	kseitz_interps-20020528-branch:1.20.0.6
	kseitz_interps-20020528-branchpoint:1.20
	cagney_regbuf-20020515-branch:1.20.0.4
	cagney_regbuf-20020515-branchpoint:1.20
	jimb-macro-020506-branch:1.20.0.2
	jimb-macro-020506-branchpoint:1.20
	gdb_5_2-2002-04-29-release:1.19
	gdb_5_2-branch:1.19.0.2
	gdb_5_2-2002-03-03-branchpoint:1.19
	gdb_5_1_1-2002-01-24-release:1.15
	gdb_5_1_0_1-2002-01-03-release:1.15
	cygnus_cvs_20020108_pre:1.18
	gdb_5_1_0_1-2002-01-03-branchpoint:1.15
	gdb_5_1_0_1-2002-01-03-branch:1.15.0.6
	gdb_5_1-2001-11-21-release:1.15
	gdb_s390-2001-09-26-branch:1.15.0.4
	gdb_s390-2001-09-26-branchpoint:1.15
	gdb_5_1-2001-07-29-branch:1.15.0.2
	gdb_5_1-2001-07-29-branchpoint:1.15
	dberlin-typesystem-branch:1.14.0.2
	dberlin-typesystem-branchpoint:1.14
	gdb-post-ptid_t-2001-05-03:1.14
	gdb-pre-ptid_t-2001-05-03:1.14
	insight-precleanup-2001-01-01:1.10
	gdb-post-protoization-2000-07-29:1.8
	gdb-pre-protoization-2000-07-29:1.7
	gdb-premipsmulti-2000-06-06-branch:1.6.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.6
	gdb-post-params-removal-2000-06-04:1.6
	gdb-pre-params-removal-2000-06-04:1.6
	gdb-post-params-removal-2000-05-28:1.6
	gdb-pre-params-removal-2000-05-28:1.6
	gdb_5_0-2000-05-19-release:1.5
	gdb_4_18_2-2000-05-18-release:1.5
	gdb_4_95_1-2000-05-11-snapshot:1.5
	gdb_4_95_0-2000-04-27-snapshot:1.5
	gdb_5_0-2000-04-10-branch:1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.5
	repo-unification-2000-02-06:1.1.1.18
	insight-2000-02-04:1.1.1.18
	gdb-2000-02-04:1.1.1.18
	gdb-2000-02-02:1.1.1.18
	gdb-2000-02-01:1.1.1.17
	gdb-2000-01-31:1.1.1.17
	gdb-2000-01-26:1.1.1.17
	gdb-2000-01-24:1.1.1.17
	gdb-2000-01-17:1.1.1.17
	gdb-2000-01-10:1.1.1.16
	gdb-2000-01-05:1.1.1.16
	gdb-1999-12-21:1.1.1.16
	gdb-1999-12-13:1.1.1.16
	gdb-1999-12-07:1.1.1.16
	gdb-1999-12-06:1.1.1.16
	gdb-1999-11-16:1.1.1.16
	gdb-1999-11-08:1.1.1.16
	gdb-1999-11-01:1.1.1.16
	gdb-1999-10-25:1.1.1.16
	gdb-1999-10-18:1.1.1.15
	gdb-1999-10-11:1.1.1.15
	gdb-1999-10-04:1.1.1.15
	gdb-1999-09-28:1.1.1.14
	gdb-1999-09-21:1.1.1.13
	gdb-1999-09-13:1.1.1.12
	gdb-1999-09-08:1.1.1.12
	gdb-1999-08-30:1.1.1.11
	gdb-1999-08-23:1.1.1.10
	gdb-1999-08-16:1.1.1.10
	gdb-1999-08-09:1.1.1.9
	gdb-1999-08-02:1.1.1.9
	gdb-1999-07-26:1.1.1.8
	gdb-1999-07-19:1.1.1.8
	gdb-1999-07-12:1.1.1.7
	gdb-post-reformat-19990707:1.1.1.7
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.7
	gdb-pre-reformat-19990707:1.1.1.6
	gdb-1999-07-07:1.1.1.6
	gdb-1999-07-05:1.1.1.6
	gdb-1999-06-28:1.1.1.5
	gdb-1999-06-21:1.1.1.4
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.97
date	2013.09.06.08.53.09;	author aburgess;	state Exp;
branches;
next	1.96;

1.96
date	2013.08.28.12.25.05;	author qiyao;	state Exp;
branches;
next	1.95;

1.95
date	2013.05.05.16.54.26;	author jkratoch;	state Exp;
branches;
next	1.94;

1.94
date	2013.03.21.17.37.29;	author devans;	state Exp;
branches;
next	1.93;

1.93
date	2013.03.20.15.46.24;	author jkratoch;	state Exp;
branches;
next	1.92;

1.92
date	2013.01.31.18.37.37;	author aristovski;	state Exp;
branches;
next	1.91;

1.91
date	2013.01.22.20.17.10;	author palves;	state Exp;
branches;
next	1.90;

1.90
date	2013.01.01.06.32.42;	author brobecke;	state Exp;
branches;
next	1.89;

1.89
date	2012.10.23.06.20.49;	author qiyao;	state Exp;
branches;
next	1.88;

1.88
date	2012.10.23.06.12.04;	author qiyao;	state Exp;
branches;
next	1.87;

1.87
date	2012.08.22.17.48.52;	author tromey;	state Exp;
branches;
next	1.86;

1.86
date	2012.08.22.17.31.44;	author tromey;	state Exp;
branches;
next	1.85;

1.85
date	2012.01.04.08.17.01;	author brobecke;	state Exp;
branches;
next	1.84;

1.84
date	2011.09.21.15.21.28;	author jsm28;	state Exp;
branches
	1.84.2.1;
next	1.83;

1.83
date	2011.09.06.14.48.59;	author palves;	state Exp;
branches;
next	1.82;

1.82
date	2011.09.02.21.16.53;	author ratmice;	state Exp;
branches;
next	1.81;

1.81
date	2011.07.22.09.22.50;	author pmuldoon;	state Exp;
branches;
next	1.80;

1.80
date	2011.07.21.11.03.45;	author pmuldoon;	state Exp;
branches;
next	1.79;

1.79
date	2011.06.13.10.55.26;	author palves;	state Exp;
branches;
next	1.78;

1.78
date	2011.05.27.18.26.19;	author palves;	state Exp;
branches;
next	1.77;

1.77
date	2011.03.16.15.18.58;	author tromey;	state Exp;
branches;
next	1.76;

1.76
date	2011.03.01.21.12.27;	author msnyder;	state Exp;
branches;
next	1.75;

1.75
date	2011.01.01.15.33.03;	author brobecke;	state Exp;
branches;
next	1.74;

1.74
date	2010.12.29.00.58.14;	author msnyder;	state Exp;
branches;
next	1.73;

1.73
date	2010.09.11.16.00.25;	author jkratoch;	state Exp;
branches;
next	1.72;

1.72
date	2010.06.26.06.44.47;	author hilfingr;	state Exp;
branches;
next	1.71;

1.71
date	2010.05.14.18.35.11;	author msnyder;	state Exp;
branches;
next	1.70;

1.70
date	2010.01.01.07.31.31;	author brobecke;	state Exp;
branches;
next	1.69;

1.69
date	2009.09.23.17.27.39;	author tromey;	state Exp;
branches;
next	1.68;

1.68
date	2009.05.23.16.17.15;	author jkratoch;	state Exp;
branches
	1.68.4.1;
next	1.67;

1.67
date	2009.05.21.16.00.13;	author palves;	state Exp;
branches;
next	1.66;

1.66
date	2009.01.09.11.00.00;	author brobecke;	state Exp;
branches;
next	1.65;

1.65
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.64;

1.64
date	2008.09.08.21.46.21;	author palves;	state Exp;
branches;
next	1.63;

1.63
date	2008.08.16.23.51.14;	author palves;	state Exp;
branches;
next	1.62;

1.62
date	2008.07.12.19.25.42;	author palves;	state Exp;
branches;
next	1.61;

1.61
date	2008.07.09.22.16.14;	author palves;	state Exp;
branches;
next	1.60;

1.60
date	2008.05.02.13.58.38;	author ams;	state Exp;
branches;
next	1.59;

1.59
date	2008.03.14.19.55.51;	author vprus;	state Exp;
branches;
next	1.58;

1.58
date	2008.03.14.18.57.43;	author vprus;	state Exp;
branches;
next	1.57;

1.57
date	2008.03.05.17.21.10;	author drow;	state Exp;
branches;
next	1.56;

1.56
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.55;

1.55
date	2007.08.29.22.04.15;	author msnyder;	state Exp;
branches;
next	1.54;

1.54
date	2007.08.23.18.08.28;	author brobecke;	state Exp;
branches;
next	1.53;

1.53
date	2007.08.13.23.02.08;	author msnyder;	state Exp;
branches;
next	1.52;

1.52
date	2007.07.31.22.01.03;	author msnyder;	state Exp;
branches;
next	1.51;

1.51
date	2007.07.05.22.47.27;	author msnyder;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.09.23.45.35;	author fnf;	state Exp;
branches;
next	1.49;

1.49
date	2007.02.08.16.25.25;	author fnf;	state Exp;
branches;
next	1.48;

1.48
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.47;

1.47
date	2006.12.06.16.49.57;	author ams;	state Exp;
branches;
next	1.46;

1.46
date	2006.07.21.14.46.53;	author ams;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2006.02.23.18.37.42;	author drow;	state Exp;
branches
	1.45.14.1;
next	1.44;

1.44
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.43;

1.43
date	2005.11.25.18.33.12;	author ams;	state Exp;
branches;
next	1.42;

1.42
date	2005.11.02.05.57.25;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.01.11.09.18;	author ams;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.16.17.05.31;	author mmitchel;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2005.02.12.00.39.19;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2005.02.11.04.05.47;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2005.01.17.16.17.33;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2005.01.12.18.31.31;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2004.10.14.12.44.24;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2004.09.13.18.26.28;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2004.02.28.18.04.36;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.19.16.48.43;	author ezannoni;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2003.11.06.22.54.01;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.21.01.26.44;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.14.16.32.12;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.04.17.08.22;	author carlton;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.02.16.02.58;	author rth;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.12.15.31.30;	author cagney;	state Exp;
branches
	1.26.24.1;
next	1.25;

1.25
date	2003.02.06.01.19.12;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.05.22.38.11;	author ezannoni;	state Exp;
branches
	1.24.4.1;
next	1.23;

1.23
date	2002.10.03.01.23.50;	author ezannoni;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2002.07.03.20.27.12;	author hunt;	state Exp;
branches
	1.22.8.1;
next	1.21;

1.21
date	2002.06.21.00.13.54;	author ezannoni;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.27.21.20.15;	author schwab;	state Exp;
branches
	1.20.4.1
	1.20.6.1;
next	1.19;

1.19
date	2002.01.17.22.15.16;	author cagney;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2002.01.05.05.54.29;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.27.04.15.09;	author tromey;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.27.22.39.55;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.14.18.59.07;	author ciceron;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.19.23.56.13;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.06.08.21.07;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.07.07.29.38;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.06.04.17.03;	author jtc;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.15.01.01.46;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.01.23.53.02;	author davea;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.05.10.36.41;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.22.05.43.39;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.30.18.54.28;	author msnyder;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.19.12.30.38;	author eliz;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.03.15.37.09;	author ezannoni;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.23.00.25.42;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.05.11.20.29.07;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.84.2.1
date	2012.01.06.04.43.11;	author brobecke;	state Exp;
branches;
next	;

1.68.4.1
date	2009.09.23.17.33.06;	author tromey;	state Exp;
branches;
next	;

1.46.2.1
date	2006.12.06.16.54.13;	author ams;	state Exp;
branches;
next	;

1.45.14.1
date	2006.05.12.07.40.23;	author nickrob;	state Exp;
branches;
next	1.45.14.2;

1.45.14.2
date	2006.08.28.07.48.49;	author nickrob;	state Exp;
branches;
next	;

1.40.2.1
date	2005.03.28.19.10.24;	author mmitchel;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2005.04.05.17.53.05;	author mmitchel;	state Exp;
branches;
next	;

1.32.2.1
date	2004.03.27.17.37.46;	author drow;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2004.09.16.17.01.03;	author drow;	state Exp;
branches;
next	;

1.26.24.1
date	2003.06.03.20.54.34;	author cagney;	state Exp;
branches;
next	;

1.24.4.1
date	2003.02.03.06.02.44;	author cagney;	state Exp;
branches;
next	1.24.4.2;

1.24.4.2
date	2003.02.04.07.02.35;	author cagney;	state Exp;
branches;
next	1.24.4.3;

1.24.4.3
date	2003.02.04.19.59.01;	author cagney;	state Exp;
branches;
next	;

1.23.2.1
date	2003.12.14.20.27.12;	author drow;	state Exp;
branches;
next	;

1.22.8.1
date	2002.10.11.22.22.53;	author carlton;	state Exp;
branches;
next	1.22.8.2;

1.22.8.2
date	2002.11.15.19.18.43;	author carlton;	state Exp;
branches;
next	1.22.8.3;

1.22.8.3
date	2003.02.07.19.17.48;	author carlton;	state Exp;
branches;
next	1.22.8.4;

1.22.8.4
date	2003.03.06.00.56.27;	author carlton;	state Exp;
branches;
next	1.22.8.5;

1.22.8.5
date	2003.06.27.21.49.54;	author carlton;	state Exp;
branches;
next	1.22.8.6;

1.22.8.6
date	2003.08.05.17.13.05;	author carlton;	state Exp;
branches;
next	1.22.8.7;

1.22.8.7
date	2003.09.17.21.28.17;	author carlton;	state Exp;
branches;
next	1.22.8.8;

1.22.8.8
date	2003.11.11.23.50.43;	author carlton;	state Exp;
branches;
next	;

1.20.4.1
date	2002.06.21.16.46.51;	author cagney;	state Exp;
branches;
next	;

1.20.6.1
date	2002.05.28.23.47.01;	author kseitz;	state Exp;
branches;
next	1.20.6.2;

1.20.6.2
date	2002.07.22.21.46.58;	author kseitz;	state Exp;
branches;
next	1.20.6.3;

1.20.6.3
date	2002.11.04.00.17.30;	author ezannoni;	state Exp;
branches;
next	1.20.6.4;

1.20.6.4
date	2002.11.04.22.47.26;	author ezannoni;	state Exp;
branches;
next	1.20.6.5;

1.20.6.5
date	2002.11.05.22.16.50;	author ezannoni;	state Exp;
branches;
next	;

1.19.2.1
date	2002.06.21.00.13.22;	author ezannoni;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.11.20.29.07;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.05.25.18.01.49;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.06.14.18.07.27;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.06.21.13.24.51;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.06.28.16.00.27;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.07.05.17.52.48;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.07.07.20.05.55;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.07.19.23.27.53;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.08.02.23.45.26;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.08.16.19.52.29;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.08.31.01.04.52;	author jsm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	99.09.08.23.59.09;	author shebs;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.09.22.03.24.27;	author jsm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.09.28.21.52.05;	author jsm;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.10.05.23.08.11;	author jsm;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	99.10.26.03.43.10;	author jsm;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2000.01.18.00.54.09;	author jsm;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	2000.02.03.04.14.27;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.97
log
@Give every interpreter a command_loop_proc.

  https://sourceware.org/ml/gdb-patches/2013-09/msg00179.html

gdb/ChangeLog

        * cli/cli-interp.c (_initialize_cli_interp): Add a
        command_loop_proc to interp_procs.
        * event-top.c (cli_command_loop): Change signature to match
        interp_command_loop_ftype.
        * event-top.h (cli_command_loop): Same.
        * interps.c (interp_new): Require every interpreter to have a
        command_loop_proc.
        (current_interp_command_loop): Just call the command_loop_proc on
        the current interpreter.
        * tui/tui-interp.c (_initialize_tui_interp): Add a
        command_loop_proc to interp_procs.
@
text
@/* Top level stuff for GDB, the GNU debugger.

   Copyright (C) 1999-2013 Free Software Foundation, Inc.

   Written by Elena Zannoni <ezannoni@@cygnus.com> of Cygnus Solutions.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "top.h"
#include "inferior.h"
#include "target.h"
#include "terminal.h"		/* for job_control */
#include "event-loop.h"
#include "event-top.h"
#include "interps.h"
#include <signal.h>
#include "exceptions.h"
#include "cli/cli-script.h"     /* for reset_command_nest_depth */
#include "main.h"
#include "gdbthread.h"
#include "observer.h"
#include "continuations.h"
#include "gdbcmd.h"		/* for dont_repeat() */
#include "annotate.h"
#include "maint.h"

/* readline include files.  */
#include "readline/readline.h"
#include "readline/history.h"

/* readline defines this.  */
#undef savestring

static void rl_callback_read_char_wrapper (gdb_client_data client_data);
static void command_line_handler (char *rl);
static void change_line_handler (void);
static void command_handler (char *command);
static char *top_level_prompt (void);

/* Signal handlers.  */
#ifdef SIGQUIT
static void handle_sigquit (int sig);
#endif
#ifdef SIGHUP
static void handle_sighup (int sig);
#endif
static void handle_sigfpe (int sig);

/* Functions to be invoked by the event loop in response to
   signals.  */
#if defined (SIGQUIT) || defined (SIGHUP)
static void async_do_nothing (gdb_client_data);
#endif
#ifdef SIGHUP
static void async_disconnect (gdb_client_data);
#endif
static void async_float_handler (gdb_client_data);
#ifdef STOP_SIGNAL
static void async_stop_sig (gdb_client_data);
#endif

/* Readline offers an alternate interface, via callback
   functions.  These are all included in the file callback.c in the
   readline distribution.  This file provides (mainly) a function, which
   the event loop uses as callback (i.e. event handler) whenever an event
   is detected on the standard input file descriptor.
   readline_callback_read_char is called (by the GDB event loop) whenever
   there is a new character ready on the input stream.  This function
   incrementally builds a buffer internal to readline where it
   accumulates the line read up to the point of invocation.  In the
   special case in which the character read is newline, the function
   invokes a GDB supplied callback routine, which does the processing of
   a full command line.  This latter routine is the asynchronous analog
   of the old command_line_input in gdb.  Instead of invoking (and waiting
   for) readline to read the command line and pass it back to
   command_loop for processing, the new command_line_handler function has
   the command line already available as its parameter.  INPUT_HANDLER is
   to be set to the function that readline will invoke when a complete
   line of input is ready.  CALL_READLINE is to be set to the function
   that readline offers as callback to the event_loop.  */

void (*input_handler) (char *);
void (*call_readline) (gdb_client_data);

/* Important variables for the event loop.  */

/* This is used to determine if GDB is using the readline library or
   its own simplified form of readline.  It is used by the asynchronous
   form of the set editing command.
   ezannoni: as of 1999-04-29 I expect that this
   variable will not be used after gdb is changed to use the event
   loop as default engine, and event-top.c is merged into top.c.  */
int async_command_editing_p;

/* This is the annotation suffix that will be used when the
   annotation_level is 2.  */
char *async_annotation_suffix;

/* This is used to display the notification of the completion of an
   asynchronous execution command.  */
int exec_done_display_p = 0;

/* This is the file descriptor for the input stream that GDB uses to
   read commands from.  */
int input_fd;

/* Signal handling variables.  */
/* Each of these is a pointer to a function that the event loop will
   invoke if the corresponding signal has received.  The real signal
   handlers mark these functions as ready to be executed and the event
   loop, in a later iteration, calls them.  See the function
   invoke_async_signal_handler.  */
static struct async_signal_handler *sigint_token;
#ifdef SIGHUP
static struct async_signal_handler *sighup_token;
#endif
#ifdef SIGQUIT
static struct async_signal_handler *sigquit_token;
#endif
static struct async_signal_handler *sigfpe_token;
#ifdef STOP_SIGNAL
static struct async_signal_handler *sigtstp_token;
#endif

/* Structure to save a partially entered command.  This is used when
   the user types '\' at the end of a command line.  This is necessary
   because each line of input is handled by a different call to
   command_line_handler, and normally there is no state retained
   between different calls.  */
static int more_to_come = 0;

struct readline_input_state
  {
    char *linebuffer;
    char *linebuffer_ptr;
  }
readline_input_state;

/* This hook is called by rl_callback_read_char_wrapper after each
   character is processed.  */
void (*after_char_processing_hook) (void);


/* Wrapper function for calling into the readline library.  The event
   loop expects the callback function to have a paramter, while
   readline expects none.  */
static void
rl_callback_read_char_wrapper (gdb_client_data client_data)
{
  rl_callback_read_char ();
  if (after_char_processing_hook)
    (*after_char_processing_hook) ();
}

/* Initialize all the necessary variables, start the event loop,
   register readline, and stdin, start the loop.  The DATA is the
   interpreter data cookie, ignored for now.  */

void
cli_command_loop (void *data)
{
  display_gdb_prompt (0);

  /* Now it's time to start the event loop.  */
  start_event_loop ();
}

/* Change the function to be invoked every time there is a character
   ready on stdin.  This is used when the user sets the editing off,
   therefore bypassing readline, and letting gdb handle the input
   itself, via gdb_readline2.  Also it is used in the opposite case in
   which the user sets editing on again, by restoring readline
   handling of the input.  */
static void
change_line_handler (void)
{
  /* NOTE: this operates on input_fd, not instream.  If we are reading
     commands from a file, instream will point to the file.  However in
     async mode, we always read commands from a file with editing
     off.  This means that the 'set editing on/off' will have effect
     only on the interactive session.  */

  if (async_command_editing_p)
    {
      /* Turn on editing by using readline.  */
      call_readline = rl_callback_read_char_wrapper;
      input_handler = command_line_handler;
    }
  else
    {
      /* Turn off editing by using gdb_readline2.  */
      rl_callback_handler_remove ();
      call_readline = gdb_readline2;

      /* Set up the command handler as well, in case we are called as
         first thing from .gdbinit.  */
      input_handler = command_line_handler;
    }
}

/* Displays the prompt.  If the argument NEW_PROMPT is NULL, the
   prompt that is displayed is the current top level prompt.
   Otherwise, it displays whatever NEW_PROMPT is as a local/secondary
   prompt.

   This is used after each gdb command has completed, and in the
   following cases:

   1. When the user enters a command line which is ended by '\'
   indicating that the command will continue on the next line.  In
   that case the prompt that is displayed is the empty string.

   2. When the user is entering 'commands' for a breakpoint, or
   actions for a tracepoint.  In this case the prompt will be '>'

   3. On prompting for pagination.  */

void
display_gdb_prompt (char *new_prompt)
{
  char *actual_gdb_prompt = NULL;
  struct cleanup *old_chain;

  annotate_display_prompt ();

  /* Reset the nesting depth used when trace-commands is set.  */
  reset_command_nest_depth ();

  /* Each interpreter has its own rules on displaying the command
     prompt.  */
  if (!current_interp_display_prompt_p ())
    return;

  old_chain = make_cleanup (free_current_contents, &actual_gdb_prompt);

  /* Do not call the python hook on an explicit prompt change as
     passed to this function, as this forms a secondary/local prompt,
     IE, displayed but not set.  */
  if (! new_prompt)
    {
      if (sync_execution)
	{
	  /* This is to trick readline into not trying to display the
	     prompt.  Even though we display the prompt using this
	     function, readline still tries to do its own display if
	     we don't call rl_callback_handler_install and
	     rl_callback_handler_remove (which readline detects
	     because a global variable is not set).  If readline did
	     that, it could mess up gdb signal handlers for SIGINT.
	     Readline assumes that between calls to rl_set_signals and
	     rl_clear_signals gdb doesn't do anything with the signal
	     handlers.  Well, that's not the case, because when the
	     target executes we change the SIGINT signal handler.  If
	     we allowed readline to display the prompt, the signal
	     handler change would happen exactly between the calls to
	     the above two functions.  Calling
	     rl_callback_handler_remove(), does the job.  */

	  rl_callback_handler_remove ();
	  do_cleanups (old_chain);
	  return;
	}
      else
	{
	  /* Display the top level prompt.  */
	  actual_gdb_prompt = top_level_prompt ();
	}
    }
  else
    actual_gdb_prompt = xstrdup (new_prompt);

  if (async_command_editing_p)
    {
      rl_callback_handler_remove ();
      rl_callback_handler_install (actual_gdb_prompt, input_handler);
    }
  /* new_prompt at this point can be the top of the stack or the one
     passed in.  It can't be NULL.  */
  else
    {
      /* Don't use a _filtered function here.  It causes the assumed
         character position to be off, since the newline we read from
         the user is not accounted for.  */
      fputs_unfiltered (actual_gdb_prompt, gdb_stdout);
      gdb_flush (gdb_stdout);
    }

  do_cleanups (old_chain);
}

/* Return the top level prompt, as specified by "set prompt", possibly
   overriden by the python gdb.prompt_hook hook, and then composed
   with the prompt prefix and suffix (annotations).  The caller is
   responsible for freeing the returned string.  */

static char *
top_level_prompt (void)
{
  char *prefix;
  char *prompt = NULL;
  char *suffix;
  char *composed_prompt;
  size_t prompt_length;

  /* Give observers a chance of changing the prompt.  E.g., the python
     `gdb.prompt_hook' is installed as an observer.  */
  observer_notify_before_prompt (get_prompt ());

  prompt = xstrdup (get_prompt ());

  if (annotation_level >= 2)
    {
      /* Prefix needs to have new line at end.  */
      prefix = (char *) alloca (strlen (async_annotation_suffix) + 10);
      strcpy (prefix, "\n\032\032pre-");
      strcat (prefix, async_annotation_suffix);
      strcat (prefix, "\n");

      /* Suffix needs to have a new line at end and \032 \032 at
	 beginning.  */
      suffix = (char *) alloca (strlen (async_annotation_suffix) + 6);
      strcpy (suffix, "\n\032\032");
      strcat (suffix, async_annotation_suffix);
      strcat (suffix, "\n");
    }
  else
    {
      prefix = "";
      suffix = "";
    }

  prompt_length = strlen (prefix) + strlen (prompt) + strlen (suffix);
  composed_prompt = xmalloc (prompt_length + 1);

  strcpy (composed_prompt, prefix);
  strcat (composed_prompt, prompt);
  strcat (composed_prompt, suffix);

  xfree (prompt);

  return composed_prompt;
}

/* When there is an event ready on the stdin file desriptor, instead
   of calling readline directly throught the callback function, or
   instead of calling gdb_readline2, give gdb a chance to detect
   errors and do something.  */
void
stdin_event_handler (int error, gdb_client_data client_data)
{
  if (error)
    {
      printf_unfiltered (_("error detected on stdin\n"));
      delete_file_handler (input_fd);
      discard_all_continuations ();
      discard_all_intermediate_continuations ();
      /* If stdin died, we may as well kill gdb.  */
      quit_command ((char *) 0, stdin == instream);
    }
  else
    (*call_readline) (client_data);
}

/* Re-enable stdin after the end of an execution command in
   synchronous mode, or after an error from the target, and we aborted
   the exec operation.  */

void
async_enable_stdin (void)
{
  if (sync_execution)
    {
      /* See NOTE in async_disable_stdin().  */
      /* FIXME: cagney/1999-09-27: Call this before clearing
	 sync_execution.  Current target_terminal_ours() implementations
	 check for sync_execution before switching the terminal.  */
      target_terminal_ours ();
      sync_execution = 0;
    }
}

/* Disable reads from stdin (the console) marking the command as
   synchronous.  */

void
async_disable_stdin (void)
{
  sync_execution = 1;
}


/* Handles a gdb command.  This function is called by
   command_line_handler, which has processed one or more input lines
   into COMMAND.  */
/* NOTE: 1999-04-30 This is the asynchronous version of the command_loop
   function.  The command_loop function will be obsolete when we
   switch to use the event loop at every execution of gdb.  */
static void
command_handler (char *command)
{
  int stdin_is_tty = ISATTY (stdin);
  struct cleanup *stat_chain;

  clear_quit_flag ();
  if (instream == stdin && stdin_is_tty)
    reinitialize_more_filter ();

  /* If readline returned a NULL command, it means that the connection
     with the terminal is gone.  This happens at the end of a
     testsuite run, after Expect has hung up but GDB is still alive.
     In such a case, we just quit gdb killing the inferior program
     too.  */
  if (command == 0)
    {
      printf_unfiltered ("quit\n");
      execute_command ("quit", stdin == instream);
    }

  stat_chain = make_command_stats_cleanup (1);

  execute_command (command, instream == stdin);

  /* Do any commands attached to breakpoint we stopped at.  */
  bpstat_do_actions ();

  do_cleanups (stat_chain);
}

/* Handle a complete line of input.  This is called by the callback
   mechanism within the readline library.  Deal with incomplete
   commands as well, by saving the partial input in a global
   buffer.  */

/* NOTE: 1999-04-30 This is the asynchronous version of the
   command_line_input function; command_line_input will become
   obsolete once we use the event loop as the default mechanism in
   GDB.  */
static void
command_line_handler (char *rl)
{
  static char *linebuffer = 0;
  static unsigned linelength = 0;
  char *p;
  char *p1;
  char *nline;
  int repeat = (instream == stdin);

  if (annotation_level > 1 && instream == stdin)
    {
      printf_unfiltered (("\n\032\032post-"));
      puts_unfiltered (async_annotation_suffix);
      printf_unfiltered (("\n"));
    }

  if (linebuffer == 0)
    {
      linelength = 80;
      linebuffer = (char *) xmalloc (linelength);
    }

  p = linebuffer;

  if (more_to_come)
    {
      strcpy (linebuffer, readline_input_state.linebuffer);
      p = readline_input_state.linebuffer_ptr;
      xfree (readline_input_state.linebuffer);
      more_to_come = 0;
    }

#ifdef STOP_SIGNAL
  if (job_control)
    signal (STOP_SIGNAL, handle_stop_sig);
#endif

  /* Make sure that all output has been output.  Some machines may let
     you get away with leaving out some of the gdb_flush, but not
     all.  */
  wrap_here ("");
  gdb_flush (gdb_stdout);
  gdb_flush (gdb_stderr);

  if (source_file_name != NULL)
    ++source_line_number;

  /* If we are in this case, then command_handler will call quit 
     and exit from gdb.  */
  if (!rl || rl == (char *) EOF)
    {
      command_handler (0);
      return;			/* Lint.  */
    }
  if (strlen (rl) + 1 + (p - linebuffer) > linelength)
    {
      linelength = strlen (rl) + 1 + (p - linebuffer);
      nline = (char *) xrealloc (linebuffer, linelength);
      p += nline - linebuffer;
      linebuffer = nline;
    }
  p1 = rl;
  /* Copy line.  Don't copy null at end.  (Leaves line alone
     if this was just a newline).  */
  while (*p1)
    *p++ = *p1++;

  xfree (rl);			/* Allocated in readline.  */

  if (p > linebuffer && *(p - 1) == '\\')
    {
      *p = '\0';
      p--;			/* Put on top of '\'.  */

      readline_input_state.linebuffer = xstrdup (linebuffer);
      readline_input_state.linebuffer_ptr = p;

      /* We will not invoke a execute_command if there is more
	 input expected to complete the command.  So, we need to
	 print an empty prompt here.  */
      more_to_come = 1;
      display_gdb_prompt ("");
      return;
    }

#ifdef STOP_SIGNAL
  if (job_control)
    signal (STOP_SIGNAL, SIG_DFL);
#endif

#define SERVER_COMMAND_LENGTH 7
  server_command =
    (p - linebuffer > SERVER_COMMAND_LENGTH)
    && strncmp (linebuffer, "server ", SERVER_COMMAND_LENGTH) == 0;
  if (server_command)
    {
      /* Note that we don't set `line'.  Between this and the check in
         dont_repeat, this insures that repeating will still do the
         right thing.  */
      *p = '\0';
      command_handler (linebuffer + SERVER_COMMAND_LENGTH);
      display_gdb_prompt (0);
      return;
    }

  /* Do history expansion if that is wished.  */
  if (history_expansion_p && instream == stdin
      && ISATTY (instream))
    {
      char *history_value;
      int expanded;

      *p = '\0';		/* Insert null now.  */
      expanded = history_expand (linebuffer, &history_value);
      if (expanded)
	{
	  /* Print the changes.  */
	  printf_unfiltered ("%s\n", history_value);

	  /* If there was an error, call this function again.  */
	  if (expanded < 0)
	    {
	      xfree (history_value);
	      return;
	    }
	  if (strlen (history_value) > linelength)
	    {
	      linelength = strlen (history_value) + 1;
	      linebuffer = (char *) xrealloc (linebuffer, linelength);
	    }
	  strcpy (linebuffer, history_value);
	  p = linebuffer + strlen (linebuffer);
	}
      xfree (history_value);
    }

  /* If we just got an empty line, and that is supposed to repeat the
     previous command, return the value in the global buffer.  */
  if (repeat && p == linebuffer && *p != '\\')
    {
      command_handler (saved_command_line);
      display_gdb_prompt (0);
      return;
    }

  for (p1 = linebuffer; *p1 == ' ' || *p1 == '\t'; p1++);
  if (repeat && !*p1)
    {
      command_handler (saved_command_line);
      display_gdb_prompt (0);
      return;
    }

  *p = 0;

  /* Add line to history if appropriate.  */
  if (instream == stdin
      && ISATTY (stdin) && *linebuffer)
    add_history (linebuffer);

  /* Note: lines consisting solely of comments are added to the command
     history.  This is useful when you type a command, and then
     realize you don't want to execute it quite yet.  You can comment
     out the command and then later fetch it from the value history
     and remove the '#'.  The kill ring is probably better, but some
     people are in the habit of commenting things out.  */
  if (*p1 == '#')
    *p1 = '\0';			/* Found a comment.  */

  /* Save into global buffer if appropriate.  */
  if (repeat)
    {
      if (linelength > saved_command_line_size)
	{
	  saved_command_line = xrealloc (saved_command_line, linelength);
	  saved_command_line_size = linelength;
	}
      strcpy (saved_command_line, linebuffer);
      if (!more_to_come)
	{
	  command_handler (saved_command_line);
	  display_gdb_prompt (0);
	}
      return;
    }

  command_handler (linebuffer);
  display_gdb_prompt (0);
  return;
}

/* Does reading of input from terminal w/o the editing features
   provided by the readline library.  */

/* NOTE: 1999-04-30 Asynchronous version of gdb_readline; gdb_readline
   will become obsolete when the event loop is made the default
   execution for gdb.  */
void
gdb_readline2 (gdb_client_data client_data)
{
  int c;
  char *result;
  int input_index = 0;
  int result_size = 80;
  static int done_once = 0;

  /* Unbuffer the input stream, so that, later on, the calls to fgetc
     fetch only one char at the time from the stream.  The fgetc's will
     get up to the first newline, but there may be more chars in the
     stream after '\n'.  If we buffer the input and fgetc drains the
     stream, getting stuff beyond the newline as well, a select, done
     afterwards will not trigger.  */
  if (!done_once && !ISATTY (instream))
    {
      setbuf (instream, NULL);
      done_once = 1;
    }

  result = (char *) xmalloc (result_size);

  /* We still need the while loop here, even though it would seem
     obvious to invoke gdb_readline2 at every character entered.  If
     not using the readline library, the terminal is in cooked mode,
     which sends the characters all at once.  Poll will notice that the
     input fd has changed state only after enter is pressed.  At this
     point we still need to fetch all the chars entered.  */

  while (1)
    {
      /* Read from stdin if we are executing a user defined command.
         This is the right thing for prompt_for_continue, at least.  */
      c = fgetc (instream ? instream : stdin);

      if (c == EOF)
	{
	  if (input_index > 0)
	    /* The last line does not end with a newline.  Return it,
	       and if we are called again fgetc will still return EOF
	       and we'll return NULL then.  */
	    break;
	  xfree (result);
	  (*input_handler) (0);
	  return;
	}

      if (c == '\n')
	{
	  if (input_index > 0 && result[input_index - 1] == '\r')
	    input_index--;
	  break;
	}

      result[input_index++] = c;
      while (input_index >= result_size)
	{
	  result_size *= 2;
	  result = (char *) xrealloc (result, result_size);
	}
    }

  result[input_index++] = '\0';
  (*input_handler) (result);
}


/* Initialization of signal handlers and tokens.  There is a function
   handle_sig* for each of the signals GDB cares about.  Specifically:
   SIGINT, SIGFPE, SIGQUIT, SIGTSTP, SIGHUP, SIGWINCH.  These
   functions are the actual signal handlers associated to the signals
   via calls to signal().  The only job for these functions is to
   enqueue the appropriate event/procedure with the event loop.  Such
   procedures are the old signal handlers.  The event loop will take
   care of invoking the queued procedures to perform the usual tasks
   associated with the reception of the signal.  */
/* NOTE: 1999-04-30 This is the asynchronous version of init_signals.
   init_signals will become obsolete as we move to have to event loop
   as the default for gdb.  */
void
async_init_signals (void)
{
  signal (SIGINT, handle_sigint);
  sigint_token =
    create_async_signal_handler (async_request_quit, NULL);
  signal (SIGTERM, handle_sigterm);

  /* If SIGTRAP was set to SIG_IGN, then the SIG_IGN will get passed
     to the inferior and breakpoints will be ignored.  */
#ifdef SIGTRAP
  signal (SIGTRAP, SIG_DFL);
#endif

#ifdef SIGQUIT
  /* If we initialize SIGQUIT to SIG_IGN, then the SIG_IGN will get
     passed to the inferior, which we don't want.  It would be
     possible to do a "signal (SIGQUIT, SIG_DFL)" after we fork, but
     on BSD4.3 systems using vfork, that can affect the
     GDB process as well as the inferior (the signal handling tables
     might be in memory, shared between the two).  Since we establish
     a handler for SIGQUIT, when we call exec it will set the signal
     to SIG_DFL for us.  */
  signal (SIGQUIT, handle_sigquit);
  sigquit_token =
    create_async_signal_handler (async_do_nothing, NULL);
#endif
#ifdef SIGHUP
  if (signal (SIGHUP, handle_sighup) != SIG_IGN)
    sighup_token =
      create_async_signal_handler (async_disconnect, NULL);
  else
    sighup_token =
      create_async_signal_handler (async_do_nothing, NULL);
#endif
  signal (SIGFPE, handle_sigfpe);
  sigfpe_token =
    create_async_signal_handler (async_float_handler, NULL);

#ifdef STOP_SIGNAL
  sigtstp_token =
    create_async_signal_handler (async_stop_sig, NULL);
#endif

}

/* Tell the event loop what to do if SIGINT is received.
   See event-signal.c.  */
void
handle_sigint (int sig)
{
  signal (sig, handle_sigint);

  /* We could be running in a loop reading in symfiles or something so
     it may be quite a while before we get back to the event loop.  So
     set quit_flag to 1 here.  Then if QUIT is called before we get to
     the event loop, we will unwind as expected.  */

  set_quit_flag ();

  /* If immediate_quit is set, we go ahead and process the SIGINT right
     away, even if we usually would defer this to the event loop.  The
     assumption here is that it is safe to process ^C immediately if
     immediate_quit is set.  If we didn't, SIGINT would be really
     processed only the next time through the event loop.  To get to
     that point, though, the command that we want to interrupt needs to
     finish first, which is unacceptable.  If immediate quit is not set,
     we process SIGINT the next time through the loop, which is fine.  */
  gdb_call_async_signal_handler (sigint_token, immediate_quit);
}

/* Quit GDB if SIGTERM is received.
   GDB would quit anyway, but this way it will clean up properly.  */
void
handle_sigterm (int sig)
{
  signal (sig, handle_sigterm);
  quit_force ((char *) 0, stdin == instream);
}

/* Do the quit.  All the checks have been done by the caller.  */
void
async_request_quit (gdb_client_data arg)
{
  /* If the quit_flag has gotten reset back to 0 by the time we get
     back here, that means that an exception was thrown to unwind the
     current command before we got back to the event loop.  So there
     is no reason to call quit again here.  */

  if (check_quit_flag ())
    quit ();
}

#ifdef SIGQUIT
/* Tell the event loop what to do if SIGQUIT is received.
   See event-signal.c.  */
static void
handle_sigquit (int sig)
{
  mark_async_signal_handler (sigquit_token);
  signal (sig, handle_sigquit);
}
#endif

#if defined (SIGQUIT) || defined (SIGHUP)
/* Called by the event loop in response to a SIGQUIT or an
   ignored SIGHUP.  */
static void
async_do_nothing (gdb_client_data arg)
{
  /* Empty function body.  */
}
#endif

#ifdef SIGHUP
/* Tell the event loop what to do if SIGHUP is received.
   See event-signal.c.  */
static void
handle_sighup (int sig)
{
  mark_async_signal_handler (sighup_token);
  signal (sig, handle_sighup);
}

/* Called by the event loop to process a SIGHUP.  */
static void
async_disconnect (gdb_client_data arg)
{
  volatile struct gdb_exception exception;

  TRY_CATCH (exception, RETURN_MASK_ALL)
    {
      quit_cover ();
    }

  if (exception.reason < 0)
    {
      fputs_filtered ("Could not kill the program being debugged",
		      gdb_stderr);
      exception_print (gdb_stderr, exception);
    }

  TRY_CATCH (exception, RETURN_MASK_ALL)
    {
      pop_all_targets ();
    }

  signal (SIGHUP, SIG_DFL);	/*FIXME: ???????????  */
  raise (SIGHUP);
}
#endif

#ifdef STOP_SIGNAL
void
handle_stop_sig (int sig)
{
  mark_async_signal_handler (sigtstp_token);
  signal (sig, handle_stop_sig);
}

static void
async_stop_sig (gdb_client_data arg)
{
  char *prompt = get_prompt ();

#if STOP_SIGNAL == SIGTSTP
  signal (SIGTSTP, SIG_DFL);
#if HAVE_SIGPROCMASK
  {
    sigset_t zero;

    sigemptyset (&zero);
    sigprocmask (SIG_SETMASK, &zero, 0);
  }
#elif HAVE_SIGSETMASK
  sigsetmask (0);
#endif
  raise (SIGTSTP);
  signal (SIGTSTP, handle_stop_sig);
#else
  signal (STOP_SIGNAL, handle_stop_sig);
#endif
  printf_unfiltered ("%s", prompt);
  gdb_flush (gdb_stdout);

  /* Forget about any previous command -- null line now will do
     nothing.  */
  dont_repeat ();
}
#endif /* STOP_SIGNAL */

/* Tell the event loop what to do if SIGFPE is received.
   See event-signal.c.  */
static void
handle_sigfpe (int sig)
{
  mark_async_signal_handler (sigfpe_token);
  signal (sig, handle_sigfpe);
}

/* Event loop will call this functin to process a SIGFPE.  */
static void
async_float_handler (gdb_client_data arg)
{
  /* This message is based on ANSI C, section 4.7.  Note that integer
     divide by zero causes this, so "float" is a misnomer.  */
  error (_("Erroneous arithmetic operation."));
}


/* Called by do_setshow_command.  */
void
set_async_editing_command (char *args, int from_tty,
			   struct cmd_list_element *c)
{
  change_line_handler ();
}

/* Set things up for readline to be invoked via the alternate
   interface, i.e. via a callback function (rl_callback_read_char),
   and hook up instream to the event loop.  */
void
gdb_setup_readline (void)
{
  /* This function is a noop for the sync case.  The assumption is
     that the sync setup is ALL done in gdb_init, and we would only
     mess it up here.  The sync stuff should really go away over
     time.  */
  if (!batch_silent)
    gdb_stdout = stdio_fileopen (stdout);
  gdb_stderr = stderr_fileopen ();
  gdb_stdlog = gdb_stderr;  /* for moment */
  gdb_stdtarg = gdb_stderr; /* for moment */
  gdb_stdtargerr = gdb_stderr; /* for moment */

  /* If the input stream is connected to a terminal, turn on
     editing.  */
  if (ISATTY (instream))
    {
      /* Tell gdb that we will be using the readline library.  This
	 could be overwritten by a command in .gdbinit like 'set
	 editing on' or 'off'.  */
      async_command_editing_p = 1;
	  
      /* When a character is detected on instream by select or poll,
	 readline will be invoked via this callback function.  */
      call_readline = rl_callback_read_char_wrapper;
    }
  else
    {
      async_command_editing_p = 0;
      call_readline = gdb_readline2;
    }
  
  /* When readline has read an end-of-line character, it passes the
     complete line to gdb for processing; command_line_handler is the
     function that does this.  */
  input_handler = command_line_handler;
      
  /* Tell readline to use the same input stream that gdb uses.  */
  rl_instream = instream;

  /* Get a file descriptor for the input stream, so that we can
     register it with the event loop.  */
  input_fd = fileno (instream);

  /* Now we need to create the event sources for the input file
     descriptor.  */
  /* At this point in time, this is the only event source that we
     register with the even loop.  Another source is going to be the
     target program (inferior), but that must be registered only when
     it actually exists (I.e. after we say 'run' or after we connect
     to a remote target.  */
  add_file_handler (input_fd, stdin_event_handler, 0);
}

/* Disable command input through the standard CLI channels.  Used in
   the suspend proc for interpreters that use the standard gdb readline
   interface, like the cli & the mi.  */
void
gdb_disable_readline (void)
{
  /* FIXME - It is too heavyweight to delete and remake these every
     time you run an interpreter that needs readline.  It is probably
     better to have the interpreters cache these, which in turn means
     that this needs to be moved into interpreter specific code.  */

#if 0
  ui_file_delete (gdb_stdout);
  ui_file_delete (gdb_stderr);
  gdb_stdlog = NULL;
  gdb_stdtarg = NULL;
  gdb_stdtargerr = NULL;
#endif

  rl_callback_handler_remove ();
  delete_file_handler (input_fd);
}
@


1.96
log
@gdb/

	* event-top.c (gdb_setup_readline): Call stderr_fileopen
	instead of stdio_fileopen.
	* main.c (captured_main) [__MINGW32__]: Set stderr unbuffered.
	.Call stderr_fileopen instead of stdio_fileopen.
	* ui-file.c [__MINGW32__] (stderr_file_write): New function.
	[__MINGW32__] (stderr_file_fputs): New function.
	(stderr_fileopen): New function.
	* ui-file.h (stderr_fileopen): Declare.
@
text
@d170 3
a172 1
   register readline, and stdin, start the loop.  */
d174 1
a174 1
cli_command_loop (void)
@


1.95
log
@gdb/
	* event-top.c (display_gdb_prompt): Call missing do_cleanups.
	* infcmd.c (get_return_value) <!stop_regs>: Do not overwrite CLEANUP.
	* symfile.c (symfile_bfd_open): New variable back_to.  Do not leave
	a stale cleanup.  Fix double free of NAME.
@
text
@d958 1
a958 1
  gdb_stderr = stdio_fileopen (stderr);
@


1.94
log
@	New commands "mt set per-command {space,time,symtab} {on,off}".
	* NEWS: Add entry.
	* event-top.c: #include "maint.h".
	* main.c: #include "maint.h".
	* maint.c: #include <sys/time.h>, <time.h>, block.h, top.h,
	timeval-utils.h, maint.h, cli/cli-setshow.h.
	(per_command_time, per_command_space): New static globals.
	(per_command_symtab): New static global.
	(per_command_setlist, per_command_showlist): New static globals.
	(struct cmd_stats): Move here from utils.c.
	(set_per_command_time): Renamed from set_display_time in utils.c
	and moved here.  All callers updated.
	(set_per_command_space): Renamed from set_display_space in utils.c
	and moved here.  All callers updated.
	(count_symtabs_and_blocks): New function.
	(report_command_stats): Moved here from utils.c.  Add support for
	printing symtab stats.  Only print data if enabled before command
	executed.
	(make_command_stats_cleanup): Ditto.
	(sert_per_command_cmd, show_per_command_cmd): New functions.
	(_initialize_maint_cmds): Add new commands
	mt set per-command {space,time,symtab} {on,off}.
	* maint.h: New file.
	* top.c: #include "maint.h".
	* utils.c (reset_prompt_for_continue_wait_time): New function.
	(get_prompt_for_continue_wait_time): New function.
	* utils.h (reset_prompt_for_continue_wait_time): Declare
	(get_prompt_for_continue_wait_time): Declare.
	(make_command_stats_cleanup): Moved to maint.h.
	(set_display_time, set_display_space): Moved to maint.h and renamed
	to set_per_command_time, set_per_command_space.
	* cli/cli-setshow.c (parse_cli_boolean_value): Renamed from
	parse_binary_operation and made non-static.  Don't call error,
	just return an error marker.  All callers updated.
	* cli/cli-setshow.h (parse_cli_boolean_value): Declare.

	doc/
	* gdb.texinfo (Maintenance Commands): Add docs for
	"mt set per-command {space,time,symtab} {on,off}".

	testsuite/
	* gdb.base/maint.exp: Update tests for per-command stats.
@
text
@d272 1
@


1.93
log
@gdb/
	Code cleanup.
	* bfd-target.c (target_bfd_xclose): Remove parameter quitting.
	* bsd-kvm.c (bsd_kvm_close): Likewise.
	* bsd-uthread.c (bsd_uthread_close): Likewise.
	* corelow.c (core_close): Likewise.
	(core_close_cleanup): Remove parameter quitting from a caller.
	* event-top.c (async_disconnect): Likewise.
	* exec.c (exec_close_1): Remove parameter quitting.
	* go32-nat.c (go32_close): Likewise.
	* linux-nat.c (linux_nat_close): Remove parameter quitting.  Remove
	parameter quitting from a caller.
	* mips-linux-nat.c (super_close): Remove parameter quitting from the
	variable.
	(mips_linux_close): Remove parameter quitting.  Remove parameter
	quitting from a caller.
	* monitor.c (monitor_close): Remove parameter quitting.
	* monitor.h (monitor_close): Likewise.
	* record-btrace.c (record_btrace_close): Likewise.
	* record-full.c (record_full_close): Likewise.
	* remote-m32r-sdi.c (m32r_close): Remove parameter quitting and remove
	it also from fprintf_unfiltered.
	* remote-mips.c (mips_close): Remove parameter quitting.
	(mips_detach): Remove parameter quitting from a caller.
	* remote-sim.c (gdbsim_close): Remove parameter quitting.
	(gdbsim_close): Remove duplicate function comment.  Remove parameter
	quitting and remove it also from printf_filtered.
	* remote.c (remote_close): Remove parameter quitting.
	* solib-svr4.c (enable_break): Remove parameter quitting from a caller.
	* target.c (update_current_target): Remove parameter int from to_close
	de_fault.
	(push_target, unpush_target, pop_target): Remove parameter quitting from
	a caller.
	(pop_all_targets_above, pop_all_targets): Remove parameter quitting.
	Remove parameter quitting from a caller.
	(target_preopen): Remove parameter quitting from a caller.
	(target_close): Remove parameter quitting.  Remove parameter quitting
	from a caller two times.  Remove parameter quitting also from
	fprintf_unfiltered.
	* target.h (struct target_ops): Remove parameter quitting and as int
	from fields to_xclose and to_close.
	(extern struct target_ops current_target):
	(target_close, pop_all_targets): Remove parameter quitting.  Update the
	comment.
	(pop_all_targets_above): Remove parameter quitting.
	* top.c (quit_target): Remove parameter quitting from a caller.
	* tracepoint.c (tfile_close): Remove parameter quitting.
	* windows-nat.c (windows_close): Remove parameter quitting.
@
text
@d39 1
@


1.92
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

	* charset.c (intermediate_encoding): Remove unused i.
	* completer.c (signal_completer): Remove unused i.
	* continuations.c (discard_my_continuations_1): Remove unused
	continuation_ptr.
	* corelow.c (core_close): Remove unuseD name.
	(get_core_siginfo): Remove unused pid.
	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Remove unused
	i, cps.
	* dwarf2loc.c (dwarf2_compile_expr_to_ax): Remove unused base_offset.
	(loclist_describe_location): Remove unused first.
	* event-top.c (command_line_handler): Remove unused got_eof.
	* exec.c (exec_close_1): Remove unused need_symtab_cleanup.
	(resize_section_table): Remove unused old_value.
	* gdb_bfd.c (gdb_bfd_map_section): Remove unused header.
	* gnu-v3-abi.c (compute_vtable_size): Remove unused addr.
	* i386-tdep.c (i386_process_record): Remove unused rex.
	* infcmd.c (get_return_value): Remove unused uiout.
	* jv-lang.c (type_from_class): Remove unused is_array.
	* jv-valprint.c (java_val_print): Remove unused i.
	* linux-nat.c (linux_nat_stop_lwp): Remove unused ptid.
	* linux-thread-db.c (thread_db_find_new_threads_2): Remove unuseD pid.
	* m2-typeprint.c (m2_print_type): Remove unused code.
	* macroexp.c (get_character_constant): Remove unused body_start.
	(macro_stringify): Remove unused result.
	* objc-lang.c (find_methods): Remove unused gdbarch.
	* objfiles.c (filter_overlapping_sections): Remove unused abfd1, abfd2.
	* regcache.c (regcache_cooked_read): Remove unused gdbarch.
	* stack.c (print_frame_args): Remove unused summary.
	* thread.c (thread_apply_command): Remove unused p.
	* valarith.c (value_x_unop): Remove unused mangle_ptr.
	* valops.c (search_struct_method): Remove unused skip.
	* valprint.c (generic_val_print): Remove unused byte_order.
	* varobj.c (varobj_update): Remove unused changed.
	* cli/cli-cmds.c (complete_command): Remove unused next_item.
	(alias_command): Remove unused c.
	* mi/mi-cmd-catch.c (mi_catch_load_unload): Remove unused c.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Remove unused
	format.
	(mi_cmd_data_write_memory): Remove unused word_format.
	(mi_cmd_data_write_memory_bytes): Remove unused r.
	* python/py-gdb-readline.c (gdbpy_readline_wrapper): Remove unused
	p_start, p_end.
	* python/python.c (_initialize_python): Remove unused cmd_name, cmd.
	* tui/tui-disasm.c (tui_set_disassem_content): Remove unused
	line_width.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00766.html
@
text
@d870 1
a870 1
      pop_all_targets (1);
@


1.91
log
@With some changes to how software single-step (SSS) breakpoints are
handled, one of those being to place SSS breakpoints on the breakpoint
chain as all other breakpoints, annota1.exp times out with lots and
lots of breakpoint-invalid and frame-changed annotations.  All those
extra annotations are actually unnecessary.  For one, SSS breakpoints
are internal breakpoints, so the frontend shouldn't care if they were
added, removed or changed.  Then, there's really no point in emitting
"breakpoints-invalid" or "frames-invalid" more than once between times
the frontend/user can actually issues GDB commands; the frontend will
have to wait for the GDB prompt to refresh its state, so emitting
those annotations at most once between prompts is enough.  Non-stop or
async would complicate this, but no frontend will be using annotations
in those modes (one of goes of emacs switching to MI was non-stop mode
support, AFAIK).  The previous patch reveals there has been an
intention in the past to suppress multiple breakpoints-invalid
annotations caused by ignore count changes.  As the previous patch
shows, that's always been broken, but in any case, this patch actually
makes it work.  The next patch will remove several annotation-specific
calls in breakpoint.c in favor of always using the breakpoint modified
& friends observers, and that causes yet more of these annotations,
because several calls to the corresponding annotate_* functions in
breakpoint.c are missing, particularly in newer code.

So all in all, here's a simple mechanism that avoids sending the same
annotation to the frontend more than once until gdb is ready to accept
further commands.

Tested on x86_64 Fedora 17.

2013-01-22  Pedro Alves  <palves@@redhat.com>

	* annotate.c: Include "inferior.h".
	(frames_invalid_emitted)
	(breakpoints_invalid_emitted): New globals.
	(async_background_execution_p): New function.
	(annotate_breakpoints_changed, annotate_frames_invalid): Skip
	emitting the annotation if it has already been emitted.
	(annotate_display_prompt): New function.
	* annotate.h (annotate_display_prompt): New declaration.
	* event-top.c: Include annotate.h.
	(display_gdb_prompt): Call annotate_display_prompt.
@
text
@a455 2
  char got_eof = 0;

a499 1
      got_eof = 1;
@


1.90
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d38 1
d235 2
@


1.89
log
@gdb/
	* event-top.c (mark_async_signal_handler_wrapper): Remove.
	* event-top.h: Remove its declaration.
	(async_request_quit): Call mark_async_signal_handler instead of
	mark_async_signal_handler_wrapper.
	(async_do_nothing, async_disconnect): Likewise.
	(async_stop_sig): Likewise.
	* remote.c (handle_remote_sigint): Likewise.
	(handle_remote_sigint_twice): Likewise.
@
text
@d3 1
a3 2
   Copyright (C) 1999-2002, 2004-2005, 2007-2012 Free Software
   Foundation, Inc.
@


1.88
log
@gdb/
	* event-top.c (sigint_token, sighup_token): Replace 'void *'
	with 'static struct async_signal_handler *'.
	(sighup_token, sigquit_token, sigstp_token): Likewise.
@
text
@a772 6
void
mark_async_signal_handler_wrapper (void *token)
{
  mark_async_signal_handler ((struct async_signal_handler *) token);
}

d826 1
a826 1
  mark_async_signal_handler_wrapper (sigquit_token);
d847 1
a847 1
  mark_async_signal_handler_wrapper (sighup_token);
d883 1
a883 1
  mark_async_signal_handler_wrapper (sigtstp_token);
d923 1
a923 1
  mark_async_signal_handler_wrapper (sigfpe_token);
@


1.87
log
@	* defs.h (quit_flag): Don't declare.
	(clear_quit_flag, check_quit_flag, set_quit_flag): Declare.
	(QUIT): Use new functions.
	* event-top.c (command_handler): Use clear_quit_flag.
	(handle_sigint): Use set_quit_flag.
	(async_request_quit): Use check_quit_flag.  Don't check
	immediate_quit.
	* exceptions.c (throw_exception): Use clear_quit_flag.
	* main.c (captured_main): Use clear_quit_flag.
	* python/python.c (clear_quit_flag, set_quit_flag)
	(check_quit_flag): New functions.
	* remote-sim.c (gdb_os_poll_quit): Use check_quit_flag,
	clear_quit_flag.
	* remote.c (remote_wait_as): Use check_quit_flag,
	clear_quit_flag.
	(remote_start_remote): Call QUIT.
	* symfile.c (load_progress): Use check_quit_flag.
	* top.c (command_loop): Use clear_quit_flag.
	(command_line_input): Call QUIT.
	* utils.c (quit_flag): Conditionally define.
	(clear_quit_flag, check_quit_flag, set_quit_flag): New
	functions.
	(prompt_for_continue): Call QUIT.  Use quit, not
	async_request_quit.
	* remote-mips.c (mips_expect_timeout): Call QUIT.
	* monitor.c (monitor_expect): Call QUIT.
@
text
@d126 1
a126 1
void *sigint_token;
d128 1
a128 1
void *sighup_token;
d131 1
a131 1
void *sigquit_token;
d133 1
a133 1
void *sigfpe_token;
d135 1
a135 1
void *sigtstp_token;
@


1.86
log
@	* event-top.c (sigwinch_token, handle_sigwinch): Remove.
	(async_init_signals): Update.
	* utils.c (init_page_info): Don't use SIGWINCH_HANDLER.
	(SIGWINCH_HANDLER_BODY): Remove.
gdb/doc
	* gdbint.texinfo (Host Definition): Remove documentation for
	SIGWINCH_HANDLER and SIGWINCH_HANDLER_BODY.
@
text
@d412 1
a412 1
  quit_flag = 0;
d791 1
a791 1
  quit_flag = 1;
d820 1
a820 2
     is no reason to call quit again here, unless immediate_quit is
     set.  */
d822 1
a822 1
  if (quit_flag || immediate_quit)
@


1.85
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@a60 3
#if defined(SIGWINCH) && defined(SIGWINCH_HANDLER)
static void handle_sigwinch (int sig);
#endif
a133 3
#if defined(SIGWINCH) && defined(SIGWINCH_HANDLER)
void *sigwinch_token;
#endif
a765 5
#if defined(SIGWINCH) && defined(SIGWINCH_HANDLER)
  signal (SIGWINCH, handle_sigwinch);
  sigwinch_token =
    create_async_signal_handler (SIGWINCH_HANDLER, NULL);
#endif
a941 11

/* Tell the event loop what to do if SIGWINCH is received.
   See event-signal.c.  */
#if defined(SIGWINCH) && defined(SIGWINCH_HANDLER)
static void
handle_sigwinch (int sig)
{
  mark_async_signal_handler_wrapper (sigwinch_token);
  signal (sig, handle_sigwinch);
}
#endif
@


1.84
log
@	* event-top.c (async_disconnect): If an exception is thrown from
	quit_cover, call pop_all_targets.  Use TRY_CATCH instead of
	catch_errors.
	* top.c (quit_cover): Return void and take no arguments.
	* top.h (quit_cover): Update prototype.
@
text
@d3 2
a4 2
   Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005, 2007, 2008, 2009, 2010,
   2011 Free Software Foundation, Inc.
@


1.84.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 2
   Copyright (C) 1999-2002, 2004-2005, 2007-2012 Free Software
   Foundation, Inc.
@


1.83
log
@2011-09-06  Pedro Alves  <pedro@@codesourcery.com>

	* event-top.h (MAXPROMPTS, struct prompts): Delete.
	(set_async_annotation_level, set_async_prompt, pop_prompt)
	(push_prompt, new_async_prompt): Delete declarations.
	* top.h (get_prompt, set_prompt): Change prototype.
	(get_prefix, set_prefix, get_suffix, set_suffix): Delete
	declarations.
	* top.c (command_loop):
	(top_prompt): New global.
	(get_prefix, set_prefix, get_suffix, ): Delete.
	(get_prompt, set_prompt): Rewrite.
	(show_new_async_prompt): Rename to ...
	(show_prompt): ... this.
	(init_main): Adjust.  Don't handle --annotate=2 here.
	* event-top.c (new_async_prompt): Delete.
	(the_prompts): Delete.
	(more_to_come): Make static.
	(display_gdb_prompt): Use top_level_prompt() to compute the top
	level prompt, and don't notify the before_prompt observers
	directly here.  Always trick readline into not trying to display
	the prompt if sync_execution and displaying the primary prompt.
	If displaying a local/secondary prompt, always show it, even if
	sync_execution is set.
	(change_annotation_level): Delete.
	(top_level_prompt): New, based on change_annotation_level.
	(push_prompt, pop_prompt): Delete.
	(async_disable_stdin): No longer pushes prompt.
	(command_line_handler): No longer pushes or pops prompt.  If more
	input is expected, call display_gdb_prompt with an explicit empty
	prompt.
	(async_stop_sig): Adjust.
	(set_async_annotation_level, set_async_prompt): Delete.
	* python/python.c (before_prompt_hook): Adjust.
@
text
@d873 19
a891 3
  catch_errors (quit_cover, NULL,
		"Could not kill the program being debugged",
		RETURN_MASK_ALL);
@


1.82
log
@PR gdb/10720
* event-top.c (cli_command_loop): Replace readline setup with
direct call to display_gdb_prompt.
(display_gdb_prompt): Do not call observer mechanism during
synchronous execution.

testsuite:
* lib/prompt.exp: New file for testing the first prompt.
* gdb.python/py-prompt.exp: Ditto.
* gdb.python/py-prompt.c: Ditto (copy of ext-attach.c).
@
text
@a49 1
static void change_annotation_level (void);
d51 1
a110 4
/* This variable contains the new prompt that the user sets with the
   set prompt command.  */
char *new_async_prompt;

a122 5
/* This is the prompt stack.  Prompts will be pushed on the stack as
   needed by the different 'kinds' of user inputs GDB is asking
   for.  See event-loop.h.  */
struct prompts the_prompts;

d149 1
a149 1
int more_to_come = 0;
d218 8
a225 4
/* Displays the prompt. The prompt that is displayed is the current
   top of the prompt stack, if the argument NEW_PROMPT is
   0. Otherwise, it displays whatever NEW_PROMPT is.  This is used
   after each gdb command has completed, and in the following cases:
d227 3
a229 2
   indicating that the command will continue on the next line.
   In that case the prompt that is displayed is the empty string.
d232 3
a234 2
   3. Other????
   FIXME: 2. & 3. not implemented yet for async.  */
a237 1
  int prompt_length = 0;
d239 1
d249 1
a249 42
  /* Get the prompt before the observers are called as observer hook
     functions may change the prompt.  Do not call observers on an
     explicit prompt change as passed to this function, as this forms
     a temporary prompt, IE, displayed but not set.  Do not call
     observers for a prompt change if sync_execution is set, it will
     call us again with sync_execution not set when it wants to
     display an actual prompt.  */
  if (! sync_execution && ! new_prompt)
    {
      char *post_gdb_prompt = NULL;
      char *pre_gdb_prompt = xstrdup (get_prompt (0));

      observer_notify_before_prompt (pre_gdb_prompt);
      post_gdb_prompt = get_prompt (0);

      /* If the observer changed the prompt, use that prompt.  */
      if (strcmp (pre_gdb_prompt, post_gdb_prompt) != 0)
	actual_gdb_prompt = post_gdb_prompt;

      xfree (pre_gdb_prompt);
    }

  /* In the sync_execution && !is_running case we need to display the prompt
     even though it may be "" to avoid a double prompt, while installing the
     callback handlers, in the async_editing_p case for pagination,
     So fall through.  */
  if (sync_execution && is_running (inferior_ptid))
    {
      /* This is to trick readline into not trying to display the
         prompt.  Even though we display the prompt using this
         function, readline still tries to do its own display if we
         don't call rl_callback_handler_install and
         rl_callback_handler_remove (which readline detects because a
         global variable is not set).  If readline did that, it could
         mess up gdb signal handlers for SIGINT.  Readline assumes
         that between calls to rl_set_signals and rl_clear_signals gdb
         doesn't do anything with the signal handlers.  Well, that's
         not the case, because when the target executes we change the
         SIGINT signal handler.  If we allowed readline to display the
         prompt, the signal handler change would happen exactly
         between the calls to the above two functions.
         Calling rl_callback_handler_remove(), does the job.  */
d251 4
a254 8
      rl_callback_handler_remove ();
      return;
    }

  /* If the observer changed the prompt, ACTUAL_GDB_PROMPT will not be
     NULL.  Otherwise, either copy the existing prompt, or set it to
     NEW_PROMPT.  */
  if (! actual_gdb_prompt)
d256 1
a256 1
      if (! new_prompt)
d258 18
a275 13
	  /* Just use the top of the prompt stack.  */
	  prompt_length = strlen (get_prefix (0)) +
	    strlen (get_suffix (0)) +
	    strlen (get_prompt (0)) + 1;

	  actual_gdb_prompt = (char *) alloca (prompt_length);

	  /* Prefix needs to have new line at end.  */
	  strcpy (actual_gdb_prompt, get_prefix (0));
	  strcat (actual_gdb_prompt, get_prompt (0));
	  /* Suffix needs to have a new line at end and \032 \032 at
	     beginning.  */
	  strcat (actual_gdb_prompt, get_suffix (0));
d278 4
a281 1
	actual_gdb_prompt = new_prompt;;
d283 2
d301 2
d305 34
a338 35
/* Used when the user requests a different annotation level, with
   'set annotate'.  It pushes a new prompt (with prefix and suffix) on top
   of the prompt stack, if the annotation level desired is 2, otherwise
   it pops the top of the prompt stack when we want the annotation level
   to be the normal ones (1 or 0).  */
static void
change_annotation_level (void)
{
  char *prefix, *suffix;

  if (!get_prefix (0) || !get_prompt (0) || !get_suffix (0))
    {
      /* The prompt stack has not been initialized to "", we are
         using gdb w/o the --async switch.  */
      warning (_("Command has same effect as set annotate"));
      return;
    }

  if (annotation_level > 1)
    {
      if (!strcmp (get_prefix (0), "") && !strcmp (get_suffix (0), ""))
	{
	  /* Push a new prompt if the previous annotation_level was not >1.  */
	  prefix = (char *) alloca (strlen (async_annotation_suffix) + 10);
	  strcpy (prefix, "\n\032\032pre-");
	  strcat (prefix, async_annotation_suffix);
	  strcat (prefix, "\n");

	  suffix = (char *) alloca (strlen (async_annotation_suffix) + 6);
	  strcpy (suffix, "\n\032\032");
	  strcat (suffix, async_annotation_suffix);
	  strcat (suffix, "\n");

	  push_prompt (prefix, (char *) 0, suffix);
	}
d342 2
a343 5
      if (strcmp (get_prefix (0), "") && strcmp (get_suffix (0), ""))
	{
	  /* Pop the top of the stack, we are going back to annotation < 1.  */
	  pop_prompt ();
	}
a344 1
}
d346 2
a347 9
/* Pushes a new prompt on the prompt stack.  Each prompt has three
   parts: prefix, prompt, suffix.  Usually prefix and suffix are empty
   strings, except when the annotation level is 2.  Memory is allocated
   within xstrdup for the new prompt.  */
void
push_prompt (char *prefix, char *prompt, char *suffix)
{
  the_prompts.top++;
  set_prefix (prefix, 0);
d349 3
a351 7
  /* Note that this function is used by the set annotate 2
     command.  This is why we take care of saving the old prompt
     in case a new one is not specified.  */
  if (prompt)
    set_prompt (prompt, 0);
  else
    set_prompt (get_prompt (-1), 0);
d353 1
a353 2
  set_suffix (suffix, 0);
}
d355 1
a355 19
/* Pops the top of the prompt stack, and frees the memory allocated
   for it.  */
void
pop_prompt (void)
{
  /* If we are not during a 'synchronous' execution command, in which
     case, the top prompt would be empty.  */
  if (strcmp (get_prompt (0), ""))
    /* This is for the case in which the prompt is set while the
       annotation level is 2.  The top prompt will be changed, but when
       we return to annotation level < 2, we want that new prompt to be
       in effect, until the user does another 'set prompt'.  */
    if (strcmp (get_prompt (0), get_prompt (-1)))
      set_prompt (get_prompt (0), -1);

  set_prefix (NULL, 0);
  set_prompt (NULL, 0);
  set_suffix (NULL, 0);
  the_prompts.top--;
a391 1
      pop_prompt ();
d402 1
a402 5
  if (!sync_execution)
    {
      sync_execution = 1;
      push_prompt ("", "", "");
    }
a484 1
      pop_prompt ();
d537 1
a537 2
      push_prompt ("", "", "");
      display_gdb_prompt (0);
d892 1
a892 1
  char *prompt = get_prompt (0);
a957 15
/* Called by do_setshow_command.  */
void
set_async_annotation_level (char *args, int from_tty,
			    struct cmd_list_element *c)
{
  change_annotation_level ();
}

/* Called by do_setshow_command.  */
void
set_async_prompt (char *args, int from_tty, struct cmd_list_element *c)
{
  set_prompt (new_async_prompt, 0);
}

@


1.81
log
@2011-07-22  Phil Muldoon  <pmuldoon@@redhat.com>

	* event-top.c (cli_command_loop): Use get_prompt, get_suffix,
	get_prefix.
	(display_gdb_prompt): Likewise.
	(change_annotation_level): Likewise.
	(push_prompt): Likewise.
	(pop_prompt): Likewise.
	(handle_stop_sig): Use get_prompt with a level.
	* top.c (command_loop): Use get_prompt with a level.
	(set_async_annotation_level): Use set_prompt with a level.
	(get_prefix): New function.
	(set_prefix): Ditto.
	(set_suffix): Ditto.
	(get_suffix): Ditto.
	(get_prompt): Accept a level argument.
	(set_prompt): Accept a level argument.  Free old prompts.  Set
	new_async_prompt if level is 0.
	(init_main): Use set_prompt with a level.  Do not set
	new_async_prompt.
	* event-top.h (PROMPT, SUFFIX, PREFIX): Move to top.c
	* top.h: Declare set_suffix, get_suffix, set_prefix, get_prefix.
	Modify set_prompt, get_prompt to account for levels.
	* tui/tui-interp.c (tui_command_loop): Use get_prompt with a
	level
	* python/python.c (before_prompt_hook): Use set_prompt.
@
text
@d188 1
a188 21
  /* If we are using readline, set things up and display the first
     prompt, otherwise just print the prompt.  */
  if (async_command_editing_p)
    {
      int length;
      char *a_prompt;
      char *gdb_prompt = get_prompt (0);

      /* Tell readline what the prompt to display is and what function
         it will need to call after a whole line is read.  This also
         displays the first prompt.  */
      length = strlen (get_prefix (0))
	+ strlen (gdb_prompt) + strlen (get_suffix(0)) + 1;
      a_prompt = (char *) alloca (length);
      strcpy (a_prompt, get_prefix (0));
      strcat (a_prompt, gdb_prompt);
      strcat (a_prompt, get_suffix (0));
      rl_callback_handler_install (a_prompt, input_handler);
    }
  else
    display_gdb_prompt (0);
d255 5
a259 2
     a temporary prompt, IE, displayed but not set.  */
  if (! new_prompt)
d274 4
@


1.80
log
@2011-07-21  Phil Muldoon  <pmuldoon@@redhat.com>
            Tom Tromey  <tromey@@redhat.com>

	* top.c (set_prompt): Rewrite to free previous prompt, free
	asynch_new_prompt and set both on new prompts.
	* event-top.c (display_gdb_prompt): Add prompt substitution
	logic.
	* python/python.c (before_prompt_hook): New function.

2011-07-21  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.python/python.exp: Add prompt substitution tests.

2011-07-21  Phil Muldoon  <pmuldoon@@redhat.com>

	* observer.texi (GDB Observers): Add before_prompt observer.
	* gdb.texinfo (Basic Python): Add documentation for prompt
	substitution.
@
text
@d194 1
a194 1
      char *gdb_prompt = get_prompt ();
d199 2
a200 2
      length = strlen (PREFIX (0)) 
	+ strlen (gdb_prompt) + strlen (SUFFIX (0)) + 1;
d202 1
a202 1
      strcpy (a_prompt, PREFIX (0));
d204 1
a204 1
      strcat (a_prompt, SUFFIX (0));
d279 1
a279 1
      char *pre_gdb_prompt = xstrdup (get_prompt ());
d282 1
a282 1
      post_gdb_prompt = get_prompt ();
d320 3
a322 3
	  prompt_length = strlen (PREFIX (0)) +
	    strlen (SUFFIX (0)) +
	    strlen (get_prompt()) + 1;
d327 2
a328 2
	  strcpy (actual_gdb_prompt, PREFIX (0));
	  strcat (actual_gdb_prompt, get_prompt());
d331 1
a331 1
	  strcat (actual_gdb_prompt, SUFFIX (0));
d364 1
a364 1
  if (!PREFIX (0) || !PROMPT (0) || !SUFFIX (0))
d374 1
a374 1
      if (!strcmp (PREFIX (0), "") && !strcmp (SUFFIX (0), ""))
d392 1
a392 1
      if (strcmp (PREFIX (0), "") && strcmp (SUFFIX (0), ""))
d408 1
a408 1
  PREFIX (0) = xstrdup (prefix);
d414 1
a414 1
    PROMPT (0) = xstrdup (prompt);
d416 1
a416 1
    PROMPT (0) = xstrdup (PROMPT (-1));
d418 1
a418 1
  SUFFIX (0) = xstrdup (suffix);
d428 1
a428 1
  if (strcmp (PROMPT (0), ""))
d433 6
a438 9
    if (strcmp (PROMPT (0), PROMPT (-1)))
      {
	xfree (PROMPT (-1));
	PROMPT (-1) = xstrdup (PROMPT (0));
      }

  xfree (PREFIX (0));
  xfree (PROMPT (0));
  xfree (SUFFIX (0));
d983 1
a983 1
  char *prompt = get_prompt ();
d1061 1
a1061 1
  PROMPT (0) = xstrdup (new_async_prompt);
@


1.79
log
@2011-06-13  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* top.h (line): Rename to ...
	(saved_command_line): ... this.
	(linesize): Rename to ...
	(saved_command_line_size): ... this.
	* top.c (line): Rename to ...
	(saved_command_line): ... this.
	(linesize): Rename to ...
	(saved_command_line_size): ... this.
	(dont_repeat, command_line_input, dont_repeat_command): Adjust.
	* event-top.c (command_line_handler): Adjust.
	* main.c (captured_main): Adjust.
@
text
@d36 1
d262 1
a262 1
  char *gdb_prompt = get_prompt ();
d272 19
d312 4
a315 1
  if (!new_prompt)
d317 18
a334 13
      /* Just use the top of the prompt stack.  */
      prompt_length = strlen (PREFIX (0)) +
	strlen (SUFFIX (0)) +
	strlen (gdb_prompt) + 1;

      new_prompt = (char *) alloca (prompt_length);

      /* Prefix needs to have new line at end.  */
      strcpy (new_prompt, PREFIX (0));
      strcat (new_prompt, gdb_prompt);
      /* Suffix needs to have a new line at end and \032 \032 at
         beginning.  */
      strcat (new_prompt, SUFFIX (0));
d340 1
a340 1
      rl_callback_handler_install (new_prompt, input_handler);
d349 1
a349 1
      fputs_unfiltered (new_prompt, gdb_stdout);
@


1.78
log
@2011-05-27  Pedro Alves  <pedro@@codesourcery.com>

	* defs.h (struct continuation, continuation_ftype)
	(continuation_free_arg_ftype, add_continuation)
	(do_all_continuations, do_all_continuations_thread)
	(discard_all_continuations, discard_all_continuations_thread)
	(add_intermediate_continuation, do_all_intermediate_continuations)
	(do_all_intermediate_continuations_thread)
	(discard_all_intermediate_continuations)
	(discard_all_intermediate_continuations_thread)
	(add_inferior_continuation, do_all_inferior_continuations)
	(discard_all_inferior_continuations): Move to ...
	* continuations.h: ... this new file.
	* breakpoint.c, continuations.c, event-top.c, inf-loop.c,
	infcmd.c, inferior.c, infrun.c, interps.c: Include
	continuations.h.
@
text
@a522 2
  extern char *line;
  extern int linesize;
d662 1
a662 1
      command_handler (line);
d670 1
a670 1
      command_handler (line);
d694 1
a694 1
      if (linelength > linesize)
d696 2
a697 2
	  line = xrealloc (line, linelength);
	  linesize = linelength;
d699 1
a699 1
      strcpy (line, linebuffer);
d702 1
a702 1
	  command_handler (line);
@


1.77
log
@	* tracepoint.c (stop_tracing): Don't declare.
	* event-top.c (after_char_processing_hook): Add `(void)'.
@
text
@d36 1
a36 1

@


1.76
log
@2011-03-01  Michael Snyder  <msnyder@@vmware.com>

	* event-top.c (display_gdb_prompt): Remove superfluous null check.
@
text
@d168 1
a168 1
void (*after_char_processing_hook) ();
@


1.75
log
@run copyright.sh for 2011.
@
text
@d315 2
a316 2
     passed in.  */
  else if (new_prompt)
@


1.74
log
@2010-12-28  Michael Snyder  <msnyder@@vmware.com>

	* event-loop.c: Comment clean-up.
	* event-loop.h: Ditto.
	* event-top.c: Ditto.
	* gdb.c: Ditto.
	* gdb.h: Ditto.
	* main.c: Ditto.
	* top.c: Ditto.
	* top.h: Ditto.
@
text
@d3 2
a4 2
   Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
@


1.73
log
@gdb/
	Redirect also uiout and stdtarg{,err} in execute_command_to_string.
	* cli-logging.c (struct saved_output_files) <targerr>: New.
	(set_logging_redirect, pop_output_files, handle_redirections):
	Redirect also gdb_stdtargerr.
	* defs.h (struct ui_out, make_cleanup_ui_out_redirect_pop): New
	declarations.
	* event-top.c (gdb_setup_readline, gdb_disable_readline): Redirect
	also gdb_stdtargerr.
	* top.c (execute_command_to_string): Move make_cleanup_ui_file_delete
	to the top.  Redirect also gdb_stdlog, gdb_stdtarg and gdb_stdtargerr.
	Use ui_out_redirect, register make_cleanup_ui_out_redirect_pop.
	* tui/tui-io.c (tui_setup_io): Redirect also gdb_stdtargerr.
	* utils.c (do_ui_out_redirect_pop, make_cleanup_ui_out_redirect_pop):
	New functions.

gdb/testsuite/
	* gdb.python/python.exp (set height 0, collect help from uiout)
	(verify help to uiout): New tests.
@
text
@d21 1
a21 1
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */
d37 1
a37 2
/* For dont_repeat() */
#include "gdbcmd.h"
d39 1
a39 1
/* readline include files */
d52 1
a52 1
/* Signal handlers. */
d65 1
a65 1
   signals. */
d78 1
a78 1
   functions. These are all included in the file callback.c in the
d83 1
a83 1
   there is a new character ready on the input stream. This function
d89 1
a89 1
   of the old command_line_input in gdb. Instead of invoking (and waiting
d95 1
a95 1
   that readline offers as callback to the event_loop. */
d100 1
a100 1
/* Important variables for the event loop. */
d103 1
a103 1
   its own simplified form of readline. It is used by the asynchronous
d107 1
a107 1
   loop as default engine, and event-top.c is merged into top.c. */
d111 1
a111 1
   set prompt command. */
d115 1
a115 1
   annotation_level is 2. */
d119 1
a119 1
   asynchronous execution command. */
d123 1
a123 1
   read commands from. */
d126 1
a126 1
/* This is the prompt stack. Prompts will be pushed on the stack as
d128 1
a128 1
   for. See event-loop.h. */
d131 1
a131 1
/* signal handling variables */
d133 1
a133 1
   invoke if the corresponding signal has received. The real signal
d135 2
a136 2
   loop, in a later iteration, calls them. See the function
   invoke_async_signal_handler. */
d153 1
a153 1
   the user types '\' at the end of a command line. This is necessary
d156 1
a156 1
   between different calls. */
d171 3
a173 3
/* Wrapper function for calling into the readline library. The event
   loop expects the callback function to have a paramter, while readline 
   expects none. */
d183 1
a183 1
   register readline, and stdin, start the loop. */
d188 1
a188 1
     prompt, otherwise just print the prompt. */
d195 3
a197 3
      /* Tell readline what the prompt to display is and what function it
         will need to call after a whole line is read. This also displays
         the first prompt. */
d209 1
a209 1
  /* Now it's time to start the event loop. */
d214 1
a214 1
   ready on stdin. This is used when the user sets the editing off,
d216 1
a216 1
   itself, via gdb_readline2. Also it is used in the opposite case in
d218 1
a218 1
   handling of the input. */
d222 2
a223 2
  /* NOTE: this operates on input_fd, not instream. If we are reading
     commands from a file, instream will point to the file. However in
d225 2
a226 2
     off. This means that the 'set editing on/off' will have effect
     only on the interactive session. */
d230 1
a230 1
      /* Turn on editing by using readline. */
d236 1
a236 1
      /* Turn off editing by using gdb_readline2. */
d241 1
a241 1
         first thing from .gdbinit. */
d248 1
a248 1
   0. Otherwise, it displays whatever NEW_PROMPT is. This is used
d250 1
a250 1
   1. when the user enters a command line which is ended by '\'
d254 1
a254 1
   actions for a tracepoint. In this case the prompt will be '>'
d256 1
a256 1
   FIXME: 2. & 3. not implemented yet for async. */
d278 1
a278 1
         global variable is not set). If readline did that, it could
d281 1
a281 1
         doesn't do anything with the signal handlers. Well, that's
d283 1
a283 1
         SIGINT signal handler. If we allowed readline to display the
d286 1
a286 1
         Calling rl_callback_handler_remove(), does the job. */
d294 1
a294 1
      /* Just use the top of the prompt stack. */
d301 1
a301 1
      /* Prefix needs to have new line at end. */
d305 1
a305 1
         beginning. */
d314 2
a315 1
  /* new_prompt at this point can be the top of the stack or the one passed in */
d327 1
a327 1
   'set annotate'. It pushes a new prompt (with prefix and suffix) on top
d330 1
a330 1
   to be the normal ones (1 or 0). */
d339 1
a339 1
         using gdb w/o the --async switch */
d348 1
a348 1
	  /* Push a new prompt if the previous annotation_level was not >1. */
d366 1
a366 1
	  /* Pop the top of the stack, we are going back to annotation < 1. */
d372 4
a375 4
/* Pushes a new prompt on the prompt stack. Each prompt has three
   parts: prefix, prompt, suffix. Usually prefix and suffix are empty
   strings, except when the annotation level is 2. Memory is allocated
   within xstrdup for the new prompt. */
d383 2
a384 2
     command. This is why we take care of saving the old prompt
     in case a new one is not specified. */
d393 2
a394 1
/* Pops the top of the prompt stack, and frees the memory allocated for it. */
d399 1
a399 1
     case, the top prompt would be empty. */
d402 1
a402 1
       annotation level is 2. The top prompt will be changed, but when
d404 1
a404 1
       in effect, until the user does another 'set prompt'. */
d420 1
a420 1
   errors and do something. */
d430 1
a430 1
      /* If stdin died, we may as well kill gdb. */
d439 1
a439 1
   the exec operation. */
d446 1
a446 1
      /* See NOTE in async_disable_stdin() */
d449 1
a449 1
	 check for sync_execution before switching the terminal. */
d457 1
a457 1
   synchronous. */
d470 1
a470 1
/* Handles a gdb command. This function is called by
d472 1
a472 1
   into COMMAND. */
d475 1
a475 1
   switch to use the event loop at every execution of gdb. */
d486 5
a490 5
  /* If readline returned a NULL command, it means that the 
     connection with the terminal is gone. This happens at the
     end of a testsuite run, after Expect has hung up 
     but GDB is still alive. In such a case, we just quit gdb
     killing the inferior program too. */
d507 4
a510 3
/* Handle a complete line of input. This is called by the callback
   mechanism within the readline library.  Deal with incomplete commands
   as well, by saving the partial input in a global buffer.  */
d513 1
a513 1
   command_line_input function. command_line_input will become
d515 1
a515 1
   GDB. */
d560 2
a561 1
     you get away with leaving out some of the gdb_flush, but not all.  */
d570 1
a570 1
     and exit from gdb. */
d575 1
a575 1
      return;			/* Lint. */
d586 1
a586 1
     if this was just a newline)  */
d601 2
a602 2
	 input expected to complete the command. So, we need to
	 print an empty prompt here. */
d660 2
a661 3
  /* If we just got an empty line, and that is supposed
     to repeat the previous command, return the value in the
     global buffer.  */
d691 1
a691 1
    *p1 = '\0';			/* Found a comment. */
d716 1
a716 1
   provided by the readline library. */
d718 1
a718 1
/* NOTE: 1999-04-30 Asynchronous version of gdb_readline. gdb_readline
d720 1
a720 1
   execution for gdb. */
d731 1
a731 1
     fetch only one char at the time from the stream. The fgetc's will
d733 1
a733 1
     stream after '\n'. If we buffer the input and fgetc drains the
d735 1
a735 1
     afterwards will not trigger. */
d747 3
a749 3
     which sends the characters all at once. Poll will notice that the
     input fd has changed state only after enter is pressed. At this
     point we still need to fetch all the chars entered. */
d760 3
a762 3
	    /* The last line does not end with a newline.  Return it, and
	       if we are called again fgetc will still return EOF and
	       we'll return NULL then.  */
d790 1
a790 1
   handle_sig* for each of the signals GDB cares about. Specifically:
d795 1
a795 1
   procedures are the old signal handlers. The event loop will take
d797 1
a797 1
   associated with the reception of the signal. */
d800 1
a800 1
   as the default for gdb. */
d858 2
a859 2
/* Tell the event loop what to do if SIGINT is received. 
   See event-signal.c. */
d867 1
a867 1
     set quit_flag to 1 here. Then if QUIT is called before we get to
d873 1
a873 1
     away, even if we usually would defer this to the event loop. The
d875 1
a875 1
     immediate_quit is set. If we didn't, SIGINT would be really
d879 1
a879 1
     we process SIGINT the next time through the loop, which is fine. */
d892 1
a892 1
/* Do the quit. All the checks have been done by the caller. */
d900 1
a900 1
     set.*/
d907 2
a908 2
/* Tell the event loop what to do if SIGQUIT is received. 
   See event-signal.c. */
d923 1
a923 1
  /* Empty function body. */
d928 2
a929 2
/* Tell the event loop what to do if SIGHUP is received. 
   See event-signal.c. */
d937 1
a937 1
/* Called by the event loop to process a SIGHUP */
d944 1
a944 1
  signal (SIGHUP, SIG_DFL);	/*FIXME: ??????????? */
d982 2
a983 1
  /* Forget about any previous command -- null line now will do nothing.  */
d988 2
a989 2
/* Tell the event loop what to do if SIGFPE is received. 
   See event-signal.c. */
d997 1
a997 1
/* Event loop will call this functin to process a SIGFPE. */
d1001 2
a1002 2
  /* This message is based on ANSI C, section 4.7. Note that integer
     divide by zero causes this, so "float" is a misnomer. */
d1006 2
a1007 2
/* Tell the event loop what to do if SIGWINCH is received. 
   See event-signal.c. */
d1020 2
a1021 1
set_async_editing_command (char *args, int from_tty, struct cmd_list_element *c)
d1028 2
a1029 1
set_async_annotation_level (char *args, int from_tty, struct cmd_list_element *c)
d1043 1
a1043 1
   and hook up instream to the event loop. */
d1062 1
a1062 1
      /* Tell gdb that we will be using the readline library. This
d1078 1
a1078 1
     complete line to gdb for processing. command_line_handler is the
d1082 1
a1082 1
  /* Tell readline to use the same input stream that gdb uses. */
d1092 1
a1092 1
     register with the even loop. Another source is going to be the
@


1.72
log
@Refactor 'maint time' command statistics.

Consolidate code for displaying per-command time and space statistics to avoid
duplication.  Piggyback on cleanups so that statistics get printed even when
commands terminate as a result of an error.

Changelog

    * gdb/defs.h (make_command_stats_cleanup): Declare.
    (set_display_time): Declare.
    (set_display_space): Declare.
    * gdb/event-top.c (command_handler): Use make_command_stats_cleanup.
    * gdb/main.c (display_time, display_space): Move definitions to utils.c.
    (captured_main): Use make_command_stats_cleanup to get start-up
    statistics.
    Use set_display_time and set_display_space for processing OPT_STATISTICS
    case.
    * gdb/maint.c (maintenance_time_display): Use set_display_time.
    (maintenance_space_display): Use set_display_space.
    * gdb/top.c (execute_command): Remove obsolete 'maint time' code.
    (command_loop): Use make_command_stats_cleanup.
    * gdb/utils.c (struct cmd_stats): Structure for storing initial time
    and space usage.
    (display_time, display_space): Move definitions here from utils.c.
    (set_display_time): New function.
    (set_display_space): New function.
    (make_command_stats_cleanup): New function.
    (report_command_stats): New auxiliary function for
    make_command_stats_cleanup.
    * gdb/testsuite/gdb.gdb/selftest.exp: Adjust expected message for
    capturing start-up runtime.
@
text
@d1051 1
d1110 1
@


1.71
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* elfread.c: White space.
	* environ.c: White space.
	* eval.c: White space.
	* event-loop.c: White space.
	* event-top.c: White space.
	* exceptions.c: White space.
	* exec.c: White space.
	* expprint.c: White space.
@
text
@d479 1
a479 6
  long time_at_cmd_start;
#ifdef HAVE_SBRK
  long space_at_cmd_start = 0;
#endif
  extern int display_time;
  extern int display_space;
d496 1
a496 10
  time_at_cmd_start = get_run_time ();

  if (display_space)
    {
#ifdef HAVE_SBRK
      char *lim = (char *) sbrk (0);

      space_at_cmd_start = lim - lim_at_start;
#endif
    }
d503 1
a503 21
  if (display_time)
    {
      long cmd_time = get_run_time () - time_at_cmd_start;

      printf_unfiltered (_("Command execution time: %ld.%06ld\n"),
			 cmd_time / 1000000, cmd_time % 1000000);
    }

  if (display_space)
    {
#ifdef HAVE_SBRK
      char *lim = (char *) sbrk (0);
      long space_now = lim - lim_at_start;
      long space_diff = space_now - space_at_cmd_start;

      printf_unfiltered (_("Space used: %ld (%c%ld for this command)\n"),
			 space_now,
			 (space_diff >= 0 ? '+' : '-'),
			 space_diff);
#endif
    }
@


1.70
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d507 1
a559 1

d993 1
@


1.69
log
@2009-09-23  John Wright  <john.wright@@hp.com>

	PR gdb/10684:
	* event-top.c (command_line_handler): Terminate linebuffer before
	xstrdup.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005, 2007, 2008, 2009
@


1.68
log
@gdb/
	Replace the savestring calls by xstrdup calls where possible.
	* breakpoint.c (condition_command, set_raw_breakpoint)
	(create_catchpoint, update_breakpoint_locations): Replace the
	savestring calls by xstrdup calls where possible.
	* buildsym.c (start_subfile, patch_subfile_names, record_debugformat)
	(record_producer): Likewise.
	* coffread.c (coff_start_symtab, complete_symtab): Likewise.
	* corefile.c (set_gnutarget): Likewise.
	* dbxread.c (add_new_header_file): Likewise.
	* demangle.c (set_demangling_command, set_demangling_style): Likewise.
	* event-top.c (push_prompt, pop_prompt, command_line_handler)
	(set_async_prompt): Likewise.
	* infcmd.c (set_inferior_io_terminal, attach_command_post_wait):
	Likewise.
	* language.c (set_language_command, _initialize_language): Likewise.
	* linespec.c (decode_line_2): Likewise.
	* rs6000-nat.c (add_vmap): Likewise.
	* top.c (set_prompt, init_history, init_main): Likewise.
	* tracepoint.c (stringify_collection_list): Likewise.
	* varobj.c (varobj_create): Remove variable expr_len.  Replace the
	savestring calls by xstrdup calls where possible.
	(value_of_root, c_name_of_variable, c_describe_child): Replace the
	savestring calls by xstrdup calls where possible.
	* xcoffread.c (complete_symtab): Likewise.
	* cli/cli-script.c (build_command_line, define_command): Likewise.
	* cli/cli-setshow.c (do_setshow_command): Likewise.
@
text
@d625 1
@


1.68.4.1
log
@2009-09-23  John Wright  <john.wright@@hp.com>

	PR gdb/10684:
	* event-top.c (command_line_handler): Terminate linebuffer before
	xstrdup.
@
text
@a624 1
      *p = '\0';
@


1.67
log
@	* linux-nat.c (linux_nat_terminal_inferior)
	(linux_nat_terminal_ours): Don't check sync_execution.
	* remote.c (remote_terminal_inferior, remote_terminal_ours):
	Don't check sync_execution.  Update comments.
	* target.c (target_terminal_inferior): New.
	* target.h (target_terminal_inferior): Delete macro, and declare
	as function.
	* event-top.c (async_disable_stdin): Make idempotent.  Don't give
	the target the terminal here.
	* inflow.c (terminal_ours_1): Don't return early without setting
	`terminal_is_ours'.
@
text
@d375 1
a375 1
   within savestring for the new prompt. */
d380 1
a380 1
  PREFIX (0) = savestring (prefix, strlen (prefix));
d386 1
a386 1
    PROMPT (0) = savestring (prompt, strlen (prompt));
d388 1
a388 1
    PROMPT (0) = savestring (PROMPT (-1), strlen (PROMPT (-1)));
d390 1
a390 1
  SUFFIX (0) = savestring (suffix, strlen (suffix));
d407 1
a407 1
	PROMPT (-1) = savestring (PROMPT (0), strlen (PROMPT (0)));
d627 1
a627 2
      readline_input_state.linebuffer = savestring (linebuffer,
						    strlen (linebuffer));
d1065 1
a1065 1
  PROMPT (0) = savestring (new_async_prompt, strlen (new_async_prompt));
@


1.66
log
@        * event-top.c (async_disconnect, async_stop_sig): use "raise"
        instead of "kill" to raise a signal.
@
text
@d461 5
a465 8
  sync_execution = 1;
  push_prompt ("", "", "");
  /* FIXME: cagney/1999-09-27: At present this call is technically
     redundant since infcmd.c and infrun.c both already call
     target_terminal_inferior().  As the terminal handling (in
     sync/async mode) is refined, the duplicate calls can be
     eliminated (Here or in infcmd.c/infrun.c). */
  target_terminal_inferior ();
@


1.65
log
@        Updated copyright notices for most files.
@
text
@d980 1
a980 1
  kill (getpid (), SIGHUP);
d1008 1
a1008 1
  kill (getpid (), SIGTSTP);
@


1.64
log
@	* inferior.h (stop_bpstat): Delete.

	* breakpoint.h (bpstat_do_actions): Remove bpstat* argument.

	* breakpoint.c (bpstat_do_actions): Rename to ...
	(bpstat_do_actions_1): ... this.  Make static.  Change return type
	to int.  Return true if a breakpoint proceeded.
	(bpstat_do_actions): New, as wrapper around bpstat_do_actions_1.
	(delete_breakpoint): Don't reference the global stop_bpstat; it's
	gone.

	* gdbthread.h (struct thread_info): Add stop_bpstat.
	(save_infrun_state, load_infrun_state): Remove stop_bpstat
	argument.
	* thread.c (load_infrun_state, save_infrun_state): Remove
	stop_bpstat argument, and the code referencing it.

	* infcall.c: Include "gdbthread.h".
	(call_function_by_hand): Adjust.
	* exceptions.c: Include "gdbthread.h".
	(throw_exception): Adjust.
	* infcmd.c (stop_bpstat): Delete.
	(continue_command): In all-stop, set the ignore count on the
	thread that reported the stop.  In non-stop, set it on the current
	thread.
	(finish_command_continuation): Adjust.
	(program_info): Adjust.
	* infrun.c (clear_proceed_status): Adjust.
	(context_switch): Don't context-switch stop_bpstat.
	(handle_inferior_event): Adjust.
	(normal_stop): Adjust.
	(save_inferior_status, restore_inferior_status): Adjust.

	* inf-loop.c (inferior_event_handler): Remove parameter to
	bpstat_do_actions call.
	* top.c (command_loop): Remove parameter to bpstat_do_actions
	call.  Call it unconditionally.
	* event-top.c (command_handler): Ditto.
	* python/python.c (execute_gdb_command): Ditto.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005, 2007, 2008
@


1.63
log
@	* gdbthread.h: Add comments.
	* stack.c (get_selected_block): Return 0 on an exited thread.
	* top.c (execute_command): Check for is_stopped, not !is_running.
	* event-top.c (command_handler): Likewise.
@
text
@a480 1
  struct cleanup *old_chain;
a491 1
  old_chain = make_cleanup (null_cleanup, 0);
d516 4
a519 4
  /* Do any commands attached to breakpoint we stopped at. Only if we
     are always running synchronously. Or if we have just executed a
     command that doesn't start the target. */
  if (!target_can_async_p () || is_stopped (inferior_ptid))
d521 1
a521 2
      bpstat_do_actions (&stop_bpstat);
      do_cleanups (old_chain);
d523 3
a525 3
      if (display_time)
	{
	  long cmd_time = get_run_time () - time_at_cmd_start;
d527 6
a532 3
	  printf_unfiltered (_("Command execution time: %ld.%06ld\n"),
			     cmd_time / 1000000, cmd_time % 1000000);
	}
d534 4
a537 11
      if (display_space)
	{
#ifdef HAVE_SBRK
	  char *lim = (char *) sbrk (0);
	  long space_now = lim - lim_at_start;
	  long space_diff = space_now - space_at_cmd_start;

	  printf_unfiltered (_("Space used: %ld (%c%ld for this command)\n"),
			     space_now,
			     (space_diff >= 0 ? '+' : '-'),
			     space_diff);
a538 1
	}
@


1.62
log
@2008-07-12  Pedro Alves  <pedro@@codesourcery.com>

	Rewrite continuations internals on top of cleanups and plug
	continuation arguments leaks.

	* defs.h (struct continuation): Make it opaque.
	(add_continuation, add_intermediate_continuation): Drop the int
	argument of the continuation hook argument.  Add
	continuation_free_args argument.
	(do_all_continuations, do_all_intermediate_continuations): Drop
	the error_p argument.

	* utils.c (add_continuation): Drop the int argument of the
	continuation hook argument.  Add continuation_free_args argument.
	Reimplement on top of cleanups.
	(do_all_continuations): Drop error argument.  Reimplement on top
	of cleanups.
	(discard_all_continuations): Reimplement on top of cleanups.
	(add_intermediate_continuation): Drop the int argument of the
	continuation hook argument.  Add continuation_free_args argument.
	Reimplement on top of cleanups.
	(do_all_intermediate_continuations): Drop error argument.
	Reimplement on top of cleanups.
	(discard_all_intermediate_continuations): Reimplement on top of
	cleanups.

	* breakpoint.c (until_break_command_continuation): Drop error
	argument.  Add xfree as continuation argument deleter.

	* inf-loop.c (inferior_event_handler): On error, discard all
	continuations.  Adjust to new do_all_intermediate_continuations
	and do_all_continuations interfaces.

	* infcmd.c (step_1_continuation): Drop error_p argument.  Adjust.
	Pass xfree as continuation argument deleter.
	(finish_command_continuation): Drop error_p argument.  Adjust.
	(finish_command_continuation_free_arg): New.
	(finish_command): Pass finish_command_continuation_free_arg as
	continuation argument deleter.  Adjust to new do_all_continuations
	interfaces.
	(attach_command_continuation): Drop error_p argument.
	(attach_command_continuation_free_args): New.
	(attach_command): Pass attach_command_continuation_free_args as
	continuation argument deleter.

	* interps.c (interp_set): Adjust to new do_all_continuations
	interfaces.

	* event-top.c (stdin_event_handler): In error, also discard the
	intermediate continuations.
@
text
@d521 1
a521 1
  if (!target_can_async_p () || !is_running (inferior_ptid))
@


1.61
log
@	Add "executing" property to threads.

	* inferior.h (target_executing): Delete.
	* gdbthread.h (struct thread_info): Add executing_ field.
	(set_executing, is_executing): New.
	* thread.c (main_thread_executing): New.
	(init_thread_list): Clear it and also main_thread_running.
	(is_running): Return false if target has no execution.
	(any_running, is_executing, set_executing): New.

	* top.c: Include "gdbthread.h".
	(target_executing): Delete.
	(execute_command): Replace target_executing check by any_running.
	* event-top.c: Include "gdbthread.h".
	(display_gdb_prompt, command_handler): Replace target_executing by
	is_running.
	* inf-loop.c: Include "gdbthread.h".  Don't mark as not executing
	here.  Replace target_executing by is_running.
	* infrun.c (handle_inferior_event): Mark all threads as
	not-executing.
	* linux-nat.c (linux_nat_resume): Don't mark thread as executing
	here.
	* stack.c (get_selected_block): Return null if inferior is
	executing.
	* target.c (target_resume): Mark resumed ptid as executing.
	* breakpoint.c (until_break_command): Replace target_executing
	check by is_executing.
	* remote.c (remote_async_resume): Don't mark inferior as executing
	here.
	* mi/mi-interp.c (mi_cmd_interpreter_exec): Replace target_executing
	by any_running.

	* mi/mi-main.c (mi_cmd_exec_interrupt, mi_cmd_execute)
	(mi_execute_async_cli_command): Replace target_executing by
	is_running.

	* frame.c (get_current_frame): Error out if the current thread is
	executing.
	(has_stack_frames): New.
	(get_selected_frame, deprecated_safe_get_selected_frame): Check
	has_stack_frames.

	* Makefile.in (event-top.o, frame.o, inf-loop.o, top.o): Depend on
	$(gdbthread_h).
@
text
@d428 1
@


1.60
log
@2008-05-02  Andrew Stubbs  <andrew.stubbs@@st.com>

	* main.h (batch_silent): Declare.
	* event-top.c: Include main.h.
	(gdb_setup_readline): Remove extern batch_silent declaration.
	* infrun.c (normal_stop): Don't print source location when running in
	--batch-silent mode.
	* Makefile.in (event-top.o): Add main.h dependency.
@
text
@d35 1
d272 1
a272 1
  if (target_executing && sync_execution)
d520 1
a520 1
  if (!target_can_async_p () || !target_executing)
@


1.59
log
@	* defs.h (do_exec_error_cleanups, discard_exec_error_cleanups)
	(make_exec_error_cleanup): Remove declarations.
	* utils.c (exec_error_cleanup_chain): Remove.
	(do_exec_error_cleanups, discard_exec_error_cleanups)
	(make_exec_error_cleanup): Remove.
	* event-loop.c (start_event_loop): Adjust call to
	async_enable_stdin.
	* event-top.c (async_enable_stdin): Remove the paramater dummy.
	(async_disable_stdin): Don't register async_enable_stdin via
	cleanup.
	* inf-loop.c (inferior_event_handler): Don't
	call do_exec_error_cleanups.  Call async_enable_stdin instead.
	* event-loop.c (start_event_loop): Adjust call to
	async_enable_stdin.
	* tui/tui-interp.c (tui_command_loop): Adjust call to
	async_enable_stdin.
@
text
@d34 1
a1087 2
  extern int batch_silent;

@


1.58
log
@	Async mode fixes.
        * Makefile.in (infcmd.o, inf-loop.o): Update dependencies.
        * breakpoint.c (bpstat_do_actions): In async mode,
        don't jump to top expecting stop_bpstat to be already
        updated.
        * event-loop.c (start_event_loop): Call async_enable_stdin
        on exception.
        * event-top.c (async_enable_stdin): Do nothing if sync_execution
        is not set.
        (command_handler): Do not setup continuation here.
        (command_line_handler_continuation): Move to...
        * top.c (command_line_handler_continuation): ... here.
        (execute_command): In async mode, register continuation.
        Don't check frame's language in running in async mode.
        * exceptions.c (throw_exception): Don't do exec_error_cleanups.
        * inf-loop.c (complete_execution): Inline into...
        (inferior_event_handler): ... here.  Clear target_executing before
        doing any cleanups.  Don't try to show prompt if the target was
        resumed.
        * infcmd.c (signal_command): Add support for async mode.
        (finish_command): Only add continuation if the target was
        successfully resumed.
        * remote.c (init_async_opts): Register to_get_thread_local_address
        handler.
        * mi/mi-interp.c (mi_cmd_interpreter_exec): Don't mess
        with sync_execution.
        * tui/tui-interp.c (tui_command_loop): Call async_enable_stdin
        on exception.
@
text
@d438 1
a438 1
async_enable_stdin (void *dummy)
a465 5
  /* Add the reinstate of stdin to the list of cleanups to be done
     in case the target errors out and dies. These cleanups are also
     done in case of normal successful termination of the execution
     command, by complete_execution(). */
  make_exec_error_cleanup (async_enable_stdin, NULL);
@


1.57
log
@	* Makefile.in (mingw-hdep.o, posix-hdep.o, remote-fileio.o): Update.
	* event-loop.c (call_async_signal_handler): New.
	* event-loop.h (call_async_signal_handler)
	(gdb_call_async_signal_handler): Declare.
	(mark_async_signal_handler): Add comments.
	* event-top.c (handle_sigint): Use gdb_call_async_signal_handler.
	* mingw-hdep.c (sigint_event, sigint_handler): New.
	(gdb_select): Use them.  Wait for the readline signal handler
	to finish.
	(gdb_call_async_signal_handler, _initialize_mingw_hdep): New functions.
	* posix-hdep.c (gdb_call_async_signal_handler): New function.
	* remote-fileio.c (sigint_fileio_token, async_remote_fileio_interrupt):
	New.
	(remote_fileio_ctrl_c_signal_handler): Use
	gdb_call_async_signal_handler.
	(initialize_remote_fileio): Initialize sigint_fileio_token.
	* remote.c (initialize_sigint_signal_handler, handle_remote_sigint): Do
	not initialize tokens here.
	(handle_remote_sigint_twice): Likewise.  Reinstall
	handle_remote_sigint.
	(async_remote_interrupt_twice): Just call interrupt_query.
	(cleanup_sigint_signal_handler): Do not delete tokens.
	(remote_interrupt, remote_interrupt_twice): Use
	gdb_call_async_signal_handler.
	(interrupt_query): Reinstall the default signal handler.
	(_initialize_remote): Initialize tokens here.
@
text
@a46 1
static void command_line_handler_continuation (struct continuation_arg *arg);
d440 10
a449 7
  /* See NOTE in async_disable_stdin() */
  /* FIXME: cagney/1999-09-27: Call this before clearing
     sync_execution.  Current target_terminal_ours() implementations
     check for sync_execution before switching the terminal. */
  target_terminal_ours ();
  pop_prompt ();
  sync_execution = 0;
a484 2
  struct continuation_arg *arg1;
  struct continuation_arg *arg2;
a519 18
  /* Set things up for this function to be compete later, once the
     execution has completed, if we are doing an execution command,
     otherwise, just go ahead and finish. */
  if (target_can_async_p () && target_executing)
    {
      arg1 =
	(struct continuation_arg *) xmalloc (sizeof (struct continuation_arg));
      arg2 =
	(struct continuation_arg *) xmalloc (sizeof (struct continuation_arg));
      arg1->next = arg2;
      arg2->next = NULL;
      arg1->data.longint = time_at_cmd_start;
#ifdef HAVE_SBRK
      arg2->data.longint = space_at_cmd_start;
#endif
      add_continuation (command_line_handler_continuation, arg1);
    }

a551 37
/* Do any commands attached to breakpoint we stopped at. Only if we
   are always running synchronously. Or if we have just executed a
   command that doesn't start the target. */
void
command_line_handler_continuation (struct continuation_arg *arg)
{
  extern int display_time;
  extern int display_space;

  long time_at_cmd_start  = arg->data.longint;
  long space_at_cmd_start = arg->next->data.longint;

  bpstat_do_actions (&stop_bpstat);
  /*do_cleanups (old_chain); *//*?????FIXME????? */

  if (display_time)
    {
      long cmd_time = get_run_time () - time_at_cmd_start;

      printf_unfiltered (_("Command execution time: %ld.%06ld\n"),
			 cmd_time / 1000000, cmd_time % 1000000);
    }
  if (display_space)
    {
#ifdef HAVE_SBRK
      char *lim = (char *) sbrk (0);
      long space_now = lim - lim_at_start;
      long space_diff = space_now - space_at_cmd_start;

      printf_unfiltered (_("Space used: %ld (%c%ld for this command)\n"),
			 space_now,
			 (space_diff >= 0 ? '+' : '-'),
			 space_diff);
#endif
    }
}

@


1.56
log
@	Updated copyright notices for most files.
@
text
@d978 3
a980 7
     finish first, which is unacceptable. */
  if (immediate_quit)
    async_request_quit (0);
  else
    /* If immediate quit is not set, we process SIGINT the next time
       through the loop, which is fine. */
    mark_async_signal_handler_wrapper (sigint_token);
@


1.55
log
@2007-08-29  Michael Snyder  <msnyder@@access-company.com>

	* event-top.c (gdb_readline2): Return after EOF.
@
text
@d3 1
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005, 2007
@


1.54
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d866 1
@


1.53
log
@2007-08-13  Michael Snyder  <msnyder@@access-company.com>

	* event-top.c (command_line_handler): Memory leak.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d21 1
a21 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA. */
@


1.52
log
@2007-07-31  Michael Snyder  <msnyder@@access-company.com>

	* event-top.c (command_line_handler): Add pedantic return.
@
text
@a756 1
	  xfree (history_value);
d758 1
@


1.51
log
@2007-07-05  Michael Snyder  <msnyder@@access-company.com>

	* event-top.c (cli_command_loop): Prompt string can (and should)
	be freed after call to readline (Coverity).  Also move local var
	declarations into block where they are used.

	* tui/tui-interp.c (tui_command_loop): Prompt string can (and
	should) be freed after call to readline (Coverity).  Also move
	local var declarations into block where they are used.
@
text
@d676 1
@


1.50
log
@	2007-02-09  Fred Fish  <fnf@@specifix.com>
	Based on work by Apple Computer, Inc.
	* event-top.c (async_request_quit): Call quit() whenever either
	quit_flag is set or immediate_quit is set.
@
text
@a188 4
  int length;
  char *a_prompt;
  char *gdb_prompt = get_prompt ();

d193 4
d200 3
a202 2
      length = strlen (PREFIX (0)) + strlen (gdb_prompt) + strlen (SUFFIX (0)) + 1;
      a_prompt = (char *) xmalloc (length);
@


1.49
log
@Reviewed by Daniel Jacobowitz <drow@@false.org>

	2008-02-08  Fred Fish  <fnf@@specifix.com>
	* event-top.c (handle_sigint): Set quit_flag.
	(async_request_quit): Don't set quit_flag.  Avoid calling quit()
	if quit_flag has already been reset.
@
text
@d1000 4
a1003 3
     back here, that means that an exception was thrown to unwind
     the current command before we got back to the event loop.  So
     there is no reason to call quit again here. */
d1005 2
a1006 4
  if (quit_flag == 0)
    return;

  quit ();
@


1.48
log
@Copyright updates for 2007.
@
text
@d964 7
d999 8
a1006 1
  quit_flag = 1;
@


1.47
log
@2006-12-06  Andrew Stubbs  <andrew.stubbs@@st.com>

	* event-top.c (command_handler): On EOF, print 'quit' and run quit
	command via execute_command such that hooks and trace work.
	* utils.c (defaulted_query): On EOF, print default answer and newline.
@
text
@d3 2
a4 2
   Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005 Free Software
   Foundation, Inc.
@


1.46
log
@2006-07-21  Andrew Stubbs  <andrew.stubbs@@st.com>

	* cli/cli-cmds.c (source_verbose, trace_commands): New variables.
	(source_script): New function.
	(source_verbose_cleanup): New function.
	(source_command): Move old contents to source_script.
	Make function static. Parse -v option and call source_script.
	(init_cli_cmds): Update source command help.
	Add 'set trace-commands' command.
	* cli/cli-script.c (command_next_depth): New static variable.
	(suppress_next_print_command_trace): New static variable.
	(reset_command_nest_depth): New function.
	(print_command_trace): New function.
	(execute_control_command): Split the continue_control and break_control
	cases, add calls to print_command_trace and count the nest depth.
	(while_command): Set suppress_next_print_command_trace.
	(if_command): Likewise.
	* top.c (execute_command): Call print_command_trace.
	* cli/cli-cmds.h (source_verbose, trace_commands): New extern variables.
	(source_command): Change to source_script.
	* main.c (captued_main): Use source_script instead of source_command.
	* top.h (source_command): Change to source_script.
	* event-top.c (display_gdb_prompt): Call reset_command_nest_depth.
	* cli/cli-script.h (print_command_trace): Export.
	(reset_command_nest_depth): Likewise.

docs/
	* gdb.texinfo (Optional warnings and messages): Add
	'set/show trace-commands'.
	(Command files): Add '-v' to source command.

testsuite/
	* gdb.base/default.exp: Update source command error message.
	* gdb.base/help.exp: Update 'help source' message.
@
text
@d504 4
a507 1
    quit_command ((char *) 0, stdin == instream);
@


1.46.2.1
log
@2006-12-06  Andrew Stubbs  <andrew.stubbs@@st.com>

	* event-top.c (command_handler): On EOF, print 'quit' and run quit
	command via execute_command such that hooks and trace work.
	* utils.c (defaulted_query): On EOF, print default answer and newline.
@
text
@d504 1
a504 4
    {
      printf_unfiltered ("quit\n");
      execute_command ("quit", stdin == instream);
    }
@


1.45
log
@	* event-top.c (async_do_nothing, async_disconnect)
	(async_stop_sig, async_float_handler): Remove duplicated
	prototypes.
	(handle_sighup): Guard prototype with SIGHUP.
	(async_do_nothing): Guard function and prototype with
	SIGQUIT || SIGHUP.
	(async_disconnect): Guard prototype with SIGHUP.
	(async_stop_sig): Guard prototype with STOP_SIGNAL.
@
text
@d35 1
d264 3
@


1.45.14.1
log
@2006-05-13    Changes based on Apple GDB (CVS repository 5th Sept 2005)

	* async-nat-inferior.c, async-nat-inferior.h,
	* async-nat-sigthread.c, async-nat-sigthread.h: New files

	* linux-nat.c: Include async-nat-inferior.h.
	(linux_nat_wait): Add extra argument.  If target_can_async_p
	do something completely different.

	* interps.h (interp_set, interp_set_quiet): New externs.

	* interps.c (interp_set): Make asynchronous.
	(interp_set_quiet): Don't make static.
	(current_interp_command_loop): Call functions with new arguments.

	* target.h (target_wait): Add extra argument.
	(gdb_override_async, gdb_set_async_override) New externs.
	(target_can_async_p): Make conditional on gdb_override_async.

	* target.c (gdb_override_async): New variable.
	(gdb_set_async_override, do_restore_target_async_mask):
	New functions.
	(debug_to_wait): Add extra argument.

	* linux-thread-db.c (thread_db_wait): Add extra argument.

	* wrapper.h (safe_execute_command): Declare structure.

	* top.c (*deprecated_target_wait_hook): Add extra argument.
	(read_command_file): Make asynchronous.

	* remote.c (remote_wait, remote_async_wait): Add extra argument.

	* infrun.c: Include event-top.h
	(wait_for_inferior, fetch_inferior_event): Add extra argument to
	target_wait.
	(proceed): Set target_executing = 0.
	(handle_inferior_event): Call async_disable_stdin if async.

	* inf-ptrace.c: Include inf-loop.h, async-nat-inferior.h.
	(inf_ptrace_him): Create a signal thread.
	(inf_ptrace_wait): Add extra argument to target_wait.

	* inf-loop.c (inferior_event_handler, complete_execution):
	Changes for asynchronous operation (copied verbatim).

	* inf-child.c: Include async-nat-inferior.h.
	(inf_child_target): Use methods async_terminal_inferior
	and async_terminal_ours.

	* i386-linux-nat.c: Include inf-loop.h, async-nat-inferior.h.
	(i386_linux_resume): Call gdb_process_events and then
	async methods.

	* exec.c: Include event-loop.h, async-nat-inferior.h.
	(async_file_handler, standard_async, standard_is_async_p)
	(standard_can_async_p): New functions.
	(init_exec_ops): Initialise above methods.

	* event-top.h (cli_command_loop): Make argument void*.

	* event-top.c (display_gdb_prompt, async_enable_stdin)
	(async_disable_stdin, handle_sigint, async_request_quit)
	(gdb_setup_readline, _initialize_event_loop):
	Changes for asynchronous operation (copied verbatim).
	(cli_command_loop): Make argument void*.

	* event-loop.h (gdb_client_data): Move typedef to defs.h.
	(gdb_create_event): Declare.
	(event_handler_func): Move typedef from event-loop.c.

	* event-loop.c (use_poll): Set to 0.
	(gdb_queue_event, gdb_create_event): New functions.
	(async_queue_event): Don't make static.
	(create_file_event): Use gdb_create_event.
	(gdb_event): Change component from int to void*.
	(process_event, handle_file_event, handle_timer_event):
	Change according to gdb_event.
	(event_handler_func): Move typedef to event-loop.c.

	* defs.h: (gdb_mi_run_status, event_loop_p): New externs.
	(gdb_client_data): Move typedef from event-loop.h.
	(*deprecated_command_loop_hook): Make argument void*.
	(*deprecated_target_wait_hook): Add argument.

	* cli-out.h (cli_quoted_out_new): Declare.

	* cli-out.c (cli_quoted_out_new): New function.
	Include mi/mi-console.h.

	* cli/cli-interp.c: Include inferior.h, mi/mi-console.h.
	(safe_execute_command): Make static.
	(cli_interpreter_resume, cli_interpreter_exec):
	Make asynchronous.
	(cli_quoted_interpreter_resume): New function.
	(_initialize_cli_interp): Add li_command_loop to procs.
	Initialize the console-quoted interpreter.

	* tui/tui-hooks.c (tui_target_wait_hook): Add extra argument.

	* mi/mi-main.h (mi_dont_register_continuation)
	(current_command_token,  mi_interp, mi_interpreter_exec_continuation)
	(mi_continuation_arg): New externs.
	(mi_setup_continuation_arg): Declare.

	* mi/mi-main.c: Include wrapper.h.
	(struct mi_continuation_arg): New structure.
	(mi_interpreter_exec_continuation): Move to mi-interp.c.
	(mi_execute_async_cli_command)
	(mi_exec_async_cli_cmd_continuation): Make asynchronous.
	(mi_setup_continuation_arg): New function.

	* mi/mi-interp.c (mi_interpreter_exec_continuation):
	Move from mi-main.c
	(mi_cmd_interpreter_exec): Switch interpreters.  Make
	asynchronous.
	(mi1_command_loop, mi2_command_loop, mi3_command_loop):
	Make argument void*.

	* Makefile.in (async_nat_inferior_h, async_nat_sigthread_h):
	New variables.
	(gdb$(EXEEXT), $(TUI)$(EXEEXT)): Link with libpthread.
	(async-nat-inferior.o, async-nat-sigthread.o): New rules.
	(COMMON_OBS): Add above object files.
	(exec.o, i386-linux-nat.o, inf-ptrace.o, linux-nat.o):
	Update dependencies.

2006-05-13  Nick Roberts  <nickrob@@snap.net.nz>

	* main.c: (event_loop_p): Re-instate variable.
	(captured_main): Re-instate async/noasync option.
	(print_gdb_help): Describe option again.

	* exec.c(init_exec_ops): Only initialise async methods with async
	option.

	* inf-ptrace.c (inf_ptrace_him): Only reate a signal thread with
	async option.

	* README.async, TODO.async, PROBLEMS.async: New files.
@
text
@d186 1
a186 1
cli_command_loop (void *data /* unused */)
a261 1
  static int stdin_handler_removed = 0;
a284 2
      delete_file_handler (input_fd);
      stdin_handler_removed = 1;
a307 14
      /* Claim the terminal before we reset it.  It is quick if the
	 terminal is already ours, and if not, we are going to lose
	 when we try to install the callback handler otherwise.  We
	 can get here with the terminal still belonging to the
	 inferior if it dies an unexpected death, and somebody forgets
	 to clean up properly.  Better safe than sorry... */

      target_terminal_ours ();
      if (stdin_handler_removed)
	{
	  add_file_handler (input_fd, stdin_event_handler, 0);
	  stdin_handler_removed = 0;
	}

d433 1
a433 12
   the exec operation. 
   One tricky point here.  We want to be careful not to stack up
   enables & disables.  This is because we can run the inferior many
   times in one execution command (for instance if a breakpoint command
   restarts the inferior).  And it is not possible a-priori to know when
   we find that the inferior has been restarted whether 
   async_disable_stdin has been called (and thus whether we should re-enable
   it).  If we just make sure that we only do things one level deep here,
   it removes the bookkeeping from callers, which is much better.
*/

int stdin_enabled = 1;
a437 5
  if (stdin_enabled)
    return;

  stdin_enabled = 1; 

d444 1
a444 4
  /* This is bogus...  We shouldn't have to lie about the type of
     execution in order to implement the terminal_ours...
     sync_execution = 0;
  */
d453 1
a453 9

  if (!stdin_enabled)
    return;

  stdin_enabled = 0;

  /* Just don't do this...
     sync_execution = 1; */

a956 10
  /* We used to set the quit flag in async_request_quit, which is either
     called when immediate_quit is 1, or when we get back to the event
     loop.  This is wrong, because you could be running in a loop reading
     in symfiles or something, and it could be quite a while before you 
     get to the event loop.  Instead, set quit_flag to 1 here, then mark
     the sigint handler as ready.  Then if somebody calls QUIT before you
     get to the event loop, they will unwind as expected.  */

  quit_flag = 1;

d985 1
a985 8
  /* If the quit_flag has gotten reset back to 0 by the time we get
     back here, that means that an exception was thrown to unwind
     the current command before we got back to the event loop.  So
     there is no reason to call quit again here. */

  if (quit_flag == 0)
    return;

a1129 6

  /* Note also that if instream == NULL, then we don't want to setup
     readline even IF event_loop_p is true, because we don't have an
     input source for events yet.  This usually only happens if a
     command is run in the .gdbinit file. */

a1131 3
  if (instream == NULL)
    return;

a1199 13

/* Don't set up readline now, this is better done in the interpreter's
   resume method, since we will have to do this coming back & forth
   among interpreters anyway... */

void
_initialize_event_loop (void)
{
  /* Tell gdb to use the cli_command_loop as the main loop. */

  if (deprecated_command_loop_hook == NULL)
    deprecated_command_loop_hook = cli_command_loop;
}
@


1.45.14.2
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a34 1
#include "cli/cli-script.h"     /* for reset_command_nest_depth */
a263 3
  /* Reset the nesting depth used when trace-commands is set.  */
  reset_command_nest_depth ();

@


1.44
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@a51 4
static void async_do_nothing (gdb_client_data arg);
static void async_disconnect (gdb_client_data arg);
static void async_stop_sig (gdb_client_data arg);
static void async_float_handler (gdb_client_data arg);
d57 1
d59 1
d67 1
d69 2
d72 1
d74 1
d76 1
d1000 3
a1002 1
/* Called by the event loop in response to a SIGQUIT. */
d1008 1
@


1.43
log
@2005-11-16  Andrew Stubbs  <andrew.stubbs@@st.com>

	* event-top.h (async_init_signals): Add SIGTERM handler.
	(handle_sigterm): New function.
	* event-top.h (handle_sigterm): New prototype.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2004, 2005 Free Software
d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA. */
@


1.42
log
@        * event-top.c (gdb_setup_readline): Add missing type in extern
        declaration.
@
text
@d895 1
d968 9
@


1.41
log
@2005-11-01  Andrew Stubbs  <andrew.stubbs@@st.com>

	* event-top.c (gdb_setup_readline): Don't set gdb_stdout when
	--batch-silent option was given.
	* main.c (batch_silent): New variable.
	(captured_main): Add new option --batch-silent.
	(print_gdb_help): Likewise.

doc/
	* gdb.texinfo (Choosing modes): Add --batch-silent.
@
text
@d1113 1
a1113 1
  extern batch_silent;
@


1.40
log
@	* event-top.c (async_init_signals): Allow for systems that do not
	define SIGQUIT.
	* ser-tcp.c (net_open): Allow for systems that do not have SIGPIPE.
@
text
@d1113 1
d1115 2
a1116 1
  gdb_stdout = stdio_fileopen (stdout);
@


1.40.2.1
log
@	* gdb/configure.ac: No tgetent on MinGW.
	* gdb/event-loop.c (struct gdb_notifier): Add "handles" for Windows.
	(create_file_handler): On Windows, update handles, rather than
	check_masks and ready_masks.
	(delete_file_handler): Likewise.
	(gdb_wait_for_event): Use WaitForMultipleObjects, not select, on
	Windows.
	* gdb/event-top.c (gdb_setup_readline): Put console into
	character-at-a-time mode under Windows.
@
text
@a42 5
#ifdef __MINGW32__
#include <windows.h>
#include <io.h>
#endif

a1130 14
#ifdef WINAPI
      /* Set the console to character-at-a-time (as opposed to
	 line-at-a-time) mode.  Otherwise, we will get only a single
	 keyboard event for the entire line, and readline will not
	 see each character as it arrives.  */
      {
	DWORD mode;
	HANDLE console_handle;
	console_handle = (HANDLE) _get_osfhandle (fileno (instream));
	GetConsoleMode(console_handle, &mode);
	mode &= ~ENABLE_LINE_INPUT;
	SetConsoleMode(console_handle, mode);
      }
#endif
@


1.40.2.2
log
@	* gdb/ser-tcp.c (net_write_prim): Correct prototype.

	* readline/input.c (rl_getc): Use getche to read console input on
	Windows.

	Revert:
	2005-03-28  Mark Mitchell  <mark@@codesourcery.com>
	* gdb/event-top.c (gdb_setup_readline): Put console into
	character-at-a-time mode under Windows.
@
text
@d43 5
d1136 14
@


1.39
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d58 1
d60 1
d138 1
d140 1
d902 1
d914 1
d975 1
d984 1
@


1.38
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d413 1
a413 1
      printf_unfiltered ("error detected on stdin\n");
d536 1
a536 1
	  printf_unfiltered ("Command execution time: %ld.%06ld\n",
d547 1
a547 1
	  printf_unfiltered ("Space used: %ld (%c%ld for this command)\n",
d575 1
a575 1
      printf_unfiltered ("Command execution time: %ld.%06ld\n",
d585 1
a585 1
      printf_unfiltered ("Space used: %ld (%c%ld for this command)\n",
d618 1
a618 1
      printf_unfiltered ("\n\032\032post-");
d620 1
a620 1
      printf_unfiltered ("\n");
@


1.37
log
@2005-01-17  Andrew Cagney  <cagney@@gnu.org>

	* top.h (source_error, source_pre_error): Delete declaration.
	* cli/cli-script.c (source_error_allocated, source_error): Delete.
	(script_from_file, source_cleanup_lines): Do not manipulate
	source_error_allocated, error_pre_print and source_error.
	(struct source_cleanup_lines_args): Delete fields old_pre_error,
	and old_error_pre_print.
	* top.c (source_error_allocated, source_error)
	(source_pre_error): Delete.
	(command_line_input): Do not set error_pre_print.
	* event-top.c (command_line_handler): Do not set error_pre_print.
@
text
@d328 1
a328 1
      warning ("Command has same effect as set annotate");
d1059 1
a1059 1
  error ("Erroneous arithmetic operation.");
@


1.36
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d2 4
a5 1
   Copyright 1999, 2000, 2001, 2002, 2004 Free Software Foundation, Inc.
d652 1
a652 9
    {
      ++source_line_number;
      sprintf (source_error,
	       "%s%s:%d: Error in sourced command file:\n",
	       source_pre_error,
	       source_file_name,
	       source_line_number);
      error_pre_print = source_error;
    }
@


1.35
log
@* top.c (gdb_readline): Always accept "rn" as a line-ending.
* event-top.c (gdb_readline2): Likewise.
@
text
@d31 1
@


1.34
log
@2004-09-13  Andrew Cagney  <cagney@@gnu.org>

	Eliminate event_loop_p, always has the value 1.
	* defs.h (event_loop_p): Delete macro.
	* breakpoint.c (until_break_command): Simplify.
	* utils.c (prompt_for_continue): Simplify.
	* tracepoint.c (read_actions): Simplify.
	* top.c (throw_exception, execute_command, gdb_readline_wrapper)
	(gdb_rl_operate_and_get_next, command_line_input, get_prompt)
	(set_prompt, init_main): Simplify.
	(init_signals, disconnect): Delete, unused.
	* remote.c (remote_async_resume)
	(extended_remote_async_create_inferior): Simplify.
	* mi/mi-interp.c (mi_input): Delete, unused.
	(mi_interpreter_resume, mi_command_loop): Simplify.
	* interps.c (current_interp_command_loop): Simplify.
	* infrun.c (proceed): Simplify.
	* infcmd.c (run_command, continue_command, step_1, jump_command)
	(until_command, advance_command, finish_command)
	(interrupt_target_command): Simplify.
	* event-top.c (gdb_setup_readline, gdb_disable_readline): Simplify.
@
text
@a857 3
#ifndef CRLF_SOURCE_FILES
	break;
#else
a862 1
#endif
@


1.33
log
@2004-02-28  Andrew Cagney  <cagney@@redhat.com>

	* utils.c: Use "", instead of <>, to include readline.
	tui/tui-win.c, tui/tui.c, tui/tui-hooks.c: Ditto.
	* tracepoint.c, top.c, symmisc.c, symfile.c: Ditto.
	* source.c, solib.c, exec.c, event-top.c: Ditto.
	* corelow.c, completer.c, cli/cli-setshow.c: Ditto.
	* cli/cli-dump.c, cli/cli-cmds.c: Ditto.
	* Makefile.in: Update all dependencies.
	(readline_tilde_h, readline_history_h): Define.
	(readline_headers): Delete.
@
text
@d1109 13
a1121 5
  /* This function is a noop for the sync case.  The assumption is that
     the sync setup is ALL done in gdb_init, and we would only mess it up
     here.  The sync stuff should really go away over time. */

  if (event_loop_p)
d1123 4
a1126 13
      gdb_stdout = stdio_fileopen (stdout);
      gdb_stderr = stdio_fileopen (stderr);
      gdb_stdlog = gdb_stderr;  /* for moment */
      gdb_stdtarg = gdb_stderr; /* for moment */

      /* If the input stream is connected to a terminal, turn on
         editing.  */
      if (ISATTY (instream))
	{
	  /* Tell gdb that we will be using the readline library. This
	     could be overwritten by a command in .gdbinit like 'set
	     editing on' or 'off'. */
	  async_command_editing_p = 1;
d1128 8
a1135 31
	  /* When a character is detected on instream by select or
	     poll, readline will be invoked via this callback
	     function. */
	  call_readline = rl_callback_read_char_wrapper;
	}
      else
	{
	  async_command_editing_p = 0;
	  call_readline = gdb_readline2;
	}

      /* When readline has read an end-of-line character, it passes
         the complete line to gdb for processing. command_line_handler
         is the function that does this. */
      input_handler = command_line_handler;

      /* Tell readline to use the same input stream that gdb uses. */
      rl_instream = instream;

      /* Get a file descriptor for the input stream, so that we can
         register it with the event loop. */
      input_fd = fileno (instream);

      /* Now we need to create the event sources for the input file
         descriptor. */
      /* At this point in time, this is the only event source that we
         register with the even loop. Another source is going to be
         the target program (inferior), but that must be registered
         only when it actually exists (I.e. after we say 'run' or
         after we connect to a remote target. */
      add_file_handler (input_fd, stdin_event_handler, 0);
d1137 21
d1166 4
a1169 7
  if (event_loop_p)
    {
      /* FIXME - It is too heavyweight to delete and remake these
         every time you run an interpreter that needs readline.
         It is probably better to have the interpreters cache these,
         which in turn means that this needs to be moved into interpreter
         specific code. */
d1172 4
a1175 4
      ui_file_delete (gdb_stdout);
      ui_file_delete (gdb_stderr);
      gdb_stdlog = NULL;
      gdb_stdtarg = NULL;
d1178 2
a1179 3
      rl_callback_handler_remove ();
      delete_file_handler (input_fd);
    }
@


1.32
log
@2004-02-19  Elena Zannoni  <ezannoni@@redhat.com>

       * event-top.c (async_request_quit): Remove uses of REQUEST_QUIT
       macro, which was part of the now removed Mach 3 port.
       * utils.c (request_quit): Ditto.
@
text
@d36 2
a37 2
#include <readline/readline.h>
#include <readline/history.h>
@


1.32.2.1
log
@Merge mainline to intercu branch.
@
text
@d36 2
a37 2
#include "readline/readline.h"
#include "readline/history.h"
@


1.32.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d1109 5
a1113 13
  /* This function is a noop for the sync case.  The assumption is
     that the sync setup is ALL done in gdb_init, and we would only
     mess it up here.  The sync stuff should really go away over
     time.  */

  gdb_stdout = stdio_fileopen (stdout);
  gdb_stderr = stdio_fileopen (stderr);
  gdb_stdlog = gdb_stderr;  /* for moment */
  gdb_stdtarg = gdb_stderr; /* for moment */

  /* If the input stream is connected to a terminal, turn on
     editing.  */
  if (ISATTY (instream))
d1115 13
a1127 4
      /* Tell gdb that we will be using the readline library. This
	 could be overwritten by a command in .gdbinit like 'set
	 editing on' or 'off'.  */
      async_command_editing_p = 1;
d1129 31
a1159 8
      /* When a character is detected on instream by select or poll,
	 readline will be invoked via this callback function.  */
      call_readline = rl_callback_read_char_wrapper;
    }
  else
    {
      async_command_editing_p = 0;
      call_readline = gdb_readline2;
a1160 21
  
  /* When readline has read an end-of-line character, it passes the
     complete line to gdb for processing. command_line_handler is the
     function that does this.  */
  input_handler = command_line_handler;
      
  /* Tell readline to use the same input stream that gdb uses. */
  rl_instream = instream;

  /* Get a file descriptor for the input stream, so that we can
     register it with the event loop.  */
  input_fd = fileno (instream);

  /* Now we need to create the event sources for the input file
     descriptor.  */
  /* At this point in time, this is the only event source that we
     register with the even loop. Another source is going to be the
     target program (inferior), but that must be registered only when
     it actually exists (I.e. after we say 'run' or after we connect
     to a remote target.  */
  add_file_handler (input_fd, stdin_event_handler, 0);
d1169 7
a1175 4
  /* FIXME - It is too heavyweight to delete and remake these every
     time you run an interpreter that needs readline.  It is probably
     better to have the interpreters cache these, which in turn means
     that this needs to be moved into interpreter specific code.  */
d1178 4
a1181 4
  ui_file_delete (gdb_stdout);
  ui_file_delete (gdb_stderr);
  gdb_stdlog = NULL;
  gdb_stdtarg = NULL;
d1184 3
a1186 2
  rl_callback_handler_remove ();
  delete_file_handler (input_fd);
@


1.31
log
@2003-11-06  Andrew Cagney  <cagney@@redhat.com>

	* valops.c (destructor_name_p): Replace STREQN with strncmp.
	* top.c (command_line_input): Ditto.
	* objc-exp.y (yylex): Ditto.
	* minsyms.c (prim_record_minimal_symbol_and_info): Ditto.
	* jv-exp.y (yylex): Ditto.
	* f-exp.y (yylex): Ditto.
	* event-top.c (command_line_handler): Ditto.
	* environ.c (get_in_environ): Ditto.
	(set_in_environ): Ditto.
	* dwarfread.c (handle_producer): Ditto.
	* dbxread.c (process_one_symbol): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* c-exp.y (yylex): Ditto.

2003-11-06  Andrew Cagney  <cagney@@redhat.com>

	* mi-cmd-var.c (mi_cmd_var_set_format): Replace STREQN with
	strncmp.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
a973 3
#ifdef REQUEST_QUIT
  REQUEST_QUIT;
#else
a974 1
#endif
@


1.30
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d705 1
a705 1
    && STREQN (linebuffer, "server ", SERVER_COMMAND_LENGTH);
@


1.29
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@a1086 1
/* ARGSUSED */
a1093 1
/* ARGSUSED */
a1100 1
/* ARGSUSED */
@


1.28
log
@2003-08-04  David Carlton  <carlton@@kealia.com>

	* charset.c (cached_iconv_convert): Add __FILE__ and __LINE__ args
	to internal_error call.
	* source.c (forward_search_command): Add "%s" format argument.
	(reverse_search_command): Ditto.
	* top.c (quit_confirm): Ditto.
	* cli/cli-setshow.c (do_setshow_command): Ditto.
	* cp-valprint.c (cp_print_class_method): Replace
	{f,}printf_{un,}filtered by {f,}puts_{un,}filtered.
	(cp_print_class_member): Ditto.
	* event-top.c (command_line_handler): Ditto.
	* linux-proc.c (linux_info_proc_cmd): Ditto.
	* p-typeprint.c (pascal_type_print_base): Ditto.
	* p-valprint.c (pascal_object_print_class_method): Ditto.
	(pascal_object_print_class_member): Ditto.
	* printcmd.c (print_scalar_formatted,printf_command): Ditto.
	* remote.c (remote_cisco_section_offsets): Ditto.
	* top.c (command_line_input): Ditto.
	* utils.c (vwarning,error_stream,quit): Ditto.
	* valprint.c (print_floating,print_binary_chars)
	(print_octal_chars,print_decimal_chars,print_hex_chars): Ditto.

2003-08-04  David Carlton  <carlton@@kealia.com>

	* mi-main.c (mi_error_last_message): Add "%s" second argument to
	xasprintf call.

2003-08-04  David Carlton  <carlton@@kealia.com>

	* generic/gdbtk.c (gdbtk_source_start_file): Add "%s" first
	argument to error call.
	(tk_command): Ditto.
	(view_command): Ditto.
@
text
@d602 1
a602 1
  register char *p;
@


1.27
log
@        * top.h (lim_at_start): Declare.
        * main.c (captured_main): Set it.
        * top.c (lim_at_start): Define.
        (command_loop): Use it instead of &environ.
        * event-top.c (command_handler): Likewise.

        * gdb.base/selftest.exp: Next over lim_at_start initialization.
@
text
@d615 1
a615 1
      printf_unfiltered (async_annotation_suffix);
@


1.26
log
@2003-02-12  Andrew Cagney  <ac131313@@redhat.com>

	* event-top.c (cli_command_loop): Delete declaration.
	(_initialize_event_loop): Delete function setting event_loop_hook.
	* event-top.h (cli_command_loop): Declare.  Update copyright.
	(EVENT_TOP_H): Define.  Wrap header in #ifdef EVENT_TOP_H.
	* interps.c (current_interp_command_loop): When event_loop_p, call
	cli_command_loop.
@
text
@a494 1
      extern char **environ;
d496 1
a496 2

      space_at_cmd_start = (long) (lim - (char *) &environ);
a538 1
	  extern char **environ;
d540 1
a540 1
	  long space_now = lim - (char *) &environ;
a576 1
      extern char **environ;
d578 1
a578 1
      long space_now = lim - (char *) &environ;
@


1.26.24.1
log
@Snap const char * mess.
@
text
@d1093 1
a1093 2
set_async_editing_command (const char *args, int from_tty,
			   struct cmd_list_element *c)
d1101 1
a1101 2
set_async_annotation_level (const char *args, int from_tty,
			    struct cmd_list_element *c)
d1109 1
a1109 1
set_async_prompt (const char *args, int from_tty, struct cmd_list_element *c)
@


1.25
log
@2003-02-05  Jim Ingham <jingham@@apple.com>
            Keith Seitz  <keiths@@redhat.com>
            Elena Zannoni  <ezannoni@@redhat.com>
            Andrew Cagney  <ac131313@@redhat.com>

	* Makefile.in (SUBDIR_CLI_OBS): Add "cli-interp.o".
	(SUBDIR_CLI_SRCS): Add "cli/cli-interp.c".
	(SUBDIR_MI_OBS): Add "mi-interp.o".
	(SUBDIR_MI_SRCS): Add "mi/mi-interp.c".
	(SFILES): Add "interps.c".
	(COMMON_OBS): Add "interps.o".
	(interps_h, mi_main_h): Define.
	(interps.o, cli-interp.o, mi-interp.o): Add dependencies.
	(mi-main.o, main.o, event-top.o): Update dependencies.
	* cli/cli-interp.c: New file.
	* interps.h, interps.c: New files.
	* top.c: (gdb_init): Don't install the default interpreter, handed
	by captured_main.
	* main.c: Include "interps.h".
	(interpreter_p): Note that it should malloc'ed.
	(captured_command_loop): Call current_interp_command_loop.
	(captured_main): Initialize interpreter_p to INTERP_CONSOLE.  Use
	xfree and xstrdup when updating interpreter_p.  Install the
	default interpreter.  Add hack to stop mi1's copyright notice
	being encoded.
	* event-top.h (gdb_setup_readline): Declare.
	(gdb_disable_readline): Declare.
	* event-top.c: Include "interps.h".
	(display_gdb_prompt): Call current_interp_display_prompt_p.
	(gdb_setup_readline): Initialize gdb_stdout, gdb_stderr,
	gdb_stdlog, and gdb_stdtarg.
	(_initialize_event_loop): Don't call gdb_setup_readline.
	* cli-out.c (cli_out_set_stream): New function.
	* cli-out.h (cli_out_set_stream): Declare.
@
text
@a41 2
extern void _initialize_event_loop (void);

a47 1
void cli_command_loop (void);
a1198 9

void
_initialize_event_loop (void)
{
  /* Tell gdb to use the cli_command_loop as the main loop. */
  if (event_loop_p && command_loop_hook == NULL)
    command_loop_hook = cli_command_loop;
}

@


1.24
log
@2002-11-05  Elena Zannoni  <ezannoni@@redhat.com>

        From Jim Ingham  <jingham@@apple.com>:
	* event-top.c (gdb_disable_readline): New function.
	(_initialize_event_loop): Move comment.
@
text
@d29 1
d254 3
a256 3
  /* When an alternative interpreter has been installed, do not
     display the comand prompt. */
  if (interpreter_p)
d1129 5
a1205 2
  gdb_setup_readline ();

@


1.24.4.1
log
@Merge kseitz_interps-20020528-branch.
@
text
@a28 1
#include "interps.h"
d253 3
a255 3
  /* Each interpreter has its own rules on wether or not display the
     command prompt. */
  if (!gdb_interpreter_display_prompt_p ())
a1127 5
      gdb_stdout = stdio_fileopen (stdout);
      gdb_stderr = stdio_fileopen (stderr);
      gdb_stdlog = gdb_stderr;  /* for moment */
      gdb_stdtarg = gdb_stderr; /* for moment */

d1200 2
@


1.24.4.2
log
@Clean up.
@
text
@d256 1
a256 1
  if (!current_interp_display_prompt_p ())
@


1.24.4.3
log
@Overhaul changelog entries.
@
text
@d254 2
a255 2
  /* Each interpreter has its own rules on displaying the command
     prompt.  */
@


1.23
log
@2002-10-02  Elena Zannoni  <ezannoni@@redhat.com>

	* event-top.c (gdb_setup_readline): New function. Code moved from
	_initialize_event_loop().
	(_initialize_event_loop): Call gdb_setup_readline().
@
text
@d1171 26
d1202 1
d1204 1
a1204 4
    {
      /* Tell gdb to use the cli_command_loop as the main loop. */
      command_loop_hook = cli_command_loop;
    }
d1206 1
@


1.23.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a28 1
#include "interps.h"
d41 2
d49 1
d253 3
a255 3
  /* Each interpreter has its own rules on displaying the command
     prompt.  */
  if (!current_interp_display_prompt_p ())
d497 1
d499 2
a500 1
      space_at_cmd_start = lim - lim_at_start;
d543 1
d545 1
a545 1
	  long space_now = lim - lim_at_start;
d582 1
d584 1
a584 1
      long space_now = lim - lim_at_start;
d608 1
a608 1
  char *p;
d621 1
a621 1
      puts_unfiltered (async_annotation_suffix);
d711 1
a711 1
    && strncmp (linebuffer, "server ", SERVER_COMMAND_LENGTH) == 0;
d1093 1
d1101 1
d1109 1
a1127 5
      gdb_stdout = stdio_fileopen (stdout);
      gdb_stderr = stdio_fileopen (stderr);
      gdb_stdlog = gdb_stderr;  /* for moment */
      gdb_stdtarg = gdb_stderr; /* for moment */

a1170 3
/* Disable command input through the standard CLI channels.  Used in
   the suspend proc for interpreters that use the standard gdb readline
   interface, like the cli & the mi.  */
d1172 1
a1172 1
gdb_disable_readline (void)
d1174 3
a1176 1
  if (event_loop_p)
d1178 2
a1179 15
      /* FIXME - It is too heavyweight to delete and remake these
         every time you run an interpreter that needs readline.
         It is probably better to have the interpreters cache these,
         which in turn means that this needs to be moved into interpreter
         specific code. */

#if 0
      ui_file_delete (gdb_stdout);
      ui_file_delete (gdb_stderr);
      gdb_stdlog = NULL;
      gdb_stdtarg = NULL;
#endif

      rl_callback_handler_remove ();
      delete_file_handler (input_fd);
@


1.22
log
@2002-07-03  Martin M. Hunt  <hunt@@redhat.com>

	* event-top.c (command_line_handler): Don't read past
        beginning of buffer.
@
text
@d1120 1
a1120 1
_initialize_event_loop (void)
d1122 4
a1159 3
      /* Tell gdb to use the cli_command_loop as the main loop. */
      command_loop_hook = cli_command_loop;

d1168 12
@


1.22.8.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d1120 1
a1120 1
gdb_setup_readline (void)
a1121 4
  /* This function is a noop for the sync case.  The assumption is that
     the sync setup is ALL done in gdb_init, and we would only mess it up
     here.  The sync stuff should really go away over time. */

d1156 3
a1166 12
    }
}

void
_initialize_event_loop (void)
{
  gdb_setup_readline ();

  if (event_loop_p && command_loop_hook == NULL)
    {
      /* Tell gdb to use the cli_command_loop as the main loop. */
      command_loop_hook = cli_command_loop;
@


1.22.8.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a1170 26
/* Disable command input through the standard CLI channels.  Used in
   the suspend proc for interpreters that use the standard gdb readline
   interface, like the cli & the mi.  */
void
gdb_disable_readline (void)
{
  if (event_loop_p)
    {
      /* FIXME - It is too heavyweight to delete and remake these
         every time you run an interpreter that needs readline.
         It is probably better to have the interpreters cache these,
         which in turn means that this needs to be moved into interpreter
         specific code. */

#if 0
      ui_file_delete (gdb_stdout);
      ui_file_delete (gdb_stderr);
      gdb_stdlog = NULL;
      gdb_stdtarg = NULL;
#endif

      rl_callback_handler_remove ();
      delete_file_handler (input_fd);
    }
}

a1175 1
  /* Tell gdb to use the cli_command_loop as the main loop. */
d1177 4
a1180 1
    command_loop_hook = cli_command_loop;
a1181 1

@


1.22.8.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a28 1
#include "interps.h"
d253 3
a255 3
  /* Each interpreter has its own rules on displaying the command
     prompt.  */
  if (!current_interp_display_prompt_p ())
a1127 5
      gdb_stdout = stdio_fileopen (stdout);
      gdb_stderr = stdio_fileopen (stderr);
      gdb_stdlog = gdb_stderr;  /* for moment */
      gdb_stdtarg = gdb_stderr; /* for moment */

d1200 2
@


1.22.8.4
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d42 2
d50 1
d1202 9
@


1.22.8.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d495 1
d497 2
a498 1
      space_at_cmd_start = lim - lim_at_start;
d541 1
d543 1
a543 1
	  long space_now = lim - lim_at_start;
d580 1
d582 1
a582 1
      long space_now = lim - lim_at_start;
@


1.22.8.6
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d615 1
a615 1
      puts_unfiltered (async_annotation_suffix);
@


1.22.8.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d602 1
a602 1
  char *p;
@


1.22.8.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d705 1
a705 1
    && strncmp (linebuffer, "server ", SERVER_COMMAND_LENGTH) == 0;
d1087 1
d1095 1
d1103 1
@


1.21
log
@2002-06-20  Elena Zannoni  <ezannoni@@redhat.com>

	* event-top.c (command_handler): Don't use space_at_cmd_start
	unless there is sbrk() on the host. Assign time and space data
	to union fields of the appropriate length.
@
text
@d686 1
a686 1
  if (*(p - 1) == '\\')
@


1.20
log
@	* event-top.c (command_line_handler): Remove useless if.
@
text
@d517 4
a520 2
      arg1->data.integer = time_at_cmd_start;
      arg2->data.integer = space_at_cmd_start;
@


1.20.4.1
log
@More merging.
@
text
@d517 2
a518 4
      arg1->data.longint = time_at_cmd_start;
#ifdef HAVE_SBRK
      arg2->data.longint = space_at_cmd_start;
#endif
@


1.20.6.1
log
@Initial check-in of interpreter support from Apple. (Slightly massaged and
modified by me.)
@
text
@a28 1
#include "interps.h"
d255 1
a255 1
  if (gdb_interpreter_display_prompt (new_prompt))
a1113 8
void
_initialize_event_loop (void)
{
  /* Tell gdb to use the cli_command_loop as the main loop. */
  if (event_loop_p && command_loop_hook == NULL)
    command_loop_hook = cli_command_loop;
}

d1118 1
a1118 1
gdb_setup_readline (void)
a1119 4
  /* This function is a noop for the async case.  The assumption is that
     the async setup is ALL done in gdb_init, and we would only mess it up
     here.  The async stuff should really go away over time. */

a1121 5
      gdb_stdout = stdio_fileopen (stdout);
      gdb_stderr = stdio_fileopen (stderr);
      gdb_stdlog = gdb_stderr;  /* for moment */
      gdb_stdtarg = gdb_stderr; /* for moment */

d1154 3
a1166 28

/* Disable command input through the standard CLI channels.  Used in
   the suspend proc for interpreters that use the standard gdb readline
   interface, like the cli & the mi. */

void
gdb_disable_readline (void)
{
  if (event_loop_p)
    {
      /* FIXME - It is too heavyweight to delete and remake these
         every time you run an interpreter that needs readline.
         It is probably better to have the interpreters cache these,
         which in turn means that this needs to be moved into interpreter
         specific code. */

#if 0
      ui_file_delete (gdb_stdout);
      ui_file_delete (gdb_stderr);
      gdb_stdlog = NULL;
      gdb_stdtarg = NULL;
#endif

      rl_callback_handler_remove ();
      delete_file_handler (input_fd);
    }
}

@


1.20.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d518 2
a519 4
      arg1->data.longint = time_at_cmd_start;
#ifdef HAVE_SBRK
      arg2->data.longint = space_at_cmd_start;
#endif
d685 1
a685 1
  if (p > linebuffer && *(p - 1) == '\\')
@


1.20.6.3
log
@merge from mainline
@
text
@d1131 3
a1133 4

  /* This function is a noop for the sync case.  The assumption is that
     the sync setup is ALL done in gdb_init, and we would only mess it up
     here.  The sync stuff should really go away over time. */
@


1.20.6.4
log
@2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* event-top.c (display_gdb_prompt): Use
	gdb_interpreter_display_prompt_p.
	* cli/cli-interp.c (cli_interpreter_display_prompt_p): Rename from
	cli_interpreter_display_prompt and rewrite.
	(_initialize_cli_interp): New proc name is
	cli_interpreter_display_prompt_p.
	* interps.c (gdb_new_interpreter): Initialize prompt_proc_p
	instead of prompt_proc.
	(gdb_interpreter_display_prompt_p): Rewrite as a predicate.
	* interps.h (interp_prompt_ftype): Update typedef.
	(struct gdb_interpreter_procs): Rename prompt_proc to
	prompt_proc_p.
	(gdb_interpreter_display_prompt_p): Export this instead of old
	function.

2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-interp.c (_initialize_mi_interp): Use mi_interpreter_prompt_p
	instead of mi_interpreter_prompt.
	(mi_interpreter_prompt_p): Rename from mi_interpreter_prompt and
	rewrite.
@
text
@d254 3
a256 3
  /* Each interpreter has its own rules on wether or not display the
     command prompt. */
  if (!gdb_interpreter_display_prompt_p ())
@


1.20.6.5
log
@2002-11-05  Elena Zannoni  <ezannoni@@redhat.com>

        * event-top.c: Reorg some code, to minimize diffs with mainline.
@
text
@d1117 8
d1131 1
d1188 2
a1189 1
   interface, like the cli & the mi.  */
a1210 8
}

void
_initialize_event_loop (void)
{
  /* Tell gdb to use the cli_command_loop as the main loop. */
  if (event_loop_p && command_loop_hook == NULL)
    command_loop_hook = cli_command_loop;
@


1.19
log
@Remove else clause to #if UI_OUT.
@
text
@d688 3
a690 5
      if (*p == '\\')
	{
	  readline_input_state.linebuffer = savestring (linebuffer,
							strlen (linebuffer));
	  readline_input_state.linebuffer_ptr = p;
d692 7
a698 8
	  /* We will not invoke a execute_command if there is more
	     input expected to complete the command. So, we need to
	     print an empty prompt here. */
	  more_to_come = 1;
	  push_prompt ("", "", "");
	  display_gdb_prompt (0);
	  return;
	}
@


1.19.2.1
log
@2002-06-20  Elena Zannoni  <ezannoni@@redhat.com>

        * event-top.c (command_handler): Don't use space_at_cmd_start
        unless there is sbrk() on the host. Assign time and space data
        to union fields of the appropriate length.
@
text
@d517 2
a518 4
      arg1->data.longint = time_at_cmd_start;
#ifdef HAVE_SBRK
      arg2->data.longint = space_at_cmd_start;
#endif
@


1.18
log
@Remove obsolete MacOS support.
@
text
@a252 1
#ifdef UI_OUT
a256 1
#endif
@


1.17
log
@	* NEWS: Updated.
	* event-loop.c (start_event_loop): Call
	after_char_processing_hook.
	* event-top.h (after_char_processing_hook): Declare.
	* event-top.c (rl_callback_read_char_wrapper): Call
	after_char_processing_hook.
	(after_char_processing_hook): New global.
	* top.c (operate_saved_history): New global.
	(gdb_rl_operate_and_get_next): New function.
	(init_main): Add the operate-and-get-next defun.
	(gdb_rl_operate_and_get_next_completion): New function.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
a309 6

      /* OBSOLETE #ifdef MPW */
      /* OBSOLETE        *//* Move to a new line so the entered line doesn't have a prompt */
      /* OBSOLETE          on the front of it. */
      /* OBSOLETE       fputs_unfiltered ("\n", gdb_stdout); */
      /* OBSOLETE #endif  *//* MPW */
@


1.16
log
@* event-top.c (async_stop_sig) [HAVE_SIGPROCMASK]: Some
gratuitious whitespace changes.
[!HAVE_SIGPROCMASK]: Call sigsetmask if HAVE_SIGSETMASK is defined.
* top.c: Remove redundant logic to define HAVE_SIGSETMASK.
(sigsetmask) Don't define macro.
(stop_sig) [HAVE_SIGPROCMASK]: Add bit of code snatched from
async_stop_sig from event-top.c.
[!HAVE_SIGPROCMASK]: Call sigsetmask if HAVE_SIGSETMASK is
defined.
* configure.in (AC_CHECK_FUNCS): Put functions in alphabetical
order.  Add sigsetmask.
(AC_FUNC_VFORK, AC_FUNC_ALLOCA): Reorder such that they're in
alphabetical order.
* config/xm-aix4.h, config/alpha/xm-alphalinux.h,
config/i386/xm-cygwin.h, config/rs6000/xm-rs6000.h
(HAVE_SIGSETMASK): Remove.
* aclocal.m4, config.in, configure
@
text
@d156 4
d169 2
@


1.15
log
@	* utils.c (query): Remove tui hacks; tui must use the query_hook.
	* top.c (command_loop): Remove tui insert_mode hacks; don't call
	tuiCleanUp because this must be made with atexit by tui.
	* symfile.c (symbol_file_command): Remove call to TUIDO
	* stack.c (show_and_print_stack_frame_stub): Remove tui check;
	not necessary when using the selected frame hooks.
	(print_stack_frame_stub): Likewise.
	(print_frame_info_base): Likewise.
	(print_frame_info): Likewise.
	(up_silently_command): Likewise.
	(down_silently_command): Likewise.
	(show_stack_frame): Likewise for TUIDO.
	(select_frame): Likewise.
	(select_and_print_frame): Likewise.
	(stack_publish_stopped_with_no_frame): Remove.
	(select_and_maybe_print_frame): Remove.
	* main.c (captured_main): Remove tui_fileopen and tuiInit; tui
	must use the initialize ui hook.
	* infrun.c (normal_stop): Remove call to TUIDO; tui must use the
	selected frame hooks.
	* event-top.c (command_handler): Remove tui insert_mode hack.
	* defs.h: Remove TUIDO; Only include tui.h.
	* breakpoint.c (mention): Remove calls to TUIDO.
	(delete_breakpoint): Remove tui hacks; tui must install
	the breakpoint hooks.
@
text
@d1045 1
d1049 1
a1049 1
#else
@


1.14
log
@Obsolete MPW as host.
@
text
@a480 4
#if defined(TUI)
  extern int insert_mode;
#endif

a485 3
#if defined(TUI)
  insert_mode = 0;
#endif
@


1.13
log
@Update/correct copyright notices.
@
text
@d305 5
a309 5
#ifdef MPW
      /* Move to a new line so the entered line doesn't have a prompt
         on the front of it. */
      fputs_unfiltered ("\n", gdb_stdout);
#endif /* MPW */
@


1.12
log
@* event-top.c: Remove duplicate #include <signal.h>.
@
text
@d2 1
a2 1
   Copyright 1999 Free Software Foundation, Inc.
@


1.11
log
@* signals.h: Removed.
* event-top.c (#include <signal.h>): Changed from signals.h.
* inflow.c: Likewise.
* mac-xdep.c: Likewise.
* ser-pipe.c: Likewise.
* ser-tcp.c: Likewise.
* standalone.c: Likewise.
* top.c: Likewise.
* utils.c: Likewise.
* Makefile.in: Removed signals.h from dependencies.
@
text
@a37 2
#include <signal.h>

@


1.10
log
@Replace free() with xfree().
@
text
@a26 1
#include "signals.h"
d29 1
@


1.9
log
@
Corrected spelling in comments:
foe->for  executin ->execution.
@
text
@d396 1
a396 1
	free (PROMPT (-1));
d400 3
a402 3
  free (PREFIX (0));
  free (PROMPT (0));
  free (SUFFIX (0));
d646 1
a646 1
      free (readline_input_state.linebuffer);
d693 1
a693 1
  free (rl);			/* Allocated in readline.  */
d752 1
a752 1
	      free (history_value);
d762 1
a762 1
	  free (history_value);
d871 1
a871 1
	  free (result);
@


1.8
log
@Protoization.
@
text
@d160 1
a160 1
/* Wrapper function foe calling into the readline library. The event
d518 1
a518 1
     executin has completed, if we are doing an execution command,
@


1.7
log
@Replace command_loop_marker() with null_cleanup().
@
text
@d1019 1
a1019 2
handle_sighup (sig)
     int sig;
@


1.6
log
@Eliminate make_cleanup_func from top.c
@
text
@d490 1
a490 1
  old_chain = make_cleanup (command_loop_marker, 0);
@


1.5
log
@2000-03-30  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * defs.h (struct continuation_arg): make 'data' a union, to avoid
        casting problems when int and pointer are not the  same size.
        * event-top.c (command_handler): use data as a union.
        (command_line_handler_continuation): ditto.
        * infcmd.c (step_1_continuation): use data as a union.  Re-indent.
        (step_once): ditto.  (finish_command_continuation): ditto.
        (finish_command): ditto.
        * breakpoint.c (until_break_command): use data as a union.
        (until_break_command_continuation): ditto.
        * utils.c (add_intermediate_continuation): fix typo in comment.
@
text
@d490 1
a490 1
  old_chain = make_cleanup ((make_cleanup_func) command_loop_marker, 0);
@


1.4
log
@	* event-top.c (_initialize_event_loop): If instream is not
	connected to a terminal device, turn editing off.
@
text
@d528 2
a529 2
      arg1->data = (void *) time_at_cmd_start;
      arg2->data = (void *) space_at_cmd_start;
d575 2
a576 2
  long time_at_cmd_start = (long) arg->data;
  long space_at_cmd_start = (long) arg->next->data;
@


1.3
log
@2000-03-03  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* defs.h (struct continuation_arg): Change type of field 'data'
 	from PTR to void *.

	* event-loop.h: Eliminate uses of PTR, use 'void *' instead.

	* event-top.c: Ditto.
@
text
@d1136 19
a1154 3
      /* When a character is detected on instream by select or poll,
         readline will be invoked via this callback function. */
      call_readline = rl_callback_read_char_wrapper;
a1178 5

      /* Tell gdb that we will be using the readline library. This
         could be overwritten by a command in .gdbinit like 'set
         editing on' or 'off'. */
      async_command_editing_p = 1;
@


1.2
log
@Add mi/ and testsuite/gdb.mi/ subdirectories.
Add --enable-gdbmi option to configury.
Add mi rules to Makefile.in
Add mi conditional output to event-top.c infrun.c main.c top.c.
Add -i=mi option.
@
text
@d132 1
a132 1
PTR sigint_token;
d134 1
a134 1
PTR sighup_token;
d136 2
a137 2
PTR sigquit_token;
PTR sigfpe_token;
d139 1
a139 1
PTR sigwinch_token;
d142 1
a142 1
PTR sigtstp_token;
d528 2
a529 2
      arg1->data = (PTR) time_at_cmd_start;
      arg2->data = (PTR) space_at_cmd_start;
d960 1
a960 1
mark_async_signal_handler_wrapper (PTR token)
@


1.1
log
@Initial revision
@
text
@d19 2
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d23 5
d29 4
a32 4
#ifdef HAVE_POLL
#include <sys/poll.h>
#endif
#include "inferior.h"
d38 2
d43 1
a43 1
extern FILE *instream;
d45 11
a55 4
static void command_line_handler PARAMS ((char *));
static void gdb_readline2 PARAMS ((void));
static void pop_prompt PARAMS ((void));
static void push_prompt PARAMS ((char *, char *, char *));
d58 6
a63 5
void handle_sigint PARAMS ((int));
void handle_sigquit PARAMS ((int));
void handle_sighup PARAMS ((int));
void handle_sigfpe PARAMS ((int));
void handle_sigwinch PARAMS ((int));
d67 4
a70 27
void async_request_quit PARAMS ((void));
void async_do_nothing PARAMS ((void));
void async_disconnect PARAMS ((void));
void async_float_handler PARAMS ((void));

/* Functions from top.c. */
extern void command_loop_marker PARAMS ((int));
extern int quit_cover PARAMS ((PTR));
extern void quit_command PARAMS ((char *, int));
extern void execute_command PARAMS ((char *, int));

/* Variables from top.c. */
extern int source_line_number;
extern char *source_file_name;
extern char *source_error;
extern char *source_pre_error;
extern int history_expansion_p;
extern int server_command;

/* If this definition isn't overridden by the header files, assume
   that isatty and fileno exist on this system.  */
#ifndef ISATTY
#define ISATTY(FP)	(isatty (fileno (FP)))
#endif

/* Hook for alternate command interface.  */
void (*async_hook) PARAMS ((void));
d92 2
a93 2
void (*input_handler) PARAMS ((char *));
void (*call_readline) PARAMS ((void));
d99 2
a100 2
   form of the set editing command. 
   ezannoni: as of 4/29/99 I expect that this
d113 4
d132 1
a132 1
async_signal_handler *sigint_token;
d134 1
a134 1
async_signal_handler *sighup_token;
d136 2
a137 2
async_signal_handler *sigquit_token;
async_signal_handler *sigfpe_token;
d139 4
a142 1
async_signal_handler *sigwinch_token;
d160 9
d170 1
a170 1
   register readline, and stdin. */
d172 1
a172 1
setup_event_loop ()
d174 3
a176 2
  int length = strlen (PREFIX (0)) + strlen (PROMPT (0)) + strlen (SUFFIX (0)) + 1;
  char *a_prompt = (char *) xmalloc (length);
d178 16
a193 42
  /* Set things up for readline to be invoked via the alternate
     interface, i.e. via a callback function (rl_callback_read_char). */
  call_readline = rl_callback_read_char;

  /* When readline has read an end-of-line character, it passes the
     complete line to gdb for processing. command_line_handler is the
     function that does this. */
  input_handler = command_line_handler;

  /* Tell readline what the prompt to display is and what function it
     will need to call after a whole line is read. */
  strcpy (a_prompt, PREFIX (0));
  strcat (a_prompt, PROMPT (0));
  strcat (a_prompt, SUFFIX (0));
  rl_callback_handler_install (a_prompt, input_handler);

  /* Tell readline to use the same input stream that gdb uses. */
  rl_instream = instream;
  /* Get a file descriptor for the input stream, so that we can
     register it with the event loop. */
  input_fd = fileno (instream);

  /* Now we need to create the event sources for the input file descriptor. */
  /* At this point in time, this is the only event source that we
     register with the even loop. Another source is going to be the
     target program (inferior), but that must be registered only when
     it actually exists (I.e. after we say 'run' or after we connect
     to a remote target. */
#ifdef HAVE_POLL
  create_file_handler (input_fd, POLLIN,
		       (file_handler_func *) call_readline, 0);
#else
  create_file_handler (input_fd, GDB_READABLE,
		       (file_handler_func *) call_readline, 0);
#endif

  /* Loop until there is something to do. This is the entry point to
     the event loop engine. gdb_do_one_event will process one event
     for each invocation.  It always returns 1, unless there are no
     more event sources registered. In this case it returns 0.  */
  while (gdb_do_one_event () != 0)
    ;
d195 2
a196 3
  /* We are done with the event loop. There are no more event sources
     to listen to.  So we exit GDB. */
  return;
d205 2
a206 2
void
change_line_handler ()
d208 6
d217 2
a218 1
      call_readline = rl_callback_read_char;
d225 4
a229 13

  /* To tell the event loop to change the handler associated with the
     input file descriptor, we need to create a new event source,
     corresponding to the same fd, but with a new event handler
     function. */
  delete_file_handler (input_fd);
#ifdef HAVE_POLL
  create_file_handler (input_fd, POLLIN,
		       (file_handler_func *) call_readline, 0);
#else
  create_file_handler (input_fd, GDB_READABLE,
		       (file_handler_func *) call_readline, 0);
#endif
d236 2
a237 2
   1. when the user enters a command line which is ended by '\' 
   indicating that the command will continue on the next line. 
d239 3
a241 3
   2. When the user is entering 'commands' for a breakpoint, or 
   actions for a tracepoint. In this case the prompt will be '>' 
   3. Other???? 
d244 1
a244 2
display_gdb_prompt (new_prompt)
     char *new_prompt;
d247 29
d282 1
a282 1
	strlen (PROMPT (0)) + 1;
d288 1
a288 1
      strcat (new_prompt, PROMPT (0));
d299 1
d320 3
a322 3
   to be the normal ones (1 or 2). */
void
change_annotation_level ()
d366 2
a367 5
static void
push_prompt (prefix, prompt, suffix)
     char *prefix;
     char *prompt;
     char *suffix;
d372 3
d384 2
a385 2
static void
pop_prompt ()
d387 12
a398 5
  if (strcmp (PROMPT (0), PROMPT (-1)))
    {
      free (PROMPT (-1));
      PROMPT (-1) = savestring (PROMPT (0), strlen (PROMPT (0)));
    }
d405 56
d462 1
d466 1
a466 1
/* NOTE: 4/30/99 This is the asynchronous version of the command_loop
d469 2
a470 3
void
command_handler (command)
     char *command;
d474 2
d517 61
a577 1
  /* Do any commands attached to breakpoint we stopped at.  */
d579 1
a579 1
  do_cleanups (old_chain);
a587 1

d608 1
a608 1
/* NOTE: 4/30/99 This is the asynchronous version of the
d613 1
a613 2
command_line_handler (rl)
     char *rl;
a618 1
  int change_prompt = 0;
d648 1
a648 1
      change_prompt = 1;
d653 1
a653 1
    signal (STOP_SIGNAL, stop_sig);
d695 1
a695 1
  if (p == linebuffer || *(p - 1) == '\\')
a696 1
      /* We come here also if the line entered is empty (just a 'return') */
a707 1
	  display_gdb_prompt ("");
d709 3
d825 1
a825 1
/* NOTE: 4/30/99 Asynchronous version of gdb_readline. gdb_readline
d828 2
a829 2
static void
gdb_readline2 ()
d835 13
d872 1
a872 1
	  command_line_handler (0);
d895 1
a895 1
  command_line_handler (result);
d908 1
a908 1
/* NOTE: 4/30/99 This is the asynchronous version of init_signals.
d912 1
a912 1
async_init_signals ()
d916 1
a916 1
    create_async_signal_handler ((async_handler_func *) async_request_quit, NULL);
d934 1
a934 1
    create_async_signal_handler ((async_handler_func *) async_do_nothing, NULL);
d938 1
a938 1
      create_async_signal_handler ((async_handler_func *) async_disconnect, NULL);
d941 1
a941 1
      create_async_signal_handler ((async_handler_func *) async_do_nothing, NULL);
d945 1
a945 1
    create_async_signal_handler ((async_handler_func *) async_float_handler, NULL);
d950 5
a954 1
    create_async_signal_handler ((async_handler_func *) SIGWINCH_HANDLER, NULL);
d956 7
d967 2
a968 3
void 
handle_sigint (sig)
     int sig;
d980 1
a980 1
    async_request_quit ();
d984 1
a984 1
    mark_async_signal_handler (sigint_token);
d988 2
a989 2
void 
async_request_quit ()
d1001 2
a1002 3
void 
handle_sigquit (sig)
     int sig;
d1004 1
a1004 1
  mark_async_signal_handler (sigquit_token);
d1009 2
a1010 2
void 
async_do_nothing ()
d1018 1
a1018 1
void 
d1022 1
a1022 1
  mark_async_signal_handler (sighup_token);
d1026 3
a1028 3
/* Called by the event loop to process a SIGHUP. */
void 
async_disconnect ()
d1038 36
d1076 2
a1077 3
void 
handle_sigfpe (sig)
     int sig;
d1079 1
a1079 1
  mark_async_signal_handler (sigfpe_token);
d1084 2
a1085 2
void 
async_float_handler ()
d1095 2
a1096 3
void 
handle_sigwinch (sig)
     int sig;
d1098 1
a1098 1
  mark_async_signal_handler (sigwinch_token);
d1107 1
a1107 4
set_async_editing_command (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
d1115 1
a1115 4
set_async_annotation_level (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
d1123 1
a1123 4
set_async_prompt (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
d1128 42
a1169 3



@


1.1.1.1
log
@import gdb-1999-05-10
@
text
@@


1.1.1.2
log
@import gdb-1999-05-25 snapshot
@
text
@a40 3
static void change_line_handler PARAMS ((void));
static void change_annotation_level PARAMS ((void));
static void command_handler PARAMS ((char *));
d107 1
a107 1
   ezannoni: as of 1999-04-29 I expect that this
d222 1
a222 1
static void
d311 1
a311 1
static void
d392 1
a392 1
/* NOTE: 1999-04-30 This is the asynchronous version of the command_loop
d395 1
a395 1
static void
d474 1
a474 1
/* NOTE: 1999-04-30 This is the asynchronous version of the
d692 1
a692 1
/* NOTE: 1999-04-30 Asynchronous version of gdb_readline. gdb_readline
d762 1
a762 1
/* NOTE: 1999-04-30 This is the asynchronous version of init_signals.
@


1.1.1.3
log
@import gdb-1999-06-14 snapshot
@
text
@a22 1
#include "top.h"
a26 1
#include "terminal.h" /* for job_control*/
d35 1
a35 1
extern void _initialize_event_loop (void);
d46 5
a50 12
static void handle_sigint PARAMS ((int));
static void handle_sigquit PARAMS ((int));
static void handle_sighup PARAMS ((int));
static void handle_sigfpe PARAMS ((int));
static void handle_sigwinch PARAMS ((int));
/* Signal to catch ^Z typed while reading a command: SIGTSTP or SIGCONT.  */
#ifndef STOP_SIGNAL
#ifdef SIGTSTP
#define STOP_SIGNAL SIGTSTP
void handle_stop_sig PARAMS ((int));
#endif
#endif
d54 18
a71 5
void async_request_quit PARAMS ((gdb_client_data));
static void async_do_nothing PARAMS ((gdb_client_data));
static void async_disconnect PARAMS ((gdb_client_data));
static void async_float_handler PARAMS ((gdb_client_data));
static void async_stop_sig PARAMS ((gdb_client_data));
d79 3
d109 1
a109 1
   form of the set editing command.
d138 1
a138 1
PTR sigint_token;
d140 1
a140 1
PTR sighup_token;
d142 2
a143 2
PTR sigquit_token;
PTR sigfpe_token;
d145 1
a145 1
PTR sigwinch_token;
a146 5
#ifdef STOP_SIGNAL
PTR sigtstp_token;
#endif

void mark_async_signal_handler_wrapper PARAMS ((void *));
d166 1
a166 1
start_event_loop ()
d168 24
a191 2
  int length;
  char *a_prompt;
d193 13
a205 16
  /* If we are using readline, set things up and display the first
     prompt, otherwise just print the prompt. */
  if (async_command_editing_p)
    {
      /* Tell readline what the prompt to display is and what function it
	 will need to call after a whole line is read. This also displays
	 the first prompt.*/
      length = strlen (PREFIX (0)) + strlen (PROMPT (0)) + strlen (SUFFIX (0)) + 1;
      a_prompt = (char *) xmalloc (length);
      strcpy (a_prompt, PREFIX (0));
      strcat (a_prompt, PROMPT (0));
      strcat (a_prompt, SUFFIX (0));
      rl_callback_handler_install (a_prompt, input_handler);
    }
  else
    display_gdb_prompt (0);
a231 1
      input_handler = command_line_handler;
a237 4

      /* Set up the command handler as well, in case we are called as
	 first thing from .gdbinit. */
      input_handler = command_line_handler;
d258 2
a259 2
   1. when the user enters a command line which is ended by '\'
   indicating that the command will continue on the next line.
d261 3
a263 3
   2. When the user is entering 'commands' for a breakpoint, or
   actions for a tracepoint. In this case the prompt will be '>'
   3. Other????
d524 1
a524 1
    signal (STOP_SIGNAL, handle_stop_sig);
d729 1
a729 1
	  (*input_handler) (0);
d752 1
a752 1
  (*input_handler) (result);
d770 1
a770 1
{  
d773 1
a773 1
    create_async_signal_handler (async_request_quit, NULL);
d791 1
a791 1
    create_async_signal_handler (async_do_nothing, NULL);
d795 1
a795 1
      create_async_signal_handler (async_disconnect, NULL);
d798 1
a798 1
      create_async_signal_handler (async_do_nothing, NULL);
d802 1
a802 1
    create_async_signal_handler (async_float_handler, NULL);
d807 1
a807 1
    create_async_signal_handler (SIGWINCH_HANDLER, NULL);
a808 12
#ifdef STOP_SIGNAL
  sigtstp_token =
    create_async_signal_handler (async_stop_sig, NULL);
#endif

}

void 
mark_async_signal_handler_wrapper (token)
     void *token;
{
  mark_async_signal_handler ((async_signal_handler *) token);
d813 1
a813 1
static void 
d827 1
a827 1
    async_request_quit (0);
d831 1
a831 1
    mark_async_signal_handler_wrapper (sigint_token);
d836 1
a836 2
async_request_quit (arg)
     gdb_client_data arg;
d848 1
a848 1
static void 
d852 1
a852 1
  mark_async_signal_handler_wrapper (sigquit_token);
d857 2
a858 3
static void 
async_do_nothing (arg)
     gdb_client_data arg;
d866 1
a866 1
static void 
d870 1
a870 1
  mark_async_signal_handler_wrapper (sighup_token);
d874 3
a876 4
/* Called by the event loop to process a SIGHUP */
static void 
async_disconnect (arg)
     gdb_client_data arg;
a885 29
#ifdef STOP_SIGNAL
void handle_stop_sig (sig)
     int sig;
{
 mark_async_signal_handler_wrapper (sigtstp_token);
 signal (sig, handle_stop_sig);
}

static void
async_stop_sig (arg)
     gdb_client_data arg;
{
 char *prompt = PROMPT (0);
#if STOP_SIGNAL == SIGTSTP
  signal (SIGTSTP, SIG_DFL);
  sigsetmask (0);
  kill (getpid (), SIGTSTP);
  signal (SIGTSTP, handle_stop_sig);
#else
  signal (STOP_SIGNAL, handle_stop_sig);
#endif
  printf_unfiltered ("%s", prompt);
  gdb_flush (gdb_stdout);

  /* Forget about any previous command -- null line now will do nothing.  */
  dont_repeat ();
}
#endif /* STOP_SIGNAL */

d888 1
a888 1
static void 
d892 1
a892 1
  mark_async_signal_handler_wrapper (sigfpe_token);
d897 2
a898 3
static void 
async_float_handler (arg)
     gdb_client_data arg;
d908 1
a908 1
static void 
d912 1
a912 1
  mark_async_signal_handler_wrapper (sigwinch_token);
a950 9
/* Set things up for readline to be invoked via the alternate
   interface, i.e. via a callback function (rl_callback_read_char),
   and hook up instream to the event loop.*/
void
_initialize_event_loop ()
{
  /* When a character is detected on instream by select or poll, readline
     will be invoked via this callback function. */
  call_readline = rl_callback_read_char;
a951 11
  /* When readline has read an end-of-line character, it passes the
     complete line to gdb for processing. command_line_handler is the
     function that does this. */
  input_handler = command_line_handler;

  /* Tell readline to use the same input stream that gdb uses. */
  rl_instream = instream;

  /* Get a file descriptor for the input stream, so that we can
     register it with the event loop. */
  input_fd = fileno (instream);
a952 14
  /* Now we need to create the event sources for the input file descriptor. */
  /* At this point in time, this is the only event source that we
     register with the even loop. Another source is going to be the
     target program (inferior), but that must be registered only when
     it actually exists (I.e. after we say 'run' or after we connect
     to a remote target. */
#ifdef HAVE_POLL
  create_file_handler (input_fd, POLLIN,
		       (file_handler_func *) call_readline, 0);
#else
  create_file_handler (input_fd, GDB_READABLE,
		       (file_handler_func *) call_readline, 0);
#endif
}
@


1.1.1.4
log
@import gdb-1999-06-21 snapshot
@
text
@d22 1
d25 1
a25 1
#include <poll.h>
a28 2
#include <signal.h>
#include "event-loop.h"
d37 1
a37 1
extern void _initialize_event_loop PARAMS ((void));
a167 1
  char *gdb_prompt = get_prompt ();
d176 1
a176 1
      length = strlen (PREFIX (0)) + strlen (gdb_prompt) + strlen (SUFFIX (0)) + 1;
d179 1
a179 1
      strcat (a_prompt, gdb_prompt);
a253 1
  char *gdb_prompt  = get_prompt ();
d260 1
a260 1
	strlen (gdb_prompt) + 1;
d266 1
a266 1
      strcat (new_prompt, gdb_prompt);
d897 1
a897 1
 char *prompt = get_prompt ();
d986 22
a1007 25
  if (async_p)
    {
      /* When a character is detected on instream by select or poll,
	 readline will be invoked via this callback function. */
      call_readline = rl_callback_read_char;

      /* When readline has read an end-of-line character, it passes
	 the complete line to gdb for processing. command_line_handler
	 is the function that does this. */
      input_handler = command_line_handler;

      /* Tell readline to use the same input stream that gdb uses. */
      rl_instream = instream;

      /* Get a file descriptor for the input stream, so that we can
	 register it with the event loop. */
      input_fd = fileno (instream);

      /* Now we need to create the event sources for the input file
         descriptor. */
      /* At this point in time, this is the only event source that we
	 register with the even loop. Another source is going to be
	 the target program (inferior), but that must be registered
	 only when it actually exists (I.e. after we say 'run' or
	 after we connect to a remote target. */
d1009 2
a1010 2
      create_file_handler (input_fd, POLLIN,
			   (file_handler_func *) call_readline, 0);
d1012 2
a1013 2
      create_file_handler (input_fd, GDB_READABLE,
			   (file_handler_func *) call_readline, 0);
a1014 1
    }
@


1.1.1.5
log
@import gdb-1999-06-28 snapshot
@
text
@d23 3
d41 1
a41 1
void gdb_readline2 PARAMS ((void));
d163 1
a163 1
   register readline, and stdin, start the loop. */
d165 1
a165 1
cli_command_loop ()
d188 10
a197 2
  /* Now it's time to start the event loop. */
  start_event_loop ();
a229 5
  /* NOTE: this operates on input_fd, not instream. If we are reading
     commands from a file, instream will point to the file. However in
     async mode, we always read commands from a file with editing
     off. This means that the 'set editing on/off' will have effect
     only on the interactive session. */
d231 7
a237 1
  add_file_handler (input_fd, (file_handler_func *) call_readline, 0);
d685 1
a685 1
void
d1004 1
a1004 1
         register it with the event loop. */
a1006 3
      /* Tell gdb to use the cli_command_loop as the main loop. */
      command_loop_hook = cli_command_loop;

d1014 7
a1020 6
      add_file_handler (input_fd, (file_handler_func *) call_readline, 0);
      
      /* Tell gdb that we will be using the readline library. This
	 could be overwritten by a command in .gdbinit like 'set
	 editing on' or 'off'. */
      async_command_editing_p = 1;
@


1.1.1.6
log
@import gdb-1999-07-05 snapshot
@
text
@a37 1
static void command_line_handler_continuation PARAMS ((struct continuation_arg *));
d39 2
a40 2
void pop_prompt PARAMS ((void));
void push_prompt PARAMS ((char *, char *, char *));
d46 1
a46 1
void handle_sigint PARAMS ((int));
d334 1
a334 1
void
a342 3
  /* Note that this function is used by the set annotate 2
     command. This is why we take care of saving the old prompt
     in case a new one is not specified. */
d352 1
a352 1
void
d355 5
a359 12
  /* If we are not during a 'synchronous' execution command, in which
     case, the top prompt would be empty. */
  if (strcmp (PROMPT (0), ""))
    /* This is for the case in which the prompt is set while the
       annotation level is 2. The top prompt will be changed, but when
       we return to annotation level < 2, we want that new prompt to be
       in effect, until the user does another 'set prompt'. */
    if (strcmp (PROMPT (0), PROMPT (-1)))
      {
	free (PROMPT (-1));
	PROMPT (-1) = savestring (PROMPT (0), strlen (PROMPT (0)));
      }
a378 2
  struct continuation_arg *arg1;
  struct continuation_arg *arg2;
a418 28
 
  /* Set things up for this function to be compete later, once the
     executin has completed, if we are doing an execution command,
     otherwise, just go ahead and finish. */
  if (target_has_async && target_executing)
    {
      arg1 = 
	(struct continuation_arg *) xmalloc (sizeof (struct continuation_arg));
      arg2 = 
	(struct continuation_arg *) xmalloc (sizeof (struct continuation_arg));
      arg1->next = arg2;
      arg2->next = NULL;
      arg1->data = (PTR) time_at_cmd_start;
      arg2->data = (PTR) space_at_cmd_start;
      add_continuation (command_line_handler_continuation, arg1);
    }

  /* Do any commands attached to breakpoint we stopped at. Only if we
     are always running synchronously. Or if we have just executed a
     command that doesn't start the target. */
  if (!target_has_async || !target_executing)
    {
      bpstat_do_actions (&stop_bpstat);
      do_cleanups (old_chain);
    
      if (display_time)
	{
	  long cmd_time = get_run_time () - time_at_cmd_start;
d420 3
a422 33
	  printf_unfiltered ("Command execution time: %ld.%06ld\n",
			     cmd_time / 1000000, cmd_time % 1000000);
	}

      if (display_space)
	{
#ifdef HAVE_SBRK
	  extern char **environ;
	  char *lim = (char *) sbrk (0);
	  long space_now = lim - (char *) &environ;
	  long space_diff = space_now - space_at_cmd_start;

	  printf_unfiltered ("Space used: %ld (%c%ld for this command)\n",
			     space_now,
			     (space_diff >= 0 ? '+' : '-'),
			     space_diff);
#endif
	}
    }
}

/* Do any commands attached to breakpoint we stopped at. Only if we
   are always running synchronously. Or if we have just executed a
   command that doesn't start the target. */
void
command_line_handler_continuation (arg)
     struct continuation_arg *arg;
{ 
  extern int display_time;
  extern int display_space;

  long time_at_cmd_start = (long) arg->data;
  long space_at_cmd_start = (long) arg->next->data;
a423 3
  bpstat_do_actions (&stop_bpstat);
  /*do_cleanups (old_chain);*/  /*?????FIXME?????*/
    
d431 1
d800 1
a800 1
void 
@


1.1.1.7
log
@import gdb-1999-07-07 post reformat
@
text
@d19 1
a19 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA. */
d24 1
a24 1
#include "terminal.h"		/* for job_control */
d174 2
a175 2
         will need to call after a whole line is read. This also displays
         the first prompt. */
d212 1
a212 1
         first thing from .gdbinit. */
d245 1
a245 1
  char *gdb_prompt = get_prompt ();
d432 1
a432 1

d438 1
a438 1
      arg1 =
d440 1
a440 1
      arg2 =
d456 1
a456 1

d488 1
a488 1
{
d496 2
a497 2
  /*do_cleanups (old_chain); *//*?????FIXME????? */

d818 1
a818 1
{
d864 1
a864 1
void
d873 1
a873 1
void
d895 1
a895 1
void
d909 1
a909 1
static void
d918 1
a918 1
static void
d928 1
a928 1
static void
d937 1
a937 1
static void
d950 1
a950 2
void
handle_stop_sig (sig)
d953 2
a954 2
  mark_async_signal_handler_wrapper (sigtstp_token);
  signal (sig, handle_stop_sig);
d961 1
a961 1
  char *prompt = get_prompt ();
d980 1
a980 1
static void
d989 1
a989 1
static void
d1001 1
a1001 1
static void
d1046 1
a1046 1
   and hook up instream to the event loop. */
d1053 1
a1053 1
         readline will be invoked via this callback function. */
d1057 2
a1058 2
         the complete line to gdb for processing. command_line_handler
         is the function that does this. */
d1074 4
a1077 4
         register with the even loop. Another source is going to be
         the target program (inferior), but that must be registered
         only when it actually exists (I.e. after we say 'run' or
         after we connect to a remote target. */
d1079 1
a1079 1

d1081 2
a1082 2
         could be overwritten by a command in .gdbinit like 'set
         editing on' or 'off'. */
d1086 1
@


1.1.1.8
log
@import gdb-1999-07-19 snapshot
@
text
@a247 22

  if (target_executing && sync_execution) 
    {
      /* This is to trick readline into not trying to display the
	 prompt.  Even though we display the prompt using this
	 function, readline still tries to do its own display if we
	 don't call rl_callback_handler_install and
	 rl_callback_handler_remove (which readline detects because a
	 global variable is not set). If readline did that, it could
	 mess up gdb signal handlers for SIGINT.  Readline assumes
	 that between calls to rl_set_signals and rl_clear_signals gdb
	 doesn't do anything with the signal handlers. Well, that's
	 not the case, because when the target executes we change the
	 SIGINT signal handler. If we allowed readline to display the
	 prompt, the signal handler change would happen exactly
	 between the calls to the above two functions.
	 Calling rl_callback_handler_remove(), does the job. */

      rl_callback_handler_remove ();
      return;
    }

a269 1
  /* new_prompt at this point can be the top of the stack or the one passed in */
d290 1
a290 1
   to be the normal ones (1 or 0). */
d538 1
d568 1
a568 1
      pop_prompt ();
d629 1
a630 3
	  push_prompt ("", "", "");
	  display_gdb_prompt (0);
	  return;
@


1.1.1.9
log
@import gdb-1999-08-02 snapshot
@
text
@d637 1
a637 1
  if (*(p - 1) == '\\')
d639 1
@


1.1.1.10
log
@import gdb-1999-08-16 snapshot
@
text
@d227 1
a227 1
  add_file_handler (input_fd, call_readline, 0);
a776 13
  static int done_once = 0;

  /* Unbuffer the input stream, so that, later on, the calls to fgetc
     fetch only one char at the time from the stream. The fgetc's will
     get up to the first newline, but there may be more chars in the
     stream after '\n'. If we buffer the input and fgetc drains the
     stream, getting stuff beyond the newline as well, a select, done
     afterwards will not trigger. */
  if (!done_once && !ISATTY (instream))
    {
      setbuf (instream, NULL);
      done_once = 1;
    }
d1103 1
a1103 1
      add_file_handler (input_fd, call_readline, 0);
@


1.1.1.11
log
@import gdb-1999-08-30 snapshot
@
text
@a28 3
/* For dont_repeat() */
#include "gdbcmd.h"

d63 1
d69 6
a115 4
/* This is used to display the notification of the completion of an
   asynchronous execution command. */
int exec_done_display_p = 0;

d143 2
@


1.1.1.12
log
@import gdb-1999-09-08 snapshot
@
text
@a54 1
#if defined(SIGWINCH) && defined(SIGWINCH_HANDLER)
a55 1
#endif
@


1.1.1.13
log
@import gdb-1999-09-21
@
text
@d26 1
a26 1
#include "signals.h"
a27 1
#include "event-top.h"
d39 1
a39 1
extern void _initialize_event_loop (void);
d41 8
a48 11
static void rl_callback_read_char_wrapper (gdb_client_data client_data);
static void command_line_handler (char *rl);
static void command_line_handler_continuation (struct continuation_arg *arg);
static void change_line_handler (void);
static void change_annotation_level (void);
static void command_handler (char *command);
void cli_command_loop (void);
static void async_do_nothing (gdb_client_data arg);
static void async_disconnect (gdb_client_data arg);
static void async_stop_sig (gdb_client_data arg);
static void async_float_handler (gdb_client_data arg);
d51 4
a54 3
static void handle_sigquit (int sig);
static void handle_sighup (int sig);
static void handle_sigfpe (int sig);
d56 8
a63 1
static void handle_sigwinch (int sig);
d68 4
a71 4
static void async_do_nothing (gdb_client_data);
static void async_disconnect (gdb_client_data);
static void async_float_handler (gdb_client_data);
static void async_stop_sig (gdb_client_data);
d93 2
a94 2
void (*input_handler) (char *);
void (*call_readline) (gdb_client_data);
a160 9
/* Wrapper function foe calling into the readline library. The event
   loop expects the callback function to have a paramter, while readline 
   expects none. */
static void
rl_callback_read_char_wrapper (gdb_client_data client_data)
{
  rl_callback_read_char ();
}

d164 1
a164 1
cli_command_loop (void)
d198 1
a198 1
change_line_handler (void)
a199 6
  /* NOTE: this operates on input_fd, not instream. If we are reading
     commands from a file, instream will point to the file. However in
     async mode, we always read commands from a file with editing
     off. This means that the 'set editing on/off' will have effect
     only on the interactive session. */

d203 1
a203 1
      call_readline = rl_callback_read_char_wrapper;
d216 12
d242 2
a243 1
display_gdb_prompt (char *new_prompt)
d315 1
a315 1
change_annotation_level (void)
d360 4
a363 1
push_prompt (char *prefix, char *prompt, char *suffix)
d381 1
a381 1
pop_prompt (void)
a400 20

/* When there is an event ready on the stdin file desriptor, instead
   of calling readline directly throught the callback function, or
   instead of calling gdb_readline2, give gdb a chance to detect
   errors and do something. */
void
stdin_event_handler (int error, int fd, gdb_client_data client_data)
{
  if (error)
    {
      printf_unfiltered ("error detected on stdin, fd %d\n", fd);
      delete_file_handler (fd);
      discard_all_continuations ();
      /* If stdin died, we may as well kill gdb. */
      exit (1);
    }
  else
    (*call_readline) (client_data);      
}

d409 2
a410 1
command_handler (char *command)
d510 2
a511 1
command_line_handler_continuation (struct continuation_arg *arg)
d554 2
a555 1
command_line_handler (char *rl)
d771 1
a771 1
gdb_readline2 (gdb_client_data client_data)
d854 1
a854 1
async_init_signals (void)
d902 2
a903 1
mark_async_signal_handler_wrapper (PTR token)
d905 1
a905 1
  mark_async_signal_handler ((struct async_signal_handler *) token);
d911 2
a912 1
handle_sigint (int sig)
d933 2
a934 1
async_request_quit (gdb_client_data arg)
d947 2
a948 1
handle_sigquit (int sig)
d956 2
a957 1
async_do_nothing (gdb_client_data arg)
d975 2
a976 1
async_disconnect (gdb_client_data arg)
d988 2
a989 1
handle_stop_sig (int sig)
d996 2
a997 1
async_stop_sig (gdb_client_data arg)
d1019 2
a1020 1
handle_sigfpe (int sig)
d1028 2
a1029 1
async_float_handler (gdb_client_data arg)
d1040 2
a1041 1
handle_sigwinch (int sig)
d1052 4
a1055 1
set_async_editing_command (char *args, int from_tty, struct cmd_list_element *c)
d1063 4
a1066 1
set_async_annotation_level (char *args, int from_tty, struct cmd_list_element *c)
d1074 4
a1077 1
set_async_prompt (char *args, int from_tty, struct cmd_list_element *c)
d1086 1
a1086 1
_initialize_event_loop (void)
d1092 1
a1092 1
      call_readline = rl_callback_read_char_wrapper;
d1116 1
a1116 1
      add_file_handler (input_fd, stdin_event_handler, 0);
@


1.1.1.14
log
@import gdb-1999-09-28 snapshot
@
text
@d247 1
a247 1
  if (target_executing && sync_execution)
d250 13
a262 13
         prompt.  Even though we display the prompt using this
         function, readline still tries to do its own display if we
         don't call rl_callback_handler_install and
         rl_callback_handler_remove (which readline detects because a
         global variable is not set). If readline did that, it could
         mess up gdb signal handlers for SIGINT.  Readline assumes
         that between calls to rl_set_signals and rl_clear_signals gdb
         doesn't do anything with the signal handlers. Well, that's
         not the case, because when the target executes we change the
         SIGINT signal handler. If we allowed readline to display the
         prompt, the signal handler change would happen exactly
         between the calls to the above two functions.
         Calling rl_callback_handler_remove(), does the job. */
d413 1
a413 1
    (*call_readline) (client_data);
a415 33
/* Re-enable stdin after the end of an execution command in
   synchronous mode, or after an error from the target, and we aborted
   the exec operation. */

void
async_enable_stdin (void *dummy)
{
  /* See NOTE in async_disable_stdin() */
  /* FIXME: cagney/1999-09-27: Call this before clearing
     sync_execution.  Current target_terminal_ours() implementations
     check for sync_execution before switching the terminal. */
  target_terminal_ours ();
  pop_prompt ();
  sync_execution = 0;
}

/* Disable reads from stdin (the console) marking the command as
   synchronous. */

void
async_disable_stdin (void)
{
  sync_execution = 1;
  push_prompt ("", "", "");
  /* FIXME: cagney/1999-09-27: At present this call is technically
     redundant since infcmd.c and infrun.c both already call
     target_terminal_inferior().  As the terminal handling (in
     sync/async mode) is refined, the duplicate calls can be
     eliminated (Here or in infcmd.c/infrun.c). */
  target_terminal_inferior ();
  make_exec_cleanup (async_enable_stdin, NULL);
  make_exec_error_cleanup (async_enable_stdin, NULL);
}
a416 1

d474 1
a474 1
  if (target_can_async_p () && target_executing)
d490 1
a490 1
  if (!target_can_async_p () || !target_executing)
d1080 1
a1080 1
  if (event_loop_p)
@


1.1.1.15
log
@import gdb-1999-10-04 snapshot
@
text
@a36 2
#include <signal.h>

d402 1
a402 1
stdin_event_handler (int error, gdb_client_data client_data)
d406 2
a407 2
      printf_unfiltered ("error detected on stdin\n");
      delete_file_handler (input_fd);
d446 1
a446 4
  /* Add the reinstate of stdin to the list of cleanups to be done
     in case the target errors out and dies. These cleanups are also
     done in case of normal successful termination of the execution
     command, by complete_execution(). */
a1039 7
#if HAVE_SIGPROCMASK
  {
    sigset_t zero;
    sigemptyset (&zero);
    sigprocmask (SIG_SETMASK, &zero, 0);
  }
#else
a1040 1
#endif
@


1.1.1.16
log
@import gdb-1999-10-25 snapshot
@
text
@a24 1
#include "target.h"
@


1.1.1.17
log
@import gdb-2000-01-17 snapshot
@
text
@d413 1
a413 1
      quit_command ((char *) 0, stdin == instream);
@


1.1.1.18
log
@import gdb-2000-02-02 snapshot
@
text
@d249 1
@


