head	1.35;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.35
	gdb_7_6-2013-04-26-release:1.35
	gdb_7_6-branch:1.35.0.2
	gdb_7_6-2013-03-12-branchpoint:1.35
	gdb_7_5_1-2012-11-29-release:1.34
	gdb_7_5-2012-08-17-release:1.34
	gdb_7_5-branch:1.34.0.2
	gdb_7_5-2012-07-18-branchpoint:1.34
	gdb_7_4_1-2012-04-26-release:1.33.2.1
	gdb_7_4-2012-01-24-release:1.33.2.1
	gdb_7_4-branch:1.33.0.2
	gdb_7_4-2011-12-13-branchpoint:1.33
	gdb_7_3_1-2011-09-04-release:1.32
	gdb_7_3-2011-07-26-release:1.32
	gdb_7_3-branch:1.32.0.2
	gdb_7_3-2011-04-01-branchpoint:1.32
	gdb_7_2-2010-09-02-release:1.27
	gdb_7_2-branch:1.27.0.2
	gdb_7_2-2010-07-07-branchpoint:1.27
	gdb_7_1-2010-03-18-release:1.26
	gdb_7_1-branch:1.26.0.2
	gdb_7_1-2010-02-18-branchpoint:1.26
	gdb_7_0_1-2009-12-22-release:1.24
	gdb_7_0-2009-10-06-release:1.24
	gdb_7_0-branch:1.24.0.4
	gdb_7_0-2009-09-16-branchpoint:1.24
	arc-sim-20090309:1.20
	msnyder-checkpoint-072509-branch:1.24.0.2
	msnyder-checkpoint-072509-branchpoint:1.24
	arc-insight_6_8-branch:1.20.0.6
	arc-insight_6_8-branchpoint:1.20
	insight_6_8-branch:1.20.0.4
	insight_6_8-branchpoint:1.20
	reverse-20081226-branch:1.23.0.6
	reverse-20081226-branchpoint:1.23
	multiprocess-20081120-branch:1.23.0.4
	multiprocess-20081120-branchpoint:1.23
	reverse-20080930-branch:1.23.0.2
	reverse-20080930-branchpoint:1.23
	reverse-20080717-branch:1.21.0.4
	reverse-20080717-branchpoint:1.21
	msnyder-reverse-20080609-branch:1.21.0.2
	msnyder-reverse-20080609-branchpoint:1.21
	drow-reverse-20070409-branch:1.18.0.2
	drow-reverse-20070409-branchpoint:1.18
	gdb_6_8-2008-03-27-release:1.20
	gdb_6_8-branch:1.20.0.2
	gdb_6_8-2008-02-26-branchpoint:1.20
	gdb_6_7_1-2007-10-29-release:1.19
	gdb_6_7-2007-10-10-release:1.19
	gdb_6_7-branch:1.19.0.2
	gdb_6_7-2007-09-07-branchpoint:1.19
	insight_6_6-20070208-release:1.17
	gdb_6_6-2006-12-18-release:1.17
	gdb_6_6-branch:1.17.0.18
	gdb_6_6-2006-11-15-branchpoint:1.17
	insight_6_5-20061003-release:1.17
	gdb-csl-symbian-6_4_50_20060226-12:1.17
	gdb-csl-sourcerygxx-3_4_4-25:1.16
	nickrob-async-20060828-mergepoint:1.17
	gdb-csl-symbian-6_4_50_20060226-11:1.17
	gdb-csl-sourcerygxx-4_1-17:1.17
	gdb-csl-20060226-branch-local-2:1.17
	gdb-csl-sourcerygxx-4_1-14:1.17
	gdb-csl-sourcerygxx-4_1-13:1.17
	gdb-csl-sourcerygxx-4_1-12:1.17
	gdb-csl-sourcerygxx-3_4_4-21:1.17
	gdb_6_5-20060621-release:1.17
	gdb-csl-sourcerygxx-4_1-9:1.17
	gdb-csl-sourcerygxx-4_1-8:1.17
	gdb-csl-sourcerygxx-4_1-7:1.17
	gdb-csl-arm-2006q1-6:1.17
	gdb-csl-sourcerygxx-4_1-6:1.17
	gdb-csl-symbian-6_4_50_20060226-10:1.17
	gdb-csl-symbian-6_4_50_20060226-9:1.17
	gdb-csl-symbian-6_4_50_20060226-8:1.17
	gdb-csl-coldfire-4_1-11:1.17
	gdb-csl-sourcerygxx-3_4_4-19:1.17
	gdb-csl-coldfire-4_1-10:1.17
	gdb_6_5-branch:1.17.0.16
	gdb_6_5-2006-05-14-branchpoint:1.17
	gdb-csl-sourcerygxx-4_1-5:1.17
	nickrob-async-20060513-branch:1.17.0.14
	nickrob-async-20060513-branchpoint:1.17
	gdb-csl-sourcerygxx-4_1-4:1.17
	msnyder-reverse-20060502-branch:1.17.0.12
	msnyder-reverse-20060502-branchpoint:1.17
	gdb-csl-morpho-4_1-4:1.17
	gdb-csl-sourcerygxx-3_4_4-17:1.17
	readline_5_1-import-branch:1.17.0.10
	readline_5_1-import-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.17
	gdb-csl-symbian-20060226-branch:1.17.0.8
	gdb-csl-symbian-20060226-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.17
	msnyder-reverse-20060331-branch:1.17.0.6
	msnyder-reverse-20060331-branchpoint:1.17
	gdb-csl-available-20060303-branch:1.17.0.4
	gdb-csl-available-20060303-branchpoint:1.17
	gdb-csl-20060226-branch:1.17.0.2
	gdb-csl-20060226-branchpoint:1.17
	gdb_6_4-20051202-release:1.16
	msnyder-fork-checkpoint-branch:1.16.0.12
	msnyder-fork-checkpoint-branchpoint:1.16
	gdb-csl-gxxpro-6_3-branch:1.16.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.16
	gdb_6_4-branch:1.16.0.8
	gdb_6_4-2005-11-01-branchpoint:1.16
	gdb-csl-arm-20051020-branch:1.16.0.6
	gdb-csl-arm-20051020-branchpoint:1.16
	msnyder-tracepoint-checkpoint-branch:1.16.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.16
	gdb-csl-arm-20050325-2005-q1b:1.16
	gdb-csl-arm-20050325-2005-q1a:1.16
	csl-arm-20050325-branch:1.16.0.2
	csl-arm-20050325-branchpoint:1.16
	gdb-post-i18n-errorwarning-20050211:1.16
	gdb-pre-i18n-errorwarning-20050211:1.16
	gdb_6_3-20041109-release:1.15
	gdb_6_3-branch:1.15.0.6
	gdb_6_3-20041019-branchpoint:1.15
	drow_intercu-merge-20040921:1.15
	drow_intercu-merge-20040915:1.15
	jimb-gdb_6_2-e500-branch:1.15.0.8
	jimb-gdb_6_2-e500-branchpoint:1.15
	gdb_6_2-20040730-release:1.15
	gdb_6_2-branch:1.15.0.4
	gdb_6_2-2004-07-10-gmt-branchpoint:1.15
	gdb_6_1_1-20040616-release:1.14
	gdb_6_1-2004-04-05-release:1.14
	drow_intercu-merge-20040402:1.15
	drow_intercu-merge-20040327:1.15
	ezannoni_pie-20040323-branch:1.15.0.2
	ezannoni_pie-20040323-branchpoint:1.15
	cagney_tramp-20040321-mergepoint:1.15
	cagney_tramp-20040309-branch:1.14.0.8
	cagney_tramp-20040309-branchpoint:1.14
	gdb_6_1-branch:1.14.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.14
	drow_intercu-20040221-branch:1.14.0.4
	drow_intercu-20040221-branchpoint:1.14
	cagney_bfdfile-20040213-branch:1.14.0.2
	cagney_bfdfile-20040213-branchpoint:1.14
	drow-cplus-merge-20040208:1.13
	carlton_dictionary-20040126-merge:1.13
	cagney_bigcore-20040122-branch:1.13.0.2
	cagney_bigcore-20040122-branchpoint:1.13
	drow-cplus-merge-20040113:1.13
	drow-cplus-merge-20031224:1.13
	drow-cplus-merge-20031220:1.13
	carlton_dictionary-20031215-merge:1.13
	drow-cplus-merge-20031214:1.13
	carlton-dictionary-20031111-merge:1.12
	gdb_6_0-2003-10-04-release:1.10
	kettenis_sparc-20030918-branch:1.10.0.50
	kettenis_sparc-20030918-branchpoint:1.10
	carlton_dictionary-20030917-merge:1.10
	ezannoni_pie-20030916-branchpoint:1.10
	ezannoni_pie-20030916-branch:1.10.0.48
	cagney_x86i386-20030821-branch:1.10.0.46
	cagney_x86i386-20030821-branchpoint:1.10
	carlton_dictionary-20030805-merge:1.10
	carlton_dictionary-20030627-merge:1.10
	gdb_6_0-branch:1.10.0.44
	gdb_6_0-2003-06-23-branchpoint:1.10
	jimb-ppc64-linux-20030613-branch:1.10.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.10
	cagney_convert-20030606-branch:1.10.0.40
	cagney_convert-20030606-branchpoint:1.10
	cagney_writestrings-20030508-branch:1.10.0.38
	cagney_writestrings-20030508-branchpoint:1.10
	jimb-ppc64-linux-20030528-branch:1.10.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.10
	carlton_dictionary-20030523-merge:1.10
	cagney_fileio-20030521-branch:1.10.0.34
	cagney_fileio-20030521-branchpoint:1.10
	kettenis_i386newframe-20030517-mergepoint:1.10
	jimb-ppc64-linux-20030509-branch:1.10.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.10
	kettenis_i386newframe-20030504-mergepoint:1.10
	carlton_dictionary-20030430-merge:1.10
	kettenis_i386newframe-20030419-branch:1.10.0.30
	kettenis_i386newframe-20030419-branchpoint:1.10
	carlton_dictionary-20030416-merge:1.10
	cagney_frameaddr-20030409-mergepoint:1.10
	kettenis_i386newframe-20030406-branch:1.10.0.28
	kettenis_i386newframe-20030406-branchpoint:1.10
	cagney_frameaddr-20030403-branchpoint:1.10
	cagney_frameaddr-20030403-branch:1.10.0.26
	cagney_framebase-20030330-mergepoint:1.10
	cagney_framebase-20030326-branch:1.10.0.24
	cagney_framebase-20030326-branchpoint:1.10
	cagney_lazyid-20030317-branch:1.10.0.22
	cagney_lazyid-20030317-branchpoint:1.10
	kettenis-i386newframe-20030316-mergepoint:1.10
	offbyone-20030313-branch:1.10.0.20
	offbyone-20030313-branchpoint:1.10
	kettenis-i386newframe-20030308-branch:1.10.0.18
	kettenis-i386newframe-20030308-branchpoint:1.10
	carlton_dictionary-20030305-merge:1.10
	cagney_offbyone-20030303-branch:1.10.0.16
	cagney_offbyone-20030303-branchpoint:1.10
	carlton_dictionary-20030207-merge:1.10
	interps-20030203-mergepoint:1.10
	interps-20030202-branch:1.10.0.14
	interps-20030202-branchpoint:1.10
	cagney-unwind-20030108-branch:1.10.0.12
	cagney-unwind-20030108-branchpoint:1.10
	carlton_dictionary-20021223-merge:1.10
	gdb_5_3-2002-12-12-release:1.10
	carlton_dictionary-20021115-merge:1.10
	kseitz_interps-20021105-merge:1.10
	kseitz_interps-20021103-merge:1.10
	drow-cplus-merge-20021020:1.10
	drow-cplus-merge-20021025:1.10
	carlton_dictionary-20021025-merge:1.10
	carlton_dictionary-20021011-merge:1.10
	drow-cplus-branch:1.10.0.10
	drow-cplus-branchpoint:1.10
	kseitz_interps-20020930-merge:1.10
	carlton_dictionary-20020927-merge:1.10
	carlton_dictionary-branch:1.10.0.8
	carlton_dictionary-20020920-branchpoint:1.10
	gdb_5_3-branch:1.10.0.6
	gdb_5_3-2002-09-04-branchpoint:1.10
	kseitz_interps-20020829-merge:1.10
	cagney_sysregs-20020825-branch:1.10.0.4
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.10.0.2
	readline_4_3-import-branchpoint:1.10
	gdb_5_2_1-2002-07-23-release:1.7.2.1
	kseitz_interps-20020528-branch:1.8.0.6
	kseitz_interps-20020528-branchpoint:1.8
	cagney_regbuf-20020515-branch:1.8.0.4
	cagney_regbuf-20020515-branchpoint:1.8
	jimb-macro-020506-branch:1.8.0.2
	jimb-macro-020506-branchpoint:1.8
	gdb_5_2-2002-04-29-release:1.7.2.1
	gdb_5_2-branch:1.7.0.2
	gdb_5_2-2002-03-03-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.6
	gdb_5_1_0_1-2002-01-03-release:1.6
	cygnus_cvs_20020108_pre:1.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.6.0.8
	gdb_5_1-2001-11-21-release:1.6
	gdb_s390-2001-09-26-branch:1.6.0.6
	gdb_s390-2001-09-26-branchpoint:1.6
	gdb_5_1-2001-07-29-branch:1.6.0.4
	gdb_5_1-2001-07-29-branchpoint:1.6
	dberlin-typesystem-branch:1.6.0.2
	dberlin-typesystem-branchpoint:1.6
	gdb-post-ptid_t-2001-05-03:1.6
	gdb-pre-ptid_t-2001-05-03:1.6
	insight-precleanup-2001-01-01:1.5
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.2.2.1
	gdb_4_18_2-2000-05-18-release:1.2.2.1
	gdb_4_95_1-2000-05-11-snapshot:1.2.2.1
	gdb_4_95_0-2000-04-27-snapshot:1.2.2.1
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.35
date	2013.01.01.06.32.39;	author brobecke;	state Exp;
branches;
next	1.34;

1.34
date	2012.01.04.08.16.59;	author brobecke;	state Exp;
branches;
next	1.33;

1.33
date	2011.12.05.03.58.23;	author ndreys;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2011.01.05.22.22.47;	author msnyder;	state Exp;
branches;
next	1.31;

1.31
date	2011.01.01.15.32.57;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2010.12.29.21.44.26;	author msnyder;	state Exp;
branches;
next	1.29;

1.29
date	2010.09.27.17.41.36;	author tromey;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.31.17.26.08;	author swagiaal;	state Exp;
branches;
next	1.27;

1.27
date	2010.05.13.22.04.58;	author msnyder;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.12.21.40.24;	author vprus;	state Exp;
branches;
next	1.25;

1.25
date	2010.01.01.07.31.30;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.03.05.57.50;	author brobecke;	state Exp;
branches;
next	1.23;

1.23
date	2008.08.05.20.43.17;	author tromey;	state Exp;
branches;
next	1.22;

1.22
date	2008.08.05.20.41.16;	author tromey;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.05.19.21.55;	author aristovski;	state Exp;
branches;
next	1.20;

1.20
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2007.08.23.18.08.26;	author brobecke;	state Exp;
branches;
next	1.18;

1.18
date	2007.01.09.17.58.49;	author drow;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.29.17.53.25;	author ibr;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.20.09.53.03;	author hilfingr;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.09.23.50.55;	author ezannoni;	state Exp;
branches
	1.14.4.1
	1.14.8.1;
next	1.13;

1.13
date	2003.11.15.19.39.04;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.07.22.04.39;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.03.17.03.11;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.29.22.55.26;	author cagney;	state Exp;
branches
	1.10.8.1
	1.10.10.1;
next	1.9;

1.9
date	2002.07.12.15.23.10;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.15.05.23.01;	author cagney;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	2002.02.23.03.57.26;	author jimb;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.03.06.08.21.05;	author kevinb;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.12.15.01.01.45;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.05.20.49.53;	author dberlin;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.19.07.08.35;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.08.04.39.01;	author kingdon;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.33.2.1
date	2012.01.06.04.43.05;	author brobecke;	state Exp;
branches;
next	;

1.14.4.1
date	2004.03.27.17.37.44;	author drow;	state Exp;
branches;
next	;

1.14.8.1
date	2004.03.21.23.57.33;	author cagney;	state Exp;
branches;
next	;

1.10.8.1
date	2003.11.11.23.50.38;	author carlton;	state Exp;
branches;
next	1.10.8.2;

1.10.8.2
date	2003.12.16.00.00.13;	author carlton;	state Exp;
branches;
next	;

1.10.10.1
date	2003.12.14.20.27.07;	author drow;	state Exp;
branches;
next	;

1.8.6.1
date	2002.07.22.21.46.55;	author kseitz;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2002.08.09.18.34.23;	author kseitz;	state Exp;
branches;
next	;

1.7.2.1
date	2002.04.15.05.22.18;	author cagney;	state Exp;
branches;
next	;

1.6.2.1
date	2001.07.06.19.16.57;	author dberlin;	state Exp;
branches;
next	;

1.2.2.1
date	2000.04.19.07.08.34;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.33.58;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.23.39;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.04.22;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.12.07.03.55.58;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Implement a cached obstack.
   Written by Fred Fish <fnf@@cygnus.com>
   Rewritten by Jim Blandy <jimb@@cygnus.com>

   Copyright (C) 1999-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdb_obstack.h"
#include "bcache.h"
#include "gdb_string.h"		/* For memcpy declaration */
#include "gdb_assert.h"

#include <stddef.h>
#include <stdlib.h>

/* The type used to hold a single bcache string.  The user data is
   stored in d.data.  Since it can be any type, it needs to have the
   same alignment as the most strict alignment of any type on the host
   machine.  I don't know of any really correct way to do this in
   stock ANSI C, so just do it the same way obstack.h does.  */

struct bstring
{
  /* Hash chain.  */
  struct bstring *next;
  /* Assume the data length is no more than 64k.  */
  unsigned short length;
  /* The half hash hack.  This contains the upper 16 bits of the hash
     value and is used as a pre-check when comparing two strings and
     avoids the need to do length or memcmp calls.  It proves to be
     roughly 100% effective.  */
  unsigned short half_hash;

  union
  {
    char data[1];
    double dummy;
  }
  d;
};


/* The structure for a bcache itself.  The bcache is initialized, in
   bcache_xmalloc(), by filling it with zeros and then setting the
   corresponding obstack's malloc() and free() methods.  */

struct bcache
{
  /* All the bstrings are allocated here.  */
  struct obstack cache;

  /* How many hash buckets we're using.  */
  unsigned int num_buckets;
  
  /* Hash buckets.  This table is allocated using malloc, so when we
     grow the table we can return the old table to the system.  */
  struct bstring **bucket;

  /* Statistics.  */
  unsigned long unique_count;	/* number of unique strings */
  long total_count;	/* total number of strings cached, including dups */
  long unique_size;	/* size of unique strings, in bytes */
  long total_size;      /* total number of bytes cached, including dups */
  long structure_size;	/* total size of bcache, including infrastructure */
  /* Number of times that the hash table is expanded and hence
     re-built, and the corresponding number of times that a string is
     [re]hashed as part of entering it into the expanded table.  The
     total number of hashes can be computed by adding TOTAL_COUNT to
     expand_hash_count.  */
  unsigned long expand_count;
  unsigned long expand_hash_count;
  /* Number of times that the half-hash compare hit (compare the upper
     16 bits of hash values) hit, but the corresponding combined
     length/data compare missed.  */
  unsigned long half_hash_miss_count;

  /* Hash function to be used for this bcache object.  */
  unsigned long (*hash_function)(const void *addr, int length);

  /* Compare function to be used for this bcache object.  */
  int (*compare_function)(const void *, const void *, int length);
};

/* The old hash function was stolen from SDBM. This is what DB 3.0
   uses now, and is better than the old one.  */

unsigned long
hash(const void *addr, int length)
{
  return hash_continue (addr, length, 0);
}

/* Continue the calculation of the hash H at the given address.  */

unsigned long
hash_continue (const void *addr, int length, unsigned long h)
{
  const unsigned char *k, *e;

  k = (const unsigned char *)addr;
  e = k+length;
  for (; k< e;++k)
    {
      h *=16777619;
      h ^= *k;
    }
  return (h);
}

/* Growing the bcache's hash table.  */

/* If the average chain length grows beyond this, then we want to
   resize our hash table.  */
#define CHAIN_LENGTH_THRESHOLD (5)

static void
expand_hash_table (struct bcache *bcache)
{
  /* A table of good hash table sizes.  Whenever we grow, we pick the
     next larger size from this table.  sizes[i] is close to 1 << (i+10),
     so we roughly double the table size each time.  After we fall off 
     the end of this table, we just double.  Don't laugh --- there have
     been executables sighted with a gigabyte of debug info.  */
  static unsigned long sizes[] = { 
    1021, 2053, 4099, 8191, 16381, 32771,
    65537, 131071, 262144, 524287, 1048573, 2097143,
    4194301, 8388617, 16777213, 33554467, 67108859, 134217757,
    268435459, 536870923, 1073741827, 2147483659UL
  };
  unsigned int new_num_buckets;
  struct bstring **new_buckets;
  unsigned int i;

  /* Count the stats.  Every unique item needs to be re-hashed and
     re-entered.  */
  bcache->expand_count++;
  bcache->expand_hash_count += bcache->unique_count;

  /* Find the next size.  */
  new_num_buckets = bcache->num_buckets * 2;
  for (i = 0; i < (sizeof (sizes) / sizeof (sizes[0])); i++)
    if (sizes[i] > bcache->num_buckets)
      {
	new_num_buckets = sizes[i];
	break;
      }

  /* Allocate the new table.  */
  {
    size_t new_size = new_num_buckets * sizeof (new_buckets[0]);

    new_buckets = (struct bstring **) xmalloc (new_size);
    memset (new_buckets, 0, new_size);

    bcache->structure_size -= (bcache->num_buckets
			       * sizeof (bcache->bucket[0]));
    bcache->structure_size += new_size;
  }

  /* Rehash all existing strings.  */
  for (i = 0; i < bcache->num_buckets; i++)
    {
      struct bstring *s, *next;

      for (s = bcache->bucket[i]; s; s = next)
	{
	  struct bstring **new_bucket;
	  next = s->next;

	  new_bucket = &new_buckets[(bcache->hash_function (&s->d.data,
							    s->length)
				     % new_num_buckets)];
	  s->next = *new_bucket;
	  *new_bucket = s;
	}
    }

  /* Plug in the new table.  */
  if (bcache->bucket)
    xfree (bcache->bucket);
  bcache->bucket = new_buckets;
  bcache->num_buckets = new_num_buckets;
}


/* Looking up things in the bcache.  */

/* The number of bytes needed to allocate a struct bstring whose data
   is N bytes long.  */
#define BSTRING_SIZE(n) (offsetof (struct bstring, d.data) + (n))

/* Find a copy of the LENGTH bytes at ADDR in BCACHE.  If BCACHE has
   never seen those bytes before, add a copy of them to BCACHE.  In
   either case, return a pointer to BCACHE's copy of that string.  */
const void *
bcache (const void *addr, int length, struct bcache *cache)
{
  return bcache_full (addr, length, cache, NULL);
}

/* Find a copy of the LENGTH bytes at ADDR in BCACHE.  If BCACHE has
   never seen those bytes before, add a copy of them to BCACHE.  In
   either case, return a pointer to BCACHE's copy of that string.  If
   optional ADDED is not NULL, return 1 in case of new entry or 0 if
   returning an old entry.  */

const void *
bcache_full (const void *addr, int length, struct bcache *bcache, int *added)
{
  unsigned long full_hash;
  unsigned short half_hash;
  int hash_index;
  struct bstring *s;

  if (added)
    *added = 0;

  /* Lazily initialize the obstack.  This can save quite a bit of
     memory in some cases.  */
  if (bcache->total_count == 0)
    {
      /* We could use obstack_specify_allocation here instead, but
	 gdb_obstack.h specifies the allocation/deallocation
	 functions.  */
      obstack_init (&bcache->cache);
    }

  /* If our average chain length is too high, expand the hash table.  */
  if (bcache->unique_count >= bcache->num_buckets * CHAIN_LENGTH_THRESHOLD)
    expand_hash_table (bcache);

  bcache->total_count++;
  bcache->total_size += length;

  full_hash = bcache->hash_function (addr, length);

  half_hash = (full_hash >> 16);
  hash_index = full_hash % bcache->num_buckets;

  /* Search the hash bucket for a string identical to the caller's.
     As a short-circuit first compare the upper part of each hash
     values.  */
  for (s = bcache->bucket[hash_index]; s; s = s->next)
    {
      if (s->half_hash == half_hash)
	{
	  if (s->length == length
	      && bcache->compare_function (&s->d.data, addr, length))
	    return &s->d.data;
	  else
	    bcache->half_hash_miss_count++;
	}
    }

  /* The user's string isn't in the list.  Insert it after *ps.  */
  {
    struct bstring *new
      = obstack_alloc (&bcache->cache, BSTRING_SIZE (length));

    memcpy (&new->d.data, addr, length);
    new->length = length;
    new->next = bcache->bucket[hash_index];
    new->half_hash = half_hash;
    bcache->bucket[hash_index] = new;

    bcache->unique_count++;
    bcache->unique_size += length;
    bcache->structure_size += BSTRING_SIZE (length);

    if (added)
      *added = 1;

    return &new->d.data;
  }
}


/* Compare the byte string at ADDR1 of lenght LENGHT to the
   string at ADDR2.  Return 1 if they are equal.  */

static int
bcache_compare (const void *addr1, const void *addr2, int length)
{
  return memcmp (addr1, addr2, length) == 0;
}

/* Allocating and freeing bcaches.  */

/* Allocated a bcache.  HASH_FUNCTION and COMPARE_FUNCTION can be used
   to pass in custom hash, and compare functions to be used by this
   bcache.  If HASH_FUNCTION is NULL hash() is used and if
   COMPARE_FUNCTION is NULL memcmp() is used.  */

struct bcache *
bcache_xmalloc (unsigned long (*hash_function)(const void *, int length),
                int (*compare_function)(const void *, 
					const void *, 
					int length))
{
  /* Allocate the bcache pre-zeroed.  */
  struct bcache *b = XCALLOC (1, struct bcache);

  if (hash_function)
    b->hash_function = hash_function;
  else
    b->hash_function = hash;

  if (compare_function)
    b->compare_function = compare_function;
  else
    b->compare_function = bcache_compare;
  return b;
}

/* Free all the storage associated with BCACHE.  */
void
bcache_xfree (struct bcache *bcache)
{
  if (bcache == NULL)
    return;
  /* Only free the obstack if we actually initialized it.  */
  if (bcache->total_count > 0)
    obstack_free (&bcache->cache, 0);
  xfree (bcache->bucket);
  xfree (bcache);
}



/* Printing statistics.  */

static void
print_percentage (int portion, int total)
{
  if (total == 0)
    /* i18n: Like "Percentage of duplicates, by count: (not applicable)".  */
    printf_filtered (_("(not applicable)\n"));
  else
    printf_filtered ("%3d%%\n", (int) (portion * 100.0 / total));
}


/* Print statistics on BCACHE's memory usage and efficacity at
   eliminating duplication.  NAME should describe the kind of data
   BCACHE holds.  Statistics are printed using `printf_filtered' and
   its ilk.  */
void
print_bcache_statistics (struct bcache *c, char *type)
{
  int occupied_buckets;
  int max_chain_length;
  int median_chain_length;
  int max_entry_size;
  int median_entry_size;

  /* Count the number of occupied buckets, tally the various string
     lengths, and measure chain lengths.  */
  {
    unsigned int b;
    int *chain_length = XCALLOC (c->num_buckets + 1, int);
    int *entry_size = XCALLOC (c->unique_count + 1, int);
    int stringi = 0;

    occupied_buckets = 0;

    for (b = 0; b < c->num_buckets; b++)
      {
	struct bstring *s = c->bucket[b];

	chain_length[b] = 0;

	if (s)
	  {
	    occupied_buckets++;
	    
	    while (s)
	      {
		gdb_assert (b < c->num_buckets);
		chain_length[b]++;
		gdb_assert (stringi < c->unique_count);
		entry_size[stringi++] = s->length;
		s = s->next;
	      }
	  }
      }

    /* To compute the median, we need the set of chain lengths
       sorted.  */
    qsort (chain_length, c->num_buckets, sizeof (chain_length[0]),
	   compare_positive_ints);
    qsort (entry_size, c->unique_count, sizeof (entry_size[0]),
	   compare_positive_ints);

    if (c->num_buckets > 0)
      {
	max_chain_length = chain_length[c->num_buckets - 1];
	median_chain_length = chain_length[c->num_buckets / 2];
      }
    else
      {
	max_chain_length = 0;
	median_chain_length = 0;
      }
    if (c->unique_count > 0)
      {
	max_entry_size = entry_size[c->unique_count - 1];
	median_entry_size = entry_size[c->unique_count / 2];
      }
    else
      {
	max_entry_size = 0;
	median_entry_size = 0;
      }

    xfree (chain_length);
    xfree (entry_size);
  }

  printf_filtered (_("  Cached '%s' statistics:\n"), type);
  printf_filtered (_("    Total object count:  %ld\n"), c->total_count);
  printf_filtered (_("    Unique object count: %lu\n"), c->unique_count);
  printf_filtered (_("    Percentage of duplicates, by count: "));
  print_percentage (c->total_count - c->unique_count, c->total_count);
  printf_filtered ("\n");

  printf_filtered (_("    Total object size:   %ld\n"), c->total_size);
  printf_filtered (_("    Unique object size:  %ld\n"), c->unique_size);
  printf_filtered (_("    Percentage of duplicates, by size:  "));
  print_percentage (c->total_size - c->unique_size, c->total_size);
  printf_filtered ("\n");

  printf_filtered (_("    Max entry size:     %d\n"), max_entry_size);
  printf_filtered (_("    Average entry size: "));
  if (c->unique_count > 0)
    printf_filtered ("%ld\n", c->unique_size / c->unique_count);
  else
    /* i18n: "Average entry size: (not applicable)".  */
    printf_filtered (_("(not applicable)\n"));    
  printf_filtered (_("    Median entry size:  %d\n"), median_entry_size);
  printf_filtered ("\n");

  printf_filtered (_("    \
Total memory used by bcache, including overhead: %ld\n"),
		   c->structure_size);
  printf_filtered (_("    Percentage memory overhead: "));
  print_percentage (c->structure_size - c->unique_size, c->unique_size);
  printf_filtered (_("    Net memory savings:         "));
  print_percentage (c->total_size - c->structure_size, c->total_size);
  printf_filtered ("\n");

  printf_filtered (_("    Hash table size:           %3d\n"), 
		   c->num_buckets);
  printf_filtered (_("    Hash table expands:        %lu\n"),
		   c->expand_count);
  printf_filtered (_("    Hash table hashes:         %lu\n"),
		   c->total_count + c->expand_hash_count);
  printf_filtered (_("    Half hash misses:          %lu\n"),
		   c->half_hash_miss_count);
  printf_filtered (_("    Hash table population:     "));
  print_percentage (occupied_buckets, c->num_buckets);
  printf_filtered (_("    Median hash chain length:  %3d\n"),
		   median_chain_length);
  printf_filtered (_("    Average hash chain length: "));
  if (c->num_buckets > 0)
    printf_filtered ("%3lu\n", c->unique_count / c->num_buckets);
  else
    /* i18n: "Average hash chain length: (not applicable)".  */
    printf_filtered (_("(not applicable)\n"));
  printf_filtered (_("    Maximum hash chain length: %3d\n"), 
		   max_chain_length);
  printf_filtered ("\n");
}

int
bcache_memory_used (struct bcache *bcache)
{
  if (bcache->total_count == 0)
    return 0;
  return obstack_memory_used (&bcache->cache);
}
@


1.34
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d5 1
a5 2
   Copyright (C) 1999-2000, 2002-2003, 2007-2012 Free Software
   Foundation, Inc.
@


1.33
log
@* bcache.c (bcache): Rename `bcache' to `cache'(-Wshadow).
@
text
@d5 2
a6 2
   Copyright (C) 1999, 2000, 2002, 2003, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.33.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d5 2
a6 2
   Copyright (C) 1999-2000, 2002-2003, 2007-2012 Free Software
   Foundation, Inc.
@


1.32
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d212 1
a212 1
bcache (const void *addr, int length, struct bcache *bcache)
d214 1
a214 1
  return bcache_full (addr, length, bcache, NULL);
@


1.31
log
@run copyright.sh for 2011.
@
text
@d458 2
a459 1
  printf_filtered (_("    Total memory used by bcache, including overhead: %ld\n"),
@


1.30
log
@2010-12-29  Michael Snyder  <msnyder@@vmware.com>

	* bcache.c: Comment clean-up.
	* block.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* bsd-kvm.c: Ditto.
	* buildsym.c: Ditto.
@
text
@d5 1
a5 1
   Copyright (C) 1999, 2000, 2002, 2003, 2007, 2008, 2009, 2010
@


1.29
log
@	* bcache.c (expand_hash_table): Use hash_function, not hash.
@
text
@d100 2
a101 3
/* The old hash function was stolen from SDBM. This is what DB 3.0 uses now,
 * and is better than the old one. 
 */
d307 2
a308 2
   bcache. If HASH_FUNCTION is NULL hash() is used and if COMPARE_FUNCTION
   is NULL memcmp() is used.  */
d312 3
a314 1
                int (*compare_function)(const void *, const void *, int length))
d352 1
a352 1
    /* i18n: Like "Percentage of duplicates, by count: (not applicable)" */
d403 2
a404 1
    /* To compute the median, we need the set of chain lengths sorted.  */
d453 1
a453 1
    /* i18n: "Average entry size: (not applicable)" */
d466 2
a467 1
  printf_filtered (_("    Hash table size:           %3d\n"), c->num_buckets);
d482 1
a482 1
    /* i18n: "Average hash chain length: (not applicable)" */
d484 2
a485 1
  printf_filtered (_("    Maximum hash chain length: %3d\n"), max_chain_length);
@


1.28
log
@Enable custom bcache hash function.

2010-08-25  Sami Wagiaalla  <swagiaal@@redhat.com>

	* psymtab.c (add_psymbol_to_bcache): Remove 'static' from
	'static partial_symbol psymbol'.
	(psymbol_hash): New function.
	(psymbol_compare): New function.
	* bcache.c (hash_continue): New.
	(hash): Use hash_continue.
	* bcache.c: Add hash_function and compare_function
	pointers to bcache struct.
	(bcache_full): Use bcache->hash_function, and
	bcache->compare_function.
	(bcache_compare): New function.
	(bcache_xmalloc): Take hash_function and
	compare_function arguments and initialize the
	bcach's pointers.
	Updated comment.
	* objfiles.c (allocate_objfile): Updated.
	* symfile.c (reread_symbols): Updated.
	* python/py-type.c (typy_richcompare): Updated.
@
text
@d187 2
a188 1
	  new_bucket = &new_buckets[(hash (&s->d.data, s->length)
@


1.27
log
@2010-05-13  Michael Snyder  <msnyder@@vmware.com>

	* bcache.c: White space.
@
text
@d92 6
d107 8
a115 1
  unsigned long h;
d119 1
a119 1
  for (h=0; k< e;++k)
d251 2
a252 1
  full_hash = hash (addr, length);
d264 1
a264 1
	      && ! memcmp (&s->d.data, addr, length))
d293 10
d305 5
d311 2
a312 1
bcache_xmalloc (void)
d317 9
@


1.26
log
@	Implement core awareness.

	* bcache.c (compare_ints): Remove
	(print_percentage): Use compare_positive_ints.
	* defs.h (compare_positive_ints): Declare.
	* linux-nat.h (struct lin_lwp): New field core.
	(linux_nat_core_of_thread_1): Declare.
	* linux-nat.c (add_lwp): Init the 'core' field.
	(linux_nat_wait_1): Record the core.
	(linux_nat_core_of_thread_1, linux_nat_core_of_thread): New.
	(linux_nat_add_target): Register the above.
	* linux-thread-db.c (update_thread_core): New.
	(thread_db_find_new_threads): Update core information for
	every thread.
	* remote.c (struct private_thread_info): New.
	(free_private_thread_info, demand_private_info): New.
	(PACKET_qXfer_threads, use_osdata_threads): New.
	(struct thread_item, threads_parsing_context
	(start_thread, end_thread, thread_attributes)
	(thread_children, threads_children, threads_elements): New.
	(remote_threads_info): Try qXfer:threads before anything
	else.
	(remote_protocol_packets): Register qXfer:threads.
	(remote_open_1): Init use_osdata_threads.
	(struct stop_reply): New field 'core'.
	(remote_parse_stop_reply): Parse core number.
	(process_stop_reply): Record core number.
	(remote_xfer_partial): Handle qXfer:threads.
	(remote_core_of_thread): New.
	(init_remote_ops): Register remote_core_of_thread.
	(_initialize_remote): Register qXfer:read.
	* target.c (target_core_of_thread): New
	* target.h (enum target_object): New value TARGET_OBJECT_THREADS.
	(struct target_ops): New field to_core_of_threads.
	(target_core_of_thread): Declare.
	* gdbthread.h (struct thread_info): New field private_dtor.
	* thread.c (print_thread_info): Report the core.
	* ui-out.c (MAX_UI_OUT_LEVELS): Increase.
	* utils.c (compare_positive_ints): New.
	* features/threads.dtd: New.
	* mi/mi-interp.c (mi_on_normal_stop): Report the core.
	* mi/mi-main.c (struct collect_cores_data, collect_cores)
	(do_nothing, free_vector_of_osdata_items)
	(splay_tree_int_comparator, free_splay_tree): New.
	(print_one_inferior_data): Implemented printing of selected
	inferiors.  Collect and print cores.
	(output_cores): New.
	(mi_cmd_list_thread_groups): Support --recurse.  Permit specifying
	thread groups together with --available.
@
text
@d101 11
a111 11
		const unsigned char *k, *e;
		unsigned long h;
		
		k = (const unsigned char *)addr;
		e = k+length;
		for (h=0; k< e;++k)
		{
				h *=16777619;
				h ^= *k;
		}
		return (h);
d155 1
d261 1
d286 1
@


1.25
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a303 9
static int
compare_ints (const void *ap, const void *bp)
{
  /* Because we know we're comparing two ints which are positive,
     there's no danger of overflow here.  */
  return * (int *) ap - * (int *) bp;
}


d361 1
a361 1
	   compare_ints);
d363 1
a363 1
	   compare_ints);
@


1.24
log
@        Updated copyright notices for most files.
@
text
@d5 1
a5 1
   Copyright (C) 1999, 2000, 2002, 2003, 2007, 2008, 2009
@


1.23
log
@	* bcache.c (deprecated_bcache_added): Initialize obstack.
	(bcache_xmalloc): Don't initialize obstack.
	(bcache_xfree): Conditionally free obstack.
	(bcache_memory_used): Update.
@
text
@d5 1
a5 1
   Copyright (C) 1999, 2000, 2002, 2003, 2007, 2008
@


1.22
log
@	* symfile.c (add_psymbol_to_bcache): Return a const pointer.  Use
	bcache_full.
	(append_psymbol_to_list): Accept a const pointer.
	(add_psymbol_to_list): Fix const correctness.
	* bcache.h: (deprecated_bcache_added, deprecated_bcache): Remove.
	(bcache_full): Declare.
	* bcache.c (bcache_data, deprecated_bcache): Remove.
	(bcache): Use bcache_full.
	(bcache_full): Rename from deprecated_bcache_added.  Change return
	type.
@
text
@d220 10
a283 4
  /* We could use obstack_specify_allocation here instead, but
     gdb_obstack.h specifies the allocation/deallocation
     functions.  */
  obstack_init (&b->cache);
d293 3
a295 1
  obstack_free (&bcache->cache, 0);
d454 2
@


1.21
log
@	* bcache.c (bcache_data): Call deprecated_bcache_added function.
	(deprecated_bcache_added): New function name. Body of function
	bcache_data is used here with the addition of 'added' argument.
	* bcache.h (deprecated_bcache_added): New function.
	* symfile.c (add_psymbol_to_bcache): New helper function, takes part of
	work from add_psymbol_to_list - initialises partial symbol and stashes
	it in objfile's cache.
	(append_psymbol_to_list): New helper function, takes other part of
	work from add_psymbol_to_list - adds partial symbol to the given list.
	(add_psymbol_to_list): Call helper functions instead of doing work
	here. If adding to global list, do not duplicate partial symbols in the
	partial symtab.
@
text
@a196 13
static void *
bcache_data (const void *addr, int length, struct bcache *bcache)
{
  return deprecated_bcache_added (addr, length, bcache, NULL);
}


void *
deprecated_bcache (const void *addr, int length, struct bcache *bcache)
{
  return bcache_data (addr, length, bcache);
}

d200 1
a200 1
  return bcache_data (addr, length, bcache);
d209 2
a210 3
void *
deprecated_bcache_added (const void *addr, int length, struct bcache *bcache, 
			 int *added)
@


1.20
log
@	Updated copyright notices for most files.
@
text
@d200 26
d231 3
d274 3
a279 12

void *
deprecated_bcache (const void *addr, int length, struct bcache *bcache)
{
  return bcache_data (addr, length, bcache);
}

const void *
bcache (const void *addr, int length, struct bcache *bcache)
{
  return bcache_data (addr, length, bcache);
}
@


1.19
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d5 2
a6 1
   Copyright (C) 1999, 2000, 2002, 2003, 2007 Free Software Foundation, Inc.
@


1.18
log
@Copyright updates for 2007.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.17
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d5 1
a5 1
   Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
@


1.16
log
@2005-01-29  Baurzhan Ismagulov  <ibr@@radix50.net>

	* ax-gdb.c, ax-general.c, bcache.c, bfd-target.c, bsd-kvm.c,
	* buildsym.c, c-lang.c, c-typeprint.c, c-valprint.c, charset.c,
	* coff-pe-read.c, coffread.c, complaints.c, copying.c: I18n markup.
@
text
@d5 1
a5 1
   Copyright 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.15
log
@print_percentage: Use floating point to avoid incorrect results when
 portion*100 overflows.
@
text
@d304 2
a305 1
    printf_filtered ("(not applicable)\n");
d386 4
a389 4
  printf_filtered ("  Cached '%s' statistics:\n", type);
  printf_filtered ("    Total object count:  %ld\n", c->total_count);
  printf_filtered ("    Unique object count: %lu\n", c->unique_count);
  printf_filtered ("    Percentage of duplicates, by count: ");
d393 3
a395 3
  printf_filtered ("    Total object size:   %ld\n", c->total_size);
  printf_filtered ("    Unique object size:  %ld\n", c->unique_size);
  printf_filtered ("    Percentage of duplicates, by size:  ");
d399 2
a400 2
  printf_filtered ("    Max entry size:     %d\n", max_entry_size);
  printf_filtered ("    Average entry size: ");
d404 3
a406 2
    printf_filtered ("(not applicable)\n");    
  printf_filtered ("    Median entry size:  %d\n", median_entry_size);
d409 1
a409 1
  printf_filtered ("    Total memory used by bcache, including overhead: %ld\n",
d411 1
a411 1
  printf_filtered ("    Percentage memory overhead: ");
d413 1
a413 1
  printf_filtered ("    Net memory savings:         ");
d417 2
a418 2
  printf_filtered ("    Hash table size:           %3d\n", c->num_buckets);
  printf_filtered ("    Hash table expands:        %lu\n",
d420 1
a420 1
  printf_filtered ("    Hash table hashes:         %lu\n",
d422 1
a422 1
  printf_filtered ("    Half hash misses:          %lu\n",
d424 1
a424 1
  printf_filtered ("    Hash table population:     ");
d426 1
a426 1
  printf_filtered ("    Median hash chain length:  %3d\n",
d428 1
a428 1
  printf_filtered ("    Average hash chain length: ");
d432 3
a434 2
    printf_filtered ("(not applicable)\n");
  printf_filtered ("    Maximum hash chain length: %3d\n", max_chain_length);
@


1.14
log
@2004-02-09  Elena Zannoni  <ezannoni@@redhat.com>

	* bcache.c (bcache_xmalloc): Use obstack_init instead of
	obstack_specify_allocation.
	* objfiles.c (allocate_objfile): Ditto.
	* solib-sunos.c (solib_add_common_symbols)
	(allocate_rt_common_objfile): Ditto.
	* symfile.c (reread_symbols): Ditto.
	* gdb_obstack.h: Add comment.
@
text
@d306 1
a306 1
    printf_filtered ("%3d%%\n", portion * 100 / total);
@


1.14.4.1
log
@Merge mainline to intercu branch.
@
text
@d306 1
a306 1
    printf_filtered ("%3d%%\n", (int) (portion * 100.0 / total));
@


1.14.8.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d306 1
a306 1
    printf_filtered ("%3d%%\n", (int) (portion * 100.0 / total));
@


1.13
log
@2003-11-15  Andrew Cagney  <cagney@@redhat.com>

	* bcache.h (deprecated_bcache): Declare.
	(bcache): Make returned buffer constant.
	* bcache.c (deprecated_bcache): New function.
	(bcache_data): New function.
	(bcache): Call bcache data.
	* symfile.c (add_psymbol_to_list): Use deprecated_bcache.
	(add_psymbol_with_dem_name_to_list): Ditto.
@
text
@d269 4
a272 1
  obstack_specify_allocation (&b->cache, 0, 0, xmalloc, xfree);
@


1.12
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* bcache.h: Update copyright.  Add comments on bcache VS hashtab.
	* bcache.c (struct bstring): Make "length" an unsigned short, add
	"half_hash".
	(struct bcache): Add "half_hash_error_count".
	(bcache): Compute and save the "half_hash".  Compare the
	"half_hash" before comparing the length.  Update
	half_hash_error_count.
@
text
@d198 2
a199 2
void *
bcache (const void *addr, int length, struct bcache *bcache)
d250 11
@


1.11
log
@
	* bcache.c: Include "gdb_assert.h".
	(struct bcache): Add fields "expand_count" and
	"expand_hash_count".
	(expand_hash_table): Update the expand counts.
	(print_bcache_statistics): Use XCALLOC, not alloca.  Print stats
	on object sizes and hashes.
	* Makefile.in (bcache.o): Update dependencies.
@
text
@d41 1
d43 7
a49 1
  size_t length;
d89 4
d201 2
d213 7
a219 3
  hash_index = hash (addr, length) % bcache->num_buckets;

  /* Search the hash bucket for a string identical to the caller's.  */
d221 10
a230 3
    if (s->length == length
	&& ! memcmp (&s->d.data, addr, length))
      return &s->d.data;
d239 1
d406 2
@


1.10
log
@2002-07-29  Andrew Cagney  <ac131313@@redhat.com>

* gdb_obstack.h: New file.
* symtab.h: Include "gdb_obstack.h" instead of "obstack.h".
(obstack_chunk_alloc, obstack_chunk_free): Delete macros.
* objfiles.h: Include "gdb_obstack.h".
* Makefile.in (gdb_obstack_h): Define.
(symtab_h): Add $(gdb_obstack_h).
(objfiles_h): Add $(gdb_obstack_h).

* objfiles.c: Include "gdb_obstack.h" instead of "obstack.h".
* macrotab.c, cp-valprint.c, dbxread.c: Ditto.
* ch-typeprint.c, ch-valprint.c, dstread.c: Ditto.
* macroexp.c, p-typeprint.c, stabsread.c: Ditto.
* symtab.c, f-typeprint.c, mdebugread.c: Ditto.
* p-valprint.c, symmisc.c, typeprint.c: Ditto.
* symfile.c, coffread.c, c-typeprint.c: Ditto.
* buildsym.c, bcache.c, ada-typeprint.c: Ditto.

* Makefile.in (bcache.o): Update dependencies.
(buildsym.o, c-typeprint.o, ch-typeprint.o): Ditto.
(ch-valprint.o, coffread.o, cp-valprint.o): Ditto.
(dbxread.o, dstread.o, f-typeprint.o): Ditto.
(objfiles.o, p-typeprint.o, p-valprint.o): Ditto.
(stabsread.o, symfile.o, symmisc.o): Ditto.
(symtab.o, typeprint.o, macroexp.o): Ditto.
(macrotab.o, mdebugread.o): Ditto.
(f_lang_h, coff_sym_h, coff_symconst_h): Define.
(coff_ecoff_h, aout_aout64_h): Define.
(aout_stabs_gnu_h, libaout_h): Define.
@
text
@d5 1
a5 1
   Copyright 1999, 2000, 2002 Free Software Foundation, Inc.
d28 1
d75 7
d128 5
d281 2
d284 2
a285 1
  /* Count the number of occupied buckets, and measure chain lengths.  */
d288 3
a290 2
    int *chain_length
      = (int *) alloca (c->num_buckets * sizeof (*chain_length));
d306 1
d308 2
d318 2
d331 13
d359 9
d377 4
@


1.10.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d5 1
a5 1
   Copyright 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
a27 1
#include "gdb_assert.h"
a39 1
  /* Hash chain.  */
d41 1
a41 7
  /* Assume the data length is no more than 64k.  */
  unsigned short length;
  /* The half hash hack.  This contains the upper 16 bits of the hash
     value and is used as a pre-check when comparing two strings and
     avoids the need to do length or memcmp calls.  It proves to be
     roughly 100% effective.  */
  unsigned short half_hash;
a73 11
  /* Number of times that the hash table is expanded and hence
     re-built, and the corresponding number of times that a string is
     [re]hashed as part of entering it into the expanded table.  The
     total number of hashes can be computed by adding TOTAL_COUNT to
     expand_hash_count.  */
  unsigned long expand_count;
  unsigned long expand_hash_count;
  /* Number of times that the half-hash compare hit (compare the upper
     16 bits of hash values) hit, but the corresponding combined
     length/data compare missed.  */
  unsigned long half_hash_miss_count;
a119 5
  /* Count the stats.  Every unique item needs to be re-hashed and
     re-entered.  */
  bcache->expand_count++;
  bcache->expand_hash_count += bcache->unique_count;

d174 2
a175 2
static void *
bcache_data (const void *addr, int length, struct bcache *bcache)
a176 2
  unsigned long full_hash;
  unsigned short half_hash;
d187 3
a189 7
  full_hash = hash (addr, length);
  half_hash = (full_hash >> 16);
  hash_index = full_hash % bcache->num_buckets;

  /* Search the hash bucket for a string identical to the caller's.
     As a short-circuit first compare the upper part of each hash
     values.  */
d191 3
a193 10
    {
      if (s->half_hash == half_hash)
	{
	  if (s->length == length
	      && ! memcmp (&s->d.data, addr, length))
	    return &s->d.data;
	  else
	    bcache->half_hash_miss_count++;
	}
    }
a201 1
    new->half_hash = half_hash;
a211 11
void *
deprecated_bcache (const void *addr, int length, struct bcache *bcache)
{
  return bcache_data (addr, length, bcache);
}

const void *
bcache (const void *addr, int length, struct bcache *bcache)
{
  return bcache_data (addr, length, bcache);
}
a267 2
  int max_entry_size;
  int median_entry_size;
d269 1
a269 2
  /* Count the number of occupied buckets, tally the various string
     lengths, and measure chain lengths.  */
d272 2
a273 3
    int *chain_length = XCALLOC (c->num_buckets + 1, int);
    int *entry_size = XCALLOC (c->unique_count + 1, int);
    int stringi = 0;
a288 1
		gdb_assert (b < c->num_buckets);
a289 2
		gdb_assert (stringi < c->unique_count);
		entry_size[stringi++] = s->length;
a297 2
    qsort (entry_size, c->unique_count, sizeof (entry_size[0]),
	   compare_ints);
a308 13
    if (c->unique_count > 0)
      {
	max_entry_size = entry_size[c->unique_count - 1];
	median_entry_size = entry_size[c->unique_count / 2];
      }
    else
      {
	max_entry_size = 0;
	median_entry_size = 0;
      }

    xfree (chain_length);
    xfree (entry_size);
a323 9
  printf_filtered ("    Max entry size:     %d\n", max_entry_size);
  printf_filtered ("    Average entry size: ");
  if (c->unique_count > 0)
    printf_filtered ("%ld\n", c->unique_size / c->unique_count);
  else
    printf_filtered ("(not applicable)\n");    
  printf_filtered ("    Median entry size:  %d\n", median_entry_size);
  printf_filtered ("\n");

a332 6
  printf_filtered ("    Hash table expands:        %lu\n",
		   c->expand_count);
  printf_filtered ("    Hash table hashes:         %lu\n",
		   c->total_count + c->expand_hash_count);
  printf_filtered ("    Half hash misses:          %lu\n",
		   c->half_hash_miss_count);
@


1.10.8.1
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d5 1
a5 1
   Copyright 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
a27 1
#include "gdb_assert.h"
a39 1
  /* Hash chain.  */
d41 1
a41 7
  /* Assume the data length is no more than 64k.  */
  unsigned short length;
  /* The half hash hack.  This contains the upper 16 bits of the hash
     value and is used as a pre-check when comparing two strings and
     avoids the need to do length or memcmp calls.  It proves to be
     roughly 100% effective.  */
  unsigned short half_hash;
a73 11
  /* Number of times that the hash table is expanded and hence
     re-built, and the corresponding number of times that a string is
     [re]hashed as part of entering it into the expanded table.  The
     total number of hashes can be computed by adding TOTAL_COUNT to
     expand_hash_count.  */
  unsigned long expand_count;
  unsigned long expand_hash_count;
  /* Number of times that the half-hash compare hit (compare the upper
     16 bits of hash values) hit, but the corresponding combined
     length/data compare missed.  */
  unsigned long half_hash_miss_count;
a119 5
  /* Count the stats.  Every unique item needs to be re-hashed and
     re-entered.  */
  bcache->expand_count++;
  bcache->expand_hash_count += bcache->unique_count;

a176 2
  unsigned long full_hash;
  unsigned short half_hash;
d187 3
a189 7
  full_hash = hash (addr, length);
  half_hash = (full_hash >> 16);
  hash_index = full_hash % bcache->num_buckets;

  /* Search the hash bucket for a string identical to the caller's.
     As a short-circuit first compare the upper part of each hash
     values.  */
d191 3
a193 10
    {
      if (s->half_hash == half_hash)
	{
	  if (s->length == length
	      && ! memcmp (&s->d.data, addr, length))
	    return &s->d.data;
	  else
	    bcache->half_hash_miss_count++;
	}
    }
a201 1
    new->half_hash = half_hash;
a267 2
  int max_entry_size;
  int median_entry_size;
d269 1
a269 2
  /* Count the number of occupied buckets, tally the various string
     lengths, and measure chain lengths.  */
d272 2
a273 3
    int *chain_length = XCALLOC (c->num_buckets + 1, int);
    int *entry_size = XCALLOC (c->unique_count + 1, int);
    int stringi = 0;
a288 1
		gdb_assert (b < c->num_buckets);
a289 2
		gdb_assert (stringi < c->unique_count);
		entry_size[stringi++] = s->length;
a297 2
    qsort (entry_size, c->unique_count, sizeof (entry_size[0]),
	   compare_ints);
a308 13
    if (c->unique_count > 0)
      {
	max_entry_size = entry_size[c->unique_count - 1];
	median_entry_size = entry_size[c->unique_count / 2];
      }
    else
      {
	max_entry_size = 0;
	median_entry_size = 0;
      }

    xfree (chain_length);
    xfree (entry_size);
a323 9
  printf_filtered ("    Max entry size:     %d\n", max_entry_size);
  printf_filtered ("    Average entry size: ");
  if (c->unique_count > 0)
    printf_filtered ("%ld\n", c->unique_size / c->unique_count);
  else
    printf_filtered ("(not applicable)\n");    
  printf_filtered ("    Median entry size:  %d\n", median_entry_size);
  printf_filtered ("\n");

a332 6
  printf_filtered ("    Hash table expands:        %lu\n",
		   c->expand_count);
  printf_filtered ("    Hash table hashes:         %lu\n",
		   c->total_count + c->expand_hash_count);
  printf_filtered ("    Half hash misses:          %lu\n",
		   c->half_hash_miss_count);
@


1.10.8.2
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d198 2
a199 2
static void *
bcache_data (const void *addr, int length, struct bcache *bcache)
a249 11
void *
deprecated_bcache (const void *addr, int length, struct bcache *bcache)
{
  return bcache_data (addr, length, bcache);
}

const void *
bcache (const void *addr, int length, struct bcache *bcache)
{
  return bcache_data (addr, length, bcache);
}
@


1.9
log
@* bcache.h: Update copyright.
(struct bstring, struct bcache): Move definition to "bcache.c".
Replaced by opaque declaration.
(bcache_xfree): Replace free_bcache.
(bcache_xmalloc, bcache_memory_used): Declare.

* bcache.c: Update copyright.
(struct bstring, struct bcache): Moved to here from "bcache.h".
Update comments.
(bcache_xmalloc, bcache_memory_used): New functions.
(bcache_xfree): Replace function free_bcache.

* Makefile.in (objfiles.o): Add $(bcache_h).
(objfiles_h): Remove $(bcache_h).
(symfile.o): Add $(bcache_h).

* symmisc.c: Update copyright.
(print_symbol_bcache_statistics): Pass psymbol_cache by value.
(print_objfile_statistics): Use bcache_memory_used.

* symfile.c: Include "bcache.h".
(reread_symbols): Use bcache_xfree.
(reread_symbols): Use bcache_xmalloc and bcache_xfree.
(add_psymbol_to_list): Pass psymbol_cache by value.
(add_psymbol_with_dem_name_to_list): Ditto.

* objfiles.h: Update copyright.
(struct bcache): Declare opaque.  Do not include "bcache.h".
(struct objfile): Change psymbol_cache and macro_cache to ``struct
bcache'' pointers.
* dwarf2read.c (macro_start_file): Pass macro_cache by value.

* objfiles.c: Include "bcache.h".  Update copyright.
(allocate_objfile): Use bcache_xmalloc to create psymbol_cache and
macro_cache.
(free_objfile): Use bcache_xfree.
@
text
@d25 1
a25 1
#include "obstack.h"
@


1.8
log
@* bcache.c: Include <stddef.h> and <stdlib.h> after "defs.h".
Update copyright.
@
text
@d32 44
d213 10
a222 1
/* Freeing bcaches.  */
d226 1
a226 1
free_bcache (struct bcache *bcache)
d228 2
d231 2
a232 6
  if (bcache->bucket)
    xfree (bcache->bucket);

  /* This isn't necessary, but at least the bcache is always in a
     consistent state.  */
  memset (bcache, 0, sizeof (*bcache));
d344 6
@


1.8.6.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a31 44
/* The type used to hold a single bcache string.  The user data is
   stored in d.data.  Since it can be any type, it needs to have the
   same alignment as the most strict alignment of any type on the host
   machine.  I don't know of any really correct way to do this in
   stock ANSI C, so just do it the same way obstack.h does.  */

struct bstring
{
  struct bstring *next;
  size_t length;

  union
  {
    char data[1];
    double dummy;
  }
  d;
};


/* The structure for a bcache itself.  The bcache is initialized, in
   bcache_xmalloc(), by filling it with zeros and then setting the
   corresponding obstack's malloc() and free() methods.  */

struct bcache
{
  /* All the bstrings are allocated here.  */
  struct obstack cache;

  /* How many hash buckets we're using.  */
  unsigned int num_buckets;
  
  /* Hash buckets.  This table is allocated using malloc, so when we
     grow the table we can return the old table to the system.  */
  struct bstring **bucket;

  /* Statistics.  */
  unsigned long unique_count;	/* number of unique strings */
  long total_count;	/* total number of strings cached, including dups */
  long unique_size;	/* size of unique strings, in bytes */
  long total_size;      /* total number of bytes cached, including dups */
  long structure_size;	/* total size of bcache, including infrastructure */
};

d169 1
a169 10
/* Allocating and freeing bcaches.  */

struct bcache *
bcache_xmalloc (void)
{
  /* Allocate the bcache pre-zeroed.  */
  struct bcache *b = XCALLOC (1, struct bcache);
  obstack_specify_allocation (&b->cache, 0, 0, xmalloc, xfree);
  return b;
}
d173 1
a173 1
bcache_xfree (struct bcache *bcache)
a174 2
  if (bcache == NULL)
    return;
d176 6
a181 2
  xfree (bcache->bucket);
  xfree (bcache);
a292 6
}

int
bcache_memory_used (struct bcache *bcache)
{
  return obstack_memory_used (&bcache->cache);
@


1.8.6.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d25 1
a25 1
#include "gdb_obstack.h"
@


1.7
log
@Indicate that the bcache functions don't change the strings
they're passed.
* bcache.h (bcache, hash): Add `const' keywords to declarations.
* bcache.c (bcache, hash): Add `const' keywords to definitions.
@
text
@d4 2
a5 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
a23 3
#include <stddef.h>
#include <stdlib.h>

d28 3
@


1.7.2.1
log
@* bcache.c: Include <stddef.h> and <stdlib.h> after "defs.h".
Update copyright.
@
text
@d4 1
a4 2

   Copyright 1999, 2000, 2002 Free Software Foundation, Inc.
d23 3
a29 3

#include <stddef.h>
#include <stdlib.h>
@


1.6
log
@Update/correct copyright notices.
@
text
@d36 1
a36 1
hash(void *addr, int length)
d130 1
a130 1
bcache (void *addr, int length, struct bcache *bcache)
@


1.6.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d31 1
a31 1
/* The old hash function was stolen from SDBM. This is what DB 3.1 uses now,
a32 1
 * It's the FNV hash.
d36 1
a36 1
hash (void *addr, int length)
d38 11
a48 11
  const unsigned char *k, *e;
  unsigned long h;
  
  k = (const unsigned char *)addr;
  e = k+length;
  for (h=0x811c9dc5; k< e;++k)
    {
      h *=16777619;
      h ^= *k;
    }
  return (h);
a49 1

d162 1
@


1.5
log
@Replace free() with xfree().
@
text
@d4 1
a4 1
   Copyright 1999 Free Software Foundation, Inc.
@


1.4
log
@C++ improvements
@
text
@d114 1
a114 1
    free (bcache->bucket);
d176 1
a176 1
    free (bcache->bucket);
@


1.3
log
@* bcache.c (free_bcache): Do not free NULL.
@
text
@d31 3
a33 1

a34 2
/* The hash function.  */

d36 1
a36 1
hash (void *addr, int length)
d38 11
a48 27
  /* If it's a short string, hash on every character.  Otherwise, sample
     characters from throughout the string.  */
  if (length <= 64)
    {
      char *byte = addr;
      unsigned long h = 0;
      int i;

      for (i = 0; i < length; i++)
	h = h * 65793 ^ (h >> (sizeof (h) * 8 - 6)) ^ byte[i];

      return h;
    }
  else
    {
      char *byte = addr;
      int n, i;
      unsigned long h = 0;

      for (n = i = 0; n < 64; n++)
	{
	  h = h * 65793 + (h >> (sizeof (h) * 8 - 6)) + byte[i];
	  i = h % length;
	}

      return h;
    }
a49 1

@


1.2
log
@	Clean up compiler warnings:
	* bcache.h, bcache.c, c-valprint.c, coffread.c, stabsread.c,
	stack.c, valprint.c: Change variables to unsigned.
	* bcache.c: Rearrange to avoid warnings about variables not being set.
	* c-lang.c, ch-lang.c, f-lang.c, m2-lang.c: Include valprint.h
	rather than declaring print_max and repeat_count_threashold
	ourselves (incorrectly).
	* valprint.h: Do declare repeat_count_threashold.
	* ch-exp.c: Use default case for internal error.
	* findvar.c: Don't omit argument type.
	* symtab.c: Remove unused variable.
@
text
@d192 2
a193 1
  free (bcache->bucket);
@


1.2.2.1
log
@* bcache.c (free_bcache): Do not free NULL.
@
text
@d192 1
a192 2
  if (bcache->bucket)
    free (bcache->bucket);
@


1.1
log
@Initial revision
@
text
@d2 20
a21 2
   Written by Fred Fish (fnf@@cygnus.com)
   Copyright 1995, 1998 Free Software Foundation, Inc.
d23 2
a24 15
This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a30 1
/* Prototypes for local functions. */
d32 2
a33 1
static unsigned int hash PARAMS ((void *, int));
d35 10
a44 1
static void *lookup_cache PARAMS ((void *, int, int, struct bcache *));
d46 2
a47 3
/* FIXME:  Incredibly simplistic hash generator.  Probably way too expensive
 (consider long strings) and unlikely to have good distribution across hash
 values for typical input. */
d49 3
a51 13
static unsigned int
hash (bytes, count)
     void *bytes;
     int count;
{
  unsigned int len;
  unsigned long hashval;
  unsigned int c;
  const unsigned char *data = bytes;

  hashval = 0;
  len = 0;
  while (count-- > 0)
d53 3
a55 20
      c = *data++;
      hashval += c + (c << 17);
      hashval ^= hashval >> 2;
      ++len;
    }
  hashval += len + (len << 17);
  hashval ^= hashval >> 2;
  return (hashval % BCACHE_HASHSIZE);
}

static void *
lookup_cache (bytes, count, hashval, bcachep)
     void *bytes;
     int count;
     int hashval;
     struct bcache *bcachep;
{
  void *location = NULL;
  struct hashlink **hashtablep;
  struct hashlink *linkp;
d57 1
a57 5
  hashtablep = bcachep -> indextable[count];
  if (hashtablep != NULL)
    {
      linkp = hashtablep[hashval];
      while (linkp != NULL)
d59 2
a60 6
	  if (memcmp (BCACHE_DATA (linkp), bytes, count) == 0)
	    {
	      location = BCACHE_DATA (linkp);
	      break;
	    }
	  linkp = linkp -> next;
d62 2
a64 1
  return (location);
d67 44
a110 11
void *
bcache (bytes, count, bcachep)
     void *bytes;
     int count;
     struct bcache *bcachep;
{
  int hashval;
  void *location;
  struct hashlink *newlink;
  struct hashlink **linkpp;
  struct hashlink ***hashtablepp;
d112 2
a113 1
  if (count >= BCACHE_MAXLENGTH)
d115 3
a117 11
      /* Rare enough to just stash unique copies */
      location = (void *) obstack_alloc (&bcachep->cache, count);
      bcachep -> cache_bytes += count;
      memcpy (location, bytes, count);
      bcachep -> bcache_overflows++;
    }
  else
    {
      hashval = hash (bytes, count);
      location = lookup_cache (bytes, count, hashval, bcachep);
      if (location != NULL)
d119 7
a125 22
	  bcachep -> cache_savings += count;
	  bcachep -> cache_hits++;
	}
      else
	{
	  bcachep -> cache_misses++;
	  hashtablepp = &bcachep -> indextable[count];
	  if (*hashtablepp == NULL)
	    {
	      *hashtablepp = (struct hashlink **)
		obstack_alloc (&bcachep->cache, BCACHE_HASHSIZE * sizeof (struct hashlink *));
	      bcachep -> cache_bytes += BCACHE_HASHSIZE * sizeof (struct hashlink *);
	      memset (*hashtablepp, 0, BCACHE_HASHSIZE * sizeof (struct hashlink *));
	    }
	  linkpp = &(*hashtablepp)[hashval];
	  newlink = (struct hashlink *)
	    obstack_alloc (&bcachep->cache, BCACHE_DATA_ALIGNMENT + count);
	  bcachep -> cache_bytes += BCACHE_DATA_ALIGNMENT + count;
	  memcpy (BCACHE_DATA (newlink), bytes, count);
	  newlink -> next = *linkpp;
	  *linkpp = newlink;
	  location = BCACHE_DATA (newlink);
d128 6
a133 1
  return (location);
d136 15
a150 1
#if MAINTENANCE_CMDS
d152 36
d189 9
a197 7
print_bcache_statistics (bcachep, id)
     struct bcache *bcachep;
     char *id;
{
  struct hashlink **hashtablep;
  struct hashlink *linkp;
  int tidx, tcount, hidx, hcount, lcount, lmax, temp, lmaxt, lmaxh;
d199 18
a216 36
  for (lmax = lcount = tcount = hcount = tidx = 0; tidx < BCACHE_MAXLENGTH; tidx++)
    {
      hashtablep = bcachep -> indextable[tidx];
      if (hashtablep != NULL)
	{
	  tcount++;
	  for (hidx = 0; hidx < BCACHE_HASHSIZE; hidx++)
	    {
	      linkp = hashtablep[hidx];
	      if (linkp != NULL)
		{
		  hcount++;
		  for (temp = 0; linkp != NULL; linkp = linkp -> next)
		    {
		      lcount++;
		      temp++;
		    }
		  if (temp > lmax)
		    {
		      lmax = temp;
		      lmaxt = tidx;
		      lmaxh = hidx;
		    }
		}
	    }
	}
    }
  printf_filtered ("  Cached '%s' statistics:\n", id);
  printf_filtered ("    Cache hits: %d\n", bcachep -> cache_hits);
  printf_filtered ("    Cache misses: %d\n", bcachep -> cache_misses);
  printf_filtered ("    Cache hit ratio: ");
  if (bcachep -> cache_hits + bcachep -> cache_misses > 0)
    {
      printf_filtered ("%d%%\n", ((bcachep -> cache_hits) * 100) /
		       (bcachep -> cache_hits + bcachep -> cache_misses));
    }
d218 86
a303 14
    {
      printf_filtered ("(not applicable)\n");
    }
  printf_filtered ("    Space used for caching: %d\n", bcachep -> cache_bytes);
  printf_filtered ("    Space saved by cache hits: %d\n", bcachep -> cache_savings);
  printf_filtered ("    Number of bcache overflows: %d\n", bcachep -> bcache_overflows);
  printf_filtered ("    Number of index buckets used: %d\n", tcount);
  printf_filtered ("    Number of hash table buckets used: %d\n", hcount);
  printf_filtered ("    Number of chained items: %d\n", lcount);
  printf_filtered ("    Average hash table population: ");
  if (tcount > 0)
    {
      printf_filtered ("%d%%\n", (hcount * 100) / (tcount * BCACHE_HASHSIZE));
    }
d305 3
a307 13
    {
      printf_filtered ("(not applicable)\n");
    }
  printf_filtered ("    Average chain length ");
  if (hcount > 0)
    {
      printf_filtered ("%d\n", lcount / hcount);
    }
  else
    {
      printf_filtered ("(not applicable)\n");
    }
  printf_filtered ("    Maximum chain length %d at %d:%d\n", lmax, lmaxt, lmaxh);
a308 2

#endif	/* MAINTENANCE_CMDS */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d141 2
d218 2
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d33 2
a34 2
   (consider long strings) and unlikely to have good distribution across hash
   values for typical input. */
d71 1
a71 1
  hashtablep = bcachep->indextable[count];
d82 1
a82 1
	  linkp = linkp->next;
d104 1
a104 1
      bcachep->cache_bytes += count;
d106 1
a106 1
      bcachep->bcache_overflows++;
d114 2
a115 2
	  bcachep->cache_savings += count;
	  bcachep->cache_hits++;
d119 2
a120 2
	  bcachep->cache_misses++;
	  hashtablepp = &bcachep->indextable[count];
d125 1
a125 1
	      bcachep->cache_bytes += BCACHE_HASHSIZE * sizeof (struct hashlink *);
d131 1
a131 1
	  bcachep->cache_bytes += BCACHE_DATA_ALIGNMENT + count;
d133 1
a133 1
	  newlink->next = *linkpp;
d152 1
a152 1
      hashtablep = bcachep->indextable[tidx];
d162 1
a162 1
		  for (temp = 0; linkp != NULL; linkp = linkp->next)
d178 2
a179 2
  printf_filtered ("    Cache hits: %d\n", bcachep->cache_hits);
  printf_filtered ("    Cache misses: %d\n", bcachep->cache_misses);
d181 1
a181 1
  if (bcachep->cache_hits + bcachep->cache_misses > 0)
d183 2
a184 2
      printf_filtered ("%d%%\n", ((bcachep->cache_hits) * 100) /
		       (bcachep->cache_hits + bcachep->cache_misses));
d190 3
a192 3
  printf_filtered ("    Space used for caching: %d\n", bcachep->cache_bytes);
  printf_filtered ("    Space saved by cache hits: %d\n", bcachep->cache_savings);
  printf_filtered ("    Number of bcache overflows: %d\n", bcachep->bcache_overflows);
@


1.1.1.4
log
@import gdb-1999-12-06 snapshot
@
text
@d2 2
a3 3
   Written by Fred Fish <fnf@@cygnus.com>
   Rewritten by Jim Blandy <jimb@@cygnus.com>
   Copyright 1999 Free Software Foundation, Inc.
a21 3
#include <stddef.h>
#include <stdlib.h>

d27 3
d31 1
a31 2

/* The hash function.  */
d33 8
a40 2
unsigned long
hash (void *addr, int length)
d42 4
a45 7
  /* If it's a short string, hash on every character.  Otherwise, sample
     characters from throughout the string.  */
  if (length <= 64)
    {
      char *byte = addr;
      unsigned long h = 0;
      int i;
d47 24
a70 2
      for (i = 0; i < length; i++)
	h = h * 65793 ^ (h >> (sizeof (h) * 8 - 6)) ^ byte[i];
d72 2
a73 3
      return h;
    }
  else
d75 2
a76 5
      char *byte = addr;
      int n, i;
      unsigned long h = 0;

      for (n = i = 0; n < 64; n++)
d78 6
a83 2
	  h = h * 65793 + (h >> (sizeof (h) * 8 - 6)) + byte[i];
	  i = h % length;
a84 2

      return h;
d86 1
d89 11
a99 2

/* Growing the bcache's hash table.  */
d101 9
a109 45
/* If the average chain length grows beyond this, then we want to
   resize our hash table.  */
#define CHAIN_LENGTH_THRESHOLD (5)

static void
expand_hash_table (struct bcache *bcache)
{
  /* A table of good hash table sizes.  Whenever we grow, we pick the
     next larger size from this table.  sizes[i] is close to 1 << (i+10),
     so we roughly double the table size each time.  After we fall off 
     the end of this table, we just double.  Don't laugh --- there have
     been executables sighted with a gigabyte of debug info.  */
  static unsigned long sizes[] = { 
    1021, 2053, 4099, 8191, 16381, 32771,
    65537, 131071, 262144, 524287, 1048573, 2097143,
    4194301, 8388617, 16777213, 33554467, 67108859, 134217757,
    268435459, 536870923, 1073741827, 2147483659UL
  };
  int new_num_buckets;
  struct bstring **new_buckets;
  int i;

  /* Find the next size.  */
  for (i = 0; i < (sizeof (sizes) / sizeof (sizes[0])); i++)
    if (sizes[i] > bcache->num_buckets)
      {
	new_num_buckets = sizes[i];
	break;
      }
  if (i >= (sizeof (sizes) / sizeof (sizes[0])))
    new_num_buckets = bcache->num_buckets * 2;

  /* Allocate the new table.  */
  {
    size_t new_size = new_num_buckets * sizeof (new_buckets[0]);
    new_buckets = (struct bstring **) xmalloc (new_size);
    memset (new_buckets, 0, new_size);

    bcache->structure_size -= (bcache->num_buckets
			       * sizeof (bcache->bucket[0]));
    bcache->structure_size += new_size;
  }

  /* Rehash all existing strings.  */
  for (i = 0; i < bcache->num_buckets; i++)
d111 8
a118 3
      struct bstring *s, *next;

      for (s = bcache->bucket[i]; s; s = next)
d120 17
a136 7
	  struct bstring **new_bucket;
	  next = s->next;

	  new_bucket = &new_buckets[(hash (&s->d.data, s->length)
				     % new_num_buckets)];
	  s->next = *new_bucket;
	  *new_bucket = s;
d139 1
a139 6

  /* Plug in the new table.  */
  if (bcache->bucket)
    free (bcache->bucket);
  bcache->bucket = new_buckets;
  bcache->num_buckets = new_num_buckets;
a141 52

/* Looking up things in the bcache.  */

/* The number of bytes needed to allocate a struct bstring whose data
   is N bytes long.  */
#define BSTRING_SIZE(n) (offsetof (struct bstring, d.data) + (n))

/* Find a copy of the LENGTH bytes at ADDR in BCACHE.  If BCACHE has
   never seen those bytes before, add a copy of them to BCACHE.  In
   either case, return a pointer to BCACHE's copy of that string.  */
void *
bcache (void *addr, int length, struct bcache *bcache)
{
  int hash_index;
  struct bstring *s;

  /* If our average chain length is too high, expand the hash table.  */
  if (bcache->unique_count >= bcache->num_buckets * CHAIN_LENGTH_THRESHOLD)
    expand_hash_table (bcache);

  bcache->total_count++;
  bcache->total_size += length;

  hash_index = hash (addr, length) % bcache->num_buckets;

  /* Search the hash bucket for a string identical to the caller's.  */
  for (s = bcache->bucket[hash_index]; s; s = s->next)
    if (s->length == length
	&& ! memcmp (&s->d.data, addr, length))
      return &s->d.data;

  /* The user's string isn't in the list.  Insert it after *ps.  */
  {
    struct bstring *new
      = obstack_alloc (&bcache->cache, BSTRING_SIZE (length));
    memcpy (&new->d.data, addr, length);
    new->length = length;
    new->next = bcache->bucket[hash_index];
    bcache->bucket[hash_index] = new;

    bcache->unique_count++;
    bcache->unique_size += length;
    bcache->structure_size += BSTRING_SIZE (length);

    return &new->d.data;
  }
}


/* Freeing bcaches.  */

/* Free all the storage associated with BCACHE.  */
d143 7
a149 4
free_bcache (struct bcache *bcache)
{
  obstack_free (&bcache->cache, 0);
  free (bcache->bucket);
d151 51
a201 23
  /* This isn't necessary, but at least the bcache is always in a
     consistent state.  */
  memset (bcache, 0, sizeof (*bcache));
}



/* Printing statistics.  */

static int
compare_ints (const void *ap, const void *bp)
{
  /* Because we know we're comparing two ints which are positive,
     there's no danger of overflow here.  */
  return * (int *) ap - * (int *) bp;
}


static void
print_percentage (int portion, int total)
{
  if (total == 0)
    printf_filtered ("(not applicable)\n");
d203 8
a210 86
    printf_filtered ("%3d%%\n", portion * 100 / total);
}


/* Print statistics on BCACHE's memory usage and efficacity at
   eliminating duplication.  NAME should describe the kind of data
   BCACHE holds.  Statistics are printed using `printf_filtered' and
   its ilk.  */
void
print_bcache_statistics (struct bcache *c, char *type)
{
  int occupied_buckets;
  int max_chain_length;
  int median_chain_length;

  /* Count the number of occupied buckets, and measure chain lengths.  */
  {
    int b;
    int *chain_length
      = (int *) alloca (c->num_buckets * sizeof (*chain_length));

    occupied_buckets = 0;

    for (b = 0; b < c->num_buckets; b++)
      {
	struct bstring *s = c->bucket[b];

	chain_length[b] = 0;

	if (s)
	  {
	    occupied_buckets++;
	    
	    while (s)
	      {
		chain_length[b]++;
		s = s->next;
	      }
	  }
      }

    /* To compute the median, we need the set of chain lengths sorted.  */
    qsort (chain_length, c->num_buckets, sizeof (chain_length[0]),
	   compare_ints);

    if (c->num_buckets > 0)
      {
	max_chain_length = chain_length[c->num_buckets - 1];
	median_chain_length = chain_length[c->num_buckets / 2];
      }
    else
      {
	max_chain_length = 0;
	median_chain_length = 0;
      }
  }

  printf_filtered ("  Cached '%s' statistics:\n", type);
  printf_filtered ("    Total object count:  %ld\n", c->total_count);
  printf_filtered ("    Unique object count: %ld\n", c->unique_count);
  printf_filtered ("    Percentage of duplicates, by count: ");
  print_percentage (c->total_count - c->unique_count, c->total_count);
  printf_filtered ("\n");

  printf_filtered ("    Total object size:   %ld\n", c->total_size);
  printf_filtered ("    Unique object size:  %ld\n", c->unique_size);
  printf_filtered ("    Percentage of duplicates, by size:  ");
  print_percentage (c->total_size - c->unique_size, c->total_size);
  printf_filtered ("\n");

  printf_filtered ("    Total memory used by bcache, including overhead: %ld\n",
		   c->structure_size);
  printf_filtered ("    Percentage memory overhead: ");
  print_percentage (c->structure_size - c->unique_size, c->unique_size);
  printf_filtered ("    Net memory savings:         ");
  print_percentage (c->total_size - c->structure_size, c->total_size);
  printf_filtered ("\n");

  printf_filtered ("    Hash table size:           %3d\n", c->num_buckets);
  printf_filtered ("    Hash table population:     ");
  print_percentage (occupied_buckets, c->num_buckets);
  printf_filtered ("    Median hash chain length:  %3d\n",
		   median_chain_length);
  printf_filtered ("    Average hash chain length: ");
  if (c->num_buckets > 0)
    printf_filtered ("%3ld\n", c->unique_count / c->num_buckets);
d212 4
a215 3
    printf_filtered ("(not applicable)\n");
  printf_filtered ("    Maximum hash chain length: %3d\n", max_chain_length);
  printf_filtered ("\n");
@


