head	1.191;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.182
	gdb_7_6-2013-04-26-release:1.182
	gdb_7_6-branch:1.182.0.2
	gdb_7_6-2013-03-12-branchpoint:1.182
	gdb_7_5_1-2012-11-29-release:1.159.2.5
	gdb_7_5-2012-08-17-release:1.159.2.4
	gdb_7_5-branch:1.159.0.2
	gdb_7_5-2012-07-18-branchpoint:1.159
	gdb_7_4_1-2012-04-26-release:1.134.2.5
	gdb_7_4-2012-01-24-release:1.134.2.5
	gdb_7_4-branch:1.134.0.2
	gdb_7_4-2011-12-13-branchpoint:1.134
	gdb_7_3_1-2011-09-04-release:1.117.2.8
	gdb_7_3-2011-07-26-release:1.117.2.8
	gdb_7_3-branch:1.117.0.2
	gdb_7_3-2011-04-01-branchpoint:1.117
	gdb_7_2-2010-09-02-release:1.103
	gdb_7_2-branch:1.103.0.2
	gdb_7_2-2010-07-07-branchpoint:1.103
	gdb_7_1-2010-03-18-release:1.96.2.1
	gdb_7_1-branch:1.96.0.2
	gdb_7_1-2010-02-18-branchpoint:1.96
	gdb_7_0_1-2009-12-22-release:1.89.2.2
	gdb_7_0-2009-10-06-release:1.89.2.2
	gdb_7_0-branch:1.89.0.2
	gdb_7_0-2009-09-16-branchpoint:1.89
	arc-sim-20090309:1.74
	msnyder-checkpoint-072509-branch:1.88.0.2
	msnyder-checkpoint-072509-branchpoint:1.88
	arc-insight_6_8-branch:1.74.0.6
	arc-insight_6_8-branchpoint:1.74
	insight_6_8-branch:1.74.0.4
	insight_6_8-branchpoint:1.74
	reverse-20081226-branch:1.83.0.6
	reverse-20081226-branchpoint:1.83
	multiprocess-20081120-branch:1.83.0.4
	multiprocess-20081120-branchpoint:1.83
	reverse-20080930-branch:1.83.0.2
	reverse-20080930-branchpoint:1.83
	reverse-20080717-branch:1.80.0.4
	reverse-20080717-branchpoint:1.80
	msnyder-reverse-20080609-branch:1.80.0.2
	msnyder-reverse-20080609-branchpoint:1.80
	drow-reverse-20070409-branch:1.67.0.2
	drow-reverse-20070409-branchpoint:1.67
	gdb_6_8-2008-03-27-release:1.74
	gdb_6_8-branch:1.74.0.2
	gdb_6_8-2008-02-26-branchpoint:1.74
	gdb_6_7_1-2007-10-29-release:1.72
	gdb_6_7-2007-10-10-release:1.72
	gdb_6_7-branch:1.72.0.2
	gdb_6_7-2007-09-07-branchpoint:1.72
	insight_6_6-20070208-release:1.65
	gdb_6_6-2006-12-18-release:1.65
	gdb_6_6-branch:1.65.0.18
	gdb_6_6-2006-11-15-branchpoint:1.65
	insight_6_5-20061003-release:1.65
	gdb-csl-symbian-6_4_50_20060226-12:1.65
	gdb-csl-sourcerygxx-3_4_4-25:1.63
	nickrob-async-20060828-mergepoint:1.65
	gdb-csl-symbian-6_4_50_20060226-11:1.65
	gdb-csl-sourcerygxx-4_1-17:1.65
	gdb-csl-20060226-branch-local-2:1.65
	gdb-csl-sourcerygxx-4_1-14:1.65
	gdb-csl-sourcerygxx-4_1-13:1.65
	gdb-csl-sourcerygxx-4_1-12:1.65
	gdb-csl-sourcerygxx-3_4_4-21:1.65
	gdb_6_5-20060621-release:1.65
	gdb-csl-sourcerygxx-4_1-9:1.65
	gdb-csl-sourcerygxx-4_1-8:1.65
	gdb-csl-sourcerygxx-4_1-7:1.65
	gdb-csl-arm-2006q1-6:1.65
	gdb-csl-sourcerygxx-4_1-6:1.65
	gdb-csl-symbian-6_4_50_20060226-10:1.65
	gdb-csl-symbian-6_4_50_20060226-9:1.65
	gdb-csl-symbian-6_4_50_20060226-8:1.65
	gdb-csl-coldfire-4_1-11:1.65
	gdb-csl-sourcerygxx-3_4_4-19:1.65
	gdb-csl-coldfire-4_1-10:1.65
	gdb_6_5-branch:1.65.0.16
	gdb_6_5-2006-05-14-branchpoint:1.65
	gdb-csl-sourcerygxx-4_1-5:1.65
	nickrob-async-20060513-branch:1.65.0.14
	nickrob-async-20060513-branchpoint:1.65
	gdb-csl-sourcerygxx-4_1-4:1.65
	msnyder-reverse-20060502-branch:1.65.0.12
	msnyder-reverse-20060502-branchpoint:1.65
	gdb-csl-morpho-4_1-4:1.65
	gdb-csl-sourcerygxx-3_4_4-17:1.65
	readline_5_1-import-branch:1.65.0.10
	readline_5_1-import-branchpoint:1.65
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.65
	gdb-csl-symbian-20060226-branch:1.65.0.8
	gdb-csl-symbian-20060226-branchpoint:1.65
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.65
	msnyder-reverse-20060331-branch:1.65.0.6
	msnyder-reverse-20060331-branchpoint:1.65
	gdb-csl-available-20060303-branch:1.65.0.4
	gdb-csl-available-20060303-branchpoint:1.65
	gdb-csl-20060226-branch:1.65.0.2
	gdb-csl-20060226-branchpoint:1.65
	gdb_6_4-20051202-release:1.63
	msnyder-fork-checkpoint-branch:1.63.0.10
	msnyder-fork-checkpoint-branchpoint:1.63
	gdb-csl-gxxpro-6_3-branch:1.63.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.63
	gdb_6_4-branch:1.63.0.6
	gdb_6_4-2005-11-01-branchpoint:1.63
	gdb-csl-arm-20051020-branch:1.63.0.4
	gdb-csl-arm-20051020-branchpoint:1.63
	msnyder-tracepoint-checkpoint-branch:1.63.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.63
	gdb-csl-arm-20050325-2005-q1b:1.62
	gdb-csl-arm-20050325-2005-q1a:1.62
	csl-arm-20050325-branch:1.62.0.2
	csl-arm-20050325-branchpoint:1.62
	gdb-post-i18n-errorwarning-20050211:1.60
	gdb-pre-i18n-errorwarning-20050211:1.59
	gdb_6_3-20041109-release:1.57
	gdb_6_3-branch:1.57.0.4
	gdb_6_3-20041019-branchpoint:1.57
	drow_intercu-merge-20040921:1.57
	drow_intercu-merge-20040915:1.57
	jimb-gdb_6_2-e500-branch:1.57.0.6
	jimb-gdb_6_2-e500-branchpoint:1.57
	gdb_6_2-20040730-release:1.57
	gdb_6_2-branch:1.57.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.57
	gdb_6_1_1-20040616-release:1.56
	gdb_6_1-2004-04-05-release:1.56
	drow_intercu-merge-20040402:1.56
	drow_intercu-merge-20040327:1.56
	ezannoni_pie-20040323-branch:1.56.0.10
	ezannoni_pie-20040323-branchpoint:1.56
	cagney_tramp-20040321-mergepoint:1.56
	cagney_tramp-20040309-branch:1.56.0.8
	cagney_tramp-20040309-branchpoint:1.56
	gdb_6_1-branch:1.56.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.56
	drow_intercu-20040221-branch:1.56.0.4
	drow_intercu-20040221-branchpoint:1.56
	cagney_bfdfile-20040213-branch:1.56.0.2
	cagney_bfdfile-20040213-branchpoint:1.56
	drow-cplus-merge-20040208:1.54
	carlton_dictionary-20040126-merge:1.54
	cagney_bigcore-20040122-branch:1.54.0.2
	cagney_bigcore-20040122-branchpoint:1.54
	drow-cplus-merge-20040113:1.53
	drow-cplus-merge-20031224:1.53
	drow-cplus-merge-20031220:1.53
	carlton_dictionary-20031215-merge:1.52
	drow-cplus-merge-20031214:1.52
	carlton-dictionary-20031111-merge:1.52
	gdb_6_0-2003-10-04-release:1.49.4.2
	kettenis_sparc-20030918-branch:1.51.0.6
	kettenis_sparc-20030918-branchpoint:1.51
	carlton_dictionary-20030917-merge:1.51
	ezannoni_pie-20030916-branchpoint:1.51
	ezannoni_pie-20030916-branch:1.51.0.4
	cagney_x86i386-20030821-branch:1.51.0.2
	cagney_x86i386-20030821-branchpoint:1.51
	carlton_dictionary-20030805-merge:1.51
	carlton_dictionary-20030627-merge:1.49
	gdb_6_0-branch:1.49.0.4
	gdb_6_0-2003-06-23-branchpoint:1.49
	jimb-ppc64-linux-20030613-branch:1.49.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.49
	cagney_convert-20030606-branch:1.48.0.2
	cagney_convert-20030606-branchpoint:1.48
	cagney_writestrings-20030508-branch:1.46.0.4
	cagney_writestrings-20030508-branchpoint:1.46
	jimb-ppc64-linux-20030528-branch:1.47.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.47
	carlton_dictionary-20030523-merge:1.47
	cagney_fileio-20030521-branch:1.47.0.2
	cagney_fileio-20030521-branchpoint:1.47
	kettenis_i386newframe-20030517-mergepoint:1.47
	jimb-ppc64-linux-20030509-branch:1.46.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.46
	kettenis_i386newframe-20030504-mergepoint:1.46
	carlton_dictionary-20030430-merge:1.46
	kettenis_i386newframe-20030419-branch:1.45.0.16
	kettenis_i386newframe-20030419-branchpoint:1.45
	carlton_dictionary-20030416-merge:1.45
	cagney_frameaddr-20030409-mergepoint:1.45
	kettenis_i386newframe-20030406-branch:1.45.0.14
	kettenis_i386newframe-20030406-branchpoint:1.45
	cagney_frameaddr-20030403-branchpoint:1.45
	cagney_frameaddr-20030403-branch:1.45.0.12
	cagney_framebase-20030330-mergepoint:1.45
	cagney_framebase-20030326-branch:1.45.0.10
	cagney_framebase-20030326-branchpoint:1.45
	cagney_lazyid-20030317-branch:1.45.0.8
	cagney_lazyid-20030317-branchpoint:1.45
	kettenis-i386newframe-20030316-mergepoint:1.45
	offbyone-20030313-branch:1.45.0.6
	offbyone-20030313-branchpoint:1.45
	kettenis-i386newframe-20030308-branch:1.45.0.4
	kettenis-i386newframe-20030308-branchpoint:1.45
	carlton_dictionary-20030305-merge:1.45
	cagney_offbyone-20030303-branch:1.45.0.2
	cagney_offbyone-20030303-branchpoint:1.45
	carlton_dictionary-20030207-merge:1.40
	interps-20030203-mergepoint:1.38
	interps-20030202-branch:1.38.0.2
	interps-20030202-branchpoint:1.38
	cagney-unwind-20030108-branch:1.34.0.2
	cagney-unwind-20030108-branchpoint:1.34
	carlton_dictionary-20021223-merge:1.32
	gdb_5_3-2002-12-12-release:1.21
	carlton_dictionary-20021115-merge:1.28
	kseitz_interps-20021105-merge:1.25
	kseitz_interps-20021103-merge:1.25
	drow-cplus-merge-20021020:1.23
	drow-cplus-merge-20021025:1.25
	carlton_dictionary-20021025-merge:1.25
	carlton_dictionary-20021011-merge:1.23
	drow-cplus-branch:1.23.0.2
	drow-cplus-branchpoint:1.23
	kseitz_interps-20020930-merge:1.23
	carlton_dictionary-20020927-merge:1.23
	carlton_dictionary-branch:1.22.0.2
	carlton_dictionary-20020920-branchpoint:1.22
	gdb_5_3-branch:1.21.0.10
	gdb_5_3-2002-09-04-branchpoint:1.21
	kseitz_interps-20020829-merge:1.21
	cagney_sysregs-20020825-branch:1.21.0.8
	cagney_sysregs-20020825-branchpoint:1.21
	readline_4_3-import-branch:1.21.0.6
	readline_4_3-import-branchpoint:1.21
	gdb_5_2_1-2002-07-23-release:1.16
	kseitz_interps-20020528-branch:1.21.0.4
	kseitz_interps-20020528-branchpoint:1.21
	cagney_regbuf-20020515-branch:1.21.0.2
	cagney_regbuf-20020515-branchpoint:1.21
	jimb-macro-020506-branch:1.18.0.2
	jimb-macro-020506-branchpoint:1.18
	gdb_5_2-2002-04-29-release:1.16
	gdb_5_2-branch:1.16.0.2
	gdb_5_2-2002-03-03-branchpoint:1.16
	gdb_5_1_1-2002-01-24-release:1.11
	gdb_5_1_0_1-2002-01-03-release:1.11
	cygnus_cvs_20020108_pre:1.13
	gdb_5_1_0_1-2002-01-03-branchpoint:1.11
	gdb_5_1_0_1-2002-01-03-branch:1.11.0.8
	gdb_5_1-2001-11-21-release:1.11
	gdb_s390-2001-09-26-branch:1.11.0.6
	gdb_s390-2001-09-26-branchpoint:1.11
	gdb_5_1-2001-07-29-branch:1.11.0.4
	gdb_5_1-2001-07-29-branchpoint:1.11
	dberlin-typesystem-branch:1.11.0.2
	dberlin-typesystem-branchpoint:1.11
	gdb-post-ptid_t-2001-05-03:1.11
	gdb-pre-ptid_t-2001-05-03:1.11
	insight-precleanup-2001-01-01:1.4;
locks; strict;
comment	@ * @;


1.191
date	2013.10.02.00.46.06;	author kseitz;	state Exp;
branches;
next	1.190;

1.190
date	2013.09.23.18.07.46;	author tromey;	state Exp;
branches;
next	1.189;

1.189
date	2013.08.20.15.04.51;	author tromey;	state Exp;
branches;
next	1.188;

1.188
date	2013.08.12.11.54.04;	author alianwar;	state Exp;
branches;
next	1.187;

1.187
date	2013.08.07.19.52.16;	author tromey;	state Exp;
branches;
next	1.186;

1.186
date	2013.08.01.23.35.04;	author devans;	state Exp;
branches;
next	1.185;

1.185
date	2013.05.30.16.57.38;	author tromey;	state Exp;
branches;
next	1.184;

1.184
date	2013.05.14.20.41.45;	author jkratoch;	state Exp;
branches;
next	1.183;

1.183
date	2013.04.08.20.18.11;	author tromey;	state Exp;
branches;
next	1.182;

1.182
date	2013.03.12.17.39.43;	author kseitz;	state Exp;
branches;
next	1.181;

1.181
date	2013.03.11.18.24.59;	author devans;	state Exp;
branches;
next	1.180;

1.180
date	2013.03.06.11.05.54;	author muller;	state Exp;
branches;
next	1.179;

1.179
date	2013.03.05.21.15.34;	author devans;	state Exp;
branches;
next	1.178;

1.178
date	2013.03.04.19.38.02;	author jkratoch;	state Exp;
branches;
next	1.177;

1.177
date	2013.03.04.19.30.25;	author jkratoch;	state Exp;
branches;
next	1.176;

1.176
date	2013.02.03.16.13.29;	author jkratoch;	state Exp;
branches;
next	1.175;

1.175
date	2013.01.23.20.07.39;	author devans;	state Exp;
branches;
next	1.174;

1.174
date	2013.01.01.06.32.46;	author brobecke;	state Exp;
branches;
next	1.173;

1.173
date	2012.12.24.19.42.15;	author jkratoch;	state Exp;
branches;
next	1.172;

1.172
date	2012.11.10.20.25.56;	author kseitz;	state Exp;
branches;
next	1.171;

1.171
date	2012.10.11.16.12.04;	author devans;	state Exp;
branches;
next	1.170;

1.170
date	2012.09.25.12.22.54;	author brobecke;	state Exp;
branches;
next	1.169;

1.169
date	2012.09.18.16.52.18;	author brobecke;	state Exp;
branches;
next	1.168;

1.168
date	2012.08.11.00.20.18;	author sergiodj;	state Exp;
branches;
next	1.167;

1.167
date	2012.07.30.17.45.36;	author kseitz;	state Exp;
branches;
next	1.166;

1.166
date	2012.07.26.16.22.48;	author kseitz;	state Exp;
branches;
next	1.165;

1.165
date	2012.07.25.12.26.27;	author teawater;	state Exp;
branches;
next	1.164;

1.164
date	2012.07.23.20.40.07;	author kseitz;	state Exp;
branches;
next	1.163;

1.163
date	2012.07.23.20.31.34;	author kseitz;	state Exp;
branches;
next	1.162;

1.162
date	2012.07.18.20.38.18;	author kseitz;	state Exp;
branches;
next	1.161;

1.161
date	2012.07.18.20.30.01;	author kseitz;	state Exp;
branches;
next	1.160;

1.160
date	2012.07.18.03.35.29;	author kseitz;	state Exp;
branches;
next	1.159;

1.159
date	2012.06.29.22.46.44;	author devans;	state Exp;
branches
	1.159.2.1;
next	1.158;

1.158
date	2012.06.04.02.57.28;	author devans;	state Exp;
branches;
next	1.157;

1.157
date	2012.05.31.18.44.49;	author kseitz;	state Exp;
branches;
next	1.156;

1.156
date	2012.05.18.21.02.48;	author sergiodj;	state Exp;
branches;
next	1.155;

1.155
date	2012.04.18.14.56.59;	author tromey;	state Exp;
branches;
next	1.154;

1.154
date	2012.04.05.18.50.27;	author kseitz;	state Exp;
branches;
next	1.153;

1.153
date	2012.03.16.16.47.30;	author gary;	state Exp;
branches;
next	1.152;

1.152
date	2012.03.01.20.33.09;	author kseitz;	state Exp;
branches;
next	1.151;

1.151
date	2012.02.10.17.31.34;	author tromey;	state Exp;
branches;
next	1.150;

1.150
date	2012.02.10.13.27.04;	author jkratoch;	state Exp;
branches;
next	1.149;

1.149
date	2012.02.08.19.54.37;	author brobecke;	state Exp;
branches;
next	1.148;

1.148
date	2012.02.07.04.48.21;	author devans;	state Exp;
branches;
next	1.147;

1.147
date	2012.02.01.16.10.31;	author gary;	state Exp;
branches;
next	1.146;

1.146
date	2012.01.27.20.31.13;	author jkratoch;	state Exp;
branches;
next	1.145;

1.145
date	2012.01.26.04.21.40;	author brobecke;	state Exp;
branches;
next	1.144;

1.144
date	2012.01.26.04.20.36;	author brobecke;	state Exp;
branches;
next	1.143;

1.143
date	2012.01.17.20.30.22;	author devans;	state Exp;
branches;
next	1.142;

1.142
date	2012.01.04.14.24.57;	author brobecke;	state Exp;
branches;
next	1.141;

1.141
date	2012.01.04.13.15.20;	author brobecke;	state Exp;
branches;
next	1.140;

1.140
date	2012.01.04.08.17.05;	author brobecke;	state Exp;
branches;
next	1.139;

1.139
date	2011.12.27.04.07.03;	author brobecke;	state Exp;
branches;
next	1.138;

1.138
date	2011.12.21.07.24.40;	author brobecke;	state Exp;
branches;
next	1.137;

1.137
date	2011.12.16.21.39.16;	author tromey;	state Exp;
branches;
next	1.136;

1.136
date	2011.12.16.21.35.57;	author tromey;	state Exp;
branches;
next	1.135;

1.135
date	2011.12.14.14.34.59;	author brobecke;	state Exp;
branches;
next	1.134;

1.134
date	2011.12.09.19.22.31;	author pinskia;	state Exp;
branches
	1.134.2.1;
next	1.133;

1.133
date	2011.12.06.19.57.47;	author devans;	state Exp;
branches;
next	1.132;

1.132
date	2011.12.06.18.54.39;	author tromey;	state Exp;
branches;
next	1.131;

1.131
date	2011.11.11.19.52.46;	author kseitz;	state Exp;
branches;
next	1.130;

1.130
date	2011.08.26.17.58.57;	author aristovski;	state Exp;
branches;
next	1.129;

1.129
date	2011.08.18.16.17.38;	author kseitz;	state Exp;
branches;
next	1.128;

1.128
date	2011.07.05.20.30.19;	author tromey;	state Exp;
branches;
next	1.127;

1.127
date	2011.07.04.18.31.25;	author bauermann;	state Exp;
branches;
next	1.126;

1.126
date	2011.07.04.14.16.14;	author jkratoch;	state Exp;
branches;
next	1.125;

1.125
date	2011.07.01.20.27.58;	author jkratoch;	state Exp;
branches;
next	1.124;

1.124
date	2011.07.01.20.19.03;	author jkratoch;	state Exp;
branches;
next	1.123;

1.123
date	2011.07.01.20.16.38;	author jkratoch;	state Exp;
branches;
next	1.122;

1.122
date	2011.05.31.22.13.51;	author kseitz;	state Exp;
branches;
next	1.121;

1.121
date	2011.05.31.21.54.07;	author kseitz;	state Exp;
branches;
next	1.120;

1.120
date	2011.05.24.21.00.09;	author kseitz;	state Exp;
branches;
next	1.119;

1.119
date	2011.05.18.16.30.35;	author tromey;	state Exp;
branches;
next	1.118;

1.118
date	2011.04.04.17.41.07;	author tromey;	state Exp;
branches;
next	1.117;

1.117
date	2011.03.25.17.13.12;	author tromey;	state Exp;
branches
	1.117.2.1;
next	1.116;

1.116
date	2011.03.24.20.25.14;	author tromey;	state Exp;
branches;
next	1.115;

1.115
date	2011.03.24.19.39.49;	author tromey;	state Exp;
branches;
next	1.114;

1.114
date	2011.03.16.21.12.12;	author kseitz;	state Exp;
branches;
next	1.113;

1.113
date	2011.03.04.20.07.22;	author bauermann;	state Exp;
branches;
next	1.112;

1.112
date	2011.03.01.22.16.40;	author msnyder;	state Exp;
branches;
next	1.111;

1.111
date	2011.03.01.20.57.52;	author msnyder;	state Exp;
branches;
next	1.110;

1.110
date	2011.03.01.00.26.14;	author msnyder;	state Exp;
branches;
next	1.109;

1.109
date	2011.01.09.03.08.57;	author msnyder;	state Exp;
branches;
next	1.108;

1.108
date	2011.01.06.09.30.35;	author brobecke;	state Exp;
branches;
next	1.107;

1.107
date	2011.01.05.22.22.49;	author msnyder;	state Exp;
branches;
next	1.106;

1.106
date	2011.01.01.15.33.09;	author brobecke;	state Exp;
branches;
next	1.105;

1.105
date	2010.12.02.20.05.59;	author kseitz;	state Exp;
branches;
next	1.104;

1.104
date	2010.07.13.20.07.44;	author tromey;	state Exp;
branches;
next	1.103;

1.103
date	2010.05.14.23.41.04;	author msnyder;	state Exp;
branches;
next	1.102;

1.102
date	2010.05.06.19.14.08;	author msnyder;	state Exp;
branches;
next	1.101;

1.101
date	2010.05.02.23.52.14;	author jkratoch;	state Exp;
branches;
next	1.100;

1.100
date	2010.05.02.21.14.59;	author jkratoch;	state Exp;
branches;
next	1.99;

1.99
date	2010.03.26.19.41.50;	author uweigand;	state Exp;
branches;
next	1.98;

1.98
date	2010.03.09.18.09.07;	author kseitz;	state Exp;
branches;
next	1.97;

1.97
date	2010.03.04.18.38.35;	author kseitz;	state Exp;
branches;
next	1.96;

1.96
date	2010.02.16.20.51.49;	author drow;	state Exp;
branches
	1.96.2.1;
next	1.95;

1.95
date	2010.01.12.05.48.56;	author brobecke;	state Exp;
branches;
next	1.94;

1.94
date	2010.01.01.07.31.36;	author brobecke;	state Exp;
branches;
next	1.93;

1.93
date	2009.11.11.23.34.11;	author kseitz;	state Exp;
branches;
next	1.92;

1.92
date	2009.10.19.09.51.41;	author palves;	state Exp;
branches;
next	1.91;

1.91
date	2009.09.29.00.48.31;	author uweigand;	state Exp;
branches;
next	1.90;

1.90
date	2009.09.21.19.46.43;	author kseitz;	state Exp;
branches;
next	1.89;

1.89
date	2009.08.14.00.32.32;	author palves;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2009.06.25.18.01.06;	author klo;	state Exp;
branches;
next	1.87;

1.87
date	2009.06.16.18.39.41;	author kseitz;	state Exp;
branches;
next	1.86;

1.86
date	2009.06.03.18.16.44;	author uweigand;	state Exp;
branches;
next	1.85;

1.85
date	2009.05.23.16.17.17;	author jkratoch;	state Exp;
branches;
next	1.84;

1.84
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.83;

1.83
date	2008.09.05.11.37.17;	author uweigand;	state Exp;
branches
	1.83.4.1;
next	1.82;

1.82
date	2008.08.21.18.14.39;	author drow;	state Exp;
branches;
next	1.81;

1.81
date	2008.08.20.11.47.57;	author palves;	state Exp;
branches;
next	1.80;

1.80
date	2008.05.23.23.39.03;	author schwab;	state Exp;
branches;
next	1.79;

1.79
date	2008.05.19.15.50.09;	author uweigand;	state Exp;
branches;
next	1.78;

1.78
date	2008.05.15.19.24.46;	author brobecke;	state Exp;
branches;
next	1.77;

1.77
date	2008.05.03.00.37.34;	author uweigand;	state Exp;
branches;
next	1.76;

1.76
date	2008.04.19.06.09.37;	author nickrob;	state Exp;
branches;
next	1.75;

1.75
date	2008.04.03.21.39.16;	author brobecke;	state Exp;
branches;
next	1.74;

1.74
date	2008.01.01.22.53.11;	author drow;	state Exp;
branches;
next	1.73;

1.73
date	2007.09.24.07.40.32;	author vprus;	state Exp;
branches;
next	1.72;

1.72
date	2007.08.23.18.08.35;	author brobecke;	state Exp;
branches;
next	1.71;

1.71
date	2007.08.10.22.01.27;	author msnyder;	state Exp;
branches;
next	1.70;

1.70
date	2007.07.31.19.58.39;	author drow;	state Exp;
branches;
next	1.69;

1.69
date	2007.06.18.18.23.08;	author uweigand;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.09.14.15.52;	author uweigand;	state Exp;
branches;
next	1.67;

1.67
date	2007.03.28.00.12.15;	author palves;	state Exp;
branches;
next	1.66;

1.66
date	2007.01.09.17.58.51;	author drow;	state Exp;
branches;
next	1.65;

1.65
date	2006.01.10.22.14.43;	author kettenis;	state Exp;
branches;
next	1.64;

1.64
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.63;

1.63
date	2005.04.26.14.57.21;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2005.02.12.00.39.20;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2005.02.11.18.13.50;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2005.02.11.04.05.56;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2005.01.14.20.24.20;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2004.11.12.21.45.06;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2004.06.18.21.36.15;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2004.02.11.18.04.14;	author carlton;	state Exp;
branches
	1.56.4.1;
next	1.55;

1.55
date	2004.02.09.22.29.21;	author ezannoni;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.20.02.04.19;	author jjohnstn;	state Exp;
branches;
next	1.53;

1.53
date	2003.12.17.21.47.47;	author jjohnstn;	state Exp;
branches;
next	1.52;

1.52
date	2003.10.20.14.38.42;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2003.08.02.03.59.40;	author fedor;	state Exp;
branches;
next	1.50;

1.50
date	2003.07.23.19.24.31;	author ezannoni;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.08.18.27.13;	author cagney;	state Exp;
branches
	1.49.4.1;
next	1.48;

1.48
date	2003.06.03.02.56.04;	author carlton;	state Exp;
branches;
next	1.47;

1.47
date	2003.05.14.17.43.18;	author ezannoni;	state Exp;
branches;
next	1.46;

1.46
date	2003.04.27.03.23.38;	author fedor;	state Exp;
branches
	1.46.4.1;
next	1.45;

1.45
date	2003.03.03.17.20.24;	author carlton;	state Exp;
branches
	1.45.16.1;
next	1.44;

1.44
date	2003.02.28.17.21.16;	author carlton;	state Exp;
branches;
next	1.43;

1.43
date	2003.02.25.21.36.18;	author carlton;	state Exp;
branches;
next	1.42;

1.42
date	2003.02.20.17.17.24;	author carlton;	state Exp;
branches;
next	1.41;

1.41
date	2003.02.20.00.01.05;	author carlton;	state Exp;
branches;
next	1.40;

1.40
date	2003.02.07.00.27.30;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2003.02.04.21.24.21;	author carlton;	state Exp;
branches;
next	1.38;

1.38
date	2003.01.14.20.48.50;	author carlton;	state Exp;
branches;
next	1.37;

1.37
date	2003.01.12.20.55.32;	author carlton;	state Exp;
branches;
next	1.36;

1.36
date	2003.01.11.01.01.04;	author carlton;	state Exp;
branches;
next	1.35;

1.35
date	2003.01.09.21.34.15;	author carlton;	state Exp;
branches;
next	1.34;

1.34
date	2003.01.08.22.40.18;	author carlton;	state Exp;
branches;
next	1.33;

1.33
date	2003.01.07.17.05.49;	author carlton;	state Exp;
branches;
next	1.32;

1.32
date	2002.12.19.18.56.14;	author carlton;	state Exp;
branches;
next	1.31;

1.31
date	2002.12.09.19.49.00;	author carlton;	state Exp;
branches;
next	1.30;

1.30
date	2002.12.05.22.25.49;	author carlton;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.15.21.55.16;	author carlton;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.11.23.20.07;	author carlton;	state Exp;
branches;
next	1.27;

1.27
date	2002.11.11.21.18.55;	author carlton;	state Exp;
branches;
next	1.26;

1.26
date	2002.11.08.19.16.17;	author carlton;	state Exp;
branches;
next	1.25;

1.25
date	2002.10.24.21.02.53;	author ezannoni;	state Exp;
branches;
next	1.24;

1.24
date	2002.10.24.00.13.57;	author carlton;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.22.22.18.41;	author fnasser;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2002.09.20.14.58.58;	author fnasser;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2002.05.11.22.46.19;	author drow;	state Exp;
branches
	1.21.4.1;
next	1.20;

1.20
date	2002.05.10.20.05.27;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.10.00.29.23;	author ezannoni;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.05.22.04.41;	author jimb;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.22.18.57.07;	author drow;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.14.23.57.50;	author drow;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.14.23.40.23;	author drow;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.02.03.42.58;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.10.22.04.10;	author fnf;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.10.21.34.56;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.27.00.19.09;	author jimb;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.03.23.00.41.01;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.21.20.51.15;	author jimb;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.20.16.17.22;	author jimb;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.15.18.02.14;	author hunt;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.14.18.36.45;	author kseitz;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.06.08.21.09;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.01.01.48;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.01.00.41.27;	author fnasser;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.19.17.27.38;	author jimb;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.10.23.02.56;	author fnasser;	state Exp;
branches;
next	;

1.159.2.1
date	2012.07.23.21.12.34;	author kseitz;	state Exp;
branches;
next	1.159.2.2;

1.159.2.2
date	2012.07.25.12.50.08;	author teawater;	state Exp;
branches;
next	1.159.2.3;

1.159.2.3
date	2012.07.26.16.34.45;	author kseitz;	state Exp;
branches;
next	1.159.2.4;

1.159.2.4
date	2012.07.30.18.03.57;	author kseitz;	state Exp;
branches;
next	1.159.2.5;

1.159.2.5
date	2012.10.11.16.57.43;	author devans;	state Exp;
branches;
next	;

1.134.2.1
date	2011.12.16.21.36.36;	author tromey;	state Exp;
branches;
next	1.134.2.2;

1.134.2.2
date	2011.12.16.21.39.58;	author tromey;	state Exp;
branches;
next	1.134.2.3;

1.134.2.3
date	2012.01.04.13.23.08;	author brobecke;	state Exp;
branches;
next	1.134.2.4;

1.134.2.4
date	2012.01.04.13.23.50;	author brobecke;	state Exp;
branches;
next	1.134.2.5;

1.134.2.5
date	2012.01.06.04.43.19;	author brobecke;	state Exp;
branches;
next	;

1.117.2.1
date	2011.07.02.19.33.09;	author jkratoch;	state Exp;
branches;
next	1.117.2.2;

1.117.2.2
date	2011.07.02.19.34.43;	author jkratoch;	state Exp;
branches;
next	1.117.2.3;

1.117.2.3
date	2011.07.02.19.37.21;	author jkratoch;	state Exp;
branches;
next	1.117.2.4;

1.117.2.4
date	2011.07.02.19.40.12;	author jkratoch;	state Exp;
branches;
next	1.117.2.5;

1.117.2.5
date	2011.07.02.20.07.57;	author jkratoch;	state Exp;
branches;
next	1.117.2.6;

1.117.2.6
date	2011.07.02.20.10.29;	author jkratoch;	state Exp;
branches;
next	1.117.2.7;

1.117.2.7
date	2011.07.02.20.13.08;	author jkratoch;	state Exp;
branches;
next	1.117.2.8;

1.117.2.8
date	2011.07.04.14.19.14;	author jkratoch;	state Exp;
branches;
next	;

1.96.2.1
date	2010.02.19.01.00.06;	author brobecke;	state Exp;
branches;
next	;

1.89.2.1
date	2009.09.29.00.49.18;	author uweigand;	state Exp;
branches;
next	1.89.2.2;

1.89.2.2
date	2009.09.29.18.59.39;	author uweigand;	state Exp;
branches;
next	;

1.83.4.1
date	2008.11.21.02.31.57;	author shebs;	state Exp;
branches;
next	;

1.56.4.1
date	2004.09.16.17.01.11;	author drow;	state Exp;
branches;
next	;

1.49.4.1
date	2003.07.23.19.28.35;	author ezannoni;	state Exp;
branches;
next	1.49.4.2;

1.49.4.2
date	2003.09.09.03.57.17;	author fedor;	state Exp;
branches;
next	;

1.46.4.1
date	2003.06.03.20.54.38;	author cagney;	state Exp;
branches;
next	;

1.45.16.1
date	2003.05.04.11.37.43;	author kettenis;	state Exp;
branches;
next	1.45.16.2;

1.45.16.2
date	2003.05.18.09.44.15;	author kettenis;	state Exp;
branches;
next	;

1.23.2.1
date	2002.10.26.17.12.08;	author drow;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2003.12.14.20.27.20;	author drow;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2003.12.20.18.16.49;	author drow;	state Exp;
branches;
next	1.23.2.4;

1.23.2.4
date	2004.02.09.19.43.41;	author drow;	state Exp;
branches;
next	;

1.22.2.1
date	2002.09.27.20.03.06;	author carlton;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2002.10.18.23.42.58;	author carlton;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2002.10.25.23.49.54;	author carlton;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2002.10.29.01.07.47;	author carlton;	state Exp;
branches;
next	1.22.2.5;

1.22.2.5
date	2002.11.01.01.12.52;	author carlton;	state Exp;
branches;
next	1.22.2.6;

1.22.2.6
date	2002.11.02.01.37.03;	author carlton;	state Exp;
branches;
next	1.22.2.7;

1.22.2.7
date	2002.11.05.01.22.21;	author carlton;	state Exp;
branches;
next	1.22.2.8;

1.22.2.8
date	2002.11.07.00.59.50;	author carlton;	state Exp;
branches;
next	1.22.2.9;

1.22.2.9
date	2002.11.14.00.07.54;	author carlton;	state Exp;
branches;
next	1.22.2.10;

1.22.2.10
date	2002.11.16.00.16.57;	author carlton;	state Exp;
branches;
next	1.22.2.11;

1.22.2.11
date	2002.11.23.00.42.54;	author carlton;	state Exp;
branches;
next	1.22.2.12;

1.22.2.12
date	2002.11.28.00.53.23;	author carlton;	state Exp;
branches;
next	1.22.2.13;

1.22.2.13
date	2002.12.21.00.17.43;	author carlton;	state Exp;
branches;
next	1.22.2.14;

1.22.2.14
date	2003.02.12.23.37.09;	author carlton;	state Exp;
branches;
next	1.22.2.15;

1.22.2.15
date	2003.02.22.01.33.13;	author carlton;	state Exp;
branches;
next	1.22.2.16;

1.22.2.16
date	2003.03.06.00.56.30;	author carlton;	state Exp;
branches;
next	1.22.2.17;

1.22.2.17
date	2003.05.01.00.46.50;	author carlton;	state Exp;
branches;
next	1.22.2.18;

1.22.2.18
date	2003.05.02.20.36.08;	author carlton;	state Exp;
branches;
next	1.22.2.19;

1.22.2.19
date	2003.05.09.18.28.52;	author carlton;	state Exp;
branches;
next	1.22.2.20;

1.22.2.20
date	2003.05.23.18.40.41;	author carlton;	state Exp;
branches;
next	1.22.2.21;

1.22.2.21
date	2003.06.27.21.50.05;	author carlton;	state Exp;
branches;
next	1.22.2.22;

1.22.2.22
date	2004.01.26.19.11.27;	author carlton;	state Exp;
branches;
next	;

1.21.4.1
date	2002.10.01.00.46.10;	author kseitz;	state Exp;
branches;
next	1.21.4.2;

1.21.4.2
date	2002.11.04.00.17.32;	author ezannoni;	state Exp;
branches;
next	;

1.11.2.1
date	2001.07.06.19.17.01;	author dberlin;	state Exp;
branches;
next	;


desc
@@


1.191
log
@Constification of parse_linespec and fallout:
https://sourceware.org/ml/gdb-patches/2013-09/msg01017.html
https://sourceware.org/ml/gdb-patches/2013-09/msg01018.html
https://sourceware.org/ml/gdb-patches/2013-09/msg01019.html
https://sourceware.org/ml/gdb-patches/2013-09/msg01020.html
@
text
@/* Parser for linespec for the GNU debugger, GDB.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "symtab.h"
#include "frame.h"
#include "command.h"
#include "symfile.h"
#include "objfiles.h"
#include "source.h"
#include "demangle.h"
#include "value.h"
#include "completer.h"
#include "cp-abi.h"
#include "cp-support.h"
#include "parser-defs.h"
#include "block.h"
#include "objc-lang.h"
#include "linespec.h"
#include "exceptions.h"
#include "language.h"
#include "interps.h"
#include "mi/mi-cmds.h"
#include "target.h"
#include "arch-utils.h"
#include <ctype.h>
#include "cli/cli-utils.h"
#include "filenames.h"
#include "ada-lang.h"
#include "stack.h"

typedef struct symbol *symbolp;
DEF_VEC_P (symbolp);

typedef struct type *typep;
DEF_VEC_P (typep);

/* An address entry is used to ensure that any given location is only
   added to the result a single time.  It holds an address and the
   program space from which the address came.  */

struct address_entry
{
  struct program_space *pspace;
  CORE_ADDR addr;
};

typedef struct bound_minimal_symbol bound_minimal_symbol_d;

DEF_VEC_O (bound_minimal_symbol_d);

/* An enumeration of possible signs for a line offset.  */
enum offset_relative_sign
{
  /* No sign  */
  LINE_OFFSET_NONE,

  /* A plus sign ("+")  */
  LINE_OFFSET_PLUS,

  /* A minus sign ("-")  */
  LINE_OFFSET_MINUS,

  /* A special "sign" for unspecified offset.  */
  LINE_OFFSET_UNKNOWN
};

/* A line offset in a linespec.  */

struct line_offset
{
  /* Line offset and any specified sign.  */
  int offset;
  enum offset_relative_sign sign;
};

/* A linespec.  Elements of this structure are filled in by a parser
   (either parse_linespec or some other function).  The structure is
   then converted into SALs by convert_linespec_to_sals.  */

struct linespec
{
  /* An expression and the resulting PC.  Specifying an expression
     currently precludes the use of other members.  */

  /* The expression entered by the user.  */
  const char *expression;

  /* The resulting PC expression derived from evaluating EXPRESSION.  */
  CORE_ADDR expr_pc;

  /* Any specified file symtabs.  */

  /* The user-supplied source filename or NULL if none was specified.  */
  const char *source_filename;

  /* The list of symtabs to search to which to limit the search.  May not
     be NULL.  If SOURCE_FILENAME is NULL (no user-specified filename),
     FILE_SYMTABS should contain one single NULL member.  This will
     cause the code to use the default symtab.  */
  VEC (symtab_ptr) *file_symtabs;

  /* The name of a function or method and any matching symbols.  */

  /* The user-specified function name.  If no function name was
     supplied, this may be NULL.  */
  const char *function_name;

  /* A list of matching function symbols and minimal symbols.  Both lists
     may be NULL if no matching symbols were found.  */
  VEC (symbolp) *function_symbols;
  VEC (bound_minimal_symbol_d) *minimal_symbols;

  /* The name of a label and matching symbols.  */

  /* The user-specified label name.  */
  const char *label_name;

  /* A structure of matching label symbols and the corresponding
     function symbol in which the label was found.  Both may be NULL
     or both must be non-NULL.  */
  struct
  {
    VEC (symbolp) *label_symbols;
    VEC (symbolp) *function_symbols;
  } labels;

  /* Line offset.  It may be LINE_OFFSET_UNKNOWN, meaning that no
   offset was specified.  */
  struct line_offset line_offset;
};
typedef struct linespec *linespec_p;

/* A canonical linespec represented as a symtab-related string.

   Each entry represents the "SYMTAB:SUFFIX" linespec string.
   SYMTAB can be converted for example by symtab_to_fullname or
   symtab_to_filename_for_display as needed.  */

struct linespec_canonical_name
{
  /* Remaining text part of the linespec string.  */
  char *suffix;

  /* If NULL then SUFFIX is the whole linespec string.  */
  struct symtab *symtab;
};

/* An instance of this is used to keep all state while linespec
   operates.  This instance is passed around as a 'this' pointer to
   the various implementation methods.  */

struct linespec_state
{
  /* The language in use during linespec processing.  */
  const struct language_defn *language;

  /* The program space as seen when the module was entered.  */
  struct program_space *program_space;

  /* The default symtab to use, if no other symtab is specified.  */
  struct symtab *default_symtab;

  /* The default line to use.  */
  int default_line;

  /* The 'funfirstline' value that was passed in to decode_line_1 or
     decode_line_full.  */
  int funfirstline;

  /* Nonzero if we are running in 'list' mode; see decode_line_list.  */
  int list_mode;

  /* The 'canonical' value passed to decode_line_full, or NULL.  */
  struct linespec_result *canonical;

  /* Canonical strings that mirror the symtabs_and_lines result.  */
  struct linespec_canonical_name *canonical_names;

  /* This is a set of address_entry objects which is used to prevent
     duplicate symbols from being entered into the result.  */
  htab_t addr_set;
};

/* This is a helper object that is used when collecting symbols into a
   result.  */

struct collect_info
{
  /* The linespec object in use.  */
  struct linespec_state *state;

  /* A list of symtabs to which to restrict matches.  */
  VEC (symtab_ptr) *file_symtabs;

  /* The result being accumulated.  */
  struct
  {
    VEC (symbolp) *symbols;
    VEC (bound_minimal_symbol_d) *minimal_symbols;
  } result;
};

/* Token types  */

enum ls_token_type
{
  /* A keyword  */
  LSTOKEN_KEYWORD = 0,

  /* A colon "separator"  */
  LSTOKEN_COLON,

  /* A string  */
  LSTOKEN_STRING,

  /* A number  */
  LSTOKEN_NUMBER,

  /* A comma  */
  LSTOKEN_COMMA,

  /* EOI (end of input)  */
  LSTOKEN_EOI,

  /* Consumed token  */
  LSTOKEN_CONSUMED
};
typedef enum ls_token_type linespec_token_type;

/* List of keywords  */

static const char * const linespec_keywords[] = { "if", "thread", "task" };

/* A token of the linespec lexer  */

struct ls_token
{
  /* The type of the token  */
  linespec_token_type type;

  /* Data for the token  */
  union
  {
    /* A string, given as a stoken  */
    struct stoken string;

    /* A keyword  */
    const char *keyword;
  } data;
};
typedef struct ls_token linespec_token;

#define LS_TOKEN_STOKEN(TOK) (TOK).data.string
#define LS_TOKEN_KEYWORD(TOK) (TOK).data.keyword

/* An instance of the linespec parser.  */

struct ls_parser
{
  /* Lexer internal data  */
  struct
  {
    /* Save head of input stream.  */
    const char *saved_arg;

    /* Head of the input stream.  */
    const char **stream;
#define PARSER_STREAM(P) (*(P)->lexer.stream)

    /* The current token.  */
    linespec_token current;
  } lexer;

  /* Is the entire linespec quote-enclosed?  */
  int is_quote_enclosed;

  /* Is a keyword syntactically valid at this point?
     In, e.g., "break thread thread 1", the leading "keyword" must not
     be interpreted as such.  */
  int keyword_ok;

  /* The state of the parse.  */
  struct linespec_state state;
#define PARSER_STATE(PPTR) (&(PPTR)->state)

  /* The result of the parse.  */
  struct linespec result;
#define PARSER_RESULT(PPTR) (&(PPTR)->result)
};
typedef struct ls_parser linespec_parser;

/* Prototypes for local functions.  */

static void iterate_over_file_blocks (struct symtab *symtab,
				      const char *name, domain_enum domain,
				      symbol_found_callback_ftype *callback,
				      void *data);

static void initialize_defaults (struct symtab **default_symtab,
				 int *default_line);

static CORE_ADDR linespec_expression_to_pc (const char **exp_ptr);

static struct symtabs_and_lines decode_objc (struct linespec_state *self,
					     linespec_p ls,
					     const char **argptr);

static VEC (symtab_ptr) *symtabs_from_filename (const char *);

static VEC (symbolp) *find_label_symbols (struct linespec_state *self,
					  VEC (symbolp) *function_symbols,
					  VEC (symbolp) **label_funcs_ret,
					  const char *name);

static void find_linespec_symbols (struct linespec_state *self,
				   VEC (symtab_ptr) *file_symtabs,
				   const char *name,
				   VEC (symbolp) **symbols,
				   VEC (bound_minimal_symbol_d) **minsyms);

static struct line_offset
     linespec_parse_variable (struct linespec_state *self,
			      const char *variable);

static int symbol_to_sal (struct symtab_and_line *result,
			  int funfirstline, struct symbol *sym);

static void add_matching_symbols_to_info (const char *name,
					  struct collect_info *info,
					  struct program_space *pspace);

static void add_all_symbol_names_from_pspace (struct collect_info *info,
					      struct program_space *pspace,
					      VEC (const_char_ptr) *names);

static VEC (symtab_ptr) *collect_symtabs_from_filename (const char *file);

static void decode_digits_ordinary (struct linespec_state *self,
				    linespec_p ls,
				    int line,
				    struct symtabs_and_lines *sals,
				    struct linetable_entry **best_entry);

static void decode_digits_list_mode (struct linespec_state *self,
				     linespec_p ls,
				     struct symtabs_and_lines *values,
				     struct symtab_and_line val);

static void minsym_found (struct linespec_state *self, struct objfile *objfile,
			  struct minimal_symbol *msymbol,
			  struct symtabs_and_lines *result);

static int compare_symbols (const void *a, const void *b);

static int compare_msymbols (const void *a, const void *b);

static const char *find_toplevel_char (const char *s, char c);

/* Permitted quote characters for the parser.  This is different from the
   completer's quote characters to allow backward compatibility with the
   previous parser.  */
static const char *const linespec_quote_characters = "\"\'";

/* Lexer functions.  */

/* Lex a number from the input in PARSER.  This only supports
   decimal numbers.

   Return true if input is decimal numbers.  Return false if not.  */

static int
linespec_lexer_lex_number (linespec_parser *parser, linespec_token *tokenp)
{
  tokenp->type = LSTOKEN_NUMBER;
  LS_TOKEN_STOKEN (*tokenp).length = 0;
  LS_TOKEN_STOKEN (*tokenp).ptr = PARSER_STREAM (parser);

  /* Keep any sign at the start of the stream.  */
  if (*PARSER_STREAM (parser) == '+' || *PARSER_STREAM (parser) == '-')
    {
      ++LS_TOKEN_STOKEN (*tokenp).length;
      ++(PARSER_STREAM (parser));
    }

  while (isdigit (*PARSER_STREAM (parser)))
    {
      ++LS_TOKEN_STOKEN (*tokenp).length;
      ++(PARSER_STREAM (parser));
    }

  /* If the next character in the input buffer is not a space, comma,
     quote, or colon, this input does not represent a number.  */
  if (*PARSER_STREAM (parser) != '\0'
      && !isspace (*PARSER_STREAM (parser)) && *PARSER_STREAM (parser) != ','
      && *PARSER_STREAM (parser) != ':'
      && !strchr (linespec_quote_characters, *PARSER_STREAM (parser)))
    {
      PARSER_STREAM (parser) = LS_TOKEN_STOKEN (*tokenp).ptr;
      return 0;
    }

  return 1;
}

/* Does P represent one of the keywords?  If so, return
   the keyword.  If not, return NULL.  */

static const char *
linespec_lexer_lex_keyword (const char *p)
{
  int i;

  if (p != NULL)
    {
      for (i = 0; i < ARRAY_SIZE (linespec_keywords); ++i)
	{
	  int len = strlen (linespec_keywords[i]);

	  /* If P begins with one of the keywords and the next
	     character is not a valid identifier character,
	     we have found a keyword.  */
	  if (strncmp (p, linespec_keywords[i], len) == 0
	      && !(isalnum (p[len]) || p[len] == '_'))
	    return linespec_keywords[i];
	}
    }

  return NULL;
}

/* Does STRING represent an Ada operator?  If so, return the length
   of the decoded operator name.  If not, return 0.  */

static int
is_ada_operator (const char *string)
{
  const struct ada_opname_map *mapping;

  for (mapping = ada_opname_table;
       mapping->encoded != NULL
	 && strncmp (mapping->decoded, string,
		     strlen (mapping->decoded)) != 0; ++mapping)
    ;

  return mapping->decoded == NULL ? 0 : strlen (mapping->decoded);
}

/* Find QUOTE_CHAR in STRING, accounting for the ':' terminal.  Return
   the location of QUOTE_CHAR, or NULL if not found.  */

static const char *
skip_quote_char (const char *string, char quote_char)
{
  const char *p, *last;

  p = last = find_toplevel_char (string, quote_char);
  while (p && *p != '\0' && *p != ':')
    {
      p = find_toplevel_char (p, quote_char);
      if (p != NULL)
	last = p++;
    }

  return last;
}

/* Make a writable copy of the string given in TOKEN, trimming
   any trailing whitespace.  */

static char *
copy_token_string (linespec_token token)
{
  char *str, *s;

  if (token.type == LSTOKEN_KEYWORD)
    return xstrdup (LS_TOKEN_KEYWORD (token));

  str = savestring (LS_TOKEN_STOKEN (token).ptr,
		    LS_TOKEN_STOKEN (token).length);
  s = remove_trailing_whitespace (str, str + LS_TOKEN_STOKEN (token).length);
  *s = '\0';

  return str;
}

/* Does P represent the end of a quote-enclosed linespec?  */

static int
is_closing_quote_enclosed (const char *p)
{
  if (strchr (linespec_quote_characters, *p))
    ++p;
  p = skip_spaces ((char *) p);
  return (*p == '\0' || linespec_lexer_lex_keyword (p));
}

/* Find the end of the parameter list that starts with *INPUT.
   This helper function assists with lexing string segments
   which might contain valid (non-terminating) commas.  */

static const char *
find_parameter_list_end (const char *input)
{
  char end_char, start_char;
  int depth;
  const char *p;

  start_char = *input;
  if (start_char == '(')
    end_char = ')';
  else if (start_char == '<')
    end_char = '>';
  else
    return NULL;

  p = input;
  depth = 0;
  while (*p)
    {
      if (*p == start_char)
	++depth;
      else if (*p == end_char)
	{
	  if (--depth == 0)
	    {
	      ++p;
	      break;
	    }
	}
      ++p;
    }

  return p;
}


/* Lex a string from the input in PARSER.  */

static linespec_token
linespec_lexer_lex_string (linespec_parser *parser)
{
  linespec_token token;
  const char *start = PARSER_STREAM (parser);

  token.type = LSTOKEN_STRING;

  /* If the input stream starts with a quote character, skip to the next
     quote character, regardless of the content.  */
  if (strchr (linespec_quote_characters, *PARSER_STREAM (parser)))
    {
      const char *end;
      char quote_char = *PARSER_STREAM (parser);

      /* Special case: Ada operators.  */
      if (PARSER_STATE (parser)->language->la_language == language_ada
	  && quote_char == '\"')
	{
	  int len = is_ada_operator (PARSER_STREAM (parser));

	  if (len != 0)
	    {
	      /* The input is an Ada operator.  Return the quoted string
		 as-is.  */
	      LS_TOKEN_STOKEN (token).ptr = PARSER_STREAM (parser);
	      LS_TOKEN_STOKEN (token).length = len;
	      PARSER_STREAM (parser) += len;
	      return token;
	    }

	  /* The input does not represent an Ada operator -- fall through
	     to normal quoted string handling.  */
	}

      /* Skip past the beginning quote.  */
      ++(PARSER_STREAM (parser));

      /* Mark the start of the string.  */
      LS_TOKEN_STOKEN (token).ptr = PARSER_STREAM (parser);

      /* Skip to the ending quote.  */
      end = skip_quote_char (PARSER_STREAM (parser), quote_char);

      /* Error if the input did not terminate properly.  */
      if (end == NULL)
	error (_("unmatched quote"));

      /* Skip over the ending quote and mark the length of the string.  */
      PARSER_STREAM (parser) = (char *) ++end;
      LS_TOKEN_STOKEN (token).length = PARSER_STREAM (parser) - 2 - start;
    }
  else
    {
      const char *p;

      /* Otherwise, only identifier characters are permitted.
	 Spaces are the exception.  In general, we keep spaces,
	 but only if the next characters in the input do not resolve
	 to one of the keywords.

	 This allows users to forgo quoting CV-qualifiers, template arguments,
	 and similar common language constructs.  */

      while (1)
	{
	  if (isspace (*PARSER_STREAM (parser)))
	    {
	      p = skip_spaces_const (PARSER_STREAM (parser));
	      /* When we get here we know we've found something followed by
		 a space (we skip over parens and templates below).
		 So if we find a keyword now, we know it is a keyword and not,
		 say, a function name.  */
	      if (linespec_lexer_lex_keyword (p) != NULL)
		{
		  LS_TOKEN_STOKEN (token).ptr = start;
		  LS_TOKEN_STOKEN (token).length
		    = PARSER_STREAM (parser) - start;
		  return token;
		}

	      /* Advance past the whitespace.  */
	      PARSER_STREAM (parser) = p;
	    }

	  /* If the next character is EOI or (single) ':', the
	     string is complete;  return the token.  */
	  if (*PARSER_STREAM (parser) == 0)
	    {
	      LS_TOKEN_STOKEN (token).ptr = start;
	      LS_TOKEN_STOKEN (token).length = PARSER_STREAM (parser) - start;
	      return token;
	    }
	  else if (PARSER_STREAM (parser)[0] == ':')
	    {
	      /* Do not tokenize the C++ scope operator. */
	      if (PARSER_STREAM (parser)[1] == ':')
		++(PARSER_STREAM (parser));

	      /* Do not tokenify if the input length so far is one
		 (i.e, a single-letter drive name) and the next character
		 is a directory separator.  This allows Windows-style
		 paths to be recognized as filenames without quoting it.  */
	      else if ((PARSER_STREAM (parser) - start) != 1
		       || !IS_DIR_SEPARATOR (PARSER_STREAM (parser)[1]))
		{
		  LS_TOKEN_STOKEN (token).ptr = start;
		  LS_TOKEN_STOKEN (token).length
		    = PARSER_STREAM (parser) - start;
		  return token;
		}
	    }
	  /* Special case: permit quote-enclosed linespecs.  */
	  else if (parser->is_quote_enclosed
		   && strchr (linespec_quote_characters,
			      *PARSER_STREAM (parser))
		   && is_closing_quote_enclosed (PARSER_STREAM (parser)))
	    {
	      LS_TOKEN_STOKEN (token).ptr = start;
	      LS_TOKEN_STOKEN (token).length = PARSER_STREAM (parser) - start;
	      return token;
	    }
	  /* Because commas may terminate a linespec and appear in
	     the middle of valid string input, special cases for
	     '<' and '(' are necessary.  */
	  else if (*PARSER_STREAM (parser) == '<'
		   || *PARSER_STREAM (parser) == '(')
	    {
	      const char *p;

	      p = find_parameter_list_end (PARSER_STREAM (parser));
	      if (p != NULL)
		{
		  PARSER_STREAM (parser) = p;
		  continue;
		}
	    }
	  /* Commas are terminators, but not if they are part of an
	     operator name.  */
	  else if (*PARSER_STREAM (parser) == ',')
	    {
	      if ((PARSER_STATE (parser)->language->la_language
		   == language_cplus)
		  && (PARSER_STREAM (parser) - start) > 8
		  /* strlen ("operator") */)
		{
		  char *p = strstr (start, "operator");

		  if (p != NULL && is_operator_name (p))
		    {
		      /* This is an operator name.  Keep going.  */
		      ++(PARSER_STREAM (parser));
		      continue;
		    }
		}

	      /* Comma terminates the string.  */
	      LS_TOKEN_STOKEN (token).ptr = start;
	      LS_TOKEN_STOKEN (token).length = PARSER_STREAM (parser) - start;
	      return token;
	    }

	  /* Advance the stream.  */
	  ++(PARSER_STREAM (parser));
	}
    }

  return token;
}

/* Lex a single linespec token from PARSER.  */

static linespec_token
linespec_lexer_lex_one (linespec_parser *parser)
{
  const char *keyword;

  if (parser->lexer.current.type == LSTOKEN_CONSUMED)
    {
      /* Skip any whitespace.  */
      PARSER_STREAM (parser) = skip_spaces_const (PARSER_STREAM (parser));

      /* Check for a keyword, they end the linespec.  */
      keyword = NULL;
      if (parser->keyword_ok)
	keyword = linespec_lexer_lex_keyword (PARSER_STREAM (parser));
      if (keyword != NULL)
	{
	  parser->lexer.current.type = LSTOKEN_KEYWORD;
	  LS_TOKEN_KEYWORD (parser->lexer.current) = keyword;
	  return parser->lexer.current;
	}

      /* Handle other tokens.  */
      switch (*PARSER_STREAM (parser))
	{
	case 0:
	  parser->lexer.current.type = LSTOKEN_EOI;
	  break;

	case '+': case '-':
	case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
           if (!linespec_lexer_lex_number (parser, &(parser->lexer.current)))
	     parser->lexer.current = linespec_lexer_lex_string (parser);
          break;

	case ':':
	  /* If we have a scope operator, lex the input as a string.
	     Otherwise, return LSTOKEN_COLON.  */
	  if (PARSER_STREAM (parser)[1] == ':')
	    parser->lexer.current = linespec_lexer_lex_string (parser);
	  else
	    {
	      parser->lexer.current.type = LSTOKEN_COLON;
	      ++(PARSER_STREAM (parser));
	    }
	  break;

	case '\'': case '\"':
	  /* Special case: permit quote-enclosed linespecs.  */
	  if (parser->is_quote_enclosed
	      && is_closing_quote_enclosed (PARSER_STREAM (parser)))
	    {
	      ++(PARSER_STREAM (parser));
	      parser->lexer.current.type = LSTOKEN_EOI;
	    }
	  else
	    parser->lexer.current = linespec_lexer_lex_string (parser);
	  break;

	case ',':
	  parser->lexer.current.type = LSTOKEN_COMMA;
	  LS_TOKEN_STOKEN (parser->lexer.current).ptr
	    = PARSER_STREAM (parser);
	  LS_TOKEN_STOKEN (parser->lexer.current).length = 1;
	  ++(PARSER_STREAM (parser));
	  break;

	default:
	  /* If the input is not a number, it must be a string.
	     [Keywords were already considered above.]  */
	  parser->lexer.current = linespec_lexer_lex_string (parser);
	  break;
	}
    }

  return parser->lexer.current;
}

/* Consume the current token and return the next token in PARSER's
   input stream.  */

static linespec_token
linespec_lexer_consume_token (linespec_parser *parser)
{
  parser->lexer.current.type = LSTOKEN_CONSUMED;
  return linespec_lexer_lex_one (parser);
}

/* Return the next token without consuming the current token.  */

static linespec_token
linespec_lexer_peek_token (linespec_parser *parser)
{
  linespec_token next;
  const char *saved_stream = PARSER_STREAM (parser);
  linespec_token saved_token = parser->lexer.current;

  next = linespec_lexer_consume_token (parser);
  PARSER_STREAM (parser) = saved_stream;
  parser->lexer.current = saved_token;
  return next;
}

/* Helper functions.  */

/* Add SAL to SALS.  */

static void
add_sal_to_sals_basic (struct symtabs_and_lines *sals,
		       struct symtab_and_line *sal)
{
  ++sals->nelts;
  sals->sals = xrealloc (sals->sals, sals->nelts * sizeof (sals->sals[0]));
  sals->sals[sals->nelts - 1] = *sal;
}

/* Add SAL to SALS, and also update SELF->CANONICAL_NAMES to reflect
   the new sal, if needed.  If not NULL, SYMNAME is the name of the
   symbol to use when constructing the new canonical name.

   If LITERAL_CANONICAL is non-zero, SYMNAME will be used as the
   canonical name for the SAL.  */

static void
add_sal_to_sals (struct linespec_state *self,
		 struct symtabs_and_lines *sals,
		 struct symtab_and_line *sal,
		 const char *symname, int literal_canonical)
{
  add_sal_to_sals_basic (sals, sal);

  if (self->canonical)
    {
      struct linespec_canonical_name *canonical;

      self->canonical_names = xrealloc (self->canonical_names,
					(sals->nelts
					 * sizeof (*self->canonical_names)));
      canonical = &self->canonical_names[sals->nelts - 1];
      if (!literal_canonical && sal->symtab)
	{
	  const char *fullname = symtab_to_fullname (sal->symtab);

	  /* Note that the filter doesn't have to be a valid linespec
	     input.  We only apply the ":LINE" treatment to Ada for
	     the time being.  */
	  if (symname != NULL && sal->line != 0
	      && self->language->la_language == language_ada)
	    canonical->suffix = xstrprintf ("%s:%d", symname, sal->line);
	  else if (symname != NULL)
	    canonical->suffix = xstrdup (symname);
	  else
	    canonical->suffix = xstrprintf ("%d", sal->line);
	  canonical->symtab = sal->symtab;
	}
      else
	{
	  if (symname != NULL)
	    canonical->suffix = xstrdup (symname);
	  else
	    canonical->suffix = NULL;
	  canonical->symtab = NULL;
	}
    }
}

/* A hash function for address_entry.  */

static hashval_t
hash_address_entry (const void *p)
{
  const struct address_entry *aep = p;
  hashval_t hash;

  hash = iterative_hash_object (aep->pspace, 0);
  return iterative_hash_object (aep->addr, hash);
}

/* An equality function for address_entry.  */

static int
eq_address_entry (const void *a, const void *b)
{
  const struct address_entry *aea = a;
  const struct address_entry *aeb = b;

  return aea->pspace == aeb->pspace && aea->addr == aeb->addr;
}

/* Check whether the address, represented by PSPACE and ADDR, is
   already in the set.  If so, return 0.  Otherwise, add it and return
   1.  */

static int
maybe_add_address (htab_t set, struct program_space *pspace, CORE_ADDR addr)
{
  struct address_entry e, *p;
  void **slot;

  e.pspace = pspace;
  e.addr = addr;
  slot = htab_find_slot (set, &e, INSERT);
  if (*slot)
    return 0;

  p = XNEW (struct address_entry);
  memcpy (p, &e, sizeof (struct address_entry));
  *slot = p;

  return 1;
}

/* A callback function and the additional data to call it with.  */

struct symbol_and_data_callback
{
  /* The callback to use.  */
  symbol_found_callback_ftype *callback;

  /* Data to be passed to the callback.  */
  void *data;
};

/* A helper for iterate_over_all_matching_symtabs that is used to
   restrict calls to another callback to symbols representing inline
   symbols only.  */

static int
iterate_inline_only (struct symbol *sym, void *d)
{
  if (SYMBOL_INLINED (sym))
    {
      struct symbol_and_data_callback *cad = d;

      return cad->callback (sym, cad->data);
    }
  return 1; /* Continue iterating.  */
}

/* Some data for the expand_symtabs_matching callback.  */

struct symbol_matcher_data
{
  /* The lookup name against which symbol name should be compared.  */
  const char *lookup_name;

  /* The routine to be used for comparison.  */
  symbol_name_cmp_ftype symbol_name_cmp;
};

/* A helper for iterate_over_all_matching_symtabs that is passed as a
   callback to the expand_symtabs_matching method.  */

static int
iterate_name_matcher (const char *name, void *d)
{
  const struct symbol_matcher_data *data = d;

  if (data->symbol_name_cmp (name, data->lookup_name) == 0)
    return 1; /* Expand this symbol's symbol table.  */
  return 0; /* Skip this symbol.  */
}

/* A helper that walks over all matching symtabs in all objfiles and
   calls CALLBACK for each symbol matching NAME.  If SEARCH_PSPACE is
   not NULL, then the search is restricted to just that program
   space.  If INCLUDE_INLINE is nonzero then symbols representing
   inlined instances of functions will be included in the result.  */

static void
iterate_over_all_matching_symtabs (struct linespec_state *state,
				   const char *name,
				   const domain_enum domain,
				   symbol_found_callback_ftype *callback,
				   void *data,
				   struct program_space *search_pspace,
				   int include_inline)
{
  struct objfile *objfile;
  struct program_space *pspace;
  struct symbol_matcher_data matcher_data;

  matcher_data.lookup_name = name;
  matcher_data.symbol_name_cmp =
    state->language->la_get_symbol_name_cmp != NULL
    ? state->language->la_get_symbol_name_cmp (name)
    : strcmp_iw;

  ALL_PSPACES (pspace)
  {
    if (search_pspace != NULL && search_pspace != pspace)
      continue;
    if (pspace->executing_startup)
      continue;

    set_current_program_space (pspace);

    ALL_OBJFILES (objfile)
    {
      struct symtab *symtab;

      if (objfile->sf)
	objfile->sf->qf->expand_symtabs_matching (objfile, NULL,
						  iterate_name_matcher,
						  ALL_DOMAIN,
						  &matcher_data);

      ALL_OBJFILE_PRIMARY_SYMTABS (objfile, symtab)
	{
	  iterate_over_file_blocks (symtab, name, domain, callback, data);

	  if (include_inline)
	    {
	      struct symbol_and_data_callback cad = { callback, data };
	      struct block *block;
	      int i;

	      for (i = FIRST_LOCAL_BLOCK;
		   i < BLOCKVECTOR_NBLOCKS (BLOCKVECTOR (symtab)); i++)
		{
		  block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), i);
		  state->language->la_iterate_over_symbols
		    (block, name, domain, iterate_inline_only, &cad);
		}
	    }
	}
    }
  }
}

/* Returns the block to be used for symbol searches from
   the current location.  */

static struct block *
get_current_search_block (void)
{
  struct block *block;
  enum language save_language;

  /* get_selected_block can change the current language when there is
     no selected frame yet.  */
  save_language = current_language->la_language;
  block = get_selected_block (0);
  set_language (save_language);

  return block;
}

/* Iterate over static and global blocks.  */

static void
iterate_over_file_blocks (struct symtab *symtab,
			  const char *name, domain_enum domain,
			  symbol_found_callback_ftype *callback, void *data)
{
  struct block *block;

  for (block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), STATIC_BLOCK);
       block != NULL;
       block = BLOCK_SUPERBLOCK (block))
    LA_ITERATE_OVER_SYMBOLS (block, name, domain, callback, data);
}

/* A helper for find_method.  This finds all methods in type T which
   match NAME.  It adds matching symbol names to RESULT_NAMES, and
   adds T's direct superclasses to SUPERCLASSES.  */

static void
find_methods (struct type *t, const char *name,
	      VEC (const_char_ptr) **result_names,
	      VEC (typep) **superclasses)
{
  int ibase;
  const char *class_name = type_name_no_tag (t);

  /* Ignore this class if it doesn't have a name.  This is ugly, but
     unless we figure out how to get the physname without the name of
     the class, then the loop can't do any good.  */
  if (class_name)
    {
      int method_counter;

      CHECK_TYPEDEF (t);

      /* Loop over each method name.  At this level, all overloads of a name
         are counted as a single name.  There is an inner loop which loops over
         each overload.  */

      for (method_counter = TYPE_NFN_FIELDS (t) - 1;
	   method_counter >= 0;
	   --method_counter)
	{
	  const char *method_name = TYPE_FN_FIELDLIST_NAME (t, method_counter);
	  char dem_opname[64];

	  if (strncmp (method_name, "__", 2) == 0 ||
	      strncmp (method_name, "op", 2) == 0 ||
	      strncmp (method_name, "type", 4) == 0)
	    {
	      if (cplus_demangle_opname (method_name, dem_opname, DMGL_ANSI))
		method_name = dem_opname;
	      else if (cplus_demangle_opname (method_name, dem_opname, 0))
		method_name = dem_opname;
	    }

	  if (strcmp_iw (method_name, name) == 0)
	    {
	      int field_counter;

	      for (field_counter = (TYPE_FN_FIELDLIST_LENGTH (t, method_counter)
				    - 1);
		   field_counter >= 0;
		   --field_counter)
		{
		  struct fn_field *f;
		  const char *phys_name;

		  f = TYPE_FN_FIELDLIST1 (t, method_counter);
		  if (TYPE_FN_FIELD_STUB (f, field_counter))
		    continue;
		  phys_name = TYPE_FN_FIELD_PHYSNAME (f, field_counter);
		  VEC_safe_push (const_char_ptr, *result_names, phys_name);
		}
	    }
	}
    }

  for (ibase = 0; ibase < TYPE_N_BASECLASSES (t); ibase++)
    VEC_safe_push (typep, *superclasses, TYPE_BASECLASS (t, ibase));
}

/* Find an instance of the character C in the string S that is outside
   of all parenthesis pairs, single-quoted strings, and double-quoted
   strings.  Also, ignore the char within a template name, like a ','
   within foo<int, int>.  */

static const char *
find_toplevel_char (const char *s, char c)
{
  int quoted = 0;		/* zero if we're not in quotes;
				   '"' if we're in a double-quoted string;
				   '\'' if we're in a single-quoted string.  */
  int depth = 0;		/* Number of unclosed parens we've seen.  */
  const char *scan;

  for (scan = s; *scan; scan++)
    {
      if (quoted)
	{
	  if (*scan == quoted)
	    quoted = 0;
	  else if (*scan == '\\' && *(scan + 1))
	    scan++;
	}
      else if (*scan == c && ! quoted && depth == 0)
	return scan;
      else if (*scan == '"' || *scan == '\'')
	quoted = *scan;
      else if (*scan == '(' || *scan == '<')
	depth++;
      else if ((*scan == ')' || *scan == '>') && depth > 0)
	depth--;
    }

  return 0;
}

/* The string equivalent of find_toplevel_char.  Returns a pointer
   to the location of NEEDLE in HAYSTACK, ignoring any occurrences
   inside "()" and "<>".  Returns NULL if NEEDLE was not found.  */

static const char *
find_toplevel_string (const char *haystack, const char *needle)
{
  const char *s = haystack;

  do
    {
      s = find_toplevel_char (s, *needle);

      if (s != NULL)
	{
	  /* Found first char in HAYSTACK;  check rest of string.  */
	  if (strncmp (s, needle, strlen (needle)) == 0)
	    return s;

	  /* Didn't find it; loop over HAYSTACK, looking for the next
	     instance of the first character of NEEDLE.  */
	  ++s;
	}
    }
  while (s != NULL && *s != '\0');

  /* NEEDLE was not found in HAYSTACK.  */
  return NULL;
}

/* Convert CANONICAL to its string representation using
   symtab_to_fullname for SYMTAB.  The caller must xfree the result.  */

static char *
canonical_to_fullform (const struct linespec_canonical_name *canonical)
{
  if (canonical->symtab == NULL)
    return xstrdup (canonical->suffix);
  else
    return xstrprintf ("%s:%s", symtab_to_fullname (canonical->symtab),
		       canonical->suffix);
}

/* Given FILTERS, a list of canonical names, filter the sals in RESULT
   and store the result in SELF->CANONICAL.  */

static void
filter_results (struct linespec_state *self,
		struct symtabs_and_lines *result,
		VEC (const_char_ptr) *filters)
{
  int i;
  const char *name;

  for (i = 0; VEC_iterate (const_char_ptr, filters, i, name); ++i)
    {
      struct linespec_sals lsal;
      int j;

      memset (&lsal, 0, sizeof (lsal));

      for (j = 0; j < result->nelts; ++j)
	{
	  const struct linespec_canonical_name *canonical;
	  char *fullform;
	  struct cleanup *cleanup;

	  canonical = &self->canonical_names[j];
	  fullform = canonical_to_fullform (canonical);
	  cleanup = make_cleanup (xfree, fullform);

	  if (strcmp (name, fullform) == 0)
	    add_sal_to_sals_basic (&lsal.sals, &result->sals[j]);

	  do_cleanups (cleanup);
	}

      if (lsal.sals.nelts > 0)
	{
	  lsal.canonical = xstrdup (name);
	  VEC_safe_push (linespec_sals, self->canonical->sals, &lsal);
	}
    }

  self->canonical->pre_expanded = 0;
}

/* Store RESULT into SELF->CANONICAL.  */

static void
convert_results_to_lsals (struct linespec_state *self,
			  struct symtabs_and_lines *result)
{
  struct linespec_sals lsal;

  lsal.canonical = NULL;
  lsal.sals = *result;
  VEC_safe_push (linespec_sals, self->canonical->sals, &lsal);
}

/* A structure that contains two string representations of a struct
   linespec_canonical_name:
     - one where the the symtab's fullname is used;
     - one where the filename followed the "set filename-display"
       setting.  */

struct decode_line_2_item
{
  /* The form using symtab_to_fullname.
     It must be xfree'ed after use.  */
  char *fullform;

  /* The form using symtab_to_filename_for_display.
     It must be xfree'ed after use.  */
  char *displayform;

  /* Field is initialized to zero and it is set to one if the user
     requested breakpoint for this entry.  */
  unsigned int selected : 1;
};

/* Helper for qsort to sort decode_line_2_item entries by DISPLAYFORM and
   secondarily by FULLFORM.  */

static int
decode_line_2_compare_items (const void *ap, const void *bp)
{
  const struct decode_line_2_item *a = ap;
  const struct decode_line_2_item *b = bp;
  int retval;

  retval = strcmp (a->displayform, b->displayform);
  if (retval != 0)
    return retval;

  return strcmp (a->fullform, b->fullform);
}

/* Handle multiple results in RESULT depending on SELECT_MODE.  This
   will either return normally, throw an exception on multiple
   results, or present a menu to the user.  On return, the SALS vector
   in SELF->CANONICAL is set up properly.  */

static void
decode_line_2 (struct linespec_state *self,
	       struct symtabs_and_lines *result,
	       const char *select_mode)
{
  char *args, *prompt;
  int i;
  struct cleanup *old_chain;
  VEC (const_char_ptr) *filters = NULL;
  struct get_number_or_range_state state;
  struct decode_line_2_item *items;
  int items_count;

  gdb_assert (select_mode != multiple_symbols_all);
  gdb_assert (self->canonical != NULL);
  gdb_assert (result->nelts >= 1);

  old_chain = make_cleanup (VEC_cleanup (const_char_ptr), &filters);

  /* Prepare ITEMS array.  */
  items_count = result->nelts;
  items = xmalloc (sizeof (*items) * items_count);
  make_cleanup (xfree, items);
  for (i = 0; i < items_count; ++i)
    {
      const struct linespec_canonical_name *canonical;
      struct decode_line_2_item *item;

      canonical = &self->canonical_names[i];
      gdb_assert (canonical->suffix != NULL);
      item = &items[i];

      item->fullform = canonical_to_fullform (canonical);
      make_cleanup (xfree, item->fullform);

      if (canonical->symtab == NULL)
	item->displayform = canonical->suffix;
      else
	{
	  const char *fn_for_display;

	  fn_for_display = symtab_to_filename_for_display (canonical->symtab);
	  item->displayform = xstrprintf ("%s:%s", fn_for_display,
					  canonical->suffix);
	  make_cleanup (xfree, item->displayform);
	}

      item->selected = 0;
    }

  /* Sort the list of method names.  */
  qsort (items, items_count, sizeof (*items), decode_line_2_compare_items);

  /* Remove entries with the same FULLFORM.  */
  if (items_count >= 2)
    {
      struct decode_line_2_item *dst, *src;

      dst = items;
      for (src = &items[1]; src < &items[items_count]; src++)
	if (strcmp (src->fullform, dst->fullform) != 0)
	  *++dst = *src;
      items_count = dst + 1 - items;
    }

  if (select_mode == multiple_symbols_cancel && items_count > 1)
    error (_("canceled because the command is ambiguous\n"
	     "See set/show multiple-symbol."));
  
  if (select_mode == multiple_symbols_all || items_count == 1)
    {
      do_cleanups (old_chain);
      convert_results_to_lsals (self, result);
      return;
    }

  printf_unfiltered (_("[0] cancel\n[1] all\n"));
  for (i = 0; i < items_count; i++)
    printf_unfiltered ("[%d] %s\n", i + 2, items[i].displayform);

  prompt = getenv ("PS2");
  if (prompt == NULL)
    {
      prompt = "> ";
    }
  args = command_line_input (prompt, 0, "overload-choice");

  if (args == 0 || *args == 0)
    error_no_arg (_("one or more choice numbers"));

  init_number_or_range (&state, args);
  while (!state.finished)
    {
      int num;

      num = get_number_or_range (&state);

      if (num == 0)
	error (_("canceled"));
      else if (num == 1)
	{
	  /* We intentionally make this result in a single breakpoint,
	     contrary to what older versions of gdb did.  The
	     rationale is that this lets a user get the
	     multiple_symbols_all behavior even with the 'ask'
	     setting; and he can get separate breakpoints by entering
	     "2-57" at the query.  */
	  do_cleanups (old_chain);
	  convert_results_to_lsals (self, result);
	  return;
	}

      num -= 2;
      if (num >= items_count)
	printf_unfiltered (_("No choice number %d.\n"), num);
      else
	{
	  struct decode_line_2_item *item = &items[num];

	  if (!item->selected)
	    {
	      VEC_safe_push (const_char_ptr, filters, item->fullform);
	      item->selected = 1;
	    }
	  else
	    {
	      printf_unfiltered (_("duplicate request for %d ignored.\n"),
				 num + 2);
	    }
	}
    }

  filter_results (self, result, filters);
  do_cleanups (old_chain);
}



/* The parser of linespec itself.  */

/* Throw an appropriate error when SYMBOL is not found (optionally in
   FILENAME).  */

static void ATTRIBUTE_NORETURN
symbol_not_found_error (const char *symbol, const char *filename)
{
  if (symbol == NULL)
    symbol = "";

  if (!have_full_symbols ()
      && !have_partial_symbols ()
      && !have_minimal_symbols ())
    throw_error (NOT_FOUND_ERROR,
		 _("No symbol table is loaded.  Use the \"file\" command."));

  /* If SYMBOL starts with '$', the user attempted to either lookup
     a function/variable in his code starting with '$' or an internal
     variable of that name.  Since we do not know which, be concise and
     explain both possibilities.  */
  if (*symbol == '$')
    {
      if (filename)
	throw_error (NOT_FOUND_ERROR,
		     _("Undefined convenience variable or function \"%s\" "
		       "not defined in \"%s\"."), symbol, filename);
      else
	throw_error (NOT_FOUND_ERROR,
		     _("Undefined convenience variable or function \"%s\" "
		       "not defined."), symbol);
    }
  else
    {
      if (filename)
	throw_error (NOT_FOUND_ERROR,
		     _("Function \"%s\" not defined in \"%s\"."),
		     symbol, filename);
      else
	throw_error (NOT_FOUND_ERROR,
		     _("Function \"%s\" not defined."), symbol);
    }
}

/* Throw an appropriate error when an unexpected token is encountered 
   in the input.  */

static void ATTRIBUTE_NORETURN
unexpected_linespec_error (linespec_parser *parser)
{
  linespec_token token;
  static const char * token_type_strings[]
    = {"keyword", "colon", "string", "number", "comma", "end of input"};

  /* Get the token that generated the error.  */
  token = linespec_lexer_lex_one (parser);

  /* Finally, throw the error.  */
  if (token.type == LSTOKEN_STRING || token.type == LSTOKEN_NUMBER
      || token.type == LSTOKEN_KEYWORD)
    {
      char *string;
      struct cleanup *cleanup;

      string = copy_token_string (token);
      cleanup = make_cleanup (xfree, string);
      throw_error (GENERIC_ERROR,
		   _("malformed linespec error: unexpected %s, \"%s\""),
		   token_type_strings[token.type], string);
    }
  else
    throw_error (GENERIC_ERROR,
		 _("malformed linespec error: unexpected %s"),
		 token_type_strings[token.type]);
}

/* Parse and return a line offset in STRING.  */

static struct line_offset
linespec_parse_line_offset (const char *string)
{
  struct line_offset line_offset = {0, LINE_OFFSET_NONE};

  if (*string == '+')
    {
      line_offset.sign = LINE_OFFSET_PLUS;
      ++string;
    }
  else if (*string == '-')
    {
      line_offset.sign = LINE_OFFSET_MINUS;
      ++string;
    }

  /* Right now, we only allow base 10 for offsets.  */
  line_offset.offset = atoi (string);
  return line_offset;
}

/* Parse the basic_spec in PARSER's input.  */

static void
linespec_parse_basic (linespec_parser *parser)
{
  char *name;
  linespec_token token;
  VEC (symbolp) *symbols, *labels;
  VEC (bound_minimal_symbol_d) *minimal_symbols;
  struct cleanup *cleanup;

  /* Get the next token.  */
  token = linespec_lexer_lex_one (parser);

  /* If it is EOI or KEYWORD, issue an error.  */
  if (token.type == LSTOKEN_KEYWORD || token.type == LSTOKEN_EOI)
    unexpected_linespec_error (parser);
  /* If it is a LSTOKEN_NUMBER, we have an offset.  */
  else if (token.type == LSTOKEN_NUMBER)
    {
      /* Record the line offset and get the next token.  */
      name = copy_token_string (token);
      cleanup = make_cleanup (xfree, name);
      PARSER_RESULT (parser)->line_offset = linespec_parse_line_offset (name);
      do_cleanups (cleanup);

      /* Get the next token.  */
      token = linespec_lexer_consume_token (parser);

      /* If the next token is a comma, stop parsing and return.  */
      if (token.type == LSTOKEN_COMMA)
	return;

      /* If the next token is anything but EOI or KEYWORD, issue
	 an error.  */
      if (token.type != LSTOKEN_KEYWORD && token.type != LSTOKEN_EOI)
	unexpected_linespec_error (parser);
    }

  if (token.type == LSTOKEN_KEYWORD || token.type == LSTOKEN_EOI)
    return;

  /* Next token must be LSTOKEN_STRING.  */
  if (token.type != LSTOKEN_STRING)
    unexpected_linespec_error (parser);

  /* The current token will contain the name of a function, method,
     or label.  */
  name  = copy_token_string (token);
  cleanup = make_cleanup (xfree, name);

  /* Try looking it up as a function/method.  */
  find_linespec_symbols (PARSER_STATE (parser),
			 PARSER_RESULT (parser)->file_symtabs, name,
			 &symbols, &minimal_symbols);

  if (symbols != NULL || minimal_symbols != NULL)
    {
      PARSER_RESULT (parser)->function_symbols = symbols;
      PARSER_RESULT (parser)->minimal_symbols = minimal_symbols;
      PARSER_RESULT (parser)->function_name = name;
      symbols = NULL;
      discard_cleanups (cleanup);
    }
  else
    {
      /* NAME was not a function or a method.  So it must be a label
	 name or user specified variable like "break foo.c:$zippo".  */
      labels = find_label_symbols (PARSER_STATE (parser), NULL,
				   &symbols, name);
      if (labels != NULL)
	{
	  PARSER_RESULT (parser)->labels.label_symbols = labels;
	  PARSER_RESULT (parser)->labels.function_symbols = symbols;
	  PARSER_RESULT (parser)->label_name = name;
	  symbols = NULL;
	  discard_cleanups (cleanup);
	}
      else if (token.type == LSTOKEN_STRING
	       && *LS_TOKEN_STOKEN (token).ptr == '$')
	{
	  /* User specified a convenience variable or history value.  */
	  PARSER_RESULT (parser)->line_offset
	    = linespec_parse_variable (PARSER_STATE (parser), name);

	  if (PARSER_RESULT (parser)->line_offset.sign == LINE_OFFSET_UNKNOWN)
	    {
	      /* The user-specified variable was not valid.  Do not
		 throw an error here.  parse_linespec will do it for us.  */
	      PARSER_RESULT (parser)->function_name = name;
	      discard_cleanups (cleanup);
	      return;
	    }
	}
      else
	{
	  /* The name is also not a label.  Abort parsing.  Do not throw
	     an error here.  parse_linespec will do it for us.  */

	  /* Save a copy of the name we were trying to lookup.  */
	  PARSER_RESULT (parser)->function_name = name;
	  discard_cleanups (cleanup);
	  return;
	}
    }

  /* Get the next token.  */
  token = linespec_lexer_consume_token (parser);

  if (token.type == LSTOKEN_COLON)
    {
      /* User specified a label or a lineno.  */
      token = linespec_lexer_consume_token (parser);

      if (token.type == LSTOKEN_NUMBER)
	{
	  /* User specified an offset.  Record the line offset and
	     get the next token.  */
	  name = copy_token_string (token);
	  cleanup = make_cleanup (xfree, name);
	  PARSER_RESULT (parser)->line_offset
	    = linespec_parse_line_offset (name);
	  do_cleanups (cleanup);

	  /* Ge the next token.  */
	  token = linespec_lexer_consume_token (parser);
	}
      else if (token.type == LSTOKEN_STRING)
	{
	  /* Grab a copy of the label's name and look it up.  */
	  name = copy_token_string (token);
	  cleanup = make_cleanup (xfree, name);
	  labels = find_label_symbols (PARSER_STATE (parser),
				       PARSER_RESULT (parser)->function_symbols,
				       &symbols, name);

	  if (labels != NULL)
	    {
	      PARSER_RESULT (parser)->labels.label_symbols = labels;
	      PARSER_RESULT (parser)->labels.function_symbols = symbols;
	      PARSER_RESULT (parser)->label_name = name;
	      symbols = NULL;
	      discard_cleanups (cleanup);
	    }
	  else
	    {
	      /* We don't know what it was, but it isn't a label.  */
	      throw_error (NOT_FOUND_ERROR,
			   _("No label \"%s\" defined in function \"%s\"."),
			   name, PARSER_RESULT (parser)->function_name);
	    }

	  /* Check for a line offset.  */
	  token = linespec_lexer_consume_token (parser);
	  if (token.type == LSTOKEN_COLON)
	    {
	      /* Get the next token.  */
	      token = linespec_lexer_consume_token (parser);

	      /* It must be a line offset.  */
	      if (token.type != LSTOKEN_NUMBER)
		unexpected_linespec_error (parser);

	      /* Record the lione offset and get the next token.  */
	      name = copy_token_string (token);
	      cleanup = make_cleanup (xfree, name);

	      PARSER_RESULT (parser)->line_offset
		= linespec_parse_line_offset (name);
	      do_cleanups (cleanup);

	      /* Get the next token.  */
	      token = linespec_lexer_consume_token (parser);
	    }
	}
      else
	{
	  /* Trailing ':' in the input. Issue an error.  */
	  unexpected_linespec_error (parser);
	}
    }
}

/* Canonicalize the linespec contained in LS.  The result is saved into
   STATE->canonical.  */

static void
canonicalize_linespec (struct linespec_state *state, linespec_p ls)
{
  /* If canonicalization was not requested, no need to do anything.  */
  if (!state->canonical)
    return;

  /* Shortcut expressions, which can only appear by themselves.  */
  if (ls->expression != NULL)
    state->canonical->addr_string = xstrdup (ls->expression);
  else
    {
      struct ui_file *buf;
      int need_colon = 0;

      buf = mem_fileopen ();
      if (ls->source_filename)
	{
	  fputs_unfiltered (ls->source_filename, buf);
	  need_colon = 1;
	}

      if (ls->function_name)
	{
	  if (need_colon)
	    fputc_unfiltered (':', buf);
	  fputs_unfiltered (ls->function_name, buf);
	  need_colon = 1;
	}

      if (ls->label_name)
	{
	  if (need_colon)
	    fputc_unfiltered (':', buf);

	  if (ls->function_name == NULL)
	    {
	      struct symbol *s;

	      /* No function was specified, so add the symbol name.  */
	      gdb_assert (ls->labels.function_symbols != NULL
			  && (VEC_length (symbolp, ls->labels.function_symbols)
			      == 1));
	      s = VEC_index (symbolp, ls->labels.function_symbols, 0);
	      fputs_unfiltered (SYMBOL_NATURAL_NAME (s), buf);
	      fputc_unfiltered (':', buf);
	    }

	  fputs_unfiltered (ls->label_name, buf);
	  need_colon = 1;
	  state->canonical->special_display = 1;
	}

      if (ls->line_offset.sign != LINE_OFFSET_UNKNOWN)
	{
	  if (need_colon)
	    fputc_unfiltered (':', buf);
	  fprintf_filtered (buf, "%s%d",
			    (ls->line_offset.sign == LINE_OFFSET_NONE ? ""
			     : (ls->line_offset.sign
				== LINE_OFFSET_PLUS ? "+" : "-")),
			    ls->line_offset.offset);
	}

      state->canonical->addr_string = ui_file_xstrdup (buf, NULL);
      ui_file_delete (buf);
    }
}

/* Given a line offset in LS, construct the relevant SALs.  */

static struct symtabs_and_lines
create_sals_line_offset (struct linespec_state *self,
			 linespec_p ls)
{
  struct symtabs_and_lines values;
  struct symtab_and_line val;
  int use_default = 0;

  init_sal (&val);
  values.sals = NULL;
  values.nelts = 0;

  /* This is where we need to make sure we have good defaults.
     We must guarantee that this section of code is never executed
     when we are called with just a function name, since
     set_default_source_symtab_and_line uses
     select_source_symtab that calls us with such an argument.  */

  if (VEC_length (symtab_ptr, ls->file_symtabs) == 1
      && VEC_index (symtab_ptr, ls->file_symtabs, 0) == NULL)
    {
      const char *fullname;

      set_current_program_space (self->program_space);

      /* Make sure we have at least a default source line.  */
      set_default_source_symtab_and_line ();
      initialize_defaults (&self->default_symtab, &self->default_line);
      fullname = symtab_to_fullname (self->default_symtab);
      VEC_pop (symtab_ptr, ls->file_symtabs);
      VEC_free (symtab_ptr, ls->file_symtabs);
      ls->file_symtabs = collect_symtabs_from_filename (fullname);
      use_default = 1;
    }

  val.line = ls->line_offset.offset;
  switch (ls->line_offset.sign)
    {
    case LINE_OFFSET_PLUS:
      if (ls->line_offset.offset == 0)
	val.line = 5;
      if (use_default)
	val.line = self->default_line + val.line;
      break;

    case LINE_OFFSET_MINUS:
      if (ls->line_offset.offset == 0)
	val.line = 15;
      if (use_default)
	val.line = self->default_line - val.line;
      else
	val.line = -val.line;
      break;

    case LINE_OFFSET_NONE:
      break;			/* No need to adjust val.line.  */
    }

  if (self->list_mode)
    decode_digits_list_mode (self, ls, &values, val);
  else
    {
      struct linetable_entry *best_entry = NULL;
      int *filter;
      struct block **blocks;
      struct cleanup *cleanup;
      struct symtabs_and_lines intermediate_results;
      int i, j;

      intermediate_results.sals = NULL;
      intermediate_results.nelts = 0;

      decode_digits_ordinary (self, ls, val.line, &intermediate_results,
			      &best_entry);
      if (intermediate_results.nelts == 0 && best_entry != NULL)
	decode_digits_ordinary (self, ls, best_entry->line,
				&intermediate_results, &best_entry);

      cleanup = make_cleanup (xfree, intermediate_results.sals);

      /* For optimized code, the compiler can scatter one source line
	 across disjoint ranges of PC values, even when no duplicate
	 functions or inline functions are involved.  For example,
	 'for (;;)' inside a non-template, non-inline, and non-ctor-or-dtor
	 function can result in two PC ranges.  In this case, we don't
	 want to set a breakpoint on the first PC of each range.  To filter
	 such cases, we use containing blocks -- for each PC found
	 above, we see if there are other PCs that are in the same
	 block.  If yes, the other PCs are filtered out.  */

      filter = XNEWVEC (int, intermediate_results.nelts);
      make_cleanup (xfree, filter);
      blocks = XNEWVEC (struct block *, intermediate_results.nelts);
      make_cleanup (xfree, blocks);

      for (i = 0; i < intermediate_results.nelts; ++i)
	{
	  set_current_program_space (intermediate_results.sals[i].pspace);

	  filter[i] = 1;
	  blocks[i] = block_for_pc_sect (intermediate_results.sals[i].pc,
					 intermediate_results.sals[i].section);
	}

      for (i = 0; i < intermediate_results.nelts; ++i)
	{
	  if (blocks[i] != NULL)
	    for (j = i + 1; j < intermediate_results.nelts; ++j)
	      {
		if (blocks[j] == blocks[i])
		  {
		    filter[j] = 0;
		    break;
		  }
	      }
	}

      for (i = 0; i < intermediate_results.nelts; ++i)
	if (filter[i])
	  {
	    struct symbol *sym = (blocks[i]
				  ? block_containing_function (blocks[i])
				  : NULL);

	    if (self->funfirstline)
	      skip_prologue_sal (&intermediate_results.sals[i]);
	    /* Make sure the line matches the request, not what was
	       found.  */
	    intermediate_results.sals[i].line = val.line;
	    add_sal_to_sals (self, &values, &intermediate_results.sals[i],
			     sym ? SYMBOL_NATURAL_NAME (sym) : NULL, 0);
	  }

      do_cleanups (cleanup);
    }

  if (values.nelts == 0)
    {
      if (ls->source_filename)
	throw_error (NOT_FOUND_ERROR, _("No line %d in file \"%s\"."),
		     val.line, ls->source_filename);
      else
	throw_error (NOT_FOUND_ERROR, _("No line %d in the current file."),
		     val.line);
    }

  return values;
}

/* Create and return SALs from the linespec LS.  */

static struct symtabs_and_lines
convert_linespec_to_sals (struct linespec_state *state, linespec_p ls)
{
  struct symtabs_and_lines sals = {NULL, 0};

  if (ls->expression != NULL)
    {
      struct symtab_and_line sal;

      /* We have an expression.  No other attribute is allowed.  */
      sal = find_pc_line (ls->expr_pc, 0);
      sal.pc = ls->expr_pc;
      sal.section = find_pc_overlay (ls->expr_pc);
      sal.explicit_pc = 1;
      add_sal_to_sals (state, &sals, &sal, ls->expression, 1);
    }
  else if (ls->labels.label_symbols != NULL)
    {
      /* We have just a bunch of functions/methods or labels.  */
      int i;
      struct symtab_and_line sal;
      struct symbol *sym;

      for (i = 0; VEC_iterate (symbolp, ls->labels.label_symbols, i, sym); ++i)
	{
	  struct program_space *pspace = SYMTAB_PSPACE (SYMBOL_SYMTAB (sym));

	  if (symbol_to_sal (&sal, state->funfirstline, sym)
	      && maybe_add_address (state->addr_set, pspace, sal.pc))
	    add_sal_to_sals (state, &sals, &sal,
			     SYMBOL_NATURAL_NAME (sym), 0);
	}
    }
  else if (ls->function_symbols != NULL || ls->minimal_symbols != NULL)
    {
      /* We have just a bunch of functions and/or methods.  */
      int i;
      struct symtab_and_line sal;
      struct symbol *sym;
      bound_minimal_symbol_d *elem;
      struct program_space *pspace;

      if (ls->function_symbols != NULL)
	{
	  /* Sort symbols so that symbols with the same program space are next
	     to each other.  */
	  qsort (VEC_address (symbolp, ls->function_symbols),
		 VEC_length (symbolp, ls->function_symbols),
		 sizeof (symbolp), compare_symbols);

	  for (i = 0; VEC_iterate (symbolp, ls->function_symbols, i, sym); ++i)
	    {
	      pspace = SYMTAB_PSPACE (SYMBOL_SYMTAB (sym));
	      set_current_program_space (pspace);
	      if (symbol_to_sal (&sal, state->funfirstline, sym)
		  && maybe_add_address (state->addr_set, pspace, sal.pc))
		add_sal_to_sals (state, &sals, &sal,
				 SYMBOL_NATURAL_NAME (sym), 0);
	    }
	}

      if (ls->minimal_symbols != NULL)
	{
	  /* Sort minimal symbols by program space, too.  */
	  qsort (VEC_address (bound_minimal_symbol_d, ls->minimal_symbols),
		 VEC_length (bound_minimal_symbol_d, ls->minimal_symbols),
		 sizeof (bound_minimal_symbol_d), compare_msymbols);

	  for (i = 0;
	       VEC_iterate (bound_minimal_symbol_d, ls->minimal_symbols,
			    i, elem);
	       ++i)
	    {
	      pspace = elem->objfile->pspace;
	      set_current_program_space (pspace);
	      minsym_found (state, elem->objfile, elem->minsym, &sals);
	    }
	}
    }
  else if (ls->line_offset.sign != LINE_OFFSET_UNKNOWN)
    {
      /* Only an offset was specified.  */
	sals = create_sals_line_offset (state, ls);

	/* Make sure we have a filename for canonicalization.  */
	if (ls->source_filename == NULL)
	  {
	    const char *fullname = symtab_to_fullname (state->default_symtab);

	    /* It may be more appropriate to keep DEFAULT_SYMTAB in its symtab
	       form so that displaying SOURCE_FILENAME can follow the current
	       FILENAME_DISPLAY_STRING setting.  But as it is used only rarely
	       it has been kept for code simplicity only in absolute form.  */
	    ls->source_filename = xstrdup (fullname);
	  }
    }
  else
    {
      /* We haven't found any results...  */
      return sals;
    }

  canonicalize_linespec (state, ls);

  if (sals.nelts > 0 && state->canonical != NULL)
    state->canonical->pre_expanded = 1;

  return sals;
}

/* Parse a string that specifies a linespec.
   Pass the address of a char * variable; that variable will be
   advanced over the characters actually parsed.

   The basic grammar of linespecs:

   linespec -> expr_spec | var_spec | basic_spec
   expr_spec -> '*' STRING
   var_spec -> '$' (STRING | NUMBER)

   basic_spec -> file_offset_spec | function_spec | label_spec
   file_offset_spec -> opt_file_spec offset_spec
   function_spec -> opt_file_spec function_name_spec opt_label_spec
   label_spec -> label_name_spec

   opt_file_spec -> "" | file_name_spec ':'
   opt_label_spec -> "" | ':' label_name_spec

   file_name_spec -> STRING
   function_name_spec -> STRING
   label_name_spec -> STRING
   function_name_spec -> STRING
   offset_spec -> NUMBER
               -> '+' NUMBER
	       -> '-' NUMBER

   This may all be followed by several keywords such as "if EXPR",
   which we ignore.

   A comma will terminate parsing.

   The function may be an undebuggable function found in minimal symbol table.

   If the argument FUNFIRSTLINE is nonzero, we want the first line
   of real code inside a function when a function is specified, and it is
   not OK to specify a variable or type to get its line number.

   DEFAULT_SYMTAB specifies the file to use if none is specified.
   It defaults to current_source_symtab.
   DEFAULT_LINE specifies the line number to use for relative
   line numbers (that start with signs).  Defaults to current_source_line.
   If CANONICAL is non-NULL, store an array of strings containing the canonical
   line specs there if necessary.  Currently overloaded member functions and
   line numbers or static functions without a filename yield a canonical
   line spec.  The array and the line spec strings are allocated on the heap,
   it is the callers responsibility to free them.

   Note that it is possible to return zero for the symtab
   if no file is validly specified.  Callers must check that.
   Also, the line number returned may be invalid.  */

/* Parse the linespec in ARGPTR.  */

static struct symtabs_and_lines
parse_linespec (linespec_parser *parser, const char **argptr)
{
  linespec_token token;
  struct symtabs_and_lines values;
  volatile struct gdb_exception file_exception;
  struct cleanup *cleanup;

  /* A special case to start.  It has become quite popular for
     IDEs to work around bugs in the previous parser by quoting
     the entire linespec, so we attempt to deal with this nicely.  */
  parser->is_quote_enclosed = 0;
  if (!is_ada_operator (*argptr)
      && strchr (linespec_quote_characters, **argptr) != NULL)
    {
      const char *end;

      end = skip_quote_char (*argptr + 1, **argptr);
      if (end != NULL && is_closing_quote_enclosed (end))
	{
	  /* Here's the special case.  Skip ARGPTR past the initial
	     quote.  */
	  ++(*argptr);
	  parser->is_quote_enclosed = 1;
	}
    }

  /* A keyword at the start cannot be interpreted as such.
     Consider "b thread thread 42".  */
  parser->keyword_ok = 0;

  parser->lexer.saved_arg = *argptr;
  parser->lexer.stream = argptr;
  file_exception.reason = 0;

  /* Initialize the default symtab and line offset.  */
  initialize_defaults (&PARSER_STATE (parser)->default_symtab,
		       &PARSER_STATE (parser)->default_line);

  /* Objective-C shortcut.  */
  values = decode_objc (PARSER_STATE (parser), PARSER_RESULT (parser), argptr);
  if (values.sals != NULL)
    return values;

  /* Start parsing.  */

  /* Get the first token.  */
  token = linespec_lexer_lex_one (parser);

  /* It must be either LSTOKEN_STRING or LSTOKEN_NUMBER.  */
  if (token.type == LSTOKEN_STRING && *LS_TOKEN_STOKEN (token).ptr == '*')
    {
      char *expr;
      const char *copy;

      /* User specified an expression, *EXPR.  */
      copy = expr = copy_token_string (token);
      cleanup = make_cleanup (xfree, expr);
      PARSER_RESULT (parser)->expr_pc = linespec_expression_to_pc (&copy);
      discard_cleanups (cleanup);
      PARSER_RESULT (parser)->expression = expr;

      /* This is a little hacky/tricky.  If linespec_expression_to_pc
	 did not evaluate the entire token, then we must find the
	 string COPY inside the original token buffer.  */
      if (*copy != '\0')
	{
	  PARSER_STREAM (parser) = strstr (parser->lexer.saved_arg, copy);
	  gdb_assert (PARSER_STREAM (parser) != NULL);
	}

      /* Consume the token.  */
      linespec_lexer_consume_token (parser);

      goto convert_to_sals;
    }
  else if (token.type == LSTOKEN_STRING && *LS_TOKEN_STOKEN (token).ptr == '$')
    {
      char *var;

      /* A NULL entry means to use GLOBAL_DEFAULT_SYMTAB.  */
      VEC_safe_push (symtab_ptr, PARSER_RESULT (parser)->file_symtabs, NULL);

      /* User specified a convenience variable or history value.  */
      var = copy_token_string (token);
      cleanup = make_cleanup (xfree, var);
      PARSER_RESULT (parser)->line_offset
	= linespec_parse_variable (PARSER_STATE (parser), var);
      do_cleanups (cleanup);

      /* If a line_offset wasn't found (VAR is the name of a user
	 variable/function), then skip to normal symbol processing.  */
      if (PARSER_RESULT (parser)->line_offset.sign != LINE_OFFSET_UNKNOWN)
	{
	  /* Consume this token.  */
	  linespec_lexer_consume_token (parser);

	  goto convert_to_sals;
	}
    }
  else if (token.type != LSTOKEN_STRING && token.type != LSTOKEN_NUMBER)
    unexpected_linespec_error (parser);

  /* Now we can recognize keywords.  */
  parser->keyword_ok = 1;

  /* Shortcut: If the next token is not LSTOKEN_COLON, we know that
     this token cannot represent a filename.  */
  token = linespec_lexer_peek_token (parser);

  if (token.type == LSTOKEN_COLON)
    {
      char *user_filename;

      /* Get the current token again and extract the filename.  */
      token = linespec_lexer_lex_one (parser);
      user_filename = copy_token_string (token);

      /* Check if the input is a filename.  */
      TRY_CATCH (file_exception, RETURN_MASK_ERROR)
	{
	  PARSER_RESULT (parser)->file_symtabs
	    = symtabs_from_filename (user_filename);
	}

      if (file_exception.reason >= 0)
	{
	  /* Symtabs were found for the file.  Record the filename.  */
	  PARSER_RESULT (parser)->source_filename = user_filename;

	  /* Get the next token.  */
	  token = linespec_lexer_consume_token (parser);

	  /* This is LSTOKEN_COLON; consume it.  */
	  linespec_lexer_consume_token (parser);
	}
      else
	{
	  /* No symtabs found -- discard user_filename.  */
	  xfree (user_filename);

	  /* A NULL entry means to use GLOBAL_DEFAULT_SYMTAB.  */
	  VEC_safe_push (symtab_ptr, PARSER_RESULT (parser)->file_symtabs, NULL);
	}
    }
  /* If the next token is not EOI, KEYWORD, or COMMA, issue an error.  */
  else if (token.type != LSTOKEN_EOI && token.type != LSTOKEN_KEYWORD
	   && token.type != LSTOKEN_COMMA)
    {
      /* TOKEN is the _next_ token, not the one currently in the parser.
	 Consuming the token will give the correct error message.  */
      linespec_lexer_consume_token (parser);
      unexpected_linespec_error (parser);
    }
  else
    {
      /* A NULL entry means to use GLOBAL_DEFAULT_SYMTAB.  */
      VEC_safe_push (symtab_ptr, PARSER_RESULT (parser)->file_symtabs, NULL);
    }

  /* Parse the rest of the linespec.  */
  linespec_parse_basic (parser);

  if (PARSER_RESULT (parser)->function_symbols == NULL
      && PARSER_RESULT (parser)->labels.label_symbols == NULL
      && PARSER_RESULT (parser)->line_offset.sign == LINE_OFFSET_UNKNOWN
      && PARSER_RESULT (parser)->minimal_symbols == NULL)
    {
      /* The linespec didn't parse.  Re-throw the file exception if
	 there was one.  */
      if (file_exception.reason < 0)
	throw_exception (file_exception);

      /* Otherwise, the symbol is not found.  */
      symbol_not_found_error (PARSER_RESULT (parser)->function_name,
			      PARSER_RESULT (parser)->source_filename);
    }

 convert_to_sals:

  /* Get the last token and record how much of the input was parsed,
     if necessary.  */
  token = linespec_lexer_lex_one (parser);
  if (token.type != LSTOKEN_EOI && token.type != LSTOKEN_KEYWORD)
    PARSER_STREAM (parser) = LS_TOKEN_STOKEN (token).ptr;

  /* Convert the data in PARSER_RESULT to SALs.  */
  values = convert_linespec_to_sals (PARSER_STATE (parser),
				     PARSER_RESULT (parser));

  return values;
}


/* A constructor for linespec_state.  */

static void
linespec_state_constructor (struct linespec_state *self,
			    int flags, const struct language_defn *language,
			    struct symtab *default_symtab,
			    int default_line,
			    struct linespec_result *canonical)
{
  memset (self, 0, sizeof (*self));
  self->language = language;
  self->funfirstline = (flags & DECODE_LINE_FUNFIRSTLINE) ? 1 : 0;
  self->list_mode = (flags & DECODE_LINE_LIST_MODE) ? 1 : 0;
  self->default_symtab = default_symtab;
  self->default_line = default_line;
  self->canonical = canonical;
  self->program_space = current_program_space;
  self->addr_set = htab_create_alloc (10, hash_address_entry, eq_address_entry,
				      xfree, xcalloc, xfree);
}

/* Initialize a new linespec parser.  */

static void
linespec_parser_new (linespec_parser *parser,
		     int flags, const struct language_defn *language,
		     struct symtab *default_symtab,
		     int default_line,
		     struct linespec_result *canonical)
{
  parser->lexer.current.type = LSTOKEN_CONSUMED;
  memset (PARSER_RESULT (parser), 0, sizeof (struct linespec));
  PARSER_RESULT (parser)->line_offset.sign = LINE_OFFSET_UNKNOWN;
  linespec_state_constructor (PARSER_STATE (parser), flags, language,
			      default_symtab, default_line, canonical);
}

/* A destructor for linespec_state.  */

static void
linespec_state_destructor (struct linespec_state *self)
{
  htab_delete (self->addr_set);
}

/* Delete a linespec parser.  */

static void
linespec_parser_delete (void *arg)
{
  linespec_parser *parser = (linespec_parser *) arg;

  xfree ((char *) PARSER_RESULT (parser)->expression);
  xfree ((char *) PARSER_RESULT (parser)->source_filename);
  xfree ((char *) PARSER_RESULT (parser)->label_name);
  xfree ((char *) PARSER_RESULT (parser)->function_name);

  if (PARSER_RESULT (parser)->file_symtabs != NULL)
    VEC_free (symtab_ptr, PARSER_RESULT (parser)->file_symtabs);

  if (PARSER_RESULT (parser)->function_symbols != NULL)
    VEC_free (symbolp, PARSER_RESULT (parser)->function_symbols);

  if (PARSER_RESULT (parser)->minimal_symbols != NULL)
    VEC_free (bound_minimal_symbol_d, PARSER_RESULT (parser)->minimal_symbols);

  if (PARSER_RESULT (parser)->labels.label_symbols != NULL)
    VEC_free (symbolp, PARSER_RESULT (parser)->labels.label_symbols);

  if (PARSER_RESULT (parser)->labels.function_symbols != NULL)
    VEC_free (symbolp, PARSER_RESULT (parser)->labels.function_symbols);

  linespec_state_destructor (PARSER_STATE (parser));
}

/* See linespec.h.  */

void
decode_line_full (char **argptr, int flags,
		  struct symtab *default_symtab,
		  int default_line, struct linespec_result *canonical,
		  const char *select_mode,
		  const char *filter)
{
  struct symtabs_and_lines result;
  struct cleanup *cleanups;
  VEC (const_char_ptr) *filters = NULL;
  linespec_parser parser;
  struct linespec_state *state;
  const char *copy, *orig;

  gdb_assert (canonical != NULL);
  /* The filter only makes sense for 'all'.  */
  gdb_assert (filter == NULL || select_mode == multiple_symbols_all);
  gdb_assert (select_mode == NULL
	      || select_mode == multiple_symbols_all
	      || select_mode == multiple_symbols_ask
	      || select_mode == multiple_symbols_cancel);
  gdb_assert ((flags & DECODE_LINE_LIST_MODE) == 0);

  linespec_parser_new (&parser, flags, current_language, default_symtab,
		       default_line, canonical);
  cleanups = make_cleanup (linespec_parser_delete, &parser);
  save_current_program_space ();

  orig = copy = *argptr;
  result = parse_linespec (&parser, &copy);
  *argptr += copy - orig;
  state = PARSER_STATE (&parser);

  gdb_assert (result.nelts == 1 || canonical->pre_expanded);
  gdb_assert (canonical->addr_string != NULL);
  canonical->pre_expanded = 1;

  /* Arrange for allocated canonical names to be freed.  */
  if (result.nelts > 0)
    {
      int i;

      make_cleanup (xfree, state->canonical_names);
      for (i = 0; i < result.nelts; ++i)
	{
	  gdb_assert (state->canonical_names[i].suffix != NULL);
	  make_cleanup (xfree, state->canonical_names[i].suffix);
	}
    }

  if (select_mode == NULL)
    {
      if (ui_out_is_mi_like_p (interp_ui_out (top_level_interpreter ())))
	select_mode = multiple_symbols_all;
      else
	select_mode = multiple_symbols_select_mode ();
    }

  if (select_mode == multiple_symbols_all)
    {
      if (filter != NULL)
	{
	  make_cleanup (VEC_cleanup (const_char_ptr), &filters);
	  VEC_safe_push (const_char_ptr, filters, filter);
	  filter_results (state, &result, filters);
	}
      else
	convert_results_to_lsals (state, &result);
    }
  else
    decode_line_2 (state, &result, select_mode);

  do_cleanups (cleanups);
}

/* See linespec.h.  */

struct symtabs_and_lines
decode_line_1 (char **argptr, int flags,
	       struct symtab *default_symtab,
	       int default_line)
{
  struct symtabs_and_lines result;
  linespec_parser parser;
  struct cleanup *cleanups;
  const char *copy, *orig;

  linespec_parser_new (&parser, flags, current_language, default_symtab,
		       default_line, NULL);
  cleanups = make_cleanup (linespec_parser_delete, &parser);
  save_current_program_space ();

  orig = copy = *argptr;
  result = parse_linespec (&parser, &copy);
  *argptr += copy - orig;

  do_cleanups (cleanups);
  return result;
}

/* See linespec.h.  */

struct symtabs_and_lines
decode_line_with_current_source (char *string, int flags)
{
  struct symtabs_and_lines sals;
  struct symtab_and_line cursal;

  if (string == 0)
    error (_("Empty line specification."));

  /* We use whatever is set as the current source line.  We do not try
     and get a default source symtab+line or it will recursively call us!  */
  cursal = get_current_source_symtab_and_line ();

  sals = decode_line_1 (&string, flags,
			cursal.symtab, cursal.line);

  if (*string)
    error (_("Junk at end of line specification: %s"), string);
  return sals;
}

/* See linespec.h.  */

struct symtabs_and_lines
decode_line_with_last_displayed (char *string, int flags)
{
  struct symtabs_and_lines sals;

  if (string == 0)
    error (_("Empty line specification."));

  if (last_displayed_sal_is_valid ())
    sals = decode_line_1 (&string, flags,
			  get_last_displayed_symtab (),
			  get_last_displayed_line ());
  else
    sals = decode_line_1 (&string, flags, (struct symtab *) NULL, 0);

  if (*string)
    error (_("Junk at end of line specification: %s"), string);
  return sals;
}



/* First, some functions to initialize stuff at the beggining of the
   function.  */

static void
initialize_defaults (struct symtab **default_symtab, int *default_line)
{
  if (*default_symtab == 0)
    {
      /* Use whatever we have for the default source line.  We don't use
         get_current_or_default_symtab_and_line as it can recurse and call
	 us back!  */
      struct symtab_and_line cursal = 
	get_current_source_symtab_and_line ();
      
      *default_symtab = cursal.symtab;
      *default_line = cursal.line;
    }
}



/* Evaluate the expression pointed to by EXP_PTR into a CORE_ADDR,
   advancing EXP_PTR past any parsed text.  */

static CORE_ADDR
linespec_expression_to_pc (const char **exp_ptr)
{
  if (current_program_space->executing_startup)
    /* The error message doesn't really matter, because this case
       should only hit during breakpoint reset.  */
    throw_error (NOT_FOUND_ERROR, _("cannot evaluate expressions while "
				    "program space is in startup"));

  (*exp_ptr)++;
  return value_as_address (parse_to_comma_and_eval (exp_ptr));
}



/* Here's where we recognise an Objective-C Selector.  An Objective C
   selector may be implemented by more than one class, therefore it
   may represent more than one method/function.  This gives us a
   situation somewhat analogous to C++ overloading.  If there's more
   than one method that could represent the selector, then use some of
   the existing C++ code to let the user choose one.  */

static struct symtabs_and_lines
decode_objc (struct linespec_state *self, linespec_p ls, const char **argptr)
{
  struct collect_info info;
  VEC (const_char_ptr) *symbol_names = NULL;
  struct symtabs_and_lines values;
  const char *new_argptr;
  struct cleanup *cleanup = make_cleanup (VEC_cleanup (const_char_ptr),
					  &symbol_names);

  info.state = self;
  info.file_symtabs = NULL;
  VEC_safe_push (symtab_ptr, info.file_symtabs, NULL);
  make_cleanup (VEC_cleanup (symtab_ptr), &info.file_symtabs);
  info.result.symbols = NULL;
  info.result.minimal_symbols = NULL;
  values.nelts = 0;
  values.sals = NULL;

  new_argptr = find_imps (*argptr, &symbol_names); 
  if (VEC_empty (const_char_ptr, symbol_names))
    {
      do_cleanups (cleanup);
      return values;
    }

  add_all_symbol_names_from_pspace (&info, NULL, symbol_names);

  if (!VEC_empty (symbolp, info.result.symbols)
      || !VEC_empty (bound_minimal_symbol_d, info.result.minimal_symbols))
    {
      char *saved_arg;

      saved_arg = alloca (new_argptr - *argptr + 1);
      memcpy (saved_arg, *argptr, new_argptr - *argptr);
      saved_arg[new_argptr - *argptr] = '\0';

      ls->function_name = xstrdup (saved_arg);
      ls->function_symbols = info.result.symbols;
      ls->minimal_symbols = info.result.minimal_symbols;
      values = convert_linespec_to_sals (self, ls);

      if (self->canonical)
	{
	  self->canonical->pre_expanded = 1;
	  if (ls->source_filename)
	    self->canonical->addr_string
	      = xstrprintf ("%s:%s", ls->source_filename, saved_arg);
	  else
	    self->canonical->addr_string = xstrdup (saved_arg);
	}
    }

  *argptr = new_argptr;

  do_cleanups (cleanup);

  return values;
}

/* An instance of this type is used when collecting prefix symbols for
   decode_compound.  */

struct decode_compound_collector
{
  /* The result vector.  */
  VEC (symbolp) *symbols;

  /* A hash table of all symbols we found.  We use this to avoid
     adding any symbol more than once.  */
  htab_t unique_syms;
};

/* A callback for iterate_over_symbols that is used by
   lookup_prefix_sym to collect type symbols.  */

static int
collect_one_symbol (struct symbol *sym, void *d)
{
  struct decode_compound_collector *collector = d;
  void **slot;
  struct type *t;

  if (SYMBOL_CLASS (sym) != LOC_TYPEDEF)
    return 1; /* Continue iterating.  */

  t = SYMBOL_TYPE (sym);
  CHECK_TYPEDEF (t);
  if (TYPE_CODE (t) != TYPE_CODE_STRUCT
      && TYPE_CODE (t) != TYPE_CODE_UNION
      && TYPE_CODE (t) != TYPE_CODE_NAMESPACE)
    return 1; /* Continue iterating.  */

  slot = htab_find_slot (collector->unique_syms, sym, INSERT);
  if (!*slot)
    {
      *slot = sym;
      VEC_safe_push (symbolp, collector->symbols, sym);
    }

  return 1; /* Continue iterating.  */
}

/* Return any symbols corresponding to CLASS_NAME in FILE_SYMTABS.  */

static VEC (symbolp) *
lookup_prefix_sym (struct linespec_state *state, VEC (symtab_ptr) *file_symtabs,
		   const char *class_name)
{
  int ix;
  struct symtab *elt;
  struct decode_compound_collector collector;
  struct cleanup *outer;
  struct cleanup *cleanup;

  collector.symbols = NULL;
  outer = make_cleanup (VEC_cleanup (symbolp), &collector.symbols);

  collector.unique_syms = htab_create_alloc (1, htab_hash_pointer,
					     htab_eq_pointer, NULL,
					     xcalloc, xfree);
  cleanup = make_cleanup_htab_delete (collector.unique_syms);

  for (ix = 0; VEC_iterate (symtab_ptr, file_symtabs, ix, elt); ++ix)
    {
      if (elt == NULL)
	{
	  iterate_over_all_matching_symtabs (state, class_name, STRUCT_DOMAIN,
					     collect_one_symbol, &collector,
					     NULL, 0);
	  iterate_over_all_matching_symtabs (state, class_name, VAR_DOMAIN,
					     collect_one_symbol, &collector,
					     NULL, 0);
	}
      else
	{
	  /* Program spaces that are executing startup should have
	     been filtered out earlier.  */
	  gdb_assert (!SYMTAB_PSPACE (elt)->executing_startup);
	  set_current_program_space (SYMTAB_PSPACE (elt));
	  iterate_over_file_blocks (elt, class_name, STRUCT_DOMAIN,
				    collect_one_symbol, &collector);
	  iterate_over_file_blocks (elt, class_name, VAR_DOMAIN,
				    collect_one_symbol, &collector);
	}
    }

  do_cleanups (cleanup);
  discard_cleanups (outer);
  return collector.symbols;
}

/* A qsort comparison function for symbols.  The resulting order does
   not actually matter; we just need to be able to sort them so that
   symbols with the same program space end up next to each other.  */

static int
compare_symbols (const void *a, const void *b)
{
  struct symbol * const *sa = a;
  struct symbol * const *sb = b;
  uintptr_t uia, uib;

  uia = (uintptr_t) SYMTAB_PSPACE (SYMBOL_SYMTAB (*sa));
  uib = (uintptr_t) SYMTAB_PSPACE (SYMBOL_SYMTAB (*sb));

  if (uia < uib)
    return -1;
  if (uia > uib)
    return 1;

  uia = (uintptr_t) *sa;
  uib = (uintptr_t) *sb;

  if (uia < uib)
    return -1;
  if (uia > uib)
    return 1;

  return 0;
}

/* Like compare_symbols but for minimal symbols.  */

static int
compare_msymbols (const void *a, const void *b)
{
  const struct bound_minimal_symbol *sa = a;
  const struct bound_minimal_symbol *sb = b;
  uintptr_t uia, uib;

  uia = (uintptr_t) sa->objfile->pspace;
  uib = (uintptr_t) sa->objfile->pspace;

  if (uia < uib)
    return -1;
  if (uia > uib)
    return 1;

  uia = (uintptr_t) sa->minsym;
  uib = (uintptr_t) sb->minsym;

  if (uia < uib)
    return -1;
  if (uia > uib)
    return 1;

  return 0;
}

/* Look for all the matching instances of each symbol in NAMES.  Only
   instances from PSPACE are considered; other program spaces are
   handled by our caller.  If PSPACE is NULL, then all program spaces
   are considered.  Results are stored into INFO.  */

static void
add_all_symbol_names_from_pspace (struct collect_info *info,
				  struct program_space *pspace,
				  VEC (const_char_ptr) *names)
{
  int ix;
  const char *iter;

  for (ix = 0; VEC_iterate (const_char_ptr, names, ix, iter); ++ix)
    add_matching_symbols_to_info (iter, info, pspace);
}

static void
find_superclass_methods (VEC (typep) *superclasses,
			 const char *name,
			 VEC (const_char_ptr) **result_names)
{
  int old_len = VEC_length (const_char_ptr, *result_names);
  VEC (typep) *iter_classes;
  struct cleanup *cleanup = make_cleanup (null_cleanup, NULL);

  iter_classes = superclasses;
  while (1)
    {
      VEC (typep) *new_supers = NULL;
      int ix;
      struct type *t;

      make_cleanup (VEC_cleanup (typep), &new_supers);
      for (ix = 0; VEC_iterate (typep, iter_classes, ix, t); ++ix)
	find_methods (t, name, result_names, &new_supers);

      if (VEC_length (const_char_ptr, *result_names) != old_len
	  || VEC_empty (typep, new_supers))
	break;

      iter_classes = new_supers;
    }

  do_cleanups (cleanup);
}

/* This finds the method METHOD_NAME in the class CLASS_NAME whose type is
   given by one of the symbols in SYM_CLASSES.  Matches are returned
   in SYMBOLS (for debug symbols) and MINSYMS (for minimal symbols).  */

static void
find_method (struct linespec_state *self, VEC (symtab_ptr) *file_symtabs,
	     const char *class_name, const char *method_name,
	     VEC (symbolp) *sym_classes, VEC (symbolp) **symbols,
	     VEC (bound_minimal_symbol_d) **minsyms)
{
  struct symbol *sym;
  struct cleanup *cleanup = make_cleanup (null_cleanup, NULL);
  int ix;
  int last_result_len;
  VEC (typep) *superclass_vec;
  VEC (const_char_ptr) *result_names;
  struct collect_info info;

  /* Sort symbols so that symbols with the same program space are next
     to each other.  */
  qsort (VEC_address (symbolp, sym_classes),
	 VEC_length (symbolp, sym_classes),
	 sizeof (symbolp),
	 compare_symbols);

  info.state = self;
  info.file_symtabs = file_symtabs;
  info.result.symbols = NULL;
  info.result.minimal_symbols = NULL;

  /* Iterate over all the types, looking for the names of existing
     methods matching METHOD_NAME.  If we cannot find a direct method in a
     given program space, then we consider inherited methods; this is
     not ideal (ideal would be to respect C++ hiding rules), but it
     seems good enough and is what GDB has historically done.  We only
     need to collect the names because later we find all symbols with
     those names.  This loop is written in a somewhat funny way
     because we collect data across the program space before deciding
     what to do.  */
  superclass_vec = NULL;
  make_cleanup (VEC_cleanup (typep), &superclass_vec);
  result_names = NULL;
  make_cleanup (VEC_cleanup (const_char_ptr), &result_names);
  last_result_len = 0;
  for (ix = 0; VEC_iterate (symbolp, sym_classes, ix, sym); ++ix)
    {
      struct type *t;
      struct program_space *pspace;

      /* Program spaces that are executing startup should have
	 been filtered out earlier.  */
      gdb_assert (!SYMTAB_PSPACE (SYMBOL_SYMTAB (sym))->executing_startup);
      pspace = SYMTAB_PSPACE (SYMBOL_SYMTAB (sym));
      set_current_program_space (pspace);
      t = check_typedef (SYMBOL_TYPE (sym));
      find_methods (t, method_name, &result_names, &superclass_vec);

      /* Handle all items from a single program space at once; and be
	 sure not to miss the last batch.  */
      if (ix == VEC_length (symbolp, sym_classes) - 1
	  || (pspace
	      != SYMTAB_PSPACE (SYMBOL_SYMTAB (VEC_index (symbolp, sym_classes,
							  ix + 1)))))
	{
	  /* If we did not find a direct implementation anywhere in
	     this program space, consider superclasses.  */
	  if (VEC_length (const_char_ptr, result_names) == last_result_len)
	    find_superclass_methods (superclass_vec, method_name,
				     &result_names);

	  /* We have a list of candidate symbol names, so now we
	     iterate over the symbol tables looking for all
	     matches in this pspace.  */
	  add_all_symbol_names_from_pspace (&info, pspace, result_names);

	  VEC_truncate (typep, superclass_vec, 0);
	  last_result_len = VEC_length (const_char_ptr, result_names);
	}
    }

  if (!VEC_empty (symbolp, info.result.symbols)
      || !VEC_empty (bound_minimal_symbol_d, info.result.minimal_symbols))
    {
      *symbols = info.result.symbols;
      *minsyms = info.result.minimal_symbols;
      do_cleanups (cleanup);
      return;
    }

  /* Throw an NOT_FOUND_ERROR.  This will be caught by the caller
     and other attempts to locate the symbol will be made.  */
  throw_error (NOT_FOUND_ERROR, _("see caller, this text doesn't matter"));
}



/* This object is used when collecting all matching symtabs.  */

struct symtab_collector
{
  /* The result vector of symtabs.  */
  VEC (symtab_ptr) *symtabs;

  /* This is used to ensure the symtabs are unique.  */
  htab_t symtab_table;
};

/* Callback for iterate_over_symtabs.  */

static int
add_symtabs_to_list (struct symtab *symtab, void *d)
{
  struct symtab_collector *data = d;
  void **slot;

  slot = htab_find_slot (data->symtab_table, symtab, INSERT);
  if (!*slot)
    {
      *slot = symtab;
      VEC_safe_push (symtab_ptr, data->symtabs, symtab);
    }

  return 0;
}

/* Given a file name, return a VEC of all matching symtabs.  */

static VEC (symtab_ptr) *
collect_symtabs_from_filename (const char *file)
{
  struct symtab_collector collector;
  struct cleanup *cleanups;
  struct program_space *pspace;

  collector.symtabs = NULL;
  collector.symtab_table = htab_create (1, htab_hash_pointer, htab_eq_pointer,
					NULL);
  cleanups = make_cleanup_htab_delete (collector.symtab_table);

  /* Find that file's data.  */
  ALL_PSPACES (pspace)
  {
    if (pspace->executing_startup)
      continue;

    set_current_program_space (pspace);
    iterate_over_symtabs (file, add_symtabs_to_list, &collector);
  }

  do_cleanups (cleanups);
  return collector.symtabs;
}

/* Return all the symtabs associated to the FILENAME.  */

static VEC (symtab_ptr) *
symtabs_from_filename (const char *filename)
{
  VEC (symtab_ptr) *result;
  
  result = collect_symtabs_from_filename (filename);

  if (VEC_empty (symtab_ptr, result))
    {
      if (!have_full_symbols () && !have_partial_symbols ())
	throw_error (NOT_FOUND_ERROR,
		     _("No symbol table is loaded.  "
		       "Use the \"file\" command."));
      throw_error (NOT_FOUND_ERROR, _("No source file named %s."), filename);
    }

  return result;
}

/* Look up a function symbol named NAME in symtabs FILE_SYMTABS.  Matching
   debug symbols are returned in SYMBOLS.  Matching minimal symbols are
   returned in MINSYMS.  */

static void
find_function_symbols (struct linespec_state *state,
		       VEC (symtab_ptr) *file_symtabs, const char *name,
		       VEC (symbolp) **symbols,
		       VEC (bound_minimal_symbol_d) **minsyms)
{
  struct collect_info info;
  VEC (const_char_ptr) *symbol_names = NULL;
  struct cleanup *cleanup = make_cleanup (VEC_cleanup (const_char_ptr),
					  &symbol_names);

  info.state = state;
  info.result.symbols = NULL;
  info.result.minimal_symbols = NULL;
  info.file_symtabs = file_symtabs;

  /* Try NAME as an Objective-C selector.  */
  find_imps (name, &symbol_names);
  if (!VEC_empty (const_char_ptr, symbol_names))
    add_all_symbol_names_from_pspace (&info, NULL, symbol_names);
  else
    add_matching_symbols_to_info (name, &info, NULL);

  do_cleanups (cleanup);

  if (VEC_empty (symbolp, info.result.symbols))
    {
      VEC_free (symbolp, info.result.symbols);
      *symbols = NULL;
    }
  else
    *symbols = info.result.symbols;

  if (VEC_empty (bound_minimal_symbol_d, info.result.minimal_symbols))
    {
      VEC_free (bound_minimal_symbol_d, info.result.minimal_symbols);
      *minsyms = NULL;
    }
  else
    *minsyms = info.result.minimal_symbols;
}

/* Find all symbols named NAME in FILE_SYMTABS, returning debug symbols
   in SYMBOLS and minimal symbols in MINSYMS.  */

static void
find_linespec_symbols (struct linespec_state *state,
		       VEC (symtab_ptr) *file_symtabs,
		       const char *name,
		       VEC (symbolp) **symbols,
		       VEC (bound_minimal_symbol_d) **minsyms)
{
  struct cleanup *cleanup;
  char *canon;
  const char *lookup_name;
  volatile struct gdb_exception except;

  cleanup = demangle_for_lookup (name, state->language->la_language,
				 &lookup_name);
  if (state->language->la_language == language_ada)
    {
      /* In Ada, the symbol lookups are performed using the encoded
         name rather than the demangled name.  */
      lookup_name = ada_name_for_lookup (name);
      make_cleanup (xfree, (void *) lookup_name);
    }

  canon = cp_canonicalize_string_no_typedefs (lookup_name);
  if (canon != NULL)
    {
      lookup_name = canon;
      make_cleanup (xfree, canon);
    }

  /* It's important to not call expand_symtabs_matching unnecessarily
     as it can really slow things down (by unnecessarily expanding
     potentially 1000s of symtabs, which when debugging some apps can
     cost 100s of seconds).  Avoid this to some extent by *first* calling
     find_function_symbols, and only if that doesn't find anything
     *then* call find_method.  This handles two important cases:
     1) break (anonymous namespace)::foo
     2) break class::method where method is in class (and not a baseclass)  */

  find_function_symbols (state, file_symtabs, lookup_name,
			 symbols, minsyms);

  /* If we were unable to locate a symbol of the same name, try dividing
     the name into class and method names and searching the class and its
     baseclasses.  */
  if (VEC_empty (symbolp, *symbols)
      && VEC_empty (bound_minimal_symbol_d, *minsyms))
    {
      char *klass, *method;
      const char *last, *p, *scope_op;
      VEC (symbolp) *classes;

      /* See if we can find a scope operator and break this symbol
	 name into namespaces${SCOPE_OPERATOR}class_name and method_name.  */
      scope_op = "::";
      p = find_toplevel_string (lookup_name, scope_op);
      if (p == NULL)
	{
	  /* No C++ scope operator.  Try Java.  */
	  scope_op = ".";
	  p = find_toplevel_string (lookup_name, scope_op);
	}

      last = NULL;
      while (p != NULL)
	{
	  last = p;
	  p = find_toplevel_string (p + strlen (scope_op), scope_op);
	}

      /* If no scope operator was found, there is nothing more we can do;
	 we already attempted to lookup the entire name as a symbol
	 and failed.  */
      if (last == NULL)
	{
	  do_cleanups (cleanup);
	  return;
	}

      /* LOOKUP_NAME points to the class name.
	 LAST points to the method name.  */
      klass = xmalloc ((last - lookup_name + 1) * sizeof (char));
      make_cleanup (xfree, klass);
      strncpy (klass, lookup_name, last - lookup_name);
      klass[last - lookup_name] = '\0';

      /* Skip past the scope operator.  */
      last += strlen (scope_op);
      method = xmalloc ((strlen (last) + 1) * sizeof (char));
      make_cleanup (xfree, method);
      strcpy (method, last);

      /* Find a list of classes named KLASS.  */
      classes = lookup_prefix_sym (state, file_symtabs, klass);
      make_cleanup (VEC_cleanup (symbolp), &classes);

      if (!VEC_empty (symbolp, classes))
	{
	  /* Now locate a list of suitable methods named METHOD.  */
	  TRY_CATCH (except, RETURN_MASK_ERROR)
	    {
	      find_method (state, file_symtabs, klass, method, classes,
			   symbols, minsyms);
	    }

	  /* If successful, we're done.  If NOT_FOUND_ERROR
	     was not thrown, rethrow the exception that we did get.  */
	  if (except.reason < 0 && except.error != NOT_FOUND_ERROR)
	    throw_exception (except);
	}
    }

  do_cleanups (cleanup);
}

/* Return all labels named NAME in FUNCTION_SYMBOLS.  Return the
   actual function symbol in which the label was found in LABEL_FUNC_RET.  */

static VEC (symbolp) *
find_label_symbols (struct linespec_state *self,
		    VEC (symbolp) *function_symbols,
		    VEC (symbolp) **label_funcs_ret, const char *name)
{
  int ix;
  struct block *block;
  struct symbol *sym;
  struct symbol *fn_sym;
  VEC (symbolp) *result = NULL;

  if (function_symbols == NULL)
    {
      set_current_program_space (self->program_space);
      block = get_current_search_block ();

      for (;
	   block && !BLOCK_FUNCTION (block);
	   block = BLOCK_SUPERBLOCK (block))
	;
      if (!block)
	return NULL;
      fn_sym = BLOCK_FUNCTION (block);

      sym = lookup_symbol (name, block, LABEL_DOMAIN, 0);

      if (sym != NULL)
	{
	  VEC_safe_push (symbolp, result, sym);
	  VEC_safe_push (symbolp, *label_funcs_ret, fn_sym);
	}
    }
  else
    {
      for (ix = 0;
	   VEC_iterate (symbolp, function_symbols, ix, fn_sym); ++ix)
	{
	  set_current_program_space (SYMTAB_PSPACE (SYMBOL_SYMTAB (fn_sym)));
	  block = SYMBOL_BLOCK_VALUE (fn_sym);
	  sym = lookup_symbol (name, block, LABEL_DOMAIN, 0);

	  if (sym != NULL)
	    {
	      VEC_safe_push (symbolp, result, sym);
	      VEC_safe_push (symbolp, *label_funcs_ret, fn_sym);
	    }
	}
    }

  return result;
}



/* A helper for create_sals_line_offset that handles the 'list_mode' case.  */

static void
decode_digits_list_mode (struct linespec_state *self,
			 linespec_p ls,
			 struct symtabs_and_lines *values,
			 struct symtab_and_line val)
{
  int ix;
  struct symtab *elt;

  gdb_assert (self->list_mode);

  for (ix = 0; VEC_iterate (symtab_ptr, ls->file_symtabs, ix, elt);
       ++ix)
    {
      /* The logic above should ensure this.  */
      gdb_assert (elt != NULL);

      set_current_program_space (SYMTAB_PSPACE (elt));

      /* Simplistic search just for the list command.  */
      val.symtab = find_line_symtab (elt, val.line, NULL, NULL);
      if (val.symtab == NULL)
	val.symtab = elt;
      val.pspace = SYMTAB_PSPACE (elt);
      val.pc = 0;
      val.explicit_line = 1;

      add_sal_to_sals (self, values, &val, NULL, 0);
    }
}

/* A helper for create_sals_line_offset that iterates over the symtabs,
   adding lines to the VEC.  */

static void
decode_digits_ordinary (struct linespec_state *self,
			linespec_p ls,
			int line,
			struct symtabs_and_lines *sals,
			struct linetable_entry **best_entry)
{
  int ix;
  struct symtab *elt;

  for (ix = 0; VEC_iterate (symtab_ptr, ls->file_symtabs, ix, elt); ++ix)
    {
      int i;
      VEC (CORE_ADDR) *pcs;
      CORE_ADDR pc;

      /* The logic above should ensure this.  */
      gdb_assert (elt != NULL);

      set_current_program_space (SYMTAB_PSPACE (elt));

      pcs = find_pcs_for_symtab_line (elt, line, best_entry);
      for (i = 0; VEC_iterate (CORE_ADDR, pcs, i, pc); ++i)
	{
	  struct symtab_and_line sal;

	  init_sal (&sal);
	  sal.pspace = SYMTAB_PSPACE (elt);
	  sal.symtab = elt;
	  sal.line = line;
	  sal.pc = pc;
	  add_sal_to_sals_basic (sals, &sal);
	}

      VEC_free (CORE_ADDR, pcs);
    }
}



/* Return the line offset represented by VARIABLE.  */

static struct line_offset
linespec_parse_variable (struct linespec_state *self, const char *variable)
{
  int index = 0;
  const char *p;
  struct line_offset offset = {0, LINE_OFFSET_NONE};

  p = (variable[1] == '$') ? variable + 2 : variable + 1;
  if (*p == '$')
    ++p;
  while (*p >= '0' && *p <= '9')
    ++p;
  if (!*p)		/* Reached end of token without hitting non-digit.  */
    {
      /* We have a value history reference.  */
      struct value *val_history;

      sscanf ((variable[1] == '$') ? variable + 2 : variable + 1, "%d", &index);
      val_history
	= access_value_history ((variable[1] == '$') ? -index : index);
      if (TYPE_CODE (value_type (val_history)) != TYPE_CODE_INT)
	error (_("History values used in line "
		 "specs must have integer values."));
      offset.offset = value_as_long (val_history);
    }
  else
    {
      /* Not all digits -- may be user variable/function or a
	 convenience variable.  */
      LONGEST valx;
      struct internalvar *ivar;

      /* Try it as a convenience variable.  If it is not a convenience
	 variable, return and allow normal symbol lookup to occur.  */
      ivar = lookup_only_internalvar (variable + 1);
      if (ivar == NULL)
	/* No internal variable with that name.  Mark the offset
	   as unknown to allow the name to be looked up as a symbol.  */
	offset.sign = LINE_OFFSET_UNKNOWN;
      else
	{
	  /* We found a valid variable name.  If it is not an integer,
	     throw an error.  */
	  if (!get_internalvar_integer (ivar, &valx))
	    error (_("Convenience variables used in line "
		     "specs must have integer values."));
	  else
	    offset.offset = valx;
	}
    }

  return offset;
}


/* A callback used to possibly add a symbol to the results.  */

static int
collect_symbols (struct symbol *sym, void *data)
{
  struct collect_info *info = data;

  /* In list mode, add all matching symbols, regardless of class.
     This allows the user to type "list a_global_variable".  */
  if (SYMBOL_CLASS (sym) == LOC_BLOCK || info->state->list_mode)
    VEC_safe_push (symbolp, info->result.symbols, sym);
  return 1; /* Continue iterating.  */
}

/* We've found a minimal symbol MSYMBOL in OBJFILE to associate with our
   linespec; return the SAL in RESULT.  */

static void
minsym_found (struct linespec_state *self, struct objfile *objfile,
	      struct minimal_symbol *msymbol,
	      struct symtabs_and_lines *result)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  CORE_ADDR pc;
  struct symtab_and_line sal;

  sal = find_pc_sect_line (SYMBOL_VALUE_ADDRESS (msymbol),
			   (struct obj_section *) 0, 0);
  sal.section = SYMBOL_OBJ_SECTION (objfile, msymbol);

  /* The minimal symbol might point to a function descriptor;
     resolve it to the actual code address instead.  */
  pc = gdbarch_convert_from_func_ptr_addr (gdbarch, sal.pc, &current_target);
  if (pc != sal.pc)
    sal = find_pc_sect_line (pc, NULL, 0);

  if (self->funfirstline)
    skip_prologue_sal (&sal);

  if (maybe_add_address (self->addr_set, objfile->pspace, sal.pc))
    add_sal_to_sals (self, result, &sal, SYMBOL_NATURAL_NAME (msymbol), 0);
}

/* A helper struct to pass some data through
   iterate_over_minimal_symbols.  */

struct collect_minsyms
{
  /* The objfile we're examining.  */
  struct objfile *objfile;

  /* The funfirstline setting from the initial call.  */
  int funfirstline;

  /* The list_mode setting from the initial call.  */
  int list_mode;

  /* The resulting symbols.  */
  VEC (bound_minimal_symbol_d) *msyms;
};

/* A helper function to classify a minimal_symbol_type according to
   priority.  */

static int
classify_mtype (enum minimal_symbol_type t)
{
  switch (t)
    {
    case mst_file_text:
    case mst_file_data:
    case mst_file_bss:
      /* Intermediate priority.  */
      return 1;

    case mst_solib_trampoline:
      /* Lowest priority.  */
      return 2;

    default:
      /* Highest priority.  */
      return 0;
    }
}

/* Callback for qsort that sorts symbols by priority.  */

static int
compare_msyms (const void *a, const void *b)
{
  const bound_minimal_symbol_d *moa = a;
  const bound_minimal_symbol_d *mob = b;
  enum minimal_symbol_type ta = MSYMBOL_TYPE (moa->minsym);
  enum minimal_symbol_type tb = MSYMBOL_TYPE (mob->minsym);

  return classify_mtype (ta) - classify_mtype (tb);
}

/* Callback for iterate_over_minimal_symbols that adds the symbol to
   the result.  */

static void
add_minsym (struct minimal_symbol *minsym, void *d)
{
  struct collect_minsyms *info = d;
  bound_minimal_symbol_d mo;

  /* Exclude data symbols when looking for breakpoint locations.   */
  if (!info->list_mode)
    switch (minsym->type)
      {
	case mst_slot_got_plt:
	case mst_data:
	case mst_bss:
	case mst_abs:
	case mst_file_data:
	case mst_file_bss:
	  {
	    /* Make sure this minsym is not a function descriptor
	       before we decide to discard it.  */
	    struct gdbarch *gdbarch = get_objfile_arch (info->objfile);
	    CORE_ADDR addr = gdbarch_convert_from_func_ptr_addr
			       (gdbarch, SYMBOL_VALUE_ADDRESS (minsym),
				&current_target);

	    if (addr == SYMBOL_VALUE_ADDRESS (minsym))
	      return;
	  }
      }

  mo.minsym = minsym;
  mo.objfile = info->objfile;
  VEC_safe_push (bound_minimal_symbol_d, info->msyms, &mo);
}

/* Search minimal symbols in all objfiles for NAME.  If SEARCH_PSPACE
   is not NULL, the search is restricted to just that program
   space.  */

static void
search_minsyms_for_name (struct collect_info *info, const char *name,
			 struct program_space *search_pspace)
{
  struct objfile *objfile;
  struct program_space *pspace;

  ALL_PSPACES (pspace)
  {
    struct collect_minsyms local;
    struct cleanup *cleanup;

    if (search_pspace != NULL && search_pspace != pspace)
      continue;
    if (pspace->executing_startup)
      continue;

    set_current_program_space (pspace);

    memset (&local, 0, sizeof (local));
    local.funfirstline = info->state->funfirstline;
    local.list_mode = info->state->list_mode;

    cleanup = make_cleanup (VEC_cleanup (bound_minimal_symbol_d),
			    &local.msyms);

    ALL_OBJFILES (objfile)
    {
      local.objfile = objfile;
      iterate_over_minimal_symbols (objfile, name, add_minsym, &local);
    }

    if (!VEC_empty (bound_minimal_symbol_d, local.msyms))
      {
	int classification;
	int ix;
	bound_minimal_symbol_d *item;

	qsort (VEC_address (bound_minimal_symbol_d, local.msyms),
	       VEC_length (bound_minimal_symbol_d, local.msyms),
	       sizeof (bound_minimal_symbol_d),
	       compare_msyms);

	/* Now the minsyms are in classification order.  So, we walk
	   over them and process just the minsyms with the same
	   classification as the very first minsym in the list.  */
	item = VEC_index (bound_minimal_symbol_d, local.msyms, 0);
	classification = classify_mtype (MSYMBOL_TYPE (item->minsym));

	for (ix = 0;
	     VEC_iterate (bound_minimal_symbol_d, local.msyms, ix, item);
	     ++ix)
	  {
	    if (classify_mtype (MSYMBOL_TYPE (item->minsym)) != classification)
	      break;

	    VEC_safe_push (bound_minimal_symbol_d,
			   info->result.minimal_symbols, item);
	  }
      }

    do_cleanups (cleanup);
  }
}

/* A helper function to add all symbols matching NAME to INFO.  If
   PSPACE is not NULL, the search is restricted to just that program
   space.  */

static void
add_matching_symbols_to_info (const char *name,
			      struct collect_info *info,
			      struct program_space *pspace)
{
  int ix;
  struct symtab *elt;

  for (ix = 0; VEC_iterate (symtab_ptr, info->file_symtabs, ix, elt); ++ix)
    {
      if (elt == NULL)
	{
	  iterate_over_all_matching_symtabs (info->state, name, VAR_DOMAIN,
					     collect_symbols, info,
					     pspace, 1);
	  search_minsyms_for_name (info, name, pspace);
	}
      else if (pspace == NULL || pspace == SYMTAB_PSPACE (elt))
	{
	  /* Program spaces that are executing startup should have
	     been filtered out earlier.  */
	  gdb_assert (!SYMTAB_PSPACE (elt)->executing_startup);
	  set_current_program_space (SYMTAB_PSPACE (elt));
	  iterate_over_file_blocks (elt, name, VAR_DOMAIN,
				    collect_symbols, info);
	}
    }
}



/* Now come some functions that are called from multiple places within
   decode_line_1.  */

static int
symbol_to_sal (struct symtab_and_line *result,
	       int funfirstline, struct symbol *sym)
{
  if (SYMBOL_CLASS (sym) == LOC_BLOCK)
    {
      *result = find_function_start_sal (sym, funfirstline);
      return 1;
    }
  else
    {
      if (SYMBOL_CLASS (sym) == LOC_LABEL && SYMBOL_VALUE_ADDRESS (sym) != 0)
	{
	  init_sal (result);
	  result->symtab = SYMBOL_SYMTAB (sym);
	  result->line = SYMBOL_LINE (sym);
	  result->pc = SYMBOL_VALUE_ADDRESS (sym);
	  result->pspace = SYMTAB_PSPACE (SYMBOL_SYMTAB (sym));
	  result->explicit_pc = 1;
	  return 1;
	}
      else if (funfirstline)
	{
	  /* Nothing.  */
	}
      else if (SYMBOL_LINE (sym) != 0)
	{
	  /* We know its line number.  */
	  init_sal (result);
	  result->symtab = SYMBOL_SYMTAB (sym);
	  result->line = SYMBOL_LINE (sym);
	  result->pspace = SYMTAB_PSPACE (SYMBOL_SYMTAB (sym));
	  return 1;
	}
    }

  return 0;
}

/* See the comment in linespec.h.  */

void
init_linespec_result (struct linespec_result *lr)
{
  memset (lr, 0, sizeof (*lr));
}

/* See the comment in linespec.h.  */

void
destroy_linespec_result (struct linespec_result *ls)
{
  int i;
  struct linespec_sals *lsal;

  xfree (ls->addr_string);
  for (i = 0; VEC_iterate (linespec_sals, ls->sals, i, lsal); ++i)
    {
      xfree (lsal->canonical);
      xfree (lsal->sals.sals);
    }
  VEC_free (linespec_sals, ls->sals);
}

/* Cleanup function for a linespec_result.  */

static void
cleanup_linespec_result (void *a)
{
  destroy_linespec_result (a);
}

/* See the comment in linespec.h.  */

struct cleanup *
make_cleanup_destroy_linespec_result (struct linespec_result *ls)
{
  return make_cleanup (cleanup_linespec_result, ls);
}
@


1.190
log
@(clh 9)
@
text
@d281 1
a281 1
    char *saved_arg;
d284 1
a284 1
    char **stream;
d323 1
a323 1
					     char **argptr);
d518 2
a519 2
static char *
find_parameter_list_end (char *input)
d523 1
a523 1
  char *p;
d560 1
a560 1
  char *start = PARSER_STREAM (parser);
d610 1
a610 1
      char *p;
d624 1
a624 1
	      p = skip_spaces (PARSER_STREAM (parser));
d684 1
a684 1
	      char *p;
d736 1
a736 1
      PARSER_STREAM (parser) = skip_spaces (PARSER_STREAM (parser));
d822 1
a822 1
  char *saved_stream = PARSER_STREAM (parser);
d2147 1
a2147 1
parse_linespec (linespec_parser *parser, char **argptr)
d2429 1
d2445 3
a2447 1
  result = parse_linespec (&parser, argptr);
d2502 1
d2509 3
a2511 1
  result = parse_linespec (&parser, argptr);
d2611 1
a2611 1
decode_objc (struct linespec_state *self, linespec_p ls, char **argptr)
d2616 1
a2616 1
  char *new_argptr;
d3062 1
a3062 1
  find_imps ((char *) name, &symbol_names);
@


1.189
log
@move gdbarch object from objfile to per-BFD

This moves the "gdbarch" field from the objfile into the BFD.

This field's value is derived from the BFD and is immutable over the
lifetime of the BFD.  This makes it a reasonable candidate for pushing
into the per-BFD object.

This is part of the long-term objfile splitting project.  In the long
run I think this patch will make it simpler to moves types from the
objfile to the per-BFD object; but the patch makes sense as a minor
cleanup by itself.

Built and regtested on x86-64 Fedora 18.

	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Use
	get_objfile_arch.
	* elfread.c (elf_rel_plt_read, elf_gnu_ifunc_record_cache)
	(elf_gnu_ifunc_resolve_by_got): Use get_objfile_arch.
	* jit.c (jit_object_close_impl): Update.
	* jv-lang.c (get_dynamics_objfile): Update.
	* linespec.c (add_minsym): Use get_dynamics_objfile.
	* objfiles.c (get_objfile_bfd_data): Initialize 'gdbarch' field.
	(allocate_objfile): Don't initialize 'gdbarch' field.
	(get_objfile_arch): Update.
	* objfiles.h (struct objfile_per_bfd_storage) <gdbarch>: New field,
	moved from...
	(struct objfile) <gdbarch>: ... here.  Remove.
	* stap-probe.c (stap_can_evaluate_probe_arguments): Use
	get_objfile_arch.
	* symfile.c (init_entry_point_info): Use get_objfile_arch.
@
text
@d64 1
a64 2
/* A helper struct which just holds a minimal symbol and the object
   file from which it came.  */
d66 1
a66 7
typedef struct minsym_and_objfile
{
  struct minimal_symbol *minsym;
  struct objfile *objfile;
} minsym_and_objfile_d;

DEF_VEC_O (minsym_and_objfile_d);
d128 1
a128 1
  VEC (minsym_and_objfile_d) *minimal_symbols;
d216 1
a216 1
    VEC (minsym_and_objfile_d) *minimal_symbols;
d336 1
a336 1
				   VEC (minsym_and_objfile_d) **minsyms);
d1583 1
a1583 1
  VEC (minsym_and_objfile_d) *minimal_symbols;
d2022 1
a2022 1
      minsym_and_objfile_d *elem;
d2047 3
a2049 3
	  qsort (VEC_address (minsym_and_objfile_d, ls->minimal_symbols),
		 VEC_length (minsym_and_objfile_d, ls->minimal_symbols),
		 sizeof (minsym_and_objfile_d), compare_msymbols);
d2052 2
a2053 1
	       VEC_iterate (minsym_and_objfile_d, ls->minimal_symbols, i, elem);
d2404 1
a2404 1
    VEC_free (minsym_and_objfile_d, PARSER_RESULT (parser)->minimal_symbols);
d2633 1
a2633 1
      || !VEC_empty (minsym_and_objfile_d, info.result.minimal_symbols))
d2791 2
a2792 2
  const struct minsym_and_objfile *sa = a;
  const struct minsym_and_objfile *sb = b;
d2869 1
a2869 1
	     VEC (minsym_and_objfile_d) **minsyms)
d2942 1
a2942 1
      || !VEC_empty (minsym_and_objfile_d, info.result.minimal_symbols))
d3043 1
a3043 1
		       VEC (minsym_and_objfile_d) **minsyms)
d3072 1
a3072 1
  if (VEC_empty (minsym_and_objfile_d, info.result.minimal_symbols))
d3074 1
a3074 1
      VEC_free (minsym_and_objfile_d, info.result.minimal_symbols);
d3089 1
a3089 1
		       VEC (minsym_and_objfile_d) **minsyms)
d3129 1
a3129 1
      && VEC_empty (minsym_and_objfile_d, *minsyms))
d3446 1
a3446 1
  VEC (minsym_and_objfile_d) *msyms;
d3478 2
a3479 2
  const minsym_and_objfile_d *moa = a;
  const minsym_and_objfile_d *mob = b;
d3493 1
a3493 1
  minsym_and_objfile_d mo;
d3520 1
a3520 1
  VEC_safe_push (minsym_and_objfile_d, info->msyms, &mo);
d3550 1
a3550 1
    cleanup = make_cleanup (VEC_cleanup (minsym_and_objfile_d),
d3559 1
a3559 1
    if (!VEC_empty (minsym_and_objfile_d, local.msyms))
d3563 1
a3563 1
	minsym_and_objfile_d *item;
d3565 3
a3567 3
	qsort (VEC_address (minsym_and_objfile_d, local.msyms),
	       VEC_length (minsym_and_objfile_d, local.msyms),
	       sizeof (minsym_and_objfile_d),
d3573 1
a3573 1
	item = VEC_index (minsym_and_objfile_d, local.msyms, 0);
d3577 1
a3577 1
	     VEC_iterate (minsym_and_objfile_d, local.msyms, ix, item);
d3583 1
a3583 1
	    VEC_safe_push (minsym_and_objfile_d,
@


1.188
log
@? .deps
? Makefile
? ada-exp.c
? ada-lex.c
? build-gnulib
? c-exp.c
? config.cache
? config.h
? config.log
? config.status
? cp-name-parser.c
? f-exp.c
? gcore
? gdb
? gdb-gdb.gdb
? go-exp.c
? init.c
? jit-reader.h
? jv-exp.c
? m2-exp.c
? observer.h
? observer.inc
? p-exp.c
? stamp-h
? stamp-xml
? version.c
? xml-builtin.c
? data-directory/Makefile
? data-directory/python
? data-directory/stamp-python
? data-directory/stamp-syscalls
? data-directory/stamp-system-gdbinit
? data-directory/syscalls
? data-directory/system-gdbinit
? doc/Makefile
? gdbserver/.deps
? gdbserver/Makefile
? gdbserver/build-gnulib-gdbserver
? gdbserver/config.cache
? gdbserver/config.h
? gdbserver/config.log
? gdbserver/config.status
? gdbserver/gdbreplay
? gdbserver/gdbserver
? gdbserver/i386-avx-linux.c
? gdbserver/i386-linux.c
? gdbserver/i386-mmx-linux.c
? gdbserver/stamp-h
? gdbserver/stamp-xml
? gdbserver/version.c
? gdbserver/xml-builtin.c
? testsuite/Makefile
? testsuite/config.log
? testsuite/config.status
? testsuite/gdb.log
? testsuite/gdb.sum
? testsuite/site.exp
? testsuite/gdb.ada/Makefile
? testsuite/gdb.arch/Makefile
? testsuite/gdb.asm/Makefile
? testsuite/gdb.base/Makefile
? testsuite/gdb.btrace/Makefile
? testsuite/gdb.cell/Makefile
? testsuite/gdb.cp/Makefile
? testsuite/gdb.disasm/Makefile
? testsuite/gdb.dwarf2/Makefile
? testsuite/gdb.fortran/Makefile
? testsuite/gdb.go/Makefile
? testsuite/gdb.hp/Makefile
? testsuite/gdb.hp/gdb.aCC/Makefile
? testsuite/gdb.hp/gdb.base-hp/Makefile
? testsuite/gdb.hp/gdb.compat/Makefile
? testsuite/gdb.hp/gdb.defects/Makefile
? testsuite/gdb.hp/gdb.objdbg/Makefile
? testsuite/gdb.java/Makefile
? testsuite/gdb.linespec/Makefile
? testsuite/gdb.mi/Makefile
? testsuite/gdb.modula2/Makefile
? testsuite/gdb.multi/Makefile
? testsuite/gdb.objc/Makefile
? testsuite/gdb.opencl/Makefile
? testsuite/gdb.opt/Makefile
? testsuite/gdb.pascal/Makefile
? testsuite/gdb.python/Makefile
? testsuite/gdb.reverse/Makefile
? testsuite/gdb.server/Makefile
? testsuite/gdb.stabs/Makefile
? testsuite/gdb.threads/Makefile
? testsuite/gdb.threads/threadapply
? testsuite/gdb.trace/Makefile
? testsuite/gdb.xml/Makefile

RCS file: /cvs/src/src/gdb/.dir-locals.el,v
Working file: .dir-locals.el
head: 1.2
branch:
locks: strict
access list:
symbolic names:
	gdb_7_6-2013-04-26-release: 1.2
	gdb_7_6-branch: 1.2.0.2
	gdb_7_6-2013-03-12-branchpoint: 1.2
	gdb_7_5_1-2012-11-29-release: 1.1
	gdb_7_5-2012-08-17-release: 1.1
	gdb_7_5-branch: 1.1.0.2
	gdb_7_5-2012-07-18-branchpoint: 1.1
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1.2
date: 2013/01/01 06:32:34;  author: brobecke;  state: Exp;  lines: +1 -1
Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
----------------------------
revision 1.1
date: 2012/03/28 17:35:38;  author: tromey;  state: Exp;
	* .dir-locals.el: New file.
=============================================================================

RCS file: /cvs/src/src/gdb/.gitignore,v
Working file: .gitignore
head: 1.5
branch:
locks: strict
access list:
symbolic names:
	gdb_7_6-2013-04-26-release: 1.4
	gdb_7_6-branch: 1.4.0.2
	gdb_7_6-2013-03-12-branchpoint: 1.4
	gdb_7_5_1-2012-11-29-release: 1.3
	gdb_7_5-2012-08-17-release: 1.3
	gdb_7_5-branch: 1.3.0.2
	gdb_7_5-2012-07-18-branchpoint: 1.3
	gdb_7_4_1-2012-04-26-release: 1.1
	gdb_7_4-2012-01-24-release: 1.1
	gdb_7_4-branch: 1.1.0.4
	gdb_7_4-2011-12-13-branchpoint: 1.1
	gdb_7_3_1-2011-09-04-release: 1.1
	gdb_7_3-2011-07-26-release: 1.1
	gdb_7_3-branch: 1.1.0.2
	gdb_7_3-2011-04-01-branchpoint: 1.1
keyword substitution: kv
total revisions: 5;	selected revisions: 5
description:
----------------------------
revision 1.5
date: 2013/06/17 04:39:15;  author: vapier;  state: Exp;  lines: +1 -0
gdb: ignore generated gcore
----------------------------
revision 1.4
date: 2012/08/13 15:43:59;  author: vapier;  state: Exp;  lines: +1 -0
gdb: ignore generated go-exp.c
----------------------------
revision 1.3
date: 2012/03/21 04:53:29;  author: vapier;  state: Exp;  lines: +2 -0
gdb: update gitignore
----------------------------
revision 1.2
date: 2012/01/02 02:28:56;  author: jkratoch;  state: Exp;  lines: +0 -1
gdb/
	Remove the gdbtui binary.
	* .gitignore (/gdbtui): Remove.
	* Makefile.in (TUI): Remove.
	(SUBDIR_TUI_OBS): Remove tui-main.o.
	(SUBDIR_TUI_SRCS): Remove tui/tui-main.c.
	(all-tui, install-tui, uninstall-tui, $(TUI)$(EXEEXT), clean-tui)
	(tui-main.o): Remove.
	(all_object_files): Remove tui-main.o.
	* NEWS: New note for the gdbtui removal.
	* configure: Rebuilt.
	* configure.ac: No longer add all-tui, clean-tui, install-tui and
	uninstall-tui to CONFIG_ALL, CONFIG_CLEAN, CONFIG_INSTALL and
	CONFIG_UNINSTALL respectively.
	* gdb.c (main): Remove args.interpreter_p initialization.
	* main.c (captured_main): Set INTERPRETER_P directly by INTERP_CONSOLE.
	* main.h (struct captured_main_args): Remove interpreter_p.
	* tui/tui-main.c: Remove.

gdb/doc/
	Remove the gdbtui binary.
	* all-cfg.texi (GDBTUI): Remove.
	* gdb.texinfo (Mode Options): Remove the GDBTUI reference.
	(TUI): Remove GDBTUI pindex.  Remove the GDBTUI reference.
	* gdbint.texinfo (Testsuite): Replace `gdbtui' by `gdb -tui'.
----------------------------
revision 1.1
date: 2011/03/29 18:21:32;  author: vapier;  state: Exp;
gdb: start a gitignore

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
=============================================================================

RCS file: /cvs/src/src/gdb/CONTRIBUTE,v
Working file: CONTRIBUTE
head: 1.13
branch:
locks: strict
access list:
symbolic names:
	gdb_7_6-2013-04-26-release: 1.13
	gdb_7_6-branch: 1.13.0.4
	gdb_7_6-2013-03-12-branchpoint: 1.13
	gdb_7_5_1-2012-11-29-release: 1.13
	gdb_7_5-2012-08-17-release: 1.13
	gdb_7_5-branch: 1.13.0.2
	gdb_7_5-2012-07-18-branchpoint: 1.13
	gdb_7_4_1-2012-04-26-release: 1.12
	gdb_7_4-2012-01-24-release: 1.12
	gdb_7_4-branch: 1.12.0.10
	gdb_7_4-2011-12-13-branchpoint: 1.12
	gdb_7_3_1-2011-09-04-release: 1.12
	gdb_7_3-2011-07-26-release: 1.12
	gdb_7_3-branch: 1.12.0.8
	gdb_7_3-2011-04-01-branchpoint: 1.12
	gdb_7_2-2010-09-02-release: 1.12
	gdb_7_2-branch: 1.12.0.6
	gdb_7_2-2010-07-07-branchpoint: 1.12
	gdb_7_1-2010-03-18-release: 1.12
	gdb_7_1-branch: 1.12.0.4
	gdb_7_1-2010-02-18-branchpoint: 1.12
	gdb_7_0_1-2009-12-22-release: 1.12
	gdb_7_0-2009-10-06-release: 1.12
	gdb_7_0-branch: 1.12.0.2
	gdb_7_0-2009-09-16-branchpoint: 1.12
	arc-sim-20090309: 1.9
	msnyder-checkpoint-072509-branch: 1.11.0.2
	msnyder-checkpoint-072509-branchpoint: 1.11
	arc-insight_6_8-branch: 1.9.0.16
	arc-insight_6_8-branchpoint: 1.9
	insight_6_8-branch: 1.9.0.14
	insight_6_8-branchpoint: 1.9
	reverse-20081226-branch: 1.10.0.4
	reverse-20081226-branchpoint: 1.10
	multiprocess-20081120-branch: 1.10.0.2
	multiprocess-20081120-branchpoint: 1.10
	reverse-20080930-branch: 1.9.0.12
	reverse-20080930-branchpoint: 1.9
	reverse-20080717-branch: 1.9.0.10
	reverse-20080717-branchpoint: 1.9
	msnyder-reverse-20080609-branch: 1.9.0.8
	msnyder-reverse-20080609-branchpoint: 1.9
	drow-reverse-20070409-branch: 1.9.0.6
	drow-reverse-20070409-branchpoint: 1.9
	gdb_6_8-2008-03-27-release: 1.9
	gdb_6_8-branch: 1.9.0.4
	gdb_6_8-2008-02-26-branchpoint: 1.9
	gdb_6_7_1-2007-10-29-release: 1.9
	gdb_6_7-2007-10-10-release: 1.9
	gdb_6_7-branch: 1.9.0.2
	gdb_6_7-2007-09-07-branchpoint: 1.9
	insight_6_6-20070208-release: 1.8
	gdb_6_6-2006-12-18-release: 1.8
	gdb_6_6-branch: 1.8.0.106
	gdb_6_6-2006-11-15-branchpoint: 1.8
	insight_6_5-20061003-release: 1.8
	gdb-csl-symbian-6_4_50_20060226-12: 1.8
	gdb-csl-sourcerygxx-3_4_4-25: 1.8
	nickrob-async-20060828-mergepoint: 1.8
	gdb-csl-symbian-6_4_50_20060226-11: 1.8
	gdb-csl-sourcerygxx-4_1-17: 1.8
	gdb-csl-20060226-branch-local-2: 1.8
	gdb-csl-sourcerygxx-4_1-14: 1.8
	gdb-csl-sourcerygxx-4_1-13: 1.8
	gdb-csl-sourcerygxx-4_1-12: 1.8
	gdb-csl-sourcerygxx-3_4_4-21: 1.8
	gdb_6_5-20060621-release: 1.8
	gdb-csl-sourcerygxx-4_1-9: 1.8
	gdb-csl-sourcerygxx-4_1-8: 1.8
	gdb-csl-sourcerygxx-4_1-7: 1.8
	gdb-csl-arm-2006q1-6: 1.8
	gdb-csl-sourcerygxx-4_1-6: 1.8
	gdb-csl-symbian-6_4_50_20060226-10: 1.8
	gdb-csl-symbian-6_4_50_20060226-9: 1.8
	gdb-csl-symbian-6_4_50_20060226-8: 1.8
	gdb-csl-coldfire-4_1-11: 1.8
	gdb-csl-sourcerygxx-3_4_4-19: 1.8
	gdb-csl-coldfire-4_1-10: 1.8
	gdb_6_5-branch: 1.8.0.104
	gdb_6_5-2006-05-14-branchpoint: 1.8
	gdb-csl-sourcerygxx-4_1-5: 1.8
	nickrob-async-20060513-branch: 1.8.0.102
	nickrob-async-20060513-branchpoint: 1.8
	gdb-csl-sourcerygxx-4_1-4: 1.8
	msnyder-reverse-20060502-branch: 1.8.0.100
	msnyder-reverse-20060502-branchpoint: 1.8
	gdb-csl-morpho-4_1-4: 1.8
	gdb-csl-sourcerygxx-3_4_4-17: 1.8
	readline_5_1-import-branch: 1.8.0.98
	readline_5_1-import-branchpoint: 1.8
	gdb-csl-20060226-branch-merge-to-csl-symbian-1: 1.8
	gdb-csl-symbian-20060226-branch: 1.8.0.96
	gdb-csl-symbian-20060226-branchpoint: 1.8
	gdb-csl-20060226-branch-merge-to-csl-local-1: 1.8
	msnyder-reverse-20060331-branch: 1.8.0.94
	msnyder-reverse-20060331-branchpoint: 1.8
	gdb-csl-available-20060303-branch: 1.8.0.92
	gdb-csl-available-20060303-branchpoint: 1.8
	gdb-csl-20060226-branch: 1.8.0.90
	gdb-csl-20060226-branchpoint: 1.8
	gdb_6_4-20051202-release: 1.8
	msnyder-fork-checkpoint-branch: 1.8.0.88
	msnyder-fork-checkpoint-branchpoint: 1.8
	gdb-csl-gxxpro-6_3-branch: 1.8.0.86
	gdb-csl-gxxpro-6_3-branchpoint: 1.8
	gdb_6_4-branch: 1.8.0.84
	gdb_6_4-2005-11-01-branchpoint: 1.8
	gdb-csl-arm-20051020-branch: 1.8.0.82
	gdb-csl-arm-20051020-branchpoint: 1.8
	msnyder-tracepoint-checkpoint-branch: 1.8.0.80
	msnyder-tracepoint-checkpoint-branchpoint: 1.8
	gdb-csl-arm-20050325-2005-q1b: 1.8
	gdb-csl-arm-20050325-2005-q1a: 1.8
	csl-arm-20050325-branch: 1.8.0.78
	csl-arm-20050325-branchpoint: 1.8
	gdb-post-i18n-errorwarning-20050211: 1.8
	gdb-pre-i18n-errorwarning-20050211: 1.8
	gdb_6_3-20041109-release: 1.8
	gdb_6_3-branch: 1.8.0.74
	gdb_6_3-20041019-branchpoint: 1.8
	drow_intercu-merge-20040921: 1.8
	drow_intercu-merge-20040915: 1.8
	jimb-gdb_6_2-e500-branch: 1.8.0.76
	jimb-gdb_6_2-e500-branchpoint: 1.8
	gdb_6_2-20040730-release: 1.8
	gdb_6_2-branch: 1.8.0.72
	gdb_6_2-2004-07-10-gmt-branchpoint: 1.8
	gdb_6_1_1-20040616-release: 1.8
	gdb_6_1-2004-04-05-release: 1.8
	drow_intercu-merge-20040402: 1.8
	drow_intercu-merge-20040327: 1.8
	ezannoni_pie-20040323-branch: 1.8.0.70
	ezannoni_pie-20040323-branchpoint: 1.8
	cagney_tramp-20040321-mergepoint: 1.8
	cagney_tramp-20040309-branch: 1.8.0.68
	cagney_tramp-20040309-branchpoint: 1.8
	gdb_6_1-branch: 1.8.0.66
	gdb_6_1-2004-03-01-gmt-branchpoint: 1.8
	drow_intercu-20040221-branch: 1.8.0.64
	drow_intercu-20040221-branchpoint: 1.8
	cagney_bfdfile-20040213-branch: 1.8.0.62
	cagney_bfdfile-20040213-branchpoint: 1.8
	drow-cplus-merge-20040208: 1.8
	carlton_dictionary-20040126-merge: 1.8
	cagney_bigcore-20040122-branch: 1.8.0.60
	cagney_bigcore-20040122-branchpoint: 1.8
	drow-cplus-merge-20040113: 1.8
	drow-cplus-merge-20031224: 1.8
	drow-cplus-merge-20031220: 1.8
	carlton_dictionary-20031215-merge: 1.8
	drow-cplus-merge-20031214: 1.8
	carlton-dictionary-20031111-merge: 1.8
	gdb_6_0-2003-10-04-release: 1.8
	kettenis_sparc-20030918-branch: 1.8.0.58
	kettenis_sparc-20030918-branchpoint: 1.8
	carlton_dictionary-20030917-merge: 1.8
	ezannoni_pie-20030916-branchpoint: 1.8
	ezannoni_pie-20030916-branch: 1.8.0.56
	cagney_x86i386-20030821-branch: 1.8.0.54
	cagney_x86i386-20030821-branchpoint: 1.8
	carlton_dictionary-20030805-merge: 1.8
	carlton_dictionary-20030627-merge: 1.8
	gdb_6_0-branch: 1.8.0.52
	gdb_6_0-2003-06-23-branchpoint: 1.8
	jimb-ppc64-linux-20030613-branch: 1.8.0.50
	jimb-ppc64-linux-20030613-branchpoint: 1.8
	cagney_convert-20030606-branch: 1.8.0.48
	cagney_convert-20030606-branchpoint: 1.8
	cagney_writestrings-20030508-branch: 1.8.0.46
	cagney_writestrings-20030508-branchpoint: 1.8
	jimb-ppc64-linux-20030528-branch: 1.8.0.44
	jimb-ppc64-linux-20030528-branchpoint: 1.8
	carlton_dictionary-20030523-merge: 1.8
	cagney_fileio-20030521-branch: 1.8.0.42
	cagney_fileio-20030521-branchpoint: 1.8
	kettenis_i386newframe-20030517-mergepoint: 1.8
	jimb-ppc64-linux-20030509-branch: 1.8.0.40
	jimb-ppc64-linux-20030509-branchpoint: 1.8
	kettenis_i386newframe-20030504-mergepoint: 1.8
	carlton_dictionary-20030430-merge: 1.8
	kettenis_i386newframe-20030419-branch: 1.8.0.38
	kettenis_i386newframe-20030419-branchpoint: 1.8
	carlton_dictionary-20030416-merge: 1.8
	cagney_frameaddr-20030409-mergepoint: 1.8
	kettenis_i386newframe-20030406-branch: 1.8.0.36
	kettenis_i386newframe-20030406-branchpoint: 1.8
	cagney_frameaddr-20030403-branchpoint: 1.8
	cagney_frameaddr-20030403-branch: 1.8.0.34
	cagney_framebase-20030330-mergepoint: 1.8
	cagney_framebase-20030326-branch: 1.8.0.32
	cagney_framebase-20030326-branchpoint: 1.8
	cagney_lazyid-20030317-branch: 1.8.0.30
	cagney_lazyid-20030317-branchpoint: 1.8
	kettenis-i386newframe-20030316-mergepoint: 1.8
	offbyone-20030313-branch: 1.8.0.28
	offbyone-20030313-branchpoint: 1.8
	kettenis-i386newframe-20030308-branch: 1.8.0.26
	kettenis-i386newframe-20030308-branchpoint: 1.8
	carlton_dictionary-20030305-merge: 1.8
	cagney_offbyone-20030303-branch: 1.8.0.24
	cagney_offbyone-20030303-branchpoint: 1.8
	carlton_dictionary-20030207-merge: 1.8
	interps-20030203-mergepoint: 1.8
	interps-20030202-branch: 1.8.0.22
	interps-20030202-branchpoint: 1.8
	cagney-unwind-20030108-branch: 1.8.0.20
	cagney-unwind-20030108-branchpoint: 1.8
	carlton_dictionary-20021223-merge: 1.8
	gdb_5_3-2002-12-12-release: 1.8
	carlton_dictionary-20021115-merge: 1.8
	kseitz_interps-20021105-merge: 1.8
	kseitz_interps-20021103-merge: 1.8
	drow-cplus-merge-20021020: 1.8
	drow-cplus-merge-20021025: 1.8
	carlton_dictionary-20021025-merge: 1.8
	carlton_dictionary-20021011-merge: 1.8
	drow-cplus-branch: 1.8.0.18
	drow-cplus-branchpoint: 1.8
	kseitz_interps-20020930-merge: 1.8
	carlton_dictionary-20020927-merge: 1.8
	carlton_dictionary-branch: 1.8.0.16
	carlton_dictionary-20020920-branchpoint: 1.8
	gdb_5_3-branch: 1.8.0.14
	gdb_5_3-2002-09-04-branchpoint: 1.8
	kseitz_interps-20020829-merge: 1.8
	cagney_sysregs-20020825-branch: 1.8.0.12
	cagney_sysregs-20020825-branchpoint: 1.8
	readline_4_3-import-branch: 1.8.0.10
	readline_4_3-import-branchpoint: 1.8
	gdb_5_2_1-2002-07-23-release: 1.8
	kseitz_interps-20020528-branch: 1.8.0.8
	kseitz_interps-20020528-branchpoint: 1.8
	cagney_regbuf-20020515-branch: 1.8.0.6
	cagney_regbuf-20020515-branchpoint: 1.8
	jimb-macro-020506-branch: 1.8.0.4
	jimb-macro-020506-branchpoint: 1.8
	gdb_5_2-2002-04-29-release: 1.8
	gdb_5_2-branch: 1.8.0.2
	gdb_5_2-2002-03-03-branchpoint: 1.8
	gdb_5_1_1-2002-01-24-release: 1.5.4.1
	gdb_5_1_0_1-2002-01-03-release: 1.5.4.1
	cygnus_cvs_20020108_pre: 1.6
	gdb_5_1_0_1-2002-01-03-branchpoint: 1.5.4.1
	gdb_5_1_0_1-2002-01-03-branch: 1.5.4.1.0.4
	gdb_5_1-2001-11-21-release: 1.5.4.1
	gdb_s390-2001-09-26-branch: 1.5.4.1.0.2
	gdb_s390-2001-09-26-branchpoint: 1.5.4.1
	gdb_5_1-2001-07-29-branch: 1.5.0.4
	gdb_5_1-2001-07-29-branchpoint: 1.5
	dberlin-typesystem-branch: 1.5.0.2
	dberlin-typesystem-branchpoint: 1.5
	gdb-post-ptid_t-2001-05-03: 1.5
	gdb-pre-ptid_t-2001-05-03: 1.5
	insight-precleanup-2001-01-01: 1.2
	gdb-post-protoization-2000-07-29: 1.2
	gdb-pre-protoization-2000-07-29: 1.2
	gdb-premipsmulti-2000-06-06-branch: 1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint: 1.2
	gdb-post-params-removal-2000-06-04: 1.2
	gdb-pre-params-removal-2000-06-04: 1.2
	gdb-post-params-removal-2000-05-28: 1.2
	gdb-pre-params-removal-2000-05-28: 1.2
	gdb_5_0-2000-05-19-release: 1.2
	gdb_4_18_2-2000-05-18-release: 1.2
	gdb_4_95_1-2000-05-11-snapshot: 1.2
	gdb_4_95_0-2000-04-27-snapshot: 1.2
	gdb_5_0-2000-04-10-branch: 1.2.0.2
	gdb_5_0-2000-04-10-branchpoint: 1.2
keyword substitution: kv
total revisions: 14;	selected revisions: 14
description:
----------------------------
revision 1.13
date: 2012/04/25 07:08:07;  author: sivachandra;  state: Exp;  lines: +3 -3
2012-04-25  Siva Chandra Reddy  <sivachandra@@google.com>

	* CONTRIBUTE: Use unified diff instead of context diff when
	generating patches.
----------------------------
revision 1.12
date: 2009/08/22 17:08:09;  author: rwild;  state: Exp;  lines: +1 -1
Cleanups after the update to Autoconf 2.64, Automake 1.11.

/:
	* README-maintainer-mode: Point directly to upstream locations
	for autoconf, automake, libtool, gettext, instead of copies on
	sources.redhat.com.  Document required versions.
	* configure.ac: Do not substitute datarootdir, htmldir,
	pdfdir, docdir.  Do not process --with-datarootdir,
	--with-htmldir, --with-pdfdir, --with-docdir.
	* configure: Regenerate.

gdb/:
	* CONTRIBUTE: Bump documented Autoconf version.
	* configure.ac: Do not substitute datarootdir, htmldir,
	pdfdir, docdir.  Do not process --with-datarootdir,
	--with-htmldir, --with-pdfdir, --with-docdir.
	* configure: Regenerate.

gdb/doc/:
	* gdbint.texinfo (Releasing GDB): Point to
	README-maintainer-mode file for required autoconf version.
	* configure.ac: Do not substitute datarootdir, htmldir,
	pdfdir, docdir.  Do not process --with-datarootdir,
	--with-htmldir, --with-pdfdir, --with-docdir.
	* configure: Regenerate.

gprof/:
	* Makefile.am (pdf__strip_dir, install-pdf, install-pdf-am)
	(install-pdf-recursive, html__strip_dir, install-html)
	(install-html-am, install-html-recursive): Remove.
	* Makefile.in: Regenerate.

opcodes/:
	* Makefile.am (install-pdf, install-html): Remove.
	* Makefile.in: Regenerate.

gas/:
	* Makefile.am (install-pdf, install-pdf-recursive, install-html)
	(install-html-recursive): Remove.
	* Makefile.in: Regenerate.
	* doc/Makefile.am (pdf__strip_dir, install-pdf, install-pdf-am)
	(html__strip_dir, install-html, install-html-am): Remove.
	* doc/Makefile.in: Regenerate.

ld/:
	* Makefile.am (pdf__strip_dir, install-pdf, install-pdf-am)
	(install-pdf-recursive, html__strip_dir, install-html)
	(install-html-am, install-html-recursive): Remove.
	* Makefile.in: Regenerate.

binutils/:
	* Makefile.am (install-pdf, install-pdf-recursive, install-html)
	(install-html-recursive): Remove.
	* Makefile.in: Regenerate.
	* doc/Makefile.am (pdf__strip_dir, install-pdf, install-pdf-am)
	(html__strip_dir, install-html, install-html-am): Remove.
	* doc/Makefile.in: Regenerate.

bfd/:
	* Makefile.am (datarootdir, docdir, htmldor, pdfdir)
	(install-pdf, install-pdf-recursive, install-html)
	(install-html-recursive): Remove.
	* Makefile.in: Regenerate.

bfd/doc/:
	* Makefile.am (pdf__strip_dir, install-pdf, install-pdf-am)
	(html__strip_dir, install-html, install-html-am): Remove.
	* Makefile.in: Regenerate.
----------------------------
revision 1.11
date: 2009/01/09 04:46:22;  author: brobecke;  state: Exp;  lines: +2 -1
        * CONTRIBUTE: Minor reformatting.
----------------------------
revision 1.10
date: 2008/10/27 17:41:57;  author: palves;  state: Exp;  lines: +3 -3
	* CONTRIBUTE: Mention autoconf 2.59 and configure.ac instead of
	2.13 and configure.in.
----------------------------
revision 1.9
date: 2007/01/04 20:28:38;  author: drow;  state: Exp;  lines: +1 -1
	* CONTRIBUTE: Use sourceware.org.
----------------------------
revision 1.8
date: 2002/02/23 20:36:48;  author: cagney;  state: Exp;  lines: +1 -1
From 2002-02-19 Paul Eggert <eggert@@twinsun.com>:
* Makefile.in (VER): Change "head -1" to "sed q", since POSIX
1003.1-2001 no longer allows "head -1".
* gdb/Makefile.in (version.c): Likewise.
* gdb/doc/Makefile.in (GDBvn.texi): Likewise.
* gdb/CONTRIBUTE: Change "diff -c3" to "diff -c", which is
equivalent.  POSIX 1003.1-2001 no longer allows "diff -c3".
----------------------------
revision 1.7
date: 2002/01/13 16:16:58;  author: cagney;  state: Exp;  lines: +1 -1
From 2002-01-09 John Marshall <johnm@@falch.net>:
* CONTRIBUTE, README, TODO: Change sourceware.cygnus.com to
sources.redhat.com, and tweak some related URLs which had
suffered from linkrot.
----------------------------
revision 1.6
date: 2001/09/26 20:52:56;  author: cagney;  state: Exp;  lines: +19 -49
* CONTRIBUTE: Update.
----------------------------
revision 1.5
date: 2001/03/03 03:23:50;  author: cagney;  state: Exp;  lines: +6 -2
branches:  1.5.4;
Change convention to ``Fix PR gdb/NNNN''
----------------------------
revision 1.4
date: 2001/02/23 22:20:38;  author: cagney;  state: Exp;  lines: +9 -0
Mention how to cite GDB problem reports.
----------------------------
revision 1.3
date: 2001/02/23 22:09:30;  author: cagney;  state: Exp;  lines: +7 -0
Mention gdbarch.sh and to not submit gdbarch.[ch].
----------------------------
revision 1.2
date: 2000/03/01 08:33:47;  author: cagney;  state: Exp;  lines: +7 -0
Note that there is no need to send configure.in patches.
----------------------------
revision 1.1
date: 2000/02/13 00:22:01;  author: cagney;  state: Exp;
Explain how to contribute to GDB.
----------------------------
revision 1.5.4.1
date: 2001/09/26 20:53:27;  author: cagney;  state: Exp;  lines: +19 -49
* CONTRIBUTE: Update.
=============================================================================

RCS file: /cvs/src/src/gdb/COPYING,v
Working file: COPYING
head: 1.3
branch:
locks: strict
access list:
symbolic names:
	gdb_7_6-2013-04-26-release: 1.3
	gdb_7_6-branch: 1.3.0.12
	gdb_7_6-2013-03-12-branchpoint: 1.3
	gdb_7_5_1-2012-11-29-release: 1.3
	gdb_7_5-2012-08-17-release: 1.3
	gdb_7_5-branch: 1.3.0.10
	gdb_7_5-2012-07-18-branchpoint: 1.3
	gdb_7_4_1-2012-04-26-release: 1.3
	gdb_7_4-2012-01-24-release: 1.3
	gdb_7_4-branch: 1.3.0.8
	gdb_7_4-2011-12-13-branchpoint: 1.3
	gdb_7_3_1-2011-09-04-release: 1.3
	gdb_7_3-2011-07-26-release: 1.3
	gdb_7_3-branch: 1.3.0.6
	gdb_7_3-2011-04-01-branchpoint: 1.3
	gdb_7_2-2010-09-02-release: 1.3
	gdb_7_2-branch: 1.3.0.4
	gdb_7_2-2010-07-07-branchpoint: 1.3
	gdb_7_1-2010-03-18-release: 1.3
	gdb_7_1-branch: 1.3.0.2
	gdb_7_1-2010-02-18-branchpoint: 1.3
	gdb_7_0_1-2009-12-22-release: 1.2.42.1
	gdb_7_0-2009-10-06-release: 1.2
	gdb_7_0-branch: 1.2.0.42
	gdb_7_0-2009-09-16-branchpoint: 1.2
	arc-sim-20090309: 1.2
	msnyder-checkpoint-072509-branch: 1.2.0.40
	msnyder-checkpoint-072509-branchpoint: 1.2
	arc-insight_6_8-branch: 1.2.0.38
	arc-insight_6_8-branchpoint: 1.2
	insight_6_8-branch: 1.2.0.36
	insight_6_8-branchpoint: 1.2
	reverse-20081226-branch: 1.2.0.34
	reverse-20081226-branchpoint: 1.2
	multiprocess-20081120-branch: 1.2.0.32
	multiprocess-20081120-branchpoint: 1.2
	reverse-20080930-branch: 1.2.0.30
	reverse-20080930-branchpoint: 1.2
	reverse-20080717-branch: 1.2.0.28
	reverse-20080717-branchpoint: 1.2
	msnyder-reverse-20080609-branch: 1.2.0.26
	msnyder-reverse-20080609-branchpoint: 1.2
	drow-reverse-20070409-branch: 1.2.0.24
	drow-reverse-20070409-branchpoint: 1.2
	gdb_6_8-2008-03-27-release: 1.2
	gdb_6_8-branch: 1.2.0.22
	gdb_6_8-2008-02-26-branchpoint: 1.2
	gdb_6_7_1-2007-10-29-release: 1.2
	gdb_6_7-2007-10-10-release: 1.2
	gdb_6_7-branch: 1.2.0.20
	gdb_6_7-2007-09-07-branchpoint: 1.2
	insight_6_6-20070208-release: 1.2
	gdb_6_6-2006-12-18-release: 1.2
	gdb_6_6-branch: 1.2.0.18
	gdb_6_6-2006-11-15-branchpoint: 1.2
	insight_6_5-20061003-release: 1.2
	gdb-csl-symbian-6_4_50_20060226-12: 1.2
	gdb-csl-sourcerygxx-3_4_4-25: 1.1.1.1
	nickrob-async-20060828-mergepoint: 1.2
	gdb-csl-symbian-6_4_50_20060226-11: 1.2
	gdb-csl-sourcerygxx-4_1-17: 1.2
	gdb-csl-20060226-branch-local-2: 1.2
	gdb-csl-sourcerygxx-4_1-14: 1.2
	gdb-csl-sourcerygxx-4_1-13: 1.2
	gdb-csl-sourcerygxx-4_1-12: 1.2
	gdb-csl-sourcerygxx-3_4_4-21: 1.2
	gdb_6_5-20060621-release: 1.2
	gdb-csl-sourcerygxx-4_1-9: 1.2
	gdb-csl-sourcerygxx-4_1-8: 1.2
	gdb-csl-sourcerygxx-4_1-7: 1.2
	gdb-csl-arm-2006q1-6: 1.2
	gdb-csl-sourcerygxx-4_1-6: 1.2
	gdb-csl-symbian-6_4_50_20060226-10: 1.2
	gdb-csl-symbian-6_4_50_20060226-9: 1.2
	gdb-csl-symbian-6_4_50_20060226-8: 1.2
	gdb-csl-coldfire-4_1-11: 1.2
	gdb-csl-sourcerygxx-3_4_4-19: 1.2
	gdb-csl-coldfire-4_1-10: 1.2
	gdb_6_5-branch: 1.2.0.16
	gdb_6_5-2006-05-14-branchpoint: 1.2
	gdb-csl-sourcerygxx-4_1-5: 1.2
	nickrob-async-20060513-branch: 1.2.0.14
	nickrob-async-20060513-branchpoint: 1.2
	gdb-csl-sourcerygxx-4_1-4: 1.2
	msnyder-reverse-20060502-branch: 1.2.0.12
	msnyder-reverse-20060502-branchpoint: 1.2
	gdb-csl-morpho-4_1-4: 1.2
	gdb-csl-sourcerygxx-3_4_4-17: 1.2
	readline_5_1-import-branch: 1.2.0.10
	readline_5_1-import-branchpoint: 1.2
	gdb-csl-20060226-branch-merge-to-csl-symbian-1: 1.2
	gdb-csl-symbian-20060226-branch: 1.2.0.8
	gdb-csl-symbian-20060226-branchpoint: 1.2
	gdb-csl-20060226-branch-merge-to-csl-local-1: 1.2
	msnyder-reverse-20060331-branch: 1.2.0.6
	msnyder-reverse-20060331-branchpoint: 1.2
	gdb-csl-available-20060303-branch: 1.2.0.4
	gdb-csl-available-20060303-branchpoint: 1.2
	gdb-csl-20060226-branch: 1.2.0.2
	gdb-csl-20060226-branchpoint: 1.2
	gdb_6_4-20051202-release: 1.1.1.1
	msnyder-fork-checkpoint-branch: 1.1.1.1.0.102
	msnyder-fork-checkpoint-branchpoint: 1.1.1.1
	gdb-csl-gxxpro-6_3-branch: 1.1.1.1.0.100
	gdb-csl-gxxpro-6_3-branchpoint: 1.1.1.1
	gdb_6_4-branch: 1.1.1.1.0.98
	gdb_6_4-2005-11-01-branchpoint: 1.1.1.1
	gdb-csl-arm-20051020-branch: 1.1.1.1.0.96
	gdb-csl-arm-20051020-branchpoint: 1.1.1.1
	msnyder-tracepoint-checkpoint-branch: 1.1.1.1.0.94
	msnyder-tracepoint-checkpoint-branchpoint: 1.1.1.1
	gdb-csl-arm-20050325-2005-q1b: 1.1.1.1
	gdb-csl-arm-20050325-2005-q1a: 1.1.1.1
	csl-arm-20050325-branch: 1.1.1.1.0.92
	csl-arm-20050325-branchpoint: 1.1.1.1
	gdb-post-i18n-errorwarning-20050211: 1.1.1.1
	gdb-pre-i18n-errorwarning-20050211: 1.1.1.1
	gdb_6_3-20041109-release: 1.1.1.1
	gdb_6_3-branch: 1.1.1.1.0.88
	gdb_6_3-20041019-branchpoint: 1.1.1.1
	drow_intercu-merge-20040921: 1.1.1.1
	drow_intercu-merge-20040915: 1.1.1.1
	jimb-gdb_6_2-e500-branch: 1.1.1.1.0.90
	jimb-gdb_6_2-e500-branchpoint: 1.1.1.1
	gdb_6_2-20040730-release: 1.1.1.1
	gdb_6_2-branch: 1.1.1.1.0.86
	gdb_6_2-2004-07-10-gmt-branchpoint: 1.1.1.1
	gdb_6_1_1-20040616-release: 1.1.1.1
	gdb_6_1-2004-04-05-release: 1.1.1.1
	drow_intercu-merge-20040402: 1.1.1.1
	drow_intercu-merge-20040327: 1.1.1.1
	ezannoni_pie-20040323-branch: 1.1.1.1.0.84
	ezannoni_pie-20040323-branchpoint: 1.1.1.1
	cagney_tramp-20040321-mergepoint: 1.1.1.1
	cagney_tramp-20040309-branch: 1.1.1.1.0.82
	cagney_tramp-20040309-branchpoint: 1.1.1.1
	gdb_6_1-branch: 1.1.1.1.0.80
	gdb_6_1-2004-03-01-gmt-branchpoint: 1.1.1.1
	drow_intercu-20040221-branch: 1.1.1.1.0.78
	drow_intercu-20040221-branchpoint: 1.1.1.1
	cagney_bfdfile-20040213-branch: 1.1.1.1.0.76
	cagney_bfdfile-20040213-branchpoint: 1.1.1.1
	drow-cplus-merge-20040208: 1.1.1.1
	carlton_dictionary-20040126-merge: 1.1.1.1
	cagney_bigcore-20040122-branch: 1.1.1.1.0.74
	cagney_bigcore-20040122-branchpoint: 1.1.1.1
	drow-cplus-merge-20040113: 1.1.1.1
	drow-cplus-merge-20031224: 1.1.1.1
	drow-cplus-merge-20031220: 1.1.1.1
	carlton_dictionary-20031215-merge: 1.1.1.1
	drow-cplus-merge-20031214: 1.1.1.1
	carlton-dictionary-20031111-merge: 1.1.1.1
	gdb_6_0-2003-10-04-release: 1.1.1.1
	kettenis_sparc-20030918-branch: 1.1.1.1.0.72
	kettenis_sparc-20030918-branchpoint: 1.1.1.1
	carlton_dictionary-20030917-merge: 1.1.1.1
	ezannoni_pie-20030916-branchpoint: 1.1.1.1
	ezannoni_pie-20030916-branch: 1.1.1.1.0.70
	cagney_x86i386-20030821-branch: 1.1.1.1.0.68
	cagney_x86i386-20030821-branchpoint: 1.1.1.1
	carlton_dictionary-20030805-merge: 1.1.1.1
	carlton_dictionary-20030627-merge: 1.1.1.1
	gdb_6_0-branch: 1.1.1.1.0.66
	gdb_6_0-2003-06-23-branchpoint: 1.1.1.1
	jimb-ppc64-linux-20030613-branch: 1.1.1.1.0.64
	jimb-ppc64-linux-20030613-branchpoint: 1.1.1.1
	cagney_convert-20030606-branch: 1.1.1.1.0.62
	cagney_convert-20030606-branchpoint: 1.1.1.1
	cagney_writestrings-20030508-branch: 1.1.1.1.0.60
	cagney_writestrings-20030508-branchpoint: 1.1.1.1
	jimb-ppc64-linux-20030528-branch: 1.1.1.1.0.58
	jimb-ppc64-linux-20030528-branchpoint: 1.1.1.1
	carlton_dictionary-20030523-merge: 1.1.1.1
	cagney_fileio-20030521-branch: 1.1.1.1.0.56
	cagney_fileio-20030521-branchpoint: 1.1.1.1
	kettenis_i386newframe-20030517-mergepoint: 1.1.1.1
	jimb-ppc64-linux-20030509-branch: 1.1.1.1.0.54
	jimb-ppc64-linux-20030509-branchpoint: 1.1.1.1
	kettenis_i386newframe-20030504-mergepoint: 1.1.1.1
	carlton_dictionary-20030430-merge: 1.1.1.1
	kettenis_i386newframe-20030419-branch: 1.1.1.1.0.52
	kettenis_i386newframe-20030419-branchpoint: 1.1.1.1
	carlton_dictionary-20030416-merge: 1.1.1.1
	cagney_frameaddr-20030409-mergepoint: 1.1.1.1
	kettenis_i386newframe-20030406-branch: 1.1.1.1.0.50
	kettenis_i386newframe-20030406-branchpoint: 1.1.1.1
	cagney_frameaddr-20030403-branchpoint: 1.1.1.1
	cagney_frameaddr-20030403-branch: 1.1.1.1.0.48
	cagney_framebase-20030330-mergepoint: 1.1.1.1
	cagney_framebase-20030326-branch: 1.1.1.1.0.46
	cagney_framebase-20030326-branchpoint: 1.1.1.1
	cagney_lazyid-20030317-branch: 1.1.1.1.0.44
	cagney_lazyid-20030317-branchpoint: 1.1.1.1
	kettenis-i386newframe-20030316-mergepoint: 1.1.1.1
	offbyone-20030313-branch: 1.1.1.1.0.42
	offbyone-20030313-branchpoint: 1.1.1.1
	kettenis-i386newframe-20030308-branch: 1.1.1.1.0.40
	kettenis-i386newframe-20030308-branchpoint: 1.1.1.1
	carlton_dictionary-20030305-merge: 1.1.1.1
	cagney_offbyone-20030303-branch: 1.1.1.1.0.38
	cagney_offbyone-20030303-branchpoint: 1.1.1.1
	carlton_dictionary-20030207-merge: 1.1.1.1
	interps-20030203-mergepoint: 1.1.1.1
	interps-20030202-branch: 1.1.1.1.0.36
	interps-20030202-branchpoint: 1.1.1.1
	cagney-unwind-20030108-branch: 1.1.1.1.0.34
	cagney-unwind-20030108-branchpoint: 1.1.1.1
	carlton_dictionary-20021223-merge: 1.1.1.1
	gdb_5_3-2002-12-12-release: 1.1.1.1
	carlton_dictionary-20021115-merge: 1.1.1.1
	kseitz_interps-20021105-merge: 1.1.1.1
	kseitz_interps-20021103-merge: 1.1.1.1
	drow-cplus-merge-20021020: 1.1.1.1
	drow-cplus-merge-20021025: 1.1.1.1
	carlton_dictionary-20021025-merge: 1.1.1.1
	carlton_dictionary-20021011-merge: 1.1.1.1
	drow-cplus-branch: 1.1.1.1.0.32
	drow-cplus-branchpoint: 1.1.1.1
	kseitz_interps-20020930-merge: 1.1.1.1
	carlton_dictionary-20020927-merge: 1.1.1.1
	carlton_dictionary-branch: 1.1.1.1.0.30
	carlton_dictionary-20020920-branchpoint: 1.1.1.1
	gdb_5_3-branch: 1.1.1.1.0.28
	gdb_5_3-2002-09-04-branchpoint: 1.1.1.1
	kseitz_interps-20020829-merge: 1.1.1.1
	cagney_sysregs-20020825-branch: 1.1.1.1.0.26
	cagney_sysregs-20020825-branchpoint: 1.1.1.1
	readline_4_3-import-branch: 1.1.1.1.0.24
	readline_4_3-import-branchpoint: 1.1.1.1
	gdb_5_2_1-2002-07-23-release: 1.1.1.1
	kseitz_interps-20020528-branch: 1.1.1.1.0.22
	kseitz_interps-20020528-branchpoint: 1.1.1.1
	cagney_regbuf-20020515-branch: 1.1.1.1.0.20
	cagney_regbuf-20020515-branchpoint: 1.1.1.1
	jimb-macro-020506-branch: 1.1.1.1.0.18
	jimb-macro-020506-branchpoint: 1.1.1.1
	gdb_5_2-2002-04-29-release: 1.1.1.1
	gdb_5_2-branch: 1.1.1.1.0.16
	gdb_5_2-2002-03-03-branchpoint: 1.1.1.1
	gdb_5_1_1-2002-01-24-release: 1.1.1.1
	gdb_5_1_0_1-2002-01-03-release: 1.1.1.1
	cygnus_cvs_20020108_pre: 1.1.1.1
	gdb_5_1_0_1-2002-01-03-branchpoint: 1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch: 1.1.1.1.0.14
	gdb_5_1-2001-11-21-release: 1.1.1.1
	gdb_s390-2001-09-26-branch: 1.1.1.1.0.12
	gdb_s390-2001-09-26-branchpoint: 1.1.1.1
	gdb_5_1-2001-07-29-branch: 1.1.1.1.0.10
	gdb_5_1-2001-07-29-branchpoint: 1.1.1.1
	dberlin-typesystem-branch: 1.1.1.1.0.8
	dberlin-typesystem-branchpoint: 1.1.1.1
	gdb-post-ptid_t-2001-05-03: 1.1.1.1
	gdb-pre-ptid_t-2001-05-03: 1.1.1.1
	insight-precleanup-2001-01-01: 1.1.1.1
	gdb-post-protoization-2000-07-29: 1.1.1.1
	gdb-pre-protoization-2000-07-29: 1.1.1.1
	gdb-premipsmulti-2000-06-06-branch: 1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint: 1.1.1.1
	gdb-post-params-removal-2000-06-04: 1.1.1.1
	gdb-pre-params-removal-2000-06-04: 1.1.1.1
	gdb-post-params-removal-2000-05-28: 1.1.1.1
	gdb-pre-params-removal-2000-05-28: 1.1.1.1
	gdb_5_0-2000-05-19-release: 1.1.1.1
	gdb_4_18_2-2000-05-18-release: 1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot: 1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot: 1.1.1.1
	gdb_5_0-2000-04-10-branch: 1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint: 1.1.1.1
	repo-unification-2000-02-06: 1.1.1.1
	insight-2000-02-04: 1.1.1.1
	gdb-2000-02-04: 1.1.1.1
	gdb-2000-02-02: 1.1.1.1
	gdb-2000-02-01: 1.1.1.1
	gdb-2000-01-31: 1.1.1.1
	gdb-2000-01-26: 1.1.1.1
	gdb-2000-01-24: 1.1.1.1
	gdb-2000-01-17: 1.1.1.1
	gdb-2000-01-10: 1.1.1.1
	gdb-2000-01-05: 1.1.1.1
	gdb-1999-12-21: 1.1.1.1
	gdb-1999-12-13: 1.1.1.1
	gdb-1999-12-07: 1.1.1.1
	gdb-1999-12-06: 1.1.1.1
	gdb-1999-11-16: 1.1.1.1
	gdb-1999-11-08: 1.1.1.1
	gdb-1999-11-01: 1.1.1.1
	gdb-1999-10-25: 1.1.1.1
	gdb-1999-10-18: 1.1.1.1
	gdb-1999-10-11: 1.1.1.1
	gdb-1999-10-04: 1.1.1.1
	gdb-1999-09-28: 1.1.1.1
	gdb-1999-09-21: 1.1.1.1
	gdb-1999-09-13: 1.1.1.1
	gdb-1999-09-08: 1.1.1.1
	gdb-1999-08-30: 1.1.1.1
	gdb-1999-08-23: 1.1.1.1
	gdb-1999-08-16: 1.1.1.1
	gdb-1999-08-09: 1.1.1.1
	gdb-1999-08-02: 1.1.1.1
	gdb-1999-07-26: 1.1.1.1
	gdb-1999-07-19: 1.1.1.1
	gdb-1999-07-12: 1.1.1.1
	gdb-post-reformat-19990707: 1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot: 1.1.1.1
	gdb-pre-reformat-19990707: 1.1.1.1
	gdb-1999-07-07: 1.1.1.1
	gdb-1999-07-05: 1.1.1.1
	gdb-1999-06-28: 1.1.1.1
	gdb-1999-06-21: 1.1.1.1
	gdb-1999-06-14: 1.1.1.1
	gdb-1999-06-07: 1.1.1.1
	gdb-1999-06-01: 1.1.1.1
	gdb-4_18-branch: 1.1.1.1.0.2
	gdb-4_18-release: 1.1.1.1
	gdb-1999-05-25: 1.1.1.1
	gdb-1999-05-19: 1.1.1.1
	gdb-1999-05-10: 1.1.1.1
	gdb-19990504: 1.1.1.1
	gdb-19990422: 1.1.1.1
	SNAPSHOT: 1.1.1
	gdb-4_18: 1.1.1.1
	GDB_4_18: 1.1.1
keyword substitution: o
total revisions: 5;	selected revisions: 5
description:
----------------------------
revision 1.3
date: 2009/12/21 07:40:04;  author: brobecke;  state: Exp;  lines: +624 -292
        * COPYING: Update to GPL version 3.
----------------------------
revision 1.2
date: 2005/12/17 22:33:58;  author: eliz;  state: Exp;  lines: +4 -2
branches:  1.2.42;

	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
----------------------------
revision 1.1
date: 1999/04/16 01:33:57;  author: shebs;  state: Exp;
branches:  1.1.1;
Initial revision
----------------------------
revision 1.1.1.1
date: 1999/04/16 01:33:57;  author: shebs;  state: Exp;  lines: +0 -0
Initial creation of sourceware repository
----------------------------
revision 1.2.42.1
date: 2009/12/21 07:43:55;  author: brobecke;  state: Exp;  lines: +624 -292
        * COPYING: Update to GPL version 3.
=============================================================================

RCS file: /cvs/src/src/gdb/ChangeLog,v
Working file: ChangeLog
head: 1.15798
branch:
locks: strict
access list:
symbolic names:
	gdb_7_6-2013-04-26-release: 1.15260.2.48
	gdb_7_6-branch: 1.15260.0.2
	gdb_7_6-2013-03-12-branchpoint: 1.15260
	gdb_7_5_1-2012-11-29-release: 1.14469.2.40
	gdb_7_5-2012-08-17-release: 1.14469.2.23
	gdb_7_5-branch: 1.14469.0.2
	gdb_7_5-2012-07-18-branchpoint: 1.14469
	gdb_7_4_1-2012-04-26-release: 1.13614.2.54
	gdb_7_4-2012-01-24-release: 1.13614.2.42
	gdb_7_4-branch: 1.13614.0.2
	gdb_7_4-2011-12-13-branchpoint: 1.13614
	gdb_7_3_1-2011-09-04-release: 1.12887.2.70
	gdb_7_3-2011-07-26-release: 1.12887.2.64
	gdb_7_3-branch: 1.12887.0.2
	gdb_7_3-2011-04-01-branchpoint: 1.12887
	gdb_7_2-2010-09-02-release: 1.11973.2.42
	gdb_7_2-branch: 1.11973.0.2
	gdb_7_2-2010-07-07-branchpoint: 1.11973
	gdb_7_1-2010-03-18-release: 1.11378.2.33
	gdb_7_1-branch: 1.11378.0.2
	gdb_7_1-2010-02-18-branchpoint: 1.11378
	gdb_7_0_1-2009-12-22-release: 1.10874.2.60
	gdb_7_0-2009-10-06-release: 1.10874.2.46
	gdb_7_0-branch: 1.10874.0.2
	gdb_7_0-2009-09-16-branchpoint: 1.10874
	arc-sim-20090309: 1.9174.2.17.4.1
	msnyder-checkpoint-072509-branch: 1.10747.0.2
	msnyder-checkpoint-072509-branchpoint: 1.10747
	arc-insight_6_8-branch: 1.9174.2.17.0.4
	arc-insight_6_8-branchpoint: 1.9174.2.17
	insight_6_8-branch: 1.9174.2.17.0.2
	insight_6_8-branchpoint: 1.9174.2.17
	reverse-20081226-branch: 1.10052.0.2
	reverse-20081226-branchpoint: 1.10052
	multiprocess-20081120-branch: 1.9991.0.2
	multiprocess-20081120-branchpoint: 1.9991
	reverse-20080930-branch: 1.9859.0.2
	reverse-20080930-branchpoint: 1.9859
	reverse-20080717-branch: 1.9579.0.2
	reverse-20080717-branchpoint: 1.9579
	msnyder-reverse-20080609-branch: 1.9466.0.2
	msnyder-reverse-20080609-branchpoint: 1.9466
	drow-reverse-20070409-branch: 1.8264.0.2
	drow-reverse-20070409-branchpoint: 1.8264
	gdb_6_8-2008-03-27-release: 1.9174.2.17
	gdb_6_8-branch: 1.9174.0.2
	gdb_6_8-2008-02-26-branchpoint: 1.9174
	gdb_6_7_1-2007-10-29-release: 1.8684.2.30
	gdb_6_7-2007-10-10-release: 1.8684.2.19
	gdb_6_7-branch: 1.8684.0.2
	gdb_6_7-2007-09-07-branchpoint: 1.8684
	insight_6_6-20070208-release: 1.7962.2.20
	gdb_6_6-2006-12-18-release: 1.7962.2.19
	gdb_6_6-branch: 1.7962.0.2
	gdb_6_6-2006-11-15-branchpoint: 1.7962
	insight_6_5-20061003-release: 1.7738.2.19
	gdb-csl-symbian-6_4_50_20060226-12: 1.7617.2.2
	gdb-csl-sourcerygxx-3_4_4-25: 1.7432
	nickrob-async-20060828-mergepoint: 1.7891
	gdb-csl-symbian-6_4_50_20060226-11: 1.7617.2.2
@
text
@d3514 1
a3514 1
	    struct gdbarch *gdbarch = info->objfile->gdbarch;
@


1.187
log
@also filter label symbols

The bug here is that, with dwz -m, a function (and a label) appear in
both a PU and a CU when running cplabel.exp.  So, a breakpoint gets
two locations:

    (gdb) break foo::bar:to_the_top
    Breakpoint 2 at 0x400503: foo::bar:to_the_top. (2 locations)

What is especially wacky is that both locations are at the same place:

    (gdb) info b
    Num     Type           Disp Enb Address            What
    1       breakpoint     keep y   <MULTIPLE>
    1.1                         y     0x000000000040051c foo::bar:get_out_of_here
    1.2                         y     0x000000000040051c foo::bar:get_out_of_here

This happens due to the weird way we run "dwz -m".
It's unclear to me that this would ever happen for real code.

While I think this borders on "diminishing returns" territory, the fix
is pretty straightforward: use the existing address-filtering function
in linespec to also filter when looking at labels.

Built and regtested (both ways) on x86-64 Fedora 18.

	* linespec.c (convert_linespec_to_sals): Use maybe_add_address
	when adding label symbols.
@
text
@d1649 1
a1649 1
	 name.  */
d1660 16
@


1.186
log
@	Further workarounds for binutils/15021.
	* dwarf2read.c (recursively_compute_inclusions): Change type of result
	parameter to VEC (symtab_ptr) **.  New parameter all_type_symtabs.
	Watch for duplicate symtabs coming from type units.
	(compute_symtab_includes): Update call to
	recursively_compute_inclusions. Build vector of included symtabs
	instead of per_cus.
	* symtab.h (symtab_ptr): New typedef.
	(DEF_VEC_P (symtab_ptr)): New VEC type.
	* linespec.c (symtab_p): Delete.  All uses updated to use symtab_ptr
	instead.
@
text
@d1999 4
a2002 1
	  if (symbol_to_sal (&sal, state->funfirstline, sym))
@


1.185
log
@fix linespec bug noticed by the checker

This fixes a linespec bug noticed by the cleanup checker.

find_linespec_symbols did this:

  cleanup = demangle_for_lookup (name, state->language->la_language,
				 &lookup_name);
[...]
      cleanup = make_cleanup (xfree, canon);

But this is wrong, as it makes a subsequent call to do_cleanups not
clean up all the local state.

	* linespec.c (find_linespec_symbols): Don't reassign to 'cleanup'.
@
text
@a47 3
typedef struct symtab *symtab_p;
DEF_VEC_P (symtab_p);

d124 1
a124 1
  VEC (symtab_p) *file_symtabs;
d217 1
a217 1
  VEC (symtab_p) *file_symtabs;
d332 1
a332 1
static VEC (symtab_p) *symtabs_from_filename (const char *);
d340 1
a340 1
				   VEC (symtab_p) *file_symtabs,
d360 1
a360 1
static VEC (symtab_p) *collect_symtabs_from_filename (const char *file);
d1841 2
a1842 2
  if (VEC_length (symtab_p, ls->file_symtabs) == 1
      && VEC_index (symtab_p, ls->file_symtabs, 0) == NULL)
d1852 2
a1853 2
      VEC_pop (symtab_p, ls->file_symtabs);
      VEC_free (symtab_p, ls->file_symtabs);
d2214 1
a2214 1
      VEC_safe_push (symtab_p, PARSER_RESULT (parser)->file_symtabs, NULL);
d2275 1
a2275 1
	  VEC_safe_push (symtab_p, PARSER_RESULT (parser)->file_symtabs, NULL);
d2290 1
a2290 1
      VEC_safe_push (symtab_p, PARSER_RESULT (parser)->file_symtabs, NULL);
d2385 1
a2385 1
    VEC_free (symtab_p, PARSER_RESULT (parser)->file_symtabs);
d2603 2
a2604 2
  VEC_safe_push (symtab_p, info.file_symtabs, NULL);
  make_cleanup (VEC_cleanup (symtab_p), &info.file_symtabs);
d2697 1
a2697 1
lookup_prefix_sym (struct linespec_state *state, VEC (symtab_p) *file_symtabs,
d2714 1
a2714 1
  for (ix = 0; VEC_iterate (symtab_p, file_symtabs, ix, elt); ++ix)
d2853 1
a2853 1
find_method (struct linespec_state *self, VEC (symtab_p) *file_symtabs,
d2949 1
a2949 1
  VEC (symtab_p) *symtabs;
d2967 1
a2967 1
      VEC_safe_push (symtab_p, data->symtabs, symtab);
d2975 1
a2975 1
static VEC (symtab_p) *
d3003 1
a3003 1
static VEC (symtab_p) *
d3006 1
a3006 1
  VEC (symtab_p) *result;
d3010 1
a3010 1
  if (VEC_empty (symtab_p, result))
d3028 1
a3028 1
		       VEC (symtab_p) *file_symtabs, const char *name,
d3073 1
a3073 1
		       VEC (symtab_p) *file_symtabs,
d3255 1
a3255 1
  for (ix = 0; VEC_iterate (symtab_p, ls->file_symtabs, ix, elt);
d3288 1
a3288 1
  for (ix = 0; VEC_iterate (symtab_p, ls->file_symtabs, ix, elt); ++ix)
d3591 1
a3591 1
  for (ix = 0; VEC_iterate (symtab_p, info->file_symtabs, ix, elt); ++ix)
@


1.184
log
@gdb/
	* linespec.c (convert_linespec_to_sals): New comment for
	SOURCE_FILENAME assignment.
@
text
@d3100 1
a3100 1
      cleanup = make_cleanup (xfree, canon);
@


1.183
log
@	PR symtab/8424:
	* blockframe.c (find_pc_partial_function_gnu_ifunc): Check
	SYMBOL_SECTION, not SYMBOL_OBJ_SECTION.
	* breakpoint.c (resolve_sal_pc): Update.
	* elfread.c (elf_gnu_ifunc_record_cache): Update.
	* findvar.c (struct minsym_lookup_data) <objfile>: New field.
	(minsym_lookup_iterator_cb): Use it.
	(default_read_var_value): Update.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline):
	Update.
	* infcmd.c (jump_command): Update.
	* linespec.c (minsym_found): Update.
	* maint.c (maintenance_translate_address): Update.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Update.
	(prim_record_minimal_symbol_full): Don't set SYMBOL_OBJ_SECTION.
	* parse.c (write_exp_msymbol): Update.
	* printcmd.c (address_info): Update.
	* psymtab.c (find_pc_sect_psymbol): Update.
	(fixup_psymbol_section): Check SYMBOL_SECTION, not
	SYMBOL_OBJ_SECTION.
	(add_psymbol_to_bcache): Correctly initialize SYMBOL_SECTION.
	Don't initialize SYMBOL_OBJ_SECTION.
	* spu-tdep.c (spu_catch_start): Update.
	* stabsread.c (define_symbol): Don't set SYMBOL_SECTION.
	* symmisc.c (dump_msymbols, print_symbol): Update.
	* symtab.c (fixup_section): Don't set 'obj_section'.  Change
	how fallback section is computed.
	(fixup_symbol_section): Update.
	(find_pc_sect_symtab, find_function_start_sal, skip_prologue_sal):
	Update.
	(allocate_symbol, initialize_symbol, allocate_template_symbol):
	Initialize SYMBOL_SECTION.
	* symtab.h (struct general_symbol_info) <section>: Update comment.
	<obj_section>: Remove.
	(SYMBOL_OBJ_SECTION): Add 'objfile' argument.  Rewrite.
	(SYMBOL_OBJFILE): New macro.
@
text
@d2062 4
@


1.182
log
@	* ada-lang.c (ada_read_renaming_var_value): Pass const
	pointer to expression string to parse_exp_1.
	(create_excep_cond_exprs): Likewise.
	* ax-gdb.c (agent_eval_command_one): Likewise.
	(maint_agent_printf_command): Likewise.
	Constify much of the string handling/parsing.
	* breakpoint.c (set_breakpoint_condition): Pass const
	pointer to expression string to parse_exp_1.
	(update_watchpoint): Likewise.
	(parse_cmd_to_aexpr): Constify string handling.
	Pass const pointer to parse_exp_1.
	(init_breakpoint_sal): Pass const pointer to parse_exp_1.
	(find_condition_and_thread): Likewise.
	Make TOK const.
	(watch_command_1): Make "arg" const.
	Constify string handling.
	Copy the expression string instead of changing the input
	string.
	(update_breakpoint_location): Pass const pointer to
	parse_exp_1.
	* eval.c (parse_and_eval_address): Make "exp" const.
	(parse_to_comma_and_eval): Make "expp" const.
	(parse_and_eval): Make "exp" const.
	* expression.h (parse_expression): Make argument const.
	(parse_exp_1): Make first argument const.
	* findcmd.c (parse_find_args): Treat "args" as const.
	* linespec.c (parse_linespec): Pass const pointer to
	linespec_expression_to_pc.
	(linespec_expression_to_pc): Make "exp_ptr" const.
	* parse.c (parse_exp_1): Make "stringptr" const.
	Make a copy of the expression to pass to parse_exp_in_context until
	this whole interface can be constified.
	(parse_expression): Make "string" const.
	* printcmd.c (ui_printf): Treat "arg" as const.
	Handle const strings.
	* tracepoint.c (validate_actionline): Pass const pointer to
	all calls to parse_exp_1.
	(encode_actions_1): Likewise.
	* value.h (parse_to_comma_and_eval): Make argument const.
	(parse_and_eval_address): Likewise.
	(parse_and_eval): Likewise.
	* varobj.c (varobj_create): Pass const pointer to parse_exp_1.
	(varobj_set_value): Likewise.
	* cli/cli-cmds.c (disassemble_command): Treat "arg" as const and
	constify string handling.
	Pass const pointers to parse_and_eval_address and
	parse_to_comman_and_eval.
	* cli/cli-utils.c (skip_to_space): Rename to ...
	(skip_to_space_const): ... this. Handle const strings.
	* cli/cli-utils.h (skip_to_space): Turn into macro which invokes
	skip_to_space_const.
	(skip_to_space_const): Declare.
	* common/format.c (parse_format_string): Make "arg" const.
	Handle const strings.
	* common/format.h (parse_format_string): Make "arg" const.
	* gdbserver/ax.c (ax_printf): Make "format" const.
	* python/python.c (gdbpy_parse_and_eval): Do not make a copy
	of the expression string.
@
text
@d3402 1
a3402 1
  sal.section = SYMBOL_OBJ_SECTION (msymbol);
@


1.181
log
@	* linespec.c (find_linespec_symbols): Call find_function_symbols
	first, and then call lookup_prefix_sym/find_method.
@
text
@d329 1
a329 1
static CORE_ADDR linespec_expression_to_pc (char **exp_ptr);
d2184 2
a2185 1
      char *expr, *copy;
d2569 1
a2569 1
linespec_expression_to_pc (char **exp_ptr)
@


1.180
log
@	* linespec.c (get_current_search_block): ARI fix, use (void)
	for empty parameter list.
@
text
@a3075 2
  char *klass, *method, *canon;
  const char *lookup_name, *last, *p, *scope_op;
d3077 2
a3078 1
  VEC (symbolp) *classes;
d3098 25
a3122 8
  /* See if we can find a scope operator and break this symbol
     name into namespaces${SCOPE_OPERATOR}class_name and method_name.  */
  scope_op = "::";
  p = find_toplevel_string (lookup_name, scope_op);
  if (p == NULL)
    {
      /* No C++ scope operator.  Try Java.  */
      scope_op = ".";
d3124 6
a3129 17
    }

  last = NULL;
  while (p != NULL)
    {
      last = p;
      p = find_toplevel_string (p + strlen (scope_op), scope_op);
    }

  /* If no scope operator was found, lookup the name as a symbol.  */
  if (last == NULL)
    {
      find_function_symbols (state, file_symtabs, lookup_name,
			     symbols, minsyms);
      do_cleanups (cleanup);
      return;
    }
d3131 2
a3132 20
  /* NAME points to the class name.
     LAST points to the method name.  */
  klass = xmalloc ((last - lookup_name + 1) * sizeof (char));
  make_cleanup (xfree, klass);
  strncpy (klass, lookup_name, last - lookup_name);
  klass[last - lookup_name] = '\0';

  /* Skip past the scope operator.  */
  last += strlen (scope_op);
  method = xmalloc ((strlen (last) + 1) * sizeof (char));
  make_cleanup (xfree, method);
  strcpy (method, last);

  /* Find a list of classes named KLASS.  */
  classes = lookup_prefix_sym (state, file_symtabs, klass);
  make_cleanup (VEC_cleanup (symbolp), &classes);
  if (!VEC_empty (symbolp, classes))
    {
      /* Now locate a list of suitable methods named METHOD.  */
      TRY_CATCH (except, RETURN_MASK_ERROR)
d3134 2
a3135 2
	  find_method (state, file_symtabs, klass, method, classes,
		       symbols, minsyms);
d3138 4
a3141 5
      /* If successful, we're done.  If NOT_FOUND_ERROR
	 was not thrown, rethrow the exception that we did get.
	 Otherwise, fall back to looking up the entire name as a symbol.
	 This can happen with namespace::function.  */
      if (except.reason >= 0)
d3146 32
a3177 2
      else if (except.error != NOT_FOUND_ERROR)
	throw_exception (except);
d3180 1
a3180 4
  /* We couldn't find a class, so we check the entire name as a symbol
     instead.  */
   find_function_symbols (state, file_symtabs, lookup_name, symbols, minsyms);
   do_cleanups (cleanup);
@


1.179
log
@	* ada-lang.c (ada_lookup_symbol_list_worker): New function, contents
	of old ada_lookup_symbol_list.  In !full_search case, don't
	search superblocks.
	(ada_lookup_symbol_list): Delete arg full_search, all callers
	updated.  Call ada_lookup_symbol_list_worker.
	(ada_iterate_over_symbols): Call ada_lookup_symbol_list_worker.
	* ada-lang.h (ada_lookup_symbol_list): Update.
	* language.h (language_defn): Update comment for
	la_iterate_over_symbols.
	* linespec.c (iterate_over_file_blocks): New function.
	(iterate_over_all_matching_symtabs): Call it.
	(lookup_prefix_sym): Ditto.
	(get_current_search_block): New function.
	(get_search_block): Delete.
	(find_label_symbols): Call get_current_search_block.
	(add_matching_symbols_to_info): Call iterate_over_file_blocks.
	* symtab.c (iterate_over_symbols): Don't search superblocks.
@
text
@d1072 1
a1072 1
get_current_search_block ()
@


1.178
log
@gdb/
	* linespec.c (decode_line_2): Fix duplicate request off by two message.
@
text
@d321 5
d1047 1
a1047 5
	  struct block *block;

	  block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), STATIC_BLOCK);
	  state->language->la_iterate_over_symbols (block, name, domain,
						    callback, data);
d1052 1
d1068 2
a1069 2
/* Returns the block to be used for symbol searches for the given SYMTAB,
   which may be NULL.  */
d1072 1
a1072 1
get_search_block (struct symtab *symtab)
d1075 1
d1077 10
a1086 5
  if (symtab != NULL)
    block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), STATIC_BLOCK);
  else
    {
      enum language save_language;
d1088 6
a1093 6
      /* get_selected_block can change the current language when there is
	 no selected frame yet.  */
      save_language = current_language->la_language;
      block = get_selected_block (0);
      set_language (save_language);
    }
d1095 4
a1098 1
  return block;
a2724 2
	  struct block *search_block;

d2729 4
a2732 5
	  search_block = get_search_block (elt);
	  LA_ITERATE_OVER_SYMBOLS (search_block, class_name, STRUCT_DOMAIN,
				   collect_one_symbol, &collector);
	  LA_ITERATE_OVER_SYMBOLS (search_block, class_name, VAR_DOMAIN,
				   collect_one_symbol, &collector);
d3187 1
a3187 1
      block = get_search_block (NULL);
d3591 2
a3592 3
	  LA_ITERATE_OVER_SYMBOLS (get_search_block (elt), name,
				   VAR_DOMAIN, collect_symbols,
				   info);
@


1.177
log
@gdb/
	* linespec.c (struct linespec_canonical_name): New.
	(struct linespec_state): Change canonical_names type to it.
	(add_sal_to_sals): Change variable canonical_name to canonical.  Change
	xrealloc element size.  Initialize the different CANONICAL fields.
	(canonical_to_fullform): New.
	(filter_results): Use it.  Add variables canonical, fullform and
	cleanup.
	(struct decode_line_2_item, decode_line_2_compare_items): New.
	(decode_line_2): Remove variables iter and item_names, add variables
	items and items_count.  Modify the code for these new variables.

gdb/testsuite/
	* gdb.linespec/base/one/thefile.cc (twodup): New.
	(m): Call it.
	* gdb.linespec/base/two/thefile.cc (dupname): New.
	(n): Call it.
	* gdb.linespec/break-ask.exp: New file.
	* gdb.linespec/lspec.cc (body_elsewhere): New comment marker.
@
text
@d1464 1
a1464 1
				 num);
@


1.176
log
@gdb/
	* ada-lang.c (user_select_syms): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	* breakpoint.c (print_breakpoint_location, resolve_sal_pc): Likewise.
	(clear_command): New variable sal_fullname, initialize it.  Replace
	compare_filenames_for_search by filename_cmp with sal_fullname.
	(say_where, update_static_tracepoint): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	* cli/cli-cmds.c (edit_command, list_command, ambiguous_line_spec):
	Likewise.
	* dwarf2read.c: Include source.h.
	(fixup_go_packaging): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* linespec.c (add_sal_to_sals): Rename variable filename to fullname.
	Replace symtab->filename refererences by symtab_to_filename_for_display
	calls.
	(create_sals_line_offset, convert_linespec_to_sals): New variable
	fullname, initialize it, replace symtab->filename reference by the
	variable.
	* linux-fork.c: Include source.h.
	(info_checkpoints_command): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* macroscope.c (sal_macro_scope): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	* mdebugread.c: Include source.h.
	(psymtab_to_symtab_1): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(mi_cmd_file_list_exec_source_files): Likewise.
	* printcmd.c: Include source.h.
	(build_address_symbolic): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* psymtab.c (partial_map_symtabs_matching_filename)
	(read_psymtabs_with_fullname): Call compare_filenames_for_search also
	with psymtab_to_fullname.
	* python/py-symtab.c (stpy_str): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	(stpy_get_filename): New variable filename, initialize it, use instead
	of symtab->filename refererences.
	(salpy_str): Make variable filename const char *.  Replace
	symtab->filename refererences by symtab_to_filename_for_display calls.
	* skip.c: Include source.h and filenames.h.
	(skip_file_command): Remove const from the symtab variable.  Replace
	symtab->filename refererences by symtab_to_fullname call.
	(function_name_is_marked_for_skip): New variables searched_for_fullname
	and fullname.  Use them to search also with symtab's fullname.
	* source.c (find_source_lines): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	(print_source_lines_base): New variable filename, use it instead of
	symtab->filename.  Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	(line_info, forward_search_command): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	(reverse_search_command): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.  New variable filename for it.
	* stack.c (frame_info): Likewise.
	* symmisc.c: Include source.h.
	(dump_objfile, dump_symtab_1, maintenance_print_symbols)
	(maintenance_info_symtabs): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* symtab.c (iterate_over_some_symtabs): Call
	compare_filenames_for_search also with symtab_to_fullname.
	(lookup_symbol_aux_quick, basic_lookup_transparent_type_quick): Replace
	symtab->filename refererences by symtab_to_filename_for_display calls.
	(find_line_symtab): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	(file_matches): Replace filename_cmp by compare_filenames_for_search.
	(print_symbol_info): Make the last parameter const char *.  New
	variable s_filename.  Use it in the function.
	(symtab_symbol_info): Make the last_filename variable const char *.
	Replace symtab->filename refererences by symtab_to_filename_for_display
	calls.
	(rbreak_command): New variable fullname.  Use it.  Replace
	symtab->filename refererence by symtab_to_filename_for_display call.
	* tracepoint.c (set_traceframe_context, trace_find_line_command)
	(print_one_static_tracepoint_marker): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	* tui/tui-source.c (tui_set_source_content): New variables filename and
	s_filename.  Replace symtab->filename refererences by this variable.
	Replace other symtab->filename refererences by
	symtab_to_filename_for_display calls.
@
text
@d160 15
d204 1
a204 1
  char **canonical_names;
d866 1
a866 1
      char *canonical_name = NULL;
d869 3
a871 1
					sals->nelts * sizeof (char *));
d881 1
a881 2
	    canonical_name = xstrprintf ("%s:%s:%d", fullname, symname,
					 sal->line);
d883 1
a883 1
	    canonical_name = xstrprintf ("%s:%s", fullname, symname);
d885 10
a894 1
	    canonical_name = xstrprintf ("%s:%d", fullname, sal->line);
a895 4
      else if (symname != NULL)
	canonical_name = xstrdup (symname);

      self->canonical_names[sals->nelts - 1] = canonical_name;
d1224 13
d1257 9
a1265 1
	  if (strcmp (name, self->canonical_names[j]) == 0)
d1267 2
d1294 38
a1341 1
  const char *iter;
d1345 1
a1345 1
  VEC (const_char_ptr) *item_names = NULL, *filters = NULL;
d1347 2
d1352 3
d1356 5
a1360 3
  old_chain = make_cleanup (VEC_cleanup (const_char_ptr), &item_names);
  make_cleanup (VEC_cleanup (const_char_ptr), &filters);
  for (i = 0; i < result->nelts; ++i)
d1362 9
a1370 2
      int j, found = 0;
      const char *iter;
d1372 3
a1374 2
      gdb_assert (self->canonical_names[i] != NULL);
      for (j = 0; VEC_iterate (const_char_ptr, item_names, j, iter); ++j)
d1376 6
a1381 5
	  if (strcmp (iter, self->canonical_names[i]) == 0)
	    {
	      found = 1;
	      break;
	    }
d1384 1
a1384 2
      if (!found)
	VEC_safe_push (const_char_ptr, item_names, self->canonical_names[i]);
d1387 16
a1402 2
  if (select_mode == multiple_symbols_cancel
      && VEC_length (const_char_ptr, item_names) > 1)
d1406 1
a1406 2
  if (select_mode == multiple_symbols_all
      || VEC_length (const_char_ptr, item_names) == 1)
a1412 5
  /* Sort the list of method names alphabetically.  */
  qsort (VEC_address (const_char_ptr, item_names),
	 VEC_length (const_char_ptr, item_names),
	 sizeof (const_char_ptr), compare_strings);

d1414 2
a1415 2
  for (i = 0; VEC_iterate (const_char_ptr, item_names, i, iter); ++i)
    printf_unfiltered ("[%d] %s\n", i + 2, iter);
d1450 1
a1450 1
      if (num >= VEC_length (const_char_ptr, item_names))
d1454 1
a1454 1
	  const char *elt = VEC_index (const_char_ptr, item_names, num);
d1456 1
a1456 1
	  if (elt != NULL)
d1458 2
a1459 2
	      VEC_safe_push (const_char_ptr, filters, elt);
	      VEC_replace (const_char_ptr, item_names, num, NULL);
d2433 2
a2434 2
	  gdb_assert (state->canonical_names[i] != NULL);
	  make_cleanup (xfree, state->canonical_names[i]);
@


1.175
log
@	* linespec.c (find_linespec_symbols): Make static.
@
text
@d857 1
a857 1
	  char *filename = sal->symtab->filename;
d864 1
a864 1
	    canonical_name = xstrprintf ("%s:%s:%d", filename, symname,
d867 1
a867 1
	    canonical_name = xstrprintf ("%s:%s", filename, symname);
d869 1
a869 1
	    canonical_name = xstrprintf ("%s:%d", filename, sal->line);
d1732 2
d1739 1
d1742 1
a1742 2
      ls->file_symtabs
	= collect_symtabs_from_filename (self->default_symtab->filename);
d1944 5
a1948 1
	  ls->source_filename = xstrdup (state->default_symtab->filename);
@


1.174
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d322 5
a326 5
void find_linespec_symbols (struct linespec_state *self,
			    VEC (symtab_p) *file_symtabs,
			    const char *name,
			    VEC (symbolp) **symbols,
			    VEC (minsym_and_objfile_d) **minsyms);
d2951 1
a2951 1
void
@


1.173
log
@gdb/
	Code cleanup.
	* dwarf2read.c (fixup_go_packaging): Do not check symtab->FILENAME for
	NULL.
	* linespec.c (add_sal_to_sals): Likewise.
	* psympriv.h (allocate_psymtab): Add ATTRIBUTE_NONNULL.
	* stack.c (print_frame): Do not check symtab->FILENAME for NULL.
	* symfile.h (allocate_symtab): Add ATTRIBUTE_NONNULL.
	* symtab.h (struct symtab): Add comment it is never NULL for filename.
	* tracepoint.c (set_traceframe_context): Do not check symtab->FILENAME
	for NULL.
	* tui/tui-source.c (tui_set_source_content): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 1986-2005, 2007-2012 Free Software Foundation, Inc.
@


1.172
log
@	* breakpoint.c (clear_command): Add cleanup for
	sals.sals if an argument is given.

	* linespec.c (parse_linespec): Do cleanups after
	parsing a convenience variable.
@
text
@d855 1
a855 1
      if (!literal_canonical && sal->symtab && sal->symtab->filename)
@


1.171
log
@	PR breakpoints/14643.
	* linespec.c (struct ls_parser): New member keyword_ok.
	(linespec_lexer_lex_string): Add comment.
	(linespec_lexer_lex_one): Ignore keywords if it's the wrong place
	for one.
	(parse_linespec): Set keyword_ok.

	testsuite/
	* gdb.linespec/ls-errs.exp: Change tests of "b if|task|thread".
	* gdb.linespec/thread.c: New file.
	* gdb.linespec/thread.exp: New file.
@
text
@d2098 1
a2103 2
	  discard_cleanups (cleanup);

a2108 2

      do_cleanups (cleanup);
@


1.170
log
@Small typo in comment inside create_sals_line_offset

gdb/ChangeLog:

        * linespec.c (create_sals_line_offset): Fix typo in comment.
@
text
@d289 5
d615 4
d728 4
a731 2
      /* Check for a keyword.  */
      keyword = linespec_lexer_lex_keyword (PARSER_STREAM (parser));
d2038 4
d2116 3
@


1.169
log
@wrong language used when re-setting breakpoint

The debugger sometimes fails to re-set a breakpoint as follow,
causing it to become disabled:

    (gdb) b nested_sub
    Breakpoint 1 at 0x401cec: file foo.adb, line 7.
    (gdb) b do_nothing
    Breakpoint 2 at 0x401cdc: file pck.adb, line 4.
    (gdb) run
    Starting program: /[...]/foo
    Error in re-setting breakpoint 1: Function "nested_sub" not defined.

    Breakpoint 2, pck.do_nothing () at pck.adb:4
    4             null;

This only happens on machines where the debug-file-directory is
a valid directory name.

The reason behind the error is that the linespec code that re-sets
the breakpoints uses the current_language global when iterating
over a symtab's symbols. However, the that global gets switched from
Ada to C during the startup phase, probably as a side-effect of stopping
in some system code for which debugging info is available. The fix
is to make sure that we use the correct language.

gdb/ChangeLog:

        * linespec.c (iterate_over_all_matching_symtabs): Use the correct
        language when iterating over symbols.

gdb/testsuite/ChangeLog:

        * gdb.ada/bp_reset: New testcase.
@
text
@d1714 1
a1714 1
     when we are called with just a function anme, since
@


1.168
log
@2012-08-10  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* linespec.c (find_methods): Remove unused variables `i1' and
	`name_len'.
	(decode_line_full): Likewise for `arg_start'.
@
text
@d1013 2
a1014 1
	  LA_ITERATE_OVER_SYMBOLS (block, name, domain, callback, data);
d1025 2
a1026 2
		  LA_ITERATE_OVER_SYMBOLS (block, name, domain,
					   iterate_inline_only, &cad);
@


1.167
log
@	* linespec.c (linespec_lex_number): A number followed
	by quotes is a valid number, too.

	* gdb.linespec/ls-errs.exp: Check some quote-enclosed
	linespecs.
@
text
@a1065 1
  int i1 = 0;
a1074 1
      int name_len = strlen (name);
a2273 1
  char *arg_start = *argptr;
@


1.166
log
@	* linespec.c (linespec_lexer_lex_number): The input
	is also a valid number if the next character is a comma
	or colon.
@
text
@d394 1
a394 1
     or colon, this input does not represent a number.  */
d397 2
a398 1
      && *PARSER_STREAM (parser) != ':')
@


1.165
log
@2012-07-25  Hui Zhu  <hui_zhu@@mentor.com>

	* linespec.c (linespec_lexer_lex_number): Update comments,
	change the return and add check to make sure the input is
	the decimal numbers.
	(linespec_lexer_lex_one): If linespec_lexer_lex_number return
	false, call linespec_lexer_lex_string.
@
text
@d369 2
a370 1
   decimal numbers.\
d393 5
a397 1
  if (*PARSER_STREAM (parser) != '\0' && !isspace(*PARSER_STREAM (parser)))
@


1.164
log
@	* linespec.c (convert_linespec_to_sal): Don't add
	any symbols to the result vector if symbol_to_sal
	returns zero.
@
text
@d369 2
a370 1
   decimal numbers.  */
d372 2
a373 2
static linespec_token
linespec_lexer_lex_number (linespec_parser *parser)
d375 3
a377 5
  linespec_token token;

  token.type = LSTOKEN_NUMBER;
  LS_TOKEN_STOKEN (token).length = 0;
  LS_TOKEN_STOKEN (token).ptr = PARSER_STREAM (parser);
d382 1
a382 1
      ++LS_TOKEN_STOKEN (token).length;
d388 1
a388 1
      ++LS_TOKEN_STOKEN (token).length;
d392 7
a398 1
  return token;
d732 2
a733 1
          parser->lexer.current = linespec_lexer_lex_number (parser);
@


1.163
log
@	* linespec.c (decode_objc): Record the function name
	in the linespec.
@
text
@d1863 3
a1865 3
	  symbol_to_sal (&sal, state->funfirstline, sym);
	  add_sal_to_sals (state, &sals, &sal,
			   SYMBOL_NATURAL_NAME (sym), 0);
d1889 2
a1890 2
	      symbol_to_sal (&sal, state->funfirstline, sym);
	      if (maybe_add_address (state->addr_set, pspace, sal.pc))
@


1.162
log
@	* linespec.c (add_sal_to_sals): Add LITERAL_CANONICAL
	parameter.  If non-zero, use SYMNAME as the canonical name
	for the SaL.
	Update all callers.
	(convert_linespec_to_sals): Use add_sal_to_sals for
	expressions, too.
	(decode_line_full): No need to "fill in missing canonical names"
	anymore. Simply make cleanups for the allocated names.
@
text
@d2480 1
@


1.161
log
@	* linespec.c (struct linespec): Constify expression,
	source_filename, function_name, and label_name.
	(symbol_not_found_error): Make all parameters const.
	(linespec_parser_delete): No need to check for NULL
	when using xfree. Cast const char * to char * for xfree.
@
text
@d813 4
a816 1
   symbol to use when constructing the new canonical name.  */
d822 1
a822 1
		 const char *symname)
d832 1
a832 1
      if (sal->symtab && sal->symtab->filename)
d848 2
d1817 1
a1817 1
			     sym ? SYMBOL_NATURAL_NAME (sym) : NULL);
d1845 2
d1848 5
a1852 6
      sals.sals = XMALLOC (struct symtab_and_line);
      sals.nelts = 1;
      sals.sals[0] = find_pc_line (ls->expr_pc, 0);
      sals.sals[0].pc = ls->expr_pc;
      sals.sals[0].section = find_pc_overlay (ls->expr_pc);
      sals.sals[0].explicit_pc = 1;
d1865 1
a1865 1
			   SYMBOL_NATURAL_NAME (sym));
d1891 2
a1892 1
		add_sal_to_sals (state, &sals, &sal, SYMBOL_NATURAL_NAME (sym));
d2290 1
a2290 1
  /* Fill in the missing canonical names.  */
a2294 2
      if (state->canonical_names == NULL)
	state->canonical_names = xcalloc (result.nelts, sizeof (char *));
d2298 1
a2298 3
	  if (state->canonical_names[i] == NULL)
	    state->canonical_names[i] = savestring (arg_start,
						    *argptr - arg_start);
d3112 1
a3112 1
      add_sal_to_sals (self, values, &val, NULL);
d3256 1
a3256 1
    add_sal_to_sals (self, result, &sal, SYMBOL_NATURAL_NAME (msymbol));
@


1.160
log
@	* linespec.c (linespec_parse_line_offset): Make parameter
	const.
@
text
@d113 1
a113 1
  char *expression;
d121 1
a121 1
  char *source_filename;
d133 1
a133 1
  char *function_name;
d143 1
a143 1
  char *label_name;
d1350 1
a1350 1
symbol_not_found_error (char *symbol, char *filename)
d2223 4
a2226 8
  if (PARSER_RESULT (parser)->expression)
    xfree (PARSER_RESULT (parser)->expression);
  if (PARSER_RESULT (parser)->source_filename)
    xfree (PARSER_RESULT (parser)->source_filename);
  if (PARSER_RESULT (parser)->label_name)
    xfree (PARSER_RESULT (parser)->label_name);
  if (PARSER_RESULT (parser)->function_name)
    xfree (PARSER_RESULT (parser)->function_name);
@


1.159
log
@	* linespec.c: #include "stack.h".
	(decode_line_with_current_source): Moved here from symtab.c and
	renamed from decode_line_spec.  All callers updated.
	(decode_line_with_last_displayed): Moved here from breakpoint.c and
	renamed from decode_line_spec_1.  All callers updated.
	* linespec.h (decode_line_with_current_source): Move declaration here
	from symtab.h and renamed from decode_line_spec.
	(decode_line_with_last_displayed): Move declaration here from symtab.h
	and renamed from decode_line_spec_1.
	* macrocmd.c: #include "linespec.h".
	* symtab.c: Remove #include "linespec.h".
@
text
@d1423 1
a1423 1
linespec_parse_line_offset (char *string)
@


1.159.2.1
log
@	* linespec.c (convert_linespec_to_sal): Don't add
	any symbols to the result vector if symbol_to_sal
	returns zero.
@
text
@d1857 3
a1859 3
	  if (symbol_to_sal (&sal, state->funfirstline, sym))
	    add_sal_to_sals (state, &sals, &sal,
			     SYMBOL_NATURAL_NAME (sym));
d1883 2
a1884 2
	      if (symbol_to_sal (&sal, state->funfirstline, sym)
		  && maybe_add_address (state->addr_set, pspace, sal.pc))
@


1.159.2.2
log
@2012-07-25  Hui Zhu  <hui_zhu@@mentor.com>

	* linespec.c (linespec_lexer_lex_number): Update comments,
	change the return and add check to make sure the input is
	the decimal numbers.
	(linespec_lexer_lex_one): If linespec_lexer_lex_number return
	false, call linespec_lexer_lex_string.
@
text
@d369 1
a369 2
   decimal numbers.\
   Return true if input is decimal numbers.  Return false if not.  */
d371 2
a372 2
static int
linespec_lexer_lex_number (linespec_parser *parser, linespec_token *tokenp)
d374 5
a378 3
  tokenp->type = LSTOKEN_NUMBER;
  LS_TOKEN_STOKEN (*tokenp).length = 0;
  LS_TOKEN_STOKEN (*tokenp).ptr = PARSER_STREAM (parser);
d383 1
a383 1
      ++LS_TOKEN_STOKEN (*tokenp).length;
d389 1
a389 1
      ++LS_TOKEN_STOKEN (*tokenp).length;
d393 1
a393 7
  if (*PARSER_STREAM (parser) != '\0' && !isspace(*PARSER_STREAM (parser)))
    {
      PARSER_STREAM (parser) = LS_TOKEN_STOKEN (*tokenp).ptr;
      return 0;
    }

  return 1;
d727 1
a727 2
           if (!linespec_lexer_lex_number (parser, &(parser->lexer.current)))
	     parser->lexer.current = linespec_lexer_lex_string (parser);
@


1.159.2.3
log
@	* linespec.c (linespec_lexer_lex_number): The input
	is also a valid number if the next character is a comma
	or colon.
@
text
@d369 1
a369 2
   decimal numbers.

d392 1
a392 5
  /* If the next character in the input buffer is not a space, comma,
     or colon, the input does not represent a number.  */
  if (*PARSER_STREAM (parser) != '\0'
      && !isspace (*PARSER_STREAM (parser)) && *PARSER_STREAM (parser) != ','
      && *PARSER_STREAM (parser) != ':')
@


1.159.2.4
log
@	* linespec.c (linespec_lex_number): A number followed
	by quotes is a valid number, too.

	* gdb.linespec/ls-errs.exp: Check some quote-enclosed
	linespecs.
@
text
@d394 1
a394 1
     quote, or colon, the input does not represent a number.  */
d397 1
a397 2
      && *PARSER_STREAM (parser) != ':'
      && !strchr (linespec_quote_characters, *PARSER_STREAM (parser)))
@


1.159.2.5
log
@	PR breakpoints/14643.
	* linespec.c (struct ls_parser): New member keyword_ok.
	(linespec_lexer_lex_string): Add comment.
	(linespec_lexer_lex_one): Ignore keywords if it's the wrong place
	for one.
	(parse_linespec): Set keyword_ok.

	testsuite/
	* gdb.linespec/ls-errs.exp: Change tests of "b if|task|thread".
	* gdb.linespec/thread.c: New file.
	* gdb.linespec/thread.exp: New file.
@
text
@a288 5
  /* Is a keyword syntactically valid at this point?
     In, e.g., "break thread thread 1", the leading "keyword" must not
     be interpreted as such.  */
  int keyword_ok;

a609 4
	      /* When we get here we know we've found something followed by
		 a space (we skip over parens and templates below).
		 So if we find a keyword now, we know it is a keyword and not,
		 say, a function name.  */
d719 2
a720 4
      /* Check for a keyword, they end the linespec.  */
      keyword = NULL;
      if (parser->keyword_ok)
	keyword = linespec_lexer_lex_keyword (PARSER_STREAM (parser));
a2020 4
  /* A keyword at the start cannot be interpreted as such.
     Consider "b thread thread 42".  */
  parser->keyword_ok = 0;

a2094 3
  /* Now we can recognize keywords.  */
  parser->keyword_ok = 1;

@


1.158
log
@	* objfiles.h (ALL_OBJFILE_PRIMARY_SYMTABS): New macro.
	(ALL_PRIMARY_SYMTABS): Use it.
	(ALL_PSPACE_PRIMARY_SYMTABS): Ditto.
	* dwarf2read.c (dw2_find_symbol_file): Ditto.
	* linespec.c (iterate_over_all_matching_symtabs): Ditto.
	* symtab.c (lookup_symbol_aux_objfile): Ditto.
	(basic_lookup_transparent_type): Ditto.
@
text
@d46 1
d2329 2
d2351 45
@


1.157
log
@	* linespec.c (decode_objc): Add cleanup to free
	INFO.FILE_SYMTABS.
	(find_linespec_symbols): Add cleanup to free CLASSES.
	* symfile.c (find_separate_debug_file_by_debuglink): Add
	cleanup to free DEBUGLINK.
	* ui-out.c (clear_header_list): No need to check if
	HEADER_NEXT.COLHDR is NULL.
	Free HEADER_NEXT.COL_NAME.
@
text
@d990 1
a990 1
      ALL_OBJFILE_SYMTABS (objfile, symtab)
d992 6
a997 1
	  if (symtab->primary)
d999 2
a1000 1
	      struct block *block;
d1002 2
a1003 4
	      block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), STATIC_BLOCK);
	      LA_ITERATE_OVER_SYMBOLS (block, name, domain, callback, data);

	      if (include_inline)
d1005 3
a1007 10
		  struct symbol_and_data_callback cad = { callback, data };
		  int i;

		  for (i = FIRST_LOCAL_BLOCK;
		       i < BLOCKVECTOR_NBLOCKS (BLOCKVECTOR (symtab)); i++)
		    {
		      block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), i);
		      LA_ITERATE_OVER_SYMBOLS (block, name, domain,
					       iterate_inline_only, &cad);
		    }
@


1.156
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d2412 1
d2953 1
@


1.155
log
@	* linespec.c (convert_linespec_to_sals): Don't use
	SYMBOL_OBJ_SECTION.
	(compare_msymbols): Arguments are minsym_and_objfile, not
	minimal_symbol*.  Don't use SYMBOL_OBJ_SECTION.
@
text
@a2673 1
  char *name_iter;
a3387 2
      struct symbol *sym;

@


1.154
log
@linespec rewrite:
	* linespec.c (decode_compound): Remove.
	(enum offset_relative_sign): New enum.
	(struct line_offset): New struct.
	(struct linespec): New struct.
	(struct linespec_state): Move file_symtabs,
	user_filename, and user_function into struct linespec.
	Make result an anonymous struct holding vectors of
	symbolp and minsym_and_objfile_d.
	Add language member.
	(enum ls_token_type): New enum.
	(linespec_keywords): New array.
	(struct ls_token): New struct.
	(struct ls_parser): New struct.
	(linespec_lexer_lex_number): New function.
	(linespec_lexer_lex_keyword): New function.
	(is_ada_operator): New function.
	(skip_quote_char): New function.
	(copy_token_string): New function.
	(is_closing_quote_enclosed): New function.
	(find_parameter_list_end): New function.
	(linespec_lexer_lex_string): New function.
	(linespec_lexer_lex_one): New function.
	(linespec_lexer_consume_token): New function.
	(linespec_lexer_peek_token): New function.
	(cplusplus_error): Remove unused function.
	(find_methods): Update comment.
	(find_toplevel_char): Return const.
	(is_objc_method_format): Remove unused function.
	(find_toplevel_string): New function.
	(is_linespec_boundary): Remove.
	(symbol_not_found_error): New function.
	(find_method_overload_end): Remove function.
	(unexpected_linespec_error): New function.
	(keep_name_info): Remove.
	(linespec_parse_line_offset): New function.
	(linespec_parse_basic): New function.
	(canonicalize_linespec): New function.
	(decode_line_internal): Remove.
	(create_sals_line_offset): New function adapted from
	decode_all_digits.
	(convert_linespec_to_sals): New function.
	(parse_linespec): New function.
	(linespec_parser_new): New function.
	(linespec_state_destructor): Change parameter type to
	struct linespec_state *.
	Add language parameter.
	Remove freeing of moved members.
	(linespec_parser_delete): New function.
	(decode_line_full): Use parse_linespec and linespec_parser_new.
	(decode_line_1): Likewise.
	(decode_indirect): Rename to ...
	(linespec_expression_to_pc): ... this and rewrite
	to simply find CORE_ADDR, storing this result for later
	conversion to SALs.
	(locate_first_half): Remove.
	(deocde_objc): Add parameter LS.
	Initialize new struct collect_info members.
	Handle minimal symbols, too.
	(decode_compound): Delete.
	(lookup_prefix_sym): Rewrite.
	(compare_msymbols): New function.
	(find_method): Rewrite.
	Do not call cplusplus_error.
	(symtabs_from_filename): Rewrite.
	(collect_function_symbols): Delete.
	(find_function_symbols): Rewrite without ARGPTR-style
	processing.
	(decode_all_digits): Delete. (Rewritten as create_sals_line_offset.)
	(decode_dollar): Adapted and renamed to ...
	(linespec_parse_variable): ... this.
	(find_linespec_symbols): New function.
	(decode_label): Adapted and renamed to ...
	(find_label_symbols): ... this.
	(decode_digits_list_mode): Add and use LS argument.
	(decode_digits_ordinary): Likewise.
	(collect_symbols): Do not collect SALs, just symbols and msymbols.
	If in list mode, allow any symbol class.  Otherwise, only
	permit LOC_BLOCK symbols.
	(minsym_found): Update comments.
	(search_minsyms_for_name): Do not convert the matching symbol
	into a SAL.  Simply push the symbol and objfile into the
	result vector.
	(decode_variable): Delete. Contents adapted into
	find_linespec_symbols.

	* cp-support.c (SKIP_SPACE): Remove.
	(operator_tokens): Remove unused global.
	(cp_validate_operator): Remove.
	* cp-support.h (cp_validate_operator): Remove declaration.

	* gdb.base/advance.exp: Update error message for
	"advance malformed" test.
	* gdb.base/break.exp: Likewise for "breakpoint with
	trailing garbage" test.
	* gdb.base/hbreak2.exp: Likewise for "hardware breakpoint
	with trailing garbage" test.
	* gdb.base/jump.exp: Likewise for "jump with trailing
	argument junk" test.
	* gdb.base/sepdebug.exp: Likewise for "breakpoint with
	trailng garbage" test.
	* gdb.base/until.exp: Likewise for "malformed until" test.
	* gdb.cp/ovldbreak.exp: Create the breakpoint table
	for "breakpoint info (after setting on all)".
	* gdb.cp/userdef.exp: Remove quoting for "break A2::operator+"
	tests.
	* gdb.cp/cplabel.cc: New file.
	* gdb.cp/cplabel.exp: New test.
	* gdb.linespec/ls-errs.c: New file.
	* gdb.linespec/ls-errs.exp: New test.
@
text
@d1902 1
a1902 1
	      pspace = SYMBOL_OBJ_SECTION (elem->minsym)->objfile->pspace;
d2587 2
a2588 2
  struct minimal_symbol * const *sa = a;
  struct minimal_symbol * const *sb = b;
d2591 2
a2592 2
  uia = (uintptr_t) SYMBOL_OBJ_SECTION (*sa)->objfile->pspace;
  uib = (uintptr_t) SYMBOL_OBJ_SECTION (*sb)->objfile->pspace;
d2599 2
a2600 2
  uia = (uintptr_t) *sa;
  uib = (uintptr_t) *sb;
@


1.153
log
@gdb:
	PR breakpoints/10738
	* dwarf2read.c (use_deprecated_index_sections): New global.
	(struct partial_die_info): New member may_be_inlined.
	(read_partial_die): Set may_be_inlined where appropriate.
	(add_partial_subprogram): Add partial symbols for partial
	DIEs that may be inlined.
	(new_symbol_full): Add inlined subroutines to the current
	scope.
	(write_psymtabs_to_index): Bump version number.
	(dwarf2_read_index): Read only version 6 indices unless
	use_deprecated_index_sections is set.
	* linespec.c (symbol_and_data_callback): New structure.
	(iterate_inline_only): New function.
	(iterate_over_all_matching_symtabs): New argument
	"include_inline".  If nonzero, also call the callback for
	symbols representing inlined subroutines.
	(lookup_prefix_sym): Pass extra argument to the above.
	(find_function_symbols): Likewise.
	(add_matching_symbols_to_info): Likewise.
	* NEWS: Mention that GDB can now set breakpoints on inlined
	functions.

gdb/doc:
	PR breakpoints/10738
	* gdb.texinfo (Inline Functions): Remove the now-unnecessary @@item
	stating that GDB cannot set breakpoints on inlined functions.
	(Mode Options): Document --use-deprecated-index-sections.
	(Index Section Format): Document new index section version format.

gdb/testsuite:
	PR breakpoints/10738
	* gdb.opt/inline-break.exp: New file.
	* gdb.opt/inline-break.c: Likewise.
	* gdb.dwarf2/inline-break.exp: Likewise.
	* gdb.dwarf2/inline-break.S: Likewise.
	* gdb.base/annota1.exp: Cope with old .gdb_index warnings.
	* gdb.base/async-shell.exp: Likewise.
	* lib/mi-support.exp (library_loaded_re): Likewise.
@
text
@d66 93
d165 3
a176 13
  /* If the linespec started with "FILE:", this holds all the matching
     symtabs.  Otherwise, it will hold a single NULL entry, meaning
     that the default symtab should be used.  */
  VEC (symtab_p) *file_symtabs;

  /* If the linespec started with "FILE:", this holds an xmalloc'd
     copy of "FILE".  */
  char *user_filename;

  /* If the linespec is "FUNCTION:LABEL", this holds an xmalloc'd copy
     of "FUNCTION".  */
  char *user_function;

d203 3
d207 88
a294 1
  struct symtabs_and_lines result;
d296 1
d303 1
a303 4
static struct symtabs_and_lines decode_indirect (struct linespec_state *self,
						 char **argptr);

static char *locate_first_half (char **argptr, int *is_quote_enclosed);
d306 1
d309 1
a309 41
static struct symtabs_and_lines decode_compound (struct linespec_state *self,
						 char **argptr,
						 char *saved_arg,
						 char *p);

static VEC (symbolp) *lookup_prefix_sym (char **argptr, char *p,
					 VEC (symtab_p) *,
					 char **);

static struct symtabs_and_lines find_method (struct linespec_state *self,
					     char *saved_arg,
					     char *copy,
					     const char *class_name,
					     VEC (symbolp) *sym_classes);

static void cplusplus_error (const char *name, const char *fmt, ...)
     ATTRIBUTE_NORETURN ATTRIBUTE_PRINTF (2, 3);

static char *find_toplevel_char (char *s, char c);

static int is_objc_method_format (const char *s);

static VEC (symtab_p) *symtabs_from_filename (char **argptr,
					      char *p, int is_quote_enclosed,
					      char **user_filename);

static VEC (symbolp) *find_function_symbols (char **argptr, char *p,
					     int is_quote_enclosed,
					     char **user_function);

static struct symtabs_and_lines decode_all_digits (struct linespec_state *self,
						   char **argptr,
						   char *q);

static struct symtabs_and_lines decode_dollar (struct linespec_state *self,
					       char *copy);

static int decode_label (struct linespec_state *self,
			 VEC (symbolp) *function_symbols,
			 char *copy,
			 struct symtabs_and_lines *result);
d311 14
a324 2
static struct symtabs_and_lines decode_variable (struct linespec_state *self,
						 char *copy);
d337 460
d836 1
a836 1
	      && current_language->la_language == language_ada)
d895 1
a895 3
/* Issue a helpful hint on using the command completion feature on
   single quoted demangled C++ symbols as part of the completion
   error.  */
d897 1
a897 32
static void
cplusplus_error (const char *name, const char *fmt, ...)
{
  struct ui_file *tmp_stream;
  char *message;

  tmp_stream = mem_fileopen ();
  make_cleanup_ui_file_delete (tmp_stream);

  {
    va_list args;

    va_start (args, fmt);
    vfprintf_unfiltered (tmp_stream, fmt, args);
    va_end (args);
  }

  while (*name == '\'')
    name++;
  fprintf_unfiltered (tmp_stream,
		      ("Hint: try '%s<TAB> or '%s<ESC-?>\n"
		       "(Note leading single quote.)"),
		      name, name);

  message = ui_file_xstrdup (tmp_stream, NULL);
  make_cleanup (xfree, message);
  throw_error (NOT_FOUND_ERROR, "%s", message);
}

/* A callback function and the additional data to call it with.  */

struct symbol_and_data_callback
d953 2
a954 1
iterate_over_all_matching_symtabs (const char *name,
d967 2
a968 2
    current_language->la_get_symbol_name_cmp != NULL
    ? current_language->la_get_symbol_name_cmp (name)
d1043 1
a1043 1
   match NAME.  It adds resulting symbol names to RESULT_NAMES, and
d1117 2
a1118 2
static char *
find_toplevel_char (char *s, char c)
d1124 1
a1124 1
  char *scan;
d1148 3
a1150 3
/* Determines if the gives string corresponds to an Objective-C method
   representation, such as -[Foo bar:] or +[Foo bar].  Objective-C symbols
   are allowed to have spaces and parentheses in them.  */
d1152 2
a1153 2
static int 
is_objc_method_format (const char *s)
d1155 21
a1175 10
  if (s == NULL || *s == '\0')
    return 0;
  /* Handle arguments with the format FILENAME:SYMBOL.  */
  if ((s[0] == ':') && (strchr ("+-", s[1]) != NULL) 
      && (s[2] == '[') && strchr(s, ']'))
    return 1;
  /* Handle arguments that are just SYMBOL.  */
  else if ((strchr ("+-", s[0]) != NULL) && (s[1] == '[') && strchr(s, ']'))
    return 1;
  return 0;
d1344 6
a1349 1
/* Valid delimiters for linespec keywords "if", "thread" or "task".  */
d1351 75
a1425 2
static int
is_linespec_boundary (char c)
d1427 16
a1442 1
  return c == ' ' || c == '\t' || c == '\0' || c == ',';
d1445 1
a1445 3
/* A helper function for decode_line_1 and friends which skips P
   past any method overload information at the beginning of P, e.g.,
   "(const struct foo *)".
d1447 2
a1448 4
   This function assumes that P has already been validated to contain
   overload information, and it will assert if *P != '('.  */
static char *
find_method_overload_end (char *p)
d1450 5
a1454 1
  int depth = 0;
d1456 2
a1457 1
  gdb_assert (*p == '(');
d1459 80
a1538 1
  while (*p)
d1540 17
a1556 3
      if (*p == '(')
	++depth;
      else if (*p == ')')
d1558 26
a1583 1
	  if (--depth == 0)
d1585 17
a1601 2
	      ++p;
	      break;
d1604 5
a1608 1
      ++p;
d1610 68
d1679 3
a1681 1
  return p;
d1684 1
a1684 3
/* Keep important information used when looking up a name.  This includes
   template parameters, overload information, and important keywords, including
   the possible Java trailing type.  */
d1686 3
a1688 2
static char *
keep_name_info (char *p, int on_boundary)
d1690 3
a1692 3
  const char *quotes = get_gdb_completer_quote_characters ();
  char *saved_p = p;
  int nest = 0;
d1694 51
a1744 1
  while (*p)
d1746 27
a1772 2
      if (strchr (quotes, *p))
	break;
d1774 4
a1777 2
      if (*p == ',' && !nest)
	break;
d1779 1
a1779 1
      if (on_boundary && !nest)
d1781 1
a1781 2
	  const char *const words[] = { "if", "thread", "task" };
	  int wordi;
d1783 3
a1785 6
	  for (wordi = 0; wordi < ARRAY_SIZE (words); wordi++)
	    if (strncmp (p, words[wordi], strlen (words[wordi])) == 0
		&& is_linespec_boundary (p[strlen (words[wordi])]))
	      break;
	  if (wordi < ARRAY_SIZE (words))
	    break;
d1788 12
a1799 4
      if (*p == '(' || *p == '<' || *p == '[')
	nest++;
      else if ((*p == ')' || *p == '>' || *p == ']') && nest > 0)
	nest--;
d1801 6
a1806 1
      p++;
d1808 8
a1815 2
      /* The ',' check could fail on "operator ,".  */
      p += cp_validate_operator (p);
d1817 1
a1817 1
      on_boundary = is_linespec_boundary (p[-1]);
d1820 9
a1828 2
  while (p > saved_p && is_linespec_boundary (p[-1]))
    p--;
d1830 1
a1830 1
  return p;
d1833 97
a1929 2

/* The parser of linespec itself.  */
d1931 1
a1931 1
/* Parse a string that specifies a line number.
d1935 21
a1955 1
   The string can be:
d1957 2
a1958 9
   LINENUM -- that line number in current file.  PC returned is 0.
   FILE:LINENUM -- that line in that file.  PC returned is 0.
   FUNCTION -- line number of openbrace of that function.
   PC returned is the start of the function.
   LABEL -- a label in the current scope
   VARIABLE -- line number of definition of that variable.
   PC returned is 0.
   FILE:FUNCTION -- likewise, but prefer functions in that file.
   *EXPR -- line in which address EXPR appears.
d1960 1
a1960 1
   This may all be followed by an "if EXPR", which we ignore.
d1962 1
a1962 1
   FUNCTION may be an undebuggable function found in minimal symbol table.
d1982 1
a1982 59
/* We allow single quotes in various places.  This is a hideous
   kludge, which exists because the completer can't yet deal with the
   lack of single quotes.  FIXME: write a linespec_completer which we
   can use as appropriate instead of make_symbol_completion_list.  */

static struct symtabs_and_lines
decode_line_internal (struct linespec_state *self, char **argptr)
{
  char *p;
  char *q;

  char *copy;
  /* This says whether or not something in *ARGPTR is quoted with
     completer_quotes (i.e. with single quotes).  */
  int is_quoted;
  /* Is *ARGPTR enclosed in double quotes?  */
  int is_quote_enclosed;
  int is_objc_method = 0;
  char *saved_arg = *argptr;
  /* If IS_QUOTED, the end of the quoted bit.  */
  char *end_quote = NULL;
  /* Is *ARGPTR enclosed in single quotes?  */
  int is_squote_enclosed = 0;
  /* The "first half" of the linespec.  */
  char *first_half;

  /* If we are parsing `function:label', this holds the symbols
     matching the function name.  */
  VEC (symbolp) *function_symbols = NULL;
  /* If FUNCTION_SYMBOLS is not NULL, then this is the exception that
     was thrown when trying to parse a filename.  */
  volatile struct gdb_exception file_exception;

  struct cleanup *cleanup = make_cleanup (null_cleanup, NULL);

  /* Defaults have defaults.  */

  initialize_defaults (&self->default_symtab, &self->default_line);
  
  /* See if arg is *PC.  */

  if (**argptr == '*')
    {
      do_cleanups (cleanup);
      return decode_indirect (self, argptr);
    }

  is_quoted = (strchr (get_gdb_completer_quote_characters (),
		       **argptr) != NULL);

  if (is_quoted)
    {
      end_quote = skip_quoted (*argptr);
      if (*end_quote == '\0')
	is_squote_enclosed = 1;
    }

  /* Check to see if it's a multipart linespec (with colons or
     periods).  */
d1984 7
a1990 7
  /* Locate the end of the first half of the linespec.
     After the call, for instance, if the argptr string is "foo.c:123"
     p will point at ":123".  If there is only one part, like "foo", p
     will point to "".  If this is a C++ name, like "A::B::foo", p will
     point to "::B::foo".  Argptr is not changed by this call.  */

  first_half = p = locate_first_half (argptr, &is_quote_enclosed);
d1992 6
a1997 8
  /* First things first: if ARGPTR starts with a filename, get its
     symtab and strip the filename from ARGPTR.
     Avoid calling symtab_from_filename if we know can,
     it can be expensive.  We know we can avoid the call if we see a
     single word (e.g., "break NAME") or if we see a qualified C++
     name ("break QUAL::NAME").  */

  if (*p != '\0' && !(p[0] == ':' && p[1] == ':'))
d1999 1
a1999 6
      TRY_CATCH (file_exception, RETURN_MASK_ERROR)
	{
	  self->file_symtabs = symtabs_from_filename (argptr, p,
						      is_quote_enclosed,
						      &self->user_filename);
	}
d2001 2
a2002 1
      if (file_exception.reason >= 0)
d2004 4
a2007 15
	  /* Check for single quotes on the non-filename part.  */
	  is_quoted = (**argptr
		       && strchr (get_gdb_completer_quote_characters (),
				  **argptr) != NULL);
	  if (is_quoted)
	    end_quote = skip_quoted (*argptr);

	  /* Locate the next "half" of the linespec.  */
	  first_half = p = locate_first_half (argptr, &is_quote_enclosed);
	}

      if (VEC_empty (symtab_p, self->file_symtabs))
	{
	  /* A NULL entry means to use GLOBAL_DEFAULT_SYMTAB.  */
	  VEC_safe_push (symtab_p, self->file_symtabs, NULL);
a2009 5
  else
    {
      /* A NULL entry means to use GLOBAL_DEFAULT_SYMTAB.  */
      VEC_safe_push (symtab_p, self->file_symtabs, NULL);
    }
d2011 3
a2013 4
  /* Check if this is an Objective-C method (anything that starts with
     a '+' or '-' and a '[').  */
  if (is_objc_method_format (p))
    is_objc_method = 1;
d2015 3
a2017 1
  /* Check if the symbol could be an Objective-C selector.  */
d2019 4
a2022 2
  {
    struct symtabs_and_lines values;
d2024 1
a2024 7
    values = decode_objc (self, argptr);
    if (values.sals != NULL)
      {
	do_cleanups (cleanup);
	return values;
      }
  }
d2026 2
a2027 1
  /* Does it look like there actually were two parts?  */
d2029 2
a2030 1
  if (p[0] == ':' || p[0] == '.')
d2032 1
a2032 22
      /* Is it a C++ or Java compound data structure?
	 The check on p[1] == ':' is capturing the case of "::",
	 since p[0]==':' was checked above.
	 Note that the call to decode_compound does everything
	 for us, including the lookup on the symbol table, so we
	 can return now.  */
	
      if (p[0] == '.' || p[1] == ':')
	{
	 /* We only perform this check for the languages where it might
	    make sense.  For instance, Ada does not use this type of
	    syntax, and trying to apply this logic on an Ada linespec
	    may trigger a spurious error (for instance, decode_compound
	    does not like expressions such as `ops."<"', which is a
	    valid function name in Ada).  */
	  if (current_language->la_language == language_c
	      || current_language->la_language == language_cplus
	      || current_language->la_language == language_java)
	    {
	      struct symtabs_and_lines values;
	      volatile struct gdb_exception ex;
	      char *saved_argptr = *argptr;
d2034 15
a2048 2
	      if (is_quote_enclosed)
		++saved_arg;
d2050 2
a2051 2
	      /* Initialize it just to avoid a GCC false warning.  */
	      memset (&values, 0, sizeof (values));
d2053 5
a2057 6
	      TRY_CATCH (ex, RETURN_MASK_ERROR)
		{
		  values = decode_compound (self, argptr, saved_arg, p);
		}
	      if ((is_quoted || is_squote_enclosed) && **argptr == '\'')
		*argptr = *argptr + 1;
d2059 2
a2060 5
	      if (ex.reason >= 0)
		{
		  do_cleanups (cleanup);
		  return values;
		}
d2062 5
a2066 2
	      if (ex.error != NOT_FOUND_ERROR)
		throw_exception (ex);
d2068 3
a2070 4
	      *argptr = saved_argptr;
	    }
	}
      else
d2072 1
a2072 7
	  /* If there was an exception looking up a specified filename earlier,
	     then check whether we were really given `function:label'.   */
	  if (file_exception.reason < 0)
	    {
	      function_symbols = find_function_symbols (argptr, p,
							is_quote_enclosed,
							&self->user_function);
d2074 2
a2075 4
	      /* If we did not find a function, re-throw the original
		 exception.  */
	      if (!function_symbols)
		throw_exception (file_exception);
d2077 2
a2078 2
	      make_cleanup (VEC_cleanup (symbolp), &function_symbols);
	    }
d2080 1
a2080 10
	  /* Check for single quotes on the non-filename part.  */
	  if (!is_quoted)
	    {
	      is_quoted = (**argptr
			   && strchr (get_gdb_completer_quote_characters (),
				      **argptr) != NULL);
	      if (is_quoted)
		end_quote = skip_quoted (*argptr);
	    }
	}
d2082 2
d2085 3
a2087 5
  /* self->file_symtabs holds the  specified file symtabs, or 0 if no file
     specified.
     If we are parsing `function:symbol', then FUNCTION_SYMBOLS holds the
     functions before the `:'.
     arg no longer contains the file name.  */
d2089 1
a2089 3
  /* If the filename was quoted, we must re-check the quotation.  */

  if (end_quote == first_half && *end_quote!= '\0')
d2091 1
a2091 6
      is_quoted = (**argptr
		   && strchr (get_gdb_completer_quote_characters (),
			      **argptr) != NULL);
      if (is_quoted)
	end_quote = skip_quoted (*argptr);
    }
d2093 3
a2095 1
  /* Check whether arg is all digits (and sign).  */
d2097 6
a2102 5
  q = *argptr;
  if (*q == '-' || *q == '+')
    q++;
  while (*q >= '0' && *q <= '9')
    q++;
d2104 4
a2107 4
  if (q != *argptr && (*q == 0 || *q == ' ' || *q == '\t' || *q == ',')
      && function_symbols == NULL)
    {
      struct symtabs_and_lines values;
d2109 2
a2110 5
      /* We found a token consisting of all digits -- at least one digit.  */
      values = decode_all_digits (self, argptr, q);
      do_cleanups (cleanup);
      return values;
    }
d2112 7
a2118 2
  /* Arg token is not digits => try it as a variable name
     Find the next token (everything up to end or next whitespace).  */
d2120 3
a2122 8
  if (**argptr == '$')		/* May be a convenience variable.  */
    /* One or two $ chars possible.  */
    p = skip_quoted (*argptr + (((*argptr)[1] == '$') ? 2 : 1));
  else if (is_quoted || is_squote_enclosed)
    {
      p = end_quote;
      if (p[-1] != '\'')
	error (_("Unmatched single quote."));
d2124 3
a2126 1
  else if (is_objc_method)
d2128 4
a2131 2
      /* allow word separators in method names for Obj-C.  */
      p = skip_quoted_chars (*argptr, NULL, "");
d2135 2
a2136 16
      p = skip_quoted (*argptr);
    }

  /* Keep any important naming information.  */
  p = keep_name_info (p, p == saved_arg || is_linespec_boundary (p[-1]));

  copy = (char *) alloca (p - *argptr + 1);
  memcpy (copy, *argptr, p - *argptr);
  copy[p - *argptr] = '\0';
  if (p != *argptr
      && copy[0]
      && copy[0] == copy[p - *argptr - 1]
      && strchr (get_gdb_completer_quote_characters (), copy[0]) != NULL)
    {
      copy[p - *argptr - 1] = '\0';
      copy++;
a2137 4
  else if (is_quoted || is_squote_enclosed)
    copy[p - *argptr - 1] = '\0';
  
  *argptr = skip_spaces (p);
d2139 2
a2140 3
  /* If it starts with $: may be a legitimate variable or routine name
     (e.g. HP-UX millicode routines such as $$dyncall), or it may
     be history value, or it may be a convenience variable.  */
d2142 4
a2145 1
  if (*copy == '$' && function_symbols == NULL)
d2147 4
a2150 1
      struct symtabs_and_lines values;
d2152 3
a2154 3
      values = decode_dollar (self, copy);
      do_cleanups (cleanup);
      return values;
d2157 1
a2157 13
  /* Try the token as a label, but only if no file was specified,
     because we can only really find labels in the current scope.  */

  if (VEC_length (symtab_p, self->file_symtabs) == 1
      && VEC_index (symtab_p, self->file_symtabs, 0) == NULL)
    {
      struct symtabs_and_lines label_result;
      if (decode_label (self, function_symbols, copy, &label_result))
	{
	  do_cleanups (cleanup);
	  return label_result;
	}
    }
d2159 5
a2163 2
  if (function_symbols)
    throw_exception (file_exception);
d2165 3
a2167 2
  /* Look up that token as a variable.
     If file specified, use that file's per-file block to start with.  */
d2169 2
a2170 2
  {
    struct symtabs_and_lines values;
a2171 5
    values = decode_variable (self, copy);
    do_cleanups (cleanup);
    return values;
  }
}
d2177 1
a2177 1
			    int flags,
d2183 1
d2194 16
d2213 1
a2213 1
linespec_state_destructor (void *arg)
d2215 21
a2235 1
  struct linespec_state *self = arg;
d2237 13
a2249 4
  xfree (self->user_filename);
  xfree (self->user_function);
  VEC_free (symtab_p, self->file_symtabs);
  htab_delete (self->addr_set);
a2261 1
  struct linespec_state state;
d2265 2
d2277 3
a2279 3
  linespec_state_constructor (&state, flags,
			      default_symtab, default_line, canonical);
  cleanups = make_cleanup (linespec_state_destructor, &state);
d2282 2
a2283 1
  result = decode_line_internal (&state, argptr);
d2294 3
a2296 3
      if (state.canonical_names == NULL)
	state.canonical_names = xcalloc (result.nelts, sizeof (char *));
      make_cleanup (xfree, state.canonical_names);
d2299 4
a2302 4
	  if (state.canonical_names[i] == NULL)
	    state.canonical_names[i] = savestring (arg_start,
						   *argptr - arg_start);
	  make_cleanup (xfree, state.canonical_names[i]);
d2320 1
a2320 1
	  filter_results (&state, &result, filters);
d2323 1
a2323 1
	convert_results_to_lsals (&state, &result);
d2326 1
a2326 1
    decode_line_2 (&state, &result, select_mode);
d2337 1
a2337 1
  struct linespec_state state;
d2340 3
a2342 3
  linespec_state_constructor (&state, flags,
			      default_symtab, default_line, NULL);
  cleanups = make_cleanup (linespec_state_destructor, &state);
d2345 2
a2346 1
  result = decode_line_internal (&state, argptr);
d2374 2
a2375 1
/* Decode arg of the form *PC.  */
d2377 2
a2378 2
static struct symtabs_and_lines
decode_indirect (struct linespec_state *self, char **argptr)
a2379 4
  struct symtabs_and_lines values;
  CORE_ADDR pc;
  char *initial = *argptr;
  
d2386 2
a2387 157
  (*argptr)++;
  pc = value_as_address (parse_to_comma_and_eval (argptr));

  values.sals = (struct symtab_and_line *)
    xmalloc (sizeof (struct symtab_and_line));

  values.nelts = 1;
  values.sals[0] = find_pc_line (pc, 0);
  values.sals[0].pc = pc;
  values.sals[0].section = find_pc_overlay (pc);
  values.sals[0].explicit_pc = 1;

  if (self->canonical)
    self->canonical->addr_string = savestring (initial, *argptr - initial);

  return values;
}



/* Locate the first half of the linespec, ending in a colon, period,
   or whitespace.  (More or less.)  Also, check to see if *ARGPTR is
   enclosed in double quotes; if so, set is_quote_enclosed, advance
   ARGPTR past that and zero out the trailing double quote.
   If ARGPTR is just a simple name like "main", p will point to ""
   at the end.  */

static char *
locate_first_half (char **argptr, int *is_quote_enclosed)
{
  char *ii;
  char *p, *p1;
  int has_comma;

  /* Check if the linespec starts with an Ada operator (such as "+",
     or ">", for instance).  */
  p = *argptr;
  if (p[0] == '"'
      && current_language->la_language == language_ada)
    {
      const struct ada_opname_map *op;

      for (op = ada_opname_table; op->encoded != NULL; op++)
        if (strncmp (op->decoded, p, strlen (op->decoded)) == 0)
	  break;
      if (op->encoded != NULL)
	{
	  *is_quote_enclosed = 0;
	  return p + strlen (op->decoded);
	}
    }

  /* Maybe we were called with a line range FILENAME:LINENUM,FILENAME:LINENUM
     and we must isolate the first half.  Outer layers will call again later
     for the second half.

     Don't count commas that appear in argument lists of overloaded
     functions, or in quoted strings.  It's stupid to go to this much
     trouble when the rest of the function is such an obvious roach hotel.  */
  ii = find_toplevel_char (*argptr, ',');
  has_comma = (ii != 0);

  /* Temporarily zap out second half to not confuse the code below.
     This is undone below.  Do not change ii!!  */
  if (has_comma)
    {
      *ii = '\0';
    }

  /* Maybe arg is FILE : LINENUM or FILE : FUNCTION.  May also be
     CLASS::MEMBER, or NAMESPACE::NAME.  Look for ':', but ignore
     inside of <>.  */

  p = *argptr;
  if (p[0] == '"')
    {
      *is_quote_enclosed = 1;
      (*argptr)++;
      p++;
    }
  else
    {
      *is_quote_enclosed = 0;
      if (strchr (get_gdb_completer_quote_characters (), *p))
	{
	  ++(*argptr);
	  ++p;
	}
    }


  /* Check for a drive letter in the filename.  This is done on all hosts
     to capture cross-compilation environments.  On Unixen, directory
     separators are illegal in filenames, so if the user enters "e:/foo.c",
     he is referring to a directory named "e:" and a source file named
     "foo.c", and we still want to keep these two pieces together.  */
  if (isalpha (p[0]) && p[1] == ':' && IS_DIR_SEPARATOR (p[2]))
    p += 3;

  for (; *p; p++)
    {
      if (p[0] == '<')
	{
	  char *temp_end = find_template_name_end (p);

	  if (!temp_end)
	    error (_("malformed template specification in command"));
	  p = temp_end;
	}

      if (p[0] == '(')
	p = find_method_overload_end (p);

      /* Check for a colon and a plus or minus and a [ (which
         indicates an Objective-C method).  */
      if (is_objc_method_format (p))
	{
	  break;
	}
      /* Check for the end of the first half of the linespec.  End of
         line, a tab, a colon or a space.  But if enclosed in double
	 quotes we do not break on enclosed spaces.  */
      if (!*p
	  || p[0] == '\t'
	  || (p[0] == ':')
	  || ((p[0] == ' ') && !*is_quote_enclosed))
	break;
      if (p[0] == '.' && strchr (p, ':') == NULL)
	{
	  /* Java qualified method.  Find the *last* '.', since the
	     others are package qualifiers.  Stop at any open parenthesis
	     which might provide overload information.  */
	  for (p1 = p; *p1 && *p1 != '('; p1++)
	    {
	      if (*p1 == '.')
		p = p1;
	    }
	  break;
	}
    }
  p = skip_spaces (p);

  /* If the closing double quote was left at the end, remove it.  */
  if (*is_quote_enclosed)
    {
      char *closing_quote = strchr (p - 1, '"');

      if (closing_quote && closing_quote[1] == '\0')
	*closing_quote = '\0';
    }

  /* Now that we've safely parsed the first half, put back ',' so
     outer layers can see it.  */
  if (has_comma)
    *ii = ',';

  return p;
d2400 1
a2400 1
decode_objc (struct linespec_state *self, char **argptr)
d2404 1
d2410 6
a2415 2
  info.result.sals = NULL;
  info.result.nelts = 0;
d2421 1
a2421 1
      return info.result;
d2426 2
a2427 1
  if (info.result.nelts > 0)
d2435 4
d2442 1
a2442 1
	  if (self->user_filename)
d2444 1
a2444 1
	      = xstrprintf ("%s:%s", self->user_filename, saved_arg);
a2452 2
  return info.result;
}
d2454 1
a2454 232
/* This handles C++ and Java compound data structures.  P should point
   at the first component separator, i.e. double-colon or period.  As
   an example, on entrance to this function we could have ARGPTR
   pointing to "AAA::inA::fun" and P pointing to "::inA::fun".  */

static struct symtabs_and_lines
decode_compound (struct linespec_state *self,
		 char **argptr, char *the_real_saved_arg, char *p)
{
  struct symtabs_and_lines values;
  char *p2;
  char *saved_arg2 = *argptr;
  char *temp_end;
  struct symbol *sym;
  char *copy;
  VEC (symbolp) *sym_classes;
  char *saved_arg, *class_name;
  struct cleanup *cleanup = make_cleanup (null_cleanup, NULL);

  /* If the user specified any completer quote characters in the input,
     strip them.  They are superfluous.  */
  saved_arg = alloca (strlen (the_real_saved_arg) + 1);
  {
    char *dst = saved_arg;
    char *src = the_real_saved_arg;
    char *quotes = get_gdb_completer_quote_characters ();
    while (*src != '\0')
      {
	if (strchr (quotes, *src) == NULL)
	  *dst++ = *src;
	++src;
      }
    *dst = '\0';
  }

  /* First check for "global" namespace specification, of the form
     "::foo".  If found, skip over the colons and jump to normal
     symbol processing.  I.e. the whole line specification starts with
     "::" (note the condition that *argptr == p).  */
  if (p[0] == ':' 
      && ((*argptr == p) || (p[-1] == ' ') || (p[-1] == '\t')))
    saved_arg2 += 2;

  /* Given our example "AAA::inA::fun", we have two cases to consider:

     1) AAA::inA is the name of a class.  In that case, presumably it
        has a method called "fun"; we then look up that method using
        find_method.

     2) AAA::inA isn't the name of a class.  In that case, either the
        user made a typo, AAA::inA is the name of a namespace, or it is
        the name of a minimal symbol.
	In this case we just delegate to decode_variable.

     Thus, our first task is to find everything before the last set of
     double-colons and figure out if it's the name of a class.  So we
     first loop through all of the double-colons.  */

  p2 = p;		/* Save for restart.  */

  /* This is very messy.  Following the example above we have now the
     following pointers:
     p -> "::inA::fun"
     argptr -> "AAA::inA::fun
     saved_arg -> "AAA::inA::fun
     saved_arg2 -> "AAA::inA::fun
     p2 -> "::inA::fun".  */

  /* In the loop below, with these strings, we'll make 2 passes, each
     is marked in comments.  */

  while (1)
    {
      static char *break_characters = " \t(";

      /* Move pointer up to next possible class/namespace token.  */

      p = p2 + 1;	/* Restart with old value +1.  */

      /* PASS1: at this point p2->"::inA::fun", so p->":inA::fun",
	 i.e. if there is a double-colon, p will now point to the
	 second colon.  */
      /* PASS2: p2->"::fun", p->":fun" */

      /* Move pointer ahead to next double-colon.  */
      while (*p
	     && strchr (break_characters, *p) == NULL
	     && strchr (get_gdb_completer_quote_characters (), *p) == NULL)
	{
	  if (current_language->la_language == language_cplus)
	    p += cp_validate_operator (p);

	  if (p[0] == '<')
	    {
	      temp_end = find_template_name_end (p);
	      if (!temp_end)
		error (_("malformed template specification in command"));
	      p = temp_end;
	    }
	  /* Note that, since, at the start of this loop, p would be
	     pointing to the second colon in a double-colon, we only
	     satisfy the condition below if there is another
	     double-colon to the right (after).  I.e. there is another
	     component that can be a class or a namespace.  I.e, if at
	     the beginning of this loop (PASS1), we had
	     p->":inA::fun", we'll trigger this when p has been
	     advanced to point to "::fun".  */
	  /* PASS2: we will not trigger this.  */
	  else if ((p[0] == ':') && (p[1] == ':'))
	    break;	/* Found double-colon.  */
	  else
	    {
	      /* PASS2: We'll keep getting here, until P points to one of the
		 break characters, at which point we exit this loop.  */
	      if (*p)
		{
		  if (p[1] == '('
		      && strncmp (&p[1], CP_ANONYMOUS_NAMESPACE_STR,
				  CP_ANONYMOUS_NAMESPACE_LEN) == 0)
		    p += CP_ANONYMOUS_NAMESPACE_LEN;
		  else if (strchr (break_characters, *p) == NULL)
		    ++p;
		}
	    }
	}

      if (*p != ':')
	break;		/* Out of the while (1).  This would happen
			   for instance if we have looked up
			   unsuccessfully all the components of the
			   string, and p->""(PASS2).  */

      /* We get here if p points to one of the break characters or "" (i.e.,
	 string ended).  */
      /* Save restart for next time around.  */
      p2 = p;
      /* Restore argptr as it was on entry to this function.  */
      *argptr = saved_arg2;
      /* PASS1: at this point p->"::fun" argptr->"AAA::inA::fun",
	 p2->"::fun".  */

      /* All ready for next pass through the loop.  */
    }			/* while (1) */


  /* Start of lookup in the symbol tables.  */

  /* Lookup in the symbol table the substring between argptr and
     p.  Note, this call changes the value of argptr.  */
  /* Before the call, argptr->"AAA::inA::fun",
     p->"", p2->"::fun".  After the call: argptr->"fun", p, p2
     unchanged.  */
  sym_classes = lookup_prefix_sym (argptr, p2, self->file_symtabs,
				   &class_name);
  make_cleanup (VEC_cleanup (symbolp), &sym_classes);
  make_cleanup (xfree, class_name);

  /* If a class has been found, then we're in case 1 above.  So we
     look up "fun" as a method of those classes.  */
  if (!VEC_empty (symbolp, sym_classes))
    {
      /* Arg token is not digits => try it as a function name.
	 Find the next token (everything up to end or next
	 blank).  */
      if (**argptr
	  && strchr (get_gdb_completer_quote_characters (),
		     **argptr) != NULL)
	{
	  p = skip_quoted (*argptr);
	  *argptr = *argptr + 1;
	}
      else
	{
	  /* At this point argptr->"fun".  */
	  char *a;

	  p = *argptr;
	  while (*p && *p != ' ' && *p != '\t' && *p != ',' && *p != ':'
		 && *p != '(')
	    p++;
	  /* At this point p->"".  String ended.  */
	  /* Nope, C++ operators could have spaces in them
	     ("foo::operator <" or "foo::operator delete []").
	     I apologize, this is a bit hacky...  */
	  if (current_language->la_language == language_cplus
	      && *p == ' ' && p - 8 - *argptr + 1 > 0)
	    {
	      /* The above loop has already swallowed "operator".  */
	      p += cp_validate_operator (p - 8) - 8;
	    }

	  /* Keep any important naming information.  */
	  p = keep_name_info (p, 1);
	}

      /* Allocate our own copy of the substring between argptr and
	 p.  */
      copy = (char *) alloca (p - *argptr + 1);
      memcpy (copy, *argptr, p - *argptr);
      copy[p - *argptr] = '\0';
      if (p != *argptr
	  && copy[p - *argptr - 1]
	  && strchr (get_gdb_completer_quote_characters (),
		     copy[p - *argptr - 1]) != NULL)
	copy[p - *argptr - 1] = '\0';

      /* At this point copy->"fun", p->"".  */

      /* No line number may be specified.  */
      *argptr = skip_spaces (p);
      /* At this point arptr->"".  */

      /* Look for copy as a method of sym_class.  */
      /* At this point copy->"fun", sym_class is "AAA:inA",
	 saved_arg->"AAA::inA::fun".  This concludes the scanning of
	 the string for possible components matches.  If we find it
	 here, we return.  If not, and we are at the and of the string,
	 we'll lookup the whole string in the symbol tables.  */

      values = find_method (self, saved_arg, copy, class_name, sym_classes);

      do_cleanups (cleanup);
      return values;
    } /* End if symbol found.  */


  /* We couldn't find a class, so we're in case 2 above.  We check the
     entire name as a symbol instead.  The simplest way to do this is
     to just throw an exception and let our caller fall through to
     decode_variable.  */

  throw_error (NOT_FOUND_ERROR, _("see caller, this text doesn't matter"));
d2500 1
a2500 6
/* Return the symbol corresponding to the substring of *ARGPTR ending
   at P, allowing whitespace.  Also, advance *ARGPTR past the symbol
   name in question, the compound object separator ("::" or "."), and
   whitespace.  Note that *ARGPTR is changed whether or not the
   this call finds anything (i.e we return NULL).  As an
   example, say ARGPTR is "AAA::inA::fun" and P is "::inA::fun".  */
d2503 2
a2504 2
lookup_prefix_sym (char **argptr, char *p, VEC (symtab_p) *file_symtabs,
		   char **class_name)
a2505 2
  char *p1;
  char *copy;
a2510 19
  struct block *search_block;

  /* Extract the class name.  */
  p1 = p;
  while (p != *argptr && p[-1] == ' ')
    --p;
  copy = (char *) xmalloc (p - *argptr + 1);
  memcpy (copy, *argptr, p - *argptr);
  copy[p - *argptr] = 0;
  *class_name = copy;
  outer = make_cleanup (xfree, copy);

  /* Discard the class name from the argptr.  */
  p = p1 + (p1[0] == ':' ? 2 : 1);
  p = skip_spaces (p);
  *argptr = p;

  /* At this point p1->"::inA::fun", p->"inA::fun" copy->"AAA",
     argptr->"inA::fun".  */
d2513 1
a2513 1
  make_cleanup (VEC_cleanup (symbolp), &collector.symbols);
d2524 1
a2524 1
	  iterate_over_all_matching_symtabs (copy, STRUCT_DOMAIN,
d2527 1
a2527 1
	  iterate_over_all_matching_symtabs (copy, VAR_DOMAIN,
d2538 40
a2577 8
	  set_current_program_space (SYMTAB_PSPACE (elt));
	  search_block = get_search_block (elt);
	  LA_ITERATE_OVER_SYMBOLS (search_block, copy, STRUCT_DOMAIN,
				   collect_one_symbol, &collector);
	  LA_ITERATE_OVER_SYMBOLS (search_block, copy, VAR_DOMAIN,
				   collect_one_symbol, &collector);
	}
    }
d2579 1
a2579 3
  do_cleanups (cleanup);
  discard_cleanups (outer);
  return collector.symbols;
d2582 1
a2582 3
/* A qsort comparison function for symbols.  The resulting order does
   not actually matter; we just need to be able to sort them so that
   symbols with the same program space end up next to each other.  */
d2585 1
a2585 1
compare_symbols (const void *a, const void *b)
d2587 2
a2588 2
  struct symbol * const *sa = a;
  struct symbol * const *sb = b;
d2591 2
a2592 2
  uia = (uintptr_t) SYMTAB_PSPACE (SYMBOL_SYMTAB (*sa));
  uib = (uintptr_t) SYMTAB_PSPACE (SYMBOL_SYMTAB (*sb));
d2657 3
a2659 2
/* This finds the method COPY in the class whose type is given by one
   of the symbols in SYM_CLASSES.  */
d2661 5
a2665 3
static struct symtabs_and_lines
find_method (struct linespec_state *self, char *saved_arg,
	     char *copy, const char *class_name, VEC (symbolp) *sym_classes)
a2666 1
  char *canon;
a2675 9
  /* NAME is typed by the user: it needs to be canonicalized before
     searching the symbol tables.  */
  canon = cp_canonicalize_string_no_typedefs (copy);
  if (canon != NULL)
    {
      copy = canon;
      make_cleanup (xfree, copy);
    }

d2684 3
a2686 2
  info.result.sals = NULL;
  info.result.nelts = 0;
d2689 1
a2689 1
     methods matching COPY.  If we cannot find a direct method in a
d2713 1
a2713 1
      find_methods (t, copy, &result_names, &superclass_vec);
d2725 2
a2726 1
	    find_superclass_methods (superclass_vec, copy, &result_names);
d2738 2
a2739 1
  if (info.result.nelts > 0)
d2741 2
a2742 10
      if (self->canonical)
	{
	  self->canonical->pre_expanded = 1;
	  if (self->user_filename)
	    self->canonical->addr_string
	      = xstrprintf ("%s:%s", self->user_filename, saved_arg);
	  else
	    self->canonical->addr_string = xstrdup (saved_arg);
	}

d2744 1
a2744 2

      return info.result;
d2747 3
a2749 8
  if (copy[0] == '~')
    cplusplus_error (saved_arg,
		     "the class `%s' does not have destructor defined\n",
		     class_name);
  else
    cplusplus_error (saved_arg,
		     "the class %s does not have any method named %s\n",
		     class_name, copy);
d2811 1
a2811 3
/* Return all the symtabs associated to the filename given by the
   substring of *ARGPTR ending at P, and advance ARGPTR past that
   filename.  */
d2814 1
a2814 2
symtabs_from_filename (char **argptr, char *p, int is_quote_enclosed,
		       char **user_filename)
a2815 3
  char *p1;
  char *copy;
  struct cleanup *outer;
d2818 1
a2818 324
  p1 = p;
  while (p != *argptr && p[-1] == ' ')
    --p;
  if ((*p == '"') && is_quote_enclosed)
    --p;
  copy = xmalloc (p - *argptr + 1);
  outer = make_cleanup (xfree, copy);
  memcpy (copy, *argptr, p - *argptr);
  /* It may have the ending quote right after the file name.  */
  if ((is_quote_enclosed && copy[p - *argptr - 1] == '"')
      || copy[p - *argptr - 1] == '\'')
    copy[p - *argptr - 1] = 0;
  else
    copy[p - *argptr] = 0;

  result = collect_symtabs_from_filename (copy);

  if (VEC_empty (symtab_p, result))
    {
      if (!have_full_symbols () && !have_partial_symbols ())
	throw_error (NOT_FOUND_ERROR,
		     _("No symbol table is loaded.  "
		       "Use the \"file\" command."));
      throw_error (NOT_FOUND_ERROR, _("No source file named %s."), copy);
    }

  /* Discard the file name from the arg.  */
  if (*p1 == '\0')
    *argptr = p1;
  else
    *argptr = skip_spaces (p1 + 1);

  discard_cleanups (outer);
  *user_filename = copy;
  return result;
}

/* A callback used by iterate_over_all_matching_symtabs that collects
   symbols for find_function_symbols.  */

static int
collect_function_symbols (struct symbol *sym, void *arg)
{
  VEC (symbolp) **syms = arg;

  if (SYMBOL_CLASS (sym) == LOC_BLOCK)
    VEC_safe_push (symbolp, *syms, sym);

  return 1; /* Continue iterating.  */
}

/* Look up a function symbol in *ARGPTR.  If found, advance *ARGPTR
   and return the symbol.  If not found, return NULL.  */

static VEC (symbolp) *
find_function_symbols (char **argptr, char *p, int is_quote_enclosed,
		       char **user_function)
{
  char *p1;
  char *copy;
  VEC (symbolp) *result = NULL;

  p1 = p;
  while (p != *argptr && p[-1] == ' ')
    --p;
  if ((*p == '"') && is_quote_enclosed)
    --p;
  copy = (char *) xmalloc (p - *argptr + 1);
  *user_function = copy;
  memcpy (copy, *argptr, p - *argptr);
  /* It may have the ending quote right after the file name.  */
  if ((is_quote_enclosed && copy[p - *argptr - 1] == '"')
      || copy[p - *argptr - 1] == '\'')
    copy[p - *argptr - 1] = 0;
  else
    copy[p - *argptr] = 0;

  iterate_over_all_matching_symtabs (copy, VAR_DOMAIN,
				     collect_function_symbols, &result, NULL,
				     0);

  if (VEC_empty (symbolp, result))
    VEC_free (symbolp, result);
  else
    {
      /* Discard the file name from the arg.  */
      *argptr = skip_spaces (p1 + 1);
    }

  return result;
}



/* A helper for decode_all_digits that handles the 'list_mode' case.  */

static void
decode_digits_list_mode (struct linespec_state *self,
			 struct symtabs_and_lines *values,
			 struct symtab_and_line val)
{
  int ix;
  struct symtab *elt;

  gdb_assert (self->list_mode);

  for (ix = 0; VEC_iterate (symtab_p, self->file_symtabs, ix, elt); ++ix)
    {
      /* The logic above should ensure this.  */
      gdb_assert (elt != NULL);

      set_current_program_space (SYMTAB_PSPACE (elt));

      /* Simplistic search just for the list command.  */
      val.symtab = find_line_symtab (elt, val.line, NULL, NULL);
      if (val.symtab == NULL)
	val.symtab = elt;
      val.pspace = SYMTAB_PSPACE (elt);
      val.pc = 0;
      val.explicit_line = 1;

      add_sal_to_sals (self, values, &val, NULL);
    }
}

/* A helper for decode_all_digits that iterates over the symtabs,
   adding lines to the VEC.  */

static void
decode_digits_ordinary (struct linespec_state *self,
			int line,
			struct symtabs_and_lines *sals,
			struct linetable_entry **best_entry)
{
  int ix;
  struct symtab *elt;

  for (ix = 0; VEC_iterate (symtab_p, self->file_symtabs, ix, elt); ++ix)
    {
      int i;
      VEC (CORE_ADDR) *pcs;
      CORE_ADDR pc;

      /* The logic above should ensure this.  */
      gdb_assert (elt != NULL);

      set_current_program_space (SYMTAB_PSPACE (elt));

      pcs = find_pcs_for_symtab_line (elt, line, best_entry);
      for (i = 0; VEC_iterate (CORE_ADDR, pcs, i, pc); ++i)
	{
	  struct symtab_and_line sal;

	  init_sal (&sal);
	  sal.pspace = SYMTAB_PSPACE (elt);
	  sal.symtab = elt;
	  sal.line = line;
	  sal.pc = pc;
	  add_sal_to_sals_basic (sals, &sal);
	}

      VEC_free (CORE_ADDR, pcs);
    }
}

/* This decodes a line where the argument is all digits (possibly
   preceded by a sign).  Q should point to the end of those digits;
   the other arguments are as usual.  */

static struct symtabs_and_lines
decode_all_digits (struct linespec_state *self,
		   char **argptr,
		   char *q)
{
  struct symtabs_and_lines values;
  struct symtab_and_line val;
  int use_default = 0;
  char *saved_arg = *argptr;

  enum sign
    {
      none, plus, minus
    }
  sign = none;

  init_sal (&val);
  values.sals = NULL;
  values.nelts = 0;

  /* This is where we need to make sure that we have good defaults.
     We must guarantee that this section of code is never executed
     when we are called with just a function name, since
     set_default_source_symtab_and_line uses
     select_source_symtab that calls us with such an argument.  */

  if (VEC_length (symtab_p, self->file_symtabs) == 1
      && VEC_index (symtab_p, self->file_symtabs, 0) == NULL)
    {
      set_current_program_space (self->program_space);

      /* Make sure we have at least a default source file.  */
      set_default_source_symtab_and_line ();
      initialize_defaults (&self->default_symtab, &self->default_line);
      VEC_pop (symtab_p, self->file_symtabs);
      VEC_free (symtab_p, self->file_symtabs);
      self->file_symtabs
	= collect_symtabs_from_filename (self->default_symtab->filename);
      use_default = 1;
    }

  if (**argptr == '+')
    sign = plus, (*argptr)++;
  else if (**argptr == '-')
    sign = minus, (*argptr)++;
  val.line = atoi (*argptr);
  switch (sign)
    {
    case plus:
      if (q == *argptr)
	val.line = 5;
      if (use_default)
	val.line = self->default_line + val.line;
      break;
    case minus:
      if (q == *argptr)
	val.line = 15;
      if (use_default)
	val.line = self->default_line - val.line;
      else
	val.line = 1;
      break;
    case none:
      break;		/* No need to adjust val.line.  */
    }

  *argptr = skip_spaces (q);

  if (self->list_mode)
    decode_digits_list_mode (self, &values, val);
  else
    {
      struct linetable_entry *best_entry = NULL;
      int *filter;
      struct block **blocks;
      struct cleanup *cleanup;
      struct symtabs_and_lines intermediate_results;
      int i, j;

      intermediate_results.sals = NULL;
      intermediate_results.nelts = 0;

      decode_digits_ordinary (self, val.line, &intermediate_results,
			      &best_entry);
      if (intermediate_results.nelts == 0 && best_entry != NULL)
	decode_digits_ordinary (self, best_entry->line, &intermediate_results,
				&best_entry);

      cleanup = make_cleanup (xfree, intermediate_results.sals);

      /* For optimized code, compiler can scatter one source line
	 accross disjoint ranges of PC values, even when no duplicate
	 functions or inline functions are involved.  For example,
	 'for (;;)' inside non-template non-inline non-ctor-or-dtor
	 function can result in two PC ranges.  In this case, we don't
	 want to set breakpoint on first PC of each range.  To filter
	 such cases, we use containing blocks -- for each PC found
	 above we see if there are other PCs that are in the same
	 block.  If yes, the other PCs are filtered out.  */

      filter = xmalloc (intermediate_results.nelts * sizeof (int));
      make_cleanup (xfree, filter);
      blocks = xmalloc (intermediate_results.nelts * sizeof (struct block *));
      make_cleanup (xfree, blocks);

      for (i = 0; i < intermediate_results.nelts; ++i)
	{
	  set_current_program_space (intermediate_results.sals[i].pspace);

	  filter[i] = 1;
	  blocks[i] = block_for_pc_sect (intermediate_results.sals[i].pc,
					 intermediate_results.sals[i].section);
	}

      for (i = 0; i < intermediate_results.nelts; ++i)
	{
	  if (blocks[i] != NULL)
	    for (j = i + 1; j < intermediate_results.nelts; ++j)
	      {
		if (blocks[j] == blocks[i])
		  {
		    filter[j] = 0;
		    break;
		  }
	      }
	}

      for (i = 0; i < intermediate_results.nelts; ++i)
	if (filter[i])
	  {
	    struct symbol *sym = (blocks[i]
				  ? block_containing_function (blocks[i])
				  : NULL);

	    if (self->funfirstline)
	      skip_prologue_sal (&intermediate_results.sals[i]);
	    /* Make sure the line matches the request, not what was
	       found.  */
	    intermediate_results.sals[i].line = val.line;
	    add_sal_to_sals (self, &values, &intermediate_results.sals[i],
			     sym ? SYMBOL_NATURAL_NAME (sym) : NULL);
	  }

      do_cleanups (cleanup);
    }

  if (values.nelts == 0)
    {
      if (self->user_filename)
	throw_error (NOT_FOUND_ERROR, _("No line %d in file \"%s\"."),
		     val.line, self->user_filename);
      else
	throw_error (NOT_FOUND_ERROR, _("No line %d in the current file."),
		     val.line);
    }
d2820 1
a2820 1
  if (self->canonical)
d2822 5
a2826 10
      char *copy = savestring (saved_arg, q - saved_arg);

      self->canonical->pre_expanded = 1;
      gdb_assert (self->user_filename || use_default);
      self->canonical->addr_string
	= xstrprintf ("%s:%s", (self->user_filename
				? self->user_filename
				: self->default_symtab->filename),
		      copy);
      xfree (copy);
d2829 1
a2829 1
  return values;
d2832 14
a2845 1

d2847 11
a2857 1
/* Decode a linespec starting with a dollar sign.  */
d2859 1
a2859 12
static struct symtabs_and_lines
decode_dollar (struct linespec_state *self, char *copy)
{
  LONGEST valx;
  int index = 0;
  struct symtabs_and_lines values;
  struct symtab_and_line val;
  char *p;
  struct symbol *sym;
  struct minimal_symbol *msymbol;
  int ix;
  struct symtab *elt;
d2861 1
a2861 4
  p = (copy[1] == '$') ? copy + 2 : copy + 1;
  while (*p >= '0' && *p <= '9')
    p++;
  if (!*p)		/* Reached end of token without hitting non-digit.  */
d2863 5
a2867 2
      /* We have a value history reference.  */
      struct value *val_history;
d2869 4
a2872 6
      sscanf ((copy[1] == '$') ? copy + 2 : copy + 1, "%d", &index);
      val_history = access_value_history ((copy[1] == '$') ? -index : index);
      if (TYPE_CODE (value_type (val_history)) != TYPE_CODE_INT)
	error (_("History values used in line "
		 "specs must have integer values."));
      valx = value_as_long (val_history);
d2875 2
a2876 3
    {
      /* Not all digits -- may be user variable/function or a
	 convenience variable.  */
d2878 2
a2879 1
      volatile struct gdb_exception exc;
d2881 12
a2892 3
      /* Avoid "may be used uninitialized" warning.  */
      values.sals = NULL;
      values.nelts = 0;
d2894 9
a2902 4
      TRY_CATCH (exc, RETURN_MASK_ERROR)
	{
	  values = decode_variable (self, copy);
	}
d2904 6
a2909 2
      if (exc.reason == 0)
	return values;
d2911 10
a2920 2
      if (exc.error != NOT_FOUND_ERROR)
	throw_exception (exc);
d2922 5
a2926 4
      /* Not a user variable or function -- must be convenience variable.  */
      if (!get_internalvar_integer (lookup_internalvar (copy + 1), &valx))
	error (_("Convenience variables used in line "
		 "specs must have integer values."));
d2929 8
a2936 1
  init_sal (&val);
d2938 29
a2966 6
  values.sals = NULL;
  values.nelts = 0;

  for (ix = 0; VEC_iterate (symtab_p, self->file_symtabs, ix, elt); ++ix)
    {
      if (elt == NULL)
d2968 2
a2969 2
	  elt = self->default_symtab;
	  set_current_program_space (self->program_space);
d2971 2
a2972 20
      else
	set_current_program_space (SYMTAB_PSPACE (elt));

      /* Either history value or convenience value from above, in valx.  */
      val.symtab = elt;
      val.line = valx;
      val.pc = 0;
      val.pspace = elt ? SYMTAB_PSPACE (elt) : current_program_space;

      add_sal_to_sals (self, &values, &val, NULL);
    }

  if (self->canonical)
    {
      self->canonical->pre_expanded = 1;
      if (self->user_filename)
	self->canonical->addr_string = xstrprintf ("%s:%s",
						   self->user_filename, copy);
      else
	self->canonical->addr_string = xstrdup (copy);
d2975 4
a2978 1
  return values;
d2981 2
a2982 11


/* A helper for decode_line_1 that tries to find a label.  The label
   is searched for in the current block.
   FUNCTION_SYMBOLS is a list of the enclosing functions; or NULL if none
   specified.
   COPY is the name of the label to find.
   CANONICAL is the same as the "canonical" argument to decode_line_1.
   RESULT is a pointer to a symtabs_and_lines structure which will be
   filled in on success.
   This function returns 1 if a label was found, 0 otherwise.  */
d2984 4
a2987 4
static int
decode_label (struct linespec_state *self,
	      VEC (symbolp) *function_symbols, char *copy,
	      struct symtabs_and_lines *result)
d2989 3
d2993 1
a2993 1
  int ix;
a2996 8
      struct block *block;
      struct symbol *sym;
      struct symtab_and_line sal;
      struct symtabs_and_lines values;

      values.nelts = 0;
      values.sals = NULL;

d3005 1
a3005 1
	return 0;
d3008 40
a3047 1
      sym = lookup_symbol (copy, block, LABEL_DOMAIN, 0);
d3049 1
a3049 2
      if (sym == NULL)
	return 0;
d3051 5
a3055 3
      symbol_to_sal (&sal, self->funfirstline, sym);
      add_sal_to_sals (self, &values, &sal,
		       SYMBOL_NATURAL_NAME (fn_sym));
d3057 1
a3057 7
      if (self->canonical)
	{
	  self->canonical->special_display = 1;
	  self->canonical->addr_string
	    = xstrprintf ("%s:%s", SYMBOL_NATURAL_NAME (fn_sym),
			  copy);
	}
d3059 7
a3065 1
      *result = values;
d3067 1
a3067 1
      return 1;
d3069 1
d3071 12
a3082 2
  result->sals = NULL;
  result->nelts = 0;
d3084 1
a3084 1
  for (ix = 0; VEC_iterate (symbolp, function_symbols, ix, fn_sym); ++ix)
d3086 6
a3091 2
      struct block *block;
      struct symbol *sym;
d3093 1
a3093 3
      set_current_program_space (SYMTAB_PSPACE (SYMBOL_SYMTAB (fn_sym)));
      block = SYMBOL_BLOCK_VALUE (fn_sym);
      sym = lookup_symbol (copy, block, LABEL_DOMAIN, 0);
d3095 2
a3096 1
      if (sym != NULL)
a3098 1
	  char *symname;
d3100 6
a3105 6
	  symbol_to_sal (&sal, self->funfirstline, sym);
	  symname = xstrprintf ("%s:%s",
				SYMBOL_NATURAL_NAME (fn_sym),
				SYMBOL_NATURAL_NAME (sym));
	  add_sal_to_sals (self, result, &sal, symname);
	  xfree (symname);
d3107 2
d3110 12
d3123 19
a3141 1
  if (self->canonical && result->nelts > 0)
d3143 4
a3146 2
      self->canonical->pre_expanded = 1;
      self->canonical->special_display = 1;
d3148 17
a3164 3
      gdb_assert (self->user_function);
      self->canonical->addr_string
	= xstrprintf ("%s:%s", self->user_function, copy);
d3167 1
a3167 1
  return result->nelts > 0;
d3169 1
a3176 8
  struct symtab_and_line sal;

  if (symbol_to_sal (&sal, info->state->funfirstline, sym)
      && maybe_add_address (info->state->addr_set,
			    SYMTAB_PSPACE (SYMBOL_SYMTAB (sym)),
			    sal.pc))
    add_sal_to_sals (info->state, &info->result, &sal,
		     SYMBOL_NATURAL_NAME (sym));
d3178 4
d3185 2
a3186 2
/* We've found a minimal symbol MSYMBOL to associate with our
   linespec; add it to the result symtabs_and_lines.  */
a3213 11
/* A helper struct which just holds a minimal symbol and the object
   file from which it came.  */

typedef struct minsym_and_objfile
{
  struct minimal_symbol *minsym;
  struct objfile *objfile;
} minsym_and_objfile_d;

DEF_VEC_O (minsym_and_objfile_d);

d3366 2
a3367 2
	    minsym_found (info->state, item->objfile, item->minsym,
			  &info->result);
d3387 1
a3387 1
  for (ix = 0; VEC_iterate (symtab_p, info->state->file_symtabs, ix, elt); ++ix)
d3393 1
a3393 1
	  iterate_over_all_matching_symtabs (name, VAR_DOMAIN,
a3410 61
/* Decode a linespec that's a variable.  If FILE_SYMTAB is non-NULL,
   look in that symtab's static variables first.  */ 

static struct symtabs_and_lines
decode_variable (struct linespec_state *self, char *copy)
{
  struct collect_info info;
  const char *lookup_name;
  char *canon;
  struct cleanup *cleanup;

  info.state = self;
  info.result.sals = NULL;
  info.result.nelts = 0;

  cleanup = demangle_for_lookup (copy, current_language->la_language,
				 &lookup_name);
  if (current_language->la_language == language_ada)
    {
      /* In Ada, the symbol lookups are performed using the encoded
         name rather than the demangled name.  */
      lookup_name = ada_name_for_lookup (copy);
      make_cleanup (xfree, (void *) lookup_name);
    }

  canon = cp_canonicalize_string_no_typedefs (lookup_name);
  if (canon != NULL)
    {
      make_cleanup (xfree, canon);
      lookup_name = canon;
    }

  add_matching_symbols_to_info (lookup_name, &info, NULL);

  if (info.result.nelts > 0)
    {
      if (self->canonical)
	{
	  self->canonical->pre_expanded = 1;
	  if (self->user_filename)
	    self->canonical->addr_string
	      = xstrprintf ("%s:%s", self->user_filename, copy);
	  else
	    self->canonical->addr_string = xstrdup (copy);
	}
      return info.result;
    }

  if (!have_full_symbols ()
      && !have_partial_symbols ()
      && !have_minimal_symbols ())
    throw_error (NOT_FOUND_ERROR,
		 _("No symbol table is loaded.  Use the \"file\" command."));
  if (self->user_filename)
    throw_error (NOT_FOUND_ERROR, _("Function \"%s\" not defined in \"%s\"."),
		 copy, self->user_filename);
  else
    throw_error (NOT_FOUND_ERROR, _("Function \"%s\" not defined."), copy);
}


@


1.152
log
@	* linespec.c (decode_line_2): Sort the list of methods
	alphabetically before presenting the user with a selection
	menu.
@
text
@d324 27
d378 2
a379 1
   space.  */
d386 2
a387 1
				   struct program_space *search_pspace)
d426 14
d1931 1
a1931 1
					     NULL);
d1934 1
a1934 1
					     NULL);
d2297 2
a2298 1
				     collect_function_symbols, &result, NULL);
d2999 1
a2999 1
					     pspace);
@


1.151
log
@	* linespec.c (decode_line_internal): Skip symtabs_from_filename
	when we have a C++ qualified name.
@
text
@d653 5
@


1.150
log
@gdb/
	* linespec.c (decode_line_internal): Fix comment correctness.
@
text
@d915 3
a917 1
     it can be expensive.  */
d919 1
a919 1
  if (*p != '\0')
@


1.149
log
@Rename la_get_symbol_name_match_p into la_get_symbol_name_cmp

The la_get_symbol_name_match_p language hook was poorly named, as
it suggested that the function should return nonzero if the names
match, whereas it is the exact opposite.  This patch therefore
renames the hook and associated typedef, as well some of the code
that uses that hook.

gdb/ChangeLog:

        * language.h (symbol_name_cmp_ftype): Renames
        symbol_name_match_p_ftype.
        (struct language_defn)[la_get_symbol_name_cmp]: Renames
        la_get_symbol_name_match_p.
        * ada-lang.c (ada_get_symbol_name_cmp): Renames
        ada_get_symbol_name_match_p.  Update comment.
        (ada_language_defn)[la_get_symbol_name_cmp]: Update value.
        * linespec.c (struct symbol_matcher_data)[symbol_name_cmp]:
        Renames symbol_name_match_p.  Update field type.
        (iterate_name_matcher, iterate_over_all_matching_symtabs): Adjust.
        * c-lang.c, d-lang.c, f-lang.c, jv-lang.c, m2-lang.c, objc-lang.c,
        opencl-lang.c, p-lang.c: Replace "la_get_symbol_name_match_p" by
        "la_get_symbol_name_cmp" in comments.
        * language.c: Likewise.
@
text
@d906 1
a906 1
     p will point at "123".  If there is only one part, like "foo", p
@


1.148
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@d332 1
a332 1
  symbol_name_match_p_ftype symbol_name_match_p;
d343 1
a343 1
  if (data->symbol_name_match_p (name, data->lookup_name) == 0)
d365 3
a367 3
  matcher_data.symbol_name_match_p =
    current_language->la_get_symbol_name_match_p != NULL
    ? current_language->la_get_symbol_name_match_p (name)
@


1.147
log
@2012-02-01  Gary Benson  <gbenson@@redhat.com>

	* symtab.h (symbol_name_match_p_ftype): New typedef.
	(iterate_over_symbols): Use the above.
	* symtab.c (iterate_over_symbols): Likewise.
	* language.h (language_defn->la_iterate_over_symbols): Likewise.
	* ada-lang.c (ada_iterate_over_symbols): Likewise.
	* linespec.c (iterate_over_all_matching_symtabs): Likewise.
	(iterate_name_matcher): Document return values.
	(collect_one_symbol): Likewise.
	(collect_function_symbols): Likewise.
	(collect_symbols): Likewise.
@
text
@d438 1
a438 2
  char *class_name = type_name_no_tag (t);
  char *canon;
d458 1
a458 1
	  char *method_name = TYPE_FN_FIELDLIST_NAME (t, method_counter);
@


1.146
log
@gdb/
	Fix the 2012-01-26 regression by la_get_symbol_name_match_p.
	* linespec.c (iterate_name_matcher): Negate the SYMBOL_NAME_MATCH_P
	result.
@
text
@d344 2
a345 2
    return 1;
  return 0;
d356 1
a356 1
				   int (*callback) (struct symbol *, void *),
d1811 1
a1811 1
    return 1;
d1818 1
a1818 1
    return 1;
d1827 1
a1827 1
  return 1;
d2218 1
a2218 1
  return 1;
d2725 1
a2725 1
  return 1;
@


1.145
log
@Remove language param from name_matcher in struct quick_symbol_functions

The quick_symbol_functions struct contains a field which is pointer
a function which takes another function, called name_matcher, as
its parameter.  This name_matcher currently has 3 arguments, one
of them being the language. This parameter is no longer used, and
thus deleted.

gdb/ChangeLog:

        * symfile.h (struct quick_symbol_functions) [expand_symtabs_matching]:
        Remove language parameter from name_matcher.  Adjust the comment.
        * symtab.c (search_symbols_name_matches, expand_partial_symbol_name):
        Remove language parameter.
        * ada-lang.c (ada_expand_partial_symbol_name): Likewise.
        * linespec.c (iterate_name_matcher): Likewise.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust type of
        name_matcher.  Adjust call accordingly.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (maintenance_check_symtabs): Adjust type of parameter "fun".
        * psymtab.h (maintenance_check_symtabs): Likewise.
@
text
@d343 1
a343 1
  if (data->symbol_name_match_p (name, data->lookup_name))
@


1.144
log
@Ada: allow unqualified function names in linespecs

This is the meat, where we replace the old la_symbol_name_compare
language method with the new ada_get_symbol_name_match_p.
It fixes the problem when trying to insert a breakpoint on "+".

gdb/ChangeLog:

        * language.h (symbol_name_match_p_ftype): New typedef.
        (struct language_defn): Replace field la_symbol_name_compare
        by la_get_symbol_name_match_p.
        * ada-lang.c (ada_get_symbol_name_match_p): New function.
        (ada_language_defn): Use it.
        * linespec.c (struct symbol_matcher_data): New type.
        (iterate_name_matcher): Rewrite.
        (iterate_over_all_matching_symtabs): Pass a pointer to
        a symbol_matcher_data struct to expand_symtabs_matching
        instead of just the lookup name.
        * c-lang.c, d-lang.c, jv-lang.c, m2-lang.c, objc-lang.c,
        opencl-lang.c, p-lang.c, language.c: Delete field
        la_symbol_name_compare, and replace by NULL for new field
        la_get_symbol_name_match_p.
        * symfile.h (struct quick_symbol_functions): Update comment.
@
text
@d339 1
a339 2
iterate_name_matcher (const struct language_defn *language,
		      const char *name, void *d)
@


1.143
log
@	* linespec.c (decode_line_internal): Don't call symtabs_from_filename
	if we know we don't have a file name to look for.
@
text
@d324 11
d342 1
a342 1
  const char **dname = d;
d344 1
a344 1
  if (language->la_symbol_name_compare (name, *dname) == 0)
d363 7
d388 1
a388 1
						  &name);
@


1.142
log
@do not call decode_compound with Ada expressions.

Trying to insert a breakpoint on `ops."<"', we get the following error:

    (gdb) b ops."<"
    malformed template specification in command

This is because locate_first_half skips the linespec until the dot,
and the decode_line_internal thinks that the dot might mean that
we have C++ or Java compound.  It then tries calling decode_compound
which errors out because it sees the opening angle bracket but not
the closing one (I am guessing).

This patch short-circuits this part of the code when the current
language is Ada.

gdb/ChangeLog:

        * linespec.c (decode_line_internal): Check for C++ or Java
        compound constructs only if the current language is C, C++
        or Java.
@
text
@d897 5
a901 2
     symtab and strip the filename from ARGPTR.  */
  TRY_CATCH (file_exception, RETURN_MASK_ERROR)
d903 25
a927 2
      self->file_symtabs = symtabs_from_filename (argptr, p, is_quote_enclosed,
						  &self->user_filename);
d929 1
a929 2

  if (VEC_empty (symtab_p, self->file_symtabs))
a934 13
  if (file_exception.reason >= 0)
    {
      /* Check for single quotes on the non-filename part.  */
      is_quoted = (**argptr
		   && strchr (get_gdb_completer_quote_characters (),
			      **argptr) != NULL);
      if (is_quoted)
	end_quote = skip_quoted (*argptr);

      /* Locate the next "half" of the linespec.  */
      first_half = p = locate_first_half (argptr, &is_quote_enclosed);
    }

@


1.141
log
@linespec: keep function descriptors during minimal symbol search

When discarding data (minimal) symbols, we need to be careful to
not throw away the function descriptors.  This makes a difference
on platforms where these descriptors are used and live in a data
section.

gdb/ChangeLog:

        * linespec.c (add_minsym): Preserve function descriptors.
@
text
@d954 13
a966 3
	  struct symtabs_and_lines values;
	  volatile struct gdb_exception ex;
	  char *saved_argptr = *argptr;
d968 2
a969 2
	  if (is_quote_enclosed)
	    ++saved_arg;
d971 2
a972 2
	  /* Initialize it just to avoid a GCC false warning.  */
	  memset (&values, 0, sizeof (values));
d974 6
a979 6
	  TRY_CATCH (ex, RETURN_MASK_ERROR)
	    {
	      values = decode_compound (self, argptr, saved_arg, p);
	    }
	  if ((is_quoted || is_squote_enclosed) && **argptr == '\'')
	    *argptr = *argptr + 1;
d981 5
a985 5
	  if (ex.reason >= 0)
	    {
	      do_cleanups (cleanup);
	      return values;
	    }
d987 2
a988 2
	  if (ex.error != NOT_FOUND_ERROR)
	    throw_exception (ex);
d990 2
a991 1
	  *argptr = saved_argptr;
@


1.140
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2802 11
a2812 1
	return;
@


1.139
log
@Ignore data minimal symbols for breakpoint linespecs

gdb/ChangeLog:

        * linespec.c (struct collect_minsyms) [list_mode]: New field.
        (add_minsym): Ignore data symbols if not in list mode.
        (search_minsyms_for_name): Set local.list_mode.

gdb/testsuite/ChangeLog:

        * gdb.base/dmsym.c, gdb.base/dmsym_main.c, gdb.base/dmsym.exp:
        New files.
@
text
@d3 1
a3 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008,
   2009, 2010, 2011 Free Software Foundation, Inc.
@


1.138
log
@Add handling for unqualified Ada operators in linespecs

This patch enhances the linespec parser to recognize unqualified
operator names in linespecs. This allows the user to insert a breakpoint
on operator "+" as follow, for instance:

        (gdb) break "+"

Previously, it was possible to insert such a breakpoint, but one
had to fully qualify the function name. For instance:

        (gdb) break ops."+"

gdb/ChangeLog:

        * linespec.c (locate_first_half): Add handling of Ada operators
        when the current language is Ada.
@
text
@d2741 3
d2794 13
d2837 1
@


1.137
log
@	* linespec.c (collect_symbols): Call maybe_add_address after
	calling symbol_to_sal.
	(minsym_found): Call maybe_add_address here.
	(search_minsyms_for_name): Don't call maybe_add_address.
@
text
@d1334 18
@


1.136
log
@	* linespec.c (struct collect_info) <objfile>: Remove field.
	(decode_objc): Update.
	(find_method): Update.
	(decode_variable): Update.
	(struct minsym_and_objfile): New.
	(struct collect_minsyms): New.
	(classify_mtype): New function.
	(compare_msyms): Likewise.
	(add_minsym): Likewise.
	(check_minsym): Remove.
	(search_minsyms_for_name): Sort minsyms and apply only those with
	top priority.
@
text
@d2662 4
a2665 13
  if ((SYMBOL_CLASS (sym) == LOC_STATIC
       && !info->state->funfirstline
       && !maybe_add_address (info->state->addr_set,
			      SYMTAB_PSPACE (SYMBOL_SYMTAB (sym)),
			      SYMBOL_VALUE_ADDRESS (sym)))
      || (SYMBOL_CLASS (sym) == LOC_BLOCK
	  && !maybe_add_address (info->state->addr_set,
				 SYMTAB_PSPACE (SYMBOL_SYMTAB (sym)),
				 BLOCK_START (SYMBOL_BLOCK_VALUE (sym)))))
    {
      /* Nothing.  */
    }
  else if (symbol_to_sal (&sal, info->state->funfirstline, sym))
d2697 2
a2698 1
  add_sal_to_sals (self, result, &sal, SYMBOL_NATURAL_NAME (msymbol));
d2837 2
a2838 5
	    if (maybe_add_address (info->state->addr_set, 
				   item->objfile->pspace,
				   SYMBOL_VALUE_ADDRESS (item->minsym)))
	      minsym_found (info->state, item->objfile, item->minsym,
			    &info->result);
@


1.135
log
@Make decode_line_internal static.

gdb/ChangeLog:

	* linespec.c (decode_line_internal): Make static.
@
text
@a123 3

  /* The current objfile; used only by the minimal symbol code.  */
  struct objfile *objfile;
a1461 1
  info.objfile = NULL;
a1964 1
  info.objfile = NULL;
d2709 10
a2718 2
/* Callback for iterate_over_minimal_symbols that may add the symbol
   to the result.  */
d2720 4
a2723 2
static void
check_minsym (struct minimal_symbol *minsym, void *d)
d2725 12
a2736 1
  struct collect_info *info = d;
d2738 4
a2741 3
  if (MSYMBOL_TYPE (minsym) == mst_unknown
      || MSYMBOL_TYPE (minsym) == mst_slot_got_plt
      || MSYMBOL_TYPE (minsym) == mst_solib_trampoline)
d2743 13
a2755 1
      /* Reject some odd ones.  */
d2757 27
a2783 10
  else if (info->state->funfirstline
	   && MSYMBOL_TYPE (minsym) != mst_text
	   && MSYMBOL_TYPE (minsym) != mst_text_gnu_ifunc
	   && MSYMBOL_TYPE (minsym) != mst_file_text)
    {
      /* When FUNFIRSTLINE, only allow text symbols.  */
    }
  else if (maybe_add_address (info->state->addr_set, info->objfile->pspace,
			      SYMBOL_VALUE_ADDRESS (minsym)))
    minsym_found (info->state, info->objfile, minsym, &info->result);
d2799 3
d2809 6
d2817 2
a2818 2
      info->objfile = objfile;
      iterate_over_minimal_symbols (objfile, name, check_minsym, info);
d2820 34
a2906 1
  info.objfile = NULL;
@


1.134
log
@2011-12-09  Andrew Pinski  <apinski@@cavium.com>

	* linespec.c (hash_address_entry): Use iterative_hash_object on each
	field rather than the struct itself.
@
text
@d838 1
a838 1
struct symtabs_and_lines
@


1.134.2.1
log
@	* linespec.c (struct collect_info) <objfile>: Remove field.
	(decode_objc): Update.
	(find_method): Update.
	(decode_variable): Update.
	(struct minsym_and_objfile): New.
	(struct collect_minsyms): New.
	(classify_mtype): New function.
	(compare_msyms): Likewise.
	(add_minsym): Likewise.
	(check_minsym): Remove.
	(search_minsyms_for_name): Sort minsyms and apply only those with
	top priority.
@
text
@d124 3
d1465 1
d1969 1
d2714 2
a2715 2
/* A helper struct which just holds a minimal symbol and the object
   file from which it came.  */
d2717 2
a2718 1
typedef struct minsym_and_objfile
d2720 1
a2720 3
  struct minimal_symbol *minsym;
  struct objfile *objfile;
} minsym_and_objfile_d;
d2722 10
a2731 24
DEF_VEC_O (minsym_and_objfile_d);

/* A helper struct to pass some data through
   iterate_over_minimal_symbols.  */

struct collect_minsyms
{
  /* The objfile we're examining.  */
  struct objfile *objfile;

  /* The funfirstline setting from the initial call.  */
  int funfirstline;

  /* The resulting symbols.  */
  VEC (minsym_and_objfile_d) *msyms;
};

/* A helper function to classify a minimal_symbol_type according to
   priority.  */

static int
classify_mtype (enum minimal_symbol_type t)
{
  switch (t)
d2733 1
a2733 13
    case mst_file_text:
    case mst_file_data:
    case mst_file_bss:
      /* Intermediate priority.  */
      return 1;

    case mst_solib_trampoline:
      /* Lowest priority.  */
      return 2;

    default:
      /* Highest priority.  */
      return 0;
d2735 3
a2737 27
}

/* Callback for qsort that sorts symbols by priority.  */

static int
compare_msyms (const void *a, const void *b)
{
  const minsym_and_objfile_d *moa = a;
  const minsym_and_objfile_d *mob = b;
  enum minimal_symbol_type ta = MSYMBOL_TYPE (moa->minsym);
  enum minimal_symbol_type tb = MSYMBOL_TYPE (mob->minsym);

  return classify_mtype (ta) - classify_mtype (tb);
}

/* Callback for iterate_over_minimal_symbols that adds the symbol to
   the result.  */

static void
add_minsym (struct minimal_symbol *minsym, void *d)
{
  struct collect_minsyms *info = d;
  minsym_and_objfile_d mo;

  mo.minsym = minsym;
  mo.objfile = info->objfile;
  VEC_safe_push (minsym_and_objfile_d, info->msyms, &mo);
a2752 3
    struct collect_minsyms local;
    struct cleanup *cleanup;

a2759 6
    memset (&local, 0, sizeof (local));
    local.funfirstline = info->state->funfirstline;

    cleanup = make_cleanup (VEC_cleanup (minsym_and_objfile_d),
			    &local.msyms);

d2762 2
a2763 2
      local.objfile = objfile;
      iterate_over_minimal_symbols (objfile, name, add_minsym, &local);
a2764 34

    if (!VEC_empty (minsym_and_objfile_d, local.msyms))
      {
	int classification;
	int ix;
	minsym_and_objfile_d *item;

	qsort (VEC_address (minsym_and_objfile_d, local.msyms),
	       VEC_length (minsym_and_objfile_d, local.msyms),
	       sizeof (minsym_and_objfile_d),
	       compare_msyms);

	/* Now the minsyms are in classification order.  So, we walk
	   over them and process just the minsyms with the same
	   classification as the very first minsym in the list.  */
	item = VEC_index (minsym_and_objfile_d, local.msyms, 0);
	classification = classify_mtype (MSYMBOL_TYPE (item->minsym));

	for (ix = 0;
	     VEC_iterate (minsym_and_objfile_d, local.msyms, ix, item);
	     ++ix)
	  {
	    if (classify_mtype (MSYMBOL_TYPE (item->minsym)) != classification)
	      break;

	    if (maybe_add_address (info->state->addr_set, 
				   item->objfile->pspace,
				   SYMBOL_VALUE_ADDRESS (item->minsym)))
	      minsym_found (info->state, item->objfile, item->minsym,
			    &info->result);
	  }
      }

    do_cleanups (cleanup);
d2818 1
@


1.134.2.2
log
@	* linespec.c (collect_symbols): Call maybe_add_address after
	calling symbol_to_sal.
	(minsym_found): Call maybe_add_address here.
	(search_minsyms_for_name): Don't call maybe_add_address.
@
text
@d2662 13
a2674 4
  if (symbol_to_sal (&sal, info->state->funfirstline, sym)
      && maybe_add_address (info->state->addr_set,
			    SYMTAB_PSPACE (SYMBOL_SYMTAB (sym)),
			    sal.pc))
d2706 1
a2706 2
  if (maybe_add_address (self->addr_set, objfile->pspace, sal.pc))
    add_sal_to_sals (self, result, &sal, SYMBOL_NATURAL_NAME (msymbol));
d2845 5
a2849 2
	    minsym_found (info->state, item->objfile, item->minsym,
			  &info->result);
@


1.134.2.3
log
@Ignore data minimal symbols for breakpoint linespecs

gdb/ChangeLog:

        * linespec.c (struct collect_minsyms) [list_mode]: New field.
        (add_minsym): Ignore data symbols if not in list mode.
        (search_minsyms_for_name): Set local.list_mode.

gdb/testsuite/ChangeLog:

        * gdb.base/dmsym.c, gdb.base/dmsym_main.c, gdb.base/dmsym.exp:
        New files.
@
text
@a2722 3
  /* The list_mode setting from the initial call.  */
  int list_mode;

a2772 13
  /* Exclude data symbols when looking for breakpoint locations.   */
  if (!info->list_mode)
    switch (minsym->type)
      {
	case mst_slot_got_plt:
	case mst_data:
	case mst_bss:
	case mst_abs:
	case mst_file_data:
	case mst_file_bss:
	return;
      }

a2802 1
    local.list_mode = info->state->list_mode;
@


1.134.2.4
log
@linespec: keep function descriptors during minimal symbol search

When discarding data (minimal) symbols, we need to be careful to
not throw away the function descriptors.  This makes a difference
on platforms where these descriptors are used and live in a data
section.

gdb/ChangeLog:

        * linespec.c (add_minsym): Preserve function descriptors.
@
text
@d2786 1
a2786 11
	  {
	    /* Make sure this minsym is not a function descriptor
	       before we decide to discard it.  */
	    struct gdbarch *gdbarch = info->objfile->gdbarch;
	    CORE_ADDR addr = gdbarch_convert_from_func_ptr_addr
			       (gdbarch, SYMBOL_VALUE_ADDRESS (minsym),
				&current_target);

	    if (addr == SYMBOL_VALUE_ADDRESS (minsym))
	      return;
	  }
@


1.134.2.5
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1986-2005, 2007-2012 Free Software Foundation, Inc.
@


1.133
log
@	* linespec.c (decode_dollar): Avoid "may be used uninitialized" warning.
@
text
@d256 1
d258 2
a259 1
  return iterative_hash_object (*aep, 0);
@


1.132
log
@the "ambiguous linespec" series
gdb
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * language.h (struct language_defn): Add new component
        la_symbol_name_compare.
        * symfile.h (struct quick_symbol_functions): Update the profile
        of parameter "name_matcher" for the expand_symtabs_matching
        method.  Update the documentation accordingly.
        * ada-lang.h (ada_name_for_lookup): Add declaration.
        * ada-lang.c (ada_name_for_lookup): New function, extracted out
        from ada_iterate_over_symbols.
        (ada_iterate_over_symbols): Do not encode symbol name anymore.
        (ada_expand_partial_symbol_name): Adjust profile.
        (ada_language_defn): Add value for la_symbol_name_compare field.
        * linespec.c: #include "ada-lang.h".
        (iterate_name_matcher): Add language parameter. Replace call
        to strcmp_iw by call to language->la_symbol_name_compare.
        (decode_variable): Encode COPY if current language is Ada.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust profile
        of name_matcher parameter.  Adjust call to name_matcher.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (expand_partial_symbol_names): Update profile of parameter "fun".
        * psymtab.h (expand_partial_symbol_names): Update profile of
        parameter "fun".
        * symtab.c (demangle_for_lookup): Update function documentation.
        (search_symbols_name_matches): Add language parameter.
        (expand_partial_symbol_name): Likewise.
        * c-lang.c (c_language_defn, cplus_language_defn)
        (asm_language_defn, minimal_language_defn): Add value for
        la_symbol_name_compare field.
        * d-lang.c (d_language_defn): Likewise.
        * f-lang.c (f_language_defn): Ditto.
        * jv-lang.c (java_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * opencl-lang.c (opencl_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * language.c (unknown_language_defn, auto_language_defn)
        (local_language_defn): Ditto.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* linespec.c (iterate_over_all_matching_symtabs): Use
	LA_ITERATE_OVER_SYMBOLS.
	(lookup_prefix_sym, add_matching_symbols_to_info): Likewise.
	(find_function_symbols, decode_variable): Remove Ada special
	case.
	* language.h (struct language_defn) <la_iterate_over_symbols>: New
	field.
	(LA_ITERATE_OVER_SYMBOLS): New macro.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Update.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Update.
	* d-lang.c (d_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* m2-lang.c (m2_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* opencl-lang.c (opencl_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* ada-lang.c (ada_iterate_over_symbols): New function.
	(ada_language_defn): Update.

2011-12-06  Tom Tromey  <tromey@@redhat.com>
	    Joel Brobecker  <brobecker@@acacore.com>

	PR breakpoints/13105, PR objc/8341, PR objc/8343, PR objc/8366,
	PR objc/8535, PR breakpoints/11657, PR breakpoints/11970,
	PR breakpoints/12023, PR breakpoints/12334, PR breakpoints/12856,
	PR shlibs/8929, PR shlibs/7393:
	* python/py-type.c (compare_maybe_null_strings): Rename from
	compare_strings.
	(check_types_equal): Update.
	* utils.c (compare_strings): New function.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Update for
	location changes.
	* tracepoint.c (scope_info): Update.
	(trace_find_line_command): Use DECODE_LINE_FUNFIRSTLINE.
	* symtab.h (iterate_over_minimal_symbols)
	(iterate_over_some_symtabs, iterate_over_symtabs)
	(find_pcs_for_symtab_line, iterate_over_symbols)
	(demangle_for_lookup): Declare.
	(expand_line_sal): Remove.
	* symtab.c (iterate_over_some_symtabs, iterate_over_symtabs)
	(lookup_symtab_callback): New functions.
	(lookup_symtab): Rewrite.
	(demangle_for_lookup): New function, extract from
	lookup_symbol_in_language.
	(lookup_symbol_in_language): Use it.
	(iterate_over_symbols): New function.
	(find_line_symtab): Update.
	(find_pcs_for_symtab_line): New functions.
	(find_line_common): Add 'start' argument.
	(decode_line_spec): Update.  Change argument to 'flags', change
	interpretation.
	(append_expanded_sal): Remove.
	(append_exact_match_to_sals): Remove.
	(expand_line_sal): Remove.
	* symfile.h (struct quick_symbol_functions) <lookup_symtab>:
	Remove.
	<map_symtabs_matching_filename>: New field.
	* stack.c (func_command): Only look in the current program space.
	Use DECODE_LINE_FUNFIRSTLINE.
	* source.c (line_info): Set pspace on sal.  Check program space in
	the loop.  Use DECODE_LINE_LIST_MODE.
	(select_source_symtab): Use DECODE_LINE_FUNFIRSTLINE.
	* solib-target.c: Remove DEF_VEC_I(CORE_ADDR).
	* python/python.c (gdbpy_decode_line): Update.
	* psymtab.c (partial_map_expand_apply): New function.
	(partial_map_symtabs_matching_filename): Rename from
	lookup_partial_symbol.  Update arguments.
	(lookup_symtab_via_partial_symtab): Remove.
	(psym_functions): Update.
	* objc-lang.h (parse_selector, parse_method): Don't declare.
	(find_imps): Update.
	* objc-lang.c (parse_selector, parse_method): Now static.
	(find_methods): Change arguments.  Fill in a vector of symbol
	names.
	(uniquify_strings): New function.
	(find_imps): Change arguments.
	* minsyms.c (iterate_over_minimal_symbols): New function.
	* linespec.h (enum decode_line_flags): New.
	(struct linespec_sals): New.
	(struct linespec_result) <canonical>: Remove.
	<pre_expanded, addr_string, sals>: New fields.
	(destroy_linespec_result, make_cleanup_destroy_linespec_result)
	(decode_line_full): Declare.
	(decode_line_1): Update.
	* linespec.c (struct address_entry, struct linespec_state, struct
	collect_info): New types.
	(add_sal_to_sals_basic, add_sal_to_sals, hash_address_entry)
	(eq_address_entry, maybe_add_address): New functions.
	(total_number_of_methods): Remove.
	(iterate_name_matcher, iterate_over_all_matching_symtabs): New
	functions.
	(find_methods): Change arguments.  Don't canonicalize input.
	Simplify logic.
	(add_matching_methods, add_constructors)
	(build_canonical_line_spec): Remove.
	(filter_results, convert_results_to_lsals): New functions.
	(decode_line_2): Change arguments.  Rewrite for new data
	structures.
	(decode_line_internal): Rename from decode_line_1.  Change
	arguments.  Add cleanups.  Update for new data structures.
	(linespec_state_constructor, linespec_state_destructor)
	(decode_line_full, decode_line_1): New functions.
	(decode_indirect): Change arguments.  Update.
	(locate_first_half): Use skip_spaces.
	(decode_objc): Change arguments.  Update for new data structures.
	Simplify logic.
	(decode_compound): Change arguments.  Add cleanups.  Remove
	fallback code, replace with error.
	(struct decode_compound_collector): New type.
	(collect_one_symbol): New function.
	(lookup_prefix_sym): Change arguments.  Update.
	(compare_symbol_name, add_all_symbol_names_from_pspace)
	(find_superclass_methods ): New functions.
	(find_method): Rewrite.
	(struct symtab_collector): New type.
	(add_symtabs_to_list, collect_symtabs_from_filename): New
	functions.
	(symtabs_from_filename): Change API.  Rename from
	symtab_from_filename.
	(collect_function_symbols): New function.
	(find_function_symbols): Change API.  Rename from
	find_function_symbol.  Rewrite.
	(decode_all_digits): Change arguments.  Rewrite.
	(decode_dollar): Change arguments.  Use decode_variable.
	(decode_label): Change arguments.  Rewrite.
	(collect_symbols): New function.
	(minsym_found): Change arguments.  Rewrite.
	(check_minsym, search_minsyms_for_name)
	(add_matching_symbols_to_info): New function.
	(decode_variable): Change arguments.  Iterate over all symbols.
	(symbol_found): Remove.
	(symbol_to_sal): New function.
	(init_linespec_result, destroy_linespec_result)
	(cleanup_linespec_result, make_cleanup_destroy_linespec_result):
	New functions.
	(decode_digits_list_mode, decode_digits_ordinary): New functions.
	* dwarf2read.c (dw2_map_expand_apply): New function.
	(dw2_map_symtabs_matching_filename): Rename from
	dw2_lookup_symtab.  Change arguments.
	(dwarf2_gdb_index_functions): Update.
	* dwarf2loc.c: Remove DEF_VEC_I(CORE_ADDR).
	* defs.h (compare_strings): Declare.
	* cli/cli-cmds.c (compare_strings): Move to utils.c.
	(edit_command, list_command): Use DECODE_LINE_LIST_MODE.  Call
	filter_sals.
	(compare_symtabs, filter_sals): New functions.
	* breakpoint.h (struct bp_location) <line_number, source_file>:
	New fields.
	(struct breakpoint) <line_number, source_file>: Remove.
	<filter>: New field.
	* breakpoint.c (print_breakpoint_location, init_raw_breakpoint)
	(momentary_breakpoint_from_master, add_location_to_breakpoint):
	Update for changes to locations.
	(init_breakpoint_sal): Add 'filter' argument.  Set 'filter' on
	breakpoint.
	(create_breakpoint_sal): Add 'filter' argument.
	(remove_sal, expand_line_sal_maybe): Remove.
	(create_breakpoints_sal): Remove 'sals' argument.  Handle
	pre-expanded sals and the filter.
	(parse_breakpoint_sals): Use decode_line_full.
	(check_fast_tracepoint_sals): Use get_sal_arch.
	(create_breakpoint): Create a linespec_sals.  Update.
	(break_range_command): Use decode_line_full.  Update.
	(until_break_command): Update.
	(clear_command): Update match conditions for linespec.c changes.
	Use DECODE_LINE_LIST_MODE.
	(say_where): Update for changes to locations.
	(bp_location_dtor): Free 'source_file'.
	(base_breakpoint_dtor): Free 'filter'.  Don't free 'source_file'.
	(update_static_tracepoint): Update for changes to locations.
	(update_breakpoint_locations): Disable ranged breakpoint if too
	many locations match.  Update.
	(addr_string_to_sals): Use decode_line_full.  Resolve all sal
	PCs.
	(breakpoint_re_set_default): Don't call expand_line_sal_maybe.
	(decode_line_spec_1): Update.  Change argument name to 'flags',
	change interpretation.
	* block.h (block_containing_function): Declare.
	* block.c (block_containing_function): New function.
	* skip.c (skip_function_command): Update.
	(skip_re_set): Update.
	* infcmd.c (jump_command): Use DECODE_LINE_FUNFIRSTLINE.
	* mi/mi-main.c (mi_cmd_trace_find): Use DECODE_LINE_FUNFIRSTLINE.
	* NEWS: Add entry.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Allow
	breakpoint's pspace to be NULL.
	* breakpoint.h (struct breakpoint) <pspace>: Update comment.
	* breakpoint.c (init_raw_breakpoint): Conditionally set
	breakpoint's pspace.
	(init_breakpoint_sal): Don't set breakpoint's pspace.
	(prepare_re_set_context): Conditionally switch program space.
	(addr_string_to_sals): Check executing_startup on location's
	program space.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* breakpoint.h (enum enable_state) <bp_startup_disabled>: Remove.
	* breakpoint.c (should_be_inserted): Explicitly check if program
	space is executing startup.
	(describe_other_breakpoints): Update.
	(disable_breakpoints_before_startup): Change executing_startup
	earlier.  Remove loop.
	(enable_breakpoints_after_startup): Likewise.
	(init_breakpoint_sal): Don't use bp_startup_disabled.
	(create_breakpoint): Don't use bp_startup_disabled.
	(update_global_location_list): Use should_be_inserted.
	(bkpt_re_set): Update.
gdb/testsuite
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * gdb.ada/fullname_bp.exp: Add tests for other valid linespecs
        involving a fully qualified function name.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.ada/homonym.exp: Add three breakpoint tests.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.base/solib-weak.exp (do_test): Remove kfail.
	* gdb.trace/tracecmd.exp: Disable pending breakpoints earlier.
	* gdb.objc/objcdecode.exp: Update for output changes.
	* gdb.linespec/linespec.exp: New file.
	* gdb.linespec/lspec.cc: New file.
	* gdb.linespec/lspec.h: New file.
	* gdb.linespec/body.h: New file.
	* gdb.linespec/base/two/thefile.cc: New file.
	* gdb.linespec/base/one/thefile.cc: New file.
	* gdb.linespec/Makefile.in: New file.
	* gdb.cp/templates.exp (test_template_breakpoints): Update for
	output changes.
	* gdb.cp/re-set-overloaded.exp: Remove kfail.
	* gdb.cp/ovldbreak.exp: Update for output changes.  "all" test now
	makes one breakpoint.
	* gdb.cp/method2.exp (test_break): Update for output changes.
	* gdb.cp/mb-templates.exp: Update for output changes.
	* gdb.cp/mb-inline.exp: Update for output changes.
	* gdb.cp/mb-ctor.exp: Update for output changes.
	* gdb.cp/ovsrch.exp: Use fully-qualified names.
	* gdb.base/solib-symbol.exp: Run to main later.  Breakpoint now
	has multiple matches.
	* gdb.base/sepdebug.exp: Disable pending breakpoints.  Update for
	error message change.
	* gdb.base/list.exp (test_list_filename_and_number): Update for
	error message change.
	* gdb.base/break.exp: Disable pending breakpoints.  Update for
	output changes.
	* configure.ac: Add gdb.linespec.
	* configure: Rebuild.
	* Makefile.in (ALL_SUBDIRS): Add gdb.linespec.
gdb/doc
2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Set Breaks): Update for new behavior.
@
text
@d2497 4
@


1.131
log
@	PR gdb/12843
	* linespec.c (locate_first_half): Keep ':' if it looks
	like it could be part of a Windows path starting with
	a drive letter.
@
text
@d47 81
d134 2
a135 1
static struct symtabs_and_lines decode_indirect (char **argptr);
d139 5
a143 10
static struct symtabs_and_lines decode_objc (char **argptr,
					     int funfirstline,
					     struct symtab *file_symtab,
					     struct linespec_result *canonical,
					     char *saved_arg);

static struct symtabs_and_lines decode_compound (char **argptr,
						 int funfirstline,
						 struct linespec_result *canonical,
						 struct symtab *file_symtab,
d147 3
a149 2
static struct symbol *lookup_prefix_sym (char **argptr, char *p,
					 struct symtab *);
d151 1
a151 2
static struct symtabs_and_lines find_method (int funfirstline,
					     struct linespec_result *canonical,
d154 2
a155 3
					     struct type *t,
					     struct symbol *sym_class,
					     struct symtab *);
d160 29
a188 1
static int total_number_of_methods (struct type *type);
d190 7
a196 2
static int find_methods (struct type *, char *,
			 enum language, struct symbol **, struct symtab *);
d198 61
a258 3
static int add_matching_methods (int method_counter, struct type *t,
				 enum language language,
				 struct symbol **sym_arr);
d260 1
a260 3
static int add_constructors (int method_counter, struct type *t,
			     enum language language,
			     struct symbol **sym_arr);
d262 5
a266 2
static void build_canonical_line_spec (struct symtab_and_line *,
				       char *, struct linespec_result *);
d268 2
a269 1
static char *find_toplevel_char (char *s, char c);
d271 3
a273 1
static int is_objc_method_format (const char *s);
d275 5
a279 23
static struct symtabs_and_lines decode_line_2 (struct symbol *[],
					       int, int,
					       struct linespec_result *);

static struct symtab *symtab_from_filename (char **argptr,
					    char *p, int is_quote_enclosed);

static struct symbol *find_function_symbol (char **argptr, char *p,
					    int is_quote_enclosed);

static struct
symtabs_and_lines decode_all_digits (char **argptr,
				     struct symtab *default_symtab,
				     int default_line,
				     struct linespec_result *canonical,
				     struct symtab *file_symtab,
				     char *q);

static struct symtabs_and_lines decode_dollar (char *copy,
					       int funfirstline,
					       struct symtab *default_symtab,
					       struct linespec_result *canonical,
					       struct symtab *file_symtab);
d281 5
a285 3
static int decode_label (struct symbol *function_symbol,
			 char *copy, struct linespec_result *canonical,
			 struct symtabs_and_lines *result);
d287 3
a289 16
static struct symtabs_and_lines decode_variable (char *copy,
						 int funfirstline,
						 struct linespec_result *canonical,
						 struct symtab *file_symtab);

static struct
symtabs_and_lines symbol_found (int funfirstline,
				struct linespec_result *canonical,
				char *copy,
				struct symbol *sym,
				struct symtab *file_symtab,
				struct symbol *function_symbol);

static struct
symtabs_and_lines minsym_found (int funfirstline,
				struct minimal_symbol *msymbol);
d291 2
a292 1
/* Helper functions.  */
d327 2
a328 4
/* Return the number of methods described for TYPE, including the
   methods from types it derives from.  This can't be done in the symbol
   reader because the type of the baseclass might still be stubbed
   when the definition of the derived class is parsed.  */
d331 21
a351 1
total_number_of_methods (struct type *type)
d353 9
a361 2
  int n;
  int count;
d363 11
a373 4
  CHECK_TYPEDEF (type);
  if (! HAVE_CPLUS_STRUCT (type))
    return 0;
  count = TYPE_NFN_FIELDS_TOTAL (type);
d375 5
a379 2
  for (n = 0; n < TYPE_N_BASECLASSES (type); n++)
    count += total_number_of_methods (TYPE_BASECLASS (type, n));
d381 6
a386 1
  return count;
d413 3
a415 6
/* Recursive helper function for decode_line_1.
   Look for methods named NAME in type T.
   Return number of matches.
   Put matches in SYM_ARR, which should have been allocated with
   a size of total_number_of_methods (T) * sizeof (struct symbol *).
   Note that this function is g++ specific.  */
d417 4
a420 3
static int
find_methods (struct type *t, char *name, enum language language,
	      struct symbol **sym_arr, struct symtab *file_symtab)
a424 1
  struct cleanup *cleanup;
a426 11
  /* NAME is typed by the user: it needs to be canonicalized before
     passing to lookup_symbol.  */
  canon = cp_canonicalize_string_no_typedefs (name);
  if (canon != NULL)
    {
      name = canon;
      cleanup = make_cleanup (xfree, name);
    }
  else
    cleanup = make_cleanup (null_cleanup, NULL);

d430 1
a430 3
  if (class_name
      && (lookup_symbol_in_language (class_name, get_search_block (file_symtab),
			 STRUCT_DOMAIN, language, (int *) NULL)))
d458 3
a460 11
	  if (strcmp_iw (name, method_name) == 0)
	    /* Find all the overloaded methods with that name.  */
	    i1 += add_matching_methods (method_counter, t, language,
					sym_arr + i1);
	  else if (strncmp (class_name, name, name_len) == 0
		   && (class_name[name_len] == '\0'
		       || class_name[name_len] == '<'))
	    i1 += add_constructors (method_counter, t, language,
				    sym_arr + i1);
	}
    }
d462 7
a468 15
  /* Only search baseclasses if there is no match yet, since names in
     derived classes override those in baseclasses.

     FIXME: The above is not true; it is only true of member functions
     if they have the same number of arguments (??? - section 13.1 of the
     ARM says the function members are not in the same scope but doesn't
     really spell out the rules in a way I understand.  In any case, if
     the number of arguments differ this is a case in which we can overload
     rather than hiding without any problem, and gcc 2.4.5 does overload
     rather than hiding in this case).  */

  if (i1 == 0)
    for (ibase = 0; ibase < TYPE_N_BASECLASSES (t); ibase++)
      i1 += find_methods (TYPE_BASECLASS (t, ibase), name,
			  language, sym_arr + i1, file_symtab);
d470 7
a476 55
  do_cleanups (cleanup);
  return i1;
}

/* Add the symbols associated to methods of the class whose type is T
   and whose name matches the method indexed by METHOD_COUNTER in the
   array SYM_ARR.  Return the number of methods added.  */

static int
add_matching_methods (int method_counter, struct type *t,
		      enum language language, struct symbol **sym_arr)
{
  int field_counter;
  int i1 = 0;

  for (field_counter = TYPE_FN_FIELDLIST_LENGTH (t, method_counter) - 1;
       field_counter >= 0;
       --field_counter)
    {
      struct fn_field *f;
      const char *phys_name;

      f = TYPE_FN_FIELDLIST1 (t, method_counter);

      if (TYPE_FN_FIELD_STUB (f, field_counter))
	{
	  char *tmp_name, *tmp2;

	  tmp_name = gdb_mangle_name (t,
				      method_counter,
				      field_counter);
	  tmp2 = alloca (strlen (tmp_name) + 1);
	  strcpy (tmp2, tmp_name);
	  xfree (tmp_name);
	  phys_name = tmp2;
	}
      else
	phys_name = TYPE_FN_FIELD_PHYSNAME (f, field_counter);

      sym_arr[i1] = lookup_symbol_in_language (phys_name,
				   NULL, VAR_DOMAIN,
				   language,
				   (int *) NULL);
      if (sym_arr[i1])
	i1++;
      else
	{
	  /* This error message gets printed, but the method
	     still seems to be found.
	     fputs_filtered("(Cannot find method ", gdb_stdout);
	     fprintf_symbol_filtered (gdb_stdout, phys_name,
	                              language_cplus,
	                              DMGL_PARAMS | DMGL_ANSI);
	     fputs_filtered(" - possibly inlined.)\n", gdb_stdout);
	  */
d480 2
a481 85
  return i1;
}

/* Add the symbols associated to constructors of the class whose type
   is CLASS_TYPE and which are indexed by by METHOD_COUNTER to the
   array SYM_ARR.  Return the number of methods added.  */

static int
add_constructors (int method_counter, struct type *t,
		  enum language language, struct symbol **sym_arr)
{
  int field_counter;
  int i1 = 0;

  /* For GCC 3.x and stabs, constructors and destructors
     have names like __base_ctor and __complete_dtor.
     Check the physname for now if we're looking for a
     constructor.  */
  for (field_counter
	 = TYPE_FN_FIELDLIST_LENGTH (t, method_counter) - 1;
       field_counter >= 0;
       --field_counter)
    {
      struct fn_field *f;
      const char *phys_name;

      f = TYPE_FN_FIELDLIST1 (t, method_counter);

      /* GCC 3.x will never produce stabs stub methods, so
	 we don't need to handle this case.  */
      if (TYPE_FN_FIELD_STUB (f, field_counter))
	continue;
      phys_name = TYPE_FN_FIELD_PHYSNAME (f, field_counter);
      if (! is_constructor_name (phys_name))
	continue;

      /* If this method is actually defined, include it in the
	 list.  */
      sym_arr[i1] = lookup_symbol_in_language (phys_name,
				   NULL, VAR_DOMAIN,
				   language,
				   (int *) NULL);
      if (sym_arr[i1])
	i1++;
    }

  return i1;
}

/* Helper function for decode_line_1.
   Build a canonical line spec in CANONICAL if it is non-NULL and if
   the SAL has a symtab.
   If SYMNAME is non-NULL the canonical line spec is `filename:symname'.
   If SYMNAME is NULL the line number from SAL is used and the canonical
   line spec is `filename:linenum'.  */

static void
build_canonical_line_spec (struct symtab_and_line *sal, char *symname,
			   struct linespec_result *canonical)
{
  char **canonical_arr;
  char *canonical_name;
  char *filename;
  struct symtab *s = sal->symtab;

  if (s == (struct symtab *) NULL
      || s->filename == (char *) NULL
      || canonical == NULL)
    return;

  canonical_arr = (char **) xmalloc (sizeof (char *));
  canonical->canonical = canonical_arr;

  filename = s->filename;
  if (symname != NULL)
    {
      canonical_name = xmalloc (strlen (filename) + strlen (symname) + 2);
      sprintf (canonical_name, "%s:%s", filename, symname);
    }
  else
    {
      canonical_name = xmalloc (strlen (filename) + 30);
      sprintf (canonical_name, "%s:%d", filename, sal->line);
    }
  canonical_arr[0] = canonical_name;
a483 2


d539 51
a589 4
/* Given a list of NELTS symbols in SYM_ARR, return a list of lines to
   operate on (ask user if necessary).
   If CANONICAL is non-NULL return a corresponding array of mangled names
   as canonical line specs there.  */
d591 4
a594 3
static struct symtabs_and_lines
decode_line_2 (struct symbol *sym_arr[], int nelts, int funfirstline,
	       struct linespec_result *canonical)
d596 2
a597 2
  struct symtabs_and_lines values, return_values;
  char *args, *arg1;
a598 2
  char *prompt;
  char *symname;
d600 26
a625 2
  char **canonical_arr = (char **) NULL;
  const char *select_mode = multiple_symbols_select_mode ();
d627 2
a628 1
  if (select_mode == multiple_symbols_cancel)
d632 2
a633 7
  values.sals = (struct symtab_and_line *)
    alloca (nelts * sizeof (struct symtab_and_line));
  return_values.sals = (struct symtab_and_line *)
    xmalloc (nelts * sizeof (struct symtab_and_line));
  old_chain = make_cleanup (xfree, return_values.sals);

  if (canonical)
d635 3
a637 4
      canonical_arr = (char **) xmalloc (nelts * sizeof (char *));
      make_cleanup (xfree, canonical_arr);
      memset (canonical_arr, 0, nelts * sizeof (char *));
      canonical->canonical = canonical_arr;
d640 3
a642 9
  i = 0;
  while (i < nelts)
    {
      init_sal (&return_values.sals[i]);	/* Initialize to zeroes.  */
      init_sal (&values.sals[i]);
      if (sym_arr[i] && SYMBOL_CLASS (sym_arr[i]) == LOC_BLOCK)
	values.sals[i] = find_function_start_sal (sym_arr[i], funfirstline);
      i++;
    }
d644 2
a645 6
  /* If select_mode is "all", then do not print the multiple-choice
     menu and act as if the user had chosen choice "1" (all).  */
  if (select_mode == multiple_symbols_all
      || ui_out_is_mi_like_p (interp_ui_out (top_level_interpreter ())))
    args = "1";
  else
d647 1
a647 31
      i = 0;
      printf_unfiltered (_("[0] cancel\n[1] all\n"));
      while (i < nelts)
        {
          if (sym_arr[i] && SYMBOL_CLASS (sym_arr[i]) == LOC_BLOCK)
            {
              if (values.sals[i].symtab)
                printf_unfiltered ("[%d] %s at %s:%d\n",
                                   (i + 2),
                                   SYMBOL_PRINT_NAME (sym_arr[i]),
                                   values.sals[i].symtab->filename,
                                   values.sals[i].line);
              else
                printf_unfiltered (_("[%d] %s at ?FILE:%d [No symtab? "
				     "Probably broken debug info...]\n"),
                                   (i + 2),
                                   SYMBOL_PRINT_NAME (sym_arr[i]),
                                   values.sals[i].line);

            }
          else
            printf_unfiltered (_("?HERE\n"));
          i++;
        }

      prompt = getenv ("PS2");
      if (prompt == NULL)
        {
          prompt = "> ";
        }
      args = command_line_input (prompt, 0, "overload-choice");
d649 1
d654 2
a655 2
  i = 0;
  while (*args)
d659 1
a659 7
      arg1 = args;
      while (*arg1 >= '0' && *arg1 <= '9')
	arg1++;
      if (*arg1 && *arg1 != ' ' && *arg1 != '\t')
	error (_("Arguments must be choice numbers."));

      num = atoi (args);
d665 9
a673 16
	  if (canonical_arr)
	    {
	      for (i = 0; i < nelts; i++)
		{
		  if (canonical_arr[i] == NULL)
		    {
		      symname = SYMBOL_LINKAGE_NAME (sym_arr[i]);
		      canonical_arr[i] = xstrdup (symname);
		    }
		}
	    }
	  memcpy (return_values.sals, values.sals,
		  (nelts * sizeof (struct symtab_and_line)));
	  return_values.nelts = nelts;
	  discard_cleanups (old_chain);
	  return return_values;
d676 3
a678 4
      if (num >= nelts + 2)
	{
	  printf_unfiltered (_("No choice number %d.\n"), num);
	}
d681 3
a683 2
	  num -= 2;
	  if (values.sals[num].pc)
d685 2
a686 8
	      if (canonical_arr)
		{
		  symname = SYMBOL_LINKAGE_NAME (sym_arr[num]);
		  make_cleanup (xfree, symname);
		  canonical_arr[i] = xstrdup (symname);
		}
	      return_values.sals[i++] = values.sals[num];
	      values.sals[num].pc = 0;
d694 1
d696 2
a697 7
      args = arg1;
      while (*args == ' ' || *args == '\t')
	args++;
    }
  return_values.nelts = i;
  discard_cleanups (old_chain);
  return return_values;
d837 1
a837 2
decode_line_1 (char **argptr, int funfirstline, struct symtab *default_symtab,
	       int default_line, struct linespec_result *canonical)
a840 2
  /* If a file name is specified, this is its symtab.  */
  struct symtab *file_symtab = NULL;
d857 4
a860 4
  /* If we are parsing `function:label', this holds the symbol for the
     function.  */
  struct symbol *function_symbol = NULL;
  /* If FUNCTION_SYMBOL is not NULL, then this is the exception that
d864 2
d868 1
a868 1
  initialize_defaults (&default_symtab, &default_line);
d873 4
a876 1
    return decode_indirect (argptr);
d903 8
a910 1
      file_symtab = symtab_from_filename (argptr, p, is_quote_enclosed);
d936 1
a936 2
    values = decode_objc (argptr, funfirstline, file_symtab,
			  canonical, saved_arg);
d938 4
a941 1
      return values;
d969 1
a969 2
	      values = decode_compound (argptr, funfirstline, canonical,
					file_symtab, saved_arg, p);
d975 4
a978 1
	    return values;
d991 4
a994 2
	      function_symbol = find_function_symbol (argptr, p,
						      is_quote_enclosed);
d997 1
a997 1
	      if (!function_symbol)
d999 2
d1015 4
a1018 3
  /* file_symtab is specified file's symtab, or 0 if no file specified.
     If we are parsing `function:symbol', then FUNCTION_SYMBOL is the
     function before the `:'.
d1041 9
a1049 4
      && function_symbol == NULL)
    /* We found a token consisting of all digits -- at least one digit.  */
    return decode_all_digits (argptr, default_symtab, default_line,
			      canonical, file_symtab, q);
d1089 2
a1090 3
  while (*p == ' ' || *p == '\t')
    p++;
  *argptr = p;
d1096 8
a1103 3
  if (*copy == '$' && function_symbol == NULL)
    return decode_dollar (copy, funfirstline, default_symtab,
			  canonical, file_symtab);
d1108 2
a1109 1
  if (!file_symtab)
d1112 5
a1116 2
      if (decode_label (function_symbol, copy, canonical, &label_result))
	return label_result;
d1119 1
a1119 1
  if (function_symbol)
d1125 40
a1164 1
  return decode_variable (copy, funfirstline, canonical, file_symtab);
d1167 76
a1242 1

d1244 18
a1261 2
/* Now, more helper functions for decode_line_1.  Some conventions
   that these functions follow:
d1263 1
a1263 19
   Decode_line_1 typically passes along some of its arguments or local
   variables to the subfunctions.  It passes the variables by
   reference if they are modified by the subfunction, and by value
   otherwise.

   Some of the functions have side effects that don't arise from
   variables that are passed by reference.  In particular, if a
   function is passed ARGPTR as an argument, it modifies what ARGPTR
   points to; typically, it advances *ARGPTR past whatever substring
   it has just looked at.  (If it doesn't modify *ARGPTR, then the
   function gets passed *ARGPTR instead, which is then called ARG.)
   Also, functions that return a struct symtabs_and_lines may modify
   CANONICAL, as in the description of decode_line_1.

   If a function returns a struct symtabs_and_lines, then that struct
   will immediately make its way up the call chain to be returned by
   decode_line_1.  In particular, all of the functions decode_XXX
   calculate the appropriate struct symtabs_and_lines, under the
   assumption that their argument is of the form XXX.  */
d1289 1
a1289 1
decode_indirect (char **argptr)
d1293 1
d1295 6
d1313 3
d1423 1
a1423 2
  while (p[0] == ' ' || p[0] == '\t')
    p++;
d1451 2
a1452 3
struct symtabs_and_lines
decode_objc (char **argptr, int funfirstline, struct symtab *file_symtab,
	     struct linespec_result *canonical, char *saved_arg)
d1454 10
a1463 6
  struct symtabs_and_lines values;
  struct symbol **sym_arr = NULL;
  struct symbol *sym = NULL;
  struct block *block = NULL;
  unsigned i1 = 0;
  unsigned i2 = 0;
d1465 8
a1472 2
  values.sals = NULL;
  values.nelts = 0;
d1474 1
a1474 18
  find_imps (file_symtab, get_search_block (file_symtab), *argptr,
	     NULL, &i1, &i2); 
    
  if (i1 > 0)
    {
      sym_arr = (struct symbol **)
	alloca ((i1 + 1) * sizeof (struct symbol *));
      sym_arr[i1] = NULL;

      *argptr = find_imps (file_symtab, block, *argptr, sym_arr, &i1, &i2);
    }

  /* i1 now represents the TOTAL number of matches found.
     i2 represents how many HIGH-LEVEL (struct symbol) matches,
     which will come first in the sym_arr array.  Any low-level
     (minimal_symbol) matches will follow those.  */
      
  if (i1 == 1)
d1476 1
a1476 38
      if (i2 > 0)
	{
	  /* Already a struct symbol.  */
	  sym = sym_arr[0];
	}
      else
	{
	  sym = find_pc_function (SYMBOL_VALUE_ADDRESS (sym_arr[0]));
	  if ((sym != NULL) && strcmp (SYMBOL_LINKAGE_NAME (sym_arr[0]),
				       SYMBOL_LINKAGE_NAME (sym)) != 0)
	    {
	      warning (_("debugging symbol \"%s\" does "
			 "not match selector; ignoring"),
		       SYMBOL_LINKAGE_NAME (sym));
	      sym = NULL;
	    }
	}
	      
      values.sals = (struct symtab_and_line *)
	xmalloc (sizeof (struct symtab_and_line));
      values.nelts = 1;
	      
      if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)
	{
	  /* Canonicalize this, so it remains resolved for dylib loads.  */
	  values.sals[0] = find_function_start_sal (sym, funfirstline);
	  build_canonical_line_spec (values.sals,
				     SYMBOL_NATURAL_NAME (sym), canonical);
	}
      else
	{
	  /* The only match was a non-debuggable symbol, which might point
	     to a function descriptor; resolve it to the actual code address
	     instead.  */
	  struct minimal_symbol *msymbol = (struct minimal_symbol *)sym_arr[0];
	  struct objfile *objfile = msymbol_objfile (msymbol);
	  struct gdbarch *gdbarch = get_objfile_arch (objfile);
	  CORE_ADDR pc = SYMBOL_VALUE_ADDRESS (msymbol);
d1478 3
a1480 2
	  pc = gdbarch_convert_from_func_ptr_addr (gdbarch, pc,
						   &current_target);
d1482 8
a1489 2
	  init_sal (&values.sals[0]);
	  values.sals[0].pc = pc;
a1490 1
      return values;
d1493 1
a1493 5
  if (i1 > 1)
    {
      /* More than one match.  The user must choose one or more.  */
      return decode_line_2 (sym_arr, i2, funfirstline, canonical);
    }
d1495 2
a1496 1
  return values;
d1505 2
a1506 3
decode_compound (char **argptr, int funfirstline,
		 struct linespec_result *canonical, struct symtab *file_symtab,
		 char *the_real_saved_arg, char *p)
d1509 1
a1509 1
  char *p2, *name, *canon;
d1514 3
a1516 4
  struct symbol *sym_class;
  struct type *t;
  char *saved_arg;
  struct cleanup *cleanup;
d1551 1
a1551 2
        We just look up AAA::inA::fun with lookup_symbol.  If that fails,
        try lookup_minimal_symbol.
d1651 8
a1658 9
  sym_class = lookup_prefix_sym (argptr, p2, file_symtab);

  /* If sym_class has been found, and if "AAA::inA" is a class, then
     we're in case 1 above.  So we look up "fun" as a method of that
     class.  */
  if (sym_class &&
      (t = check_typedef (SYMBOL_TYPE (sym_class)),
       (TYPE_CODE (t) == TYPE_CODE_STRUCT
	|| TYPE_CODE (t) == TYPE_CODE_UNION)))
d1708 1
a1708 3
      while (*p == ' ' || *p == '\t')
	p++;
      *argptr = p;
d1718 4
a1721 2
      return find_method (funfirstline, canonical, saved_arg, copy, t,
			  sym_class, file_symtab);
d1726 6
a1731 1
     entire name as a symbol instead.  */
d1733 2
a1734 1
  p = keep_name_info (p, 1);
d1736 12
a1747 7
  copy = (char *) alloca (p - saved_arg2 + 1);
  memcpy (copy, saved_arg2, p - saved_arg2);
  /* Note: if is_quoted should be true, we snuff out quote here
     anyway.  */
  copy[p - saved_arg2] = '\000';
  /* Set argptr to skip over the name.  */
  *argptr = (*p == '\'') ? p + 1 : p;
d1749 6
a1754 2
  /* Look up entire name.  */
  name = copy;
d1756 12
a1767 3
  cleanup = make_cleanup (null_cleanup, NULL);
  canon = cp_canonicalize_string_no_typedefs (copy);
  if (canon != NULL)
d1769 2
a1770 2
      name = canon;
      make_cleanup (xfree, name);
d1773 1
a1773 20
  sym = lookup_symbol (name, get_selected_block (0), VAR_DOMAIN, 0);
  do_cleanups (cleanup);
  if (sym)
    return symbol_found (funfirstline, canonical, copy, sym, NULL, NULL);
  else
    {
      struct minimal_symbol *msym;

      /* Couldn't find any interpretation as classes/namespaces.  As a last
	 resort, try the minimal symbol tables.  */
      msym = lookup_minimal_symbol (copy, NULL, NULL);
      if (msym != NULL)
	return minsym_found (funfirstline, msym);
    }    

  /* Couldn't find a minimal symbol, either, so give up.  */
  cplusplus_error (the_real_saved_arg,
		   "Can't find member of namespace, "
		   "class, struct, or union named \"%s\"\n",
		   copy);
a1775 2
/* Next come some helper functions for decode_compound.  */

d1780 1
a1780 1
   lookup_symbol call finds anything (i.e we return NULL).  As an
d1783 3
a1785 2
static struct symbol *
lookup_prefix_sym (char **argptr, char *p, struct symtab *file_symtab)
d1789 6
a1794 1
  struct symbol *sym;
d1800 1
a1800 1
  copy = (char *) alloca (p - *argptr + 1);
d1803 2
d1808 1
a1808 2
  while (*p == ' ' || *p == '\t')
    p++;
d1814 2
a1815 10
  sym = lookup_symbol (copy, get_search_block (file_symtab), STRUCT_DOMAIN, 0);
  if (sym == NULL)
    {
      /* Typedefs are in VAR_DOMAIN so the above symbol lookup will
	 fail when the user attempts to lookup a method of a class
	 via a typedef'd name (NOT via the class's name, which is already
	 handled in symbol_matches_domain).  So try the lookup again
	 using VAR_DOMAIN (where typedefs live) and double-check that we
	 found a struct/class type.  */
      struct symbol *s = lookup_symbol (copy, 0, VAR_DOMAIN, 0);
d1817 17
a1833 1
      if (s != NULL)
d1835 1
a1835 1
	  struct type *t = SYMBOL_TYPE (s);
d1837 9
a1845 3
	  CHECK_TYPEDEF (t);
	  if (TYPE_CODE (t) == TYPE_CODE_STRUCT)
	    return s;
d1849 80
a1928 1
  return sym;
d1931 2
a1932 2
/* This finds the method COPY in the class whose type is T and whose
   symbol is SYM_CLASS.  */
d1935 2
a1936 4
find_method (int funfirstline, struct linespec_result *canonical,
	     char *saved_arg,
	     char *copy, struct type *t, struct symbol *sym_class,
	     struct symtab *file_symtab)
d1938 17
a1954 34
  struct symtabs_and_lines values;
  struct symbol *sym = NULL;
  int i1;	/*  Counter for the symbol array.  */
  struct symbol **sym_arr =  alloca (total_number_of_methods (t)
				     * sizeof (struct symbol *));

  /* Find all methods with a matching name, and put them in
     sym_arr.  */

  i1 = find_methods (t, copy, SYMBOL_LANGUAGE (sym_class), sym_arr,
		     file_symtab);

  /* If we were given a specific overload instance in COPY, defer the field
     acceptance till the strcmp_iw verification below, even if we found just
     a single field with that name.  */
  if (i1 == 1 && strchr (copy, '(') == NULL)
    {
      /* There is exactly one field with that name.  */
      sym = sym_arr[0];

      if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)
	{
	  values.sals = (struct symtab_and_line *)
	    xmalloc (sizeof (struct symtab_and_line));
	  values.nelts = 1;
	  values.sals[0] = find_function_start_sal (sym,
						    funfirstline);
	}
      else
	{
	  values.sals = NULL;
	  values.nelts = 0;
	}
      return values;
a1955 31
  if (i1 > 0)
    {
      /* If we were given a specific overload instance, use that
	 (or error if no matches were found).  Otherwise ask the user
	 which one to use.  */
      if (strchr (copy, '('))
	{
	  int i;
	  char *name;
	  char *canon;
	  struct cleanup *cleanup;

	  /* Construct the proper search name based on SYM_CLASS and COPY.
	     SAVED_ARG may contain a valid name, but that name might not be
	     what is actually stored in the symbol table.  For example,
	     if SAVED_ARG (and SYM_CLASS) were found via an import
	     ("using namespace" in C++), then the physname of
	     SYM_CLASS ("A::myclass") may not be the same as SAVED_ARG
	     ("myclass").  */
	  name = xmalloc (strlen (SYMBOL_NATURAL_NAME (sym_class))
			  + 2 /* "::" */ + strlen (copy) + 1);
	  strcpy (name, SYMBOL_NATURAL_NAME (sym_class));
	  strcat (name, "::");
	  strcat (name, copy);
	  canon = cp_canonicalize_string_no_typedefs (name);
	  if (canon != NULL)
	    {
	      xfree (name);
	      name = canon;
	    }
	  cleanup = make_cleanup (xfree, name);
d1957 72
a2028 13
	  for (i = 0; i < i1; ++i)
	    {
	      if (strcmp_iw (name, SYMBOL_LINKAGE_NAME (sym_arr[i])) == 0)
		{
		  values.sals = (struct symtab_and_line *)
		    xmalloc (sizeof (struct symtab_and_line));
		  values.nelts = 1;
		  values.sals[0] = find_function_start_sal (sym_arr[i],
							    funfirstline);
		  do_cleanups (cleanup);
		  return values;
		}
	    }
d2030 1
a2030 4
	  cplusplus_error (saved_arg, _("the class `%s' does not have "
					"any method instance named %s"),
				      SYMBOL_PRINT_NAME (sym_class), copy);
	}
d2032 1
a2032 1
      return decode_line_2 (sym_arr, i1, funfirstline, canonical);
d2034 5
d2040 28
d2069 2
a2070 8
      if (copy[0] == '~')
	cplusplus_error (saved_arg,
			 "the class `%s' does not have destructor defined\n",
			 SYMBOL_PRINT_NAME (sym_class));
      else
	cplusplus_error (saved_arg,
			 "the class %s does not have any method named %s\n",
			 SYMBOL_PRINT_NAME (sym_class), copy);
d2072 2
d2076 27
a2102 1

d2104 3
a2106 2
/* Return the symtab associated to the filename given by the substring
   of *ARGPTR ending at P, and advance ARGPTR past that filename.  */
d2108 3
a2110 2
static struct symtab *
symtab_from_filename (char **argptr, char *p, int is_quote_enclosed)
d2114 2
a2115 1
  struct symtab *file_symtab;
d2122 2
a2123 1
  copy = (char *) alloca (p - *argptr + 1);
d2132 3
a2134 3
  /* Find that file's data.  */
  file_symtab = lookup_symtab (copy);
  if (file_symtab == 0)
d2145 19
a2163 5
    return file_symtab;
  p = p1 + 1;
  while (*p == ' ' || *p == '\t')
    p++;
  *argptr = p;
d2165 1
a2165 1
  return file_symtab;
d2171 3
a2173 2
static struct symbol *
find_function_symbol (char **argptr, char *p, int is_quote_enclosed)
d2177 1
a2177 1
  struct symbol *function_symbol;
d2184 2
a2185 1
  copy = (char *) alloca (p - *argptr + 1);
d2194 2
a2195 4
  function_symbol = lookup_symbol (copy, get_selected_block (0),
				   VAR_DOMAIN, 0);
  if (!function_symbol || SYMBOL_CLASS (function_symbol) != LOC_BLOCK)
    return NULL;
d2197 7
a2203 5
  /* Discard the file name from the arg.  */
  p = p1 + 1;
  while (*p == ' ' || *p == '\t')
    p++;
  *argptr = p;
d2205 1
a2205 1
  return function_symbol;
d2210 71
d2286 3
a2288 4
decode_all_digits (char **argptr, struct symtab *default_symtab,
		   int default_line, struct linespec_result *canonical,
		   struct symtab *file_symtab, char *q)

d2292 2
a2300 3
  /* We might need a canonical line spec if no file was specified.  */
  int need_canonical = (file_symtab == NULL) ? 1 : 0;

d2302 2
a2303 2

  val.pspace = current_program_space;
d2311 2
a2312 1
  if (file_symtab == 0 && default_symtab == 0)
d2314 2
d2318 6
a2323 1
      initialize_defaults (&default_symtab, &default_line);
d2336 2
a2337 2
      if (file_symtab == 0)
	val.line = default_line + val.line;
d2342 2
a2343 2
      if (file_symtab == 0)
	val.line = default_line - val.line;
d2351 103
a2453 12
  while (*q == ' ' || *q == '\t')
    q++;
  *argptr = q;
  if (file_symtab == 0)
    file_symtab = default_symtab;

  /* It is possible that this source file has more than one symtab, 
     and that the new line number specification has moved us from the
     default (in file_symtab) to a new one.  */
  val.symtab = find_line_symtab (file_symtab, val.line, NULL, NULL);
  if (val.symtab == 0)
    val.symtab = file_symtab;
a2454 9
  val.pspace = SYMTAB_PSPACE (val.symtab);
  val.pc = 0;
  values.sals = (struct symtab_and_line *)
    xmalloc (sizeof (struct symtab_and_line));
  values.sals[0] = val;
  values.nelts = 1;
  if (need_canonical)
    build_canonical_line_spec (values.sals, NULL, canonical);
  values.sals[0].explicit_line = 1;
d2463 1
a2463 2
decode_dollar (char *copy, int funfirstline, struct symtab *default_symtab,
	       struct linespec_result *canonical, struct symtab *file_symtab)
a2466 1
  int need_canonical = 0;
d2472 2
d2495 12
a2506 13
      /* Look up entire name as a symbol first.  */
      sym = lookup_symbol (copy, 0, VAR_DOMAIN, 0);
      file_symtab = (struct symtab *) NULL;
      need_canonical = 1;
      /* Symbol was found --> jump to normal symbol processing.  */
      if (sym)
	return symbol_found (funfirstline, canonical, copy, sym, NULL, NULL);

      /* If symbol was not found, look in minimal symbol tables.  */
      msymbol = lookup_minimal_symbol (copy, NULL, NULL);
      /* Min symbol was found --> jump to minsym processing.  */
      if (msymbol)
	return minsym_found (funfirstline, msymbol);
d2516 18
a2533 5
  /* Either history value or convenience value from above, in valx.  */
  val.symtab = file_symtab ? file_symtab : default_symtab;
  val.line = valx;
  val.pc = 0;
  val.pspace = current_program_space;
d2535 2
a2536 3
  values.sals = (struct symtab_and_line *) xmalloc (sizeof val);
  values.sals[0] = val;
  values.nelts = 1;
d2538 9
a2546 2
  if (need_canonical)
    build_canonical_line_spec (values.sals, NULL, canonical);
d2555 1
a2555 1
   FUNCTION_SYMBOL is the enclosing function; or NULL if none
d2564 2
a2565 2
decode_label (struct symbol *function_symbol, char *copy,
	      struct linespec_result *canonical,
d2568 2
a2569 2
  struct symbol *sym;
  struct block *block;
d2571 1
a2571 3
  if (function_symbol)
    block = SYMBOL_BLOCK_VALUE (function_symbol);
  else
d2573 11
a2583 1
      block = get_selected_block (0);
d2590 138
a2727 1
      function_symbol = BLOCK_FUNCTION (block);
d2729 32
d2762 3
a2764 1
  sym = lookup_symbol (copy, block, LABEL_DOMAIN, 0);
d2766 11
a2776 2
  if (sym != NULL)
    *result = symbol_found (0, canonical, copy, sym, NULL, function_symbol);
d2778 18
a2795 1
  return sym != NULL;
d2802 1
a2802 3
decode_variable (char *copy, int funfirstline,
		 struct linespec_result *canonical,
		 struct symtab *file_symtab)
d2804 3
a2806 2
  char *name, *canon;
  struct symbol *sym;
a2807 1
  struct minimal_symbol *msymbol;
d2809 16
a2824 3
  name = copy;
  cleanup = make_cleanup (null_cleanup, NULL);
  canon = cp_canonicalize_string_no_typedefs (copy);
d2827 2
a2828 2
      name = canon;
      make_cleanup (xfree, name);
d2831 1
a2831 1
  sym = lookup_symbol (name, get_search_block (file_symtab), VAR_DOMAIN, 0);
d2833 1
a2833 1
  if (sym != NULL)
d2835 10
a2844 3
      do_cleanups (cleanup);
      return symbol_found (funfirstline, canonical, copy, sym,
			   file_symtab, NULL);
a2846 6
  msymbol = lookup_minimal_symbol (name, NULL, NULL);
  do_cleanups (cleanup);

  if (msymbol != NULL)
    return minsym_found (funfirstline, msymbol);

d2852 5
a2856 1
  throw_error (NOT_FOUND_ERROR, _("Function \"%s\" not defined."), copy);
d2865 3
a2867 7
/* We've found a symbol SYM to associate with our linespec; build a
   corresponding struct symtabs_and_lines.  */

static struct symtabs_and_lines
symbol_found (int funfirstline, struct linespec_result *canonical, char *copy,
	      struct symbol *sym, struct symtab *file_symtab,
	      struct symbol *function_symbol)
a2868 2
  struct symtabs_and_lines values;
  
d2871 2
a2872 21
      /* Arg is the name of a function.  */
      values.sals = (struct symtab_and_line *)
	xmalloc (sizeof (struct symtab_and_line));
      values.sals[0] = find_function_start_sal (sym, funfirstline);
      values.nelts = 1;

      /* Don't use the SYMBOL_LINE; if used at all it points to
	 the line containing the parameters or thereabouts, not
	 the first line of code.  */

      /* We might need a canonical line spec if it is a static
	 function.  */
      if (file_symtab == 0)
	{
	  struct blockvector *bv = BLOCKVECTOR (SYMBOL_SYMTAB (sym));
	  struct block *b = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);

	  if (lookup_block_symbol (b, copy, VAR_DOMAIN) != NULL)
	    build_canonical_line_spec (values.sals, copy, canonical);
	}
      return values;
d2878 7
a2884 22
	  /* We know its line number.  */
	  values.sals = (struct symtab_and_line *)
	    xmalloc (sizeof (struct symtab_and_line));
	  values.nelts = 1;
	  init_sal (&values.sals[0]);
	  values.sals[0].symtab = SYMBOL_SYMTAB (sym);
	  values.sals[0].line = SYMBOL_LINE (sym);
	  values.sals[0].pc = SYMBOL_VALUE_ADDRESS (sym);
	  values.sals[0].pspace = SYMTAB_PSPACE (SYMBOL_SYMTAB (sym));
	  values.sals[0].explicit_pc = 1;

	  if (canonical)
	    {
	      canonical->special_display = 1;
	      canonical->canonical = xmalloc (sizeof (char *));
	      canonical->canonical[0]
		= xstrprintf ("%s:%s",
			      SYMBOL_NATURAL_NAME (function_symbol),
			      SYMBOL_NATURAL_NAME (sym));
	    }

	  return values;
d2888 1
a2888 4
	  /* NOT_FOUND_ERROR is not correct but it ensures COPY will be
	     searched also as a minimal symbol.  */

	  throw_error (NOT_FOUND_ERROR, _("\"%s\" is not a function"), copy);
d2893 5
a2897 8
	  values.sals = (struct symtab_and_line *)
	    xmalloc (sizeof (struct symtab_and_line));
	  values.nelts = 1;
	  memset (&values.sals[0], 0, sizeof (values.sals[0]));
	  values.sals[0].symtab = SYMBOL_SYMTAB (sym);
	  values.sals[0].line = SYMBOL_LINE (sym);
	  values.sals[0].pspace = SYMTAB_PSPACE (SYMBOL_SYMTAB (sym));
	  return values;
a2898 7
      else
	/* This can happen if it is compiled with a compiler which doesn't
	   put out line numbers for variables.  */
	/* FIXME: Shouldn't we just set .line and .symtab to zero
	   and return?  For example, "info line foo" could print
	   the address.  */
	error (_("Line number not known for symbol \"%s\""), copy);
d2900 2
d2904 1
a2904 2
/* We've found a minimal symbol MSYMBOL to associate with our
   linespec; build a corresponding struct symtabs_and_lines.  */
d2906 2
a2907 2
static struct symtabs_and_lines
minsym_found (int funfirstline, struct minimal_symbol *msymbol)
d2909 4
a2912 4
  struct objfile *objfile = msymbol_objfile (msymbol);
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  struct symtabs_and_lines values;
  CORE_ADDR pc;
d2914 5
a2918 5
  values.sals = (struct symtab_and_line *)
    xmalloc (sizeof (struct symtab_and_line));
  values.sals[0] = find_pc_sect_line (SYMBOL_VALUE_ADDRESS (msymbol),
				      (struct obj_section *) 0, 0);
  values.sals[0].section = SYMBOL_OBJ_SECTION (msymbol);
d2920 8
a2927 7
  /* The minimal symbol might point to a function descriptor;
     resolve it to the actual code address instead.  */
  pc = gdbarch_convert_from_func_ptr_addr (gdbarch,
                                           values.sals[0].pc,
                                           &current_target);
  if (pc != values.sals[0].pc)
    values.sals[0] = find_pc_sect_line (pc, NULL, 0);
d2929 1
a2929 2
  if (funfirstline)
    skip_prologue_sal (&values.sals[0]);
d2931 4
a2934 2
  values.nelts = 1;
  return values;
d2937 4
a2940 2
void
init_linespec_result (struct linespec_result *lr)
d2942 1
a2942 1
  memset (lr, 0, sizeof (*lr));
@


1.130
log
@	* linespec.c (symtab_from_filename): Check for the end of string.
@
text
@d46 1
d1198 10
@


1.129
log
@	PR c++/12266
	* cp-name-parser.y (struct demangle_info): Remove unused
	member PREV.
	(d_grab): Likewise.
	(allocate_info): Change return type to struct demangle_info *.
	Always allocate a new demangle_info.
	Remove unused PREV pointer.
	(cp_new_demangle_parse_info): New function.
	(cp_demangled_name_parse_free): New function.
	(do_demangled_name_parse_free_cleanup): New function.
	(make_cleanup_cp_demangled_name_parse_free): New function.
	(cp_demangled_name_to_comp): Change return type to
	struct demangle_parse_info *.
	Allocate a new storage for each call.
	(main): Update usage for cp_demangled_name_to_comp
	API change.
	* cp-support.h (struct demangle_parse_info): New structure.
	(cp_demangled_name_to_comp): Update API change for
	return type.
	(cp_new_demangle_parse_info): Declare.
	(make_cleanup_cp_demangled_name_parse_free): New declaration.
	(cp_demangled_name_parse_free): Declare.
	* cp-support.c (cp_canonicalize_string): Update API
	change for cp_demangled_name_to_comp.
	(mangled_name_to_comp): Likewise.
	Return struct demangle_parse_info, too.
	(cp_class_name_from_physname): Update mangled_name_to_comp
	API change.
	(method_name_from_physname): Likewise.
	(cp_func_name): Update API change for cp_demangled_name_to_comp.
	(cp_remove_params): Likewise.
	* python/py-type.c (typy_legacy_template_argument): Likewise.

	* cp-support.h (cp_canonicalize_string_no_typedefs): Declare.
	(cp_merge_demangle_parse_infos): Declare.
	* cp-support.c (ignore_typedefs): New file global.
	(copy_string_to_obstack): New function.
	(inspect_type): New function.
	(replace_typedefs): New function.
	(replace_typedefs_qualified_name): New function.
	(cp_canonicalize_string_no_typedefs): New function.
	* cp-name-parser.y (cp_merge_demangle_parse_infos): New function.
	(cp_new_demangle__parse_info): Allocate and initialize the obstack.
	* linespec.c (find_methods): Use cp_canonicalize_string_no_typedefs
	instead of cp_canonicalize_string.
	(find_method): Likewise.
	(decode_compound): Before looking up the name, call
	cp_canonicalize_string_no_typedefs.
	(decode_variable): Likewise.
@
text
@d1838 2
@


1.128
log
@	* symtab.c (operator_chars): Now static.
	* linespec.c (operator_chars): Don't declare.
@
text
@d248 1
a248 1
  canon = cp_canonicalize_string (name);
d1368 1
a1368 1
  char *p2;
d1376 1
d1601 12
a1612 1
  sym = lookup_symbol (copy, get_selected_block (0), VAR_DOMAIN, 0);
d1758 1
a1758 1
	  canon = cp_canonicalize_string (name);
d2100 1
d2102 1
d2105 10
a2114 2
  sym = lookup_symbol (copy, get_search_block (file_symtab),
		       VAR_DOMAIN, 0);
d2117 5
a2121 1
    return symbol_found (funfirstline, canonical, copy, sym, file_symtab, NULL);
d2123 2
a2124 1
  msymbol = lookup_minimal_symbol (copy, NULL, NULL);
@


1.127
log
@	* breakpoint.c: Fix typos in comments.
	* linespec.c: Likewise.
	* symtab.c: Likewise.
@
text
@a46 4
/* We share this one with symtab.c, but it is not exported widely.  */

extern char *operator_chars (char *, char **);

@


1.126
log
@gdb/
	Fix false GCC warning.
	* linespec.c (decode_line_1): Initialize values.
@
text
@d831 1
a831 1
  /* Is *ARGPTR is enclosed in double quotes?  */
@


1.125
log
@gdb/
	* linespec.c (find_method): Accept the function type automatically only
	if it was specified with parameter types.

gdb/testsuite/
	* gdb.cp/paren-type.cc: New files.
	* gdb.cp/paren-type.exp: New files.
@
text
@d935 3
@


1.124
log
@gdb/
	Stop on first linespec terminator instead of eating what we can.
	* linespec.c (is_linespec_boundary): New function.
	(name_end): Remove function.
	(keep_name_info): New parameter on_boundary, replace the body.
	(decode_line_1): Provide the parameter to keep_name_info.
	(decode_compound): Likewise.  Drop the trailing java return type
	handling.  Twice.

gdb/testsuite/
	Stop on first linespec terminator instead of eating what we can.
	* gdb.cp/minsym-fallback-main.cc (main): Call also C::operator ().
	* gdb.cp/minsym-fallback.cc (C::operator ()): Define.
	* gdb.cp/minsym-fallback.exp (break 'C::f()'): Change to ...
	(break C::f()): ... this one.
	(break C::operator()()): New test.
	* gdb.cp/minsym-fallback.h (C::operator ()): Declare.
	* gdb.java/jmisc.exp (break jmisc.main(java.lang.String[])int): New
	test.
@
text
@d1700 4
a1703 1
  if (i1 == 1)
@


1.123
log
@gdb/
	Fall back linespec to minimal symbols.
	* linespec.c (decode_line_1): New variable ex, saved_argptr.  Protect
	decode_compound by TRY_CATCH, fall back on minsyms if it failed.
	(find_method, symbol_found): Change error to cplusplus_error.

gdb/testsuite/
	Fall back linespec to minimal symbols.
	* gdb.base/psymtab.exp (Don't search past end of psymtab.): Update the
	error message.
	* gdb.cp/cplusfuncs.exp (list foo::operator int*): Likewise.
	* gdb.cp/minsym-fallback-main.cc: New file.
	* gdb.cp/minsym-fallback.cc: New file.
	* gdb.cp/minsym-fallback.exp: New file.
	* gdb.cp/minsym-fallback.h: New file.
@
text
@d682 8
d721 3
a723 2
/* Does P point to a sequence of characters which implies the end
   of a name?  Terminals include "if" and "thread" clauses. */
d725 2
a726 2
static int
name_end (char *p)
d728 3
a730 9
  while (isspace (*p))
    ++p;
  if (*p == 'i' && p[1] == 'f'
      && (isspace (p[2]) || p[2] == '\0' || p[2] == '('))
    return 1;

  if (strncmp (p, "thread", 6) == 0
      && (isspace (p[6]) || p[6] == '\0'))
    return 1;
d732 4
a735 2
  return 0;
}
d737 2
a738 2
/* Keep important information used when looking up a name.  This includes
   template parameters, overload information, and important keywords.  */
d740 4
a743 5
static char *
keep_name_info (char *ptr)
{
  char *p = ptr;
  char *start = ptr;
d745 7
a751 3
  /* Keep any template parameters.  */
  if (name_end (ptr))
    return remove_trailing_whitespace (start, ptr);
d753 4
a756 3
  p = skip_spaces (p);
  if (*p == '<')
    ptr = p = find_template_name_end (ptr);
d758 1
a758 2
  if (name_end (ptr))
    return remove_trailing_whitespace (start, ptr);
d760 2
a761 3
  /* Keep method overload information.  */
  if (*p == '(')
    ptr = p = find_method_overload_end (p);
d763 2
a764 2
  if (name_end (ptr))
    return remove_trailing_whitespace (start, ptr);
d766 2
a767 16
  /* Keep important keywords.  */  
  while (1)
    {
      char *quotes = get_gdb_completer_quote_characters ();
      p = skip_spaces (p);
      if (strncmp (p, "const", 5) == 0
	  && (isspace (p[5]) || p[5] == '\0'
	      || strchr (quotes, p[5]) != NULL))
	ptr = p = p + 5;
      else if (strncmp (p, "volatile", 8) == 0
	       && (isspace (p[8]) || p[8] == '\0'
		   || strchr (quotes, p[8]) != NULL))
	ptr = p = p + 8;
      else
	break;
    }
d769 1
a769 1
  return remove_trailing_whitespace (start, ptr);
d1030 1
a1030 1
  p = keep_name_info (p);
a1375 1
  char *saved_java_argptr = NULL;
d1553 1
a1553 25
	  p = keep_name_info (p);

	  /* Java may append typenames,  so assume that if there is
	     anything else left in *argptr, it must be a typename.  */
	  if (*p && current_language->la_language == language_java)
	    {
	      struct type *type;

	      p2 = p;
	      while (*p2)
		++p2;
	      copy = (char *) alloca (p2 - p + 1);
	      memcpy (copy, p, p2 - p);
	      copy[p2 - p] = '\0';
	      type = lookup_typename (current_language, get_current_arch (),
				      copy, NULL, 1);
	      if (type != NULL)
		{
		  /* Save the location of this just in case this
		     method/type combination isn't actually defined.
		     It will be checked later.  */
		  saved_java_argptr = p;
		  p = p2;
		}
	    }
d1582 2
a1583 21
      values = find_method (funfirstline, canonical, saved_arg,
			    copy, t, sym_class, file_symtab);
      if (saved_java_argptr != NULL && values.nelts == 1)
	{
	  /* The user specified a specific return type for a java method.
	     Double-check that it really is the one the user specified.
	     [This is a necessary evil because strcmp_iw_ordered stops
	     comparisons too prematurely.]  */
	  sym = find_pc_sect_function (values.sals[0].pc,
				       values.sals[0].section);
	  /* We just found a SAL, we had better be able to go backwards!  */
	  gdb_assert (sym != NULL);
	  if (strcmp_iw (SYMBOL_LINKAGE_NAME (sym), saved_arg) != 0)
	    {
	      xfree (values.sals);
	      error (_("the class `%s' does not have "
		       "any method instance named %s"),
		     SYMBOL_PRINT_NAME (sym_class), copy);
	    }
	}
      return values;
d1590 1
a1590 1
  p = keep_name_info (p);
@


1.122
log
@	PR c++/12750
	* linespec.c (get_search_block): New function.
	(find_methods): Add FILE_SYMTATB parameter and use it and
	get_search_block to pass an appropriate block to
	lookup_symbol_in_namespace.
	(decode_line_1): Record if *ARGPTR is single-quote enclosed.
	Check if *ARGPTR starts with a filename first.
	If it does, call locate_first_half again to locate the next
	"first half" of the linespec.
	Pass FILE_SYMTATB to decode_objc and decode_compound.
	Swallow the trailing single-quote if IS_SQUOTE_ENCLOSED.
	(locate_first_half): Stop on the first colon seen.
	(decode_compound): Add FILE_SYMTAB parameter.
	Pass FILE_SYMTAB to lookup_prefix_sym and find_method.
	(lookup_prefix_sym): Add FILE_SYMTAB parameter and use
	get_search_block with lookup_symbol.
	(find_method): Add FILE_SYMTAB parameter and pass it to
	find_methods.
	(decode_objc): Use get_search_block.
@
text
@d936 2
d941 6
a946 2
	  values = decode_compound (argptr, funfirstline, canonical,
				    file_symtab, saved_arg, p);
d949 8
a956 1
	  return values;
d958 13
d972 9
a980 19
      /* If there was an exception looking up a specified filename earlier,
	 then check whether we were really given `function:label'.   */
      if (file_exception.reason < 0)
	{
	  function_symbol = find_function_symbol (argptr, p, is_quote_enclosed);
	  /* If we did not find a function, re-throw the original
	     exception.  */
	  if (!function_symbol)
	    throw_exception (file_exception);
	}

      /* Check for single quotes on the non-filename part.  */
      if (!is_quoted)
	{
	  is_quoted = (**argptr
		       && strchr (get_gdb_completer_quote_characters (),
				  **argptr) != NULL);
	  if (is_quoted)
	    end_quote = skip_quoted (*argptr);
d1817 3
a1819 3
	  error (_("the class `%s' does not have "
		   "any method instance named %s"),
		 SYMBOL_PRINT_NAME (sym_class), copy);
d2227 6
a2232 1
	error (_("\"%s\" is not a function"), copy);
@


1.121
log
@	PR symtab/12704
	* cp-namespace.c (ANONYMOUS_NAMESPACE_LEN): Remove.
	(cp_scan_for_anonymous_namespaces): Use CP_ANONYMOUS_NAMESPACE_STR
	and CP_ANONYMOUS_NAMESPACE_LEN.
	(cp_is_anonymous): Likewise.
	* cp-support.h (CP_ANONYMOUS_NAMESPACE_STR): Define.
	(CP_ANONYMOUS_NAMESPACE_LEN): Define.
	* dwarf2read.c (namespace_name): Likewise.
	(fixup_partial_die): Likewise.
	* linespec.c (decode_compound): If CP_ANONYMOUS_NAMESPACE_STR is
	seen in the input, keep it.
@
text
@d69 1
d73 2
a74 1
static struct symbol *lookup_prefix_sym (char **argptr, char *p);
d81 2
a82 1
					     struct symbol *sym_class);
d90 1
a90 1
			 enum language, struct symbol **);
d209 24
d242 1
a242 1
	      struct symbol **sym_arr)
d265 1
a265 1
      && (lookup_symbol_in_language (class_name, (struct block *) NULL,
d320 1
a320 1
			  language, sym_arr + i1);
d844 2
d869 5
a873 1
    end_quote = skip_quoted (*argptr);
d886 20
d916 1
a916 1
    values = decode_objc (argptr, funfirstline, NULL,
d940 2
a941 2
				    saved_arg, p);
	  if (is_quoted && **argptr == '\'')
d946 2
a947 8
      /* No, the first part is a filename; set file_symtab to be that file's
	 symtab.  Also, move argptr past the filename.  */

      TRY_CATCH (file_exception, RETURN_MASK_ERROR)
	{
	  file_symtab = symtab_from_filename (argptr, p, is_quote_enclosed);
	}
      /* If that failed, maybe we have `function:label'.  */
d1004 1
a1004 1
  else if (is_quoted)
d1034 1
a1034 1
  else if (is_quoted)
d1210 2
a1211 3
         line, a tab, a double colon or the last single colon, or a
         space.  But if enclosed in double quotes we do not break on
         enclosed spaces.  */
d1214 1
a1214 2
	  || ((p[0] == ':')
	      && ((p[1] == ':') || (strchr (p + 1, ':') == NULL)))
d1273 2
a1274 14
  if (file_symtab != NULL)
    block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (file_symtab), STATIC_BLOCK);
  else
    {
      enum language save_language;

      /* get_selected_block can change the current language when there is
	 no selected frame yet.  */
      save_language = current_language->la_language;
      block = get_selected_block (0);
      set_language (save_language);
    }

  find_imps (file_symtab, block, *argptr, NULL, &i1, &i2); 
d1356 1
a1356 1
		 struct linespec_result *canonical,
d1504 1
a1504 1
  sym_class = lookup_prefix_sym (argptr, p2);
d1599 1
a1599 1
			    copy, t, sym_class);
d1667 1
a1667 1
lookup_prefix_sym (char **argptr, char *p)
d1690 1
a1690 1
  sym = lookup_symbol (copy, get_selected_block (0), STRUCT_DOMAIN, 0);
d1720 2
a1721 1
	     char *copy, struct type *t, struct symbol *sym_class)
d1732 2
a1733 1
  i1 = find_methods (t, copy, SYMBOL_LANGUAGE (sym_class), sym_arr);
d2124 1
a2124 5
  sym = lookup_symbol (copy,
		       (file_symtab
			? BLOCKVECTOR_BLOCK (BLOCKVECTOR (file_symtab),
					     STATIC_BLOCK)
			: get_selected_block (0)),
@


1.120
log
@	PR breakpoint/12803
	* linespec.c (keep_name_info): Add handling for "volatile" keyword.
	(decode_compound): Unconditionally call	keep_name_info.
@
text
@d1433 9
a1441 2
	      if (*p && strchr (break_characters, *p) == NULL)
		p++;
@


1.119
log
@	* value.c (value_fn_field): Constify.
	* symtab.c (gdb_mangle_name): Constify.
	* stabsread.c (update_method_name_from_physname): Make 'physname'
	argument const.
	* p-typeprint.c (pascal_type_print_method_args): Make arguments
	const.  Use explicit fputc_filtered loop.
	(pascal_type_print_base): Constify.
	* p-lang.h (pascal_type_print_method_args): Update.
	* linespec.c (add_matching_methods): Constify.
	(add_constructors): Likewise.
	* jv-typeprint.c (java_type_print_base): Constify.
	* gdbtypes.h (struct cplus_struct_type)
	<fn_fieldlist.fn_field.physname>: Now const.
	* dwarf2read.c (compute_delayed_physnames): Constify.
	(dwarf2_add_member_fn): Likewise.
	* c-typeprint.c (c_type_print_base): Constify.  Use cleanups.
@
text
@d718 1
a718 2
  while (isspace (*p))
    ++p;
d733 15
a747 6
  while (isspace (*p))
    ++p;
  if (strncmp (p, "const", 5) == 0
      && (isspace (p[5]) || p[5] == '\0'
	  || strchr (get_gdb_completer_quote_characters (), p[5]) != NULL))
    ptr = p = p + 5;
d1585 1
a1585 3
  if (current_language->la_language == language_cplus
      || current_language->la_language == language_java)
    p = keep_name_info (p);
@


1.118
log
@	* tracepoint.c (scope_info): Update.
	* symtab.c (decode_line_spec): Update.
	* python/python.c (gdbpy_decode_line): Update.
	* linespec.h (decode_line_1): Update.
	* linespec.c (decode_line_1): Remove 'not_found_ptr' argument.
	(decode_compound, find_method, symtab_from_filename)
	(decode_variable): Likewise.
	* cli/cli-cmds.c (edit_command): Update.
	(list_command): Update.
	* breakpoint.c (parse_breakpoint_sals): Remove 'not_found_ptr'
	argument.
	(create_breakpoint): Update.
	(until_break_command): Update.
	(addr_string_to_sals): Update.
	(decode_line_spec_1): Update.
@
text
@d315 1
a315 1
      char *phys_name;
d321 1
a321 1
	  char *tmp_name;
d326 2
a327 2
	  phys_name = alloca (strlen (tmp_name) + 1);
	  strcpy (phys_name, tmp_name);
d329 1
d377 1
a377 1
      char *phys_name;
@


1.117
log
@	* linespec.c (symbol_found): Restore line-based result for
	non-LOC_LABEL symbols.
@
text
@d70 1
a70 2
						 char *p,
						 int *not_found_ptr);
d79 1
a79 2
					     struct symbol *sym_class,
					     int *not_found_ptr);
d109 1
a109 2
					    char *p, int is_quote_enclosed,
					    int *not_found_ptr);
d135 1
a135 2
						 struct symtab *file_symtab,
						 int *not_found_ptr);
d782 1
a782 6
   Also, the line number returned may be invalid.  
 
   If NOT_FOUND_PTR is not null, store a boolean true/false value at
   the location, based on whether or not failure occurs due to an
   unknown function or file.  In the case where failure does occur due
   to an unknown function or file, do not issue an error message.  */
d791 1
a791 2
	       int default_line, struct linespec_result *canonical,
	       int *not_found_ptr)
a817 3
  if (not_found_ptr)
    *not_found_ptr = 0;

d878 1
a878 1
				    saved_arg, p, not_found_ptr);
d889 1
a889 2
	  file_symtab = symtab_from_filename (argptr, p, is_quote_enclosed,
					      not_found_ptr);
a898 2
	  if (not_found_ptr)
	    *not_found_ptr = 0;
d1003 1
a1003 5
    {
      if (not_found_ptr)
	*not_found_ptr = 1;
      throw_exception (file_exception);
    }
d1008 1
a1008 2
  return decode_variable (copy, funfirstline, canonical,
			  file_symtab, not_found_ptr);
d1315 1
a1315 1
		 char *the_real_saved_arg, char *p, int *not_found_ptr)
d1550 1
a1550 1
			    copy, t, sym_class, not_found_ptr);
a1603 2
  if (not_found_ptr)
    *not_found_ptr = 1;
d1673 1
a1673 2
	     char *copy, struct type *t, struct symbol *sym_class,
	     int *not_found_ptr)
a1760 2
      if (not_found_ptr)
        *not_found_ptr = 1;
d1775 1
a1775 4
   of *ARGPTR ending at P, and advance ARGPTR past that filename.  If
   NOT_FOUND_PTR is not null and the source file is not found, store
   boolean true at the location pointed to and do not issue an
   error message.  */
d1778 1
a1778 2
symtab_from_filename (char **argptr, char *p, int is_quote_enclosed, 
		      int *not_found_ptr)
a1801 2
      if (not_found_ptr)
	*not_found_ptr = 1;
d2065 1
a2065 3
   look in that symtab's static variables first.  If NOT_FOUND_PTR is
   not NULL and the function cannot be found, store boolean true in
   the location pointed to and do not issue an error message.  */ 
d2070 1
a2070 1
		 struct symtab *file_symtab, int *not_found_ptr)
a2089 3
  if (not_found_ptr)
    *not_found_ptr = 1;

@


1.117.2.1
log
@commit 7f71565092a430e0a7509868b7279497db6f7cbe
Author: Tom Tromey <tromey@@redhat.com>
Date:   Mon Apr 4 17:41:05 2011 +0000

gdb/
	* tracepoint.c (scope_info): Update.
	* symtab.c (decode_line_spec): Update.
	* python/python.c (gdbpy_decode_line): Update.
	* linespec.h (decode_line_1): Update.
	* linespec.c (decode_line_1): Remove 'not_found_ptr' argument.
	(decode_compound, find_method, symtab_from_filename)
	(decode_variable): Likewise.
	* cli/cli-cmds.c (edit_command): Update.
	(list_command): Update.
	* breakpoint.c (parse_breakpoint_sals): Remove 'not_found_ptr'
	argument.
	(create_breakpoint): Update.
	(until_break_command): Update.
	(addr_string_to_sals): Update.
	(decode_line_spec_1): Update.
@
text
@d70 2
a71 1
						 char *p);
d80 2
a81 1
					     struct symbol *sym_class);
d111 2
a112 1
					    char *p, int is_quote_enclosed);
d138 2
a139 1
						 struct symtab *file_symtab);
d786 6
a791 1
   Also, the line number returned may be invalid.  */
d800 2
a801 1
	       int default_line, struct linespec_result *canonical)
d828 3
d891 1
a891 1
				    saved_arg, p);
d902 2
a903 1
	  file_symtab = symtab_from_filename (argptr, p, is_quote_enclosed);
d913 2
d1019 5
a1023 1
    throw_exception (file_exception);
d1028 2
a1029 1
  return decode_variable (copy, funfirstline, canonical, file_symtab);
d1336 1
a1336 1
		 char *the_real_saved_arg, char *p)
d1571 1
a1571 1
			    copy, t, sym_class);
d1625 2
d1696 2
a1697 1
	     char *copy, struct type *t, struct symbol *sym_class)
d1785 2
d1801 4
a1804 1
   of *ARGPTR ending at P, and advance ARGPTR past that filename.  */
d1807 2
a1808 1
symtab_from_filename (char **argptr, char *p, int is_quote_enclosed)
d1832 2
d2097 3
a2099 1
   look in that symtab's static variables first.  */ 
d2104 1
a2104 1
		 struct symtab *file_symtab)
d2124 3
@


1.117.2.2
log
@commit 2bdc820adfead6aa7fdb16242280473af1040d4e
Author: Keith Seitz <keiths@@redhat.com>
Date:   Tue May 24 21:00:04 2011 +0000

gdb/
	PR breakpoint/12803
	* linespec.c (keep_name_info): Add handling for "volatile" keyword.
	(decode_compound): Unconditionally call	keep_name_info.
@
text
@d717 2
a718 1
  p = skip_spaces (p);
d733 6
a738 15
  while (1)
    {
      char *quotes = get_gdb_completer_quote_characters ();
      p = skip_spaces (p);
      if (strncmp (p, "const", 5) == 0
	  && (isspace (p[5]) || p[5] == '\0'
	      || strchr (quotes, p[5]) != NULL))
	ptr = p = p + 5;
      else if (strncmp (p, "volatile", 8) == 0
	       && (isspace (p[8]) || p[8] == '\0'
		   || strchr (quotes, p[8]) != NULL))
	ptr = p = p + 8;
      else
	break;
    }
d1576 3
a1578 1
  p = keep_name_info (p);
@


1.117.2.3
log
@commit f658463559c9f03672b0fd226e4941f159e65bc0
Author: Keith Seitz <keiths@@redhat.com>
Date:   Tue May 31 21:54:06 2011 +0000

gdb/
	PR symtab/12704
	* cp-namespace.c (ANONYMOUS_NAMESPACE_LEN): Remove.
	(cp_scan_for_anonymous_namespaces): Use CP_ANONYMOUS_NAMESPACE_STR
	and CP_ANONYMOUS_NAMESPACE_LEN.
	(cp_is_anonymous): Likewise.
	* cp-support.h (CP_ANONYMOUS_NAMESPACE_STR): Define.
	(CP_ANONYMOUS_NAMESPACE_LEN): Define.
	* dwarf2read.c (namespace_name): Likewise.
	(fixup_partial_die): Likewise.
	* linespec.c (decode_compound): If CP_ANONYMOUS_NAMESPACE_STR is
	seen in the input, keep it.
@
text
@d1432 2
a1433 9
	      if (*p)
		{
		  if (p[1] == '('
		      && strncmp (&p[1], CP_ANONYMOUS_NAMESPACE_STR,
				  CP_ANONYMOUS_NAMESPACE_LEN) == 0)
		    p += CP_ANONYMOUS_NAMESPACE_LEN;
		  else if (strchr (break_characters, *p) == NULL)
		    ++p;
		}
@


1.117.2.4
log
@commit 835cf7647bf08d33e2c7286b45658cc58704b363
Author: Keith Seitz <keiths@@redhat.com>
Date:   Tue May 31 22:13:51 2011 +0000

gdb/
	PR c++/12750
	* linespec.c (get_search_block): New function.
	(find_methods): Add FILE_SYMTATB parameter and use it and
	get_search_block to pass an appropriate block to
	lookup_symbol_in_namespace.
	(decode_line_1): Record if *ARGPTR is single-quote enclosed.
	Check if *ARGPTR starts with a filename first.
	If it does, call locate_first_half again to locate the next
	"first half" of the linespec.
	Pass FILE_SYMTATB to decode_objc and decode_compound.
	Swallow the trailing single-quote if IS_SQUOTE_ENCLOSED.
	(locate_first_half): Stop on the first colon seen.
	(decode_compound): Add FILE_SYMTAB parameter.
	Pass FILE_SYMTAB to lookup_prefix_sym and find_method.
	(lookup_prefix_sym): Add FILE_SYMTAB parameter and use
	get_search_block with lookup_symbol.
	(find_method): Add FILE_SYMTAB parameter and pass it to
	find_methods.
	(decode_objc): Use get_search_block.
@
text
@a68 1
						 struct symtab *file_symtab,
d72 1
a72 2
static struct symbol *lookup_prefix_sym (char **argptr, char *p,
					 struct symtab *);
d79 1
a79 2
					     struct symbol *sym_class,
					     struct symtab *);
d87 1
a87 1
			 enum language, struct symbol **, struct symtab *);
a205 24
/* Returns the block to be used for symbol searches for the given SYMTAB,
   which may be NULL.  */

static struct block *
get_search_block (struct symtab *symtab)
{
  struct block *block;

  if (symtab != NULL)
    block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), STATIC_BLOCK);
  else
    {
      enum language save_language;

      /* get_selected_block can change the current language when there is
	 no selected frame yet.  */
      save_language = current_language->la_language;
      block = get_selected_block (0);
      set_language (save_language);
    }

  return block;
}

d215 1
a215 1
	      struct symbol **sym_arr, struct symtab *file_symtab)
d238 1
a238 1
      && (lookup_symbol_in_language (class_name, get_search_block (file_symtab),
d293 1
a293 1
			  language, sym_arr + i1, file_symtab);
a815 2
  /* Is *ARGPTR enclosed in single quotes?  */
  int is_squote_enclosed = 0;
d839 1
a839 5
    {
      end_quote = skip_quoted (*argptr);
      if (*end_quote == '\0')
	is_squote_enclosed = 1;
    }
a851 20
  /* First things first: if ARGPTR starts with a filename, get its
     symtab and strip the filename from ARGPTR.  */
  TRY_CATCH (file_exception, RETURN_MASK_ERROR)
    {
      file_symtab = symtab_from_filename (argptr, p, is_quote_enclosed);
    }

  if (file_exception.reason >= 0)
    {
      /* Check for single quotes on the non-filename part.  */
      is_quoted = (**argptr
		   && strchr (get_gdb_completer_quote_characters (),
			      **argptr) != NULL);
      if (is_quoted)
	end_quote = skip_quoted (*argptr);

      /* Locate the next "half" of the linespec.  */
      first_half = p = locate_first_half (argptr, &is_quote_enclosed);
    }

d862 1
a862 1
    values = decode_objc (argptr, funfirstline, file_symtab,
d886 2
a887 2
				    file_symtab, saved_arg, p);
	  if ((is_quoted || is_squote_enclosed) && **argptr == '\'')
d892 8
a899 2
      /* If there was an exception looking up a specified filename earlier,
	 then check whether we were really given `function:label'.   */
d956 1
a956 1
  else if (is_quoted || is_squote_enclosed)
d986 1
a986 1
  else if (is_quoted || is_squote_enclosed)
d1162 3
a1164 2
         line, a tab, a colon or a space.  But if enclosed in double
	 quotes we do not break on enclosed spaces.  */
d1167 2
a1168 1
	  || (p[0] == ':')
d1227 14
a1240 2
  find_imps (file_symtab, get_search_block (file_symtab), *argptr,
	     NULL, &i1, &i2); 
d1322 1
a1322 1
		 struct linespec_result *canonical, struct symtab *file_symtab,
d1470 1
a1470 1
  sym_class = lookup_prefix_sym (argptr, p2, file_symtab);
d1565 1
a1565 1
			    copy, t, sym_class, file_symtab);
d1633 1
a1633 1
lookup_prefix_sym (char **argptr, char *p, struct symtab *file_symtab)
d1656 1
a1656 1
  sym = lookup_symbol (copy, get_search_block (file_symtab), STRUCT_DOMAIN, 0);
d1686 1
a1686 2
	     char *copy, struct type *t, struct symbol *sym_class,
	     struct symtab *file_symtab)
d1697 1
a1697 2
  i1 = find_methods (t, copy, SYMBOL_LANGUAGE (sym_class), sym_arr,
		     file_symtab);
d2088 5
a2092 1
  sym = lookup_symbol (copy, get_search_block (file_symtab),
@


1.117.2.5
log
@commit 2daaa790297294478cb724dbec677879580bb2cf
Author: Jan Kratochvil <jan.kratochvil@@redhat.com>
Date:   Fri Jul 1 20:16:38 2011 +0000

gdb/
	Fall back linespec to minimal symbols.
	* linespec.c (decode_line_1): New variable ex, saved_argptr.  Protect
	decode_compound by TRY_CATCH, fall back on minsyms if it failed.
	(find_method, symbol_found): Change error to cplusplus_error.

gdb/testsuite/
	Fall back linespec to minimal symbols.
	* gdb.base/psymtab.exp (Don't search past end of psymtab.): Update the
	error message.
	* gdb.cp/cplusfuncs.exp (list foo::operator int*): Likewise.
	* gdb.cp/minsym-fallback-main.cc: New file.
	* gdb.cp/minsym-fallback.cc: New file.
	* gdb.cp/minsym-fallback.exp: New file.
	* gdb.cp/minsym-fallback.h: New file.
@
text
@a934 2
	  volatile struct gdb_exception ex;
	  char *saved_argptr = *argptr;
d938 2
a939 6

	  TRY_CATCH (ex, RETURN_MASK_ERROR)
	    {
	      values = decode_compound (argptr, funfirstline, canonical,
					file_symtab, saved_arg, p);
	    }
d942 1
a942 8

	  if (ex.reason >= 0)
	    return values;

	  if (ex.error != NOT_FOUND_ERROR)
	    throw_exception (ex);

	  *argptr = saved_argptr;
a943 13
      else
	{
	  /* If there was an exception looking up a specified filename earlier,
	     then check whether we were really given `function:label'.   */
	  if (file_exception.reason < 0)
	    {
	      function_symbol = find_function_symbol (argptr, p,
						      is_quote_enclosed);
	      /* If we did not find a function, re-throw the original
		 exception.  */
	      if (!function_symbol)
		throw_exception (file_exception);
	    }
d945 19
a963 9
	  /* Check for single quotes on the non-filename part.  */
	  if (!is_quoted)
	    {
	      is_quoted = (**argptr
			   && strchr (get_gdb_completer_quote_characters (),
				      **argptr) != NULL);
	      if (is_quoted)
		end_quote = skip_quoted (*argptr);
	    }
d1800 3
a1802 3
	  cplusplus_error (saved_arg, _("the class `%s' does not have "
					"any method instance named %s"),
				      SYMBOL_PRINT_NAME (sym_class), copy);
d2210 1
a2210 6
	{
	  /* NOT_FOUND_ERROR is not correct but it ensures COPY will be
	     searched also as a minimal symbol.  */

	  throw_error (NOT_FOUND_ERROR, _("\"%s\" is not a function"), copy);
	}
@


1.117.2.6
log
@commit 67e102403d7a0b16395389587713e703b0267ab3
Author: Jan Kratochvil <jan.kratochvil@@redhat.com>
Date:   Fri Jul 1 20:18:59 2011 +0000

gdb/
	Stop on first linespec terminator instead of eating what we can.
	* linespec.c (is_linespec_boundary): New function.
	(name_end): Remove function.
	(keep_name_info): New parameter on_boundary, replace the body.
	(decode_line_1): Provide the parameter to keep_name_info.
	(decode_compound): Likewise.  Drop the trailing java return type
	handling.  Twice.

gdb/testsuite/
	Stop on first linespec terminator instead of eating what we can.
	* gdb.cp/minsym-fallback-main.cc (main): Call also C::operator ().
	* gdb.cp/minsym-fallback.cc (C::operator ()): Define.
	* gdb.cp/minsym-fallback.exp (break 'C::f()'): Change to ...
	(break C::f()): ... this one.
	(break C::operator()()): New test.
	* gdb.cp/minsym-fallback.h (C::operator ()): Declare.
	* gdb.java/jmisc.exp (break jmisc.main(java.lang.String[])int): New
	test.
@
text
@a680 8
/* Valid delimiters for linespec keywords "if", "thread" or "task".  */

static int
is_linespec_boundary (char c)
{
  return c == ' ' || c == '\t' || c == '\0' || c == ',';
}

d712 19
d732 1
a732 2
   template parameters, overload information, and important keywords, including
   the possible Java trailing type.  */
d735 1
a735 1
keep_name_info (char *p, int on_boundary)
d737 2
a738 3
  const char *quotes = get_gdb_completer_quote_characters ();
  char *saved_p = p;
  int nest = 0;
d740 3
a742 4
  while (*p)
    {
      if (strchr (quotes, *p))
	break;
d744 3
a746 2
      if (*p == ',' && !nest)
	break;
d748 2
a749 4
      if (on_boundary && !nest)
	{
	  const char *const words[] = { "if", "thread", "task" };
	  int wordi;
d751 3
a753 7
	  for (wordi = 0; wordi < ARRAY_SIZE (words); wordi++)
	    if (strncmp (p, words[wordi], strlen (words[wordi])) == 0
		&& is_linespec_boundary (p[strlen (words[wordi])]))
	      break;
	  if (wordi < ARRAY_SIZE (words))
	    break;
	}
d755 2
a756 4
      if (*p == '(' || *p == '<' || *p == '[')
	nest++;
      else if ((*p == ')' || *p == '>' || *p == ']') && nest > 0)
	nest--;
d758 15
a772 6
      p++;

      /* The ',' check could fail on "operator ,".  */
      p += cp_validate_operator (p);

      on_boundary = is_linespec_boundary (p[-1]);
d775 1
a775 4
  while (p > saved_p && is_linespec_boundary (p[-1]))
    p--;

  return p;
d1036 1
a1036 1
  p = keep_name_info (p, p == saved_arg || is_linespec_boundary (p[-1]));
d1382 1
d1560 25
a1584 1
	  p = keep_name_info (p, 1);
d1613 21
a1633 2
      return find_method (funfirstline, canonical, saved_arg, copy, t,
			  sym_class, file_symtab);
d1640 1
a1640 1
  p = keep_name_info (p, 1);
@


1.117.2.7
log
@commit c92bdb809c286916b2ee6c267dad6a58a5706a62
Author: Jan Kratochvil <jan.kratochvil@@redhat.com>
Date:   Fri Jul 1 20:27:58 2011 +0000

gdb/
	* linespec.c (find_method): Accept the function type automatically only
	if it was specified with parameter types.

gdb/testsuite/
	* gdb.cp/paren-type.cc: New files.
	* gdb.cp/paren-type.exp: New files.
@
text
@d1699 1
a1699 4
  /* If we were given a specific overload instance in COPY, defer the field
     acceptance till the strcmp_iw verification below, even if we found just
     a single field with that name.  */
  if (i1 == 1 && strchr (copy, '(') == NULL)
@


1.117.2.8
log
@gdb/
	Fix false GCC warning.
	* linespec.c (decode_line_1): Initialize values.
@
text
@a933 3
	  /* Initialize it just to avoid a GCC false warning.  */
	  memset (&values, 0, sizeof (values));

@


1.116
log
@gdb
	PR breakpoints/11816:
	* linespec.c (decode_line_1): Parse `function:label' linespecs.
	(decode_compound): Update.
	(find_function_symbol): New function.
	(decode_dollar): Update.
	(decode_label): Add 'function_symbol' parameter.  Handle
	function-relative labels.
	(decode_variable): Update.
	(symbol_found): Add 'function_symbol' parameter.  Use label's PC,
	not its line.  Set `special_display' and canonical name for
	labels.
gdb/doc
	* gdb.texinfo (Specify Location): Document `function:label'
	linespec.
gdb/testsuite
	* gdb.base/label.exp: Use `main:there' linespec.  Add re-running
	test.
@
text
@d2177 1
a2177 3
      if (funfirstline && SYMBOL_CLASS (sym) != LOC_LABEL)
	error (_("\"%s\" is not a function"), copy);
      else if (SYMBOL_VALUE_ADDRESS (sym) != 0)
d2202 14
@


1.115
log
@	* symtab.c (decode_line_spec): Update.
	* linespec.c (build_canonical_line_spec): Change type of
	'canonical'.
	(decode_line_2, decode_line_1, decode_objc, decode_compound)
	(find_method, decode_all_digits, decode_dollar, decode_label)
	(symbol_found): Likewise.
	(init_linespec_result): New function.
	* breakpoint.c (struct captured_parse_breakpoint_args)
	<canonical_p>: New field, replaces addr_string_p.
	(create_breakpoints_sal): Add 'canonical' parameter, replacing
	'addr_string'.
	(parse_breakpoint_sals): Likewise.
	(do_captured_parse_breakpoint): Update.
	(create_breakpoint): Use struct linespec_result.
	(until_break_command): Update.
	(breakpoint_re_set_one): Update.
	(decode_line_spec_1): Update.
	* linespec.h (struct linespec_result): New.
	(init_linespec_result): Declare.
@
text
@d114 3
d131 2
a132 1
static int decode_label (char *copy, struct linespec_result *canonical,
d146 2
a147 1
				struct symtab *file_symtab);
d821 7
d900 16
a915 2
      file_symtab = symtab_from_filename (argptr, p, is_quote_enclosed,
					  not_found_ptr);
d929 2
d952 2
a953 1
  if (q != *argptr && (*q == 0 || *q == ' ' || *q == '\t' || *q == ','))
d1004 1
a1004 1
  if (*copy == '$')
d1014 1
a1014 1
      if (decode_label (copy, canonical, &label_result))
d1018 7
d1612 1
a1612 1
    return symbol_found (funfirstline, canonical, copy, sym, NULL);
d1850 38
d2022 1
a2022 1
	return symbol_found (funfirstline, canonical, copy, sym, NULL);
d2058 2
d2067 2
a2068 1
decode_label (char *copy, struct linespec_result *canonical,
d2072 15
d2088 1
a2088 1
  sym = lookup_symbol (copy, get_selected_block (0), LABEL_DOMAIN, 0);
d2091 1
a2091 1
    *result = symbol_found (0, canonical, copy, sym, NULL);
d2117 1
a2117 1
    return symbol_found (funfirstline, canonical, copy, sym, file_symtab);
d2146 2
a2147 1
	      struct symbol *sym, struct symtab *file_symtab)
d2179 1
a2179 1
      else if (SYMBOL_LINE (sym) != 0)
d2185 1
a2185 1
	  memset (&values.sals[0], 0, sizeof (values.sals[0]));
d2188 1
d2190 12
@


1.114
log
@	* linespec.c (find_methods): Canonicalize NAME before looking
	up the symbol.
	(name_end): New function.
	(keep_name_info): New function.
	(decode_line_1): Use keep_name_info.
	(decode_compound): Likewise.
	* cli/cli-utils.h (remove_trailing_whitespace): New function.
	* cli/cli-utils.c (remove_trailing_whitespace): Likewise.

	PR c++/12273
	* linespec.c (locate_first_half): Keep overload information, too.
	(decode_compound): Use a string to represent break characters
	to escape the loop.
	If P points to a break character, do not increment it.
	For C++ and Java, keep overload information and relevant keywords.
	If we cannot find a symbol, search the minimal symbols.

	PR c++/11734
	* linespec.c (decode_compound): Rename SAVED_ARG to
	THE_REAL_SAVED_ARG.
	Make a copy of THE_REAL_SAVED_ARG in SAVED_ARG and strip
	single-quotes.
	Pass a valid block to lookup_symbol.
	(lookup_prefix_sym): Likewise.
	(find_method): Construct search name based on SYM_CLASS instead
	of SAVED_ARG.
	* psymtab.c (lookup_partial_symbol): Add language parameter.
	(lookup_symbol_aux_psymtabs): Likewise.
	Don't assume that the psymtab we found was the right one. Search
	for the desired symbol in the symtab to be certain.
	(psymtab_search_name): New function.
	(lookup_partial_symbol): Use psymtab_search_name.
	Add language parameter.
	(read_symtabs_for_function): Add language parameter and pass to
	lookup_partial_symbol.
	(find_symbol_file_from_partial): Likewise.
@
text
@d63 1
a63 1
					     char ***canonical,
d68 1
a68 1
						 char ***canonical,
d76 1
a76 1
					     char ***canonical,
d100 1
a100 1
				       char *, char ***);
d107 2
a108 1
					       int, int, char ***);
d118 1
a118 1
				     char ***canonical,
d125 1
a125 1
					       char ***canonical,
d128 1
a128 1
static int decode_label (char *copy, char ***canonical,
d133 1
a133 1
						 char ***canonical,
d139 1
a139 1
				char ***canonical,
d409 1
a409 1
			   char ***canonical)
d418 1
a418 1
      || canonical == (char ***) NULL)
d422 1
a422 1
  *canonical = canonical_arr;
d502 1
a502 1
	       char ***canonical)
d528 1
a528 1
      *canonical = canonical_arr;
d795 2
a796 1
	       int default_line, char ***canonical, int *not_found_ptr)
d1192 1
a1192 1
	     char ***canonical, char *saved_arg)
d1298 2
a1299 1
decode_compound (char **argptr, int funfirstline, char ***canonical,
d1658 2
a1659 1
find_method (int funfirstline, char ***canonical, char *saved_arg,
d1822 1
a1822 1
		   int default_line, char ***canonical,
d1911 1
a1911 1
	       char ***canonical, struct symtab *file_symtab)
d1991 2
a1992 1
decode_label (char *copy, char ***canonical, struct symtabs_and_lines *result)
d2010 2
a2011 1
decode_variable (char *copy, int funfirstline, char ***canonical,
d2053 1
a2053 1
symbol_found (int funfirstline, char ***canonical, char *copy,
d2139 6
@


1.113
log
@	* eval.c (parse_and_eval_address_1): Remove function.
	* linespec.c (decode_indirect): Call parse_to_comma_and_eval
	instead of parse_and_eval_address_1.
	* value.h (parse_and_eval_address_1): Remove prototype.
@
text
@d44 2
d218 13
d293 1
d682 59
d949 2
a950 11
  /* Keep any template parameters.  */
  if (*p == '<')
    p = find_template_name_end (p);

  /* Keep method overload information.  */
  if (*p == '(')
    p = find_method_overload_end (p);

  /* Make sure we keep important kewords like "const".  */
  if (strncmp (p, " const", 6) == 0)
    p += 6;
d1126 4
d1297 1
a1297 1
		 char *saved_arg, char *p, int *not_found_ptr)
d1308 17
d1341 4
a1344 2
        user made a typo or AAA::inA is the name of a namespace.
        Either way, we just look up AAA::inA::fun with lookup_symbol.
d1365 2
d1377 3
a1379 2
      while (*p && (p[0] != ' ') && (p[0] != '\t') && (p[0] != '\'')
	     && (*p != '('))
d1403 6
a1408 3
	    /* PASS2: We'll keep getting here, until p->"", at which point
	       we exit this loop.  */
	    p++;
d1417 1
a1417 1
      /* We get here if p points to ' ', '\t', '\'', "::" or ""(i.e
d1477 2
a1478 12
	  /* Keep any template parameters.  */
	  if (*p == '<')
	    p = find_template_name_end (p);

	  /* Keep method overload information.  */
	  a = strchr (p, '(');
	  if (a != NULL)
	    p = find_method_overload_end (a);

	  /* Make sure we keep important kewords like "const".  */
	  if (strncmp (p, " const", 6) == 0)
	    p += 6;
d1558 4
d1571 1
a1571 1
  sym = lookup_symbol (copy, 0, VAR_DOMAIN, 0);
d1574 10
d1585 1
a1585 2
  /* Couldn't find any interpretation as classes/namespaces, so give
     up.  The quotes are important if copy is empty.  */
d1588 1
a1588 1
  cplusplus_error (saved_arg,
d1627 1
a1627 1
  sym = lookup_symbol (copy, 0, STRUCT_DOMAIN, 0);
d1695 1
a1695 1
      if (strchr (saved_arg, '(') != NULL)
d1698 2
a1699 2
	  char *name = saved_arg;
	  char *canon = cp_canonicalize_string (name);
d1702 13
d1717 1
a1718 1
	      cleanup = make_cleanup (xfree, canon);
d1720 1
a1720 2
	  else
	    cleanup = make_cleanup (null_cleanup, NULL);
@


1.112
log
@2011-03-01  Michael Snyder  <msnyder@@vmware.com>

	* linespec.c (decode_line_1): Remove unnecessary null check.
@
text
@d983 1
a983 1
  pc = parse_and_eval_address_1 (argptr);
@


1.111
log
@2011-03-01  Michael Snyder  <msnyder@@vmware.com>

	* linespec.c (decode_line_1): Check for null before dereference.
@
text
@d729 1
a729 1
  int is_quoted = 0;
d748 2
a749 4
  if (*argptr)
    {
      if (**argptr == '*')
	return decode_indirect (argptr);
d751 2
a752 3
      is_quoted = (strchr (get_gdb_completer_quote_characters (),
			   **argptr) != NULL);
    }
@


1.110
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* linespec.c (decode_objc): Delete unused variable.
@
text
@d729 1
a729 1
  int is_quoted;
d748 8
a755 2
  if (**argptr == '*')
    return decode_indirect (argptr);
a756 3
  is_quoted = (*argptr
	       && strchr (get_gdb_completer_quote_characters (),
			  **argptr) != NULL);
@


1.109
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* h8300-tdep.c: Comment cleanup, mostly periods and spaces.
	* hppa-hpux-tdep.c: Ditto.
	* hppa-linux-nat.c: Ditto.
	* hppa-linux-tdep.c: Ditto.
	* hppanbsd-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* hppa-tdep.h: Ditto.
	* hpux-thread.c: Ditto.
	* i386-cygwin-tdep.c: Ditto.
	* i386-darwin-nat.c: Ditto.
	* i386gnu-nat.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* i386-linux-tdep.c: Ditto.
	* i386-nat.c: Ditto.
	* i386-nat.h: Ditto.
	* i386nbsd-tdep.c: Ditto.
	* i386-sol2-nat.c: Ditto.
	* i386-stub.c: Ditto.
	* i386-tdep.c: Ditto.
	* i386-tdep.h: Ditto.
	* i387-tdep.c: Ditto.
	* ia64-linux-nat.c: Ditto.
	* ia64-linux-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* infcall.c: Ditto.
	* infcall.h: Ditto.
	* infcmd.c: Ditto.
	* inferior.c: Ditto.
	* inferior.h: Ditto.
	* infloop.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* interps.c: Ditto.
	* interps.h: Ditto.
	* iq2000-tdep.c: Ditto.
	* irix5-nat.c: Ditto.
	* jit.c: Ditto.
	* jit.h: Ditto.
	* jv-exp.y: Ditto.
	* jv-lang.c: Ditto.
	* jv-lang.h: Ditto.
	* jv-typeprint.c: Ditto.
	* jv-valprint.c: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* linespec.c: Ditto.
	* linux-fork.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-thread-db.c: Ditto.
	* lm32-tdep.c: Ditto.
@
text
@a1124 1
  char *copy = NULL;
d1145 1
a1145 1
  copy = find_imps (file_symtab, block, *argptr, NULL, &i1, &i2); 
d1153 1
a1153 2
      copy = find_imps (file_symtab, block, *argptr, sym_arr, &i1, &i2); 
      *argptr = copy;
@


1.108
log
@Remove trailing new-line at end of error string

gdb/ChangeLog:

	* linespec.c (decode_compound, find_method): Remove trailing \n
	at end of error string.
	* solib-irix.c (irix_current_sos): Likewise.
	* varobj.c (uninstall_variable): Likewise.
@
text
@d45 1
a45 1
/* We share this one with symtab.c, but it is not exported widely. */
d49 1
a49 1
/* Prototypes for local functions */
d145 1
a145 1
/* Helper functions. */
d181 1
a181 1
   methods from types it derives from. This can't be done in the symbol
d324 1
a324 1
	     still seems to be found
d327 2
a328 2
	     language_cplus,
	     DMGL_PARAMS | DMGL_ANSI);
d460 1
a460 1
   representation, such as -[Foo bar:] or +[Foo bar]. Objective-C symbols
d667 1
a667 1
/* The parser of linespec itself. */
d698 1
a698 1
   line specs there if necessary. Currently overloaded member functions and
d700 1
a700 1
   line spec. The array and the line spec strings are allocated on the heap,
d763 2
a764 2
     will point to "". If this is a C++ name, like "A::B::foo", p will
     point to "::B::foo". Argptr is not changed by this call.  */
d790 1
a790 1
	 since p[0]==':' was checked above.  
d793 1
a793 1
	 can return now. */
d866 1
a866 1
      /* allow word separators in method names for Obj-C */
d874 1
a874 1
  /* Keep any template parameters */
d882 1
a882 1
  /* Make sure we keep important kewords like "const" */
d963 1
a963 1
	 us back! */
d1024 1
a1024 1
     This is undone below. Do not change ii!!  */
d1061 1
a1061 1
         indicates an Objective-C method) */
d1150 2
a1151 1
      sym_arr = (struct symbol **) alloca ((i1 + 1) * sizeof (struct symbol *));
d1215 1
a1215 1
      /* More than one match. The user must choose one or more.  */
d1244 1
a1244 1
     "::" (note the condition that *argptr == p). */
d1265 1
a1265 1
  /* This is very messy. Following the example above we have now the
d1271 1
a1271 1
     p2 -> "::inA::fun". */
d1274 1
a1274 1
     is marked in comments.*/
d1284 1
a1284 1
	 second colon. */
d1304 2
a1305 2
	     double-colon to the right (after). I.e. there is another
	     component that can be a class or a namespace. I.e, if at
d1309 1
a1309 1
	  /* PASS2: we will not trigger this. */
d1322 1
a1322 1
			   string, and p->""(PASS2)  */
d1325 1
a1325 1
	 string ended). */
d1337 1
a1337 1
  /* Start of lookup in the symbol tables. */
d1340 1
a1340 1
     p. Note, this call changes the value of argptr.  */
d1384 1
a1384 1
	  /* Keep any template parameters */
d1393 1
a1393 1
	  /* Make sure we keep important kewords like "const" */
d1423 1
a1423 1
	 p. */
d1433 1
a1433 1
      /* At this point copy->"fun", p->"" */
d1441 1
a1441 1
      /* Look for copy as a method of sym_class. */
d1445 1
a1445 1
	 here, we return. If not, and we are at the and of the string,
d1469 1
a1469 1
    } /* End if symbol found */
d1483 1
a1483 1
  /* Look up entire name */
d1529 1
a1529 1
     argptr->"inA::fun" */
d1946 1
a1946 1
      /* Arg is the name of a function */
@


1.107
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d1463 1
a1463 1
		       "any method instance named %s\n"),
d1628 1
a1628 1
		   "any method instance named %s\n"),
@


1.106
log
@run copyright.sh for 2011.
@
text
@d497 2
a498 3
    error (_("\
canceled because the command is ambiguous\n\
See set/show multiple-symbol."));
d544 2
a545 1
                printf_unfiltered (_("[%d] %s at ?FILE:%d [No symtab? Probably broken debug info...]\n"),
d622 2
a623 1
	      printf_unfiltered (_("duplicate request for %d ignored.\n"), num);
d707 4
a710 4
   If NOT_FOUND_PTR is not null, store a boolean true/false value at the location, based
   on whether or not failure occurs due to an unknown function or file.  In the case
   where failure does occur due to an unknown function or file, do not issue an error
   message.  */
d1172 2
a1173 1
	  if ((sym != NULL) && strcmp (SYMBOL_LINKAGE_NAME (sym_arr[0]), SYMBOL_LINKAGE_NAME (sym)) != 0)
d1175 3
a1177 1
	      warning (_("debugging symbol \"%s\" does not match selector; ignoring"), SYMBOL_LINKAGE_NAME (sym));
d1182 2
a1183 1
      values.sals = (struct symtab_and_line *) xmalloc (sizeof (struct symtab_and_line));
d1190 2
a1191 1
	  build_canonical_line_spec (values.sals, SYMBOL_NATURAL_NAME (sym), canonical);
d1462 2
a1463 1
	      error (_("the class `%s' does not have any method instance named %s\n"),
d1492 2
a1493 1
		   "Can't find member of namespace, class, struct, or union named \"%s\"\n",
d1559 2
a1560 1
	     char *copy, struct type *t, struct symbol *sym_class, int *not_found_ptr)
d1627 2
a1628 1
	  error (_("the class `%s' does not have any method instance named %s\n"),
d1687 2
a1688 1
		     _("No symbol table is loaded.  Use the \"file\" command."));
d1820 2
a1821 1
	error (_("History values used in line specs must have integer values."));
d1845 2
a1846 1
	error (_("Convenience variables used in line specs must have integer values."));
d1891 3
a1893 3
   look in that symtab's static variables first.  If NOT_FOUND_PTR is not NULL and
   the function cannot be found, store boolean true in the location pointed to
   and do not issue an error message.  */ 
@


1.105
log
@	* linespec.c (find_method): Move name canonicalization outside
	the loop.
	Be paranoid and use a cleanup.
@
text
@d5 1
a5 1
   2009, 2010 Free Software Foundation, Inc.
@


1.104
log
@gdb
	PR breakpoints/8357:
	* symtab.h (domain_enum_tag) <LABEL_DOMAIN>: Update comment.
	* linespec.c (decode_line_1): Update comment.  Call decode_label.
	(decode_label): New function.
	(symbol_found): Handle LOC_LABEL.
	* dwarf2read.c (new_symbol) <DW_TAG_label>: Set symbol's type and
	domain.  Call add_symbol_to_list.
gdb/doc
	* gdb.texinfo (Specify Location): Document labels.
gdb/testsuite
	* gdb.base/label.exp: New file.
	* gdb.base/label.c: New file.
@
text
@d1592 11
a1605 6
	      char *name = saved_arg;
	      char *canon = cp_canonicalize_string (name);

	      if (canon != NULL)
		name = canon;

d1613 1
a1613 2
		  if (canon)
		    xfree (canon);
a1615 3

	      if (canon)
		xfree (canon);
@


1.103
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* jv-lang.c: White space.
	* jv-typeprint.c: White space.
	* jv-valprint.c: White space.
	* language.c: White space.
	* libunwind-frame.c: White space.
	* linespec.c: White space.
	* linux-nat.c: White space.
	* linux-record.c: White space.
	* linux-thread-db.c: White space.
@
text
@d125 3
d678 1
d910 10
d1855 21
d1955 1
a1955 1
      if (funfirstline)
d1966 1
@


1.102
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* linespec.c (decode_compound): Delete unused variable.
	* dictionary.c (iterator_next_hashed): Delete unused variable.
	* infcall.c (call_function_by_hand): Delete unused variable.
	* infcmd.c (step_1): Delete unused variable.
	(registers_info): Delete unused variable.
	(attach_command): Delete unused variable.
	* infrun.c (follow_exec): Delete unused variable.
	(handle_step_into_function_backwards): Delete unused variable.
	(_initialize_infrun): Delete unused variable.
	* stack.c (parse_frame_specification_1): Delete unused variable.
	(frame_info): Delete unused variable.
	(backtrace_command_1): Delete unused variable.
	(catch_info): Delete unused variable.
@
text
@d153 1
d159 1
d772 1
d1040 1
d1081 1
d1347 1
d1381 1
d1518 1
d1522 1
d1578 1
d1583 1
d1790 1
a1850 1

d1912 1
@


1.101
log
@gdb/
	* cli/cli-cmds.h (error_no_arg): Remove.  Move the comment ...
	* command.h (error_no_arg): ... here.  Remove NORETURN, change
	ATTR_NORETURN to ATTRIBUTE_NORETURN.
	* defs.h (NORETURN, ATTR_NORETURN): Remove.
	(perror_with_name, verror, error, error_stream, vfatal, fatal)
	(internal_verror, internal_error, nomem): Remove NORETURN, change
	ATTR_NORETURN to ATTRIBUTE_NORETURN.
	* exceptions.c (throw_exception, deprecated_throw_reason, throw_verror)
	(throw_vfatal, throw_error): Remove NORETURN.
	(throw_it): Remove NORETURN, change ATTR_NORETURN to ATTRIBUTE_NORETURN.
	* exceptions.h (throw_exception, throw_verror, throw_vfatal)
	(throw_error, deprecated_throw_reason): Remove NORETURN, change
	ATTR_NORETURN to ATTRIBUTE_NORETURN.
	* linespec.c (cplusplus_error): Remove NORETURN, change ATTR_NORETURN
	to ATTRIBUTE_NORETURN for prototype, for the definition only remove
	NORETURN.
	* remote-mips.c (mips_error): Change NORETURN to ATTRIBUTE_NORETURN.
	* remote-sim.c (gdb_os_error): Change ATTR_NORETURN to
	ATTRIBUTE_NORETURN.
	* target.c (tcomplain): Likewise.
	* target.h (noprocess): Remove NORETURN, change ATTR_NORETURN to
	ATTRIBUTE_NORETURN.
	* utils.c (verror, error, vfatal, fatal, error_stream, internal_verror)
	(internal_error, perror_with_name, nomem): Remove NORETURN.
	* xml-support.h (gdb_xml_error): Change ATTR_NORETURN to
	ATTRIBUTE_NORETURN.

gdb/doc/
	* gdbint.texinfo (Host Definition): Remove items NORETURN and
	ATTR_NORETURN.
@
text
@a1211 1
  struct symbol **sym_arr;
@


1.100
log
@gdb/
	* ada-lang.c (lim_warning): Change ATTR_FORMAT to ATTRIBUTE_PRINTF.
	* amd64-tdep.c (amd64_insn_length_fprintf): Likewise.
	* cli-out.c (cli_field_fmt): New ATTRIBUTE_PRINTF.
	(cli_message, out_field_fmt): Change ATTR_FORMAT to ATTRIBUTE_PRINTF.
	* complaints.c (find_complaint): New ATTRIBUTE_PRINTF.
	(vcomplaint): Change ATTR_FORMAT to ATTRIBUTE_PRINTF.
	* complaints.h (complaint, internal_complaint): Likewise.
	* defs.h: Change ATTR_FORMAT to ATTRIBUTE_PRINTF in the top comment.
	(ATTR_FORMAT): Remove.
	(query, nquery, yquery, vprintf_filtered, vfprintf_filtered)
	(fprintf_filtered, fprintfi_filtered, printf_filtered, printfi_filtered)
	(vprintf_unfiltered, vfprintf_unfiltered, fprintf_unfiltered)
	(printf_unfiltered, xasprintf, xvasprintf, xstrprintf, xstrvprintf)
	(xsnprintf, verror, error, vfatal, fatal, internal_verror)
	(internal_error, internal_vwarning, internal_warning, warning)
	(vwarning): Change ATTR_FORMAT to ATTRIBUTE_PRINTF.
	* disasm.c (fprintf_disasm): Likewise.
	* exceptions.c (throw_it): Likewise.
	* exceptions.h (exception_fprintf, throw_verror, throw_vfatal)
	(throw_error): Likewise.
	* language.h (type_error, range_error): Likewise.
	* linespec.c (cplusplus_error): Likewise.
	* mi/mi-interp.c (mi_interp_query_hook): Likewise.
	* mi/mi-out.c (mi_field_fmt, mi_message): Likewise.
	* monitor.c (monitor_debug): Likewise.
	* parser-defs.h (parser_fprintf): Likewise.
	* serial.h (serial_printf): Likewise.
	* tui/tui-hooks.c (tui_query_hook): Likewise.
	* ui-out.c (default_field_fmt, default_message, uo_field_fmt)
	(uo_message): Likewise.
	* ui-out.h (ui_out_field_fmt, ui_out_message): Likewise.
	* utils.c (vfprintf_maybe_filtered, internal_vproblem, defaulted_query):
	Likewise.
	* xml-support.h (gdb_xml_debug, gdb_xml_error): Likewise.
@
text
@d81 2
a82 3
static NORETURN void cplusplus_error (const char *name,
				      const char *fmt, ...)
     ATTR_NORETURN ATTRIBUTE_PRINTF (2, 3);
d148 1
a148 1
static NORETURN void
@


1.99
log
@	* breakpoint.c (expand_line_sal_maybe): Always call skip_prologue_sal.
	(skip_prologue_sal): Remove local definition.
	(resolve_sal_pc): Remove now unnecessary code.
	* linespec.c (minsym_found): Call skip_prologue_sal.
	* symtab.c (find_function_start_pc): Remove.
	(find_function_start_sal): Extract prologue skipping into ...
	(skip_prologue_sal): ... this new function.  Handle code both
	with and without debug info.  Respect SAL's explicit_pc and
	explicit_line flags.  Inline old find_function_start_pc.
	* symtab.h (find_function_start_pc): Remove.
	(skip_prologue_sal): Add prototype.
@
text
@d83 1
a83 1
     ATTR_NORETURN ATTR_FORMAT (printf, 2, 3);
@


1.98
log
@dwarf2_physname patchset:

	Based on work from Daniel Jacobowitz  <dan@@codesourcery.com>
	* c-typeprint.c (cp_type_print_method_args): For non-static methods,
	print out const or volatile qualifiers, too.
	(c_type_print_args): Add parameters show_artificial and language.
	Skip artificial parameters when requested.
	Use the appropriate language printer.
	(c_type_print_varspec): Tell c_type_print_args to skip artificial
	parameters and pass language_c.
	* dwarf2read.c (die_list): New file global.
	(struct partial_die_info): Update comments for name field.
	(pdi_needs_namespace): Renamed to ...
	(die_needs_namespace): ... this. Rewrite.
	(dwarf2_linkage_name): Remove.
	(add_partial_symbol): Do not predicate the call to
	partial_die_full_name based on pdi_needs_namespace.
	Remove call to cp_check_possible_namespace_symbols and associated
	outdated comments.
	(guess_structure_name): Do not inspect child subprogram DIEs.
	(dwarf2_fullname): Update comments.
	Use die_needs_namespace to assist in computing the name.
	(read_func_scope): Use dwarf2_name to get the DIE's name.
	Use dwarf2_physname to get the "linkage name" of the DIE.
	(dwarf2_add_member_field): Use dwarf2_physname instead of
	dwarf2_linkage_name.
	(read_structure_type): For structs and classes, set TYPE_NAME, too.
	(determine_class): Remove.
	(read_partial_die): Ignore DW_AT_MIPS_linkage_name for all languages
	except Ada.
	(new_symbol): Unconditionally call dwarf2_name.
	Compute the "linkage name" using dwarf2_physname.
	Use dwarf2_name instead of dwarf2_full_name for enumerator DIEs.
	When determining to scan for anonymous C++ namespaces, ignore
	the linkage name.
	(dwarf2_physname): New function.
	(dwarf2_full_name): Move content to new function and call
	that.
	(dwarf2_compute_name): "New" function.
	(_initialize_dwarf2_read): Initialize die_list.
	* gnu-v3-eabi.c (gnu_v3_find_method_in): Remove unused variable
	physname.
	(gnu_v3_print_method_ptr): Use the physname for virtual methods
	without a demangled name.
	Print out type information for non-virtual methods.
        * linespec.c (decode_line_1): Force ANY string using "::" (or
	"." for java) to use decode_compound, and clean up any stray quoting.
        If we found a file symtab, re-evaluate whether the remainder is_quoted.
        (decode_compound): Stop consuming at an open parenthesis.
        Keep template parameters.
        Keep any overload information.
        Keep keywords like "const".
        Remove paren_pointer.
        Move is_quoted check from set_flags to here.
        Remove #if 0 code from 2000. Ten years is long enough.
        (find_method): Before comparing symbol names, canonicalize the string
        from the user.
        If a specific overload is requested, find it. Otherwise throw an error.
	(find_method_overload_end): New function.
	(set_flags): Remove.
        (decode_compound): Assume that parentheses are matched.
        It's a lot easier.
	* symtab.c (symbol_find_demangled_name): Add DMGL_VERBOSE flag
	to cplus_demangle.
	* linespec.c (decode_line_1): Keep important keywords like
	"const" and "volatile".
	* symtab.h (SYMBOL_CPLUS_DEMANGLED_NAME): Remove.
	* typeprint.h (c_type_print_args): Add declaration.
	* ui-file.c (do_ui_file_obsavestring): New function.
	(ui_file_obsavestring): New function.
	* ui-file.h (ui_file_obsavestring): Add declaration.
	* valops.c (find_overload_match): Resolve the object to
	a non-pointer type.
	If the object is a data member, search the object for the member
	and return with staticp set.
	Use SYMBOL_NATURAL_NAME instead of SYMBOL_CPLUS_DEMANGLED_NAME.
	Do not attempt to extract a function name from non-function types.
	If the extracted function name and the original name are the same,
	we don't have a C++ method.

	From Jan Kratochvil  <jan.kratochvil@@redhat.com>:
    	* dwarf2read.c (new_symbol <DW_TAG_enumerator>): Call dwarf2_full_name.

	* ada-lang.c (ada_lookup_symbol): Remove linkage_name parameters
	and arguments from symbol lookups.
	* ax-gdb.c (gen_expr): Likewise.
	* cp-namespace.c (cp_lookup_symbol_nonlocal, lookup_namespace_scope,
	cp_lookup_symbol_namespace, lookup_symbol_file, lookup_nested_type,
	lookup_possible_namespace_symbol): Likewise.
	* cp-support.c (read_in_psymtabs): Likewise.
	* cp-support.h (cp_lookup_symbol_nonlocal): Likewise.
	* language.h (la_lookup_symbol_nonlocal): Likewise.
	* scm-valprint.c (scm_inferior_print): Likewise.
	* solib-darwin.c (darwin_relocate_section_addresses): Likewise.
	* solib-svr.c (elf_lookup_lib): Likewise.
	* solib.c (show_auto_solib_add): Likewise.
	* solist.h (lookup_lib_global, solib_global_lookup): Likewise.
	* symmisc.c (maintenance_check_symtabs): Likewise.
	* symtab.c (lookup_symbol_in_language, lookup_symbol_aux,
	lookup_symbol_aux_local, lookup_symbol_aux_block,
	lookup_symbol_from_objfile, lookup_symbol_aux_symtabs,
	lookup_symbol_aux_psymtabs,basic_lookup_symbol_nonlocal,
	lookup_symbol_static, lookup_symbol_global, symbol_matches_domain,
	basic_lookup_transparent_type, find_main_psymtab,
	lookup_block_symbol): Likewise.
	* symtab.h (basic_lookp_symbol_nonlocal, lookup_symbol_static,
	lookup_symbol_global, lookup_symbol_aux_block,
	lookup_symbol_partial_symbol, lookup_block_symbol,
	lookup_global_symbol, value_maybe_namespace_elt): Likewise.
@
text
@d1959 1
a1959 20
    {
      struct symtab_and_line sal;

      values.sals[0].pc = find_function_start_pc (gdbarch,
						  values.sals[0].pc,
						  values.sals[0].section);

      sal = find_pc_sect_line (values.sals[0].pc, values.sals[0].section, 0);

      /* Check if SKIP_PROLOGUE left us in mid-line, and the next
	 line is still part of the same function.  If there is no
	 line information here, sal.pc will be the passed in PC.  */
      if (sal.pc != values.sals[0].pc
	  && (lookup_minimal_symbol_by_pc_section (values.sals[0].pc,
						   values.sals[0].section)
	      == lookup_minimal_symbol_by_pc_section (sal.end,
						      values.sals[0].section)))
	/* Recalculate the line number (might not be N+1).  */
	values.sals[0] = find_pc_sect_line (sal.end, values.sals[0].section, 0);
    }
@


1.97
log
@	* linespec.c (decode_line_1): Update comments for is_quote_enclosed.
	If the filename portion of the linespec was quoted, recheck the
	remainder for additional quoting.
	(locate_first_half): Skip over completer chars, too.
@
text
@d43 1
a53 2
static void set_flags (char *arg, int *is_quoted, char **paren_pointer);

d630 31
a720 3
  /* This is NULL if there are no parens in *ARGPTR, or a pointer to
     the closing parenthesis if there are parens.  */
  char *paren_pointer;
d745 3
a747 6
  /* Set various flags.  'paren_pointer' is important for overload
     checking, where we allow things like:
        (gdb) break c::f(int)
  */

  set_flags (*argptr, &is_quoted, &paren_pointer);
d765 1
a765 4
    {
      is_objc_method = 1;
      paren_pointer  = NULL; /* Just a category name.  Ignore it.  */
    }
d790 5
a794 2
	  if (paren_pointer == NULL)
	    return decode_compound (argptr, funfirstline, canonical,
d796 3
a798 1
	  /* Otherwise, fall through to decode_variable below.  */
a799 4
      else
	{
	  /* No, the first part is a filename; set file_symtab to be that file's
	     symtab.  Also, move argptr past the filename.  */
d801 2
a802 2
	  file_symtab = symtab_from_filename (argptr, p, is_quote_enclosed,
					      not_found_ptr);
d804 2
a805 30
	  /* Check for single quotes on the non-filename part.  */
	  if (!is_quoted)
	    {
	      is_quoted = (**argptr
			   && strchr (get_gdb_completer_quote_characters (),
				      **argptr) != NULL);
	      if (is_quoted)
		end_quote = skip_quoted (*argptr);
	    }
	}
    }
#if 0
  /* No one really seems to know why this was added. It certainly
     breaks the command line, though, whenever the passed
     name is of the form ClassName::Method. This bit of code
     singles out the class name, and if funfirstline is set (for
     example, you are setting a breakpoint at this function),
     you get an error. This did not occur with earlier
     verions, so I am ifdef'ing this out. 3/29/99 */
  else
    {
      /* Check if what we have till now is a symbol name */

      /* We may be looking at a template instantiation such
         as "foo<int>".  Check here whether we know about it,
         instead of falling through to the code below which
         handles ordinary function names, because that code
         doesn't like seeing '<' and '>' in a name -- the
         skip_quoted call doesn't go past them.  So see if we
         can figure it out right now. */
d807 2
a808 5
      copy = (char *) alloca (p - *argptr + 1);
      memcpy (copy, *argptr, p - *argptr);
      copy[p - *argptr] = '\000';
      sym = lookup_symbol (copy, 0, VAR_DOMAIN, 0);
      if (sym)
d810 5
a814 2
	  *argptr = (*p == '\'') ? p + 1 : p;
	  return symbol_found (funfirstline, canonical, copy, sym, NULL);
a815 2
      /* Otherwise fall out from here and go to file/line spec
         processing, etc. */
a816 1
#endif
a861 4
  else if (paren_pointer != NULL)
    {
      p = paren_pointer + 1;
    }
d871 8
d926 3
a928 4
   function gets passed *ARGPTR instead, which is then called ARG: see
   set_flags, for example.)  Also, functions that return a struct
   symtabs_and_lines may modify CANONICAL, as in the description of
   decode_line_1.
a954 38
static void
set_flags (char *arg, int *is_quoted, char **paren_pointer)
{
  char *ii;
  int has_if = 0;

  /* 'has_if' is for the syntax:
        (gdb) break foo if (a==b)
  */
  if ((ii = strstr (arg, " if ")) != NULL ||
      (ii = strstr (arg, "\tif ")) != NULL ||
      (ii = strstr (arg, " if\t")) != NULL ||
      (ii = strstr (arg, "\tif\t")) != NULL ||
      (ii = strstr (arg, " if(")) != NULL ||
      (ii = strstr (arg, "\tif( ")) != NULL)
    has_if = 1;
  /* Temporarily zap out "if (condition)" to not confuse the
     parenthesis-checking code below.  This is undone below. Do not
     change ii!!  */
  if (has_if)
    {
      *ii = '\0';
    }

  *is_quoted = (*arg
		&& strchr (get_gdb_completer_quote_characters (),
			   *arg) != NULL);

  *paren_pointer = strchr (arg, '(');
  if (*paren_pointer != NULL)
    *paren_pointer = strrchr (*paren_pointer, ')');

  /* Now that we're safely past the paren_pointer check, put back " if
     (condition)" so outer layers can see it.  */
  if (has_if)
    *ii = ' ';
}

d1061 3
a1063 2
	     others are package qualifiers.  */
	  for (p1 = p; *p1; p1++)
d1215 1
d1264 2
a1265 1
      while (*p && (p[0] != ' ') && (p[0] != '\t') && (p[0] != '\''))
d1343 1
d1345 2
a1346 1
	  while (*p && *p != ' ' && *p != '\t' && *p != ',' && *p != ':')
d1358 36
d1422 20
a1441 3
      return find_method (funfirstline, canonical, saved_arg,
			  copy, t, sym_class, not_found_ptr);

d1565 33
a1597 2
      /* There is more than one field with that name
	 (overloaded).  Ask the user which one to use.  */
d1903 1
a1903 1
	  if (lookup_block_symbol (b, copy, NULL, VAR_DOMAIN) != NULL)
@


1.96
log
@	gdb/
	* linespec.c (decode_line_1): Handle FILE:FUNCTION even if
	FUNCTION contains parentheses.  Improve removal of a trailing
	single quote.

	gdb/testsuite/
	* gdb.base/list.exp (test_list_filename_and_function): Add test
	with single quotes.
	* gdb.cp/overload.cc (intToChar): Rewrite onto one line for easy
	matching.
	* gdb.cp/overload.exp: Add tests with filename, function, and quotes.
	Add KFAIL'd tests for PR gdb/11289.
@
text
@d697 1
a697 1
  /* Is part of *ARGPTR is enclosed in double quotes?  */
d703 2
d736 1
a736 1
  p = locate_first_half (argptr, &is_quote_enclosed);
a755 3
  if (is_quoted)
    *argptr = *argptr + 1;

d830 11
d1069 8
a1076 1
    *is_quote_enclosed = 0;
d1594 2
a1595 1
  if (is_quote_enclosed && copy[p - *argptr - 1] == '"')
@


1.96.2.1
log
@Workaround for PR/10966:

gdb/ChangeLog:

        * linespec.c (add_matching_methods): Only match methods that are
        in the VAR_DOMAIN and whose class is LOC_BLOCK.
@
text
@d316 1
a316 4
      /* See PR10966.  Remove check on symbol domain and class when
	 we stop using (bad) linkage names on constructors.  */
      if (sym_arr[i1] && (SYMBOL_DOMAIN (sym_arr[i1]) == VAR_DOMAIN
			  && SYMBOL_CLASS (sym_arr[i1]) == LOC_BLOCK))
@


1.95
log
@gdb/ChangeLog:

        Add support for DW_AT_GNAT_descriptive_type.
        * gdbtypes.h (enum type_specific_kind): New enum.
        (struct main_type) [type_specific_field]: New component.
        [type_specific]: Add new component "gnat_stuff".
        (struct gnat_aux_type): New type.
        (INIT_CPLUS_SPECIFIC): Also set TYPE_SPECIFIC_FIELD (type).
        (HAVE_CPLUS_STRUCT): Also check TYPE_SPECIFIC_FIELD (type).
        (gnat_aux_default, allocate_gnat_aux_type): Add declaration.
        (INIT_GNAT_SPECIFIC, ALLOCATE_GNAT_AUX_TYPE, HAVE_GNAT_AUX_INFO)
        (TYPE_SPECIFIC_FIELD): New macros.
        (TYPE_CPLUS_SPECIFIC): Return cplus_struct_default if the given
        type does not hold any cplus-specific data.
        (TYPE_RAW_CPLUS_SPECIFIC): New macro.
        (TYPE_GNAT_SPECIFIC, TYPE_DESCRIPTIVE_TYPE): New macros.
        (TYPE_IS_OPAQUE): Use HAVE_CPLUS_STRUCT to check if type has
        cplus-specific data.
        * gdbtypes.c (allocate_cplus_struct_type): Minor stylistic rewrite.
        Set new component TYPE_SPECIFIC_FIELD (type).
        (gnat_aux_default): New constant.
        (allocate_gnat_aux_type): New function.
        (init_type): Add initialization the type-specific stuff for
        TYPE_CODE_FLT and TYPE_CODE_FUNC types.
        (print_gnat_stuff): New function.
        (recursive_dump_type): Use HAVE_CPLUS_STRUCT to check for cplus-
        specific data.  Adjust code that prints the contents of the
        type-specific union using the TYPE_SPECIFIC_FIELD value.
        * dwarf2read.c (dwarf2_attach_fields_to_type): Do not allocate
        the type cplus stuff for Ada types.
        (dwarf2_add_member_fn, dwarf2_attach_fn_fields_to_type):
        Error out if these routines are called with an Ada type.
        (read_structure_type, read_array_type, read_subrange_type):
        Add call to set_descriptive_type.
        (set_die_type): Initialize the gnat-specific data if necessary.
        (need_gnat_info, die_descriptive_type, set_descriptive_type):
        New functions.
        * ada-lang.c (decode_constrained_packed_array_type): Use
        decode_constrained_packed_array_type instead of doing a standard
        lookup to locate a parallel type.
        (find_parallel_type_by_descriptive_type): New function.
        (ada_find_parallel_type_with_name): New function.
        (ada_find_parallel_type): Reimplement using
        ada_find_parallel_type_with_name.
        * ada-valprint.c (print_field_values): Use HAVE_CPLUS_STRUCT
        to check if type has a cplus stuff.
        * linespec.c (total_number_of_methods): Likewise.
        * mdebugread.c (new_type): Likewise.

gdb/testsuite/ChangeLog:

        * gdb.base/maint.exp: Adjust the expected output for the
        "maint print type" test. Use gdb_test_multiple instead of
        gdb_sent/gdb_expect.
@
text
@d701 2
d722 2
d754 3
d759 1
a759 1
  if ((p[0] == ':' || p[0] == '.') && paren_pointer == NULL)
a760 3
      if (is_quoted)
	*argptr = *argptr + 1;
      
d769 10
a778 2
	return decode_compound (argptr, funfirstline, canonical,
				saved_arg, p, not_found_ptr);
d780 2
a781 2
      /* No, the first part is a filename; set file_symtab to be that file's
	 symtab.  Also, move argptr past the filename.  */
d783 10
a792 2
      file_symtab = symtab_from_filename (argptr, p, is_quote_enclosed, 
		      			  not_found_ptr);
d852 1
a852 1
      p = skip_quoted (*argptr);
d885 2
@


1.94
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d189 1
a189 1
  if (TYPE_CPLUS_SPECIFIC (type) == NULL)
@


1.93
log
@	* linespec.c (lookup_prefix_sym): Lookup the symbol
	in both STRUCT_DOMAIN and VAR_DOMAIN.
@
text
@d5 1
a5 1
   2009 Free Software Foundation, Inc.
@


1.92
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d1431 1
d1450 20
a1469 1
  return lookup_symbol (copy, 0, STRUCT_DOMAIN, 0);
@


1.91
log
@	* eval.c (evaluate_subexp_standard) [OP_OBJC_MSGCALL]: Support
	platforms that use function descriptors.  Prefer to use function
	pointer types instead of function types.
	* linespec.c (decode_objc): Support function descriptors.  Fully
	initialize SAL result.
	* objc-lang.c (find_methods): Support function descriptors.
	Do not require function symbol to point to text section.

	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): When calling
	via a function pointer, use the descriptor it points to.
@
text
@d1587 2
d1640 1
d1712 1
@


1.90
log
@	* cp-support.h (cp_validate_operator): Declare new function.
	* cp-support.c (cp_validate_operator): New function.
	* linespec.c (decode_compound): For C++ check for a valid operator.
@
text
@d1175 13
a1187 5
	  /* The only match was a non-debuggable symbol.  */
	  values.sals[0].symtab = NULL;
	  values.sals[0].line = 0;
	  values.sals[0].end = 0;
	  values.sals[0].pc = SYMBOL_VALUE_ADDRESS (sym_arr[0]);
@


1.89
log
@	* ui-file.h (ui_file_xstrdup): Mention that the length argument
	may be NULL.
	* ui-file.c (ui_file_xstrdup): Don't dereference LENGTH if it is
	NULL.
	* aix-thread.c (aix_thread_extra_thread_info): Pass NULL as length
	parameter to ui_file_xstrdup.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* infrun.c (print_target_wait_results): Ditto.
	* language.c (add_language): Ditto.
	* linespec.c (cplusplus_error): Ditto.
	* remote.c (escape_buffer): Ditto.
	* typeprint.c (type_to_string): Ditto.
	* utils.c (error_stream): Ditto.
	* varobj.c (value_get_print_value): Ditto.
	* xtensa-tdep.c (xtensa_verify_config): Replace `dummy' local with
	`length' local.  Pass it to ui_file_xstrdup, and avoid an strlen
	call.
	* gdbarch.sh (verify_gdbarch): Ditto.
	* gdbarch.c: Regenerate.
	* cli/cli-setshow.c (do_setshow_command): Pass NULL as length
	parameter to ui_file_xstrdup.
	* python/python-frame.c (frapy_str): Ditto.
	* python/python-type.c (typy_str): Use the length local instead of
	calling strlen.
	* python/python-value.c (valpy_str): Pass NULL as length parameter
	to ui_file_xstrdup.
@
text
@d33 1
d1261 3
d1341 9
a1489 10
      char *tmp;

      if (is_operator_name (copy))
	{
	  tmp = (char *) alloca (strlen (copy + 3) + 9);
	  strcpy (tmp, "operator ");
	  strcat (tmp, copy + 3);
	}
      else
	tmp = copy;
d1492 1
a1492 1
      if (tmp[0] == '~')
d1499 1
a1499 1
			 SYMBOL_PRINT_NAME (sym_class), tmp);
@


1.89.2.1
log
@	* eval.c (evaluate_subexp_standard) [OP_OBJC_MSGCALL]: Support
	platforms that use function descriptors.  Prefer to use function
	pointer types instead of function types.
	* linespec.c (decode_objc): Support function descriptors.  Fully
	initialize SAL result.
	* objc-lang.c (find_methods): Support function descriptors.
	Do not require function symbol to point to text section.

	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): When calling
	via a function pointer, use the descriptor it points to.
@
text
@d1174 5
a1178 13
	  /* The only match was a non-debuggable symbol, which might point
	     to a function descriptor; resolve it to the actual code address
	     instead.  */
	  struct minimal_symbol *msymbol = (struct minimal_symbol *)sym_arr[0];
	  struct objfile *objfile = msymbol_objfile (msymbol);
	  struct gdbarch *gdbarch = get_objfile_arch (objfile);
	  CORE_ADDR pc = SYMBOL_VALUE_ADDRESS (msymbol);

	  pc = gdbarch_convert_from_func_ptr_addr (gdbarch, pc,
						   &current_target);

	  init_sal (&values.sals[0]);
	  values.sals[0].pc = pc;
@


1.89.2.2
log
@	Revert 2009-09-28 commit:
	* eval.c (evaluate_subexp_standard) [OP_OBJC_MSGCALL]: Support
	platforms that use function descriptors.  Prefer to use function
	pointer types instead of function types.
	* linespec.c (decode_objc): Support function descriptors.  Fully
	initialize SAL result.
	* objc-lang.c (find_methods): Support function descriptors.
	Do not require function symbol to point to text section.

	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): When calling
	via a function pointer, use the descriptor it points to.
@
text
@d1174 13
a1186 5
	  /* The only match was a non-debuggable symbol.  */
	  values.sals[0].symtab = NULL;
	  values.sals[0].line = 0;
	  values.sals[0].end = 0;
	  values.sals[0].pc = SYMBOL_VALUE_ADDRESS (sym_arr[0]);
@


1.88
log
@	* linespec.c (find_method): Add new not_found_ptr parameter to
	bring in line with symtab_from_filename, decode_variable.
	(decode_compound): Likewise.  Also propagate not_found_ptr to
	find_method.
	(decode_line_1): Propagate not_found_ptr to decode_compound.
	(cplusplus_error): Now throws NOT_FOUND_ERROR.
@
text
@a152 1
  long len;
d171 3
a173 3
  message = ui_file_xstrdup (tmp_stream, &len);                                   
  make_cleanup (xfree, message);                                              
  throw_error (NOT_FOUND_ERROR, "%s", message);  
@


1.87
log
@	* linespec.c (collect_methods): Delete.
	(add_matching_methods): Reove destructor special case.
	(find_method): Call find_methods directly instead of
	collect_methods.
	* valops.c (value_struct_elt): Remove destructor
	special cases.
	(check_field): Likewise.
	(value_struct_elt_for_reference): Likewise.
	(destructor_name_p): Remove misleading comment about dtors
	being "special cases".
	* gdbtypes.h (get_destructor_fn_field): Remove. No longer needed.
	* gdbtypes.c (get_destructor_fn_field): Likewise.
@
text
@d68 2
a69 1
						 char *p);
d78 2
a79 1
					     struct symbol *sym_class);
d153 2
d171 4
a174 1
  error_stream (tmp_stream);
d766 1
a766 1
				saved_arg, p);
d1200 1
a1200 1
		 char *saved_arg, char *p)
d1367 1
a1367 1
			  copy, t, sym_class);
d1390 2
d1437 1
a1437 1
	     char *copy, struct type *t, struct symbol *sym_class)
d1488 2
@


1.86
log
@	* value.h (struct internalvar): Remove.
	(get_internalvar_integer): Add prototype.
	(set_internalvar_integer): Add prototype.
	(clear_internalvar): Add prototype.

	* value.c (struct internalvar): Move here.  Add type member.  Remove
	endian member.  Add union_internalvar member instead of value member.
	(init_if_undefined_command): Use intvar->type.
	(create_internalvar): Do not initialize value/endian, but type.
	(create_internalvar_type_lazy): Call create_internalvar.
	(value_of_internalvar): Handle host-side internalvar contents.
	(set_internalvar_component): Likewise.
	(set_internalvar): Likewise.
	(get_internalvar_integer): New function.
	(clear_internalvar): Likewise.
	(set_internalvar_integer): Likewise.
	(preserve_values): Handle host-side internalvar contents.

	* breakpoint.c (set_breakpoint_count, set_tracepoint_count): Call
	set_internalvar_integer instead of set_internalvar.
	* findcmd.c (find_command): Likewise.
	* infrun.c (handle_inferior_event): Likewise.
	* source.c (forward_search_command, reverse_search_command): Likewise.
	* tracepoint.c (set_traceframe_num, set_tracepoint_num,
	set_traceframe_context): Likewise.

	* printcmd.c (x_command): Call clear_internalvar instead of
	set_internalvar.
	* tracepoint.c (set_traceframe_context): Likewise.

	* breakpoint.c (get_number_trailer): Call get_internalvar_integer
	instead of value_of_internalvar.
	* linespec.c (decode_dollar): Likewise.

	* expprint.c (dump_subexp_body_standard): Use internalvar_name
	instead of accessing internalvar private elements.
	* valops.c (value_assign): Copy from original source instead of
	accessing internalvar private elements.
@
text
@a78 4
static int collect_methods (char *copy, struct type *t,
			    struct symbol *sym_class,
			    struct symbol **sym_arr);

a304 5
      /* Destructor is handled by caller, don't add it to
	 the list.  */
      if (is_destructor_name (phys_name) != 0)
	continue;

d843 4
d1439 1
a1439 1
  i1 = collect_methods (copy, t, sym_class, sym_arr);
a1489 31
/* Find all methods named COPY in the class whose type is T, and put
   them in SYM_ARR.  Return the number of methods found.  */

static int
collect_methods (char *copy, struct type *t,
		 struct symbol *sym_class, struct symbol **sym_arr)
{
  int i1 = 0;	/*  Counter for the symbol array.  */

  if (destructor_name_p (copy, t))
    {
      /* Destructors are a special case.  */
      int m_index, f_index;

      if (get_destructor_fn_field (t, &m_index, &f_index))
	{
	  struct fn_field *f = TYPE_FN_FIELDLIST1 (t, m_index);

	  sym_arr[i1] =
	    lookup_symbol (TYPE_FN_FIELD_PHYSNAME (f, f_index),
			   NULL, VAR_DOMAIN, (int *) NULL);
	  if (sym_arr[i1])
	    i1++;
	}
    }
  else
    i1 = find_methods (t, copy, SYMBOL_LANGUAGE (sym_class), sym_arr);

  return i1;
}

@


1.85
log
@gdb/
	Replace the savestring calls by xstrdup calls where possible.
	* breakpoint.c (condition_command, set_raw_breakpoint)
	(create_catchpoint, update_breakpoint_locations): Replace the
	savestring calls by xstrdup calls where possible.
	* buildsym.c (start_subfile, patch_subfile_names, record_debugformat)
	(record_producer): Likewise.
	* coffread.c (coff_start_symtab, complete_symtab): Likewise.
	* corefile.c (set_gnutarget): Likewise.
	* dbxread.c (add_new_header_file): Likewise.
	* demangle.c (set_demangling_command, set_demangling_style): Likewise.
	* event-top.c (push_prompt, pop_prompt, command_line_handler)
	(set_async_prompt): Likewise.
	* infcmd.c (set_inferior_io_terminal, attach_command_post_wait):
	Likewise.
	* language.c (set_language_command, _initialize_language): Likewise.
	* linespec.c (decode_line_2): Likewise.
	* rs6000-nat.c (add_vmap): Likewise.
	* top.c (set_prompt, init_history, init_main): Likewise.
	* tracepoint.c (stringify_collection_list): Likewise.
	* varobj.c (varobj_create): Remove variable expr_len.  Replace the
	savestring calls by xstrdup calls where possible.
	(value_of_root, c_name_of_variable, c_describe_child): Replace the
	savestring calls by xstrdup calls where possible.
	* xcoffread.c (complete_symtab): Likewise.
	* cli/cli-script.c (build_command_line, define_command): Likewise.
	* cli/cli-setshow.c (do_setshow_command): Likewise.
@
text
@d1672 1
a1672 1
  struct value *valx;
d1687 1
d1689 2
a1690 2
      valx = access_value_history ((copy[1] == '$') ? -index : index);
      if (TYPE_CODE (value_type (valx)) != TYPE_CODE_INT)
d1692 1
d1714 1
a1714 2
      valx = value_of_internalvar (lookup_internalvar (copy + 1));
      if (TYPE_CODE (value_type (valx)) != TYPE_CODE_INT)
d1722 1
a1722 1
  val.line = value_as_long (valx);
@


1.84
log
@        Updated copyright notices for most files.
@
text
@d590 1
a590 1
		      canonical_arr[i] = savestring (symname, strlen (symname));
d614 1
a614 1
		  canonical_arr[i] = savestring (symname, strlen (symname));
@


1.83
log
@	* breakpoint.h (struct bp_location): Change type of section
	member to "struct obj_section *".
	* tracepoint.h (struct tracepoint): Likewise.
	* symtab.h (struct general_symbol_info): Replace bfd_section
	member with obj_section.
	(struct symtab_and_line): Change type of section member to
	"struct obj_section *".
	(SYMBOL_BFD_SECTION): Remove macro, replace by ...
	(SYMBOL_OBJ_SECTION): ... this.

	* minsym.c (prim_record_minimal_symbol_and_info): Record symbol
	section as obj_section instead of bfd_section.

	* ada-lang.c (ada_decode_symbol): Use gsymbol->obj_section
	directly instead of looking of obj_section from bfd_section.

	* objfiles.h (find_pc_sect_section): Remove.
	* objfiles.c (find_pc_sect_section): Remove.
	(find_pc_section): Inline find_pc_sect_section code.

	* symfile.h (find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(section_is_overlay, section_is_mapped): Change type of section
	argument to struct obj_section *.
	(pc_in_mapped_range, pc_in_unmapped_range): Likewise.
	(overlay_mapped_address, overlay_unmapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	* symtab.h (symbol_overlayed_address): Likewise.
	* symfile.c (overlay_is_mapped): Remove.
	(section_is_mapped): Inline overlay_is_mapped code.  Update.
	(overlay_invalidate_all): Update.
	(section_is_overlay): Change section argument to type
	"struct obj_section *".  Use bfd_ methods.
	(pc_in_unmapped_range): Likewise.  Handle relocated sections.
	(pc_in_mapped_range): Likewise.  Handle relocated sections.
	(sections_overlap): Likewise.
	(overlay_unmapped_address): Likewise.
	(overlay_mapped_address): Likewise.
	(symbol_overlayed_address): Likewise.
	(find_pc_overlay): Return struct obj_section *.
	(find_pc_mapped_section): Likewise.
	(list_overlays_command): Update.
	(map_overlay_command, unmap_overlay_command): Update.
	(simple_overlay_update): Update.

	* block.h (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* block.c (blockvector_for_pc_sect): Change section argument
	to type "struct obj_section *".
	(block_for_pc_sect): Likewise.
	* symtab.h (find_pc_sect_function, find_pc_sect_psymtab,
	find_pc_sect_symtab, find_pc_sect_psymbol, find_pc_sect_line,
	lookup_minimal_symbol_by_pc_section, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.
	* blockframe.c (find_pc_sect_function): Likewise.
	* breakpoint.c (describe_other_breakpoints): Likewise.
	(breakpoint_has_pc, check_duplicates_for): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_minimal_symbol_by_pc_section): Likewise.
	* symtab.c (find_pc_sect_psymtab_closer): Likewise.
	(find_pc_sect_psymtab, find_pc_sect_psymbol, find_pc_sect_symtab,
	find_pc_sect_line, find_function_start_pc): Likewise.
	(matching_bfd_sections): Rename to ...
	(matching_obj_sections): ... this.  Update argument types.

	* blockframe.c (find_pc_partial_function): Update to section
	type changes.  No longer call find_pc_sect_section.
	(cache_pc_function_section): Change to type "struct obj_section *".
	* breakpoint.c (resolve_sal_pc): Update to section type changes.
	* exec.c (xfer_memory): Likewise.
	* findvar.c (read_var_value): Likewise.
	* infcmd.c (jump_command): Likewise.
	* linespec.c (minsym_found): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Likewise.
	(lookup_solib_trampoline_symbol_by_pc): Likewise.
	* parse.c (write_exp_msymbol): Likewise.
	* printcmd.c (build_address_symbolic): Likewise.
	(address_info, sym_info): Likewise.
	* symmisc.c (dump_msymbols, print_symbol): Likewise.
	* symtab.c (fixup_section): Likewise.
	(fixup_symbol_section, fixup_psymbol_section): Likewise.
	(find_pc_line, find_function_start_sal): Likewise.
	* target.c (memory_xfer_partial): Likewise.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline): Likewise.
	* spu-tdep.c (spu_overlay_update): Likewise.
@
text
@d4 2
a5 2
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
   Free Software Foundation, Inc.
@


1.83.4.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@a25 1
#include "exec.h"
a28 1
#include "inferior.h"
a53 2
extern struct exec *decode_sharp (char **argptr);

a131 1
						 struct exec *exec,
a395 3
  char *exec_name;
  int exec_space;

a405 11
  /* Maybe add the exec's name to the front of the canonical name.  */
  exec_name = NULL;
  exec_space = 0;
  if (number_of_execs () > 1
      && s->objfile
      && s->objfile->exec)
    {
      exec_name = s->objfile->exec->shortname;
      exec_space = strlen (exec_name) + 2;
    }

d409 2
a410 4
      canonical_name = xmalloc (exec_space + strlen (filename) + strlen (symname) + 2);
      if (exec_name)
	sprintf (canonical_name, "#%s#", exec_name);
      sprintf (canonical_name + exec_space, "%s:%s", filename, symname);
d414 2
a415 4
      canonical_name = xmalloc (exec_space + strlen (filename) + 30);
      if (exec_name)
	sprintf (canonical_name, "#%s#", exec_name);
      sprintf (canonical_name + exec_space, "%s:%d", filename, sal->line);
d691 1
a691 1
  struct exec *exec;
d710 1
a710 7

  /* Start with a plausible default for the executable.  */
  exec = (number_of_execs () > 1 ? current_exec : NULL);

  if (**argptr == '#')
    exec = decode_sharp (argptr);

d879 1
a879 1
			  file_symtab, exec, not_found_ptr);
a966 24
/* The #-sign introduces a specification of an executable.  */

struct exec *
decode_sharp (char **argptr)
{
  char *exec_spec, *spec_end;
  struct exec *exec = NULL;

  /* Skip over the '#'.  */
  (*argptr)++;
  exec_spec = *argptr;
  spec_end = strchr (exec_spec, '#');
  if (!spec_end)
    error (_("Unmatched '#'."));
  exec = find_exec_by_substr (exec_spec, spec_end);
  if (!exec)
    {
      char *name = savestring (exec_spec, spec_end - exec_spec);
      error (_("No exec named `%s'"), name);
    }
  *argptr = spec_end + 1;
  return exec;
}

d974 1
a974 1

d1743 1
a1743 1
		 struct symtab *file_symtab, struct exec *exec, int *not_found_ptr)
d1749 1
a1749 1
  sym = lookup_symbol_in_exec (copy,
a1753 1
		       exec,
d1759 1
a1759 1
  msymbol = lookup_minimal_symbol_in_exec (copy, NULL, exec);
d1808 2
a1809 5
	  if (lookup_block_symbol (b, copy, NULL, VAR_DOMAIN) != NULL
	      || number_of_execs () > 1)
	    {
	      build_canonical_line_spec (values.sals, copy, canonical);
	    }
a1810 2
      else if (number_of_execs () > 1)
	build_canonical_line_spec (values.sals, copy, canonical);
a1825 2
	  if (number_of_execs () > 1)
	    build_canonical_line_spec (values.sals, copy, canonical);
@


1.82
log
@	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME.
	* blockframe.c (find_pc_partial_function): Likewise.
	* buildsym.c (find_symbol_in_list): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* coffread.c (patch_opaque_types, process_coff_symbol): Likewise.
	(coff_read_enum_type): Likewise.  Use SYMBOL_SET_LINKAGE_NAME.
	* cp-support.c (cp_remove_params): Renamed from remove_params and
	made global.
	(overload_list_add_symbol): Update call to remove_params.
	* cp-support.h (cp_remove_params): Declare.
	* dwarf2read.c (process_enumeration_scope): Use SYMBOL_LINKAGE_NAME.
	(dwarf2_const_value): Use SYMBOL_PRINT_NAME.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* f-valprint.c (info_common_command, there_is_a_visible_common_named):
	Use SYMBOL_LINKAGE_NAME to find symbols and SYMBOL_PRINT_NAME
	for messages.
	* findvar.c (read_var_value): Use SYMBOL_LINKAGE_NAME.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa_hpux_skip_trampoline_code): Use SYMBOL_LINKAGE_NAME to find
	symbols and SYMBOL_PRINT_NAME for messages.
	* jv-lang.c (add_class_symbol): Use SYMBOL_SET_LINKAGE_NAME.
	* linespec.c (decode_line_2): Use SYMBOL_LINKAGE_NAME.
	* mdebugread.c (parse_symbol): Use SYMBOL_LINKAGE_NAME and
	SYMBOL_SET_LINKAGE_NAME.
	(mylookup_symbol): Use SYMBOL_LINKAGE_NAME.
	* minsyms.c (add_minsym_to_demangled_hash_table): Use
	SYMBOL_SEARCH_NAME.
	(lookup_minimal_symbol): Use SYMBOL_LINKAGE_NAME or
	SYMBOL_MATCHES_SEARCH_NAME, depending on the pass.
	* objfiles.h (ALL_OBJFILE_MSYMBOLS): Use SYMBOL_LINKAGE_NAME.
	* printcmd.c (build_address_symbolic): Use SYMBOL_LINKAGE_NAME.
	(address_info): Use SYMBOL_PRINT_NAME for messages and
	SYMBOL_LINKAGE_NAME for lookups.
	* sol-thread.c (info_cb): Use SYMBOL_PRINT_NAME for messages.
	* stabsread.c (patch_block_stabs, define_symbol)
	(read_type, read_enum_type, common_block_end)
	(cleanup_undefined_types_1, scan_file_globals): Use
	SYMBOL_LINKAGE_NAME, SYMBOL_SET_LINKAGE_NAME, ALL_OBJFILE_MSYMBOLS,
	and SYMBOL_PRINT_NAME.
	* stack.c (print_frame_args): Use SYMBOL_LINKAGE_NAME.
	(print_frame, frame_info): Use SYMBOL_PRINT_NAME for output.  Use
	cp_remove_params instead of cplus_demangle.
	(print_block_frame_labels, print_frame_arg_vars): Use
	SYMBOL_LINKAGE_NAME.
	* symmisc.c (dump_msymbols): Use ALL_OBJFILE_MSYMBOLS and
	SYMBOL_LINKAGE_NAME.
	(dump_symtab_1, print_symbol, print_partial_symbols)
	(maintenance_check_symtabs): Use SYMBOL_LINKAGE_NAME.
	* symtab.h (DEPRECATED_SYMBOL_NAME): Delete.
	(SYMBOL_SET_LINKAGE_NAME): New.
	(SYMBOL_SET_NAMES): Add a comment.
	* tracepoint.c (set_traceframe_context, validate_actionline)
	(collect_symbol, scope_info): Use SYMBOL_LINKAGE_NAME for
	lookups and SYMBOL_PRINT_NAME for output.
	* typeprint.c (typedef_print): Use SYMBOL_LINKAGE_NAME.
	* xcoffread.c (process_xcoff_symbol): Use SYMBOL_SET_LINKAGE_NAME.
@
text
@d1852 2
a1853 2
				      (struct bfd_section *) 0, 0);
  values.sals[0].section = SYMBOL_BFD_SECTION (msymbol);
@


1.81
log
@	gdb/
	* linespec.c (symtab_from_filename): Also throw NOT_FOUND_ERROR if
	there are no symbols loaded, instead of throwing a generic error.
	(decode_variable): Likewise.

	gdb/testsuite/
	* gdb.base/pending.exp: Test pending breakpoints without symbols
	loaded.
@
text
@d589 1
a589 1
		      symname = DEPRECATED_SYMBOL_NAME (sym_arr[i]);
d612 1
a612 1
		  symname = DEPRECATED_SYMBOL_NAME (sym_arr[num]);
@


1.80
log
@* linespec.c (decode_objc): Save current language around call to
get_selected_block.
@
text
@a1558 2
      if (!have_full_symbols () && !have_partial_symbols ())
	error (_("No symbol table is loaded.  Use the \"file\" command."));
d1561 3
a1763 4
  if (!have_full_symbols () &&
      !have_partial_symbols () && !have_minimal_symbols ())
    error (_("No symbol table is loaded.  Use the \"file\" command."));

d1766 6
@


1.79
log
@	* symtab.h (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	* symtab.c (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	(search_symbols): Update.

	* linespec.c (find_methods, collect_methods): Update.
	(add_matching_methods, add_constructors): Update.
	(decode_compound, decode_dollar, decode_variable): Update.
	(lookup_prefix_sym): Update.

	(symbol_found): Remove SYM_SYMTAB parameter.
	Use SYMBOL_SYMTAB (sym) instead.

	* gdbtypes.c (lookup_typename): Update.
	(lookup_struct, lookup_union, lookup_enum): Update.
	(lookup_template_type): Update.
	(check_typedef): Update.
	* language.c (lang_bool_type): Update.
	* mdebugread.c (parse_procedure): Update.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* parse.c (write_dollar_variable): Update.
	* printcmd.c (address_info): Update.
	* source.c (select_source_symtab): Update.
	* stack.c (print_frame_args, print_frame_arg_vars): Update.
	* valops.c (find_function_in_inferior): Update.
	(value_struct_elt_for_reference): Update.
	* value.c (value_static_field, value_fn_field): Update.

	* alpha-mdebug-tdep.c (find_proc_desc): Update.
	* arm-tdep.c (arm_skip_prologue): Update.
	* mt-tdep.c (mt_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Update.

	* ada-lang.h (struct ada_symbol_info): Remove SYMTAB member.
	* ada-lang.c (ada_add_block_symbols): Remove SYMTAB parameter.
	(add_defn_to_vec): Likewise.
	(ada_add_block_symbols): Likewise.
	(lookup_cached_symbol, cache_symbol): Likewise.
	(standard_lookup): Update.
	(ada_lookup_symbol_list): Update.

	* c-valprint.c (c_val_print): Update.
	* cp-support.c (cp_lookup_rtti_type): Update.
	* jv-lang.c (java_lookup_class, get_java_object_type): Update.
	* objc-lang.c (lookup_struct_typedef, find_imps): Update.
	* p-valprint.c (pascal_val_print): Update.
	* scm-lang.c (scm_lookup_name): Update.

	* c-exp.y: Update.
	* f-exp.y: Update.
	* jv-exp.y: Update.
	* m2-exp.y: Update.
	* objc-exp.y: Update.
	* p-exp.y: Update.
@
text
@d1119 10
a1128 2
    block = get_selected_block (0);
    
@


1.78
log
@        * linespec.c (decode_line_1): Fix a couple of comments.
@
text
@d139 1
a139 2
				struct symtab *file_symtab,
				struct symtab *sym_symtab);
d216 1
a216 2
			 STRUCT_DOMAIN, language, (int *) NULL,
			 (struct symtab **) NULL)))
d317 1
a317 2
				   (int *) NULL,
				   (struct symtab **) NULL);
d374 1
a374 2
				   (int *) NULL,
				   (struct symtab **) NULL);
d799 1
a799 1
      sym = lookup_symbol (copy, 0, VAR_DOMAIN, 0, &sym_symtab);
d803 1
a803 2
	  return symbol_found (funfirstline, canonical, copy, sym,
			       NULL, sym_symtab);
a1196 2
  /* The symtab that SYM was found in.  */
  struct symtab *sym_symtab;
d1374 1
a1374 1
  sym = lookup_symbol (copy, 0, VAR_DOMAIN, 0, &sym_symtab);
d1376 1
a1376 2
    return symbol_found (funfirstline, canonical, copy, sym,
			 NULL, sym_symtab);
d1417 1
a1417 2
  return lookup_symbol (copy, 0, STRUCT_DOMAIN, 0,
			(struct symtab **) NULL);
d1507 1
a1507 2
			   NULL, VAR_DOMAIN, (int *) NULL,
			   (struct symtab **) NULL);
a1669 2
  /* The symtab that SYM was found in.  */
  struct symtab *sym_symtab;
d1689 1
a1689 1
      sym = lookup_symbol (copy, 0, VAR_DOMAIN, 0, &sym_symtab);
d1694 1
a1694 2
	return symbol_found (funfirstline, canonical, copy, sym,
			     NULL, sym_symtab);
a1736 2
  /* The symtab that SYM was found in.  */
  struct symtab *sym_symtab;
d1745 1
a1745 1
		       VAR_DOMAIN, 0, &sym_symtab);
d1748 1
a1748 2
    return symbol_found (funfirstline, canonical, copy, sym,
			 file_symtab, sym_symtab);
d1775 1
a1775 2
	      struct symbol *sym, struct symtab *file_symtab,
	      struct symtab *sym_symtab)
d1795 1
a1795 1
	  struct blockvector *bv = BLOCKVECTOR (sym_symtab);
d1813 1
a1813 1
	  values.sals[0].symtab = sym_symtab;
@


1.77
log
@	* linespec.c: Include "target.h".
	(minsym_found): Handle minimal symbols pointing to function
	descriptors.  Use find_function_start_pc.
	* minsyms.c (msymbol_objfile): New function.
	* parse.c (write_exp_msymbol): Handle minimal symbols pointing
	to function descriptors.
	* symtab.c (fixup_section): Only use minimal symbol at the same
	address to determine section of a symbol.
	(find_function_start_pc): New function.
	(find_function_start_sal): Use it.
	* symtab.h (msymbol_objfile): Add prototype.
	(find_function_start_pc): Likewise.
	* value.c: Include "objfiles.h".
	(value_fn_field): Handle minimal symbols pointing to function
	descriptors.
	* Makefile.in (linespec.o): Update dependencies.
	(value.o): Likewise.
@
text
@d774 1
a774 1
      /* No, the first part is a filename; set s to be that file's
d815 1
a815 1
  /* S is specified file's symtab, or 0 if no file specified.
@


1.76
log
@Include interps.h and mi/mi-cmds.h.
(decode_line_2): When using MI, always set all breakpoints in menu.
@
text
@d41 1
d1850 2
d1853 1
d1860 9
d1873 3
a1875 4
      values.sals[0].pc
	+= gdbarch_deprecated_function_start_offset (current_gdbarch);
      values.sals[0].pc = gdbarch_skip_prologue
			    (current_gdbarch, values.sals[0].pc);
@


1.75
log
@        * symtab.c (multiple_symbols_ask, multiple_symbols_all)
        (multiple_symbols_cancel): New constants.
        (multiple_symbols_modes, multiple_symbols_mode): New static globals.
        (multiple_symbols_select_mode): New function.
        (_initialize_symtab): Add new set/show multiple-symbols commands.
        * symtab.h (multiple_symbols_ask, multiple_symbols_all)
        (multiple_symbols_cancel, multiple_symbols_select_mode): Declare.
        * ada-lang.c (user_select_syms): Add handling of new multiple-symbols
        setting.
        * linespec.c (decode_line_2): Likewise.
@
text
@d39 2
d529 2
a530 1
  if (select_mode == multiple_symbols_all)
@


1.74
log
@	Updated copyright notices for most files.
@
text
@d494 1
d496 5
a515 1
  printf_unfiltered (_("[0] cancel\n[1] all\n"));
d521 1
a521 17
	{
	  values.sals[i] = find_function_start_sal (sym_arr[i], funfirstline);
	  if (values.sals[i].symtab)
	    printf_unfiltered ("[%d] %s at %s:%d\n",
			       (i + 2),
			       SYMBOL_PRINT_NAME (sym_arr[i]),
			       values.sals[i].symtab->filename,
			       values.sals[i].line);
	  else
	    printf_unfiltered (_("[%d] %s at ?FILE:%d [No symtab? Probably broken debug info...]\n"),
			       (i + 2),
			       SYMBOL_PRINT_NAME (sym_arr[i]),
			       values.sals[i].line);

	}
      else
	printf_unfiltered (_("?HERE\n"));
d525 5
a529 2
  prompt = getenv ("PS2");
  if (prompt == NULL)
d531 30
a560 1
      prompt = "> ";
a561 1
  args = command_line_input (prompt, 0, "overload-choice");
@


1.73
log
@	* breakpoint.c (remove_sal): New.
	(expand_line_sal_maybe): New.
	(create_breakpoints): Call expand_line_sal_maybe.
	(clear_command): Add comment.
	(breakpoint_re_set_one): Call expand_line_sal_maybe.
	* linespec.c (decode_indirect): Set explicit_pc to 1.
	(decode_all_digits): Set explicit_line to 1.
	(append_expanded_sal): New.
	(expand_line_sal): New.
	* linespec.h (expand_line_sal): Declare.
	* symtab.c (init_sal): Initialize explicit_pc
	and explicit_line.
	* symtab.h (struct symtab_and_line): New fields
	explicit_pc and explicit_line.
@
text
@d4 1
a4 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007
@


1.72
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d966 1
d1637 1
@


1.71
log
@2007-08-10  Michael Snyder  <msnyder@@access-company.com>

	* linespec.c (decode_dollar): Dead code, ptr can't be non-null.
	(decode_objc): Use "NULL" instead of 0.
	(find_method): Ditto.
	(decode_all_digits): Ditto.
	(decode_dollar): Ditto.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.70
log
@	* linespec.c (minsym_found): Advance to the next line if possible.

	* gdb.base/prologue.c, gdb.base/prologue.exp: New.
	* lib/gdb.exp (gdb_breakpoint): Handle "temporary".
@
text
@d1108 1
a1108 1
      sym_arr[i1] = 0;
d1148 1
a1148 1
	  values.sals[0].symtab = 0;
d1414 1
a1414 1
  struct symbol *sym = 0;
d1576 1
a1576 1
  int need_canonical = (file_symtab == 0) ? 1 : 0;
d1678 1
a1678 1
      file_symtab = (struct symtab *) 0;
a1691 1
      need_canonical = (file_symtab == 0) ? 1 : 0;
@


1.69
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (DEPRECATED_FUNCTION_START_OFFSET): Replace by
	gdbarch_deprecated_function_start_offset.
	* symtab.c (find_function_start_sal)skip_prologue_using_sal): Likewise.
	* linespec.c (minsym_found): Likewise.
	* infrun.c (handle_inferior_event): Likewise.
	* infcall.c (find_function_addr): Likewise.
	* cli/cli-cmds.c (disassemble_command): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1836 2
d1842 13
d1856 1
@


1.68
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SKIP_PROLOGUE): Replace by gdbarch_skip_prologue.
	* symtab.c (find_function_start_sal, in_prologue): Likewise.
	* linespec.c (minsym_found): Likewise.
	* infrun.c (step_into_function): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1836 2
a1837 1
      values.sals[0].pc += DEPRECATED_FUNCTION_START_OFFSET;
@


1.67
log
@	* linespec.c: Include language.h.
	(find_methods): Add language parameter.  Call
	lookup_symbol_in_language.  Pass language down.
	(add_matching_methods): Likewise.  Call
	lookup_symbol_in_language.
	(add_constructors): Likewise.
	(find_method): Pass sym_class to collect_methods.
	(collect_methods): Add sym_class parameter.  Pass language
	down.
	* symtab.c (lookup_symbol): Rename to ...
	(lookup_symbol_in_language): ... this.  Add language
	parameter.  Use passed language instead of current_language.
	(lookup_symbol): New as wrapper around
	lookup_symbol_in_language.
	(lookup_symbol_aux): Add language parameter.  Use passed
	language instead of current_language.
	(search_symbols): Indent.
	* symtab.h (enum language): Forward declare.
	(lookup_symbol_in_language): Declare.
	(lookup_symbol): Update description.
	* ada-lang.h (lookup_symbol_in_language): Remove declaration.
	* ada-lang.c (restore_language): Remove.
	(lookup_symbol_in_language): Remove.
@
text
@d1837 2
a1838 1
      values.sals[0].pc = SKIP_PROLOGUE (values.sals[0].pc);
@


1.66
log
@Copyright updates for 2007.
@
text
@d40 1
d79 1
d88 2
a89 1
static int find_methods (struct type *, char *, struct symbol **);
d92 1
d96 1
d204 2
a205 1
find_methods (struct type *t, char *name, struct symbol **sym_arr)
d215 2
a216 2
      && (lookup_symbol (class_name, (struct block *) NULL,
			 STRUCT_DOMAIN, (int *) NULL,
d247 1
a247 1
	    i1 += add_matching_methods (method_counter, t,
d252 1
a252 1
	    i1 += add_constructors (method_counter, t,
d270 2
a271 1
      i1 += find_methods (TYPE_BASECLASS (t, ibase), name, sym_arr + i1);
d282 1
a282 1
		      struct symbol **sym_arr)
d309 1
a309 1
		
d315 1
a315 1
      sym_arr[i1] = lookup_symbol (phys_name,
d317 1
d344 1
a344 1
		  struct symbol **sym_arr)
d360 1
a360 1
		  
d373 1
a373 1
      sym_arr[i1] = lookup_symbol (phys_name,
d375 1
d1422 1
a1422 1
  i1 = collect_methods (copy, t, sym_arr);
d1478 1
a1478 1
		 struct symbol **sym_arr)
d1500 1
a1500 1
    i1 = find_methods (t, copy, sym_arr);
@


1.65
log
@* linespec.c (decode_objc): Make i1 and i2 unsigned.
(find_method): Set values.sals to NULL.
@
text
@d3 2
a4 2
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
@


1.64
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d1083 2
a1084 2
  int i1 = 0;
  int i2 = 0;
d1430 1
@


1.63
log
@2005-04-26  Andrew Cagney  <cagney@@gnu.org>

	* remote.c (remote_open_1): Move "ex"'s declaration to where it is
	used.
	(remote_get_thread_local_address): Use throw_error, include a
	printed string.
	* linux-thread-db.c (thread_db_get_thread_local_address): Ditto.
	* dwarf2loc.c (dwarf_expr_tls_address): Ditto.
	* cli/cli-script.c (script_from_file): Mark up throw_error message.
	* linespec.c (symtab_from_filename, decode_variable): Ditto.
@
text
@d3 1
a3 1
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.62
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d1532 1
a1532 1
      throw_error (NOT_FOUND_ERROR, "No source file named %s.", copy);
d1744 1
a1744 1
  throw_error (NOT_FOUND_ERROR, "Function \"%s\" not defined.", copy);
@


1.61
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d503 1
a503 1
  printf_unfiltered ("[0] cancel\n[1] all\n");
d518 1
a518 1
	    printf_unfiltered ("[%d] %s at ?FILE:%d [No symtab? Probably broken debug info...]\n",
d525 1
a525 1
	printf_unfiltered ("?HERE\n");
d576 1
a576 1
	  printf_unfiltered ("No choice number %d.\n", num);
d594 1
a594 1
	      printf_unfiltered ("duplicate request for %d ignored.\n", num);
@


1.60
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d537 1
a537 1
    error_no_arg ("one or more choice numbers");
@


1.59
log
@2005-01-14  Andrew Cagney  <cagney@@gnu.org>

	* linespec.c (symtab_from_filename, decode_variable): Use
	throw_error instead of error_silent.
	* breakpoint.c (do_captured_parse_breakpoint): Change return type
	to void.
	(break_command_1): Use catch_exception and check the error return
	status.
	* exceptions.c (throw_error): New function.
	(throw_vsilent): Delete function.
	* exceptions.h (throw_error): Declare.
	(throw_vsilent): Delete declaration.
	* utils.c (error_silent): Delete function.
	* defs.h (error_silent): Delete declaration.
@
text
@d548 1
a548 1
	error ("Arguments must be choice numbers.");
d553 1
a553 1
	error ("canceled");
d810 1
a810 1
	error ("Unmatched single quote.");
d1015 1
a1015 1
	    error ("malformed template specification in command");
d1122 1
a1122 1
	      warning ("debugging symbol \"%s\" does not match selector; ignoring", SYMBOL_LINKAGE_NAME (sym));
d1230 1
a1230 1
		error ("malformed template specification in command");
d1529 1
a1529 1
	error ("No symbol table is loaded.  Use the \"file\" command.");
d1659 1
a1659 1
	error ("History values used in line specs must have integer values.");
d1685 1
a1685 1
	error ("Convenience variables used in line specs must have integer values.");
d1740 1
a1740 1
    error ("No symbol table is loaded.  Use the \"file\" command.");
d1789 1
a1789 1
	error ("\"%s\" is not a function", copy);
d1807 1
a1807 1
	error ("Line number not known for symbol \"%s\"", copy);
@


1.58
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_TYPE, VALUE_NEXT, VALUE_OFFSET, VALUE_BITSIZE)
	(VALUE_BITPOS): Delete.
	(value_type, value_offset, value_bitsize, value_bitpos): Declare.
	* value.c (value_type, value_offset, value_bitpos)
	(value_bitsize): New functions.  Update references.
	* arm-tdep.c, gnu-v3-abi.c, hpacc-abi.c, gnu-v2-abi.c: Update.
	* f-valprint.c, cp-valprint.c, c-valprint.c: Update.
	* ada-valprint.c, typeprint.c, scm-valprint.c, scm-exp.c: Update.
	* p-valprint.c, jv-valprint.c, jv-lang.c, varobj.c: Update.
	* objc-lang.c, ada-lang.c, std-regs.c, stack.c: Update.
	* infcall.c, linespec.c, printcmd.c, valarith.c: Update.
	* valops.c, eval.c, findvar.c, breakpoint.c: Update.
	* tracepoint.c, ax-gdb.c, mi/mi-main.c, cli/cli-dump.c:
	* rs6000-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d2 3
a4 2
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d39 1
d1531 2
a1532 12
	{
	  *not_found_ptr = 1;
	  /* The caller has indicated that it wishes quiet notification of any
	     error where the function or file is not found.  A call to 
	     error_silent causes an error to occur, but it does not issue 
	     the supplied message.  The message can be manually output by
	     the caller, if desired.  This is used, for example, when 
	     attempting to set breakpoints for functions in shared libraries 
	     that have not yet been loaded.  */
	  error_silent ("No source file named %s.", copy);
	}
      error ("No source file named %s.", copy);
d1743 2
a1744 13
    {
      *not_found_ptr = 1;
      /* The caller has indicated that it wishes quiet notification of any
	 error where the function or file is not found.  A call to 
	 error_silent causes an error to occur, but it does not issue 
	 the supplied message.  The message can be manually output by
	 the caller, if desired.  This is used, for example, when 
	 attempting to set breakpoints for functions in shared libraries 
	 that have not yet been loaded.  */
      error_silent ("Function \"%s\" not defined.", copy);
    }
  
  error ("Function \"%s\" not defined.", copy);
@


1.57
log
@2004-06-18  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_FUNCTION_START_OFFSET): Deprecated.
	* gdbarch.h, gdbarch.c: Re-generate.
	* ada-lang.c (ada_finish_decode_line_1): Update.
	* infrun.c (handle_inferior_event): Update.
	* infcall.c (find_function_addr): Update.
	* linespec.c (minsym_found): Update.
	* symtab.c (find_function_start_sal, skip_prologue_using_sal):
	Update.
	* blockframe.c (legacy_frameless_look_for_prologue): Update.
	* cli/cli-cmds.c (disassemble_command): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.

Index: doc/ChangeLog
2004-06-18  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	FUNCTION_START_OFFSET.
@
text
@d1666 1
a1666 1
      if (TYPE_CODE (VALUE_TYPE (valx)) != TYPE_CODE_INT)
d1692 1
a1692 1
      if (TYPE_CODE (VALUE_TYPE (valx)) != TYPE_CODE_INT)
@


1.56
log
@2004-02-11  David Carlton  <carlton@@kealia.com>

	* linespec.c (decode_compound): Only look for a class symbol when
	considering all but the rightmost component.

2004-02-11  David Carlton  <carlton@@kealia.com>

	* gdb.cp/breakpoint.exp: New.
	* gdb.cp/breakpoint.cc: New.
@
text
@d1845 1
a1845 1
      values.sals[0].pc += FUNCTION_START_OFFSET;
@


1.56.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d1845 1
a1845 1
      values.sals[0].pc += DEPRECATED_FUNCTION_START_OFFSET;
@


1.55
log
@2004-02-09  Elena Zannoni  <ezannoni@@redhat.com>

	* linespec.c (decode_line_1, locate_first_half)
	(decode_compound, lookup_prefix_sym): Update comments. Delete old
	commented out code.
@
text
@d1183 13
a1195 19
  /* We have what looks like a class or namespace
     scope specification (A::B), possibly with many
     levels of namespaces or classes (A::B::C::D).

     Some versions of the HP ANSI C++ compiler (as also possibly
     other compilers) generate class/function/member names with
     embedded double-colons if they are inside namespaces. To
     handle this, we loop a few times, considering larger and
     larger prefixes of the string as though they were single
     symbols.  So, if the initially supplied string is
     A::B::C::D::foo, we have to look up "A", then "A::B",
     then "A::B::C", then "A::B::C::D", and finally
     "A::B::C::D::foo" as single, monolithic symbols, because
     A, B, C or D may be namespaces.

     Note that namespaces can nest only inside other
     namespaces, and not inside classes.  So we need only
     consider *prefixes* of the string; there is no need to look up
     "B::C" separately as a symbol in the previous example.  */
a1211 72

      /* Start of lookup in the symbol tables. */

      /* Lookup in the symbol table the substring between argptr and
	 p. Note, this call changes the value of argptr.  */
      /* PASS1: Before the call, argptr->"AAA::inA::fun",
	 p->"::inA::fun".  After the call: argptr->"inA::fun", p
	 unchanged.  */
      /* PASS2: Before the call, argptr->"AAA::inA::fun", p->"::fun".
	 After the call: argptr->"fun", p->"::fun".  */
      sym_class = lookup_prefix_sym (argptr, p);

      /* PASS1: assume sym_class == NULL. Skip the whole if-stmt. */
      /* PASS2: assume sym_class has been found, i.e. "AAA::inA" is a
	 class. Enter the if-stmt.  */
      if (sym_class &&
	  (t = check_typedef (SYMBOL_TYPE (sym_class)),
	   (TYPE_CODE (t) == TYPE_CODE_STRUCT
	    || TYPE_CODE (t) == TYPE_CODE_UNION)))
	{
	  /* Arg token is not digits => try it as a function name.
	     Find the next token (everything up to end or next
	     blank).  */
	  if (**argptr
	      && strchr (get_gdb_completer_quote_characters (),
			 **argptr) != NULL)
	    {
	      p = skip_quoted (*argptr);
	      *argptr = *argptr + 1;
	    }
	  else
	    {
	      /* PASS2: at this point argptr->"fun".  */
	      p = *argptr;
	      while (*p && *p != ' ' && *p != '\t' && *p != ',' && *p != ':')
		p++;
	      /* PASS2: at this point p->"".  String ended.  */
	    }

	  /* Allocate our own copy of the substring between argptr and
	     p. */
	  copy = (char *) alloca (p - *argptr + 1);
	  memcpy (copy, *argptr, p - *argptr);
	  copy[p - *argptr] = '\0';
	  if (p != *argptr
	      && copy[p - *argptr - 1]
	      && strchr (get_gdb_completer_quote_characters (),
			 copy[p - *argptr - 1]) != NULL)
	    copy[p - *argptr - 1] = '\0';

	  /* PASS2: At this point copy->"fun", p->"" */

	  /* No line number may be specified.  */
	  while (*p == ' ' || *p == '\t')
	    p++;
	  *argptr = p;

	  /* Look for copy as a method of sym_class. */
	  /* PASS2: at this point copy->"fun", sym_class is "AAA:inA".
	     This concludes the scanning of the string for possible
	     components matches.  If we find it here, we return. If
	     not, and we are at the and of the string, we'll get out
	     of the loop and lookup the whole string in the symbol
	     tables.  */

	  return find_method (funfirstline, canonical, saved_arg,
			      copy, t, sym_class);
	} /* End if symbol found */

      /* End of lookup in the symbol tables.  */

      /* Prepare for next run through the loop.  */
d1219 1
d1239 1
d1243 2
d1252 1
a1252 1
			   string, and p->"".  */
d1260 2
a1261 1
      /* PASS1: at this point p->"::fun" argptr->"AAA::inA::fun".  */
d1266 72
a1337 3
  /* Last chance attempt -- check entire name as a symbol.  Use "copy"
     in preparation for jumping out of this block, to be consistent
     with usage following the jump target.  */
@


1.54
log
@
2004-01-19  Jeff Johnston  <jjohnstn@@redhat.com>

        * linespec.c (decode_variable, symtab_from_filename):  Call
        error_silent with error message instead of throwing an exception
        directly.
        * defs.h (error_silent, error_output_message): Add prototypes.
        (catch_exceptions_with_msg): Ditto.
        * utils.c (error_silent, error_output_message): New functions.
        * top.c (catch_exceptions_with_msg): New function.
@
text
@d697 5
a701 1
  /* Locate the end of the first half of the linespec.  */
d730 7
a736 2
      /* Is it a C++ or Java compound data structure?  */

d966 3
a968 1
   ARGPTR past that and zero out the trailing double quote.  */
d1155 3
a1157 1
   at the first component separator, i.e. double-colon or period.  */
a1164 3
#if 0
  char *q, *q1;
#endif
d1175 4
a1178 3
  /* First check for "global" namespace specification,
     of the form "::foo".  If found, skip over the colons
     and jump to normal symbol processing.  */
d1204 12
d1218 10
d1230 3
d1250 1
d1254 1
d1256 13
a1268 29
/*
   q = operator_chars (*argptr, &q1);
   if (q1 - q)
   {
   char *opname;
   char *tmp = alloca (q1 - q + 1);
   memcpy (tmp, q, q1 - q);
   tmp[q1 - q] = '\0';
   opname = cplus_mangle_opname (tmp, DMGL_ANSI);
   if (opname == NULL)
   {
   cplusplus_error (saved_arg, "no mangling for \"%s\"\n", tmp);
   }
   copy = (char*) alloca (3 + strlen(opname));
   sprintf (copy, "__%s", opname);
   p = q1;
   }
   else
 */
	  {
	    copy = (char *) alloca (p - *argptr + 1);
	    memcpy (copy, *argptr, p - *argptr);
	    copy[p - *argptr] = '\0';
	    if (p != *argptr
		&& copy[p - *argptr - 1]
		&& strchr (get_gdb_completer_quote_characters (),
			   copy[p - *argptr - 1]) != NULL)
	      copy[p - *argptr - 1] = '\0';
	  }
d1275 8
d1285 3
a1287 1
	}
d1289 1
d1291 1
d1293 5
d1308 8
d1323 12
a1334 1
	break;		/* Out of the while (1).  */
d1336 1
a1336 2
      p2 = p;		/* Save restart for next time around.  */
      *argptr = saved_arg2;	/* Restore argptr.  */
d1349 1
d1368 3
a1370 1
   whitespace.  */
d1386 1
a1386 1
  /* Discard the class name from the arg.  */
d1391 3
@


1.53
log
@
2003-12-17  Jeff Johnston  <jjohnstn@@redhat.com>

        * linespec.h (decode_line_1): Add new not_found_ptr parameter.
        * linespec.c (decode_line_1): Add new parameter.  Pass on
        new parameter to decode_variable and symtab_from_filename
        functions.
        (decode_variable): Add new not_found_ptr parameter.  Throw exception
        rather than failing if the not_found_ptr is non-null and the
        function is not found.
        (symtab_from_filename): Add new not_found_ptr parametr.   Throw
        exception rather than failing if the not_found_ptr is non-null and
        the source file is not found.
        * breakpoint.c: Change all callers of decode_line_1 to add default
        extra parameter for decode_line_1 calls.
        * tracepoint.c: Ditto.
        * cli/cli-cmds.c: Ditto.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d1472 8
a1479 1
	  throw_exception (RETURN_ERROR);
d1694 8
a1701 1
      throw_exception (RETURN_ERROR);
@


1.52
log
@2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* targets.c: Replace "struct sec" with "struct bfd_section"
	* syms.c, sparclynx.c, section.c, opncls.c: Ditto.
	* libcoff-in.h, libbfd-in.h, elfxx-target.h: Ditto.
	* elf.c, coffgen.c, bfd.c, bfd-in.h, aoutf1.h: Ditto.
	* aout-tic30.c, aout-target.h:
	* bfd-in2.h, libcoff.h, libbfd.h: Regenerate.

Index: binutils/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* coffgrok.h (coff_section): Replace 'struct sec" with "struct
	bfd_section".

Index: gdb/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* symtab.c: Replace "struct sec" with "struct bfd_section".
	* objfiles.c, linespec.c, blockframe.c, block.c: Ditto.

Index: ld/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* pe-dll.c: Replace "struct sec" with "struct bfd_section".

Index: sim/common/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* sim-base.h: Replace "struct sec" with "struct bfd_section".
@
text
@d103 2
a104 1
					    char *p, int is_quote_enclosed);
d123 2
a124 1
						 struct symtab *file_symtab);
d642 6
a647 1
   Also, the line number returned may be invalid.  */
d656 1
a656 1
	       int default_line, char ***canonical)
d675 3
d735 2
a736 1
      file_symtab = symtab_from_filename (argptr, p, is_quote_enclosed);
d841 2
a842 1
  return decode_variable (copy, funfirstline, canonical, file_symtab);
d1437 4
a1440 1
   of *ARGPTR ending at P, and advance ARGPTR past that filename.  */
d1443 2
a1444 1
symtab_from_filename (char **argptr, char *p, int is_quote_enclosed)
d1469 5
d1650 3
a1652 1
   look in that symtab's static variables first.  */
d1656 1
a1656 1
		 struct symtab *file_symtab)
d1684 6
@


1.51
log
@* linespec.c (is_objc_method_format): New function
(decode_line_1, locate_first_half): Use it.
Fixes PR objc/1298
@
text
@d1739 1
a1739 1
				      (struct sec *) 0, 0);
@


1.50
log
@2003-07-23  Michal Ludvig  <mludvig@@suse.cz>
	    Elena Zannoni  <ezannoni@@redhat.com>

 	* linespec.c (decode_line_2): Avoid crash if
 	find_function_start_sal() returns empty record.
@
text
@d97 2
d448 19
d693 1
a693 2
  if (*p && (p[0] == ':') && (strchr ("+-", p[1]) != NULL) 
      && (p[2] == '['))
d995 1
a995 2
      if (*p && (p[0] == ':') && (strchr ("+-", p[1]) != NULL) 
	  && (p[2] == '['))
@


1.49
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* acinclude.m4 (gcc_AC_CHECK_DECL, (gcc_AC_CHECK_DECL): Stolen
	from GCC's acinclude.m4.
	* configure.in: Check for getopt's delcaration.
	* aclocal.m4, config.in, configure: Re-generate.
	* main.c (error_init): Delete declaration.
	* defs.h (error_init): Declare.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Make static.
	(rs6000_convert_from_func_ptr_addr): Make static.
	(_initialize_rs6000_tdep): Add declaration.
	* cli/cli-cmds.c (dont_repeat): Delete declaration.
	(show_commands, set_verbose, show_history): Delete declaration.
	* top.h (set_verbose): Add declaration.
	(show_history, set_history, show_commands): Add declaration.
	(do_restore_instream_cleanup): Add declaration.
	* objc-lang.c (specialcmp): Make static.
	(print_object_command): Make static.
	(find_objc_msgsend): Make static.
	(find_objc_msgcall_submethod_helper): Make static.
	(find_objc_msgcall_submethod): Make static.
	(_initialize_objc_language): Add declaration.
	(find_implementation_from_class): Make static.
	(find_implementation): Make static.
	* objc-exp.y (yylex): Delete lookup_struct_typedef declaration.
	* objc-lang.h (lookup_struct_typedef): Add declaration.
	* cli/cli-interp.c (_initialize_cli_interp): Add declaration.
	* cli/cli-script.c (clear_hook_in_cleanup): Make static.
	(do_restore_user_call_depth): Make static.
	(do_restore_instream_cleanup): Delete declaration.
	(dont_repeat): Delete declaration.
	* cli/cli-decode.c (add_abbrev_cmd): Delete function.
	* cli/cli-dump.c (_initialize_cli_dump): Add declaration.
	* reggroups.c (_initialize_reggroup): Add declaration.
	* cp-support.c (_initialize_cp_support): Add declaration.
	* cp-abi.c (_initialize_cp_abi): Add declaration.
	* hpacc-abi.c (_initialize_hpacc_abi): Add declaration.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Make static.
	(_initialize_gnu_v3_abi): Add declaration.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Make static.
	(_initialize_gnu_v2_abi): Add declaration.
	* frame-base.c (_initialize_frame_base): Add declaration.
	* doublest.c (floatformat_from_length): Make static.
	* frame-unwind.c (_initialize_frame_unwind): Add declaration.
	* frame.c (create_sentinel_frame): Make static.
	(_initialize_frame): Add declaration.
	* top.c (do_catch_errors): Make static.
	(gdb_rl_operate_and_get_next_completion): Make static.
	* typeprint.c: Include "typeprint.h".
	* sentinel-frame.c (sentinel_frame_prev_register): Make static.
	(sentinel_frame_this_id): Make static.
	* p-valprint.c (_initialize_pascal_valprint): Add declaration.
	* ui-out.c (make_cleanup_ui_out_begin_end): Delete function.
	* dwarf2-frame.c (dwarf2_frame_cache): Make static.
	* p-exp.y (push_current_type, pop_current_type): ISO C declaration.
	* dwarf2expr.h (dwarf_expr_context): ISO C declaration.
	* maint.c (maintenance_print_architecture): Make static.
	* signals/signals.c (_initialize_signals): Add declaration.
	* std-regs.c (_initialize_frame_reg): Add declaration.
	* jv-exp.y (push_variable): ISO C definition.
	(push_qualified_expression_name): Ditto.
	* memattr.c (_initialize_mem): Add declaration.
	* remote.c (remote_check_watch_resources): Make static.
	(remote_stopped_by_watchpoint): Make static.
	(remote_stopped_data_address): Make static.
	* d10v-tdep.c (nr_dmap_regs): Make static.
	(a0_regnum): Make static.
	(d10v_frame_unwind_cache): Make static.
	(d10v_frame_p): Make static.
	* osabi.c (show_osabi): Make static.
	(_initialize_gdb_osabi): Add extern declaration.
	* gdbtypes.c (make_qualified_type): Make static.
	(safe_parse_type): Make static.
	* macrocmd.c (_initialize_macrocmd): Add extern declaration.
	* macrotab.c (macro_bcache_free): Make static.
	* interps.c (interp_set_quiet): Make static.
	(interpreter_exec_cmd): Make static.
	* stack.h (select_frame_command): New file.
	* stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete function.
	(select_frame_command): Make global.
	* infcall.c: Include "infcall.h".
	* linespec.c: Include "linespec.h".
	* symfile.c (sections_overlap): Make static.
	* cp-support.h (cp_initialize_namespace): ISO C declaration.
	* charset.c (_initialize_charset): Add missing prototype.
	* regcache.c (init_legacy_regcache_descr): Make static.
	(do_regcache_xfree): Make static.
	(regcache_xfer_part): Make static.
	(_initialize_regcache): Add missing prototype.
	* breakpoint.c (parse_breakpoint_sals): Make static.
	(breakpoint_sals_to_pc): Make static.
	* interps.h (clear_interpreter_hooks): ISO C declaration.
	* Makefile.in (stack_h): Define.
	(stack.o, typeprint.o, mi-main.o): Update dependencies.
	(mi-cmd-stack.o, infcall.o, linespec.o): Update dependencies.

Index: mi/ChangeLog
2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-parse.c (_initialize_mi_parse): Delete function.
	* mi-main.c: Include "mi-main.h".
	* mi-interp.c (_initialize_mi_interp): Add declaration.
	* mi-cmd-stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete extern declaration.
	(mi_cmd_stack_select_frame): Replace select_frame_command_wrapper
	with select_frame_command.
@
text
@d486 12
a497 5
	  printf_unfiltered ("[%d] %s at %s:%d\n",
			     (i + 2),
			     SYMBOL_PRINT_NAME (sym_arr[i]),
			     values.sals[i].symtab->filename,
			     values.sals[i].line);
@


1.49.4.1
log
@2003-07-23  Michal Ludvig  <mludvig@@suse.cz>
	    Elena Zannoni  <ezannoni@@redhat.com>

 	* linespec.c (decode_line_2): Avoid crash if
 	find_function_start_sal() returns empty record.
@
text
@d486 5
a490 12
	  if (values.sals[i].symtab)
	    printf_unfiltered ("[%d] %s at %s:%d\n",
			       (i + 2),
			       SYMBOL_PRINT_NAME (sym_arr[i]),
			       values.sals[i].symtab->filename,
			       values.sals[i].line);
	  else
	    printf_unfiltered ("[%d] %s at ?FILE:%d [No symtab? Probably broken debug info...]\n",
			       (i + 2),
			       SYMBOL_PRINT_NAME (sym_arr[i]),
			       values.sals[i].line);

@


1.49.4.2
log
@* linespec.c (is_objc_method_format): New function
(decode_line_1, locate_first_half): Use it.
@
text
@a96 2
static int is_objc_method_format (const char *s);

a445 19
/* Determines if the gives string corresponds to an Objective-C method
   representation, such as -[Foo bar:] or +[Foo bar]. Objective-C symbols
   are allowed to have spaces and parentheses in them.  */

static int 
is_objc_method_format (const char *s)
{
  if (s == NULL || *s == '\0')
    return 0;
  /* Handle arguments with the format FILENAME:SYMBOL.  */
  if ((s[0] == ':') && (strchr ("+-", s[1]) != NULL) 
      && (s[2] == '[') && strchr(s, ']'))
    return 1;
  /* Handle arguments that are just SYMBOL.  */
  else if ((strchr ("+-", s[0]) != NULL) && (s[1] == '[') && strchr(s, ']'))
    return 1;
  return 0;
}

d672 2
a673 1
  if (is_objc_method_format (p))
d975 2
a976 1
      if (is_objc_method_format (p))
@


1.48
log
@2003-06-02  David Carlton  <carlton@@bactrian.org>

	* linespec.c (find_methods): Break out code into
	add_matching_methods and add_constructors.
	(add_matching_methods): New.
	(add_constructors): Ditto.
@
text
@d37 1
@


1.47
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@d85 6
a218 1
	  int field_counter;
d234 2
a235 46
	    for (field_counter = TYPE_FN_FIELDLIST_LENGTH (t, method_counter) - 1;
		 field_counter >= 0;
		 --field_counter)
	      {
		struct fn_field *f;
		char *phys_name;

		f = TYPE_FN_FIELDLIST1 (t, method_counter);

		if (TYPE_FN_FIELD_STUB (f, field_counter))
		  {
		    char *tmp_name;

		    tmp_name = gdb_mangle_name (t,
						method_counter,
						field_counter);
		    phys_name = alloca (strlen (tmp_name) + 1);
		    strcpy (phys_name, tmp_name);
		    xfree (tmp_name);
		  }
		else
		  phys_name = TYPE_FN_FIELD_PHYSNAME (f, field_counter);
		
		/* Destructor is handled by caller, don't add it to
		   the list.  */
		if (is_destructor_name (phys_name) != 0)
		  continue;

		sym_arr[i1] = lookup_symbol (phys_name,
					     NULL, VAR_DOMAIN,
					     (int *) NULL,
					     (struct symtab **) NULL);
		if (sym_arr[i1])
		  i1++;
		else
		  {
		    /* This error message gets printed, but the method
		       still seems to be found
		       fputs_filtered("(Cannot find method ", gdb_stdout);
		       fprintf_symbol_filtered (gdb_stdout, phys_name,
		       language_cplus,
		       DMGL_PARAMS | DMGL_ANSI);
		       fputs_filtered(" - possibly inlined.)\n", gdb_stdout);
		     */
		  }
	      }
d239 2
a240 33
	    {
	      /* For GCC 3.x and stabs, constructors and destructors
		 have names like __base_ctor and __complete_dtor.
		 Check the physname for now if we're looking for a
		 constructor.  */
	      for (field_counter
		     = TYPE_FN_FIELDLIST_LENGTH (t, method_counter) - 1;
		   field_counter >= 0;
		   --field_counter)
		{
		  struct fn_field *f;
		  char *phys_name;
		  
		  f = TYPE_FN_FIELDLIST1 (t, method_counter);

		  /* GCC 3.x will never produce stabs stub methods, so
		     we don't need to handle this case.  */
		  if (TYPE_FN_FIELD_STUB (f, field_counter))
		    continue;
		  phys_name = TYPE_FN_FIELD_PHYSNAME (f, field_counter);
		  if (! is_constructor_name (phys_name))
		    continue;

		  /* If this method is actually defined, include it in the
		     list.  */
		  sym_arr[i1] = lookup_symbol (phys_name,
					       NULL, VAR_DOMAIN,
					       (int *) NULL,
					       (struct symtab **) NULL);
		  if (sym_arr[i1])
		    i1++;
		}
	    }
d258 107
@


1.46
log
@* linespec.c (decode_objc): New function to decode ObjC calls
(decode_line_1): Check for ObjC calls (using decode_objc)
* Makefile (linespec.o): Update dependencies.
@
text
@d197 1
a197 1
			 STRUCT_NAMESPACE, (int *) NULL,
d258 1
a258 1
					     NULL, VAR_NAMESPACE,
d304 1
a304 1
					       NULL, VAR_NAMESPACE,
d685 1
a685 1
      sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0, &sym_symtab);
d1217 1
a1217 1
  sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0, &sym_symtab);
d1256 1
a1256 1
  return lookup_symbol (copy, 0, STRUCT_NAMESPACE, 0,
d1346 1
a1346 1
			   NULL, VAR_NAMESPACE, (int *) NULL,
d1524 1
a1524 1
      sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0, &sym_symtab);
d1582 1
a1582 1
		       VAR_NAMESPACE, 0, &sym_symtab);
d1634 1
a1634 1
	  if (lookup_block_symbol (b, copy, NULL, VAR_NAMESPACE) != NULL)
@


1.46.4.1
log
@Snap const char * mess.
@
text
@d47 1
a47 1
static void set_flags (const char *arg, int *is_quoted, char **paren_pointer);
d49 1
a49 1
static struct symtabs_and_lines decode_indirect (const char **argptr);
d51 1
a51 2
static const char *locate_first_half (const char **argptr,
				      int *is_quote_enclosed);
d53 1
a53 1
static struct symtabs_and_lines decode_objc (const char **argptr,
d57 1
a57 1
					     const char *saved_arg);
d59 1
a59 1
static struct symtabs_and_lines decode_compound (const char **argptr,
d62 2
a63 2
						 const char *saved_arg,
						 const char *p);
d65 1
a65 1
static struct symbol *lookup_prefix_sym (const char **argptr, const char *p);
d69 1
a69 1
					     const char *saved_arg,
d88 1
a88 1
static const char *find_toplevel_char (const char *s, char c);
d93 2
a94 3
static struct symtab *symtab_from_filename (const char **argptr,
					    const char *p,
					    int is_quote_enclosed);
d97 1
a97 1
symtabs_and_lines decode_all_digits (const char **argptr,
d102 1
a102 1
				     const char *q);
d377 2
a378 2
static const char *
find_toplevel_char (const char *s, char c)
d384 1
a384 1
  const char *scan;
d582 1
a582 2
decode_line_1 (const char **argptr, int funfirstline,
	       struct symtab *default_symtab,
d585 2
a586 2
  const char *p;
  const char *q;
d600 1
a600 1
  const char *saved_arg = *argptr;
d814 1
a814 1
set_flags (const char *arg, int *is_quoted, char **paren_pointer)
d856 1
a856 1
decode_indirect (const char **argptr)
d882 2
a883 2
static const char *
locate_first_half (const char **argptr, int *is_quote_enclosed)
d885 2
a886 3
  const char *ii;
  const char *p;
  const char *p1;
d923 1
a923 1
	  const char *temp_end = find_template_name_end (p);
d986 2
a987 2
decode_objc (const char **argptr, int funfirstline, struct symtab *file_symtab,
	     char ***canonical, const char *saved_arg)
d992 1
a992 1
  const char *copy = NULL;
d1071 2
a1072 2
decode_compound (const char **argptr, int funfirstline, char ***canonical,
		 const char *saved_arg, const char *p)
d1075 1
a1075 1
  const char *p2;
d1079 2
a1080 2
  const char *saved_arg2 = *argptr;
  const char *temp_end;
d1237 1
a1237 1
lookup_prefix_sym (const char **argptr, const char *p)
d1239 1
a1239 1
  const char *p1;
d1264 1
a1264 1
find_method (int funfirstline, char ***canonical, const char *saved_arg,
d1364 1
a1364 2
symtab_from_filename (const char **argptr, const char *p,
		      int is_quote_enclosed)
d1366 1
a1366 1
  const char *p1;
d1408 1
a1408 1
decode_all_digits (const char **argptr, struct symtab *default_symtab,
d1410 1
a1410 1
		   struct symtab *file_symtab, const char *q)
@


1.45
log
@2003-03-03  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (find_method): Extract code into collect_methods.
	(collect_methods): New.
@
text
@d36 1
d53 6
d599 1
d625 19
d725 5
d928 7
d977 89
@


1.45.16.1
log
@Merge from mainline.
@
text
@a35 1
#include "objc-lang.h"
a51 6
static struct symtabs_and_lines decode_objc (char **argptr,
					     int funfirstline,
					     struct symtab *file_symtab,
					     char ***canonical,
					     char *saved_arg);

a591 1
  int is_objc_method = 0;
a616 19
  /* Check if this is an Objective-C method (anything that starts with
     a '+' or '-' and a '[').  */
  if (*p && (p[0] == ':') && (strchr ("+-", p[1]) != NULL) 
      && (p[2] == '['))
    {
      is_objc_method = 1;
      paren_pointer  = NULL; /* Just a category name.  Ignore it.  */
    }

  /* Check if the symbol could be an Objective-C selector.  */

  {
    struct symtabs_and_lines values;
    values = decode_objc (argptr, funfirstline, NULL,
			  canonical, saved_arg);
    if (values.sals != NULL)
      return values;
  }

a697 5
  else if (is_objc_method)
    {
      /* allow word separators in method names for Obj-C */
      p = skip_quoted_chars (*argptr, NULL, "");
    }
a895 7
      /* Check for a colon and a plus or minus and a [ (which
         indicates an Objective-C method) */
      if (*p && (p[0] == ':') && (strchr ("+-", p[1]) != NULL) 
	  && (p[2] == '['))
	{
	  break;
	}
a937 89

/* Here's where we recognise an Objective-C Selector.  An Objective C
   selector may be implemented by more than one class, therefore it
   may represent more than one method/function.  This gives us a
   situation somewhat analogous to C++ overloading.  If there's more
   than one method that could represent the selector, then use some of
   the existing C++ code to let the user choose one.  */

struct symtabs_and_lines
decode_objc (char **argptr, int funfirstline, struct symtab *file_symtab,
	     char ***canonical, char *saved_arg)
{
  struct symtabs_and_lines values;
  struct symbol **sym_arr = NULL;
  struct symbol *sym = NULL;
  char *copy = NULL;
  struct block *block = NULL;
  int i1 = 0;
  int i2 = 0;

  values.sals = NULL;
  values.nelts = 0;

  if (file_symtab != NULL)
    block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (file_symtab), STATIC_BLOCK);
  else
    block = get_selected_block (0);
    
  copy = find_imps (file_symtab, block, *argptr, NULL, &i1, &i2); 
    
  if (i1 > 0)
    {
      sym_arr = (struct symbol **) alloca ((i1 + 1) * sizeof (struct symbol *));
      sym_arr[i1] = 0;

      copy = find_imps (file_symtab, block, *argptr, sym_arr, &i1, &i2); 
      *argptr = copy;
    }

  /* i1 now represents the TOTAL number of matches found.
     i2 represents how many HIGH-LEVEL (struct symbol) matches,
     which will come first in the sym_arr array.  Any low-level
     (minimal_symbol) matches will follow those.  */
      
  if (i1 == 1)
    {
      if (i2 > 0)
	{
	  /* Already a struct symbol.  */
	  sym = sym_arr[0];
	}
      else
	{
	  sym = find_pc_function (SYMBOL_VALUE_ADDRESS (sym_arr[0]));
	  if ((sym != NULL) && strcmp (SYMBOL_LINKAGE_NAME (sym_arr[0]), SYMBOL_LINKAGE_NAME (sym)) != 0)
	    {
	      warning ("debugging symbol \"%s\" does not match selector; ignoring", SYMBOL_LINKAGE_NAME (sym));
	      sym = NULL;
	    }
	}
	      
      values.sals = (struct symtab_and_line *) xmalloc (sizeof (struct symtab_and_line));
      values.nelts = 1;
	      
      if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)
	{
	  /* Canonicalize this, so it remains resolved for dylib loads.  */
	  values.sals[0] = find_function_start_sal (sym, funfirstline);
	  build_canonical_line_spec (values.sals, SYMBOL_NATURAL_NAME (sym), canonical);
	}
      else
	{
	  /* The only match was a non-debuggable symbol.  */
	  values.sals[0].symtab = 0;
	  values.sals[0].line = 0;
	  values.sals[0].end = 0;
	  values.sals[0].pc = SYMBOL_VALUE_ADDRESS (sym_arr[0]);
	}
      return values;
    }

  if (i1 > 1)
    {
      /* More than one match. The user must choose one or more.  */
      return decode_line_2 (sym_arr, i2, funfirstline, canonical);
    }

  return values;
}
@


1.45.16.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d197 1
a197 1
			 STRUCT_DOMAIN, (int *) NULL,
d258 1
a258 1
					     NULL, VAR_DOMAIN,
d304 1
a304 1
					       NULL, VAR_DOMAIN,
d685 1
a685 1
      sym = lookup_symbol (copy, 0, VAR_DOMAIN, 0, &sym_symtab);
d1217 1
a1217 1
  sym = lookup_symbol (copy, 0, VAR_DOMAIN, 0, &sym_symtab);
d1256 1
a1256 1
  return lookup_symbol (copy, 0, STRUCT_DOMAIN, 0,
d1346 1
a1346 1
			   NULL, VAR_DOMAIN, (int *) NULL,
d1524 1
a1524 1
      sym = lookup_symbol (copy, 0, VAR_DOMAIN, 0, &sym_symtab);
d1582 1
a1582 1
		       VAR_DOMAIN, 0, &sym_symtab);
d1634 1
a1634 1
	  if (lookup_block_symbol (b, copy, NULL, VAR_DOMAIN) != NULL)
@


1.44
log
@2003-02-28  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (decode_compound): Extract code into find_method.
	(find_method): New.
@
text
@d67 3
d1141 1
a1141 1
  int i1 = 0;	/*  Counter for the symbol array.  */
d1145 2
a1146 4
  if (destructor_name_p (copy, t))
    {
      /* Destructors are a special case.  */
      int m_index, f_index;
d1148 1
a1148 3
      if (get_destructor_fn_field (t, &m_index, &f_index))
	{
	  struct fn_field *f = TYPE_FN_FIELDLIST1 (t, m_index);
a1149 10
	  sym_arr[i1] =
	    lookup_symbol (TYPE_FN_FIELD_PHYSNAME (f, f_index),
			   NULL, VAR_NAMESPACE, (int *) NULL,
			   (struct symtab **) NULL);
	  if (sym_arr[i1])
	    i1++;
	}
    }
  else
    i1 = find_methods (t, copy, sym_arr);
d1196 32
@


1.43
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d60 7
a954 1
  int i1;
d1046 2
a1047 70
	  sym = 0;
	  i1 = 0;	/*  Counter for the symbol array.  */
	  sym_arr = (struct symbol **) alloca (total_number_of_methods (t)
					       * sizeof (struct symbol *));

	  if (destructor_name_p (copy, t))
	    {
	      /* Destructors are a special case.  */
	      int m_index, f_index;

	      if (get_destructor_fn_field (t, &m_index, &f_index))
		{
		  struct fn_field *f = TYPE_FN_FIELDLIST1 (t, m_index);

		  sym_arr[i1] =
		    lookup_symbol (TYPE_FN_FIELD_PHYSNAME (f, f_index),
				   NULL, VAR_NAMESPACE, (int *) NULL,
				   (struct symtab **) NULL);
		  if (sym_arr[i1])
		    i1++;
		}
	    }
	  else
	    i1 = find_methods (t, copy, sym_arr);
	  if (i1 == 1)
	    {
	      /* There is exactly one field with that name.  */
	      sym = sym_arr[0];

	      if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)
		{
		  values.sals = (struct symtab_and_line *)
		    xmalloc (sizeof (struct symtab_and_line));
		  values.nelts = 1;
		  values.sals[0] = find_function_start_sal (sym,
							    funfirstline);
		}
	      else
		{
		  values.nelts = 0;
		}
	      return values;
	    }
	  if (i1 > 0)
	    {
	      /* There is more than one field with that name
		 (overloaded).  Ask the user which one to use.  */
	      return decode_line_2 (sym_arr, i1, funfirstline, canonical);
	    }
	  else
	    {
	      char *tmp;

	      if (is_operator_name (copy))
		{
		  tmp = (char *) alloca (strlen (copy + 3) + 9);
		  strcpy (tmp, "operator ");
		  strcat (tmp, copy + 3);
		}
	      else
		tmp = copy;
	      if (tmp[0] == '~')
		cplusplus_error (saved_arg,
				 "the class `%s' does not have destructor defined\n",
				 SYMBOL_PRINT_NAME (sym_class));
	      else
		cplusplus_error (saved_arg,
				 "the class %s does not have any method named %s\n",
				 SYMBOL_PRINT_NAME (sym_class), tmp);
	    }
d1127 80
@


1.42
log
@2003-02-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME;
	expand comment.
	* ada-lang.c (user_select_syms, ada_finish_decode_line_1): Replace
	SYMBOL_PRINT_NAME with SYMBOL_SOURCE_NAME.
	* ada-typeprint.c (ada_typedef_print): Ditto.
	* ax-gdb.c (gen_var_ref): Ditto.
	* breakpoint.c (print_one_breakpoint): Ditto.
	* buildsym.c (finish_block): Ditto.
	* c-valprint.c (c_val_print): Ditto.
	* expprint.c (print_subexp): Ditto.
	* findvar.c (locate_var_value): Ditto.
	* infcmd.c (jump_command): Ditto.
	* linespec.c (decode_line_2, decode_compound): Ditto.
	* maint.c (maintenance_translate_address): Ditto.
	* objc-lang.c (compare_selectors, compare_classes): Ditto.
	* printcmd.c (build_address_symbolic, sym_info, print_frame_args):
	Ditto.
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* stack.c (print_frame, frame_info, print_block_frame_locals)
	(print_frame_arg_vars, return_command): Ditto.
	* symfile.c (compare_symbols, compare_psymbols): Ditto.
	* symmisc.c (print_symbol): Ditto.
	* symtab.c (lookup_partial_symbol, lookup_block_symbol)
	(compare_search_syms, print_symbol_info, print_msymbol_info)
	(rbreak_command): Ditto.
	* tracepoint.c (tracepoints_info): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* valops.c (value_of_variable, hand_function_call): Ditto.
	* cli/cli-cmds.c (edit_command, list_command): Ditto.
	* ada-typeprint.c: Update Copyright.
	* infcmd.c, objc-lang.c, p-valprint.c, symmisc.c: Ditto.
	* tracepoint.c, cli/cli-cmds.c: Ditto.
@
text
@d475 1
a475 1
		      symname = SYMBOL_NAME (sym_arr[i]);
d498 1
a498 1
		  symname = SYMBOL_NAME (sym_arr[num]);
@


1.41
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d433 1
a433 1
			     SYMBOL_SOURCE_NAME (sym_arr[i]),
d1104 1
a1104 1
				 SYMBOL_SOURCE_NAME (sym_class));
d1108 1
a1108 1
				 SYMBOL_SOURCE_NAME (sym_class), tmp);
@


1.40
log
@2003-02-06  Andrew Cagney  <ac131313@@redhat.com>

	* linux-proc.c: Include "gdb_stat.h" instead of <sys/stat.h>.
	* cp-valprint.c (cp_print_value_fields): Eliminate STREQN.
	* jv-typeprint.c (java_type_print_base): Ditto.
	* typeprint.c (typedef_print): Eliminate STREQ.
	* cli/cli-script.c (define_command, define_command): Ditto.
	* main.c (captured_main): Ditto.
	* values.c (lookup_internalvar): Ditto.
	* utils.c (safe_strerror, parse_escape): Eliminate assignment
	within `if' conditional.
	* linespec.c (decode_line_2): Ditto.
	* cli/cli-dump.c (bfd_openr_with_cleanup): Ditto.
	(bfd_openw_with_cleanup): Ditto.

Index: mi/ChangeLog
2003-02-06  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Include "gdb_stat.h" instead of <sys/stat.h>.
@
text
@d35 1
@


1.39
log
@2003-02-04  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (decode_compound): Extract code into
	lookup_prefix_sym.
	(lookup_prefix_sym): New function.
@
text
@d441 2
a442 1
  if ((prompt = getenv ("PS2")) == NULL)
@


1.38
log
@2003-01-14  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (decode_line_1): Normalize comments.
	(set_flags): Ditto.
	(locate_first_half): Ditto.
	(decode_compound): Ditto.
	(symtab_from_filename): Ditto.
	(decode_all_digits): Ditto.
	(decode_dollar): Ditto.
	(find_methods): Ditto.
	(find_toplevel_char): Ditto.
@
text
@d57 2
d935 1
a935 1
  char *p1, *p2;
d980 1
a980 16
      /* Extract the class name.  */
      p1 = p;
      while (p != *argptr && p[-1] == ' ')
	--p;
      copy = (char *) alloca (p - *argptr + 1);
      memcpy (copy, *argptr, p - *argptr);
      copy[p - *argptr] = 0;

      /* Discard the class name from the arg.  */
      p = p1 + (p1[0] == ':' ? 2 : 1);
      while (*p == ' ' || *p == '\t')
	p++;
      *argptr = p;

      sym_class = lookup_symbol (copy, 0, STRUCT_NAMESPACE, 0,
				 (struct symtab **) NULL);
d1156 31
@


1.37
log
@2003-01-12  David Carlton  <carlton@@bactrian.org>

	* linespec.c (symtab_from_filename): Rename variable 's' to
	'file_symtab'.
@
text
@d232 2
a233 1
		/* Destructor is handled by caller, dont add it to the list */
d259 4
a262 3
	      /* For GCC 3.x and stabs, constructors and destructors have names
		 like __base_ctor and __complete_dtor.  Check the physname for now
		 if we're looking for a constructor.  */
d273 2
a274 2
		  /* GCC 3.x will never produce stabs stub methods, so we don't need
		     to handle this case.  */
d363 1
a363 1
  int depth = 0;		/* number of unclosed parens we've seen */
d423 1
a423 1
      init_sal (&return_values.sals[i]);	/* initialize to zeroes */
d584 1
a584 1
  /* See if arg is *PC */
d589 4
a592 5
  /* Set various flags.
   * 'paren_pointer' is important for overload checking, where
   * we allow things like: 
   *     (gdb) break c::f(int)
   */
d659 1
a659 1
  /* Check whether arg is all digits (and sign) */
d675 3
a677 2
  if (**argptr == '$')		/* May be a convenience variable */
    p = skip_quoted (*argptr + (((*argptr)[1] == '$') ? 2 : 1));	/* One or two $ chars possible */
d710 1
a710 1
     be history value, or it may be a convenience variable */
d774 2
a775 2
   *     (gdb) break foo if (a==b)
   */
d783 3
a785 4
  /* Temporarily zap out "if (condition)" to not
   * confuse the parenthesis-checking code below.
   * This is undone below. Do not change ii!!
   */
d799 2
a800 3
  /* Now that we're safely past the paren_pointer check,
   * put back " if (condition)" so outer layers can see it 
   */
d853 2
a854 4
  /* Temporarily zap out second half to not
   * confuse the code below.
   * This is undone below. Do not change ii!!
   */
d860 3
a862 3
  /* Maybe arg is FILE : LINENUM or FILE : FUNCTION */
  /* May also be CLASS::MEMBER, or NAMESPACE::NAME */
  /* Look for ':', but ignore inside of <> */
d882 4
a885 3
      /* Check for the end of the first half of the linespec.  End of line,
         a tab, a double colon or the last single colon, or a space.  But
         if enclosed in double quotes we do not break on enclosed spaces */
d892 1
a892 1
      if (p[0] == '.' && strchr (p, ':') == NULL)	/* Java qualified method. */
d894 2
a895 1
	  /* Find the *last* '.', since the others are package qualifiers. */
d907 1
a907 1
  /* if the closing double quote was left at the end, remove it */
d915 2
a916 3
  /* Now that we've safely parsed the first half,
   * put back ',' so outer layers can see it 
   */
d949 2
a950 2
     of the form "::foo". If found, skip over the colons
     and jump to normal symbol processing */
d973 1
a973 1
     "B::C" separately as a symbol in the previous example. */
d975 1
a975 1
  p2 = p;		/* save for restart */
d1000 3
a1002 2
	  /* Arg token is not digits => try it as a function name
	     Find the next token(everything up to end or next blank). */
d1046 1
a1046 1
	  /* no line number may be specified */
d1052 1
a1052 1
	  i1 = 0;	/*  counter for the symbol array */
d1123 3
a1125 3
      /* Move pointer up to next possible class/namespace token */
      p = p2 + 1;	/* restart with old value +1 */
      /* Move pointer ahead to next double-colon */
d1136 1
a1136 1
	    break;	/* found double-colon */
d1142 1
a1142 1
	break;		/* out of the while (1) */
d1144 2
a1145 2
      p2 = p;		/* save restart for next time around */
      *argptr = saved_arg2;	/* restore argptr */
d1148 3
a1150 3
  /* Last chance attempt -- check entire name as a symbol */
  /* Use "copy" in preparation for jumping out of this block,
     to be consistent with usage following the jump target */
d1153 2
a1154 1
  /* Note: if is_quoted should be true, we snuff out quote here anyway */
d1156 1
a1156 1
  /* Set argptr to skip over the name */
d1164 2
a1165 2
  /* Couldn't find any interpretation as classes/namespaces, so give up */
  /* The quotes are important if copy is empty.  */
d1190 1
a1190 1
  /* It may have the ending quote right after the file name */
d1244 1
a1244 1
     select_source_symtab that calls us with such an argument  */
d1248 1
a1248 1
      /* Make sure we have at least a default source file. */
d1323 1
a1323 1
  if (!*p)			/* reached end of token without hitting non-digit */
d1325 1
a1325 1
      /* We have a value history reference */
d1334 1
a1334 1
	 convenience variable */
d1336 1
a1336 1
      /* Look up entire name as a symbol first */
d1345 1
a1345 1
      /* If symbol was not found, look in minimal symbol tables */
d1347 1
a1347 1
      /* Min symbol was found --> jump to minsym processing. */
d1351 1
a1351 1
      /* Not a user variable or function -- must be convenience variable */
d1360 1
a1360 1
  /* Either history value or convenience value from above, in valx */
@


1.36
log
@2003-01-10  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (decode_line_1): Rename variable 's' to
	'file_symtab'.
	(decode_all_digits): Rename argument 's' to 'file_symtab'.
	(decode_dollar): Ditto.
	(decode_variable): Ditto.
	(symbol_found): Ditto.
@
text
@d1180 1
a1180 1
  struct symtab *s;
d1196 2
a1197 2
  s = lookup_symtab (copy);
  if (s == 0)
d1210 1
a1210 1
  return s;
@


1.35
log
@2003-01-09  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c: Update copyright.
@
text
@d81 1
a81 1
				     struct symtab *s,
d88 1
a88 1
					       struct symtab *s);
d93 1
a93 1
						 struct symtab *s);
d100 1
a100 1
				struct symtab *s,
d564 2
a565 1
  struct symtab *s = NULL;
d618 1
a618 1
      s = symtab_from_filename (argptr, p, is_quote_enclosed);
d669 1
a669 1
			      canonical, s, q);
d712 1
a712 1
			  canonical, s);
d717 1
a717 1
  return decode_variable (copy, funfirstline, canonical, s);
d1222 1
a1222 1
		   struct symtab *s, char *q)
d1235 1
a1235 1
  int need_canonical = (s == 0) ? 1 : 0;
d1245 1
a1245 1
  if (s == 0 && default_symtab == 0)
d1262 1
a1262 1
      if (s == 0)
d1268 1
a1268 1
      if (s == 0)
d1280 2
a1281 2
  if (s == 0)
    s = default_symtab;
d1285 2
a1286 2
     default (in s) to a new one.  */
  val.symtab = find_line_symtab (s, val.line, NULL, NULL);
d1288 1
a1288 1
    val.symtab = s;
d1306 1
a1306 1
	       char ***canonical, struct symtab *s)
d1337 1
a1337 1
      s = (struct symtab *) 0;
d1351 1
a1351 1
      need_canonical = (s == 0) ? 1 : 0;
d1360 1
a1360 1
  val.symtab = s ? s : default_symtab;
d1376 1
a1376 1
/* Decode a linespec that's a variable.  If S is non-NULL,
d1381 1
a1381 1
		 struct symtab *s)
d1390 3
a1392 1
		       (s ? BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK)
d1397 2
a1398 1
    return symbol_found (funfirstline, canonical, copy, sym, s, sym_symtab);
d1423 1
a1423 1
	      struct symbol *sym, struct symtab *s,
d1442 1
a1442 1
      if (s == 0)
@


1.34
log
@2003-01-08  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (decode_line_1): Move code into decode_variable.
	(decode_variable): New function.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001
@


1.33
log
@2003-01-07  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (decode_line_1): Move code into decode_dollar.
	(decode_dollar): New function.
@
text
@d90 5
a565 5
  struct symbol *sym;
  /* The symtab that SYM was found in.  */
  struct symtab *sym_symtab;

  struct minimal_symbol *msymbol;
d716 1
a716 18
  sym = lookup_symbol (copy,
		       (s ? BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK)
			: get_selected_block (0)),
		       VAR_NAMESPACE, 0, &sym_symtab);

  if (sym != NULL)
    return symbol_found (funfirstline, canonical, copy, sym, s, sym_symtab);

  msymbol = lookup_minimal_symbol (copy, NULL, NULL);

  if (msymbol != NULL)
    return minsym_found (funfirstline, msymbol);

  if (!have_full_symbols () &&
      !have_partial_symbols () && !have_minimal_symbols ())
    error ("No symbol table is loaded.  Use the \"file\" command.");

  error ("Function \"%s\" not defined.", copy);
d1372 36
@


1.32
log
@2002-12-19  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (decode_line_1): Move code into decode_all_digits.
	(decode_all_digits): New function.
@
text
@d84 6
a556 2
  struct symtabs_and_lines values;
  struct symtab_and_line val;
a576 2
  init_sal (&val);		/* initialize to zeroes */

d710 2
a711 58
    {
      struct value *valx;
      int index = 0;
      int need_canonical = 0;

      p = (copy[1] == '$') ? copy + 2 : copy + 1;
      while (*p >= '0' && *p <= '9')
	p++;
      if (!*p)			/* reached end of token without hitting non-digit */
	{
	  /* We have a value history reference */
	  sscanf ((copy[1] == '$') ? copy + 2 : copy + 1, "%d", &index);
	  valx = access_value_history ((copy[1] == '$') ? -index : index);
	  if (TYPE_CODE (VALUE_TYPE (valx)) != TYPE_CODE_INT)
	    error ("History values used in line specs must have integer values.");
	}
      else
	{
	  /* Not all digits -- may be user variable/function or a
	     convenience variable */

	  /* Look up entire name as a symbol first */
	  sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0, &sym_symtab);
	  s = (struct symtab *) 0;
	  need_canonical = 1;
	  /* Symbol was found --> jump to normal symbol processing.  */
	  if (sym)
	    return symbol_found (funfirstline, canonical, copy, sym,
				 NULL, sym_symtab);

	  /* If symbol was not found, look in minimal symbol tables */
	  msymbol = lookup_minimal_symbol (copy, NULL, NULL);
	  /* Min symbol was found --> jump to minsym processing. */
	  if (msymbol)
	    return minsym_found (funfirstline, msymbol);

	  /* Not a user variable or function -- must be convenience variable */
	  need_canonical = (s == 0) ? 1 : 0;
	  valx = value_of_internalvar (lookup_internalvar (copy + 1));
	  if (TYPE_CODE (VALUE_TYPE (valx)) != TYPE_CODE_INT)
	    error ("Convenience variables used in line specs must have integer values.");
	}

      /* Either history value or convenience value from above, in valx */
      val.symtab = s ? s : default_symtab;
      val.line = value_as_long (valx);
      val.pc = 0;

      values.sals = (struct symtab_and_line *) xmalloc (sizeof val);
      values.sals[0] = val;
      values.nelts = 1;

      if (need_canonical)
	build_canonical_line_spec (values.sals, NULL, canonical);

      return values;
    }

a733 1
  return values;		/* for lint */
d1313 74
@


1.31
log
@2002-12-09  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (symtab_from_filename): New function.
	(decode_line_1): Move code into symtab_from_filename.
@
text
@d77 8
d664 3
a666 71
    {
      /* We found a token consisting of all digits -- at least one digit.  */
      enum sign
	{
	  none, plus, minus
	}
      sign = none;

      /* We might need a canonical line spec if no file was specified.  */
      int need_canonical = (s == 0) ? 1 : 0;

      /* This is where we need to make sure that we have good defaults.
         We must guarantee that this section of code is never executed
         when we are called with just a function name, since
	 set_default_source_symtab_and_line uses
         select_source_symtab that calls us with such an argument  */

      if (s == 0 && default_symtab == 0)
	{
	  /* Make sure we have at least a default source file. */
	  set_default_source_symtab_and_line ();
	  initialize_defaults (&default_symtab, &default_line);
	}

      if (**argptr == '+')
	sign = plus, (*argptr)++;
      else if (**argptr == '-')
	sign = minus, (*argptr)++;
      val.line = atoi (*argptr);
      switch (sign)
	{
	case plus:
	  if (q == *argptr)
	    val.line = 5;
	  if (s == 0)
	    val.line = default_line + val.line;
	  break;
	case minus:
	  if (q == *argptr)
	    val.line = 15;
	  if (s == 0)
	    val.line = default_line - val.line;
	  else
	    val.line = 1;
	  break;
	case none:
	  break;		/* No need to adjust val.line.  */
	}

      while (*q == ' ' || *q == '\t')
	q++;
      *argptr = q;
      if (s == 0)
	s = default_symtab;

      /* It is possible that this source file has more than one symtab, 
         and that the new line number specification has moved us from the
         default (in s) to a new one.  */
      val.symtab = find_line_symtab (s, val.line, NULL, NULL);
      if (val.symtab == 0)
	val.symtab = s;

      val.pc = 0;
      values.sals = (struct symtab_and_line *)
	xmalloc (sizeof (struct symtab_and_line));
      values.sals[0] = val;
      values.nelts = 1;
      if (need_canonical)
	build_canonical_line_spec (values.sals, NULL, canonical);
      return values;
    }
d1284 86
@


1.30
log
@2002-12-05  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (decode_compound): New function.
	(decode_line_1): Move code into decode_compound.
@
text
@d73 3
d545 1
a545 1
  register char *p, *p1;
d547 1
a547 1
  register struct symtab *s = NULL;
d549 1
a549 1
  register struct symbol *sym;
d553 1
a553 1
  register struct minimal_symbol *msymbol;
d597 3
a600 2
	/*  C++ */
	/*  ... or Java */
d604 2
a605 22
      /* Extract the file name.  */
      p1 = p;
      while (p != *argptr && p[-1] == ' ')
	--p;
      if ((*p == '"') && is_quote_enclosed)
	--p;
      copy = (char *) alloca (p - *argptr + 1);
      memcpy (copy, *argptr, p - *argptr);
      /* It may have the ending quote right after the file name */
      if (is_quote_enclosed && copy[p - *argptr - 1] == '"')
	copy[p - *argptr - 1] = 0;
      else
	copy[p - *argptr] = 0;

      /* Find that file's data.  */
      s = lookup_symtab (copy);
      if (s == 0)
	{
	  if (!have_full_symbols () && !have_partial_symbols ())
	    error ("No symbol table is loaded.  Use the \"file\" command.");
	  error ("No source file named %s.", copy);
	}
d607 1
a607 5
      /* Discard the file name from the arg.  */
      p = p1 + 1;
      while (*p == ' ' || *p == '\t')
	p++;
      *argptr = p;
d1300 44
@


1.29
log
@2002-11-12  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (locate_first_half): New function.
	(decode_line_1): Move code into locate_first_half.
@
text
@d51 9
a59 1
static void cplusplus_error (const char *name, const char *fmt, ...) ATTR_FORMAT (printf, 2, 3);
d91 1
a91 1
static void
d543 1
a543 4
  char *q, *p2;
#if 0
  char *q1;
#endif
a551 2
  struct symbol *sym_class;
  int i1;
a559 2
  struct symbol **sym_arr;
  struct type *t;
a560 1
  extern char *gdb_completer_quote_characters;
a591 2
      /*  C++ */
      /*  ... or Java */
d595 4
a598 226
	{
	  char *saved_arg2 = *argptr;
	  char *temp_end;
	  /* First check for "global" namespace specification,
	     of the form "::foo". If found, skip over the colons
	     and jump to normal symbol processing */
	  if (p[0] == ':' 
	      && ((*argptr == p) || (p[-1] == ' ') || (p[-1] == '\t')))
	    saved_arg2 += 2;

	  /* We have what looks like a class or namespace
	     scope specification (A::B), possibly with many
	     levels of namespaces or classes (A::B::C::D).

	     Some versions of the HP ANSI C++ compiler (as also possibly
	     other compilers) generate class/function/member names with
	     embedded double-colons if they are inside namespaces. To
	     handle this, we loop a few times, considering larger and
	     larger prefixes of the string as though they were single
	     symbols.  So, if the initially supplied string is
	     A::B::C::D::foo, we have to look up "A", then "A::B",
	     then "A::B::C", then "A::B::C::D", and finally
	     "A::B::C::D::foo" as single, monolithic symbols, because
	     A, B, C or D may be namespaces.

	     Note that namespaces can nest only inside other
	     namespaces, and not inside classes.  So we need only
	     consider *prefixes* of the string; there is no need to look up
	     "B::C" separately as a symbol in the previous example. */

	  p2 = p;		/* save for restart */
	  while (1)
	    {
	      /* Extract the class name.  */
	      p1 = p;
	      while (p != *argptr && p[-1] == ' ')
		--p;
	      copy = (char *) alloca (p - *argptr + 1);
	      memcpy (copy, *argptr, p - *argptr);
	      copy[p - *argptr] = 0;

	      /* Discard the class name from the arg.  */
	      p = p1 + (p1[0] == ':' ? 2 : 1);
	      while (*p == ' ' || *p == '\t')
		p++;
	      *argptr = p;

	      sym_class = lookup_symbol (copy, 0, STRUCT_NAMESPACE, 0,
					 (struct symtab **) NULL);

	      if (sym_class &&
		  (t = check_typedef (SYMBOL_TYPE (sym_class)),
		   (TYPE_CODE (t) == TYPE_CODE_STRUCT
		    || TYPE_CODE (t) == TYPE_CODE_UNION)))
		{
		  /* Arg token is not digits => try it as a function name
		     Find the next token(everything up to end or next blank). */
		  if (**argptr
		      && strchr (get_gdb_completer_quote_characters (),
				 **argptr) != NULL)
		    {
		      p = skip_quoted (*argptr);
		      *argptr = *argptr + 1;
		    }
		  else
		    {
		      p = *argptr;
		      while (*p && *p != ' ' && *p != '\t' && *p != ',' && *p != ':')
			p++;
		    }
/*
   q = operator_chars (*argptr, &q1);
   if (q1 - q)
   {
   char *opname;
   char *tmp = alloca (q1 - q + 1);
   memcpy (tmp, q, q1 - q);
   tmp[q1 - q] = '\0';
   opname = cplus_mangle_opname (tmp, DMGL_ANSI);
   if (opname == NULL)
   {
   cplusplus_error (saved_arg, "no mangling for \"%s\"\n", tmp);
   }
   copy = (char*) alloca (3 + strlen(opname));
   sprintf (copy, "__%s", opname);
   p = q1;
   }
   else
 */
		  {
		    copy = (char *) alloca (p - *argptr + 1);
		    memcpy (copy, *argptr, p - *argptr);
		    copy[p - *argptr] = '\0';
		    if (p != *argptr
			&& copy[p - *argptr - 1]
			&& strchr (get_gdb_completer_quote_characters (),
				   copy[p - *argptr - 1]) != NULL)
		      copy[p - *argptr - 1] = '\0';
		  }

		  /* no line number may be specified */
		  while (*p == ' ' || *p == '\t')
		    p++;
		  *argptr = p;

		  sym = 0;
		  i1 = 0;	/*  counter for the symbol array */
		  sym_arr = (struct symbol **) alloca (total_number_of_methods (t)
						* sizeof (struct symbol *));

		  if (destructor_name_p (copy, t))
		    {
		      /* Destructors are a special case.  */
		      int m_index, f_index;

		      if (get_destructor_fn_field (t, &m_index, &f_index))
			{
			  struct fn_field *f = TYPE_FN_FIELDLIST1 (t, m_index);

			  sym_arr[i1] =
			    lookup_symbol (TYPE_FN_FIELD_PHYSNAME (f, f_index),
					   NULL, VAR_NAMESPACE, (int *) NULL,
					   (struct symtab **) NULL);
			  if (sym_arr[i1])
			    i1++;
			}
		    }
		  else
		    i1 = find_methods (t, copy, sym_arr);
		  if (i1 == 1)
		    {
		      /* There is exactly one field with that name.  */
		      sym = sym_arr[0];

		      if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)
			{
			  values.sals = (struct symtab_and_line *)
			    xmalloc (sizeof (struct symtab_and_line));
			  values.nelts = 1;
			  values.sals[0] = find_function_start_sal (sym,
							      funfirstline);
			}
		      else
			{
			  values.nelts = 0;
			}
		      return values;
		    }
		  if (i1 > 0)
		    {
		      /* There is more than one field with that name
		         (overloaded).  Ask the user which one to use.  */
		      return decode_line_2 (sym_arr, i1, funfirstline, canonical);
		    }
		  else
		    {
		      char *tmp;

		      if (is_operator_name (copy))
			{
			  tmp = (char *) alloca (strlen (copy + 3) + 9);
			  strcpy (tmp, "operator ");
			  strcat (tmp, copy + 3);
			}
		      else
			tmp = copy;
		      if (tmp[0] == '~')
			cplusplus_error (saved_arg,
					 "the class `%s' does not have destructor defined\n",
					 SYMBOL_SOURCE_NAME (sym_class));
		      else
			cplusplus_error (saved_arg,
					 "the class %s does not have any method named %s\n",
					 SYMBOL_SOURCE_NAME (sym_class), tmp);
		    }
		}

	      /* Move pointer up to next possible class/namespace token */
	      p = p2 + 1;	/* restart with old value +1 */
	      /* Move pointer ahead to next double-colon */
	      while (*p && (p[0] != ' ') && (p[0] != '\t') && (p[0] != '\''))
		{
		  if (p[0] == '<')
		    {
		      temp_end = find_template_name_end (p);
		      if (!temp_end)
			error ("malformed template specification in command");
		      p = temp_end;
		    }
		  else if ((p[0] == ':') && (p[1] == ':'))
		    break;	/* found double-colon */
		  else
		    p++;
		}

	      if (*p != ':')
		break;		/* out of the while (1) */

	      p2 = p;		/* save restart for next time around */
	      *argptr = saved_arg2;	/* restore argptr */
	    }			/* while (1) */

	  /* Last chance attempt -- check entire name as a symbol */
	  /* Use "copy" in preparation for jumping out of this block,
	     to be consistent with usage following the jump target */
	  copy = (char *) alloca (p - saved_arg2 + 1);
	  memcpy (copy, saved_arg2, p - saved_arg2);
	  /* Note: if is_quoted should be true, we snuff out quote here anyway */
	  copy[p - saved_arg2] = '\000';
	  /* Set argptr to skip over the name */
	  *argptr = (*p == '\'') ? p + 1 : p;
	  /* Look up entire name */
	  sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0, &sym_symtab);
	  s = (struct symtab *) 0;
	  if (sym)
	    return symbol_found (funfirstline, canonical, copy, sym,
				 NULL, sym_symtab);

	  /* Couldn't find any interpretation as classes/namespaces, so give up */
	  /* The quotes are important if copy is empty.  */
	  cplusplus_error (saved_arg,
			   "Can't find member of namespace, class, struct, or union named \"%s\"\n",
			   copy);
	}
      /*  end of C++  */

d873 2
a874 1
/* Now, still more helper functions.  */
d876 20
a895 5
/* NOTE: carlton/2002-11-07: Some of these have non-obvious side
   effects.  In particular, if a function is passed ARGPTR as an
   argument, it modifies what ARGPTR points to.  (Typically, it
   advances *ARGPTR past whatever substring it has just looked
   at.)  */
d1073 246
@


1.28
log
@2002-11-11  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (set_flags): New function.
	(decode_line_1): Move code into set_flags.
@
text
@d49 2
d535 1
a535 1
  char *q, *ii, *p2;
d539 1
a539 1
  register struct symtab *s;
d555 1
a556 1
  int has_comma = 0;
d581 2
a582 3
  /* Maybe we were called with a line range FILENAME:LINENUM,FILENAME:LINENUM
     and we must isolate the first half.  Outer layers will call again later
     for the second half.
d584 1
a584 5
     Don't count commas that appear in argument lists of overloaded
     functions, or in quoted strings.  It's stupid to go to this much
     trouble when the rest of the function is such an obvious roach hotel.  */
  ii = find_toplevel_char (*argptr, ',');
  has_comma = (ii != 0);
d586 1
a586 8
  /* Temporarily zap out second half to not
   * confuse the code below.
   * This is undone below. Do not change ii!!
   */
  if (has_comma)
    {
      *ii = '\0';
    }
d588 1
a588 59
  /* Maybe arg is FILE : LINENUM or FILE : FUNCTION */
  /* May also be CLASS::MEMBER, or NAMESPACE::NAME */
  /* Look for ':', but ignore inside of <> */

  s = NULL;
  p = *argptr;
  if (p[0] == '"')
    {
      is_quote_enclosed = 1;
      (*argptr)++;
      p++;
    }
  else
    is_quote_enclosed = 0;
  for (; *p; p++)
    {
      if (p[0] == '<')
	{
	  char *temp_end = find_template_name_end (p);
	  if (!temp_end)
	    error ("malformed template specification in command");
	  p = temp_end;
	}
      /* Check for the end of the first half of the linespec.  End of line,
         a tab, a double colon or the last single colon, or a space.  But
         if enclosed in double quotes we do not break on enclosed spaces */
      if (!*p
	  || p[0] == '\t'
	  || ((p[0] == ':')
	      && ((p[1] == ':') || (strchr (p + 1, ':') == NULL)))
	  || ((p[0] == ' ') && !is_quote_enclosed))
	break;
      if (p[0] == '.' && strchr (p, ':') == NULL)	/* Java qualified method. */
	{
	  /* Find the *last* '.', since the others are package qualifiers. */
	  for (p1 = p; *p1; p1++)
	    {
	      if (*p1 == '.')
		p = p1;
	    }
	  break;
	}
    }
  while (p[0] == ' ' || p[0] == '\t')
    p++;

  /* if the closing double quote was left at the end, remove it */
  if (is_quote_enclosed)
    {
      char *closing_quote = strchr (p - 1, '"');
      if (closing_quote && closing_quote[1] == '\0')
	*closing_quote = '\0';
    }

  /* Now that we've safely parsed the first half,
   * put back ',' so outer layers can see it 
   */
  if (has_comma)
    *ii = ',';
d1186 95
@


1.27
log
@2002-11-11  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (decode_line_1): Move chunks of code to separate
	functions.
	(initialize_defaults): New function.
	(decode_indirect): New function.
@
text
@d45 2
d533 1
a533 1
  char *q, *pp, *ii, *p2;
d547 5
a553 2
  int has_parens;
  int has_if = 0;
a570 19
  /* 'has_if' is for the syntax:
   *     (gdb) break foo if (a==b)
   */
  if ((ii = strstr (*argptr, " if ")) != NULL ||
      (ii = strstr (*argptr, "\tif ")) != NULL ||
      (ii = strstr (*argptr, " if\t")) != NULL ||
      (ii = strstr (*argptr, "\tif\t")) != NULL ||
      (ii = strstr (*argptr, " if(")) != NULL ||
      (ii = strstr (*argptr, "\tif( ")) != NULL)
    has_if = 1;
  /* Temporarily zap out "if (condition)" to not
   * confuse the parenthesis-checking code below.
   * This is undone below. Do not change ii!!
   */
  if (has_if)
    {
      *ii = '\0';
    }

d572 1
a572 1
   * 'has_parens' is important for overload checking, where
d577 1
a577 14
  /* Maybe arg is FILE : LINENUM or FILE : FUNCTION */

  is_quoted = (**argptr
	       && strchr (get_gdb_completer_quote_characters (),
			  **argptr) != NULL);

  has_parens = ((pp = strchr (*argptr, '(')) != NULL
		&& (pp = strrchr (pp, ')')) != NULL);

  /* Now that we're safely past the has_parens check,
   * put back " if (condition)" so outer layers can see it 
   */
  if (has_if)
    *ii = ' ';
d658 1
a658 1
  if ((p[0] == ':' || p[0] == '.') && !has_parens)
d1051 1
a1051 1
  else if (has_parens)
d1053 1
a1053 1
      p = pp + 1;
d1190 40
@


1.26
log
@2002-11-08  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (symbol_found): New function.
	(minsym_found): New function.
	(decode_line_1): Separate out some code into separate functions.
@
text
@d42 5
a540 1
  register CORE_ADDR pc;
d559 2
a560 12
  if (default_symtab == 0)
    {
      /* Use whatever we have for the default source line.  We don't use
         get_current_or_default_symtab_and_line as it can recurse and call
	 us back! */
      struct symtab_and_line cursal = 
      			get_current_source_symtab_and_line ();
      
      default_symtab = cursal.symtab;
      default_line = cursal.line;
    }

d564 1
a564 14
    {
      (*argptr)++;
      pc = parse_and_eval_address_1 (argptr);

      values.sals = (struct symtab_and_line *)
	xmalloc (sizeof (struct symtab_and_line));

      values.nelts = 1;
      values.sals[0] = find_pc_line (pc, 0);
      values.sals[0].pc = pc;
      values.sals[0].section = find_pc_overlay (pc);

      return values;
    }
a1013 2
          struct symtab_and_line cursal;

d1016 1
a1016 4
          cursal = get_current_source_symtab_and_line ();
      
          default_symtab = cursal.symtab;
          default_line = cursal.line;
d1190 52
@


1.25
log
@2002-10-24  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (INIT_SAL): Delete macro.
	(init_sal): Export.
	* symtab.c (init_sal): New function.

	* ada-lang.c (ada_finish_decode_line_1): Change INIT_SAL macro
	to init_sal function call.
	(find_sal_from_funcs_and_line): Ditto.
	(all_sals_for_line): Ditto.
	* breakpoint.c (create_internal_breakpoint): Ditto.
	(create_fork_vfork_event_catchpoint): Ditto.
	(create_exec_event_catchpoint): Ditto.
	(parse_breakpoint_sals): Ditto.
	(watch_command_1): Ditto.
	(handle_gnu_4_16_catch_command): Ditto.
	(clear_command): Ditto.
	* hppa-tdep.c (child_enable_exception_callback): Ditto.
	* infcmd.c (run_stack_dummy): Ditto.
	* infrun.c (process_event_stop_test): Ditto.
	(check_sigtramp2): Ditto.
	(step_over_function): Ditto.
	* linespec.c (decode_line_2): Ditto.
	(decode_line_1): Ditto.
	* source.c (line_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
@
text
@d56 12
a924 8
	  /* Prepare to jump: restore the " if (condition)" so outer layers see it */
	  /* Symbol was found --> jump to normal symbol processing.
	     Code following "symbol_found" expects "copy" to have the
	     symbol name, "sym" to have the symbol pointer, "s" to be
	     a specified file's symtab, and sym_symtab to be the symbol's
	     symtab. */
	  /* By jumping there we avoid falling through the FILE:LINE and
	     FILE:FUNC processing stuff below */
d926 2
a927 1
	    goto symbol_found;
a992 3
	  /* Yes, we have a symbol; jump to symbol processing */
	  /* Code after symbol_found expects S, SYM_SYMTAB, SYM, 
	     and COPY to be set correctly */
d994 2
a995 2
	  s = (struct symtab *) 0;
	  goto symbol_found;
d1156 1
a1156 5
	  /* Symbol was found --> jump to normal symbol processing.
	     Code following "symbol_found" expects "copy" to have the
	     symbol name, "sym" to have the symbol pointer, "s" to be
	     a specified file's symtab, and sym_symtab to be the symbol's
	     symtab. */
d1158 2
a1159 1
	    goto symbol_found;
d1165 1
a1165 1
	    goto minimal_symbol_found;
d1198 24
a1221 2
symbol_found:			/* We also jump here from inside the C++ class/namespace 
				   code on finding a symbol of the form "A::B::C" */
d1223 31
a1253 1
  if (sym != NULL)
d1255 3
a1257 1
      if (SYMBOL_CLASS (sym) == LOC_BLOCK)
d1259 1
a1259 1
	  /* Arg is the name of a function */
a1261 1
	  values.sals[0] = find_function_start_sal (sym, funfirstline);
d1263 3
a1265 14

	  /* Don't use the SYMBOL_LINE; if used at all it points to
	     the line containing the parameters or thereabouts, not
	     the first line of code.  */

	  /* We might need a canonical line spec if it is a static
	     function.  */
	  if (s == 0)
	    {
	      struct blockvector *bv = BLOCKVECTOR (sym_symtab);
	      struct block *b = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	      if (lookup_block_symbol (b, copy, NULL, VAR_NAMESPACE) != NULL)
		build_canonical_line_spec (values.sals, copy, canonical);
	    }
d1269 6
a1274 22
	{
	  if (funfirstline)
	    error ("\"%s\" is not a function", copy);
	  else if (SYMBOL_LINE (sym) != 0)
	    {
	      /* We know its line number.  */
	      values.sals = (struct symtab_and_line *)
		xmalloc (sizeof (struct symtab_and_line));
	      values.nelts = 1;
	      memset (&values.sals[0], 0, sizeof (values.sals[0]));
	      values.sals[0].symtab = sym_symtab;
	      values.sals[0].line = SYMBOL_LINE (sym);
	      return values;
	    }
	  else
	    /* This can happen if it is compiled with a compiler which doesn't
	       put out line numbers for variables.  */
	    /* FIXME: Shouldn't we just set .line and .symtab to zero
	       and return?  For example, "info line foo" could print
	       the address.  */
	    error ("Line number not known for symbol \"%s\"", copy);
	}
d1276 1
d1278 2
a1279 1
  msymbol = lookup_minimal_symbol (copy, NULL, NULL);
d1281 4
a1284 2
minimal_symbol_found:		/* We also jump here from the case for variables
				   that begin with '$' */
d1286 6
a1291 1
  if (msymbol != NULL)
d1293 2
a1294 12
      values.sals = (struct symtab_and_line *)
	xmalloc (sizeof (struct symtab_and_line));
      values.sals[0] = find_pc_sect_line (SYMBOL_VALUE_ADDRESS (msymbol),
					  (struct sec *) 0, 0);
      values.sals[0].section = SYMBOL_BFD_SECTION (msymbol);
      if (funfirstline)
	{
	  values.sals[0].pc += FUNCTION_START_OFFSET;
	  values.sals[0].pc = SKIP_PROLOGUE (values.sals[0].pc);
	}
      values.nelts = 1;
      return values;
d1296 2
a1297 7

  if (!have_full_symbols () &&
      !have_partial_symbols () && !have_minimal_symbols ())
    error ("No symbol table is loaded.  Use the \"file\" command.");

  error ("Function \"%s\" not defined.", copy);
  return values;		/* for lint */
@


1.24
log
@2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c: #include "parser-defs.h".
	Delete prototype for find_template_name_end.
	* Makefile.in (linespec.o): Depend on $(parser_defs_h).
@
text
@d370 2
a371 2
      INIT_SAL (&return_values.sals[i]);	/* initialize to zeroes */
      INIT_SAL (&values.sals[i]);
d539 1
a539 1
  INIT_SAL (&val);		/* initialize to zeroes */
@


1.23
log
@	* source.c (get_current_or_default_source_symtab_and_line): Remove
	function.
	(set_default_source_symtab_and_line): New function. Attempts to
	determine a source file to list lines from if one is not currently
	defined.
	(get_current_source_symtab_and_line): Initialize sal.pc and
        sal.end fields.
	(set_current_source_symtab_and_line): Mark argument as const.
	* source.h: Update declarations and comments.
	* linespec.c (decode_line_1): Replace call to removed routine above.
	* stack.c (print_frame_info_base): Ditto.
	* cli/cli-cmds.c (edit_command): Ditto.
	(list_command): Ditto.
@
text
@d34 1
a34 5

/* Prototype for one function in parser-defs.h,
   instead of including that entire file. */

extern char *find_template_name_end (char *);
@


1.23.2.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d34 5
a38 1
#include "parser-defs.h"
d374 2
a375 2
      init_sal (&return_values.sals[i]);	/* initialize to zeroes */
      init_sal (&values.sals[i]);
d543 1
a543 1
  init_sal (&val);		/* initialize to zeroes */
@


1.23.2.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
a34 3
#include "block.h"
#include "objc-lang.h"
#include "linespec.h"
d42 1
a42 36
static void initialize_defaults (struct symtab **default_symtab,
				 int *default_line);

static void set_flags (char *arg, int *is_quoted, char **paren_pointer);

static struct symtabs_and_lines decode_indirect (char **argptr);

static char *locate_first_half (char **argptr, int *is_quote_enclosed);

static struct symtabs_and_lines decode_objc (char **argptr,
					     int funfirstline,
					     struct symtab *file_symtab,
					     char ***canonical,
					     char *saved_arg);

static struct symtabs_and_lines decode_compound (char **argptr,
						 int funfirstline,
						 char ***canonical,
						 char *saved_arg,
						 char *p);

static struct symbol *lookup_prefix_sym (char **argptr, char *p);

static struct symtabs_and_lines find_method (int funfirstline,
					     char ***canonical,
					     char *saved_arg,
					     char *copy,
					     struct type *t,
					     struct symbol *sym_class);

static int collect_methods (char *copy, struct type *t,
			    struct symbol **sym_arr);

static NORETURN void cplusplus_error (const char *name,
				      const char *fmt, ...)
     ATTR_NORETURN ATTR_FORMAT (printf, 2, 3);
a47 6
static int add_matching_methods (int method_counter, struct type *t,
				 struct symbol **sym_arr);

static int add_constructors (int method_counter, struct type *t,
			     struct symbol **sym_arr);

a52 2
static int is_objc_method_format (const char *s);

a55 34
static struct symtab *symtab_from_filename (char **argptr,
					    char *p, int is_quote_enclosed);

static struct
symtabs_and_lines decode_all_digits (char **argptr,
				     struct symtab *default_symtab,
				     int default_line,
				     char ***canonical,
				     struct symtab *file_symtab,
				     char *q);

static struct symtabs_and_lines decode_dollar (char *copy,
					       int funfirstline,
					       struct symtab *default_symtab,
					       char ***canonical,
					       struct symtab *file_symtab);

static struct symtabs_and_lines decode_variable (char *copy,
						 int funfirstline,
						 char ***canonical,
						 struct symtab *file_symtab);

static struct
symtabs_and_lines symbol_found (int funfirstline,
				char ***canonical,
				char *copy,
				struct symbol *sym,
				struct symtab *file_symtab,
				struct symtab *sym_symtab);

static struct
symtabs_and_lines minsym_found (int funfirstline,
				struct minimal_symbol *msymbol);

d62 1
a62 1
static NORETURN void
d126 1
a126 1
			 STRUCT_DOMAIN, (int *) NULL,
d142 1
d158 45
a202 2
	    i1 += add_matching_methods (method_counter, t,
					sym_arr + i1);
d206 32
a237 2
	    i1 += add_constructors (method_counter, t,
				    sym_arr + i1);
a258 107
/* Add the symbols associated to methods of the class whose type is T
   and whose name matches the method indexed by METHOD_COUNTER in the
   array SYM_ARR.  Return the number of methods added.  */

static int
add_matching_methods (int method_counter, struct type *t,
		      struct symbol **sym_arr)
{
  int field_counter;
  int i1 = 0;

  for (field_counter = TYPE_FN_FIELDLIST_LENGTH (t, method_counter) - 1;
       field_counter >= 0;
       --field_counter)
    {
      struct fn_field *f;
      char *phys_name;

      f = TYPE_FN_FIELDLIST1 (t, method_counter);

      if (TYPE_FN_FIELD_STUB (f, field_counter))
	{
	  char *tmp_name;

	  tmp_name = gdb_mangle_name (t,
				      method_counter,
				      field_counter);
	  phys_name = alloca (strlen (tmp_name) + 1);
	  strcpy (phys_name, tmp_name);
	  xfree (tmp_name);
	}
      else
	phys_name = TYPE_FN_FIELD_PHYSNAME (f, field_counter);
		
      /* Destructor is handled by caller, don't add it to
	 the list.  */
      if (is_destructor_name (phys_name) != 0)
	continue;

      sym_arr[i1] = lookup_symbol (phys_name,
				   NULL, VAR_DOMAIN,
				   (int *) NULL,
				   (struct symtab **) NULL);
      if (sym_arr[i1])
	i1++;
      else
	{
	  /* This error message gets printed, but the method
	     still seems to be found
	     fputs_filtered("(Cannot find method ", gdb_stdout);
	     fprintf_symbol_filtered (gdb_stdout, phys_name,
	     language_cplus,
	     DMGL_PARAMS | DMGL_ANSI);
	     fputs_filtered(" - possibly inlined.)\n", gdb_stdout);
	  */
	}
    }

  return i1;
}

/* Add the symbols associated to constructors of the class whose type
   is CLASS_TYPE and which are indexed by by METHOD_COUNTER to the
   array SYM_ARR.  Return the number of methods added.  */

static int
add_constructors (int method_counter, struct type *t,
		  struct symbol **sym_arr)
{
  int field_counter;
  int i1 = 0;

  /* For GCC 3.x and stabs, constructors and destructors
     have names like __base_ctor and __complete_dtor.
     Check the physname for now if we're looking for a
     constructor.  */
  for (field_counter
	 = TYPE_FN_FIELDLIST_LENGTH (t, method_counter) - 1;
       field_counter >= 0;
       --field_counter)
    {
      struct fn_field *f;
      char *phys_name;
		  
      f = TYPE_FN_FIELDLIST1 (t, method_counter);

      /* GCC 3.x will never produce stabs stub methods, so
	 we don't need to handle this case.  */
      if (TYPE_FN_FIELD_STUB (f, field_counter))
	continue;
      phys_name = TYPE_FN_FIELD_PHYSNAME (f, field_counter);
      if (! is_constructor_name (phys_name))
	continue;

      /* If this method is actually defined, include it in the
	 list.  */
      sym_arr[i1] = lookup_symbol (phys_name,
				   NULL, VAR_DOMAIN,
				   (int *) NULL,
				   (struct symtab **) NULL);
      if (sym_arr[i1])
	i1++;
    }

  return i1;
}

d310 1
a310 1
  int depth = 0;		/* Number of unclosed parens we've seen.  */
a334 19
/* Determines if the gives string corresponds to an Objective-C method
   representation, such as -[Foo bar:] or +[Foo bar]. Objective-C symbols
   are allowed to have spaces and parentheses in them.  */

static int 
is_objc_method_format (const char *s)
{
  if (s == NULL || *s == '\0')
    return 0;
  /* Handle arguments with the format FILENAME:SYMBOL.  */
  if ((s[0] == ':') && (strchr ("+-", s[1]) != NULL) 
      && (s[2] == '[') && strchr(s, ']'))
    return 1;
  /* Handle arguments that are just SYMBOL.  */
  else if ((strchr ("+-", s[0]) != NULL) && (s[1] == '[') && strchr(s, ']'))
    return 1;
  return 0;
}

d370 1
a370 1
      init_sal (&return_values.sals[i]);	/* Initialize to zeroes.  */
d375 5
a379 12
	  if (values.sals[i].symtab)
	    printf_unfiltered ("[%d] %s at %s:%d\n",
			       (i + 2),
			       SYMBOL_PRINT_NAME (sym_arr[i]),
			       values.sals[i].symtab->filename,
			       values.sals[i].line);
	  else
	    printf_unfiltered ("[%d] %s at ?FILE:%d [No symtab? Probably broken debug info...]\n",
			       (i + 2),
			       SYMBOL_PRINT_NAME (sym_arr[i]),
			       values.sals[i].line);

d386 1
a386 2
  prompt = getenv ("PS2");
  if (prompt == NULL)
d418 1
a418 1
		      symname = DEPRECATED_SYMBOL_NAME (sym_arr[i]);
d441 1
a441 1
		  symname = DEPRECATED_SYMBOL_NAME (sym_arr[num]);
d511 12
a522 4
  char *p;
  char *q;
  /* If a file name is specified, this is its symtab.  */
  struct symtab *file_symtab = NULL;
d524 2
d527 2
a528 5
  /* This is NULL if there are no parens in *ARGPTR, or a pointer to
     the closing parenthesis if there are parens.  */
  char *paren_pointer;
  /* This says whether or not something in *ARGPTR is quoted with
     completer_quotes (i.e. with single quotes).  */
a529 1
  /* Is part of *ARGPTR is enclosed in double quotes?  */
d531 5
a535 1
  int is_objc_method = 0;
d537 3
d543 13
a555 3
  initialize_defaults (&default_symtab, &default_line);
  
  /* See if arg is *PC.  */
d558 6
a563 1
    return decode_indirect (argptr);
d565 7
a571 4
  /* Set various flags.  'paren_pointer' is important for overload
     checking, where we allow things like:
        (gdb) break c::f(int)
  */
d573 18
a590 1
  set_flags (*argptr, &is_quoted, &paren_pointer);
d592 20
a611 2
  /* Check to see if it's a multipart linespec (with colons or
     periods).  */
d613 3
a615 1
  /* Locate the end of the first half of the linespec.  */
d617 5
a621 1
  p = locate_first_half (argptr, &is_quote_enclosed);
d623 5
a627 3
  /* Check if this is an Objective-C method (anything that starts with
     a '+' or '-' and a '[').  */
  if (is_objc_method_format (p))
d629 1
a629 2
      is_objc_method = 1;
      paren_pointer  = NULL; /* Just a category name.  Ignore it.  */
d632 45
a676 1
  /* Check if the symbol could be an Objective-C selector.  */
d678 7
a684 7
  {
    struct symtabs_and_lines values;
    values = decode_objc (argptr, funfirstline, NULL,
			  canonical, saved_arg);
    if (values.sals != NULL)
      return values;
  }
d686 5
a690 1
  /* Does it look like there actually were two parts?  */
d692 1
a692 1
  if ((p[0] == ':' || p[0] == '.') && paren_pointer == NULL)
d694 2
d698 195
a892 2
      
      /* Is it a C++ or Java compound data structure?  */
d894 2
a895 3
      if (p[0] == '.' || p[1] == ':')
	return decode_compound (argptr, funfirstline, canonical,
				saved_arg, p);
d897 49
a945 2
      /* No, the first part is a filename; set s to be that file's
	 symtab.  Also, move argptr past the filename.  */
d947 14
a960 1
      file_symtab = symtab_from_filename (argptr, p, is_quote_enclosed);
d985 1
a985 1
      sym = lookup_symbol (copy, 0, VAR_DOMAIN, 0, &sym_symtab);
d988 3
d992 2
a993 2
	  return symbol_found (funfirstline, canonical, copy, sym,
			       NULL, sym_symtab);
d1003 1
a1003 1
  /* Check whether arg is all digits (and sign).  */
d1012 76
a1087 3
    /* We found a token consisting of all digits -- at least one digit.  */
    return decode_all_digits (argptr, default_symtab, default_line,
			      canonical, file_symtab, q);
d1092 2
a1093 3
  if (**argptr == '$')		/* May be a convenience variable.  */
    /* One or two $ chars possible.  */
    p = skip_quoted (*argptr + (((*argptr)[1] == '$') ? 2 : 1));
d1100 1
a1100 6
  else if (is_objc_method)
    {
      /* allow word separators in method names for Obj-C */
      p = skip_quoted_chars (*argptr, NULL, "");
    }
  else if (paren_pointer != NULL)
d1102 1
a1102 1
      p = paren_pointer + 1;
d1126 1
a1126 1
     be history value, or it may be a convenience variable.  */
d1129 20
a1148 2
    return decode_dollar (copy, funfirstline, default_symtab,
			  canonical, file_symtab);
d1150 29
a1178 2
  /* Look up that token as a variable.
     If file specified, use that file's per-file block to start with.  */
d1180 3
a1182 2
  return decode_variable (copy, funfirstline, canonical, file_symtab);
}
d1184 2
a1185 1

d1187 2
a1188 2
/* Now, more helper functions for decode_line_1.  Some conventions
   that these functions follow:
a1189 20
   Decode_line_1 typically passes along some of its arguments or local
   variables to the subfunctions.  It passes the variables by
   reference if they are modified by the subfunction, and by value
   otherwise.

   Some of the functions have side effects that don't arise from
   variables that are passed by reference.  In particular, if a
   function is passed ARGPTR as an argument, it modifies what ARGPTR
   points to; typically, it advances *ARGPTR past whatever substring
   it has just looked at.  (If it doesn't modify *ARGPTR, then the
   function gets passed *ARGPTR instead, which is then called ARG: see
   set_flags, for example.)  Also, functions that return a struct
   symtabs_and_lines may modify CANONICAL, as in the description of
   decode_line_1.

   If a function returns a struct symtabs_and_lines, then that struct
   will immediately make its way up the call chain to be returned by
   decode_line_1.  In particular, all of the functions decode_XXX
   calculate the appropriate struct symtabs_and_lines, under the
   assumption that their argument is of the form XXX.  */
d1191 2
a1192 2
/* First, some functions to initialize stuff at the beggining of the
   function.  */
d1194 4
a1197 15
static void
initialize_defaults (struct symtab **default_symtab, int *default_line)
{
  if (*default_symtab == 0)
    {
      /* Use whatever we have for the default source line.  We don't use
         get_current_or_default_symtab_and_line as it can recurse and call
	 us back! */
      struct symtab_and_line cursal = 
	get_current_source_symtab_and_line ();
      
      *default_symtab = cursal.symtab;
      *default_line = cursal.line;
    }
}
d1199 2
a1200 5
static void
set_flags (char *arg, int *is_quoted, char **paren_pointer)
{
  char *ii;
  int has_if = 0;
d1202 1
a1202 14
  /* 'has_if' is for the syntax:
        (gdb) break foo if (a==b)
  */
  if ((ii = strstr (arg, " if ")) != NULL ||
      (ii = strstr (arg, "\tif ")) != NULL ||
      (ii = strstr (arg, " if\t")) != NULL ||
      (ii = strstr (arg, "\tif\t")) != NULL ||
      (ii = strstr (arg, " if(")) != NULL ||
      (ii = strstr (arg, "\tif( ")) != NULL)
    has_if = 1;
  /* Temporarily zap out "if (condition)" to not confuse the
     parenthesis-checking code below.  This is undone below. Do not
     change ii!!  */
  if (has_if)
d1204 1
a1204 88
      *ii = '\0';
    }

  *is_quoted = (*arg
		&& strchr (get_gdb_completer_quote_characters (),
			   *arg) != NULL);

  *paren_pointer = strchr (arg, '(');
  if (*paren_pointer != NULL)
    *paren_pointer = strrchr (*paren_pointer, ')');

  /* Now that we're safely past the paren_pointer check, put back " if
     (condition)" so outer layers can see it.  */
  if (has_if)
    *ii = ' ';
}



/* Decode arg of the form *PC.  */

static struct symtabs_and_lines
decode_indirect (char **argptr)
{
  struct symtabs_and_lines values;
  CORE_ADDR pc;
  
  (*argptr)++;
  pc = parse_and_eval_address_1 (argptr);

  values.sals = (struct symtab_and_line *)
    xmalloc (sizeof (struct symtab_and_line));

  values.nelts = 1;
  values.sals[0] = find_pc_line (pc, 0);
  values.sals[0].pc = pc;
  values.sals[0].section = find_pc_overlay (pc);

  return values;
}



/* Locate the first half of the linespec, ending in a colon, period,
   or whitespace.  (More or less.)  Also, check to see if *ARGPTR is
   enclosed in double quotes; if so, set is_quote_enclosed, advance
   ARGPTR past that and zero out the trailing double quote.  */

static char *
locate_first_half (char **argptr, int *is_quote_enclosed)
{
  char *ii;
  char *p, *p1;
  int has_comma;

  /* Maybe we were called with a line range FILENAME:LINENUM,FILENAME:LINENUM
     and we must isolate the first half.  Outer layers will call again later
     for the second half.

     Don't count commas that appear in argument lists of overloaded
     functions, or in quoted strings.  It's stupid to go to this much
     trouble when the rest of the function is such an obvious roach hotel.  */
  ii = find_toplevel_char (*argptr, ',');
  has_comma = (ii != 0);

  /* Temporarily zap out second half to not confuse the code below.
     This is undone below. Do not change ii!!  */
  if (has_comma)
    {
      *ii = '\0';
    }

  /* Maybe arg is FILE : LINENUM or FILE : FUNCTION.  May also be
     CLASS::MEMBER, or NAMESPACE::NAME.  Look for ':', but ignore
     inside of <>.  */

  p = *argptr;
  if (p[0] == '"')
    {
      *is_quote_enclosed = 1;
      (*argptr)++;
      p++;
    }
  else
    *is_quote_enclosed = 0;
  for (; *p; p++)
    {
      if (p[0] == '<')
d1206 5
a1210 35
	  char *temp_end = find_template_name_end (p);
	  if (!temp_end)
	    error ("malformed template specification in command");
	  p = temp_end;
	}
      /* Check for a colon and a plus or minus and a [ (which
         indicates an Objective-C method) */
      if (is_objc_method_format (p))
	{
	  break;
	}
      /* Check for the end of the first half of the linespec.  End of
         line, a tab, a double colon or the last single colon, or a
         space.  But if enclosed in double quotes we do not break on
         enclosed spaces.  */
      if (!*p
	  || p[0] == '\t'
	  || ((p[0] == ':')
	      && ((p[1] == ':') || (strchr (p + 1, ':') == NULL)))
	  || ((p[0] == ' ') && !*is_quote_enclosed))
	break;
      if (p[0] == '.' && strchr (p, ':') == NULL)
	{
	  /* Java qualified method.  Find the *last* '.', since the
	     others are package qualifiers.  */
	  for (p1 = p; *p1; p1++)
	    {
	      if (*p1 == '.')
		p = p1;
	    }
	  break;
	}
    }
  while (p[0] == ' ' || p[0] == '\t')
    p++;
d1212 7
a1218 72
  /* If the closing double quote was left at the end, remove it.  */
  if (*is_quote_enclosed)
    {
      char *closing_quote = strchr (p - 1, '"');
      if (closing_quote && closing_quote[1] == '\0')
	*closing_quote = '\0';
    }

  /* Now that we've safely parsed the first half, put back ',' so
     outer layers can see it.  */
  if (has_comma)
    *ii = ',';

  return p;
}



/* Here's where we recognise an Objective-C Selector.  An Objective C
   selector may be implemented by more than one class, therefore it
   may represent more than one method/function.  This gives us a
   situation somewhat analogous to C++ overloading.  If there's more
   than one method that could represent the selector, then use some of
   the existing C++ code to let the user choose one.  */

struct symtabs_and_lines
decode_objc (char **argptr, int funfirstline, struct symtab *file_symtab,
	     char ***canonical, char *saved_arg)
{
  struct symtabs_and_lines values;
  struct symbol **sym_arr = NULL;
  struct symbol *sym = NULL;
  char *copy = NULL;
  struct block *block = NULL;
  int i1 = 0;
  int i2 = 0;

  values.sals = NULL;
  values.nelts = 0;

  if (file_symtab != NULL)
    block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (file_symtab), STATIC_BLOCK);
  else
    block = get_selected_block (0);
    
  copy = find_imps (file_symtab, block, *argptr, NULL, &i1, &i2); 
    
  if (i1 > 0)
    {
      sym_arr = (struct symbol **) alloca ((i1 + 1) * sizeof (struct symbol *));
      sym_arr[i1] = 0;

      copy = find_imps (file_symtab, block, *argptr, sym_arr, &i1, &i2); 
      *argptr = copy;
    }

  /* i1 now represents the TOTAL number of matches found.
     i2 represents how many HIGH-LEVEL (struct symbol) matches,
     which will come first in the sym_arr array.  Any low-level
     (minimal_symbol) matches will follow those.  */
      
  if (i1 == 1)
    {
      if (i2 > 0)
	{
	  /* Already a struct symbol.  */
	  sym = sym_arr[0];
	}
      else
	{
	  sym = find_pc_function (SYMBOL_VALUE_ADDRESS (sym_arr[0]));
	  if ((sym != NULL) && strcmp (SYMBOL_LINKAGE_NAME (sym_arr[0]), SYMBOL_LINKAGE_NAME (sym)) != 0)
d1220 4
a1223 2
	      warning ("debugging symbol \"%s\" does not match selector; ignoring", SYMBOL_LINKAGE_NAME (sym));
	      sym = NULL;
d1225 1
a1225 10
	}
	      
      values.sals = (struct symtab_and_line *) xmalloc (sizeof (struct symtab_and_line));
      values.nelts = 1;
	      
      if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)
	{
	  /* Canonicalize this, so it remains resolved for dylib loads.  */
	  values.sals[0] = find_function_start_sal (sym, funfirstline);
	  build_canonical_line_spec (values.sals, SYMBOL_NATURAL_NAME (sym), canonical);
d1229 3
a1231 138
	  /* The only match was a non-debuggable symbol.  */
	  values.sals[0].symtab = 0;
	  values.sals[0].line = 0;
	  values.sals[0].end = 0;
	  values.sals[0].pc = SYMBOL_VALUE_ADDRESS (sym_arr[0]);
	}
      return values;
    }

  if (i1 > 1)
    {
      /* More than one match. The user must choose one or more.  */
      return decode_line_2 (sym_arr, i2, funfirstline, canonical);
    }

  return values;
}

/* This handles C++ and Java compound data structures.  P should point
   at the first component separator, i.e. double-colon or period.  */

static struct symtabs_and_lines
decode_compound (char **argptr, int funfirstline, char ***canonical,
		 char *saved_arg, char *p)
{
  struct symtabs_and_lines values;
  char *p2;
#if 0
  char *q, *q1;
#endif
  char *saved_arg2 = *argptr;
  char *temp_end;
  struct symbol *sym;
  /* The symtab that SYM was found in.  */
  struct symtab *sym_symtab;
  char *copy;
  struct symbol *sym_class;
  struct symbol **sym_arr;
  struct type *t;

  /* First check for "global" namespace specification,
     of the form "::foo".  If found, skip over the colons
     and jump to normal symbol processing.  */
  if (p[0] == ':' 
      && ((*argptr == p) || (p[-1] == ' ') || (p[-1] == '\t')))
    saved_arg2 += 2;

  /* We have what looks like a class or namespace
     scope specification (A::B), possibly with many
     levels of namespaces or classes (A::B::C::D).

     Some versions of the HP ANSI C++ compiler (as also possibly
     other compilers) generate class/function/member names with
     embedded double-colons if they are inside namespaces. To
     handle this, we loop a few times, considering larger and
     larger prefixes of the string as though they were single
     symbols.  So, if the initially supplied string is
     A::B::C::D::foo, we have to look up "A", then "A::B",
     then "A::B::C", then "A::B::C::D", and finally
     "A::B::C::D::foo" as single, monolithic symbols, because
     A, B, C or D may be namespaces.

     Note that namespaces can nest only inside other
     namespaces, and not inside classes.  So we need only
     consider *prefixes* of the string; there is no need to look up
     "B::C" separately as a symbol in the previous example.  */

  p2 = p;		/* Save for restart.  */
  while (1)
    {
      sym_class = lookup_prefix_sym (argptr, p);

      if (sym_class &&
	  (t = check_typedef (SYMBOL_TYPE (sym_class)),
	   (TYPE_CODE (t) == TYPE_CODE_STRUCT
	    || TYPE_CODE (t) == TYPE_CODE_UNION)))
	{
	  /* Arg token is not digits => try it as a function name.
	     Find the next token (everything up to end or next
	     blank).  */
	  if (**argptr
	      && strchr (get_gdb_completer_quote_characters (),
			 **argptr) != NULL)
	    {
	      p = skip_quoted (*argptr);
	      *argptr = *argptr + 1;
	    }
	  else
	    {
	      p = *argptr;
	      while (*p && *p != ' ' && *p != '\t' && *p != ',' && *p != ':')
		p++;
	    }
/*
   q = operator_chars (*argptr, &q1);
   if (q1 - q)
   {
   char *opname;
   char *tmp = alloca (q1 - q + 1);
   memcpy (tmp, q, q1 - q);
   tmp[q1 - q] = '\0';
   opname = cplus_mangle_opname (tmp, DMGL_ANSI);
   if (opname == NULL)
   {
   cplusplus_error (saved_arg, "no mangling for \"%s\"\n", tmp);
   }
   copy = (char*) alloca (3 + strlen(opname));
   sprintf (copy, "__%s", opname);
   p = q1;
   }
   else
 */
	  {
	    copy = (char *) alloca (p - *argptr + 1);
	    memcpy (copy, *argptr, p - *argptr);
	    copy[p - *argptr] = '\0';
	    if (p != *argptr
		&& copy[p - *argptr - 1]
		&& strchr (get_gdb_completer_quote_characters (),
			   copy[p - *argptr - 1]) != NULL)
	      copy[p - *argptr - 1] = '\0';
	  }

	  /* No line number may be specified.  */
	  while (*p == ' ' || *p == '\t')
	    p++;
	  *argptr = p;

	  return find_method (funfirstline, canonical, saved_arg,
			      copy, t, sym_class);
	}

      /* Move pointer up to next possible class/namespace token.  */
      p = p2 + 1;	/* Restart with old value +1.  */
      /* Move pointer ahead to next double-colon.  */
      while (*p && (p[0] != ' ') && (p[0] != '\t') && (p[0] != '\''))
	{
	  if (p[0] == '<')
d1233 8
a1240 4
	      temp_end = find_template_name_end (p);
	      if (!temp_end)
		error ("malformed template specification in command");
	      p = temp_end;
a1241 2
	  else if ((p[0] == ':') && (p[1] == ':'))
	    break;	/* Found double-colon.  */
d1243 6
a1248 1
	    p++;
d1250 1
d1252 1
a1252 2
      if (*p != ':')
	break;		/* Out of the while (1).  */
d1254 2
a1255 26
      p2 = p;		/* Save restart for next time around.  */
      *argptr = saved_arg2;	/* Restore argptr.  */
    }			/* while (1) */

  /* Last chance attempt -- check entire name as a symbol.  Use "copy"
     in preparation for jumping out of this block, to be consistent
     with usage following the jump target.  */
  copy = (char *) alloca (p - saved_arg2 + 1);
  memcpy (copy, saved_arg2, p - saved_arg2);
  /* Note: if is_quoted should be true, we snuff out quote here
     anyway.  */
  copy[p - saved_arg2] = '\000';
  /* Set argptr to skip over the name.  */
  *argptr = (*p == '\'') ? p + 1 : p;
  /* Look up entire name */
  sym = lookup_symbol (copy, 0, VAR_DOMAIN, 0, &sym_symtab);
  if (sym)
    return symbol_found (funfirstline, canonical, copy, sym,
			 NULL, sym_symtab);

  /* Couldn't find any interpretation as classes/namespaces, so give
     up.  The quotes are important if copy is empty.  */
  cplusplus_error (saved_arg,
		   "Can't find member of namespace, class, struct, or union named \"%s\"\n",
		   copy);
}
d1257 1
a1257 50
/* Next come some helper functions for decode_compound.  */

/* Return the symbol corresponding to the substring of *ARGPTR ending
   at P, allowing whitespace.  Also, advance *ARGPTR past the symbol
   name in question, the compound object separator ("::" or "."), and
   whitespace.  */

static struct symbol *
lookup_prefix_sym (char **argptr, char *p)
{
  char *p1;
  char *copy;

  /* Extract the class name.  */
  p1 = p;
  while (p != *argptr && p[-1] == ' ')
    --p;
  copy = (char *) alloca (p - *argptr + 1);
  memcpy (copy, *argptr, p - *argptr);
  copy[p - *argptr] = 0;

  /* Discard the class name from the arg.  */
  p = p1 + (p1[0] == ':' ? 2 : 1);
  while (*p == ' ' || *p == '\t')
    p++;
  *argptr = p;

  return lookup_symbol (copy, 0, STRUCT_DOMAIN, 0,
			(struct symtab **) NULL);
}

/* This finds the method COPY in the class whose type is T and whose
   symbol is SYM_CLASS.  */

static struct symtabs_and_lines
find_method (int funfirstline, char ***canonical, char *saved_arg,
	     char *copy, struct type *t, struct symbol *sym_class)
{
  struct symtabs_and_lines values;
  struct symbol *sym = 0;
  int i1;	/*  Counter for the symbol array.  */
  struct symbol **sym_arr =  alloca (total_number_of_methods (t)
				     * sizeof (struct symbol *));

  /* Find all methods with a matching name, and put them in
     sym_arr.  */

  i1 = collect_methods (copy, t, sym_arr);

  if (i1 == 1)
d1259 6
a1264 4
      /* There is exactly one field with that name.  */
      sym = sym_arr[0];

      if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)
d1266 2
a1267 9
	  values.sals = (struct symtab_and_line *)
	    xmalloc (sizeof (struct symtab_and_line));
	  values.nelts = 1;
	  values.sals[0] = find_function_start_sal (sym,
						    funfirstline);
	}
      else
	{
	  values.nelts = 0;
d1269 1
a1271 295
  if (i1 > 0)
    {
      /* There is more than one field with that name
	 (overloaded).  Ask the user which one to use.  */
      return decode_line_2 (sym_arr, i1, funfirstline, canonical);
    }
  else
    {
      char *tmp;

      if (is_operator_name (copy))
	{
	  tmp = (char *) alloca (strlen (copy + 3) + 9);
	  strcpy (tmp, "operator ");
	  strcat (tmp, copy + 3);
	}
      else
	tmp = copy;
      if (tmp[0] == '~')
	cplusplus_error (saved_arg,
			 "the class `%s' does not have destructor defined\n",
			 SYMBOL_PRINT_NAME (sym_class));
      else
	cplusplus_error (saved_arg,
			 "the class %s does not have any method named %s\n",
			 SYMBOL_PRINT_NAME (sym_class), tmp);
    }
}

/* Find all methods named COPY in the class whose type is T, and put
   them in SYM_ARR.  Return the number of methods found.  */

static int
collect_methods (char *copy, struct type *t,
		 struct symbol **sym_arr)
{
  int i1 = 0;	/*  Counter for the symbol array.  */

  if (destructor_name_p (copy, t))
    {
      /* Destructors are a special case.  */
      int m_index, f_index;

      if (get_destructor_fn_field (t, &m_index, &f_index))
	{
	  struct fn_field *f = TYPE_FN_FIELDLIST1 (t, m_index);

	  sym_arr[i1] =
	    lookup_symbol (TYPE_FN_FIELD_PHYSNAME (f, f_index),
			   NULL, VAR_DOMAIN, (int *) NULL,
			   (struct symtab **) NULL);
	  if (sym_arr[i1])
	    i1++;
	}
    }
  else
    i1 = find_methods (t, copy, sym_arr);

  return i1;
}



/* Return the symtab associated to the filename given by the substring
   of *ARGPTR ending at P, and advance ARGPTR past that filename.  */

static struct symtab *
symtab_from_filename (char **argptr, char *p, int is_quote_enclosed)
{
  char *p1;
  char *copy;
  struct symtab *file_symtab;
  
  p1 = p;
  while (p != *argptr && p[-1] == ' ')
    --p;
  if ((*p == '"') && is_quote_enclosed)
    --p;
  copy = (char *) alloca (p - *argptr + 1);
  memcpy (copy, *argptr, p - *argptr);
  /* It may have the ending quote right after the file name.  */
  if (is_quote_enclosed && copy[p - *argptr - 1] == '"')
    copy[p - *argptr - 1] = 0;
  else
    copy[p - *argptr] = 0;

  /* Find that file's data.  */
  file_symtab = lookup_symtab (copy);
  if (file_symtab == 0)
    {
      if (!have_full_symbols () && !have_partial_symbols ())
	error ("No symbol table is loaded.  Use the \"file\" command.");
      error ("No source file named %s.", copy);
    }

  /* Discard the file name from the arg.  */
  p = p1 + 1;
  while (*p == ' ' || *p == '\t')
    p++;
  *argptr = p;

  return file_symtab;
}



/* This decodes a line where the argument is all digits (possibly
   preceded by a sign).  Q should point to the end of those digits;
   the other arguments are as usual.  */

static struct symtabs_and_lines
decode_all_digits (char **argptr, struct symtab *default_symtab,
		   int default_line, char ***canonical,
		   struct symtab *file_symtab, char *q)

{
  struct symtabs_and_lines values;
  struct symtab_and_line val;

  enum sign
    {
      none, plus, minus
    }
  sign = none;

  /* We might need a canonical line spec if no file was specified.  */
  int need_canonical = (file_symtab == 0) ? 1 : 0;

  init_sal (&val);

  /* This is where we need to make sure that we have good defaults.
     We must guarantee that this section of code is never executed
     when we are called with just a function name, since
     set_default_source_symtab_and_line uses
     select_source_symtab that calls us with such an argument.  */

  if (file_symtab == 0 && default_symtab == 0)
    {
      /* Make sure we have at least a default source file.  */
      set_default_source_symtab_and_line ();
      initialize_defaults (&default_symtab, &default_line);
    }

  if (**argptr == '+')
    sign = plus, (*argptr)++;
  else if (**argptr == '-')
    sign = minus, (*argptr)++;
  val.line = atoi (*argptr);
  switch (sign)
    {
    case plus:
      if (q == *argptr)
	val.line = 5;
      if (file_symtab == 0)
	val.line = default_line + val.line;
      break;
    case minus:
      if (q == *argptr)
	val.line = 15;
      if (file_symtab == 0)
	val.line = default_line - val.line;
      else
	val.line = 1;
      break;
    case none:
      break;		/* No need to adjust val.line.  */
    }

  while (*q == ' ' || *q == '\t')
    q++;
  *argptr = q;
  if (file_symtab == 0)
    file_symtab = default_symtab;

  /* It is possible that this source file has more than one symtab, 
     and that the new line number specification has moved us from the
     default (in file_symtab) to a new one.  */
  val.symtab = find_line_symtab (file_symtab, val.line, NULL, NULL);
  if (val.symtab == 0)
    val.symtab = file_symtab;

  val.pc = 0;
  values.sals = (struct symtab_and_line *)
    xmalloc (sizeof (struct symtab_and_line));
  values.sals[0] = val;
  values.nelts = 1;
  if (need_canonical)
    build_canonical_line_spec (values.sals, NULL, canonical);
  return values;
}



/* Decode a linespec starting with a dollar sign.  */

static struct symtabs_and_lines
decode_dollar (char *copy, int funfirstline, struct symtab *default_symtab,
	       char ***canonical, struct symtab *file_symtab)
{
  struct value *valx;
  int index = 0;
  int need_canonical = 0;
  struct symtabs_and_lines values;
  struct symtab_and_line val;
  char *p;
  struct symbol *sym;
  /* The symtab that SYM was found in.  */
  struct symtab *sym_symtab;
  struct minimal_symbol *msymbol;

  p = (copy[1] == '$') ? copy + 2 : copy + 1;
  while (*p >= '0' && *p <= '9')
    p++;
  if (!*p)		/* Reached end of token without hitting non-digit.  */
    {
      /* We have a value history reference.  */
      sscanf ((copy[1] == '$') ? copy + 2 : copy + 1, "%d", &index);
      valx = access_value_history ((copy[1] == '$') ? -index : index);
      if (TYPE_CODE (VALUE_TYPE (valx)) != TYPE_CODE_INT)
	error ("History values used in line specs must have integer values.");
    }
  else
    {
      /* Not all digits -- may be user variable/function or a
	 convenience variable.  */

      /* Look up entire name as a symbol first.  */
      sym = lookup_symbol (copy, 0, VAR_DOMAIN, 0, &sym_symtab);
      file_symtab = (struct symtab *) 0;
      need_canonical = 1;
      /* Symbol was found --> jump to normal symbol processing.  */
      if (sym)
	return symbol_found (funfirstline, canonical, copy, sym,
			     NULL, sym_symtab);

      /* If symbol was not found, look in minimal symbol tables.  */
      msymbol = lookup_minimal_symbol (copy, NULL, NULL);
      /* Min symbol was found --> jump to minsym processing.  */
      if (msymbol)
	return minsym_found (funfirstline, msymbol);

      /* Not a user variable or function -- must be convenience variable.  */
      need_canonical = (file_symtab == 0) ? 1 : 0;
      valx = value_of_internalvar (lookup_internalvar (copy + 1));
      if (TYPE_CODE (VALUE_TYPE (valx)) != TYPE_CODE_INT)
	error ("Convenience variables used in line specs must have integer values.");
    }

  init_sal (&val);

  /* Either history value or convenience value from above, in valx.  */
  val.symtab = file_symtab ? file_symtab : default_symtab;
  val.line = value_as_long (valx);
  val.pc = 0;

  values.sals = (struct symtab_and_line *) xmalloc (sizeof val);
  values.sals[0] = val;
  values.nelts = 1;

  if (need_canonical)
    build_canonical_line_spec (values.sals, NULL, canonical);

  return values;
}



/* Decode a linespec that's a variable.  If FILE_SYMTAB is non-NULL,
   look in that symtab's static variables first.  */

static struct symtabs_and_lines
decode_variable (char *copy, int funfirstline, char ***canonical,
		 struct symtab *file_symtab)
{
  struct symbol *sym;
  /* The symtab that SYM was found in.  */
  struct symtab *sym_symtab;

  struct minimal_symbol *msymbol;

  sym = lookup_symbol (copy,
		       (file_symtab
			? BLOCKVECTOR_BLOCK (BLOCKVECTOR (file_symtab),
					     STATIC_BLOCK)
			: get_selected_block (0)),
		       VAR_DOMAIN, 0, &sym_symtab);

  if (sym != NULL)
    return symbol_found (funfirstline, canonical, copy, sym,
			 file_symtab, sym_symtab);

  msymbol = lookup_minimal_symbol (copy, NULL, NULL);

  if (msymbol != NULL)
    return minsym_found (funfirstline, msymbol);
d1278 1
a1278 86
}




/* Now come some functions that are called from multiple places within
   decode_line_1.  */

/* We've found a symbol SYM to associate with our linespec; build a
   corresponding struct symtabs_and_lines.  */

static struct symtabs_and_lines
symbol_found (int funfirstline, char ***canonical, char *copy,
	      struct symbol *sym, struct symtab *file_symtab,
	      struct symtab *sym_symtab)
{
  struct symtabs_and_lines values;
  
  if (SYMBOL_CLASS (sym) == LOC_BLOCK)
    {
      /* Arg is the name of a function */
      values.sals = (struct symtab_and_line *)
	xmalloc (sizeof (struct symtab_and_line));
      values.sals[0] = find_function_start_sal (sym, funfirstline);
      values.nelts = 1;

      /* Don't use the SYMBOL_LINE; if used at all it points to
	 the line containing the parameters or thereabouts, not
	 the first line of code.  */

      /* We might need a canonical line spec if it is a static
	 function.  */
      if (file_symtab == 0)
	{
	  struct blockvector *bv = BLOCKVECTOR (sym_symtab);
	  struct block *b = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	  if (lookup_block_symbol (b, copy, NULL, VAR_DOMAIN) != NULL)
	    build_canonical_line_spec (values.sals, copy, canonical);
	}
      return values;
    }
  else
    {
      if (funfirstline)
	error ("\"%s\" is not a function", copy);
      else if (SYMBOL_LINE (sym) != 0)
	{
	  /* We know its line number.  */
	  values.sals = (struct symtab_and_line *)
	    xmalloc (sizeof (struct symtab_and_line));
	  values.nelts = 1;
	  memset (&values.sals[0], 0, sizeof (values.sals[0]));
	  values.sals[0].symtab = sym_symtab;
	  values.sals[0].line = SYMBOL_LINE (sym);
	  return values;
	}
      else
	/* This can happen if it is compiled with a compiler which doesn't
	   put out line numbers for variables.  */
	/* FIXME: Shouldn't we just set .line and .symtab to zero
	   and return?  For example, "info line foo" could print
	   the address.  */
	error ("Line number not known for symbol \"%s\"", copy);
    }
}

/* We've found a minimal symbol MSYMBOL to associate with our
   linespec; build a corresponding struct symtabs_and_lines.  */

static struct symtabs_and_lines
minsym_found (int funfirstline, struct minimal_symbol *msymbol)
{
  struct symtabs_and_lines values;

  values.sals = (struct symtab_and_line *)
    xmalloc (sizeof (struct symtab_and_line));
  values.sals[0] = find_pc_sect_line (SYMBOL_VALUE_ADDRESS (msymbol),
				      (struct bfd_section *) 0, 0);
  values.sals[0].section = SYMBOL_BFD_SECTION (msymbol);
  if (funfirstline)
    {
      values.sals[0].pc += FUNCTION_START_OFFSET;
      values.sals[0].pc = SKIP_PROLOGUE (values.sals[0].pc);
    }
  values.nelts = 1;
  return values;
@


1.23.2.3
log
@Merge from mainline.
@
text
@d103 1
a103 2
					    char *p, int is_quote_enclosed,
					    int *not_found_ptr);
d122 1
a122 2
						 struct symtab *file_symtab,
						 int *not_found_ptr);
d640 1
a640 6
   Also, the line number returned may be invalid.  
 
   If NOT_FOUND_PTR is not null, store a boolean true/false value at the location, based
   on whether or not failure occurs due to an unknown function or file.  In the case
   where failure does occur due to an unknown function or file, do not issue an error
   message.  */
d649 1
a649 1
	       int default_line, char ***canonical, int *not_found_ptr)
a667 3
  if (not_found_ptr)
    *not_found_ptr = 0;

d725 1
a725 2
      file_symtab = symtab_from_filename (argptr, p, is_quote_enclosed, 
		      			  not_found_ptr);
d830 1
a830 2
  return decode_variable (copy, funfirstline, canonical,
			  file_symtab, not_found_ptr);
d1425 1
a1425 4
   of *ARGPTR ending at P, and advance ARGPTR past that filename.  If
   NOT_FOUND_PTR is not null and the source file is not found, store
   boolean true at the location pointed to and do not issue an
   error message.  */
d1428 1
a1428 2
symtab_from_filename (char **argptr, char *p, int is_quote_enclosed, 
		      int *not_found_ptr)
a1452 5
      if (not_found_ptr)
	{
	  *not_found_ptr = 1;
	  throw_exception (RETURN_ERROR);
	}
d1629 1
a1629 3
   look in that symtab's static variables first.  If NOT_FOUND_PTR is not NULL and
   the function cannot be found, store boolean true in the location pointed to
   and do not issue an error message.  */ 
d1633 1
a1633 1
		 struct symtab *file_symtab, int *not_found_ptr)
a1660 6
  if (not_found_ptr)
    {
      *not_found_ptr = 1;
      throw_exception (RETURN_ERROR);
    }
  
@


1.23.2.4
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d1472 1
a1472 8
	  /* The caller has indicated that it wishes quiet notification of any
	     error where the function or file is not found.  A call to 
	     error_silent causes an error to occur, but it does not issue 
	     the supplied message.  The message can be manually output by
	     the caller, if desired.  This is used, for example, when 
	     attempting to set breakpoints for functions in shared libraries 
	     that have not yet been loaded.  */
	  error_silent ("No source file named %s.", copy);
d1687 1
a1687 8
      /* The caller has indicated that it wishes quiet notification of any
	 error where the function or file is not found.  A call to 
	 error_silent causes an error to occur, but it does not issue 
	 the supplied message.  The message can be manually output by
	 the caller, if desired.  This is used, for example, when 
	 attempting to set breakpoints for functions in shared libraries 
	 that have not yet been loaded.  */
      error_silent ("Function \"%s\" not defined.", copy);
@


1.22
log
@        * source.c: Make global variables current_source_symtab and
        current_source_line static.
        (list_command): Moved to cli/cli-cmds.c.
        (ambiguous_line_spec): Moved to cli/cli-cmds.c.
        (get_first_line_listed): New accessor function.
        (get_lines_to_list): New accessor function.
        (get_current_source_symtab_and_line): New function. Retrieves the
        position in the source code that we consider current.
        (get_current_or_default_source_symtab_and_line): New function.
        Like the above but attempts to determine a default position if one
        is not currently defined.
        (set_current_source_symtab_and_line): New function. Sets the source
        code position considered current and returns the previously set one.
        (clear_current_source_symtab_and_line): Reset stored information about
        a current source line.
        (_initialize_source): Remove registration for the "list" command and
        its alias.
        * source.h: Add declarations for the new functions above.
        * symtab.h: Remove declarations for the global variables mentioned
        above.
        * breakpoint.c (parse_breakpoint_sals): Use accessor functions to
        obtain current source line.
        * linespec.c (decode_line_1): Ditto.
        * macroscope.c (default_macro_scope): Ditto.
        * scm-lang.c (scm_unpac): Ditto.
        * stack.c (print_frame_info_base): Ditto.
        * symfile.c (clear_symtab_users): Ditto.
        * symtab.c (decode_line_spec): Ditto.
        * cli/cli-cmds.c (list_command): Moved here from source.c.
        (ambiguous_line_spec): Moved here from source.c.
        (_init_cli_cmds): Add definition for "list" and its alias.
        * Makefile.in: Update dependencies.
@
text
@d1030 1
a1030 1
	 get_current_or_default_source_symtab_and_line uses
d1035 5
a1039 2
          struct symtab_and_line cursal =
		  get_current_or_default_source_symtab_and_line ();
@


1.22.2.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d1030 1
a1030 1
	 set_default_source_symtab_and_line uses
d1035 2
a1036 5
          struct symtab_and_line cursal;

	  /* Make sure we have at least a default source file. */
	  set_default_source_symtab_and_line ();
          cursal = get_current_source_symtab_and_line ();
@


1.22.2.2
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a24 1
#include "block.h"
@


1.22.2.3
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d25 1
d35 5
a39 2
#include "block.h"
#include "parser-defs.h"
d375 2
a376 2
      init_sal (&return_values.sals[i]);	/* initialize to zeroes */
      init_sal (&values.sals[i]);
d544 1
a544 1
  init_sal (&val);		/* initialize to zeroes */
@


1.22.2.4
log
@2002-10-28  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (dl1_initialize_defaults): New function.
	(dl1_indirect): Ditto.
	(dl1_set_flags): Ditto.
	(dl1_locate_first_half): Ditto.
	(decode_line_1): Call the above functions.
	* symtab.c (lookup_symbol_aux_minsyms): Add block_index argument,
	and delete is_a_field_of_this argument.
	(lookup_symbol_aux_nonlocal): Add call to
	lookup_symbol_aux_minsyms, and expand HP comment.
	(lookup_symbol_aux): Delete calls to lookup_symbol_aux_minsyms.
	Expand on comment before lookup_transparent_type.
@
text
@a56 10
static void dl1_initialize_defaults (struct symtab **default_symtab,
				     int *default_line);

static struct symtabs_and_lines dl1_indirect (char **argptr);

static void dl1_set_flags (char **argptr, int *is_quoted,
			   char **paren_pointer);

static char *dl1_locate_first_half (char **argptr, int *is_quote_enclosed);

d515 5
a519 5
  char *q, *ii, *p2;
  /* This is NULL if there are no parens in argptr, or a pointer to
     the closing parenthesis if there are parens.  */
  char *paren_pointer;
  register struct symtab *s = NULL;
d525 1
d532 3
d538 1
d544 12
a555 2
  dl1_initialize_defaults (&default_symtab, &default_line);
  
d559 33
a591 1
    return dl1_indirect (argptr);
d594 1
a594 1
   * 'paren_pointer' is important for overload checking, where
d599 5
a603 1
  dl1_set_flags (argptr, &is_quoted, &paren_pointer);
d605 2
a606 2
  /* Locate the first half of the linespec, ending in a colon, period,
     or whitespace.  (More or less.)  */
d608 15
a622 1
  p = dl1_locate_first_half (argptr, &is_quote_enclosed);
d624 70
a693 1
  if ((p[0] == ':' || p[0] == '.') && paren_pointer == NULL)
d770 29
a799 9
		  copy = (char *) alloca (p - *argptr + 1);
		  memcpy (copy, *argptr, p - *argptr);
		  copy[p - *argptr] = '\0';
		  if (p != *argptr
		      && copy[p - *argptr - 1]
		      && strchr (get_gdb_completer_quote_characters (),
				 copy[p - *argptr - 1]) != NULL)
		    copy[p - *argptr - 1] = '\0';
		  
d963 37
d1101 1
a1101 1
  else if (paren_pointer != NULL)
d1103 1
a1103 1
      p = paren_pointer + 1;
a1279 181
}

/* Now come a bunch of helper functions for decode_line_1.  */

/* Defaults have defaults.  */

static void
dl1_initialize_defaults (struct symtab **default_symtab, int *default_line)
{
  if (*default_symtab == NULL)
    {
      /* Use whatever we have for the default source line.  We don't use
         get_current_or_default_symtab_and_line as it can recurse and call
	 us back! */
      struct symtab_and_line cursal
	= get_current_source_symtab_and_line ();
      
      *default_symtab = cursal.symtab;
      *default_line = cursal.line;
    }
}

/* See if arg is *PC */

static struct symtabs_and_lines
dl1_indirect (char **argptr)
{
  struct symtabs_and_lines values;
  CORE_ADDR pc;

  (*argptr)++;
  pc = parse_and_eval_address_1 (argptr);

  values.sals = (struct symtab_and_line *)
    xmalloc (sizeof (struct symtab_and_line));

  values.nelts = 1;
  values.sals[0] = find_pc_line (pc, 0);
  values.sals[0].pc = pc;
  values.sals[0].section = find_pc_overlay (pc);

  return values;
}

static void
dl1_set_flags (char **argptr, int *is_quoted, char **paren_pointer)
{
  char *ii;
  int has_if = 0;
  
  /* 'has_if' is for the syntax:
   *     (gdb) break foo if (a==b)
   */
  if ((ii = strstr (*argptr, " if ")) != NULL ||
      (ii = strstr (*argptr, "\tif ")) != NULL ||
      (ii = strstr (*argptr, " if\t")) != NULL ||
      (ii = strstr (*argptr, "\tif\t")) != NULL ||
      (ii = strstr (*argptr, " if(")) != NULL ||
      (ii = strstr (*argptr, "\tif( ")) != NULL)
    has_if = 1;
  /* Temporarily zap out "if (condition)" to not
   * confuse the parenthesis-checking code below.
   * This is undone below. Do not change ii!!
   */
  if (has_if)
    {
      *ii = '\0';
    }

  /* Set various flags.
   * 'paren_pointer' is important for overload checking, where
   * we allow things like: 
   *     (gdb) break c::f(int)
   */

  /* Maybe arg is FILE : LINENUM or FILE : FUNCTION */

  *is_quoted = (**argptr
		&& strchr (get_gdb_completer_quote_characters (),
			   **argptr) != NULL);

  *paren_pointer = strchr (*argptr, '(');

  if (*paren_pointer != NULL)
    *paren_pointer = strrchr (*paren_pointer, ')');

  /* Now that we're safely past the has_parens check,
   * put back " if (condition)" so outer layers can see it 
   */
  if (has_if)
    *ii = ' ';
}

static char *
dl1_locate_first_half (char **argptr, int *is_quote_enclosed)
{
  char *ii;
  char *p, *p1;
  int has_comma;

  /* Maybe we were called with a line range
     FILENAME:LINENUM,FILENAME:LINENUM and we must isolate the first
     half.  Outer layers will call again later for the second half.

     Don't count commas that appear in argument lists of overloaded
     functions, or in quoted strings.  It's stupid to go to this much
     trouble when the rest of the function is such an obvious roach
     hotel.  */
  
  ii = find_toplevel_char (*argptr, ',');
  has_comma = (ii != 0);

  /* Temporarily zap out second half to not
   * confuse the code below.
   * This is undone below. Do not change ii!!
   */
  if (has_comma)
    {
      *ii = '\0';
    }

  /* Maybe arg is FILE : LINENUM or FILE : FUNCTION */
  /* May also be CLASS::MEMBER, or NAMESPACE::NAME */
  /* Look for ':', but ignore inside of <> */

  p = *argptr;
  if (p[0] == '"')
    {
      *is_quote_enclosed = 1;
      (*argptr)++;
      p++;
    }
  else
    *is_quote_enclosed = 0;
  for (; *p; p++)
    {
      if (p[0] == '<')
	{
	  char *temp_end = find_template_name_end (p);
	  if (!temp_end)
	    error ("malformed template specification in command");
	  p = temp_end;
	}
      /* Check for the end of the first half of the linespec.  End of line,
         a tab, a double colon or the last single colon, or a space.  But
         if enclosed in double quotes we do not break on enclosed spaces */
      if (!*p
	  || p[0] == '\t'
	  || ((p[0] == ':')
	      && ((p[1] == ':') || (strchr (p + 1, ':') == NULL)))
	  || ((p[0] == ' ') && !*is_quote_enclosed))
	break;
      if (p[0] == '.' && strchr (p, ':') == NULL)	/* Java qualified method. */
	{
	  /* Find the *last* '.', since the others are package qualifiers. */
	  for (p1 = p; *p1; p1++)
	    {
	      if (*p1 == '.')
		p = p1;
	    }
	  break;
	}
    }
  while (p[0] == ' ' || p[0] == '\t')
    p++;

  /* if the closing double quote was left at the end, remove it */
  if (*is_quote_enclosed)
    {
      char *closing_quote = strchr (p - 1, '"');
      if (closing_quote && closing_quote[1] == '\0')
	*closing_quote = '\0';
    }

  /* Now that we've safely parsed the first half,
   * put back ',' so outer layers can see it 
   */
  if (has_comma)
    *ii = ',';

  return p;
@


1.22.2.5
log
@2002-10-31  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (dl1_handle_multipart): New function.
	(dl1_multipart_compound): Ditto.
	(dl1_examine_compound_token): Ditto.
	(dl1_locate_class_sym): Ditto.
	(dl1_find_next_token): Ditto.
	(dl1_find_method): Ditto.
	(dl1_count_methods): Ditto.
	(dl1_handle_filename): Ditto.
	(decode_line_1): Call dl1_handle_multipart.
	(cplusplus_error): Declare to be NORETURN.

Also, my previous change on the branch should have mentioned:

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* ada-lang.c (standard_lookup): Set last argument to lookup_symbol
	to NULL.
	* p-valprint.c (pascal_val_print): Ditto.
	* objc-lang.c (find_imps): Ditto.
	* c-valprint.c (c_val_print): Ditto.
@
text
@d43 1
a43 1
static NORETURN void cplusplus_error (const char *name, const char *fmt, ...) ATTR_NORETURN ATTR_FORMAT (printf, 2, 3);
a64 15
enum dl1_control_flow { DO_NOTHING, DO_RETURN, DO_SYMBOL_FOUND };

static enum
dl1_control_flow dl1_handle_multipart (char **argptr,
				       int funfirstline,
				       char ***canonical,
				       char *saved_arg,
				       int is_quoted,
				       char *paren_pointer,
				       char **temp_copy,
				       struct symbol **sym,
				       struct symtab **sym_symtab,
				       struct symtab **s,
				       struct symtabs_and_lines *values);

a66 38
static enum
dl1_control_flow dl1_multipart_compound (char **argptr,
					 int funfirstline,
					 char ***canonical,
					 char *saved_arg,
					 char *p,
					 char **temp_copy,
					 struct symbol **sym,
					 struct symtab **sym_symtab,
					 struct symtab **s,
					 struct symtabs_and_lines *values);

static enum
dl1_control_flow dl1_examine_compound_token (char **argptr,
					     int funfirstline,
					     char ***canonical,
					     char *saved_arg,
					     char *p,
					     struct symtabs_and_lines *values);

static struct symbol *dl1_locate_class_sym (char **argptr, char *p);

static char *dl1_find_next_token (char **argptr);

static void dl1_find_method (int funfirstline, char ***canonical,
			     char *saved_arg, char *copy,
			     struct type *t,
			     struct symbol *sym_class,
			     struct symbol **sym_arr,
			     struct symtabs_and_lines *values);

static int dl1_count_methods (char *copy, struct type *t,
			      struct symbol **sym_arr);

static void dl1_handle_filename (char **argptr, char *p,
				 int is_quote_enclosed,
				 struct symtab **s);

d73 1
a73 1
static NORETURN void
d524 2
a525 2
  char *p;
  char *q, *ii;
d529 1
a529 1
  struct symtab *s = NULL;
d531 1
a531 1
  struct symbol *sym;
d535 1
a535 1
  struct minimal_symbol *msymbol;
d537 2
d541 2
d564 243
a806 17
  /* Handle multipart linespecs (with colons or periods).  */
  {
    /* The code after symbol_found depends on having access to a
       string 'copy' which is allocated via alloca.  But we can't
       allocate via alloca within dl1_handle_multipart and still
       expect it to be valid after we exit.  temp_copy will help us
       get around that.  */
    char *temp_copy;

    switch (dl1_handle_multipart (argptr, funfirstline, canonical,
				  saved_arg, is_quoted, paren_pointer,
				  &temp_copy, &sym, &sym_symtab,
				  &s, &values))
      {
      case DO_RETURN:
	return values;
      case DO_SYMBOL_FOUND:
d808 3
a810 5
	  int temp_copy_len = strlen (temp_copy);
	  copy = (char *) alloca (temp_copy_len + 1);
	  memcpy (copy, temp_copy, temp_copy_len + 1);
	  xfree (temp_copy);
	  goto symbol_found;
d812 7
a818 5
      default:
	/* Do nothing.  */
	;
      }
  }
d1101 1
a1101 3
/* Now come a bunch of helper functions for decode_line_1.  Warning:
   most of them have the side effect of advancing argptr, and I'm not
   mentioning that in the comments.  */
a1191 41
static enum dl1_control_flow
dl1_handle_multipart (char **argptr, int funfirstline, char ***canonical,
		      char *saved_arg, int is_quoted, char *paren_pointer,
		      char **temp_copy,
		      struct symbol **sym, struct symtab **sym_symtab,
		      struct symtab **s,
		      struct symtabs_and_lines *values)
{
  char *p;
  int is_quote_enclosed;

  /* Locate the first half of the linespec, ending in a colon, period,
     or whitespace.  (More or less.)  */

  p = dl1_locate_first_half (argptr, &is_quote_enclosed);

  /* Does it look like there actually were two parts?  */

  if ((p[0] == ':' || p[0] == '.') && paren_pointer == NULL)
    {
      if (is_quoted)
	*argptr = *argptr + 1;
      
      /* Is it a C++ or Java compound data structure?  */
      
      if (p[0] == '.' || p[1] == ':')
	{
	  return dl1_multipart_compound (argptr, funfirstline, canonical,
					 saved_arg, p, temp_copy, sym,
					 sym_symtab, s, values);
	}

      /* No, the first part is a filename; update argptr and s
	 accordingly.  */
      
      dl1_handle_filename (argptr, p, is_quote_enclosed, s);
    }
  
  return DO_NOTHING;
}

a1279 324
}

static enum dl1_control_flow
dl1_multipart_compound (char **argptr, int funfirstline, char ***canonical,
			char *saved_arg, char *p,
			char **temp_copy, struct symbol **sym,
			struct symtab **sym_symtab,
			struct symtab **s,
			struct symtabs_and_lines *values)
{
  char *saved_arg2 = *argptr;
  char *temp_end;
  char *p2;
  
  /* First check for "global" namespace specification,
     of the form "::foo". If found, skip over the colons
     and jump to normal symbol processing */
  if (p[0] == ':' 
      && ((*argptr == p) || (p[-1] == ' ') || (p[-1] == '\t')))
    saved_arg2 += 2;
      
  /* We have what looks like a class or namespace
     scope specification (A::B), possibly with many
     levels of namespaces or classes (A::B::C::D).

     Some versions of the HP ANSI C++ compiler (as also possibly
     other compilers) generate class/function/member names with
     embedded double-colons if they are inside namespaces. To
     handle this, we loop a few times, considering larger and
     larger prefixes of the string as though they were single
     symbols.  So, if the initially supplied string is
     A::B::C::D::foo, we have to look up "A", then "A::B",
     then "A::B::C", then "A::B::C::D", and finally
     "A::B::C::D::foo" as single, monolithic symbols, because
     A, B, C or D may be namespaces.

     Note that namespaces can nest only inside other
     namespaces, and not inside classes.  So we need only
     consider *prefixes* of the string; there is no need to look up
     "B::C" separately as a symbol in the previous example. */

  p2 = p;		/* save for restart */
  while (1)
    {
      enum dl1_control_flow do_next
	= dl1_examine_compound_token (argptr, funfirstline, canonical,
				      saved_arg, p, values);

      if (do_next != DO_NOTHING)
	return do_next;
      
      /* Move pointer up to next possible class/namespace token */
      p = p2 + 1;	/* restart with old value +1 */
      /* Move pointer ahead to next double-colon */
      while (*p && (p[0] != ' ') && (p[0] != '\t') && (p[0] != '\''))
	{
	  if (p[0] == '<')
	    {
	      temp_end = find_template_name_end (p);
	      if (!temp_end)
		error ("malformed template specification in command");
	      p = temp_end;
	    }
	  else if ((p[0] == ':') && (p[1] == ':'))
	    break;	/* found double-colon */
	  else
	    p++;
	}

      if (*p != ':')
	break;		/* out of the while (1) */
	  
      p2 = p;		/* save restart for next time around */
      *argptr = saved_arg2;	/* restore argptr */
    }			/* while (1) */

  /* Last chance attempt -- check entire name as a symbol */
  /* Use "temp_copy" in preparation for jumping out of the block
     after we make it back to decode_line_1.  */
  *temp_copy = xmalloc (p - saved_arg2 + 1);
  memcpy (*temp_copy, saved_arg2, p - saved_arg2);
  /* Note: if is_quoted should be true, we snuff out quote here anyway */
  (*temp_copy)[p - saved_arg2] = '\000';
  /* Set argptr to skip over the name */
  *argptr = (*p == '\'') ? p + 1 : p;
  /* Look up entire name */
  *sym = lookup_symbol (*temp_copy, 0, VAR_NAMESPACE, 0, sym_symtab);
  *s = (struct symtab *) 0;
  /* Prepare to jump: restore the " if (condition)" so outer layers see it */
  /* Symbol was found --> jump to normal symbol processing.
     Code following "symbol_found" expects "copy" to have the
     symbol name, "sym" to have the symbol pointer, "s" to be
     a specified file's symtab, and sym_symtab to be the symbol's
     symtab. */
  /* By jumping there we avoid falling through the FILE:LINE and
     FILE:FUNC processing stuff below */
  if (*sym)
    return DO_SYMBOL_FOUND;

  /* Couldn't find any interpretation as classes/namespaces, so give up */
  /* FIXME: carlton/2002-10-31: I should arrange for *temp_copy to be
     xfree'd.  */
  /* The quotes are important if copy is empty.  */
  cplusplus_error (saved_arg,
		   "Can't find member of namespace, class, struct, or union named \"%s\"\n",
		   *temp_copy);
}

static enum dl1_control_flow
dl1_examine_compound_token (char **argptr, int funfirstline,
			    char ***canonical, 
			    char *saved_arg, char *p,
			    struct symtabs_and_lines *values)
{
  char *copy;
  struct symbol *sym_class;
  struct type *t;
  
  /* If p points at the name of a class, find the corresponding
     symbol.  */

  sym_class = dl1_locate_class_sym (argptr, p);

  if (sym_class &&
      (t = check_typedef (SYMBOL_TYPE (sym_class)),
       (TYPE_CODE (t) == TYPE_CODE_STRUCT
	|| TYPE_CODE (t) == TYPE_CODE_UNION)))
    {
      int i1;
      struct symbol **sym_arr;
      
      /* Arg token is not digits => try it as a function name
	 Find the next token(everything up to end or next blank). */

      p = dl1_find_next_token (argptr);
      copy = (char *) alloca (p - *argptr + 1);
      memcpy (copy, *argptr, p - *argptr);
      copy[p - *argptr] = '\0';
      if (p != *argptr
	  && copy[p - *argptr - 1]
	  && strchr (get_gdb_completer_quote_characters (),
		     copy[p - *argptr - 1]) != NULL)
	copy[p - *argptr - 1] = '\0';
	      
      /* no line number may be specified */
      while (*p == ' ' || *p == '\t')
	p++;
      *argptr = p;

      sym_arr = (struct symbol **) alloca (total_number_of_methods (t)
					   * sizeof (struct symbol *));
      
      dl1_find_method (funfirstline, canonical, saved_arg, copy, t,
		       sym_class, sym_arr, values);
      
      return DO_RETURN;
    }
  else
    {
      return DO_NOTHING;
    }
}

static struct symbol *
dl1_locate_class_sym (char **argptr, char *p)
{
  char *p1;
  char *copy;
      
  /* Extract the class name.  */
  p1 = p;
  while (p != *argptr && p[-1] == ' ')
    --p;
  copy = (char *) alloca (p - *argptr + 1);
  memcpy (copy, *argptr, p - *argptr);
  copy[p - *argptr] = 0;
	  
  /* Discard the class name from the arg.  */
  p = p1 + (p1[0] == ':' ? 2 : 1);
  while (*p == ' ' || *p == '\t')
    p++;
  *argptr = p;

  return lookup_symbol (copy, NULL, STRUCT_NAMESPACE, NULL, NULL);
}

static char *
dl1_find_next_token (char **argptr)
{
  char *p;
  
  if (**argptr
      && strchr (get_gdb_completer_quote_characters (),
		 **argptr) != NULL)
    {
      p = skip_quoted (*argptr);
      *argptr = *argptr + 1;
    }
  else
    {
      p = *argptr;
      while (*p && *p != ' ' && *p != '\t' && *p != ',' && *p != ':')
	p++;
    }

  return p;
}

static void
dl1_find_method (int funfirstline, char ***canonical, char *saved_arg,
		 char *copy, struct type *t, struct symbol *sym_class,
		 struct symbol **sym_arr,
		 struct symtabs_and_lines *values)
{
  int i1 = dl1_count_methods (copy, t, sym_arr);

  if (i1 == 1)
    {
      /* There is exactly one field with that name.  */
      struct symbol *sym = sym_arr[0];

      if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)
	{
	  values->sals = xmalloc (sizeof (struct symtab_and_line));
	  values->nelts = 1;
	  values->sals[0] = find_function_start_sal (sym, funfirstline);
	}
      else
	{
	  values->nelts = 0;
	}
    }
  else if (i1 > 0)
    {
      /* There is more than one field with that name
	 (overloaded).  Ask the user which one to use.  */
      *values = decode_line_2 (sym_arr, i1, funfirstline, canonical);
    }
  else
    {
      char *tmp;
	  
      if (is_operator_name (copy))
	{
	  tmp = (char *) alloca (strlen (copy + 3) + 9);
	  strcpy (tmp, "operator ");
	  strcat (tmp, copy + 3);
	}
      else
	tmp = copy;
      if (tmp[0] == '~')
	cplusplus_error (saved_arg,
			 "the class `%s' does not have destructor defined\n",
			 SYMBOL_SOURCE_NAME (sym_class));
      else
	cplusplus_error (saved_arg,
			 "the class %s does not have any method named %s\n",
			 SYMBOL_SOURCE_NAME (sym_class), tmp);
    }
}

static int
dl1_count_methods (char *copy, struct type *t, struct symbol **sym_arr)
{
  int i1 = 0;	/*  counter for the symbol array */
  
  if (destructor_name_p (copy, t))
    {
      /* Destructors are a special case.  */
      int m_index, f_index;
      
      if (get_destructor_fn_field (t, &m_index, &f_index))
	{
	  struct fn_field *f = TYPE_FN_FIELDLIST1 (t, m_index);
	  
	  sym_arr[i1] =
	    lookup_symbol (TYPE_FN_FIELD_PHYSNAME (f, f_index),
			   NULL, VAR_NAMESPACE, (int *) NULL,
			   (struct symtab **) NULL);
	  if (sym_arr[i1])
	    i1++;
	}
    }
  else
    i1 = find_methods (t, copy, sym_arr);

  return i1;
}

static void
dl1_handle_filename (char **argptr, char *p, int is_quote_enclosed,
		     struct symtab **s)
{
  char *p1;
  char *copy;
  
  /* Extract the file name.  */
  p1 = p;
  while (p != *argptr && p[-1] == ' ')
    --p;
  if ((*p == '"') && is_quote_enclosed)
    --p;
  copy = (char *) alloca (p - *argptr + 1);
  memcpy (copy, *argptr, p - *argptr);
  /* It may have the ending quote right after the file name */
  if (is_quote_enclosed && copy[p - *argptr - 1] == '"')
    copy[p - *argptr - 1] = 0;
  else
    copy[p - *argptr] = 0;
      
  /* Find that file's data.  */
  *s = lookup_symtab (copy);
  if (*s == 0)
    {
      if (!have_full_symbols () && !have_partial_symbols ())
	error ("No symbol table is loaded.  Use the \"file\" command.");
      error ("No source file named %s.", copy);
    }
  
  /* Discard the file name from the arg.  */
  p = p1 + 1;
  while (*p == ' ' || *p == '\t')
    p++;
  *argptr = p;
@


1.22.2.6
log
@2002-11-01  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (dl1_set_flags): Change arguments.
	(dl1_compound): Rename from dl1_multipart_compound, and shuffle
	components.
	(dl1_examine_compound_token): Change call structure.
	(dl1_find_method): Ditto.
	(dl1_handle_filename): Ditto.
	(dl1_is_all_digits): New function.
	(dl1_all_digits): Ditto.
	(dl1_skip_digits): Ditto.
	(dl1_dollar): Ditto.
	(dl1_variable): Ditto.
	(dl1_symbol_found): Ditto.
	(dl1_minsym_found): Ditto.
	(decode_line_1): Slim down dramatically.
@
text
@d62 1
a62 1
static void dl1_set_flags (char *arg, int *is_quoted,
d65 1
a65 7
static char *dl1_locate_first_half (char **argptr, int *is_quote_enclosed);

static struct symtabs_and_lines dl1_compound (char **argptr,
					      int funfirstline,
					      char ***canonical,
					      char *saved_arg,
					      char *p);
d67 2
a68 1
static int dl1_examine_compound_token (char **argptr,
d72 6
a77 1
				       char *p,
d80 22
d106 6
a111 7
static struct symtabs_and_lines dl1_find_method (int funfirstline,
						 char ***canonical,
						 char *saved_arg,
						 char *copy,
						 struct type *t,
						 struct symbol *sym_class,
						 struct symbol **sym_arr);
d116 3
a118 37
static struct symtab *dl1_handle_filename (char **argptr, char *p,
					    int is_quote_enclosed);

static int dl1_is_all_digits (char *arg);

static struct symtabs_and_lines dl1_all_digits (char **argptr,
						struct symtab *default_symtab,
						int default_line,
						char ***canonical,
						struct symtab *file_symtab);

static char *dl1_skip_digits (char *arg);

static struct symtabs_and_lines dl1_dollar (char **argptr,
					    int funfirstline,
					    struct symtab *default_symtab,
					    char ***canonical,
					    struct symtab *file_symtab);

static struct symtabs_and_lines dl1_variable (char **argptr,
					      int funfirstline,
					      char ***canonical,
					      int is_quoted,
					      char *paren_pointer,
					      struct symtab *file_symtab);

static struct
symtabs_and_lines dl1_symbol_found (int funfirstline,
				    char ***canonical,
				    char *copy,
				    struct symbol *sym,
				    struct symtab *file_symtab,
				    struct symtab *sym_symtab);

static struct
symtabs_and_lines dl1_minsym_found (int funfirstline,
				    struct minimal_symbol *msymbol);
d575 4
d582 8
a589 2
  /* If a file name is specified, this is its symtab.  */
  struct symtab *file_symtab = NULL;
d591 1
d594 2
d611 1
a611 1
  dl1_set_flags (*argptr, &is_quoted, &paren_pointer);
d613 1
a613 1
  /* Check to see if it's a multipart linespec (with colons or periods).  */
d615 47
a661 5
    char *p;
    int is_quote_enclosed;
    
    /* Locate the first half of the linespec, ending in a colon, period,
       or whitespace.  (More or less.)  */
d663 2
a664 1
    p = dl1_locate_first_half (argptr, &is_quote_enclosed);
d666 5
a670 1
    /* Does it look like there actually were two parts?  */
d672 3
a674 10
    if ((p[0] == ':' || p[0] == '.') && paren_pointer == NULL)
      {
	if (is_quoted)
	  *argptr = *argptr + 1;
      
	/* Is it a C++ or Java compound data structure?  */
      
	if (p[0] == '.' || p[1] == ':')
	  return dl1_compound (argptr, funfirstline, canonical,
			       saved_arg, p);
d676 3
a678 2
	/* No, the first part is a filename; set file_symtab
	   accordingly.  Also, move argptr past the filename.  */
d680 3
a682 3
	file_symtab = dl1_handle_filename (argptr, p, is_quote_enclosed);
      }
  }
d684 24
a707 1
  /* Check whether arg is all digits (and sign) */
d709 22
a730 3
  if (dl1_is_all_digits (*argptr))
    return dl1_all_digits (argptr, default_symtab, default_line,
			   canonical, file_symtab);
d735 32
d770 64
a833 5
  
  if (**argptr == '$')
    return dl1_dollar (argptr, funfirstline, default_symtab, canonical,
		       file_symtab);
  
d837 85
a921 2
  return dl1_variable (argptr, funfirstline, canonical, is_quoted,
		       paren_pointer, file_symtab);
d969 1
a969 1
dl1_set_flags (char *arg, int *is_quoted, char **paren_pointer)
d977 6
a982 6
  if ((ii = strstr (arg, " if ")) != NULL ||
      (ii = strstr (arg, "\tif ")) != NULL ||
      (ii = strstr (arg, " if\t")) != NULL ||
      (ii = strstr (arg, "\tif\t")) != NULL ||
      (ii = strstr (arg, " if(")) != NULL ||
      (ii = strstr (arg, "\tif( ")) != NULL)
d1001 1
a1001 1
  *is_quoted = (*arg
d1003 1
a1003 1
			   *arg) != NULL);
d1005 1
a1005 1
  *paren_pointer = strchr (arg, '(');
d1017 41
d1148 7
a1154 3
static struct symtabs_and_lines
dl1_compound (char **argptr, int funfirstline, char ***canonical,
	      char *saved_arg, char *p)
a1158 3
  char *copy;
  struct symtab *sym_symtab;
  struct symbol *sym;
d1190 6
a1195 5
      struct symtabs_and_lines values;
      
      if (dl1_examine_compound_token (argptr, funfirstline, canonical,
				      saved_arg, p, &values))
	return values;
d1216 1
a1216 1
	break;
d1220 1
a1220 1
    }
d1223 4
a1226 2
  copy = alloca (p - saved_arg2 + 1);
  memcpy (copy, saved_arg2, p - saved_arg2);
d1228 1
a1228 1
  copy[p - saved_arg2] = '\0';
d1232 12
a1243 5
  sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0, &sym_symtab);

  if (sym != NULL)
    return dl1_symbol_found (funfirstline, canonical, copy,
			     sym, NULL, sym_symtab);
d1246 2
d1251 1
a1251 1
		   copy);
d1254 1
a1254 1
static int
d1298 2
a1299 2
      *values = dl1_find_method (funfirstline, canonical, saved_arg, copy,
				 t, sym_class, sym_arr);
d1301 1
a1301 1
      return 1;
d1305 1
a1305 1
      return 0;
d1354 1
a1354 1
static struct symtabs_and_lines
d1357 2
a1358 1
		 struct symbol **sym_arr)
a1359 1
  struct symtabs_and_lines values;
d1369 3
a1371 3
	  values.sals = xmalloc (sizeof (struct symtab_and_line));
	  values.nelts = 1;
	  values.sals[0] = find_function_start_sal (sym, funfirstline);
d1375 1
a1375 1
	  values.nelts = 0;
d1382 1
a1382 1
      values = decode_line_2 (sym_arr, i1, funfirstline, canonical);
a1404 2

  return values;
d1435 3
a1437 2
static struct symtab *
dl1_handle_filename (char **argptr, char *p, int is_quote_enclosed)
a1440 1
  struct symtab *s;
d1457 2
a1458 2
  s = lookup_symtab (copy);
  if (s == NULL)
a1469 325

  return s;
}

static int
dl1_is_all_digits (char *arg)
{
  char *q = dl1_skip_digits (arg);

  return q != arg && (*q == 0 || *q == ' ' || *q == '\t' || *q == ',');
}

static struct symtabs_and_lines
dl1_all_digits (char **argptr, struct symtab *default_symtab,
		int default_line, char ***canonical,
		struct symtab *file_symtab)
{
  struct symtabs_and_lines values;
  struct symtab_and_line val;
  char *end_of_digits = dl1_skip_digits (*argptr);

  enum sign
    {
      none, plus, minus
    }
  sign = none;

  init_sal (&val);

  /* We might need a canonical line spec if no file was specified.  */
  int need_canonical = (file_symtab == NULL) ? 1 : 0;

  /* This is where we need to make sure that we have good defaults.
     We must guarantee that this section of code is never executed
     when we are called with just a function name, since
     set_default_source_symtab_and_line uses
     select_source_symtab that calls us with such an argument  */

  if (file_symtab == NULL && default_symtab == NULL)
    {
      struct symtab_and_line cursal;
	  
      /* Make sure we have at least a default source file. */
      set_default_source_symtab_and_line ();
      cursal = get_current_source_symtab_and_line ();
      
      default_symtab = cursal.symtab;
      default_line = cursal.line;
    }

  if (**argptr == '+')
    sign = plus, (*argptr)++;
  else if (**argptr == '-')
    sign = minus, (*argptr)++;
  val.line = atoi (*argptr);
  switch (sign)
    {
    case plus:
      if (end_of_digits == *argptr)
	val.line = 5;
      if (file_symtab == NULL)
	val.line = default_line + val.line;
      break;
    case minus:
      if (end_of_digits == *argptr)
	val.line = 15;
      if (file_symtab == NULL)
	val.line = default_line - val.line;
      else
	val.line = 1;
      break;
    case none:
      break;		/* No need to adjust val.line.  */
    }

  while (*end_of_digits == ' ' || *end_of_digits == '\t')
    end_of_digits++;
  *argptr = end_of_digits;
  if (file_symtab == 0)
    file_symtab = default_symtab;

  /* It is possible that this source file has more than one symtab, 
     and that the new line number specification has moved us from the
     default (in file_symtab) to a new one.  */
  val.symtab = find_line_symtab (file_symtab, val.line, NULL, NULL);
  if (val.symtab == 0)
    val.symtab = file_symtab;

  val.pc = 0;
  values.sals = xmalloc (sizeof (struct symtab_and_line));
  values.sals[0] = val;
  values.nelts = 1;
  if (need_canonical)
    build_canonical_line_spec (values.sals, NULL, canonical);
  return values;
}

static char *
dl1_skip_digits (char *arg)
{
  if (*arg == '-' || *arg == '+')
    arg++;
  while (*arg >= '0' && *arg <= '9')
    arg++;

  return arg;
}

static struct symtabs_and_lines
dl1_dollar (char **argptr, int funfirstline, struct symtab *default_symtab,
	    char ***canonical, struct symtab *file_symtab)
{
  struct value *valx;
  int index = 0;
  int need_canonical = 0;
  char *p;
  struct symtabs_and_lines values;
  char *copy;

  /* One or two $ chars possible */
  p = skip_quoted (*argptr + (((*argptr)[1] == '$') ? 2 : 1));

  copy = (char *) alloca (p - *argptr + 1);
  memcpy (copy, *argptr, p - *argptr);
  copy[p - *argptr] = '\0';

  while (*p == ' ' || *p == '\t')
    p++;
  *argptr = p;
  
  p = (copy[1] == '$') ? copy + 2 : copy + 1;
  while (*p >= '0' && *p <= '9')
    p++;
  if (!*p)		/* reached end of token without hitting non-digit */
    {
      /* We have a value history reference */
      sscanf ((copy[1] == '$') ? copy + 2 : copy + 1, "%d", &index);
      valx = access_value_history ((copy[1] == '$') ? -index : index);
      if (TYPE_CODE (VALUE_TYPE (valx)) != TYPE_CODE_INT)
	error ("History values used in line specs must have integer values.");
    }
  else
    {
      /* Not all digits -- may be user variable/function or a
	 convenience variable */

      struct symbol *sym;
      struct symtab *sym_symtab;
      struct minimal_symbol *msymbol;
      
      /* Look up entire name as a symbol first */
      sym = lookup_symbol (copy, 0, VAR_NAMESPACE, 0, &sym_symtab);
      if (sym != NULL)
	return dl1_symbol_found (funfirstline, canonical, copy,
				 sym, NULL, sym_symtab);

      /* If symbol was not found, look in minimal symbol tables */
      msymbol = lookup_minimal_symbol (copy, NULL, NULL);
      if (msymbol != NULL)
	return dl1_minsym_found (funfirstline, msymbol);

      /* Not a user variable or function -- must be convenience variable */
      file_symtab = NULL;
      need_canonical = 1;
      valx = value_of_internalvar (lookup_internalvar (copy + 1));
      if (TYPE_CODE (VALUE_TYPE (valx)) != TYPE_CODE_INT)
	error ("Convenience variables used in line specs must have integer values.");
    }

  /* Either history value or convenience value from above, in valx */
  values.sals = xmalloc (sizeof (struct symtab_and_line));
  init_sal (values.sals);
  values.sals[0].symtab  = file_symtab != NULL ? file_symtab : default_symtab;
  values.sals[0].line = value_as_long (valx);
  values.sals[0].pc = 0;
  values.nelts = 1;

  if (need_canonical)
    build_canonical_line_spec (values.sals, NULL, canonical);

  return values;
}

static struct symtabs_and_lines
dl1_variable (char **argptr, int funfirstline, char ***canonical,
	      int is_quoted, char *paren_pointer,
	      struct symtab *file_symtab)
{
  char *p;
  char *copy;
  struct symbol *sym;
  struct symtab *sym_symtab;
  struct minimal_symbol *msymbol;

  if (is_quoted)
    {
      p = skip_quoted (*argptr);
      if (p[-1] != '\'')
	error ("Unmatched single quote.");
    }
  else if (paren_pointer != NULL)
    {
      p = paren_pointer + 1;
    }
  else
    {
      p = skip_quoted (*argptr);
    }

  copy = (char *) alloca (p - *argptr + 1);
  memcpy (copy, *argptr, p - *argptr);
  copy[p - *argptr] = '\0';

  /* If it's completer-quoted, get rid of the quotes.  */

  if (p != *argptr
      && copy[0]
      && copy[0] == copy[p - *argptr - 1]
      && strchr (get_gdb_completer_quote_characters (), copy[0]) != NULL)
    {
      copy[p - *argptr - 1] = '\0';
      copy++;
    }
  
  while (*p == ' ' || *p == '\t')
    p++;
  *argptr = p;

  /* Look up that token as a variable.
     If file specified, use that file's per-file block to start with.  */

  sym = lookup_symbol (copy,
		       (file_symtab != NULL
			? BLOCKVECTOR_BLOCK (BLOCKVECTOR (file_symtab),
					     STATIC_BLOCK)
			: get_selected_block (0)),
		       VAR_NAMESPACE, 0, &sym_symtab);

  if (sym != NULL)
    {
      return dl1_symbol_found (funfirstline, canonical, copy,
			       sym, file_symtab, sym_symtab);
    }

  msymbol = lookup_minimal_symbol (copy, NULL, NULL);

  if (msymbol != NULL)
    return dl1_minsym_found (funfirstline, msymbol);

  if (!have_full_symbols () &&
      !have_partial_symbols () && !have_minimal_symbols ())
    error ("No symbol table is loaded.  Use the \"file\" command.");

  error ("Function \"%s\" not defined.", copy);
}

static struct symtabs_and_lines
dl1_symbol_found (int funfirstline, char ***canonical, char *copy,
		  struct symbol *sym, struct symtab *file_symtab,
		  struct symtab *sym_symtab)
{
  struct symtabs_and_lines values;
  
  if (SYMBOL_CLASS (sym) == LOC_BLOCK)
    {
      /* Arg is the name of a function */
      values.sals = xmalloc (sizeof (struct symtab_and_line));
      values.sals[0] = find_function_start_sal (sym, funfirstline);
      values.nelts = 1;

      /* Don't use the SYMBOL_LINE; if used at all it points to
	 the line containing the parameters or thereabouts, not
	 the first line of code.  */

      /* We might need a canonical line spec if it is a static
	 function.  */
      if (file_symtab == NULL)
	{
	  struct blockvector *bv = BLOCKVECTOR (sym_symtab);
	  struct block *b = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
	  if (lookup_block_symbol (b, copy, NULL, VAR_NAMESPACE) != NULL)
	    build_canonical_line_spec (values.sals, copy, canonical);
	}
      return values;
    }
  else
    {
      if (funfirstline)
	error ("\"%s\" is not a function", copy);
      else if (SYMBOL_LINE (sym) != 0)
	{
	  /* We know its line number.  */
	  values.sals = xmalloc (sizeof (struct symtab_and_line));
	  values.nelts = 1;
	  memset (&values.sals[0], 0, sizeof (values.sals[0]));
	  values.sals[0].symtab = sym_symtab;
	  values.sals[0].line = SYMBOL_LINE (sym);
	  return values;
	}
      else
	/* This can happen if it is compiled with a compiler which doesn't
	   put out line numbers for variables.  */
	/* FIXME: Shouldn't we just set .line and .symtab to zero
	   and return?  For example, "info line foo" could print
	   the address.  */
	error ("Line number not known for symbol \"%s\"", copy);
    }
}

static struct symtabs_and_lines
dl1_minsym_found (int funfirstline, struct minimal_symbol *msymbol)
{
  struct symtabs_and_lines values;
  
  values.sals = xmalloc (sizeof (struct symtab_and_line));
  values.sals[0] = find_pc_sect_line (SYMBOL_VALUE_ADDRESS (msymbol),
				      (struct sec *) 0, 0);
  values.sals[0].section = SYMBOL_BFD_SECTION (msymbol);
  if (funfirstline)
    {
      values.sals[0].pc += FUNCTION_START_OFFSET;
      values.sals[0].pc = SKIP_PROLOGUE (values.sals[0].pc);
    }
  values.nelts = 1;
  return values;
@


1.22.2.7
log
@2002-11-04  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (initialize_defaults): Rename from
	dl1_initialize_defaults.
	(set_flags): Rename from dl1_set_flags.
	(decode_line_1): Set flags before decoding indirect.
	(decode_indirect): Rename from dl1_indirect.
	(set_flags): Miscellaneous cleanup.
	(decode_indirect): Miscellaneous cleanup.
	Move around some functions and declarations.
@
text
@a42 7
static void initialize_defaults (struct symtab **default_symtab,
				 int *default_line);

static void set_flags (char *arg, int *is_quoted, char **paren_pointer);

static struct symtabs_and_lines decode_indirect (char **argptr);

d57 8
a132 244
/* The parser of linespec itself. */

/* Parse a string that specifies a line number.
   Pass the address of a char * variable; that variable will be
   advanced over the characters actually parsed.

   The string can be:

   LINENUM -- that line number in current file.  PC returned is 0.
   FILE:LINENUM -- that line in that file.  PC returned is 0.
   FUNCTION -- line number of openbrace of that function.
   PC returned is the start of the function.
   VARIABLE -- line number of definition of that variable.
   PC returned is 0.
   FILE:FUNCTION -- likewise, but prefer functions in that file.
   *EXPR -- line in which address EXPR appears.

   This may all be followed by an "if EXPR", which we ignore.

   FUNCTION may be an undebuggable function found in minimal symbol table.

   If the argument FUNFIRSTLINE is nonzero, we want the first line
   of real code inside a function when a function is specified, and it is
   not OK to specify a variable or type to get its line number.

   DEFAULT_SYMTAB specifies the file to use if none is specified.
   It defaults to current_source_symtab.
   DEFAULT_LINE specifies the line number to use for relative
   line numbers (that start with signs).  Defaults to current_source_line.
   If CANONICAL is non-NULL, store an array of strings containing the canonical
   line specs there if necessary. Currently overloaded member functions and
   line numbers or static functions without a filename yield a canonical
   line spec. The array and the line spec strings are allocated on the heap,
   it is the callers responsibility to free them.

   Note that it is possible to return zero for the symtab
   if no file is validly specified.  Callers must check that.
   Also, the line number returned may be invalid.  */

/* We allow single quotes in various places.  This is a hideous
   kludge, which exists because the completer can't yet deal with the
   lack of single quotes.  FIXME: write a linespec_completer which we
   can use as appropriate instead of make_symbol_completion_list.  */

/* Everything else in this file is a helper function for
   decode_line_1.  */

/* FIXME: carlton/2002-11-04: It would be nice for ARGPTR to be a
   const char **.  But, alas, that can't easily be fixed right now:
   for one thing, some functions actually do temporarily modify some
   of the chars in question (e.g. is_quoted), and, for another thing,
   GCC would seem not to be to thrilled about implicit conversions
   from char ** to const char **.  */

struct symtabs_and_lines
decode_line_1 (char **argptr, int funfirstline, struct symtab *default_symtab,
	       int default_line, char ***canonical)
{
  /* This is NULL if there are no parens in *ARGPTR, or a pointer to
     the closing parenthesis if there are parens.  */
  char *paren_pointer;
  /* This says whether or not something in *ARGPTR is quoted with
     completer_quotes (i.e. with single quotes).  */
  int is_quoted;
  /* If a file name is specified, this is its symtab.  */
  struct symtab *file_symtab = NULL;
  /* This function advances *ARGPTR, but, for error messages, we want
     to remember what it pointed to initially.  */
  char *saved_arg = *argptr;

  /* Defaults have defaults.  */

  initialize_defaults (&default_symtab, &default_line);
  
  /* Set various flags.
   * 'paren_pointer' is important for overload checking, where
   * we allow things like: 
   *     (gdb) break c::f(int)
   */

  set_flags (*argptr, &is_quoted, &paren_pointer);

  /* See if arg is *PC */

  if (**argptr == '*')
    return decode_indirect (argptr);

  /* Check to see if it's a multipart linespec (with colons or periods).  */
  {
    char *p;
    int is_quote_enclosed;
    
    /* Locate the first half of the linespec, ending in a colon, period,
       or whitespace.  (More or less.)  */

    p = dl1_locate_first_half (argptr, &is_quote_enclosed);

    /* Does it look like there actually were two parts?  */

    if ((p[0] == ':' || p[0] == '.') && paren_pointer == NULL)
      {
	if (is_quoted)
	  *argptr = *argptr + 1;
      
	/* Is it a C++ or Java compound data structure?  */
      
	if (p[0] == '.' || p[1] == ':')
	  return dl1_compound (argptr, funfirstline, canonical,
			       saved_arg, p);

	/* No, the first part is a filename; set file_symtab
	   accordingly.  Also, move argptr past the filename.  */
      
	file_symtab = dl1_handle_filename (argptr, p, is_quote_enclosed);
      }
  }

  /* Check whether arg is all digits (and sign) */

  if (dl1_is_all_digits (*argptr))
    return dl1_all_digits (argptr, default_symtab, default_line,
			   canonical, file_symtab);

  /* Arg token is not digits => try it as a variable name
     Find the next token (everything up to end or next whitespace).  */

  /* If it starts with $: may be a legitimate variable or routine name
     (e.g. HP-UX millicode routines such as $$dyncall), or it may
     be history value, or it may be a convenience variable */
  
  if (**argptr == '$')
    return dl1_dollar (argptr, funfirstline, default_symtab, canonical,
		       file_symtab);
  
  /* Look up that token as a variable.
     If file specified, use that file's per-file block to start with.  */

  return dl1_variable (argptr, funfirstline, canonical, is_quoted,
		       paren_pointer, file_symtab);
}



/* Now, the helper functions.  */

/* NOTE: carlton/2002-11-04: Some of these have non-obvious side
   effects.  In particular, if a function is passed ARGPTR as an
   argument, it probably modifies what ARGPTR points to.  */

/* First, some functions to initialize stuff at the beggining of the
   function.  */

static void
initialize_defaults (struct symtab **default_symtab, int *default_line)
{
  if (*default_symtab == NULL)
    {
      /* Use whatever we have for the default source line.  We don't use
         get_current_or_default_symtab_and_line as it can recurse and call
	 us back! */
      struct symtab_and_line cursal
	= get_current_source_symtab_and_line ();
      
      *default_symtab = cursal.symtab;
      *default_line = cursal.line;
    }
}

static void
set_flags (char *arg, int *is_quoted, char **paren_pointer)
{
  char *if_index;
  char *paren_start;
  int has_if = 0;
  
  /* 'has_if' is for the syntax:
   *     (gdb) break foo if (a==b)
   */
  if ((if_index = strstr (arg, " if ")) != NULL ||
      (if_index = strstr (arg, "\tif ")) != NULL ||
      (if_index = strstr (arg, " if\t")) != NULL ||
      (if_index = strstr (arg, "\tif\t")) != NULL ||
      (if_index = strstr (arg, " if(")) != NULL ||
      (if_index = strstr (arg, "\tif( ")) != NULL)
    has_if = 1;
  /* Temporarily zap out "if (condition)" to not
   * confuse the parenthesis-checking code below.
   * This is undone below. Do not change if_index!!
   */
  if (has_if)
    {
      *if_index = '\0';
    }

  /* Set various flags.
   * 'paren_pointer' is important for overload checking, where
   * we allow things like: 
   *     (gdb) break c::f(int)
   */

  /* Maybe arg is FILE : LINENUM or FILE : FUNCTION */

  *is_quoted = (*arg && (strchr (get_gdb_completer_quote_characters (),
				 *arg)
			 != NULL));

  paren_start = strchr (arg, '(');

  if (paren_start != NULL)
    *paren_pointer = strrchr (paren_start, ')');
  else
    *paren_pointer = NULL;

  /* Now that we're safely past the has_parens check,
   * put back " if (condition)" so outer layers can see it 
   */
  if (has_if)
    *if_index = ' ';
}



/* Decode arg of the form *PC.  */

static struct symtabs_and_lines
decode_indirect (char **argptr)
{
  struct symtabs_and_lines values;
  CORE_ADDR pc;

  (*argptr)++;				/* Skip the initial asterisk.  */
  pc = parse_and_eval_address_1 (argptr);

  values.sals = xmalloc (sizeof (struct symtab_and_line));

  values.nelts = 1;
  values.sals[0] = find_pc_line (pc, 0);
  values.sals[0].pc = pc;
  values.sals[0].section = find_pc_overlay (pc);

  return values;
}


d538 220
@


1.22.2.8
log
@2002-11-06  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c: Delete declaration of operator_chars.

	* symtab.c (lookup_symbol_aux): Add comment.

	* linespec.c: Update copyright notice.
	(examine_compound_token): Rename from dl1_examine_compound_token.
	Misc. cleanups.
	(locate_class_sym): Rename from dl1_locate_class_sym.
	(decode_compound): Misc. cleanup.
	(symbol_found): Rename from dl1_symbol_found; misc. cleanup.
	(find_next_token): Rename from dl1_find_next_token; misc. cleanup.
	(find_method): Rename from dl1_find_method.  Delete sym_arr
	argument.  Misc. cleanup.
	(count_methods): Rename from dl1_find_method.  Reorder arguments
	to match find_methods.  Misc. cleanup.
	(find_method_name): New function.
	(add_matching_methods): New function.
	(add_constructors): New fnuction.
	(find_methods): Separate out some of code into find_method_name,
	add_matching_methods, and add_constructors; misc. cleanup.
	(is_all_digits): Rename from dl1_is_all_digits.
	(decode_all_digits): Rename from dl1_all_digits.  Don't set
	defaults: we already did that in initialize_defaults.
	(skip_digits): Rename from dl1_skip_digits.
	(handle_filename): Rename from dl1_handle_filename;
	misc. cleanup.
	(minsym_found): Rename from dl1_minsym_found; misc. cleanup.
	(decode_dollar): Rename from dl1_decode_dollar; misc. cleanup.
	(build_canonical_line_spec): Misc. cleanup.
	(find_toplevel_char): Move; change 0 to NULL.
	(decode_variable): Rename from dl1_variable; misc. cleanup.
	(select_symbols): Rename from decode_line_2; misc. cleanup; fork
	out some code into select_symbols_args.
	(select_symbols_args): New function.
	(decode_line_1): Misc. cleanup.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002
d37 5
a41 1
/* Prototypes for local functions.  */
d50 1
a50 1
static char *locate_first_half (char **argptr, int *is_quote_enclosed);
d52 1
a52 1
static char *find_toplevel_char (char *s, char c);
d54 1
a54 5
static struct symtabs_and_lines decode_compound (char **argptr,
						 int funfirstline,
						 char ***canonical,
						 char *saved_arg,
						 char *next_component);
d56 2
a57 6
static int examine_compound_token (char **argptr,
				   int funfirstline,
				   char ***canonical,
				   char *saved_arg,
				   char *p,
				   struct symtabs_and_lines *values);
d59 1
a59 3
static struct symbol *locate_class_sym (char **argptr, char *p);

static char *find_next_token (char **argptr);
d61 2
a62 40
static int total_number_of_methods (struct type *type);

static struct symtabs_and_lines find_method (int funfirstline,
					     char ***canonical,
					     char *saved_arg,
					     char *method,
					     struct type *class_type,
					     struct symbol *class_sym);

static int count_methods (struct type *class_type, char *method,
			  struct symbol **sym_arr);

static int find_methods (struct type *class_type, char *method,
			 struct symbol **sym_arr);

static char *find_method_name (struct type *class_type, int method_counter,
			       char *dem_opname);

static int add_matching_methods (int method_counter, struct type *class_type,
				 struct symbol **sym_arr);

static int add_constructors (int method_counter, struct type *class_type,
			     struct symbol **sym_arr);

static struct symtabs_and_lines select_symbols (struct symbol **sym_arr,
						int nelts,
						int funfirstline,
						char ***canonical);

static struct
symtabs_and_lines select_symbols_args (struct symbol **sym_arr,
				       int nelts,
				       char *args,
				       char **canonical_arr,
				       struct symtabs_and_lines values,
				       struct cleanup *old_chain);

static NORETURN void cplusplus_error (const char *name,
				      const char *fmt, ...)
     ATTR_NORETURN ATTR_FORMAT (printf, 2, 3);
d64 1
a64 2
static struct symtab *handle_filename (char **argptr, char *filename_end,
				       int is_quote_enclosed);
d66 5
a70 1
static int is_all_digits (char *arg);
d72 6
a77 6
static struct
symtabs_and_lines decode_all_digits (char **argptr,
				    struct symtab *default_symtab,
				    int default_line,
				    char ***canonical,
				    struct symtab *file_symtab);
d79 1
a79 1
static char *skip_digits (char *arg);
d81 1
a81 5
static struct symtabs_and_lines decode_dollar (char **argptr,
					       int funfirstline,
					       struct symtab *default_symtab,
					       char ***canonical,
					       struct symtab *file_symtab);
d83 1
a83 2
static struct symtabs_and_lines decode_variable (char **argptr,
						 int funfirstline,
d85 34
a118 7
						 int is_quoted,
						 char *paren_pointer,
						 struct symtab *file_symtab);

static void build_canonical_line_spec (struct symtab_and_line *sal,
				       char *symname,
				       char ***canonical);
d121 6
a126 6
symtabs_and_lines symbol_found (int funfirstline,
				char ***canonical,
				char *copy,
				struct symbol *sym,
				struct symtab *file_symtab,
				struct symtab *sym_symtab);
d129 2
a130 2
symtabs_and_lines minsym_found (int funfirstline,
				struct minimal_symbol *msymbol);
d132 1
a132 1
/* The parser of linespec itself.  */
d214 1
a214 1
  /* See if arg is *PC.  */
d219 1
a219 2
  /* Check to see if it's a multipart linespec (with colons or
     periods).  */
a221 1
    /* Is part of *ARGPTR is enclosed in double quotes?  */
d224 2
a225 1
    /* Locate the end of the first half of the linespec.  */
d227 1
a227 1
    p = locate_first_half (argptr, &is_quote_enclosed);
d239 2
a240 2
	  return decode_compound (argptr, funfirstline, canonical,
				  saved_arg, p);
d245 1
a245 1
	file_symtab = handle_filename (argptr, p, is_quote_enclosed);
d249 1
a249 1
  /* Check whether arg is all digits (and sign).  */
d251 3
a253 3
  if (is_all_digits (*argptr))
    return decode_all_digits (argptr, default_symtab, default_line,
			      canonical, file_symtab);
d255 2
a256 1
  /* Arg token is not digits => try it as a variable name.  */
d260 1
a260 1
     be history value, or it may be a convenience variable.  */
d263 2
a264 2
    return decode_dollar (argptr, funfirstline, default_symtab, canonical,
			  file_symtab);
d266 2
a267 2
  /* Look up that token as a variable.  If file specified, use that
     file's per-file block to start with.  */
d269 2
a270 2
  return decode_variable (argptr, funfirstline, canonical, is_quoted,
			  paren_pointer, file_symtab);
d279 1
a279 10
   argument, it modifies what ARGPTR points to.  (Typically, it
   advances *ARGPTR past whatever substring it has just looked
   at.)  */

/* NOTE: carlton/2002-11-06: Some of these functions are a little
   longer than I would like.  Note, however, that some of the length
   comes from frequent use of alloca, leading to code that can't be
   refactored so easily: you can't return memory allocated with alloca
   from a function.  There are times when it would be nice to program
   in a language with a string datatype.  */
d291 1
a291 1
	 us back!  */
d317 4
a320 3
  /* Temporarily zap out "if (condition)" to not confuse the
     parenthesis-checking code below.  This is undone below. Do not
     change if_index!!  */
d345 3
a347 2
  /* Now that we're safely past the has_parens check, put back " if
     (condition)" so outer layers can see it.  */
a374 1

d376 406
a781 10
/* Locate the first half of the linespec, ending in a colon, period,
   or whitespace.  (More or less.)  Also, check to see if *ARGPTR is
   enclosed in double quotes; if so, set is_quote_enclosed, advance
   ARGPTR past that and zero out the trailing double quote.  */

/* FIXME: carlton/2002-11-05: Is zeroing out the trailing double quote
   really the right thing to do?  It never seems to be restored
   anywhere: also, decode_compound ignores is_quote_enclosed entirely,
   while handle_filename seems to expect the double quote to still be
   present.  Sigh...  */
d784 1
a784 1
locate_first_half (char **argptr, int *is_quote_enclosed)
d786 1
a786 1
  char *comma_index;
d799 2
a800 2
  comma_index = find_toplevel_char (*argptr, ',');
  has_comma = (comma_index != NULL);
d802 4
a805 2
  /* Temporarily zap out second half to not confuse the code below.
     This is undone below. Do not change comma_index!!  */
d808 1
a808 1
      *comma_index = '\0';
a823 1
  
d833 3
a835 5
      
      /* Check for the end of the first half of the linespec.  End of
         line, a tab, a double colon or the last single colon, or a
         space.  But if enclosed in double quotes we do not break on
         enclosed spaces.  */
d842 1
a842 3

      /* Java qualified method.  */
      if (p[0] == '.' && strchr (p, ':') == NULL)
d844 1
a844 2
	  /* Find the *last* '.', since the others are package
	     qualifiers.  */
a852 1
  
d856 1
a856 1
  /* If the closing double quote was left at the end, remove it.  */
d860 1
a860 1
      if (closing_quote != NULL && closing_quote[1] == '\0')
d864 3
a866 2
  /* Now that we've safely parsed the first half, put back ',' so
     outer layers can see it.  */
d868 1
a868 1
    *comma_index = ',';
a872 46
/* Find an instance of the character C in the string S that is outside
   of all parenthesis pairs, single-quoted strings, and double-quoted
   strings.  Also, ignore the char within a template name, like a ','
   within foo<int, int>.  */

static char *
find_toplevel_char (char *s, char c)
{
  char quoted = 0;		/* Zero if we're not in quotes;
				   '"' if we're in a double-quoted string;
				   '\'' if we're in a single-quoted string.  */
  int depth = 0;		/* Number of unclosed parens we've seen.  */
  char *scan;

  for (scan = s; *scan; scan++)
    {
      if (quoted)
	{
	  if (*scan == quoted)
	    quoted = 0;
	  else if (*scan == '\\' && *(scan + 1))
	    scan++;
	}
      else if (*scan == c && !quoted && depth == 0)
	return scan;
      else if (*scan == '"' || *scan == '\'')
	quoted = *scan;
      else if (*scan == '(' || *scan == '<')
	depth++;
      else if ((*scan == ')' || *scan == '>') && depth > 0)
	depth--;
    }

  return NULL;
}



/* This handles C++ and Java compound data structures.  After this
   function come a bunch of its helper functions.  (And helper
   functions for the helper functions, and so forth: this is by far
   the messiest part of decode_line_1.)  */

/* NEXT_COMPONENT should point at the first component separator,
   i.e. double-colon or period.  */

d874 2
a875 2
decode_compound (char **argptr, int funfirstline, char ***canonical,
		 char *saved_arg, char *next_component)
d879 1
d884 5
a888 7
  /* First check for "global" namespace specification, of the form
     "::foo".  If found, skip over the colons and jump to normal
     symbol processing.  */
  if (next_component[0] == ':' 
      && ((*argptr == next_component)
	  || (next_component[-1] == ' ')
	  || (next_component[-1] == '\t')))
d911 1
d915 3
a917 6
      char *current_component = next_component;

      /* See if we can get a useful response starting from the current
	 prefix.  */
      if (examine_compound_token (argptr, funfirstline, canonical,
				  saved_arg, next_component, &values))
d920 4
a923 8
      /* Move pointer up to next possible class/namespace token: look
	 for double colons starting after the one we just dealt
	 with.  */
      next_component = current_component + 1;
      while (*next_component
	     && (next_component[0] != ' ')
	     && (next_component[0] != '\t')
	     && (next_component[0] != '\''))
d925 1
a925 1
	  if (next_component[0] == '<')
d927 1
a927 1
	      temp_end = find_template_name_end (next_component);
d930 1
a930 1
	      next_component = temp_end;
d932 2
a933 3
	  else if ((next_component[0] == ':')
		   && (next_component[1] == ':'))
	    break;	/* Found double-colon.  */
d935 1
a935 1
	    next_component++;
d938 1
a938 1
      if (*next_component != ':')
d941 2
a942 1
      *argptr = saved_arg2;	/* Restore argptr.  */
d945 8
a952 8
  /* Last chance attempt -- check entire name as a symbol.  */
  copy = alloca (next_component - saved_arg2 + 1);
  memcpy (copy, saved_arg2, next_component - saved_arg2);
  /* Note: if is_quoted should be true, we snuff out quote here anyway.  */
  copy[next_component - saved_arg2] = '\0';
  /* Set argptr to skip over the name.  */
  *argptr = (*next_component == '\'') ? next_component + 1 : next_component;
  /* Look up entire name.  */
d956 2
a957 2
    return symbol_found (funfirstline, canonical, copy,
			 sym, NULL, sym_symtab);
d959 1
a959 1
  /* Couldn't find any interpretation as classes/namespaces, so give up.  */
a965 6
/* This checks to see if we can get a useful response by treating the
   substring of *ARGPTR ending at CURRENT_COMPONENT as a class name,
   and the rest as a method name.  If so, it puts a return value for
   decode_line_1 in *VALUES and returns 1; otherwise, it returns
   0.  */

d967 4
a970 4
examine_compound_token (char **argptr, int funfirstline,
			char ***canonical, 
			char *saved_arg, char *current_component,
			struct symtabs_and_lines *values)
d973 1
a973 1
  struct symbol *class_sym;
d976 2
a977 3
  /* If CURRENT_COMPONENT points at the end of a name of a class, find
     the corresponding symbol and advance ARGPTR past the end of the
     class.  */
d979 1
a979 1
  class_sym = locate_class_sym (argptr, current_component);
d981 4
a984 7
  if (class_sym == NULL)
    return 0;

  t = check_typedef (SYMBOL_TYPE (class_sym));

  if (TYPE_CODE (t) == TYPE_CODE_STRUCT
      || TYPE_CODE (t) == TYPE_CODE_UNION)
d986 5
a990 1
      /* Find the next token (everything up to end or next blank).  */
d992 9
a1000 10
      current_component = find_next_token (argptr);
      copy = alloca (current_component - *argptr + 1);
      memcpy (copy, *argptr, current_component - *argptr);
      copy[current_component - *argptr] = '\0';
      if (current_component != *argptr
	  && copy[current_component - *argptr - 1]
	  && (strchr (get_gdb_completer_quote_characters (),
		      copy[current_component - *argptr - 1])
	      != NULL))
	copy[current_component - *argptr - 1] = '\0';
d1002 4
a1005 3
      while (*current_component == ' ' || *current_component == '\t')
	current_component++;
      *argptr = current_component;
d1007 5
a1011 2
      *values = find_method (funfirstline, canonical, saved_arg, copy,
			     t, class_sym);
d1022 1
a1022 1
locate_class_sym (char **argptr, char *p)
d1031 1
a1031 1
  copy = alloca (p - *argptr + 1);
d1041 1
a1041 218
  return lookup_symbol (copy, NULL, STRUCT_NAMESPACE, NULL, NULL);
}

/* Find the next token (presumably a method name); if some of it is
   quoted, advance ARGPTR past the opening quote.  */

static char *
find_next_token (char **argptr)
{
  char *p;
  
  if (**argptr
      && (strchr (get_gdb_completer_quote_characters (),
		  **argptr)
	  != NULL))
    {
      p = skip_quoted (*argptr);
      *argptr = *argptr + 1;
    }
  else
    {
      p = *argptr;
      while (*p && *p != ' ' && *p != '\t' && *p != ',' && *p != ':')
	p++;
    }

  return p;
}

/* Return the number of methods described for TYPE, including the
   methods from types it derives from. This can't be done in the symbol
   reader because the type of the baseclass might still be stubbed
   when the definition of the derived class is parsed.  */

static int
total_number_of_methods (struct type *type)
{
  int n;
  int count;

  CHECK_TYPEDEF (type);
  if (TYPE_CPLUS_SPECIFIC (type) == NULL)
    return 0;
  count = TYPE_NFN_FIELDS_TOTAL (type);

  for (n = 0; n < TYPE_N_BASECLASSES (type); n++)
    count += total_number_of_methods (TYPE_BASECLASS (type, n));

  return count;
}

/* This finds the method METHOD in the class whose type is CLASS_TYPE
   and whose symbol is CLASS_SYM.  */

/* FIXME: carlton/2002-11-06: we only use CLASS_SYM to get the name of
   the class; probably we should just get that from CLASS_TYPE
   instead.  */

static struct symtabs_and_lines
find_method (int funfirstline, char ***canonical, char *saved_arg,
	     char *method, struct type *class_type,
	     struct symbol *class_sym)
{
  struct symtabs_and_lines values;
  struct symbol **sym_arr;
  int method_count;

  sym_arr = alloca (total_number_of_methods (class_type)
		    * sizeof (struct symbol *));

  /* Find all methods with a matching name, and put them in
     sym_arr.  */
  method_count = count_methods (class_type, method, sym_arr);

  if (method_count == 1)
    {
      /* There is exactly one field with that name.  */
      struct symbol *sym = sym_arr[0];

      if (sym != NULL && SYMBOL_CLASS (sym) == LOC_BLOCK)
	{
	  values.sals = xmalloc (sizeof (struct symtab_and_line));
	  values.nelts = 1;
	  values.sals[0] = find_function_start_sal (sym, funfirstline);
	}
      else
	{
	  values.nelts = 0;
	}
    }
  else if (method_count > 0)
    {
      /* There is more than one field with that name
	 (overloaded).  Ask the user which one to use.  */
      values = select_symbols (sym_arr, method_count, funfirstline, canonical);
    }
  else
    {
      char *tmp;
	  
      if (is_operator_name (method))
	{
	  tmp = alloca (strlen (method + 3) + 9);
	  strcpy (tmp, "operator ");
	  strcat (tmp, method + 3);
	}
      else
	tmp = method;
      if (tmp[0] == '~')
	cplusplus_error (saved_arg,
			 "the class `%s' does not have destructor defined\n",
			 SYMBOL_SOURCE_NAME (class_sym));
      else
	cplusplus_error (saved_arg,
			 "the class %s does not have any method named %s\n",
			 SYMBOL_SOURCE_NAME (class_sym), tmp);
    }

  return values;
}

/* Find all methods in the class whose type is CLASS_TYPE whose name
   is METHOD, and put them in SYM_ARR.  Return the number of methods
   found.  */

static int
count_methods (struct type *class_type, char *method,
	       struct symbol **sym_arr)
{
  int count = 0;	/* Counter for the symbol array.  */
  
  if (destructor_name_p (method, class_type))
    {
      /* Destructors are a special case.  */
      int m_index, f_index;
      
      if (get_destructor_fn_field (class_type, &m_index, &f_index))
	{
	  struct fn_field *f = TYPE_FN_FIELDLIST1 (class_type, m_index);
	  
	  sym_arr[count] =
	    lookup_symbol (TYPE_FN_FIELD_PHYSNAME (f, f_index),
			   NULL, VAR_NAMESPACE, NULL, NULL);
	  if (sym_arr[count])
	    count++;
	}
    }
  else
    count = find_methods (class_type, method, sym_arr);

  return count;
}

/* This does most of the legwork for count_methods, and the arguments
   are the same.  */

static int
find_methods (struct type *class_type, char *method,
	      struct symbol **sym_arr)
{
  int count = 0;
  int ibase;
  char *class_name = type_name_no_tag (class_type);

  /* Ignore this class if it doesn't have a name.  This is ugly, but
     unless we figure out how to get the physname without the name of
     the class, then the loop can't do any good.  */
  if (class_name != NULL
      && (lookup_symbol (class_name, NULL, STRUCT_NAMESPACE, NULL,
			 NULL) != NULL))
    {
      int method_counter;
      int name_len = strlen (method);

      check_typedef (class_type);

      /* Loop over each method name.  At this level, all overloads of a name
         are counted as a single name.  There is an inner loop which loops over
         each overload.  */

      for (method_counter = TYPE_NFN_FIELDS (class_type) - 1;
	   method_counter >= 0;
	   --method_counter)
	{
	  int field_counter;
	  char dem_opname[64];
	  char *current_method_name
	    = find_method_name (class_type, method_counter, dem_opname);

	  if (strcmp_iw (method, current_method_name) == 0)
	    /* Find all the overloaded methods with that name.  */
	    count += add_matching_methods (method_counter, class_type,
					   sym_arr + count);
	  else if (strncmp (class_name, method, name_len) == 0
		   && (class_name[name_len] == '\0'
		       || class_name[name_len] == '<'))
	    count += add_constructors (method_counter, class_type,
				       sym_arr + count);
	}
    }

  /* Only search baseclasses if there is no match yet, since names in
     derived classes override those in baseclasses.

     FIXME: The above is not true; it is only true of member functions
     if they have the same number of arguments (??? - section 13.1 of the
     ARM says the function members are not in the same scope but doesn't
     really spell out the rules in a way I understand.  In any case, if
     the number of arguments differ this is a case in which we can overload
     rather than hiding without any problem, and gcc 2.4.5 does overload
     rather than hiding in this case).  */

  if (count == 0)
    for (ibase = 0; ibase < TYPE_N_BASECLASSES (class_type); ibase++)
      count += find_methods (TYPE_BASECLASS (class_type, ibase), method,
			     sym_arr + count);

  return count;
a1043 5
/* Return the name of the METHOD_COUNTER'th method of the class whose
   type is CLASS_TYPE.  If demangling is necessary, DEM_OPNAME will be
   used as storage space.  Note that this function is g++
   specific.  */

d1045 1
a1045 2
find_method_name (struct type *class_type, int method_counter,
		  char *dem_opname)
d1047 10
a1056 4
  char *name = TYPE_FN_FIELDLIST_NAME (class_type, method_counter);
  if (strncmp (name, "__", 2) == 0
      || strncmp (name, "op", 2) == 0
      || strncmp (name, "type", 4) == 0)
d1058 3
a1060 4
      if (cplus_demangle_opname (name, dem_opname, DMGL_ANSI))
	name = dem_opname;
      else if (cplus_demangle_opname (name, dem_opname, 0))
	name = dem_opname;
d1063 1
a1063 1
  return name;
d1066 4
a1069 7
/* Add the symbols associated to methods of the class whose type is
   CLASS_TYPE and whose name matches the method indexed by
   METHOD_COUNTER to the array SYM_ARR.  Return the number of methods
   added.  */
static int
add_matching_methods (int method_counter, struct type *class_type,
		      struct symbol **sym_arr)
d1071 4
a1074 7
  int field_counter;
  int count = 0;
  
  for (field_counter
	 = TYPE_FN_FIELDLIST_LENGTH (class_type, method_counter) - 1;
       field_counter >= 0;
       --field_counter)
d1076 2
a1077 4
      struct fn_field *f;
      char *phys_name;

      f = TYPE_FN_FIELDLIST1 (class_type, method_counter);
d1079 1
a1079 1
      if (TYPE_FN_FIELD_STUB (f, field_counter))
d1081 3
a1083 7
	  char *tmp_name;

	  tmp_name = gdb_mangle_name (class_type, method_counter,
				      field_counter);
	  phys_name = alloca (strlen (tmp_name) + 1);
	  strcpy (phys_name, tmp_name);
	  xfree (tmp_name);
a1085 11
	phys_name = TYPE_FN_FIELD_PHYSNAME (f, field_counter);
		
      /* Destructor is handled by caller; don't add it to the list.  */
      if (is_destructor_name (phys_name) != 0)
	continue;

      sym_arr[count] = lookup_symbol (phys_name, NULL, VAR_NAMESPACE,
				      NULL, NULL);
      if (sym_arr[count])
	count++;
      else
d1087 1
a1087 8
	  /* This error message gets printed, but the method
	     still seems to be found
	     fputs_filtered("(Cannot find method ", gdb_stdout);
	     fprintf_symbol_filtered (gdb_stdout, phys_name,
	     language_cplus,
	     DMGL_PARAMS | DMGL_ANSI);
	     fputs_filtered(" - possibly inlined.)\n", gdb_stdout);
	  */
d1090 1
a1090 23

  return count;
}

/* If we're looking for a constructor, add the symbols associated to
   methods of the class whose type is CLASS_TYPE and which are indexed
   by by METHOD_COUNTER to the array SYM_ARR.  Return the number of
   methods added.  */

static int
add_constructors (int method_counter, struct type *class_type,
		  struct symbol **sym_arr)
{
  int field_counter;
  int count = 0;

  /* For GCC 3.x and stabs, constructors and destructors have names
     like __base_ctor and __complete_dtor.  Check the physname for now
     if we're looking for a constructor.  */
  for (field_counter
	 = TYPE_FN_FIELDLIST_LENGTH (class_type, method_counter) - 1;
       field_counter >= 0;
       --field_counter)
d1092 3
a1094 19
      struct fn_field *f;
      char *phys_name;
		  
      f = TYPE_FN_FIELDLIST1 (class_type, method_counter);

      /* GCC 3.x will never produce stabs stub methods, so we don't need
	 to handle this case.  */
      if (TYPE_FN_FIELD_STUB (f, field_counter))
	continue;
      phys_name = TYPE_FN_FIELD_PHYSNAME (f, field_counter);
      if (! is_constructor_name (phys_name))
	continue;

      /* If this method is actually defined, include it in the
	 list.  */
      sym_arr[count] = lookup_symbol (phys_name, NULL, VAR_NAMESPACE,
				      NULL, NULL);
      if (sym_arr[count])
	count++;
d1096 1
a1096 24

  return count;
}

/* Given a list of NELTS symbols in SYM_ARR, return a list of lines to
   operate on (ask user if necessary).
   If CANONICAL is non-NULL return a corresponding array of mangled names
   as canonical line specs there.  */

static struct symtabs_and_lines
select_symbols (struct symbol **sym_arr, int nelts, int funfirstline,
		char ***canonical)
{
  struct symtabs_and_lines values, return_values;
  char *args, *arg1;
  int i;
  char *prompt;
  char *symname;
  struct cleanup *old_chain = NULL;
  char **canonical_arr = NULL;

  values.sals = alloca (nelts * sizeof (struct symtab_and_line));

  if (canonical)
d1098 3
a1100 12
      canonical_arr = xmalloc (nelts * sizeof (char *));
      old_chain = make_cleanup (xfree, canonical_arr);
      memset (canonical_arr, 0, nelts * sizeof (char *));
      *canonical = canonical_arr;
    }

  i = 0;
  printf_unfiltered ("[0] cancel\n[1] all\n");
  while (i < nelts)
    {
      init_sal (&values.sals[i]);	/* Initialize to zeroes.  */
      if (sym_arr[i] && SYMBOL_CLASS (sym_arr[i]) == LOC_BLOCK)
d1102 3
a1104 6
	  values.sals[i] = find_function_start_sal (sym_arr[i], funfirstline);
	  printf_unfiltered ("[%d] %s at %s:%d\n",
			     (i + 2),
			     SYMBOL_SOURCE_NAME (sym_arr[i]),
			     values.sals[i].symtab->filename,
			     values.sals[i].line);
d1107 9
a1115 2
	printf_unfiltered ("?HERE\n");
      i++;
d1118 1
a1118 11
  if ((prompt = getenv ("PS2")) == NULL)
    {
      prompt = "> ";
    }
  args = command_line_input (prompt, 0, "overload-choice");

  if (args == 0 || *args == 0)
    error_no_arg ("one or more choice numbers");

  return select_symbols_args (sym_arr, nelts, args, canonical_arr,
			      values, old_chain);
d1121 2
a1122 8
/* This is the part of select_symbols that actually handles the user's
   response.  */

static struct symtabs_and_lines
select_symbols_args (struct symbol **sym_arr, int nelts,
		     char *args, char **canonical_arr,
		     struct symtabs_and_lines values,
		     struct cleanup *old_chain)
d1124 1
a1124 3
  struct symtabs_and_lines return_values;
  struct cleanup *new_chain;
  int i;
d1126 1
a1126 10
  return_values.sals = xmalloc (nelts * sizeof (struct symtab_and_line));
  new_chain = make_cleanup (xfree, return_values.sals);
  if (old_chain == NULL)
    old_chain = new_chain;

  for (i = 0; i < nelts; ++i)
    init_sal (&return_values.sals[i]);

  i = 0;
  while (*args)
d1128 4
a1131 14
      int num;
      char *arg1;

      arg1 = args;
      while (*arg1 >= '0' && *arg1 <= '9')
	arg1++;
      if (*arg1 && *arg1 != ' ' && *arg1 != '\t')
	error ("Arguments must be choice numbers.");

      num = atoi (args);

      if (num == 0)
	error ("canceled");
      else if (num == 1)
d1133 8
a1140 43
	  if (canonical_arr != NULL)
	    {
	      int j;
	      
	      for (j = 0; j < nelts; j++)
		{
		  if (canonical_arr[j] == NULL)
		    {
		      char *symname = SYMBOL_NAME (sym_arr[j]);
		      canonical_arr[j]
			= savestring (symname, strlen (symname));
		    }
		}
	    }
	  memcpy (return_values.sals, values.sals,
		  (nelts * sizeof (struct symtab_and_line)));
	  return_values.nelts = nelts;
	  discard_cleanups (old_chain);
	  return return_values;
	}

      if (num >= nelts + 2)
	{
	  printf_unfiltered ("No choice number %d.\n", num);
	}
      else
	{
	  num -= 2;
	  if (values.sals[num].pc)
	    {
	      if (canonical_arr != NULL)
		{
		  char *symname = SYMBOL_NAME (sym_arr[num]);
		  make_cleanup (xfree, symname);
		  canonical_arr[i] = savestring (symname, strlen (symname));
		}
	      return_values.sals[i++] = values.sals[num];
	      values.sals[num].pc = 0;
	    }
	  else
	    {
	      printf_unfiltered ("duplicate request for %d ignored.\n", num);
	    }
a1141 4

      args = arg1;
      while (*args == ' ' || *args == '\t')
	args++;
d1143 2
a1144 22
  return_values.nelts = i;
  discard_cleanups (old_chain);
  return return_values;
}

/* Issue a helpful hint on using the command completion feature on
   single quoted demangled C++ symbols as part of the completion
   error.  */

static NORETURN void
cplusplus_error (const char *name, const char *fmt, ...)
{
  struct ui_file *tmp_stream;
  tmp_stream = mem_fileopen ();
  make_cleanup_ui_file_delete (tmp_stream);

  {
    va_list args;
    va_start (args, fmt);
    vfprintf_unfiltered (tmp_stream, fmt, args);
    va_end (args);
  }
d1146 1
a1146 7
  while (*name == '\'')
    name++;
  fprintf_unfiltered (tmp_stream,
		      ("Hint: try '%s<TAB> or '%s<ESC-?>\n"
		       "(Note leading single quote.)"),
		      name, name);
  error_stream (tmp_stream);
a1148 5


/* Return the symtab associated to the filename given by the substring
   of *ARGPTR ending at FILE_NAME_END.  */

d1150 1
a1150 1
handle_filename (char **argptr, char *filename_end, int is_quote_enclosed)
d1152 1
a1152 1
  char *saved_filename_end;
d1154 1
a1154 1
  struct symtab *file_symtab;
d1157 10
a1166 10
  saved_filename_end = filename_end;
  while (filename_end != *argptr && filename_end[-1] == ' ')
    --filename_end;
  if ((*filename_end == '"') && is_quote_enclosed)
    --filename_end;
  copy = alloca (filename_end - *argptr + 1);
  memcpy (copy, *argptr, filename_end - *argptr);
  /* It may have the ending quote right after the file name.  */
  if (is_quote_enclosed && copy[filename_end - *argptr - 1] == '"')
    copy[filename_end - *argptr - 1] = 0;
d1168 1
a1168 1
    copy[filename_end - *argptr] = 0;
d1171 2
a1172 2
  file_symtab = lookup_symtab (copy);
  if (file_symtab == NULL)
d1180 4
a1183 4
  filename_end = saved_filename_end + 1;
  while (*filename_end == ' ' || *filename_end == '\t')
    filename_end++;
  *argptr = filename_end;
d1185 1
a1185 1
  return file_symtab;
a1187 4


/* Functions related to cases where the arg is all digits.  */

d1189 1
a1189 1
is_all_digits (char *arg)
d1191 1
a1191 1
  char *q = skip_digits (arg);
d1197 3
a1199 3
decode_all_digits (char **argptr, struct symtab *default_symtab,
		   int default_line, char ***canonical,
		   struct symtab *file_symtab)
d1203 1
a1203 1
  char *end_of_digits = skip_digits (*argptr);
d1220 1
a1220 1
     select_source_symtab that calls us with such an argument.  */
d1224 3
a1226 1
      /* Make sure we have at least a default source file.  */
d1228 4
a1231 1
      initialize_defaults (&default_symtab, &default_line);
d1262 1
a1262 1
  if (file_symtab == NULL)
d1269 1
a1269 1
  if (val.symtab == NULL)
d1282 1
a1282 1
skip_digits (char *arg)
a1291 4


/* Decode a linespec starting with a dollar sign.  */

d1293 2
a1294 2
decode_dollar (char **argptr, int funfirstline, struct symtab *default_symtab,
	       char ***canonical, struct symtab *file_symtab)
d1303 1
a1303 1
  /* One or two $ chars possible.  */
d1306 1
a1306 1
  copy = alloca (p - *argptr + 1);
d1317 1
a1317 1
  if (!*p)		/* Reached end of token without hitting non-digit.  */
d1319 1
a1319 1
      /* We have a value history reference.  */
d1328 1
a1328 1
	 convenience variable.  */
d1334 1
a1334 1
      /* Look up entire name as a symbol first.  */
d1337 2
a1338 2
	return symbol_found (funfirstline, canonical, copy,
			     sym, NULL, sym_symtab);
d1340 1
a1340 1
      /* If symbol was not found, look in minimal symbol tables.  */
d1343 1
a1343 1
	return minsym_found (funfirstline, msymbol);
d1345 1
a1345 1
      /* Not a user variable or function -- must be convenience variable.  */
d1353 1
a1353 1
  /* Either history value or convenience value from above, in valx.  */
a1366 2


d1368 3
a1370 3
decode_variable (char **argptr, int funfirstline, char ***canonical,
		 int is_quoted, char *paren_pointer,
		 struct symtab *file_symtab)
d1393 1
a1393 1
  copy = alloca (p - *argptr + 1);
d1420 1
a1420 1
		       VAR_NAMESPACE, NULL, &sym_symtab);
d1424 2
a1425 2
      return symbol_found (funfirstline, canonical, copy,
			   sym, file_symtab, sym_symtab);
d1431 1
a1431 1
    return minsym_found (funfirstline, msymbol);
a1439 42


/* Build a canonical line spec in CANONICAL if it is non-NULL and if
   the SAL has a symtab.
   If SYMNAME is non-NULL the canonical line spec is `filename:symname'.
   If SYMNAME is NULL the line number from SAL is used and the canonical
   line spec is `filename:linenum'.  */

static void
build_canonical_line_spec (struct symtab_and_line *sal, char *symname,
			   char ***canonical)
{
  char **canonical_arr;
  char *canonical_name;
  char *filename;
  struct symtab *sal_symtab = sal->symtab;

  if (sal_symtab == NULL
      || sal_symtab->filename == NULL
      || canonical == NULL)
    return;

  canonical_arr = xmalloc (sizeof (char *));
  *canonical = canonical_arr;

  filename = sal_symtab->filename;
  if (symname != NULL)
    {
      canonical_name = xmalloc (strlen (filename) + strlen (symname) + 2);
      sprintf (canonical_name, "%s:%s", filename, symname);
    }
  else
    {
      canonical_name = xmalloc (strlen (filename) + 30);
      sprintf (canonical_name, "%s:%d", filename, sal->line);
    }
  canonical_arr[0] = canonical_name;
}

/* We've found a symbol SYM to associate with our linespec; build a
   corresponding struct symtabs_and_lines.  */

d1441 3
a1443 3
symbol_found (int funfirstline, char ***canonical, char *copy,
	      struct symbol *sym, struct symtab *file_symtab,
	      struct symtab *sym_symtab)
d1449 1
a1449 1
      /* Arg is the name of a function.  */
a1492 3
/* We've found a minimal symbol MSYMBOL to associate with our
   linespec; build a corresponding struct symtabs_and_lines.  */

d1494 1
a1494 1
minsym_found (int funfirstline, struct minimal_symbol *msymbol)
d1500 1
a1500 1
				      NULL, 0);
@


1.22.2.9
log
@2002-11-13  David Carlton  <carlton@@math.stanford.edu>

	* buildsym.c (finish_block): Initialize block_scope (block) in
	C++ function blocks.
	* dwarf2read.c: Delete variable current_namespace.
	(psymtab_to_symtab_1): Rename current_namespace to
	processing_current_namespace.
	(read_namespace): Ditto.
	* buildsym.h: New variable processing_current_namespace.
	* block.h: Declarations for block_scope and block_set_scope.
	* block.c (block_scope): New function.
	(block_set_scope): New function.
	* cp-support.h (struct namespace_info): Add 'scope' member.
	* buildsym.c (finish_block): Replace BLOCK_USING by
	block_set_using.
	(end_symtab): Ditto.
	* block.h: Declaration for block_set_using.
	* block.c (block_set_using): New function.
	(block_initialize_namespace): New function.
	* symtab.c (lookup_symbol_aux_using): Replace BLOCK_USING by
	block_using.
	* buildsym.c (finish_block): Set BLOCK_NAMESPACE to NULL, not
	BLOCK_USING.
	* jv-lang.c (get_java_class_symtab): Ditto.
	* block.h: Declaration for block_using.
	* block.c (block_using): New function.
	* Makefile.in (block.o): New rule; also add block.c to SFILES and
	block.o to COMMON_OBS.
	* block.c: New file.
	* symtab.c (contained_in): Move to block.c.
	(block_function): Ditto.
	* block.h (struct block): Have the language-specific stuff contain
	a struct namespace_info.
	(BLOCK_NAMESPACE): New macro.
	(BLOCK_USING): Delete.
	* linespec.c (decode_variable): Add comment before
	decode_variable.
	* cp-support.h (struct namespace_info): New struct.
@
text
@a1483 3
/* Decode a linespec that's a variable.  If FILE_SYMTAB is non-NULL,
   look in that file's static variables first.  */

@


1.22.2.10
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux): Get at static block via
	block_static_block.
	(lookup_symbol_aux_local): Delete static_block argument, and use
	block_static_block.
	* block.h: Declare block_static_block.
	* block.c (block_static_block): New function.
	* linespec.c (decode_all_digits): Move up definition of
	need_canonical.
@
text
@d1327 2
a1330 2

  init_sal (&val);
@


1.22.2.11
log
@2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (examine_compound_token): Rewrite as switch
	statement, and add FIXME comment.
	* frame.h: Make arg of block_innermost_frame const.
	* blockframe.c (block_innermost_frame): Make arg const.
	* block.h: Make args to block_function, contained_in const.
	* block.c (block_function): Make arg const.
	(contained_in): Ditto.
	* value.h: Make arg of symbol_read_needs_frame const.
	* findvar.c (symbol_read_needs_frame): Make arg const.
	* symtab.h: Make first arg of symbol_demangled_name const.
	* symtab.c (symbol_demangled_name): Make arg const.
	* value.h: Make first arg of read_var_value const.
	* findvar.c (read_var_value): Make first arg const.
	* Makefile.in (valops.o): Depend on cp_support_h.
	* valops.c: #include "cp-support.h"
	* symtab.h: Add FIXME about name of namespace_enum.
	Add opaque declaration of struct using_direct_node.
	* symtab.c (lookup_symbol_namespace): Make extern; rename args.
	* symtab.h: Declare lookup_symbol_namespace.
	* valops.c (value_struct_elt_for_reference): Make 'name' a const
	char *.
	(value_namespace_elt): New function.
	* expprint.c (print_subexp): Ditto.
	(dump_subexp): Ditto.
	* parse.c (length_of_subexp): Ditto.
	(prefixify_subexp): Ditto.
	* expression.h: Update comment to reflect the block in OP_SCOPE.
	* c-exp.y: Set block in OP_SCOPE expression.
	* jv-exp.y (push_qualified_expression_name): Put a NULL block in
	OP_SCOPE expression.
	* objc-exp.y: Ditto.
	* p-exp.y: Ditto.
	* eval.c (evaluate_subexp_standard): Handle OP_SCOPE via
	value_aggregate_elt.
	* value.h: Add declaration for value_aggregate_elt; delete
	declaration for value_struct_elt_for_reference.
	* valops.c (value_aggregate_elt): New function.
	(value_struct_elt_for_reference): Make static.  Don't check type
	of curtype.
	* c-exp.y: Accept TYPE_CODE_NAMESPACE in qualified_name.
	* cp-support.c (cp_check_namespace_symbol): Set TYPE_NAME (type).

2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change a couple of tests to not use
	single quotes.
@
text
@d681 2
a682 1
  switch (TYPE_CODE (t))
a683 2
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
d705 3
a707 7
    case TYPE_CODE_NAMESPACE:
      return 0;
    default:
      /* FIXME: carlton/2002-11-19: Once this all settles down, this
	 case should be an error rather than a return 0; that will
	 allow us to make VALUES the return value rather than an
	 argument.  */
@


1.22.2.12
log
@2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (add_partial_enumeration): New function.
	(scan_partial_symbols): Call add_partial_enumeration.
	(locate_pdi_sibling): New function.
	(scan_partial_symbols): Call locate_pdi_sibling.  Get rid of
	nesting_level.
	(pdi_needs_namespace): New function.
	(add_partial_symbol): Add 'namespace' arg; calculate full name
	when appropriate.
	(scan_partial_symbols): Update calls to add_partial_symbol.
	(add_partial_enumeration): Ditto.
	(read_enumeration): Add processing_current_prefix to name when
	appropriate.
	(new_symbol): Set names of enumerators and typedefs appropriately
	if processing_has_namespace_info.
	* symtab.c (lookup_symbol_namespace): Rename 'namespace' argument
	to 'namespace_name'.
	* symtab.h: Ditto.
	* symtab.c (lookup_symbol_namespace): Delete FIXME comments; add a
	new one.
	(lookup_symbol_aux_file): New function.
	(lookup_symbol_aux): Delete FIXME comment.
	(lookup_symbol_aux): Don't search static block explicitly; delete
	FIXME comments.
	* valops.c (value_namespace_elt): Update call to
	lookup_symbol_namespace.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* symtab.c (lookup_symbol_namespace): Delete 'using' argument and
	add 'block' argument; get using directives via iterators.
	(lookup_symbol_aux_using_loop): Delete 'using' argument and add
	'block' argument.
	(lookup_symbol_aux_using): Don't calculate using directives.
	* block.c (block_using_iterator_first): New function.
	(block_using_iterator_next): Ditto.
	* block.h: Add comment.
	(struct block_using_iterator): New struct.
	Declare block_using_iterator_first, block_using_iterator_next.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (read_structure_scope): Set type name and
	processing_current_prefix appropriately.
	(new_symbol): Make sure that, in symbols associated to class
	types, the name includes appropriate namespaces.
	* buildsym.h: Rename processing_current_namespace to
	processing_current_prefix.
	* buildsym.c (finish_block): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	(read_namespace): Ditto.  Also rename previous_namespace to
	previous_prefix.

	Now come a thousand and one const correctness fixes:
	* p-typeprint.c (pascal_print_type): Const.
	(pascal_type_print_method_args): Const.
	* p-lang.h: Const.
	* m2-typeprint.c (m2_print_type): Const.
	* valops.c (hand_function_call): Const.
	* jv-lang.c (java_primitive_type_from_name): Const.
	* jv-lang.h: Const.
	* jv-typeprint.c (java_print_type): Const.
	* language.c: (unk_lang_print_type): Const.
	* stack.c (frame_info): Const.
	* linespec.c (find_methods): Const.
	(find_method_name): Const
	* f-lang.h: Const.
	* f-typeprint.c (f_print_type): Const.
	* c-typeprint.c (c_print_type): Const.
	* c-lang.h: Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (lookup_primitive_typename): Const.
	* stack.c (print_frame): Const.
	(func_command): Delete pointless cast.
	* linespec.c (find_method_name): Const.
	* language.h: Const.
	* symfile.c (compare_psymbols): Const.
	* symtab.c (completion_list_add_name): Const.
	* breakpoint.c (break_at_finish_at_depth_command_1): Remove
	useless cast.
	(break_at_finish_command_1): Ditto.
	* typeprint.c (type_print): Const.
	* symtab.h: Const.
	* symtab.c (gdb_mangle_name): Const.
	(symbol_init_demangled_name): Const.
	(symbol_demangled_name): Const.
	* defs.h: Const.
	* printcmd.c (build_address_symbolic): Const.
	* valops.c (search_struct_method): Const.
	* cp-valprint.c (cp_is_vtbl_ptr_type): Const.
	(cp_print_value): Const.
	(cp_print_class_member): Const.
	* c-typeprint.c (cp_type_print_derivation_info): Const.
	(c_type_print_varspec_prefix): Const.
	(c_type_print_base): Const.
	* p-valprint.c (pascal_object_is_vtbl_ptr_type): Const.
	(pascal_object_print_value): Const.
	(pascal_object_print_class_member): Const.
	* p-typeprint.c (pascal_type_print_derivation_info): Const.
	(pascal_type_print_varspec_prefix): Const.
	(pascal_type_print_base): Const.
	* jv-typeprint.c (java_type_print_base): Const.
	* jv-lang.h (java_demangle_type_signature): Const.
	* jv-lang.c (java_demangle_type_signature): Const.
	(java_demangled_signature_length): Const.
	(java_demangled_signature_copy): Const.
	* jv-typeprint.c (java_type_print_derivation_info): Const.
	* jv-valprint.c (java_value_print): Const.
	(java_print_value_fields): Const.
	* jv-lang.c (is_object_type): Const.
	(evaluate_subexp_java): Const.
	* stabsread.c (read_cpp_abbrev): Const.
	(complain_about_struct_wipeout): Const.
	(cleanup_undefined_types): Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (add_name): Second arg const.
	(lookup_typename): Const.
	(lookup_unsigned_typename): Const.
	(lookup_signed_typename): Const.
	* linespec.c (find_methods): const char *class_name.
	* symtab.c (gdb_mangle_name): const char *newname.
	* valops.c (destructor_name_p): const char *dname.
	(search_struct_field): First arg const.
	* gdbtypes.c (check_typedef): const char *name (multiple places).
	(cfront_mangle_name): const char *newname.
	* gdbtypes.c (add_mangled_type): const char *tname.
	* valops.c (find_overload_match): const char *obj_type_name.
	* utils.c (gdb_print_host_address): Make first arg const.
	* defs.h: Declare first arg of gdb_print_host_address to be
	const.
	* valarith.c (find_size_for_pointer_math): const char *name.

2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/m-data.cc (main): Add marker comment.
	* gdb.c++/m-data.exp: Use marker comment instead of line numbers.
	* gdb.c++/m-data.cc: Delete superfluous namespace.
	* gdb.c++/m-static.cc: Ditto.
	* gdb.c++/m-static1.cc: Ditto.
	* carlton_runtest: Compare based on gdb.sum, not based on output.
	* carlton_runnamespace: Ditto.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Put tests for CClass.
	* gdb.c++/namespace.cc (C): Add CClass.
@
text
@d82 2
a83 3
static const char *find_method_name (struct type *class_type,
				     int method_counter,
				     char *dem_opname);
d899 1
a899 1
  const char *class_name = type_name_no_tag (class_type);
d923 1
a923 1
	  const char *current_method_name
d962 1
a962 1
static const char *
d966 1
a966 1
  const char *name = TYPE_FN_FIELDLIST_NAME (class_type, method_counter);
@


1.22.2.13
log
@2002-12-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_minsyms): Don't call
	lookup_symbol_aux from within this.
	* values.c (value_static_field): lookup_symbol_linkage.
	(value_fn_field): lookup_symbol_linkage.
	* valops.c (value_struct_elt_for_reference): lookup_symbol_linkage.
	* blockframe.c (inside_main_func): lookup_symbol_linkage.
	* source.c (select_source_symtab): lookup_symbol_linkage.
	* nlmread.c (nlm_symfile_read): Call lookup_symbol_linkage.
	* nindy-tdep.c (nindy_frame_chain_valid): Call
	lookup_symbol_linkage.
	* linespec.c (count_methods): Call lookup_symbol_linkage.
	(add_matching_methods): Ditto.
	(add_constructors): Ditto.
	* hppa-tdep.c (find_stub_with_shl_get): Call
	lookup_symbol_linkage.  Delete symbol2.
	(initialize_hp_cxx_exception_support): Call lookup_symbol_linkage.
	* cli/cli-cmds.c (edit_command): SYMBOL_PRINT_NAME.
	(list_command): SYMBOL_PRINT_NAME.
	* valops.c (value_of_variable): SYMBOL_PRINT_NAME
	(hand_function_call): SYMBOL_PRINT_NAME.
	* typeprint.c (typedef_print): SYMBOL_PRINT_NAME.
	* tracepoint.c (tracepoints_info): SYMBOL_PRINT_NAME.
	* symtab.c (lookup_partial_symbol): SYMBOL_BEST_NAME.
	(compare_search_syms): SYMBOL_BEST_NAME.
	(print_symbol_info): SYMBOL_PRINT_NAME.
	(print_msymbol_info): SYMBOL_PRINT_NAME.
	(rbreak_command): SYMBOL_PRINT_NAME.
	* symmisc.c (print_symbol): SYMBOL_PRINT_NAME.
	* stack.c (print_frame): SYMBOL_PRINT_NAME.
	(frame_info): SYMBOL_PRINT_NAME.
	(print_block_frame_locals): SYMBOL_PRINT_NAME.
	(print_block_frame_labels): SYMBOL_PRINT_NAME.
	(print_frame_arg_vars): SYMBOL_PRINT_NAME.
	(return_command): SYMBOL_PRINT_NAME.
	* stabsread.c (define_symbol): SYMBOL_PRINT_NAME.
	* p-valprint.c (pascal_val_print): SYMBOL_PRINT_NAME.
	* printcmd.c (build_address_symbolic): SYMBOL_PRINT_NAME.
	(sym_info): SYMBOL_PRINT_NAME.
	(print_frame_args): SYMBOL_PRINT_NAME.
	* objc-lang.c (compare_selectors): SYMBOL_BEST_NAME.
	(compare_classes): SYMBOL_BEST_NAME.
	* maint.c (maintenance_translate_address): SYMBOL_PRINT_NAME.
	* linespec.c (find_method): SYMBOL_PRINT_NAME.
	(select_symbols): SYMBOL_PRINT_NAME.
	* infcmd.c (jump_command): SYMBOL_PRINT_NAME.
	* findvar.c (locate_var_value): SYMBOL_PRINT_NAME.
	* expprint.c (print_subexp): SYMBOL_PRINT_NAME.
	* c-valprint.c (c_val_print): SYMBOL_PRINT_NAME.
	* buildsym.c (finish_block): SYMBOL_PRINT_NAME.
	* breakpoint.c (print_one_breakpoint): SYMBOL_PRINT_NAME.
	* ax-gdb.c (gen_var_ref): SYMBOL_PRINT_NAME.
	* ada-typeprint.c (ada_typedef_print): SYMBOL_PRINT_NAME.
	* ada-lang.c (user_select_syms): Use SYMBOL_PRINT_NAME instead of
	SYMBOL_SOURCE_NAME.
	(user_select_syms):
	(ada_finish_decode_line_1): Use SYMBOL_BEST_NAME instead of
	SYMBOL_SOURCE_NAME.
	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME.
	* symfile.c (compare_symbols): Use SYMBOL_BEST_NAME, not
	SYMBOL_SOURCE_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_symbol_linkage): New function.
	* symtab.h: Declare lookup_symbol_linkage.
	* c-valprint.c (c_val_print): Call lookup_symbol_minsym.
	* symtab.c (lookup_symbol_aux_minsyms): Call minsym_static.
	* minsyms.c (minsym_static): New function.
	* symtab.h: Declare minsym_static.
	* symtab.c (lookup_symbol_minsym): New function.
	(search_symbols): Call lookup_symbol_minsym instead of
	lookup_symbol.
	(lookup_symbol_namespace): Don't take apart NAME.
	* symtab.h: Declare lookup_symbol_minsym.
	* printcmd.c (build_address_symbolic): Don't use old version of
	SYMBOL_LINKAGE_NAME.
	* symtab.c (lookup_block_symbol): Change mangled names to linkage
	name, and use SYMBOL_LINKAGE_NAME as appropriate.
	* symtab.h (SYMBOL_LINKAGE_NAME): New macro, with a different
	meaning from the old macro of the same name.  Also, add comments
	about proper uses of names.
@
text
@d849 1
a849 1
			 SYMBOL_PRINT_NAME (class_sym));
d853 1
a853 1
			 SYMBOL_PRINT_NAME (class_sym), tmp);
d879 2
a880 1
	    lookup_symbol_linkage (TYPE_FN_FIELD_PHYSNAME (f, f_index));
d1019 2
a1020 1
      sym_arr[count] = lookup_symbol_linkage (phys_name);
d1074 2
a1075 1
      sym_arr[count] = lookup_symbol_linkage (phys_name);
d1120 1
a1120 1
			     SYMBOL_PRINT_NAME (sym_arr[i]),
@


1.22.2.14
log
@2003-02-12  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (examine_compound_token): Call decode_namespace.
	(decode_namespace): New function.
	* cp-support.c (cp_find_first_component): Return the offset, not a
	pointer.
	(check_possible_namespace_symbols_loop): Update call to
	cp_find_first_component.
	(cp_check_possible_namespace_symbols): Ditto.
	(cp_func_name): Ditto.
	* buildsym.c (scan_for_anonymous_namespaces): Ditto.
	(finish_block): Ditto.
	* linespec.c (examine_compound_token): Ditto.
	* symtab.c (lookup_symbol_aux_using_loop): Ditto.
	* valops.c (find_oload_champ_namespace_loop): Ditto.
	* cp-support.h: Declare cp_find_first_component to return an int.
	* Makefile.in (linespec.o): cp_support_h.
	* linespec.c (symtab_from_filename): Rename from handle_filename.
	(decode_line_1): Call symtab_from_filename instead of
	handle_filename.
	(locate_compound_sym): Rename from locate_class_sym.  Search in
	such a way that we find namespace symbols, too.
	(examine_compound_token): Call locate_class_sym instead of
	locate_compound_sym.
	(locate_compound_sym): Add NAMESPACE arg.
	(examine_compound_token): New arg to locate_compound_sym.
	Handle TYPE_CODE_NAMESPACE.
	#include "cp-support.hp"
@
text
@a35 1
#include "cp-support.h"
d63 1
a63 9
static struct symbol *locate_compound_sym (char **argptr,
					   char *current_component,
					   const char *namespace);

static int decode_namespace (char **argptr, int funfirstline,
			     char ***canonical,
			     char *next_component,
			     const char *namespace,
			     struct symtabs_and_lines *values);
d109 2
a110 3
static struct symtab *symtab_from_filename (char **argptr,
					    char *filename_end,
					    int is_quote_enclosed);
d266 1
a266 1
	file_symtab = symtab_from_filename (argptr, p, is_quote_enclosed);
d667 7
a673 7
  const char *namespace = "";

  while (1)
    {
      char *copy;
      struct symbol *class_sym;
      struct type *t;
d675 1
a675 3
      /* If CURRENT_COMPONENT points at the end of a name of a class
	 or namespace, find the corresponding symbol and advance
	 ARGPTR past the end of the class/namespace.  */
d677 2
a678 1
      class_sym = locate_compound_sym (argptr, current_component, namespace);
d680 1
a680 2
      if (class_sym == NULL)
	return 0;
d682 16
a697 18
      t = check_typedef (SYMBOL_TYPE (class_sym));

      switch (TYPE_CODE (t))
	{
	case TYPE_CODE_STRUCT:
	case TYPE_CODE_UNION:
	  /* Find the next token (everything up to end or next blank).  */

	  current_component = find_next_token (argptr);
	  copy = alloca (current_component - *argptr + 1);
	  memcpy (copy, *argptr, current_component - *argptr);
	  copy[current_component - *argptr] = '\0';
	  if (current_component != *argptr
	      && copy[current_component - *argptr - 1]
	      && (strchr (get_gdb_completer_quote_characters (),
			  copy[current_component - *argptr - 1])
		  != NULL))
	    copy[current_component - *argptr - 1] = '\0';
d699 3
a701 3
	  while (*current_component == ' ' || *current_component == '\t')
	    current_component++;
	  *argptr = current_component;
d703 2
a704 2
	  *values = find_method (funfirstline, canonical, saved_arg, copy,
				 t, class_sym);
d706 9
a714 25
	  return 1;
	case TYPE_CODE_NAMESPACE:
	  {
	    char *next_component = find_next_token (argptr);
	    namespace = TYPE_TAG_NAME (t);
	    if (*next_component == ':')
	      {
		current_component = next_component;
		break;
	      }
	    else
	      {
		return decode_namespace (argptr, funfirstline,
					 canonical,
					 next_component, namespace,
					 values);
	      }
	  }
	default:
	  /* FIXME: carlton/2002-11-19: Once this all settles down, this
	     case should be an error rather than a return 0; that will
	     allow us to make VALUES the return value rather than an
	     argument.  */
	  return 0;
	}
a717 6
/* Locate a symbol associated to a class/namespace that starts at
   *argptr and ends at current_component, looking for it in the
   namespace NAMESPACE.  Advance *ARGPTR to the start of the next
   component.  It's the caller's responsibility to verify that the
   symbol in question is non-NULL and of the correct type.  */

d719 1
a719 2
locate_compound_sym (char **argptr, char *current_component,
		     const char *namespace)
d724 7
a730 7
  /* Extract the class/namespace name.  */
  p1 = current_component;
  while (current_component != *argptr && current_component[-1] == ' ')
    --current_component;
  copy = alloca (current_component - *argptr + 1);
  memcpy (copy, *argptr, current_component - *argptr);
  copy[current_component - *argptr] = 0;
d733 4
a736 9
  current_component = p1 + (p1[0] == ':' ? 2 : 1);
  while (*current_component == ' ' || *current_component == '\t')
    current_component++;
  *argptr = current_component;

  return lookup_symbol_namespace (namespace, strlen (namespace),
				  copy, NULL, get_selected_block(0),
				  VAR_NAMESPACE, NULL);
}
d738 1
a738 40
/* Try to look up the symbol in the namespace NAMESPACE whose name
   starts at *ARGPTR and ends at *NEXT_COMPONENT.  If successful,
   return 1 and store an appropriate symtabs_and_lines in VALUES;
   otherwise, return 0.  */

/* FIXME: carlton/2003-02-12: The only reason for not just returning
   the symtabs_and_lines directly (and signalling an error if an
   appropriate one can't be produced) is because
   examine_compound_token wants it for historical reasons; I sure
   don't like it.  */

static int
decode_namespace (char **argptr, int funfirstline,
		  char ***canonical,
		  char *next_component, const char *namespace,
		  struct symtabs_and_lines *values)
{
  char *copy;
  struct symbol *sym;
  struct symtab *sym_symtab;

  copy = alloca (next_component - *argptr + 1);
  memcpy (copy, *argptr, next_component - *argptr);
  copy[next_component - *argptr] = '\0';
  *argptr = next_component;

  sym = lookup_symbol_namespace (namespace, strlen (namespace),
				 copy, NULL, get_selected_block(0),
				 VAR_NAMESPACE, &sym_symtab);

  if (sym != NULL)
    {
      *values = symbol_found (funfirstline, canonical, copy,
			      sym, NULL, sym_symtab);
      return 1;
    }
  else
    {
      return 0;
    }
d1265 1
a1265 2
symtab_from_filename (char **argptr, char *filename_end,
		       int is_quote_enclosed)
@


1.22.2.15
log
@2003-02-21  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (locate_compound_sym): Update call to
	lookup_symbol_namespace.
	* symtab.c (make_symbol_overload_list): Delete namespace_len
	argument.
	* symtab.h: Update declaration for make_symbol_overload_list.
	* valops.c (find_oload_champ_namespace_loop): New format for
	make_symbol_overload_list.
	* symtab.c (lookup_symbol_namespace): Delete namespace_len
	argument.
	(lookup_symbol_aux_using_loop): Update call to
	lookup_symbol_namespace.
	(make_symbol_overload_list_using): Delete namespace_len argument.
	* linespec.c (decode_namespace): Update call to
	lookup_symbol_namespace.
	* valops.c (value_namespace_elt): Ditto.
	* symtab.c (lookup_nested_type): Ditto.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* block.c (block_all_usings): Delete.
	(block_using): Make static.
	(block_using_iterator_next): New using_direct format.
	(block_using_iterator_first): Ditto.
	* buildsym.c (scan_for_anonymous_namespaces): Rename variables.
	(add_using_directive): New using functions.
	(end_symtab): Use cp_copy_usings.
	(copy_usings_to_obstack): Delete.
	* block.c: Tweak initial comment.
	(struct namespace_info): Move here.
	(block_initialize_namespace): Set scope to NULL!
	* block.h: Add compilation guards.
	Reorder and update declarations.
	* cp-support.c (cp_find_first_component): Return unsigned int.
	(cp_entire_prefix_len): New.
	(cp_add_using_obstack): Delete.
	(cp_add_using_xmalloc): Delete.
	(cp_copy_usings): Rewrite.
	(cp_free_usings): Delete.
	(cp_add_using): New.
	(cp_is_anonymous): Delete second argument.
	(xstrndup): New.
	* cp-support.h: Add compilation guards.
	Update declarations.
	* coffread.c: New variable coff_source_file.
	(coff_start_symtab): Use coff_source_file.
	(complete_symtab): Ditto.
	(coff_end_symtab): Ditto.
	(coff_symtab_read): Ditto.
	* dbxread.c (find_stab_function_addr): Const fix.
	* buildsym.h: Const fix.
	* buildsym.c (start_symtab): Const fix.
	(start_subfile): Ditto.
	* cp-support.c (cp_add_using_xmalloc): Copy name.
	* dwarf2read.c (read_namespace): Loop through extensions
	correctly.
	(read_file_scope): Const fix.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(read_typedef): Ditto.
	* buildsym.c (finish_block): Update comments and simplify code
	when setting scope.
	* buildsym.h: Add opaque declaration of 'struct block'.
	Change comment before processing_current_prefix.
	* arm-tdep.c (arm_gdbarch_init): Add break; after default:.
@
text
@d775 2
a776 2
  return lookup_symbol_namespace (namespace, copy, NULL,
				  get_selected_block(0),
d806 2
a807 2
  sym = lookup_symbol_namespace (namespace, copy, NULL,
				 get_selected_block(0),
@


1.22.2.16
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d1267 1
a1267 1
		      char *symname = DEPRECATED_SYMBOL_NAME (sym_arr[j]);
d1291 1
a1291 1
		  char *symname = DEPRECATED_SYMBOL_NAME (sym_arr[num]);
@


1.22.2.17
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d34 1
a35 2
#include "block.h"
#include "objc-lang.h"
a50 6
static struct symtabs_and_lines decode_objc (char **argptr,
					     int funfirstline,
					     struct symtab *file_symtab,
					     char ***canonical,
					     char *saved_arg);

a142 1
						 int is_objc_method,
a225 1
  int is_objc_method = 0;
a259 19
    /* Check if this is an Objective-C method (anything that starts with
       a '+' or '-' and a '[').  */
    if (*p && (p[0] == ':') && (strchr ("+-", p[1]) != NULL) 
	&& (p[2] == '['))
      {
	is_objc_method = 1;
	paren_pointer  = NULL; /* Just a category name.  Ignore it.  */
      }

    /* Check if the symbol could be an Objective-C selector.  */

    {
      struct symtabs_and_lines values;
      values = decode_objc (argptr, funfirstline, NULL,
			    canonical, saved_arg);
      if (values.sals != NULL)
	return values;
    }

d300 1
a300 1
			  is_objc_method, paren_pointer, file_symtab);
a474 8
      /* Check for a colon and a plus or minus and a [ (which
         indicates an Objective-C method) */
      if (*p && (p[0] == ':') && (strchr ("+-", p[1]) != NULL) 
	  && (p[2] == '['))
	{
	  break;
	}

a556 91
/* Here's where we recognise an Objective-C Selector.  An Objective C
   selector may be implemented by more than one class, therefore it
   may represent more than one method/function.  This gives us a
   situation somewhat analogous to C++ overloading.  If there's more
   than one method that could represent the selector, then use some of
   the existing C++ code to let the user choose one.  */

struct symtabs_and_lines
decode_objc (char **argptr, int funfirstline, struct symtab *file_symtab,
	     char ***canonical, char *saved_arg)
{
  struct symtabs_and_lines values;
  struct symbol **sym_arr = NULL;
  struct symbol *sym = NULL;
  char *copy = NULL;
  struct block *block = NULL;
  int i1 = 0;
  int i2 = 0;

  values.sals = NULL;
  values.nelts = 0;

  if (file_symtab != NULL)
    block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (file_symtab), STATIC_BLOCK);
  else
    block = get_selected_block (0);
    
  copy = find_imps (file_symtab, block, *argptr, NULL, &i1, &i2); 
    
  if (i1 > 0)
    {
      sym_arr = (struct symbol **) alloca ((i1 + 1) * sizeof (struct symbol *));
      sym_arr[i1] = 0;

      copy = find_imps (file_symtab, block, *argptr, sym_arr, &i1, &i2); 
      *argptr = copy;
    }

  /* i1 now represents the TOTAL number of matches found.
     i2 represents how many HIGH-LEVEL (struct symbol) matches,
     which will come first in the sym_arr array.  Any low-level
     (minimal_symbol) matches will follow those.  */
      
  if (i1 == 1)
    {
      if (i2 > 0)
	{
	  /* Already a struct symbol.  */
	  sym = sym_arr[0];
	}
      else
	{
	  sym = find_pc_function (SYMBOL_VALUE_ADDRESS (sym_arr[0]));
	  if ((sym != NULL) && strcmp (SYMBOL_LINKAGE_NAME (sym_arr[0]), SYMBOL_LINKAGE_NAME (sym)) != 0)
	    {
	      warning ("debugging symbol \"%s\" does not match selector; ignoring", SYMBOL_LINKAGE_NAME (sym));
	      sym = NULL;
	    }
	}
	      
      values.sals = (struct symtab_and_line *) xmalloc (sizeof (struct symtab_and_line));
      values.nelts = 1;
	      
      if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)
	{
	  /* Canonicalize this, so it remains resolved for dylib loads.  */
	  values.sals[0] = find_function_start_sal (sym, funfirstline);
	  build_canonical_line_spec (values.sals, SYMBOL_NATURAL_NAME (sym), canonical);
	}
      else
	{
	  /* The only match was a non-debuggable symbol.  */
	  values.sals[0].symtab = 0;
	  values.sals[0].line = 0;
	  values.sals[0].end = 0;
	  values.sals[0].pc = SYMBOL_VALUE_ADDRESS (sym_arr[0]);
	}
      return values;
    }

  if (i1 > 1)
    {
      /* More than one match. The user must choose one or more.  */
      return select_symbols (sym_arr, i2, funfirstline, canonical);
    }

  return values;
}



d1574 1
a1574 1
		 int is_quoted, int is_objc_method, char *paren_pointer,
a1587 5
    }
  else if (is_objc_method)
    {
      /* allow word separators in method names for Obj-C */
      p = skip_quoted_chars (*argptr, NULL, "");
@


1.22.2.18
log
@2003-05-02  David Carlton  <carlton@@bactrian.org>

	* minsyms.c: Delete declarations for lookup_minimal_symbol_linkage
	and lookup_minimal_symbol_natural.
	* linespec.c (decode_variable): Call
	lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol.
	(decode_dollar): Ditto.
@
text
@d1668 1
a1668 1
      msymbol = lookup_minimal_symbol_linkage_or_natural (copy);
d1765 1
a1765 1
  msymbol = lookup_minimal_symbol_linkage_or_natural (copy);
@


1.22.2.19
log
@2003-05-09  David Carlton  <carlton@@bactrian.org>

	* linespec.c (examine_compound_token): Handled classes nested
	within classes, not just classes nested within namespaces.

2003-05-09  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/breakpoint.cc: New.
	* gdb.c++/breakpoint.exp: New.
	* gdb.c++/namespace.exp: Update "print C::D::cd" for current
	output.
@
text
@a803 1
  /* The namespace or class that we're nested within.  */
d820 1
d823 1
a823 8
      current_component = find_next_token (argptr);
      if (*current_component == ':')
	{
	  /* We're still in the process of reading types: we haven't
	     found the method at the bottom yet.  */
	  namespace = TYPE_TAG_NAME (t);
	}
      else
d825 14
a838 15
	  switch (TYPE_CODE (t))
	    {
	    case TYPE_CODE_STRUCT:
	    case TYPE_CODE_UNION:
	      /* Find the next token (everything up to end or next blank).  */

	      copy = alloca (current_component - *argptr + 1);
	      memcpy (copy, *argptr, current_component - *argptr);
	      copy[current_component - *argptr] = '\0';
	      if (current_component != *argptr
		  && copy[current_component - *argptr - 1]
		  && (strchr (get_gdb_completer_quote_characters (),
			      copy[current_component - *argptr - 1])
		      != NULL))
		copy[current_component - *argptr - 1] = '\0';
d840 3
a842 3
	      while (*current_component == ' ' || *current_component == '\t')
		current_component++;
	      *argptr = current_component;
d844 2
a845 2
	      *values = find_method (funfirstline, canonical, saved_arg, copy,
				     t, class_sym);
d847 11
a857 2
	      return 1;
	    case TYPE_CODE_NAMESPACE:
d861 1
a861 2
					 current_component,
					 TYPE_TAG_NAME (t),
d864 7
a870 7
	    default:
	      /* FIXME: carlton/2002-11-19: Once this all settles
		 down, this case should be an error rather than a
		 return 0; that will allow us to make VALUES the
		 return value rather than an argument.  */
	      return 0;
	    }
@


1.22.2.20
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d779 1
a779 1
  sym = lookup_symbol (copy, 0, VAR_DOMAIN, 0, &sym_symtab);
d902 3
a904 3
  return cp_lookup_symbol_namespace (namespace, copy, NULL,
				     get_selected_block(0),
				     VAR_DOMAIN, NULL);
d933 3
a935 3
  sym = cp_lookup_symbol_namespace (namespace, copy, NULL,
				    get_selected_block(0),
				    VAR_DOMAIN, &sym_symtab);
d1113 1
a1113 1
      && (lookup_symbol (class_name, NULL, STRUCT_DOMAIN, NULL,
d1662 1
a1662 1
      sym = lookup_symbol (copy, 0, VAR_DOMAIN, 0, &sym_symtab);
d1757 1
a1757 1
		       VAR_DOMAIN, NULL, &sym_symtab);
d1843 1
a1843 1
	  if (lookup_block_symbol (b, copy, NULL, VAR_DOMAIN) != NULL)
@


1.22.2.21
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a37 1
#include "linespec.h"
d330 2
@


1.22.2.22
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d128 1
a128 2
					    int is_quote_enclosed,
					    int *not_found_ptr);
d153 1
a153 2
						 struct symtab *file_symtab,
						 int *not_found_ptr);
d208 1
a208 6
   Also, the line number returned may be invalid.  
 
   If NOT_FOUND_PTR is not null, store a boolean true/false value at the location, based
   on whether or not failure occurs due to an unknown function or file.  In the case
   where failure does occur due to an unknown function or file, do not issue an error
   message.  */
d227 1
a227 1
	       int default_line, char ***canonical, int *not_found_ptr)
a241 3
  if (not_found_ptr)
    *not_found_ptr = 0;

d305 1
a305 2
	file_symtab = symtab_from_filename (argptr, p, is_quote_enclosed,
					    not_found_ptr);
d329 1
a329 2
			  is_objc_method, paren_pointer, file_symtab,
			  not_found_ptr);
d1469 1
a1469 3
   of *ARGPTR ending at FILE_NAME_END.  If NOT_FOUND_PTR is not null
   and the source file is not found, store boolean true at the
   location pointed to and do not issue an error message.  */
d1473 1
a1473 1
		       int is_quote_enclosed, int *not_found_ptr)
a1498 12
      if (not_found_ptr)
	{
	  *not_found_ptr = 1;
	  /* The caller has indicated that it wishes quiet notification of any
	     error where the function or file is not found.  A call to 
	     error_silent causes an error to occur, but it does not issue 
	     the supplied message.  The message can be manually output by
	     the caller, if desired.  This is used, for example, when 
	     attempting to set breakpoints for functions in shared libraries 
	     that have not yet been loaded.  */
	  error_silent ("No source file named %s.", copy);
	}
d1696 1
a1696 3
   look in that file's static variables first.  If NOT_FOUND_PTR is not NULL and
   the function cannot be found, store boolean true in the location pointed to
   and do not issue an error message.  */ 
d1701 1
a1701 1
		 struct symtab *file_symtab, int *not_found_ptr)
a1772 13
  if (not_found_ptr)
    {
      *not_found_ptr = 1;
      /* The caller has indicated that it wishes quiet notification of any
	 error where the function or file is not found.  A call to 
	 error_silent causes an error to occur, but it does not issue 
	 the supplied message.  The message can be manually output by
	 the caller, if desired.  This is used, for example, when 
	 attempting to set breakpoints for functions in shared libraries 
	 that have not yet been loaded.  */
      error_silent ("Function \"%s\" not defined.", copy);
    }
  
@


1.21
log
@2002-05-11 Daniel Jacobowitz  <drow@@mvista.com>

        From Peter Schauer <Peter.Schauer@@Regent.E-Technik.TU-Muenchen.DE>:
        * linespec.c (find_methods): Handle GCC 3.x template constructors.
@
text
@d29 1
d549 8
a556 2
      default_symtab = current_source_symtab;
      default_line = current_source_line;
d1030 2
a1031 1
         select_source_symtab calls us with such an argument  */
d1035 5
a1039 3
	  select_source_symtab (0);
	  default_symtab = current_source_symtab;
	  default_line = current_source_line;
@


1.21.4.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a28 1
#include "source.h"
d548 2
a549 8
      /* Use whatever we have for the default source line.  We don't use
         get_current_or_default_symtab_and_line as it can recurse and call
	 us back! */
      struct symtab_and_line cursal = 
      			get_current_source_symtab_and_line ();
      
      default_symtab = cursal.symtab;
      default_line = cursal.line;
d1023 1
a1023 2
	 set_default_source_symtab_and_line uses
         select_source_symtab that calls us with such an argument  */
d1027 3
a1029 8
          struct symtab_and_line cursal;

	  /* Make sure we have at least a default source file. */
	  set_default_source_symtab_and_line ();
          cursal = get_current_source_symtab_and_line ();
      
          default_symtab = cursal.symtab;
          default_line = cursal.line;
@


1.21.4.2
log
@merge from mainline
@
text
@d34 5
a38 1
#include "parser-defs.h"
d374 2
a375 2
      init_sal (&return_values.sals[i]);	/* initialize to zeroes */
      init_sal (&values.sals[i]);
d543 1
a543 1
  init_sal (&val);		/* initialize to zeroes */
@


1.20
log
@2002-05-10 Daniel Jacobowitz  <drow@@mvista.com>

        * linespec.c (decode_line_1): Check for a double quote after
        a filename correctly.
@
text
@d133 1
d206 3
a208 1
	  else if (strcmp_iw (class_name, name) == 0)
@


1.19
log
@2002-05-09  Elena Zannoni  <ezannoni@@redhat.com>

	From Daniel Berlin <dan@@cgsoftware.com>
	* linespec.c (find_toplevel_char): '<' and '>' also increase and
	decrease the depth we are at, in the case of templates.
@
text
@d934 4
a937 9
      if ((**argptr == '"') && is_quote_enclosed)
	{
	  memcpy (copy, *argptr + 1, p - *argptr - 1);
	  /* It may have the ending quote right after the file name */
	  if (copy[p - *argptr - 2] == '"')
	    copy[p - *argptr - 2] = 0;
	  else
	    copy[p - *argptr - 1] = 0;
	}
d939 1
a939 4
	{
	  memcpy (copy, *argptr, p - *argptr);
	  copy[p - *argptr] = 0;
	}
@


1.18
log
@gdb/ChangeLog:
* stack.c (get_selected_block): Add new argument `addr_in_block',
used to return the exact code address we used to select the block,
not just the block.
* blockframe.c (get_frame_block, get_current_block): Same.
* frame.h (get_frame_block, get_current_block,
get_selected_block): Update declarations.
* linespec.c, stack.c, blockframe.c, breakpoint.c, findvar.c,
linespec.c, varobj.c, printcmd.c, symtab.c: Callers changed.

gdb/mi/ChangeLog:
* mi-cmd-stack.c (list_args_or_locals): Pass new arg to
get_frame_block.  (See entry in gdb/ChangeLog.)
@
text
@d301 3
a303 1
   strings.  */
d326 1
a326 1
      else if (*scan == '(')
d328 1
a328 1
      else if (*scan == ')' && depth > 0)
@


1.17
log
@2002-03-22  Daniel Jacobowitz  <drow@@mvista.com>

        * symtab.h (lookup_block_symbol): Add mangled_name argument
        to prototype.

        * symmisc.c (maintenance_check_symtabs): Call lookup_block_symbol
        with new mangled_name argument.
        * linespec.c (decode_line_1): Likewise.
        * valops (value_of_this): Likewise.
        * symtab.c (lookup_transparent_type): Likewise.
        (lookup_symbol_aux): Likewise.  Accept new mangled_name argument.
        (lookup_symbol): If we are given a mangled name, pass it down
        to lookup_symbol_aux.
        (lookup_block_symbol): If we are given a mangled name to check
        against, only return symbols which match it.
@
text
@d1190 1
a1190 1
			: get_selected_block ()),
@


1.16
log
@Revert accidental commit.
@
text
@d1216 1
a1216 1
	      if (lookup_block_symbol (b, copy, VAR_NAMESPACE) != NULL)
@


1.15
log
@2002-02-14  Daniel Jacobowitz  <drow@@mvista.com>

        Fix part of PR gdb/267.
        * linespec.c (find_methods): Handle constructors specially for now.
@
text
@d1216 1
a1216 1
	      if (lookup_block_symbol (b, copy, NULL, VAR_NAMESPACE) != NULL)
@


1.14
log
@* utils.c (error_begin): Make static.
* defs.h (error_begin): Delete declaration.

* linespec.c (cplusplus_error): Replace cplusplus_hint.
(decode_line_1): Use cplusplus_error instead of error_begin,
cplusplus_hint and return_to_top_level.
* coffread.c (coff_symfile_read): Use error instead of error_begin
and return_to_top_level.
* infrun.c (default_skip_permanent_breakpoint): Ditto.
@
text
@d205 33
d1216 1
a1216 1
	      if (lookup_block_symbol (b, copy, VAR_NAMESPACE) != NULL)
@


1.13
log
@Approved by Jim Blandy:

	2001-12-10  Fred Fish  <fnf@@redhat.com>
	* arm-linux-tdep.c (skip_hurd_resolver): Use NULL rather than
	zero in args to lookup_minimal_symbol.
	* linespec.c (decode_line_1): Ditto.
	* i386-linux-tdep.c (skip_hurd_resolver): Ditto.
	* minsyms.c (find_stab_function_addr): Ditto.
	* symfile.c (simple_read_overlay_table): Ditto.
	(simple_read_overlay_region_table): Ditto.
@
text
@d45 1
a45 1
static void cplusplus_hint (char *name);
d61 3
a63 3
/* While the C++ support is still in flux, issue a possibly helpful hint on
   using the new command completion feature on single quoted demangled C++
   symbols.  Remove when loose ends are cleaned up.   FIXME -fnf */
d66 1
a66 1
cplusplus_hint (char *name)
d68 11
d81 5
a85 2
  printf_filtered ("Hint: try '%s<TAB> or '%s<ESC-?>\n", name, name);
  printf_filtered ("(Note leading single quote.)\n");
d739 1
a739 4
   error_begin ();
   printf_filtered ("no mangling for \"%s\"\n", tmp);
   cplusplus_hint (saved_arg);
   return_to_top_level (RETURN_ERROR);
a823 1
		      error_begin ();
d825 3
a827 3
			printf_filtered
			  ("the class `%s' does not have destructor defined\n",
			   SYMBOL_SOURCE_NAME (sym_class));
d829 3
a831 5
			printf_filtered
			  ("the class %s does not have any method named %s\n",
			   SYMBOL_SOURCE_NAME (sym_class), tmp);
		      cplusplus_hint (saved_arg);
		      return_to_top_level (RETURN_ERROR);
a883 1
	  error_begin ();
d885 3
a887 4
	  printf_filtered
	    ("Can't find member of namespace, class, struct, or union named \"%s\"\n", copy);
	  cplusplus_hint (saved_arg);
	  return_to_top_level (RETURN_ERROR);
@


1.12
log
@s/value_ptr/struct value */
@
text
@d1118 1
a1118 1
	  msymbol = lookup_minimal_symbol (copy, 0, 0);
@


1.11
log
@(Changes from Daniel Berlin, with revisions by Jim Blandy.)

Abstract out operations specific to particular C++ ABI's, and
invoke them through a function table.  This removes the C++ ABI
dependencies scattered throughout the code, and allows us to
cleanly add support for new C++ ABI's.
* cp-abi.h, cp-abi.h, gnu-v2-abi.c, hpacc-abi.c: New files.
* c-typeprint.c, c-valprint.c, dbxread.c, eval.c, gdbtypes.c,
jv-typeprint.c, linespec.c, symtab.c, typeprint.c, valops.c:
#include "cp-abi.h".  These files all use functions now declared
there.
* symtab.h (OPNAME_PREFIX_P, VTBL_PREFIX_P, DESTRUCTOR_PREFIX_P):
Deleted.  These services are now provided by functions declared in
cp-abi.h.
* value.h (value_rtti_type, value_virtual_fn_field): Same.
* values.c (value_virtual_fn_field): Same, for this definition.
* valops.c (value_rtti_type): Same.
* c-typeprint.c (c_type_print_base): Use the functions from
"cp-abi.h", instead of the old macros, or hard-coded ABI-specific
tests.
* dbxread.c (record_minimal_symbol): Same.
* gdbtypes.c (get_destructor_fn_field, virtual_base_index,
virtual_base_index_skip_primaries): Same.
* jv-typeprint.c (java_type_print_base): Same.
* linespec.c (find_methods, decode_line_1): Same.
* symtab.c (gdb_mangle_name): Same.
* Makefile.in (SFILES): Add the new .c files mentioned above.
(cp_abi_h): New variable.
(COMMON_OBS): Add gnu-v2-abi.o, hpacc-abi.o, and cp-abi.o.
(cp-abi.o, gnu-v2-abi.o, hpacc-abi.o): New targets.
(c-typeprint.o, c-valprint.o, dbxread.o, eval.o, gdbtypes.o,
jv-typeprint.o, symtab.o, linespec.o, typeprint.o, valops.o): Add
dependency on $(cp_abi_h).
@
text
@d1085 1
a1085 1
      value_ptr valx;
@


1.11.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d108 1
a108 1
  const char *class_name = type_name_no_tag (t);
d277 1
a277 1
      else if (*scan == '(' || *scan == '<')
d279 1
a279 1
      else if ((*scan == ')' || *scan == '>') && depth > 0)
@


1.10
log
@* config/pa/xm-hppah.h (HPPA_COMPILER_BUG): Delete. GDB only
compiles using an ISO-C compiler.
(MALLOC_INCOMPATIBLE): Ditto.
* linespec.c (decode_line_1): Delete hack to work around
HPPA_COMPILER_BUG.
@
text
@d32 1
d170 1
a170 1
		if (DESTRUCTOR_PREFIX_P (phys_name))
d805 1
a805 1
		      if (OPNAME_PREFIX_P (copy))
@


1.9
log
@* gdb/linespec.c (find_methods): Whitespace differences aren't
significant in *un*mangled method names.  Use strcmp_iw to compare
them, not STREQ.  (Fix from Daniel Berlin.)

* gdb/testsuite/gdb.c++/userdef.exp: Check that GDB tolerates whitespace in
unmangled operator names.
@
text
@a461 28
#ifdef HPPA_COMPILER_BUG
  /* FIXME: The native HP 9000/700 compiler has a bug which appears
     when optimizing this file with target i960-vxworks.  I haven't
     been able to construct a simple test case.  The problem is that
     in the second call to SKIP_PROLOGUE below, the compiler somehow
     does not realize that the statement val = find_pc_line (...) will
     change the values of the fields of val.  It extracts the elements
     into registers at the top of the block, and does not update the
     registers after the call to find_pc_line.  You can check this by
     inserting a printf at the end of find_pc_line to show what values
     it is returning for val.pc and val.end and another printf after
     the call to see what values the function actually got (remember,
     this is compiling with cc -O, with this patch removed).  You can
     also examine the assembly listing: search for the second call to
     skip_prologue; the LDO statement before the next call to
     find_pc_line loads the address of the structure which
     find_pc_line will return; if there is a LDW just before the LDO,
     which fetches an element of the structure, then the compiler
     still has the bug.

     Setting val to volatile avoids the problem.  We must undef
     volatile, because the HPPA native compiler does not define
     __STDC__, although it does understand volatile, and so volatile
     will have been defined away in defs.h.  */
#undef volatile
  volatile struct symtab_and_line val;
#define volatile		/*nothing */
#else
a462 1
#endif
@


1.8
log
@* linespec.c (find_methods): Just call CHECK_TYPEDEF on t, rather
than asking for sym_class's type; that's circuitous.  Remove
sym_class, since the last use of it is gone.
@
text
@d143 1
a143 1
	  if (STREQ (name, method_name))
@


1.7
log
@2001-03-15  Martin Hunt  <hunt@@redhat.com>

	* linespec.c (decode_line_1): Remove trailing quote
	when parsing double quotes.
@
text
@a106 1
  struct symbol *sym_class;
d113 3
a115 5
      && (sym_class = lookup_symbol (class_name,
				     (struct block *) NULL,
				     STRUCT_NAMESPACE,
				     (int *) NULL,
				     (struct symtab **) NULL)))
d119 1
a119 2
      /* FIXME: Shouldn't this just be CHECK_TYPEDEF (t)?  */
      t = SYMBOL_TYPE (sym_class);
d167 1
a167 1

@


1.6
log
@	* linespec.c (decode_line_1): Skip argptr over a leading
	double quote. Prevents alloc of 0 bytes and memcpy of -1 bytes.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000
d615 1
a615 1
  if (**argptr == '"')
d619 1
d658 1
a658 1
      char *closing_quote = strchr (p, '"');
a1094 3

  if (is_quote_enclosed && **argptr == '"')
    (*argptr)++;
@


1.5
log
@Update/correct copyright notices.
@
text
@d615 1
a615 1
  if (p[0] == '"')
d618 1
a618 1
      p++;
@


1.4
log
@Replace free() with xfree().
@
text
@d2 2
a3 1
   Copyright 1986, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.3
log
@2000-11-30  Fernando Nasser  <fnasser@@redhat.com>

        * linespec.h: New file. Declarations for linespec.c.
        * linespec.c, alpha-tdep.c, breakpoint.c, parse.c, source.c,
        symtab.c, tracepoint.c: Include the above.
        * completer.c: New file. Line completion stuff for GDB.
        (get_gdb_completer_word_break_characters,
        get_gdb_completer_quote_characters): New functions. Accessors for
        useful completer internal data.
        (filename_completer, line_completion_function, skip_quoted): Moved
        here from top.c.
        * completer.h: New file. Declarations for the above.
        * linespec.c (decode_line_1): Use
        get_gdb_completer_word_break_characters and
        get_gdb_completer_quote_characters.
        * top.c: Include completer.h.
        (filename_completer, line_completion_function, skip_quoted):
        Moved to completer.c.
        * corefile.c, exec.c, source.c, symfile.c, linespec.c: Include
        completer.h.
        * Makefile.in (SFILES): Add completer.c.
        (COMMON_OBS): Add completer.o.
        (completer.o): New target.
        (linespec.o, alpha-tdep.o, breakpoint.o, parse.o, source.o,
        symtab.o, tracepoint.o): Add linespec.h to dependencies list.
        (corefile.o, exec.o, source.o, symfile.o, linespec.o): Add completer.h
        to dependencies list.
@
text
@d166 1
a166 1
		    free (tmp_name);
d309 1
a309 1
  old_chain = make_cleanup (free, return_values.sals);
d314 1
a314 1
      make_cleanup (free, canonical_arr);
d395 1
a395 1
		  make_cleanup (free, symname);
@


1.2
log
@* symtab.c (no_symtab_msg): Remove definition.
(sources_info): Replace use of no_symtab_msg with the string
itself.
* linespec.c (no_symtab_msg): Remove declaration.
(decode_line_1): Replace uses of no_symtab_msg with the string
itself.
@
text
@d24 2
a25 1
#include "gdbtypes.h"
a27 1
#include "gdbcmd.h"
d29 2
a30 1
#include "inferior.h"
d577 2
a578 1
	       && strchr (gdb_completer_quote_characters, **argptr) != NULL);
d732 2
a733 1
		      && strchr (gdb_completer_quote_characters, **argptr) != NULL)
d772 1
a772 1
			&& strchr (gdb_completer_quote_characters,
d1103 1
a1103 1
      && strchr (gdb_completer_quote_characters, copy[0]) != NULL)
@


1.1
log
@2000-11-10  Fernando Nasser  <fnasser@@totem.toronto.redhat.com>

	* symtab.c (decode_line_1, total_number_of_methods, find_methods,
	build_command_line_spec, find_toplevel_char, decode_line_2):
	Move to linespec.c.
	* linespec.c: New file. Routines that handle linespecs, formerly
	in symtab.c.
	* symtab.h: Export find_line_symtab and find_function_start_sal,
	* Makefile.in: Add linespec.c.
@
text
@a39 2
extern char *no_symtab_msg;

d940 1
a940 1
	    error (no_symtab_msg);
d1260 1
a1260 1
    error (no_symtab_msg);
@

