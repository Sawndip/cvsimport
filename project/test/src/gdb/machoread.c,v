head	1.59;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.47
	gdb_7_6-2013-04-26-release:1.47
	gdb_7_6-branch:1.47.0.2
	gdb_7_6-2013-03-12-branchpoint:1.47
	gdb_7_5_1-2012-11-29-release:1.37
	gdb_7_5-2012-08-17-release:1.37
	gdb_7_5-branch:1.37.0.2
	gdb_7_5-2012-07-18-branchpoint:1.37
	gdb_7_4_1-2012-04-26-release:1.32.2.1
	gdb_7_4-2012-01-24-release:1.32.2.1
	gdb_7_4-branch:1.32.0.2
	gdb_7_4-2011-12-13-branchpoint:1.32
	gdb_7_3_1-2011-09-04-release:1.26
	gdb_7_3-2011-07-26-release:1.26
	gdb_7_3-branch:1.26.0.2
	gdb_7_3-2011-04-01-branchpoint:1.26
	gdb_7_2-2010-09-02-release:1.21
	gdb_7_2-branch:1.21.0.2
	gdb_7_2-2010-07-07-branchpoint:1.21
	gdb_7_1-2010-03-18-release:1.20
	gdb_7_1-branch:1.20.0.2
	gdb_7_1-2010-02-18-branchpoint:1.20
	gdb_7_0_1-2009-12-22-release:1.5
	gdb_7_0-2009-10-06-release:1.5
	gdb_7_0-branch:1.5.0.4
	gdb_7_0-2009-09-16-branchpoint:1.5
	msnyder-checkpoint-072509-branch:1.5.0.2
	msnyder-checkpoint-072509-branchpoint:1.5
	reverse-20081226-branch:1.1.0.2
	reverse-20081226-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.59
date	2013.09.25.22.48.18;	author devans;	state Exp;
branches;
next	1.58;

1.58
date	2013.09.24.14.00.06;	author jkratoch;	state Exp;
branches;
next	1.57;

1.57
date	2013.09.24.13.57.37;	author jkratoch;	state Exp;
branches;
next	1.56;

1.56
date	2013.07.01.19.52.32;	author tromey;	state Exp;
branches;
next	1.55;

1.55
date	2013.06.18.23.35.37;	author brobecke;	state Exp;
branches;
next	1.54;

1.54
date	2013.06.07.14.39.31;	author palves;	state Exp;
branches;
next	1.53;

1.53
date	2013.06.03.13.22.29;	author brobecke;	state Exp;
branches;
next	1.52;

1.52
date	2013.05.30.17.06.31;	author tromey;	state Exp;
branches;
next	1.51;

1.51
date	2013.05.06.19.38.04;	author tromey;	state Exp;
branches;
next	1.50;

1.50
date	2013.04.08.20.13.21;	author tromey;	state Exp;
branches;
next	1.49;

1.49
date	2013.04.08.20.04.42;	author tromey;	state Exp;
branches;
next	1.48;

1.48
date	2013.03.21.16.18.48;	author tromey;	state Exp;
branches;
next	1.47;

1.47
date	2013.01.01.06.32.47;	author brobecke;	state Exp;
branches;
next	1.46;

1.46
date	2012.12.15.13.10.50;	author brobecke;	state Exp;
branches;
next	1.45;

1.45
date	2012.08.22.16.24.38;	author tromey;	state Exp;
branches;
next	1.44;

1.44
date	2012.08.02.09.36.39;	author qiyao;	state Exp;
branches;
next	1.43;

1.43
date	2012.07.26.09.00.42;	author gingold;	state Exp;
branches;
next	1.42;

1.42
date	2012.07.23.14.58.44;	author tromey;	state Exp;
branches;
next	1.41;

1.41
date	2012.07.23.14.57.54;	author tromey;	state Exp;
branches;
next	1.40;

1.40
date	2012.07.23.14.56.10;	author tromey;	state Exp;
branches;
next	1.39;

1.39
date	2012.07.18.19.34.57;	author tromey;	state Exp;
branches;
next	1.38;

1.38
date	2012.07.18.19.33.34;	author tromey;	state Exp;
branches;
next	1.37;

1.37
date	2012.05.05.03.05.31;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2012.04.27.20.47.55;	author sergiodj;	state Exp;
branches;
next	1.35;

1.35
date	2012.03.14.01.46.59;	author brobecke;	state Exp;
branches;
next	1.34;

1.34
date	2012.02.16.14.57.02;	author gingold;	state Exp;
branches;
next	1.33;

1.33
date	2012.01.04.08.17.06;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2011.12.07.09.11.25;	author gingold;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2011.11.24.16.26.25;	author gingold;	state Exp;
branches;
next	1.30;

1.30
date	2011.07.01.18.36.45;	author brobecke;	state Exp;
branches;
next	1.29;

1.29
date	2011.07.01.18.36.36;	author brobecke;	state Exp;
branches;
next	1.28;

1.28
date	2011.05.26.07.47.10;	author gingold;	state Exp;
branches;
next	1.27;

1.27
date	2011.04.17.18.38.45;	author jkratoch;	state Exp;
branches;
next	1.26;

1.26
date	2011.03.07.16.17.29;	author tromey;	state Exp;
branches;
next	1.25;

1.25
date	2011.01.09.03.20.33;	author msnyder;	state Exp;
branches;
next	1.24;

1.24
date	2011.01.05.22.22.49;	author msnyder;	state Exp;
branches;
next	1.23;

1.23
date	2011.01.01.15.33.10;	author brobecke;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.30.19.14.30;	author tromey;	state Exp;
branches;
next	1.21;

1.21
date	2010.03.10.18.20.06;	author tromey;	state Exp;
branches;
next	1.20;

1.20
date	2010.02.09.15.53.00;	author gingold;	state Exp;
branches;
next	1.19;

1.19
date	2010.02.04.12.45.49;	author gingold;	state Exp;
branches;
next	1.18;

1.18
date	2010.02.03.14.13.16;	author gingold;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.14.12.47.44;	author gingold;	state Exp;
branches;
next	1.16;

1.16
date	2010.01.01.07.31.37;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2009.12.15.09.56.23;	author gingold;	state Exp;
branches;
next	1.14;

1.14
date	2009.12.15.09.41.16;	author gingold;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.15.09.37.14;	author gingold;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.09.14.53.25;	author gingold;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.07.09.47.40;	author gingold;	state Exp;
branches;
next	1.10;

1.10
date	2009.12.07.09.36.44;	author gingold;	state Exp;
branches;
next	1.9;

1.9
date	2009.12.03.14.21.22;	author gingold;	state Exp;
branches;
next	1.8;

1.8
date	2009.12.02.11.44.35;	author gingold;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.18.14.10.47;	author gingold;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.13.09.42.57;	author gingold;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.19.14.30.30;	author gingold;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.16.18.49.25;	author ppluzhnikov;	state Exp;
branches;
next	1.3;

1.3
date	2009.02.04.08.47.56;	author gingold;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.27.09.23.01;	author gingold;	state Exp;
branches;
next	;

1.32.2.1
date	2012.01.06.04.43.20;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.59
log
@	* symfile.h (struct sym_fns): Delete member "sym_flavour".
	All uses updated.
	(add_symtab_fns): Update prototype.
	* symfile.c (sym_fns_ptr): Delete.  Replace with ...
	(registered_sym_fns): ... this.
	(symtab_fns): Update.
	(add_symtab_fns): New arg "flavour".  All callers updated.
	(find_sym_fns): Rewrite to use new sym_fns registry.
@
text
@/* Darwin support for GDB, the GNU debugger.
   Copyright (C) 2008-2013 Free Software Foundation, Inc.

   Contributed by AdaCore.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "bfd.h"
#include "symfile.h"
#include "objfiles.h"
#include "buildsym.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "mach-o.h"
#include "gdb_assert.h"
#include "aout/stab_gnu.h"
#include "vec.h"
#include "psympriv.h"
#include "complaints.h"
#include "gdb_bfd.h"

#include <string.h>

/* If non-zero displays debugging message.  */
static unsigned int mach_o_debug_level = 0;

/* Dwarf debugging information are never in the final executable.  They stay
   in object files and the executable contains the list of object files read
   during the link.
   Each time an oso (other source) is found in the executable, the reader
   creates such a structure.  They are read after the processing of the
   executable.  */

typedef struct oso_el
{
  /* Object file name.  Can also be a member name.  */
  const char *name;

  /* Associated time stamp.  */
  unsigned long mtime;

  /* Stab symbols range for this OSO.  */
  asymbol **oso_sym;
  asymbol **end_sym;

  /* Number of interesting stabs in the range.  */
  unsigned int nbr_syms;
}
oso_el;

/* Vector of object files to be read after the executable.  */
DEF_VEC_O (oso_el);

static void
macho_new_init (struct objfile *objfile)
{
}

static void
macho_symfile_init (struct objfile *objfile)
{
  objfile->flags |= OBJF_REORDERED;
}

/*  Add a new OSO to the vector of OSO to load.  */

static void
macho_register_oso (VEC (oso_el) **oso_vector_ptr,
		    struct objfile *objfile,
                    asymbol **oso_sym, asymbol **end_sym,
                    unsigned int nbr_syms)
{
  oso_el el;

  el.name = (*oso_sym)->name;
  el.mtime = (*oso_sym)->value;
  el.oso_sym = oso_sym;
  el.end_sym = end_sym;
  el.nbr_syms = nbr_syms;
  VEC_safe_push (oso_el, *oso_vector_ptr, &el);
}

/* Add symbol SYM to the minimal symbol table of OBJFILE.  */

static void
macho_symtab_add_minsym (struct objfile *objfile, const asymbol *sym)
{
  if (sym->name == NULL || *sym->name == '\0')
    {
      /* Skip names that don't exist (shouldn't happen), or names
         that are null strings (may happen).  */
      return;
    }

  if (sym->flags & (BSF_GLOBAL | BSF_LOCAL | BSF_WEAK))
    {
      CORE_ADDR symaddr;
      CORE_ADDR offset;
      enum minimal_symbol_type ms_type;

      offset = ANOFFSET (objfile->section_offsets,
			 gdb_bfd_section_index (objfile->obfd, sym->section));

      /* Bfd symbols are section relative.  */
      symaddr = sym->value + sym->section->vma;

      /* Select global/local/weak symbols.  Note that bfd puts abs
         symbols in their own section, so all symbols we are
         interested in will have a section.  */
      /* Relocate all non-absolute and non-TLS symbols by the
         section offset.  */
      if (sym->section != bfd_abs_section_ptr
          && !(sym->section->flags & SEC_THREAD_LOCAL))
        symaddr += offset;

      if (sym->section == bfd_abs_section_ptr)
        ms_type = mst_abs;
      else if (sym->section->flags & SEC_CODE)
        {
          if (sym->flags & (BSF_GLOBAL | BSF_WEAK))
            ms_type = mst_text;
          else
            ms_type = mst_file_text;
        }
      else if (sym->section->flags & SEC_ALLOC)
        {
          if (sym->flags & (BSF_GLOBAL | BSF_WEAK))
            {
              if (sym->section->flags & SEC_LOAD)
                ms_type = mst_data;
              else
                ms_type = mst_bss;
            }
          else if (sym->flags & BSF_LOCAL)
            {
              /* Not a special stabs-in-elf symbol, do regular
                 symbol processing.  */
              if (sym->section->flags & SEC_LOAD)
                ms_type = mst_file_data;
              else
                ms_type = mst_file_bss;
            }
          else
            ms_type = mst_unknown;
        }
      else
        return;	/* Skip this symbol.  */

      prim_record_minimal_symbol_and_info
        (sym->name, symaddr, ms_type,
	 gdb_bfd_section_index (objfile->obfd, sym->section),
	 objfile);
    }
}

/* Build the minimal symbol table from SYMBOL_TABLE of length
   NUMBER_OF_SYMBOLS for OBJFILE.  Registers OSO filenames found.  */

static void
macho_symtab_read (struct objfile *objfile,
		   long number_of_symbols, asymbol **symbol_table,
		   VEC (oso_el) **oso_vector_ptr)
{
  long i;
  const asymbol *dir_so = NULL;
  const asymbol *file_so = NULL;
  asymbol **oso_file = NULL;
  unsigned int nbr_syms = 0;

  /* Current state while reading stabs.  */
  enum
  {
    /* Not within an SO part.  Only non-debugging symbols should be present,
       and will be added to the minimal symbols table.  */
    S_NO_SO,

    /* First SO read.  Introduce an SO section, and may be followed by a second
       SO.  The SO section should contain onl debugging symbols.  */
    S_FIRST_SO,

    /* Second non-null SO found, just after the first one.  Means that the first
       is in fact a directory name.  */
    S_SECOND_SO,

    /* Non-null OSO found.  Debugging info are DWARF in this OSO file.  */
    S_DWARF_FILE,

    S_STAB_FILE
  } state = S_NO_SO;

  for (i = 0; i < number_of_symbols; i++)
    {
      const asymbol *sym = symbol_table[i];
      bfd_mach_o_asymbol *mach_o_sym = (bfd_mach_o_asymbol *)sym;

      switch (state)
        {
        case S_NO_SO:
	  if (mach_o_sym->n_type == N_SO)
            {
              /* Start of object stab.  */
	      if (sym->name == NULL || sym->name[0] == 0)
                {
                  /* Unexpected empty N_SO.  */
                  complaint (&symfile_complaints,
                             _("Unexpected empty N_SO stab"));
                }
              else
                {
                  file_so = sym;
                  dir_so = NULL;
                  state = S_FIRST_SO;
                }
            }
          else if (sym->flags & BSF_DEBUGGING)
            {
              if (mach_o_sym->n_type == N_OPT)
                {
                  /* No complaint for OPT.  */
                  break;
                }

              /* Debugging symbols are not expected here.  */
              complaint (&symfile_complaints,
                         _("%s: Unexpected debug stab outside SO markers"),
                         objfile_name (objfile));
            }
          else
            {
              /* Non-debugging symbols go to the minimal symbol table.  */
              macho_symtab_add_minsym (objfile, sym);
            }
          break;

        case S_FIRST_SO:
        case S_SECOND_SO:
	  if (mach_o_sym->n_type == N_SO)
            {
	      if (sym->name == NULL || sym->name[0] == 0)
                {
                  /* Unexpected empty N_SO.  */
                  complaint (&symfile_complaints, _("Empty SO section"));
                  state = S_NO_SO;
                }
              else if (state == S_FIRST_SO)
                {
                  /* Second SO stab for the file name.  */
                  dir_so = file_so;
                  file_so = sym;
                  state = S_SECOND_SO;
                }
              else
                complaint (&symfile_complaints, _("Three SO in a raw"));
            }
          else if (mach_o_sym->n_type == N_OSO)
            {
	      if (sym->name == NULL || sym->name[0] == 0)
                {
                  /* Empty OSO.  Means that this file was compiled with
                     stabs.  */
                  state = S_STAB_FILE;
                  warning (_("stabs debugging not supported for %s"),
                           file_so->name);
                }
              else
                {
                  /* Non-empty OSO for a Dwarf file.  */
                  oso_file = symbol_table + i;
                  nbr_syms = 0;
                  state = S_DWARF_FILE;
                }
            }
          else
            complaint (&symfile_complaints,
                       _("Unexpected stab after SO"));
          break;

        case S_STAB_FILE:
        case S_DWARF_FILE:
	  if (mach_o_sym->n_type == N_SO)
            {
	      if (sym->name == NULL || sym->name[0] == 0)
                {
                  /* End of file.  */
                  if (state == S_DWARF_FILE)
                    macho_register_oso (oso_vector_ptr, objfile,
					oso_file, symbol_table + i,
                                        nbr_syms);
                  state = S_NO_SO;
                }
              else
                {
                  complaint (&symfile_complaints, _("Missing nul SO"));
                  file_so = sym;
                  dir_so = NULL;
                  state = S_FIRST_SO;
                }
            }
          else if (sym->flags & BSF_DEBUGGING)
            {
              if (state == S_STAB_FILE)
                {
                  /* FIXME: to be implemented.  */
                }
              else
                {
                  switch (mach_o_sym->n_type)
                    {
                    case N_FUN:
                      if (sym->name == NULL || sym->name[0] == 0)
                        break;
                      /* Fall through.  */
                    case N_STSYM:
                      /* Interesting symbol.  */
                      nbr_syms++;
                      break;
                    case N_ENSYM:
                    case N_BNSYM:
                    case N_GSYM:
                      break;
                    default:
                      complaint (&symfile_complaints,
                                 _("unhandled stab for dwarf OSO file"));
                      break;
                    }
                }
            }
          else
            complaint (&symfile_complaints,
                       _("non-debugging symbol within SO"));
          break;
        }
    }

  if (state != S_NO_SO)
    complaint (&symfile_complaints, _("missing nul SO"));
}

/* If NAME describes an archive member (ie: ARCHIVE '(' MEMBER ')'),
   returns the length of the archive name.
   Returns -1 otherwise.  */

static int
get_archive_prefix_len (const char *name)
{
  char *lparen;
  int name_len = strlen (name);

  if (name_len == 0 || name[name_len - 1] != ')')
    return -1;

  lparen = strrchr (name, '(');
  if (lparen == NULL || lparen == name)
    return -1;
  return lparen - name;
}

/* Compare function to qsort OSOs, so that members of a library are
   gathered.  */

static int
oso_el_compare_name (const void *vl, const void *vr)
{
  const oso_el *l = (const oso_el *)vl;
  const oso_el *r = (const oso_el *)vr;

  return strcmp (l->name, r->name);
}

/* Hash table entry structure for the stabs symbols in the main object file.
   This is used to speed up lookup for symbols in the OSO.  */

struct macho_sym_hash_entry
{
  struct bfd_hash_entry base;
  const asymbol *sym;
};

/* Routine to create an entry in the hash table.  */

static struct bfd_hash_entry *
macho_sym_hash_newfunc (struct bfd_hash_entry *entry,
                        struct bfd_hash_table *table,
                        const char *string)
{
  struct macho_sym_hash_entry *ret = (struct macho_sym_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = (struct macho_sym_hash_entry *) bfd_hash_allocate (table,
                                                             sizeof (* ret));
  if (ret == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = (struct macho_sym_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string);

  if (ret)
    {
      /* Initialize the local fields.  */
      ret->sym = NULL;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Get the value of SYM from the minimal symtab of MAIN_OBJFILE.  This is used
   to get the value of global and common symbols.  */

static CORE_ADDR
macho_resolve_oso_sym_with_minsym (struct objfile *main_objfile, asymbol *sym)
{
  /* For common symbol and global symbols, use the min symtab.  */
  struct minimal_symbol *msym;
  const char *name = sym->name;

  if (name[0] == bfd_get_symbol_leading_char (main_objfile->obfd))
    ++name;
  msym = lookup_minimal_symbol (name, NULL, main_objfile);
  if (msym == NULL)
    {
      warning (_("can't find symbol '%s' in minsymtab"), name);
      return 0;
    }
  else
    return SYMBOL_VALUE_ADDRESS (msym);
}

/* Add oso file OSO/ABFD as a symbol file.  */

static void
macho_add_oso_symfile (oso_el *oso, bfd *abfd, const char *name,
                       struct objfile *main_objfile, int symfile_flags)
{
  int storage;
  int i;
  asymbol **symbol_table;
  asymbol **symp;
  struct bfd_hash_table table;
  int nbr_sections;
  struct cleanup *cleanup;

  /* Per section flag to mark which section have been rebased.  */
  unsigned char *sections_rebased;

  if (mach_o_debug_level > 0)
    printf_unfiltered
      (_("Loading debugging symbols from oso: %s\n"), oso->name);

  if (!bfd_check_format (abfd, bfd_object))
    {
      warning (_("`%s': can't read symbols: %s."), oso->name,
               bfd_errmsg (bfd_get_error ()));
      gdb_bfd_unref (abfd);
      return;
    }

  if (abfd->my_archive == NULL && oso->mtime != bfd_get_mtime (abfd))
    {
      warning (_("`%s': file time stamp mismatch."), oso->name);
      gdb_bfd_unref (abfd);
      return;
    }

  if (!bfd_hash_table_init_n (&table, macho_sym_hash_newfunc,
                              sizeof (struct macho_sym_hash_entry),
                              oso->nbr_syms))
    {
      warning (_("`%s': can't create hash table"), oso->name);
      gdb_bfd_unref (abfd);
      return;
    }

  bfd_set_cacheable (abfd, 1);

  /* Read symbols table.  */
  storage = bfd_get_symtab_upper_bound (abfd);
  symbol_table = (asymbol **) xmalloc (storage);
  bfd_canonicalize_symtab (abfd, symbol_table);

  /* Init section flags.  */
  nbr_sections = bfd_count_sections (abfd);
  sections_rebased = (unsigned char *) alloca (nbr_sections);
  for (i = 0; i < nbr_sections; i++)
    sections_rebased[i] = 0;

  /* Put symbols for the OSO file in the hash table.  */
  for (symp = oso->oso_sym; symp != oso->end_sym; symp++)
    {
      const asymbol *sym = *symp;
      bfd_mach_o_asymbol *mach_o_sym = (bfd_mach_o_asymbol *)sym;

      switch (mach_o_sym->n_type)
        {
        case N_ENSYM:
        case N_BNSYM:
        case N_GSYM:
          sym = NULL;
          break;
        case N_FUN:
          if (sym->name == NULL || sym->name[0] == 0)
            sym = NULL;
          break;
        case N_STSYM:
          break;
        default:
          sym = NULL;
          break;
        }
      if (sym != NULL)
        {
          struct macho_sym_hash_entry *ent;

          ent = (struct macho_sym_hash_entry *)
            bfd_hash_lookup (&table, sym->name, TRUE, FALSE);
          if (ent->sym != NULL)
            complaint (&symfile_complaints,
                       _("Duplicated symbol %s in symbol table"), sym->name);
          else
            {
              if (mach_o_debug_level > 4)
                {
                  struct gdbarch *arch = get_objfile_arch (main_objfile);
                  printf_unfiltered
                    (_("Adding symbol %s (addr: %s)\n"),
                     sym->name, paddress (arch, sym->value));
                }
              ent->sym = sym;
            }
        }
    }

  /* Relocate symbols of the OSO.  */
  for (i = 0; symbol_table[i]; i++)
    {
      asymbol *sym = symbol_table[i];
      bfd_mach_o_asymbol *mach_o_sym = (bfd_mach_o_asymbol *)sym;

      if (mach_o_sym->n_type & BFD_MACH_O_N_STAB)
        continue;
      if ((mach_o_sym->n_type & BFD_MACH_O_N_TYPE) == BFD_MACH_O_N_UNDF
           && sym->value != 0)
        {
          /* For common symbol use the min symtab and modify the OSO
             symbol table.  */
          CORE_ADDR res;

          res = macho_resolve_oso_sym_with_minsym (main_objfile, sym);
          if (res != 0)
            {
              sym->section = bfd_com_section_ptr;
              sym->value = res;
            }
        }
      else if ((mach_o_sym->n_type & BFD_MACH_O_N_TYPE) == BFD_MACH_O_N_SECT)
        {
          /* Normal symbol.  */
          asection *sec = sym->section;
          bfd_mach_o_section *msec;
          unsigned int sec_type;

          /* Skip buggy ones.  */
          if (sec == NULL || sections_rebased[sec->index] != 0)
            continue;

          /* Only consider regular, non-debugging sections.  */
          msec = bfd_mach_o_get_mach_o_section (sec);
          sec_type = msec->flags & BFD_MACH_O_SECTION_TYPE_MASK;
          if ((sec_type == BFD_MACH_O_S_REGULAR
               || sec_type == BFD_MACH_O_S_ZEROFILL)
              && (msec->flags & BFD_MACH_O_S_ATTR_DEBUG) == 0)
            {
              CORE_ADDR addr = 0;

              if ((mach_o_sym->n_type & BFD_MACH_O_N_EXT) != 0)
                {
                  /* Use the min symtab for global symbols.  */
                  addr = macho_resolve_oso_sym_with_minsym (main_objfile, sym);
                }
              else
                {
                  struct macho_sym_hash_entry *ent;

                  ent = (struct macho_sym_hash_entry *)
                    bfd_hash_lookup (&table, sym->name, FALSE, FALSE);
                  if (ent != NULL)
                    addr = bfd_asymbol_value (ent->sym);
                }

              /* Adjust the section.  */
              if (addr != 0)
                {
                  CORE_ADDR res = addr - sym->value;

                  if (mach_o_debug_level > 3)
                    {
                      struct gdbarch *arch = get_objfile_arch (main_objfile);
                      printf_unfiltered
                        (_("resolve sect %s with %s (set to %s)\n"),
                         sec->name, sym->name,
                         paddress (arch, res));
                    }
                  bfd_set_section_vma (abfd, sec, res);
                  sections_rebased[sec->index] = 1;
                }
            }
          else
            {
              /* Mark the section as never rebased.  */
              sections_rebased[sec->index] = 2;
            }
        }
    }

  bfd_hash_table_free (&table);

  /* We need to clear SYMFILE_MAINLINE to avoid interractive question
     from symfile.c:symbol_file_add_with_addrs_or_offsets.  */
  cleanup = make_cleanup_bfd_unref (abfd);
  symbol_file_add_from_bfd
    (abfd, name, symfile_flags & ~(SYMFILE_MAINLINE | SYMFILE_VERBOSE), NULL,
     main_objfile->flags & (OBJF_REORDERED | OBJF_SHARED
			    | OBJF_READNOW | OBJF_USERLOADED),
     main_objfile);
  do_cleanups (cleanup);
}

/* Read symbols from the vector of oso files.

   Note that this function sorts OSO_VECTOR_PTR.  */

static void
macho_symfile_read_all_oso (VEC (oso_el) **oso_vector_ptr,
			    struct objfile *main_objfile,
			    int symfile_flags)
{
  int ix;
  VEC (oso_el) *vec = *oso_vector_ptr;
  oso_el *oso;
  struct cleanup *cleanup = make_cleanup (null_cleanup, NULL);

  /* Sort oso by name so that files from libraries are gathered.  */
  qsort (VEC_address (oso_el, vec), VEC_length (oso_el, vec),
         sizeof (oso_el), oso_el_compare_name);

  for (ix = 0; VEC_iterate (oso_el, vec, ix, oso);)
    {
      int pfx_len;

      /* Check if this is a library name.  */
      pfx_len = get_archive_prefix_len (oso->name);
      if (pfx_len > 0)
	{
	  bfd *archive_bfd;
	  bfd *member_bfd;
	  char *archive_name = XNEWVEC (char, pfx_len + 1);
          int last_ix;
          oso_el *oso2;
          int ix2;

	  memcpy (archive_name, oso->name, pfx_len);
	  archive_name[pfx_len] = '\0';

	  make_cleanup (xfree, archive_name);

          /* Compute number of oso for this archive.  */
          for (last_ix = ix;
               VEC_iterate (oso_el, vec, last_ix, oso2); last_ix++)
            {
              if (strncmp (oso2->name, archive_name, pfx_len) != 0)
                break;
            }

	  /* Open the archive and check the format.  */
	  archive_bfd = gdb_bfd_open (archive_name, gnutarget, -1);
	  if (archive_bfd == NULL)
	    {
	      warning (_("Could not open OSO archive file \"%s\""),
		       archive_name);
              ix = last_ix;
	      continue;
	    }
	  if (!bfd_check_format (archive_bfd, bfd_archive))
	    {
	      warning (_("OSO archive file \"%s\" not an archive."),
		       archive_name);
	      gdb_bfd_unref (archive_bfd);
              ix = last_ix;
	      continue;
	    }

	  member_bfd = gdb_bfd_openr_next_archived_file (archive_bfd, NULL);

	  if (member_bfd == NULL)
	    {
	      warning (_("Could not read archive members out of "
			 "OSO archive \"%s\""), archive_name);
	      gdb_bfd_unref (archive_bfd);
              ix = last_ix;
	      continue;
	    }

          /* Load all oso in this library.  */
	  while (member_bfd != NULL)
	    {
	      bfd *prev;
	      const char *member_name = member_bfd->filename;
              int member_len = strlen (member_name);

              /* If this member is referenced, add it as a symfile.  */
              for (ix2 = ix; ix2 < last_ix; ix2++)
                {
                  oso2 = VEC_index (oso_el, vec, ix2);

                  if (oso2->name
                      && strlen (oso2->name) == pfx_len + member_len + 2
                      && !memcmp (member_name, oso2->name + pfx_len + 1,
                                  member_len))
                    {
                      macho_add_oso_symfile (oso2, member_bfd,
					     bfd_get_filename (member_bfd),
                                             main_objfile, symfile_flags);
                      oso2->name = NULL;
                      break;
                    }
                }

              prev = member_bfd;
	      member_bfd = gdb_bfd_openr_next_archived_file (archive_bfd,
							     member_bfd);

              /* Free previous member if not referenced by an oso.  */
              if (ix2 >= last_ix)
                gdb_bfd_unref (prev);
	    }
          for (ix2 = ix; ix2 < last_ix; ix2++)
            {
              oso_el *oso2 = VEC_index (oso_el, vec, ix2);

              if (oso2->name != NULL)
                warning (_("Could not find specified archive member "
                           "for OSO name \"%s\""), oso->name);
            }
          ix = last_ix;
	}
      else
	{
          bfd *abfd;

	  abfd = gdb_bfd_open (oso->name, gnutarget, -1);
	  if (!abfd)
            warning (_("`%s': can't open to read symbols: %s."), oso->name,
                     bfd_errmsg (bfd_get_error ()));
          else
            macho_add_oso_symfile (oso, abfd, oso->name, main_objfile,
				   symfile_flags);

          ix++;
        }
    }

  do_cleanups (cleanup);
}

/* DSYM (debug symbols) files contain the debug info of an executable.
   This is a separate file created by dsymutil(1) and is similar to debug
   link feature on ELF.
   DSYM files are located in a subdirectory.  Append DSYM_SUFFIX to the
   executable name and the executable base name to get the DSYM file name.  */
#define DSYM_SUFFIX ".dSYM/Contents/Resources/DWARF/"

/* Check if a dsym file exists for OBJFILE.  If so, returns a bfd for it
   and return *FILENAMEP with its original xmalloc-ated filename.
   Return NULL if no valid dsym file is found (FILENAMEP is not used in
   such case).  */

static bfd *
macho_check_dsym (struct objfile *objfile, char **filenamep)
{
  size_t name_len = strlen (objfile_name (objfile));
  size_t dsym_len = strlen (DSYM_SUFFIX);
  const char *base_name = lbasename (objfile_name (objfile));
  size_t base_len = strlen (base_name);
  char *dsym_filename = alloca (name_len + dsym_len + base_len + 1);
  bfd *dsym_bfd;
  bfd_mach_o_load_command *main_uuid;
  bfd_mach_o_load_command *dsym_uuid;

  strcpy (dsym_filename, objfile_name (objfile));
  strcpy (dsym_filename + name_len, DSYM_SUFFIX);
  strcpy (dsym_filename + name_len + dsym_len, base_name);

  if (access (dsym_filename, R_OK) != 0)
    return NULL;

  if (bfd_mach_o_lookup_command (objfile->obfd,
                                 BFD_MACH_O_LC_UUID, &main_uuid) == 0)
    {
      warning (_("can't find UUID in %s"), objfile_name (objfile));
      return NULL;
    }
  dsym_bfd = gdb_bfd_openr (dsym_filename, gnutarget);
  if (dsym_bfd == NULL)
    {
      warning (_("can't open dsym file %s"), dsym_filename);
      return NULL;
    }

  if (!bfd_check_format (dsym_bfd, bfd_object))
    {
      gdb_bfd_unref (dsym_bfd);
      warning (_("bad dsym file format: %s"), bfd_errmsg (bfd_get_error ()));
      return NULL;
    }

  if (bfd_mach_o_lookup_command (dsym_bfd,
                                 BFD_MACH_O_LC_UUID, &dsym_uuid) == 0)
    {
      warning (_("can't find UUID in %s"), dsym_filename);
      gdb_bfd_unref (dsym_bfd);
      return NULL;
    }
  if (memcmp (dsym_uuid->command.uuid.uuid, main_uuid->command.uuid.uuid,
              sizeof (main_uuid->command.uuid.uuid)))
    {
      warning (_("dsym file UUID doesn't match the one in %s"),
	       objfile_name (objfile));
      gdb_bfd_unref (dsym_bfd);
      return NULL;
    }
  *filenamep = xstrdup (dsym_filename);
  return dsym_bfd;
}

static void
macho_symfile_read (struct objfile *objfile, int symfile_flags)
{
  bfd *abfd = objfile->obfd;
  CORE_ADDR offset;
  long storage_needed;
  bfd *dsym_bfd;
  VEC (oso_el) *oso_vector = NULL;
  struct cleanup *old_chain = make_cleanup (VEC_cleanup (oso_el), &oso_vector);

  /* Get symbols from the symbol table only if the file is an executable.
     The symbol table of object files is not relocated and is expected to
     be in the executable.  */
  if (bfd_get_file_flags (abfd) & (EXEC_P | DYNAMIC))
    {
      char *dsym_filename;

      /* Process the normal symbol table first.  */
      storage_needed = bfd_get_symtab_upper_bound (objfile->obfd);
      if (storage_needed < 0)
	error (_("Can't read symbols from %s: %s"),
	       bfd_get_filename (objfile->obfd),
	       bfd_errmsg (bfd_get_error ()));

      if (storage_needed > 0)
	{
	  asymbol **symbol_table;
	  long symcount;

	  symbol_table = (asymbol **) xmalloc (storage_needed);
	  make_cleanup (xfree, symbol_table);

          init_minimal_symbol_collection ();
          make_cleanup_discard_minimal_symbols ();

	  symcount = bfd_canonicalize_symtab (objfile->obfd, symbol_table);

	  if (symcount < 0)
	    error (_("Can't read symbols from %s: %s"),
		   bfd_get_filename (objfile->obfd),
		   bfd_errmsg (bfd_get_error ()));

	  macho_symtab_read (objfile, symcount, symbol_table, &oso_vector);

          install_minimal_symbols (objfile);
	}

      /* Try to read .eh_frame / .debug_frame.  */
      /* First, locate these sections.  We ignore the result status
	 as it only checks for debug info.  */
      dwarf2_has_info (objfile, NULL);
      dwarf2_build_frame_info (objfile);

      /* Check for DSYM file.  */
      dsym_bfd = macho_check_dsym (objfile, &dsym_filename);
      if (dsym_bfd != NULL)
	{
	  int ix;
	  oso_el *oso;
          struct bfd_section *asect, *dsect;

	  make_cleanup (xfree, dsym_filename);

	  if (mach_o_debug_level > 0)
	    printf_unfiltered (_("dsym file found\n"));

          /* Set dsym section size.  */
          for (asect = objfile->obfd->sections, dsect = dsym_bfd->sections;
               asect && dsect;
               asect = asect->next, dsect = dsect->next)
            {
              if (strcmp (asect->name, dsect->name) != 0)
                break;
              bfd_set_section_size (dsym_bfd, dsect,
                                    bfd_get_section_size (asect));
            }

	  /* Add the dsym file as a separate file.  */
	  make_cleanup_bfd_unref (dsym_bfd);
          symbol_file_add_separate (dsym_bfd, dsym_filename, symfile_flags,
				    objfile);

	  /* Don't try to read dwarf2 from main file or shared libraries.  */
	  do_cleanups (old_chain);
          return;
	}
    }

  if (dwarf2_has_info (objfile, NULL))
    {
      /* DWARF 2 sections */
      dwarf2_build_psymtabs (objfile);
    }

  /* Then the oso.  */
  if (oso_vector != NULL)
    macho_symfile_read_all_oso (&oso_vector, objfile, symfile_flags);

  do_cleanups (old_chain);
}

static bfd_byte *
macho_symfile_relocate (struct objfile *objfile, asection *sectp,
                        bfd_byte *buf)
{
  bfd *abfd = objfile->obfd;

  /* We're only interested in sections with relocation
     information.  */
  if ((sectp->flags & SEC_RELOC) == 0)
    return NULL;

  if (mach_o_debug_level > 0)
    printf_unfiltered (_("Relocate section '%s' of %s\n"),
                       sectp->name, objfile_name (objfile));

  return bfd_simple_get_relocated_section_contents (abfd, sectp, buf, NULL);
}

static void
macho_symfile_finish (struct objfile *objfile)
{
}

static void
macho_symfile_offsets (struct objfile *objfile,
                       const struct section_addr_info *addrs)
{
  unsigned int i;
  unsigned int num_sections;
  struct obj_section *osect;

  /* Allocate section_offsets.  */
  objfile->num_sections = bfd_count_sections (objfile->obfd);
  objfile->section_offsets = (struct section_offsets *)
    obstack_alloc (&objfile->objfile_obstack,
                   SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));
  memset (objfile->section_offsets, 0,
          SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));

  /* This code is run when we first add the objfile with
     symfile_add_with_addrs_or_offsets, when "addrs" not "offsets" are
     passed in.  The place in symfile.c where the addrs are applied
     depends on the addrs having section names.  But in the dyld code
     we build an anonymous array of addrs, so that code is a no-op.
     Because of that, we have to apply the addrs to the sections here.
     N.B. if an objfile slides after we've already created it, then it
     goes through objfile_relocate.  */

  for (i = 0; i < addrs->num_sections; i++)
    {
      ALL_OBJFILE_OSECTIONS (objfile, osect)
	{
	  const char *bfd_sect_name = osect->the_bfd_section->name;

	  if (strcmp (bfd_sect_name, addrs->other[i].name) == 0)
	    {
	      obj_section_offset (osect) = addrs->other[i].addr;
	      break;
	    }
	}
    }

  objfile->sect_index_text = 0;

  ALL_OBJFILE_OSECTIONS (objfile, osect)
    {
      const char *bfd_sect_name = osect->the_bfd_section->name;
      int sect_index = osect - objfile->sections;;

      if (strncmp (bfd_sect_name, "LC_SEGMENT.", 11) == 0)
	bfd_sect_name += 11;
      if (strcmp (bfd_sect_name, "__TEXT") == 0
	  || strcmp (bfd_sect_name, "__TEXT.__text") == 0)
	objfile->sect_index_text = sect_index;
    }
}

static const struct sym_fns macho_sym_fns = {
  macho_new_init,               /* init anything gbl to entire symtab */
  macho_symfile_init,           /* read initial info, setup for sym_read() */
  macho_symfile_read,           /* read a symbol file into symtab */
  NULL,				/* sym_read_psymbols */
  macho_symfile_finish,         /* finished with file, cleanup */
  macho_symfile_offsets,        /* xlate external to internal form */
  default_symfile_segments,	/* Get segment information from a file.  */
  NULL,
  macho_symfile_relocate,	/* Relocate a debug section.  */
  NULL,				/* sym_get_probes */
  &psym_functions
};

/* -Wmissing-prototypes */
extern initialize_file_ftype _initialize_machoread;

void
_initialize_machoread (void)
{
  add_symtab_fns (bfd_target_mach_o_flavour, &macho_sym_fns);

  add_setshow_zuinteger_cmd ("mach-o", class_obscure,
			     &mach_o_debug_level,
			     _("Set if printing Mach-O symbols processing."),
			     _("Show if printing Mach-O symbols processing."),
			     NULL, NULL, NULL,
			     &setdebuglist, &showdebuglist);
}
@


1.58
log
@Keep objfile original filename

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Pass down original filename for objfile.
	* coffread.c (coff_symfile_read): Update symbol_file_add_separate call.
	* elfread.c (elf_symfile_read): Likewise.
	* jit.c (jit_object_close_impl): Update allocate_objfile call, no
	longer set ORIGINAL_NAME.
	(jit_bfd_try_read_symtab): Update symbol_file_add_from_bfd call.
	* jv-lang.c (get_dynamics_objfile): Update allocate_objfile call.
	* machoread.c (macho_add_oso_symfile): Add parameter name.  Update
	symbol_file_add_from_bfd call.
	(macho_symfile_read_all_oso): Update two macho_add_oso_symfile calls.
	(macho_check_dsym): Add parameter filenamep.  Change function comment.
	Set *filenamep.
	(macho_symfile_read): New variable dsym_filename.  Update
	macho_check_dsym call.  Use it for symbol_file_add_separate.
	* objfiles.c (allocate_objfile): Add parameter name.  New comment for
	it.  Use it for objfile->original_name.
	(objfile_name): Return OBFD's filename, if available.
	* objfiles.h (allocate_objfile): Add new parameter name.
	* solib.c (solib_read_symbols): Update symbol_file_add_from_bfd call.
	* symfile-mem.c (symbol_file_add_from_memory): Update
	symbol_file_add_from_bfd call.
	* symfile.c (read_symbols): Update symbol_file_add_separate call, new
	comment for it.
	(symbol_file_add_with_addrs): New parameter name, add function comment
	for it.  Remove variable name.  Update allocate_objfile call.
	(symbol_file_add_separate): New parameter name, add function comment
	for it.  Update symbol_file_add_with_addrs call.
	(symbol_file_add_from_bfd): New parameter name.  Update
	symbol_file_add_with_addrs call.
	(symbol_file_add): Update symbol_file_add_from_bfd call.
	(reread_symbols): New variable original_name.  Save
	objfile->original_name by it.
	* symfile.h (symbol_file_add_from_bfd, symbol_file_add_separate): Add
	second parameter.
@
text
@a1031 2
  bfd_target_mach_o_flavour,

d1051 1
a1051 1
  add_symtab_fns (&macho_sym_fns);
@


1.57
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@d450 1
a450 1
macho_add_oso_symfile (oso_el *oso, bfd *abfd,
d639 1
a639 1
    (abfd, symfile_flags & ~(SYMFILE_MAINLINE | SYMFILE_VERBOSE), NULL,
d739 1
d773 2
a774 1
            macho_add_oso_symfile (oso, abfd, main_objfile, symfile_flags);
d790 4
a793 2
/* Check if a dsym file exists for OBJFILE.  If so, returns a bfd for it.
   Return NULL if no valid dsym file is found.  */
d796 1
a796 1
macho_check_dsym (struct objfile *objfile)
d849 1
d868 2
d907 1
a907 1
      dsym_bfd = macho_check_dsym (objfile);
d914 2
d932 2
a933 1
          symbol_file_add_separate (dsym_bfd, symfile_flags, objfile);
@


1.56
log
@add -Wold-style-definition

This adds -Wold-style-definition to gdb's list of warnings.  This
found a couple of spots where "()" was used where "(void)" is more
correct.

Tested by rebuilding on x86-64 Fedora 18.

	* configure.ac (build_warnings): Add -Wold-style-definition.
	* configure: Rebuild.
	* machoread.c (_initialize_machoread): Use "(void)".
	* macrocmd.c (macro_inform_no_debuginfo): Fix formatting;
	use "(void)".
@
text
@d242 1
a242 1
                         objfile->name);
d794 1
a794 1
  size_t name_len = strlen (objfile->name);
d796 1
a796 1
  const char *base_name = lbasename (objfile->name);
d803 1
a803 1
  strcpy (dsym_filename, objfile->name);
d813 1
a813 1
      warning (_("can't find UUID in %s"), objfile->name);
d840 2
a841 1
      warning (_("dsym file UUID doesn't match the one in %s"), objfile->name);
d957 1
a957 1
                       sectp->name, objfile->name);
@


1.55
log
@[Darwin] Fix cleanup leak in machoread.c:macho_symfile_read

This patch fixes a cleanup leak in macho_symfile_read (symbol_table):

          symbol_table = (asymbol **) xmalloc (storage_needed);
          make_cleanup (xfree, symbol_table);

Unfortunately, fixing the leak alone triggers a crash which occurs
while loading the symbols from an executable:

    % gdb
    (gdb) file g_exe
    [SIGSEGV]

The crash is caused by the fact that performing the cleanup
right after the call to macho_symtab_read, as currently done,
is too early.

Indeed, references to this symbol_table get saved in the oso_vector
global during the call to macho_symtab_read via calls to
macho_register_oso, and those references then get accessed
later on, when processing all the OSOs that got pushed (see
call to macho_symfile_read_all_oso).

This patch prevents this by using one single cleanup queue for
the entire function, rather than having additional separate
cleanup queues (Eg: for the handling of the minimal symbols),
thus preventing the premature free'ing of the minimal_symbols
array.

Secondly, this patch takes this opportunity for avoiding the use
of the oso_vector global, thus making it simpler to track its
lifetime.

gdb/ChangeLog:

        * machoread.c (oso_vector): Delete this global.
        (macho_register_oso): Add new parameter "oso_vector_ptr".
        Use it instead of the "oso_vector" global.
        (macho_symtab_read, macho_symfile_read_all_oso): Likewise.
        (macho_symfile_read): Use a local oso_vector, to be free'ed
        at the end of this function, in place of the old "oso_vector"
        global.  Update various function calls accordingly.  Use one
        single cleanup chain for the entire function.
@
text
@d1040 1
a1040 1
_initialize_machoread ()
@


1.54
log
@Fix formating in copyright headers.

File list found with:
$ grep "along with this program" * -A 1 -rn \
	| grep "*/" \
	| grep -v "along with this program" \
	| sed 's,-[0-9]\+-.*,,g'

Tested on x86_64 Fedora 17.

gdb/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* darwin-nat.c: Fix formating in copyright header.
	* darwin-nat.h: Likewise.
	* gnu-nat.c: Likewise.
	* machoread.c: Likewise.

gdb/testsuite/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* gdb.ada/info_types.c: Fix formating in copyright header.
	* gdb.base/break-on-linker-gcd-function.cc: Likewise.
	* gdb.base/float.c: Likewise.
	* gdb.base/inferior-died.c: Likewise.
	* gdb.base/interp.c: Likewise.
	* gdb.base/jit-main.c: Likewise.
	* gdb.base/jit-solib.c: Likewise.
	* gdb.base/long_long.c: Likewise.
	* gdb.base/longjmp.c: Likewise.
	* gdb.base/nextoverexit.c: Likewise.
	* gdb.base/pr11022.c: Likewise.
	* gdb.base/prelink-lib.c: Likewise.
	* gdb.base/prelink.c: Likewise.
	* gdb.base/prologue.c: Likewise.
	* gdb.base/restore.c: Likewise.
	* gdb.base/sigchld.c: Likewise.
	* gdb.base/solib-search-lib1.c: Likewise.
	* gdb.base/solib-search-lib2.c: Likewise.
	* gdb.base/solib-search.c: Likewise.
	* gdb.base/solib-search.h: Likewise.
	* gdb.base/whatis.c: Likewise.
	* gdb.cp/abstract-origin.cc: Likewise.
	* gdb.cp/anon-struct.cc: Likewise.
	* gdb.cp/baseenum.cc: Likewise.
	* gdb.cp/bs15503.cc: Likewise.
	* gdb.cp/call-c-1.c: Likewise.
	* gdb.cp/call-c.cc: Likewise.
	* gdb.cp/class2.cc: Likewise.
	* gdb.cp/classes.cc: Likewise.
	* gdb.cp/cttiadd.cc: Likewise.
	* gdb.cp/cttiadd1.cc: Likewise.
	* gdb.cp/cttiadd2.cc: Likewise.
	* gdb.cp/cttiadd3.cc: Likewise.
	* gdb.cp/derivation.cc: Likewise.
	* gdb.cp/derivation2.cc: Likewise.
	* gdb.cp/dispcxx.cc: Likewise.
	* gdb.cp/exception.cc: Likewise.
	* gdb.cp/gdb2384-base.cc: Likewise.
	* gdb.cp/gdb2384-base.h: Likewise.
	* gdb.cp/gdb2384.cc: Likewise.
	* gdb.cp/gdb2495.cc: Likewise.
	* gdb.cp/mb-inline.h: Likewise.
	* gdb.cp/mb-inline1.cc: Likewise.
	* gdb.cp/mb-inline2.cc: Likewise.
	* gdb.cp/member-name.cc: Likewise.
	* gdb.cp/member-ptr.cc: Likewise.
	* gdb.cp/misc.cc: Likewise.
	* gdb.cp/namespace1.cc: Likewise.
	* gdb.cp/nextoverthrow.cc: Likewise.
	* gdb.cp/pr-574.cc: Likewise.
	* gdb.cp/pr9631.cc: Likewise.
	* gdb.cp/printmethod.cc: Likewise.
	* gdb.cp/psmang1.cc: Likewise.
	* gdb.cp/psmang2.cc: Likewise.
	* gdb.cp/psymtab-parameter.cc: Likewise.
	* gdb.cp/ptype-flags.cc: Likewise.
	* gdb.cp/ref-params.cc: Likewise.
	* gdb.cp/ref-types.cc: Likewise.
	* gdb.cp/smartp.cc: Likewise.
	* gdb.cp/try_catch.cc: Likewise.
	* gdb.cp/userdef.cc: Likewise.
	* gdb.cp/using-crash.cc: Likewise.
	* gdb.cp/virtfunc.cc: Likewise.
	* gdb.cp/virtfunc2.cc: Likewise.
	* gdb.dwarf2/callframecfa.S: Likewise.
	* gdb.dwarf2/dw2-ranges.c: Likewise.
	* gdb.dwarf2/dw2-ranges2.c: Likewise.
	* gdb.dwarf2/dw2-ranges3.c: Likewise.
	* gdb.dwarf2/dw2-restore.S: Likewise.
	* gdb.dwarf2/pieces.S: Likewise.
	* gdb.dwarf2/valop.S: Likewise.
	* gdb.java/jnpe.java: Likewise.
	* gdb.mi/mi-stepn.c: Likewise.
	* gdb.mi/mi-var-cp.cc: Likewise.
	* gdb.mi/mi-var-rtti.cc: Likewise.
	* gdb.mi/ns-stale-regcache.c: Likewise.
	* gdb.mi/pr11022.c: Likewise.
	* gdb.mi/solib-lib.c: Likewise.
	* gdb.mi/solib-main.c: Likewise.
	* gdb.python/py-arch.c: Likewise.
	* gdb.python/py-block.c: Likewise.
	* gdb.python/py-breakpoint.c: Likewise.
	* gdb.python/py-events.c: Likewise.
	* gdb.python/py-evthreads.c: Likewise.
	* gdb.python/py-explore.c: Likewise.
	* gdb.python/py-explore.cc: Likewise.
	* gdb.python/py-finish-breakpoint.c: Likewise.
	* gdb.python/py-finish-breakpoint2.cc: Likewise.
	* gdb.python/py-symbol.c: Likewise.
	* gdb.threads/execl.c: Likewise.
	* gdb.threads/execl1.c: Likewise.
@
text
@d67 1
a67 2
/* Vector of object files to be read after the executable.  This is one
   global variable but it's life-time is the one of macho_symfile_read.  */
a68 1
static VEC (oso_el) *oso_vector;
d84 2
a85 1
macho_register_oso (struct objfile *objfile,
d96 1
a96 1
  VEC_safe_push (oso_el, oso_vector, &el);
d177 2
a178 1
		   long number_of_symbols, asymbol **symbol_table)
d302 2
a303 1
                    macho_register_oso (objfile, oso_file, symbol_table + i,
d646 3
a648 1
/* Read symbols from the vector of oso files.  */
d651 3
a653 1
macho_symfile_read_all_oso (struct objfile *main_objfile, int symfile_flags)
d656 1
a656 1
  VEC (oso_el) *vec;
a659 3
  vec = oso_vector;
  oso_vector = NULL;

a777 1
  VEC_free (oso_el, vec);
d854 2
a872 1
          struct cleanup *back_to;
d878 1
a878 1
          back_to = make_cleanup_discard_minimal_symbols ();
d887 1
a887 1
	  macho_symtab_read (objfile, symcount, symbol_table);
a889 1
          do_cleanups (back_to);
a904 1
	  struct cleanup *cleanup;
a908 4
	  /* Remove oso.  They won't be used.  */
	  VEC_free (oso_el, oso_vector);
	  oso_vector = NULL;

d921 1
a921 1
	  cleanup = make_cleanup_bfd_unref (dsym_bfd);
a922 1
	  do_cleanups (cleanup);
d925 1
d938 3
a940 1
    macho_symfile_read_all_oso (objfile, symfile_flags);
@


1.53
log
@Revert "fix cleanup handling in macho_symfile_read"

This patch indirectly causes a SEGV by creating a dangling pointer.
Reverting this patch while working on a clearer memory management
method for this part of the code.

gdb/Changelog:

        Revert:
        * machoread.c (macho_symfile_read): Assign first cleanup to
        'back_to'.
@
text
@d19 1
a19 2
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
@


1.52
log
@fix cleanup handling in macho_symfile_read

macho_symfile_read leaks a cleanup by assigning to 'back_to' too late.

	* machoread.c (macho_symfile_read): Assign first cleanup to
	'back_to'.
@
text
@d874 1
a874 1
	  back_to = make_cleanup (xfree, symbol_table);
d877 1
a877 1
          make_cleanup_discard_minimal_symbols ();
@


1.51
log
@	* somread.c (som_symfile_offsets): Add 'const' to addrs.
	* machoread.c (macho_symfile_offsets): Add 'const' to addrs.
	* xcoffread.c (xcoff_symfile_offsets): Add 'const' to addrs.
	Remove declaration.
@
text
@d874 1
a874 1
	  make_cleanup (xfree, symbol_table);
d877 1
a877 1
          back_to = make_cleanup_discard_minimal_symbols ();
@


1.50
log
@	* coffread.c (record_minimal_symbol): Update.
	* dbxread.c (record_minimal_symbol): Update.
	* elfread.c (record_minimal_symbol): Update.
	* machoread.c (macho_symtab_add_minsym): Update.
	* mdebugread.c (record_minimal_symbol, parse_partial_symbols):
	Update.
	* minsyms.c (prim_record_minimal_symbol): Update.
	(prim_record_minimal_symbol_full): Remove 'bfd_section'
	argument.
	(prim_record_minimal_symbol_and_info): Likewise.
	* minsyms.h (prim_record_minimal_symbol_full)
	(prim_record_minimal_symbol_and_info): Update.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): Initialize SYMBOL_SECTION.
	* xcoffread.c (record_minimal_symbol, scan_xcoff_symtab):
	Update.
@
text
@d971 1
a971 1
                       struct section_addr_info *addrs)
@


1.49
log
@	* coffread.c (cs_to_section): Use gdb_bfd_section_index.
	* elfread.c (record_minimal_symbol, elf_symtab_read): Use
	gdb_bfd_section_index.
	* gdb_bfd.c (gdb_bfd_section_index, gdb_bfd_count_sections):
	New functions.
	* gdb_bfd.h (gdb_bfd_section_index, gdb_bfd_count_sections):
	Declare.
	* machoread.c (macho_symtab_add_minsym, macho_symfile_offsets):
	Update.
	* objfiles.c (add_to_objfile_sections_full): New function.
	(add_to_objfile_sections): Use it.
	(build_section_table): Rewrite.
	(objfile_relocate1): Use gdb_bfd_section_index.  Update.
	* objfiles.h (obj_section_offset): Use gdb_bfd_section_index.
	(struct objfile) <sections>: Update comment.
	(ALL_OBJFILE_OSECTIONS): Skip sections where the_bfd_section
	is NULL.
	(ALL_OBJSECTIONS): Use it.
	* solib-dsbt.c (dsbt_relocate_main_executable): Update.
	* solib-frv.c (frv_relocate_main_executable): Update.
	* solib-target.c (solib_target_relocate_section_addresses):
	Use gdb_bfd_section_index.
	* symfile.c (build_section_addr_info_from_section_table):
	Use gdb_bfd_section_index.
	(build_section_addr_info_from_bfd, place_section): Likewise.
	* symtab.c (fixup_section): Update.
	* xcoffread.c (find_targ_sec): Use gdb_bfd_section_index.
@
text
@d170 1
a170 1
	 sym->section, objfile);
@


1.48
log
@	* symfile.c (alloc_section_addr_info): Update header.  Don't set
	'num_sections' field.
	(build_section_addr_info_from_section_table): Set 'num_sections'.
	(build_section_addr_info_from_bfd): Likewise.
	(build_section_addr_info_from_objfile): Remove dead loop
	condition.
	(free_section_addr_info): Unconditionally call xfree.
	(relative_addr_info_to_section_offsets, addrs_section_sort)
	(addr_info_make_relative, syms_from_objfile_1): Remove dead loop
	condition.
	(syms_from_objfile_1): Remove dead 'if' condition.  Check
	'num_sections'.
	(add_symbol_file_command): Set 'num_sections'.
	* symfile-mem.c (symbol_file_add_from_memory): Set
	'num_sections'.
	* somread.c (som_symfile_offsets): Remove dead loop condition.
	* machoread.c (macho_symfile_offsets): Remove dead 'if'.
	* jit.c (jit_bfd_try_read_symtab): Set 'num_sections'.
@
text
@d119 2
a120 1
      offset = ANOFFSET (objfile->section_offsets, sym->section->index);
d168 3
a170 2
        (sym->name, symaddr, ms_type, sym->section->index,
         sym->section, objfile);
d1013 1
a1013 1
      int sect_index = osect->the_bfd_section->index;
@


1.47
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a993 3
      if (addrs->other[i].name == NULL)
	continue;

@


1.46
log
@Fix NULL objfile's section_offsets dereference during symbol load.

gdb/ChangeLog:

        * symfile.c (syms_from_objfile_1): Renames syms_from_objfile.
        Remove call to init_entry_point_info.  Add OBJFILE's
        section_offsets and num_sections initialization.  Add note
        about entry info in the function documentation.
        (syms_from_objfile): New function.
        * coffread.c (coff_symfile_init): Remove call to
        init_entry_point_info.
        * machoread.c (macho_symfile_init): Likewise.
        * xcoffread.c(xcoff_symfile_init): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 2008-2012 Free Software Foundation, Inc.
@


1.45
log
@	* windows-nat.c (windows_make_so): Use gdb_bfd_open.
	* symfile.c (bfd_open_maybe_remote): Use gdb_bfd_open.
	(symfile_bfd_open): Likewise.
	(generic_load): Likewise.
	* solib.c (solib_bfd_fopen): Use gdb_bfd_open.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use
	gdb_bfd_open.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use gdb_bfd_open.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_open.
	* remote-mips.c (mips_load_srec): Use gdb_bfd_open.
	(pmon_load_fast): Likewise.
	* remote-m32r-sdi.c (m32r_load): Use gdb_bfd_open.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_open.
	* machoread.c (macho_symfile_read_all_oso): Use gdb_bfd_open.
	(macho_check_dsym): Likewise.
	* m32r-rom.c (m32r_load): Use gdb_bfd_open.
	(m32r_upload_command): Likewise.
	* gdb_bfd.h (gdb_bfd_cache): Declare.
	* gdb_bfd.c (struct gdb_bfd_data): New.
	(gdb_bfd_cache): New global.
	(struct gdb_bfd_cache_search): New.
	(hash_bfd): New function.
	(eq_bfd): Likewise.
	(gdb_bfd_open): Likewise.
	(gdb_bfd_ref): Allocate a gdb_bfd_data and attach to the BFD.
	(gdb_bfd_unref): Remove closed BFD from cache.  Update for
	gdb_bfd_data.
	* exec.c (exec_file_attach): Use gdb_bfd_open.
	* dsrec.c (load_srec): Use gdb_bfd_open.
@
text
@a81 1
  init_entry_point_info (objfile);
@


1.44
log
@gdb/
	* dwarf2loc.c (entry_values_debug): Add 'unsigned'.
	(_initialize_dwarf2loc): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* dwarf2loc.h: Update the declaration of 'entry_values_debug'.
	* dwarf2read.c (dwarf2_die_debug): Add 'unsigned'.
	(_initialize_dwarf2_read): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* darwin-nat.c (dwarwin_debug_flag): Add 'unsigned'.
	(_initialize_darwin_inferior): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* frame.c (frame_debug): Add 'unsigned'.
	(_intialize_frame): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* frame.h: Update the declaration of 'frame_debug'.
	* gdbtypes.c (overload_debug): Add 'unsigned'.
	(_initialize_gdbtypes): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* inferior.h: Update declaration of 'debug_infrun'.
	* infrun.c (debug_infrun): Add 'unsigned'.
	(_initialize_infrun): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* jit.c (jit_debug): Add 'unsigned'.
	(_initialize_jit): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* linux-nat.c (debug_linux_nat): Add 'unsigned'.
	(_initialize_linux_nat): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* linux-thread-db.c (libthread_db_debug): Add 'unsigned'.
	(_initialize_thread_db): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* machoread.c (mach_o_debug_level): Add 'unsigned'.
	(_initialize_machoread): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* mi/mi-cmd-var.c: Update the declaration of 'varobjdebug'.
	* microblaze-tdep.c (microblaze_debug_flag): Add 'unsigned'.
	(_initialize_microblaze_tdep): Call add_setshow_zuinteger_cmd
	intead of add_setshow_zinteger_cmd.
	* mips-tdep.c (mips_debug): Add 'unsigned'.
	(_initialize_mips_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* monitor.c (monitor_debug): Add 'unsigned'.
	(_initialize_remote_monitors): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* observer.c (observer_debug): Add 'unsigned'.
	(_initialize_observer): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* parse.c (expressiondebug): Add 'unsigned'.
	(_initialize_parse): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.c (record_debug): Add 'unsigned'.
	(_initialize_record): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.h: Update the declaration of 'record_debug'.
	* stap-probe.c (stap_expression_debug): Add 'unsigned'.
	(_initialize_stap_probe): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* serial.c (global_serial_debug_p): Add 'unsigned'.
	(_initialize_serial): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-dsbt.c (solib_dsbt_debug): Add 'unsigned'.
	(_initialize_dsbt_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-frv.c (solib_frv_debug): Add 'unsigned'.
	(_initialize_frv_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* target.c (targetdebug): Add 'unsigned'.
	(initialize_targets): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* valops.c (overload_debug): Add 'unsigned'.
	* varobj.c (varobjdebug): Add 'unsigned'.
	(_initialize_varobj): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* xtensa-tdep.c (xtensa_debug_level): Add 'unsigned'.
	(_initialize_xtensa_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.

	* arch-utils.h: Remove the declaration of 'gdbarch_debug'.
	* gdbarch.sh (gdbarch_debug): Add 'unsigned'.
	(extern void _initialize_gdbarch): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* gdbarch.c, gdbarch.h: Re-generated.
@
text
@d691 1
a691 1
	  archive_bfd = gdb_bfd_openr (archive_name, gnutarget);
d765 1
a765 1
	  abfd = gdb_bfd_openr (oso->name, gnutarget);
@


1.43
log
@2012-07-26  Tristan Gingold  <gingold@@adacore.com>

	* machoread.c: Include gdb_bfd.h.
@
text
@d42 1
a42 1
static int mach_o_debug_level = 0;
d1049 6
a1054 6
  add_setshow_zinteger_cmd ("mach-o", class_obscure,
			    &mach_o_debug_level,
			    _("Set if printing Mach-O symbols processing."),
			    _("Show if printing Mach-O symbols processing."),
			    NULL, NULL, NULL,
			    &setdebuglist, &showdebuglist);
@


1.42
log
@	* coffread.c (coff_symfile_read): Make a cleanup for 'debugfile'
	and 'abfd'.
	* elfread.c (elf_symfile_read): Make a cleanup for 'debugfile'
	and 'abfd'.
	* jit.c (jit_bfd_try_read_symtab): Make a cleanup for 'nbfd'.
	* machoread.c (macho_add_oso_symfile): Make a cleanup for
	'abfd'.
	(macho_symfile_read): Make a cleanup for 'dsym_bfd'.
	* objfiles.c (allocate_objfile): Acquire a new reference.
	* rs6000-nat.c (add_vmap): Don't acquire a BFD reference.
	* solib.c (solib_read_symbols): Don't acquire a BFD reference.
	* spu-linux-nat.c (spu_symbol_file_add_from_memory): Make
	a cleanup for 'nbfd'.
	* symfile-mem.c (symbol_file_add_from_memory): Make a cleanup
	for 'nbfd'.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Don't
	make a cleanup for 'abfd'.
	(symbol_file_add): Make a BFD cleanup.
@
text
@d37 1
@


1.41
log
@	* cli/cli-dump.c (bfd_openr_with_cleanup): Use gdb_bfd_openr.
	(bfd_openw_with_cleanup): Use gdb_bfd_openw.
	* corelow.c (core_open): Use gdb_bfd_fopen.
	* dsrec.c (load_srec): Use gdb_bfd_openr.
	* exec.c (exec_file_attach): Use gdb_bfd_fopen.
	* gcore.c (gcore_memory_sections): Use gdb_bfd_openw.
	* gdb_bfd.c (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): New functions.
	* gdb_bfd.h (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): Declare.
	* jit.c (bfd_open_from_target_memory): Use gdb_bfd_openr_iovec.
	* m32-rom.c (m32r_load, m32r_upload_command): Use gdb_bfd_openr.
	* machoread.c (macho_symfile_read_all_oso): Use gdb_bfd_openr,
	gdb_bfd_openr_next_archived_file.
	(macho_check_dsym): Use gdb_bfd_openr.
	(macho_add_oso_symfile): Don't call gdb_bfd_stash_filename.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_fdopenr.
	* remote-m32r-sdi.c (m32r_load): Use gdb_bfd_openr.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Use
	gdb_bfd_openr.
	* remote.c (remote_bfd_open): Use gdb_bfd_openr_iovec.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_openr, gdb_bfd_fdopenr,
	gdb_bfd_openr_next_archived_file.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use gdb_bfd_openr.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use
	gdb_bfd_openr.
	* solib-spu.c (spu_bfd_fopen): Use gdb_bfd_openr_iovec.
	* solib.c (solib_bfd_fopen): Use gdb_bfd_fopen.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_openr_iovec.
	* symfile.c (bfd_open_maybe_remote): Use gdb_bfd_openr.
	(symfile_bfd_open): Use gdb_bfd_fopen.
	(generic_load): Use gdb_bfd_openr.
	* windows-nat.c (windows_make_so): Use gdb_bfd_openr.
@
text
@d457 1
d635 1
d641 1
d903 1
d924 1
d926 1
@


1.40
log
@	* bfd-target.c (target_bfd_reopen): Update.
	* cli/cli-dump.c (bfd_openr_with_cleanup)
	(bfd_openw_with_cleanup): Update.
	* corelow.c (core_open): Update.
	* dsrec.c (load_srec): Update.
	* exec.c (exec_file_attach): Update.
	* gcore.c (create_gcore_bfd): Update.
	* gdb_bfd.c (gdb_bfd_ref): Return void.
	(gdb_bfd_open): Update.
	* gdb_bfd.h (gdb_bfd_ref): Return void.
	Update comments.
	* jit.c (jit_bfd_try_read_symtab): Update.
	* m32r-rom.c (m32r_load, m32r_upload_command): Update.
	* machoread.c (macho_symfile_read_all_oso): Update.
	(macho_check_dsym): Update.
	* procfs.c (insert_dbx_link_bpt_in_file): Update.
	* remote-m32r-sdi.c (m32r_load): Update.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Update.
	* rs6000-nat.c (add_vmap): Update.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-spu.c (spu_bfd_open): Update.
	* solib.c (solib_bfd_fopen, solib_read_symbols): Update.
	* spu-linux-nat.c (spu_bfd_open): Update.
	* symfile.c (bfd_open_maybe_remote, symfile_bfd_open)
	(generic_load): Update.
	* windows-nat.c (windows_make_so): Update.
@
text
@a631 5
  /* Make sure that the filename has the correct lifetime.  The
     current filename comes either from an OSO symbol name or from an
     archive name.  Memory for both is not managed by gdb.  */
  gdb_bfd_stash_filename (abfd);

d687 1
a687 2
	  archive_bfd = bfd_openr (archive_name, gnutarget);
	  gdb_bfd_ref (archive_bfd);
d704 1
a704 4
	  gdb_bfd_stash_filename (archive_bfd);

	  member_bfd = bfd_openr_next_archived_file (archive_bfd, NULL);
	  gdb_bfd_ref (member_bfd);
d740 2
a741 3
	      member_bfd = bfd_openr_next_archived_file (archive_bfd,
							 member_bfd);
	      gdb_bfd_ref (member_bfd);
d761 1
a761 2
	  abfd = bfd_openr (oso->name, gnutarget);
	  gdb_bfd_ref (abfd);
d811 1
a811 2
  dsym_bfd = bfd_openr (dsym_filename, gnutarget);
  gdb_bfd_ref (dsym_bfd);
a816 1
  gdb_bfd_stash_filename (dsym_filename);
@


1.39
log
@	* symfile.c (symfile_bfd_open): Don't copy name.  Call
	gdb_bfd_stash_filename.
	(load_command): Open the new BFD before freeing the old.
	(bfd_open_maybe_remote): Call gdb_bfd_stash_filename.
	* symfile-mem.c (symbol_file_add_from_memory): Don't copy name.
	Call gdb_bfd_stash_filename.
	* spu-linux-nat.c (spu_bfd_open): Don't copy name.
	* solib-spu.c (spu_bfd_fopen): Don't copy name.  Call
	gdb_bfd_stash_filename.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Free found_pathname.
	* rs6000-nat.c (add_vmap): Don't copy filename.  Call
	gdb_bfd_stash_filename.
	* remote.c (remote_bfd_open): Call gdb_bfd_stash_filename.
	* machoread.c (macho_add_oso_symfile): Call
	gdb_bfd_stash_filename.
	(macho_symfile_read_all_oso): Arrange to free archive_name.  Call
	gdb_bfd_stash_filename.
	(macho_check_dsym): Don't copy filename.  Call
	gdb_bfd_stash_filename.
	* jit.c (bfd_open_from_target_memory): Don't copy the filename.
	* gdb_bfd.c (gdb_bfd_stash_filename): New function.
	* gdb_bfd.h (gdb_bfd_stash_filename): Declare.
	* gcore.c (create_gcore_bfd): Call gdb_bfd_stash_filename.
	* exec.c (exec_close): Don't free the BFD's filename.
	(exec_file_attach): Don't copy the filename.  Call
	gdb_bfd_stash_filename.
	* corelow.c (core_close): Don't free the BFD's filename.
	(core_open): Call gdb_bfd_stash_filename.
	* corefile.c (reopen_exec_file): Remove #if 0 code.
	* solib.c (solib_bfd_fopen): Call gdb_bfd_stash_filename.  Free
	pathname.
	* dwarf2read.c (try_open_dwo_file): Call gdb_bfd_stash_filename.
@
text
@d692 2
a693 1
	  archive_bfd = gdb_bfd_ref (bfd_openr (archive_name, gnutarget));
d712 2
a713 2
	  member_bfd = gdb_bfd_ref (bfd_openr_next_archived_file (archive_bfd,
								  NULL));
d749 3
a751 3
	      member_bfd
		= gdb_bfd_ref (bfd_openr_next_archived_file (archive_bfd,
							     member_bfd));
d771 2
a772 1
	  abfd = gdb_bfd_ref (bfd_openr (oso->name, gnutarget));
d822 2
a823 1
  dsym_bfd = gdb_bfd_ref (bfd_openr (dsym_filename, gnutarget));
@


1.38
log
@	* dwarf2read.c (try_open_dwo_file): Use gdb_bfd_ref and
	gdb_bfd_unref.
	(free_dwo_file): Use gdb_bfd_unref.
	* cli/cli-dump.c: Include gdb_bfd.h.
	(bfd_openw_with_cleanup): Use gdb_bfd_ref.
	(bfd_openr_with_cleanup): Likewise.
	* windows-nat.c (windows_make_so): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* utils.c: Include gdb_bfd.h.
	(do_bfd_close_cleanup): Use gdb_bfd_unref.
	* symfile.c: Include gdb_bfd.h.
	(separate_debug_file_exists): Use gdb_bfd_unref.
	(bfd_open_maybe_remote): Use gdb_bfd_ref.
	(symfile_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	(generic_load): Use gdb_bfd_ref.
	(reread_symbols): Use gdb_bfd_unref.
	* symfile-mem.c: Include gdb_bfd.h.
	(symbol_file_add_from_memory): Use make_cleanup_bfd_close.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib.c: Include gdb_bfd.h.
	(solib_bfd_fopen): Use gdb_bfd_ref.
	(solib_bfd_open): Use gdb_bfd_unref.
	(free_so_symbols): Use gdb_bfd_unref.
	(reload_shared_libraries_1): Use gdb_bfd_unref.
	* solib-spu.c: Include gdb_bfd.h.
	(spu_bfd_fopen): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* solib-frv.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-dsbt.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-darwin.c: Include gdb_bfd.h.
	(darwin_solib_get_all_image_info_addr_at_init): Use gdb_bfd_ref,
	gdb_bfd_unref.
	(darwin_bfd_open): Use gdb_bfd_unref.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_ref, gdb_bfd_unref.
	* remote-mips.c: Include gdb_bfd.h.
	(mips_load_srec): Use gdb_bfd_ref.
	(pmon_load_fast): Use gdb_bfd_ref.
	* remote-m32r-sdi.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	* record.c: Include gdb_bfd.h.
	(record_save_cleanups): Use gdb_bfd_unref.
	(cmd_record_save): Use gdb_bfd_unref.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* objfiles.h (gdb_bfd_close_or_warn): Remove.
	(gdb_bfd_ref, gdb_bfd_unref): Move to gdb_bfd.h.
	* objfiles.c: Include gdb_bfd.h.
	(free_objfile): Use gdb_bfd_unref.
	(gdb_bfd_close_or_warn, gdb_bfd_ref, gdb_bfd_unref): Move to
	gdb_bfd.c.
	* machoread.c (macho_add_oso_symfile): Use gdb_bfd_unref.
	(macho_symfile_read_all_oso): Use gdb_bfd_ref, gdb_bfd_unref.
	(macho_check_dsym): Likewise.
	* m32r-rom.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	(m32r_upload_command): Use gdb_bfd_ref.
	* jit.c: Include gdb_bfd.h.
	(jit_bfd_try_read_symtab): Use gdb_bfd_ref, gdb_bfd_unref.
	* gdb_bfd.h: New file.
	* gdb_bfd.c: New file.
	* gcore.c: Include gdb_bfd.h.
	(create_gcore_bfd): Use gdb_bfd_ref.
	(do_bfd_delete_cleanup): Use gdb_bfd_unref.
	(gcore_command): Use gdb_bfd_unref.
	* exec.c: Include gdb_bfd.h.
	(exec_close): Use gdb_bfd_unref.
	(exec_close_1): Use gdb_bfd_unref.
	(exec_file_attach): Use gdb_bfd_ref.
	* elfread.c: Include gdb_bfd.h.
	(build_id_verify): Use gdb_bfd_unref.
	* dsrec.c: Include gdb_bfd.h.
	(load_srec): Use gdb_bfd_ref.
	* corelow.c: Include gdb_bfd.h.
	(core_close): Use gdb_bfd_unref.
	(core_open): Use gdb_bfd_ref.
	* bfd-target.c: Include gdb_bfd.h.
	(target_bfd_xclose): Use gdb_bfd_unref.
	(target_bfd_reopen): Use gdb_bfd_ref.
	* Makefile.in (SFILES): Add gdb_bfd.c.
	(HFILES_NO_SRCDIR): Add gdb_bfd.h.
	(COMMON_OBS): Add gdb_bfd.o.
@
text
@d632 4
a635 4
  /* Make sure that the filename was malloc'ed.  The current filename comes
     either from an OSO symbol name or from an archive name.  Memory for both
     is not managed by gdb.  */
  abfd->filename = xstrdup (abfd->filename);
d654 1
d681 2
d708 3
d782 1
a819 1
  dsym_filename = xstrdup (dsym_filename);
a823 1
      xfree (dsym_filename);
d826 1
a831 1
      xfree (dsym_filename);
a839 1
      xfree (dsym_filename);
a846 1
      xfree (dsym_filename);
@


1.37
log
@Replace all uses of bfd_abs_section, bfd_com_section, bfd_und_section
and bfd_ind_section with their _ptr variants, or use corresponding
bfd_is_* macros.
@
text
@d469 1
a469 1
      bfd_close (abfd);
d476 1
a476 1
      bfd_close (abfd);
d485 1
a485 1
      bfd_close (abfd);
d689 1
a689 1
	  archive_bfd = bfd_openr (archive_name, gnutarget);
d701 1
a701 1
	      bfd_close (archive_bfd);
d705 2
a706 1
	  member_bfd = bfd_openr_next_archived_file (archive_bfd, NULL);
d712 1
a712 1
	      bfd_close (archive_bfd);
d742 3
a744 2
	      member_bfd = bfd_openr_next_archived_file
		(archive_bfd, member_bfd);
d748 1
a748 1
                bfd_close (prev);
d764 1
a764 1
	  abfd = bfd_openr (oso->name, gnutarget);
d814 1
a814 1
  dsym_bfd = bfd_openr (dsym_filename, gnutarget);
d824 1
a824 1
      bfd_close (dsym_bfd);
d834 1
a834 1
      bfd_close (dsym_bfd);
d842 1
a842 1
      bfd_close (dsym_bfd);
@


1.36
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* Makefile.in (SFILES): Add `probe' and `stap-probe'.
	(COMMON_OBS): Likewise.
	(HFILES_NO_SRCDIR): Add `probe'.
	* NEWS: Mention support for static and SystemTap probes.
	* amd64-tdep.c (amd64_init_abi): Initializing proper fields used by
	SystemTap probes' arguments parser.
	* arm-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(arm_stap_is_single_operand): New function.
	(arm_stap_parse_special_token): Likewise.
	(arm_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* ax-gdb.c (require_rvalue): Removing static declaration.
	(gen_expr): Likewise.
	* ax-gdb.h (gen_expr): Declaring function.
	(require_rvalue): Likewise.
	* breakpoint.c: Include `gdb_regex.h' and `probe.h'.
	(bkpt_probe_breakpoint_ops): New variable.
	(momentary_breakpoint_from_master): Set the `probe' value.
	(add_location_to_breakpoint): Likewise.
	(break_command_1): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(bkpt_probe_insert_location): New function.
	(bkpt_probe_remove_location): Likewise.
	(bkpt_probe_create_sals_from_address): Likewise.
	(bkpt_probe_decode_linespec): Likewise.
	(tracepoint_probe_create_sals_from_address): Likewise.
	(tracepoint_probe_decode_linespec): Likewise.
	(tracepoint_probe_breakpoint_ops): New variable.
	(trace_command): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(initialize_breakpoint_ops): Initializing breakpoint_ops for
	static probes on breakpoints and tracepoints.
	* breakpoint.h (struct bp_location) <probe>: New field.
	* cli-utils.c (skip_spaces_const): New function.
	(extract_arg): Likewise.
	* cli-utils.h (skip_spaces_const): Likewise.
	(extract_arg): Likewise.
	* coffread.c (coff_sym_fns): Add `sym_probe_fns' value.
	* configure.ac: Append `stap-probe.o' to be generated when ELF
	support is present.
	* configure: Regenerate.
	* dbxread.c (aout_sym_fns): Add `sym_probe_fns' value.
	* elfread.c: Include `probe.h' and `arch-utils.h'.
	(probe_key): New variable.
	(elf_get_probes): New function.
	(elf_get_probe_argument_count): Likewise.
	(elf_evaluate_probe_argument): Likewise.
	(elf_compile_to_ax): Likewise.
	(elf_symfile_relocate_probe): Likewise.
	(stap_probe_key_free): Likewise.
	(elf_probe_fns): New variable.
	(elf_sym_fns): Add `sym_probe_fns' value.
	(elf_sym_fns_lazy_psyms): Likewise.
	(elf_sym_fns_gdb_index): Likewise.
	(_initialize_elfread): Initialize objfile cache for static
	probes.
	* gdb_vecs.h (struct probe): New forward declaration.
	(probe_p): New VEC declaration.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (stap_integer_prefix): New variable.
	(stap_integer_suffix): Likewise.
	(stap_register_prefix): Likewise.
	(stap_register_suffix): Likewise.
	(stap_register_indirection_prefix): Likewise.
	(stap_register_indirection_suffix): Likewise.
	(stap_gdb_register_prefix): Likewise.
	(stap_gdb_register_suffix): Likewise.
	(stap_is_single_operand): New function.
	(stap_parse_special_token): Likewise.
	(struct stap_parse_info): Forward declaration.
	* i386-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	(i386_elf_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* i386-tdep.h (i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	* machoread.c (macho_sym_fns): Add `sym_probe_fns' value.
	* mipsread.c (ecoff_sym_fns): Likewise.
	* objfiles.c (objfile_relocate1): Support relocation for static
	probes.
	* parse.c (prefixify_expression): Remove static declaration.
	(initialize_expout): Likewise.
	(reallocate_expout): Likewise.
	* parser-defs.h (initialize_expout): Declare function.
	(reallocate_expout): Likewise.
	(prefixify_expression): Likewise.
	* ppc-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(ppc_stap_is_single_operand): New function.
	(ppc_stap_parse_special_token): Likewise.
	(ppc_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* probe.c: New file, for generic statically defined probe support.
	* probe.h: Likewise.
	* s390-tdep.c: Including headers needed to perform the parsing of
	SystemTap probes' arguments.
	(s390_stap_is_single_operand): New function.
	(s390_gdbarch_init): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* somread.c (som_sym_fns): Add `sym_probe_fns' value.
	* stap-probe.c: New file, for SystemTap probe support.
	* stap-probe.h: Likewise.
	* symfile.h: Include `gdb_vecs.h'.
	(struct sym_probe_fns): New struct.
	(struct sym_fns) <sym_probe_fns>: New field.
	* symtab.c (init_sal): Initialize `probe' field.
	* symtab.h (struct probe): Forward declaration.
	(struct symtab_and_line) <probe>: New field.
	* tracepoint.c (start_tracing): Adjust semaphore on breakpoints
	locations.
	(stop_tracing): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add `sym_probe_fns' value.
@
text
@d129 1
a129 1
      if (sym->section != &bfd_abs_section
d133 1
a133 1
      if (sym->section == &bfd_abs_section)
d566 1
a566 1
              sym->section = &bfd_com_section;
@


1.35
log
@Fix -Wmissing-prototypes build warnings on Darwin.

gdb/
2012-03-13  Josh Matthews  <josh@@joshmatthews.net>

	* darwin-nat-info.c (_initialize_darwin_info_commands): Add
	prototype.
	(darwin_debug_port_info): Make static.
	* darwin-nat.c (_initialize_darwin_inferior): Add prototype.
	* machoread.c (_initialize_machoread): Add prototype.
	* i386-darwin-nat.c (i386_darwin_dr_set, i386_darwin_dr_get)
	(i386_darwin_set_control, i386_darwin_get_control)
	i386_darwin_dr_set_addr, i386_darwin_get_addr)
	i386_darwin_get_status, i386_darwin_get_control):
	Comment out with HW_WATCHPOINT_NOT_YET_ENABLED macro.
@
text
@d1035 1
@


1.34
log
@2012-02-16  Josh Matthews  <josh@@joshmatthews.net>

        * machoread.c: Initialize nbr_syms to avoid warnings-as-errors failure.
@
text
@d1038 3
@


1.33
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d183 1
a183 1
  unsigned int nbr_syms;
@


1.32
log
@2011-12-07  Tristan Gingold  <gingold@@adacore.com>

	* machoread.c (macho_symtab_read): Do not consider N_OPT as
	a debugging stab.  Improve complaint message.
@
text
@d2 1
a2 1
   Copyright (C) 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.32.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
   Copyright (C) 2008-2012 Free Software Foundation, Inc.
@


1.31
log
@2011-11-24  Tristan Gingold  <gingold@@adacore.com>

	* machoread.c (oso_el): Remove num_Sections, symbols, offsets
	fields.  Add oso_sym, end_sym and nbr_syms.
	(macho_register_oso): Change interface.
	(macho_symtab_add_minsym): New function.
	(macho_symtab_read): Rewritten.
	(get_archive_prefix_len): Remove trailing blanks.
	(oso_el_compare_name): Add comment.
	(struct macho_sym_hash_entry): New structure.
	(macho_relocate_common_syms): Remove.
	(macho_sym_hash_newfunc): New function.
	(macho_resolve_oso_sym_with_minsym): Likewise.
	(macho_add_oso_symfile): Rewritten.
	(macho_symfile_read_all_oso): Remove trailing blanks.
	Adjust code to free oso vector.
	(macho_symfile_read): Likewise.
	Move code to initialize minimal symbol
@
text
@d232 6
d240 2
a241 1
                         _("Unexpected debug stab outside SO markers"));
@


1.30
log
@remove comment in machoread.c (macho_symfile_read)

Does not seem to be applicable to the current code anymore.

gdb/ChangeLog:

        * machoread.c (macho_symfile_read): Delete OBE comment.
@
text
@d36 1
d52 1
a52 1
  /* Object file name.  */
d58 3
a60 2
  /* Number of sections.  This is the length of SYMBOLS and OFFSETS array.  */
  int num_sections;
d62 2
a63 6
  /* Each seaction of the object file is represented by a symbol and its
     offset.  If the offset is 0, we assume that the symbol is at offset 0
     in the OSO object file and a symbol lookup in the main file is
     required to get the offset.  */
  asymbol **symbols;
  bfd_vma *offsets;
d87 3
a89 2
macho_register_oso (const asymbol *oso_sym, int nbr_sections,
                    asymbol **symbols, bfd_vma *offsets)
d93 5
a97 5
  el.name = oso_sym->name;
  el.mtime = oso_sym->value;
  el.num_sections = nbr_sections;
  el.symbols = symbols;
  el.offsets = offsets;
d101 1
a101 3
/* Build the minimal symbol table from SYMBOL_TABLE of length
   NUMBER_OF_SYMBOLS for OBJFILE.
   Read OSO files at the end.  */
d104 1
a104 2
macho_symtab_read (struct objfile *objfile,
		   long number_of_symbols, asymbol **symbol_table)
d106 6
a111 9
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  long storage_needed;
  long i, j;
  CORE_ADDR offset;
  enum minimal_symbol_type ms_type;
  unsigned int nbr_sections = bfd_count_sections (objfile->obfd);
  asymbol **first_symbol = NULL;
  bfd_vma *first_offset = NULL;
  const asymbol *oso_file = NULL;
d113 1
a113 1
  for (i = 0; i < number_of_symbols; i++)
d115 3
a117 2
      asymbol *sym = symbol_table[i];
      bfd_mach_o_asymbol *mach_o_sym = (bfd_mach_o_asymbol *)sym;
d121 44
a164 3
      if (sym->flags & BSF_DEBUGGING)
	{
	  bfd_vma addr;
d166 5
a170 2
          /* Debugging symbols are used to collect OSO file names as well
             as section offsets.  */
d172 2
a173 54
	  switch (mach_o_sym->n_type)
	    {
	    case N_SO:
              /* An empty SO entry terminates a chunk for an OSO file.  */
	      if ((sym->name == NULL || sym->name[0] == 0) && oso_file != NULL)
		{
		  macho_register_oso (oso_file, nbr_sections,
                                      first_symbol, first_offset);
		  first_symbol = NULL;
		  first_offset = NULL;
		  oso_file = NULL;
		}
	      break;
	    case N_FUN:
	    case N_STSYM:
	      if (sym->name == NULL || sym->name[0] == '\0')
		break;
	      /* Fall through.  */
	    case N_BNSYM:
	      gdb_assert (oso_file != NULL);
	      addr = sym->value 
		+ bfd_get_section_vma (sym->section->bfd, sym->section);
	      if (addr != 0
		  && first_symbol[sym->section->index] == NULL)
		{
                  /* These STAB entries can directly relocate a section.  */
		  first_symbol[sym->section->index] = sym;
		  first_offset[sym->section->index] = addr + offset;
		}
	      break;
	    case N_GSYM:
	      gdb_assert (oso_file != NULL);
	      if (first_symbol[sym->section->index] == NULL)
                {
                  /* This STAB entry needs a symbol look-up to relocate
                     the section.  */
                  first_symbol[sym->section->index] = sym;
                  first_offset[sym->section->index] = 0;
                }
	      break;
	    case N_OSO:
              /* New OSO file.  */
	      gdb_assert (oso_file == NULL);
	      first_symbol = (asymbol **)xmalloc (nbr_sections
						  * sizeof (asymbol *));
	      first_offset = (bfd_vma *)xmalloc (nbr_sections
						 * sizeof (bfd_vma));
	      for (j = 0; j < nbr_sections; j++)
		first_symbol[j] = NULL;
	      oso_file = sym;
	      break;
	    }
	  continue;
	}
d175 24
a198 6
      if (sym->name == NULL || *sym->name == '\0')
	{
	  /* Skip names that don't exist (shouldn't happen), or names
	     that are null strings (may happen).  */
	  continue;
	}
d200 2
a201 4
      if (sym->flags & (BSF_GLOBAL | BSF_LOCAL | BSF_WEAK))
	{
	  struct minimal_symbol *msym;
	  CORE_ADDR symaddr;
d203 2
a204 2
	  /* Bfd symbols are section relative.  */
	  symaddr = sym->value + sym->section->vma;
d206 4
a209 41
	  /* Select global/local/weak symbols.  Note that bfd puts abs
	     symbols in their own section, so all symbols we are
	     interested in will have a section.  */
	  /* Relocate all non-absolute and non-TLS symbols by the
	     section offset.  */
	  if (sym->section != &bfd_abs_section
	      && !(sym->section->flags & SEC_THREAD_LOCAL))
	    symaddr += offset;

	  if (sym->section == &bfd_abs_section)
	    ms_type = mst_abs;
	  else if (sym->section->flags & SEC_CODE)
	    {
	      if (sym->flags & (BSF_GLOBAL | BSF_WEAK))
		ms_type = mst_text;
	      else
		ms_type = mst_file_text;
	    }
	  else if (sym->section->flags & SEC_ALLOC)
	    {
	      if (sym->flags & (BSF_GLOBAL | BSF_WEAK))
		{
		  if (sym->section->flags & SEC_LOAD)
		    ms_type = mst_data;
		  else
		    ms_type = mst_bss;
		}
	      else if (sym->flags & BSF_LOCAL)
		{
		  /* Not a special stabs-in-elf symbol, do regular
		     symbol processing.  */
		  if (sym->section->flags & SEC_LOAD)
		    ms_type = mst_file_data;
		  else
		    ms_type = mst_file_bss;
		}
	      else
		ms_type = mst_unknown;
	    }
	  else
	    continue;	/* Skip this symbol.  */
d211 31
a241 8
	  gdb_assert (sym->section->index < nbr_sections);
	  if (oso_file != NULL
	      && first_symbol[sym->section->index] == NULL)
	    {
              /* Standard symbols can directly relocate sections.  */
	      first_symbol[sym->section->index] = sym;
	      first_offset[sym->section->index] = symaddr;
	    }
d243 97
a339 4
	  msym = prim_record_minimal_symbol_and_info
	    (sym->name, symaddr, ms_type, sym->section->index,
	     sym->section, objfile);
	}
d342 2
a343 3
  /* Just in case there is no trailing SO entry.  */
  if (oso_file != NULL)
    macho_register_oso (oso_file, nbr_sections, first_symbol, first_offset);
d358 1
a358 1
  
d365 3
d377 2
a378 1
/* Relocate all of ABFD's common symbols immediately.
d380 5
a384 9
   This modifies the section and address of all common symbols to become
   absolute symbols with their address set to match the address given by
   the main objfile's symbol table.

   The reason why the common symbols have to be handled separately
   is because relocation is performed relative to section start.
   But there is no section in this case.  So the "relocation" of
   these common symbols is performed by finding their address in
   the main objfile's symbol table, where we know it's been relocated.
d386 1
a386 2
   ABFD is an OSO's bfd.
   MAIN_OBJFILE is the object file from which the OSO is a part.  */
d388 14
a401 7
static void
macho_relocate_common_syms(bfd *abfd, struct objfile *main_objfile)
{
  int storage;
  int i;
  char leading_char;
  asymbol **symbol_table;
d403 3
a405 3
  storage = bfd_get_symtab_upper_bound (abfd);
  symbol_table = (asymbol **) xmalloc (storage);
  bfd_canonicalize_symtab (abfd, symbol_table);
d407 5
a411 1
  leading_char = bfd_get_symbol_leading_char (abfd);
d413 2
a414 3
  for (i = 0; symbol_table[i]; i++)
    {
      asymbol *sym = symbol_table[i];
d416 2
a417 5
      if (bfd_is_com_section (sym->section))
	{
	  /* This one must be solved.  */
	  struct minimal_symbol *msym;
	  const char *name = sym->name;
d419 6
a424 2
	  if (name[0] == leading_char)
	    name++;
d426 7
a432 12
	  msym = lookup_minimal_symbol (name, NULL, main_objfile);
	  if (msym == NULL)
	    {
	      warning (_("can't find symbol '%s' in minsymtab"), name);
	      continue;
	    }
	  else
	    {
	      sym->section = &bfd_abs_section;
	      sym->value = SYMBOL_VALUE_ADDRESS (msym);
	    }
	}
d434 2
a435 2

  xfree (symbol_table);
d438 1
a438 1
/* Add an oso file as a symbol file.  */
d444 1
a444 1
  struct objfile *objfile;
d446 7
a452 1
  char leading_char;
d455 2
a456 1
    printf_unfiltered (_("Loading symbols from oso: %s\n"), oso->name);
d466 16
d484 4
a487 1
  /* Relocate sections.  */
d489 5
a493 1
  leading_char = bfd_get_symbol_leading_char (main_objfile->obfd);
d495 2
a496 1
  for (i = 0; i < oso->num_sections; i++)
d498 2
a499 3
      asection *sect;
      const char *sectname;
      bfd_vma vma;
d501 18
a518 7
      /* Empty slot.  */
      if (oso->symbols[i] == NULL)
        continue;

      if (oso->offsets[i])
        vma = oso->offsets[i];
      else
d520 1
a520 2
          struct minimal_symbol *msym;
          const char *name = oso->symbols[i]->name;
d522 6
a527 9
          if (name[0] == leading_char)
            ++name;

          if (mach_o_debug_level > 3)
            printf_unfiltered (_("resolve sect %s with %s\n"),
                               oso->symbols[i]->section->name,
                               oso->symbols[i]->name);
          msym = lookup_minimal_symbol (name, NULL, main_objfile);
          if (msym == NULL)
d529 8
a536 2
              warning (_("can't find symbol '%s' in minsymtab"), name);
              continue;
a537 2
          else
            vma = SYMBOL_VALUE_ADDRESS (msym);
d539 1
a539 1
      sectname = (char *)oso->symbols[i]->section->name;
d541 10
a550 2
      sect = bfd_get_section_by_name (abfd, sectname);
      if (sect == NULL)
d552 10
a561 3
          warning (_("can't find section '%s' in OSO file %s"),
                   sectname, oso->name);
          continue;
d563 34
a596 1
      bfd_set_section_vma (abfd, sect, vma);
d598 23
a620 3
      if (mach_o_debug_level > 1)
        printf_unfiltered (_("  %s: %s\n"),
                           core_addr_to_string (vma), sectname);
d623 1
a623 4
  /* Deal with the common symbols now, as they need special handing.
     Doing it now sets them up so that we don't accidently try to
     relocate them during the normal relocation phase.  */
  macho_relocate_common_syms (abfd, main_objfile);
d632 1
a632 1
  objfile = symbol_file_add_from_bfd
d650 1
a650 1
  
d658 1
a658 1
      
d680 1
a680 1
	  
d699 1
a699 1
	  
a765 5
  for (ix = 0; VEC_iterate (oso_el, vec, ix, oso); ix++)
    {
      xfree (oso->symbols);
      xfree (oso->offsets);
    }
a843 1
  struct cleanup *back_to;
a847 3
  init_minimal_symbol_collection ();
  back_to = make_cleanup_discard_minimal_symbols ();

d864 1
d868 4
d873 1
a873 1
	  
d878 1
a878 1
	  
d880 3
a883 2
      
      install_minimal_symbols (objfile);
d890 1
a890 1
      
a902 5
	  for (ix = 0; VEC_iterate (oso_el, oso_vector, ix, oso); ix++)
	    {
	      xfree (oso->symbols);
	      xfree (oso->offsets);
	    }
d919 1
a919 1
      
d1007 1
a1007 1
      
@


1.29
log
@[mach-o] get rid of current_oso global

This current_oso global was used to store the OSO's symbol table
in order to relocate common symbols.  But it is also making the
assumption that all sections are going to be immediately relocated
as macho_add_oso_symfile does:
  - Initialize the current_oso
  - Use it through symbol_file_add_from_bfd
  - Reset the current_oso (to all fields NULL)

What actually happens is that the .debug_frame section gets read
lazily, and thus relocated at a later time.  This relocation causes
current_oso.symbol_table to be initialized (see macho_symfile_relocate)
again.  And this eventually causes to trip the...

        gdb_assert (current_oso.symbol_table == NULL);

...assertion to fail because the symbol_table was never free'ed.
To be complete, this happens because macho_symfile_relocate was
called outside of macho_add_oso_symfile's control, where the
set-global/use/unset-global dance happens.

But it looks like keeping this global around is not necessary, as
this symbol table is only used to relocate the common symbols.
We can do that prior to relocating the rest of the symbols.

gdb/ChangeLog:

        * machoread.c (struct macho_oso_data): Delete.
        (current_oso): Delete.
        (macho_relocate_common_syms): New function, mostly extracted
        out of
        (macho_add_oso_symfile): Call macho_relocate_common_syms.
        Remove code that sets and unset current_oso.
        (macho_symfile_relocate): Delete handling of common symbols,
        now moved to macho_relocate_common_syms.
@
text
@a747 3
  /* Do not try to read .eh_frame/.debug_frame as they are not relocated
     and dwarf2_build_frame_info cannot deal with unrelocated sections.  */

@


1.28
log
@2011-05-26  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (struct dwarf2_section_names): New type.
	(struct dwarf2_debug_sections): New type.
	(dwarf2_has_info): Add parameter.
	* dwarf2read.c (dwarf2_elf_names): New variable.
	(INFO_SECTION, ABBREV_SECTION, LINE_SECTION, LOC_SECTION)
	(MACINFO_SECTION, STR_SECTION, RANGES_SECTION, TYPES_SECTION)
	(FRAME_SECTION, EH_FRAME_SECTION, GDB_INDEX_SECTION): Remove.
	(dwarf2_has_info): Add names parameter.  Pass names
	to dwarf2_locate_sections.
	(section_is_p): Rewrite using the names parameter.
	(dwarf2_locate_sections): Use section names from the names parameter.
	* coffread.c (coff_symfile_read): Adjust call to dwarf2_has_info.
	* elfread.c (read_psyms): Ditto.
	* machoread.c (macho_symfile_read): Ditto.
@
text
@a73 17
struct macho_oso_data
{
  /* Per objfile symbol table.  This is used to apply relocation to sections
     It is loaded only once, then relocated, and free after sections are
     relocated.  */
  asymbol **symbol_table;

  /* The offsets for this objfile.  Used to relocate the symbol_table.  */
  struct oso_el *oso;

  struct objfile *main_objfile;
};

/* Data for OSO being processed.  */

static struct macho_oso_data current_oso;

d294 59
d429 5
a438 3
  gdb_assert (current_oso.symbol_table == NULL);
  current_oso.main_objfile = main_objfile;

a445 7

  current_oso.main_objfile = NULL;
  if (current_oso.symbol_table)
    {
      xfree (current_oso.symbol_table);
      current_oso.symbol_table = NULL;
    }
a770 41
  if (current_oso.symbol_table == NULL)
    {
      int storage;
      int i;
      char leading_char;

      storage = bfd_get_symtab_upper_bound (abfd);
      current_oso.symbol_table = (asymbol **) xmalloc (storage);
      bfd_canonicalize_symtab (abfd, current_oso.symbol_table);

      leading_char = bfd_get_symbol_leading_char (abfd);

      for (i = 0; current_oso.symbol_table[i]; i++)
        {
          asymbol *sym = current_oso.symbol_table[i];

          if (bfd_is_com_section (sym->section))
            {
              /* This one must be solved.  */
              struct minimal_symbol *msym;
              const char *name = sym->name;

              if (name[0] == leading_char)
                name++;

              msym = lookup_minimal_symbol
                (name, NULL, current_oso.main_objfile);
              if (msym == NULL)
                {
                  warning (_("can't find symbol '%s' in minsymtab"), name);
                  continue;
                }
              else
                {
                  sym->section = &bfd_abs_section;
                  sym->value = SYMBOL_VALUE_ADDRESS (msym);
                }
            }
        }
    }

@


1.27
log
@bfd/
	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Do not check for
	SEC_LOAD.

gdb/
	Fix convert_code_addr_to_desc_addr for ppc64 files after eu-strip.
	* elfread.c (elf_symfile_read): New variable synth_abfd, pass it to
	bfd_get_synthetic_symtab.
	* jit.c (jit_register_code): Pass NULL to the new parameter parent.
	* machoread.c (macho_add_oso_symfile): Pass main_objfile to the new
	parameter parent, remove the call to add_separate_debug_objfile.
	* solib.c (solib_read_symbols): Pass NULL to the new parameter parent.
	* symfile-mem.c (symbol_file_add_from_memory): Likewise.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): New parameter
	parent, new comment for it, call add_separate_debug_objfile for it.
	(symbol_file_add_separate): Pass objfile as the parameter parent,
	remove the call to add_separate_debug_objfile.
	(symbol_file_add_from_bfd): New parameter parent, pass it.
	(symbol_file_add): Pass NULL to the new parameter parent.
	* symfile.h (symbol_file_add_from_bfd): New parameter parent.

gdb/testsuite/
	* gdb.base/eu-strip-infcall.c: New file.
	* gdb.base/eu-strip-infcall.exp: New file.
@
text
@d663 1
a663 1
      dwarf2_has_info (objfile);
d705 1
a705 1
  if (dwarf2_has_info (objfile))
@


1.26
log
@	* xcoffread.c (xcoff_sym_fns): Update.
	* symfile.h (struct sym_fns) <sym_read_psymbols>: New field.
	(enum symfile_add_flags) <SYMFILE_NO_READ>: New constant.
	* symfile.c (syms_from_objfile): Handle SYMFILE_NO_READ.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	(reread_symbols): Handle OBJF_PSYMTABS_READ.
	* somread.c (som_sym_fns): Update.
	* psymtab.h (require_partial_symbols): Declare.
	* psymtab.c (require_partial_symbols): New function.
	(ALL_OBJFILE_PSYMTABS_REQUIRED): New macro.
	(ALL_OBJFILE_PSYMTABS): Undef.
	(ALL_PSYMTABS): Move from psympriv.h.
	(lookup_partial_symtab, find_pc_sect_psymtab)
	(lookup_symbol_aux_psymtabs, relocate_psymtabs)
	(find_last_source_symtab_from_partial)
	(forget_cached_source_info_partial)
	(print_psymtab_stats_for_objfile, read_symtabs_for_function)
	(expand_partial_symbol_tables, read_psymtabs_with_filename)
	(map_symbol_names_psymtab, map_symbol_filenames_psymtab)
	(find_symbol_file_from_partial, map_matching_symbols_psymtab)
	(expand_symtabs_matching_via_partial, maintenance_info_psymtabs):
	Use ALL_OBJFILE_PSYMTABS_REQUIRED.
	* psympriv.h (ALL_PSYMTABS): Move to psymtab.c.
	* objfiles.h (OBJF_PSYMTABS_READ): New macro.
	* objfiles.c (objfile_has_partial_symbols): Handle lazily-read
	psymtabs.
	* mipsread.c (ecoff_sym_fns): Update.
	* machoread.c (macho_sym_fns): Update.
	* elfread.c (elf_symfile_read): Set up for lazy psymtab reading.
	(read_psyms): New function.
	(elf_sym_fns, elf_sym_fns_gdb_index): Update.
	(elf_sym_fns_lazy_psyms): New global.
	* dwarf2read.c (dwarf2_initialize_objfile): Don't call
	dwarf2_build_psymtabs.
	* dbxread.c (aout_sym_fns): Update.
	* coffread.c (coff_sym_fns): Update.
@
text
@d400 2
a401 2
                            | OBJF_READNOW | OBJF_USERLOADED));
  add_separate_debug_objfile (objfile, main_objfile);
@


1.25
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* m2-exp.y: Comment cleanup, mostly periods and spaces.
	* m2-lang.c: Ditto.
	* m2-typeprint.c: Ditto.
	* m2-valprint.c: Ditto.
	* m32c-tdep.c: Ditto.
	* m32r-linux-nat.c: Ditto.
	* m32r-rom.c: Ditto.
	* m32r-tdep.c: Ditto.
	* m32r-tdep.h: Ditto.
	* m68hc11-tdep.c: Ditto.
	* m58klinux-nat.c: Ditto.
	* m68k-tdep.c: Ditto.
	* m88k-tdep.c: Ditto.
	* m88k-tdep.h: Ditto.
	* machoread.c: Ditto.
	* macrocmd.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* mdebugread.h: Ditto.
	* memattr.c: Ditto.
	* memattr.h: Ditto.
	* memory-map.h: Ditto.
	* mep-tdep.c: Ditto.
	* microblaze-rom.c: Ditto.
	* microblaze-tdep.c: Ditto.
	* minsyms.c: Ditto.
	* mips-irix-tdep.c: Ditto.
	* mips-linux-nat.c: Ditto.
	* mips-linux-tdep.c: Ditto.
	* mips-linux-tdep.h: Ditto.
	* mipsnbsd-nat.c: Ditto.
	* mipsnbsd-tdep.c: Ditto.
	* mipsread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mips-tdep.h: Ditto.
	* mn10300-linux-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* mn10300-tdep.h: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* moxie-tdep.c: Ditto.
	* moxie-tdep.h: Ditto.
	* mt-tdep.c: Ditto.
@
text
@d846 1
@


1.24
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d47 2
a48 2
   executable.
*/
d209 1
a209 1
	     that are null strings (may happen). */
d218 1
a218 1
	  /* Bfd symbols are section relative. */
d223 1
a223 1
	     interested in will have a section. */
d261 1
a261 1
	    continue;	/* Skip this symbol. */
@


1.23
log
@run copyright.sh for 2011.
@
text
@d843 8
a850 9
  macho_new_init,               /* sym_new_init: init anything gbl to entire symtab */
  macho_symfile_init,           /* sym_init: read initial info, setup for sym_read() */
  macho_symfile_read,           /* sym_read: read a symbol file into symtab */
  macho_symfile_finish,         /* sym_finish: finished with file, cleanup */
  macho_symfile_offsets,        /* sym_offsets:  xlate external to internal form */
  default_symfile_segments,	/* sym_segments: Get segment information from
				   a file.  */
  NULL,                         /* sym_read_linetable */
  macho_symfile_relocate,	/* sym_relocate: Relocate a debug section.  */
d860 4
a863 4
			    &mach_o_debug_level, _("\
Set if printing Mach-O symbols processing."), _("\
Show if printing Mach-O symbols processing."), NULL,
			    NULL, NULL,
@


1.22
log
@	* symfile.h (struct sym_fns) <next>: Remove.
	(add_symtab_fns): Update.
	* symfile.c (sym_fns_ptr): New typedef.
	(symtab_fns): Now a VEC.
	(add_symtab_fns): Update.  Change argument type.
	(find_sym_fns): Update.  Change return type.
	(get_symfile_segment_data): Update.
	* objfiles.h (struct objfile) <sf>: Now const.
	* somread.c (som_sym_fns): Now const.  Update.
	* xcoffread.c (xcoff_sym_fns): Now const.  Update.
	* mipsread.c (ecoff_sym_fns): Now const.  Update.
	* machoread.c (macho_sym_fns): Now const.  Update.
	* elfread.c (elf_sym_fns): Now const.  Update.
	(elf_sym_fns_gdb_index): Likewise.
	* dbxread.c (aout_sym_fns): Now const.  Update.
	* coffread.c (coff_sym_fns): Now const.  Update.
@
text
@d2 1
a2 1
   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.21
log
@gdb
	* xcoffread.c: Include psymtab.h.
	(xcoff_sym_fns): Update.
	* symtab.h (struct partial_symbol): Remove.
	(PSYMBOL_DOMAIN, PSYMBOL_CLASS): Remove.
	(struct partial_symtab): Remove.
	(PSYMTAB_TO_SYMTAB): Remove.
	(lookup_partial_symbol, lookup_partial_symtab, find_pc_psymtab)
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): Declare.
	(find_pc_psymtab, find_pc_sect_psymbol, psymtab_to_symtab)
	(find_main_psymtab): Remove.
	(find_main_filename): Declare.
	(fixup_psymbol_section): Remove.
	(fixup_section): Declare.
	* symtab.c: Include psymtab.h.
	(lookup_symtab): Use lookup_symtab method.
	(lookup_partial_symtab): Remove.
	(find_pc_sect_psymtab_closer): Remove.
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): New function.
	(find_pc_psymtab, find_pc_sect_psymbol, find_pc_psymbol): Remove.
	(fixup_section): No longer static.
	(fixup_psymbol_section): Remove.
	(lookup_symbol_aux): Use lookup_symbol_aux_quick.
	(lookup_global_symbol_from_objfile): Likewise.
	(lookup_symbol_aux_psymtabs): Remove.
	(lookup_symbol_aux_quick): New function.
	(lookup_symbol_global): Use lookup_symbol_aux_quick.
	(lookup_partial_symbol): Remove.
	(basic_lookup_transparent_type_quick): New function.
	(basic_lookup_transparent_type): Use it.
	(find_main_psymtab): Remove.
	(find_main_filename): New function.
	(find_pc_sect_symtab): Use find_pc_sect_symtab method.
	(find_line_symtab): Use expand_symtabs_with_filename method.
	(output_partial_symbol_filename): New function.
	(sources_info): Use map_partial_symbol_filenames.
	(struct search_symbols_data): New type.
	(search_symbols_file_matches): New function.
	(search_symbols_name_matches): Likewise.
	(search_symbols): Use expand_symtabs_matching method.
	(struct add_name_data): Rename from add_macro_name_data.
	(add_macro_name): Update.
	(add_partial_symbol_name): New function.
	(default_make_symbol_completion_list): Use
	map_partial_symbol_names.
	(struct add_partial_symbol_name): New type.
	(maybe_add_partial_symtab_filename): New function.
	(make_source_files_completion_list): Use
	map_partial_symbol_filenames.
	(expand_line_sal): Use expand_symtabs_with_filename method.
	* symmisc.c: Include psymtab.h.
	(print_objfile_statistics): Use print_stats method.
	(dump_objfile): Use dump method.
	(dump_psymtab, maintenance_print_psymbols)
	(maintenance_info_psymtabs, maintenance_check_symtabs)
	(extend_psymbol_list): Remove.
	* symfile.h (struct quick_symbol_functions): New struct.
	(struct sym_fns) <qf>: New field.
	(sort_pst_symbols): Remove.
	(increment_reading_symtab): Declare.
	* symfile.c: Include psymtab.h.
	(compare_psymbols, sort_pst_symbols): Remove.
	(psymtab_to_symtab): Remove.
	(increment_reading_symtab): New function.
	(symbol_file_add_with_addrs_or_offsets): Use expand_all_symtabs
	method.
	(set_initial_language): Use find_main_filename.
	(allocate_psymtab, discard_psymtab, cashier_psymtab): Remove.
	(free_named_symtabs): Remove unused code.
	(start_psymtab_common, add_psymbol_to_bcache)
	(append_psymbol_to_list, add_psymbol_to_list, init_psymbol_list):
	Remove.
	* stack.c: Include psymtab.h, symfile.h.
	(backtrace_command_1): Use find_pc_sect_symtab_via_partial.
	* source.h (psymtab_to_fullname): Don't declare.
	* source.c: Include psymtab.h.
	(select_source_symtab): Use find_last_source_symtab method.
	(forget_cached_source_info): Use forget_cached_source_info
	method.
	(find_and_open_source): No longer static.
	(psymtab_to_fullname): Remove.
	* somread.c: Include psymtab.h.
	(som_sym_fns): Update.
	* psympriv.h: New file.
	* psymtab.h: New file.
	* psymtab.c: New file.
	* objfiles.h: (ALL_OBJFILE_PSYMTABS): Remove.
	(ALL_PSYMTABS, ALL_PSPACE_PSYMTABS): Likewise.
	* objfiles.c: Include psymtab.h.
	(objfile_relocate1): Use relocate method.
	(objfile_has_partial_symbols): Use has_symbols method.
	* mipsread.c: Include psymtab.h.
	(ecoff_sym_fns): Update.
	* mi/mi-cmd-file.c: Include psymtab.h.
	(print_partial_file_name): New function.
	(mi_cmd_file_list_exec_source_files): Use
	map_partial_symbol_filenames.
	* mdebugread.c: Include psympriv.h.
	* machoread.c: Include psympriv.h.
	(macho_sym_fns): Update.
	* m2-exp.y (yylex): Use lookup_symtab.
	* elfread.c: Include psympriv.h.
	(elf_sym_fns): Update.
	* dwarf2read.c: Include psympriv.h.
	* dbxread.c: Include psympriv.h.
	(aout_sym_fns): Update.
	* cp-support.c: Include psymtab.h.
	(read_in_psymtabs): Remove.
	(make_symbol_overload_list_qualified): Use
	expand_symtabs_for_function method.
	* coffread.c: Include psympriv.h.
	(coff_sym_fns): Update.
	* blockframe.c: Include psymtab.h.
	(find_pc_partial_function): Use find_pc_sect_symtab method.
	* ada-lang.h (ada_update_initial_language): Update.
	* ada-lang.c: Include psymtab.h.
	(ada_update_initial_language): Remove 'main_pst' argument.
	(ada_lookup_partial_symbol): Remove.
	(struct ada_psym_data): New type.
	(ada_add_psyms): New function.
	(ada_add_non_local_symbols): Use map_ada_symtabs method.
	(struct add_partial_datum): New type.
	(ada_add_partial_symbol_completions): New function.
	(ada_make_symbol_completion_list): Use map_partial_symbol_names.
	(ada_exception_support_info_sniffer): Update.
	* Makefile.in (SFILES): Add psymtab.c.
	(COMMON_OBS): Add psymtab.o.
	(HFILES_NO_SRCDIR): Add psymtab.h, psympriv.h.
gdb/doc
	* gdbint.texinfo (Symbol Handling): Update.
@
text
@d840 1
a840 1
static struct sym_fns macho_sym_fns = {
d852 1
a852 2
  &psym_functions,
  NULL                          /* next: pointer to next struct sym_fns */
@


1.20
log
@2010-02-09  Tristan Gingold  <gingold@@adacore.com>

	* machoread.c (macho_symfile_relocate): New function.
	(macho_sym_fns): Use macho_symfile_relocate instead of
	default_symfile_relocate.
	(macho_oso_data): New type.
	(current_oso): New variable.
	(macho_add_oso_symfile): Do not compute section_addr_info, but
	instead set vma of sections.
	Do not set SYMFILE_VERBOSE to call symbol_file_add_from_bfd.
	Set and clear current_oso.
@
text
@d35 1
d852 1
a852 1

@


1.19
log
@2010-02-04  Tristan Gingold  <gingold@@adacore.com>

	* machoread.c (macho_add_oso): Renamed to macho_register_oso.
	(macho_symtab_read): Adjust calls to macho_add_oso.
	(macho_oso_symfile): Renamed to macho_symfile_read_all_oso.
	(macho_symfile_read): Adjust call to macho_oso_symfile.
	(macho_new_init): Move this function after declarations.
	(macho_symfile_init): Ditto.
	* darwin-nat-info.c (darwin_lib_gdb_ports): Remove.
	* darwin-nat.c (darwin_lookup_task): Remove unused prototype.
@
text
@d73 17
a316 2
  struct section_addr_info *addrs;
  int len;
d332 2
a333 8
  
  /* Compute addr length.  */
  len = 0;
  for (i = 0; i < oso->num_sections; i++)
    if (oso->symbols[i] != NULL)
      len++;
  
  addrs = alloc_section_addr_info (len);
a336 1
  len = 0;
a337 31
    if (oso->symbols[i] != NULL)
      {
        if (oso->offsets[i])
          addrs->other[len].addr = oso->offsets[i];
        else
          {
            struct minimal_symbol *msym;
            const char *name = oso->symbols[i]->name;
            
            if (name[0] == leading_char)
              ++name;

            if (mach_o_debug_level > 3)
              printf_unfiltered (_("resolve sect %s with %s\n"),
                                 oso->symbols[i]->section->name,
                                 oso->symbols[i]->name);
            msym = lookup_minimal_symbol (name, NULL, main_objfile);
            if (msym == NULL)
              {
                warning (_("can't find symbol '%s' in minsymtab"),
                         oso->symbols[i]->name);
                addrs->other[len].addr = 0;
              }
            else
              addrs->other[len].addr = SYMBOL_VALUE_ADDRESS (msym);
          }
        addrs->other[len].name = (char *)oso->symbols[i]->section->name;
        len++;
      }
      
  if (mach_o_debug_level > 1)
d339 43
a381 2
      int j;
      for (j = 0; j < addrs->num_sections; j++)
d383 1
a383 2
                           core_addr_to_string (addrs->other[j].addr),
                           addrs->other[j].name);
d391 3
d397 1
a397 1
    (abfd, symfile_flags & ~SYMFILE_MAINLINE, addrs,
d401 7
d718 59
d850 1
a850 1
  default_symfile_relocate,	/* sym_relocate: Relocate a debug section.  */
@


1.18
log
@2010-02-03  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (struct sym_fns): Add sym_relocate field.
	(default_symfile_relocate): New prototype.
	(symfile_relocate_debug_section): First argument is now an objfile.
	* symfile.c (default_symfile_relocate): Rename from
	symfile_relocate_debug_section, first argument is now an objfile.
	(symfile_relocate_debug_section): New function.
	* coffread.c (coff_sym_fns): Set sym_relocate field.
	* somread.c (som_sym_fns): Ditto.
	* mipsread.c (ecoff_sym_fns): Ditto.
	* machoread.c (macho_sym_fns): Ditto.
	* elfread.c (elf_sym_fns): Ditto.
	* dwarf2read.c (dwarf2_read_section): Ditto.
	* xcoffread.c (xcoff_sym_fns): Ditto.
	* dbxread.c (aout_sym_fns): Ditto.
	(dbx_psymtab_to_symtab): Adjust call to symfile_relocate_debug_section.
	(elfstab_build_psymtabs): Ditto.
@
text
@a40 12
static void
macho_new_init (struct objfile *objfile)
{
}

static void
macho_symfile_init (struct objfile *objfile)
{
  objfile->flags |= OBJF_REORDERED;
  init_entry_point_info (objfile);
}

d68 2
a69 1
/* Vector of object files to be read after the executable.  */
d73 13
a85 1
/*  Add a new OSO to the vector.  */
d88 2
a89 2
macho_add_oso (const asymbol *oso_sym, int nbr_sections,
	       asymbol **symbols, bfd_vma *offsets)
d139 2
a140 2
		  macho_add_oso (oso_file, nbr_sections,
                                 first_symbol, first_offset);
d262 1
a262 1
    macho_add_oso (oso_file, nbr_sections, first_symbol, first_offset);
d307 1
a307 1
      
d386 1
a386 1
macho_oso_symfile (struct objfile *main_objfile, int symfile_flags)
d688 1
a688 1
    macho_oso_symfile (objfile, symfile_flags);
@


1.17
log
@2009-01-14  Tristan Gingold  <gingold@@adacore.com>

	* machoread.c (macho_add_oso_symfile): Add symfile_flags parameter.
	Call xstrdup for abfd->filename.  Pass symfile_flags and objfile flags
	to symbol_file_add_from_bfd.  Add OSO as separate objfile.
	(macho_oso_symfile): Add symfile_flags parameter.  Pass it to
	macho_add_oso_symfile.
	(macho_symfile_read): Pass symfile_flags to macho_oso_symfile.
@
text
@d762 3
@


1.16
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d295 2
a296 1
macho_add_oso_symfile (oso_el *oso, bfd *abfd, struct objfile *main_objfile)
d298 1
d368 12
a379 1
  symbol_file_add_from_bfd (abfd, 0, addrs, 0);
d385 1
a385 1
macho_oso_symfile (struct objfile *main_objfile)
d469 2
a470 1
                      macho_add_oso_symfile (oso2, member_bfd, main_objfile);
d503 1
a503 1
            macho_add_oso_symfile (oso, abfd, main_objfile);
d687 1
a687 1
    macho_oso_symfile (objfile);
@


1.15
log
@2009-12-15  Tristan Gingold  <gingold@@adacore.com>

	* machoread.c (macho_symfile_read): Set section size of dsym bfd
	from main bfd.
@
text
@d2 1
a2 1
   Copyright (C) 2008, 2009 Free Software Foundation, Inc.
@


1.14
log
@2009-12-15  Tristan Gingold  <gingold@@adacore.com>

        * machoread.c (macho_check_dsym): Read uuid directly from load command
        instead of from a fake section.
@
text
@d629 1
d643 11
@


1.13
log
@2009-12-15  Tristan Gingold  <gingold@@adacore.com>

        * machoread.c (macho_symtab_read): Add comments.  Always set
        first_offset.
@
text
@d522 2
a523 3
  asection *sect;
  bfd_byte main_uuid[16];
  bfd_byte dsym_uuid[16];
d532 2
a533 2
  sect = bfd_get_section_by_name (objfile->obfd, "LC_UUID");
  if (sect == NULL)
a537 7
  if (!bfd_get_section_contents (objfile->obfd, sect, main_uuid,
				 0, sizeof (main_uuid)))
    {
      warning (_("can't read UUID in %s"), objfile->name);
      return NULL;
    }

d555 2
a556 2
  sect = bfd_get_section_by_name (dsym_bfd, "LC_UUID");
  if (sect == NULL)
d563 2
a564 9
  if (!bfd_get_section_contents (dsym_bfd, sect, dsym_uuid,
				 0, sizeof (dsym_uuid)))
    {
      warning (_("can't read UUID in %s"), dsym_filename);
      bfd_close (dsym_bfd);
      xfree (dsym_filename);
      return NULL;
    }
  if (memcmp (dsym_uuid, main_uuid, sizeof (main_uuid)))
a571 1

@


1.12
log
@2009-12-03  Tristan Gingold  <gingold@@adacore.com>

	* machoread.c (macho_symfile_read): Use symbol_file_add_separate
	to add dsym files.
@
text
@d72 3
a74 1
     offset.  */
d129 3
d135 2
a136 2
	      if ((sym->name == NULL || sym->name[0] == 0)
		  && oso_file != NULL)
d139 1
a139 1
				 first_symbol, first_offset);
d157 1
d165 6
a170 1
		first_symbol[sym->section->index] = sym;
d173 1
d248 1
d259 1
@


1.11
log
@2009-12-07  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (struct sym_fns): Adjust comment on sym_read.
	* symfile.c (syms_from_objfile): Pass all symfile flags to sym_read.
	* dbxread.c (dbx_symfile_read): Rename mainline to symfile_flags,
	adjust header comment.
	* elfread.c (elf_symfile_read): Ditto.
	* somread.c (som_symfile_read): Ditto.
	* xcoffread.c (xcoff_initial_scan): Ditto.
	* coffread.c (coff_symfile_read): Rename mainline to symfile_flags.
	* machoread.c (macho_symfile_read): Ditto.
	* mipsread.c (mipscoff_symfile_read): Ditto.
@
text
@d644 2
a645 2
	  /* Now recurse: read dwarf from dsym.  */
	  symbol_file_add_from_bfd (dsym_bfd, 0, NULL, 0);
d648 1
a648 1
	  return;
@


1.10
log
@2009-12-07  Tristan Gingold  <gingold@@adacore.com>

	* dbxread.c (dbx_symfile_read): No need to test mainline to call
	init_psymbol_list.
	* xcoffread.c (xcoff_initial_scan): Ditto;
	* coffread.c (coff_symfile_read): Remove call to init_psymbol_list.
	* elfread.c (elf_symfile_read): Ditto.
	* machoread.c (macho_symfile_read): Ditto.
@
text
@d577 1
a577 1
macho_symfile_read (struct objfile *objfile, int mainline)
@


1.9
log
@2009-12-03  Tristan Gingold  <gingold@@adacore.com>

	* machoread.c (macho_sym_fns): Set sym_segment routine.
@
text
@a651 5
  /* If we are reinitializing, or if we have never loaded syms yet,
     set table to empty.  */
  if (mainline)
    init_psymbol_list (objfile, 0);

@


1.8
log
@2009-12-02  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (dwarf2_build_psymtabs): Remove mainline parameter in
	prototype.
	* dwarf2read.c (dwarf2_build_psymtabs): Remove mainline paramter in
	definition, simplify code assuming it is always 0.
	* coffread.c (coff_symfile_read): Adjust call.
	* elfread.c (elf_symfile_read): Ditto.
	* machoread.c (macho_symfile_read): Explicitely calls
	init_psymbol_list if mainline is set.
@
text
@d741 2
@


1.7
log
@2009-11-18  Tristan Gingold  <gingold@@adacore.com>

	* machoread.c (macho_oso_symfile): Fix typo.  Add comments.
@
text
@d652 5
d660 1
a660 1
      dwarf2_build_psymtabs (objfile, mainline);
@


1.6
log
@2009-10-13  Tristan Gingold  <gingold@@adacore.com>

	* machoread.c: Add an empty line after comment for functions.
	(oso_el_compare_name): New function.
	(macho_add_oso_symfile): New function.
	(macho_oso_symfile): Use macho_add_oso_symfile.  Sort the oso
	and optimize accesses to libraries.
@
text
@d432 1
d451 3
a453 1
              if (ix2 < last_ix)
@


1.5
log
@2009-06-19  Tristan Gingold  <gingold@@adacore.com>

	* machoread.c (macho_symtab_read): Adjust for bfd changes.
	* darwin-nat.h (struct darwin_exception_msg): New type to describe
	a mach exception.
	(struct private_thread_info): New type to describe the state of the
	thread.
	(DEF_VEC_I thread_t): Removed, replaced by ...
	(DEF_VEC_O darwin_thread_t): ... this new type.
	(struct darwin_inferior): Renamed to ...
	(struct private_inferior): ... this type.  Fields added.
	(darwin_not_port): Moved into the private inferior structure.
	* darwin-nat.c: Add includes, improve comments.
	Rewrite to handle multiple threads and processes.
	(darwin_resume_to): New function and protype.
	(darwin_resume, darwin_wait_to, darwin_wait): Ditto.
	(darwin_kill_inferior): Add ops argument.
	(darwin_pid_to_str): New function.
	(darwin_thread_alive): Ditto.
	(darwin_inf, darwin_not_port): Removed.
	(darwin_inf_fake_stop): New variable.
	(msgin, msgout, msg_state, exc_msg): Removed.
	(mach_check_error): Use warning instead of error.
	(darwin_ptrace): Adjust debug level.
	(cmp_thread_t): Fix names (typo).
	(darwin_check_new_threads): Argument is now an inferior,
	adjust for new structures, add no change check, ignore dead ports,
	handle first thread case.
	(find_inferior_task_it): New function.
	(find_inferior_notify_it): Ditto.
	(darwin_find_inferior_by_task): Ditto.
	(darwin_find_inferior_by_notify): Ditto.
	(darwin_find_thread): Ditto.
	(darwin_suspend_inferior): Ditto.
	(darwin_resume_inferior): Ditto.
	(catch_exception_raise_state): Removed.
	(catch_exception_raise_state_identity): Removed.
	(darwin_suspend_inferior_it): New function.
	(darwin_resume_inferior_it): Ditto.
	(darwin_dump_message): New function, extracted from darwin_wait.
	(darwin_decode_exception_message): New function.
	(darwin_encode_reply): New function.
	(catch_exception_raise): Removed.
	(darwin_send_reply): New function, extracted from darwin_resume.
	(darwin_resume_thread): New function, extracted from darwin_resume.
	(struct resume_inferior_threads_param): New type.
	(darwin_resume_inferior_threads_it): New function.
	(darwin_resume_inferior_threads): New function.
	(darwin_suspend_inferior_threads): New function.
	(darwin_resume): Mostly rewritten to handle multiple threads and
	some corner cases.
	(darwin_decode_message): New function extracted from darwin_wait.
	(cancel_breakpoint): New function.
	(darwin_wait): Mostly rewritten.  Handle multiple threads.
	(darwin_mourn_inferior): Adjust for per process structures.
	(darwin_reply_to_all_pending_messages): New function.
	(darwin_stop_inferior): Adjust for per inferior structures.
	(darwin_attach_pid): Ditto.
	(darwin_init_thread_list): Ditto.
	(darwin_attach): Ditto.
	(darwin_detach): Ditto.
	(darwin_files_info): Now empty.
	(darwin_pid_to_str): Adjust returns string to match one expected by
	the testsuite.
	(darwin_read_write_inferior): Rename err variable to match other uses.
	Adjust debug message.  Handle submaps.
	(darwin_xfer_memory): Adjust for per inferior structures.
	(set_enable_mach_exceptions): Ditto.
	(darwin_pid_to_exec_file): New function.
	(darwin_get_ada_task_ptid): Ditto.
	(darwin_supports_multi_process): Ditto.
	(_initialize_darwin_inferior): Remove useless assertion, adjust for
	per inferior structures.  Add new target operations.
@
text
@d83 1
d101 1
d253 1
d269 86
d356 1
a362 3
  char leading_char;

  /* TODO: Sort them, group library search.  */
d367 3
a369 1
  leading_char = bfd_get_symbol_leading_char (main_objfile->obfd);
d371 1
a371 1
  for (ix = 0; VEC_iterate (oso_el, vec, ix, oso); ix++)
a372 1
      struct section_addr_info *addrs;
a373 56
      int len;
      int i;
      oso_el el;
      
      if (mach_o_debug_level > 0)
	printf_unfiltered (_("Loading symbols from oso: %s\n"), oso->name);

      /* Compute addr length.  */
      len = 0;
      for (i = 0; i < oso->num_sections; i++)
	if (oso->symbols[i] != NULL)
	  len++;

      addrs = alloc_section_addr_info (len);

      len = 0;
      for (i = 0; i < oso->num_sections; i++)
	if (oso->symbols[i] != NULL)
	  {
	    if (oso->offsets[i])
	      addrs->other[len].addr = oso->offsets[i];
	    else
	      {
		struct minimal_symbol *msym;
		const char *name = oso->symbols[i]->name;

		if (name[0] == leading_char)
		  ++name;

		if (mach_o_debug_level > 3)
		  printf_unfiltered (_("resolv sec %s with %s\n"),
				     oso->symbols[i]->section->name,
				     oso->symbols[i]->name);
		msym = lookup_minimal_symbol (name, NULL, main_objfile);
		if (msym == NULL)
		  {
		    warning (_("can't find symbol '%s' in minsymtab"),
			     oso->symbols[i]->name);
		    addrs->other[len].addr = 0;
		  }
		else
		  addrs->other[len].addr = SYMBOL_VALUE_ADDRESS (msym);
	      }
	    addrs->other[len].name = (char *)oso->symbols[i]->section->name;
	    len++;
	  }
      
      if (mach_o_debug_level > 1)
	{
	  int j;
	  for (j = 0; j < addrs->num_sections; j++)
	    printf_unfiltered
	      (_("  %s: %s\n"),
	       core_addr_to_string (addrs->other[j].addr),
	       addrs->other[j].name);
	}
d381 4
a384 2
	  char *archive_name = (char *) alloca (pfx_len + 1);
	  int member_len;
a385 1
	  member_len = strlen (oso->name + pfx_len + 1) - 1;
d389 8
d403 1
d411 1
d421 1
d424 2
a425 1
	  
d428 1
a428 1
	      bfd *prev = member_bfd;
d430 18
a447 3
	      if (strlen (member_name) == member_len
		  && !memcmp (member_name, oso->name + pfx_len + 1, member_len))
		break;
d450 2
a451 17
	      bfd_close (prev);
	    }
	  if (member_bfd == NULL)
	    {
	      warning (_("Could not find specified archive member "
			 "for OSO name \"%s\""), oso->name);
	      bfd_close (archive_bfd);
	      continue;
	    }
	  
	  bfd_set_cacheable (member_bfd, 1);
  
	  if (!bfd_check_format (member_bfd, bfd_object))
	    {
	      warning (_("`%s': can't read symbols: %s."), oso->name,
		       bfd_errmsg (bfd_get_error ()));
	      bfd_close (member_bfd);
d453 9
a461 2
	    else
	      symbol_file_add_from_bfd (member_bfd, 0, addrs, 0);
d465 1
a465 1
	  bfd *abfd;
d469 11
a479 17
	    {
	      warning (_("`%s': can't open to read symbols: %s."), oso->name,
		       bfd_errmsg (bfd_get_error ()));
	      continue;
	    }
	  bfd_set_cacheable (abfd, 1);
  
	  if (!bfd_check_format (abfd, bfd_object))
	    {
	      bfd_close (abfd);
	      warning (_("`%s': can't read symbols: %s."), oso->name,
		       bfd_errmsg (bfd_get_error ()));
	      continue;
	    }
  
	  symbol_file_add_from_bfd (abfd, 0, addrs, 0);
	}
d495 1
@


1.4
log
@2009-06-16  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* solib.c (symbol_add_stub): New FLAGS parameter.
	(solib_read_symbols): FROM_TTY -> FLAGS, call symbol_add_stub
	directly.
	(solib_add): Defer breakpoint_re_set until after all solibs.
	* bsd-uthread.c (bsd_uthread_solib_loaded): Adjust.
	* rs6000-nat.c (objfile_symbol_add): Adjust.
	* symfile.c (syms_from_objfile): Merge parameters into ADD_FLAGS.
	(new_symfile_objfile): Likewise.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	(symbol_file_add_from_bfd): Likewise.
	(symbol_file_add): Likewise.
	* symfile.h (enum symfile_add_flags): New. Adjust prototypes.
	* symfile-mem.c (symbol_file_add_from_memory): Adjust.
	* windows-nat.c (safe_symbol_file_add_stub): Adjust.
	* machoread.c (macho_oso_symfile, macho_symfile_read): Adjust.
@
text
@a105 1
  asymbol *sym;
d116 3
a118 1
      sym = symbol_table[i];
a122 1
	  unsigned char type = BFD_MACH_O_SYM_NTYPE(sym);
d125 1
a125 1
	  switch (type)
@


1.3
log
@2009-02-04  Tristan Gingold  <gingold@@adacore.com>

	* machoread.c (macho_symfile_read): Read minsymtab also from
	shared libraries.
	(macho_symfile_read): Try to read dwarf2 frame info from main
	object file, but not from OSO files.
	(macho_symfile_offsets): Update section names for latest BFD
	changes.
	* i386-darwin-tdep.c (i386_darwin_init_abi): Call set_solib_ops.
	(x86_darwin_init_abi_64): Ditto.
	* solib-darwin.c: New file.
	* solib-darwin.h: New file.
	* configure.tgt: Add solib.o solib-darwin.o for Darwin.
@
text
@d409 1
a409 1
	      symbol_file_add_from_bfd (member_bfd, 0, addrs, 0, 0);
d432 1
a432 1
	  symbol_file_add_from_bfd (abfd, 0, addrs, 0, 0);
d595 1
a595 1
	  symbol_file_add_from_bfd (dsym_bfd, 0, NULL, 0, 0);
@


1.2
log
@        Updated copyright notices for most files.
@
text
@d541 1
a541 1
  if (bfd_get_file_flags (abfd) & EXEC_P)
d569 6
d597 1
a597 1
	  /* Don't try to read dwarf2 from main file.  */
d608 2
a609 3
  /* FIXME: kettenis/20030504: This still needs to be integrated with
     dwarf2read.c in a better way.  */
  dwarf2_build_frame_info (objfile);
d669 5
a673 4

      if (strcmp (bfd_sect_name, "LC_SEGMENT.__TEXT") == 0)
	objfile->sect_index_text = sect_index;
      else if (strcmp (bfd_sect_name, "LC_SEGMENT.__TEXT.__text") == 0)
@


1.1
log
@gdb:
2008-11-27  Tristan Gingold  <gingold@@adacore.com>

	* NEWS: Add entry for new native configuration: Darwin.
	* configure.host: Add Darwin host.
	* configure.tgt: Add Darwin target.
	* defs.h (enum gdb_osabi): Add GDB_OSABI_DARWIN.
	* osabi.c (gdb_osabi_names): Add name for Darwin abi.
	* i386-darwin-nat.c: New file.
	* i386-darwin-tdep.c: New file.
	* machoread.c: New file.
	* darwin-nat-info.c: New file.
	* darwin-nat.c: New file.
	* darwin-nat.h: New file.
	* darwin.defs: New file.
	* config/i386/darwin.mh: New file.

gdb/doc:
2008-11-27  Tristan Gingold  <gingold@@adacore.com>

	* gdb.texinfo (Darwin): Document Darwin specific features.
@
text
@d2 1
a2 1
   Copyright (C) 2008 Free Software Foundation, Inc.
@

