head	1.57;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.48.2.1
	gdb_7_6-2013-04-26-release:1.48.2.1
	gdb_7_6-branch:1.48.0.2
	gdb_7_6-2013-03-12-branchpoint:1.48
	gdb_7_5_1-2012-11-29-release:1.31
	gdb_7_5-2012-08-17-release:1.31
	gdb_7_5-branch:1.31.0.2
	gdb_7_5-2012-07-18-branchpoint:1.31
	gdb_7_4_1-2012-04-26-release:1.23.2.1
	gdb_7_4-2012-01-24-release:1.23.2.1
	gdb_7_4-branch:1.23.0.2
	gdb_7_4-2011-12-13-branchpoint:1.23
	gdb_7_3_1-2011-09-04-release:1.11.2.1
	gdb_7_3-2011-07-26-release:1.11.2.1
	gdb_7_3-branch:1.11.0.2
	gdb_7_3-2011-04-01-branchpoint:1.11
	gdb_7_2-2010-09-02-release:1.7
	gdb_7_2-branch:1.7.0.2
	gdb_7_2-2010-07-07-branchpoint:1.7
	gdb_7_1-2010-03-18-release:1.5
	gdb_7_1-branch:1.5.0.2
	gdb_7_1-2010-02-18-branchpoint:1.5
	gdb_7_0_1-2009-12-22-release:1.3
	gdb_7_0-2009-10-06-release:1.3
	gdb_7_0-branch:1.3.0.2
	gdb_7_0-2009-09-16-branchpoint:1.3;
locks; strict;
comment	@ * @;


1.57
date	2013.10.09.13.22.36;	author jkratoch;	state Exp;
branches;
next	1.56;

1.56
date	2013.09.24.14.00.06;	author jkratoch;	state Exp;
branches;
next	1.55;

1.55
date	2013.09.24.13.57.37;	author jkratoch;	state Exp;
branches;
next	1.54;

1.54
date	2013.08.20.15.04.51;	author tromey;	state Exp;
branches;
next	1.53;

1.53
date	2013.04.12.16.04.07;	author jkratoch;	state Exp;
branches;
next	1.52;

1.52
date	2013.04.08.19.59.09;	author tromey;	state Exp;
branches;
next	1.51;

1.51
date	2013.04.08.19.48.30;	author tromey;	state Exp;
branches;
next	1.50;

1.50
date	2013.03.21.16.18.48;	author tromey;	state Exp;
branches;
next	1.49;

1.49
date	2013.03.20.18.33.05;	author tromey;	state Exp;
branches;
next	1.48;

1.48
date	2013.01.31.19.55.15;	author tromey;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2013.01.31.19.52.02;	author tromey;	state Exp;
branches;
next	1.46;

1.46
date	2013.01.31.19.18.59;	author aristovski;	state Exp;
branches;
next	1.45;

1.45
date	2013.01.21.18.13.13;	author tromey;	state Exp;
branches;
next	1.44;

1.44
date	2013.01.17.14.17.15;	author sanjoyd;	state Exp;
branches;
next	1.43;

1.43
date	2013.01.17.14.11.27;	author sanjoyd;	state Exp;
branches;
next	1.42;

1.42
date	2013.01.01.06.32.46;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2012.11.12.21.59.07;	author brobecke;	state Exp;
branches;
next	1.40;

1.40
date	2012.11.09.19.57.59;	author tromey;	state Exp;
branches;
next	1.39;

1.39
date	2012.08.22.16.44.45;	author tromey;	state Exp;
branches;
next	1.38;

1.38
date	2012.08.22.15.17.21;	author tromey;	state Exp;
branches;
next	1.37;

1.37
date	2012.08.02.09.36.39;	author qiyao;	state Exp;
branches;
next	1.36;

1.36
date	2012.07.23.14.58.44;	author tromey;	state Exp;
branches;
next	1.35;

1.35
date	2012.07.23.14.57.54;	author tromey;	state Exp;
branches;
next	1.34;

1.34
date	2012.07.23.14.56.10;	author tromey;	state Exp;
branches;
next	1.33;

1.33
date	2012.07.18.19.34.57;	author tromey;	state Exp;
branches;
next	1.32;

1.32
date	2012.07.18.19.33.33;	author tromey;	state Exp;
branches;
next	1.31;

1.31
date	2012.06.13.21.16.49;	author tromey;	state Exp;
branches;
next	1.30;

1.30
date	2012.05.18.21.02.48;	author sergiodj;	state Exp;
branches;
next	1.29;

1.29
date	2012.05.10.19.59.12;	author tromey;	state Exp;
branches;
next	1.28;

1.28
date	2012.03.22.20.33.42;	author rth;	state Exp;
branches;
next	1.27;

1.27
date	2012.02.01.20.21.22;	author tromey;	state Exp;
branches;
next	1.26;

1.26
date	2012.02.01.20.16.24;	author tromey;	state Exp;
branches;
next	1.25;

1.25
date	2012.01.04.08.17.05;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2011.12.21.21.34.25;	author tromey;	state Exp;
branches;
next	1.23;

1.23
date	2011.11.29.08.30.29;	author sanjoyd;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2011.11.27.14.26.09;	author sanjoyd;	state Exp;
branches;
next	1.21;

1.21
date	2011.11.20.09.18.48;	author sanjoyd;	state Exp;
branches;
next	1.20;

1.20
date	2011.11.20.09.14.45;	author sanjoyd;	state Exp;
branches;
next	1.19;

1.19
date	2011.11.20.09.09.56;	author sanjoyd;	state Exp;
branches;
next	1.18;

1.18
date	2011.11.20.08.53.25;	author sanjoyd;	state Exp;
branches;
next	1.17;

1.17
date	2011.11.20.08.30.59;	author sanjoyd;	state Exp;
branches;
next	1.16;

1.16
date	2011.10.28.22.40.58;	author jkratoch;	state Exp;
branches;
next	1.15;

1.15
date	2011.10.11.19.08.58;	author davem;	state Exp;
branches;
next	1.14;

1.14
date	2011.07.07.02.07.04;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2011.07.06.21.40.17;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.17.18.38.45;	author jkratoch;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.31.21.37.01;	author ppluzhnikov;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2011.01.09.03.08.57;	author msnyder;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.06.19.56.43;	author ppluzhnikov;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.01.15.33.09;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2010.05.07.02.09.55;	author msnyder;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.24.07.51.44;	author vprus;	state Exp;
branches;
next	1.5;

1.5
date	2010.01.01.07.31.36;	author brobecke;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.16.18.40.22;	author tromey;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.21.19.07.01;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2009.08.21.18.54.44;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	2009.08.20.18.02.47;	author devans;	state Exp;
branches;
next	;

1.48.2.1
date	2013.04.12.16.04.50;	author jkratoch;	state Exp;
branches;
next	;

1.23.2.1
date	2012.01.06.04.43.18;	author brobecke;	state Exp;
branches;
next	;

1.11.2.1
date	2011.07.06.22.05.37;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.57
log
@New flag OBJF_NOT_FILENAME

gdb/
2013-10-09  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	New flag OBJF_NOT_FILENAME.
	* auto-load.c (auto_load_objfile_script): Check also OBJF_NOT_FILENAME.
	* jit.c (jit_object_close_impl): Use OBJF_NOT_FILENAME for
	allocate_objfile.
	(jit_bfd_try_read_symtab): Use OBJF_NOT_FILENAME for
	symbol_file_add_from_bfd.
	* jv-lang.c (get_dynamics_objfile): Use OBJF_NOT_FILENAME for
	allocate_objfile.
	* objfiles.c (allocate_objfile): Assert OBJF_NOT_FILENAME if NAME is
	NULL.
	* objfiles.h (OBJF_NOT_FILENAME): New.
@
text
@/* Handle JIT code generation in the inferior for GDB, the GNU Debugger.

   Copyright (C) 2009-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"

#include "jit.h"
#include "jit-reader.h"
#include "block.h"
#include "breakpoint.h"
#include "command.h"
#include "dictionary.h"
#include "filenames.h"
#include "frame-unwind.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "inferior.h"
#include "observer.h"
#include "objfiles.h"
#include "regcache.h"
#include "symfile.h"
#include "symtab.h"
#include "target.h"
#include "gdb-dlfcn.h"
#include "gdb_stat.h"
#include "exceptions.h"
#include "gdb_bfd.h"

static const char *jit_reader_dir = NULL;

static const struct objfile_data *jit_objfile_data;

static const char *const jit_break_name = "__jit_debug_register_code";

static const char *const jit_descriptor_name = "__jit_debug_descriptor";

static const struct program_space_data *jit_program_space_data = NULL;

static void jit_inferior_init (struct gdbarch *gdbarch);

/* An unwinder is registered for every gdbarch.  This key is used to
   remember if the unwinder has been registered for a particular
   gdbarch.  */

static struct gdbarch_data *jit_gdbarch_data;

/* Non-zero if we want to see trace of jit level stuff.  */

static unsigned int jit_debug = 0;

static void
show_jit_debug (struct ui_file *file, int from_tty,
		struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("JIT debugging is %s.\n"), value);
}

struct target_buffer
{
  CORE_ADDR base;
  ULONGEST size;
};

/* Openning the file is a no-op.  */

static void *
mem_bfd_iovec_open (struct bfd *abfd, void *open_closure)
{
  return open_closure;
}

/* Closing the file is just freeing the base/size pair on our side.  */

static int
mem_bfd_iovec_close (struct bfd *abfd, void *stream)
{
  xfree (stream);

  /* Zero means success.  */
  return 0;
}

/* For reading the file, we just need to pass through to target_read_memory and
   fix up the arguments and return values.  */

static file_ptr
mem_bfd_iovec_pread (struct bfd *abfd, void *stream, void *buf,
                     file_ptr nbytes, file_ptr offset)
{
  int err;
  struct target_buffer *buffer = (struct target_buffer *) stream;

  /* If this read will read all of the file, limit it to just the rest.  */
  if (offset + nbytes > buffer->size)
    nbytes = buffer->size - offset;

  /* If there are no more bytes left, we've reached EOF.  */
  if (nbytes == 0)
    return 0;

  err = target_read_memory (buffer->base + offset, (gdb_byte *) buf, nbytes);
  if (err)
    return -1;

  return nbytes;
}

/* For statting the file, we only support the st_size attribute.  */

static int
mem_bfd_iovec_stat (struct bfd *abfd, void *stream, struct stat *sb)
{
  struct target_buffer *buffer = (struct target_buffer*) stream;

  sb->st_size = buffer->size;
  return 0;
}

/* Open a BFD from the target's memory.  */

static struct bfd *
bfd_open_from_target_memory (CORE_ADDR addr, ULONGEST size, char *target)
{
  struct target_buffer *buffer = xmalloc (sizeof (struct target_buffer));

  buffer->base = addr;
  buffer->size = size;
  return gdb_bfd_openr_iovec ("<in-memory>", target,
			      mem_bfd_iovec_open,
			      buffer,
			      mem_bfd_iovec_pread,
			      mem_bfd_iovec_close,
			      mem_bfd_iovec_stat);
}

/* One reader that has been loaded successfully, and can potentially be used to
   parse debug info.  */

static struct jit_reader
{
  struct gdb_reader_funcs *functions;
  void *handle;
} *loaded_jit_reader = NULL;

typedef struct gdb_reader_funcs * (reader_init_fn_type) (void);
static const char *reader_init_fn_sym = "gdb_init_reader";

/* Try to load FILE_NAME as a JIT debug info reader.  */

static struct jit_reader *
jit_reader_load (const char *file_name)
{
  void *so;
  reader_init_fn_type *init_fn;
  struct jit_reader *new_reader = NULL;
  struct gdb_reader_funcs *funcs = NULL;
  struct cleanup *old_cleanups;

  if (jit_debug)
    fprintf_unfiltered (gdb_stdlog, _("Opening shared object %s.\n"),
                        file_name);
  so = gdb_dlopen (file_name);
  old_cleanups = make_cleanup_dlclose (so);

  init_fn = gdb_dlsym (so, reader_init_fn_sym);
  if (!init_fn)
    error (_("Could not locate initialization function: %s."),
          reader_init_fn_sym);

  if (gdb_dlsym (so, "plugin_is_GPL_compatible") == NULL)
    error (_("Reader not GPL compatible."));

  funcs = init_fn ();
  if (funcs->reader_version != GDB_READER_INTERFACE_VERSION)
    error (_("Reader version does not match GDB version."));

  new_reader = XZALLOC (struct jit_reader);
  new_reader->functions = funcs;
  new_reader->handle = so;

  discard_cleanups (old_cleanups);
  return new_reader;
}

/* Provides the jit-reader-load command.  */

static void
jit_reader_load_command (char *args, int from_tty)
{
  char *so_name;
  struct cleanup *prev_cleanup;

  if (args == NULL)
    error (_("No reader name provided."));

  if (loaded_jit_reader != NULL)
    error (_("JIT reader already loaded.  Run jit-reader-unload first."));

  if (IS_ABSOLUTE_PATH (args))
    so_name = xstrdup (args);
  else
    so_name = xstrprintf ("%s%s%s", SLASH_STRING, jit_reader_dir, args);
  prev_cleanup = make_cleanup (xfree, so_name);

  loaded_jit_reader = jit_reader_load (so_name);
  do_cleanups (prev_cleanup);
}

/* Provides the jit-reader-unload command.  */

static void
jit_reader_unload_command (char *args, int from_tty)
{
  if (!loaded_jit_reader)
    error (_("No JIT reader loaded."));

  loaded_jit_reader->functions->destroy (loaded_jit_reader->functions);

  gdb_dlclose (loaded_jit_reader->handle);
  xfree (loaded_jit_reader);
  loaded_jit_reader = NULL;
}

/* Per-program space structure recording which objfile has the JIT
   symbols.  */

struct jit_program_space_data
{
  /* The objfile.  This is NULL if no objfile holds the JIT
     symbols.  */

  struct objfile *objfile;

  /* If this program space has __jit_debug_register_code, this is the
     cached address from the minimal symbol.  This is used to detect
     relocations requiring the breakpoint to be re-created.  */

  CORE_ADDR cached_code_address;

  /* This is the JIT event breakpoint, or NULL if it has not been
     set.  */

  struct breakpoint *jit_breakpoint;
};

/* Per-objfile structure recording the addresses in the program space.
   This object serves two purposes: for ordinary objfiles, it may
   cache some symbols related to the JIT interface; and for
   JIT-created objfiles, it holds some information about the
   jit_code_entry.  */

struct jit_objfile_data
{
  /* Symbol for __jit_debug_register_code.  */
  struct minimal_symbol *register_code;

  /* Symbol for __jit_debug_descriptor.  */
  struct minimal_symbol *descriptor;

  /* Address of struct jit_code_entry in this objfile.  This is only
     non-zero for objfiles that represent code created by the JIT.  */
  CORE_ADDR addr;
};

/* Fetch the jit_objfile_data associated with OBJF.  If no data exists
   yet, make a new structure and attach it.  */

static struct jit_objfile_data *
get_jit_objfile_data (struct objfile *objf)
{
  struct jit_objfile_data *objf_data;

  objf_data = objfile_data (objf, jit_objfile_data);
  if (objf_data == NULL)
    {
      objf_data = XZALLOC (struct jit_objfile_data);
      set_objfile_data (objf, jit_objfile_data, objf_data);
    }

  return objf_data;
}

/* Remember OBJFILE has been created for struct jit_code_entry located
   at inferior address ENTRY.  */

static void
add_objfile_entry (struct objfile *objfile, CORE_ADDR entry)
{
  struct jit_objfile_data *objf_data;

  objf_data = get_jit_objfile_data (objfile);
  objf_data->addr = entry;
}

/* Return jit_program_space_data for current program space.  Allocate
   if not already present.  */

static struct jit_program_space_data *
get_jit_program_space_data (void)
{
  struct jit_program_space_data *ps_data;

  ps_data = program_space_data (current_program_space, jit_program_space_data);
  if (ps_data == NULL)
    {
      ps_data = XZALLOC (struct jit_program_space_data);
      set_program_space_data (current_program_space, jit_program_space_data,
			      ps_data);
    }

  return ps_data;
}

static void
jit_program_space_data_cleanup (struct program_space *ps, void *arg)
{
  xfree (arg);
}

/* Helper function for reading the global JIT descriptor from remote
   memory.  Returns 1 if all went well, 0 otherwise.  */

static int
jit_read_descriptor (struct gdbarch *gdbarch,
		     struct jit_descriptor *descriptor,
		     struct jit_program_space_data *ps_data)
{
  int err;
  struct type *ptr_type;
  int ptr_size;
  int desc_size;
  gdb_byte *desc_buf;
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct jit_objfile_data *objf_data;

  if (ps_data->objfile == NULL)
    return 0;
  objf_data = get_jit_objfile_data (ps_data->objfile);
  if (objf_data->descriptor == NULL)
    return 0;

  if (jit_debug)
    fprintf_unfiltered (gdb_stdlog,
			"jit_read_descriptor, descriptor_addr = %s\n",
			paddress (gdbarch, SYMBOL_VALUE_ADDRESS (objf_data->descriptor)));

  /* Figure out how big the descriptor is on the remote and how to read it.  */
  ptr_type = builtin_type (gdbarch)->builtin_data_ptr;
  ptr_size = TYPE_LENGTH (ptr_type);
  desc_size = 8 + 2 * ptr_size;  /* Two 32-bit ints and two pointers.  */
  desc_buf = alloca (desc_size);

  /* Read the descriptor.  */
  err = target_read_memory (SYMBOL_VALUE_ADDRESS (objf_data->descriptor),
			    desc_buf, desc_size);
  if (err)
    {
      printf_unfiltered (_("Unable to read JIT descriptor from "
			   "remote memory\n"));
      return 0;
    }

  /* Fix the endianness to match the host.  */
  descriptor->version = extract_unsigned_integer (&desc_buf[0], 4, byte_order);
  descriptor->action_flag =
      extract_unsigned_integer (&desc_buf[4], 4, byte_order);
  descriptor->relevant_entry = extract_typed_address (&desc_buf[8], ptr_type);
  descriptor->first_entry =
      extract_typed_address (&desc_buf[8 + ptr_size], ptr_type);

  return 1;
}

/* Helper function for reading a JITed code entry from remote memory.  */

static void
jit_read_code_entry (struct gdbarch *gdbarch,
		     CORE_ADDR code_addr, struct jit_code_entry *code_entry)
{
  int err, off;
  struct type *ptr_type;
  int ptr_size;
  int entry_size;
  int align_bytes;
  gdb_byte *entry_buf;
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  /* Figure out how big the entry is on the remote and how to read it.  */
  ptr_type = builtin_type (gdbarch)->builtin_data_ptr;
  ptr_size = TYPE_LENGTH (ptr_type);

  /* Figure out where the longlong value will be.  */
  align_bytes = gdbarch_long_long_align_bit (gdbarch) / 8;
  off = 3 * ptr_size;
  off = (off + (align_bytes - 1)) & ~(align_bytes - 1);

  entry_size = off + 8;  /* Three pointers and one 64-bit int.  */
  entry_buf = alloca (entry_size);

  /* Read the entry.  */
  err = target_read_memory (code_addr, entry_buf, entry_size);
  if (err)
    error (_("Unable to read JIT code entry from remote memory!"));

  /* Fix the endianness to match the host.  */
  ptr_type = builtin_type (gdbarch)->builtin_data_ptr;
  code_entry->next_entry = extract_typed_address (&entry_buf[0], ptr_type);
  code_entry->prev_entry =
      extract_typed_address (&entry_buf[ptr_size], ptr_type);
  code_entry->symfile_addr =
      extract_typed_address (&entry_buf[2 * ptr_size], ptr_type);
  code_entry->symfile_size =
      extract_unsigned_integer (&entry_buf[off], 8, byte_order);
}

/* Proxy object for building a block.  */

struct gdb_block
{
  /* gdb_blocks are linked into a tree structure.  Next points to the
     next node at the same depth as this block and parent to the
     parent gdb_block.  */
  struct gdb_block *next, *parent;

  /* Points to the "real" block that is being built out of this
     instance.  This block will be added to a blockvector, which will
     then be added to a symtab.  */
  struct block *real_block;

  /* The first and last code address corresponding to this block.  */
  CORE_ADDR begin, end;

  /* The name of this block (if any).  If this is non-NULL, the
     FUNCTION symbol symbol is set to this value.  */
  const char *name;
};

/* Proxy object for building a symtab.  */

struct gdb_symtab
{
  /* The list of blocks in this symtab.  These will eventually be
     converted to real blocks.  */
  struct gdb_block *blocks;

  /* The number of blocks inserted.  */
  int nblocks;

  /* A mapping between line numbers to PC.  */
  struct linetable *linetable;

  /* The source file for this symtab.  */
  const char *file_name;
  struct gdb_symtab *next;
};

/* Proxy object for building an object.  */

struct gdb_object
{
  struct gdb_symtab *symtabs;
};

/* The type of the `private' data passed around by the callback
   functions.  */

typedef CORE_ADDR jit_dbg_reader_data;

/* The reader calls into this function to read data off the targets
   address space.  */

static enum gdb_status
jit_target_read_impl (GDB_CORE_ADDR target_mem, void *gdb_buf, int len)
{
  int result = target_read_memory ((CORE_ADDR) target_mem, gdb_buf, len);
  if (result == 0)
    return GDB_SUCCESS;
  else
    return GDB_FAIL;
}

/* The reader calls into this function to create a new gdb_object
   which it can then pass around to the other callbacks.  Right now,
   all that is required is allocating the memory.  */

static struct gdb_object *
jit_object_open_impl (struct gdb_symbol_callbacks *cb)
{
  /* CB is not required right now, but sometime in the future we might
     need a handle to it, and we'd like to do that without breaking
     the ABI.  */
  return XZALLOC (struct gdb_object);
}

/* Readers call into this function to open a new gdb_symtab, which,
   again, is passed around to other callbacks.  */

static struct gdb_symtab *
jit_symtab_open_impl (struct gdb_symbol_callbacks *cb,
                      struct gdb_object *object,
                      const char *file_name)
{
  struct gdb_symtab *ret;

  /* CB stays unused.  See comment in jit_object_open_impl.  */

  ret = XZALLOC (struct gdb_symtab);
  ret->file_name = file_name ? xstrdup (file_name) : xstrdup ("");
  ret->next = object->symtabs;
  object->symtabs = ret;
  return ret;
}

/* Returns true if the block corresponding to old should be placed
   before the block corresponding to new in the final blockvector.  */

static int
compare_block (const struct gdb_block *const old,
               const struct gdb_block *const new)
{
  if (old == NULL)
    return 1;
  if (old->begin < new->begin)
    return 1;
  else if (old->begin == new->begin)
    {
      if (old->end > new->end)
        return 1;
      else
        return 0;
    }
  else
    return 0;
}

/* Called by readers to open a new gdb_block.  This function also
   inserts the new gdb_block in the correct place in the corresponding
   gdb_symtab.  */

static struct gdb_block *
jit_block_open_impl (struct gdb_symbol_callbacks *cb,
                     struct gdb_symtab *symtab, struct gdb_block *parent,
                     GDB_CORE_ADDR begin, GDB_CORE_ADDR end, const char *name)
{
  struct gdb_block *block = XZALLOC (struct gdb_block);

  block->next = symtab->blocks;
  block->begin = (CORE_ADDR) begin;
  block->end = (CORE_ADDR) end;
  block->name = name ? xstrdup (name) : NULL;
  block->parent = parent;

  /* Ensure that the blocks are inserted in the correct (reverse of
     the order expected by blockvector).  */
  if (compare_block (symtab->blocks, block))
    {
      symtab->blocks = block;
    }
  else
    {
      struct gdb_block *i = symtab->blocks;

      for (;; i = i->next)
        {
          /* Guaranteed to terminate, since compare_block (NULL, _)
             returns 1.  */
          if (compare_block (i->next, block))
            {
              block->next = i->next;
              i->next = block;
              break;
            }
        }
    }
  symtab->nblocks++;

  return block;
}

/* Readers call this to add a line mapping (from PC to line number) to
   a gdb_symtab.  */

static void
jit_symtab_line_mapping_add_impl (struct gdb_symbol_callbacks *cb,
                                  struct gdb_symtab *stab, int nlines,
                                  struct gdb_line_mapping *map)
{
  int i;

  if (nlines < 1)
    return;

  stab->linetable = xmalloc (sizeof (struct linetable)
                             + (nlines - 1) * sizeof (struct linetable_entry));
  stab->linetable->nitems = nlines;
  for (i = 0; i < nlines; i++)
    {
      stab->linetable->item[i].pc = (CORE_ADDR) map[i].pc;
      stab->linetable->item[i].line = map[i].line;
    }
}

/* Called by readers to close a gdb_symtab.  Does not need to do
   anything as of now.  */

static void
jit_symtab_close_impl (struct gdb_symbol_callbacks *cb,
                       struct gdb_symtab *stab)
{
  /* Right now nothing needs to be done here.  We may need to do some
     cleanup here in the future (again, without breaking the plugin
     ABI).  */
}

/* Transform STAB to a proper symtab, and add it it OBJFILE.  */

static void
finalize_symtab (struct gdb_symtab *stab, struct objfile *objfile)
{
  struct symtab *symtab;
  struct gdb_block *gdb_block_iter, *gdb_block_iter_tmp;
  struct block *block_iter;
  int actual_nblocks, i, blockvector_size;
  CORE_ADDR begin, end;

  actual_nblocks = FIRST_LOCAL_BLOCK + stab->nblocks;

  symtab = allocate_symtab (stab->file_name, objfile);
  /* JIT compilers compile in memory.  */
  symtab->dirname = NULL;

  /* Copy over the linetable entry if one was provided.  */
  if (stab->linetable)
    {
      int size = ((stab->linetable->nitems - 1)
                  * sizeof (struct linetable_entry)
                  + sizeof (struct linetable));
      LINETABLE (symtab) = obstack_alloc (&objfile->objfile_obstack, size);
      memcpy (LINETABLE (symtab), stab->linetable, size);
    }
  else
    {
      LINETABLE (symtab) = NULL;
    }

  blockvector_size = (sizeof (struct blockvector)
                      + (actual_nblocks - 1) * sizeof (struct block *));
  symtab->blockvector = obstack_alloc (&objfile->objfile_obstack,
                                       blockvector_size);

  /* (begin, end) will contain the PC range this entire blockvector
     spans.  */
  symtab->primary = 1;
  BLOCKVECTOR_MAP (symtab->blockvector) = NULL;
  begin = stab->blocks->begin;
  end = stab->blocks->end;
  BLOCKVECTOR_NBLOCKS (symtab->blockvector) = actual_nblocks;

  /* First run over all the gdb_block objects, creating a real block
     object for each.  Simultaneously, keep setting the real_block
     fields.  */
  for (i = (actual_nblocks - 1), gdb_block_iter = stab->blocks;
       i >= FIRST_LOCAL_BLOCK;
       i--, gdb_block_iter = gdb_block_iter->next)
    {
      struct block *new_block = allocate_block (&objfile->objfile_obstack);
      struct symbol *block_name = allocate_symbol (objfile);
      struct type *block_type = arch_type (get_objfile_arch (objfile),
					   TYPE_CODE_VOID,
					   1,
					   "void");

      BLOCK_DICT (new_block) = dict_create_linear (&objfile->objfile_obstack,
                                                   NULL);
      /* The address range.  */
      BLOCK_START (new_block) = (CORE_ADDR) gdb_block_iter->begin;
      BLOCK_END (new_block) = (CORE_ADDR) gdb_block_iter->end;

      /* The name.  */
      SYMBOL_DOMAIN (block_name) = VAR_DOMAIN;
      SYMBOL_ACLASS_INDEX (block_name) = LOC_BLOCK;
      SYMBOL_SYMTAB (block_name) = symtab;
      SYMBOL_TYPE (block_name) = lookup_function_type (block_type);
      SYMBOL_BLOCK_VALUE (block_name) = new_block;

      block_name->ginfo.name = obstack_copy0 (&objfile->objfile_obstack,
					      gdb_block_iter->name,
					      strlen (gdb_block_iter->name));

      BLOCK_FUNCTION (new_block) = block_name;

      BLOCKVECTOR_BLOCK (symtab->blockvector, i) = new_block;
      if (begin > BLOCK_START (new_block))
        begin = BLOCK_START (new_block);
      if (end < BLOCK_END (new_block))
        end = BLOCK_END (new_block);

      gdb_block_iter->real_block = new_block;
    }

  /* Now add the special blocks.  */
  block_iter = NULL;
  for (i = 0; i < FIRST_LOCAL_BLOCK; i++)
    {
      struct block *new_block;

      new_block = (i == GLOBAL_BLOCK
		   ? allocate_global_block (&objfile->objfile_obstack)
		   : allocate_block (&objfile->objfile_obstack));
      BLOCK_DICT (new_block) = dict_create_linear (&objfile->objfile_obstack,
                                                   NULL);
      BLOCK_SUPERBLOCK (new_block) = block_iter;
      block_iter = new_block;

      BLOCK_START (new_block) = (CORE_ADDR) begin;
      BLOCK_END (new_block) = (CORE_ADDR) end;

      BLOCKVECTOR_BLOCK (symtab->blockvector, i) = new_block;

      if (i == GLOBAL_BLOCK)
	set_block_symtab (new_block, symtab);
    }

  /* Fill up the superblock fields for the real blocks, using the
     real_block fields populated earlier.  */
  for (gdb_block_iter = stab->blocks;
       gdb_block_iter;
       gdb_block_iter = gdb_block_iter->next)
    {
      if (gdb_block_iter->parent != NULL)
	{
	  /* If the plugin specifically mentioned a parent block, we
	     use that.  */
	  BLOCK_SUPERBLOCK (gdb_block_iter->real_block) =
	    gdb_block_iter->parent->real_block;
	}
      else
	{
	  /* And if not, we set a default parent block.  */
	  BLOCK_SUPERBLOCK (gdb_block_iter->real_block) =
	    BLOCKVECTOR_BLOCK (symtab->blockvector, STATIC_BLOCK);
	}
    }

  /* Free memory.  */
  gdb_block_iter = stab->blocks;

  for (gdb_block_iter = stab->blocks, gdb_block_iter_tmp = gdb_block_iter->next;
       gdb_block_iter;
       gdb_block_iter = gdb_block_iter_tmp)
    {
      xfree ((void *) gdb_block_iter->name);
      xfree (gdb_block_iter);
    }
  xfree (stab->linetable);
  xfree ((char *) stab->file_name);
  xfree (stab);
}

/* Called when closing a gdb_objfile.  Converts OBJ to a proper
   objfile.  */

static void
jit_object_close_impl (struct gdb_symbol_callbacks *cb,
                       struct gdb_object *obj)
{
  struct gdb_symtab *i, *j;
  struct objfile *objfile;
  jit_dbg_reader_data *priv_data;

  priv_data = cb->priv_data;

  objfile = allocate_objfile (NULL, "<< JIT compiled code >>",
			      OBJF_NOT_FILENAME);
  objfile->per_bfd->gdbarch = target_gdbarch ();

  terminate_minimal_symbol_table (objfile);

  j = NULL;
  for (i = obj->symtabs; i; i = j)
    {
      j = i->next;
      finalize_symtab (i, objfile);
    }
  add_objfile_entry (objfile, *priv_data);
  xfree (obj);
}

/* Try to read CODE_ENTRY using the loaded jit reader (if any).
   ENTRY_ADDR is the address of the struct jit_code_entry in the
   inferior address space.  */

static int
jit_reader_try_read_symtab (struct jit_code_entry *code_entry,
                            CORE_ADDR entry_addr)
{
  void *gdb_mem;
  int status;
  jit_dbg_reader_data priv_data;
  struct gdb_reader_funcs *funcs;
  volatile struct gdb_exception e;
  struct gdb_symbol_callbacks callbacks =
    {
      jit_object_open_impl,
      jit_symtab_open_impl,
      jit_block_open_impl,
      jit_symtab_close_impl,
      jit_object_close_impl,

      jit_symtab_line_mapping_add_impl,
      jit_target_read_impl,

      &priv_data
    };

  priv_data = entry_addr;

  if (!loaded_jit_reader)
    return 0;

  gdb_mem = xmalloc (code_entry->symfile_size);

  status = 1;
  TRY_CATCH (e, RETURN_MASK_ALL)
    if (target_read_memory (code_entry->symfile_addr, gdb_mem,
                            code_entry->symfile_size))
      status = 0;
  if (e.reason < 0)
    status = 0;

  if (status)
    {
      funcs = loaded_jit_reader->functions;
      if (funcs->read (funcs, &callbacks, gdb_mem, code_entry->symfile_size)
          != GDB_SUCCESS)
        status = 0;
    }

  xfree (gdb_mem);
  if (jit_debug && status == 0)
    fprintf_unfiltered (gdb_stdlog,
                        "Could not read symtab using the loaded JIT reader.\n");
  return status;
}

/* Try to read CODE_ENTRY using BFD.  ENTRY_ADDR is the address of the
   struct jit_code_entry in the inferior address space.  */

static void
jit_bfd_try_read_symtab (struct jit_code_entry *code_entry,
                         CORE_ADDR entry_addr,
                         struct gdbarch *gdbarch)
{
  bfd *nbfd;
  struct section_addr_info *sai;
  struct bfd_section *sec;
  struct objfile *objfile;
  struct cleanup *old_cleanups;
  int i;
  const struct bfd_arch_info *b;

  if (jit_debug)
    fprintf_unfiltered (gdb_stdlog,
			"jit_register_code, symfile_addr = %s, "
			"symfile_size = %s\n",
			paddress (gdbarch, code_entry->symfile_addr),
			pulongest (code_entry->symfile_size));

  nbfd = bfd_open_from_target_memory (code_entry->symfile_addr,
                                      code_entry->symfile_size, gnutarget);
  if (nbfd == NULL)
    {
      puts_unfiltered (_("Error opening JITed symbol file, ignoring it.\n"));
      return;
    }

  /* Check the format.  NOTE: This initializes important data that GDB uses!
     We would segfault later without this line.  */
  if (!bfd_check_format (nbfd, bfd_object))
    {
      printf_unfiltered (_("\
JITed symbol file is not an object file, ignoring it.\n"));
      gdb_bfd_unref (nbfd);
      return;
    }

  /* Check bfd arch.  */
  b = gdbarch_bfd_arch_info (gdbarch);
  if (b->compatible (b, bfd_get_arch_info (nbfd)) != b)
    warning (_("JITed object file architecture %s is not compatible "
               "with target architecture %s."), bfd_get_arch_info
             (nbfd)->printable_name, b->printable_name);

  /* Read the section address information out of the symbol file.  Since the
     file is generated by the JIT at runtime, it should all of the absolute
     addresses that we care about.  */
  sai = alloc_section_addr_info (bfd_count_sections (nbfd));
  old_cleanups = make_cleanup_free_section_addr_info (sai);
  i = 0;
  for (sec = nbfd->sections; sec != NULL; sec = sec->next)
    if ((bfd_get_section_flags (nbfd, sec) & (SEC_ALLOC|SEC_LOAD)) != 0)
      {
        /* We assume that these virtual addresses are absolute, and do not
           treat them as offsets.  */
        sai->other[i].addr = bfd_get_section_vma (nbfd, sec);
        sai->other[i].name = xstrdup (bfd_get_section_name (nbfd, sec));
        sai->other[i].sectindex = sec->index;
        ++i;
      }
  sai->num_sections = i;

  /* This call does not take ownership of SAI.  */
  make_cleanup_bfd_unref (nbfd);
  objfile = symbol_file_add_from_bfd (nbfd, bfd_get_filename (nbfd), 0, sai,
				      OBJF_SHARED | OBJF_NOT_FILENAME, NULL);

  do_cleanups (old_cleanups);
  add_objfile_entry (objfile, entry_addr);
}

/* This function registers code associated with a JIT code entry.  It uses the
   pointer and size pair in the entry to read the symbol file from the remote
   and then calls symbol_file_add_from_local_memory to add it as though it were
   a symbol file added by the user.  */

static void
jit_register_code (struct gdbarch *gdbarch,
                   CORE_ADDR entry_addr, struct jit_code_entry *code_entry)
{
  int success;

  if (jit_debug)
    fprintf_unfiltered (gdb_stdlog,
                        "jit_register_code, symfile_addr = %s, "
                        "symfile_size = %s\n",
                        paddress (gdbarch, code_entry->symfile_addr),
                        pulongest (code_entry->symfile_size));

  success = jit_reader_try_read_symtab (code_entry, entry_addr);

  if (!success)
    jit_bfd_try_read_symtab (code_entry, entry_addr, gdbarch);
}

/* This function unregisters JITed code and frees the corresponding
   objfile.  */

static void
jit_unregister_code (struct objfile *objfile)
{
  free_objfile (objfile);
}

/* Look up the objfile with this code entry address.  */

static struct objfile *
jit_find_objf_with_entry_addr (CORE_ADDR entry_addr)
{
  struct objfile *objf;

  ALL_OBJFILES (objf)
    {
      struct jit_objfile_data *objf_data;

      objf_data = objfile_data (objf, jit_objfile_data);
      if (objf_data != NULL && objf_data->addr == entry_addr)
        return objf;
    }
  return NULL;
}

/* This is called when a breakpoint is deleted.  It updates the
   inferior's cache, if needed.  */

static void
jit_breakpoint_deleted (struct breakpoint *b)
{
  struct bp_location *iter;

  if (b->type != bp_jit_event)
    return;

  for (iter = b->loc; iter != NULL; iter = iter->next)
    {
      struct jit_program_space_data *ps_data;

      ps_data = program_space_data (iter->pspace, jit_program_space_data);
      if (ps_data != NULL && ps_data->jit_breakpoint == iter->owner)
	{
	  ps_data->cached_code_address = 0;
	  ps_data->jit_breakpoint = NULL;
	}
    }
}

/* (Re-)Initialize the jit breakpoint if necessary.
   Return 0 on success.  */

static int
jit_breakpoint_re_set_internal (struct gdbarch *gdbarch,
				struct jit_program_space_data *ps_data)
{
  struct bound_minimal_symbol reg_symbol;
  struct minimal_symbol *desc_symbol;
  struct jit_objfile_data *objf_data;
  CORE_ADDR addr;

  if (ps_data->objfile == NULL)
    {
      /* Lookup the registration symbol.  If it is missing, then we
	 assume we are not attached to a JIT.  */
      reg_symbol = lookup_minimal_symbol_and_objfile (jit_break_name);
      if (reg_symbol.minsym == NULL
	  || SYMBOL_VALUE_ADDRESS (reg_symbol.minsym) == 0)
	return 1;

      desc_symbol = lookup_minimal_symbol (jit_descriptor_name, NULL,
					   reg_symbol.objfile);
      if (desc_symbol == NULL || SYMBOL_VALUE_ADDRESS (desc_symbol) == 0)
	return 1;

      objf_data = get_jit_objfile_data (reg_symbol.objfile);
      objf_data->register_code = reg_symbol.minsym;
      objf_data->descriptor = desc_symbol;

      ps_data->objfile = reg_symbol.objfile;
    }
  else
    objf_data = get_jit_objfile_data (ps_data->objfile);

  addr = SYMBOL_VALUE_ADDRESS (objf_data->register_code);

  if (jit_debug)
    fprintf_unfiltered (gdb_stdlog,
			"jit_breakpoint_re_set_internal, "
			"breakpoint_addr = %s\n",
			paddress (gdbarch, addr));

  if (ps_data->cached_code_address == addr)
    return 1;

  /* Delete the old breakpoint.  */
  if (ps_data->jit_breakpoint != NULL)
    delete_breakpoint (ps_data->jit_breakpoint);

  /* Put a breakpoint in the registration symbol.  */
  ps_data->cached_code_address = addr;
  ps_data->jit_breakpoint = create_jit_event_breakpoint (gdbarch, addr);

  return 0;
}

/* The private data passed around in the frame unwind callback
   functions.  */

struct jit_unwind_private
{
  /* Cached register values.  See jit_frame_sniffer to see how this
     works.  */
  struct gdb_reg_value **registers;

  /* The frame being unwound.  */
  struct frame_info *this_frame;
};

/* Sets the value of a particular register in this frame.  */

static void
jit_unwind_reg_set_impl (struct gdb_unwind_callbacks *cb, int dwarf_regnum,
                         struct gdb_reg_value *value)
{
  struct jit_unwind_private *priv;
  int gdb_reg;

  priv = cb->priv_data;

  gdb_reg = gdbarch_dwarf2_reg_to_regnum (get_frame_arch (priv->this_frame),
                                          dwarf_regnum);
  if (gdb_reg == -1)
    {
      if (jit_debug)
        fprintf_unfiltered (gdb_stdlog,
                            _("Could not recognize DWARF regnum %d"),
                            dwarf_regnum);
      return;
    }

  gdb_assert (priv->registers);
  priv->registers[gdb_reg] = value;
}

static void
reg_value_free_impl (struct gdb_reg_value *value)
{
  xfree (value);
}

/* Get the value of register REGNUM in the previous frame.  */

static struct gdb_reg_value *
jit_unwind_reg_get_impl (struct gdb_unwind_callbacks *cb, int regnum)
{
  struct jit_unwind_private *priv;
  struct gdb_reg_value *value;
  int gdb_reg, size;
  struct gdbarch *frame_arch;

  priv = cb->priv_data;
  frame_arch = get_frame_arch (priv->this_frame);

  gdb_reg = gdbarch_dwarf2_reg_to_regnum (frame_arch, regnum);
  size = register_size (frame_arch, gdb_reg);
  value = xmalloc (sizeof (struct gdb_reg_value) + size - 1);
  value->defined = deprecated_frame_register_read (priv->this_frame, gdb_reg,
						   value->value);
  value->size = size;
  value->free = reg_value_free_impl;
  return value;
}

/* gdb_reg_value has a free function, which must be called on each
   saved register value.  */

static void
jit_dealloc_cache (struct frame_info *this_frame, void *cache)
{
  struct jit_unwind_private *priv_data = cache;
  struct gdbarch *frame_arch;
  int i;

  gdb_assert (priv_data->registers);
  frame_arch = get_frame_arch (priv_data->this_frame);

  for (i = 0; i < gdbarch_num_regs (frame_arch); i++)
    if (priv_data->registers[i] && priv_data->registers[i]->free)
      priv_data->registers[i]->free (priv_data->registers[i]);

  xfree (priv_data->registers);
  xfree (priv_data);
}

/* The frame sniffer for the pseudo unwinder.

   While this is nominally a frame sniffer, in the case where the JIT
   reader actually recognizes the frame, it does a lot more work -- it
   unwinds the frame and saves the corresponding register values in
   the cache.  jit_frame_prev_register simply returns the saved
   register values.  */

static int
jit_frame_sniffer (const struct frame_unwind *self,
                   struct frame_info *this_frame, void **cache)
{
  struct jit_unwind_private *priv_data;
  struct gdb_unwind_callbacks callbacks;
  struct gdb_reader_funcs *funcs;

  callbacks.reg_get = jit_unwind_reg_get_impl;
  callbacks.reg_set = jit_unwind_reg_set_impl;
  callbacks.target_read = jit_target_read_impl;

  if (loaded_jit_reader == NULL)
    return 0;

  funcs = loaded_jit_reader->functions;

  gdb_assert (!*cache);

  *cache = XZALLOC (struct jit_unwind_private);
  priv_data = *cache;
  priv_data->registers =
    XCALLOC (gdbarch_num_regs (get_frame_arch (this_frame)),
             struct gdb_reg_value *);
  priv_data->this_frame = this_frame;

  callbacks.priv_data = priv_data;

  /* Try to coax the provided unwinder to unwind the stack */
  if (funcs->unwind (funcs, &callbacks) == GDB_SUCCESS)
    {
      if (jit_debug)
        fprintf_unfiltered (gdb_stdlog, _("Successfully unwound frame using "
                                          "JIT reader.\n"));
      return 1;
    }
  if (jit_debug)
    fprintf_unfiltered (gdb_stdlog, _("Could not unwind frame using "
                                      "JIT reader.\n"));

  jit_dealloc_cache (this_frame, *cache);
  *cache = NULL;

  return 0;
}


/* The frame_id function for the pseudo unwinder.  Relays the call to
   the loaded plugin.  */

static void
jit_frame_this_id (struct frame_info *this_frame, void **cache,
                   struct frame_id *this_id)
{
  struct jit_unwind_private private;
  struct gdb_frame_id frame_id;
  struct gdb_reader_funcs *funcs;
  struct gdb_unwind_callbacks callbacks;

  private.registers = NULL;
  private.this_frame = this_frame;

  /* We don't expect the frame_id function to set any registers, so we
     set reg_set to NULL.  */
  callbacks.reg_get = jit_unwind_reg_get_impl;
  callbacks.reg_set = NULL;
  callbacks.target_read = jit_target_read_impl;
  callbacks.priv_data = &private;

  gdb_assert (loaded_jit_reader);
  funcs = loaded_jit_reader->functions;

  frame_id = funcs->get_frame_id (funcs, &callbacks);
  *this_id = frame_id_build (frame_id.stack_address, frame_id.code_address);
}

/* Pseudo unwinder function.  Reads the previously fetched value for
   the register from the cache.  */

static struct value *
jit_frame_prev_register (struct frame_info *this_frame, void **cache, int reg)
{
  struct jit_unwind_private *priv = *cache;
  struct gdb_reg_value *value;

  if (priv == NULL)
    return frame_unwind_got_optimized (this_frame, reg);

  gdb_assert (priv->registers);
  value = priv->registers[reg];
  if (value && value->defined)
    return frame_unwind_got_bytes (this_frame, reg, value->value);
  else
    return frame_unwind_got_optimized (this_frame, reg);
}

/* Relay everything back to the unwinder registered by the JIT debug
   info reader.*/

static const struct frame_unwind jit_frame_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  jit_frame_this_id,
  jit_frame_prev_register,
  NULL,
  jit_frame_sniffer,
  jit_dealloc_cache
};


/* This is the information that is stored at jit_gdbarch_data for each
   architecture.  */

struct jit_gdbarch_data_type
{
  /* Has the (pseudo) unwinder been prepended? */
  int unwinder_registered;
};

/* Check GDBARCH and prepend the pseudo JIT unwinder if needed.  */

static void
jit_prepend_unwinder (struct gdbarch *gdbarch)
{
  struct jit_gdbarch_data_type *data;

  data = gdbarch_data (gdbarch, jit_gdbarch_data);
  if (!data->unwinder_registered)
    {
      frame_unwind_prepend_unwinder (gdbarch, &jit_frame_unwind);
      data->unwinder_registered = 1;
    }
}

/* Register any already created translations.  */

static void
jit_inferior_init (struct gdbarch *gdbarch)
{
  struct jit_descriptor descriptor;
  struct jit_code_entry cur_entry;
  struct jit_program_space_data *ps_data;
  CORE_ADDR cur_entry_addr;

  if (jit_debug)
    fprintf_unfiltered (gdb_stdlog, "jit_inferior_init\n");

  jit_prepend_unwinder (gdbarch);

  ps_data = get_jit_program_space_data ();
  if (jit_breakpoint_re_set_internal (gdbarch, ps_data) != 0)
    return;

  /* Read the descriptor so we can check the version number and load
     any already JITed functions.  */
  if (!jit_read_descriptor (gdbarch, &descriptor, ps_data))
    return;

  /* Check that the version number agrees with that we support.  */
  if (descriptor.version != 1)
    {
      printf_unfiltered (_("Unsupported JIT protocol version %ld "
			   "in descriptor (expected 1)\n"),
			 (long) descriptor.version);
      return;
    }

  /* If we've attached to a running program, we need to check the descriptor
     to register any functions that were already generated.  */
  for (cur_entry_addr = descriptor.first_entry;
       cur_entry_addr != 0;
       cur_entry_addr = cur_entry.next_entry)
    {
      jit_read_code_entry (gdbarch, cur_entry_addr, &cur_entry);

      /* This hook may be called many times during setup, so make sure we don't
         add the same symbol file twice.  */
      if (jit_find_objf_with_entry_addr (cur_entry_addr) != NULL)
        continue;

      jit_register_code (gdbarch, cur_entry_addr, &cur_entry);
    }
}

/* Exported routine to call when an inferior has been created.  */

void
jit_inferior_created_hook (void)
{
  jit_inferior_init (target_gdbarch ());
}

/* Exported routine to call to re-set the jit breakpoints,
   e.g. when a program is rerun.  */

void
jit_breakpoint_re_set (void)
{
  jit_breakpoint_re_set_internal (target_gdbarch (),
				  get_jit_program_space_data ());
}

/* This function cleans up any code entries left over when the
   inferior exits.  We get left over code when the inferior exits
   without unregistering its code, for example when it crashes.  */

static void
jit_inferior_exit_hook (struct inferior *inf)
{
  struct objfile *objf;
  struct objfile *temp;

  ALL_OBJFILES_SAFE (objf, temp)
    {
      struct jit_objfile_data *objf_data = objfile_data (objf,
							 jit_objfile_data);

      if (objf_data != NULL && objf_data->addr != 0)
	jit_unregister_code (objf);
    }
}

void
jit_event_handler (struct gdbarch *gdbarch)
{
  struct jit_descriptor descriptor;
  struct jit_code_entry code_entry;
  CORE_ADDR entry_addr;
  struct objfile *objf;

  /* Read the descriptor from remote memory.  */
  if (!jit_read_descriptor (gdbarch, &descriptor,
			    get_jit_program_space_data ()))
    return;
  entry_addr = descriptor.relevant_entry;

  /* Do the corresponding action.  */
  switch (descriptor.action_flag)
    {
    case JIT_NOACTION:
      break;
    case JIT_REGISTER:
      jit_read_code_entry (gdbarch, entry_addr, &code_entry);
      jit_register_code (gdbarch, entry_addr, &code_entry);
      break;
    case JIT_UNREGISTER:
      objf = jit_find_objf_with_entry_addr (entry_addr);
      if (objf == NULL)
	printf_unfiltered (_("Unable to find JITed code "
			     "entry at address: %s\n"),
			   paddress (gdbarch, entry_addr));
      else
        jit_unregister_code (objf);

      break;
    default:
      error (_("Unknown action_flag value in JIT descriptor!"));
      break;
    }
}

/* Called to free the data allocated to the jit_program_space_data slot.  */

static void
free_objfile_data (struct objfile *objfile, void *data)
{
  struct jit_objfile_data *objf_data = data;

  if (objf_data->register_code != NULL)
    {
      struct jit_program_space_data *ps_data;

      ps_data = program_space_data (objfile->pspace, jit_program_space_data);
      if (ps_data != NULL && ps_data->objfile == objfile)
	ps_data->objfile = NULL;
    }

  xfree (data);
}

/* Initialize the jit_gdbarch_data slot with an instance of struct
   jit_gdbarch_data_type */

static void *
jit_gdbarch_data_init (struct obstack *obstack)
{
  struct jit_gdbarch_data_type *data;

  data = obstack_alloc (obstack, sizeof (struct jit_gdbarch_data_type));
  data->unwinder_registered = 0;
  return data;
}

/* Provide a prototype to silence -Wmissing-prototypes.  */

extern void _initialize_jit (void);

void
_initialize_jit (void)
{
  jit_reader_dir = relocate_gdb_directory (JIT_READER_DIR,
                                           JIT_READER_DIR_RELOCATABLE);
  add_setshow_zuinteger_cmd ("jit", class_maintenance, &jit_debug,
			     _("Set JIT debugging."),
			     _("Show JIT debugging."),
			     _("When non-zero, JIT debugging is enabled."),
			     NULL,
			     show_jit_debug,
			     &setdebuglist, &showdebuglist);

  observer_attach_inferior_exit (jit_inferior_exit_hook);
  observer_attach_breakpoint_deleted (jit_breakpoint_deleted);

  jit_objfile_data =
    register_objfile_data_with_cleanup (NULL, free_objfile_data);
  jit_program_space_data =
    register_program_space_data_with_cleanup (NULL,
					      jit_program_space_data_cleanup);
  jit_gdbarch_data = gdbarch_data_register_pre_init (jit_gdbarch_data_init);
  if (is_dl_available ())
    {
      add_com ("jit-reader-load", no_class, jit_reader_load_command, _("\
Load FILE as debug info reader and unwinder for JIT compiled code.\n\
Usage: jit-reader-load FILE\n\
Try to load file FILE as a debug info reader (and unwinder) for\n\
JIT compiled code.  The file is loaded from " JIT_READER_DIR ",\n\
relocated relative to the GDB executable if required."));
      add_com ("jit-reader-unload", no_class, jit_reader_unload_command, _("\
Unload the currently loaded JIT debug info reader.\n\
Usage: jit-reader-unload FILE\n\n\
Do \"help jit-reader-load\" for info on loading debug info readers."));
    }
}
@


1.56
log
@Keep objfile original filename

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Pass down original filename for objfile.
	* coffread.c (coff_symfile_read): Update symbol_file_add_separate call.
	* elfread.c (elf_symfile_read): Likewise.
	* jit.c (jit_object_close_impl): Update allocate_objfile call, no
	longer set ORIGINAL_NAME.
	(jit_bfd_try_read_symtab): Update symbol_file_add_from_bfd call.
	* jv-lang.c (get_dynamics_objfile): Update allocate_objfile call.
	* machoread.c (macho_add_oso_symfile): Add parameter name.  Update
	symbol_file_add_from_bfd call.
	(macho_symfile_read_all_oso): Update two macho_add_oso_symfile calls.
	(macho_check_dsym): Add parameter filenamep.  Change function comment.
	Set *filenamep.
	(macho_symfile_read): New variable dsym_filename.  Update
	macho_check_dsym call.  Use it for symbol_file_add_separate.
	* objfiles.c (allocate_objfile): Add parameter name.  New comment for
	it.  Use it for objfile->original_name.
	(objfile_name): Return OBFD's filename, if available.
	* objfiles.h (allocate_objfile): Add new parameter name.
	* solib.c (solib_read_symbols): Update symbol_file_add_from_bfd call.
	* symfile-mem.c (symbol_file_add_from_memory): Update
	symbol_file_add_from_bfd call.
	* symfile.c (read_symbols): Update symbol_file_add_separate call, new
	comment for it.
	(symbol_file_add_with_addrs): New parameter name, add function comment
	for it.  Remove variable name.  Update allocate_objfile call.
	(symbol_file_add_separate): New parameter name, add function comment
	for it.  Update symbol_file_add_with_addrs call.
	(symbol_file_add_from_bfd): New parameter name.  Update
	symbol_file_add_with_addrs call.
	(symbol_file_add): Update symbol_file_add_from_bfd call.
	(reread_symbols): New variable original_name.  Save
	objfile->original_name by it.
	* symfile.h (symbol_file_add_from_bfd, symbol_file_add_separate): Add
	second parameter.
@
text
@d788 2
a789 1
  objfile = allocate_objfile (NULL, "<< JIT compiled code >>", 0);
d930 1
a930 1
				      OBJF_SHARED, NULL);
@


1.55
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@d788 1
a788 1
  objfile = allocate_objfile (NULL, 0);
a792 2
  objfile->original_name = "<< JIT compiled code >>";

d928 2
a929 1
  objfile = symbol_file_add_from_bfd (nbfd, 0, sai, OBJF_SHARED, NULL);
@


1.54
log
@move gdbarch object from objfile to per-BFD

This moves the "gdbarch" field from the objfile into the BFD.

This field's value is derived from the BFD and is immutable over the
lifetime of the BFD.  This makes it a reasonable candidate for pushing
into the per-BFD object.

This is part of the long-term objfile splitting project.  In the long
run I think this patch will make it simpler to moves types from the
objfile to the per-BFD object; but the patch makes sense as a minor
cleanup by itself.

Built and regtested on x86-64 Fedora 18.

	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Use
	get_objfile_arch.
	* elfread.c (elf_rel_plt_read, elf_gnu_ifunc_record_cache)
	(elf_gnu_ifunc_resolve_by_got): Use get_objfile_arch.
	* jit.c (jit_object_close_impl): Update.
	* jv-lang.c (get_dynamics_objfile): Update.
	* linespec.c (add_minsym): Use get_dynamics_objfile.
	* objfiles.c (get_objfile_bfd_data): Initialize 'gdbarch' field.
	(allocate_objfile): Don't initialize 'gdbarch' field.
	(get_objfile_arch): Update.
	* objfiles.h (struct objfile_per_bfd_storage) <gdbarch>: New field,
	moved from...
	(struct objfile) <gdbarch>: ... here.  Remove.
	* stap-probe.c (stap_can_evaluate_probe_arguments): Use
	get_objfile_arch.
	* symfile.c (init_entry_point_info): Use get_objfile_arch.
@
text
@d793 1
a793 1
  objfile->name = "<< JIT compiled code >>";
@


1.53
log
@gdb/
	Fix GDB regression related to PR binutils/14813.
	* jit.c (mem_bfd_iovec_close): Return 0 for success.
	* minidebug.c (lzma_close): Add return value comment.
	* remote.c (remote_bfd_iovec_close): Return 0 for success.
	* solib-spu.c (spu_bfd_iovec_close): Likewise.
	* spu-linux-nat.c (spu_bfd_iovec_close): Likewise.
@
text
@d789 1
a789 1
  objfile->gdbarch = target_gdbarch ();
@


1.52
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@d93 3
a95 1
  return 1;
@


1.51
log
@	* coffread.c (process_coff_symbol, coff_read_enum_type): Call
	allocate_symbol.
	* dwarf2read.c (fixup_go_packaging): Call allocate_symbol.
	(read_func_scope): Call allocate_template_symbol.
	(new_symbol_full): Call allocate_symbol.
	* jit.c (finalize_symtab): Call allocate_symbol.
	* jv-lang.c (add_class_symbol): Call allocate_symbol.
	* mdebugread.c (parse_symbol, new_block): Call allocate_symbol.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_end): Call allocate_symbol.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): New functions.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): Declare.
	* xcoffread.c (process_xcoff_symbol): Call initialize_symbol.
@
text
@d1016 2
a1017 2
  struct minimal_symbol *reg_symbol, *desc_symbol;
  struct objfile *objf;
d1025 3
a1027 2
      reg_symbol = lookup_minimal_symbol_and_objfile (jit_break_name, &objf);
      if (reg_symbol == NULL || SYMBOL_VALUE_ADDRESS (reg_symbol) == 0)
d1030 2
a1031 1
      desc_symbol = lookup_minimal_symbol (jit_descriptor_name, NULL, objf);
d1035 2
a1036 2
      objf_data = get_jit_objfile_data (objf);
      objf_data->register_code = reg_symbol;
d1039 1
a1039 1
      ps_data->objfile = objf;
@


1.50
log
@	* symfile.c (alloc_section_addr_info): Update header.  Don't set
	'num_sections' field.
	(build_section_addr_info_from_section_table): Set 'num_sections'.
	(build_section_addr_info_from_bfd): Likewise.
	(build_section_addr_info_from_objfile): Remove dead loop
	condition.
	(free_section_addr_info): Unconditionally call xfree.
	(relative_addr_info_to_section_offsets, addrs_section_sort)
	(addr_info_make_relative, syms_from_objfile_1): Remove dead loop
	condition.
	(syms_from_objfile_1): Remove dead 'if' condition.  Check
	'num_sections'.
	(add_symbol_file_command): Set 'num_sections'.
	* symfile-mem.c (symbol_file_add_from_memory): Set
	'num_sections'.
	* somread.c (som_symfile_offsets): Remove dead loop condition.
	* machoread.c (macho_symfile_offsets): Remove dead 'if'.
	* jit.c (jit_bfd_try_read_symtab): Set 'num_sections'.
@
text
@d680 1
a680 2
      struct symbol *block_name = obstack_alloc (&objfile->objfile_obstack,
                                                 sizeof (struct symbol));
a692 1
      memset (block_name, 0, sizeof (struct symbol));
@


1.49
log
@2013-03-20  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>

	PR symtab/8421:
	* coffread.c (coff_register_index): New global.
	(process_coff_symbol, coff_read_enum_type): Set
	SYMBOL_ACLASS_INDEX.
	(_initialize_coffread): Initialize new global.
	* dwarf2loc.c (locexpr_find_frame_base_location)
	(dwarf2_block_frame_base_locexpr_funcs)
	(loclist_find_frame_base_location)
	(dwarf2_block_frame_base_loclist_funcs): New.
	(dwarf_expr_frame_base_1): Call SYMBOL_BLOCK_OPS, remove internal_error.
	(dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Add location_has_loclist.
	* dwarf2loc.h (dwarf2_block_frame_base_locexpr_funcs)
	(dwarf2_block_frame_base_loclist_funcs): New.
	* dwarf2read.c (dwarf2_locexpr_index, dwarf2_loclist_index)
	(dwarf2_locexpr_block_index, dwarf2_loclist_block_index): New
	globals.
	(read_func_scope): Update.
	(fixup_go_packaging, mark_common_block_symbol_computed)
	(var_decode_location, new_symbol_full, dwarf2_const_value):
	Set SYMBOL_ACLASS_INDEX.
	(dwarf2_symbol_mark_computed): Likewise.  Add 'is_block' argument.
	(_initialize_dwarf2_read): Initialize new globals.
	* jit.c (finalize_symtab): Set SYMBOL_ACLASS_INDEX.
	* jv-lang.c (add_class_symbol): Set SYMBOL_ACLASS_INDEX.
	* mdebugread.c (mdebug_register_index, mdebug_regparm_index): New
	globals.
	(parse_symbol, psymtab_to_symtab_1): Set SYMBOL_ACLASS_INDEX.
	(_initialize_mdebugread): Initialize new globals.
	* psympriv.h (struct partial_symbol) <aclass>: Update comment.
	* stabsread.c (patch_block_stabs): Set SYMBOL_ACLASS_INDEX.
	(stab_register_index, stab_regparm_index): New globals.
	(define_symbol, read_enum_type, common_block_end): Set
	SYMBOL_ACLASS_INDEX.
	(_initialize_stabsread): Initialize new globals.
	* symtab.c (next_aclass_value, symbol_impl, symbol_impls): New
	globals.
	(MAX_SYMBOL_IMPLS): New define.
	(register_symbol_computed_impl, register_symbol_block_impl)
	(register_symbol_register_impl)
	(initialize_ordinary_address_classes): New functions.
	(_initialize_symtab): Call initialize_ordinary_address_classes.
	* symtab.h (enum address_class) <LOC_FINAL_VALUE>: New constant.
	(struct symbol_impl): New.
	(SYMBOL_ACLASS_BITS): New define.
	(struct symbol) <aclass, ops>: Remove fields.
	<aclass_index>: New field.
	(symbol_impls): Declare.
	(SYMBOL_CLASS, SYMBOL_COMPUTED_OPS, SYMBOL_REGISTER_OPS): Redefine.
	(SYMBOL_IMPL, SYMBOL_ACLASS_INDEX): New defines.
	(register_symbol_computed_impl, register_symbol_block_impl)
	(register_symbol_register_impl): Declare.
	(struct symbol_computed_ops): Add location_has_loclist.
	(struct symbol_block_ops): New.
	(SYMBOL_BLOCK_OPS): New.
	* xcoffread.c (process_xcoff_symbol): Set SYMBOL_ACLASS_INDEX.
@
text
@d926 1
@


1.48
log
@	* jit.c (jit_program_space_data): Rename from jit_inferior_data;
	change type.
	(struct jit_program_space_data): Rename from jit_inferior_data.
	Update comments.
	(get_jit_program_space_data): Rename from get_jit_inferior_data.
	Change return type.  Attach data to program space.
	(jit_program_space_data_cleanup): Rename from
	jit_inferior_data_cleanup; change argument type.
	(jit_read_descriptor): Change 'inf_data' argument to 'ps_data',
	change type.
	(jit_register_code): Update.
	(jit_update_inferior_cache): Remove.
	(jit_breakpoint_deleted): Get jit data from the location's program
	space.
	(jit_breakpoint_re_set_internal): Rename 'inf_data' argument to
	'ps_data', change type.
	(jit_inferior_init, jit_breakpoint_re_set_internal)
	(jit_event_handler): Update.
	(free_objfile_data): Get data from objfile's program space.
	(_initialize_jit): Update.
@
text
@d696 1
a696 1
      SYMBOL_CLASS (block_name) = LOC_BLOCK;
@


1.48.2.1
log
@gdb/
	Fix GDB regression related to PR binutils/14813.
	* jit.c (mem_bfd_iovec_close): Return 0 for success.
	* minidebug.c (lzma_close): Add return value comment.
	* remote.c (remote_bfd_iovec_close): Return 0 for success.
	* solib-spu.c (spu_bfd_iovec_close): Likewise.
	* spu-linux-nat.c (spu_bfd_iovec_close): Likewise.
@
text
@d93 1
a93 3

  /* Zero means success.  */
  return 0;
@


1.47
log
@	PR gdb/13987:
	* jit.c (struct jit_inferior_data) <cached_code_address,
	jit_breakpoint>: New fields.
	(jit_breakpoint_re_set_internal): Fix logging.  Only create
	breakpoint if cached address has changed.
	(jit_update_inferior_cache, jit_breakpoint_deleted): New
	functions.
	(_initialize_jit): Register breakpoint deleted observer.
gdb/testsuite
	* gdb.base/jit.exp (compile_jit_test): New proc.
	Add PIE tests.
@
text
@d52 1
a52 1
static const struct inferior_data *jit_inferior_data = NULL;
d237 1
a237 1
/* Per-inferior structure recording which objfile has the JIT
d240 1
a240 1
struct jit_inferior_data
d247 1
a247 1
  /* If this inferior has __jit_debug_register_code, this is the
d259 1
a259 1
/* Per-objfile structure recording the addresses in the inferior.
d308 2
a309 2
/* Return jit_inferior_data for current inferior.  Allocate if not already
   present.  */
d311 2
a312 2
static struct jit_inferior_data *
get_jit_inferior_data (void)
d314 1
a314 2
  struct inferior *inf;
  struct jit_inferior_data *inf_data;
d316 2
a317 3
  inf = current_inferior ();
  inf_data = inferior_data (inf, jit_inferior_data);
  if (inf_data == NULL)
d319 3
a321 2
      inf_data = XZALLOC (struct jit_inferior_data);
      set_inferior_data (inf, jit_inferior_data, inf_data);
d324 1
a324 1
  return inf_data;
d328 1
a328 1
jit_inferior_data_cleanup (struct inferior *inf, void *arg)
d339 1
a339 1
		     struct jit_inferior_data *inf_data)
d349 1
a349 1
  if (inf_data->objfile == NULL)
d351 1
a351 1
  objf_data = get_jit_objfile_data (inf_data->objfile);
a985 23
/* A callback for iterate_over_inferiors that updates the inferior's
   JIT breakpoint information, if necessary.  */

static int
jit_update_inferior_cache (struct inferior *inf, void *data)
{
  struct bp_location *loc = data;

  if (inf->pspace == loc->pspace)
    {
      struct jit_inferior_data *inf_data;

      inf_data = inferior_data (inf, jit_inferior_data);
      if (inf_data != NULL && inf_data->jit_breakpoint == loc->owner)
	{
	  inf_data->cached_code_address = 0;
	  inf_data->jit_breakpoint = NULL;
	}
    }

  return 0;
}

d998 10
a1007 1
    iterate_over_inferiors (jit_update_inferior_cache, iter);
d1015 1
a1015 1
				struct jit_inferior_data *inf_data)
d1022 1
a1022 1
  if (inf_data->objfile == NULL)
d1038 1
a1038 1
      inf_data->objfile = objf;
d1041 1
a1041 1
    objf_data = get_jit_objfile_data (inf_data->objfile);
d1051 1
a1051 1
  if (inf_data->cached_code_address == addr)
d1055 2
a1056 2
  if (inf_data->jit_breakpoint != NULL)
    delete_breakpoint (inf_data->jit_breakpoint);
d1059 2
a1060 2
  inf_data->cached_code_address = addr;
  inf_data->jit_breakpoint = create_jit_event_breakpoint (gdbarch, addr);
d1304 1
a1304 1
  struct jit_inferior_data *inf_data;
d1312 2
a1313 2
  inf_data = get_jit_inferior_data ();
  if (jit_breakpoint_re_set_internal (gdbarch, inf_data) != 0)
d1318 1
a1318 1
  if (!jit_read_descriptor (gdbarch, &descriptor, inf_data))
d1362 1
a1362 1
				  get_jit_inferior_data ());
d1394 2
a1395 1
  if (!jit_read_descriptor (gdbarch, &descriptor, get_jit_inferior_data ()))
d1424 1
a1424 1
/* Called to free the data allocated to the jit_inferior_data slot.  */
d1433 1
a1433 1
      struct jit_inferior_data *inf_data = get_jit_inferior_data ();
d1435 3
a1437 2
      if (inf_data->objfile == objfile)
	inf_data->objfile = NULL;
d1478 3
a1480 2
  jit_inferior_data =
    register_inferior_data_with_cleanup (NULL, jit_inferior_data_cleanup);
@


1.46
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

	* infrun.c (handle_syscall_event): Remove unused gdbarch.
	(save_infcall_suspend_state): Ifdef out unused inf.
	(restore_infcall_suspend_state): Ifdef out unused inf.
	* jit.c (jit_register_code): Remove unused i, b, inf_data.
	(jit_frame_sniffer): Remove unused inf_data.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00773.html
@
text
@d246 11
d259 5
a263 1
/* Per-objfile structure recording the addresses in the inferior.  */
d273 2
a274 1
  /* Address of struct jit_code_entry in this objfile.  */
d987 38
d1035 1
d1037 15
a1051 2
  if (inf_data->objfile != NULL)
    return 0;
d1053 4
a1056 13
  /* Lookup the registration symbol.  If it is missing, then we assume
     we are not attached to a JIT.  */
  reg_symbol = lookup_minimal_symbol_and_objfile (jit_break_name, &objf);
  if (reg_symbol == NULL || SYMBOL_VALUE_ADDRESS (reg_symbol) == 0)
    return 1;

  desc_symbol = lookup_minimal_symbol (jit_descriptor_name, NULL, objf);
  if (desc_symbol == NULL || SYMBOL_VALUE_ADDRESS (desc_symbol) == 0)
    return 1;

  objf_data = get_jit_objfile_data (objf);
  objf_data->register_code = reg_symbol;
  objf_data->descriptor = desc_symbol;
d1058 1
a1058 3
  inf_data->objfile = objf;

  jit_inferior_init (gdbarch);
d1064 8
a1071 1
			paddress (gdbarch, SYMBOL_VALUE_ADDRESS (reg_symbol)));
d1074 2
a1075 1
  create_jit_event_breakpoint (gdbarch, SYMBOL_VALUE_ADDRESS (reg_symbol));
d1487 2
@


1.45
log
@	* symfile.h (obsavestring): Don't declare.
	* symfile.c (obsavestring): Remove.
	* ada-exp.y: Use obstack_copy0, not obsavestring.
	* ada-lang.c: Use obstack_copy0, not obsavestring.
	* coffread.c: Use obstack_copy0, not obsavestring.
	* cp-namespace.c: Use obstack_copy0, not obsavestring.
	* dbxread.c: Use obstack_copy0, not obsavestring.
	* dwarf2read.c: Use obstack_copy0, not obsavestring.
	* jit.c: Use obstack_copy0, not obsavestring.
	* mdebugread.c: Use obstack_copy0, not obsavestring.
	* psymtab.c: Use obstack_copy0, not obsavestring.
	* stabsread.c: Use obstack_copy0, not obsavestring.
	* xcoffread.c: Use obstack_copy0, not obsavestring.
@
text
@d929 1
a929 3
  int i, success;
  const struct bfd_arch_info *b;
  struct jit_inferior_data *inf_data = get_jit_inferior_data ();
a1115 1
  struct jit_inferior_data *inf_data;
a1119 2
  inf_data = get_jit_inferior_data ();

@


1.44
log
@* jit.c (jit_reader_load_command): Interpret the jit reader name as an
  absolute path if it begins with a forward slash.
@
text
@d686 3
a688 3
      block_name->ginfo.name = obsavestring (gdb_block_iter->name,
                                             strlen (gdb_block_iter->name),
                                             &objfile->objfile_obstack);
@


1.43
log
@PR gdb/14550

 * jit.c (finalize_symtab): Ensure that only the global block has a
   NULL superblock.
@
text
@d28 1
d212 4
a215 1
  so_name = xstrprintf ("%s/%s", jit_reader_dir, args);
@


1.42
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d727 12
a738 2
        BLOCK_SUPERBLOCK (gdb_block_iter->real_block) =
          gdb_block_iter->parent->real_block;
@


1.41
log
@rename frame_register_read into deprecated_frame_register_read.

gdb/ChangeLog:

        * frame.h (deprecated_frame_register_read): Renames
        frame_register_read.
        * frame.c (deprecated_frame_register_read): Renames
        frame_register_read.  Update all callers.
        * i386-tdep.c: Update all callers of frame_register_read.
        * infcmd.c: Likewise.
        * jit.c: Likewise.
        * mips-tdep.c: Likewise.
        * mt-tdep.c: Likewise.
        * sh64-tdep.c: Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2009-2012 Free Software Foundation, Inc.
@


1.40
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d1064 2
a1065 2
  value->defined = frame_register_read (priv->this_frame, gdb_reg,
                                        value->value);
@


1.39
log
@	* jit.c (jit_object_close_impl): Don't malloc the objfile
	name.
	* objfiles.c (allocate_objfile): Don't malloc the objfile
	name.
	(free_objfile): Don't free the objfile name.
	* objfiles.h (struct objfile) <name>: Update comment.
	* symfile.c (reread_symbols): Fix reference counting.  Don't
	malloc objfile name.
@
text
@d760 1
a760 1
  objfile->gdbarch = target_gdbarch;
d1293 1
a1293 1
  jit_inferior_init (target_gdbarch);
d1302 1
a1302 1
  jit_breakpoint_re_set_internal (target_gdbarch,
@


1.38
log
@	* auto-load.c (_initialize_auto_load): Update.
	* solib-svr4.c (_initialize_svr4_solib): Update
	* solib-dsbt.c (_initialize_dsbt_solib): Update.
	* solib-darwin.c (_initialize_darwin_solib): Update.
	* registry.h: New file.
	* python/py-progspace.c (gdbpy_initialize_pspace): Update.
	* python/py-inferior.c (gdbpy_initialize_inferior): Update.
	* progspace.h: Include registry.h.  Use DECLARE_REGISTRY.
	(register_program_space_data_with_cleanup)
	(register_program_space_data, program_space_alloc_data)
	(clear_program_space_data, set_program_space_data)
	(program_space_data): Don't declare.
	* progspace.c: Use DEFINE_REGISTRY.
	(struct program_space_data, struct
	program_space_data_registration, struct
	program_space_data_registry, program_space_data_registry)
	(register_program_space_data_with_cleanup)
	(register_program_space_data, program_space_alloc_data)
	(program_space_free_data, clear_program_space_data)
	(set_program_space_data, program_space_data): Remove.
	* objfiles.h: Include registry.h.  Use DECLARE_REGISTRY.
	(struct objfile) <data, num_data>: Replace with REGISTRY_FIELDS.
	(register_objfile_data_with_cleanup, register_objfile_data)
	(clear_objfile_data, set_objfile_data, objfile_data): Don't
	declare.
	* objfiles.c: Use DEFINE_REGISTRY.
	(struct objfile_data, struct objfile_data_registration, struct
	objfile_data_registry, objfile_data_registry)
	(register_objfile_data_with_cleanup, register_objfile_data)
	(objfile_alloc_data, objfile_free_data, clear_objfile_data)
	(set_objfile_data, objfile_data): Remove.
	(_initialize_objfiles): Update.
	* jit.c (_initialize_jit): Update.
	* inflow.c (_initialize_inflow): Update.
	* inferior.h: Include registry.h.  Use DECLARE_REGISTRY.
	(struct inferior) <data, num_data>: Replace with REGISTRY_FIELDS.
	(register_inferior_data_with_cleanup, register_inferior_data)
	(clear_inferior_data, set_inferior_data, inferior_data): Don't
	declare.
	* inferior.c: Use DEFINE_REGISTRY.
	(struct inferior_data, struct inferior_data_registration, struct
	inferior_data_registry, inferior_data_registry)
	(register_inferior_data_with_cleanup, register_inferior_data)
	(inferior_alloc_data, inferior_free_data  clear_inferior_data)
	(set_inferior_data, inferior_data): Remove.
	* auxv.c (_initialize_auxv): Update.
	* ada-lang.c (_initialize_ada_language): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* i386-nat.c (i386_use_watchpoints): Update.
@
text
@d764 1
a764 2
  xfree (objfile->name);
  objfile->name = xstrdup ("<< JIT compiled code >>");
@


1.37
log
@gdb/
	* dwarf2loc.c (entry_values_debug): Add 'unsigned'.
	(_initialize_dwarf2loc): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* dwarf2loc.h: Update the declaration of 'entry_values_debug'.
	* dwarf2read.c (dwarf2_die_debug): Add 'unsigned'.
	(_initialize_dwarf2_read): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* darwin-nat.c (dwarwin_debug_flag): Add 'unsigned'.
	(_initialize_darwin_inferior): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* frame.c (frame_debug): Add 'unsigned'.
	(_intialize_frame): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* frame.h: Update the declaration of 'frame_debug'.
	* gdbtypes.c (overload_debug): Add 'unsigned'.
	(_initialize_gdbtypes): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* inferior.h: Update declaration of 'debug_infrun'.
	* infrun.c (debug_infrun): Add 'unsigned'.
	(_initialize_infrun): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* jit.c (jit_debug): Add 'unsigned'.
	(_initialize_jit): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* linux-nat.c (debug_linux_nat): Add 'unsigned'.
	(_initialize_linux_nat): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* linux-thread-db.c (libthread_db_debug): Add 'unsigned'.
	(_initialize_thread_db): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* machoread.c (mach_o_debug_level): Add 'unsigned'.
	(_initialize_machoread): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* mi/mi-cmd-var.c: Update the declaration of 'varobjdebug'.
	* microblaze-tdep.c (microblaze_debug_flag): Add 'unsigned'.
	(_initialize_microblaze_tdep): Call add_setshow_zuinteger_cmd
	intead of add_setshow_zinteger_cmd.
	* mips-tdep.c (mips_debug): Add 'unsigned'.
	(_initialize_mips_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* monitor.c (monitor_debug): Add 'unsigned'.
	(_initialize_remote_monitors): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* observer.c (observer_debug): Add 'unsigned'.
	(_initialize_observer): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* parse.c (expressiondebug): Add 'unsigned'.
	(_initialize_parse): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.c (record_debug): Add 'unsigned'.
	(_initialize_record): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.h: Update the declaration of 'record_debug'.
	* stap-probe.c (stap_expression_debug): Add 'unsigned'.
	(_initialize_stap_probe): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* serial.c (global_serial_debug_p): Add 'unsigned'.
	(_initialize_serial): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-dsbt.c (solib_dsbt_debug): Add 'unsigned'.
	(_initialize_dsbt_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-frv.c (solib_frv_debug): Add 'unsigned'.
	(_initialize_frv_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* target.c (targetdebug): Add 'unsigned'.
	(initialize_targets): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* valops.c (overload_debug): Add 'unsigned'.
	* varobj.c (varobjdebug): Add 'unsigned'.
	(_initialize_varobj): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* xtensa-tdep.c (xtensa_debug_level): Add 'unsigned'.
	(_initialize_xtensa_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.

	* arch-utils.h: Remove the declaration of 'gdbarch_debug'.
	* gdbarch.sh (gdbarch_debug): Add 'unsigned'.
	(extern void _initialize_gdbarch): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* gdbarch.c, gdbarch.h: Re-generated.
@
text
@d1417 1
a1417 1
    register_inferior_data_with_cleanup (jit_inferior_data_cleanup);
@


1.36
log
@	* coffread.c (coff_symfile_read): Make a cleanup for 'debugfile'
	and 'abfd'.
	* elfread.c (elf_symfile_read): Make a cleanup for 'debugfile'
	and 'abfd'.
	* jit.c (jit_bfd_try_read_symtab): Make a cleanup for 'nbfd'.
	* machoread.c (macho_add_oso_symfile): Make a cleanup for
	'abfd'.
	(macho_symfile_read): Make a cleanup for 'dsym_bfd'.
	* objfiles.c (allocate_objfile): Acquire a new reference.
	* rs6000-nat.c (add_vmap): Don't acquire a BFD reference.
	* solib.c (solib_read_symbols): Don't acquire a BFD reference.
	* spu-linux-nat.c (spu_symbol_file_add_from_memory): Make
	a cleanup for 'nbfd'.
	* symfile-mem.c (symbol_file_add_from_memory): Make a cleanup
	for 'nbfd'.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Don't
	make a cleanup for 'abfd'.
	(symbol_file_add): Make a BFD cleanup.
@
text
@d63 1
a63 1
static int jit_debug = 0;
d1405 7
a1411 7
  add_setshow_zinteger_cmd ("jit", class_maintenance, &jit_debug,
			    _("Set JIT debugging."),
			    _("Show JIT debugging."),
			    _("When non-zero, JIT debugging is enabled."),
			    NULL,
			    show_jit_debug,
			    &setdebuglist, &showdebuglist);
@


1.35
log
@	* cli/cli-dump.c (bfd_openr_with_cleanup): Use gdb_bfd_openr.
	(bfd_openw_with_cleanup): Use gdb_bfd_openw.
	* corelow.c (core_open): Use gdb_bfd_fopen.
	* dsrec.c (load_srec): Use gdb_bfd_openr.
	* exec.c (exec_file_attach): Use gdb_bfd_fopen.
	* gcore.c (gcore_memory_sections): Use gdb_bfd_openw.
	* gdb_bfd.c (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): New functions.
	* gdb_bfd.h (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): Declare.
	* jit.c (bfd_open_from_target_memory): Use gdb_bfd_openr_iovec.
	* m32-rom.c (m32r_load, m32r_upload_command): Use gdb_bfd_openr.
	* machoread.c (macho_symfile_read_all_oso): Use gdb_bfd_openr,
	gdb_bfd_openr_next_archived_file.
	(macho_check_dsym): Use gdb_bfd_openr.
	(macho_add_oso_symfile): Don't call gdb_bfd_stash_filename.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_fdopenr.
	* remote-m32r-sdi.c (m32r_load): Use gdb_bfd_openr.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Use
	gdb_bfd_openr.
	* remote.c (remote_bfd_open): Use gdb_bfd_openr_iovec.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_openr, gdb_bfd_fdopenr,
	gdb_bfd_openr_next_archived_file.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use gdb_bfd_openr.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use
	gdb_bfd_openr.
	* solib-spu.c (spu_bfd_fopen): Use gdb_bfd_openr_iovec.
	* solib.c (solib_bfd_fopen): Use gdb_bfd_fopen.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_openr_iovec.
	* symfile.c (bfd_open_maybe_remote): Use gdb_bfd_openr.
	(symfile_bfd_open): Use gdb_bfd_fopen.
	(generic_load): Use gdb_bfd_openr.
	* windows-nat.c (windows_make_so): Use gdb_bfd_openr.
@
text
@d899 2
a900 1
  /* This call takes ownership of NBFD.  It does not take ownership of SAI.  */
@


1.34
log
@	* bfd-target.c (target_bfd_reopen): Update.
	* cli/cli-dump.c (bfd_openr_with_cleanup)
	(bfd_openw_with_cleanup): Update.
	* corelow.c (core_open): Update.
	* dsrec.c (load_srec): Update.
	* exec.c (exec_file_attach): Update.
	* gcore.c (create_gcore_bfd): Update.
	* gdb_bfd.c (gdb_bfd_ref): Return void.
	(gdb_bfd_open): Update.
	* gdb_bfd.h (gdb_bfd_ref): Return void.
	Update comments.
	* jit.c (jit_bfd_try_read_symtab): Update.
	* m32r-rom.c (m32r_load, m32r_upload_command): Update.
	* machoread.c (macho_symfile_read_all_oso): Update.
	(macho_check_dsym): Update.
	* procfs.c (insert_dbx_link_bpt_in_file): Update.
	* remote-m32r-sdi.c (m32r_load): Update.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Update.
	* rs6000-nat.c (add_vmap): Update.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-spu.c (spu_bfd_open): Update.
	* solib.c (solib_bfd_fopen, solib_read_symbols): Update.
	* spu-linux-nat.c (spu_bfd_open): Update.
	* symfile.c (bfd_open_maybe_remote, symfile_bfd_open)
	(generic_load): Update.
	* windows-nat.c (windows_make_so): Update.
@
text
@d140 6
a145 6
  return bfd_openr_iovec ("<in-memory>", target,
                          mem_bfd_iovec_open,
                          buffer,
                          mem_bfd_iovec_pread,
                          mem_bfd_iovec_close,
                          mem_bfd_iovec_stat);
a863 1
  gdb_bfd_ref (nbfd);
@


1.33
log
@	* symfile.c (symfile_bfd_open): Don't copy name.  Call
	gdb_bfd_stash_filename.
	(load_command): Open the new BFD before freeing the old.
	(bfd_open_maybe_remote): Call gdb_bfd_stash_filename.
	* symfile-mem.c (symbol_file_add_from_memory): Don't copy name.
	Call gdb_bfd_stash_filename.
	* spu-linux-nat.c (spu_bfd_open): Don't copy name.
	* solib-spu.c (spu_bfd_fopen): Don't copy name.  Call
	gdb_bfd_stash_filename.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Free found_pathname.
	* rs6000-nat.c (add_vmap): Don't copy filename.  Call
	gdb_bfd_stash_filename.
	* remote.c (remote_bfd_open): Call gdb_bfd_stash_filename.
	* machoread.c (macho_add_oso_symfile): Call
	gdb_bfd_stash_filename.
	(macho_symfile_read_all_oso): Arrange to free archive_name.  Call
	gdb_bfd_stash_filename.
	(macho_check_dsym): Don't copy filename.  Call
	gdb_bfd_stash_filename.
	* jit.c (bfd_open_from_target_memory): Don't copy the filename.
	* gdb_bfd.c (gdb_bfd_stash_filename): New function.
	* gdb_bfd.h (gdb_bfd_stash_filename): Declare.
	* gcore.c (create_gcore_bfd): Call gdb_bfd_stash_filename.
	* exec.c (exec_close): Don't free the BFD's filename.
	(exec_file_attach): Don't copy the filename.  Call
	gdb_bfd_stash_filename.
	* corelow.c (core_close): Don't free the BFD's filename.
	(core_open): Call gdb_bfd_stash_filename.
	* corefile.c (reopen_exec_file): Remove #if 0 code.
	* solib.c (solib_bfd_fopen): Call gdb_bfd_stash_filename.  Free
	pathname.
	* dwarf2read.c (try_open_dwo_file): Call gdb_bfd_stash_filename.
@
text
@d864 1
a864 1
  nbfd = gdb_bfd_ref (nbfd);
@


1.32
log
@	* dwarf2read.c (try_open_dwo_file): Use gdb_bfd_ref and
	gdb_bfd_unref.
	(free_dwo_file): Use gdb_bfd_unref.
	* cli/cli-dump.c: Include gdb_bfd.h.
	(bfd_openw_with_cleanup): Use gdb_bfd_ref.
	(bfd_openr_with_cleanup): Likewise.
	* windows-nat.c (windows_make_so): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* utils.c: Include gdb_bfd.h.
	(do_bfd_close_cleanup): Use gdb_bfd_unref.
	* symfile.c: Include gdb_bfd.h.
	(separate_debug_file_exists): Use gdb_bfd_unref.
	(bfd_open_maybe_remote): Use gdb_bfd_ref.
	(symfile_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	(generic_load): Use gdb_bfd_ref.
	(reread_symbols): Use gdb_bfd_unref.
	* symfile-mem.c: Include gdb_bfd.h.
	(symbol_file_add_from_memory): Use make_cleanup_bfd_close.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib.c: Include gdb_bfd.h.
	(solib_bfd_fopen): Use gdb_bfd_ref.
	(solib_bfd_open): Use gdb_bfd_unref.
	(free_so_symbols): Use gdb_bfd_unref.
	(reload_shared_libraries_1): Use gdb_bfd_unref.
	* solib-spu.c: Include gdb_bfd.h.
	(spu_bfd_fopen): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* solib-frv.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-dsbt.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-darwin.c: Include gdb_bfd.h.
	(darwin_solib_get_all_image_info_addr_at_init): Use gdb_bfd_ref,
	gdb_bfd_unref.
	(darwin_bfd_open): Use gdb_bfd_unref.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_ref, gdb_bfd_unref.
	* remote-mips.c: Include gdb_bfd.h.
	(mips_load_srec): Use gdb_bfd_ref.
	(pmon_load_fast): Use gdb_bfd_ref.
	* remote-m32r-sdi.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	* record.c: Include gdb_bfd.h.
	(record_save_cleanups): Use gdb_bfd_unref.
	(cmd_record_save): Use gdb_bfd_unref.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* objfiles.h (gdb_bfd_close_or_warn): Remove.
	(gdb_bfd_ref, gdb_bfd_unref): Move to gdb_bfd.h.
	* objfiles.c: Include gdb_bfd.h.
	(free_objfile): Use gdb_bfd_unref.
	(gdb_bfd_close_or_warn, gdb_bfd_ref, gdb_bfd_unref): Move to
	gdb_bfd.c.
	* machoread.c (macho_add_oso_symfile): Use gdb_bfd_unref.
	(macho_symfile_read_all_oso): Use gdb_bfd_ref, gdb_bfd_unref.
	(macho_check_dsym): Likewise.
	* m32r-rom.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	(m32r_upload_command): Use gdb_bfd_ref.
	* jit.c: Include gdb_bfd.h.
	(jit_bfd_try_read_symtab): Use gdb_bfd_ref, gdb_bfd_unref.
	* gdb_bfd.h: New file.
	* gdb_bfd.c: New file.
	* gcore.c: Include gdb_bfd.h.
	(create_gcore_bfd): Use gdb_bfd_ref.
	(do_bfd_delete_cleanup): Use gdb_bfd_unref.
	(gcore_command): Use gdb_bfd_unref.
	* exec.c: Include gdb_bfd.h.
	(exec_close): Use gdb_bfd_unref.
	(exec_close_1): Use gdb_bfd_unref.
	(exec_file_attach): Use gdb_bfd_ref.
	* elfread.c: Include gdb_bfd.h.
	(build_id_verify): Use gdb_bfd_unref.
	* dsrec.c: Include gdb_bfd.h.
	(load_srec): Use gdb_bfd_ref.
	* corelow.c: Include gdb_bfd.h.
	(core_close): Use gdb_bfd_unref.
	(core_open): Use gdb_bfd_ref.
	* bfd-target.c: Include gdb_bfd.h.
	(target_bfd_xclose): Use gdb_bfd_unref.
	(target_bfd_reopen): Use gdb_bfd_ref.
	* Makefile.in (SFILES): Add gdb_bfd.c.
	(HFILES_NO_SRCDIR): Add gdb_bfd.h.
	(COMMON_OBS): Add gdb_bfd.o.
@
text
@a135 1
  const char *filename = xstrdup ("<in-memory>");
d140 1
a140 1
  return bfd_openr_iovec (filename, target,
@


1.31
log
@2012-06-13  Kaushik Srenevasan  <kaushik@@twitter.com>

	* jit.c (finalize_symtab): Set function's return type to 'void' by
	default.
@
text
@d41 1
d865 1
d873 1
a873 1
      bfd_close (nbfd);
@


1.30
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d663 4
d679 1
@


1.29
log
@	* jv-lang.c (get_java_class_symtab): Use allocate_global_block,
	set_block_symtab.
	* jit.c (finalize_symtab): Use allocate_global_block,
	set_block_symtab.
	* buildsym.c (finish_block_internal): New function, from old
	finish_block.
	(finish_block): Rewrite.
	(end_symtab): Use finish_block_internal, set_block_symtab.
	* block.h (struct global_block): New.
	(allocate_global_block, set_block_symtab): Declare.
	* block.c (allocate_global_block, set_block_symtab): New
	functions.
@
text
@a202 1
  int len;
a281 1
  CORE_ADDR *entry_addr_ptr;
a781 1
  struct jit_dbg_reader *i;
a941 1
  CORE_ADDR *objf_entry_addr;
a1100 1
  struct jit_dbg_reader *iter;
a1241 1
  struct jit_objfile_data *objf_data;
@


1.28
log
@	* jit.c (jit_read_code_entry): Compute alignment and offset of
	int64_t member before computing entry_size.
@
text
@d698 5
a702 1
      struct block *new_block = allocate_block (&objfile->objfile_obstack);
d712 3
@


1.27
log
@	PR gdb/13431:
	* jit.c (struct jit_inferior_data): Rewrite.
	(struct jit_objfile_data): New.
	(get_jit_objfile_data): New function.
	(add_objfile_entry): Update.
	(jit_read_descriptor): Return int.  Replace descriptor_addr
	argument with inf_data.  Update.  Don't call error.
	(jit_breakpoint_re_set_internal): Reorder logic.  Update.  Look up
	descriptor here.
	(jit_inferior_init): Don't look up descriptor.  Don't call error.
	(jit_reset_inferior_data_and_breakpoints)
	(jit_inferior_created_observer): Remove.
	(jit_inferior_exit_hook): Update.
	(jit_executable_changed_observer): Remove.
	(jit_event_handler): Update.
	(free_objfile_data): Reset inferior data if needed.
	(_initialize_jit): Update.
gdb/testsuite
	* gdb.base/jit-simple.exp: New file.
	* gdb.base/jit-simple.c: New file.
@
text
@d387 7
a393 1
  entry_size = 3 * ptr_size + 8;  /* Three pointers and one 64-bit int.  */
a407 5

  align_bytes = gdbarch_long_long_align_bit (gdbarch) / 8;
  off = 3 * ptr_size;
  off = (off + (align_bytes - 1)) & ~(align_bytes - 1);

@


1.26
log
@	* jit.c (bfd_open_from_target_memory): Move higher in file.
@
text
@d234 2
a235 1
/* Per-inferior structure recording the addresses in the inferior.  */
d239 18
a256 2
  CORE_ADDR breakpoint_addr;  /* &__jit_debug_register_code()  */
  CORE_ADDR descriptor_addr;  /* &__jit_debug_descriptor  */
d259 18
d284 1
d286 2
a287 3
  entry_addr_ptr = xmalloc (sizeof (CORE_ADDR));
  *entry_addr_ptr = entry;
  set_objfile_data (objfile, jit_objfile_data, entry_addr_ptr);
d317 1
a317 1
   memory.  */
d319 1
a319 1
static void
d322 1
a322 1
		     CORE_ADDR descriptor_addr)
d330 12
d350 2
a351 1
  err = target_read_memory (descriptor_addr, desc_buf, desc_size);
d353 5
a357 1
    error (_("Unable to read JIT descriptor from remote memory!"));
d366 2
d941 4
a944 2
      objf_entry_addr = (CORE_ADDR *) objfile_data (objf, jit_objfile_data);
      if (objf_entry_addr != NULL && *objf_entry_addr == entry_addr)
d957 3
a959 3
  if (inf_data->breakpoint_addr == 0)
    {
      struct minimal_symbol *reg_symbol;
d961 1
a961 15
      /* Lookup the registration symbol.  If it is missing, then we assume
	 we are not attached to a JIT.  */
      reg_symbol = lookup_minimal_symbol (jit_break_name, NULL, NULL);
      if (reg_symbol == NULL)
	return 1;
      inf_data->breakpoint_addr = SYMBOL_VALUE_ADDRESS (reg_symbol);
      if (inf_data->breakpoint_addr == 0)
	return 2;

      /* If we have not read the jit descriptor yet (e.g. because the JITer
	 itself is in a shared library which just got loaded), do so now.  */
      if (inf_data->descriptor_addr == 0)
	jit_inferior_init (gdbarch);
    }
  else
d964 18
d986 1
a986 1
			paddress (gdbarch, inf_data->breakpoint_addr));
d989 1
a989 1
  create_jit_event_breakpoint (gdbarch, inf_data->breakpoint_addr);
d1239 1
a1249 20
  if (inf_data->descriptor_addr == 0)
    {
      struct minimal_symbol *desc_symbol;

      /* Lookup the descriptor symbol and cache the addr.  If it is
	 missing, we assume we are not attached to a JIT and return early.  */
      desc_symbol = lookup_minimal_symbol (jit_descriptor_name, NULL, NULL);
      if (desc_symbol == NULL)
	return;

      inf_data->descriptor_addr = SYMBOL_VALUE_ADDRESS (desc_symbol);
      if (inf_data->descriptor_addr == 0)
	return;
    }

  if (jit_debug)
    fprintf_unfiltered (gdb_stdlog,
			"jit_inferior_init, descriptor_addr = %s\n",
			paddress (gdbarch, inf_data->descriptor_addr));

d1252 2
a1253 1
  jit_read_descriptor (gdbarch, &descriptor, inf_data->descriptor_addr);
d1257 6
a1262 1
    error (_("Unsupported JIT protocol version in descriptor!"));
a1298 27
/* Reset inferior_data, so sybols will be looked up again, and jit_breakpoint
   will be reset.  */

static void
jit_reset_inferior_data_and_breakpoints (void)
{
  struct jit_inferior_data *inf_data;

  /* Force jit_inferior_init to re-lookup of jit symbol addresses.  */
  inf_data = get_jit_inferior_data ();
  inf_data->breakpoint_addr = 0;
  inf_data->descriptor_addr = 0;

  /* Remove any existing JIT breakpoint(s).  */
  remove_jit_event_breakpoints ();

  jit_inferior_init (target_gdbarch);
}

/* Wrapper to match the observer function pointer prototype.  */

static void
jit_inferior_created_observer (struct target_ops *objfile, int from_tty)
{
  jit_reset_inferior_data_and_breakpoints ();
}

d1310 3
a1312 3
    if (objfile_data (objf, jit_objfile_data) != NULL)
      jit_unregister_code (objf);
}
d1314 3
a1316 4
static void
jit_executable_changed_observer (void)
{
  jit_reset_inferior_data_and_breakpoints ();
d1328 2
a1329 2
  jit_read_descriptor (gdbarch, &descriptor,
		       get_jit_inferior_data ()->descriptor_addr);
d1362 10
a1404 1
  observer_attach_inferior_created (jit_inferior_created_observer);
a1405 1
  observer_attach_executable_changed (jit_executable_changed_observer);
@


1.25
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d130 18
a233 18
/* Open a BFD from the target's memory.  */

static struct bfd *
bfd_open_from_target_memory (CORE_ADDR addr, ULONGEST size, char *target)
{
  const char *filename = xstrdup ("<in-memory>");
  struct target_buffer *buffer = xmalloc (sizeof (struct target_buffer));

  buffer->base = addr;
  buffer->size = size;
  return bfd_openr_iovec (filename, target,
                          mem_bfd_iovec_open,
                          buffer,
                          mem_bfd_iovec_pread,
                          mem_bfd_iovec_close,
                          mem_bfd_iovec_stat);
}

@


1.24
log
@	* hppa-hpux-tdep.c (hppa64_hpux_search_dummy_call_sequence): Use
	ALL_OBJFILE_MSYMBOLS.
	(hppa_hpux_find_dummy_bpaddr): Likewise.
	* jit.c (jit_object_close_impl): Use
	terminate_minimal_symbol_table.
@
text
@d3 1
a3 1
   Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.23
log
@gdb/

	* jit.c (add_objfile_entry, jit_reader_try_read_symtab)
	(jit_bfd_try_read_symtab): Fix comments.
@
text
@d697 1
a697 3
  objfile->msymbols = obstack_alloc (&objfile->objfile_obstack,
                                     sizeof (struct minimal_symbol));
  memset (objfile->msymbols, 0, sizeof (struct minimal_symbol));
@


1.23.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright (C) 2009-2012 Free Software Foundation, Inc.
@


1.22
log
@gdb/

	Fix regression in jit.exp.
	* jit.c (jit_reader_try_read_symtab, jit_bfd_try_read_symtab)
	(jit_register_code): Set the jit_objfile_data field to the correct
	value.
@
text
@d242 2
a243 1
/* Remember a mapping from entry_addr to objfile.  */
d715 2
a716 2
   ENTRY_ADDR is the address of the object file (in the target's
   address space) being read.  */
d773 1
a773 1
   object file (in the target's address space) being read.  */
@


1.21
log
@gdb/
	* jit.c: Include regcache.h.
	(jit_gdbarch_data, jit_frame_unwind): New static variables.
	(jit_unwind_reg_set_impl, free_reg_value_impl)
	(jit_unwind_reg_get_impl, jit_frame_sniffer)
	(jit_frame_unwind_stop_reason, jit_frame_this_id)
	(jit_frame_prev_register, jit_dealloc_cache)
	(jit_prepend_unwinder, jit_gdbarch_data_init): New functions.
	(jit_inferior_init): Prepend (new) pseudo unwinder by calling
	jit_prepend_unwinder.
	(_initialize_jit): Register new gdbarch data jit_gdbarch_data.
@
text
@d713 3
a715 1
/* Try to read CODE_ENTRY using the loaded jit reader (if any).  */
d718 2
a719 1
jit_reader_try_read_symtab (struct jit_code_entry *code_entry)
d741 1
a741 1
  priv_data = code_entry->symfile_addr;
d771 2
a772 1
/* Try to read CODE_ENTRY using BFD.  */
d776 1
d840 1
a840 1
  add_objfile_entry (objfile, code_entry->symfile_addr);
d863 1
a863 1
  success = jit_reader_try_read_symtab (code_entry);
d866 1
a866 1
    jit_bfd_try_read_symtab (code_entry, gdbarch);
@


1.20
log
@gdb/
	* jit.c: Include block.h, dictionary.h and frame-unwind.h.
	(add_objfile_entry, jit_target_read_impl, jit_object_open_impl)
	(jit_symtab_open_impl, compare_block, jit_block_open_impl)
	(jit_symtab_line_mapping_add_impl, jit_symtab_close_impl)
	(finalize_symtab, jit_object_close_impl)
	(jit_reader_try_read_symtab, jit_bfd_try_read_symtab)
	(free_objfile_data): New functions.
	(_initialize_jit): Register jit_objfile_data with a proper cleanup
	function.
@
text
@d34 1
d54 6
d930 236
d1179 2
d1342 13
d1379 1
@


1.19
log
@gdb/
	* jit.c: Include gdb-dlfcn.h.
	(loaded_jit_reader, reader_init_fn_sym): New static variables.
	(jit_reader_load, jit_reader_load_command)
	(jit_reader_unload_command): New functions.
	(_initialize_jit): Add commands "jit-reader-load" and
	"jit-reader-unload".
@
text
@d24 1
d27 2
d39 1
d235 12
d349 413
a761 4
/* This function registers code associated with a JIT code entry.  It uses the
   pointer and size pair in the entry to read the symbol file from the remote
   and then calls symbol_file_add_from_local_memory to add it as though it were
   a symbol file added by the user.  */
d764 2
a765 2
jit_register_code (struct gdbarch *gdbarch,
		   CORE_ADDR entry_addr, struct jit_code_entry *code_entry)
a773 1
  CORE_ADDR *entry_addr_ptr;
d827 25
a851 4
  /* Remember a mapping from entry_addr to objfile.  */
  entry_addr_ptr = xmalloc (sizeof (CORE_ADDR));
  *entry_addr_ptr = entry_addr;
  set_objfile_data (objfile, jit_objfile_data, entry_addr_ptr);
d853 2
a854 1
  do_cleanups (old_cleanups);
d1089 8
d1117 2
a1118 1
  jit_objfile_data = register_objfile_data ();
@


1.18
log
@gdb/
	* config.in: Add new #defines: JIT_READER_DIR and
	JIT_READER_DIR_RELOCATABLE.
	* configure.ac: New GDB directory entry for jit-reader-dir.
	* configure: Re-generated by autoconf.
	* jit.c: New static variable: const char *jit_reader_dir.
	(_initialize_jit): Relocate jit_reader_dir.
@
text
@d34 1
d119 86
d666 13
@


1.17
log
@gdb/
	* Makefile.in: Add jit-reader.h as a header.  Have it installed in
	$(includedir)/gdb.
	* configure.ac: Generate a correct value for TARGET_PTR for
	jit-reader.h.  Tell configure to generate jit-reader.h from
	jit-reader.in.
	* configure: Re-generated by autoconf.
	* jit-reader.in: New file.
	* jit.c: Include jit-reader.h.
@
text
@d36 2
d563 2
@


1.16
log
@gdb/
	PR symtab/13208
	* jit.c (jit_register_code): Remove unused variable my_cleanups.  Check
	for NULL from bfd_open_from_target_memory.  Fix ownership of NBFD and
	SAI.
@
text
@d23 1
@


1.15
log
@Fix jit.exp on most 32-bit targets.

	* gdbarch.sh: New field 'long_long_align_bit'.
	* gdbarch.c, gdbarch.h: Regenerate.
	* i386-tdep.c (i386_gdbarch_init): Set long_long_align_bit to 32.
	* jit.c (jit_read_code_entry): Use it to determine correct size offset.
@
text
@d256 1
a256 1
  struct cleanup *old_cleanups, *my_cleanups;
d270 5
a274 1
  old_cleanups = make_cleanup_bfd_close (nbfd);
d282 1
a282 1
      do_cleanups (old_cleanups);
d297 1
a297 1
  make_cleanup_free_section_addr_info (sai);
d310 1
a310 1
  /* This call takes ownership of sai.  */
d318 1
a318 1
  discard_cleanups (old_cleanups);
@


1.14
log
@Minor forward declaration reformatting (jit.c)

gdb/ChangeLog:

 	* jit.c (jit_inferior_init): Reformat forward declaration.
@
text
@d208 1
a208 1
  int err;
d212 1
d234 5
d240 1
a240 1
      extract_unsigned_integer (&entry_buf[3 * ptr_size], 8, byte_order);
@


1.13
log
@Fix JIT clang-lli regression (unable to read JIT descriptor from memory)

2011-07-06  Paul Pluzhnikov  <ppluzhnikov@@google.com>

        * jit.c (jit_inferior_init): Forward declare.
        (jit_breakpoint_re_set_internal): Call jit_inferior_init.

testsuite/ChangeLog:

2011-07-06  Paul Pluzhnikov  <ppluzhnikov@@google.com>

        * gdb.base/jit-so.exp: New test.
        * gdb.base/jit-dlmain.c: New file.
        * gdb.base/jit-main.c: Allow "main" to be elsewhere.
@
text
@d43 1
a43 2
static void
jit_inferior_init (struct gdbarch *gdbarch);
@


1.12
log
@bfd/
	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Do not check for
	SEC_LOAD.

gdb/
	Fix convert_code_addr_to_desc_addr for ppc64 files after eu-strip.
	* elfread.c (elf_symfile_read): New variable synth_abfd, pass it to
	bfd_get_synthetic_symtab.
	* jit.c (jit_register_code): Pass NULL to the new parameter parent.
	* machoread.c (macho_add_oso_symfile): Pass main_objfile to the new
	parameter parent, remove the call to add_separate_debug_objfile.
	* solib.c (solib_read_symbols): Pass NULL to the new parameter parent.
	* symfile-mem.c (symbol_file_add_from_memory): Likewise.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): New parameter
	parent, new comment for it, call add_separate_debug_objfile for it.
	(symbol_file_add_separate): Pass objfile as the parameter parent,
	remove the call to add_separate_debug_objfile.
	(symbol_file_add_from_bfd): New parameter parent, pass it.
	(symbol_file_add): Pass NULL to the new parameter parent.
	* symfile.h (symbol_file_add_from_bfd): New parameter parent.

gdb/testsuite/
	* gdb.base/eu-strip-infcall.c: New file.
	* gdb.base/eu-strip-infcall.exp: New file.
@
text
@d43 3
d357 5
@


1.11
log
@2011-01-31  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* breakpoint.h (remove_jit_event_breakpoints): New prototype.
	* breakpoint.c (remove_jit_event_breakpoints): New function.
	* jit.c (jit_descriptor_addr): Delete.
	(registering_code): Delete.
	(clear_int): Delete.
	(jit_inferior_data): New variable.
	(struct jit_inferior_data): New type.
	(get_jit_inferior_data): New function.
	(jit_inferior_data_cleanup): New function.
	(jit_read_descriptor): Adjust.
	(jit_register_code): Adjust.
	(jit_breakpoint_re_set_internal): New function; move code here ...
	(jit_inferior_init): ... from here.
	(jit_breakpoint_re_set): Adjust.
	(jit_reset_inferior_data_and_breakpoints): New function.
	(jit_inferior_created_observer): Adjust.
	(jit_inferior_exit_hook): Adjust.
	(jit_executable_changed_observer): New function.
	(jit_event_handler): Adjust.
	(_initialize_jit): Adjust.
@
text
@d299 1
a299 1
  objfile = symbol_file_add_from_bfd (nbfd, 0, sai, OBJF_SHARED);
@


1.11.2.1
log
@Fix JIT clang-lli regression (unable to read JIT descriptor from memory)

2011-07-06  Paul Pluzhnikov  <ppluzhnikov@@google.com>

        * jit.c (jit_inferior_init): Forward declare.
        (jit_breakpoint_re_set_internal): Call jit_inferior_init.

testsuite/ChangeLog:

2011-07-06  Paul Pluzhnikov  <ppluzhnikov@@google.com>

        * gdb.base/jit-so.exp: New test.
        * gdb.base/jit-dlmain.c: New file.
        * gdb.base/jit-main.c: Allow "main" to be elsewhere.
@
text
@a42 3
static void
jit_inferior_init (struct gdbarch *gdbarch);

a353 5

      /* If we have not read the jit descriptor yet (e.g. because the JITer
	 itself is in a shared library which just got loaded), do so now.  */
      if (inf_data->descriptor_addr == 0)
	jit_inferior_init (gdbarch);
@


1.10
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* h8300-tdep.c: Comment cleanup, mostly periods and spaces.
	* hppa-hpux-tdep.c: Ditto.
	* hppa-linux-nat.c: Ditto.
	* hppa-linux-tdep.c: Ditto.
	* hppanbsd-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* hppa-tdep.h: Ditto.
	* hpux-thread.c: Ditto.
	* i386-cygwin-tdep.c: Ditto.
	* i386-darwin-nat.c: Ditto.
	* i386gnu-nat.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* i386-linux-tdep.c: Ditto.
	* i386-nat.c: Ditto.
	* i386-nat.h: Ditto.
	* i386nbsd-tdep.c: Ditto.
	* i386-sol2-nat.c: Ditto.
	* i386-stub.c: Ditto.
	* i386-tdep.c: Ditto.
	* i386-tdep.h: Ditto.
	* i387-tdep.c: Ditto.
	* ia64-linux-nat.c: Ditto.
	* ia64-linux-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* infcall.c: Ditto.
	* infcall.h: Ditto.
	* infcmd.c: Ditto.
	* inferior.c: Ditto.
	* inferior.h: Ditto.
	* infloop.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* interps.c: Ditto.
	* interps.h: Ditto.
	* iq2000-tdep.c: Ditto.
	* irix5-nat.c: Ditto.
	* jit.c: Ditto.
	* jit.h: Ditto.
	* jv-exp.y: Ditto.
	* jv-lang.c: Ditto.
	* jv-lang.h: Ditto.
	* jv-typeprint.c: Ditto.
	* jv-valprint.c: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* linespec.c: Ditto.
	* linux-fork.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-thread-db.c: Ditto.
	* lm32-tdep.c: Ditto.
@
text
@d27 1
d41 1
a41 12
/* This is the address of the JIT descriptor in the inferior.  */

static CORE_ADDR jit_descriptor_addr = 0;

/* This is a boolean indicating whether we're currently registering code.  This
   is used to avoid re-entering the registration code.  We want to check for
   new JITed every time a new object file is loaded, but we want to avoid
   checking for new code while we're registering object files for JITed code.
   Therefore, we flip this variable to 1 before registering new object files,
   and set it to 0 before returning.  */

static int registering_code = 0;
a53 8
/* Helper cleanup function to clear an integer flag like the one above.  */

static void
clear_int (void *int_addr)
{
  *((int *) int_addr) = 0;
}

d131 34
d170 2
a171 1
		     struct jit_descriptor *descriptor)
d187 1
a187 1
  err = target_read_memory (jit_descriptor_addr, desc_buf, desc_size);
a297 5
  /* Raise this flag while we register code so we won't trigger any
     re-registration.  */
  registering_code = 1;
  my_cleanups = make_cleanup (clear_int, &registering_code);

a300 3
  /* Clear the registering_code flag.  */
  do_cleanups (my_cleanups);

d335 36
a370 2
/* (Re-)Initialize the jit breakpoint handler, and register any already
   created translations.  */
a374 3
  struct minimal_symbol *reg_symbol;
  struct minimal_symbol *desc_symbol;
  CORE_ADDR reg_addr;
d377 1
d381 1
a381 3
    fprintf_unfiltered (gdb_stdlog,
			"jit_inferior_init, registering_code = %d\n",
			registering_code);
d383 2
a384 4
  /* When we register code, GDB resets its breakpoints in case symbols have
     changed.  That in turn calls this handler, which makes us look for new
     code again.  To avoid being re-entered, we check this flag.  */
  if (registering_code)
d387 3
a389 8
  /* Lookup the registration symbol.  If it is missing, then we assume we are
     not attached to a JIT.  */
  reg_symbol = lookup_minimal_symbol (jit_break_name, NULL, NULL);
  if (reg_symbol == NULL)
    return;
  reg_addr = SYMBOL_VALUE_ADDRESS (reg_symbol);
  if (reg_addr == 0)
    return;
d391 10
a400 12
  if (jit_debug)
    fprintf_unfiltered (gdb_stdlog, "jit_inferior_init, reg_addr = %s\n",
			paddress (gdbarch, reg_addr));

  /* Lookup the descriptor symbol and cache the addr.  If it is missing, we
     assume we are not attached to a JIT and return early.  */
  desc_symbol = lookup_minimal_symbol (jit_descriptor_name, NULL, NULL);
  if (desc_symbol == NULL)
    return;
  jit_descriptor_addr = SYMBOL_VALUE_ADDRESS (desc_symbol);
  if (jit_descriptor_addr == 0)
    return;
d404 2
a405 2
			"jit_inferior_init, jit_descriptor_addr = %s\n",
			paddress (gdbarch, jit_descriptor_addr));
d409 1
a409 1
  jit_read_descriptor (gdbarch, &descriptor);
a414 3
  /* Put a breakpoint in the registration symbol.  */
  create_jit_event_breakpoint (gdbarch, reg_addr);

d446 20
d474 1
a474 1
  jit_inferior_init (target_gdbarch);
a486 4
  /* We need to reset the descriptor addr so that next time we load up the
     inferior we look for it again.  */
  jit_descriptor_addr = 0;

d492 6
d507 2
a508 1
  jit_read_descriptor (gdbarch, &descriptor);
d553 1
d555 2
@


1.9
log
@ChangeLog:
2010-01-06  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* jit.h (struct jit_code_entry): use ULONGEST for symfile_size.
	* jit.c (jit_debug): New variable.
	(show_jit_debug): New function.
	(struct target_buffer): Use ULONGEST.
	(bfd_open_from_target_memory): Likewise.
	(jit_register_code, jit_inferior_init): Add debug output.
	(_initialize_jit): Register "debug jit" command.

doc/ChangeLog:
2010-01-06  Paul Pluzhnikov  <ppluzhnikov@@google.com>

       * gdb.texinfo (Debugging Output): Document "set debug jit".
@
text
@d149 2
a150 1
/* Helper function for reading the global JIT descriptor from remote memory.  */
d300 2
a301 1
/* This function unregisters JITed code and frees the corresponding objfile.  */
d377 2
a378 2
  /* Read the descriptor so we can check the version number and load any already
     JITed functions.  */
d388 2
a389 2
  /* If we've attached to a running program, we need to check the descriptor to
     register any functions that were already generated.  */
d430 3
a432 3
/* This function cleans up any code entries left over when the inferior exits.
   We get left over code when the inferior exits without unregistering its code,
   for example when it crashes.  */
d461 1
a461 1
  /* Do the corresponding action. */
d473 2
a474 1
	printf_unfiltered (_("Unable to find JITed code entry at address: %s\n"),
d493 4
a496 4
  add_setshow_zinteger_cmd ("jit", class_maintenance, &jit_debug, _("\
Set JIT debugging."), _("\
Show JIT debugging."), _("\
When non-zero, JIT debugging is enabled."),
@


1.8
log
@run copyright.sh for 2011.
@
text
@d24 2
d53 11
d75 1
a75 1
  size_t size;
d134 1
a134 1
bfd_open_from_target_memory (CORE_ADDR addr, size_t size, char *target)
d235 7
d337 5
d357 4
d370 5
d490 8
@


1.7
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* xml-support.c (xinclude_start_include): Delete unused variable.
	(xml_process_xincludes): Delete unused variable.
	* xml-syscall.c (syscall_parse_xml): Delete unused variable.
	* target-descriptions.c (tdesc_gdb_type): Delete unused variable.
	(tdesc_find_arch_register): Delete unused variable.
	(tdesc_use_registers): Delete unused variable.
	* xml-tdesc.c (tdesc_start_target): Delete unused variable.
	* inferior.c (print_inferior): Delete unused variable.
	* record.c (record_open_1): Delete unused variable.
	(record_restore): Delete unused variable.
	(cmd_record_save): Delete unused variable.
	* gcore.c (derive_heap_segment): Delete unused variable.
	(objfile_find_memory_regions): Use unused variable.
	* jit.c (jit_inferior_init): Delete unused variable.
	* progspace.c (clone_program_space): Delete unused variable.
	(pspace_empty_p): Delete unused variable.
@
text
@d3 1
a3 1
   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
@


1.6
log
@	Multiexec MI

	* breakpoint.c (clear_syscall_counts): Take struct inferior*.
	* inferior.c (add_inferior_silent): Notify inferior_added
	observer.
	(delete_inferior_1): Notify inferior_removed observer.
	(exit_inferior_1): Pass inferior, not pid, to observer.
	(inferior_appeared): Likewise.
	(add_inferior_with_spaces): New.
	(add_inferior_command): Use the above.
	* inferior.h (delete_inferior_1, add_inferior_with_spaces):
	Declare.

	* inflow.c (inflow_inferior_exit): Likewise.
	* jit.c (jit_inferior_exit_hook): Likewise.

	* mi/mi-cmds.c (mi_cmds): Register add-inferior and
	remove-inferior.
	* mi/mi-cmds.h (mi_cmd_add_inferior, mi_cmd_remove_inferior): New.
	* mi/mi-interp.c (mi_inferior_added, mi_inferior_removed): New.
	(report_initial_inferior): New.
	(mi_inferior_removed): Register the above. Make sure
	inferior_added observer is called on the first inferior.
	(mi_new_thread, mi_thread_exit): Thread group is now identified by
	inferior number, not pid.
	(mi_solib_loaded, mi_solib_unloaded): Report which inferiors are
	affected.
	* mi/mi-main.c (current_context): New.
	(proceed_thread_callback): Use typed closure.
	Proceed everything if pid is 0. Most implementation split into
	(proceed_thread): ... this.
	(run_one_inferior): New.
	(mi_cmd_exec_continue, mi_cmd_exec_interrupt, mi_cmd_exec_run):
	Adjust for multiexec behaviour.
	(mi_cmd_add_inferior, mi_cmd_remove_inferior): New.
	(mi_cmd_execute): Handle the 'thread-group' option here.
	Do some extra checks.
	* mi-parse.c (mi_parse): Handle the --all and --thread-group
	options.
	* mi-parse.h (struct mi_parse): New fields all and thread_group.
@
text
@a315 1
  struct cleanup *old_cleanups;
@


1.5
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d400 1
a400 1
jit_inferior_exit_hook (int pid)
@


1.4
log
@	* xcoffread.c (scan_xcoff_symtab): Update.
	* symfile.h (add_psymbol_to_list): Update prototype.
	* symfile.c (add_psymbol_to_bcache): Add copy_name argument.
	(add_psymbol_to_list): Likewise.
	* stabsread.c (define_symbol): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	(handle_psymbol_enumerators): Update.
	(new_symbol): Update.
	* dbxread.c (read_dbx_symtab): Update.
	* coffread.c (process_coff_symbol): Update.
	* symtab.h (prim_record_minimal_symbol_full): Declare.
	(SYMBOL_SET_NAMES): Add copy_name argument.
	* symtab.c (struct demangled_name_entry): New struct.
	(hash_demangled_name_entry): New function.
	(eq_demangled_name_entry): Likewise.
	(create_demangled_names_hash): Use new functions.
	(symbol_set_names): Use struct demangled_name_entry.  Add
	copy_name argument.
	* minsyms.c (prim_record_minimal_symbol_full): New function.
	(prim_record_minimal_symbol_and_info): Use it.
	* elfread.c (record_minimal_symbol): Add name_len and copy_name
	arguments.  Call prim_record_minimal_symbol_full.
	(elf_symtab_read): Add copy_names argument.
	(elf_symfile_read): Update calls to elf_symtab_read.
	* dwarf2read.c (add_partial_symbol): Don't copy symbol names.
	(load_partial_dies): Likewise.
	(new_symbol): Likewise.
	* cp-namespace.c (check_one_possible_namespace_symbol): Don't save
	name on the obstack.  Update call to SYMBOL_SET_NAMES.
@
text
@d3 1
a3 2
   Copyright (C) 2009
   Free Software Foundation, Inc.
@


1.3
log
@	* jit.c (jit_event_handler): Use paddress to print target addresses.
	Wrap printf string in _().
@
text
@d256 1
a256 1
        sai->other[i].name = (char *) bfd_get_section_name (nbfd, sec);
@


1.2
log
@	* jit.c (jit_read_descriptor): New arg gdbarch, all callers updated.
	(jit_read_code_entry, jit_register_code): Ditto.
	(jit_event_handler): Ditto.
	(jit_inferior_init): Renamed from previous jit_inferior_created_hook.
	(jit_inferior_created_hook, jit_breakpoint_re_set): New functions.
	(jit_inferior_created_observer): Renamed from
	jit_inferior_created_hook1, all callers updated.
	* jit.h (jit_breakpoint_re_set): Declare.
	(jit_event_handler): Update prototype.
	* breakpoint.c (breakpoint_re_set): Call jit_breakpoint_re_set instead
	of jit_inferior_created_hook.
@
text
@d439 2
a440 2
        printf_unfiltered ("Unable to find JITed code entry at address: %p\n",
                           (void *) entry_addr);
@


1.1
log
@	Add interface for JIT code generation.
	* NEWS: Announce JIT interface.
	* Makefile.in (SFILES): Add jit.c.
	(HFILES_NO_SRCDIR): Add jit.h.
	(COMMON_OBS): Add jit.o.
	* jit.c: New file.
	* jit.h: New file.
	* breakpoint.h (enum bptype): Add bp_jit_event to enum.
	* breakpoint.c:
	(update_breakpoints_after_exec): Delete jit breakpoints after exec.
	(bpstat_what): Update event table for bp_jit_event.
	(print_it_typical): Added case for bp_jit_event.
	(print_one_breakpoint_location): Added case for bp_jit_event.
	(allocate_bp_location): Added case for bp_jit_event.
	(mention): Added case for bp_jit_event.
	(delete_command): Added case for bp_jit_event.
	(breakpoint_re_set_one): Added case for bp_jit_event.
	(breakpoint_re_set): Added call to jit_inferior_created_hook.
	(create_jit_event_breakpoint): New.
	* infrun.c (handle_inferior_event): Add handler for jit event.
	(follow_exec): Add call to jit_inferior_created_hook.
	* doc/gdb.texinfo: Add chapter on JIT interface.
@
text
@d140 2
a141 1
jit_read_descriptor (struct jit_descriptor *descriptor)
d148 1
a148 1
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch);
d151 1
a151 1
  ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;
d173 2
a174 1
jit_read_code_entry (CORE_ADDR code_addr, struct jit_code_entry *code_entry)
d181 1
a181 1
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch);
d184 1
a184 1
  ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;
d195 1
a195 1
  ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;
d211 2
a212 1
jit_register_code (CORE_ADDR entry_addr, struct jit_code_entry *code_entry)
d238 1
a238 1
  b = gdbarch_bfd_arch_info (target_gdbarch);
d305 5
a309 2
void
jit_inferior_created_hook (void)
d345 1
a345 1
  jit_read_descriptor (&descriptor);
d352 1
a352 1
  create_jit_event_breakpoint (target_gdbarch, reg_addr);
d360 1
a360 1
      jit_read_code_entry (cur_entry_addr, &cur_entry);
d367 1
a367 1
      jit_register_code (cur_entry_addr, &cur_entry);
d371 17
d391 1
a391 1
jit_inferior_created_hook1 (struct target_ops *objfile, int from_tty)
d393 1
a393 1
  jit_inferior_created_hook ();
d416 1
a416 1
jit_event_handler (void)
d424 1
a424 1
  jit_read_descriptor (&descriptor);
d433 2
a434 2
      jit_read_code_entry (entry_addr, &code_entry);
      jit_register_code (entry_addr, &code_entry);
d458 1
a458 1
  observer_attach_inferior_created (jit_inferior_created_hook1);
@

