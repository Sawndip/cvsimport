head	1.146;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.143
	gdb_7_6-2013-04-26-release:1.143
	gdb_7_6-branch:1.143.0.2
	gdb_7_6-2013-03-12-branchpoint:1.143
	gdb_7_5_1-2012-11-29-release:1.137.2.2
	gdb_7_5-2012-08-17-release:1.137.2.2
	gdb_7_5-branch:1.137.0.2
	gdb_7_5-2012-07-18-branchpoint:1.137
	gdb_7_4_1-2012-04-26-release:1.131.2.1
	gdb_7_4-2012-01-24-release:1.131.2.1
	gdb_7_4-branch:1.131.0.2
	gdb_7_4-2011-12-13-branchpoint:1.131
	gdb_7_3_1-2011-09-04-release:1.121
	gdb_7_3-2011-07-26-release:1.121
	gdb_7_3-branch:1.121.0.2
	gdb_7_3-2011-04-01-branchpoint:1.121
	gdb_7_2-2010-09-02-release:1.113.2.1
	gdb_7_2-branch:1.113.0.2
	gdb_7_2-2010-07-07-branchpoint:1.113
	gdb_7_1-2010-03-18-release:1.105
	gdb_7_1-branch:1.105.0.2
	gdb_7_1-2010-02-18-branchpoint:1.105
	gdb_7_0_1-2009-12-22-release:1.99.2.1
	gdb_7_0-2009-10-06-release:1.99
	gdb_7_0-branch:1.99.0.2
	gdb_7_0-2009-09-16-branchpoint:1.99
	arc-sim-20090309:1.79.6.1
	msnyder-checkpoint-072509-branch:1.93.0.2
	msnyder-checkpoint-072509-branchpoint:1.93
	arc-insight_6_8-branch:1.79.0.6
	arc-insight_6_8-branchpoint:1.79
	insight_6_8-branch:1.79.0.4
	insight_6_8-branchpoint:1.79
	reverse-20081226-branch:1.86.0.6
	reverse-20081226-branchpoint:1.86
	multiprocess-20081120-branch:1.86.0.4
	multiprocess-20081120-branchpoint:1.86
	reverse-20080930-branch:1.86.0.2
	reverse-20080930-branchpoint:1.86
	reverse-20080717-branch:1.85.0.2
	reverse-20080717-branchpoint:1.85
	msnyder-reverse-20080609-branch:1.84.0.2
	msnyder-reverse-20080609-branchpoint:1.84
	drow-reverse-20070409-branch:1.69.0.2
	drow-reverse-20070409-branchpoint:1.69
	gdb_6_8-2008-03-27-release:1.79
	gdb_6_8-branch:1.79.0.2
	gdb_6_8-2008-02-26-branchpoint:1.79
	gdb_6_7_1-2007-10-29-release:1.76
	gdb_6_7-2007-10-10-release:1.76
	gdb_6_7-branch:1.76.0.2
	gdb_6_7-2007-09-07-branchpoint:1.76
	insight_6_6-20070208-release:1.63
	gdb_6_6-2006-12-18-release:1.63
	gdb_6_6-branch:1.63.0.2
	gdb_6_6-2006-11-15-branchpoint:1.63
	insight_6_5-20061003-release:1.60
	gdb-csl-symbian-6_4_50_20060226-12:1.58.8.1
	gdb-csl-sourcerygxx-3_4_4-25:1.54
	nickrob-async-20060828-mergepoint:1.63
	gdb-csl-symbian-6_4_50_20060226-11:1.58.8.1
	gdb-csl-sourcerygxx-4_1-17:1.58
	gdb-csl-20060226-branch-local-2:1.58
	gdb-csl-sourcerygxx-4_1-14:1.58
	gdb-csl-sourcerygxx-4_1-13:1.58
	gdb-csl-sourcerygxx-4_1-12:1.58
	gdb-csl-sourcerygxx-3_4_4-21:1.58
	gdb_6_5-20060621-release:1.60
	gdb-csl-sourcerygxx-4_1-9:1.58
	gdb-csl-sourcerygxx-4_1-8:1.58
	gdb-csl-sourcerygxx-4_1-7:1.58
	gdb-csl-arm-2006q1-6:1.58
	gdb-csl-sourcerygxx-4_1-6:1.58
	gdb-csl-symbian-6_4_50_20060226-10:1.58.8.1
	gdb-csl-symbian-6_4_50_20060226-9:1.58.8.1
	gdb-csl-symbian-6_4_50_20060226-8:1.58.8.1
	gdb-csl-coldfire-4_1-11:1.58
	gdb-csl-sourcerygxx-3_4_4-19:1.58
	gdb-csl-coldfire-4_1-10:1.58
	gdb_6_5-branch:1.60.0.4
	gdb_6_5-2006-05-14-branchpoint:1.60
	gdb-csl-sourcerygxx-4_1-5:1.58
	nickrob-async-20060513-branch:1.60.0.2
	nickrob-async-20060513-branchpoint:1.60
	gdb-csl-sourcerygxx-4_1-4:1.58
	msnyder-reverse-20060502-branch:1.59.0.4
	msnyder-reverse-20060502-branchpoint:1.59
	gdb-csl-morpho-4_1-4:1.58
	gdb-csl-sourcerygxx-3_4_4-17:1.58
	readline_5_1-import-branch:1.59.0.2
	readline_5_1-import-branchpoint:1.59
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.58
	gdb-csl-symbian-20060226-branch:1.58.0.8
	gdb-csl-symbian-20060226-branchpoint:1.58
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.58
	msnyder-reverse-20060331-branch:1.58.0.6
	msnyder-reverse-20060331-branchpoint:1.58
	gdb-csl-available-20060303-branch:1.58.0.4
	gdb-csl-available-20060303-branchpoint:1.58
	gdb-csl-20060226-branch:1.58.0.2
	gdb-csl-20060226-branchpoint:1.58
	gdb_6_4-20051202-release:1.54.4.1
	msnyder-fork-checkpoint-branch:1.54.0.8
	msnyder-fork-checkpoint-branchpoint:1.54
	gdb-csl-gxxpro-6_3-branch:1.54.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.54
	gdb_6_4-branch:1.54.0.4
	gdb_6_4-2005-11-01-branchpoint:1.54
	gdb-csl-arm-20051020-branch:1.54.0.2
	gdb-csl-arm-20051020-branchpoint:1.54
	msnyder-tracepoint-checkpoint-branch:1.52.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.52
	gdb-csl-arm-20050325-2005-q1b:1.49
	gdb-csl-arm-20050325-2005-q1a:1.49
	csl-arm-20050325-branch:1.49.0.2
	csl-arm-20050325-branchpoint:1.49
	gdb-post-i18n-errorwarning-20050211:1.47
	gdb-pre-i18n-errorwarning-20050211:1.47
	gdb_6_3-20041109-release:1.38.2.1
	gdb_6_3-branch:1.38.0.2
	gdb_6_3-20041019-branchpoint:1.38
	drow_intercu-merge-20040921:1.38
	drow_intercu-merge-20040915:1.38
	jimb-gdb_6_2-e500-branch:1.36.0.6
	jimb-gdb_6_2-e500-branchpoint:1.36
	gdb_6_2-20040730-release:1.36
	gdb_6_2-branch:1.36.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.36
	gdb_6_1_1-20040616-release:1.31.4.1
	gdb_6_1-2004-04-05-release:1.31
	drow_intercu-merge-20040402:1.32
	drow_intercu-merge-20040327:1.32
	ezannoni_pie-20040323-branch:1.32.0.2
	ezannoni_pie-20040323-branchpoint:1.32
	cagney_tramp-20040321-mergepoint:1.32
	cagney_tramp-20040309-branch:1.31.0.6
	cagney_tramp-20040309-branchpoint:1.31
	gdb_6_1-branch:1.31.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.31
	drow_intercu-20040221-branch:1.31.0.2
	drow_intercu-20040221-branchpoint:1.31
	cagney_bfdfile-20040213-branch:1.29.0.2
	cagney_bfdfile-20040213-branchpoint:1.29
	drow-cplus-merge-20040208:1.29
	carlton_dictionary-20040126-merge:1.26
	cagney_bigcore-20040122-branch:1.26.0.2
	cagney_bigcore-20040122-branchpoint:1.26
	drow-cplus-merge-20040113:1.25
	drow-cplus-merge-20031224:1.24
	drow-cplus-merge-20031220:1.23
	carlton_dictionary-20031215-merge:1.23
	drow-cplus-branch:1.23.0.2
	drow-cplus-merge-20031214:1.23
	carlton-dictionary-20031111-merge:1.19
	gdb_6_0-2003-10-04-release:1.7.4.5
	kettenis_sparc-20030918-branch:1.14.0.4
	kettenis_sparc-20030918-branchpoint:1.14
	carlton_dictionary-20030917-merge:1.14
	ezannoni_pie-20030916-branchpoint:1.14
	ezannoni_pie-20030916-branch:1.14.0.2
	cagney_x86i386-20030821-branch:1.10.0.2
	cagney_x86i386-20030821-branchpoint:1.10
	carlton_dictionary-20030805-merge:1.10
	carlton_dictionary-branch:1.7.0.6
	carlton_dictionary-20030627-merge:1.7
	gdb_6_0-branch:1.7.0.4
	gdb_6_0-2003-06-23-branchpoint:1.7
	jimb-ppc64-linux-20030613-branch:1.7.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.7
	cagney_convert-20030606-branch:1.5.0.2
	cagney_convert-20030606-branchpoint:1.5;
locks; strict;
comment	@ * @;


1.146
date	2013.09.24.13.57.36;	author jkratoch;	state Exp;
branches;
next	1.145;

1.145
date	2013.04.19.15.35.21;	author palves;	state Exp;
branches;
next	1.144;

1.144
date	2013.04.12.14.55.28;	author tromey;	state Exp;
branches;
next	1.143;

1.143
date	2013.01.31.18.31.48;	author aristovski;	state Exp;
branches;
next	1.142;

1.142
date	2013.01.01.06.32.41;	author brobecke;	state Exp;
branches;
next	1.141;

1.141
date	2012.12.09.18.39.59;	author jkratoch;	state Exp;
branches;
next	1.140;

1.140
date	2012.08.16.15.45.44;	author brobecke;	state Exp;
branches;
next	1.139;

1.139
date	2012.08.06.19.20.42;	author tromey;	state Exp;
branches;
next	1.138;

1.138
date	2012.08.03.20.52.47;	author tromey;	state Exp;
branches;
next	1.137;

1.137
date	2012.05.24.01.26.15;	author devans;	state Exp;
branches
	1.137.2.1;
next	1.136;

1.136
date	2012.05.22.18.45.22;	author devans;	state Exp;
branches;
next	1.135;

1.135
date	2012.05.18.21.02.47;	author sergiodj;	state Exp;
branches;
next	1.134;

1.134
date	2012.04.28.23.22.13;	author devans;	state Exp;
branches;
next	1.133;

1.133
date	2012.01.17.14.03.33;	author palves;	state Exp;
branches;
next	1.132;

1.132
date	2012.01.04.08.17.00;	author brobecke;	state Exp;
branches;
next	1.131;

1.131
date	2011.10.09.19.26.42;	author jkratoch;	state Exp;
branches
	1.131.2.1;
next	1.130;

1.130
date	2011.10.09.19.21.38;	author jkratoch;	state Exp;
branches;
next	1.129;

1.129
date	2011.10.09.18.46.40;	author jkratoch;	state Exp;
branches;
next	1.128;

1.128
date	2011.07.27.17.06.13;	author jkratoch;	state Exp;
branches;
next	1.127;

1.127
date	2011.07.15.20.54.32;	author jkratoch;	state Exp;
branches;
next	1.126;

1.126
date	2011.07.15.15.01.04;	author fawzi;	state Exp;
branches;
next	1.125;

1.125
date	2011.07.04.16.30.09;	author brobecke;	state Exp;
branches;
next	1.124;

1.124
date	2011.05.24.12.40.17;	author gingold;	state Exp;
branches;
next	1.123;

1.123
date	2011.05.13.15.44.48;	author tromey;	state Exp;
branches;
next	1.122;

1.122
date	2011.05.12.17.40.54;	author tromey;	state Exp;
branches;
next	1.121;

1.121
date	2011.03.18.18.52.30;	author palves;	state Exp;
branches;
next	1.120;

1.120
date	2011.02.17.16.20.44;	author tromey;	state Exp;
branches;
next	1.119;

1.119
date	2011.01.07.19.36.16;	author msnyder;	state Exp;
branches;
next	1.118;

1.118
date	2011.01.05.22.22.48;	author msnyder;	state Exp;
branches;
next	1.117;

1.117
date	2011.01.01.15.33.01;	author brobecke;	state Exp;
branches;
next	1.116;

1.116
date	2010.11.29.21.18.15;	author tromey;	state Exp;
branches;
next	1.115;

1.115
date	2010.08.06.19.02.14;	author corinna;	state Exp;
branches;
next	1.114;

1.114
date	2010.07.07.17.26.38;	author tromey;	state Exp;
branches;
next	1.113;

1.113
date	2010.06.25.13.00.32;	author uweigand;	state Exp;
branches
	1.113.2.1;
next	1.112;

1.112
date	2010.06.07.19.55.33;	author jkratoch;	state Exp;
branches;
next	1.111;

1.111
date	2010.05.25.16.41.45;	author tromey;	state Exp;
branches;
next	1.110;

1.110
date	2010.05.14.17.53.16;	author msnyder;	state Exp;
branches;
next	1.109;

1.109
date	2010.05.06.22.50.09;	author msnyder;	state Exp;
branches;
next	1.108;

1.108
date	2010.04.20.17.33.14;	author tromey;	state Exp;
branches;
next	1.107;

1.107
date	2010.03.24.21.06.30;	author drow;	state Exp;
branches;
next	1.106;

1.106
date	2010.03.10.18.37.23;	author tromey;	state Exp;
branches;
next	1.105;

1.105
date	2010.01.01.07.31.30;	author brobecke;	state Exp;
branches;
next	1.104;

1.104
date	2009.10.28.19.28.57;	author palves;	state Exp;
branches;
next	1.103;

1.103
date	2009.10.28.19.01.16;	author palves;	state Exp;
branches;
next	1.102;

1.102
date	2009.10.28.18.37.11;	author palves;	state Exp;
branches;
next	1.101;

1.101
date	2009.10.22.20.20.27;	author ppluzhnikov;	state Exp;
branches;
next	1.100;

1.100
date	2009.10.06.23.27.04;	author muller;	state Exp;
branches;
next	1.99;

1.99
date	2009.09.15.16.20.53;	author devans;	state Exp;
branches
	1.99.2.1;
next	1.98;

1.98
date	2009.09.11.18.38.39;	author tromey;	state Exp;
branches;
next	1.97;

1.97
date	2009.09.02.14.53.55;	author tromey;	state Exp;
branches;
next	1.96;

1.96
date	2009.08.11.20.36.49;	author tromey;	state Exp;
branches;
next	1.95;

1.95
date	2009.08.06.23.25.49;	author ppluzhnikov;	state Exp;
branches;
next	1.94;

1.94
date	2009.08.06.23.19.47;	author ppluzhnikov;	state Exp;
branches;
next	1.93;

1.93
date	2009.07.10.15.27.02;	author tromey;	state Exp;
branches;
next	1.92;

1.92
date	2009.07.02.17.25.53;	author uweigand;	state Exp;
branches;
next	1.91;

1.91
date	2009.07.02.17.21.05;	author uweigand;	state Exp;
branches;
next	1.90;

1.90
date	2009.06.30.16.22.58;	author ppluzhnikov;	state Exp;
branches;
next	1.89;

1.89
date	2009.06.18.14.02.18;	author ppluzhnikov;	state Exp;
branches;
next	1.88;

1.88
date	2009.06.16.21.06.40;	author ppluzhnikov;	state Exp;
branches;
next	1.87;

1.87
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.86;

1.86
date	2008.09.05.11.40.53;	author uweigand;	state Exp;
branches;
next	1.85;

1.85
date	2008.07.15.18.40.03;	author drow;	state Exp;
branches;
next	1.84;

1.84
date	2008.05.03.23.24.17;	author bauermann;	state Exp;
branches;
next	1.83;

1.83
date	2008.05.01.18.30.50;	author drow;	state Exp;
branches;
next	1.82;

1.82
date	2008.04.30.21.18.28;	author drow;	state Exp;
branches;
next	1.81;

1.81
date	2008.03.26.14.53.28;	author uweigand;	state Exp;
branches;
next	1.80;

1.80
date	2008.03.18.19.40.47;	author uweigand;	state Exp;
branches;
next	1.79;

1.79
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches
	1.79.6.1;
next	1.78;

1.78
date	2007.12.26.10.57.50;	author luisgpm;	state Exp;
branches;
next	1.77;

1.77
date	2007.10.08.12.46.09;	author uweigand;	state Exp;
branches;
next	1.76;

1.76
date	2007.08.23.18.08.28;	author brobecke;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.12.16.59.42;	author uweigand;	state Exp;
branches;
next	1.73;

1.73
date	2007.06.09.13.42.15;	author uweigand;	state Exp;
branches;
next	1.72;

1.72
date	2007.05.31.17.32.20;	author uweigand;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.14.17.21.50;	author drow;	state Exp;
branches;
next	1.70;

1.70
date	2007.05.14.17.19.48;	author drow;	state Exp;
branches;
next	1.69;

1.69
date	2007.03.27.19.02.42;	author drow;	state Exp;
branches;
next	1.68;

1.68
date	2007.02.27.20.17.18;	author drow;	state Exp;
branches;
next	1.67;

1.67
date	2007.01.21.22.42.09;	author jkratoch;	state Exp;
branches;
next	1.66;

1.66
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.65;

1.65
date	2007.01.04.20.26.41;	author drow;	state Exp;
branches;
next	1.64;

1.64
date	2006.11.28.17.28.29;	author drow;	state Exp;
branches;
next	1.63;

1.63
date	2006.05.28.05.56.50;	author aoliva;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.28.05.56.20;	author aoliva;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.17.14.53.02;	author drow;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.09.21.14.17;	author schwab;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2006.04.05.20.01.19;	author davem;	state Exp;
branches;
next	1.58;

1.58
date	2006.01.17.22.27.21;	author jimb;	state Exp;
branches
	1.58.8.1;
next	1.57;

1.57
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.56;

1.56
date	2005.11.29.07.52.39;	author fred;	state Exp;
branches;
next	1.55;

1.55
date	2005.11.25.06.42.07;	author fred;	state Exp;
branches;
next	1.54;

1.54
date	2005.08.01.04.06.27;	author drow;	state Exp;
branches
	1.54.4.1;
next	1.53;

1.53
date	2005.07.12.13.06.54;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2005.05.28.16.44.28;	author drow;	state Exp;
branches;
next	1.51;

1.51
date	2005.04.08.12.10.21;	author drow;	state Exp;
branches;
next	1.50;

1.50
date	2005.03.26.15.20.42;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2005.03.25.16.51.40;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2005.02.11.18.13.49;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2004.11.20.10.10.17;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2004.11.09.19.51.44;	author drow;	state Exp;
branches;
next	1.45;

1.45
date	2004.11.07.21.16.11;	author drow;	state Exp;
branches;
next	1.44;

1.44
date	2004.11.06.00.39.16;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2004.11.05.22.35.22;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2004.11.05.15.16.44;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2004.11.04.21.15.15;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2004.11.02.22.25.47;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2004.10.29.14.00.55;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2004.07.23.22.05.20;	author kettenis;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2004.07.23.17.46.03;	author hunt;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.15.01.04.19;	author amodra;	state Exp;
branches
	1.36.6.1;
next	1.35;

1.35
date	2004.06.08.13.34.56;	author pbrook;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.01.10.55.19;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.01.09.52.47;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.15.20.38.08;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2004.02.16.20.32.01;	author cagney;	state Exp;
branches
	1.31.2.1
	1.31.4.1
	1.31.6.1;
next	1.30;

1.30
date	2004.02.15.21.29.26;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.07.18.29.53;	author ezannoni;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.07.14.44.50;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.02.22.00.14;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.18.21.22.50;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.27.23.15.00;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.22.20.32.51;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.05.21.14.49;	author kettenis;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2003.12.02.16.41.39;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.27.20.50.43;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.27.17.17.04;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.07.20.36.15;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.05.23.32.17;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.24.17.37.03;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.03.08.08.27;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.02.22.16.21;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.09.03.31.07;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.08.22.43.40;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.26.03.07.29;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.21.22.35.33;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.18.19.59.27;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.16.22.29.13;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.11.16.22.17;	author rth;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.08.18.27.13;	author cagney;	state Exp;
branches
	1.7.4.1
	1.7.6.1;
next	1.6;

1.6
date	2003.06.07.19.05.51;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.04.21.03.23;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.01.16.08.54;	author rth;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.01.16.04.50;	author rth;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.01.09.19.40;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.31.19.18.05;	author kettenis;	state Exp;
branches;
next	;

1.137.2.1
date	2012.08.03.20.53.03;	author tromey;	state Exp;
branches;
next	1.137.2.2;

1.137.2.2
date	2012.08.06.19.21.51;	author tromey;	state Exp;
branches;
next	;

1.131.2.1
date	2012.01.06.04.43.07;	author brobecke;	state Exp;
branches;
next	;

1.113.2.1
date	2010.07.07.18.50.57;	author tromey;	state Exp;
branches;
next	;

1.99.2.1
date	2009.10.22.20.31.36;	author ppluzhnikov;	state Exp;
branches;
next	;

1.79.6.1
date	2009.03.09.20.36.07;	author amylaar;	state Exp;
branches;
next	1.79.6.2;

1.79.6.2
date	2009.09.11.04.45.46;	author amylaar;	state Exp;
branches;
next	;

1.60.2.1
date	2006.08.28.07.48.49;	author nickrob;	state Exp;
branches;
next	;

1.58.8.1
date	2006.04.17.14.21.14;	author drow;	state Exp;
branches;
next	;

1.54.4.1
date	2005.11.28.07.20.35;	author fred;	state Exp;
branches;
next	;

1.38.2.1
date	2004.11.02.22.36.39;	author kettenis;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2004.11.20.09.42.18;	author kettenis;	state Exp;
branches;
next	;

1.36.6.1
date	2004.09.27.23.52.49;	author jimb;	state Exp;
branches;
next	1.36.6.2;

1.36.6.2
date	2004.09.27.23.53.36;	author jimb;	state Exp;
branches;
next	;

1.31.2.1
date	2004.03.27.17.37.45;	author drow;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2004.09.16.17.01.02;	author drow;	state Exp;
branches;
next	;

1.31.4.1
date	2004.05.01.11.22.54;	author kettenis;	state Exp;
branches;
next	;

1.31.6.1
date	2004.03.09.22.58.58;	author cagney;	state Exp;
branches;
next	1.31.6.2;

1.31.6.2
date	2004.03.16.16.05.54;	author cagney;	state Exp;
branches;
next	1.31.6.3;

1.31.6.3
date	2004.03.21.23.57.33;	author cagney;	state Exp;
branches;
next	;

1.23.2.1
date	2003.12.14.20.27.11;	author drow;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2003.12.24.22.08.39;	author drow;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2004.01.13.16.11.55;	author drow;	state Exp;
branches;
next	1.23.2.4;

1.23.2.4
date	2004.02.09.19.43.36;	author drow;	state Exp;
branches;
next	;

1.7.4.1
date	2003.07.11.16.56.09;	author rth;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.07.21.14.28.28;	author cagney;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2003.09.09.03.27.10;	author cagney;	state Exp;
branches;
next	1.7.4.4;

1.7.4.4
date	2003.09.14.18.26.47;	author drow;	state Exp;
branches;
next	1.7.4.5;

1.7.4.5
date	2003.09.14.18.35.57;	author drow;	state Exp;
branches;
next	;

1.7.6.1
date	2003.06.27.21.49.52;	author carlton;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2003.08.05.17.13.05;	author carlton;	state Exp;
branches;
next	1.7.6.3;

1.7.6.3
date	2003.09.17.21.28.15;	author carlton;	state Exp;
branches;
next	1.7.6.4;

1.7.6.4
date	2003.11.11.23.50.41;	author carlton;	state Exp;
branches;
next	1.7.6.5;

1.7.6.5
date	2003.12.16.00.00.26;	author carlton;	state Exp;
branches;
next	1.7.6.6;

1.7.6.6
date	2004.01.26.19.11.23;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.146
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@/* Frame unwinder for frames with DWARF Call Frame Information.

   Copyright (C) 2003-2013 Free Software Foundation, Inc.

   Contributed by Mark Kettenis.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "dwarf2expr.h"
#include "dwarf2.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
#include "gdbcore.h"
#include "gdbtypes.h"
#include "symtab.h"
#include "objfiles.h"
#include "regcache.h"
#include "value.h"

#include "gdb_assert.h"
#include "gdb_string.h"

#include "complaints.h"
#include "dwarf2-frame.h"
#include "ax.h"
#include "dwarf2loc.h"
#include "exceptions.h"
#include "dwarf2-frame-tailcall.h"

struct comp_unit;

/* Call Frame Information (CFI).  */

/* Common Information Entry (CIE).  */

struct dwarf2_cie
{
  /* Computation Unit for this CIE.  */
  struct comp_unit *unit;

  /* Offset into the .debug_frame section where this CIE was found.
     Used to identify this CIE.  */
  ULONGEST cie_pointer;

  /* Constant that is factored out of all advance location
     instructions.  */
  ULONGEST code_alignment_factor;

  /* Constants that is factored out of all offset instructions.  */
  LONGEST data_alignment_factor;

  /* Return address column.  */
  ULONGEST return_address_register;

  /* Instruction sequence to initialize a register set.  */
  const gdb_byte *initial_instructions;
  const gdb_byte *end;

  /* Saved augmentation, in case it's needed later.  */
  char *augmentation;

  /* Encoding of addresses.  */
  gdb_byte encoding;

  /* Target address size in bytes.  */
  int addr_size;

  /* Target pointer size in bytes.  */
  int ptr_size;

  /* True if a 'z' augmentation existed.  */
  unsigned char saw_z_augmentation;

  /* True if an 'S' augmentation existed.  */
  unsigned char signal_frame;

  /* The version recorded in the CIE.  */
  unsigned char version;

  /* The segment size.  */
  unsigned char segment_size;
};

struct dwarf2_cie_table
{
  int num_entries;
  struct dwarf2_cie **entries;
};

/* Frame Description Entry (FDE).  */

struct dwarf2_fde
{
  /* CIE for this FDE.  */
  struct dwarf2_cie *cie;

  /* First location associated with this FDE.  */
  CORE_ADDR initial_location;

  /* Number of bytes of program instructions described by this FDE.  */
  CORE_ADDR address_range;

  /* Instruction sequence.  */
  const gdb_byte *instructions;
  const gdb_byte *end;

  /* True if this FDE is read from a .eh_frame instead of a .debug_frame
     section.  */
  unsigned char eh_frame_p;
};

struct dwarf2_fde_table
{
  int num_entries;
  struct dwarf2_fde **entries;
};

/* A minimal decoding of DWARF2 compilation units.  We only decode
   what's needed to get to the call frame information.  */

struct comp_unit
{
  /* Keep the bfd convenient.  */
  bfd *abfd;

  struct objfile *objfile;

  /* Pointer to the .debug_frame section loaded into memory.  */
  const gdb_byte *dwarf_frame_buffer;

  /* Length of the loaded .debug_frame section.  */
  bfd_size_type dwarf_frame_size;

  /* Pointer to the .debug_frame section.  */
  asection *dwarf_frame_section;

  /* Base for DW_EH_PE_datarel encodings.  */
  bfd_vma dbase;

  /* Base for DW_EH_PE_textrel encodings.  */
  bfd_vma tbase;
};

static struct dwarf2_fde *dwarf2_frame_find_fde (CORE_ADDR *pc,
						 CORE_ADDR *out_offset);

static int dwarf2_frame_adjust_regnum (struct gdbarch *gdbarch, int regnum,
				       int eh_frame_p);

static CORE_ADDR read_encoded_value (struct comp_unit *unit, gdb_byte encoding,
				     int ptr_len, const gdb_byte *buf,
				     unsigned int *bytes_read_ptr,
				     CORE_ADDR func_base);


/* Structure describing a frame state.  */

struct dwarf2_frame_state
{
  /* Each register save state can be described in terms of a CFA slot,
     another register, or a location expression.  */
  struct dwarf2_frame_state_reg_info
  {
    struct dwarf2_frame_state_reg *reg;
    int num_regs;

    LONGEST cfa_offset;
    ULONGEST cfa_reg;
    enum {
      CFA_UNSET,
      CFA_REG_OFFSET,
      CFA_EXP
    } cfa_how;
    const gdb_byte *cfa_exp;

    /* Used to implement DW_CFA_remember_state.  */
    struct dwarf2_frame_state_reg_info *prev;
  } regs;

  /* The PC described by the current frame state.  */
  CORE_ADDR pc;

  /* Initial register set from the CIE.
     Used to implement DW_CFA_restore.  */
  struct dwarf2_frame_state_reg_info initial;

  /* The information we care about from the CIE.  */
  LONGEST data_align;
  ULONGEST code_align;
  ULONGEST retaddr_column;

  /* Flags for known producer quirks.  */

  /* The ARM compilers, in DWARF2 mode, assume that DW_CFA_def_cfa
     and DW_CFA_def_cfa_offset takes a factored offset.  */
  int armcc_cfa_offsets_sf;

  /* The ARM compilers, in DWARF2 or DWARF3 mode, may assume that
     the CFA is defined as REG - OFFSET rather than REG + OFFSET.  */
  int armcc_cfa_offsets_reversed;
};

/* Store the length the expression for the CFA in the `cfa_reg' field,
   which is unused in that case.  */
#define cfa_exp_len cfa_reg

/* Assert that the register set RS is large enough to store gdbarch_num_regs
   columns.  If necessary, enlarge the register set.  */

static void
dwarf2_frame_state_alloc_regs (struct dwarf2_frame_state_reg_info *rs,
			       int num_regs)
{
  size_t size = sizeof (struct dwarf2_frame_state_reg);

  if (num_regs <= rs->num_regs)
    return;

  rs->reg = (struct dwarf2_frame_state_reg *)
    xrealloc (rs->reg, num_regs * size);

  /* Initialize newly allocated registers.  */
  memset (rs->reg + rs->num_regs, 0, (num_regs - rs->num_regs) * size);
  rs->num_regs = num_regs;
}

/* Copy the register columns in register set RS into newly allocated
   memory and return a pointer to this newly created copy.  */

static struct dwarf2_frame_state_reg *
dwarf2_frame_state_copy_regs (struct dwarf2_frame_state_reg_info *rs)
{
  size_t size = rs->num_regs * sizeof (struct dwarf2_frame_state_reg);
  struct dwarf2_frame_state_reg *reg;

  reg = (struct dwarf2_frame_state_reg *) xmalloc (size);
  memcpy (reg, rs->reg, size);

  return reg;
}

/* Release the memory allocated to register set RS.  */

static void
dwarf2_frame_state_free_regs (struct dwarf2_frame_state_reg_info *rs)
{
  if (rs)
    {
      dwarf2_frame_state_free_regs (rs->prev);

      xfree (rs->reg);
      xfree (rs);
    }
}

/* Release the memory allocated to the frame state FS.  */

static void
dwarf2_frame_state_free (void *p)
{
  struct dwarf2_frame_state *fs = p;

  dwarf2_frame_state_free_regs (fs->initial.prev);
  dwarf2_frame_state_free_regs (fs->regs.prev);
  xfree (fs->initial.reg);
  xfree (fs->regs.reg);
  xfree (fs);
}


/* Helper functions for execute_stack_op.  */

static CORE_ADDR
read_reg (void *baton, int reg)
{
  struct frame_info *this_frame = (struct frame_info *) baton;
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  int regnum;
  gdb_byte *buf;

  regnum = gdbarch_dwarf2_reg_to_regnum (gdbarch, reg);

  buf = alloca (register_size (gdbarch, regnum));
  get_frame_register (this_frame, regnum, buf);

  /* Convert the register to an integer.  This returns a LONGEST
     rather than a CORE_ADDR, but unpack_pointer does the same thing
     under the covers, and this makes more sense for non-pointer
     registers.  Maybe read_reg and the associated interfaces should
     deal with "struct value" instead of CORE_ADDR.  */
  return unpack_long (register_type (gdbarch, regnum), buf);
}

static void
read_mem (void *baton, gdb_byte *buf, CORE_ADDR addr, size_t len)
{
  read_memory (addr, buf, len);
}

/* Execute the required actions for both the DW_CFA_restore and
DW_CFA_restore_extended instructions.  */
static void
dwarf2_restore_rule (struct gdbarch *gdbarch, ULONGEST reg_num,
		     struct dwarf2_frame_state *fs, int eh_frame_p)
{
  ULONGEST reg;

  gdb_assert (fs->initial.reg);
  reg = dwarf2_frame_adjust_regnum (gdbarch, reg_num, eh_frame_p);
  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);

  /* Check if this register was explicitly initialized in the
  CIE initial instructions.  If not, default the rule to
  UNSPECIFIED.  */
  if (reg < fs->initial.num_regs)
    fs->regs.reg[reg] = fs->initial.reg[reg];
  else
    fs->regs.reg[reg].how = DWARF2_FRAME_REG_UNSPECIFIED;

  if (fs->regs.reg[reg].how == DWARF2_FRAME_REG_UNSPECIFIED)
    complaint (&symfile_complaints, _("\
incomplete CFI data; DW_CFA_restore unspecified\n\
register %s (#%d) at %s"),
		       gdbarch_register_name
		       (gdbarch, gdbarch_dwarf2_reg_to_regnum (gdbarch, reg)),
		       gdbarch_dwarf2_reg_to_regnum (gdbarch, reg),
		       paddress (gdbarch, fs->pc));
}

/* Virtual method table for execute_stack_op below.  */

static const struct dwarf_expr_context_funcs dwarf2_frame_ctx_funcs =
{
  read_reg,
  read_mem,
  ctx_no_get_frame_base,
  ctx_no_get_frame_cfa,
  ctx_no_get_frame_pc,
  ctx_no_get_tls_address,
  ctx_no_dwarf_call,
  ctx_no_get_base_type,
  ctx_no_push_dwarf_reg_entry_value,
  ctx_no_get_addr_index
};

static CORE_ADDR
execute_stack_op (const gdb_byte *exp, ULONGEST len, int addr_size,
		  CORE_ADDR offset, struct frame_info *this_frame,
		  CORE_ADDR initial, int initial_in_stack_memory)
{
  struct dwarf_expr_context *ctx;
  CORE_ADDR result;
  struct cleanup *old_chain;

  ctx = new_dwarf_expr_context ();
  old_chain = make_cleanup_free_dwarf_expr_context (ctx);
  make_cleanup_value_free_to_mark (value_mark ());

  ctx->gdbarch = get_frame_arch (this_frame);
  ctx->addr_size = addr_size;
  ctx->ref_addr_size = -1;
  ctx->offset = offset;
  ctx->baton = this_frame;
  ctx->funcs = &dwarf2_frame_ctx_funcs;

  dwarf_expr_push_address (ctx, initial, initial_in_stack_memory);
  dwarf_expr_eval (ctx, exp, len);

  if (ctx->location == DWARF_VALUE_MEMORY)
    result = dwarf_expr_fetch_address (ctx, 0);
  else if (ctx->location == DWARF_VALUE_REGISTER)
    result = read_reg (this_frame, value_as_long (dwarf_expr_fetch (ctx, 0)));
  else
    {
      /* This is actually invalid DWARF, but if we ever do run across
	 it somehow, we might as well support it.  So, instead, report
	 it as unimplemented.  */
      error (_("\
Not implemented: computing unwound register using explicit value operator"));
    }

  do_cleanups (old_chain);

  return result;
}


/* Execute FDE program from INSN_PTR possibly up to INSN_END or up to inferior
   PC.  Modify FS state accordingly.  Return current INSN_PTR where the
   execution has stopped, one can resume it on the next call.  */

static const gdb_byte *
execute_cfa_program (struct dwarf2_fde *fde, const gdb_byte *insn_ptr,
		     const gdb_byte *insn_end, struct gdbarch *gdbarch,
		     CORE_ADDR pc, struct dwarf2_frame_state *fs)
{
  int eh_frame_p = fde->eh_frame_p;
  unsigned int bytes_read;
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  while (insn_ptr < insn_end && fs->pc <= pc)
    {
      gdb_byte insn = *insn_ptr++;
      uint64_t utmp, reg;
      int64_t offset;

      if ((insn & 0xc0) == DW_CFA_advance_loc)
	fs->pc += (insn & 0x3f) * fs->code_align;
      else if ((insn & 0xc0) == DW_CFA_offset)
	{
	  reg = insn & 0x3f;
	  reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
	  insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &utmp);
	  offset = utmp * fs->data_align;
	  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
	  fs->regs.reg[reg].loc.offset = offset;
	}
      else if ((insn & 0xc0) == DW_CFA_restore)
	{
	  reg = insn & 0x3f;
	  dwarf2_restore_rule (gdbarch, reg, fs, eh_frame_p);
	}
      else
	{
	  switch (insn)
	    {
	    case DW_CFA_set_loc:
	      fs->pc = read_encoded_value (fde->cie->unit, fde->cie->encoding,
					   fde->cie->ptr_size, insn_ptr,
					   &bytes_read, fde->initial_location);
	      /* Apply the objfile offset for relocatable objects.  */
	      fs->pc += ANOFFSET (fde->cie->unit->objfile->section_offsets,
				  SECT_OFF_TEXT (fde->cie->unit->objfile));
	      insn_ptr += bytes_read;
	      break;

	    case DW_CFA_advance_loc1:
	      utmp = extract_unsigned_integer (insn_ptr, 1, byte_order);
	      fs->pc += utmp * fs->code_align;
	      insn_ptr++;
	      break;
	    case DW_CFA_advance_loc2:
	      utmp = extract_unsigned_integer (insn_ptr, 2, byte_order);
	      fs->pc += utmp * fs->code_align;
	      insn_ptr += 2;
	      break;
	    case DW_CFA_advance_loc4:
	      utmp = extract_unsigned_integer (insn_ptr, 4, byte_order);
	      fs->pc += utmp * fs->code_align;
	      insn_ptr += 4;
	      break;

	    case DW_CFA_offset_extended:
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &reg);
	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &utmp);
	      offset = utmp * fs->data_align;
	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
	      fs->regs.reg[reg].loc.offset = offset;
	      break;

	    case DW_CFA_restore_extended:
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &reg);
	      dwarf2_restore_rule (gdbarch, reg, fs, eh_frame_p);
	      break;

	    case DW_CFA_undefined:
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &reg);
	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_UNDEFINED;
	      break;

	    case DW_CFA_same_value:
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &reg);
	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAME_VALUE;
	      break;

	    case DW_CFA_register:
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &reg);
	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &utmp);
	      utmp = dwarf2_frame_adjust_regnum (gdbarch, utmp, eh_frame_p);
	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_REG;
	      fs->regs.reg[reg].loc.reg = utmp;
	      break;

	    case DW_CFA_remember_state:
	      {
		struct dwarf2_frame_state_reg_info *new_rs;

		new_rs = XMALLOC (struct dwarf2_frame_state_reg_info);
		*new_rs = fs->regs;
		fs->regs.reg = dwarf2_frame_state_copy_regs (&fs->regs);
		fs->regs.prev = new_rs;
	      }
	      break;

	    case DW_CFA_restore_state:
	      {
		struct dwarf2_frame_state_reg_info *old_rs = fs->regs.prev;

		if (old_rs == NULL)
		  {
		    complaint (&symfile_complaints, _("\
bad CFI data; mismatched DW_CFA_restore_state at %s"),
			       paddress (gdbarch, fs->pc));
		  }
		else
		  {
		    xfree (fs->regs.reg);
		    fs->regs = *old_rs;
		    xfree (old_rs);
		  }
	      }
	      break;

	    case DW_CFA_def_cfa:
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &reg);
	      fs->regs.cfa_reg = reg;
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &utmp);

	      if (fs->armcc_cfa_offsets_sf)
		utmp *= fs->data_align;

	      fs->regs.cfa_offset = utmp;
	      fs->regs.cfa_how = CFA_REG_OFFSET;
	      break;

	    case DW_CFA_def_cfa_register:
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &reg);
	      fs->regs.cfa_reg = dwarf2_frame_adjust_regnum (gdbarch, reg,
                                                             eh_frame_p);
	      fs->regs.cfa_how = CFA_REG_OFFSET;
	      break;

	    case DW_CFA_def_cfa_offset:
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &utmp);

	      if (fs->armcc_cfa_offsets_sf)
		utmp *= fs->data_align;

	      fs->regs.cfa_offset = utmp;
	      /* cfa_how deliberately not set.  */
	      break;

	    case DW_CFA_nop:
	      break;

	    case DW_CFA_def_cfa_expression:
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &utmp);
	      fs->regs.cfa_exp_len = utmp;
	      fs->regs.cfa_exp = insn_ptr;
	      fs->regs.cfa_how = CFA_EXP;
	      insn_ptr += fs->regs.cfa_exp_len;
	      break;

	    case DW_CFA_expression:
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &reg);
	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &utmp);
	      fs->regs.reg[reg].loc.exp = insn_ptr;
	      fs->regs.reg[reg].exp_len = utmp;
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_EXP;
	      insn_ptr += utmp;
	      break;

	    case DW_CFA_offset_extended_sf:
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &reg);
	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
	      insn_ptr = safe_read_sleb128 (insn_ptr, insn_end, &offset);
	      offset *= fs->data_align;
	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
	      fs->regs.reg[reg].loc.offset = offset;
	      break;

	    case DW_CFA_val_offset:
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &reg);
	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &utmp);
	      offset = utmp * fs->data_align;
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_OFFSET;
	      fs->regs.reg[reg].loc.offset = offset;
	      break;

	    case DW_CFA_val_offset_sf:
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &reg);
	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	      insn_ptr = safe_read_sleb128 (insn_ptr, insn_end, &offset);
	      offset *= fs->data_align;
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_OFFSET;
	      fs->regs.reg[reg].loc.offset = offset;
	      break;

	    case DW_CFA_val_expression:
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &reg);
	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &utmp);
	      fs->regs.reg[reg].loc.exp = insn_ptr;
	      fs->regs.reg[reg].exp_len = utmp;
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_EXP;
	      insn_ptr += utmp;
	      break;

	    case DW_CFA_def_cfa_sf:
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &reg);
	      fs->regs.cfa_reg = dwarf2_frame_adjust_regnum (gdbarch, reg,
                                                             eh_frame_p);
	      insn_ptr = safe_read_sleb128 (insn_ptr, insn_end, &offset);
	      fs->regs.cfa_offset = offset * fs->data_align;
	      fs->regs.cfa_how = CFA_REG_OFFSET;
	      break;

	    case DW_CFA_def_cfa_offset_sf:
	      insn_ptr = safe_read_sleb128 (insn_ptr, insn_end, &offset);
	      fs->regs.cfa_offset = offset * fs->data_align;
	      /* cfa_how deliberately not set.  */
	      break;

	    case DW_CFA_GNU_window_save:
	      /* This is SPARC-specific code, and contains hard-coded
		 constants for the register numbering scheme used by
		 GCC.  Rather than having a architecture-specific
		 operation that's only ever used by a single
		 architecture, we provide the implementation here.
		 Incidentally that's what GCC does too in its
		 unwinder.  */
	      {
		int size = register_size (gdbarch, 0);

		dwarf2_frame_state_alloc_regs (&fs->regs, 32);
		for (reg = 8; reg < 16; reg++)
		  {
		    fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_REG;
		    fs->regs.reg[reg].loc.reg = reg + 16;
		  }
		for (reg = 16; reg < 32; reg++)
		  {
		    fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
		    fs->regs.reg[reg].loc.offset = (reg - 16) * size;
		  }
	      }
	      break;

	    case DW_CFA_GNU_args_size:
	      /* Ignored.  */
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &utmp);
	      break;

	    case DW_CFA_GNU_negative_offset_extended:
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &reg);
	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &utmp);
	      offset = utmp * fs->data_align;
	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
	      fs->regs.reg[reg].loc.offset = -offset;
	      break;

	    default:
	      internal_error (__FILE__, __LINE__,
			      _("Unknown CFI encountered."));
	    }
	}
    }

  if (fs->initial.reg == NULL)
    {
      /* Don't allow remember/restore between CIE and FDE programs.  */
      dwarf2_frame_state_free_regs (fs->regs.prev);
      fs->regs.prev = NULL;
    }

  return insn_ptr;
}


/* Architecture-specific operations.  */

/* Per-architecture data key.  */
static struct gdbarch_data *dwarf2_frame_data;

struct dwarf2_frame_ops
{
  /* Pre-initialize the register state REG for register REGNUM.  */
  void (*init_reg) (struct gdbarch *, int, struct dwarf2_frame_state_reg *,
		    struct frame_info *);

  /* Check whether the THIS_FRAME is a signal trampoline.  */
  int (*signal_frame_p) (struct gdbarch *, struct frame_info *);

  /* Convert .eh_frame register number to DWARF register number, or
     adjust .debug_frame register number.  */
  int (*adjust_regnum) (struct gdbarch *, int, int);
};

/* Default architecture-specific register state initialization
   function.  */

static void
dwarf2_frame_default_init_reg (struct gdbarch *gdbarch, int regnum,
			       struct dwarf2_frame_state_reg *reg,
			       struct frame_info *this_frame)
{
  /* If we have a register that acts as a program counter, mark it as
     a destination for the return address.  If we have a register that
     serves as the stack pointer, arrange for it to be filled with the
     call frame address (CFA).  The other registers are marked as
     unspecified.

     We copy the return address to the program counter, since many
     parts in GDB assume that it is possible to get the return address
     by unwinding the program counter register.  However, on ISA's
     with a dedicated return address register, the CFI usually only
     contains information to unwind that return address register.

     The reason we're treating the stack pointer special here is
     because in many cases GCC doesn't emit CFI for the stack pointer
     and implicitly assumes that it is equal to the CFA.  This makes
     some sense since the DWARF specification (version 3, draft 8,
     p. 102) says that:

     "Typically, the CFA is defined to be the value of the stack
     pointer at the call site in the previous frame (which may be
     different from its value on entry to the current frame)."

     However, this isn't true for all platforms supported by GCC
     (e.g. IBM S/390 and zSeries).  Those architectures should provide
     their own architecture-specific initialization function.  */

  if (regnum == gdbarch_pc_regnum (gdbarch))
    reg->how = DWARF2_FRAME_REG_RA;
  else if (regnum == gdbarch_sp_regnum (gdbarch))
    reg->how = DWARF2_FRAME_REG_CFA;
}

/* Return a default for the architecture-specific operations.  */

static void *
dwarf2_frame_init (struct obstack *obstack)
{
  struct dwarf2_frame_ops *ops;
  
  ops = OBSTACK_ZALLOC (obstack, struct dwarf2_frame_ops);
  ops->init_reg = dwarf2_frame_default_init_reg;
  return ops;
}

/* Set the architecture-specific register state initialization
   function for GDBARCH to INIT_REG.  */

void
dwarf2_frame_set_init_reg (struct gdbarch *gdbarch,
			   void (*init_reg) (struct gdbarch *, int,
					     struct dwarf2_frame_state_reg *,
					     struct frame_info *))
{
  struct dwarf2_frame_ops *ops = gdbarch_data (gdbarch, dwarf2_frame_data);

  ops->init_reg = init_reg;
}

/* Pre-initialize the register state REG for register REGNUM.  */

static void
dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,
		       struct dwarf2_frame_state_reg *reg,
		       struct frame_info *this_frame)
{
  struct dwarf2_frame_ops *ops = gdbarch_data (gdbarch, dwarf2_frame_data);

  ops->init_reg (gdbarch, regnum, reg, this_frame);
}

/* Set the architecture-specific signal trampoline recognition
   function for GDBARCH to SIGNAL_FRAME_P.  */

void
dwarf2_frame_set_signal_frame_p (struct gdbarch *gdbarch,
				 int (*signal_frame_p) (struct gdbarch *,
							struct frame_info *))
{
  struct dwarf2_frame_ops *ops = gdbarch_data (gdbarch, dwarf2_frame_data);

  ops->signal_frame_p = signal_frame_p;
}

/* Query the architecture-specific signal frame recognizer for
   THIS_FRAME.  */

static int
dwarf2_frame_signal_frame_p (struct gdbarch *gdbarch,
			     struct frame_info *this_frame)
{
  struct dwarf2_frame_ops *ops = gdbarch_data (gdbarch, dwarf2_frame_data);

  if (ops->signal_frame_p == NULL)
    return 0;
  return ops->signal_frame_p (gdbarch, this_frame);
}

/* Set the architecture-specific adjustment of .eh_frame and .debug_frame
   register numbers.  */

void
dwarf2_frame_set_adjust_regnum (struct gdbarch *gdbarch,
				int (*adjust_regnum) (struct gdbarch *,
						      int, int))
{
  struct dwarf2_frame_ops *ops = gdbarch_data (gdbarch, dwarf2_frame_data);

  ops->adjust_regnum = adjust_regnum;
}

/* Translate a .eh_frame register to DWARF register, or adjust a .debug_frame
   register.  */

static int
dwarf2_frame_adjust_regnum (struct gdbarch *gdbarch,
			    int regnum, int eh_frame_p)
{
  struct dwarf2_frame_ops *ops = gdbarch_data (gdbarch, dwarf2_frame_data);

  if (ops->adjust_regnum == NULL)
    return regnum;
  return ops->adjust_regnum (gdbarch, regnum, eh_frame_p);
}

static void
dwarf2_frame_find_quirks (struct dwarf2_frame_state *fs,
			  struct dwarf2_fde *fde)
{
  struct symtab *s;

  s = find_pc_symtab (fs->pc);
  if (s == NULL)
    return;

  if (producer_is_realview (s->producer))
    {
      if (fde->cie->version == 1)
	fs->armcc_cfa_offsets_sf = 1;

      if (fde->cie->version == 1)
	fs->armcc_cfa_offsets_reversed = 1;

      /* The reversed offset problem is present in some compilers
	 using DWARF3, but it was eventually fixed.  Check the ARM
	 defined augmentations, which are in the format "armcc" followed
	 by a list of one-character options.  The "+" option means
	 this problem is fixed (no quirk needed).  If the armcc
	 augmentation is missing, the quirk is needed.  */
      if (fde->cie->version == 3
	  && (strncmp (fde->cie->augmentation, "armcc", 5) != 0
	      || strchr (fde->cie->augmentation + 5, '+') == NULL))
	fs->armcc_cfa_offsets_reversed = 1;

      return;
    }
}


void
dwarf2_compile_cfa_to_ax (struct agent_expr *expr, struct axs_value *loc,
			  struct gdbarch *gdbarch,
			  CORE_ADDR pc,
			  struct dwarf2_per_cu_data *data)
{
  struct dwarf2_fde *fde;
  CORE_ADDR text_offset;
  struct dwarf2_frame_state fs;
  int addr_size;

  memset (&fs, 0, sizeof (struct dwarf2_frame_state));

  fs.pc = pc;

  /* Find the correct FDE.  */
  fde = dwarf2_frame_find_fde (&fs.pc, &text_offset);
  if (fde == NULL)
    error (_("Could not compute CFA; needed to translate this expression"));

  /* Extract any interesting information from the CIE.  */
  fs.data_align = fde->cie->data_alignment_factor;
  fs.code_align = fde->cie->code_alignment_factor;
  fs.retaddr_column = fde->cie->return_address_register;
  addr_size = fde->cie->addr_size;

  /* Check for "quirks" - known bugs in producers.  */
  dwarf2_frame_find_quirks (&fs, fde);

  /* First decode all the insns in the CIE.  */
  execute_cfa_program (fde, fde->cie->initial_instructions,
		       fde->cie->end, gdbarch, pc, &fs);

  /* Save the initialized register set.  */
  fs.initial = fs.regs;
  fs.initial.reg = dwarf2_frame_state_copy_regs (&fs.regs);

  /* Then decode the insns in the FDE up to our target PC.  */
  execute_cfa_program (fde, fde->instructions, fde->end, gdbarch, pc, &fs);

  /* Calculate the CFA.  */
  switch (fs.regs.cfa_how)
    {
    case CFA_REG_OFFSET:
      {
	int regnum = gdbarch_dwarf2_reg_to_regnum (gdbarch, fs.regs.cfa_reg);

	if (regnum == -1)
	  error (_("Unable to access DWARF register number %d"),
		 (int) fs.regs.cfa_reg); /* FIXME */
	ax_reg (expr, regnum);

	if (fs.regs.cfa_offset != 0)
	  {
	    if (fs.armcc_cfa_offsets_reversed)
	      ax_const_l (expr, -fs.regs.cfa_offset);
	    else
	      ax_const_l (expr, fs.regs.cfa_offset);
	    ax_simple (expr, aop_add);
	  }
      }
      break;

    case CFA_EXP:
      ax_const_l (expr, text_offset);
      dwarf2_compile_expr_to_ax (expr, loc, gdbarch, addr_size,
				 fs.regs.cfa_exp,
				 fs.regs.cfa_exp + fs.regs.cfa_exp_len,
				 data);
      break;

    default:
      internal_error (__FILE__, __LINE__, _("Unknown CFA rule."));
    }
}


struct dwarf2_frame_cache
{
  /* DWARF Call Frame Address.  */
  CORE_ADDR cfa;

  /* Set if the return address column was marked as unavailable
     (required non-collected memory or registers to compute).  */
  int unavailable_retaddr;

  /* Set if the return address column was marked as undefined.  */
  int undefined_retaddr;

  /* Saved registers, indexed by GDB register number, not by DWARF
     register number.  */
  struct dwarf2_frame_state_reg *reg;

  /* Return address register.  */
  struct dwarf2_frame_state_reg retaddr_reg;

  /* Target address size in bytes.  */
  int addr_size;

  /* The .text offset.  */
  CORE_ADDR text_offset;

  /* If not NULL then this frame is the bottom frame of a TAILCALL_FRAME
     sequence.  If NULL then it is a normal case with no TAILCALL_FRAME
     involved.  Non-bottom frames of a virtual tail call frames chain use
     dwarf2_tailcall_frame_unwind unwinder so this field does not apply for
     them.  */
  void *tailcall_cache;
};

/* A cleanup that sets a pointer to NULL.  */

static void
clear_pointer_cleanup (void *arg)
{
  void **ptr = arg;

  *ptr = NULL;
}

static struct dwarf2_frame_cache *
dwarf2_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct cleanup *reset_cache_cleanup, *old_chain;
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  const int num_regs = gdbarch_num_regs (gdbarch)
		       + gdbarch_num_pseudo_regs (gdbarch);
  struct dwarf2_frame_cache *cache;
  struct dwarf2_frame_state *fs;
  struct dwarf2_fde *fde;
  volatile struct gdb_exception ex;
  CORE_ADDR entry_pc;
  LONGEST entry_cfa_sp_offset;
  int entry_cfa_sp_offset_p = 0;
  const gdb_byte *instr;

  if (*this_cache)
    return *this_cache;

  /* Allocate a new cache.  */
  cache = FRAME_OBSTACK_ZALLOC (struct dwarf2_frame_cache);
  cache->reg = FRAME_OBSTACK_CALLOC (num_regs, struct dwarf2_frame_state_reg);
  *this_cache = cache;
  reset_cache_cleanup = make_cleanup (clear_pointer_cleanup, this_cache);

  /* Allocate and initialize the frame state.  */
  fs = XZALLOC (struct dwarf2_frame_state);
  old_chain = make_cleanup (dwarf2_frame_state_free, fs);

  /* Unwind the PC.

     Note that if the next frame is never supposed to return (i.e. a call
     to abort), the compiler might optimize away the instruction at
     its return address.  As a result the return address will
     point at some random instruction, and the CFI for that
     instruction is probably worthless to us.  GCC's unwinder solves
     this problem by substracting 1 from the return address to get an
     address in the middle of a presumed call instruction (or the
     instruction in the associated delay slot).  This should only be
     done for "normal" frames and not for resume-type frames (signal
     handlers, sentinel frames, dummy frames).  The function
     get_frame_address_in_block does just this.  It's not clear how
     reliable the method is though; there is the potential for the
     register state pre-call being different to that on return.  */
  fs->pc = get_frame_address_in_block (this_frame);

  /* Find the correct FDE.  */
  fde = dwarf2_frame_find_fde (&fs->pc, &cache->text_offset);
  gdb_assert (fde != NULL);

  /* Extract any interesting information from the CIE.  */
  fs->data_align = fde->cie->data_alignment_factor;
  fs->code_align = fde->cie->code_alignment_factor;
  fs->retaddr_column = fde->cie->return_address_register;
  cache->addr_size = fde->cie->addr_size;

  /* Check for "quirks" - known bugs in producers.  */
  dwarf2_frame_find_quirks (fs, fde);

  /* First decode all the insns in the CIE.  */
  execute_cfa_program (fde, fde->cie->initial_instructions,
		       fde->cie->end, gdbarch,
		       get_frame_address_in_block (this_frame), fs);

  /* Save the initialized register set.  */
  fs->initial = fs->regs;
  fs->initial.reg = dwarf2_frame_state_copy_regs (&fs->regs);

  if (get_frame_func_if_available (this_frame, &entry_pc))
    {
      /* Decode the insns in the FDE up to the entry PC.  */
      instr = execute_cfa_program (fde, fde->instructions, fde->end, gdbarch,
				   entry_pc, fs);

      if (fs->regs.cfa_how == CFA_REG_OFFSET
	  && (gdbarch_dwarf2_reg_to_regnum (gdbarch, fs->regs.cfa_reg)
	      == gdbarch_sp_regnum (gdbarch)))
	{
	  entry_cfa_sp_offset = fs->regs.cfa_offset;
	  entry_cfa_sp_offset_p = 1;
	}
    }
  else
    instr = fde->instructions;

  /* Then decode the insns in the FDE up to our target PC.  */
  execute_cfa_program (fde, instr, fde->end, gdbarch,
		       get_frame_address_in_block (this_frame), fs);

  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      /* Calculate the CFA.  */
      switch (fs->regs.cfa_how)
	{
	case CFA_REG_OFFSET:
	  cache->cfa = read_reg (this_frame, fs->regs.cfa_reg);
	  if (fs->armcc_cfa_offsets_reversed)
	    cache->cfa -= fs->regs.cfa_offset;
	  else
	    cache->cfa += fs->regs.cfa_offset;
	  break;

	case CFA_EXP:
	  cache->cfa =
	    execute_stack_op (fs->regs.cfa_exp, fs->regs.cfa_exp_len,
			      cache->addr_size, cache->text_offset,
			      this_frame, 0, 0);
	  break;

	default:
	  internal_error (__FILE__, __LINE__, _("Unknown CFA rule."));
	}
    }
  if (ex.reason < 0)
    {
      if (ex.error == NOT_AVAILABLE_ERROR)
	{
	  cache->unavailable_retaddr = 1;
	  do_cleanups (old_chain);
	  discard_cleanups (reset_cache_cleanup);
	  return cache;
	}

      throw_exception (ex);
    }

  /* Initialize the register state.  */
  {
    int regnum;

    for (regnum = 0; regnum < num_regs; regnum++)
      dwarf2_frame_init_reg (gdbarch, regnum, &cache->reg[regnum], this_frame);
  }

  /* Go through the DWARF2 CFI generated table and save its register
     location information in the cache.  Note that we don't skip the
     return address column; it's perfectly all right for it to
     correspond to a real register.  If it doesn't correspond to a
     real register, or if we shouldn't treat it as such,
     gdbarch_dwarf2_reg_to_regnum should be defined to return a number outside
     the range [0, gdbarch_num_regs).  */
  {
    int column;		/* CFI speak for "register number".  */

    for (column = 0; column < fs->regs.num_regs; column++)
      {
	/* Use the GDB register number as the destination index.  */
	int regnum = gdbarch_dwarf2_reg_to_regnum (gdbarch, column);

	/* If there's no corresponding GDB register, ignore it.  */
	if (regnum < 0 || regnum >= num_regs)
	  continue;

	/* NOTE: cagney/2003-09-05: CFI should specify the disposition
	   of all debug info registers.  If it doesn't, complain (but
	   not too loudly).  It turns out that GCC assumes that an
	   unspecified register implies "same value" when CFI (draft
	   7) specifies nothing at all.  Such a register could equally
	   be interpreted as "undefined".  Also note that this check
	   isn't sufficient; it only checks that all registers in the
	   range [0 .. max column] are specified, and won't detect
	   problems when a debug info register falls outside of the
	   table.  We need a way of iterating through all the valid
	   DWARF2 register numbers.  */
	if (fs->regs.reg[column].how == DWARF2_FRAME_REG_UNSPECIFIED)
	  {
	    if (cache->reg[regnum].how == DWARF2_FRAME_REG_UNSPECIFIED)
	      complaint (&symfile_complaints, _("\
incomplete CFI data; unspecified registers (e.g., %s) at %s"),
			 gdbarch_register_name (gdbarch, regnum),
			 paddress (gdbarch, fs->pc));
	  }
	else
	  cache->reg[regnum] = fs->regs.reg[column];
      }
  }

  /* Eliminate any DWARF2_FRAME_REG_RA rules, and save the information
     we need for evaluating DWARF2_FRAME_REG_RA_OFFSET rules.  */
  {
    int regnum;

    for (regnum = 0; regnum < num_regs; regnum++)
      {
	if (cache->reg[regnum].how == DWARF2_FRAME_REG_RA
	    || cache->reg[regnum].how == DWARF2_FRAME_REG_RA_OFFSET)
	  {
	    struct dwarf2_frame_state_reg *retaddr_reg =
	      &fs->regs.reg[fs->retaddr_column];

	    /* It seems rather bizarre to specify an "empty" column as
               the return adress column.  However, this is exactly
               what GCC does on some targets.  It turns out that GCC
               assumes that the return address can be found in the
               register corresponding to the return address column.
               Incidentally, that's how we should treat a return
               address column specifying "same value" too.  */
	    if (fs->retaddr_column < fs->regs.num_regs
		&& retaddr_reg->how != DWARF2_FRAME_REG_UNSPECIFIED
		&& retaddr_reg->how != DWARF2_FRAME_REG_SAME_VALUE)
	      {
		if (cache->reg[regnum].how == DWARF2_FRAME_REG_RA)
		  cache->reg[regnum] = *retaddr_reg;
		else
		  cache->retaddr_reg = *retaddr_reg;
	      }
	    else
	      {
		if (cache->reg[regnum].how == DWARF2_FRAME_REG_RA)
		  {
		    cache->reg[regnum].loc.reg = fs->retaddr_column;
		    cache->reg[regnum].how = DWARF2_FRAME_REG_SAVED_REG;
		  }
		else
		  {
		    cache->retaddr_reg.loc.reg = fs->retaddr_column;
		    cache->retaddr_reg.how = DWARF2_FRAME_REG_SAVED_REG;
		  }
	      }
	  }
      }
  }

  if (fs->retaddr_column < fs->regs.num_regs
      && fs->regs.reg[fs->retaddr_column].how == DWARF2_FRAME_REG_UNDEFINED)
    cache->undefined_retaddr = 1;

  do_cleanups (old_chain);

  /* Try to find a virtual tail call frames chain with bottom (callee) frame
     starting at THIS_FRAME.  */
  dwarf2_tailcall_sniffer_first (this_frame, &cache->tailcall_cache,
				 (entry_cfa_sp_offset_p
				  ? &entry_cfa_sp_offset : NULL));

  discard_cleanups (reset_cache_cleanup);
  return cache;
}

static enum unwind_stop_reason
dwarf2_frame_unwind_stop_reason (struct frame_info *this_frame,
				 void **this_cache)
{
  struct dwarf2_frame_cache *cache
    = dwarf2_frame_cache (this_frame, this_cache);

  if (cache->unavailable_retaddr)
    return UNWIND_UNAVAILABLE;

  if (cache->undefined_retaddr)
    return UNWIND_OUTERMOST;

  return UNWIND_NO_REASON;
}

static void
dwarf2_frame_this_id (struct frame_info *this_frame, void **this_cache,
		      struct frame_id *this_id)
{
  struct dwarf2_frame_cache *cache =
    dwarf2_frame_cache (this_frame, this_cache);

  if (cache->unavailable_retaddr)
    return;

  if (cache->undefined_retaddr)
    return;

  (*this_id) = frame_id_build (cache->cfa, get_frame_func (this_frame));
}

static struct value *
dwarf2_frame_prev_register (struct frame_info *this_frame, void **this_cache,
			    int regnum)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct dwarf2_frame_cache *cache =
    dwarf2_frame_cache (this_frame, this_cache);
  CORE_ADDR addr;
  int realnum;

  /* Non-bottom frames of a virtual tail call frames chain use
     dwarf2_tailcall_frame_unwind unwinder so this code does not apply for
     them.  If dwarf2_tailcall_prev_register_first does not have specific value
     unwind the register, tail call frames are assumed to have the register set
     of the top caller.  */
  if (cache->tailcall_cache)
    {
      struct value *val;
      
      val = dwarf2_tailcall_prev_register_first (this_frame,
						 &cache->tailcall_cache,
						 regnum);
      if (val)
	return val;
    }

  switch (cache->reg[regnum].how)
    {
    case DWARF2_FRAME_REG_UNDEFINED:
      /* If CFI explicitly specified that the value isn't defined,
	 mark it as optimized away; the value isn't available.  */
      return frame_unwind_got_optimized (this_frame, regnum);

    case DWARF2_FRAME_REG_SAVED_OFFSET:
      addr = cache->cfa + cache->reg[regnum].loc.offset;
      return frame_unwind_got_memory (this_frame, regnum, addr);

    case DWARF2_FRAME_REG_SAVED_REG:
      realnum
	= gdbarch_dwarf2_reg_to_regnum (gdbarch, cache->reg[regnum].loc.reg);
      return frame_unwind_got_register (this_frame, regnum, realnum);

    case DWARF2_FRAME_REG_SAVED_EXP:
      addr = execute_stack_op (cache->reg[regnum].loc.exp,
			       cache->reg[regnum].exp_len,
			       cache->addr_size, cache->text_offset,
			       this_frame, cache->cfa, 1);
      return frame_unwind_got_memory (this_frame, regnum, addr);

    case DWARF2_FRAME_REG_SAVED_VAL_OFFSET:
      addr = cache->cfa + cache->reg[regnum].loc.offset;
      return frame_unwind_got_constant (this_frame, regnum, addr);

    case DWARF2_FRAME_REG_SAVED_VAL_EXP:
      addr = execute_stack_op (cache->reg[regnum].loc.exp,
			       cache->reg[regnum].exp_len,
			       cache->addr_size, cache->text_offset,
			       this_frame, cache->cfa, 1);
      return frame_unwind_got_constant (this_frame, regnum, addr);

    case DWARF2_FRAME_REG_UNSPECIFIED:
      /* GCC, in its infinite wisdom decided to not provide unwind
	 information for registers that are "same value".  Since
	 DWARF2 (3 draft 7) doesn't define such behavior, said
	 registers are actually undefined (which is different to CFI
	 "undefined").  Code above issues a complaint about this.
	 Here just fudge the books, assume GCC, and that the value is
	 more inner on the stack.  */
      return frame_unwind_got_register (this_frame, regnum, regnum);

    case DWARF2_FRAME_REG_SAME_VALUE:
      return frame_unwind_got_register (this_frame, regnum, regnum);

    case DWARF2_FRAME_REG_CFA:
      return frame_unwind_got_address (this_frame, regnum, cache->cfa);

    case DWARF2_FRAME_REG_CFA_OFFSET:
      addr = cache->cfa + cache->reg[regnum].loc.offset;
      return frame_unwind_got_address (this_frame, regnum, addr);

    case DWARF2_FRAME_REG_RA_OFFSET:
      addr = cache->reg[regnum].loc.offset;
      regnum = gdbarch_dwarf2_reg_to_regnum
	(gdbarch, cache->retaddr_reg.loc.reg);
      addr += get_frame_register_unsigned (this_frame, regnum);
      return frame_unwind_got_address (this_frame, regnum, addr);

    case DWARF2_FRAME_REG_FN:
      return cache->reg[regnum].loc.fn (this_frame, this_cache, regnum);

    default:
      internal_error (__FILE__, __LINE__, _("Unknown register rule."));
    }
}

/* Proxy for tailcall_frame_dealloc_cache for bottom frame of a virtual tail
   call frames chain.  */

static void
dwarf2_frame_dealloc_cache (struct frame_info *self, void *this_cache)
{
  struct dwarf2_frame_cache *cache = dwarf2_frame_cache (self, &this_cache);

  if (cache->tailcall_cache)
    dwarf2_tailcall_frame_unwind.dealloc_cache (self, cache->tailcall_cache);
}

static int
dwarf2_frame_sniffer (const struct frame_unwind *self,
		      struct frame_info *this_frame, void **this_cache)
{
  /* Grab an address that is guarenteed to reside somewhere within the
     function.  get_frame_pc(), with a no-return next function, can
     end up returning something past the end of this function's body.
     If the frame we're sniffing for is a signal frame whose start
     address is placed on the stack by the OS, its FDE must
     extend one byte before its start address or we could potentially
     select the FDE of the previous function.  */
  CORE_ADDR block_addr = get_frame_address_in_block (this_frame);
  struct dwarf2_fde *fde = dwarf2_frame_find_fde (&block_addr, NULL);

  if (!fde)
    return 0;

  /* On some targets, signal trampolines may have unwind information.
     We need to recognize them so that we set the frame type
     correctly.  */

  if (fde->cie->signal_frame
      || dwarf2_frame_signal_frame_p (get_frame_arch (this_frame),
				      this_frame))
    return self->type == SIGTRAMP_FRAME;

  if (self->type != NORMAL_FRAME)
    return 0;

  /* Preinitializa the cache so that TAILCALL_FRAME can find the record by
     dwarf2_tailcall_sniffer_first.  */
  dwarf2_frame_cache (this_frame, this_cache);

  return 1;
}

static const struct frame_unwind dwarf2_frame_unwind =
{
  NORMAL_FRAME,
  dwarf2_frame_unwind_stop_reason,
  dwarf2_frame_this_id,
  dwarf2_frame_prev_register,
  NULL,
  dwarf2_frame_sniffer,
  dwarf2_frame_dealloc_cache
};

static const struct frame_unwind dwarf2_signal_frame_unwind =
{
  SIGTRAMP_FRAME,
  dwarf2_frame_unwind_stop_reason,
  dwarf2_frame_this_id,
  dwarf2_frame_prev_register,
  NULL,
  dwarf2_frame_sniffer,

  /* TAILCALL_CACHE can never be in such frame to need dealloc_cache.  */
  NULL
};

/* Append the DWARF-2 frame unwinders to GDBARCH's list.  */

void
dwarf2_append_unwinders (struct gdbarch *gdbarch)
{
  /* TAILCALL_FRAME must be first to find the record by
     dwarf2_tailcall_sniffer_first.  */
  frame_unwind_append_unwinder (gdbarch, &dwarf2_tailcall_frame_unwind);

  frame_unwind_append_unwinder (gdbarch, &dwarf2_frame_unwind);
  frame_unwind_append_unwinder (gdbarch, &dwarf2_signal_frame_unwind);
}


/* There is no explicitly defined relationship between the CFA and the
   location of frame's local variables and arguments/parameters.
   Therefore, frame base methods on this page should probably only be
   used as a last resort, just to avoid printing total garbage as a
   response to the "info frame" command.  */

static CORE_ADDR
dwarf2_frame_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct dwarf2_frame_cache *cache =
    dwarf2_frame_cache (this_frame, this_cache);

  return cache->cfa;
}

static const struct frame_base dwarf2_frame_base =
{
  &dwarf2_frame_unwind,
  dwarf2_frame_base_address,
  dwarf2_frame_base_address,
  dwarf2_frame_base_address
};

const struct frame_base *
dwarf2_frame_base_sniffer (struct frame_info *this_frame)
{
  CORE_ADDR block_addr = get_frame_address_in_block (this_frame);

  if (dwarf2_frame_find_fde (&block_addr, NULL))
    return &dwarf2_frame_base;

  return NULL;
}

/* Compute the CFA for THIS_FRAME, but only if THIS_FRAME came from
   the DWARF unwinder.  This is used to implement
   DW_OP_call_frame_cfa.  */

CORE_ADDR
dwarf2_frame_cfa (struct frame_info *this_frame)
{
  while (get_frame_type (this_frame) == INLINE_FRAME)
    this_frame = get_prev_frame (this_frame);
  /* This restriction could be lifted if other unwinders are known to
     compute the frame base in a way compatible with the DWARF
     unwinder.  */
  if (!frame_unwinder_is (this_frame, &dwarf2_frame_unwind)
      && !frame_unwinder_is (this_frame, &dwarf2_tailcall_frame_unwind))
    error (_("can't compute CFA for this frame"));
  if (get_frame_unwind_stop_reason (this_frame) == UNWIND_UNAVAILABLE)
    throw_error (NOT_AVAILABLE_ERROR,
		 _("can't compute CFA for this frame: "
		   "required registers or memory are unavailable"));
  return get_frame_base (this_frame);
}

const struct objfile_data *dwarf2_frame_objfile_data;

static unsigned int
read_1_byte (bfd *abfd, const gdb_byte *buf)
{
  return bfd_get_8 (abfd, buf);
}

static unsigned int
read_4_bytes (bfd *abfd, const gdb_byte *buf)
{
  return bfd_get_32 (abfd, buf);
}

static ULONGEST
read_8_bytes (bfd *abfd, const gdb_byte *buf)
{
  return bfd_get_64 (abfd, buf);
}

static ULONGEST
read_initial_length (bfd *abfd, const gdb_byte *buf,
		     unsigned int *bytes_read_ptr)
{
  LONGEST result;

  result = bfd_get_32 (abfd, buf);
  if (result == 0xffffffff)
    {
      result = bfd_get_64 (abfd, buf + 4);
      *bytes_read_ptr = 12;
    }
  else
    *bytes_read_ptr = 4;

  return result;
}


/* Pointer encoding helper functions.  */

/* GCC supports exception handling based on DWARF2 CFI.  However, for
   technical reasons, it encodes addresses in its FDE's in a different
   way.  Several "pointer encodings" are supported.  The encoding
   that's used for a particular FDE is determined by the 'R'
   augmentation in the associated CIE.  The argument of this
   augmentation is a single byte.  

   The address can be encoded as 2 bytes, 4 bytes, 8 bytes, or as a
   LEB128.  This is encoded in bits 0, 1 and 2.  Bit 3 encodes whether
   the address is signed or unsigned.  Bits 4, 5 and 6 encode how the
   address should be interpreted (absolute, relative to the current
   position in the FDE, ...).  Bit 7, indicates that the address
   should be dereferenced.  */

static gdb_byte
encoding_for_size (unsigned int size)
{
  switch (size)
    {
    case 2:
      return DW_EH_PE_udata2;
    case 4:
      return DW_EH_PE_udata4;
    case 8:
      return DW_EH_PE_udata8;
    default:
      internal_error (__FILE__, __LINE__, _("Unsupported address size"));
    }
}

static CORE_ADDR
read_encoded_value (struct comp_unit *unit, gdb_byte encoding,
		    int ptr_len, const gdb_byte *buf,
		    unsigned int *bytes_read_ptr,
		    CORE_ADDR func_base)
{
  ptrdiff_t offset;
  CORE_ADDR base;

  /* GCC currently doesn't generate DW_EH_PE_indirect encodings for
     FDE's.  */
  if (encoding & DW_EH_PE_indirect)
    internal_error (__FILE__, __LINE__, 
		    _("Unsupported encoding: DW_EH_PE_indirect"));

  *bytes_read_ptr = 0;

  switch (encoding & 0x70)
    {
    case DW_EH_PE_absptr:
      base = 0;
      break;
    case DW_EH_PE_pcrel:
      base = bfd_get_section_vma (unit->abfd, unit->dwarf_frame_section);
      base += (buf - unit->dwarf_frame_buffer);
      break;
    case DW_EH_PE_datarel:
      base = unit->dbase;
      break;
    case DW_EH_PE_textrel:
      base = unit->tbase;
      break;
    case DW_EH_PE_funcrel:
      base = func_base;
      break;
    case DW_EH_PE_aligned:
      base = 0;
      offset = buf - unit->dwarf_frame_buffer;
      if ((offset % ptr_len) != 0)
	{
	  *bytes_read_ptr = ptr_len - (offset % ptr_len);
	  buf += *bytes_read_ptr;
	}
      break;
    default:
      internal_error (__FILE__, __LINE__,
		      _("Invalid or unsupported encoding"));
    }

  if ((encoding & 0x07) == 0x00)
    {
      encoding |= encoding_for_size (ptr_len);
      if (bfd_get_sign_extend_vma (unit->abfd))
	encoding |= DW_EH_PE_signed;
    }

  switch (encoding & 0x0f)
    {
    case DW_EH_PE_uleb128:
      {
	uint64_t value;
	const gdb_byte *end_buf = buf + (sizeof (value) + 1) * 8 / 7;

	*bytes_read_ptr += safe_read_uleb128 (buf, end_buf, &value) - buf;
	return base + value;
      }
    case DW_EH_PE_udata2:
      *bytes_read_ptr += 2;
      return (base + bfd_get_16 (unit->abfd, (bfd_byte *) buf));
    case DW_EH_PE_udata4:
      *bytes_read_ptr += 4;
      return (base + bfd_get_32 (unit->abfd, (bfd_byte *) buf));
    case DW_EH_PE_udata8:
      *bytes_read_ptr += 8;
      return (base + bfd_get_64 (unit->abfd, (bfd_byte *) buf));
    case DW_EH_PE_sleb128:
      {
	int64_t value;
	const gdb_byte *end_buf = buf + (sizeof (value) + 1) * 8 / 7;

	*bytes_read_ptr += safe_read_sleb128 (buf, end_buf, &value) - buf;
	return base + value;
      }
    case DW_EH_PE_sdata2:
      *bytes_read_ptr += 2;
      return (base + bfd_get_signed_16 (unit->abfd, (bfd_byte *) buf));
    case DW_EH_PE_sdata4:
      *bytes_read_ptr += 4;
      return (base + bfd_get_signed_32 (unit->abfd, (bfd_byte *) buf));
    case DW_EH_PE_sdata8:
      *bytes_read_ptr += 8;
      return (base + bfd_get_signed_64 (unit->abfd, (bfd_byte *) buf));
    default:
      internal_error (__FILE__, __LINE__,
		      _("Invalid or unsupported encoding"));
    }
}


static int
bsearch_cie_cmp (const void *key, const void *element)
{
  ULONGEST cie_pointer = *(ULONGEST *) key;
  struct dwarf2_cie *cie = *(struct dwarf2_cie **) element;

  if (cie_pointer == cie->cie_pointer)
    return 0;

  return (cie_pointer < cie->cie_pointer) ? -1 : 1;
}

/* Find CIE with the given CIE_POINTER in CIE_TABLE.  */
static struct dwarf2_cie *
find_cie (struct dwarf2_cie_table *cie_table, ULONGEST cie_pointer)
{
  struct dwarf2_cie **p_cie;

  /* The C standard (ISO/IEC 9899:TC2) requires the BASE argument to
     bsearch be non-NULL.  */
  if (cie_table->entries == NULL)
    {
      gdb_assert (cie_table->num_entries == 0);
      return NULL;
    }

  p_cie = bsearch (&cie_pointer, cie_table->entries, cie_table->num_entries,
                   sizeof (cie_table->entries[0]), bsearch_cie_cmp);
  if (p_cie != NULL)
    return *p_cie;
  return NULL;
}

/* Add a pointer to new CIE to the CIE_TABLE, allocating space for it.  */
static void
add_cie (struct dwarf2_cie_table *cie_table, struct dwarf2_cie *cie)
{
  const int n = cie_table->num_entries;

  gdb_assert (n < 1
              || cie_table->entries[n - 1]->cie_pointer < cie->cie_pointer);

  cie_table->entries =
      xrealloc (cie_table->entries, (n + 1) * sizeof (cie_table->entries[0]));
  cie_table->entries[n] = cie;
  cie_table->num_entries = n + 1;
}

static int
bsearch_fde_cmp (const void *key, const void *element)
{
  CORE_ADDR seek_pc = *(CORE_ADDR *) key;
  struct dwarf2_fde *fde = *(struct dwarf2_fde **) element;

  if (seek_pc < fde->initial_location)
    return -1;
  if (seek_pc < fde->initial_location + fde->address_range)
    return 0;
  return 1;
}

/* Find the FDE for *PC.  Return a pointer to the FDE, and store the
   inital location associated with it into *PC.  */

static struct dwarf2_fde *
dwarf2_frame_find_fde (CORE_ADDR *pc, CORE_ADDR *out_offset)
{
  struct objfile *objfile;

  ALL_OBJFILES (objfile)
    {
      struct dwarf2_fde_table *fde_table;
      struct dwarf2_fde **p_fde;
      CORE_ADDR offset;
      CORE_ADDR seek_pc;

      fde_table = objfile_data (objfile, dwarf2_frame_objfile_data);
      if (fde_table == NULL)
	{
	  dwarf2_build_frame_info (objfile);
	  fde_table = objfile_data (objfile, dwarf2_frame_objfile_data);
	}
      gdb_assert (fde_table != NULL);

      if (fde_table->num_entries == 0)
	continue;

      gdb_assert (objfile->section_offsets);
      offset = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

      gdb_assert (fde_table->num_entries > 0);
      if (*pc < offset + fde_table->entries[0]->initial_location)
        continue;

      seek_pc = *pc - offset;
      p_fde = bsearch (&seek_pc, fde_table->entries, fde_table->num_entries,
                       sizeof (fde_table->entries[0]), bsearch_fde_cmp);
      if (p_fde != NULL)
        {
          *pc = (*p_fde)->initial_location + offset;
	  if (out_offset)
	    *out_offset = offset;
          return *p_fde;
        }
    }
  return NULL;
}

/* Add a pointer to new FDE to the FDE_TABLE, allocating space for it.  */
static void
add_fde (struct dwarf2_fde_table *fde_table, struct dwarf2_fde *fde)
{
  if (fde->address_range == 0)
    /* Discard useless FDEs.  */
    return;

  fde_table->num_entries += 1;
  fde_table->entries =
      xrealloc (fde_table->entries,
                fde_table->num_entries * sizeof (fde_table->entries[0]));
  fde_table->entries[fde_table->num_entries - 1] = fde;
}

#define DW64_CIE_ID 0xffffffffffffffffULL

/* Defines the type of eh_frames that are expected to be decoded: CIE, FDE
   or any of them.  */

enum eh_frame_type
{
  EH_CIE_TYPE_ID = 1 << 0,
  EH_FDE_TYPE_ID = 1 << 1,
  EH_CIE_OR_FDE_TYPE_ID = EH_CIE_TYPE_ID | EH_FDE_TYPE_ID
};

static const gdb_byte *decode_frame_entry (struct comp_unit *unit,
					   const gdb_byte *start,
					   int eh_frame_p,
					   struct dwarf2_cie_table *cie_table,
					   struct dwarf2_fde_table *fde_table,
					   enum eh_frame_type entry_type);

/* Decode the next CIE or FDE, entry_type specifies the expected type.
   Return NULL if invalid input, otherwise the next byte to be processed.  */

static const gdb_byte *
decode_frame_entry_1 (struct comp_unit *unit, const gdb_byte *start,
		      int eh_frame_p,
                      struct dwarf2_cie_table *cie_table,
                      struct dwarf2_fde_table *fde_table,
                      enum eh_frame_type entry_type)
{
  struct gdbarch *gdbarch = get_objfile_arch (unit->objfile);
  const gdb_byte *buf, *end;
  LONGEST length;
  unsigned int bytes_read;
  int dwarf64_p;
  ULONGEST cie_id;
  ULONGEST cie_pointer;
  int64_t sleb128;
  uint64_t uleb128;

  buf = start;
  length = read_initial_length (unit->abfd, buf, &bytes_read);
  buf += bytes_read;
  end = buf + length;

  /* Are we still within the section?  */
  if (end > unit->dwarf_frame_buffer + unit->dwarf_frame_size)
    return NULL;

  if (length == 0)
    return end;

  /* Distinguish between 32 and 64-bit encoded frame info.  */
  dwarf64_p = (bytes_read == 12);

  /* In a .eh_frame section, zero is used to distinguish CIEs from FDEs.  */
  if (eh_frame_p)
    cie_id = 0;
  else if (dwarf64_p)
    cie_id = DW64_CIE_ID;
  else
    cie_id = DW_CIE_ID;

  if (dwarf64_p)
    {
      cie_pointer = read_8_bytes (unit->abfd, buf);
      buf += 8;
    }
  else
    {
      cie_pointer = read_4_bytes (unit->abfd, buf);
      buf += 4;
    }

  if (cie_pointer == cie_id)
    {
      /* This is a CIE.  */
      struct dwarf2_cie *cie;
      char *augmentation;
      unsigned int cie_version;

      /* Check that a CIE was expected.  */
      if ((entry_type & EH_CIE_TYPE_ID) == 0)
	error (_("Found a CIE when not expecting it."));

      /* Record the offset into the .debug_frame section of this CIE.  */
      cie_pointer = start - unit->dwarf_frame_buffer;

      /* Check whether we've already read it.  */
      if (find_cie (cie_table, cie_pointer))
	return end;

      cie = (struct dwarf2_cie *)
	obstack_alloc (&unit->objfile->objfile_obstack,
		       sizeof (struct dwarf2_cie));
      cie->initial_instructions = NULL;
      cie->cie_pointer = cie_pointer;

      /* The encoding for FDE's in a normal .debug_frame section
         depends on the target address size.  */
      cie->encoding = DW_EH_PE_absptr;

      /* We'll determine the final value later, but we need to
	 initialize it conservatively.  */
      cie->signal_frame = 0;

      /* Check version number.  */
      cie_version = read_1_byte (unit->abfd, buf);
      if (cie_version != 1 && cie_version != 3 && cie_version != 4)
	return NULL;
      cie->version = cie_version;
      buf += 1;

      /* Interpret the interesting bits of the augmentation.  */
      cie->augmentation = augmentation = (char *) buf;
      buf += (strlen (augmentation) + 1);

      /* Ignore armcc augmentations.  We only use them for quirks,
	 and that doesn't happen until later.  */
      if (strncmp (augmentation, "armcc", 5) == 0)
	augmentation += strlen (augmentation);

      /* The GCC 2.x "eh" augmentation has a pointer immediately
         following the augmentation string, so it must be handled
         first.  */
      if (augmentation[0] == 'e' && augmentation[1] == 'h')
	{
	  /* Skip.  */
	  buf += gdbarch_ptr_bit (gdbarch) / TARGET_CHAR_BIT;
	  augmentation += 2;
	}

      if (cie->version >= 4)
	{
	  /* FIXME: check that this is the same as from the CU header.  */
	  cie->addr_size = read_1_byte (unit->abfd, buf);
	  ++buf;
	  cie->segment_size = read_1_byte (unit->abfd, buf);
	  ++buf;
	}
      else
	{
	  cie->addr_size = gdbarch_dwarf2_addr_size (gdbarch);
	  cie->segment_size = 0;
	}
      /* Address values in .eh_frame sections are defined to have the
	 target's pointer size.  Watchout: This breaks frame info for
	 targets with pointer size < address size, unless a .debug_frame
	 section exists as well.  */
      if (eh_frame_p)
	cie->ptr_size = gdbarch_ptr_bit (gdbarch) / TARGET_CHAR_BIT;
      else
	cie->ptr_size = cie->addr_size;

      buf = gdb_read_uleb128 (buf, end, &uleb128);
      if (buf == NULL)
	return NULL;
      cie->code_alignment_factor = uleb128;

      buf = gdb_read_sleb128 (buf, end, &sleb128);
      if (buf == NULL)
	return NULL;
      cie->data_alignment_factor = sleb128;

      if (cie_version == 1)
	{
	  cie->return_address_register = read_1_byte (unit->abfd, buf);
	  ++buf;
	}
      else
	{
	  buf = gdb_read_uleb128 (buf, end, &uleb128);
	  if (buf == NULL)
	    return NULL;
	  cie->return_address_register = uleb128;
	}

      cie->return_address_register
	= dwarf2_frame_adjust_regnum (gdbarch,
				      cie->return_address_register,
				      eh_frame_p);

      cie->saw_z_augmentation = (*augmentation == 'z');
      if (cie->saw_z_augmentation)
	{
	  uint64_t length;

	  buf = gdb_read_uleb128 (buf, end, &length);
	  if (buf == NULL)
	    return NULL;
	  cie->initial_instructions = buf + length;
	  augmentation++;
	}

      while (*augmentation)
	{
	  /* "L" indicates a byte showing how the LSDA pointer is encoded.  */
	  if (*augmentation == 'L')
	    {
	      /* Skip.  */
	      buf++;
	      augmentation++;
	    }

	  /* "R" indicates a byte indicating how FDE addresses are encoded.  */
	  else if (*augmentation == 'R')
	    {
	      cie->encoding = *buf++;
	      augmentation++;
	    }

	  /* "P" indicates a personality routine in the CIE augmentation.  */
	  else if (*augmentation == 'P')
	    {
	      /* Skip.  Avoid indirection since we throw away the result.  */
	      gdb_byte encoding = (*buf++) & ~DW_EH_PE_indirect;
	      read_encoded_value (unit, encoding, cie->ptr_size,
				  buf, &bytes_read, 0);
	      buf += bytes_read;
	      augmentation++;
	    }

	  /* "S" indicates a signal frame, such that the return
	     address must not be decremented to locate the call frame
	     info for the previous frame; it might even be the first
	     instruction of a function, so decrementing it would take
	     us to a different function.  */
	  else if (*augmentation == 'S')
	    {
	      cie->signal_frame = 1;
	      augmentation++;
	    }

	  /* Otherwise we have an unknown augmentation.  Assume that either
	     there is no augmentation data, or we saw a 'z' prefix.  */
	  else
	    {
	      if (cie->initial_instructions)
		buf = cie->initial_instructions;
	      break;
	    }
	}

      cie->initial_instructions = buf;
      cie->end = end;
      cie->unit = unit;

      add_cie (cie_table, cie);
    }
  else
    {
      /* This is a FDE.  */
      struct dwarf2_fde *fde;

      /* Check that an FDE was expected.  */
      if ((entry_type & EH_FDE_TYPE_ID) == 0)
	error (_("Found an FDE when not expecting it."));

      /* In an .eh_frame section, the CIE pointer is the delta between the
	 address within the FDE where the CIE pointer is stored and the
	 address of the CIE.  Convert it to an offset into the .eh_frame
	 section.  */
      if (eh_frame_p)
	{
	  cie_pointer = buf - unit->dwarf_frame_buffer - cie_pointer;
	  cie_pointer -= (dwarf64_p ? 8 : 4);
	}

      /* In either case, validate the result is still within the section.  */
      if (cie_pointer >= unit->dwarf_frame_size)
	return NULL;

      fde = (struct dwarf2_fde *)
	obstack_alloc (&unit->objfile->objfile_obstack,
		       sizeof (struct dwarf2_fde));
      fde->cie = find_cie (cie_table, cie_pointer);
      if (fde->cie == NULL)
	{
	  decode_frame_entry (unit, unit->dwarf_frame_buffer + cie_pointer,
			      eh_frame_p, cie_table, fde_table,
			      EH_CIE_TYPE_ID);
	  fde->cie = find_cie (cie_table, cie_pointer);
	}

      gdb_assert (fde->cie != NULL);

      fde->initial_location =
	read_encoded_value (unit, fde->cie->encoding, fde->cie->ptr_size,
			    buf, &bytes_read, 0);
      buf += bytes_read;

      fde->address_range =
	read_encoded_value (unit, fde->cie->encoding & 0x0f,
			    fde->cie->ptr_size, buf, &bytes_read, 0);
      buf += bytes_read;

      /* A 'z' augmentation in the CIE implies the presence of an
	 augmentation field in the FDE as well.  The only thing known
	 to be in here at present is the LSDA entry for EH.  So we
	 can skip the whole thing.  */
      if (fde->cie->saw_z_augmentation)
	{
	  uint64_t length;

	  buf = gdb_read_uleb128 (buf, end, &length);
	  if (buf == NULL)
	    return NULL;
	  buf += length;
	  if (buf > end)
	    return NULL;
	}

      fde->instructions = buf;
      fde->end = end;

      fde->eh_frame_p = eh_frame_p;

      add_fde (fde_table, fde);
    }

  return end;
}

/* Read a CIE or FDE in BUF and decode it. Entry_type specifies whether we
   expect an FDE or a CIE.  */

static const gdb_byte *
decode_frame_entry (struct comp_unit *unit, const gdb_byte *start,
		    int eh_frame_p,
                    struct dwarf2_cie_table *cie_table,
                    struct dwarf2_fde_table *fde_table,
                    enum eh_frame_type entry_type)
{
  enum { NONE, ALIGN4, ALIGN8, FAIL } workaround = NONE;
  const gdb_byte *ret;
  ptrdiff_t start_offset;

  while (1)
    {
      ret = decode_frame_entry_1 (unit, start, eh_frame_p,
				  cie_table, fde_table, entry_type);
      if (ret != NULL)
	break;

      /* We have corrupt input data of some form.  */

      /* ??? Try, weakly, to work around compiler/assembler/linker bugs
	 and mismatches wrt padding and alignment of debug sections.  */
      /* Note that there is no requirement in the standard for any
	 alignment at all in the frame unwind sections.  Testing for
	 alignment before trying to interpret data would be incorrect.

	 However, GCC traditionally arranged for frame sections to be
	 sized such that the FDE length and CIE fields happen to be
	 aligned (in theory, for performance).  This, unfortunately,
	 was done with .align directives, which had the side effect of
	 forcing the section to be aligned by the linker.

	 This becomes a problem when you have some other producer that
	 creates frame sections that are not as strictly aligned.  That
	 produces a hole in the frame info that gets filled by the 
	 linker with zeros.

	 The GCC behaviour is arguably a bug, but it's effectively now
	 part of the ABI, so we're now stuck with it, at least at the
	 object file level.  A smart linker may decide, in the process
	 of compressing duplicate CIE information, that it can rewrite
	 the entire output section without this extra padding.  */

      start_offset = start - unit->dwarf_frame_buffer;
      if (workaround < ALIGN4 && (start_offset & 3) != 0)
	{
	  start += 4 - (start_offset & 3);
	  workaround = ALIGN4;
	  continue;
	}
      if (workaround < ALIGN8 && (start_offset & 7) != 0)
	{
	  start += 8 - (start_offset & 7);
	  workaround = ALIGN8;
	  continue;
	}

      /* Nothing left to try.  Arrange to return as if we've consumed
	 the entire input section.  Hopefully we'll get valid info from
	 the other of .debug_frame/.eh_frame.  */
      workaround = FAIL;
      ret = unit->dwarf_frame_buffer + unit->dwarf_frame_size;
      break;
    }

  switch (workaround)
    {
    case NONE:
      break;

    case ALIGN4:
      complaint (&symfile_complaints, _("\
Corrupt data in %s:%s; align 4 workaround apparently succeeded"),
		 unit->dwarf_frame_section->owner->filename,
		 unit->dwarf_frame_section->name);
      break;

    case ALIGN8:
      complaint (&symfile_complaints, _("\
Corrupt data in %s:%s; align 8 workaround apparently succeeded"),
		 unit->dwarf_frame_section->owner->filename,
		 unit->dwarf_frame_section->name);
      break;

    default:
      complaint (&symfile_complaints,
		 _("Corrupt data in %s:%s"),
		 unit->dwarf_frame_section->owner->filename,
		 unit->dwarf_frame_section->name);
      break;
    }

  return ret;
}

static int
qsort_fde_cmp (const void *a, const void *b)
{
  struct dwarf2_fde *aa = *(struct dwarf2_fde **)a;
  struct dwarf2_fde *bb = *(struct dwarf2_fde **)b;

  if (aa->initial_location == bb->initial_location)
    {
      if (aa->address_range != bb->address_range
          && aa->eh_frame_p == 0 && bb->eh_frame_p == 0)
        /* Linker bug, e.g. gold/10400.
           Work around it by keeping stable sort order.  */
        return (a < b) ? -1 : 1;
      else
        /* Put eh_frame entries after debug_frame ones.  */
        return aa->eh_frame_p - bb->eh_frame_p;
    }

  return (aa->initial_location < bb->initial_location) ? -1 : 1;
}

void
dwarf2_build_frame_info (struct objfile *objfile)
{
  struct comp_unit *unit;
  const gdb_byte *frame_ptr;
  struct dwarf2_cie_table cie_table;
  struct dwarf2_fde_table fde_table;
  struct dwarf2_fde_table *fde_table2;
  volatile struct gdb_exception e;

  cie_table.num_entries = 0;
  cie_table.entries = NULL;

  fde_table.num_entries = 0;
  fde_table.entries = NULL;

  /* Build a minimal decoding of the DWARF2 compilation unit.  */
  unit = (struct comp_unit *) obstack_alloc (&objfile->objfile_obstack,
					     sizeof (struct comp_unit));
  unit->abfd = objfile->obfd;
  unit->objfile = objfile;
  unit->dbase = 0;
  unit->tbase = 0;

  if (objfile->separate_debug_objfile_backlink == NULL)
    {
      /* Do not read .eh_frame from separate file as they must be also
         present in the main file.  */
      dwarf2_get_section_info (objfile, DWARF2_EH_FRAME,
                               &unit->dwarf_frame_section,
                               &unit->dwarf_frame_buffer,
                               &unit->dwarf_frame_size);
      if (unit->dwarf_frame_size)
        {
          asection *got, *txt;

          /* FIXME: kettenis/20030602: This is the DW_EH_PE_datarel base
             that is used for the i386/amd64 target, which currently is
             the only target in GCC that supports/uses the
             DW_EH_PE_datarel encoding.  */
          got = bfd_get_section_by_name (unit->abfd, ".got");
          if (got)
            unit->dbase = got->vma;

          /* GCC emits the DW_EH_PE_textrel encoding type on sh and ia64
             so far.  */
          txt = bfd_get_section_by_name (unit->abfd, ".text");
          if (txt)
            unit->tbase = txt->vma;

	  TRY_CATCH (e, RETURN_MASK_ERROR)
	    {
	      frame_ptr = unit->dwarf_frame_buffer;
	      while (frame_ptr < unit->dwarf_frame_buffer + unit->dwarf_frame_size)
		frame_ptr = decode_frame_entry (unit, frame_ptr, 1,
						&cie_table, &fde_table,
						EH_CIE_OR_FDE_TYPE_ID);
	    }

	  if (e.reason < 0)
	    {
	      warning (_("skipping .eh_frame info of %s: %s"),
		       objfile_name (objfile), e.message);

	      if (fde_table.num_entries != 0)
		{
                  xfree (fde_table.entries);
		  fde_table.entries = NULL;
		  fde_table.num_entries = 0;
		}
	      /* The cie_table is discarded by the next if.  */
	    }

          if (cie_table.num_entries != 0)
            {
              /* Reinit cie_table: debug_frame has different CIEs.  */
              xfree (cie_table.entries);
              cie_table.num_entries = 0;
              cie_table.entries = NULL;
            }
        }
    }

  dwarf2_get_section_info (objfile, DWARF2_DEBUG_FRAME,
                           &unit->dwarf_frame_section,
                           &unit->dwarf_frame_buffer,
                           &unit->dwarf_frame_size);
  if (unit->dwarf_frame_size)
    {
      int num_old_fde_entries = fde_table.num_entries;

      TRY_CATCH (e, RETURN_MASK_ERROR)
	{
	  frame_ptr = unit->dwarf_frame_buffer;
	  while (frame_ptr < unit->dwarf_frame_buffer + unit->dwarf_frame_size)
	    frame_ptr = decode_frame_entry (unit, frame_ptr, 0,
					    &cie_table, &fde_table,
					    EH_CIE_OR_FDE_TYPE_ID);
	}
      if (e.reason < 0)
	{
	  warning (_("skipping .debug_frame info of %s: %s"),
		   objfile_name (objfile), e.message);

	  if (fde_table.num_entries != 0)
	    {
	      fde_table.num_entries = num_old_fde_entries;
	      if (num_old_fde_entries == 0)
		{
		  xfree (fde_table.entries);
		  fde_table.entries = NULL;
		}
	      else
		{
		  fde_table.entries = xrealloc (fde_table.entries,
						fde_table.num_entries *
						sizeof (fde_table.entries[0]));
		}
	    }
	  fde_table.num_entries = num_old_fde_entries;
	  /* The cie_table is discarded by the next if.  */
	}
    }

  /* Discard the cie_table, it is no longer needed.  */
  if (cie_table.num_entries != 0)
    {
      xfree (cie_table.entries);
      cie_table.entries = NULL;   /* Paranoia.  */
      cie_table.num_entries = 0;  /* Paranoia.  */
    }

  /* Copy fde_table to obstack: it is needed at runtime.  */
  fde_table2 = (struct dwarf2_fde_table *)
    obstack_alloc (&objfile->objfile_obstack, sizeof (*fde_table2));

  if (fde_table.num_entries == 0)
    {
      fde_table2->entries = NULL;
      fde_table2->num_entries = 0;
    }
  else
    {
      struct dwarf2_fde *fde_prev = NULL;
      struct dwarf2_fde *first_non_zero_fde = NULL;
      int i;

      /* Prepare FDE table for lookups.  */
      qsort (fde_table.entries, fde_table.num_entries,
             sizeof (fde_table.entries[0]), qsort_fde_cmp);

      /* Check for leftovers from --gc-sections.  The GNU linker sets
	 the relevant symbols to zero, but doesn't zero the FDE *end*
	 ranges because there's no relocation there.  It's (offset,
	 length), not (start, end).  On targets where address zero is
	 just another valid address this can be a problem, since the
	 FDEs appear to be non-empty in the output --- we could pick
	 out the wrong FDE.  To work around this, when overlaps are
	 detected, we prefer FDEs that do not start at zero.

	 Start by finding the first FDE with non-zero start.  Below
	 we'll discard all FDEs that start at zero and overlap this
	 one.  */
      for (i = 0; i < fde_table.num_entries; i++)
	{
	  struct dwarf2_fde *fde = fde_table.entries[i];

	  if (fde->initial_location != 0)
	    {
	      first_non_zero_fde = fde;
	      break;
	    }
	}

      /* Since we'll be doing bsearch, squeeze out identical (except
	 for eh_frame_p) fde entries so bsearch result is predictable.
	 Also discard leftovers from --gc-sections.  */
      fde_table2->num_entries = 0;
      for (i = 0; i < fde_table.num_entries; i++)
	{
	  struct dwarf2_fde *fde = fde_table.entries[i];

	  if (fde->initial_location == 0
	      && first_non_zero_fde != NULL
	      && (first_non_zero_fde->initial_location
		  < fde->initial_location + fde->address_range))
	    continue;

	  if (fde_prev != NULL
	      && fde_prev->initial_location == fde->initial_location)
	    continue;

	  obstack_grow (&objfile->objfile_obstack, &fde_table.entries[i],
			sizeof (fde_table.entries[0]));
	  ++fde_table2->num_entries;
	  fde_prev = fde;
	}
      fde_table2->entries = obstack_finish (&objfile->objfile_obstack);

      /* Discard the original fde_table.  */
      xfree (fde_table.entries);
    }

  set_objfile_data (objfile, dwarf2_frame_objfile_data, fde_table2);
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_dwarf2_frame (void);

void
_initialize_dwarf2_frame (void)
{
  dwarf2_frame_data = gdbarch_data_register_pre_init (dwarf2_frame_init);
  dwarf2_frame_objfile_data = register_objfile_data ();
}
@


1.145
log
@-Wpointer-sign: dwarf2-frame.c: Pass unsigned variable to safe_read_uleb128.

The 'bytes_read' change should be obvious.  As for the other hunk,
we're passing the address of the signed 'offset' to safe_read_uleb128,
which expects unsigned.  Fix it by passing the address of the unsigned
'utmp' instead, like already done on other spots in the file.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* dwarf2-frame.c (execute_cfa_program): Make 'bytes_read' local
	unsigned.  Pass 'tmp' to safe_read_uleb128 instead of the signed
	'offset', and adjust.
@
text
@d2309 1
a2309 1
		       objfile->name, e.message);
d2349 1
a2349 1
		   objfile->name, e.message);
@


1.144
log
@	* dwarf2-frame.c (struct comp_unit) <dwarf_frame_buffer>: Now
	const.
	* dwarf2read.c (struct dwarf2_section_info) <buffer>: Now const.
	(struct die_reader_specs) <buffer>: Likewise.
	(die_reader_func_ftype): Make 'info_ptr' const.
	(struct line_header) <include_dirs, statement_program_start,
	statement_program_end>: Now const.
	(struct file_entry) <name>: Likewise.
	(struct partial_die_info) <sibling>: Likewise.
	(struct dwarf_block) <data>: Likewise.
	(dwarf2_read_section): Remove cast.
	(dwarf2_get_section_info): Make 'bufp' const.
	(read_index_from_section): Constify.
	(dw2_get_file_names_reader): Make 'info_ptr' const.
	(dw2_get_primary_filename_reader): Likewise.
	(read_comp_unit_head): Make 'info_ptr' and return type const.
	(read_and_check_comp_unit_head, read_and_check_type_unit_head):
	Likewise.
	(read_abbrev_offset): Constify.
	(dwarf2_create_include_psymtab): Make 'name' const.
	(create_debug_types_hash_table): Update.
	(read_cutu_die_from_dwo): Make 'result_info_ptr' const.
	(init_cutu_and_read_dies, init_cutu_and_read_dies_no_follow):
	Constify.
	(process_psymtab_comp_unit_reader, build_type_psymtabs_reader)
	(load_partial_comp_unit_reader): Make 'info_ptr' const.
	(read_comp_units_from_section): Constify.
	(peek_abbrev_code, peek_die_abbrev, skip_children, skip_one_die)
	(locate_pdi_sibling, load_full_comp_unit_reader): Make 'info_ptr'
	const.
	(dwarf2_compute_name, setup_type_unit_groups): Constify.
	(create_dwo_debug_info_hash_table): Make 'info_ptr' const.
	(create_dwp_hash_table, dwarf2_ranges_read)
	(dwarf2_record_block_ranges): Constify.
	(read_die_and_children, read_die_and_siblings_1)
	(read_die_and_siblings): Make 'info_ptr' and 'new_info_ptr'
	const.
	(read_full_die_1, read_full_die): Make 'info_ptr' const.
	(abbrev_table_read_table): Constify.
	(load_partial_dies): Make 'info_ptr' const.
	(read_partial_die, read_attribute_value, read_attribute): Make
	'info_ptr' and return type const.
	(read_address, read_initial_length)
	(read_checked_initial_length_and_offset, read_offset)
	(read_offset_1, read_n_bytes, read_direct_string): Make 'buf'
	const.
	(read_direct_string): Make 'buf' and return type const.
	(read_indirect_string_at_offset, read_indirect_string_from_dwz)
	(read_indirect_string): Make return type const.
	(read_unsigned_leb128, read_signed_leb128): Make 'buf' const.
	(read_addr_index_from_leb128, dwarf2_read_addr_index_reader): Make
	'info_ptr' const.
	(read_str_index): Make return type const.
	(add_include_dir): Make 'include_dir' const.
	(add_file_name): Make 'name' const.
	(dwarf_decode_line_header): Constify.
	(psymtab_include_file_name): Make return type const.
	(dwarf_decode_lines_1, dwarf_decode_lines): Constify.
	(dwarf2_start_subfile): Make 'filename' const.
	(dwarf2_const_value_attr): Make 'bytes' const.
	(read_signatured_type_reader): Make 'info_ptr' const.
	(decode_locdesc): Constify.
	(skip_form_bytes): Make 'bytes', 'buffer_end', and return type
	const.
	(skip_unknown_opcode): Make 'opcode_definitions', 'mac_ptr',
	'mac_end', and return type const.
	(dwarf_parse_macro_header): Make 'mac_ptr' and return type const.
	(dwarf_decode_macro_bytes): Make 'mac_ptr', 'mac_end', and return
	type const.
	(per_cu_header_read_in): Constify.
	* symfile.h (dwarf2_get_section_info): Update.
@
text
@d413 1
a413 1
  int bytes_read;
d675 2
a676 2
	      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &offset);
	      offset *= fs->data_align;
@


1.143
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

        * dwarf2-frame.c (dwarf2_compile_cfa_to_ax): Remove unused num_regs.
        * symtab.c (iterate_over_symtabs): Remove unused s.
        (find_pc_sect_symtab): Remove unused pspAce.
        (find_pc_sect_line): Remove unused alt_symtab.
        (find_pcs_for_symtab_line): Remove unused ix, previous_function.
        (completion_list_add_name): Remove unused newsize.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00764.html
@
text
@d144 1
a144 1
  gdb_byte *dwarf_frame_buffer;
@


1.142
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a890 2
  const int num_regs = gdbarch_num_regs (gdbarch)
		       + gdbarch_num_pseudo_regs (gdbarch);
@


1.141
log
@gdb/
	* configure.ac (CC_HAS_LONG_LONG): Replace by AC_MSG_ERROR.
	* defs.h (LONGEST, ULONGEST): Remove conditionalization for
	CC_HAS_LONG_LONG.
	* dwarf2-frame.c (DW64_CIE_ID): Likewise.
	* dwarf2read.c (extract_cu_value): Remove the function.
	(create_cus_from_index_list): Make the return type void, inline the
	extract_cu_value caller, include new gdb_static_assert.
	(create_cus_from_index): Make the return type void, update the function
	comment, update the create_cus_from_index_list caller.
	(create_signatured_type_table_from_index): Make the return type void,
	inline the extract_cu_value caller, include new gdb_static_assert.
	(dwarf2_read_index): Update the create_cus_from_index and
	create_signatured_type_table_from_index caller.
	* printcmd.c (ui_printf): Remove conditionalizations for
	CC_HAS_LONG_LONG.
	* config.in: Regenerate.
	* configure: Regenerate.

gdb/doc/
	* gdbint.texinfo (Host Definition): Remove CC_HAS_LONG_LONG.
@
text
@d3 1
a3 1
   Copyright (C) 2003-2005, 2007-2012 Free Software Foundation, Inc.
@


1.140
log
@DWARF frame unwinder executes one too many rows

The problem is trying to unwind from a function where %ebp is NOT
used as the frame pointer, and the size of the frame changes over
the lifetime of that function.

For instance, trying to unwind past the GNAT runtime function
called system.tasking.rendezvous.timed_selective_wait on x86-linux,
one can get:

    (gdb) bt
    [...]
    #3  0x0805364b in system.tasking.rendezvous.timed_selective_wait ()
    #4  0xb7fe5068 in ?? ()
    Backtrace stopped: previous frame inner to this frame (corrupt stack?)

Looking at the CFI, we find the following initial instructions...

>   DW_CFA_def_cfa: %esp+4 (r4 ofs 4)
>   DW_CFA_offset: %eip at cfa-4  (r8 = %eip)

... and the associated FDE:

> 00001be4 00000054 00001be8 FDE cie=00000000 pc=08053310..08053951
[...]
>   DW_CFA_advance_loc: 8 to 080534ad
>   DW_CFA_def_cfa_offset: 112
>   DW_CFA_advance_loc2: 414 to 0805364b
>   DW_CFA_def_cfa_offset: 108
[...]

The problem is that the DWARF frame unwinder executed the FDE until
the row for PC == 0x0805364b. But in reality, our program hasn't
executed the instruction at that address yet (it is the return address).
So GDB executed a little too much of the FDE, giving us the wrong
offset for the frame base, and thus the wrong address where %eip
got saved.

This patch fixes the problem by using a more correct PC as the bound
for executing the FDE.

gdb/ChangeLog:

        * dwarf2-frame.c (dwarf2_frame_cache): Use
        get_frame_address_in_block instead of get_frame_pc as
        the bound for executing the frame's FDE.

gdb/testsuite/ChangeLog:

        * gdb.ada/rdv_wait: New testcase.
@
text
@a1807 1
#ifdef CC_HAS_LONG_LONG
a1808 3
#else
#define DW64_CIE_ID ~0
#endif
@


1.139
log
@	* dwarf2-frame.c (clear_pointer_cleanup): New function.
	(dwarf2_frame_cache): Use it.
	* frame-unwind.h (frame_sniffer_ftype): Document prologue
	cache initialization constraint.
@
text
@d1068 2
a1069 1
		       fde->cie->end, gdbarch, get_frame_pc (this_frame), fs);
d1094 1
a1094 1
		       get_frame_pc (this_frame), fs);
@


1.138
log
@	* dwarf2-frame.c (dwarf2_frame_cache): Call do_cleanups before
	return.
@
text
@d997 10
d1010 1
a1010 1
  struct cleanup *old_chain;
d1030 1
d1125 1
d1241 1
@


1.137
log
@	* dwarf2-frame.c (execute_cfa_program): Update to handle long long ->
	int64_t change to leb128 API.
	(read_encoded_value, decode_frame_entry_1): Ditto.
	* dwarf2expr.c (safe_read_uleb128, safe_read_sleb128): Ditto.
	(dwarf_block_to_dwarf_reg, dwarf_block_to_dwarf_reg_deref): Ditto.
	(dwarf_block_to_fb_offset, dwarf_block_to_sp_offset): Ditto.
	(execute_stack_op): Ditto.
	* dwarf2expr.h (gdb_read_uleb128, gdb_read_sleb128): Ditto.
	(safe_read_uleb128, safe_read_sleb128): Ditto.
	* dwarf2loc.c (decode_debug_loc_dwo_addresses): Ditto.
	(dwarf2_compile_expr_to_ax): Ditto.
	(locexpr_describe_location_piece): Ditto.
	(disassemble_dwarf_expression): Ditto.
	(locexpr_describe_location_1): Ditto.
@
text
@d1113 1
@


1.137.2.1
log
@	* dwarf2-frame.c (dwarf2_frame_cache): Call do_cleanups before
	return.
@
text
@a1112 1
	  do_cleanups (old_chain);
@


1.137.2.2
log
@	* dwarf2-frame.c (clear_pointer_cleanup): New function.
	(dwarf2_frame_cache): Use it.
	* frame-unwind.h (frame_sniffer_ftype): Document prologue
	cache initialization constraint.
@
text
@a996 10
/* A cleanup that sets a pointer to NULL.  */

static void
clear_pointer_cleanup (void *arg)
{
  void **ptr = arg;

  *ptr = NULL;
}

d1000 1
a1000 1
  struct cleanup *reset_cache_cleanup, *old_chain;
a1019 1
  reset_cache_cleanup = make_cleanup (clear_pointer_cleanup, this_cache);
a1113 1
	  discard_cleanups (reset_cache_cleanup);
a1228 1
  discard_cleanups (reset_cache_cleanup);
@


1.136
log
@	* dwarf2-frame.c (struct dwarf2_cie): Make initial_instructions, end
	"const gdb_byte *".
	(struct dwarf2_fde): Make instructions, end "const gdb_byte *".
	(execute_cfa_program): Update to match API of leb128 functions.
	(read_1_byte, read_4_bytes, read_8_bytes): Make buf parameter
	"const gdb_byte *".
	(read_unsigned_leb128, read_signed_leb128): Delete.
	(read_initial_length): Change type of buf argument to
	"const gdb_byte *".
	(read_encoded_value): Update to match API of leb128 functions.
	(decode_frame_entry): Change result to "const gdb_byte *", and
	similarly for "start" parameter.
	(decode_frame_entry_1): Ditto.  Use new leb128 reader functions.
	(dwarf2_build_frame_info): Change local frame_ptr to
	"const gdb_byte *".
	* dwarf2expr.c (safe_read_uleb128, safe_read_sleb128): Replaces
	read_uleb128, read_sleb128.  All callers updated.
	(safe_skip_leb128): New function.
	(dwarf_block_to_dwarf_reg): Update to match API of leb128 functions.
	Call gdb_read_uleb128, gdb_skip_leb128 instead of read_uleb128.
	(dwarf_block_to_dwarf_reg_deref): Update to match API of leb128
	functions.  Call gdb_read_uleb128, gdb_read_sleb128 instead of
	read_uleb128, read_sleb128.
	(dwarf_block_to_fb_offset, dwarf_block_to_sp_offset): Ditto.
	(execute_stack_op): Update to match API of leb128 functions.
	* dwarf2expr.h: #include "leb128.h".
	(read_uleb128, read_sleb128): Delete.
	(gdb_read_uleb128, gdb_read_sleb128, gdb_skip_leb128): New functions.
	(safe_read_uleb128, safe_read_sleb128, safe_skip_leb128): Declare.
	* dwarf2loc.c (debug_loc_kind): New enum.
	(decode_debug_loc_addresses): New function.
	(decode_debug_loc_dwo_addresses): New function.
	(dwarf2_find_location_expression): Rewrite.
	(dwarf2_compile_expr_to_ax): Update to match API of leb128 functions.
	(locexpr_describe_location_piece): Ditto.
	(disassemble_dwarf_expression): Ditto.
	(locexpr_describe_location_1): Ditto.
	(loclist_describe_location): Rewrite.
	* dwarf2loc.h (dwarf2_loclist_baton): New member "from_dwo".
	* dwarf2read.c (die_reader_specs): New member "buffer_end".
	(dwarf2_section_buffer_overflow_complaint): Renamed from
	dwarf2_macros_too_long_complaint.  All callers updated.
	(skip_leb128): Delete.
	(init_cu_die_reader): Initialize reader->buffer_end.
	(skip_one_die): Replace call to skip_leb128 with safe_skip_leb128.
	(skip_form_bytes): New arg buffer_end.  All callers updated.
	Replace call to skip_leb128 with gdb_skip_leb128.
	(skip_unknown_opcode): New arg mac_end.  All callers updated.
	(fill_in_loclist_baton): Initialize baton->from_dwo.
@
text
@d419 2
a420 2
      unsigned long long utmp, reg;
      long long offset;
d1631 1
a1631 1
	unsigned long long value;
d1648 1
a1648 1
	long long value;
d1833 2
a1834 2
  long long sleb128;
  unsigned long long uleb128;
d1981 1
a1981 1
	  unsigned long long length;
d2098 1
a2098 1
	  unsigned long long length;
@


1.135
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d71 2
a72 2
  gdb_byte *initial_instructions;
  gdb_byte *end;
d119 2
a120 2
  gdb_byte *instructions;
  gdb_byte *end;
d419 2
a420 2
      ULONGEST utmp, reg;
      LONGEST offset;
d428 1
a428 1
	  insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
d470 1
a470 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
d472 1
a472 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
d480 1
a480 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
d485 1
a485 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
d492 1
a492 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
d499 1
a499 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
d501 1
a501 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
d539 3
a541 2
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &fs->regs.cfa_reg);
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
d551 2
a552 3
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &fs->regs.cfa_reg);
	      fs->regs.cfa_reg = dwarf2_frame_adjust_regnum (gdbarch,
                                                             fs->regs.cfa_reg,
d558 1
a558 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
d571 2
a572 2
	      insn_ptr = read_uleb128 (insn_ptr, insn_end,
                                       &fs->regs.cfa_exp_len);
d579 1
a579 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
d582 1
a582 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
d590 1
a590 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
d592 1
a592 1
	      insn_ptr = read_sleb128 (insn_ptr, insn_end, &offset);
d600 1
a600 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
d602 1
a602 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
d609 1
a609 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
d611 1
a611 1
	      insn_ptr = read_sleb128 (insn_ptr, insn_end, &offset);
d618 1
a618 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
d620 1
a620 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
d628 2
a629 3
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &fs->regs.cfa_reg);
	      fs->regs.cfa_reg = dwarf2_frame_adjust_regnum (gdbarch,
                                                             fs->regs.cfa_reg,
d631 1
a631 1
	      insn_ptr = read_sleb128 (insn_ptr, insn_end, &offset);
d637 1
a637 1
	      insn_ptr = read_sleb128 (insn_ptr, insn_end, &offset);
d669 1
a669 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
d673 1
a673 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
d675 1
a675 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &offset);
d1503 1
a1503 1
read_1_byte (bfd *abfd, gdb_byte *buf)
d1509 1
a1509 1
read_4_bytes (bfd *abfd, gdb_byte *buf)
d1515 1
a1515 1
read_8_bytes (bfd *abfd, gdb_byte *buf)
d1521 2
a1522 58
read_unsigned_leb128 (bfd *abfd, gdb_byte *buf, unsigned int *bytes_read_ptr)
{
  ULONGEST result;
  unsigned int num_read;
  int shift;
  gdb_byte byte;

  result = 0;
  shift = 0;
  num_read = 0;

  do
    {
      byte = bfd_get_8 (abfd, (bfd_byte *) buf);
      buf++;
      num_read++;
      result |= ((byte & 0x7f) << shift);
      shift += 7;
    }
  while (byte & 0x80);

  *bytes_read_ptr = num_read;

  return result;
}

static LONGEST
read_signed_leb128 (bfd *abfd, gdb_byte *buf, unsigned int *bytes_read_ptr)
{
  LONGEST result;
  int shift;
  unsigned int num_read;
  gdb_byte byte;

  result = 0;
  shift = 0;
  num_read = 0;

  do
    {
      byte = bfd_get_8 (abfd, (bfd_byte *) buf);
      buf++;
      num_read++;
      result |= ((byte & 0x7f) << shift);
      shift += 7;
    }
  while (byte & 0x80);

  if (shift < 8 * sizeof (result) && (byte & 0x40))
    result |= -(((LONGEST)1) << shift);

  *bytes_read_ptr = num_read;

  return result;
}

static ULONGEST
read_initial_length (bfd *abfd, gdb_byte *buf, unsigned int *bytes_read_ptr)
d1631 1
a1631 1
	ULONGEST value;
d1634 1
a1634 1
	*bytes_read_ptr += read_uleb128 (buf, end_buf, &value) - buf;
d1648 1
a1648 1
	LONGEST value;
d1651 1
a1651 1
	*bytes_read_ptr += read_sleb128 (buf, end_buf, &value) - buf;
d1809 6
a1814 5
static gdb_byte *decode_frame_entry (struct comp_unit *unit, gdb_byte *start,
				     int eh_frame_p,
                                     struct dwarf2_cie_table *cie_table,
                                     struct dwarf2_fde_table *fde_table,
                                     enum eh_frame_type entry_type);
d1819 3
a1821 2
static gdb_byte *
decode_frame_entry_1 (struct comp_unit *unit, gdb_byte *start, int eh_frame_p,
d1827 1
a1827 1
  gdb_byte *buf, *end;
d1833 2
d1950 4
a1953 3
      cie->code_alignment_factor =
	read_unsigned_leb128 (unit->abfd, buf, &bytes_read);
      buf += bytes_read;
d1955 4
a1958 3
      cie->data_alignment_factor =
	read_signed_leb128 (unit->abfd, buf, &bytes_read);
      buf += bytes_read;
d1963 1
a1963 1
	  bytes_read = 1;
d1966 7
a1972 2
	cie->return_address_register = read_unsigned_leb128 (unit->abfd, buf,
							     &bytes_read);
a1977 2
      buf += bytes_read;

d1981 1
a1981 1
	  ULONGEST length;
d1983 2
a1984 3
	  length = read_unsigned_leb128 (unit->abfd, buf, &bytes_read);
	  buf += bytes_read;
	  if (buf > end)
d2098 1
a2098 1
	  ULONGEST length;
d2100 4
a2103 2
	  length = read_unsigned_leb128 (unit->abfd, buf, &bytes_read);
	  buf += bytes_read + length;
d2122 3
a2124 2
static gdb_byte *
decode_frame_entry (struct comp_unit *unit, gdb_byte *start, int eh_frame_p,
d2130 1
a2130 1
  gdb_byte *ret;
d2242 1
a2242 1
  gdb_byte *frame_ptr;
@


1.134
log
@	Initial support for Fission.  http://gcc.gnu.org/wiki/DebugFission
	* symfile.c (default_symfile_relocate): Use sectp->owner instead of
	objfile->obfd.
	* symfile.h (dwarf2_debug_sections): New member addr.
	* dwarf2expr.c (execute_stack_op): New case DW_OP_GNU_addr_index.
	(ctx_no_get_addr_index): New function.
	* dwarf2expr.h (dwarf_expr_context_funcs): New member get_addr_index.
	(ctx_no_get_addr_index): Declare.
	* dwarf2-frame.c (dwarf2_frame_ctx_funcs): Update.
	* dwarf2loc.c (dwarf_expr_get_addr_index): New function.
	(dwarf_expr_ctx_funcs): Update.
	(needs_get_addr_index): New function.
	(needs_frame_ctx_funcs): Update.
	* dwarf2loc.h (dwarf2_read_addr_index): Declare.
	* dwarf2read.c: #include "gdbcore.h".
	(dwarf2_per_objfile): New members addr, dwo_files.
	(dwarf2_elf_names): Add entry for addr.
	(struct dwo_section_names): New type.
	(dwo_section_names): New static global.
	(dwarf2_cu): New members dwo_unit, addr_base, have_addr_base.
	(dwarf2_per_cu_data): New member is_debug_types, all boolean uses of
	old debug_types_section member updated to use this.
	Rename member debug_types_section to info_or_types_section,
	all uses updated.
	(signatured_type): Rename member type_offset to type_offset_in_tu,
	all uses updated.  New member type_offset_in_section.
	(struct dwo_sections): New type.
	(struct dwo_unit): New type.
	(struct dwo_file): New type.
	(die_reader_specs): New member dwo_file.
	(dwarf2_locate_sections): Watch for .debug_addr.
	(zlib_decompress_section): Use sectp->owner instead of objfile->obfd.
	(dwarf2_read_section): Get bfd of section from bfd's asection,
	instead of objfile.
	(create_cus_from_index): Initialize the_cu->info_or_types_section.
	(create_signatured_type_table_from_index): Initialize
	sig_type->info_or_types_section.
	(dw2_get_file_names): Statement lists for type units with DWO files
	live in the DWO file.
	(create_debug_types_hash_table): New function.
	(create_all_type_units): Rewrite.
	(init_cu_die_reader): New arg dwo_file, all callers updated.
	(init_and_read_dies_worker): Get section from
	this_cu->info_or_types_section.  Set sig_type->type_offset_in_section.
	Watch for DW_AT_GNU_dwo_name and if present lookup the file and
	continue reading the CU/TU from there.
	(init_cutu_and_read_dies_no_follow): New arg dwo_file, all callers
	updated.  Get section from this_cu->info_or_types_section.
	(create_all_comp_units): Initialize this_cu->info_or_types_section.
	(skip_one_die): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(hash_dwo_file, eq_dwo_file): New functions.
	(allocate_dwo_file_hash_table): New function.
	(hash_dwo_unit, eq_dwo_unit): New functions.
	(allocate_dwo_unit_table): New function.
	(dwarf2_locate_dwo_sections): New function.
	(struct create_dwo_info_table_data): New type.
	(create_debug_info_hash_table_reader): New function.
	(create_debug_info_hash_table): New function.
	(try_open_dwo_file, open_dwo_file, init_dwo_file): New function.
	(lookup_dwo_file): New function.
	(lookup_dwo_comp_unit, lookup_dwo_type_unit): New functions.
	(free_dwo_file, free_dwo_file_cleanup): New functions.
	(free_dwo_file_from_slot, free_dwo_files): New functions.
	(dwarf2_get_pc_bounds): Handle DW_FORM_GNU_addr_index.
	(dwarf2_record_block_ranges): Ditto.
	(read_partial_die): Ditto.
	(process_enumeration_scope): Update to use type_offset_in_section.
	(read_full_die_1): New function.
	(read_full_die): Rewrite.
	(read_attribute_value): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(read_addr_index_1, read_addr_index): New functions.
	(read_addr_index_from_leb128): New function.
	(struct dwarf2_read_addr_index_data): New type.
	(dwarf2_read_addr_index_reader): New function.
	(dwarf2_read_addr_index): New function.
	(read_str_index): New function.
	(leb128_size): New function.
	(dwarf_decode_line_header): Delete arg abfd, all callers updated.
	If processing a type unit from a DWO file, get the line section
	from the DWO file.
	(var_decode_location): Watch for DW_OP_GNU_addr_index.
	(dwarf2_const_value_attr): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(lookup_die_type): Check whether section offset of type's die is
	known before looking it up.  Remove assert.  Condition can
	legimately happen for inter-cu type references.
	(dwarf_attr_name): Handle Fission attributes.
	(dwarf_form_name): Handle Fission forms.
	(dump_die_shallow): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(follow_die_sig): Update to use type_offset_in_section.
	(decode_locdesc): New case DW_OP_GNU_addr_index.
	(skip_form_bytes): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(cu_debug_loc_section): New function.
	(fill_in_loclist_baton, dwarf2_symbol_mark_computed): Call it.
	(dwarf2_per_objfile_free): Unmap .debug_addr section.
	Free DWO files if present.
	* xcoffread.c (dwarf2_xcoff_names): Add .debug_addr.

	testsuite/
	* gdb.dwarf2/dw2-intercu.S (.Ltype_int2_in_cu2): Renamed from
	.Ltype_int_in_cu2.  Use name "int2" instead of "int".
	All uses updated.
	* gdb.dwarf2/dw2-intercu.exp: Add "ptype int2" ahead of
	"ptype func_cu1" to expand cu2 before cu1.
@
text
@d895 1
a895 1
  CORE_ADDR text_offset, cfa;
@


1.133
log
@2012-01-17  Pedro Alves  <palves@@redhat.com>

	* dwarf2-frame.c (dwarf2_frame_cfa): Throw NOT_AVAILABLE_ERROR, if
	the frame's stop reason is UNWIND_UNAVAILABLE.
@
text
@d357 2
a358 1
  ctx_no_push_dwarf_reg_entry_value
@


1.132
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1493 4
@


1.131
log
@gdb/
	Recognize virtual tail call frames.
	* Makefile.in (SFILES): Add dwarf2-frame-tailcall.c.
	(HFILES_NO_SRCDIR): Add dwarf2-frame-tailcall.h.
	(COMMON_OBS): Add dwarf2-frame-tailcall.o.
	* dwarf2-frame-tailcall.c: New file.
	* dwarf2-frame-tailcall.h: New file.
	* dwarf2-frame.c: Include dwarf2-frame-tailcall.h.
	(execute_cfa_program): New function comment.  Return INSN_PTR.  Reset
	REGS.PREV only after CIE execution.
	(struct dwarf2_frame_cache): New field tailcall_cache.
	(dwarf2_frame_cache): New variables entry_pc, entry_cfa_sp_offset,
	entry_cfa_sp_offset_p and instr.  Execute FDE instructions in two
	parts, try to find entry_cfa_sp_offset.  Call
	dwarf2_tailcall_sniffer_first.
	(dwarf2_frame_prev_register): Call dwarf2_tailcall_prev_register_first
	when appropriate.
	(dwarf2_frame_dealloc_cache): New function.
	(dwarf2_frame_sniffer): Preinitialize cache by dwarf2_frame_cache.
	(dwarf2_frame_unwind): Install dwarf2_frame_dealloc_cache.
	(dwarf2_signal_frame_unwind): Do not install dwarf2_frame_dealloc_cache.
	(dwarf2_append_unwinders): Add dwarf2_tailcall_frame_unwind.
	(dwarf2_frame_cfa): Support also dwarf2_tailcall_frame_unwind.
	* dwarf2loc.c (func_addr_to_tail_call_list)
	(tailcall_dump, call_sitep, VEC (call_sitep), chain_candidate)
	(call_site_find_chain_1, call_site_find_chain): New.
	* dwarf2loc.h (struct call_site_chain): New.
	(call_site_find_chain): New declaration.
	* frame.c (get_frame_address_in_block): Support also TAILCALL_FRAME.
	* frame.h (enum frame_type): New entry TAILCALL_FRAME.
	* python/py-frame.c (gdbpy_initialize_frames): Add TAILCALL_FRAME.
	* stack.c (frame_info): Support also TAILCALL_FRAME.

gdb/doc/
	Recognize virtual tail call frames.
	* gdb.texinfo (Optimized Code): Add reference to Tail Call Frames.
	(Tail Call Frames): New node.
	(Frames In Python): Add gdb.TAILCALL_FRAME.

gdb/testsuite/
	Recognize virtual tail call frames.
	* gdb.arch/amd64-entry-value.cc (c, a, b, amb_z, amb_y, amb_x, amb)
	(amb_b, amb_a): New.
	(main): Call a and b.
	* gdb.arch/amd64-entry-value.exp (tailcall: breakhere, tailcall: bt)
	(tailcall: p i, tailcall: p j, set $sp0=$sp, up, p $sp0 == $sp, frame 3)
	(p $sp0 + sizeof (void *) == $sp, ambiguous: breakhere, ambiguous: bt):
	New tests.
@
text
@d3 1
a3 2
   Copyright (C) 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.131.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2003-2005, 2007-2012 Free Software Foundation, Inc.
@


1.130
log
@gdb/
	Implement basic support for DW_TAG_GNU_call_site.
	* block.c: Include gdbtypes.h and exceptions.h.
	(call_site_for_pc): New function.
	* block.h (call_site_for_pc): New declaration.
	* defs.h: Include hashtab.h.
	(make_cleanup_htab_delete, core_addr_hash, core_addr_eq): New
	declarations.
	* dwarf2-frame.c (dwarf2_frame_ctx_funcs): Install
	ctx_no_push_dwarf_reg_entry_value.
	* dwarf2expr.c (read_uleb128, read_sleb128): Support R as NULL.
	(dwarf_block_to_dwarf_reg): New function.
	(execute_stack_op) <DW_OP_GNU_entry_value>: Implement it.
	(ctx_no_push_dwarf_reg_entry_value): New function.
	* dwarf2expr.h (struct dwarf_expr_context_funcs): New field
	push_dwarf_reg_entry_value.
	(ctx_no_push_dwarf_reg_entry_value, dwarf_block_to_dwarf_reg): New
	declarations.
	* dwarf2loc.c: Include gdbcmd.h.
	(dwarf_expr_ctx_funcs): New forward declaration.
	(entry_values_debug, show_entry_values_debug, call_site_to_target_addr)
	(dwarf_expr_reg_to_entry_parameter)
	(dwarf_expr_push_dwarf_reg_entry_value): New.
	(dwarf_expr_ctx_funcs): Install dwarf_expr_push_dwarf_reg_entry_value.
	(dwarf2_evaluate_loc_desc_full): Handle NO_ENTRY_VALUE_ERROR.
	(needs_dwarf_reg_entry_value): New function.
	(needs_frame_ctx_funcs): Install it.
	(_initialize_dwarf2loc): New function.
	* dwarf2loc.h (entry_values_debug): New declaration.
	* dwarf2read.c (struct dwarf2_cu): New field call_site_htab.
	(read_call_site_scope): New forward declaration.
	(process_full_comp_unit): Copy call_site_htab.
	(process_die): Support DW_TAG_GNU_call_site.
	(read_call_site_scope): New function.
	(dwarf2_get_pc_bounds): Support NULL HIGHPC.
	(dwarf_tag_name): Support DW_TAG_GNU_call_site.
	(cleanup_htab): Delete.
	(write_psymtabs_to_index): Use make_cleanup_htab_delete instead of it.
	* exceptions.h (enum errors): New NO_ENTRY_VALUE_ERROR.
	* gdb-gdb.py (StructMainTypePrettyPrinter): Support
	FIELD_LOC_KIND_DWARF_BLOCK.
	* gdbtypes.h (enum field_loc_kind): New entry
	FIELD_LOC_KIND_DWARF_BLOCK.
	(struct main_type): New loc entry dwarf_block.
	(struct call_site, FIELD_DWARF_BLOCK, SET_FIELD_DWARF_BLOCK)
	(TYPE_FIELD_DWARF_BLOCK): New.
	* python/py-type.c: Include dwarf2loc.h.
	(check_types_equal): Support FIELD_LOC_KIND_DWARF_BLOCK.  New
	internal_error call on unknown FIELD_LOC_KIND.
	* symtab.h (struct symtab): New field call_site_htab.
	* utils.c (do_htab_delete_cleanup, make_cleanup_htab_delete)
	(core_addr_hash, core_addr_eq): New functions.

gdb/testsuite/
	Implement basic support for DW_TAG_GNU_call_site.
	* gdb.arch/Makefile.in (EXECUTABLES): Add amd64-entry-value.
	* gdb.arch/amd64-entry-value.cc: New file.
	* gdb.arch/amd64-entry-value.exp: New file.
@
text
@d44 1
d403 5
a407 1
static void
d690 8
a697 3
  /* Don't allow remember/restore between CIE and FDE programs.  */
  dwarf2_frame_state_free_regs (fs->regs.prev);
  fs->regs.prev = NULL;
d989 7
d1009 4
d1064 17
d1082 1
a1082 1
  execute_cfa_program (fde, fde->instructions, fde->end, gdbarch,
d1223 6
d1274 16
d1359 12
d1397 8
a1404 1
  return self->type != SIGTRAMP_FRAME;
d1414 2
a1415 1
  dwarf2_frame_sniffer
d1425 4
a1428 1
  dwarf2_frame_sniffer
d1436 4
d1491 2
a1492 1
  if (! frame_unwinder_is (this_frame, &dwarf2_frame_unwind))
@


1.129
log
@gdb/
	Fix DW_OP_GNU_implicit_pointer for DWARF32 v3+ on 64-bit arches.
	* dwarf2-frame.c (execute_stack_op): Initialize ctx->ref_addr_size.
	* dwarf2expr.c (execute_stack_op) <DW_OP_GNU_implicit_pointer>: Use
	ctx->ref_addr_size.  Handle its invalid value.
	* dwarf2expr.h (struct dwarf_expr_context): New field ref_addr_size.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full)
	(dwarf2_loc_desc_needs_frame): Initialize ctx->ref_addr_size.
	* dwarf2loc.h (dwarf2_per_cu_ref_addr_size): New declaration.
	* dwarf2read.c (decode_locdesc): Initialize ctx->ref_addr_size.
	(dwarf2_per_cu_ref_addr_size): New function.

gdb/testsuite/
	Fix DW_OP_GNU_implicit_pointer for DWARF32 v3+ on 64-bit arches.
	* gdb.dwarf2/implptr-64bit.S: New file.
	* gdb.dwarf2/implptr-64bit.exp: New file.
@
text
@d356 2
a357 1
  ctx_no_get_base_type
@


1.128
log
@gdb/
	* dwarf2-frame.c (no_get_frame_base, no_get_frame_cfa, no_get_frame_pc)
	(no_get_tls_address, no_dwarf_call, no_base_type): Move to the other
	file.
	(dwarf2_frame_ctx_funcs): Reference the renamed functions.
	* dwarf2expr.c (ctx_no_get_frame_base, ctx_no_get_frame_cfa)
	(ctx_no_get_frame_pc, ctx_no_get_tls_address, ctx_no_dwarf_call)
	(ctx_no_get_base_type): Move the functions here.
	* dwarf2expr.h (ctx_no_get_frame_base, ctx_no_get_frame_cfa)
	(ctx_no_get_frame_pc, ctx_no_get_tls_address, ctx_no_dwarf_call)
	(ctx_no_get_base_type): New declarations.
@
text
@d374 1
@


1.127
log
@gdb/
	Code cleanup.
	* dwarf2-frame.c (dwarf2_frame_ctx_funcs): New.
	(execute_stack_op): Use dwarf2_frame_ctx_funcs
	* dwarf2expr.c (dwarf_get_base_type): Access get_base_type via funcs.
	(execute_stack_op): Access read_reg, get_frame_base, read_mem,
	get_frame_cfa, get_tls_address and dwarf_call via funcs.
	* dwarf2expr.h (struct dwarf_expr_context): New forward declaration.
	(struct dwarf_expr_context_funcs): New, move here methods from ...
	(struct dwarf_expr_context): ... here.  New fields funcs.
	* dwarf2loc.c (dwarf_expr_dwarf_call): Access get_frame_pc via funcs.
	(dwarf_expr_ctx_funcs): New.
	(dwarf2_evaluate_loc_desc_full): Use dwarf_expr_ctx_funcs.
	(needs_frame_dwarf_call): Access get_frame_pc via funcs.
	(needs_frame_ctx_funcs): New.
	(dwarf2_loc_desc_needs_frame): Use needs_frame_ctx_funcs.
@
text
@a314 49
static void
no_get_frame_base (void *baton, const gdb_byte **start, size_t *length)
{
  internal_error (__FILE__, __LINE__,
		  _("Support for DW_OP_fbreg is unimplemented"));
}

/* Helper function for execute_stack_op.  */

static CORE_ADDR
no_get_frame_cfa (void *baton)
{
  internal_error (__FILE__, __LINE__,
		  _("Support for DW_OP_call_frame_cfa is unimplemented"));
}

/* Helper function for execute_stack_op.  */

static CORE_ADDR
no_get_frame_pc (void *baton)
{
  internal_error (__FILE__, __LINE__, _("\
Support for DW_OP_GNU_implicit_pointer is unimplemented"));
}

static CORE_ADDR
no_get_tls_address (void *baton, CORE_ADDR offset)
{
  internal_error (__FILE__, __LINE__, _("\
Support for DW_OP_GNU_push_tls_address is unimplemented"));
}

/* Helper function for execute_stack_op.  */

static void
no_dwarf_call (struct dwarf_expr_context *ctx, size_t die_offset)
{
  internal_error (__FILE__, __LINE__,
		  _("Support for DW_OP_call* is invalid in CFI"));
}

/* Helper function for execute_stack_op.  */

static struct type *
no_base_type (struct dwarf_expr_context *ctx, size_t die)
{
  error (_("Support for typed DWARF is not supported in CFI"));
}

d351 6
a356 6
  no_get_frame_base,
  no_get_frame_cfa,
  no_get_frame_pc,
  no_get_tls_address,
  no_dwarf_call,
  no_base_type
@


1.126
log
@2011-07-15  Fawzi Mohamed  <fawzi.mohamed@@nokia.com>

	* dwarf2-frame.c (decode_frame_entry, decode_frame_entry_1): Ensure
	that CIE pointer of an FDE really points to a CIE .
@
text
@d394 14
d425 1
a425 8
  ctx->read_reg = read_reg;
  ctx->read_mem = read_mem;
  ctx->get_frame_base = no_get_frame_base;
  ctx->get_frame_cfa = no_get_frame_cfa;
  ctx->get_frame_pc = no_get_frame_pc;
  ctx->get_tls_address = no_get_tls_address;
  ctx->dwarf_call = no_dwarf_call;
  ctx->get_base_type = no_base_type;
@


1.125
log
@Do not load .eh_frame section from separete object files

We don't need to read the .eh_frame section from the separate
object files, because this data is already present in the
main executable (it needs to, or the program wouldn't work).

We discovered this investigating a problem with the 'next' command,
which was due to unwind failures, which came from the fact that
the .eh_frame was incorrectly relocated.

gdb/ChangeLog (Tristan Gingold):

    * dwarf2-frame.c (dwarf2_build_frame_info): Do not load .eh_frame
    section in separate object files.
@
text
@d1804 10
d1817 5
a1821 1
                                     struct dwarf2_fde_table *fde_table);
a1822 2
/* Decode the next CIE or FDE.  Return NULL if invalid input, otherwise
   the next byte to be processed.  */
d1826 2
a1827 1
                      struct dwarf2_fde_table *fde_table)
d1878 4
d2047 4
d2072 2
a2073 1
			      eh_frame_p, cie_table, fde_table);
d2114 3
a2116 1
/* Read a CIE or FDE in BUF and decode it.  */
d2120 2
a2121 1
                    struct dwarf2_fde_table *fde_table)
d2130 1
a2130 1
                                  cie_table, fde_table);
d2240 1
d2282 22
a2303 4
          frame_ptr = unit->dwarf_frame_buffer;
          while (frame_ptr < unit->dwarf_frame_buffer + unit->dwarf_frame_size)
            frame_ptr = decode_frame_entry (unit, frame_ptr, 1,
                                            &cie_table, &fde_table);
d2321 33
a2353 4
      frame_ptr = unit->dwarf_frame_buffer;
      while (frame_ptr < unit->dwarf_frame_buffer + unit->dwarf_frame_size)
	frame_ptr = decode_frame_entry (unit, frame_ptr, 0,
                                        &cie_table, &fde_table);
@


1.124
log
@2011-05-24  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (enum dwarf2_section_enum): New type.
	(dwarf2_get_section_info): New prototype.
	* dwarf2read.c (dwarf2_get_section_info): Replace parameter
	section_name by sect.  Use a switch to select the info.
	* dwarf2-frame.c (warf2_get_section_info): Remove prototype.
	(dwarf2_build_frame_info): Adjust calls to dwarf2_get_section_info.
@
text
@d2230 1
a2230 5
  dwarf2_get_section_info (objfile, DWARF2_EH_FRAME,
                           &unit->dwarf_frame_section,
                           &unit->dwarf_frame_buffer,
                           &unit->dwarf_frame_size);
  if (unit->dwarf_frame_size)
d2232 9
a2240 15
      asection *got, *txt;

      /* FIXME: kettenis/20030602: This is the DW_EH_PE_datarel base
	 that is used for the i386/amd64 target, which currently is
	 the only target in GCC that supports/uses the
	 DW_EH_PE_datarel encoding.  */
      got = bfd_get_section_by_name (unit->abfd, ".got");
      if (got)
	unit->dbase = got->vma;

      /* GCC emits the DW_EH_PE_textrel encoding type on sh and ia64
         so far.  */
      txt = bfd_get_section_by_name (unit->abfd, ".text");
      if (txt)
	unit->tbase = txt->vma;
d2242 26
a2267 11
      frame_ptr = unit->dwarf_frame_buffer;
      while (frame_ptr < unit->dwarf_frame_buffer + unit->dwarf_frame_size)
	frame_ptr = decode_frame_entry (unit, frame_ptr, 1,
                                        &cie_table, &fde_table);

      if (cie_table.num_entries != 0)
        {
          /* Reinit cie_table: debug_frame has different CIEs.  */
          xfree (cie_table.entries);
          cie_table.num_entries = 0;
          cie_table.entries = NULL;
@


1.123
log
@	* utils.c (do_value_free): New function.
	(make_cleanup_value_free): Likewise.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full): Handle value
	freeing correctly.
	(dwarf2_loc_desc_needs_frame): Call
	make_cleanup_value_free_to_mark.
	* dwarf2expr.h (struct dwarf_expr_context) <mark>: Remove field.
	* dwarf2expr.c (free_dwarf_expr_context): Don't call
	value_free_to_mark.
	(new_dwarf_expr_context): Don't call value_mark.
	* dwarf2-frame.c (execute_stack_op): Call
	make_cleanup_value_free_to_mark.
	* defs.h (make_cleanup_value_free): Declare.
@
text
@a2185 6

/* Imported from dwarf2read.c.  */
extern void dwarf2_get_section_info (struct objfile *, const char *,
				     asection **, gdb_byte **,
				     bfd_size_type *);

d2230 1
a2230 1
  dwarf2_get_section_info (objfile, ".eh_frame",
d2266 1
a2266 1
  dwarf2_get_section_info (objfile, ".debug_frame",
@


1.122
log
@gdb
	PR gdb/12617:
	* value.h (value_from_contents): Declare.
	* value.c (value_from_contents): New function.
	* dwarf2read.c (dwarf_stack_op_name): Add new values.
	(dwarf2_get_die_type): New function.
	* dwarf2loc.c (dwarf_expr_get_base_type): New function.
	(allocate_piece_closure): Acquire reference to values.
	(read_pieced_value): Update for value-based expressions.
	(write_pieced_value): Likewise.
	(free_pieced_value_closure): Call value_free as needed.
	(dwarf2_evaluate_loc_desc_full): Set get_base_type field.
	Update for value-based expressions.
	* dwarf2loc.h (dwarf2_get_die_type): Declare.
	* dwarf2expr.h (struct dwarf_stack_value) <value>: Change type.
	<get_base_type>: New field.
	(struct dwarf_expr_piece) <v.value>: Change type.
	<v.regno>: New field.
	(struct dwarf_expr_context) <mark>: New field.
	(dwarf_expr_piece, dwarf_expr_fetch): Update.
	(dwarf_expr_pop, dwarf_expr_push): Remove.
	(dwarf_expr_push_address): Declare.
	* dwarf2expr.c (dwarf_arch_cookie): New global.
	(struct dwarf_gdbarch_types): New.
	(dwarf_gdbarch_types_init, dwarf_expr_address_type): New
	functions.
	(dwarf_expr_push): Change type of 'value' argument.  Update.  Now
	static.
	(dwarf_expr_push_address): New function.
	(dwarf_expr_pop): Now static.
	(dwarf_expr_fetch): Change return type.
	(dwarf_require_integral): New function.
	(dwarf_expr_fetch): Simplify.
	(add_piece): Update.
	(base_types_equal_p, dwarf_get_base_type, get_unsigned_type): New
	functions.
	(execute_stack_op) <sign_ext>: Remove.
	Use values for DWARF stack.
	<DW_OP_GNU_const_type, DW_OP_GNU_deref_type,
	DW_OP_GNU_regval_type, DW_OP_GNU_convert, DW_OP_GNU_reinterpret>:
	New cases.
	(_initialize_dwarf2expr): New function.
	(add_piece): Update.
	(new_dwarf_expr_context): Set new field.
	(free_dwarf_expr_context): Call value_free_to_mark.
	* dwarf2-frame.c (no_base_type): New function.
	(execute_stack_op): Set get_base_type field.  Update.
gdb/testsuite
	* gdb.dwarf2/typeddwarf.S: New file.
	* gdb.dwarf2/typeddwarf.c: New file.
	* gdb.dwarf2/typeddwarf.exp: New file.
@
text
@d405 1
@


1.121
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d356 8
d417 1
d419 1
a419 1
  dwarf_expr_push (ctx, initial, initial_in_stack_memory);
d425 1
a425 1
    result = read_reg (this_frame, dwarf_expr_fetch (ctx, 0));
@


1.120
log
@	* dwarf2loc.h (dwarf2_compile_expr_to_ax): Declare.
	* dwarf2loc.c (dwarf2_compile_expr_to_ax): Rename from
	compile_dwarf_to_ax.  No longer static.  Call
	dwarf2_compile_cfa_to_ax.
	(locexpr_tracepoint_var_ref): Update.
	(loclist_tracepoint_var_ref): Update.
	* dwarf2-frame.h (dwarf2_compile_cfa_to_ax): Declare.
	* dwarf2-frame.c (execute_cfa_program): Remove 'this_frame'
	argument; add 'gdbarch' and 'pc'.
	(dwarf2_compile_cfa_to_ax): New function.
	(dwarf2_frame_cache): Update.
@
text
@d43 1
d990 4
d1021 1
d1029 1
d1032 1
a1032 2
  fs = XMALLOC (struct dwarf2_frame_state);
  memset (fs, 0, sizeof (struct dwarf2_frame_state));
d1077 1
a1077 2
  /* Calculate the CFA.  */
  switch (fs->regs.cfa_how)
d1079 17
a1095 7
    case CFA_REG_OFFSET:
      cache->cfa = read_reg (this_frame, fs->regs.cfa_reg);
      if (fs->armcc_cfa_offsets_reversed)
	cache->cfa -= fs->regs.cfa_offset;
      else
	cache->cfa += fs->regs.cfa_offset;
      break;
d1097 11
a1107 6
    case CFA_EXP:
      cache->cfa =
	execute_stack_op (fs->regs.cfa_exp, fs->regs.cfa_exp_len,
			  cache->addr_size, cache->text_offset,
			  this_frame, 0, 0);
      break;
d1109 1
a1109 2
    default:
      internal_error (__FILE__, __LINE__, _("Unknown CFA rule."));
a1214 1
  *this_cache = cache;
d1218 16
d1241 3
d1361 1
d1371 1
@


1.119
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d41 2
d433 2
a434 2
		     const gdb_byte *insn_end, struct frame_info *this_frame,
		     struct dwarf2_frame_state *fs)
a436 1
  CORE_ADDR pc = get_frame_pc (this_frame);
a437 1
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
d905 79
d1061 1
a1061 1
		       fde->cie->end, this_frame, fs);
d1068 2
a1069 1
  execute_cfa_program (fde, fde->instructions, fde->end, this_frame, fs);
@


1.118
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d80 1
a80 1
  /* Target pointer size in bytes. */
d1700 1
a1700 1
  /* Are we still within the section? */
d1799 1
a1799 1
	 section exists as well. */
@


1.117
log
@run copyright.sh for 2011.
@
text
@d333 2
a334 2
  internal_error (__FILE__, __LINE__,
		  _("Support for DW_OP_GNU_implicit_pointer is unimplemented"));
d340 2
a341 2
  internal_error (__FILE__, __LINE__,
		  _("Support for DW_OP_GNU_push_tls_address is unimplemented"));
d419 2
a420 1
      error (_("Not implemented: computing unwound register using explicit value operator"));
d708 2
a709 1
	      internal_error (__FILE__, __LINE__, _("Unknown CFI encountered."));
d861 2
a862 1
dwarf2_frame_adjust_regnum (struct gdbarch *gdbarch, int regnum, int eh_frame_p)
d1492 2
a1493 1
      internal_error (__FILE__, __LINE__, _("Invalid or unsupported encoding"));
d1540 2
a1541 1
      internal_error (__FILE__, __LINE__, _("Invalid or unsupported encoding"));
d2033 2
a2034 2
      complaint (&symfile_complaints,
		 _("Corrupt data in %s:%s; align 4 workaround apparently succeeded"),
d2040 2
a2041 2
      complaint (&symfile_complaints,
		 _("Corrupt data in %s:%s; align 8 workaround apparently succeeded"),
d2059 3
a2061 2
extern void dwarf2_get_section_info (struct objfile *, const char *, asection **,
                                     gdb_byte **, bfd_size_type *);
@


1.116
log
@gdb
	* opencl-lang.c (lval_func_check_synthetic_pointer): New
	function.
	* value.h (struct lval_funcs) <indirect, check_synthetic_pointer>:
	New fields.
	(value_bits_synthetic_pointer): Declare.
	* value.c (value_bits_synthetic_pointer): New function.
	* valprint.c (valprint_check_validity): Handle synthetic
	pointers.
	* valops.c (value_ind): Use new 'indirect' lval_funcs method.
	* valarith.c (value_ptradd): Use set_value_component_location.
	* p-valprint.c (pascal_object_print_value_fields): Handle
	synthetic pointers.
	* jv-valprint.c (java_print_value_fields): Handle synthetic
	pointers.
	* dwarf2read.c (dwarf_stack_op_name): Add
	DW_OP_GNU_implicit_pointer.
	(dwarf2_fetch_die_location_block): Add get_frame_pc, baton
	arguments.  Handle location lists.
	(fill_in_loclist_baton): New function.
	(dwarf2_symbol_mark_computed): Use it.
	* dwarf2loc.h (dwarf2_find_location_expression): Declare.
	(dwarf2_fetch_die_location_block): Add get_frame_pc, baton
	arguments.
	* dwarf2loc.c (dwarf2_find_location_expression): Rename from
	find_location_expression.  No longer static.  Update all callers.
	(dwarf_expr_frame_pc): New function.
	(per_cu_dwarf_call): Add get_frame_pc, baton arguments.  Update
	all callers.
	(struct piece_closure) <per_cu>: New field.
	(allocate_piece_closure): Add per_cu argument.
	(read_pieced_value): Handle DWARF_VALUE_IMPLICIT_POINTER.
	(check_pieced_value_bits): Remove validity argument, add check_for
	argument.  Handle DWARF_VALUE_IMPLICIT_POINTER.
	(check_pieced_value_validity, check_pieced_value_invalid):
	Update.
	(check_pieced_synthetic_pointer): New function.
	(get_frame_address_in_block_wrapper): New function.
	(indirect_pieced_value): New function.
	(pieced_value_funcs): Update.
	(invalid_synthetic_pointer): New function.
	(dwarf2_evaluate_loc_desc_full): Rename from
	dwarf2_evaluate_loc_desc.  Add byte_offset argument.
	(dwarf2_evaluate_loc_desc): Rewrite.
	(dwarf2_loc_desc_needs_frame): Set new field on context.
	(get_ax_pc): New function.
	(disassemble_dwarf_expression): Handle
	DW_OP_GNU_implicit_pointer.
	* dwarf2expr.h (enum dwarf_value_location)
	<DWARF_VALUE_IMPLICIT_POINTER>: New constant.
	(struct dwarf_expr_context) <get_frame_pc>: New field.
	(struct dwarf_expr_piece) <v.ptr>: New field.
	* dwarf2expr.c (add_piece): Handle DWARF_VALUE_IMPLICIT_POINTER.
	(execute_stack_op): Handle DW_OP_GNU_implicit_pointer.
	* dwarf2-frame.c (no_get_frame_pc): New function.
	(execute_stack_op): Set new field on context.
	* cp-valprint.c (cp_print_value_fields): Handle synthetic
	pointers.
gdb/testsuite
	* gdb.dwarf2/implptr.exp: New file.
	* gdb.dwarf2/implptr.c: New file.
	* gdb.dwarf2/implptr.S: New file.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005, 2007, 2008, 2009, 2010
@


1.115
log
@	* dwarf2-frame.c (struct dwarf2_cie): Add ptr_size member.
	Throughout, call read_encoded_value with ptr_size rather than addr_size.
	(decode_frame_entry_1): Remove redundant setting of
	addr_size.  Call gdbarch_dwarf2_addr_size rather than gdbarch_ptr_bit
	to determine addr_size in Dwarf versions < 4.  Set ptr_size dependent
	on examined frame section.  Add comment to explain why.
	* gdbarch.sh (dwarf2_addr_size): Define as variable.  Add lengthy
	comment to explain usage.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set dwarf2_addr_size to 4.
@
text
@d328 9
d403 1
@


1.114
log
@	* dwarf2read.c (dwarf2_const_value) <DW_form_addr>: Create a
	LOC_COMPUTED symbol.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Set new field.
	(dwarf2_loc_desc_needs_frame): Likewise.
	(compile_dwarf_to_ax) <DW_OP_addr>: Use offset.
	* dwarf2expr.h (struct dwarf_expr_context) <offset>: New field.
	* dwarf2expr.c (execute_stack_op) <DW_OP_addr>: Use offset.
	* dwarf2-frame.c (execute_stack_op): Set 'offset' field.  Add
	'offset' argument.
	(struct dwarf2_frame_cache) <text_offset>: New field.
	(dwarf2_frame_cache): Set new field.
	(dwarf2_frame_prev_register): Update.
	(dwarf2_frame_sniffer): Update.
	(dwarf2_frame_base_sniffer): Update.
	(dwarf2_frame_find_fde): Add 'out_offset' argument.
@
text
@d80 3
d458 1
a458 1
					   fde->cie->addr_size, insn_ptr,
a1737 7
      /* The target address size.  For .eh_frame FDEs this is considered
	 equal to the size of a target pointer.  For .dwarf_frame FDEs, 
	 this is supposed to be the target address size from the associated
	 CU header.  FIXME: We do not have a good way to determine the 
	 latter.  Always use the target pointer size for now.  */
      cie->addr_size = gdbarch_ptr_bit (gdbarch) / TARGET_CHAR_BIT;

d1778 1
a1778 1
	  cie->addr_size = gdbarch_ptr_bit (gdbarch) / TARGET_CHAR_BIT;
d1781 8
d1848 1
a1848 1
	      read_encoded_value (unit, encoding, cie->addr_size,
d1914 1
a1914 1
	read_encoded_value (unit, fde->cie->encoding, fde->cie->addr_size,
d1920 1
a1920 1
			    fde->cie->addr_size, buf, &bytes_read, 0);
@


1.113
log
@ChangeLog:

	* dwarf2expr.h (struct dwarf_value_location): Use ULONGEST as type
	of stack values.
	(struct dwarf_expr_piece): Rename "expr" member to "mem".  Add new
	"value" member.
	(dwarf_expr_push): Change input type to ULONGEST.
	(dwarf_expr_fetch): Change return type to ULONGEST.
	(dwarf_expr_fetch_address): Add prototype.
	(dwarf2_read_address): Remove prototype.
	* dwarf2expr.c (dwarf_expr_push): Use ULONGEST as type of stack values.
	Truncate stack values to ctx->addr_size bytes.
	(dwarf_expr_fetch): Change return value to ULONGEST.
	(dwarf_expr_fetch_address): New function.
	(add_piece): Use dwarf_expr_fetch_address instead of dwarf_expr_fetch
	when appropriate.  Update for struct dwarf_expr_piece changes.
	(dwarf2_read_address): Remove.
	(unsigned_address_type): Remove.
	(signed_address_type): Remove.
	(execute_stack_op): Use dwarf_expr_fetch_address instead of
	dwarf_expr_fetch when appropriate.  Use ULONGEST as type of stack
	values.  Perform operations on ULONGEST instead of on GDB values,
	sign-extending from ctx->addr_size bytes as needed.  Read DW_OP_addr
	values and DW_OP_deref results as unsigned integers.
	* dwarf2loc.c (read_pieced_value): Update for struct dwarf_expr_piece
	changes.
	(write_pieced_value): Likewise.
	(dwarf2_evaluate_loc_desc): Use dwarf_expr_fetch_address instead of
	dwarf_expr_fetch when appropriate.
	(compile_dwarf_to_ax): Read DW_OP_addr values as unsigned integers.
	* dwarf2-frame.c (execute_stack_op): Use dwarf_expr_fetch_address
	instead of dwarf_expr_fetch when appropriate.

testsuite/ChangeLog:

	* gdb.cell/dwarfaddr.exp: New file.
	* gdb.cell/dwarfaddr.S: New file.
@
text
@d153 2
a154 1
static struct dwarf2_fde *dwarf2_frame_find_fde (CORE_ADDR *pc);
d373 2
a374 2
		  struct frame_info *this_frame, CORE_ADDR initial,
		  int initial_in_stack_memory)
d385 1
d906 3
d952 1
a952 1
  fde = dwarf2_frame_find_fde (&fs->pc);
d989 2
a990 1
			  cache->addr_size, this_frame, 0, 0);
d1146 2
a1147 1
			       cache->addr_size, this_frame, cache->cfa, 1);
d1157 2
a1158 1
			       cache->addr_size, this_frame, cache->cfa, 1);
d1208 1
a1208 1
  struct dwarf2_fde *fde = dwarf2_frame_find_fde (&block_addr);
d1281 1
a1281 1
  if (dwarf2_frame_find_fde (&block_addr))
d1593 1
a1593 1
dwarf2_frame_find_fde (CORE_ADDR *pc)
d1628 2
@


1.113.2.1
log
@	* dwarf2read.c (dwarf2_const_value) <DW_form_addr>: Create a
	LOC_COMPUTED symbol.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Set new field.
	(dwarf2_loc_desc_needs_frame): Likewise.
	(compile_dwarf_to_ax) <DW_OP_addr>: Use offset.
	* dwarf2expr.h (struct dwarf_expr_context) <offset>: New field.
	* dwarf2expr.c (execute_stack_op) <DW_OP_addr>: Use offset.
	* dwarf2-frame.c (execute_stack_op): Set 'offset' field.  Add
	'offset' argument.
	(struct dwarf2_frame_cache) <text_offset>: New field.
	(dwarf2_frame_cache): Set new field.
	(dwarf2_frame_prev_register): Update.
	(dwarf2_frame_sniffer): Update.
	(dwarf2_frame_base_sniffer): Update.
	(dwarf2_frame_find_fde): Add 'out_offset' argument.
@
text
@d153 1
a153 2
static struct dwarf2_fde *dwarf2_frame_find_fde (CORE_ADDR *pc,
						 CORE_ADDR *out_offset);
d372 2
a373 2
		  CORE_ADDR offset, struct frame_info *this_frame,
		  CORE_ADDR initial, int initial_in_stack_memory)
a383 1
  ctx->offset = offset;
a903 3

  /* The .text offset.  */
  CORE_ADDR text_offset;
d947 1
a947 1
  fde = dwarf2_frame_find_fde (&fs->pc, &cache->text_offset);
d984 1
a984 2
			  cache->addr_size, cache->text_offset,
			  this_frame, 0, 0);
d1140 1
a1140 2
			       cache->addr_size, cache->text_offset,
			       this_frame, cache->cfa, 1);
d1150 1
a1150 2
			       cache->addr_size, cache->text_offset,
			       this_frame, cache->cfa, 1);
d1200 1
a1200 1
  struct dwarf2_fde *fde = dwarf2_frame_find_fde (&block_addr, NULL);
d1273 1
a1273 1
  if (dwarf2_frame_find_fde (&block_addr, NULL))
d1585 1
a1585 1
dwarf2_frame_find_fde (CORE_ADDR *pc, CORE_ADDR *out_offset)
a1619 2
	  if (out_offset)
	    *out_offset = offset;
@


1.112
log
@gdb/
	Fix PR 10640.
	* dwarf2-frame.c (no_dwarf_call): New function.
	(execute_stack_op): Set CTX->DWARF_CALL.
	* dwarf2expr.c (execute_stack_op) <DW_OP_call2, DW_OP_call4>: New.
	* dwarf2expr.h (struct dwarf_expr_context) <dwarf_call>: New.
	(struct dwarf_expr_context) <get_subr>: Remove the #if0-ed field.
	* dwarf2loc.c (per_cu_dwarf_call, dwarf_expr_dwarf_call): New functions.
	(dwarf2_evaluate_loc_desc): Initialize CTX->DWARF_CALL.
	(needs_frame_dwarf_call): New function.
	(dwarf2_loc_desc_needs_frame): Initialize CTX->DWARF_CALL.
	* dwarf2read.c (follow_die_offset): Based on former follow_die_ref.
	Update the comment.  Move variables die, offset and error call to ...
	(follow_die_ref): ... a new function.
	(dwarf2_fetch_die_location_block): New function.
	* dwarf2loc.h (dwarf2_fetch_die_location_block): New prototype.

gdb/testsuite/
	Test PR 10640.
	* gdb.dwarf2/dw2-op-call.exp, gdb.dwarf2/dw2-op-call.S: New.
@
text
@a393 1
  result = dwarf_expr_fetch (ctx, 0);
d395 5
a399 3
  if (ctx->location == DWARF_VALUE_REGISTER)
    result = read_reg (this_frame, result);
  else if (ctx->location != DWARF_VALUE_MEMORY)
@


1.111
log
@	* dwarf2loc.c (dwarf_expr_frame_base): Constify.
	(dwarf_expr_frame_base_1): Likewise.
	(read_pieced_value): Update.
	(needs_frame_frame_base): Constify.
	(dwarf2_tracepoint_var_loc): Likewise.
	(dwarf2_tracepoint_var_access): Likewise.
	(locexpr_describe_location_piece): Likewise.
	(locexpr_describe_location_1): Likewise.
	* dwarf2expr.h (struct dwarf_expr_context) <get_frame_base>:
	Constify.
	(data): Now const.
	(struct dwarf_expr_piece) <v.literal.data>: Likewise.
	(dwarf_expr_eval, read_uleb128, read_sleb128)
	(dwarf2_read_address): Update.
	* dwarf2expr.c (dwarf_expr_eval): Constify.
	(read_uleb128): Likewise.
	(read_sleb128): Likewise.
	(dwarf2_read_address): Likewise.
	(require_composition): Likewise.
	(execute_stack_op): Likewise.
	* dwarf2-frame.h (struct dwarf2_frame_state_reg) <loc.exp>: Now a
	"const gdb_byte *".
	* dwarf2-frame.c (struct dwarf2_frame_state_reg_info) <cfa_exp>:
	Now const.
	(no_get_frame_base): Constify.
	(execute_stack_op): Likewise.
	(execute_cfa_program): Likewise.
	(read_encoded_value): Likewise.
@
text
@d331 9
d390 1
@


1.110
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* dbxread.c: White space.
	* dcache.c: White space.
	* disasm.c: White space.
	* doublest.c: White space.
	* dsrec.c: White space.
	* dummy-frame.c: White space.
	* dwarf2expr.c: White space.
	* dwarf2-frame.c: White space.
	* dwarf2loc.c: White space.
	* dwarf2read.c: White space.
@
text
@d159 1
a159 1
				     int ptr_len, gdb_byte *buf,
d182 1
a182 1
    gdb_byte *cfa_exp;
d309 1
a309 1
no_get_frame_base (void *baton, gdb_byte **start, size_t *length)
d362 1
a362 1
execute_stack_op (gdb_byte *exp, ULONGEST len, int addr_size,
d403 2
a404 2
execute_cfa_program (struct dwarf2_fde *fde, gdb_byte *insn_ptr,
		     gdb_byte *insn_end, struct frame_info *this_frame,
d1414 2
a1415 1
		    int ptr_len, gdb_byte *buf, unsigned int *bytes_read_ptr,
d1472 1
a1472 1
	gdb_byte *end_buf = buf + (sizeof (value) + 1) * 8 / 7;
d1489 1
a1489 1
	gdb_byte *end_buf = buf + (sizeof (value) + 1) * 8 / 7;
@


1.109
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* objfiles.c (objfile_relocate): Delete unused variable.
	* maint.c (_initialize_maint_cmds): Delete unused variable.
	* demangle.c (_initialize_demangler): Delete unused variable.
	* corefile.c (reopen_exec_file): Delete unused variable.
	* dwarf2expr.c (dwarf2_read_address): Delete unused variable.
	* dwarf2-frame.c (decode_frame_entry): Delete unused variable.
@
text
@d650 1
d1190 1
d1261 1
d1472 1
d1489 1
d1561 1
@


1.108
log
@	* dwarf2-frame.c (decode_frame_entry_1): Handle CIE version 4.
	(struct dwarf2_cie) <segment_size>: New field.
	* dwarf2read.c (partial_read_comp_unit_head): Accept DWARF 4.
	(skip_one_die): Handle DW_FORM_flag_present, DW_FORM_sec_offset,
	DW_FORM_exprloc.
	(read_attribute_value): Handle DW_FORM_flag_present,
	DW_FORM_sec_offset, DW_FORM_exprloc.
	(dump_die_shallow): Likewise.
	(attr_form_is_section_offset): Handle DW_FORM_sec_offset.
	(dwarf2_const_value): Handle DW_FORM_exprloc.
	(attr_form_is_block): Likewise.
	(struct line_header) <maximum_ops_per_instruction>: New field.
	(dwarf_decode_line_header): Set new field.
	(dwarf_decode_lines): Handle new field.
@
text
@a1923 1
  const char *msg;
@


1.107
log
@	* dwarf2-frame.c (dwarf2_frame_find_quirks): Use producer_is_realview.
	* dwarf2read.c (load_full_comp_unit): Read DW_AT_producer.
	(read_structure_type): For RealView, set TYPE_STUB on structures with
	no byte size and no children.
	(read_subroutine_type): Mark functions as prototyped by default.
	* symtab.c (producer_is_realview): New function.
	* symtab.h (expand_line_sal): Fix declaration formatting.
	(producer_is_realview): Declare.

	testsuite/
	* gdb.base/callfuncs.exp (do_function_calls): Add XFAILs for RealView.
	* gdb.base/ptype.exp (ptype_maybe_prototyped): Add overprototyped
	argument.  Handle "short" and "long".
	(Top level): Pass overprototyped output for old_fptr and xptr.
@
text
@d88 3
d1720 1
a1720 1
      if (cie_version != 1 && cie_version != 3)
d1744 14
@


1.106
log
@	* elfread.c (elf_symfile_read): Don't call
	dwarf2_build_frame_info.
	* dwarf2read.c (struct dwarf2_section_info) <readin>: New field.
	(struct dwarf2_per_objfile) <objfile>: New field.
	(dwarf2_has_info): Now idempotent.  Set objfile field.
	(dwarf2_read_section): Check and set readin field.  Call
	posix_madvise.
	(dwarf2_build_psymtabs): Don't read all sections.
	(read_type_comp_unit_head): Read types section.
	(create_debug_types_hash_table): Likewise.
	(init_cu_die_reader): Add asserts.
	(process_type_comp_unit): Add assert.
	(dwarf2_build_psymtabs_hard): Read info section.
	(load_partial_comp_unit): Add assert.
	(create_all_comp_units): Read info section.
	(load_full_comp_unit): Likewise.
	(dwarf2_ranges_read): Read ranges section.
	(dwarf2_record_block_ranges): Add assert.
	(dwarf2_read_abbrevs): Read abbrev section.
	(read_indirect_string): Read str section.
	(dwarf_decode_line_header): Read line section.
	(read_signatured_type_at_offset): Read types section.
	(dwarf_decode_macros): Read macinfo section.
	(dwarf2_symbol_mark_computed): Read loc section.
	* dwarf2-frame.c (dwarf2_frame_find_fde): Call
	dwarf2_build_frame_info.
	(dwarf2_build_frame_info): Unconditionally set
	dwarf2_frame_objfile_data on the objfile.
	* configure.ac: Check for posix_madvise.
	* config.in, configure: Rebuild.
@
text
@a841 9
  static const char *arm_idents[] = {
    "ARM C Compiler, ADS",
    "Thumb C Compiler, ADS",
    "ARM C++ Compiler, ADS",
    "Thumb C++ Compiler, ADS",
    "ARM/Thumb C/C++ Compiler, RVCT"
  };
  int i;

d845 1
a845 1
  if (s == NULL || s->producer == NULL)
d848 4
a851 5
  for (i = 0; i < ARRAY_SIZE (arm_idents); i++)
    if (strncmp (s->producer, arm_idents[i], strlen (arm_idents[i])) == 0)
      {
	if (fde->cie->version == 1)
	  fs->armcc_cfa_offsets_sf = 1;
d853 2
a854 2
	if (fde->cie->version == 1)
	  fs->armcc_cfa_offsets_reversed = 1;
d856 10
a865 10
	/* The reversed offset problem is present in some compilers
	   using DWARF3, but it was eventually fixed.  Check the ARM
	   defined augmentations, which are in the format "armcc" followed
	   by a list of one-character options.  The "+" option means
	   this problem is fixed (no quirk needed).  If the armcc
	   augmentation is missing, the quirk is needed.  */
	if (fde->cie->version == 3
	    && (strncmp (fde->cie->augmentation, "armcc", 5) != 0
		|| strchr (fde->cie->augmentation + 5, '+') == NULL))
	  fs->armcc_cfa_offsets_reversed = 1;
d867 2
a868 2
	return;
      }
@


1.105
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d1587 7
d2037 1
d2109 10
a2118 1
  if (fde_table.num_entries != 0)
a2119 1
      struct dwarf2_fde_table *fde_table2;
a2127 5
      /* Copy fde_table to obstack: it is needed at runtime.  */
      fde_table2 = (struct dwarf2_fde_table *)
          obstack_alloc (&objfile->objfile_obstack, sizeof (*fde_table2));
      fde_table2->num_entries = 0;

d2154 1
a2174 1
      set_objfile_data (objfile, dwarf2_frame_objfile_data, fde_table2);
d2179 2
@


1.104
log
@        * dwarf2-frame.c (dwarf2_build_frame_info): Discard --gc-section
	leftover FDEs.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005, 2007, 2008, 2009
@


1.103
log
@Revert previous patch.  Applied an old version by mistake.
@
text
@d2104 3
a2106 1
      int i, j;
d2115 1
d2117 45
a2161 13
      /* Since we'll be doing bsearch, squeeze out identical (except for
         eh_frame_p) fde entries so bsearch result is predictable.  */
      for (i = 0, j = 0; j < fde_table.num_entries; ++i)
        {
          const int k = j;

          obstack_grow (&objfile->objfile_obstack, &fde_table.entries[j],
                        sizeof (fde_table.entries[0]));
          while (++j < fde_table.num_entries
                 && (fde_table.entries[k]->initial_location
                     == fde_table.entries[j]->initial_location))
            /* Skip.  */;
        }
a2162 1
      fde_table2->num_entries = i;
@


1.102
log
@        * dwarf2-frame.c (dwarf2_build_frame_info): Discard --gc-section
	leftover FDEs.
@
text
@d2104 1
a2104 2
      struct dwarf2_fde *fde_prev = NULL;
      int i;
a2112 1
      fde_table2->num_entries = 0;
d2116 11
a2126 28
      for (i = 0; i < fde_table.num_entries; i++)
	{
	  struct dwarf2_fde *fde = fde_table.entries[i];

	  /* Check for leftovers from --gc-sections.  The GNU linker
	     sets the relevant symbols to zero, but doesn't zero the
	     FDE *end* ranges because there's no relocation there.
	     It's (offset, length), not (start, end).  On targets
	     where address zero is just another valid address this can
	     be a problem, since the FDEs appear to be non-empty in
	     the output --- we could pick out the wrong FDE.  To work
	     around this, when overlaps are detected, we prefer FDEs
	     that do not start at zero.  */
	  if (fde->initial_location == 0
	      && (i + 1) < fde_table.num_entries
	      && ((fde_table.entries[i + 1])->initial_location
		  < fde->initial_location + fde->address_range))
	    continue;

	  if (fde_prev != NULL
	      && fde_prev->initial_location == fde->initial_location)
	    continue;

	  obstack_grow (&objfile->objfile_obstack, &fde_table.entries[i],
			sizeof (fde_table.entries[0]));
	  ++fde_table2->num_entries;
	  fde_prev = fde;
	}
d2128 1
@


1.101
log
@2009-10-22  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	PR gdb/10819
	* dwarf2-frame.c (find_cie): Don't call bsearch on empty cie_table.
	* objfiles.c (find_pc_section): Likewise.
	(update_section_map): Don't allocate empty table.
@
text
@d2104 2
a2105 1
      int i, j;
d2114 1
d2118 28
a2145 11
      for (i = 0, j = 0; j < fde_table.num_entries; ++i)
        {
          const int k = j;

          obstack_grow (&objfile->objfile_obstack, &fde_table.entries[j],
                        sizeof (fde_table.entries[0]));
          while (++j < fde_table.num_entries
                 && (fde_table.entries[k]->initial_location
                     == fde_table.entries[j]->initial_location))
            /* Skip.  */;
        }
a2146 1
      fde_table2->num_entries = i;
@


1.100
log
@	ARI fix: OP eol rule.
	* doublest.c (floatformat_from_length): Avoid operator at end of line.
	* dwarf2-frame.c (dwarf2_build_frame_info): Idem.
	* dwarf2read.c (read_array_order, dwarf_decode_macros): Idem.
	* eval.c (evaluate_subexp_standard): Idem.
	* event-loop.c (create_timer, handle_timer_event): Idem.
	* expprint.c (print_subexp_standard): Idem.
	* f-exp.y (variable): Idem.
	* f-typeprint.c (f_print_type): Idem.
@
text
@d1528 8
@


1.99
log
@	* dwarf2expr.h (dwarf_value_location): Add more comments describing
	enum values.
	(struct dwarf_stack_value): New struct.
	(struct dwarf_expr_context): Change type of `stack' from CORE_ADDR*
	to struct dwarf_stack_value*.
	(struct dwarf_expr_piece): Move `v.value' into its own struct, v.expr,
	all uses updated.  Add v.expr.in_stack_memory.
	(dwarf_expr_push): Update declaration.
	(dwarf_expr_fetch_in_stack_memory): Declare.
	* dwarf2expr.c (dwarf_expr_grow_stack): Update calculation of
	size of stack value.
	(dwarf_expr_push): New arg in_stack_memory, all callers updated.
	(dwarf_expr_fetch_in_stack_memory): New function.
	(add_piece): Set in_stack_memory for non-literal values.
	(execute_stack_op): Allow ops to specify whether the value is on the
	program's stack.
	(execute_stack_op, case DW_OP_fbreg): Mark value as in stack memory.
	(execute_stack_op, case DW_OP_call_frame_cfa): Ditto.
	(execute_stack_op, case DW_OP_dup): Copy in_stack_memory flag.
	(execute_stack_op, cases DW_OP_pick, DW_OP_over): Ditto.
	(execute_stack_op, cases DW_OP_swap, DW_OP_rot): Update type of
	dwarf stack value.
	* dwarf2loc.c (read_pieced_value): Call read_stack for values known
	to be on the program's stack.
	(dwarf2_evaluate_loc_desc, case DWARF_VALUE_MEMORY): Call
	set_value_stack only for objects known to be in stack memory.
	* dwarf2-frame.c (execute_stack_op): New arg initial_in_stack_memory,
	all callers updated.
@
text
@d2115 2
a2116 2
                 && (fde_table.entries[k]->initial_location ==
                     fde_table.entries[j]->initial_location))
@


1.99.2.1
log
@2009-10-22  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	PR gdb/10819
	* dwarf2-frame.c (find_cie): Don't call bsearch on empty cie_table.
	* objfiles.c (find_pc_section): Likewise.
	(update_section_map): Don't allocate empty table.
@
text
@a1527 8
  /* The C standard (ISO/IEC 9899:TC2) requires the BASE argument to
     bsearch be non-NULL.  */
  if (cie_table->entries == NULL)
    {
      gdb_assert (cie_table->num_entries == 0);
      return NULL;
    }

@


1.98
log
@gdb
	* dwarf2loc.c (struct piece_closure) <arch>: New field.
	(dwarf2_evaluate_loc_desc): Update.
	(dwarf2_loc_desc_needs_frame): Likewise.
	(allocate_piece_closure): Initialize new field.
	(read_pieced_value): Update.
	(write_pieced_value): Update.
	(copy_pieced_value_closure): Update.
	* dwarf2expr.h (enum dwarf_value_location): New.
	(struct dwarf_expr_context) <in_reg>: Remove.
	<location, len, data>: New fields.
	(struct dwarf_expr_piece) <in_reg, value>: Remove.
	<location, v>: New fields.
	* dwarf2expr.c (add_piece): Remove in_reg, value arguments.
	Update.
	(require_composition): New function.
	(execute_stack_op): Update.
	<DW_OP_implicit_value, DW_OP_stack_value>: New cases.
	<DW_OP_reg0>: Set location, not in_reg.
	<DW_OP_regx>: Likewise.  Use require_composition.
	<DW_OP_fbreg>: Update.
	<DW_OP_piece>: Likewise.
	* dwarf2-frame.c (execute_stack_op): Update.
gdb/testsuite
	* gdb.dwarf2/valop.S: New file.
	* gdb.dwarf2/valop.exp: New file.
@
text
@d360 2
a361 1
		  struct frame_info *this_frame, CORE_ADDR initial)
d379 1
a379 1
  dwarf_expr_push (ctx, initial);
d979 1
a979 1
			  cache->addr_size, this_frame, 0);
d1135 1
a1135 1
			       cache->addr_size, this_frame, cache->cfa);
d1145 1
a1145 1
			       cache->addr_size, this_frame, cache->cfa);
@


1.97
log
@gdb
	* frame.h (frame_unwinder_is): Declare.
	* frame.c (frame_unwinder_is): New function.
	* dwarf2loc.c: Include dwarf2-frame.h.
	(dwarf_expr_frame_cfa): New function.
	(dwarf2_evaluate_loc_desc): Use it.
	(needs_frame_frame_cfa): New function.
	(dwarf2_loc_desc_needs_frame): Use it.
	* dwarf2expr.h (struct dwarf_expr_context) <get_frame_cfa>: New
	field.
	* dwarf2expr.c (execute_stack_op) <DW_OP_call_frame_cfa>: New
	case.
	* dwarf2-frame.h (dwarf2_frame_cfa): Declare.
	* dwarf2-frame.c (no_get_frame_cfa): New function.
	(execute_stack_op): Use it.
	(dwarf2_frame_cfa): New function.
gdb/testsuite
	* gdb.dwarf2/callframecfa.exp: New file.
	* gdb.dwarf2/callframecfa.S: New file.
@
text
@d382 1
a382 1
  if (ctx->in_reg)
d384 7
@


1.96
log
@	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Make a cleanup.
	(dwarf2_loc_desc_needs_frame): Likewise.
	* dwarf2expr.h (make_cleanup_free_dwarf_expr_context): Declare.
	* dwarf2expr.c (free_dwarf_expr_context_cleanup): New function.
	(make_cleanup_free_dwarf_expr_context): Likewise.
	* dwarf2-frame.c (execute_stack_op): Make a cleanup.
@
text
@d312 9
d375 1
d1263 17
@


1.95
log
@2009-08-06  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	gold/10400
	* dwarf2-frame.c (qsort_fde_cmp): Use stable sort.
@
text
@d355 1
d358 2
d375 1
a375 1
  free_dwarf_expr_context (ctx);
@


1.94
log
@2009-08-06  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* dwarf2-frame.c (struct dwarf2_cie): Remove 'next'.
	(struct dwarf2_cie_table): New.
	(struct dwarf2_fde): Remove 'next'.
	(struct dwarf2_fde_table): New.
	(struct comp_unit): Remove 'cie'.
	(bsearch_cie_cmp, bsearch_fde_cmp): New function.
	(find_cie, dwarf2_frame_find_fde): Use bsearch.
	(add_cie, add_fde): Use array instead of linked list.
	(decode_frame_entry, decode_frame_entry_1): New parameters.
	(qsort_fde_cmp): New function.
	(dwarf2_build_frame_info): Adjust.
@
text
@d1961 1
d1963 10
a1972 2
    /* Put eh_frame entries after debug_frame ones.  */
    return aa->eh_frame_p - bb->eh_frame_p;
@


1.93
log
@bfd
	* Makefile.am (dwarf2.lo): Use dwarf2.h, not elf/dwarf2.h.
	(elf-eh-frame.lo): Likewise.
	(elf32-bfin.lo): Likewise.
	(elf32-frv.lo): Likewise.
	(elf32-xc16x.lo): Likewise.
	* Makefile.in: Rebuild.
	* dwarf2.c: Included dwarf.h, not elf/dwarf2.h.
	* elf-eh-frame.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-xc16x.c: Likewise.
binutils
	* Makefile.am (dwarf.o): Refer to dwarf2.h, not elf/dwarf2.h.
	* Makefile.in: Rebuild.
	* dwarf.c: Include dwarf2.h, not elf/dwarf2.h.
gas
	* Makefile.am (DEPTC_alpha_ecoff): Refer to dwarf2.h, not
	elf/dwarf2.h.
	(DEPTC_alpha_elf): Likewise.
	(DEPTC_alpha_evax): Likewise.
	(DEPTC_arm_elf): Likewise.
	(DEPTC_hppa_elf): Likewise.
	(DEPTC_i386_aout): Likewise.
	(DEPTC_i386_coff): Likewise.
	(DEPTC_i386_elf): Likewise.
	(DEPTC_m68k_aout): Likewise.
	(DEPTC_m68k_coff): Likewise.
	(DEPTC_m68k_elf): Likewise.
	(DEPTC_mips_coff): Likewise.
	(DEPTC_mips_ecoff): Likewise.
	(DEPTC_mips_elf): Likewise.
	(DEPTC_ppc_coff): Likewise.
	(DEPTC_ppc_elf): Likewise.
	(DEPTC_s390_elf): Likewise.
	(DEPTC_sh_coff): Likewise.
	(DEPTC_sh_elf): Likewise.
	(DEPTC_sh64_elf): Likewise.
	(DEPTC_sparc_aout): Likewise.
	(DEPTC_sparc_coff): Likewise.
	(DEPTC_sparc_elf): Likewise.
	(as.o): Likewise.
	(dwarf2dbg.o): Likewise.
	(dw2gencfi.o): Likewise.
	(ehopt.o): Likewise.
	(read.o): Likewise.
	* Makefile.in: Rebuild.
	* dw2gencfi.h: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
gdb
	* dwarf2-frame.c: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2expr.c: Likewise.
	* dwarf2loc.c: Likewise.
	* dwarf2read.c: Likewise.
	* sh-tdep.c: Likewise.
	* xtensa-tdep.c: Likewise.
include
	* dwarf2.h: New file, moved from elf/.
include/elf

	* dwarf2.h: Move to `..'.
@
text
@d88 1
d90 4
a93 1
  struct dwarf2_cie *next;
d116 1
d118 4
a121 1
  struct dwarf2_fde *next;
a133 3
  /* Linked list of CIEs for this object.  */
  struct dwarf2_cie *cie;

d1472 11
a1482 2
/* GCC uses a single CIE for all FDEs in a .debug_frame section.
   That's why we use a simple linked list here.  */
d1484 1
d1486 1
a1486 1
find_cie (struct comp_unit *unit, ULONGEST cie_pointer)
d1488 1
a1488 1
  struct dwarf2_cie *cie = unit->cie;
d1490 12
a1501 4
  while (cie)
    {
      if (cie->cie_pointer == cie_pointer)
	return cie;
d1503 2
a1504 2
      cie = cie->next;
    }
d1506 4
a1509 1
  return NULL;
d1512 2
a1513 2
static void
add_cie (struct comp_unit *unit, struct dwarf2_cie *cie)
d1515 7
a1521 3
  cie->next = unit->cie;
  unit->cie = cie;
  cie->unit = unit;
d1534 2
a1535 1
      struct dwarf2_fde *fde;
d1537 1
d1539 2
a1540 2
      fde = objfile_data (objfile, dwarf2_frame_objfile_data);
      if (fde == NULL)
d1546 12
a1557 11
      while (fde)
	{
	  if (*pc >= fde->initial_location + offset
	      && *pc < fde->initial_location + offset + fde->address_range)
	    {
	      *pc = fde->initial_location + offset;
	      return fde;
	    }

	  fde = fde->next;
	}
a1558 1

d1562 1
d1564 1
a1564 1
add_fde (struct comp_unit *unit, struct dwarf2_fde *fde)
d1566 9
a1574 2
  fde->next = objfile_data (unit->objfile, dwarf2_frame_objfile_data);
  set_objfile_data (unit->objfile, dwarf2_frame_objfile_data, fde);
d1584 3
a1586 1
				     int eh_frame_p);
d1591 3
a1593 1
decode_frame_entry_1 (struct comp_unit *unit, gdb_byte *start, int eh_frame_p)
d1648 1
a1648 1
      if (find_cie (unit, cie_pointer))
d1785 1
d1787 1
a1787 1
      add_cie (unit, cie);
d1811 1
a1811 1
      fde->cie = find_cie (unit, cie_pointer);
d1815 2
a1816 2
			      eh_frame_p);
	  fde->cie = find_cie (unit, cie_pointer);
d1850 1
a1850 1
      add_fde (unit, fde);
d1858 3
a1860 1
decode_frame_entry (struct comp_unit *unit, gdb_byte *start, int eh_frame_p)
d1869 2
a1870 1
      ret = decode_frame_entry_1 (unit, start, eh_frame_p);
d1956 12
d1973 8
a1989 2
  /* First add the information from the .eh_frame section.  That way,
     the FDEs from that section are searched last.  */
a1997 1
      unit->cie = NULL;
d2014 10
a2023 1
	frame_ptr = decode_frame_entry (unit, frame_ptr, 1);
a2031 2
      unit->cie = NULL;

d2034 44
a2077 1
	frame_ptr = decode_frame_entry (unit, frame_ptr, 0);
@


1.92
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d25 1
a25 1
#include "elf/dwarf2.h"
@


1.91
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d382 1
d422 1
a422 1
	      utmp = extract_unsigned_integer (insn_ptr, 1);
d427 1
a427 1
	      utmp = extract_unsigned_integer (insn_ptr, 2);
d432 1
a432 1
	      utmp = extract_unsigned_integer (insn_ptr, 4);
@


1.90
log
@ChangeLog:

2009-06-30  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	gdb/10275
	* dwarf2-frame.c (dwarf2_frame_state): Move cfa_offset, cfa_reg,
	cfa_how and cfa_exp into regs and adjust users.

testsuite/ChangeLog:

2009-06-30  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	gdb/10275
	* gdb.dwarf2/dw2-restore.{S,exp}: New test.
@
text
@d337 1
a337 1
register %s (#%d) at 0x%s"),
d341 1
a341 1
		       paddr (fs->pc));
d493 2
a494 1
bad CFI data; mismatched DW_CFA_restore_state at 0x%s"), paddr (fs->pc));
d1001 1
a1001 1
incomplete CFI data; unspecified registers (e.g., %s) at 0x%s"),
d1003 1
a1003 1
			 paddr_nz (fs->pc));
@


1.89
log
@2009-06-18  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* dwarf2-frame.c (struct comp_unit): Use bfd_size_type for
	dwarf_frame_size.
@
text
@d167 9
a179 9
  LONGEST cfa_offset;
  ULONGEST cfa_reg;
  gdb_byte *cfa_exp;
  enum {
    CFA_UNSET,
    CFA_REG_OFFSET,
    CFA_EXP
  } cfa_how;

d505 1
a505 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &fs->cfa_reg);
d511 2
a512 2
	      fs->cfa_offset = utmp;
	      fs->cfa_how = CFA_REG_OFFSET;
d516 5
a520 4
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &fs->cfa_reg);
	      fs->cfa_reg = dwarf2_frame_adjust_regnum (gdbarch, fs->cfa_reg,
							eh_frame_p);
	      fs->cfa_how = CFA_REG_OFFSET;
d529 1
a529 1
	      fs->cfa_offset = utmp;
d537 5
a541 4
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &fs->cfa_exp_len);
	      fs->cfa_exp = insn_ptr;
	      fs->cfa_how = CFA_EXP;
	      insn_ptr += fs->cfa_exp_len;
d594 4
a597 3
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &fs->cfa_reg);
	      fs->cfa_reg = dwarf2_frame_adjust_regnum (gdbarch, fs->cfa_reg,
							eh_frame_p);
d599 2
a600 2
	      fs->cfa_offset = offset * fs->data_align;
	      fs->cfa_how = CFA_REG_OFFSET;
d605 1
a605 1
	      fs->cfa_offset = offset * fs->data_align;
d938 1
a938 1
  switch (fs->cfa_how)
d941 1
a941 1
      cache->cfa = read_reg (this_frame, fs->cfa_reg);
d943 1
a943 1
	cache->cfa -= fs->cfa_offset;
d945 1
a945 1
	cache->cfa += fs->cfa_offset;
d950 1
a950 1
	execute_stack_op (fs->cfa_exp, fs->cfa_exp_len,
@


1.88
log
@2009-06-16  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* dwarf2read.c (dwarf_info_section, dwarf_abbrev_section)
	(dwarf_line_section, dwarf_pubnames_section, dwarf_aranges_section)
	(dwarf_loc_section, dwarf_macinfo_section, dwarf_str_section)
	(dwarf_ranges_section, dwarf_frame_section)
	(dwarf_eh_frame_section): Removed.
	(dwarf2_resize_section): Likewise.
	(dwarf2_read_section): Now static, use bfd_mmap() if possible.
	(dwarf2_get_section_info): New function.
	(munmap_section_buffer): Likewise.
	(dwarf2_per_objfile_cleanup): Likewise.
	(section_is_p): Signature change.
	* dwarf2-frame.c (dwarf2_build_frame_info): Use
	dwarf2_get_section_info instead of dwarf2_read_section.
@
text
@d133 1
a133 1
  unsigned long dwarf_frame_size;
@


1.87
log
@        Updated copyright notices for most files.
@
text
@a1898 7
/* FIXME: kettenis/20030504: This still needs to be integrated with
   dwarf2read.c in a better way.  */

/* Imported from dwarf2read.c.  */
extern asection *dwarf_frame_section;
extern asection *dwarf_eh_frame_section;

d1900 2
a1901 1
extern gdb_byte *dwarf2_read_section (struct objfile *objfile, asection *sectp);
d1919 5
a1923 1
  if (dwarf_eh_frame_section)
a1927 6
      unit->dwarf_frame_buffer = dwarf2_read_section (objfile,
						      dwarf_eh_frame_section);

      unit->dwarf_frame_size = bfd_get_section_size (dwarf_eh_frame_section);
      unit->dwarf_frame_section = dwarf_eh_frame_section;

d1947 5
a1951 1
  if (dwarf_frame_section)
a1953 4
      unit->dwarf_frame_buffer = dwarf2_read_section (objfile,
						      dwarf_frame_section);
      unit->dwarf_frame_size = bfd_get_section_size (dwarf_frame_section);
      unit->dwarf_frame_section = dwarf_frame_section;
@


1.86
log
@	* dwarf2expr.h (dwarf2_read_address): Add gdbarch argument.
	* dwarf2expr.c (dwarf2_read_address): Add gdbarch argument.
	Call gdbarch_integer_to_address directly instead of converting
	to value and back.  Update comment.
	(execute_stack_op): Update call site.
	* dwarf2loc.c (find_location_expression): Likewise.
	(locexpr_describe_location): Update

	* dwarf2expr.h (struct dwarf_expr_context): Add gdbarch member.
	* dwarf2-frame.c (execute_stack_op): Initialize ctx->gdbarch.
	* dwarf2loc. (dwarf2_evaluate_loc_desc): Likewise.
	(dwarf2_loc_desc_needs_frame): Likewise.
@
text
@d3 2
a4 1
   Copyright (C) 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.85
log
@* dwarf2-frame.c (dwarf2_frame_cache): Update comment.

* frame.c (frame_unwind_address_in_block): Delete.
(get_frame_address_in_block): Do not use it.  Check the type
of the next frame first.
(frame_cleanup_after_sniffer): Update comment.
* frame.h (frame_unwind_address_in_block): Delete prototype.
* hppa-tdep.c (hppa_find_unwind_entry_in_block): Update comment.
@
text
@d351 1
@


1.84
log
@2008-05-03  Luis Machado  <luisgpm@@br.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* cli/cli-decode.c (lookup_cmd_1): Fix indentation.
	* doublest.c (convert_typed_floating): Fix typo in comment.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame-unwind.h (frame_sniffer_ftype): Likewise.
	* frame.c (frame_unwind_address_in_block): Likewise.
	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): Likewise.
	* symtab.h (struct symbol): Likewise.
	* tramp-frame.h (struct trad_frame_cache): Likewise.
	* value.c (allocate_repeat_value): Likewise.
@
text
@d903 1
a903 1
     frame_unwind_address_in_block does just this.  It's not clear how
@


1.83
log
@	* arm-linux-tdep.h (ARM_CPSR_REGNUM): Delete definition.
	* arm-tdep.c (arm_frame_is_thumb): New.
	(arm_pc_is_thumb): Clarify comment.
	(thumb_analyze_prologue): Remove PC special case.
	(thumb_scan_prologue): Take a block_addr argument.  Use it for
	find_pc_partial_function.  Remove unused variables.
	(arm_scan_prologue): Use arm_frame_is_thumb.  Use the block address
	for find_pc_partial_function.  Remove PC special case.
	(arm_prologue_prev_register): Add special handling for PC and CPSR.
	(arm_dwarf2_prev_register, arm_dwarf2_frame_init_reg): New.
	(arm_get_next_pc): Use arm_frame_is_thumb.
	(arm_write_pc): Use CPSR_T instead of 0x20.
	(arm_gdbarch_init): Call dwarf2_frame_set_init_reg.
	* arm-tdep.h (enum gdb_regnum): Add ARM_CPSR_REGNUM.
	(CPSR_T): Define.
	* dwarf2-frame.c (dwarf2_frame_prev_register): Handle
	DWARF2_FRAME_REG_FN.
	* dwarf2-frame.h (enum dwarf2_frame_reg_rule): Add
	DWARF2_FRAME_REG_FN.
	(struct dwarf2_frame_state_reg): Add FN to loc union.

	* gdb.arch/thumb-prologue.exp: Do not expect a saved PC.
@
text
@d932 1
a932 1
  /* Caclulate the CFA.  */
@


1.82
log
@	* dwarf2-frame.c (read_reg): Expect this_frame in the baton.
	(execute_stack_op): Put this_frame in the baton.
	(execute_cfa_program): Take this_frame.
	(struct dwarf2_frame_ops): Update comment for signal_frame_p.
	(dwarf2_frame_default_init_reg, dwarf2_frame_init_reg)
	(dwarf2_frame_signal_frame_p, dwarf2_frame_cache)
	(dwarf2_frame_this_id): Adjust to work on this_frame.
	(dwarf2_signal_frame_this_id): Delete.
	(dwarf2_frame_prev_register): Update signature.  Use new frame
	unwind methods.
	(dwarf2_frame_sniffer): Update signature.  Expect this_frame.
	(dwarf2_frame_unwind, dwarf2_signal_frame_unwind): Add
	dwarf2_frame_sniffer.
	(dwarf2_append_unwinders): New.
	(dwarf2_frame_base_address, dwarf2_frame_base_sniffer): Expect
	this_frame.
	* sparc-tdep.c (sparc32_dwarf2_struct_return_p)
	(sparc32_dwarf2_frame_init_reg): Expect this_frame.
	* cris-tdep.c (cris_dwarf2_frame_init_reg): Likewise.
	* rs6000-tdep.c (ppc_dwarf2_frame_init_reg): Likewise.
	* s390-tdep.c (s390_dwarf2_frame_init_reg): Likewise.
	* sh-tdep.c (sh_dwarf2_frame_init_reg): Likewise.
	* sparc64-tdep.c (sparc64_dwarf2_frame_init_reg): Likewise.
	* dwarf2-frame.h (dwarf2_frame_sniffer): Delete declaration.
	(dwarf2_append_unwinders): Declare.
	(dwarf2_frame_base_sniffer): Update declaration.
	* i386-linux-tdep.c (i386_linux_dwarf_signal_frame_p): Expect
	this_frame.
@
text
@d1142 3
@


1.81
log
@	* objfiles.h (struct objfile): New GDBARCH member.
	(get_objfile_arch): Add prototype.
	* objfiles.c: Include "arch-utils.h".
	(allocate_objfile): Look up gdbarch associated with bfd.
	(get_objfile_arch): New function.
	* Makefile (objfiles.o): Update dependencies.

	* dwarf2-frame.c (decode_frame_entry_1): Replace current_gdbarch
	by objfile arch.
	* dwarf2loc.c (dwarf_expr_read_reg): Replace current_gdbarch
	by frame arch.
	(locexpr_describe_location): Replace current_gdbarch by
	objfile arch.
	* dwarf2read.c (die_type): Replace current_gdbarch by objfile arch.
	(dwarf2_add_field): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_base_type): Likewise.
	(new_symbol): Likewise.

	* coffread.c (decode_type): Add OBJFILE argument.  Update callers.
	(decode_base_type, decode_function_type): Likewise.
	(coff_read_struct_type, coff_read_enum_type): Likewise.
	(coff_symtab_read): Replace current_gdbarch by objfile arch.
	(decode_base_type): Likewise.
	(coff_read_enum_type): Likewise.
	(coff_read_struct_type): Replace current_objfile by OBJFILE argument.
	(coff_read_enum_type): Likewise.

	* dbxread.c (read_dbx_symtab): Replace current_gdbarch by objfile arch.
	(end_psymtab): Likewise.
	(process_one_symbol): Likewise.

	* mdebugread.c (parse_symbol): Replace current_gdbarch by objfile arch.
	(parse_procedure): Likewise.
	(parse_partial_symbols): Likewise.

	* somread.c (som_symtab_read): Replace current_gdbarch by objfile arch.

	* stabsread.c (define_symbol): Replace current_gdbarch by objfile arch.
	Replace static pcc_promotion_type and pcc_unsigned_promotion_type by
	built-in types.
	(read_range_type): Replace current_gdbarch by objfile arch.  Replace
	static range_index_type by built-in type.
	(read_one_struct_field): Replace current_gdbarch by objfile arch.
	(read_enum_type): Likewise.

	* xcoffread.c (read_xcoff_symtab): Replace current_gdbarch by
	objfile arch.
@
text
@d275 2
a276 2
  struct frame_info *next_frame = (struct frame_info *) baton;
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d283 1
a283 1
  frame_unwind_register (next_frame, regnum, buf);
d345 1
a345 1
		  struct frame_info *next_frame, CORE_ADDR initial)
d352 1
a352 1
  ctx->baton = next_frame;
d363 1
a363 1
    result = read_reg (next_frame, result);
d373 1
a373 1
		     gdb_byte *insn_end, struct frame_info *next_frame,
d377 1
a377 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
d379 1
a379 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d613 1
a613 2
		struct gdbarch *gdbarch = get_frame_arch (next_frame);
		int size = register_size(gdbarch, 0);
d666 1
a666 2
  /* Check whether the frame preceding NEXT_FRAME will be a signal
     trampoline.  */
d680 1
a680 1
			       struct frame_info *next_frame)
d745 1
a745 1
		       struct frame_info *next_frame)
d749 1
a749 1
  ops->init_reg (gdbarch, regnum, reg, next_frame);
d766 1
a766 1
   NEXT_FRAME.  */
d770 1
a770 1
			     struct frame_info *next_frame)
d776 1
a776 1
  return ops->signal_frame_p (gdbarch, next_frame);
d869 1
a869 1
dwarf2_frame_cache (struct frame_info *next_frame, void **this_cache)
d872 1
a872 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d893 1
a893 1
     Note that if NEXT_FRAME is never supposed to return (i.e. a call
d895 1
a895 1
     NEXT_FRAME's return address.  As a result the return address will
d906 1
a906 1
  fs->pc = frame_unwind_address_in_block (next_frame, NORMAL_FRAME);
d923 1
a923 1
		       fde->cie->end, next_frame, fs);
d930 1
a930 1
  execute_cfa_program (fde, fde->instructions, fde->end, next_frame, fs);
d936 1
a936 1
      cache->cfa = read_reg (next_frame, fs->cfa_reg);
d946 1
a946 1
			  cache->addr_size, next_frame, 0);
d958 1
a958 1
      dwarf2_frame_init_reg (gdbarch, regnum, &cache->reg[regnum], next_frame);
d1061 1
a1061 1
dwarf2_frame_this_id (struct frame_info *next_frame, void **this_cache,
d1065 1
a1065 1
    dwarf2_frame_cache (next_frame, this_cache);
d1070 1
a1070 2
  (*this_id) = frame_id_build (cache->cfa,
			       frame_func_unwind (next_frame, NORMAL_FRAME));
d1073 3
a1075 3
static void
dwarf2_signal_frame_this_id (struct frame_info *next_frame, void **this_cache,
			     struct frame_id *this_id)
d1077 1
d1079 3
a1081 18
    dwarf2_frame_cache (next_frame, this_cache);

  if (cache->undefined_retaddr)
    return;

  (*this_id) = frame_id_build (cache->cfa,
			       frame_func_unwind (next_frame, SIGTRAMP_FRAME));
}

static void
dwarf2_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			    int regnum, int *optimizedp,
			    enum lval_type *lvalp, CORE_ADDR *addrp,
			    int *realnump, gdb_byte *valuep)
{
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct dwarf2_frame_cache *cache =
    dwarf2_frame_cache (next_frame, this_cache);
d1088 1
a1088 12
      *optimizedp = 1;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  /* In some cases, for example %eflags on the i386, we have
	     to provide a sane value, even though this register wasn't
	     saved.  Assume we can get it from NEXT_FRAME.  */
	  frame_unwind_register (next_frame, regnum, valuep);
	}
      break;
d1091 2
a1092 10
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->cfa + cache->reg[regnum].loc.offset;
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep, register_size (gdbarch, regnum));
	}
      break;
d1095 3
a1097 8
      *optimizedp = 0;
      *lvalp = lval_register;
      *addrp = 0;
      *realnump = gdbarch_dwarf2_reg_to_regnum
		    (gdbarch, cache->reg[regnum].loc.reg);
      if (valuep)
	frame_unwind_register (next_frame, (*realnump), valuep);
      break;
d1100 4
a1103 12
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = execute_stack_op (cache->reg[regnum].loc.exp,
				 cache->reg[regnum].exp_len,
				 cache->addr_size, next_frame, cache->cfa);
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep, register_size (gdbarch, regnum));
	}
      break;
d1106 2
a1107 8
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	store_unsigned_integer (valuep, register_size (gdbarch, regnum),
				cache->cfa + cache->reg[regnum].loc.offset);
      break;
d1110 4
a1113 11
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	store_unsigned_integer (valuep, register_size (gdbarch, regnum),
				execute_stack_op (cache->reg[regnum].loc.exp,
						  cache->reg[regnum].exp_len,
						  cache->addr_size, next_frame,
						  cache->cfa));
      break;
d1123 1
a1123 7
      *optimizedp = 0;
      *lvalp = lval_register;
      *addrp = 0;
      *realnump = regnum;
      if (valuep)
	frame_unwind_register (next_frame, (*realnump), valuep);
      break;
d1126 1
a1126 7
      *optimizedp = 0;
      *lvalp = lval_register;
      *addrp = 0;
      *realnump = regnum;
      if (valuep)
	frame_unwind_register (next_frame, (*realnump), valuep);
      break;
d1129 1
a1129 7
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	pack_long (valuep, register_type (gdbarch, regnum), cache->cfa);
      break;
d1132 2
a1133 8
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	pack_long (valuep, register_type (gdbarch, regnum),
		   cache->cfa + cache->reg[regnum].loc.offset);
      break;
d1136 5
a1140 14
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
        {
          CORE_ADDR pc = cache->reg[regnum].loc.offset;

          regnum = gdbarch_dwarf2_reg_to_regnum
		     (gdbarch, cache->retaddr_reg.loc.reg);
          pc += frame_unwind_register_unsigned (next_frame, regnum);
          pack_long (valuep, register_type (gdbarch, regnum), pc);
        }
      break;
d1147 3
a1149 16
static const struct frame_unwind dwarf2_frame_unwind =
{
  NORMAL_FRAME,
  dwarf2_frame_this_id,
  dwarf2_frame_prev_register
};

static const struct frame_unwind dwarf2_signal_frame_unwind =
{
  SIGTRAMP_FRAME,
  dwarf2_signal_frame_this_id,
  dwarf2_frame_prev_register
};

const struct frame_unwind *
dwarf2_frame_sniffer (struct frame_info *next_frame)
d1152 1
a1152 1
     function.  frame_pc_unwind(), for a no-return next function, can
d1156 3
a1158 3
     extend one byte before its start address or we will miss it.  */
  CORE_ADDR block_addr = frame_unwind_address_in_block (next_frame,
							NORMAL_FRAME);
d1161 1
a1161 1
    return NULL;
d1168 3
a1170 3
      || dwarf2_frame_signal_frame_p (get_frame_arch (next_frame),
				      next_frame))
    return &dwarf2_signal_frame_unwind;
d1172 28
a1199 1
  return &dwarf2_frame_unwind;
d1210 1
a1210 1
dwarf2_frame_base_address (struct frame_info *next_frame, void **this_cache)
d1213 1
a1213 1
    dwarf2_frame_cache (next_frame, this_cache);
d1227 1
a1227 1
dwarf2_frame_base_sniffer (struct frame_info *next_frame)
d1229 1
a1229 2
  CORE_ADDR block_addr = frame_unwind_address_in_block (next_frame,
							NORMAL_FRAME);
@


1.80
log
@2008-03-18  Ulrich Weigand  <uweigand@@de.ibm.com>
	    Jim Blandy  <jimb@@codesourcery.com>
	    Daniel Jacobowitz  <drow@@false.org>

	* dwarf2expr.h (struct dwarf_expr_context): Add ADDR_SIZE member.
	(dwarf2_read_address): Update prototype.

	* dwarf2expr.c (unsigned_address_type): Add ADDR_SIZE parameter.
	(signed_address_type): Likewise.
	(dwarf2_read_address): Replace BYTES_READ parameter with ADDR_SIZE.
	(execute_stack_op): Update calls to unsigned_address_type,
	signed_address_type and dwarf2_read_address.  Fix implementation
	of DW_OP_deref_size.

	* dwarf2loc.h (dwarf2_per_cu_objfile): Add prototype.
	(dwarf2_per_cu_addr_size): Likewise.
	(struct dwarf2_locexpr_baton): Replace OBJFILE with PER_CU.
	(struct dwarf2_loclist_baton): Likewise.

	* dwarf2loc.c (find_location_expression): Update calls to
	dwarf2_read_address.  Use dwarf2_per_cu_objfile and
	dwarf2_per_cu_addr_size to retrieve PER_CU parameters.
	(locexpr_describe_location): Likewise.
	(dwarf2_evaluate_loc_desc): Replace OBJFILE with PER_CU parameter.
	Set ctx->addr_size to dwarf2_per_cu_addr_size (per_cu).
	(dwarf2_loc_desc_needs_frame): Add PER_CU parameter.  Set ctx->addr_size
	to dwarf2_per_cu_addr_size (per_cu).
	(locexpr_read_variable): Update dwarf2_evaluate_loc_desc call.
	(loclist_read_variable): Likewise.
	(locexpr_read_needs_frame): Update dwarf2_loc_desc_needs_frame call.

	* dwarf2read.c (dwarf2_symbol_mark_computed): Set baton->per_cu
	instead of baton->objfile.
	(dwarf2_per_cu_obfile): New function.
	(dwarf2_per_cu_addr_size): Likewise.

	* dwarf2-frame.c (struct comp_unit): Move higher.
	(struct dwarf2_cie): Add UNIT and ADDR_SIZE members.
	(execute_stack_op): Add ADDR_SIZE parameter; set ctx->addr_size.
	(execute_cfa_program): Add FDE parameter.  Replace EH_FRAME_P
	parameter by using fde->eh_frame_p.  Use read_encoded_value
	to implement DW_CFA_set_loc.
	(struct dwarf2_frame_cache): Add ADDR_SIZE member.
	(dwarf2_frame_cache): Set cache->addr_size.  Update calls to
	execute_stack_op and execute_cfa_program.
	(dwarf2_frame_prev_register): Update calls to execute_stack_op.
	(size_of_encoded_value): Remove.
	(read_encoded_value): Add PTR_LEN and FUNC_BASE parameters.
	Remove call to size_of_encoded_value.  Implement DW_EH_PE_funcrel.
	(add_cie): Set cie->unit backlink.
	(decode_frame_entry_1): Set cie->addr_size.  Update calls to
	read_encoded_value.
	(dwarf2_build_frame_info): Allocate UNIT on objfile obstack.
@
text
@d1623 1
d1694 1
a1694 1
      cie->addr_size = gdbarch_ptr_bit (current_gdbarch) / TARGET_CHAR_BIT;
d1722 1
a1722 1
	  buf += TYPE_LENGTH (builtin_type_void_data_ptr);
d1743 1
a1743 1
	= dwarf2_frame_adjust_regnum (current_gdbarch,
@


1.79
log
@	Updated copyright notices for most files.
@
text
@d41 2
d49 3
d76 3
d115 29
d148 5
d344 1
a344 1
execute_stack_op (gdb_byte *exp, ULONGEST len,
d351 1
d372 3
a374 3
execute_cfa_program (gdb_byte *insn_ptr, gdb_byte *insn_end,
		     struct frame_info *next_frame,
		     struct dwarf2_frame_state *fs, int eh_frame_p)
d376 1
d409 6
a414 1
	      fs->pc = dwarf2_read_address (insn_ptr, insn_end, &bytes_read);
d865 3
d918 1
d924 2
a925 2
  execute_cfa_program (fde->cie->initial_instructions,
		       fde->cie->end, next_frame, fs, fde->eh_frame_p);
d932 1
a932 2
  execute_cfa_program (fde->instructions, fde->end, next_frame, fs,
		       fde->eh_frame_p);
d947 2
a948 1
	execute_stack_op (fs->cfa_exp, fs->cfa_exp_len, next_frame, 0);
d1145 1
a1145 1
				 next_frame, cache->cfa);
d1173 2
a1174 1
						  next_frame, cache->cfa));
a1317 29
/* A minimal decoding of DWARF2 compilation units.  We only decode
   what's needed to get to the call frame information.  */

struct comp_unit
{
  /* Keep the bfd convenient.  */
  bfd *abfd;

  struct objfile *objfile;

  /* Linked list of CIEs for this object.  */
  struct dwarf2_cie *cie;

  /* Pointer to the .debug_frame section loaded into memory.  */
  gdb_byte *dwarf_frame_buffer;

  /* Length of the loaded .debug_frame section.  */
  unsigned long dwarf_frame_size;

  /* Pointer to the .debug_frame section.  */
  asection *dwarf_frame_section;

  /* Base for DW_EH_PE_datarel encodings.  */
  bfd_vma dbase;

  /* Base for DW_EH_PE_textrel encodings.  */
  bfd_vma tbase;
};

a1444 21
static unsigned int
size_of_encoded_value (gdb_byte encoding)
{
  if (encoding == DW_EH_PE_omit)
    return 0;

  switch (encoding & 0x07)
    {
    case DW_EH_PE_absptr:
      return TYPE_LENGTH (builtin_type_void_data_ptr);
    case DW_EH_PE_udata2:
      return 2;
    case DW_EH_PE_udata4:
      return 4;
    case DW_EH_PE_udata8:
      return 8;
    default:
      internal_error (__FILE__, __LINE__, _("Invalid or unsupported encoding"));
    }
}

d1447 2
a1448 1
		    gdb_byte *buf, unsigned int *bytes_read_ptr)
a1449 1
  int ptr_len = size_of_encoded_value (DW_EH_PE_absptr);
d1477 1
a1477 6
      /* FIXME: kettenis/20040501: For now just pretend
         DW_EH_PE_funcrel is equivalent to DW_EH_PE_absptr.  For
         reading the initial location of an FDE it should be treated
         as such, and currently that's the only place where this code
         is used.  */
      base = 0;
d1563 1
d1688 7
d1783 2
a1784 1
	      read_encoded_value (unit, encoding, buf, &bytes_read);
d1848 2
a1849 1
	read_encoded_value (unit, fde->cie->encoding, buf, &bytes_read);
d1853 2
a1854 1
	read_encoded_value (unit, fde->cie->encoding & 0x0f, buf, &bytes_read);
d1988 1
a1988 1
  struct comp_unit unit;
d1992 6
a1997 4
  unit.abfd = objfile->obfd;
  unit.objfile = objfile;
  unit.dbase = 0;
  unit.tbase = 0;
d2005 3
a2007 3
      unit.cie = NULL;
      unit.dwarf_frame_buffer = dwarf2_read_section (objfile,
						     dwarf_eh_frame_section);
d2009 2
a2010 2
      unit.dwarf_frame_size = bfd_get_section_size (dwarf_eh_frame_section);
      unit.dwarf_frame_section = dwarf_eh_frame_section;
d2016 1
a2016 1
      got = bfd_get_section_by_name (unit.abfd, ".got");
d2018 1
a2018 1
	unit.dbase = got->vma;
d2022 1
a2022 1
      txt = bfd_get_section_by_name (unit.abfd, ".text");
d2024 1
a2024 1
	unit.tbase = txt->vma;
d2026 3
a2028 3
      frame_ptr = unit.dwarf_frame_buffer;
      while (frame_ptr < unit.dwarf_frame_buffer + unit.dwarf_frame_size)
	frame_ptr = decode_frame_entry (&unit, frame_ptr, 1);
d2033 9
a2041 9
      unit.cie = NULL;
      unit.dwarf_frame_buffer = dwarf2_read_section (objfile,
						     dwarf_frame_section);
      unit.dwarf_frame_size = bfd_get_section_size (dwarf_frame_section);
      unit.dwarf_frame_section = dwarf_frame_section;

      frame_ptr = unit.dwarf_frame_buffer;
      while (frame_ptr < unit.dwarf_frame_buffer + unit.dwarf_frame_size)
	frame_ptr = decode_frame_entry (&unit, frame_ptr, 0);
@


1.79.6.1
log
@Check in ARCompact simulator.  A valid configuration is arc-elf.
This is not quite finished and has most likely a few files that are
obsolete & not used, but it's good enough to run gcc regression tests.
@
text
@a594 4
	    case DW_CFA_MWARC_info:
	      /* Ignored.  */
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
	      break;
a1717 2
      if (augmentation[0] == 'H' && augmentation [1] == 'C')
      augmentation += 2;
@


1.79.6.2
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@d595 4
d1722 2
@


1.78
log
@	* dwarf2-frame.c (execute_cfa_program): Call dwarf2_restore_rule
	function to handle required actions for the DW_CFA_restore and
	DW_CFA_restore_extended instructions.
	(dwarf2_restore_rule): New function.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.77
log
@2007-10-08  Markus Deuling  <deuling@@de.ibm.com>

	* dwarf2-frame.c (read_reg, execute_cfa_program, dwarf2_frame_cache)
	(dwarf2_frame_default_init_reg, dwarf2_frame_prev_register): Replace
	current_gdbarch by gdbarch.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Likewise.
@
text
@d271 30
a356 1
	  gdb_assert (fs->initial.reg);
d358 1
a358 15
	  reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
	  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	  if (reg < fs->initial.num_regs)
	    fs->regs.reg[reg] = fs->initial.reg[reg];
	  else 
	    fs->regs.reg[reg].how = DWARF2_FRAME_REG_UNSPECIFIED;

	  if (fs->regs.reg[reg].how == DWARF2_FRAME_REG_UNSPECIFIED)
	    complaint (&symfile_complaints, _("\
incomplete CFI data; DW_CFA_restore unspecified\n\
register %s (#%d) at 0x%s"),
		       gdbarch_register_name
			 (gdbarch, gdbarch_dwarf2_reg_to_regnum (gdbarch, reg)),
		       gdbarch_dwarf2_reg_to_regnum (gdbarch, reg),
		       paddr (fs->pc));
a395 1
	      gdb_assert (fs->initial.reg);
d397 1
a397 3
	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	      fs->regs.reg[reg] = fs->initial.reg[reg];
@


1.76
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d238 1
a238 1
  regnum = gdbarch_dwarf2_reg_to_regnum (current_gdbarch, reg);
d341 2
a342 3
			 (current_gdbarch, gdbarch_dwarf2_reg_to_regnum
					     (current_gdbarch, reg)),
		       gdbarch_dwarf2_reg_to_regnum (current_gdbarch, reg),
d649 1
a649 1
  if (regnum == gdbarch_pc_regnum (current_gdbarch))
d651 1
a651 1
  else if (regnum == gdbarch_sp_regnum (current_gdbarch))
d811 2
a812 2
  const int num_regs = gdbarch_num_regs (current_gdbarch)
		       + gdbarch_num_pseudo_regs (current_gdbarch);
d911 1
a911 1
	int regnum = gdbarch_dwarf2_reg_to_regnum (current_gdbarch, column);
d1070 1
a1070 1
		    (current_gdbarch, cache->reg[regnum].loc.reg);
d1165 1
a1165 1
		     (current_gdbarch, cache->retaddr_reg.loc.reg);
@


1.75
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.74
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (STAB_REG_TO_REGNUM): Replace by
	gdbarch_stab_reg_to_regnum.
	* stabsread.c (define_symbol): Likewise.
	* gdbarch.sh (ECOFF_REG_TO_REGNUM): Replace by
	gdbarch_ecoff_reg_to_regnum.
	* mdebugread.c (parse_symbol): Likewise.
	* i386-tdep.c (i386_gdbarch_init): Likewise (comment).
	* gdbarch.sh (DWARF_REG_TO_REGNUM): Replace by
	gdbarch_dwarf_reg_to_regnum.
	* gdbarch.sh (SDB_REG_TO_REGNUM): Replace by gdbarch_sdb_reg_to_regnum.
	* coffread.c (process_coff_symbol): Likewise.
	* gdbarch.sh (DWARF2_REG_TO_REGNUM): Replace by
	gdbarch_dwarf2_reg_to_regnum.
	* dwarf2loc.c (dwarf_expr_read_reg,dwarf2_evaluate_loc_desc)
	(locexpr_describe_location): Likewise.
	* dwarf2-frame.c (read_reg,execute_cfa_program,dwarf2_frame_cache)
	(dwarf2_frame_prev_register,dwarf2_signal_frame_this_id): Likewise.
	* dwarf2loc.c (DWARF2_REG_TO_REGNUM): Remove macro.
	* dwarf2read.c (DWARF2_REG_TO_REGNUM): Remove macro.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d652 1
a652 1
  if (regnum == PC_REGNUM)
d654 1
a654 1
  else if (regnum == SP_REGNUM)
@


1.73
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (REGISTER_NAME): Replace by gdbarch_register_name.
	* tracepoint.c (scope_info): Likewise.
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_register_reggroup_p): Likewise.
	* sh64-tdep.c (sh64_do_fp_register, sh64_do_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_reggroup_p): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* remote.c (packet_reg): Likewise (comment).
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* printcmd.c (address_info): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* mt-dep.c (mt_registers_info): Likewise.
	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Likewise (comment).
	* mips-tdep.c (mips_register_reggroup_p, mips_read_fp_register_single)
	(mips_read_fp_register_double, mips_print_fp_register)
	(mips_print_register, print_gp_register_row, mips_print_registers_info)
	(mips_register_sim_regno): Likewise.
	* m68klinux-nat.c (regmap, fetch_register, store_register): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register)
	(inf_ptrace_store_register): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register)
	(ia64_linux_store_register): Likewise.
	* i386-linux-nat.c (fetch_register, store_register): Likewise.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register)
	(hppa_hpux_store_register): Likewise.
	* findvar.c (locate_var_value): Likewise.
	* dwarf2loc.c (locexpr_describe_location): Likewise.
	* dwarf2-frame.c (execute_cfa_program): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* arch-utils.c (legacy_register_sim_regno): Likewise.
	* alpha-tdep.c (alpha_register_reggroup_p): Likewise.
	* alpha-nat.c (fetch_osf_core_registers): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers, mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d240 1
a240 1
  regnum = DWARF2_REG_TO_REGNUM (reg);
d343 4
a346 2
			 (current_gdbarch, DWARF2_REG_TO_REGNUM(reg)),
		       DWARF2_REG_TO_REGNUM(reg), paddr (fs->pc));
d906 1
a906 1
     DWARF2_REG_TO_REGNUM should be defined to return a number outside
d914 1
a914 1
	int regnum = DWARF2_REG_TO_REGNUM (column);
d1072 2
a1073 1
      *realnump = DWARF2_REG_TO_REGNUM (cache->reg[regnum].loc.reg);
d1167 2
a1168 1
          regnum = DWARF2_REG_TO_REGNUM (cache->retaddr_reg.loc.reg);
@


1.72
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d342 2
a343 1
		       REGISTER_NAME(DWARF2_REG_TO_REGNUM(reg)),
@


1.71
log
@	* dwarf2-frame.c (dwarf2_frame_prev_register): Use pack_long
	instead of store_typed_address.
	* value.c (pack_long): New.
	(value_from_longest): Use it.
	* value.h (pack_long): New prototype.
@
text
@d166 1
a166 1
/* Assert that the register set RS is large enough to store NUM_REGS
d811 2
a812 1
  const int num_regs = NUM_REGS + NUM_PSEUDO_REGS;
d904 1
a904 1
     the range [0, NUM_REGS).  */
@


1.70
log
@	* dwarf2-frame.c (read_encoded_value): Correct typo.  Use
	DW_EH_PE_signed if appropriate.
@
text
@d1140 1
a1140 4
	{
	  /* Store the value.  */
	  store_typed_address (valuep, builtin_type_void_data_ptr, cache->cfa);
	}
d1149 2
a1150 5
	{
	  /* Store the value.  */
	  store_typed_address (valuep, builtin_type_void_data_ptr,
			       cache->cfa + cache->reg[regnum].loc.offset);
	}
d1164 1
a1164 1
          store_typed_address (valuep, builtin_type_void_func_ptr, pc);
@


1.69
log
@	* dwarf2-frame.c (dwarf2_frame_eh_frame_regnum): Rename to...
	(dwarf2_frame_adjust_regnum): ...this.  Make static.  Add eh_frame_p
	argument.  Update all callers.
	(struct dwarf2_frame_ops): Replace eh_frame_regnum with adjust_regnum.
	(dwarf2_frame_set_eh_frame_regnum): Rename to...
	(dwarf2_frame_set_adjust_regnum): ...this.  Update argument type.
	* dwarf2frame.h (dwarf2_frame_set_eh_frame_regnum): Rename to...
	(dwarf2_frame_set_adjust_regnum): ...this.
	(dwarf2_frame_eh_frame_regnum): Delete prototype.
	* rs6000-tdep.c: Include "dwarf2-frame.h".
	(rs6000_adjust_frame_regnum): Define.
	(rs6000_gdbarch_init): Enable use of DWARF CFI frame unwinder.
	Register rs6000_adjust_frame_regnum.

	* Makefile.in (rs6000-tdep.o): Update dependencies.
@
text
@d1454 1
a1454 1
      base = bfd_get_section_vma (unit->bfd, unit->dwarf_frame_section);
d1485 5
a1489 1
    encoding |= encoding_for_size (ptr_len);
@


1.68
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@d110 3
d320 1
a320 2
	  if (eh_frame_p)
	    reg = dwarf2_frame_eh_frame_regnum (gdbarch, reg);
d331 1
a331 2
	  if (eh_frame_p)
	    reg = dwarf2_frame_eh_frame_regnum (gdbarch, reg);
d372 1
a372 2
	      if (eh_frame_p)
		reg = dwarf2_frame_eh_frame_regnum (gdbarch, reg);
d383 1
a383 2
	      if (eh_frame_p)
		reg = dwarf2_frame_eh_frame_regnum (gdbarch, reg);
d390 1
a390 2
	      if (eh_frame_p)
		reg = dwarf2_frame_eh_frame_regnum (gdbarch, reg);
d397 1
a397 2
	      if (eh_frame_p)
		reg = dwarf2_frame_eh_frame_regnum (gdbarch, reg);
d404 1
a404 2
	      if (eh_frame_p)
		reg = dwarf2_frame_eh_frame_regnum (gdbarch, reg);
d406 1
a406 2
	      if (eh_frame_p)
		utmp = dwarf2_frame_eh_frame_regnum (gdbarch, utmp);
d454 2
a455 3
	      if (eh_frame_p)
		fs->cfa_reg = dwarf2_frame_eh_frame_regnum (gdbarch,
							    fs->cfa_reg);
d481 1
a481 2
	      if (eh_frame_p)
		reg = dwarf2_frame_eh_frame_regnum (gdbarch, reg);
d492 1
a492 2
	      if (eh_frame_p)
		reg = dwarf2_frame_eh_frame_regnum (gdbarch, reg);
d530 2
a531 3
	      if (eh_frame_p)
		fs->cfa_reg = dwarf2_frame_eh_frame_regnum (gdbarch,
							    fs->cfa_reg);
d575 1
a575 2
	      if (eh_frame_p)
		reg = dwarf2_frame_eh_frame_regnum (gdbarch, reg);
d610 3
a612 2
  /* Convert .eh_frame register number to DWARF register number.  */
  int (*eh_frame_regnum) (struct gdbarch *, int);
d720 2
a721 2
/* Set the architecture-specific mapping of .eh_frame register numbers to
   DWARF register numbers.  */
d724 3
a726 3
dwarf2_frame_set_eh_frame_regnum (struct gdbarch *gdbarch,
				  int (*eh_frame_regnum) (struct gdbarch *,
							  int))
d730 1
a730 1
  ops->eh_frame_regnum = eh_frame_regnum;
d733 2
a734 1
/* Translate a .eh_frame register to DWARF register.  */
d736 2
a737 2
int
dwarf2_frame_eh_frame_regnum (struct gdbarch *gdbarch, int regnum)
d741 1
a741 1
  if (ops->eh_frame_regnum == NULL)
d743 1
a743 1
  return ops->eh_frame_regnum (gdbarch, regnum);
d1721 4
a1724 4
      if (eh_frame_p)
	cie->return_address_register
	  = dwarf2_frame_eh_frame_regnum (current_gdbarch,
					  cie->return_address_register);
@


1.67
log
@	* dwarf2-frame.c (execute_cfa_program): New support of
	`DW_CFA_GNU_negative_offset_extended'.
@
text
@d851 1
a851 1
  fs->pc = frame_unwind_address_in_block (next_frame);
d1014 16
a1029 1
  (*this_id) = frame_id_build (cache->cfa, frame_func_unwind (next_frame));
d1197 1
a1197 1
  dwarf2_frame_this_id,
d1206 6
a1211 2
     end up returning something past the end of this function's body.  */
  CORE_ADDR block_addr = frame_unwind_address_in_block (next_frame);
d1255 3
a1257 2
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  if (dwarf2_frame_find_fde (&pc))
@


1.66
log
@Copyright updates for 2007.
@
text
@d582 11
@


1.65
log
@	* buildsym.c (start_subfile): Handle producer.
	(record_producer): New function.
	* buildsym.h (struct subfile): Include producer.
	(record_producer): New prototype.
	* dwarf2-frame.c (struct dwarf2_cie): Add version and augmentation.
	(struct dwarf2_frame_state): Add armcc_cfa_offsets_sf and
	armcc_cfa_offsets_reversed.
	(execute_cfa_program): Handle armcc_cfa_offsets_sf.
	(dwarf2_frame_find_quirks): New function.
	(dwarf2_frame_cache): Call it.  Handle armcc_cfa_offsets_reversed.
	(decode_frame_entry_1): Record the CIE version.  Record the
	augmentation.  Skip armcc augmentations.
	* dwarf2read.c (read_file_scope): Save the producer.
	* symtab.h (struct symtab): Rename unused version member to
	producer.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
@


1.64
log
@	* dwarf2-frame.c (decode_frame_entry_1): Skip unknown augmentations
	without skipping the CIE.
@
text
@d67 3
d79 3
d147 10
d449 4
d467 4
d742 43
d851 3
d871 4
a874 1
      cache->cfa += fs->cfa_offset;
d1660 1
d1664 1
a1664 1
      augmentation = (char *) buf;
d1667 5
@


1.63
log
@* dwarf2-frame.h (enum dwarf2_frame_reg_rule): Add
DWARF2_FRAME_REG_SAVED_VAL_OFFSET and
DWARF2_FRAME_REG_SAVED_VAL_EXP.
* dwarf2-frame.c (execute_cfa_program): Handle val_offset,
val_offset_sf and val_expression.
(dwarf2_frame_prev_register): Handle the new reg rules.
(dwarf2_frame_this_id): Use pc instead of function entry point.
@
text
@d1677 2
a1678 2
	  /* Otherwise we have an unknown augmentation.
	     Bail out unless we saw a 'z' prefix.  */
d1681 2
a1682 5
	      if (cie->initial_instructions == NULL)
		return end;

	      /* Skip unknown augmentations.  */
	      buf = cie->initial_instructions;
@


1.62
log
@* dwarf2-frame.c (struct dwarf2_cie): Add signal_frame field.
(dwarf2_frame_sniffer): Use it.
(decode_frame_entry_1): Set it according to augmentation "S".
@
text
@d484 28
d996 22
@


1.61
log
@	* dwarf2-frame.c: Include "value.h".
	(read_reg): Use unpack_long and register_type.
	* Makefile.in (dwarf2-frame.o): Update.
@
text
@d73 3
d1059 2
a1060 1
  if (!dwarf2_frame_find_fde (&block_addr))
d1067 3
a1069 2
  if (dwarf2_frame_signal_frame_p (get_frame_arch (next_frame),
				   next_frame))
d1529 4
d1616 11
@


1.60
log
@	* dwarf2-frame.c (struct dwarf2_fde): Add eh_frame_p.
	(execute_cfa_program): Add parameter eh_frame_p.  Call
	dwarf2_frame_eh_frame_regnum when true.
	(dwarf2_frame_cache): Pass eh_frame_p from fde to
	execute_cfa_program.
	(decode_frame_entry_1): Call dwarf2_frame_eh_frame_regnum when
	processing .eh_frame.  Copy eh_frame_p to the new fde.
	(struct dwarf2_frame_ops): Add eh_frame_regnum.
	(dwarf2_frame_set_eh_frame_regnum): Define.
	(dwarf2_frame_eh_frame_regnum): Define.

	* dwarf2-frame.h (dwarf2_frame_set_eh_frame_regnum): Declare.
	(dwarf2_frame_eh_frame_regnum): Declare.
@
text
@d35 1
d222 7
a228 1
  return extract_typed_address (buf, builtin_type_void_data_ptr);
@


1.60.2.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a34 1
#include "value.h"
a71 3
  /* True if an 'S' augmentation existed.  */
  unsigned char signal_frame;

d221 1
a221 7

  /* Convert the register to an integer.  This returns a LONGEST
     rather than a CORE_ADDR, but unpack_pointer does the same thing
     under the covers, and this makes more sense for non-pointer
     registers.  Maybe read_reg and the associated interfaces should
     deal with "struct value" instead of CORE_ADDR.  */
  return unpack_long (register_type (gdbarch, regnum), buf);
a473 28
	    case DW_CFA_val_offset:
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
	      offset = utmp * fs->data_align;
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_OFFSET;
	      fs->regs.reg[reg].loc.offset = offset;
	      break;

	    case DW_CFA_val_offset_sf:
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	      insn_ptr = read_sleb128 (insn_ptr, insn_end, &offset);
	      offset *= fs->data_align;
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_OFFSET;
	      fs->regs.reg[reg].loc.offset = offset;
	      break;

	    case DW_CFA_val_expression:
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
	      fs->regs.reg[reg].loc.exp = insn_ptr;
	      fs->regs.reg[reg].exp_len = utmp;
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_EXP;
	      insn_ptr += utmp;
	      break;

a957 22
    case DWARF2_FRAME_REG_SAVED_VAL_OFFSET:
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	store_unsigned_integer (valuep, register_size (gdbarch, regnum),
				cache->cfa + cache->reg[regnum].loc.offset);
      break;

    case DWARF2_FRAME_REG_SAVED_VAL_EXP:
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	store_unsigned_integer (valuep, register_size (gdbarch, regnum),
				execute_stack_op (cache->reg[regnum].loc.exp,
						  cache->reg[regnum].exp_len,
						  next_frame, cache->cfa));
      break;

d1049 1
a1049 2
  struct dwarf2_fde *fde = dwarf2_frame_find_fde (&block_addr);
  if (!fde)
d1056 2
a1057 3
  if (fde->cie->signal_frame
      || dwarf2_frame_signal_frame_p (get_frame_arch (next_frame),
				      next_frame))
a1516 4
      /* We'll determine the final value later, but we need to
	 initialize it conservatively.  */
      cie->signal_frame = 0;

a1599 11
	  /* "S" indicates a signal frame, such that the return
	     address must not be decremented to locate the call frame
	     info for the previous frame; it might even be the first
	     instruction of a function, so decrementing it would take
	     us to a different function.  */
	  else if (*augmentation == 'S')
	    {
	      cie->signal_frame = 1;
	      augmentation++;
	    }

@


1.59
log
@	* dwarf2-frame.c (dwarf2_frame_ops init_reg): Add "next_frame"
	argument.
	(dwarf2_frame_default_init_reg): Likewise.
	(dwarf2_frame_set_init_reg): Update init_reg arg.
	(dwarf2_frame_init_reg): Take "next_frame" and pass it to
	ops->init_reg().
	(dwarf2_frame_cache): Pass next_frame to dwarf2_frame_init_reg.
	* dwarf2-frame.h (dwarf2-frame_set_init_reg): Update declaration.
	* cris-tdep.c (cris_dwarf2_frame_init_reg): Add next_frame arg.
	* s390-tdep.c (s390_dwarf2_frame_init_reg): Likewise.
	* sh-tdep.c (sh_dwarf2_frame_init_reg): Likewise.
	* sparc64-tdep.c (sparc64_dwarf2_frame_init_reg): Likewise.
	* sparc-tdep.c (sparc32_struct_return_from_sym): New function.
	(sparc32_frame_cache): Call it.
	(sparc32_dwarf2_struct_return_p): New function.
	(sparc_dwarf2_frame_init_reg): Use it to determine if the function
	returns a structure and thus we have to indicate the return PC and
	NPC are 4 bytes later than usual.
@
text
@d92 4
d274 1
a274 1
		     struct dwarf2_frame_state *fs)
d278 1
d291 2
d303 2
d345 2
d357 2
d365 2
d373 2
d381 2
d384 2
d429 3
d453 2
d465 2
d476 3
d546 3
d655 25
d748 1
a748 1
		       fde->cie->end, next_frame, fs);
d755 2
a756 1
  execute_cfa_program (fde->instructions, fde->end, next_frame, fs);
d1553 5
d1675 2
@


1.58
log
@gdb/ChangeLog:
2006-01-17  Jim Blandy  <jimb@@redhat.com>

	* dwarf2-frame.c (dwarf2_read_section): Update forward declaration
	to match prior change to dwarf2_read_section's type.
@
text
@d509 2
a510 1
  void (*init_reg) (struct gdbarch *, int, struct dwarf2_frame_state_reg *);
d522 2
a523 1
			       struct dwarf2_frame_state_reg *reg)
d575 2
a576 1
					     struct dwarf2_frame_state_reg *))
d587 2
a588 1
		       struct dwarf2_frame_state_reg *reg)
d592 1
a592 1
  ops->init_reg (gdbarch, regnum, reg);
d720 1
a720 1
      dwarf2_frame_init_reg (gdbarch, regnum, &cache->reg[regnum]);
@


1.58.8.1
log
@	* buildsym.c (start_subfile): Handle producer.
	(record_producer): New function.
	* buildsym.h (struct subfile): Include producer.
	(record_producer): New prototype.
	* dwarf2-frame.c (struct dwarf2_cie): Add version.
	(struct dwarf2_frame_state): Add armcc_cfa_offsets_sf and
	armcc_cfa_offsets_reversed.
	(execute_cfa_program): Handle armcc_cfa_offsets_sf.
	(dwarf2_frame_find_quirks): New function.
	(dwarf2_frame_cache): Call it.  Handle armcc_cfa_offsets_reversed.
	(decode_frame_entry_1): Record the CIE version.
	* dwarf2read.c (read_file_scope): Save the producer.
	* symtab.h (struct symtab): Rename unused version member to
	producer.
@
text
@a71 3
  /* The version recorded in the CIE.  */
  unsigned char version;

a132 10

  /* Flags for known producer quirks.  */

  /* The ARM compilers, in DWARF2 mode, assume that DW_CFA_def_cfa
     and DW_CFA_def_cfa_offset takes a factored offset.  */
  int armcc_cfa_offsets_sf;

  /* The ARM compilers, in DWARF2 or DWARF3 mode, assume that
     the CFA is defined as REG - OFFSET rather than REG + OFFSET.  */
  int armcc_cfa_offsets_reversed;
a401 4

	      if (fs->armcc_cfa_offsets_sf)
		utmp *= fs->data_align;

a412 4

	      if (fs->armcc_cfa_offsets_sf)
		utmp *= fs->data_align;

a616 30

static void
dwarf2_frame_find_quirks (struct dwarf2_frame_state *fs,
			  struct dwarf2_fde *fde)
{
  static const char *arm_idents[] = {
    "ARM C Compiler, ADS",
    "Thumb C Compiler, ADS",
    "ARM C++ Compiler, ADS",
    "Thumb C++ Compiler, ADS",
    "ARM/Thumb C/C++ Compiler, RVCT"
  };
  int i;

  struct symtab *s;

  s = find_pc_symtab (fs->pc);
  if (s == NULL || s->producer == NULL)
    return;

  for (i = 0; i < ARRAY_SIZE (arm_idents); i++)
    if (strncmp (s->producer, arm_idents[i], strlen (arm_idents[i])) == 0)
      {
	if (fde->cie->version == 1)
	  fs->armcc_cfa_offsets_sf = 1;

	if (fde->cie->version == 1 || fde->cie->version == 3)
	  fs->armcc_cfa_offsets_reversed = 1;
      }
}
a682 3
  /* Check for "quirks" - known bugs in producers.  */
  dwarf2_frame_find_quirks (fs, fde);

d699 1
a699 4
      if (fs->armcc_cfa_offsets_reversed)
	cache->cfa -= fs->cfa_offset;
      else
	cache->cfa += fs->cfa_offset;
a1456 1
      cie->version = cie_version;
@


1.57
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d1713 1
a1713 1
extern char *dwarf2_read_section (struct objfile *objfile, asection *sectp);
@


1.56
log
@	* dwarf2-frame.c (dwarf2_frame_prev_register): Handle
	DWARF2_FRAME_REG_CFA_OFFSET.
	* dwarf2-frame.h (enum dwarf2_frame_reg_rule): Add
	DWARF2_FRAME_REG_CFA_OFFSET.
@
text
@d3 1
a3 1
   Copyright 2003, 2004, 2005 Free Software Foundation, Inc.
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.55
log
@	* dwarf2-frame.c: (execute_cfa_program): Don't access past the
	allocated dwarf2_frame_state.initial.regs.
@
text
@d931 13
@


1.54
log
@	* dwarf2-frame.c (read_signed_leb128): Handle values that do not
	fit in 32 bits.
	* dwarf2read.c (read_signed_leb128): Likewise.
@
text
@d297 11
a307 1
	  fs->regs.reg[reg] = fs->initial.reg[reg];
@


1.54.4.1
log
@	* dwarf2-frame.c (execute_cfa_program): Don't access past the
	allocated dwarf2_frame_state.initial.regs
@
text
@d297 1
a297 11
          if (reg < fs->initial.num_regs)
            fs->regs.reg[reg] = fs->initial.reg[reg];
          else
            fs->regs.reg[reg].how = DWARF2_FRAME_REG_UNSPECIFIED;

          if (fs->regs.reg[reg].how == DWARF2_FRAME_REG_UNSPECIFIED)
            complaint (&symfile_complaints, _("\
incomplete CFI data; DW_CFA_restore unspecified\n\
register %s (#%d) at 0x%s"),
                       REGISTER_NAME(DWARF2_REG_TO_REGNUM(reg)),
                       DWARF2_REG_TO_REGNUM(reg), paddr (fs->pc));
@


1.53
log
@* dwarf2expr.h: Tweak comment.
(struct dwarf_expr_context): Use `gdb_byte *' in read_mem and
get_frame_base function pointers.
(read_uleb128, read_sleb128): Change return type and types of
first two arguments to `gdb_byte *'.
(dwarf2_read_address): Change types of first two arguments to
`gdb_byte *'.
* dwarf2expr.c: Tweak comment.
(dwarf_expr_eval): Change type of second argument to `gdb_byte *'.
(read_uleb128, read_sleb128): Change return type and types of
first two arguments to `gdb_byte *'.
(dwarf2_read_address): Change types of first two arguments to
`gdb_byte *'.
(execute_stack_op): Change types of last two arguments to
`gdb_byte *'.  Use `gdb_byte *' for byte buffers.
* dwarf2loc.h: Tweak comment.
(struct dwarf2_locexpr_baton, struct dwarf2_loclist_baton): Use
`gdb_byte *' for byte buffers.
* dwarf2loc.c (find_location_expression): Change return type to
`gdb_byte *'.  Use `gdb_byte *' for byte buffers.  Change length
to `unsigned int'.
(dwarf_expr_read_reg): Use `gdb_byte *' for byte buffer.  Remove
bogus cast.
(dwarf_expr_read_mem): Change type of second argument to
`gdb_byte *'.
(dwarf_expr_frame_base): Change type of second argument to
`gdb_byte **'.
(dwarf2_evaluate_loc_desc): Change type of third argument to
`gdb_byte *'.
(needs_frame_read_mem): Change type of second argument to
`gdb_byte *'.
(needs_frame_frame_base): Change type of second argument
`gdb_byte **'.  Use gdb_byte for lit0.
(dwarf2_tracepoint_var_ref): Change type of fourth argument to
`gdb_byte *'.  Use `gdb_byte *' for byte buffer.
(loclist_read_variable, loclist_tracepoint_var_ref): Use `gdb_byte
*' for byte buffer.
* dwarf2-frame.c (struct dwarf2_cie, struct dwarf2_fde)
(struct dwarf2_frame_state): Use gdb_byte instead of `unsigned
char'.
(read_reg): Use `gdb_byte *' for byte buffers.  Remove redundant
cast.
(read_mem): Change second argument to `gdb_byte *'.
(no_get_frame_base): Change second argument to `gdb_byte **'.
(execute_stack_op): Change first argument to `gdb_byte *'.
(execute_cfa_program): Change first two arguments to `gdb_byte *'.
Use gdb_byte instead of `unsigned int'.  Use temprorary variable
to store result of read_uleb128.
(struct comp_unit): Use `gdb_byte *' for byte buffers.
(read_1_byte, read_4_bytes, read_8_bytes): Change last argument to
`gdb_byte *'.
(read_unsigned_leb128, read_signed_leb128): Change second argument
to `gdb_byte *'.  Use gdb_byte instead of `unsigned char'.
(read_initial_length): Change second argument to `gdb_byte *'.
Remove redundant casts.
(read_encoded_value): Use gdb_byte instead of `unsigned char'.
Remove bogus casts.
(decode_frame_entry_1): Change return type and second argument to
`gdb_byte *'.  Use `gdb_byte *' for byte buffers.  Use gdb_byte
instead of `unsigned char'.
(decode_frame_entry): Change return type and second argument to
`gdb_byte *'.  Use `gdb_byte *' for byte buffers.
(dwarf2_build_frame_info): Use `gdb_byte *' for byte buffers.
@
text
@d1108 2
a1109 2
  if ((shift < 32) && (byte & 0x40))
    result |= -(1 << shift);
@


1.52
log
@	* dwarf2-frame.c (dwarf2_frame_prev_register): Use gdb_byte.
	* i386-linux-nat.c (fetch_register, store_register, supply_gregset)
	(fill_gregset): Likewise.
	* i386-tdep.c (i386_frame_prev_register)
	(i386_sigtramp_frame_prev_register): Likewise.
	* linux-nat.c (linux_nat_xfer_memory, linux_nat_make_corefile_notes):
	Likewise.
	* linux-thread-db.c (thread_db_xfer_memory): Likewise.
	* remote.c (remote_insert_hw_breakpoint, remote_remove_hw_breakpoint):
	Likewise.
	* target.c (debug_to_insert_hw_breakpoint)
	(debug_to_remove_hw_breakpoint, update_current_target): Likewise.
@
text
@d63 2
a64 2
  unsigned char *initial_instructions;
  unsigned char *end;
d67 1
a67 1
  unsigned char encoding;
d89 2
a90 2
  unsigned char *instructions;
  unsigned char *end;
d115 1
a115 1
  unsigned char *cfa_exp;
d211 1
a211 1
  char *buf;
d215 1
a215 1
  buf = (char *) alloca (register_size (gdbarch, regnum));
d221 1
a221 1
read_mem (void *baton, char *buf, CORE_ADDR addr, size_t len)
d227 1
a227 1
no_get_frame_base (void *baton, unsigned char **start, size_t *length)
d241 1
a241 1
execute_stack_op (unsigned char *exp, ULONGEST len,
d268 1
a268 1
execute_cfa_program (unsigned char *insn_ptr, unsigned char *insn_end,
d277 1
a277 1
      unsigned char insn = *insn_ptr++;
d402 2
a403 1
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &fs->cfa_offset);
d1024 1
a1024 1
  char *dwarf_frame_buffer;
d1042 1
a1042 1
read_1_byte (bfd *bfd, char *buf)
d1044 1
a1044 1
  return bfd_get_8 (abfd, (bfd_byte *) buf);
d1048 1
a1048 1
read_4_bytes (bfd *abfd, char *buf)
d1050 1
a1050 1
  return bfd_get_32 (abfd, (bfd_byte *) buf);
d1054 1
a1054 1
read_8_bytes (bfd *abfd, char *buf)
d1056 1
a1056 1
  return bfd_get_64 (abfd, (bfd_byte *) buf);
d1060 1
a1060 1
read_unsigned_leb128 (bfd *abfd, char *buf, unsigned int *bytes_read_ptr)
d1065 1
a1065 1
  unsigned char byte;
d1087 1
a1087 1
read_signed_leb128 (bfd *abfd, char *buf, unsigned int *bytes_read_ptr)
d1092 1
a1092 1
  unsigned char byte;
d1117 1
a1117 1
read_initial_length (bfd *abfd, char *buf, unsigned int *bytes_read_ptr)
d1121 1
a1121 1
  result = bfd_get_32 (abfd, (bfd_byte *) buf);
d1124 1
a1124 1
      result = bfd_get_64 (abfd, (bfd_byte *) buf + 4);
d1150 1
a1150 1
static unsigned char
d1167 1
a1167 1
size_of_encoded_value (unsigned char encoding)
d1188 2
a1189 2
read_encoded_value (struct comp_unit *unit, unsigned char encoding,
		    unsigned char *buf, unsigned int *bytes_read_ptr)
d1210 1
a1210 1
      base += ((char *) buf - unit->dwarf_frame_buffer);
d1228 1
a1228 1
      offset = (char *) buf - unit->dwarf_frame_buffer;
d1247 1
a1247 1
	unsigned char *end_buf = buf + (sizeof (value) + 1) * 8 / 7;
d1263 1
a1263 1
	char *end_buf = buf + (sizeof (value) + 1) * 8 / 7;
d1357 2
a1358 2
static char *decode_frame_entry (struct comp_unit *unit, char *start,
				 int eh_frame_p);
d1362 2
a1363 2
static char *
decode_frame_entry_1 (struct comp_unit *unit, char *start, int eh_frame_p)
d1365 1
a1365 1
  char *buf;
a1370 1
  char *end;
d1437 2
a1438 2
      augmentation = buf;
      buf = augmentation + strlen (augmentation) + 1;
d1502 1
a1502 1
	      unsigned char encoding = (*buf++) & ~DW_EH_PE_indirect;
d1590 2
a1591 2
static char *
decode_frame_entry (struct comp_unit *unit, char *start, int eh_frame_p)
d1594 1
a1594 1
  char *ret;
d1696 1
a1696 1
  char *frame_ptr;
@


1.51
log
@	* dwarf2-frame.c (struct dwarf2_frame_cache): New field
	undefined_retaddr.
	(dwarf2_frame_cache): Initialize undefined_retaddr.
	(dwarf2_frame_this_id): Return an invalid frame ID if
	undefined_retaddr.
@
text
@d824 1
a824 1
			    int *realnump, void *valuep)
@


1.50
log
@* dwarf2-frame.c (execute_cfa_program): Implement
DW_CFA_GNU_window_save.
@
text
@d613 3
d797 4
d814 3
@


1.49
log
@* dwarf2-frame.h: Update copyrigh year.
(enum dwarf2_frame_reg_rule): Add DWARF2_FRAME_REG_RA_OFFSET.
* dwarf2-frame.c: Update copyright year.
(struct dwarf2_frame_cache): Add member `retaddr_reg'.
(dwarf2_frame_cache): Deal with DWARF2_FRAME_REG_RA_OFFSET.
(dwarf2_frame_prev_register): Handle DWARF2_FRAME_REG_RA_OFFSET.
@
text
@d448 25
@


1.48
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d3 1
a3 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d591 3
d723 2
a724 1
  /* Eliminate any DWARF2_FRAME_REG_RA rules.  */
d730 2
a731 1
	if (cache->reg[regnum].how == DWARF2_FRAME_REG_RA)
d741 2
a742 2
               Incidentally, that's how should treat a return address
               column specifying "same value" too.  */
d746 6
a751 1
	      cache->reg[regnum] = *retaddr_reg;
d754 10
a763 2
		cache->reg[regnum].loc.reg = fs->retaddr_column;
		cache->reg[regnum].how = DWARF2_FRAME_REG_SAVED_REG;
d885 15
@


1.47
log
@* dwarf2-frame.c (read_encoded_value): Correctly calculate number
of bytes read for aligned LEB128 encodings.
@
text
@d230 1
a230 1
		  "Support for DW_OP_fbreg is unimplemented");
d237 1
a237 1
		  "Support for DW_OP_GNU_push_tls_address is unimplemented");
d377 2
a378 2
		    complaint (&symfile_complaints, "\
bad CFI data; mismatched DW_CFA_restore_state at 0x%s", paddr (fs->pc));
d454 1
a454 1
	      internal_error (__FILE__, __LINE__, "Unknown CFI encountered.");
d666 1
a666 1
      internal_error (__FILE__, __LINE__, "Unknown CFA rule.");
d710 2
a711 2
	      complaint (&symfile_complaints, "\
incomplete CFI data; unspecified registers (e.g., %s) at 0x%s",
d868 1
a868 1
      internal_error (__FILE__, __LINE__, "Unknown register rule.");
d1093 1
a1093 1
      internal_error (__FILE__, __LINE__, "Unsupported address size");
d1114 1
a1114 1
      internal_error (__FILE__, __LINE__, "Invalid or unsupported encoding");
d1130 1
a1130 1
		    "Unsupported encoding: DW_EH_PE_indirect");
d1167 1
a1167 1
      internal_error (__FILE__, __LINE__, "Invalid or unsupported encoding");
d1208 1
a1208 1
      internal_error (__FILE__, __LINE__, "Invalid or unsupported encoding");
d1590 1
a1590 1
		 "Corrupt data in %s:%s; align 4 workaround apparently succeeded",
d1597 1
a1597 1
		 "Corrupt data in %s:%s; align 8 workaround apparently succeeded",
d1604 1
a1604 1
		 "Corrupt data in %s:%s",
@


1.46
log
@	* dwarf2-frame.c (dwarf2_frame_state_alloc_regs): Correct allocated
	size.
@
text
@d1179 1
a1179 1
	*bytes_read_ptr = read_uleb128 (buf, end_buf, &value) - buf;
d1195 1
a1195 1
	*bytes_read_ptr = read_sleb128 (buf, end_buf, &value) - buf;
@


1.45
log
@	* dwarf2-frame.c (struct dwarf2_frame_ops): Add signal_frame_p.
	(dwarf2_frame_set_signal_frame_p, dwarf2_frame_signal_frame_p)
	(dwarf2_signal_frame_unwind): New.
	(dwarf2_frame_sniffer): Use dwarf2_frame_signal_frame_p.
	* dwarf2-frame.h (dwarf2_frame_set_signal_frame_p): New prototype.
@
text
@d165 1
a165 1
  size_t size = rs->num_regs * sizeof (struct dwarf2_frame_state_reg_info);
@


1.44
log
@2004-11-05  Andrew Cagney  <cagney@@gnu.org>

	* dwarf2-frame.c (dwarf2_frame_cache): Only complain when both the
	CFI and the init_reg method leave the register unspecified.
	Include the register name in the "Incomplete CFI data" complaint.
	Supress leading zeros in the address.
@
text
@d474 4
d554 27
d879 7
d893 2
a894 2
  if (dwarf2_frame_find_fde (&block_addr))
    return &dwarf2_frame_unwind;
d896 9
a904 1
  return NULL;
@


1.43
log
@* dwarf2-frame.c (decode_frame_entry_1): Avoid indirection when
skipping a personality routine in a CIE augmentation.
@
text
@d677 7
a683 3
	  complaint (&symfile_complaints,
		     "Incomplete CFI data; unspecified registers at 0x%s",
		     paddr (fs->pc));
@


1.42
log
@* dwarf2-frame.c (decode_frame_entry_1): Correctly skip
personality routine in a CIE augmentation.
@
text
@d1383 2
a1384 2
	      /* Skip.  */
	      unsigned char encoding = *buf++;
@


1.41
log
@* dwarf2-frame.c (read_encoded_value): Change type of third
argument to `unsigned char *'.  Add support for LEB128 encodings.
@
text
@d1384 3
a1386 1
	      buf += size_of_encoded_value (*buf++);
@


1.40
log
@* dwarf2-frame.c (read_encoded_value): Set proper size for signed
encodings as well as unsigned encodings.
@
text
@d1070 1
a1070 1
		    char *buf, unsigned int *bytes_read_ptr)
d1091 1
a1091 1
      base += (buf - unit->dwarf_frame_buffer);
d1109 1
a1109 1
      offset = buf - unit->dwarf_frame_buffer;
d1125 7
d1141 7
@


1.39
log
@2004-10-27  Andrew Cagney  <cagney@@gnu.org>

	* trad-frame.c (trad_frame_get_prev_register): Use
	frame_unwind_register instead of frame_register_unwind, do not
	recurse the register's location.
	* xstormy16-tdep.c (xstormy16_frame_prev_register):
	* sparc-tdep.c (sparc32_frame_prev_register): Ditto.
	* sparc64-tdep.c (sparc64_frame_prev_register): Ditto.
	* sh-tdep.c (sh_frame_prev_register): Ditto.
	* m68k-tdep.c (m68k_frame_prev_register): Ditto.
	* i386-tdep.c (i386_frame_prev_register): Ditto.
	* dwarf2-frame.c (dwarf2_frame_prev_register): Ditto.
	* amd64-tdep.c (amd64_frame_prev_register): Ditto.
@
text
@d1120 1
a1120 1
  if ((encoding & 0x0f) == 0x00)
@


1.38
log
@* dwarf2-frame.c (struct dwarf2_cie): Delete `addr_size' member.
(decode_frame_entry_1): Use DW_EH_PE_absptr as default for CIE
encoding.
(dwarf2_build_frame_info): Adjust for removal of `addr_size'
member of `struct comp_unit'.
@
text
@d773 6
a778 3
      regnum = DWARF2_REG_TO_REGNUM (cache->reg[regnum].loc.reg);
      frame_register_unwind (next_frame, regnum,
			     optimizedp, lvalp, addrp, realnump, valuep);
d803 6
a808 2
      frame_register_unwind (next_frame, regnum,
			     optimizedp, lvalp, addrp, realnump, valuep);
d812 6
a817 2
      frame_register_unwind (next_frame, regnum,
			     optimizedp, lvalp, addrp, realnump, valuep);
@


1.38.2.1
log
@* dwarf2-frame.c (read_encoded_value): Set proper size for signed
encodings as well as unsigned encodings.
@
text
@d1109 1
a1109 1
  if ((encoding & 0x07) == 0x00)
@


1.38.2.2
log
@* dwarf2-frame.c (decode_frame_entry_1): Correctly skip
personality routine in a CIE augmentation.  Avoid indirection.
@
text
@d1358 2
a1359 4
	      /* Skip.  Avoid indirection since we throw away the result.  */
	      unsigned char encoding = (*buf++) & ~DW_EH_PE_indirect;
	      read_encoded_value (unit, encoding, buf, &bytes_read);
	      buf += bytes_read;
@


1.37
log
@2004-07-23  Martin Hunt  <hunt@@redhat.com>
	Kevin Buettner <kevinb@@redhat.com>

	* dwarf2-frame.c (execute_cfa_program): Fix typo in which the
	alignment was being added to the offset instead of multiplied.
@
text
@a892 3
  /* Address size for this unit - from unit header.  */
  unsigned char addr_size;

d1284 2
a1285 3
         depends on the target address size as specified in the
         Compilation Unit Header.  */
      cie->encoding = encoding_for_size (unit->addr_size);
a1555 1
  unit.addr_size = objfile->obfd->arch_info->bits_per_address / 8;
@


1.36
log
@	* dsrec.c (load_srec, make_srec): Use bfd_get_section_size instead of
	bfd_get_section_size_before_reloc or _raw_size.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2read.c (dwarf2_locate_sections): Likewise.
	(dwarf2_read_section): Likewise.
	* elfread.c (elf_locate_sections): Likewise.
	* gcore.c (derive_heap_segment): Likewise.
	* mipsread.c (read_alphacoff_dynamic_symtab): Likewise.
	* remote-e7000.c (e7000_load): Likewise.
	* remote-m32r-sdi.c (m32r_load): Likewise.
	* remote-mips.c (mips_load_srec): Likewise.
	(pmon_load_fast): Likewise.
	* remote.c (compare_sections_command): Likewise.
	* symfile.c (add_section_size_callback): Likewise.
	(load_section_callback): Likewise.
	(pc_in_unmapped_range): Likewise.
	(pc_in_mapped_range): Likewise.
	(sections_overlap): Likewise.
	(list_overlays_command): Likewise.
	(simple_overlay_update_1): Likewise.
	(simple_overlay_update): Likewise.
	* tracepoint.c (remote_set_transparent_ranges): Likewise.
	* win32-nat.c (core_section_load_dll_symbols): Likewise.
@
text
@d429 1
a429 1
	      offset += fs->data_align;
@


1.36.6.1
log
@Merge from trunk:

2004-07-23  Martin Hunt  <hunt@@redhat.com>
            Kevin Buettner <kevinb@@redhat.com>

* dwarf2-frame.c (execute_cfa_program): Fix typo in which the
alignment was being added to the offset instead of multiplied.
@
text
@d429 1
a429 1
	      offset *= fs->data_align;
@


1.36.6.2
log
@* dwarf2-frame.c (dwarf2_frame_cache): Properly retrieve a frame's
return address when the CIE and FDE refer to the return address by
different numbers.
@
text
@d693 2
a694 18
	    struct dwarf2_frame_state_reg *retaddr_reg;
            int retaddr_regno = DWARF2_REG_TO_REGNUM (fs->retaddr_column);

            /* One some systems, DWARF2_REG_TO_REGNUM is many-to-one:
               there are multiple numbers for the same register.  GCC
               may use one number in the CIE, and a different number
               in the FDE's.  If we merge entries properly when
               populating cache->reg above (preferring entries with
               information over those with no information, like
               DWARF2_FRAME_REG_UNSPECIFIED), and then use cache->reg
               as the basis, we can ensure we'll find the information,
               no matter what register number was used to record it.  */
            if (0 <= retaddr_regno && retaddr_regno < num_regs)
              retaddr_reg = &cache->reg[retaddr_regno];
            else
              /* If retaddr_column doesn't have any corresponding GDB
                 register number, then just refer to the column.  */
              retaddr_reg = &fs->regs.reg[fs->retaddr_column];
@


1.35
log
@	* gdb/dwarf2-frame.c (decode_frame_entry_1): Decode version 3 CIE
	records.
@
text
@d1574 1
a1574 2
      unit.dwarf_frame_size
	= bfd_get_section_size_before_reloc (dwarf_eh_frame_section);
d1601 1
a1601 2
      unit.dwarf_frame_size
	= bfd_get_section_size_before_reloc (dwarf_frame_section);
@


1.34
log
@* dwarf2-frame.c (read_encoded_value): Handle DW_EH_PE_funcrel
encondings.  Fixes PR gdb/1628.
@
text
@d1271 1
d1292 2
a1293 1
      if (read_1_byte (unit->abfd, buf) != DW_CIE_VERSION)
d1319 9
a1327 2
      cie->return_address_register = read_1_byte (unit->abfd, buf);
      buf += 1;
@


1.33
log
@* dwarf2-frame.c (execute_cfa_program): Complain if we encounter a
DW_CFA_restore state without a matching DW_CFA_remember_state
instead of aborting.  Fixes PR backtrace/1589.
@
text
@d1091 8
@


1.32
log
@2004-03-15  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (gdbarch_data_pre_init_fytpe)
	(gdbarch_data_register_pre_init, gdbarch_data_post_init_fytpe)
	(gdbarch_data_register_post_init): Replace gdbarch_data_init_ftype
	and register_gdbarch_data.
	(deprecated_set_gdbarch_data): Rename set_gdbarch_data.
	(struct gdbarch_data): Replace "init" by "pre_init" and
	"post_init".
	* gdbarch.h, gdbarch.c: Re-generate.
	* dwarf2-frame.c (dwarf2_frame_init): Replace "gdbarch" paramter
	with"obstack", use OBSTACK_ZALLOC.
	(dwarf2_frame_ops): Delete.
	(dwarf2_frame_set_init_reg): Use gdbarch_data.
	(dwarf2_frame_init_reg): Use gdbarch_data.
	(_initialize_dwarf2_frame): Use gdbarch_data_register_pre_init.
	* solib-svr4.c (set_solib_svr4_fetch_link_map_offsets)
	(_initialize_svr4_solib): Update.
	* user-regs.c (_initialize_user_regs): Update.
	* reggroups.c (_initialize_reggroup): Update.
	* regcache.c (_initialize_regcache): Update.
	* mips-linux-tdep.c (_initialize_mips_linux_tdep): Update.
	* libunwind-frame.c (_initialize_libunwind_frame): Update.
	* gnu-v3-abi.c (init_gnuv3_ops): Update.
	* frame-unwind.c (_initialize_frame_unwind): Update.
	* frame-base.c (_initialize_frame_base): Update.
	* user-regs.c (user_reg_add): Update.
	* reggroups.c (reggroup_add): Update.
	* mips-linux-tdep.c (set_mips_linux_register_addr): Update.
	* libunwind-frame.c (libunwind_frame_set_descr): Update.
	* frame-unwind.c (frame_unwind_append_sniffer): Update.
	* frame-base.c (frame_base_table): Update.
	* remote.c (_initialize_remote): Update.
	* gdb_obstack.h (OBSTACK_ZALLOC, OBSTACK_CALLOC): Define.
@
text
@d375 11
a385 5
		gdb_assert (old_rs);

		xfree (fs->regs.reg);
		fs->regs = *old_rs;
		xfree (old_rs);
@


1.31
log
@2004-02-16  Andrew Cagney  <cagney@@redhat.com>

	* dwarf2-frame.c (dwarf2_frame_ops): New function.
	(dwarf2_frame_set_init_reg): Use, instead of gdbarch_data.
	(dwarf2_frame_init_reg): Ditto.
@
text
@d512 1
a512 1
dwarf2_frame_init (struct gdbarch *gdbarch)
d516 1
a516 1
  ops = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct dwarf2_frame_ops);
a520 14
static struct dwarf2_frame_ops *
dwarf2_frame_ops (struct gdbarch *gdbarch)
{
  struct dwarf2_frame_ops *ops = gdbarch_data (gdbarch, dwarf2_frame_data);
  if (ops == NULL)
    {
      /* ULGH, called during architecture initialization.  Patch
         things up.  */
      ops = dwarf2_frame_init (gdbarch);
      set_gdbarch_data (gdbarch, dwarf2_frame_data, ops);
    }
  return ops;
}

d529 1
a529 1
  struct dwarf2_frame_ops *ops;
a530 1
  ops = dwarf2_frame_ops (gdbarch);
d540 1
a540 1
  struct dwarf2_frame_ops *ops;
a541 1
  ops = dwarf2_frame_ops (gdbarch);
d1595 1
a1595 1
  dwarf2_frame_data = register_gdbarch_data (dwarf2_frame_init);
@


1.31.4.1
log
@* dwarf2-frame.c (read_encoded_value): Handle DW_EH_PE_funcrel
encondings.  Fixes PR gdb/1628.
@
text
@a1100 8
    case DW_EH_PE_funcrel:
      /* FIXME: kettenis/20040501: For now just pretend
         DW_EH_PE_funcrel is equivalent to DW_EH_PE_absptr.  For
         reading the initial location of an FDE it should be treated
         as such, and currently that's the only place where this code
         is used.  */
      base = 0;
      break;
@


1.31.2.1
log
@Merge mainline to intercu branch.
@
text
@d512 1
a512 1
dwarf2_frame_init (struct obstack *obstack)
d516 1
a516 1
  ops = OBSTACK_ZALLOC (obstack, struct dwarf2_frame_ops);
d521 14
d543 1
a543 1
  struct dwarf2_frame_ops *ops = gdbarch_data (gdbarch, dwarf2_frame_data);
d545 1
d555 1
a555 1
  struct dwarf2_frame_ops *ops = gdbarch_data (gdbarch, dwarf2_frame_data);
d557 1
d1611 1
a1611 1
  dwarf2_frame_data = gdbarch_data_register_pre_init (dwarf2_frame_init);
@


1.31.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d375 5
a379 11
		if (old_rs == NULL)
		  {
		    complaint (&symfile_complaints, "\
bad CFI data; mismatched DW_CFA_restore_state at 0x%s", paddr (fs->pc));
		  }
		else
		  {
		    xfree (fs->regs.reg);
		    fs->regs = *old_rs;
		    xfree (old_rs);
		  }
d423 1
a423 1
	      offset *= fs->data_align;
d887 3
a1084 8
    case DW_EH_PE_funcrel:
      /* FIXME: kettenis/20040501: For now just pretend
         DW_EH_PE_funcrel is equivalent to DW_EH_PE_absptr.  For
         reading the initial location of an FDE it should be treated
         as such, and currently that's the only place where this code
         is used.  */
      base = 0;
      break;
a1256 1
      unsigned int cie_version;
d1272 3
a1274 2
         depends on the target address size.  */
      cie->encoding = DW_EH_PE_absptr;
d1277 1
a1277 2
      cie_version = read_1_byte (unit->abfd, buf);
      if (cie_version != 1 && cie_version != 3)
d1303 2
a1304 9
      if (cie_version == 1)
	{
	  cie->return_address_register = read_1_byte (unit->abfd, buf);
	  bytes_read = 1;
	}
      else
	cie->return_address_register = read_unsigned_leb128 (unit->abfd, buf,
							     &bytes_read);
      buf += bytes_read;
d1537 1
d1551 2
a1552 1
      unit.dwarf_frame_size = bfd_get_section_size (dwarf_eh_frame_section);
d1579 2
a1580 1
      unit.dwarf_frame_size = bfd_get_section_size (dwarf_frame_section);
@


1.31.6.1
log
@Jumbo patch.  Experiments with tramp-frame.
@
text
@d733 1
a733 2
dwarf2_frame_this_id (const struct frame_unwind *self,
		      struct frame_info *next_frame, void **this_cache,
d743 1
a743 2
dwarf2_frame_prev_register (const struct frame_unwind *self,
			    struct frame_info *next_frame, void **this_cache,
d864 1
a864 2
dwarf2_frame_base_address (const struct frame_base *self,
			   struct frame_info *next_frame, void **this_cache)
d1611 1
a1611 1
  dwarf2_frame_data = register_gdbarch_data (NULL, dwarf2_frame_init);
@


1.31.6.2
log
@Dump of tramp-frame stuff.
@
text
@d512 1
a512 1
dwarf2_frame_init (struct obstack *obstack)
d516 1
a516 1
  ops = OBSTACK_ZALLOC (obstack, struct dwarf2_frame_ops);
d521 14
d543 1
a543 1
  struct dwarf2_frame_ops *ops = gdbarch_data (gdbarch, dwarf2_frame_data);
d545 1
d555 1
a555 1
  struct dwarf2_frame_ops *ops = gdbarch_data (gdbarch, dwarf2_frame_data);
d557 1
d1614 1
a1614 1
  dwarf2_frame_data = gdbarch_data_register_pre_init (dwarf2_frame_init);
@


1.31.6.3
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d717 2
a718 1
dwarf2_frame_this_id (struct frame_info *next_frame, void **this_cache,
d728 2
a729 1
dwarf2_frame_prev_register (struct frame_info *next_frame, void **this_cache,
d850 2
a851 1
dwarf2_frame_base_address (struct frame_info *next_frame, void **this_cache)
@


1.30
log
@* dwarf2-frame.h (dwarf2_frame_set_init_reg): New prototype.
* dwarf2-frame.c (dwarf2_frame_data): New variable.
(struct dwarf2_frame_ops): New.
(dwarf2_frame_default_init_reg): New function, based on
dwarf2_frame_init_reg.
(dwarf2_frame_init, dwarf2_frame_set_init_reg): New function.
(dwarf2_frame_init_reg): Call architecture-specific function.
(dwarf2_frame_objfile_data): Renamed from dwarf2_frame_data.
(dwarf2_frame_find_fde, add_fde): Use dwarf2_frame_objfile_data
instead of dwarf2_frame_data.
(_initialize_dwarf2_frame): Initailize new dwarf2_frame_data.
Initialize dwarf2_frame_objfile instead of old dwarf2_frame_data.
@
text
@d521 14
d545 1
a545 1
  ops = gdbarch_data (gdbarch, dwarf2_frame_data);
d557 1
a557 1
  ops = gdbarch_data (gdbarch, dwarf2_frame_data);
@


1.29
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* dbxread.c (dbx_symfile_init, start_psymtab, end_psymtab,
	coffstab_build_psymtabs, elfstab_build_psymtabs)
	(stabsect_build_psymtabs): Replace psymbol_obstack with
	objfile_obstack.
	* dwarf2-frame.c (decode_frame_entry_1): Ditto.
	* dwarf2read.c (dwarf2_build_psymtabs_hard, dwarf2_read_section):
	Ditto.
	* dwarfread.c (scan_compilation_units): Ditto.
	* elfread.c (elfstab_offset_sections): Ditto.
	* hppa-tdep.c (read_unwind_info): Ditto.
	* hpread.c (hpread_build_psymtabs, hpread_start_psymtab)
	(hpread_end_psymtab): Ditto.
	* mdebugread.c (mdebug_build_psymtabs, add_pending)
	(parse_partial_symbols, new_psymtab, elfmdebug_build_psymtabs):
	Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* objfiles.c (add_to_objfile_sections)
	(build_objfile_section_table): Ditto.
	(allocate_objfile): Remove init of psymbol_obstack.
	(free_objfile): Remove freeing of psymbol_obstack.
	* objfiles.h (struct objfile): Remove field
	psymbol_obstack. Update comments.
	* pa64solib.c (pa64_solib_add_solib_objfile): Replace
	psymbol_obstack with objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
        psymbol_obstack.
	* somread.c (som_symfile_offsets, init_import_symbols)
	(init_export_symbols): Replace psymbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
	* symfile.c (default_symfile_offsets, syms_from_objfile)
	(reread_symbols): Remove freeing and init of psymbol_obstack.
	(cashier_psymtab): Update comment.
	* symmisc.c (print_objfile_statistics): Don't report stats for
	psymbol obstack.
	* symtab.h (struct general_symbol_info, struct partial_symtab):
	Update comments.
	* xcoffread.c (xcoff_start_psymtab, xcoff_end_psymtab, swap_sym)
	(xcoff_symfile_offsets): Replace psymbol_obstack with
	objfile_obstack.
@
text
@d457 6
d464 1
a464 1
struct dwarf2_frame_cache
d466 2
a467 6
  /* DWARF Call Frame Address.  */
  CORE_ADDR cfa;

  /* Saved registers, indexed by GDB register number, not by DWARF
     register number.  */
  struct dwarf2_frame_state_reg *reg;
d470 2
a471 25
/* Initialize the register state REG.  If we have a register that acts
   as a program counter, mark it as a destination for the return
   address.  If we have a register that serves as the stack pointer,
   arrange for it to be filled with the call frame address (CFA).  The
   other registers are marked as unspecified.

   We copy the return address to the program counter, since many parts
   in GDB assume that it is possible to get the return address by
   unwind the program counter register.  However, on ISA's with a
   dedicated return address register, the CFI usually only contains
   information to unwind that return address register.

   The reason we're treating the stack pointer special here is because
   in many cases GCC doesn't emit CFI for the stack pointer and
   implicitly assumes that it is equal to the CFA.  This makes some
   sense since the DWARF specification (version 3, draft 8, p. 102)
   says that:

   "Typically, the CFA is defined to be the value of the stack pointer
   at the call site in the previous frame (which may be different from
   its value on entry to the current frame)."

   However, this isn't true for all platforms supported by GCC
   (e.g. IBM S/390 and zSeries).  For those targets we should override
   the defaults given here.  */
d474 2
a475 2
dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,
		       struct dwarf2_frame_state_reg *reg)
d477 26
d509 49
d908 1
a908 1
const struct objfile_data *dwarf2_frame_data;
d1168 1
a1168 1
      fde = objfile_data (objfile, dwarf2_frame_data);
d1194 2
a1195 2
  fde->next = objfile_data (unit->objfile, dwarf2_frame_data);
  set_objfile_data (unit->objfile, dwarf2_frame_data, fde);
a1517 1

d1597 2
a1598 1
  dwarf2_frame_data = register_objfile_data ();
@


1.28
log
@* dwarf2-frame.h: Update copyright.
(enum dwarf2_frame_reg_rule): New.
(struct dwarf2_frame_state_reg): New.
(dwarf2_frame_sniffer, dwarf2_frame_base_sniffer): Make extern.
* dwarf2-frame.c: Update copyright.
(enum dwarf2_reg_rule): Remove.
(struct dwarf2_frame_state): Remove defenition of `struct
dwarf2_frame_state_reg'.
(read_reg): Call get_frame_arch to get the architecture instead of
using CURRENT_GDBARCH.
(execute_cfa_program): Prefix old `enum dwarf2_reg_rule' tags with
DWARF2_FRAME_.
(dwarf2_frame_init_reg): New function.
(dwarf2_frame_cache): Call get_frame_arch to get the architecture
instead of using CURRENT_GDBARCH.  Call dwarf2_frame_init_reg to
initialize the register state.  Prefix old `enum dwarf2_reg_rule'
tags with DWARF2_FRAME_.
(dwarf2_frame_prev_register): Call get_frame_arch to get the
architecture instead of using CURRENT_GDBARCH.  Prefix old `enum
dwarf2_reg_rule' tags with DWARF2_FRAME_.
@
text
@d1214 1
a1214 1
	obstack_alloc (&unit->objfile->psymbol_obstack,
d1330 1
a1330 1
	obstack_alloc (&unit->objfile->psymbol_obstack,
@


1.27
log
@* dwarf2-frame.c (dwarf2_frame_cache): Deal with a return address
column that's "empty" or "same value" when eliminating REG_RA
rules.
@
text
@d3 1
a3 1
   Copyright 2003 Free Software Foundation, Inc.
a99 27
enum dwarf2_reg_rule
{
  /* Make certain that 0 maps onto the correct enum value; the
     corresponding structure is being initialized using memset zero.
     This indicates that CFI didn't provide any information at all
     about a register, leaving how to obtain its value totally
     unspecified.  */
  REG_UNSPECIFIED = 0,

  /* The term "undefined" comes from the DWARF2 CFI spec which this
     code is moddeling; it indicates that the register's value is
     "undefined".  GCC uses the less formal term "unsaved".  Its
     definition is a combination of REG_UNDEFINED and REG_UNSPECIFIED.
     The failure to differentiate the two helps explain a few problems
     with the CFI generated by GCC.  */
  REG_UNDEFINED,
  REG_SAVED_OFFSET,
  REG_SAVED_REG,
  REG_SAVED_EXP,
  REG_SAME_VALUE,

  /* These aren't defined by the DWARF2 CFI specification, but are
     used internally by GDB.  */
  REG_RA,			/* Return Address.  */
  REG_CFA			/* Call Frame Address.  */
};

d106 1
a106 10
    struct dwarf2_frame_state_reg
    {
      union {
	LONGEST offset;
	ULONGEST reg;
	unsigned char *exp;
      } loc;
      ULONGEST exp_len;
      enum dwarf2_reg_rule how;
    } *reg;
d209 1
d215 1
a215 1
  buf = (char *) alloca (register_size (current_gdbarch, regnum));
d289 1
a289 1
	  fs->regs.reg[reg].how = REG_SAVED_OFFSET;
d329 1
a329 1
	      fs->regs.reg[reg].how = REG_SAVED_OFFSET;
d343 1
a343 1
	      fs->regs.reg[reg].how = REG_UNDEFINED;
d349 1
a349 1
	      fs->regs.reg[reg].how = REG_SAME_VALUE;
d356 1
a356 1
	      fs->regs.reg[reg].how = REG_SAVED_REG;
d416 1
a416 1
	      fs->regs.reg[reg].how = REG_SAVED_EXP;
d425 1
a425 1
	      fs->regs.reg[reg].how = REG_SAVED_OFFSET;
d468 36
d508 1
d580 1
a580 25
  /* Initialize the register rules.  If we have a register that acts
     as a program counter, mark it as a destination for the return
     address.  If we have a register that serves as the stack pointer,
     arrange for it to be filled with the call frame address (CFA).
     The other registers are marked as unspecified.

     We copy the return address to the program counter, since many
     parts in GDB assume that it is possible to get the return address
     by unwind the program counter register.  However, on ISA's with a
     dedicated return address register, the CFI usually only contains
     information to unwind that return address register.

     The reason we're treating the stack pointer special here is
     because in many cases GCC doesn't emit CFI for the stack pointer
     and implicitly assumes that it is equal to the CFA.  This makes
     some sense since the DWARF specification (version 3, draft 8,
     p. 102) says that:

     "Typically, the CFA is defined to be the value of the stack
     pointer at the call site in the previous frame (which may be
     different from its value on entry to the current frame)."

     However, this isn't true for all platforms supported by GCC
     (e.g. IBM S/390 and zSeries).  For those targets we should
     override the defaults given here.  */
d585 1
a585 8
      {
	if (regnum == PC_REGNUM)
	  cache->reg[regnum].how = REG_RA;
	else if (regnum == SP_REGNUM)
	  cache->reg[regnum].how = REG_CFA;
	else
	  cache->reg[regnum].how = REG_UNSPECIFIED;
      }
d618 1
a618 1
	if (fs->regs.reg[column].how == REG_UNSPECIFIED)
d627 1
a627 1
  /* Eliminate any REG_RA rules.  */
d633 1
a633 1
	if (cache->reg[regnum].how == REG_RA)
d635 3
d646 3
a648 3
		&& fs->regs.reg[fs->retaddr_column].how != REG_UNSPECIFIED
		&& fs->regs.reg[fs->retaddr_column].how != REG_SAME_VALUE)
	      cache->reg[regnum] = fs->regs.reg[fs->retaddr_column];
d652 1
a652 1
		cache->reg[regnum].how = REG_SAVED_REG;
d680 1
d686 1
a686 1
    case REG_UNDEFINED:
d702 1
a702 1
    case REG_SAVED_OFFSET:
d710 1
a710 2
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
d714 1
a714 1
    case REG_SAVED_REG:
d720 1
a720 1
    case REG_SAVED_EXP:
d730 1
a730 2
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
d734 1
a734 1
    case REG_UNSPECIFIED:
d746 1
a746 1
    case REG_SAME_VALUE:
d751 1
a751 1
    case REG_CFA:
@


1.26
log
@* dwarf2-frame.c (execute_cfa_program): Move DWA_CFA_nop before
DW_CFA_def_cfa_exporession.  Add support for
DW_CFA_offset_extendend_sf, DW_CFA_def_cfa_sf and
DW_CFA_def_cfa_offset_sf.  This should fix PR backtrace/1391.
@
text
@d664 10
a673 1
	    if (fs->retaddr_column < fs->regs.num_regs)
a676 4
		/* It turns out that GCC assumes that if the return
                   address column is "empty" the return address can be
                   found in the register corresponding to the return
                   address column.  */
@


1.25
log
@* dwarf2-frame.c (dwarf2_reg_rule): Add REG_RA and REG_CFA.
(dwarf2_frame_cache): Initialize PC_REGNUM with REG_RA and
SP_REGNUM with REG_CFA.  Don't overwrite the initialized register
rule for registers left unspecified by the CFI.  Remove the
special handling of PC_REGNUM.  Add code to eleminate any REG_RA
rules.
(dwarf2_frame_prev_register): Remove the special handling of
SP_REGNUM.  Add support for the REG_CFA rule.
@
text
@d435 3
d455 20
a474 1
	    case DW_CFA_nop:
@


1.24
log
@* dwarf2-frame.c (dwarf2_frame_cache): Don't skip the return
address column.
@
text
@d108 1
d119 6
a124 1
  REG_SAME_VALUE
d556 25
a580 2
  /* Initialize things so that all registers are marked as
     unspecified.  */
d585 8
a592 1
      cache->reg[regnum].how = REG_UNSPECIFIED;
d629 4
d634 20
a653 1
	cache->reg[regnum] = fs->regs.reg[column];
a656 25
  /* Store the location of the return addess.  If the return address
     column (adjusted) is not the same as GDB's PC_REGNUM, then this
     implies a copy from the return address column register.  */
  if (fs->retaddr_column < fs->regs.num_regs
      && fs->regs.reg[fs->retaddr_column].how != REG_UNDEFINED)
    {
      /* See comment above about a possibly negative PC_REGNUM.  If
         this assertion fails, it's a problem with this code and not
         the architecture.  */
      gdb_assert (PC_REGNUM >= 0);
      cache->reg[PC_REGNUM] = fs->regs.reg[fs->retaddr_column];
    }
  else
    {
      if (DWARF2_REG_TO_REGNUM (fs->retaddr_column) != PC_REGNUM)
	{
	  /* See comment above about PC_REGNUM being negative.  If
	     this assertion fails, it's a problem with this code and
	     not the architecture.  */
	  gdb_assert (PC_REGNUM >= 0);
	  cache->reg[PC_REGNUM].loc.reg = fs->retaddr_column;
	  cache->reg[PC_REGNUM].how = REG_SAVED_REG;
	}
    }

d691 1
a691 36
      if (regnum == SP_REGNUM)
	{
	  /* GCC defines the CFA as the value of the stack pointer
	     just before the call instruction is executed.  Do other
	     compilers use the same definition?  */
	  /* DWARF V3 Draft 7 p102: Typically, the CFA is defined to
	     be the value of the stack pointer at the call site in the
	     previous frame (which may be different from its value on
	     entry to the current frame).  */
	  /* DWARF V3 Draft 7 p103: The first column of the rules
             defines the rule which computes the CFA value; it may be
             either a register and a signed offset that are added
             together or a DWARF expression that is evaluated.  */
	  /* FIXME: cagney/2003-07-07: I don't understand this.  The
             CFI info should have provided unwind information for the
             SP register and then pointed ->cfa_reg at it, not the
             reverse.  Assuming that SP_REGNUM isn't negative, there
             is a very real posibility that CFA is an offset from some
             other register, having nothing to do with the unwound SP
             value.  */
	  /* FIXME: cagney/2003-09-05: I think I understand.  GDB was
	     lumping the two states "unspecified" and "undefined"
	     together.  Here SP_REGNUM was "unspecified", GCC assuming
	     that in such a case CFA would be used.  This branch of
	     the if statement should be deleted - the problem of
	     SP_REGNUM is now handed by the case REG_UNSPECIFIED
	     below.  */
	  *optimizedp = 0;
	  if (valuep)
	    {
	      /* Store the value.  */
	      store_typed_address (valuep, builtin_type_void_data_ptr,
				   cache->cfa);
	    }
	}
      else if (valuep)
d742 2
a743 42
      if (SP_REGNUM >= 0 && regnum == SP_REGNUM)
	{
	  /* Can things get worse?  Yep!  One of the registers GCC
	     forgot to provide unwind information for was the stack
	     pointer.  Outch!  GCC appears to assumes that the CFA
	     address can be used - after all it points to the inner
	     most address of the previous frame before the function
	     call and that's always the same as the stack pointer on
	     return, right?  Wrong.  See GCC's i386 STDCALL option for
	     an ABI that has a different entry and return stack
	     pointer.  */
	  /* DWARF V3 Draft 7 p102: Typically, the CFA is defined to
	     be the value of the stack pointer at the call site in the
	     previous frame (which may be different from its value on
	     entry to the current frame).  */
	  /* DWARF V3 Draft 7 p103: The first column of the rules
             defines the rule which computes the CFA value; it may be
             either a register and a signed offset that are added
             together or a DWARF expression that is evaluated.  */
	  /* NOTE: cagney/2003-09-05: Should issue a complaint.
             Unfortunately it turns out that DWARF2 CFI has a problem.
             Since CFI specifies the location at which a register was
             saved (not its value) it isn't possible to specify
             something like "unwound(REG) == REG + constant" using CFI
             as will almost always occure with the stack pointer.  I
             guess CFI should be point SP at CFA.  Ref: danielj,
             "Describing unsaved stack pointers", posted to dwarf2
             list 2003-08-15.  */
	  *optimizedp = 0;
	  *lvalp = not_lval;
	  *addrp = 0;
	  *realnump = -1;
	  if (valuep)
	    /* Store the value.  */
	    store_typed_address (valuep, builtin_type_void_data_ptr,
				 cache->cfa);
	}
      else
	/* Assume that the register can be found in the next inner
           most frame.  */
	frame_register_unwind (next_frame, regnum,
			       optimizedp, lvalp, addrp, realnump, valuep);
d749 12
@


1.23
log
@From Ulrich Weigand  <weigand@@informatik.uni-erlangen.de>:
* dwarf2-frame.c (dwarf2_frame_cache): Use the untranslated RA
column instead of translating it.
@
text
@d560 6
a565 1
     location information in the cache.  */
a570 14
	int regnum;
	
	/* Skip the return address column.  */
	if (column == fs->retaddr_column)
	  /* NOTE: cagney/2003-06-07: Is this right?  What if
	     RETADDR_COLUMN corresponds to a real register (and,
	     worse, that isn't the PC_REGNUM)?  I'm guessing that the
	     PC_REGNUM further down is trying to handle this.  That
	     can't be right though; PC_REGNUM may not be valid (it can
	     be negative).  I think, instead when RETADDR_COLUM isn't
	     a real register, it should map itself onto
	     frame_pc_unwind.  */
	  continue;

d572 1
a572 1
	regnum = DWARF2_REG_TO_REGNUM (column);
@


1.23.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.23.2.2
log
@Merge from mainline.
@
text
@d560 1
a560 6
     location information in the cache.  Note that we don't skip the
     return address column; it's perfectly all right for it to
     correspond to a real register.  If it doesn't correspond to a
     real register, or if we shouldn't treat it as such,
     DWARF2_REG_TO_REGNUM should be defined to return a number outside
     the range [0, NUM_REGS).  */
d566 14
d581 1
a581 1
	int regnum = DWARF2_REG_TO_REGNUM (column);
@


1.23.2.3
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@a107 1

d118 1
a118 6
  REG_SAME_VALUE,

  /* These aren't defined by the DWARF2 CFI specification, but are
     used internally by GDB.  */
  REG_RA,			/* Return Address.  */
  REG_CFA			/* Call Frame Address.  */
d550 2
a551 25
  /* Initialize the register rules.  If we have a register that acts
     as a program counter, mark it as a destination for the return
     address.  If we have a register that serves as the stack pointer,
     arrange for it to be filled with the call frame address (CFA).
     The other registers are marked as unspecified.

     We copy the return address to the program counter, since many
     parts in GDB assume that it is possible to get the return address
     by unwind the program counter register.  However, on ISA's with a
     dedicated return address register, the CFI usually only contains
     information to unwind that return address register.

     The reason we're treating the stack pointer special here is
     because in many cases GCC doesn't emit CFI for the stack pointer
     and implicitly assumes that it is equal to the CFA.  This makes
     some sense since the DWARF specification (version 3, draft 8,
     p. 102) says that:

     "Typically, the CFA is defined to be the value of the stack
     pointer at the call site in the previous frame (which may be
     different from its value on entry to the current frame)."

     However, this isn't true for all platforms supported by GCC
     (e.g. IBM S/390 and zSeries).  For those targets we should
     override the defaults given here.  */
d556 1
a556 8
      {
	if (regnum == PC_REGNUM)
	  cache->reg[regnum].how = REG_RA;
	else if (regnum == SP_REGNUM)
	  cache->reg[regnum].how = REG_CFA;
	else
	  cache->reg[regnum].how = REG_UNSPECIFIED;
      }
d593 2
a594 2
	else
	  cache->reg[regnum] = fs->regs.reg[column];
d598 24
a621 22
  /* Eliminate any REG_RA rules.  */
  {
    int regnum;

    for (regnum = 0; regnum < num_regs; regnum++)
      {
	if (cache->reg[regnum].how == REG_RA)
	  {
	    if (fs->retaddr_column < fs->regs.num_regs)
	      cache->reg[regnum] = fs->regs.reg[fs->retaddr_column];
	    else
	      {
		/* It turns out that GCC assumes that if the return
                   address column is "empty" the return address can be
                   found in the register corresponding to the return
                   address column.  */
		cache->reg[regnum].loc.reg = fs->retaddr_column;
		cache->reg[regnum].how = REG_SAVED_REG;
	      }
	  }
      }
  }
d657 36
a692 1
      if (valuep)
d743 42
a784 2
      frame_register_unwind (next_frame, regnum,
			     optimizedp, lvalp, addrp, realnump, valuep);
a789 12
      break;

    case REG_CFA:
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  /* Store the value.  */
	  store_typed_address (valuep, builtin_type_void_data_ptr, cache->cfa);
	}
@


1.23.2.4
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d3 1
a3 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d100 27
d133 10
a142 1
    struct dwarf2_frame_state_reg *reg;
a244 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d250 1
a250 1
  buf = (char *) alloca (register_size (gdbarch, regnum));
d324 1
a324 1
	  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
d364 1
a364 1
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
d378 1
a378 1
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_UNDEFINED;
d384 1
a384 1
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAME_VALUE;
d391 1
a391 1
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_REG;
a434 3
	    case DW_CFA_nop:
	      break;

d448 1
a448 1
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_EXP;
d452 1
a452 20
	    case DW_CFA_offset_extended_sf:
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
	      insn_ptr = read_sleb128 (insn_ptr, insn_end, &offset);
	      offset += fs->data_align;
	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
	      fs->regs.reg[reg].loc.offset = offset;
	      break;

	    case DW_CFA_def_cfa_sf:
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &fs->cfa_reg);
	      insn_ptr = read_sleb128 (insn_ptr, insn_end, &offset);
	      fs->cfa_offset = offset * fs->data_align;
	      fs->cfa_how = CFA_REG_OFFSET;
	      break;

	    case DW_CFA_def_cfa_offset_sf:
	      insn_ptr = read_sleb128 (insn_ptr, insn_end, &offset);
	      fs->cfa_offset = offset * fs->data_align;
	      /* cfa_how deliberately not set.  */
a480 36
/* Initialize the register state REG.  If we have a register that acts
   as a program counter, mark it as a destination for the return
   address.  If we have a register that serves as the stack pointer,
   arrange for it to be filled with the call frame address (CFA).  The
   other registers are marked as unspecified.

   We copy the return address to the program counter, since many parts
   in GDB assume that it is possible to get the return address by
   unwind the program counter register.  However, on ISA's with a
   dedicated return address register, the CFI usually only contains
   information to unwind that return address register.

   The reason we're treating the stack pointer special here is because
   in many cases GCC doesn't emit CFI for the stack pointer and
   implicitly assumes that it is equal to the CFA.  This makes some
   sense since the DWARF specification (version 3, draft 8, p. 102)
   says that:

   "Typically, the CFA is defined to be the value of the stack pointer
   at the call site in the previous frame (which may be different from
   its value on entry to the current frame)."

   However, this isn't true for all platforms supported by GCC
   (e.g. IBM S/390 and zSeries).  For those targets we should override
   the defaults given here.  */

static void
dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,
		       struct dwarf2_frame_state_reg *reg)
{
  if (regnum == PC_REGNUM)
    reg->how = DWARF2_FRAME_REG_RA;
  else if (regnum == SP_REGNUM)
    reg->how = DWARF2_FRAME_REG_CFA;
}

a484 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d556 25
a580 1
  /* Initialize the register state.  */
d585 8
a592 1
      dwarf2_frame_init_reg (gdbarch, regnum, &cache->reg[regnum]);
d625 1
a625 1
	if (fs->regs.reg[column].how == DWARF2_FRAME_REG_UNSPECIFIED)
d634 1
a634 1
  /* Eliminate any DWARF2_FRAME_REG_RA rules.  */
d640 1
a640 1
	if (cache->reg[regnum].how == DWARF2_FRAME_REG_RA)
d642 2
a643 14
	    struct dwarf2_frame_state_reg *retaddr_reg =
	      &fs->regs.reg[fs->retaddr_column];

	    /* It seems rather bizarre to specify an "empty" column as
               the return adress column.  However, this is exactly
               what GCC does on some targets.  It turns out that GCC
               assumes that the return address can be found in the
               register corresponding to the return address column.
               Incidentally, that's how should treat a return address
               column specifying "same value" too.  */
	    if (fs->retaddr_column < fs->regs.num_regs
		&& retaddr_reg->how != DWARF2_FRAME_REG_UNSPECIFIED
		&& retaddr_reg->how != DWARF2_FRAME_REG_SAME_VALUE)
	      cache->reg[regnum] = *retaddr_reg;
d646 4
d651 1
a651 1
		cache->reg[regnum].how = DWARF2_FRAME_REG_SAVED_REG;
a678 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d684 1
a684 1
    case DWARF2_FRAME_REG_UNDEFINED:
d700 1
a700 1
    case DWARF2_FRAME_REG_SAVED_OFFSET:
d708 2
a709 1
	  read_memory (*addrp, valuep, register_size (gdbarch, regnum));
d713 1
a713 1
    case DWARF2_FRAME_REG_SAVED_REG:
d719 1
a719 1
    case DWARF2_FRAME_REG_SAVED_EXP:
d729 2
a730 1
	  read_memory (*addrp, valuep, register_size (gdbarch, regnum));
d734 1
a734 1
    case DWARF2_FRAME_REG_UNSPECIFIED:
d746 1
a746 1
    case DWARF2_FRAME_REG_SAME_VALUE:
d751 1
a751 1
    case DWARF2_FRAME_REG_CFA:
d1214 1
a1214 1
	obstack_alloc (&unit->objfile->objfile_obstack,
d1330 1
a1330 1
	obstack_alloc (&unit->objfile->objfile_obstack,
@


1.22
log
@	* dwarf2read.c (dwarf_info_offset, dwarf_abbrev_offset)
	(dwarf_line_offset, dwarf_pubnames_offset, dwarf_aranges_offset)
	(dwarf_loc_offset, dwarf_macinfo_offset, dwarf_str_offset)
	(dwarf_ranges_offset, dwarf_frame_offset, dwarf_eh_frame_offset):
	Delete.
	(dwarf2_read_section): Remove offset and size arguments.  Use
	bfd_get_section_size_before_reloc and sectp->filepos.
	(dwarf2_has_info): Clear section variables instead of offsets.
	(dwarf2_locate_sections): Don't initialize the deleted variables.
	(dwarf2_build_psymtabs): Update calls to dwarf2_read_section.
	(dwarf2_build_psymtabs_easy): Likewise.
	* dwarf2-frame.c (dwarf_frame_offset, dwarf_frame_size)
	(dwarf_eh_frame_offset, dwarf_eh_frame_size): Remove extern
	declarations.
	(dwarf2_read_section): Update prototype.
	(dwarf2_build_frame_info): Update calls to dwarf2_read_section.
	Use bfd_get_section_size_before_reloc instead of global size
	variables.
@
text
@d621 1
a621 2
      int reg = DWARF2_REG_TO_REGNUM (fs->retaddr_column);
      if (reg != PC_REGNUM)
d627 1
a627 1
	  cache->reg[PC_REGNUM].loc.reg = reg;
@


1.21
log
@* dwarf2-frame.c: Fix another comment.
@
text
@a1509 2
extern file_ptr dwarf_frame_offset;
extern unsigned int dwarf_frame_size;
a1510 2
extern file_ptr dwarf_eh_frame_offset;
extern unsigned int dwarf_eh_frame_size;
d1514 1
a1514 2
extern char *dwarf2_read_section (struct objfile *objfile, file_ptr offset,
				  unsigned int size, asection *sectp);
d1531 1
a1531 1
  if (dwarf_eh_frame_offset)
a1536 2
						     dwarf_eh_frame_offset,
						     dwarf_eh_frame_size,
d1539 2
a1540 1
      unit.dwarf_frame_size = dwarf_eh_frame_size;
d1562 1
a1562 1
  if (dwarf_frame_offset)
a1565 2
						     dwarf_frame_offset,
						     dwarf_frame_size,
d1567 2
a1568 1
      unit.dwarf_frame_size = dwarf_frame_size;
@


1.20
log
@* dwarf2-frame.c: Fix some comments and whitespace problems.
@
text
@d105 1
a105 1
     about a register, leaving how to obtain it's value totally
@


1.19
log
@* dwarf2-frame.c (dwarf2_build_frame_info): Wrap comment.
@
text
@d102 1
a102 1
  /* Make certain that 0 maps onto the correct enum value - the
d105 1
a105 1
     about a register - leaving how to obtain it's value totally
d109 5
a113 6
     code is moddeling - it indicates that the register's value is
     "undefined".  */
  /* NOTE: cagney/2003-09-08: GCC uses the less formal term "unsaved"
     - it's definition is a combination of REG_UNDEFINED and
     REG_UNSPECIFIED - the failure to differentiate the two helps
     explain a few problems with the CFI GCC outputs.  */
d502 1
a502 1
     instruction is probably wortless to us.  GCC's unwinder solves
d507 4
a510 7
     handlers, sentinel frames, dummy frames).

     frame_unwind_address_in_block does just this.

     It's not clear how reliable the method is though - there is the
     potential for the register state pre-call being different to that
     on return.  */
d554 1
d563 1
d574 4
a577 3
	     can't be right though - PC_REGNUM may not be valid (it
	     can be -ve).  I think, instead when RETADDR_COLUM isn't a
	     real register, it should map itself onto frame_pc_unwind.  */
d588 2
a589 2
	   of all debug info registers.  If it doesn't complain (but
	   not too loudly).  It turns out that GCC, assumes that an
d593 2
a594 2
	   isn't sufficient - it only checks that all registers in the
	   range [0 .. max column] are specified - and won't detect
d596 1
a596 1
	   table.  Need a way of iterating through all the valid
d608 2
a609 2
     column (adjusted) is not the same as gdb's PC_REGNUM, then this
     implies a copy from the ra column register.  */
d613 3
a615 3
      /* See comment above about a possibly -ve PC_REGNUM.  If this
         assertion fails, it's a problem with this code and not the
         architecture.  */
d624 3
a626 3
	  /* See comment above about PC_REGNUM being -ve.  If this
	     assertion fails, it's a problem with this code and not
	     the architecture.  */
d662 1
a662 1
	 mark it as optimized away - the value isn't available.  */
d683 2
a684 2
             reverse.  Assuming that SP_REGNUM is !-ve, there is a
             very real posibility that CFA is an offset from some
d772 1
a772 1
	  /* NOTE: cagney/2003-09-05: Should issue a complain.
@


1.18
log
@* dwarf2-frame.c (execute_cfa_program): Mark register as
REG_SAVED_REG for DW_CFA_register opcode.
@
text
@d1558 2
a1559 1
      /* GCC emits the DW_EH_PE_textrel encoding type on sh and ia64 so far.  */
@


1.17
log
@Index: mi/ChangeLog
2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* tui-out.c: Fix "fortunatly"[sic].

Index: doc/ChangeLog
2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* annotate.texinfo: Fix "fortunatly"[sic].

2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* osabi.c (gdbarch_init_osabi): Fix typos, and "fortunatly"[sic].
	* PROBLEMS, arch-utils.c, cli-out.c, command.h: Ditto.
	* complaints.c, cris-tdep.c, disasm.c, dwarf2-frame.c: Ditto.
	* frame.c, frame.h, infcall.c, infcmd.c, infrun.c: Ditto.
	* kod.c, mips-tdep.c, regcache.c, regcache.h, remote.c: Ditto.
@
text
@d386 1
@


1.16
log
@	* dwarf2-frame.c (struct comp_unit): Add tbase member to store
	base for DW_EH_PE_textrel encodings.
	(read_encoded_value): Add a DW_EH_PE_textrel case.
	(dwarf2_build_frame_info): Set unit.tbase to beginning of text
	section.
@
text
@d773 1
a773 1
             Unfortunatly it turns out that DWARF2 CFI has a problem.
@


1.15
log
@* dwarf2-frame.c (dwarf2_build_frame_info): Fix comment.
@
text
@d888 3
d1069 3
d1532 1
d1538 1
a1538 1
      asection *got;
d1556 5
@


1.14
log
@2003-09-08  Andrew Cagney  <cagney@@redhat.com>

	* dwarf2-frame.c (enum dwarf2_reg_rule): New, replace anonymous
	enum.  Add REG_UNSPECIFIED, rename REG_UNSAVED to REG_UNDEFINED
	and REG_UNMODIFIED to REG_SAME_VALUE.
	(execute_cfa_program): Update.
	(dwarf2_frame_cache): Update.  Initialize table to
	REG_UNSPECIFIED, complain if CFI fails to specify a register's
	location.
	(dwarf2_frame_prev_register): Update.  Handle REG_UNSPECIFIED.
@
text
@d1543 3
a1545 3
	 that for the i386/amd64 target, which currently is the only
	 target in GCC that supports/uses the DW_EH_PE_datarel
	 encoding.  */
@


1.13
log
@* dwarf2-frame.c (read_encoded_value): Add support for
DW_EH_PE_aligned encoding.
@
text
@d100 22
d136 1
a136 7
      enum {
	REG_UNSAVED,
	REG_SAVED_OFFSET,
	REG_SAVED_REG,
	REG_SAVED_EXP,
	REG_UNMODIFIED
      } how;
d373 1
a373 1
	      fs->regs.reg[reg].how = REG_UNSAVED;
d379 1
a379 1
	      fs->regs.reg[reg].how = REG_UNMODIFIED;
d479 1
a479 1
  int num_regs = NUM_REGS + NUM_PSEUDO_REGS;
a482 1
  int reg;
d553 7
a559 4
  /* Save the register info in the cache.  */
  for (reg = 0; reg < fs->regs.num_regs; reg++)
    {
      int regnum;
d561 45
a605 17
      /* Skip the return address column.  */
      if (reg == fs->retaddr_column)
	/* NOTE: cagney/2003-06-07: Is this right?  What if the
           RETADDR_COLUM corresponds to a real register (and, worse,
           that isn't the PC_REGNUM)?  I'm guessing that the PC_REGNUM
           further down is trying to handle this.  That can't be right
           though - PC_REGNUM may not be valid (it can be -ve).  I
           think, instead when RETADDR_COLUM isn't a real register, it
           should map itself onto frame_pc_unwind.  */
	continue;

      /* Use the GDB register number as index.  */
      regnum = DWARF2_REG_TO_REGNUM (reg);

      if (regnum >= 0 && regnum < num_regs)
	cache->reg[regnum] = fs->regs.reg[reg];
    }
d611 1
a611 1
      && fs->regs.reg[fs->retaddr_column].how != REG_UNSAVED)
d621 1
a621 1
      reg = DWARF2_REG_TO_REGNUM (fs->retaddr_column);
d660 3
a662 1
    case REG_UNSAVED:
d687 7
d745 53
a797 1
    case REG_UNMODIFIED:
@


1.12
log
@	PR java/1322
	* dwarf2-frame.c (dwarf2_frame_find_fde): Check whether any FDEs are
	available before calling SECT_OFF_TEXT.
@
text
@d935 2
d945 2
d959 9
d973 1
a973 1
    encoding |= encoding_for_size (TYPE_LENGTH(builtin_type_void_data_ptr));
d978 1
a978 1
      *bytes_read_ptr = 2;
d981 1
a981 1
      *bytes_read_ptr = 4;
d984 1
a984 1
      *bytes_read_ptr = 8;
d987 1
a987 1
      *bytes_read_ptr = 2;
d990 1
a990 1
      *bytes_read_ptr = 4;
d993 1
a993 1
      *bytes_read_ptr = 8;
@


1.11
log
@* objfiles.h (struct objfile): Add memebers `data' and `num_data'.
(register_objfile_data, set_objfile_data, objfile_data): New
prototypes.
* objfiles.c (objfile_alloc_data, objfile_free_data): New
prototypes.
(allocate_objfile): Call objfile_alloc_data.
(free_objfile): Call objfile_free_data.
(struct objfile_data): New.
(struct objfile_data_registration): New.
(struct objfile_data_registry): New.
(objfile_data_registry): New variable.
(register_objfile_data): New function.
(objfile_alloc_data, objfile_free_data): New functions.
(set_objfile_data, objfile_data): New functions.
* dwarf2-frame.c (dwarf2_frame_data): New variable.
(dwarf2_frame_find_fde, add_fde): Use new per-objfile data mechanism.
(_initialize_dwarf2_frame): New function and prototype.
@
text
@d1027 5
d1033 1
a1033 2
      
      fde = objfile_data (objfile, dwarf2_frame_data);
@


1.10
log
@2003-07-18  Andrew Cagney  <cagney@@redhat.com>

	* dwarf2-frame.c (dwarf2_frame_sniffer): Use
	frame_unwind_address_in_block, instead of frame_pc_unwind.
	(dwarf2_frame_cache): Ditto.
@
text
@d783 2
d1029 1
a1029 1
      fde = objfile->sym_private;
d1049 2
a1050 2
  fde->next = unit->objfile->sym_private;
  unit->objfile->sym_private = fde;
d1445 9
@


1.9
log
@2003-07-16  Andrew Cagney  <cagney@@redhat.com>

	* frame-base.h (frame_base_p_ftype): Delete definition.
	(frame_base_append_predicate): Delete declaration.
	* frame-unwind.h (frame_unwind_p_ftype): Delete definition.
	(frame_unwind_append_predicate): Delete declaration.
	* frame-unwind.c (struct frame_unwind_table): Delete field "p".
	(append_predicate): Delete parameter "p".
	(frame_unwind_append_predicate): Delete function.
	(frame_unwind_append_sniffer): Update call to append_predicate.
	(frame_unwind_free): Delete function.
	(_initialize_frame_unwind): Pass NULL as "free" to
	register_gdbarch_data.
	(frame_unwind_init): Append the dummy_frame_sniffer.
	(frame_unwind_find_by_frame): Simplify.
	* frame-base.c (struct frame_base_table): Delete field "p".
	(append_predicate): Delete parameter "p".
	(frame_base_append_predicate): Delete function.
	(frame_base_append_sniffer): Update call to append_predicate.
	(frame_base_free): Delete function.
	(frame_base_find_by_frame): Simplify.
	(_initialize_frame_base): Pass NULL as "free" to
	register_gdbarch_data.
	* x86-64-tdep.c (x86_64_frame_sniffer): Replace "x86_64_frame_p".
	(x86_64_sigtramp_frame_sniffer): Replace
	"x86_64_sigtramp_frame_p".
	(x86_64_init_abi): Set the frame unwind sniffers.
	* m68k-tdep.c (m68k_frame_sniffer): Replace "m68k_frame_p".
	(m68k_sigtramp_frame_sniffer): Replace "m68k_sigtramp_frame_p"
	(m68k_gdbarch_init): Set the frame unwind sniffers.
	* i386-tdep.c (i386_sigtramp_frame_sniffer): Replace
	"i386_sigtramp_frame_p".
	(i386_frame_sniffer): Replace "i386_frame_p".
	(i386_gdbarch_init): Set the frame unwind sniffers.
	* avr-tdep.c (avr_frame_sniffer): Replace "avr_frame_sniffer".
	(avr_gdbarch_init): Set the frame unwind sniffers.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Replace
	"alpha_sigtramp_frame_p"
	(alpha_heuristic_frame_sniffer): Replace
	"alpha_heuristic_frame_p".
	(alpha_gdbarch_init): Set the frame unwind sniffers.
	(alpha_dwarf2_init_abi): Ditto.
	* alpha-mdebug-tdep.c (alpha_mdebug_frame_sniffer): Replace
	"alpha_debug_frame_p".
	(alpha_mdebug_frame_base_sniffer): Replace
	"alpha_mdebug_frame_base_p".
	(alpha_mdebug_init_abi): Set the frame unwind sniffers.
	* d10v-tdep.c (d10v_frame_sniffer): Replace "d10v_frame_p".
	(d10v_gdbarch_init): Set the frame unwind sniffer.
	* dwarf2-frame.c (dwarf2_frame_sniffer): Replace "dwarf2_frame_p".
	(dwarf2_frame_base_sniffer): Replace "dwarf2_frame_base_p".
	* dwarf2-frame.h (dwarf2_frame_sniffer): Replace "dwarf2_frame_p".
	(dwarf2_frame_base_sniffer): Replace "dwarf2_frame_base_p".
	* dummy-frame.c (dummy_frame_sniffer): Replace "dummy_frame_p".
	* dummy-frame.h (dummy_frame_sniffer): Replace "dummy_frame_p".
@
text
@d494 6
a499 9
     We don't do what GCC's does here (yet).  It's not clear how
     reliable the method is.  There's also a problem with finding the
     right FDE; see the comment in dwarf_frame_p.  If dwarf_frame_p
     selected this frame unwinder because it found the FDE for the
     next function, using the adjusted return address might not yield
     a FDE at all.  The problem isn't specific to DWARF CFI; other
     unwinders loose in similar ways.  Therefore it's probably
     acceptable to leave things slightly broken for now.  */
  fs->pc = frame_pc_unwind (next_frame);
d710 5
a714 9
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  /* The way GDB works, this function can be called with PC just after
     the last instruction of the function we're supposed to return the
     unwind methods for.  In that case we won't find the correct FDE;
     instead we find the FDE for the next function, or we won't find
     an FDE at all.  There is a possible solution (see the comment in
     dwarf2_frame_cache), GDB doesn't pass us enough information to
     implement it.  */
  if (dwarf2_frame_find_fde (&pc))
@


1.8
log
@        * Makefile.in (dwarf2-frame.o): Add complaints_h.
        * dwarf2-frame.c: Include complaints.h.
        (decode_frame_entry_1): Rename from decode_frame_entry; tidy
        variable initialization; return NULL on error.
        (decode_frame_entry): New.
@
text
@d711 1
a711 1
dwarf2_frame_p (CORE_ADDR pc)
d713 1
d752 1
a752 1
dwarf2_frame_base_p (CORE_ADDR pc)
d754 1
@


1.7
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* acinclude.m4 (gcc_AC_CHECK_DECL, (gcc_AC_CHECK_DECL): Stolen
	from GCC's acinclude.m4.
	* configure.in: Check for getopt's delcaration.
	* aclocal.m4, config.in, configure: Re-generate.
	* main.c (error_init): Delete declaration.
	* defs.h (error_init): Declare.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Make static.
	(rs6000_convert_from_func_ptr_addr): Make static.
	(_initialize_rs6000_tdep): Add declaration.
	* cli/cli-cmds.c (dont_repeat): Delete declaration.
	(show_commands, set_verbose, show_history): Delete declaration.
	* top.h (set_verbose): Add declaration.
	(show_history, set_history, show_commands): Add declaration.
	(do_restore_instream_cleanup): Add declaration.
	* objc-lang.c (specialcmp): Make static.
	(print_object_command): Make static.
	(find_objc_msgsend): Make static.
	(find_objc_msgcall_submethod_helper): Make static.
	(find_objc_msgcall_submethod): Make static.
	(_initialize_objc_language): Add declaration.
	(find_implementation_from_class): Make static.
	(find_implementation): Make static.
	* objc-exp.y (yylex): Delete lookup_struct_typedef declaration.
	* objc-lang.h (lookup_struct_typedef): Add declaration.
	* cli/cli-interp.c (_initialize_cli_interp): Add declaration.
	* cli/cli-script.c (clear_hook_in_cleanup): Make static.
	(do_restore_user_call_depth): Make static.
	(do_restore_instream_cleanup): Delete declaration.
	(dont_repeat): Delete declaration.
	* cli/cli-decode.c (add_abbrev_cmd): Delete function.
	* cli/cli-dump.c (_initialize_cli_dump): Add declaration.
	* reggroups.c (_initialize_reggroup): Add declaration.
	* cp-support.c (_initialize_cp_support): Add declaration.
	* cp-abi.c (_initialize_cp_abi): Add declaration.
	* hpacc-abi.c (_initialize_hpacc_abi): Add declaration.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Make static.
	(_initialize_gnu_v3_abi): Add declaration.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Make static.
	(_initialize_gnu_v2_abi): Add declaration.
	* frame-base.c (_initialize_frame_base): Add declaration.
	* doublest.c (floatformat_from_length): Make static.
	* frame-unwind.c (_initialize_frame_unwind): Add declaration.
	* frame.c (create_sentinel_frame): Make static.
	(_initialize_frame): Add declaration.
	* top.c (do_catch_errors): Make static.
	(gdb_rl_operate_and_get_next_completion): Make static.
	* typeprint.c: Include "typeprint.h".
	* sentinel-frame.c (sentinel_frame_prev_register): Make static.
	(sentinel_frame_this_id): Make static.
	* p-valprint.c (_initialize_pascal_valprint): Add declaration.
	* ui-out.c (make_cleanup_ui_out_begin_end): Delete function.
	* dwarf2-frame.c (dwarf2_frame_cache): Make static.
	* p-exp.y (push_current_type, pop_current_type): ISO C declaration.
	* dwarf2expr.h (dwarf_expr_context): ISO C declaration.
	* maint.c (maintenance_print_architecture): Make static.
	* signals/signals.c (_initialize_signals): Add declaration.
	* std-regs.c (_initialize_frame_reg): Add declaration.
	* jv-exp.y (push_variable): ISO C definition.
	(push_qualified_expression_name): Ditto.
	* memattr.c (_initialize_mem): Add declaration.
	* remote.c (remote_check_watch_resources): Make static.
	(remote_stopped_by_watchpoint): Make static.
	(remote_stopped_data_address): Make static.
	* d10v-tdep.c (nr_dmap_regs): Make static.
	(a0_regnum): Make static.
	(d10v_frame_unwind_cache): Make static.
	(d10v_frame_p): Make static.
	* osabi.c (show_osabi): Make static.
	(_initialize_gdb_osabi): Add extern declaration.
	* gdbtypes.c (make_qualified_type): Make static.
	(safe_parse_type): Make static.
	* macrocmd.c (_initialize_macrocmd): Add extern declaration.
	* macrotab.c (macro_bcache_free): Make static.
	* interps.c (interp_set_quiet): Make static.
	(interpreter_exec_cmd): Make static.
	* stack.h (select_frame_command): New file.
	* stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete function.
	(select_frame_command): Make global.
	* infcall.c: Include "infcall.h".
	* linespec.c: Include "linespec.h".
	* symfile.c (sections_overlap): Make static.
	* cp-support.h (cp_initialize_namespace): ISO C declaration.
	* charset.c (_initialize_charset): Add missing prototype.
	* regcache.c (init_legacy_regcache_descr): Make static.
	(do_regcache_xfree): Make static.
	(regcache_xfer_part): Make static.
	(_initialize_regcache): Add missing prototype.
	* breakpoint.c (parse_breakpoint_sals): Make static.
	(breakpoint_sals_to_pc): Make static.
	* interps.h (clear_interpreter_hooks): ISO C declaration.
	* Makefile.in (stack_h): Define.
	(stack.o, typeprint.o, mi-main.o): Update dependencies.
	(mi-cmd-stack.o, infcall.o, linespec.o): Update dependencies.

Index: mi/ChangeLog
2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-parse.c (_initialize_mi_parse): Delete function.
	* mi-main.c: Include "mi-main.h".
	* mi-interp.c (_initialize_mi_interp): Add declaration.
	* mi-cmd-stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete extern declaration.
	(mi_cmd_stack_select_frame): Replace select_frame_command_wrapper
	with select_frame_command.
@
text
@d39 1
d1062 2
a1063 1
/* Read a CIE or FDE in BUF and decode it.  */
d1065 2
d1068 1
a1068 1
decode_frame_entry (struct comp_unit *unit, char *buf, int eh_frame_p)
d1070 1
d1073 2
a1074 2
  int dwarf64_p = 0;
  ULONGEST cie_id = DW_CIE_ID;
a1075 1
  char *start = buf;
d1078 1
d1083 4
d1090 2
a1091 2
  if (bytes_read == 12)
    dwarf64_p = 1;
d1093 1
a1093 2
  /* In a .eh_frame section, zero is used to distinguish CIEs from
     FDEs.  */
d1098 2
d1137 2
a1138 1
      gdb_assert (read_1_byte (unit->abfd, buf) == DW_CIE_VERSION);
d1173 2
d1227 4
a1232 4
	  /* In an .eh_frame section, the CIE pointer is the delta
             between the address within the FDE where the CIE pointer
             is stored and the address of the CIE.  Convert it to an
             offset into the .eh_frame section.  */
d1237 4
d1272 2
d1284 93
d1422 3
a1424 3
         that for the i386/amd64 target, which currently is the only
         target in GCC that supports/uses the DW_EH_PE_datarel
         encoding.  */
@


1.7.4.1
log
@        * Makefile.in (dwarf2-frame.o): Add complaints_h.
        * dwarf2-frame.c: Include complaints.h.
        (decode_frame_entry_1): Rename from decode_frame_entry; tidy
        variable initialization; return NULL on error.
        (decode_frame_entry): New.
@
text
@a38 1
#include "complaints.h"
d1061 1
a1061 2
static char *decode_frame_entry (struct comp_unit *unit, char *start,
				 int eh_frame_p);
a1062 2
/* Decode the next CIE or FDE.  Return NULL if invalid input, otherwise
   the next byte to be processed.  */
d1064 1
a1064 1
decode_frame_entry_1 (struct comp_unit *unit, char *start, int eh_frame_p)
a1065 1
  char *buf;
d1068 2
a1069 2
  int dwarf64_p;
  ULONGEST cie_id;
d1071 1
a1073 1
  buf = start;
a1077 4
  /* Are we still within the section? */
  if (end > unit->dwarf_frame_buffer + unit->dwarf_frame_size)
    return NULL;

d1081 2
a1082 2
  /* Distinguish between 32 and 64-bit encoded frame info.  */
  dwarf64_p = (bytes_read == 12);
d1084 2
a1085 1
  /* In a .eh_frame section, zero is used to distinguish CIEs from FDEs.  */
a1089 2
  else
    cie_id = DW_CIE_ID;
d1127 1
a1127 2
      if (read_1_byte (unit->abfd, buf) != DW_CIE_VERSION)
	return NULL;
a1161 2
	  if (buf > end)
	    return NULL;
a1213 4
      /* In an .eh_frame section, the CIE pointer is the delta between the
	 address within the FDE where the CIE pointer is stored and the
	 address of the CIE.  Convert it to an offset into the .eh_frame
	 section.  */
d1216 4
a1223 4
      /* In either case, validate the result is still within the section.  */
      if (cie_pointer >= unit->dwarf_frame_size)
	return NULL;

a1254 2
	  if (buf > end)
	    return NULL;
a1264 93

/* Read a CIE or FDE in BUF and decode it.  */
static char *
decode_frame_entry (struct comp_unit *unit, char *start, int eh_frame_p)
{
  enum { NONE, ALIGN4, ALIGN8, FAIL } workaround = NONE;
  char *ret;
  const char *msg;
  ptrdiff_t start_offset;

  while (1)
    {
      ret = decode_frame_entry_1 (unit, start, eh_frame_p);
      if (ret != NULL)
	break;

      /* We have corrupt input data of some form.  */

      /* ??? Try, weakly, to work around compiler/assembler/linker bugs
	 and mismatches wrt padding and alignment of debug sections.  */
      /* Note that there is no requirement in the standard for any
	 alignment at all in the frame unwind sections.  Testing for
	 alignment before trying to interpret data would be incorrect.

	 However, GCC traditionally arranged for frame sections to be
	 sized such that the FDE length and CIE fields happen to be
	 aligned (in theory, for performance).  This, unfortunately,
	 was done with .align directives, which had the side effect of
	 forcing the section to be aligned by the linker.

	 This becomes a problem when you have some other producer that
	 creates frame sections that are not as strictly aligned.  That
	 produces a hole in the frame info that gets filled by the 
	 linker with zeros.

	 The GCC behaviour is arguably a bug, but it's effectively now
	 part of the ABI, so we're now stuck with it, at least at the
	 object file level.  A smart linker may decide, in the process
	 of compressing duplicate CIE information, that it can rewrite
	 the entire output section without this extra padding.  */

      start_offset = start - unit->dwarf_frame_buffer;
      if (workaround < ALIGN4 && (start_offset & 3) != 0)
	{
	  start += 4 - (start_offset & 3);
	  workaround = ALIGN4;
	  continue;
	}
      if (workaround < ALIGN8 && (start_offset & 7) != 0)
	{
	  start += 8 - (start_offset & 7);
	  workaround = ALIGN8;
	  continue;
	}

      /* Nothing left to try.  Arrange to return as if we've consumed
	 the entire input section.  Hopefully we'll get valid info from
	 the other of .debug_frame/.eh_frame.  */
      workaround = FAIL;
      ret = unit->dwarf_frame_buffer + unit->dwarf_frame_size;
      break;
    }

  switch (workaround)
    {
    case NONE:
      break;

    case ALIGN4:
      complaint (&symfile_complaints,
		 "Corrupt data in %s:%s; align 4 workaround apparently succeeded",
		 unit->dwarf_frame_section->owner->filename,
		 unit->dwarf_frame_section->name);
      break;

    case ALIGN8:
      complaint (&symfile_complaints,
		 "Corrupt data in %s:%s; align 8 workaround apparently succeeded",
		 unit->dwarf_frame_section->owner->filename,
		 unit->dwarf_frame_section->name);
      break;

    default:
      complaint (&symfile_complaints,
		 "Corrupt data in %s:%s",
		 unit->dwarf_frame_section->owner->filename,
		 unit->dwarf_frame_section->name);
      break;
    }

  return ret;
}

d1310 3
a1312 3
	 that for the i386/amd64 target, which currently is the only
	 target in GCC that supports/uses the DW_EH_PE_datarel
	 encoding.  */
@


1.7.4.2
log
@2003-07-21  Andrew Cagney  <cagney@@redhat.com>

	* dwarf2-frame.h (dwarf2_frame_sniffer): Replace "dwarf2_frame_p".
	* dwarf2-frame.c (dwarf2_frame_sniffer): Replace "dwarf2_frame_p".
	(dwarf2_frame_cache): Use frame_unwind_address_in_block, instead
	of frame_pc_unwind.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* alpha-tdep.c (alpha_dwarf2_init_abi): Update.
@
text
@d494 9
a502 6
     frame_unwind_address_in_block does just this.

     It's not clear how reliable the method is though - there is the
     potential for the register state pre-call being different to that
     on return.  */
  fs->pc = frame_unwind_address_in_block (next_frame);
d711 1
a711 1
dwarf2_frame_sniffer (struct frame_info *next_frame)
d713 8
a720 5
  /* Grab an address that is guarenteed to reside somewhere within the
     function.  frame_pc_unwind(), for a no-return next function, can
     end up returning something past the end of this function's body.  */
  CORE_ADDR block_addr = frame_unwind_address_in_block (next_frame);
  if (dwarf2_frame_find_fde (&block_addr))
@


1.7.4.3
log
@2003-09-08  Andrew Cagney  <cagney@@redhat.com>

	* dwarf2-frame.c (enum dwarf2_reg_rule): New, replace anonymous
	enum.  Add REG_UNSPECIFIED, rename REG_UNSAVED to REG_UNDEFINED
	and REG_UNMODIFIED to REG_SAME_VALUE.
	(execute_cfa_program): Update.
	(dwarf2_frame_cache): Update.  Initialize table to
	REG_UNSPECIFIED, complain if CFI fails to specify a register's
	location.
	(dwarf2_frame_prev_register): Update.  Handle REG_UNSPECIFIED.
@
text
@a99 22
enum dwarf2_reg_rule
{
  /* Make certain that 0 maps onto the correct enum value - the
     corresponding structure is being initialized using memset zero.
     This indicates that CFI didn't provide any information at all
     about a register - leaving how to obtain it's value totally
     unspecified.  */
  REG_UNSPECIFIED = 0,
  /* The term "undefined" comes from the DWARF2 CFI spec which this
     code is moddeling - it indicates that the register's value is
     "undefined".  */
  /* NOTE: cagney/2003-09-08: GCC uses the less formal term "unsaved"
     - it's definition is a combination of REG_UNDEFINED and
     REG_UNSPECIFIED - the failure to differentiate the two helps
     explain a few problems with the CFI GCC outputs.  */
  REG_UNDEFINED,
  REG_SAVED_OFFSET,
  REG_SAVED_REG,
  REG_SAVED_EXP,
  REG_SAME_VALUE
};

d114 7
a120 1
      enum dwarf2_reg_rule how;
d357 1
a357 1
	      fs->regs.reg[reg].how = REG_UNDEFINED;
d363 1
a363 1
	      fs->regs.reg[reg].how = REG_SAME_VALUE;
d463 1
a463 1
  const int num_regs = NUM_REGS + NUM_PSEUDO_REGS;
d467 1
d538 18
a555 7
  /* Initialize things so that all registers are marked as
     unspecified.  */
  {
    int regnum;
    for (regnum = 0; regnum < num_regs; regnum++)
      cache->reg[regnum].how = REG_UNSPECIFIED;
  }
d557 3
a559 45
  /* Go through the DWARF2 CFI generated table and save its register
     location information in the cache.  */
  {
    int column;		/* CFI speak for "register number".  */
    for (column = 0; column < fs->regs.num_regs; column++)
      {
	int regnum;
	
	/* Skip the return address column.  */
	if (column == fs->retaddr_column)
	  /* NOTE: cagney/2003-06-07: Is this right?  What if
	     RETADDR_COLUMN corresponds to a real register (and,
	     worse, that isn't the PC_REGNUM)?  I'm guessing that the
	     PC_REGNUM further down is trying to handle this.  That
	     can't be right though - PC_REGNUM may not be valid (it
	     can be -ve).  I think, instead when RETADDR_COLUM isn't a
	     real register, it should map itself onto frame_pc_unwind.  */
	  continue;

	/* Use the GDB register number as the destination index.  */
	regnum = DWARF2_REG_TO_REGNUM (column);

	/* If there's no corresponding GDB register, ignore it.  */
	if (regnum < 0 || regnum >= num_regs)
	  continue;

	/* NOTE: cagney/2003-09-05: CFI should specify the disposition
	   of all debug info registers.  If it doesn't complain (but
	   not too loudly).  It turns out that GCC, assumes that an
	   unspecified register implies "same value" when CFI (draft
	   7) specifies nothing at all.  Such a register could equally
	   be interpreted as "undefined".  Also note that this check
	   isn't sufficient - it only checks that all registers in the
	   range [0 .. max column] are specified - and won't detect
	   problems when a debug info register falls outside of the
	   table.  Need a way of iterating through all the valid
	   DWARF2 register numbers.  */
	if (fs->regs.reg[column].how == REG_UNSPECIFIED)
	  complaint (&symfile_complaints,
		     "Incomplete CFI data; unspecified registers at 0x%s",
		     paddr (fs->pc));

	cache->reg[regnum] = fs->regs.reg[column];
      }
  }
d565 1
a565 1
      && fs->regs.reg[fs->retaddr_column].how != REG_UNDEFINED)
d575 1
a575 1
      int reg = DWARF2_REG_TO_REGNUM (fs->retaddr_column);
d614 1
a614 3
    case REG_UNDEFINED:
      /* If CFI explicitly specified that the value isn't defined,
	 mark it as optimized away - the value isn't available.  */
a638 7
	  /* FIXME: cagney/2003-09-05: I think I understand.  GDB was
	     lumping the two states "unspecified" and "undefined"
	     together.  Here SP_REGNUM was "unspecified", GCC assuming
	     that in such a case CFA would be used.  This branch of
	     the if statement should be deleted - the problem of
	     SP_REGNUM is now handed by the case REG_UNSPECIFIED
	     below.  */
d690 1
a690 53
    case REG_UNSPECIFIED:
      /* GCC, in its infinite wisdom decided to not provide unwind
	 information for registers that are "same value".  Since
	 DWARF2 (3 draft 7) doesn't define such behavior, said
	 registers are actually undefined (which is different to CFI
	 "undefined").  Code above issues a complaint about this.
	 Here just fudge the books, assume GCC, and that the value is
	 more inner on the stack.  */
      if (SP_REGNUM >= 0 && regnum == SP_REGNUM)
	{
	  /* Can things get worse?  Yep!  One of the registers GCC
	     forgot to provide unwind information for was the stack
	     pointer.  Outch!  GCC appears to assumes that the CFA
	     address can be used - after all it points to the inner
	     most address of the previous frame before the function
	     call and that's always the same as the stack pointer on
	     return, right?  Wrong.  See GCC's i386 STDCALL option for
	     an ABI that has a different entry and return stack
	     pointer.  */
	  /* DWARF V3 Draft 7 p102: Typically, the CFA is defined to
	     be the value of the stack pointer at the call site in the
	     previous frame (which may be different from its value on
	     entry to the current frame).  */
	  /* DWARF V3 Draft 7 p103: The first column of the rules
             defines the rule which computes the CFA value; it may be
             either a register and a signed offset that are added
             together or a DWARF expression that is evaluated.  */
	  /* NOTE: cagney/2003-09-05: Should issue a complain.
             Unfortunatly it turns out that DWARF2 CFI has a problem.
             Since CFI specifies the location at which a register was
             saved (not its value) it isn't possible to specify
             something like "unwound(REG) == REG + constant" using CFI
             as will almost always occure with the stack pointer.  I
             guess CFI should be point SP at CFA.  Ref: danielj,
             "Describing unsaved stack pointers", posted to dwarf2
             list 2003-08-15.  */
	  *optimizedp = 0;
	  *lvalp = not_lval;
	  *addrp = 0;
	  *realnump = -1;
	  if (valuep)
	    /* Store the value.  */
	    store_typed_address (valuep, builtin_type_void_data_ptr,
				 cache->cfa);
	}
      else
	/* Assume that the register can be found in the next inner
           most frame.  */
	frame_register_unwind (next_frame, regnum,
			       optimizedp, lvalp, addrp, realnump, valuep);
      break;

    case REG_SAME_VALUE:
@


1.7.4.4
log
@	Merge from mainline:
	2003-07-13  Mark Kettenis  <kettenis@@gnu.org>

	* objfiles.h (struct objfile): Add memebers `data' and `num_data'.
	(register_objfile_data, set_objfile_data, objfile_data): New
	prototypes.
	* objfiles.c (objfile_alloc_data, objfile_free_data): New
	prototypes.
	(allocate_objfile): Call objfile_alloc_data.
	(free_objfile): Call objfile_free_data.
	(struct objfile_data): New.
	(struct objfile_data_registration): New.
	(struct objfile_data_registry): New.
	(objfile_data_registry): New variable.
	(register_objfile_data): New function.
	(objfile_alloc_data, objfile_free_data): New functions.
	(set_objfile_data, objfile_data): New functions.
	* dwarf2-frame.c (dwarf2_frame_data): New variable.
	(dwarf2_frame_find_fde, add_fde): Use new per-objfile data mechanism.
	(_initialize_dwarf2_frame): New function and prototype.
@
text
@a888 2
const struct objfile_data *dwarf2_frame_data;

d1133 1
a1133 1
      fde = objfile_data (objfile, dwarf2_frame_data);
d1153 2
a1154 2
  fde->next = objfile_data (unit->objfile, dwarf2_frame_data);
  set_objfile_data (unit->objfile, dwarf2_frame_data, fde);
a1548 9
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_dwarf2_frame (void);

void
_initialize_dwarf2_frame (void)
{
  dwarf2_frame_data = register_objfile_data ();
@


1.7.4.5
log
@	2003-08-25  Daniel Jacobowitz  <drow@@mvista.com>

	PR java/1322
	* dwarf2-frame.c (dwarf2_frame_find_fde): Check whether any FDEs are
	available before calling SECT_OFF_TEXT.
	* PROBLEMS: Remove description of java/1322.
@
text
@d1133 2
a1135 6
      if (fde == NULL)
	continue;

      gdb_assert (objfile->section_offsets);
      offset = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

@


1.7.6.1
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@@


1.7.6.2
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a38 1
#include "complaints.h"
d493 9
a501 6
     frame_unwind_address_in_block does just this.

     It's not clear how reliable the method is though - there is the
     potential for the register state pre-call being different to that
     on return.  */
  fs->pc = frame_unwind_address_in_block (next_frame);
d710 1
a710 1
dwarf2_frame_sniffer (struct frame_info *next_frame)
d712 8
a719 5
  /* Grab an address that is guarenteed to reside somewhere within the
     function.  frame_pc_unwind(), for a no-return next function, can
     end up returning something past the end of this function's body.  */
  CORE_ADDR block_addr = frame_unwind_address_in_block (next_frame);
  if (dwarf2_frame_find_fde (&block_addr))
d750 1
a750 1
dwarf2_frame_base_sniffer (struct frame_info *next_frame)
a751 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
d1061 1
a1061 2
static char *decode_frame_entry (struct comp_unit *unit, char *start,
				 int eh_frame_p);
a1062 2
/* Decode the next CIE or FDE.  Return NULL if invalid input, otherwise
   the next byte to be processed.  */
d1064 1
a1064 1
decode_frame_entry_1 (struct comp_unit *unit, char *start, int eh_frame_p)
a1065 1
  char *buf;
d1068 2
a1069 2
  int dwarf64_p;
  ULONGEST cie_id;
d1071 1
a1073 1
  buf = start;
a1077 4
  /* Are we still within the section? */
  if (end > unit->dwarf_frame_buffer + unit->dwarf_frame_size)
    return NULL;

d1081 2
a1082 2
  /* Distinguish between 32 and 64-bit encoded frame info.  */
  dwarf64_p = (bytes_read == 12);
d1084 2
a1085 1
  /* In a .eh_frame section, zero is used to distinguish CIEs from FDEs.  */
a1089 2
  else
    cie_id = DW_CIE_ID;
d1127 1
a1127 2
      if (read_1_byte (unit->abfd, buf) != DW_CIE_VERSION)
	return NULL;
a1161 2
	  if (buf > end)
	    return NULL;
a1213 4
      /* In an .eh_frame section, the CIE pointer is the delta between the
	 address within the FDE where the CIE pointer is stored and the
	 address of the CIE.  Convert it to an offset into the .eh_frame
	 section.  */
d1216 4
a1223 4
      /* In either case, validate the result is still within the section.  */
      if (cie_pointer >= unit->dwarf_frame_size)
	return NULL;

a1254 2
	  if (buf > end)
	    return NULL;
a1264 93

/* Read a CIE or FDE in BUF and decode it.  */
static char *
decode_frame_entry (struct comp_unit *unit, char *start, int eh_frame_p)
{
  enum { NONE, ALIGN4, ALIGN8, FAIL } workaround = NONE;
  char *ret;
  const char *msg;
  ptrdiff_t start_offset;

  while (1)
    {
      ret = decode_frame_entry_1 (unit, start, eh_frame_p);
      if (ret != NULL)
	break;

      /* We have corrupt input data of some form.  */

      /* ??? Try, weakly, to work around compiler/assembler/linker bugs
	 and mismatches wrt padding and alignment of debug sections.  */
      /* Note that there is no requirement in the standard for any
	 alignment at all in the frame unwind sections.  Testing for
	 alignment before trying to interpret data would be incorrect.

	 However, GCC traditionally arranged for frame sections to be
	 sized such that the FDE length and CIE fields happen to be
	 aligned (in theory, for performance).  This, unfortunately,
	 was done with .align directives, which had the side effect of
	 forcing the section to be aligned by the linker.

	 This becomes a problem when you have some other producer that
	 creates frame sections that are not as strictly aligned.  That
	 produces a hole in the frame info that gets filled by the 
	 linker with zeros.

	 The GCC behaviour is arguably a bug, but it's effectively now
	 part of the ABI, so we're now stuck with it, at least at the
	 object file level.  A smart linker may decide, in the process
	 of compressing duplicate CIE information, that it can rewrite
	 the entire output section without this extra padding.  */

      start_offset = start - unit->dwarf_frame_buffer;
      if (workaround < ALIGN4 && (start_offset & 3) != 0)
	{
	  start += 4 - (start_offset & 3);
	  workaround = ALIGN4;
	  continue;
	}
      if (workaround < ALIGN8 && (start_offset & 7) != 0)
	{
	  start += 8 - (start_offset & 7);
	  workaround = ALIGN8;
	  continue;
	}

      /* Nothing left to try.  Arrange to return as if we've consumed
	 the entire input section.  Hopefully we'll get valid info from
	 the other of .debug_frame/.eh_frame.  */
      workaround = FAIL;
      ret = unit->dwarf_frame_buffer + unit->dwarf_frame_size;
      break;
    }

  switch (workaround)
    {
    case NONE:
      break;

    case ALIGN4:
      complaint (&symfile_complaints,
		 "Corrupt data in %s:%s; align 4 workaround apparently succeeded",
		 unit->dwarf_frame_section->owner->filename,
		 unit->dwarf_frame_section->name);
      break;

    case ALIGN8:
      complaint (&symfile_complaints,
		 "Corrupt data in %s:%s; align 8 workaround apparently succeeded",
		 unit->dwarf_frame_section->owner->filename,
		 unit->dwarf_frame_section->name);
      break;

    default:
      complaint (&symfile_complaints,
		 "Corrupt data in %s:%s",
		 unit->dwarf_frame_section->owner->filename,
		 unit->dwarf_frame_section->name);
      break;
    }

  return ret;
}

d1310 3
a1312 3
	 that for the i386/amd64 target, which currently is the only
	 target in GCC that supports/uses the DW_EH_PE_datarel
	 encoding.  */
@


1.7.6.3
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a99 22
enum dwarf2_reg_rule
{
  /* Make certain that 0 maps onto the correct enum value - the
     corresponding structure is being initialized using memset zero.
     This indicates that CFI didn't provide any information at all
     about a register - leaving how to obtain it's value totally
     unspecified.  */
  REG_UNSPECIFIED = 0,
  /* The term "undefined" comes from the DWARF2 CFI spec which this
     code is moddeling - it indicates that the register's value is
     "undefined".  */
  /* NOTE: cagney/2003-09-08: GCC uses the less formal term "unsaved"
     - it's definition is a combination of REG_UNDEFINED and
     REG_UNSPECIFIED - the failure to differentiate the two helps
     explain a few problems with the CFI GCC outputs.  */
  REG_UNDEFINED,
  REG_SAVED_OFFSET,
  REG_SAVED_REG,
  REG_SAVED_EXP,
  REG_SAME_VALUE
};

d114 7
a120 1
      enum dwarf2_reg_rule how;
d357 1
a357 1
	      fs->regs.reg[reg].how = REG_UNDEFINED;
d363 1
a363 1
	      fs->regs.reg[reg].how = REG_SAME_VALUE;
d463 1
a463 1
  const int num_regs = NUM_REGS + NUM_PSEUDO_REGS;
d467 1
d538 4
a541 7
  /* Initialize things so that all registers are marked as
     unspecified.  */
  {
    int regnum;
    for (regnum = 0; regnum < num_regs; regnum++)
      cache->reg[regnum].how = REG_UNSPECIFIED;
  }
d543 10
a552 18
  /* Go through the DWARF2 CFI generated table and save its register
     location information in the cache.  */
  {
    int column;		/* CFI speak for "register number".  */
    for (column = 0; column < fs->regs.num_regs; column++)
      {
	int regnum;
	
	/* Skip the return address column.  */
	if (column == fs->retaddr_column)
	  /* NOTE: cagney/2003-06-07: Is this right?  What if
	     RETADDR_COLUMN corresponds to a real register (and,
	     worse, that isn't the PC_REGNUM)?  I'm guessing that the
	     PC_REGNUM further down is trying to handle this.  That
	     can't be right though - PC_REGNUM may not be valid (it
	     can be -ve).  I think, instead when RETADDR_COLUM isn't a
	     real register, it should map itself onto frame_pc_unwind.  */
	  continue;
d554 2
a555 2
	/* Use the GDB register number as the destination index.  */
	regnum = DWARF2_REG_TO_REGNUM (column);
d557 3
a559 23
	/* If there's no corresponding GDB register, ignore it.  */
	if (regnum < 0 || regnum >= num_regs)
	  continue;

	/* NOTE: cagney/2003-09-05: CFI should specify the disposition
	   of all debug info registers.  If it doesn't complain (but
	   not too loudly).  It turns out that GCC, assumes that an
	   unspecified register implies "same value" when CFI (draft
	   7) specifies nothing at all.  Such a register could equally
	   be interpreted as "undefined".  Also note that this check
	   isn't sufficient - it only checks that all registers in the
	   range [0 .. max column] are specified - and won't detect
	   problems when a debug info register falls outside of the
	   table.  Need a way of iterating through all the valid
	   DWARF2 register numbers.  */
	if (fs->regs.reg[column].how == REG_UNSPECIFIED)
	  complaint (&symfile_complaints,
		     "Incomplete CFI data; unspecified registers at 0x%s",
		     paddr (fs->pc));

	cache->reg[regnum] = fs->regs.reg[column];
      }
  }
d565 1
a565 1
      && fs->regs.reg[fs->retaddr_column].how != REG_UNDEFINED)
d575 1
a575 1
      int reg = DWARF2_REG_TO_REGNUM (fs->retaddr_column);
d614 1
a614 3
    case REG_UNDEFINED:
      /* If CFI explicitly specified that the value isn't defined,
	 mark it as optimized away - the value isn't available.  */
a638 7
	  /* FIXME: cagney/2003-09-05: I think I understand.  GDB was
	     lumping the two states "unspecified" and "undefined"
	     together.  Here SP_REGNUM was "unspecified", GCC assuming
	     that in such a case CFA would be used.  This branch of
	     the if statement should be deleted - the problem of
	     SP_REGNUM is now handed by the case REG_UNSPECIFIED
	     below.  */
d690 1
a690 53
    case REG_UNSPECIFIED:
      /* GCC, in its infinite wisdom decided to not provide unwind
	 information for registers that are "same value".  Since
	 DWARF2 (3 draft 7) doesn't define such behavior, said
	 registers are actually undefined (which is different to CFI
	 "undefined").  Code above issues a complaint about this.
	 Here just fudge the books, assume GCC, and that the value is
	 more inner on the stack.  */
      if (SP_REGNUM >= 0 && regnum == SP_REGNUM)
	{
	  /* Can things get worse?  Yep!  One of the registers GCC
	     forgot to provide unwind information for was the stack
	     pointer.  Outch!  GCC appears to assumes that the CFA
	     address can be used - after all it points to the inner
	     most address of the previous frame before the function
	     call and that's always the same as the stack pointer on
	     return, right?  Wrong.  See GCC's i386 STDCALL option for
	     an ABI that has a different entry and return stack
	     pointer.  */
	  /* DWARF V3 Draft 7 p102: Typically, the CFA is defined to
	     be the value of the stack pointer at the call site in the
	     previous frame (which may be different from its value on
	     entry to the current frame).  */
	  /* DWARF V3 Draft 7 p103: The first column of the rules
             defines the rule which computes the CFA value; it may be
             either a register and a signed offset that are added
             together or a DWARF expression that is evaluated.  */
	  /* NOTE: cagney/2003-09-05: Should issue a complain.
             Unfortunatly it turns out that DWARF2 CFI has a problem.
             Since CFI specifies the location at which a register was
             saved (not its value) it isn't possible to specify
             something like "unwound(REG) == REG + constant" using CFI
             as will almost always occure with the stack pointer.  I
             guess CFI should be point SP at CFA.  Ref: danielj,
             "Describing unsaved stack pointers", posted to dwarf2
             list 2003-08-15.  */
	  *optimizedp = 0;
	  *lvalp = not_lval;
	  *addrp = 0;
	  *realnump = -1;
	  if (valuep)
	    /* Store the value.  */
	    store_typed_address (valuep, builtin_type_void_data_ptr,
				 cache->cfa);
	}
      else
	/* Assume that the register can be found in the next inner
           most frame.  */
	frame_register_unwind (next_frame, regnum,
			       optimizedp, lvalp, addrp, realnump, valuep);
      break;

    case REG_SAME_VALUE:
a782 2
const struct objfile_data *dwarf2_frame_data;

a932 2
  int ptr_len = size_of_encoded_value (DW_EH_PE_absptr);
  ptrdiff_t offset;
a940 2
  *bytes_read_ptr = 0;

a952 9
    case DW_EH_PE_aligned:
      base = 0;
      offset = buf - unit->dwarf_frame_buffer;
      if ((offset % ptr_len) != 0)
	{
	  *bytes_read_ptr = ptr_len - (offset % ptr_len);
	  buf += *bytes_read_ptr;
	}
      break;
d958 1
a958 1
    encoding |= encoding_for_size (ptr_len);
d963 1
a963 1
      *bytes_read_ptr += 2;
d966 1
a966 1
      *bytes_read_ptr += 4;
d969 1
a969 1
      *bytes_read_ptr += 8;
d972 1
a972 1
      *bytes_read_ptr += 2;
d975 1
a975 1
      *bytes_read_ptr += 4;
d978 1
a978 1
      *bytes_read_ptr += 8;
a1024 5
      fde = objfile_data (objfile, dwarf2_frame_data);
      if (fde == NULL)
	continue;

      gdb_assert (objfile->section_offsets);
d1026 2
a1027 1

d1047 2
a1048 2
  fde->next = objfile_data (unit->objfile, dwarf2_frame_data);
  set_objfile_data (unit->objfile, dwarf2_frame_data, fde);
a1442 9
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_dwarf2_frame (void);

void
_initialize_dwarf2_frame (void)
{
  dwarf2_frame_data = register_objfile_data ();
@


1.7.6.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a385 1
	      fs->regs.reg[reg].how = REG_SAVED_REG;
d773 1
a773 1
             Unfortunately it turns out that DWARF2 CFI has a problem.
a887 3

  /* Base for DW_EH_PE_textrel encodings.  */
  bfd_vma tbase;
a1065 3
    case DW_EH_PE_textrel:
      base = unit->tbase;
      break;
a1525 1
  unit.tbase = 0;
d1531 1
a1531 1
      asection *got, *txt;
d1543 3
a1545 3
	 that is used for the i386/amd64 target, which currently is
	 the only target in GCC that supports/uses the
	 DW_EH_PE_datarel encoding.  */
a1548 6

      /* GCC emits the DW_EH_PE_textrel encoding type on sh and ia64
         so far.  */
      txt = bfd_get_section_by_name (unit.abfd, ".text");
      if (txt)
	unit.tbase = txt->vma;
@


1.7.6.5
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d102 1
a102 1
  /* Make certain that 0 maps onto the correct enum value; the
d105 1
a105 1
     about a register, leaving how to obtain its value totally
d109 6
a114 5
     code is moddeling; it indicates that the register's value is
     "undefined".  GCC uses the less formal term "unsaved".  Its
     definition is a combination of REG_UNDEFINED and REG_UNSPECIFIED.
     The failure to differentiate the two helps explain a few problems
     with the CFI generated by GCC.  */
d503 1
a503 1
     instruction is probably worthless to us.  GCC's unwinder solves
d508 7
a514 4
     handlers, sentinel frames, dummy frames).  The function
     frame_unwind_address_in_block does just this.  It's not clear how
     reliable the method is though; there is the potential for the
     register state pre-call being different to that on return.  */
a557 1

a565 1

d576 3
a578 4
	     can't be right though; PC_REGNUM may not be valid (it can
	     be negative).  I think, instead when RETADDR_COLUM isn't
	     a real register, it should map itself onto
	     frame_pc_unwind.  */
d589 2
a590 2
	   of all debug info registers.  If it doesn't, complain (but
	   not too loudly).  It turns out that GCC assumes that an
d594 2
a595 2
	   isn't sufficient; it only checks that all registers in the
	   range [0 .. max column] are specified, and won't detect
d597 1
a597 1
	   table.  We need a way of iterating through all the valid
d609 2
a610 2
     column (adjusted) is not the same as GDB's PC_REGNUM, then this
     implies a copy from the return address column register.  */
d614 3
a616 3
      /* See comment above about a possibly negative PC_REGNUM.  If
         this assertion fails, it's a problem with this code and not
         the architecture.  */
d622 2
a623 1
      if (DWARF2_REG_TO_REGNUM (fs->retaddr_column) != PC_REGNUM)
d625 3
a627 3
	  /* See comment above about PC_REGNUM being negative.  If
	     this assertion fails, it's a problem with this code and
	     not the architecture.  */
d629 1
a629 1
	  cache->reg[PC_REGNUM].loc.reg = fs->retaddr_column;
d663 1
a663 1
	 mark it as optimized away; the value isn't available.  */
d684 2
a685 2
             reverse.  Assuming that SP_REGNUM isn't negative, there
             is a very real posibility that CFA is an offset from some
d773 1
a773 1
	  /* NOTE: cagney/2003-09-05: Should issue a complaint.
d1511 2
d1514 2
d1519 2
a1520 1
extern char *dwarf2_read_section (struct objfile *objfile, asection *sectp);
d1537 1
a1537 1
  if (dwarf_eh_frame_section)
d1543 2
d1547 1
a1547 2
      unit.dwarf_frame_size
	= bfd_get_section_size_before_reloc (dwarf_eh_frame_section);
d1569 1
a1569 1
  if (dwarf_frame_section)
d1573 2
d1576 1
a1576 2
      unit.dwarf_frame_size
	= bfd_get_section_size_before_reloc (dwarf_frame_section);
@


1.7.6.6
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@a107 1

d118 1
a118 6
  REG_SAME_VALUE,

  /* These aren't defined by the DWARF2 CFI specification, but are
     used internally by GDB.  */
  REG_RA,			/* Return Address.  */
  REG_CFA			/* Call Frame Address.  */
a428 3
	    case DW_CFA_nop:
	      break;

d446 1
a446 20
	    case DW_CFA_offset_extended_sf:
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
	      insn_ptr = read_sleb128 (insn_ptr, insn_end, &offset);
	      offset += fs->data_align;
	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
	      fs->regs.reg[reg].how = REG_SAVED_OFFSET;
	      fs->regs.reg[reg].loc.offset = offset;
	      break;

	    case DW_CFA_def_cfa_sf:
	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &fs->cfa_reg);
	      insn_ptr = read_sleb128 (insn_ptr, insn_end, &offset);
	      fs->cfa_offset = offset * fs->data_align;
	      fs->cfa_how = CFA_REG_OFFSET;
	      break;

	    case DW_CFA_def_cfa_offset_sf:
	      insn_ptr = read_sleb128 (insn_ptr, insn_end, &offset);
	      fs->cfa_offset = offset * fs->data_align;
	      /* cfa_how deliberately not set.  */
d550 2
a551 25
  /* Initialize the register rules.  If we have a register that acts
     as a program counter, mark it as a destination for the return
     address.  If we have a register that serves as the stack pointer,
     arrange for it to be filled with the call frame address (CFA).
     The other registers are marked as unspecified.

     We copy the return address to the program counter, since many
     parts in GDB assume that it is possible to get the return address
     by unwind the program counter register.  However, on ISA's with a
     dedicated return address register, the CFI usually only contains
     information to unwind that return address register.

     The reason we're treating the stack pointer special here is
     because in many cases GCC doesn't emit CFI for the stack pointer
     and implicitly assumes that it is equal to the CFA.  This makes
     some sense since the DWARF specification (version 3, draft 8,
     p. 102) says that:

     "Typically, the CFA is defined to be the value of the stack
     pointer at the call site in the previous frame (which may be
     different from its value on entry to the current frame)."

     However, this isn't true for all platforms supported by GCC
     (e.g. IBM S/390 and zSeries).  For those targets we should
     override the defaults given here.  */
d556 1
a556 8
      {
	if (regnum == PC_REGNUM)
	  cache->reg[regnum].how = REG_RA;
	else if (regnum == SP_REGNUM)
	  cache->reg[regnum].how = REG_CFA;
	else
	  cache->reg[regnum].how = REG_UNSPECIFIED;
      }
d560 1
a560 6
     location information in the cache.  Note that we don't skip the
     return address column; it's perfectly all right for it to
     correspond to a real register.  If it doesn't correspond to a
     real register, or if we shouldn't treat it as such,
     DWARF2_REG_TO_REGNUM should be defined to return a number outside
     the range [0, NUM_REGS).  */
d566 14
d581 1
a581 1
	int regnum = DWARF2_REG_TO_REGNUM (column);
d602 2
a603 2
	else
	  cache->reg[regnum] = fs->regs.reg[column];
d607 24
a630 22
  /* Eliminate any REG_RA rules.  */
  {
    int regnum;

    for (regnum = 0; regnum < num_regs; regnum++)
      {
	if (cache->reg[regnum].how == REG_RA)
	  {
	    if (fs->retaddr_column < fs->regs.num_regs)
	      cache->reg[regnum] = fs->regs.reg[fs->retaddr_column];
	    else
	      {
		/* It turns out that GCC assumes that if the return
                   address column is "empty" the return address can be
                   found in the register corresponding to the return
                   address column.  */
		cache->reg[regnum].loc.reg = fs->retaddr_column;
		cache->reg[regnum].how = REG_SAVED_REG;
	      }
	  }
      }
  }
d666 36
a701 1
      if (valuep)
d752 42
a793 2
      frame_register_unwind (next_frame, regnum,
			     optimizedp, lvalp, addrp, realnump, valuep);
a798 12
      break;

    case REG_CFA:
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  /* Store the value.  */
	  store_typed_address (valuep, builtin_type_void_data_ptr, cache->cfa);
	}
@


1.6
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* dwarf2-frame.c (dwarf2_frame_cache): Add comments on PC_REGNUM.
	Assert that PC_REGNUM is valid.
	(dwarf2_frame_prev_register): Add comments on SP_REGNUM.
@
text
@d458 1
a458 1
struct dwarf2_frame_cache *
@


1.5
log
@* dwarf2-frame.c (struct comp_unit): Add member `dbase'.
(read_encoded_value): Handle DW_EH_PE_datarel encoding.
(dwarf2_build_frame_info): Set base for DW_EH_PE_datarel encodings
when handling .eh_frame sections.
@
text
@d547 7
d568 7
a574 1
    cache->reg[PC_REGNUM] = fs->regs.reg[fs->retaddr_column];
d580 4
d626 15
@


1.4
log
@        * dwarf2-frame.c (struct dwarf2_cie): Add saw_z_augmentation.
        (decode_frame_entry): Set it.  Skip FDE augmentation.
@
text
@d750 3
d922 3
d1260 1
d1266 2
d1276 8
@


1.3
log
@        * dwarf2-frame.c (dwarf2_frame_cache): Handle retaddr_column
        not overlapping PC_REGNUM.
@
text
@d68 3
d1117 2
a1118 1
      if (*augmentation == 'z')
d1206 12
@


1.2
log
@From Richard Henderson  <rth@@redhat.com>:
* dwarf2-frame.c (dwarf2_frame_state_alloc_regs): Fix ptr arithmetic.
@
text
@d553 5
a557 2
  /* Stored the location of the return addess.  */
  if (fs->retaddr_column < fs->regs.num_regs)
d559 9
@


1.1
log
@* dwarf2-frame.c, dwarf2-frame.h: New files.
* Makefile.in (SFILES): Add dwarf2-frame.c.
(dwarf2_frame_h): Define.
(COMMON_OBS): Add dwarf2-frame.o.
(dwarf2-frame.o): Add dependencies.
@
text
@d166 1
a166 1
  memset (rs->reg + rs->num_regs * size, 0, (num_regs - rs->num_regs) * size);
@

