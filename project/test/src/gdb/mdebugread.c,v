head	1.143;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.139
	gdb_7_6-2013-04-26-release:1.139
	gdb_7_6-branch:1.139.0.2
	gdb_7_6-2013-03-12-branchpoint:1.139
	gdb_7_5_1-2012-11-29-release:1.131
	gdb_7_5-2012-08-17-release:1.131
	gdb_7_5-branch:1.131.0.2
	gdb_7_5-2012-07-18-branchpoint:1.131
	gdb_7_4_1-2012-04-26-release:1.126.2.1
	gdb_7_4-2012-01-24-release:1.126.2.1
	gdb_7_4-branch:1.126.0.2
	gdb_7_4-2011-12-13-branchpoint:1.126
	gdb_7_3_1-2011-09-04-release:1.122
	gdb_7_3-2011-07-26-release:1.122
	gdb_7_3-branch:1.122.0.2
	gdb_7_3-2011-04-01-branchpoint:1.122
	gdb_7_2-2010-09-02-release:1.113
	gdb_7_2-branch:1.113.0.2
	gdb_7_2-2010-07-07-branchpoint:1.113
	gdb_7_1-2010-03-18-release:1.108
	gdb_7_1-branch:1.108.0.2
	gdb_7_1-2010-02-18-branchpoint:1.108
	gdb_7_0_1-2009-12-22-release:1.103
	gdb_7_0-2009-10-06-release:1.103
	gdb_7_0-branch:1.103.0.4
	gdb_7_0-2009-09-16-branchpoint:1.103
	arc-sim-20090309:1.88
	msnyder-checkpoint-072509-branch:1.103.0.2
	msnyder-checkpoint-072509-branchpoint:1.103
	arc-insight_6_8-branch:1.88.0.6
	arc-insight_6_8-branchpoint:1.88
	insight_6_8-branch:1.88.0.4
	insight_6_8-branchpoint:1.88
	reverse-20081226-branch:1.96.0.4
	reverse-20081226-branchpoint:1.96
	multiprocess-20081120-branch:1.96.0.2
	multiprocess-20081120-branchpoint:1.96
	reverse-20080930-branch:1.94.0.2
	reverse-20080930-branchpoint:1.94
	reverse-20080717-branch:1.92.0.4
	reverse-20080717-branchpoint:1.92
	msnyder-reverse-20080609-branch:1.92.0.2
	msnyder-reverse-20080609-branchpoint:1.92
	drow-reverse-20070409-branch:1.79.0.2
	drow-reverse-20070409-branchpoint:1.79
	gdb_6_8-2008-03-27-release:1.88
	gdb_6_8-branch:1.88.0.2
	gdb_6_8-2008-02-26-branchpoint:1.88
	gdb_6_7_1-2007-10-29-release:1.84
	gdb_6_7-2007-10-10-release:1.84
	gdb_6_7-branch:1.84.0.2
	gdb_6_7-2007-09-07-branchpoint:1.84
	insight_6_6-20070208-release:1.78
	gdb_6_6-2006-12-18-release:1.78
	gdb_6_6-branch:1.78.0.18
	gdb_6_6-2006-11-15-branchpoint:1.78
	insight_6_5-20061003-release:1.78
	gdb-csl-symbian-6_4_50_20060226-12:1.78
	gdb-csl-sourcerygxx-3_4_4-25:1.77
	nickrob-async-20060828-mergepoint:1.78
	gdb-csl-symbian-6_4_50_20060226-11:1.78
	gdb-csl-sourcerygxx-4_1-17:1.78
	gdb-csl-20060226-branch-local-2:1.78
	gdb-csl-sourcerygxx-4_1-14:1.78
	gdb-csl-sourcerygxx-4_1-13:1.78
	gdb-csl-sourcerygxx-4_1-12:1.78
	gdb-csl-sourcerygxx-3_4_4-21:1.78
	gdb_6_5-20060621-release:1.78
	gdb-csl-sourcerygxx-4_1-9:1.78
	gdb-csl-sourcerygxx-4_1-8:1.78
	gdb-csl-sourcerygxx-4_1-7:1.78
	gdb-csl-arm-2006q1-6:1.78
	gdb-csl-sourcerygxx-4_1-6:1.78
	gdb-csl-symbian-6_4_50_20060226-10:1.78
	gdb-csl-symbian-6_4_50_20060226-9:1.78
	gdb-csl-symbian-6_4_50_20060226-8:1.78
	gdb-csl-coldfire-4_1-11:1.78
	gdb-csl-sourcerygxx-3_4_4-19:1.78
	gdb-csl-coldfire-4_1-10:1.78
	gdb_6_5-branch:1.78.0.16
	gdb_6_5-2006-05-14-branchpoint:1.78
	gdb-csl-sourcerygxx-4_1-5:1.78
	nickrob-async-20060513-branch:1.78.0.14
	nickrob-async-20060513-branchpoint:1.78
	gdb-csl-sourcerygxx-4_1-4:1.78
	msnyder-reverse-20060502-branch:1.78.0.12
	msnyder-reverse-20060502-branchpoint:1.78
	gdb-csl-morpho-4_1-4:1.78
	gdb-csl-sourcerygxx-3_4_4-17:1.78
	readline_5_1-import-branch:1.78.0.10
	readline_5_1-import-branchpoint:1.78
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.78
	gdb-csl-symbian-20060226-branch:1.78.0.8
	gdb-csl-symbian-20060226-branchpoint:1.78
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.78
	msnyder-reverse-20060331-branch:1.78.0.6
	msnyder-reverse-20060331-branchpoint:1.78
	gdb-csl-available-20060303-branch:1.78.0.4
	gdb-csl-available-20060303-branchpoint:1.78
	gdb-csl-20060226-branch:1.78.0.2
	gdb-csl-20060226-branchpoint:1.78
	gdb_6_4-20051202-release:1.77
	msnyder-fork-checkpoint-branch:1.77.0.10
	msnyder-fork-checkpoint-branchpoint:1.77
	gdb-csl-gxxpro-6_3-branch:1.77.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.77
	gdb_6_4-branch:1.77.0.6
	gdb_6_4-2005-11-01-branchpoint:1.77
	gdb-csl-arm-20051020-branch:1.77.0.4
	gdb-csl-arm-20051020-branchpoint:1.77
	msnyder-tracepoint-checkpoint-branch:1.77.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.77
	gdb-csl-arm-20050325-2005-q1b:1.76
	gdb-csl-arm-20050325-2005-q1a:1.76
	csl-arm-20050325-branch:1.76.0.2
	csl-arm-20050325-branchpoint:1.76
	gdb-post-i18n-errorwarning-20050211:1.74
	gdb-pre-i18n-errorwarning-20050211:1.73
	gdb_6_3-20041109-release:1.64
	gdb_6_3-branch:1.64.0.2
	gdb_6_3-20041019-branchpoint:1.64
	drow_intercu-merge-20040921:1.64
	drow_intercu-merge-20040915:1.64
	jimb-gdb_6_2-e500-branch:1.62.0.6
	jimb-gdb_6_2-e500-branchpoint:1.62
	gdb_6_2-20040730-release:1.62
	gdb_6_2-branch:1.62.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.62
	gdb_6_1_1-20040616-release:1.60
	gdb_6_1-2004-04-05-release:1.60
	drow_intercu-merge-20040402:1.60
	drow_intercu-merge-20040327:1.60
	ezannoni_pie-20040323-branch:1.60.0.8
	ezannoni_pie-20040323-branchpoint:1.60
	cagney_tramp-20040321-mergepoint:1.60
	cagney_tramp-20040309-branch:1.60.0.6
	cagney_tramp-20040309-branchpoint:1.60
	gdb_6_1-branch:1.60.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.60
	drow_intercu-20040221-branch:1.60.0.2
	drow_intercu-20040221-branchpoint:1.60
	cagney_bfdfile-20040213-branch:1.59.0.2
	cagney_bfdfile-20040213-branchpoint:1.59
	drow-cplus-merge-20040208:1.59
	carlton_dictionary-20040126-merge:1.56
	cagney_bigcore-20040122-branch:1.56.0.2
	cagney_bigcore-20040122-branchpoint:1.56
	drow-cplus-merge-20040113:1.54
	drow-cplus-merge-20031224:1.54
	drow-cplus-merge-20031220:1.54
	carlton_dictionary-20031215-merge:1.54
	drow-cplus-merge-20031214:1.54
	carlton-dictionary-20031111-merge:1.53
	gdb_6_0-2003-10-04-release:1.47
	kettenis_sparc-20030918-branch:1.51.0.4
	kettenis_sparc-20030918-branchpoint:1.51
	carlton_dictionary-20030917-merge:1.51
	ezannoni_pie-20030916-branchpoint:1.51
	ezannoni_pie-20030916-branch:1.51.0.2
	cagney_x86i386-20030821-branch:1.47.0.6
	cagney_x86i386-20030821-branchpoint:1.47
	carlton_dictionary-20030805-merge:1.47
	carlton_dictionary-20030627-merge:1.47
	gdb_6_0-branch:1.47.0.4
	gdb_6_0-2003-06-23-branchpoint:1.47
	jimb-ppc64-linux-20030613-branch:1.47.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.47
	cagney_convert-20030606-branch:1.45.0.6
	cagney_convert-20030606-branchpoint:1.45
	cagney_writestrings-20030508-branch:1.44.0.12
	cagney_writestrings-20030508-branchpoint:1.44
	jimb-ppc64-linux-20030528-branch:1.45.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.45
	carlton_dictionary-20030523-merge:1.45
	cagney_fileio-20030521-branch:1.45.0.2
	cagney_fileio-20030521-branchpoint:1.45
	kettenis_i386newframe-20030517-mergepoint:1.45
	jimb-ppc64-linux-20030509-branch:1.44.0.10
	jimb-ppc64-linux-20030509-branchpoint:1.44
	kettenis_i386newframe-20030504-mergepoint:1.44
	carlton_dictionary-20030430-merge:1.44
	kettenis_i386newframe-20030419-branch:1.44.0.8
	kettenis_i386newframe-20030419-branchpoint:1.44
	carlton_dictionary-20030416-merge:1.44
	cagney_frameaddr-20030409-mergepoint:1.44
	kettenis_i386newframe-20030406-branch:1.44.0.6
	kettenis_i386newframe-20030406-branchpoint:1.44
	cagney_frameaddr-20030403-branchpoint:1.44
	cagney_frameaddr-20030403-branch:1.44.0.4
	cagney_framebase-20030330-mergepoint:1.44
	cagney_framebase-20030326-branch:1.44.0.2
	cagney_framebase-20030326-branchpoint:1.44
	cagney_lazyid-20030317-branch:1.43.0.8
	cagney_lazyid-20030317-branchpoint:1.43
	kettenis-i386newframe-20030316-mergepoint:1.43
	offbyone-20030313-branch:1.43.0.6
	offbyone-20030313-branchpoint:1.43
	kettenis-i386newframe-20030308-branch:1.43.0.4
	kettenis-i386newframe-20030308-branchpoint:1.43
	carlton_dictionary-20030305-merge:1.43
	cagney_offbyone-20030303-branch:1.43.0.2
	cagney_offbyone-20030303-branchpoint:1.43
	carlton_dictionary-20030207-merge:1.40
	interps-20030203-mergepoint:1.39
	interps-20030202-branch:1.39.0.2
	interps-20030202-branchpoint:1.39
	cagney-unwind-20030108-branch:1.37.0.2
	cagney-unwind-20030108-branchpoint:1.37
	carlton_dictionary-20021223-merge:1.32
	gdb_5_3-2002-12-12-release:1.28.6.1
	carlton_dictionary-20021115-merge:1.31
	kseitz_interps-20021105-merge:1.30
	kseitz_interps-20021103-merge:1.30
	drow-cplus-merge-20021020:1.29
	drow-cplus-merge-20021025:1.29
	carlton_dictionary-20021025-merge:1.29
	carlton_dictionary-20021011-merge:1.29
	drow-cplus-branch:1.29.0.4
	drow-cplus-branchpoint:1.29
	kseitz_interps-20020930-merge:1.29
	carlton_dictionary-20020927-merge:1.29
	carlton_dictionary-branch:1.29.0.2
	carlton_dictionary-20020920-branchpoint:1.29
	gdb_5_3-branch:1.28.0.6
	gdb_5_3-2002-09-04-branchpoint:1.28
	kseitz_interps-20020829-merge:1.28
	cagney_sysregs-20020825-branch:1.28.0.4
	cagney_sysregs-20020825-branchpoint:1.28
	readline_4_3-import-branch:1.28.0.2
	readline_4_3-import-branchpoint:1.28
	gdb_5_2_1-2002-07-23-release:1.23.2.2
	kseitz_interps-20020528-branch:1.26.0.4
	kseitz_interps-20020528-branchpoint:1.26
	cagney_regbuf-20020515-branch:1.26.0.2
	cagney_regbuf-20020515-branchpoint:1.26
	jimb-macro-020506-branch:1.25.0.2
	jimb-macro-020506-branchpoint:1.25
	gdb_5_2-2002-04-29-release:1.23.2.1
	gdb_5_2-branch:1.23.0.2
	gdb_5_2-2002-03-03-branchpoint:1.23
	gdb_5_1_1-2002-01-24-release:1.13
	gdb_5_1_0_1-2002-01-03-release:1.13
	cygnus_cvs_20020108_pre:1.20
	gdb_5_1_0_1-2002-01-03-branchpoint:1.13
	gdb_5_1_0_1-2002-01-03-branch:1.13.0.8
	gdb_5_1-2001-11-21-release:1.13
	gdb_s390-2001-09-26-branch:1.13.0.6
	gdb_s390-2001-09-26-branchpoint:1.13
	gdb_5_1-2001-07-29-branch:1.13.0.4
	gdb_5_1-2001-07-29-branchpoint:1.13
	dberlin-typesystem-branch:1.13.0.2
	dberlin-typesystem-branchpoint:1.13
	gdb-post-ptid_t-2001-05-03:1.12
	gdb-pre-ptid_t-2001-05-03:1.12
	insight-precleanup-2001-01-01:1.9
	gdb-post-protoization-2000-07-29:1.6
	gdb-pre-protoization-2000-07-29:1.5
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb-post-params-removal-2000-06-04:1.5
	gdb-pre-params-removal-2000-06-04:1.4
	gdb-post-params-removal-2000-05-28:1.4
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.1.1.5.2.1
	gdb_4_18_2-2000-05-18-release:1.1.1.5.2.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.5
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.5
	gdb_5_0-2000-04-10-branch:1.1.1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.5
	repo-unification-2000-02-06:1.1.1.5
	insight-2000-02-04:1.1.1.5
	gdb-2000-02-04:1.1.1.5
	gdb-2000-02-02:1.1.1.5
	gdb-2000-02-01:1.1.1.5
	gdb-2000-01-31:1.1.1.5
	gdb-2000-01-26:1.1.1.5
	gdb-2000-01-24:1.1.1.5
	gdb-2000-01-17:1.1.1.5
	gdb-2000-01-10:1.1.1.5
	gdb-2000-01-05:1.1.1.5
	gdb-1999-12-21:1.1.1.5
	gdb-1999-12-13:1.1.1.5
	gdb-1999-12-07:1.1.1.5
	gdb-1999-12-06:1.1.1.5
	gdb-1999-11-16:1.1.1.5
	gdb-1999-11-08:1.1.1.5
	gdb-1999-11-01:1.1.1.5
	gdb-1999-10-25:1.1.1.5
	gdb-1999-10-18:1.1.1.5
	gdb-1999-10-11:1.1.1.5
	gdb-1999-10-04:1.1.1.5
	gdb-1999-09-28:1.1.1.5
	gdb-1999-09-21:1.1.1.5
	gdb-1999-09-13:1.1.1.5
	gdb-1999-09-08:1.1.1.5
	gdb-1999-08-30:1.1.1.4
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.143
date	2013.04.08.20.13.21;	author tromey;	state Exp;
branches;
next	1.142;

1.142
date	2013.04.08.19.56.03;	author tromey;	state Exp;
branches;
next	1.141;

1.141
date	2013.04.08.19.48.30;	author tromey;	state Exp;
branches;
next	1.140;

1.140
date	2013.03.20.18.33.05;	author tromey;	state Exp;
branches;
next	1.139;

1.139
date	2013.02.03.16.13.29;	author jkratoch;	state Exp;
branches;
next	1.138;

1.138
date	2013.01.21.18.13.13;	author tromey;	state Exp;
branches;
next	1.137;

1.137
date	2013.01.21.18.05.13;	author tromey;	state Exp;
branches;
next	1.136;

1.136
date	2013.01.18.03.09.42;	author qiyao;	state Exp;
branches;
next	1.135;

1.135
date	2013.01.14.10.39.33;	author qiyao;	state Exp;
branches;
next	1.134;

1.134
date	2013.01.01.06.32.47;	author brobecke;	state Exp;
branches;
next	1.133;

1.133
date	2012.12.12.17.03.03;	author tromey;	state Exp;
branches;
next	1.132;

1.132
date	2012.12.12.16.22.33;	author tromey;	state Exp;
branches;
next	1.131;

1.131
date	2012.05.10.19.50.08;	author tromey;	state Exp;
branches;
next	1.130;

1.130
date	2012.04.18.06.46.46;	author jkratoch;	state Exp;
branches;
next	1.129;

1.129
date	2012.02.07.04.48.21;	author devans;	state Exp;
branches;
next	1.128;

1.128
date	2012.01.19.12.51.04;	author gary;	state Exp;
branches;
next	1.127;

1.127
date	2012.01.04.08.17.06;	author brobecke;	state Exp;
branches;
next	1.126;

1.126
date	2011.11.10.20.21.28;	author devans;	state Exp;
branches
	1.126.2.1;
next	1.125;

1.125
date	2011.06.14.18.53.14;	author tromey;	state Exp;
branches;
next	1.124;

1.124
date	2011.06.14.16.49.41;	author tromey;	state Exp;
branches;
next	1.123;

1.123
date	2011.04.04.15.11.19;	author tromey;	state Exp;
branches;
next	1.122;

1.122
date	2011.03.23.18.23.54;	author ktietz;	state Exp;
branches;
next	1.121;

1.121
date	2011.03.05.22.02.47;	author msnyder;	state Exp;
branches;
next	1.120;

1.120
date	2011.03.02.23.54.16;	author msnyder;	state Exp;
branches;
next	1.119;

1.119
date	2011.02.26.02.07.08;	author msnyder;	state Exp;
branches;
next	1.118;

1.118
date	2011.01.09.03.20.33;	author msnyder;	state Exp;
branches;
next	1.117;

1.117
date	2011.01.05.22.22.49;	author msnyder;	state Exp;
branches;
next	1.116;

1.116
date	2011.01.01.15.33.10;	author brobecke;	state Exp;
branches;
next	1.115;

1.115
date	2010.10.01.20.26.11;	author tromey;	state Exp;
branches;
next	1.114;

1.114
date	2010.08.09.19.42.48;	author swagiaal;	state Exp;
branches;
next	1.113;

1.113
date	2010.05.16.00.18.02;	author msnyder;	state Exp;
branches;
next	1.112;

1.112
date	2010.05.08.04.58.45;	author jkratoch;	state Exp;
branches;
next	1.111;

1.111
date	2010.05.07.00.47.36;	author msnyder;	state Exp;
branches;
next	1.110;

1.110
date	2010.03.10.18.27.00;	author tromey;	state Exp;
branches;
next	1.109;

1.109
date	2010.03.10.18.20.06;	author tromey;	state Exp;
branches;
next	1.108;

1.108
date	2010.01.12.05.48.56;	author brobecke;	state Exp;
branches;
next	1.107;

1.107
date	2010.01.01.07.31.37;	author brobecke;	state Exp;
branches;
next	1.106;

1.106
date	2009.12.14.06.19.13;	author hilfingr;	state Exp;
branches;
next	1.105;

1.105
date	2009.11.16.18.40.22;	author tromey;	state Exp;
branches;
next	1.104;

1.104
date	2009.11.05.19.53.03;	author tromey;	state Exp;
branches;
next	1.103;

1.103
date	2009.06.29.13.18.37;	author uweigand;	state Exp;
branches;
next	1.102;

1.102
date	2009.06.17.18.41.50;	author uweigand;	state Exp;
branches;
next	1.101;

1.101
date	2009.06.04.12.28.39;	author uweigand;	state Exp;
branches;
next	1.100;

1.100
date	2009.06.03.18.08.14;	author uweigand;	state Exp;
branches;
next	1.99;

1.99
date	2009.01.13.11.52.43;	author brobecke;	state Exp;
branches;
next	1.98;

1.98
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.97;

1.97
date	2008.12.28.14.14.19;	author jkratoch;	state Exp;
branches;
next	1.96;

1.96
date	2008.10.08.12.49.12;	author jkratoch;	state Exp;
branches;
next	1.95;

1.95
date	2008.10.01.16.41.27;	author tromey;	state Exp;
branches;
next	1.94;

1.94
date	2008.08.24.16.39.57;	author tromey;	state Exp;
branches;
next	1.93;

1.93
date	2008.08.21.18.14.39;	author drow;	state Exp;
branches;
next	1.92;

1.92
date	2008.05.27.20.24.51;	author brobecke;	state Exp;
branches;
next	1.91;

1.91
date	2008.05.27.19.29.51;	author schwab;	state Exp;
branches;
next	1.90;

1.90
date	2008.05.19.15.50.09;	author uweigand;	state Exp;
branches;
next	1.89;

1.89
date	2008.03.26.14.53.28;	author uweigand;	state Exp;
branches;
next	1.88;

1.88
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.87;

1.87
date	2007.10.19.12.26.34;	author uweigand;	state Exp;
branches;
next	1.86;

1.86
date	2007.10.19.12.23.20;	author uweigand;	state Exp;
branches;
next	1.85;

1.85
date	2007.10.12.16.13.20;	author uweigand;	state Exp;
branches;
next	1.84;

1.84
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches;
next	1.83;

1.83
date	2007.06.22.12.26.59;	author uweigand;	state Exp;
branches;
next	1.82;

1.82
date	2007.06.12.16.59.43;	author uweigand;	state Exp;
branches;
next	1.81;

1.81
date	2007.06.12.16.33.20;	author uweigand;	state Exp;
branches;
next	1.80;

1.80
date	2007.06.12.15.33.04;	author uweigand;	state Exp;
branches;
next	1.79;

1.79
date	2007.01.09.17.58.52;	author drow;	state Exp;
branches;
next	1.78;

1.78
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.77;

1.77
date	2005.05.23.03.28.37;	author brobecke;	state Exp;
branches;
next	1.76;

1.76
date	2005.02.12.00.39.20;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2005.02.11.18.13.51;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2005.02.11.04.05.57;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2005.02.06.16.22.14;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2005.01.14.00.59.31;	author msnyder;	state Exp;
branches;
next	1.71;

1.71
date	2004.10.31.17.57.43;	author cagney;	state Exp;
branches;
next	1.70;

1.70
date	2004.10.31.17.48.17;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2004.10.31.16.31.50;	author cagney;	state Exp;
branches;
next	1.68;

1.68
date	2004.10.31.04.33.13;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2004.10.31.03.42.52;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2004.10.31.02.59.21;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2004.10.23.16.18.09;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2004.09.11.10.24.49;	author hilfingr;	state Exp;
branches;
next	1.63;

1.63
date	2004.09.07.21.55.11;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2004.05.07.14.29.33;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2004.05.01.00.34.54;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2004.02.14.15.46.33;	author ezannoni;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2004.02.07.23.13.47;	author ezannoni;	state Exp;
branches;
next	1.58;

1.58
date	2004.02.07.18.29.53;	author ezannoni;	state Exp;
branches;
next	1.57;

1.57
date	2004.02.07.16.57.55;	author ezannoni;	state Exp;
branches;
next	1.56;

1.56
date	2004.01.18.03.42.28;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2004.01.18.01.22.57;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2003.11.23.20.41.17;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2003.11.08.00.13.02;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2003.10.06.19.27.12;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2003.09.16.18.56.35;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2003.09.14.16.32.13;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2003.09.12.18.40.17;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2003.09.11.23.43.56;	author carlton;	state Exp;
branches;
next	1.47;

1.47
date	2003.06.11.23.29.47;	author carlton;	state Exp;
branches;
next	1.46;

1.46
date	2003.06.11.22.27.12;	author carlton;	state Exp;
branches;
next	1.45;

1.45
date	2003.05.14.17.43.18;	author ezannoni;	state Exp;
branches;
next	1.44;

1.44
date	2003.03.19.19.45.49;	author kevinb;	state Exp;
branches
	1.44.8.1;
next	1.43;

1.43
date	2003.02.25.21.36.18;	author carlton;	state Exp;
branches;
next	1.42;

1.42
date	2003.02.20.18.31.14;	author drow;	state Exp;
branches;
next	1.41;

1.41
date	2003.02.20.00.01.05;	author carlton;	state Exp;
branches;
next	1.40;

1.40
date	2003.02.04.18.07.01;	author drow;	state Exp;
branches;
next	1.39;

1.39
date	2003.01.18.15.55.52;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2003.01.14.00.15.05;	author ezannoni;	state Exp;
branches;
next	1.37;

1.37
date	2003.01.07.07.09.24;	author brobecke;	state Exp;
branches;
next	1.36;

1.36
date	2003.01.04.22.37.47;	author drow;	state Exp;
branches;
next	1.35;

1.35
date	2003.01.03.15.34.59;	author brobecke;	state Exp;
branches;
next	1.34;

1.34
date	2003.01.03.15.29.29;	author brobecke;	state Exp;
branches;
next	1.33;

1.33
date	2003.01.03.14.01.46;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2002.12.17.00.39.07;	author kevinb;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.11.00.55.34;	author drow;	state Exp;
branches;
next	1.30;

1.30
date	2002.10.25.22.25.55;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.18.20.47.39;	author jimb;	state Exp;
branches
	1.29.2.1
	1.29.4.1;
next	1.28;

1.28
date	2002.07.29.22.55.26;	author cagney;	state Exp;
branches
	1.28.6.1;
next	1.27;

1.27
date	2002.07.11.20.46.19;	author drow;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.13.14.00.36;	author drow;	state Exp;
branches
	1.26.4.1;
next	1.25;

1.25
date	2002.04.22.10.19.35;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.19.19.00.03;	author aoliva;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.24.04.08.33;	author fnf;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2002.01.20.19.42.04;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.20.19.12.23;	author drow;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.09.21.45.26;	author fnf;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.06.23.38.14;	author fnf;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.06.22.31.00;	author ezannoni;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.24.17.10.18;	author jimb;	state Exp;
branches;
next	1.16;

1.16
date	2001.10.12.23.51.28;	author drow;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.05.02.54.15;	author ezannoni;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.05.02.02.44;	author ezannoni;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.29.10.45.10;	author aoliva;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.03.07.02.57.08;	author jtc;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.06.08.21.10;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.15.01.01.48;	author kevinb;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.04.04.01.15;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.24.04.42.12;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.28.01.12.28;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.15.01.44.40;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.04.16.52.33;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.126.2.1
date	2012.01.06.04.43.20;	author brobecke;	state Exp;
branches;
next	;

1.60.2.1
date	2004.09.16.17.01.13;	author drow;	state Exp;
branches;
next	;

1.44.8.1
date	2003.05.18.09.44.16;	author kettenis;	state Exp;
branches;
next	;

1.29.2.1
date	2002.09.20.18.52.16;	author carlton;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2002.09.20.23.55.03;	author carlton;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2002.09.24.00.04.50;	author carlton;	state Exp;
branches;
next	1.29.2.4;

1.29.2.4
date	2002.09.25.00.19.27;	author carlton;	state Exp;
branches;
next	1.29.2.5;

1.29.2.5
date	2002.10.18.23.42.58;	author carlton;	state Exp;
branches;
next	1.29.2.6;

1.29.2.6
date	2002.11.15.19.18.50;	author carlton;	state Exp;
branches;
next	1.29.2.7;

1.29.2.7
date	2002.12.21.00.17.43;	author carlton;	state Exp;
branches;
next	1.29.2.8;

1.29.2.8
date	2002.12.23.19.38.34;	author carlton;	state Exp;
branches;
next	1.29.2.9;

1.29.2.9
date	2003.02.07.19.17.50;	author carlton;	state Exp;
branches;
next	1.29.2.10;

1.29.2.10
date	2003.02.20.23.54.59;	author carlton;	state Exp;
branches;
next	1.29.2.11;

1.29.2.11
date	2003.03.06.00.56.30;	author carlton;	state Exp;
branches;
next	1.29.2.12;

1.29.2.12
date	2003.04.16.19.56.53;	author carlton;	state Exp;
branches;
next	1.29.2.13;

1.29.2.13
date	2003.04.18.18.10.48;	author carlton;	state Exp;
branches;
next	1.29.2.14;

1.29.2.14
date	2003.05.23.18.40.42;	author carlton;	state Exp;
branches;
next	1.29.2.15;

1.29.2.15
date	2003.06.27.21.50.05;	author carlton;	state Exp;
branches;
next	1.29.2.16;

1.29.2.16
date	2003.09.17.21.28.25;	author carlton;	state Exp;
branches;
next	1.29.2.17;

1.29.2.17
date	2003.11.11.23.50.49;	author carlton;	state Exp;
branches;
next	1.29.2.18;

1.29.2.18
date	2003.12.16.00.00.41;	author carlton;	state Exp;
branches;
next	1.29.2.19;

1.29.2.19
date	2004.01.26.19.11.27;	author carlton;	state Exp;
branches;
next	;

1.29.4.1
date	2003.12.14.20.27.21;	author drow;	state Exp;
branches;
next	1.29.4.2;

1.29.4.2
date	2004.02.09.19.43.43;	author drow;	state Exp;
branches;
next	;

1.28.6.1
date	2002.09.25.03.52.31;	author jimb;	state Exp;
branches;
next	;

1.26.4.1
date	2002.07.22.21.47.00;	author kseitz;	state Exp;
branches;
next	1.26.4.2;

1.26.4.2
date	2002.08.09.18.34.25;	author kseitz;	state Exp;
branches;
next	1.26.4.3;

1.26.4.3
date	2002.10.01.00.46.10;	author kseitz;	state Exp;
branches;
next	1.26.4.4;

1.26.4.4
date	2002.11.04.00.17.32;	author ezannoni;	state Exp;
branches;
next	;

1.23.2.1
date	2002.03.25.16.50.20;	author aoliva;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2002.06.16.14.13.59;	author cagney;	state Exp;
branches;
next	;

1.13.2.1
date	2001.07.06.19.17.01;	author dberlin;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.47;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.25.18.02.40;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.08.01;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.09.08.23.59.21;	author shebs;	state Exp;
branches
	1.1.1.5.2.1;
next	;

1.1.1.5.2.1
date	2000.05.15.01.44.33;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.143
log
@	* coffread.c (record_minimal_symbol): Update.
	* dbxread.c (record_minimal_symbol): Update.
	* elfread.c (record_minimal_symbol): Update.
	* machoread.c (macho_symtab_add_minsym): Update.
	* mdebugread.c (record_minimal_symbol, parse_partial_symbols):
	Update.
	* minsyms.c (prim_record_minimal_symbol): Update.
	(prim_record_minimal_symbol_full): Remove 'bfd_section'
	argument.
	(prim_record_minimal_symbol_and_info): Likewise.
	* minsyms.h (prim_record_minimal_symbol_full)
	(prim_record_minimal_symbol_and_info): Update.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): Initialize SYMBOL_SECTION.
	* xcoffread.c (record_minimal_symbol, scan_xcoff_symtab):
	Update.
@
text
@/* Read a symbol table in ECOFF format (Third-Eye).

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   Original version contributed by Alessandro Forin (af@@cs.cmu.edu) at
   CMU.  Major work by Per Bothner, John Gilmore and Ian Lance Taylor
   at Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This module provides the function mdebug_build_psymtabs.  It reads
   ECOFF debugging information into partial symbol tables.  The
   debugging information is read from two structures.  A struct
   ecoff_debug_swap includes the sizes of each ECOFF structure and
   swapping routines; these are fixed for a particular target.  A
   struct ecoff_debug_info points to the debugging information for a
   particular object file.

   ECOFF symbol tables are mostly written in the byte order of the
   target machine.  However, one section of the table (the auxiliary
   symbol information) is written in the host byte order.  There is a
   bit in the other symbol info which describes which host byte order
   was used.  ECOFF thereby takes the trophy from Intel `b.out' for
   the most brain-dead adaptation of a file format to byte order.

   This module can read all four of the known byte-order combinations,
   on any type of host.  */

#include "defs.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcore.h"
#include "filenames.h"
#include "objfiles.h"
#include "gdb_obstack.h"
#include "buildsym.h"
#include "stabsread.h"
#include "complaints.h"
#include "demangle.h"
#include "gdb-demangle.h"
#include "gdb_assert.h"
#include "block.h"
#include "dictionary.h"
#include "mdebugread.h"
#include "gdb_stat.h"
#include "gdb_string.h"
#include "psympriv.h"
#include "source.h"

#include "bfd.h"

#include "coff/ecoff.h"		/* COFF-like aspects of ecoff files.  */

#include "libaout.h"		/* Private BFD a.out information.  */
#include "aout/aout64.h"
#include "aout/stab_gnu.h"	/* STABS information.  */

#include "expression.h"

extern void _initialize_mdebugread (void);

/* Provide a way to test if we have both ECOFF and ELF symbol tables.
   We use this define in order to know whether we should override a 
   symbol's ECOFF section with its ELF section.  This is necessary in 
   case the symbol's ELF section could not be represented in ECOFF.  */
#define ECOFF_IN_ELF(bfd) (bfd_get_flavour (bfd) == bfd_target_elf_flavour \
			   && bfd_get_section_by_name (bfd, ".mdebug") != NULL)

/* The objfile we are currently reading.  */

static struct objfile *mdebugread_objfile;



/* We put a pointer to this structure in the read_symtab_private field
   of the psymtab.  */

struct symloc
  {
    /* Index of the FDR that this psymtab represents.  */
    int fdr_idx;
    /* The BFD that the psymtab was created from.  */
    bfd *cur_bfd;
    const struct ecoff_debug_swap *debug_swap;
    struct ecoff_debug_info *debug_info;
    struct mdebug_pending **pending_list;
    /* Pointer to external symbols for this file.  */
    EXTR *extern_tab;
    /* Size of extern_tab.  */
    int extern_count;
    enum language pst_language;
  };

#define PST_PRIVATE(p) ((struct symloc *)(p)->read_symtab_private)
#define FDR_IDX(p) (PST_PRIVATE(p)->fdr_idx)
#define CUR_BFD(p) (PST_PRIVATE(p)->cur_bfd)
#define DEBUG_SWAP(p) (PST_PRIVATE(p)->debug_swap)
#define DEBUG_INFO(p) (PST_PRIVATE(p)->debug_info)
#define PENDING_LIST(p) (PST_PRIVATE(p)->pending_list)

#define SC_IS_TEXT(sc) ((sc) == scText \
		   || (sc) == scRConst \
          	   || (sc) == scInit \
          	   || (sc) == scFini)
#define SC_IS_DATA(sc) ((sc) == scData \
		   || (sc) == scSData \
		   || (sc) == scRData \
		   || (sc) == scPData \
		   || (sc) == scXData)
#define SC_IS_COMMON(sc) ((sc) == scCommon || (sc) == scSCommon)
#define SC_IS_BSS(sc) ((sc) == scBss)
#define SC_IS_SBSS(sc) ((sc) == scSBss)
#define SC_IS_UNDEF(sc) ((sc) == scUndefined || (sc) == scSUndefined)

/* Various complaints about symbol reading that don't abort the process.  */
static void
index_complaint (const char *arg1)
{
  complaint (&symfile_complaints, _("bad aux index at symbol %s"), arg1);
}

static void
unknown_ext_complaint (const char *arg1)
{
  complaint (&symfile_complaints, _("unknown external symbol %s"), arg1);
}

static void
basic_type_complaint (int arg1, const char *arg2)
{
  complaint (&symfile_complaints, _("cannot map ECOFF basic type 0x%x for %s"),
	     arg1, arg2);
}

static void
bad_tag_guess_complaint (const char *arg1)
{
  complaint (&symfile_complaints,
	     _("guessed tag type of %s incorrectly"), arg1);
}

static void
bad_rfd_entry_complaint (const char *arg1, int arg2, int arg3)
{
  complaint (&symfile_complaints, _("bad rfd entry for %s: file %d, index %d"),
	     arg1, arg2, arg3);
}

static void
unexpected_type_code_complaint (const char *arg1)
{
  complaint (&symfile_complaints, _("unexpected type code for %s"), arg1);
}

/* Macros and extra defs.  */

/* Puns: hard to find whether -g was used and how.  */

#define MIN_GLEVEL GLEVEL_0
#define compare_glevel(a,b)					\
	(((a) == GLEVEL_3) ? ((b) < GLEVEL_3) :			\
	 ((b) == GLEVEL_3) ? -1 : (int)((b) - (a)))

/* Things that really are local to this module.  */

/* Remember what we deduced to be the source language of this psymtab.  */

static enum language psymtab_language = language_unknown;

/* Current BFD.  */

static bfd *cur_bfd;

/* How to parse debugging information for CUR_BFD.  */

static const struct ecoff_debug_swap *debug_swap;

/* Pointers to debugging information for CUR_BFD.  */

static struct ecoff_debug_info *debug_info;

/* Pointer to current file decriptor record, and its index.  */

static FDR *cur_fdr;
static int cur_fd;

/* Index of current symbol.  */

static int cur_sdx;

/* Note how much "debuggable" this image is.  We would like
   to see at least one FDR with full symbols.  */

static int max_gdbinfo;
static int max_glevel;

/* When examining .o files, report on undefined symbols.  */

static int n_undef_symbols, n_undef_labels, n_undef_vars, n_undef_procs;

/* Pseudo symbol to use when putting stabs into the symbol table.  */

static char stabs_symbol[] = STABS_SYMBOL;

/* Nonzero if we have seen ecoff debugging info for a file.  */

static int found_ecoff_debugging_info;

/* Forward declarations.  */

static int upgrade_type (int, struct type **, int, union aux_ext *,
			 int, char *);

static void parse_partial_symbols (struct objfile *);

static int has_opaque_xref (FDR *, SYMR *);

static int cross_ref (int, union aux_ext *, struct type **, enum type_code,
		      char **, int, char *);

static struct symbol *new_symbol (char *);

static struct type *new_type (char *);

enum block_type { FUNCTION_BLOCK, NON_FUNCTION_BLOCK };

static struct block *new_block (enum block_type);

static struct symtab *new_symtab (const char *, int, struct objfile *);

static struct linetable *new_linetable (int);

static struct blockvector *new_bvect (int);

static struct type *parse_type (int, union aux_ext *, unsigned int, int *,
				int, char *);

static struct symbol *mylookup_symbol (char *, struct block *, domain_enum,
				       enum address_class);

static void sort_blocks (struct symtab *);

static struct partial_symtab *new_psymtab (char *, struct objfile *);

static void psymtab_to_symtab_1 (struct objfile *objfile,
				 struct partial_symtab *, const char *);

static void add_block (struct block *, struct symtab *);

static void add_symbol (struct symbol *, struct symtab *, struct block *);

static int add_line (struct linetable *, int, CORE_ADDR, int);

static struct linetable *shrink_linetable (struct linetable *);

static void handle_psymbol_enumerators (struct objfile *, FDR *, int,
					CORE_ADDR);

static char *mdebug_next_symbol_text (struct objfile *);

/* Exported procedure: Builds a symtab from the partial symtab SELF.
   Restores the environment in effect when SELF was created, delegates
   most of the work to an ancillary procedure, and sorts
   and reorders the symtab list at the end.  SELF is not NULL.  */

static void
mdebug_read_symtab (struct partial_symtab *self, struct objfile *objfile)
{
  if (info_verbose)
    {
      printf_filtered (_("Reading in symbols for %s..."), self->filename);
      gdb_flush (gdb_stdout);
    }

  next_symbol_text_func = mdebug_next_symbol_text;

  psymtab_to_symtab_1 (objfile, self, self->filename);

  /* Match with global symbols.  This only needs to be done once,
     after all of the symtabs and dependencies have been read in.  */
  scan_file_globals (objfile);

  if (info_verbose)
    printf_filtered (_("done.\n"));
}

/* File-level interface functions.  */

/* Find a file descriptor given its index RF relative to a file CF.  */

static FDR *
get_rfd (int cf, int rf)
{
  FDR *fdrs;
  FDR *f;
  RFDT rfd;

  fdrs = debug_info->fdr;
  f = fdrs + cf;
  /* Object files do not have the RFD table, all refs are absolute.  */
  if (f->rfdBase == 0)
    return fdrs + rf;
  (*debug_swap->swap_rfd_in) (cur_bfd,
			      ((char *) debug_info->external_rfd
			       + ((f->rfdBase + rf)
				  * debug_swap->external_rfd_size)),
			      &rfd);
  return fdrs + rfd;
}

/* Return a safer print NAME for a file descriptor.  */

static char *
fdr_name (FDR *f)
{
  if (f->rss == -1)
    return "<stripped file>";
  if (f->rss == 0)
    return "<NFY>";
  return debug_info->ss + f->issBase + f->rss;
}


/* Read in and parse the symtab of the file OBJFILE.  Symbols from
   different sections are relocated via the SECTION_OFFSETS.  */

void
mdebug_build_psymtabs (struct objfile *objfile,
		       const struct ecoff_debug_swap *swap,
		       struct ecoff_debug_info *info)
{
  cur_bfd = objfile->obfd;
  debug_swap = swap;
  debug_info = info;

  stabsread_new_init ();
  buildsym_new_init ();
  free_header_files ();
  init_header_files ();
        
  /* Make sure all the FDR information is swapped in.  */
  if (info->fdr == (FDR *) NULL)
    {
      char *fdr_src;
      char *fdr_end;
      FDR *fdr_ptr;

      info->fdr = (FDR *) obstack_alloc (&objfile->objfile_obstack,
					 (info->symbolic_header.ifdMax
					  * sizeof (FDR)));
      fdr_src = info->external_fdr;
      fdr_end = (fdr_src
		 + info->symbolic_header.ifdMax * swap->external_fdr_size);
      fdr_ptr = info->fdr;
      for (; fdr_src < fdr_end; fdr_src += swap->external_fdr_size, fdr_ptr++)
	(*swap->swap_fdr_in) (objfile->obfd, fdr_src, fdr_ptr);
    }

  parse_partial_symbols (objfile);

#if 0
  /* Check to make sure file was compiled with -g.  If not, warn the
     user of this limitation.  */
  if (compare_glevel (max_glevel, GLEVEL_2) < 0)
    {
      if (max_gdbinfo == 0)
	printf_unfiltered (_("\n%s not compiled with -g, "
			     "debugging support is limited.\n"),
			   objfile->name);
      printf_unfiltered (_("You should compile with -g2 or "
			   "-g3 for best debugging support.\n"));
      gdb_flush (gdb_stdout);
    }
#endif
}

/* Local utilities */

/* Map of FDR indexes to partial symtabs.  */

struct pst_map
{
  struct partial_symtab *pst;	/* the psymtab proper */
  long n_globals;		/* exported globals (external symbols) */
  long globals_offset;		/* cumulative */
};


/* Utility stack, used to nest procedures and blocks properly.
   It is a doubly linked list, to avoid too many alloc/free.
   Since we might need it quite a few times it is NOT deallocated
   after use.  */

static struct parse_stack
  {
    struct parse_stack *next, *prev;
    struct symtab *cur_st;	/* Current symtab.  */
    struct block *cur_block;	/* Block in it.  */

    /* What are we parsing.  stFile, or stBlock are for files and
       blocks.  stProc or stStaticProc means we have seen the start of a
       procedure, but not the start of the block within in.  When we see
       the start of that block, we change it to stNil, without pushing a
       new block, i.e. stNil means both a procedure and a block.  */

    int blocktype;

    struct type *cur_type;	/* Type we parse fields for.  */
    int cur_field;		/* Field number in cur_type.  */
    CORE_ADDR procadr;		/* Start addres of this procedure.  */
    int numargs;		/* Its argument count.  */
  }

 *top_stack;			/* Top stack ptr */


/* Enter a new lexical context.  */

static void
push_parse_stack (void)
{
  struct parse_stack *new;

  /* Reuse frames if possible.  */
  if (top_stack && top_stack->prev)
    new = top_stack->prev;
  else
    new = (struct parse_stack *) xzalloc (sizeof (struct parse_stack));
  /* Initialize new frame with previous content.  */
  if (top_stack)
    {
      struct parse_stack *prev = new->prev;

      *new = *top_stack;
      top_stack->prev = new;
      new->prev = prev;
      new->next = top_stack;
    }
  top_stack = new;
}

/* Exit a lexical context.  */

static void
pop_parse_stack (void)
{
  if (!top_stack)
    return;
  if (top_stack->next)
    top_stack = top_stack->next;
}


/* Cross-references might be to things we haven't looked at
   yet, e.g. type references.  To avoid too many type
   duplications we keep a quick fixup table, an array
   of lists of references indexed by file descriptor.  */

struct mdebug_pending
{
  struct mdebug_pending *next;	/* link */
  char *s;			/* the unswapped symbol */
  struct type *t;		/* its partial type descriptor */
};


/* The pending information is kept for an entire object file.  We
   allocate the pending information table when we create the partial
   symbols, and we store a pointer to the single table in each
   psymtab.  */

static struct mdebug_pending **pending_list;

/* Check whether we already saw symbol SH in file FH.  */

static struct mdebug_pending *
is_pending_symbol (FDR *fh, char *sh)
{
  int f_idx = fh - debug_info->fdr;
  struct mdebug_pending *p;

  /* Linear search is ok, list is typically no more than 10 deep.  */
  for (p = pending_list[f_idx]; p; p = p->next)
    if (p->s == sh)
      break;
  return p;
}

/* Add a new symbol SH of type T.  */

static void
add_pending (FDR *fh, char *sh, struct type *t)
{
  int f_idx = fh - debug_info->fdr;
  struct mdebug_pending *p = is_pending_symbol (fh, sh);

  /* Make sure we do not make duplicates.  */
  if (!p)
    {
      p = ((struct mdebug_pending *)
	   obstack_alloc (&mdebugread_objfile->objfile_obstack,
			  sizeof (struct mdebug_pending)));
      p->s = sh;
      p->t = t;
      p->next = pending_list[f_idx];
      pending_list[f_idx] = p;
    }
}


/* Parsing Routines proper.  */

/* Parse a single symbol.  Mostly just make up a GDB symbol for it.
   For blocks, procedures and types we open a new lexical context.
   This is basically just a big switch on the symbol's type.  Argument
   AX is the base pointer of aux symbols for this file (fh->iauxBase).
   EXT_SH points to the unswapped symbol, which is needed for struct,
   union, etc., types; it is NULL for an EXTR.  BIGEND says whether
   aux symbols are big-endian or little-endian.  Return count of
   SYMR's handled (normally one).  */

static int
mdebug_reg_to_regnum (struct symbol *sym, struct gdbarch *gdbarch)
{
  return gdbarch_ecoff_reg_to_regnum (gdbarch, SYMBOL_VALUE (sym));
}

static const struct symbol_register_ops mdebug_register_funcs = {
  mdebug_reg_to_regnum
};

/* The "aclass" indices for computed symbols.  */

static int mdebug_register_index;
static int mdebug_regparm_index;

static int
parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,
	      struct section_offsets *section_offsets, struct objfile *objfile)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  const bfd_size_type external_sym_size = debug_swap->external_sym_size;
  void (*const swap_sym_in) (bfd *, void *, SYMR *) = debug_swap->swap_sym_in;
  char *name;
  struct symbol *s;
  struct block *b;
  struct mdebug_pending *pend;
  struct type *t;
  struct field *f;
  int count = 1;
  enum address_class class;
  TIR tir;
  long svalue = sh->value;
  int bitsize;

  if (ext_sh == (char *) NULL)
    name = debug_info->ssext + sh->iss;
  else
    name = debug_info->ss + cur_fdr->issBase + sh->iss;

  switch (sh->sc)
    {
    case scText:
    case scRConst:
      /* Do not relocate relative values.
         The value of a stEnd symbol is the displacement from the
         corresponding start symbol value.
         The value of a stBlock symbol is the displacement from the
         procedure address.  */
      if (sh->st != stEnd && sh->st != stBlock)
	sh->value += ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));
      break;
    case scData:
    case scSData:
    case scRData:
    case scPData:
    case scXData:
      sh->value += ANOFFSET (section_offsets, SECT_OFF_DATA (objfile));
      break;
    case scBss:
    case scSBss:
      sh->value += ANOFFSET (section_offsets, SECT_OFF_BSS (objfile));
      break;
    }

  switch (sh->st)
    {
    case stNil:
      break;

    case stGlobal:		/* External symbol, goes into global block.  */
      class = LOC_STATIC;
      b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (top_stack->cur_st),
			     GLOBAL_BLOCK);
      s = new_symbol (name);
      SYMBOL_VALUE_ADDRESS (s) = (CORE_ADDR) sh->value;
      goto data;

    case stStatic:		/* Static data, goes into current block.  */
      class = LOC_STATIC;
      b = top_stack->cur_block;
      s = new_symbol (name);
      if (SC_IS_COMMON (sh->sc))
	{
	  /* It is a FORTRAN common block.  At least for SGI Fortran the
	     address is not in the symbol; we need to fix it later in
	     scan_file_globals.  */
	  int bucket = hashname (SYMBOL_LINKAGE_NAME (s));
	  SYMBOL_VALUE_CHAIN (s) = global_sym_chain[bucket];
	  global_sym_chain[bucket] = s;
	}
      else
	SYMBOL_VALUE_ADDRESS (s) = (CORE_ADDR) sh->value;
      goto data;

    case stLocal:		/* Local variable, goes into current block.  */
      b = top_stack->cur_block;
      s = new_symbol (name);
      SYMBOL_VALUE (s) = svalue;
      if (sh->sc == scRegister)
	class = mdebug_register_index;
      else
	class = LOC_LOCAL;

    data:			/* Common code for symbols describing data.  */
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
      SYMBOL_ACLASS_INDEX (s) = class;
      add_symbol (s, top_stack->cur_st, b);

      /* Type could be missing if file is compiled without debugging info.  */
      if (SC_IS_UNDEF (sh->sc)
	  || sh->sc == scNil || sh->index == indexNil)
	SYMBOL_TYPE (s) = objfile_type (objfile)->nodebug_data_symbol;
      else
	SYMBOL_TYPE (s) = parse_type (cur_fd, ax, sh->index, 0, bigend, name);
      /* Value of a data symbol is its memory address.  */
      break;

    case stParam:		/* Arg to procedure, goes into current
				   block.  */
      max_gdbinfo++;
      found_ecoff_debugging_info = 1;
      top_stack->numargs++;

      /* Special GNU C++ name.  */
      if (is_cplus_marker (name[0]) && name[1] == 't' && name[2] == 0)
	name = "this";		/* FIXME, not alloc'd in obstack.  */
      s = new_symbol (name);

      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
      SYMBOL_IS_ARGUMENT (s) = 1;
      switch (sh->sc)
	{
	case scRegister:
	  /* Pass by value in register.  */
	  SYMBOL_ACLASS_INDEX (s) = mdebug_register_index;
	  break;
	case scVar:
	  /* Pass by reference on stack.  */
	  SYMBOL_ACLASS_INDEX (s) = LOC_REF_ARG;
	  break;
	case scVarRegister:
	  /* Pass by reference in register.  */
	  SYMBOL_ACLASS_INDEX (s) = mdebug_regparm_index;
	  break;
	default:
	  /* Pass by value on stack.  */
	  SYMBOL_ACLASS_INDEX (s) = LOC_ARG;
	  break;
	}
      SYMBOL_VALUE (s) = svalue;
      SYMBOL_TYPE (s) = parse_type (cur_fd, ax, sh->index, 0, bigend, name);
      add_symbol (s, top_stack->cur_st, top_stack->cur_block);
      break;

    case stLabel:		/* label, goes into current block.  */
      s = new_symbol (name);
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;	/* So that it can be used */
      SYMBOL_ACLASS_INDEX (s) = LOC_LABEL;	/* but not misused.  */
      SYMBOL_VALUE_ADDRESS (s) = (CORE_ADDR) sh->value;
      SYMBOL_TYPE (s) = objfile_type (objfile)->builtin_int;
      add_symbol (s, top_stack->cur_st, top_stack->cur_block);
      break;

    case stProc:	/* Procedure, usually goes into global block.  */
    case stStaticProc:	/* Static procedure, goes into current block.  */
      /* For stProc symbol records, we need to check the storage class
         as well, as only (stProc, scText) entries represent "real"
         procedures - See the Compaq document titled "Object File /
         Symbol Table Format Specification" for more information.
         If the storage class is not scText, we discard the whole block
         of symbol records for this stProc.  */
      if (sh->st == stProc && sh->sc != scText)
        {
          char *ext_tsym = ext_sh;
          int keep_counting = 1;
          SYMR tsym;

          while (keep_counting)
            {
              ext_tsym += external_sym_size;
              (*swap_sym_in) (cur_bfd, ext_tsym, &tsym);
              count++;
              switch (tsym.st)
                {
                  case stParam:
                    break;
                  case stEnd:
                    keep_counting = 0;
                    break;
                  default:
                    complaint (&symfile_complaints,
                               _("unknown symbol type 0x%x"), sh->st);
                    break;
                }
            }
          break;
        }
      s = new_symbol (name);
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
      SYMBOL_ACLASS_INDEX (s) = LOC_BLOCK;
      /* Type of the return value.  */
      if (SC_IS_UNDEF (sh->sc) || sh->sc == scNil)
	t = objfile_type (objfile)->builtin_int;
      else
	{
	  t = parse_type (cur_fd, ax, sh->index + 1, 0, bigend, name);
	  if (strcmp (name, "malloc") == 0
	      && TYPE_CODE (t) == TYPE_CODE_VOID)
	    {
	      /* I don't know why, but, at least under Alpha GNU/Linux,
	         when linking against a malloc without debugging
	         symbols, its read as a function returning void---this
	         is bad because it means we cannot call functions with
	         string arguments interactively; i.e., "call
	         printf("howdy\n")" would fail with the error message
	         "program has no memory available".  To avoid this, we
	         patch up the type and make it void*
	         instead. (davidm@@azstarnet.com).  */
	      t = make_pointer_type (t, NULL);
	    }
	}
      b = top_stack->cur_block;
      if (sh->st == stProc)
	{
	  struct blockvector *bv = BLOCKVECTOR (top_stack->cur_st);

	  /* The next test should normally be true, but provides a
	     hook for nested functions (which we don't want to make
	     global).  */
	  if (b == BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK))
	    b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	  /* Irix 5 sometimes has duplicate names for the same
	     function.  We want to add such names up at the global
	     level, not as a nested function.  */
	  else if (sh->value == top_stack->procadr)
	    b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	}
      add_symbol (s, top_stack->cur_st, b);

      /* Make a type for the procedure itself.  */
      SYMBOL_TYPE (s) = lookup_function_type (t);

      /* All functions in C++ have prototypes.  For C we don't have enough
         information in the debug info.  */
      if (SYMBOL_LANGUAGE (s) == language_cplus)
	TYPE_PROTOTYPED (SYMBOL_TYPE (s)) = 1;

      /* Create and enter a new lexical context.  */
      b = new_block (FUNCTION_BLOCK);
      SYMBOL_BLOCK_VALUE (s) = b;
      BLOCK_FUNCTION (b) = s;
      BLOCK_START (b) = BLOCK_END (b) = sh->value;
      BLOCK_SUPERBLOCK (b) = top_stack->cur_block;
      add_block (b, top_stack->cur_st);

      /* Not if we only have partial info.  */
      if (SC_IS_UNDEF (sh->sc) || sh->sc == scNil)
	break;

      push_parse_stack ();
      top_stack->cur_block = b;
      top_stack->blocktype = sh->st;
      top_stack->cur_type = SYMBOL_TYPE (s);
      top_stack->cur_field = -1;
      top_stack->procadr = sh->value;
      top_stack->numargs = 0;
      break;

      /* Beginning of code for structure, union, and enum definitions.
         They all share a common set of local variables, defined here.  */
      {
	enum type_code type_code;
	char *ext_tsym;
	int nfields;
	long max_value;
	struct field *f;

    case stStruct:		/* Start a block defining a struct type.  */
	type_code = TYPE_CODE_STRUCT;
	goto structured_common;

    case stUnion:		/* Start a block defining a union type.  */
	type_code = TYPE_CODE_UNION;
	goto structured_common;

    case stEnum:		/* Start a block defining an enum type.  */
	type_code = TYPE_CODE_ENUM;
	goto structured_common;

    case stBlock:		/* Either a lexical block, or some type.  */
	if (sh->sc != scInfo && !SC_IS_COMMON (sh->sc))
	  goto case_stBlock_code;	/* Lexical block */

	type_code = TYPE_CODE_UNDEF;	/* We have a type.  */

	/* Common code for handling struct, union, enum, and/or as-yet-
	   unknown-type blocks of info about structured data.  `type_code'
	   has been set to the proper TYPE_CODE, if we know it.  */
      structured_common:
	found_ecoff_debugging_info = 1;
	push_parse_stack ();
	top_stack->blocktype = stBlock;

	/* First count the number of fields and the highest value.  */
	nfields = 0;
	max_value = 0;
	for (ext_tsym = ext_sh + external_sym_size;
	     ;
	     ext_tsym += external_sym_size)
	  {
	    SYMR tsym;

	    (*swap_sym_in) (cur_bfd, ext_tsym, &tsym);

	    switch (tsym.st)
	      {
	      case stEnd:
                /* C++ encodes class types as structures where there the
                   methods are encoded as stProc.  The scope of stProc
                   symbols also ends with stEnd, thus creating a risk of
                   taking the wrong stEnd symbol record as the end of
                   the current struct, which would cause GDB to undercount
                   the real number of fields in this struct.  To make sure
                   we really reached the right stEnd symbol record, we
                   check the associated name, and match it against the
                   struct name.  Since method names are mangled while
                   the class name is not, there is no risk of having a
                   method whose name is identical to the class name
                   (in particular constructor method names are different
                   from the class name).  There is therefore no risk that
                   this check stops the count on the StEnd of a method.
		   
		   Also, assume that we're really at the end when tsym.iss
		   is 0 (issNull).  */
                if (tsym.iss == issNull
		    || strcmp (debug_info->ss + cur_fdr->issBase + tsym.iss,
                               name) == 0)
                  goto end_of_fields;
                break;

	      case stMember:
		if (nfields == 0 && type_code == TYPE_CODE_UNDEF)
		  {
		    /* If the type of the member is Nil (or Void),
		       without qualifiers, assume the tag is an
		       enumeration.
		       Alpha cc -migrate enums are recognized by a zero
		       index and a zero symbol value.
		       DU 4.0 cc enums are recognized by a member type of
		       btEnum without qualifiers and a zero symbol value.  */
		    if (tsym.index == indexNil
			|| (tsym.index == 0 && sh->value == 0))
		      type_code = TYPE_CODE_ENUM;
		    else
		      {
			(*debug_swap->swap_tir_in) (bigend,
						    &ax[tsym.index].a_ti,
						    &tir);
			if ((tir.bt == btNil || tir.bt == btVoid
			     || (tir.bt == btEnum && sh->value == 0))
			    && tir.tq0 == tqNil)
			  type_code = TYPE_CODE_ENUM;
		      }
		  }
		nfields++;
		if (tsym.value > max_value)
		  max_value = tsym.value;
		break;

	      case stBlock:
	      case stUnion:
	      case stEnum:
	      case stStruct:
		{
#if 0
		  /* This is a no-op; is it trying to tell us something
		     we should be checking?  */
		  if (tsym.sc == scVariant);	/*UNIMPLEMENTED */
#endif
		  if (tsym.index != 0)
		    {
		      /* This is something like a struct within a
		         struct.  Skip over the fields of the inner
		         struct.  The -1 is because the for loop will
		         increment ext_tsym.  */
		      ext_tsym = ((char *) debug_info->external_sym
				  + ((cur_fdr->isymBase + tsym.index - 1)
				     * external_sym_size));
		    }
		}
		break;

	      case stTypedef:
		/* mips cc puts out a typedef for struct x if it is not yet
		   defined when it encounters
		   struct y { struct x *xp; };
		   Just ignore it.  */
		break;

	      case stIndirect:
		/* Irix5 cc puts out a stIndirect for struct x if it is not
		   yet defined when it encounters
		   struct y { struct x *xp; };
		   Just ignore it.  */
		break;

	      default:
		complaint (&symfile_complaints,
			   _("declaration block contains "
			     "unhandled symbol type %d"),
			   tsym.st);
	      }
	  }
      end_of_fields:

	/* In an stBlock, there is no way to distinguish structs,
	   unions, and enums at this point.  This is a bug in the
	   original design (that has been fixed with the recent
	   addition of the stStruct, stUnion, and stEnum symbol
	   types.)  The way you can tell is if/when you see a variable
	   or field of that type.  In that case the variable's type
	   (in the AUX table) says if the type is struct, union, or
	   enum, and points back to the stBlock here.  So you can
	   patch the tag kind up later - but only if there actually is
	   a variable or field of that type.

	   So until we know for sure, we will guess at this point.
	   The heuristic is:
	   If the first member has index==indexNil or a void type,
	   assume we have an enumeration.
	   Otherwise, if there is more than one member, and all
	   the members have offset 0, assume we have a union.
	   Otherwise, assume we have a struct.

	   The heuristic could guess wrong in the case of of an
	   enumeration with no members or a union with one (or zero)
	   members, or when all except the last field of a struct have
	   width zero.  These are uncommon and/or illegal situations,
	   and in any case guessing wrong probably doesn't matter
	   much.

	   But if we later do find out we were wrong, we fixup the tag
	   kind.  Members of an enumeration must be handled
	   differently from struct/union fields, and that is harder to
	   patch up, but luckily we shouldn't need to.  (If there are
	   any enumeration members, we can tell for sure it's an enum
	   here.)  */

	if (type_code == TYPE_CODE_UNDEF)
	  {
	    if (nfields > 1 && max_value == 0)
	      type_code = TYPE_CODE_UNION;
	    else
	      type_code = TYPE_CODE_STRUCT;
	  }

	/* Create a new type or use the pending type.  */
	pend = is_pending_symbol (cur_fdr, ext_sh);
	if (pend == (struct mdebug_pending *) NULL)
	  {
	    t = new_type (NULL);
	    add_pending (cur_fdr, ext_sh, t);
	  }
	else
	  t = pend->t;

	/* Do not set the tag name if it is a compiler generated tag name
	   (.Fxx or .xxfake or empty) for unnamed struct/union/enums.
	   Alpha cc puts out an sh->iss of zero for those.  */
	if (sh->iss == 0 || name[0] == '.' || name[0] == '\0')
	  TYPE_TAG_NAME (t) = NULL;
	else
	  TYPE_TAG_NAME (t) = obconcat (&mdebugread_objfile->objfile_obstack,
					name, (char *) NULL);

	TYPE_CODE (t) = type_code;
	TYPE_LENGTH (t) = sh->value;
	TYPE_NFIELDS (t) = nfields;
	TYPE_FIELDS (t) = f = ((struct field *)
			       TYPE_ALLOC (t,
					   nfields * sizeof (struct field)));

	if (type_code == TYPE_CODE_ENUM)
	  {
	    int unsigned_enum = 1;

	    /* This is a non-empty enum.  */

	    /* DEC c89 has the number of enumerators in the sh.value field,
	       not the type length, so we have to compensate for that
	       incompatibility quirk.
	       This might do the wrong thing for an enum with one or two
	       enumerators and gcc -gcoff -fshort-enums, but these cases
	       are hopefully rare enough.
	       Alpha cc -migrate has a sh.value field of zero, we adjust
	       that too.  */
	    if (TYPE_LENGTH (t) == TYPE_NFIELDS (t)
		|| TYPE_LENGTH (t) == 0)
	      TYPE_LENGTH (t) = gdbarch_int_bit (gdbarch) / HOST_CHAR_BIT;
	    for (ext_tsym = ext_sh + external_sym_size;
		 ;
		 ext_tsym += external_sym_size)
	      {
		SYMR tsym;
		struct symbol *enum_sym;

		(*swap_sym_in) (cur_bfd, ext_tsym, &tsym);

		if (tsym.st != stMember)
		  break;

		SET_FIELD_ENUMVAL (*f, tsym.value);
		FIELD_TYPE (*f) = t;
		FIELD_NAME (*f) = debug_info->ss + cur_fdr->issBase + tsym.iss;
		FIELD_BITSIZE (*f) = 0;

		enum_sym = allocate_symbol (mdebugread_objfile);
		SYMBOL_SET_LINKAGE_NAME
		  (enum_sym,
		   obstack_copy0 (&mdebugread_objfile->objfile_obstack,
				  f->name, strlen (f->name)));
		SYMBOL_ACLASS_INDEX (enum_sym) = LOC_CONST;
		SYMBOL_TYPE (enum_sym) = t;
		SYMBOL_DOMAIN (enum_sym) = VAR_DOMAIN;
		SYMBOL_VALUE (enum_sym) = tsym.value;
		if (SYMBOL_VALUE (enum_sym) < 0)
		  unsigned_enum = 0;
		add_symbol (enum_sym, top_stack->cur_st, top_stack->cur_block);

		/* Skip the stMembers that we've handled.  */
		count++;
		f++;
	      }
	    if (unsigned_enum)
	      TYPE_UNSIGNED (t) = 1;
	  }
	/* Make this the current type.  */
	top_stack->cur_type = t;
	top_stack->cur_field = 0;

	/* Do not create a symbol for alpha cc unnamed structs.  */
	if (sh->iss == 0)
	  break;

	/* gcc puts out an empty struct for an opaque struct definitions,
	   do not create a symbol for it either.  */
	if (TYPE_NFIELDS (t) == 0)
	  {
	    TYPE_STUB (t) = 1;
	    break;
	  }

	s = new_symbol (name);
	SYMBOL_DOMAIN (s) = STRUCT_DOMAIN;
	SYMBOL_ACLASS_INDEX (s) = LOC_TYPEDEF;
	SYMBOL_VALUE (s) = 0;
	SYMBOL_TYPE (s) = t;
	add_symbol (s, top_stack->cur_st, top_stack->cur_block);
	break;

	/* End of local variables shared by struct, union, enum, and
	   block (as yet unknown struct/union/enum) processing.  */
      }

    case_stBlock_code:
      found_ecoff_debugging_info = 1;
      /* Beginnning of (code) block.  Value of symbol
         is the displacement from procedure start.  */
      push_parse_stack ();

      /* Do not start a new block if this is the outermost block of a
         procedure.  This allows the LOC_BLOCK symbol to point to the
         block with the local variables, so funcname::var works.  */
      if (top_stack->blocktype == stProc
	  || top_stack->blocktype == stStaticProc)
	{
	  top_stack->blocktype = stNil;
	  break;
	}

      top_stack->blocktype = stBlock;
      b = new_block (NON_FUNCTION_BLOCK);
      BLOCK_START (b) = sh->value + top_stack->procadr;
      BLOCK_SUPERBLOCK (b) = top_stack->cur_block;
      top_stack->cur_block = b;
      add_block (b, top_stack->cur_st);
      break;

    case stEnd:		/* end (of anything) */
      if (sh->sc == scInfo || SC_IS_COMMON (sh->sc))
	{
	  /* Finished with type */
	  top_stack->cur_type = 0;
	}
      else if (sh->sc == scText &&
	       (top_stack->blocktype == stProc ||
		top_stack->blocktype == stStaticProc))
	{
	  /* Finished with procedure */
	  struct blockvector *bv = BLOCKVECTOR (top_stack->cur_st);
	  struct mdebug_extra_func_info *e;
	  struct block *b = top_stack->cur_block;
	  struct type *ftype = top_stack->cur_type;
	  int i;

	  BLOCK_END (top_stack->cur_block) += sh->value;	/* size */

	  /* Make up special symbol to contain procedure specific info.  */
	  s = new_symbol (MDEBUG_EFI_SYMBOL_NAME);
	  SYMBOL_DOMAIN (s) = LABEL_DOMAIN;
	  SYMBOL_ACLASS_INDEX (s) = LOC_CONST;
	  SYMBOL_TYPE (s) = objfile_type (mdebugread_objfile)->builtin_void;
	  e = ((struct mdebug_extra_func_info *)
	       obstack_alloc (&mdebugread_objfile->objfile_obstack,
			      sizeof (struct mdebug_extra_func_info)));
	  memset (e, 0, sizeof (struct mdebug_extra_func_info));
	  SYMBOL_VALUE_BYTES (s) = (gdb_byte *) e;
	  e->numargs = top_stack->numargs;
	  e->pdr.framereg = -1;
	  add_symbol (s, top_stack->cur_st, top_stack->cur_block);

	  /* f77 emits proc-level with address bounds==[0,0],
	     So look for such child blocks, and patch them.  */
	  for (i = 0; i < BLOCKVECTOR_NBLOCKS (bv); i++)
	    {
	      struct block *b_bad = BLOCKVECTOR_BLOCK (bv, i);

	      if (BLOCK_SUPERBLOCK (b_bad) == b
		  && BLOCK_START (b_bad) == top_stack->procadr
		  && BLOCK_END (b_bad) == top_stack->procadr)
		{
		  BLOCK_START (b_bad) = BLOCK_START (b);
		  BLOCK_END (b_bad) = BLOCK_END (b);
		}
	    }

	  if (TYPE_NFIELDS (ftype) <= 0)
	    {
	      /* No parameter type information is recorded with the function's
	         type.  Set that from the type of the parameter symbols.  */
	      int nparams = top_stack->numargs;
	      int iparams;
	      struct symbol *sym;

	      if (nparams > 0)
		{
		  struct block_iterator iter;

		  TYPE_NFIELDS (ftype) = nparams;
		  TYPE_FIELDS (ftype) = (struct field *)
		    TYPE_ALLOC (ftype, nparams * sizeof (struct field));

		  iparams = 0;
		  ALL_BLOCK_SYMBOLS (b, iter, sym)
		    {
		      if (iparams == nparams)
			break;

		      if (SYMBOL_IS_ARGUMENT (sym))
			{
			  TYPE_FIELD_TYPE (ftype, iparams) = SYMBOL_TYPE (sym);
			  TYPE_FIELD_ARTIFICIAL (ftype, iparams) = 0;
			  iparams++;
			}
		    }
		}
	    }
	}
      else if (sh->sc == scText && top_stack->blocktype == stBlock)
	{
	  /* End of (code) block.  The value of the symbol is the
	     displacement from the procedure`s start address of the
	     end of this block.  */
	  BLOCK_END (top_stack->cur_block) = sh->value + top_stack->procadr;
	}
      else if (sh->sc == scText && top_stack->blocktype == stNil)
	{
	  /* End of outermost block.  Pop parse stack and ignore.  The
	     following stEnd of stProc will take care of the block.  */
	  ;
	}
      else if (sh->sc == scText && top_stack->blocktype == stFile)
	{
	  /* End of file.  Pop parse stack and ignore.  Higher
	     level code deals with this.  */
	  ;
	}
      else
	complaint (&symfile_complaints,
		   _("stEnd with storage class %d not handled"), sh->sc);

      pop_parse_stack ();	/* Restore previous lexical context.  */
      break;

    case stMember:		/* member of struct or union */
      f = &TYPE_FIELDS (top_stack->cur_type)[top_stack->cur_field++];
      FIELD_NAME (*f) = name;
      SET_FIELD_BITPOS (*f, sh->value);
      bitsize = 0;
      FIELD_TYPE (*f) = parse_type (cur_fd, ax, sh->index,
				    &bitsize, bigend, name);
      FIELD_BITSIZE (*f) = bitsize;
      break;

    case stIndirect:		/* forward declaration on Irix5 */
      /* Forward declarations from Irix5 cc are handled by cross_ref,
         skip them.  */
      break;

    case stTypedef:		/* type definition */
      found_ecoff_debugging_info = 1;

      /* Typedefs for forward declarations and opaque structs from alpha cc
         are handled by cross_ref, skip them.  */
      if (sh->iss == 0)
	break;

      /* Parse the type or use the pending type.  */
      pend = is_pending_symbol (cur_fdr, ext_sh);
      if (pend == (struct mdebug_pending *) NULL)
	{
	  t = parse_type (cur_fd, ax, sh->index, (int *) NULL, bigend, name);
	  add_pending (cur_fdr, ext_sh, t);
	}
      else
	t = pend->t;

      /* Mips cc puts out a typedef with the name of the struct for forward
         declarations.  These should not go into the symbol table and
         TYPE_NAME should not be set for them.
         They can't be distinguished from an intentional typedef to
         the same name however:
         x.h:
         struct x { int ix; int jx; };
         struct xx;
         x.c:
         typedef struct x x;
         struct xx {int ixx; int jxx; };
         generates a cross referencing stTypedef for x and xx.
         The user visible effect of this is that the type of a pointer
         to struct foo sometimes is given as `foo *' instead of `struct foo *'.
         The problem is fixed with alpha cc and Irix5 cc.  */

      /* However if the typedef cross references to an opaque aggregate, it
         is safe to omit it from the symbol table.  */

      if (has_opaque_xref (cur_fdr, sh))
	break;
      s = new_symbol (name);
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
      SYMBOL_ACLASS_INDEX (s) = LOC_TYPEDEF;
      SYMBOL_BLOCK_VALUE (s) = top_stack->cur_block;
      SYMBOL_TYPE (s) = t;
      add_symbol (s, top_stack->cur_st, top_stack->cur_block);

      /* Incomplete definitions of structs should not get a name.  */
      if (TYPE_NAME (SYMBOL_TYPE (s)) == NULL
	  && (TYPE_NFIELDS (SYMBOL_TYPE (s)) != 0
	      || (TYPE_CODE (SYMBOL_TYPE (s)) != TYPE_CODE_STRUCT
		  && TYPE_CODE (SYMBOL_TYPE (s)) != TYPE_CODE_UNION)))
	{
	  if (TYPE_CODE (SYMBOL_TYPE (s)) == TYPE_CODE_PTR
	      || TYPE_CODE (SYMBOL_TYPE (s)) == TYPE_CODE_FUNC)
	    {
	      /* If we are giving a name to a type such as "pointer to
	         foo" or "function returning foo", we better not set
	         the TYPE_NAME.  If the program contains "typedef char
	         *caddr_t;", we don't want all variables of type char
	         * to print as caddr_t.  This is not just a
	         consequence of GDB's type management; CC and GCC (at
	         least through version 2.4) both output variables of
	         either type char * or caddr_t with the type
	         refering to the stTypedef symbol for caddr_t.  If a future
	         compiler cleans this up it GDB is not ready for it
	         yet, but if it becomes ready we somehow need to
	         disable this check (without breaking the PCC/GCC2.4
	         case).

	         Sigh.

	         Fortunately, this check seems not to be necessary
	         for anything except pointers or functions.  */
	    }
	  else
	    TYPE_NAME (SYMBOL_TYPE (s)) = SYMBOL_LINKAGE_NAME (s);
	}
      break;

    case stFile:		/* file name */
      push_parse_stack ();
      top_stack->blocktype = sh->st;
      break;

      /* I`ve never seen these for C */
    case stRegReloc:
      break;			/* register relocation */
    case stForward:
      break;			/* forwarding address */
    case stConstant:
      break;			/* constant */
    default:
      complaint (&symfile_complaints, _("unknown symbol type 0x%x"), sh->st);
      break;
    }

  return count;
}

/* Basic types.  */

static const struct objfile_data *basic_type_data;

static struct type *
basic_type (int bt, struct objfile *objfile)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  struct type **map_bt = objfile_data (objfile, basic_type_data);
  struct type *tp;

  if (bt >= btMax)
    return NULL;

  if (!map_bt)
    {
      map_bt = OBSTACK_CALLOC (&objfile->objfile_obstack,
			       btMax, struct type *);
      set_objfile_data (objfile, basic_type_data, map_bt);
    }

  if (map_bt[bt])
    return map_bt[bt];

  switch (bt)
    {
    case btNil:
      tp = objfile_type (objfile)->builtin_void;
      break;

    case btAdr:
      tp = init_type (TYPE_CODE_PTR, 4, TYPE_FLAG_UNSIGNED,
		      "adr_32", objfile);
      TYPE_TARGET_TYPE (tp) = objfile_type (objfile)->builtin_void;
      break;

    case btChar:
      tp = init_type (TYPE_CODE_INT, 1, 0,
		      "char", objfile);
      break;

    case btUChar:
      tp = init_type (TYPE_CODE_INT, 1, TYPE_FLAG_UNSIGNED,
		      "unsigned char", objfile);
      break;

    case btShort:
      tp = init_type (TYPE_CODE_INT, 2, 0,
		      "short", objfile);
      break;

    case btUShort:
      tp = init_type (TYPE_CODE_INT, 2, TYPE_FLAG_UNSIGNED,
		      "unsigned short", objfile);
      break;

    case btInt:
      tp = init_type (TYPE_CODE_INT, 4, 0,
		      "int", objfile);
      break;

   case btUInt:
      tp = init_type (TYPE_CODE_INT, 4, TYPE_FLAG_UNSIGNED,
		      "unsigned int", objfile);
      break;

    case btLong:
      tp = init_type (TYPE_CODE_INT, 4, 0,
		      "long", objfile);
      break;

    case btULong:
      tp = init_type (TYPE_CODE_INT, 4, TYPE_FLAG_UNSIGNED,
		      "unsigned long", objfile);
      break;

    case btFloat:
      tp = init_type (TYPE_CODE_FLT,
		      gdbarch_float_bit (gdbarch) / TARGET_CHAR_BIT, 0,
		      "float", objfile);
      break;

    case btDouble:
      tp = init_type (TYPE_CODE_FLT,
		      gdbarch_double_bit (gdbarch) / TARGET_CHAR_BIT, 0,
		      "double", objfile);
      break;

    case btComplex:
      tp = init_type (TYPE_CODE_COMPLEX,
		      2 * gdbarch_float_bit (gdbarch) / TARGET_CHAR_BIT, 0,
		      "complex", objfile);
      TYPE_TARGET_TYPE (tp) = basic_type (btFloat, objfile);
      break;

    case btDComplex:
      tp = init_type (TYPE_CODE_COMPLEX,
		      2 * gdbarch_double_bit (gdbarch) / TARGET_CHAR_BIT, 0,
		      "double complex", objfile);
      TYPE_TARGET_TYPE (tp) = basic_type (btDouble, objfile);
      break;

    case btFixedDec:
      /* We use TYPE_CODE_INT to print these as integers.  Does this do any
	 good?  Would we be better off with TYPE_CODE_ERROR?  Should
	 TYPE_CODE_ERROR print things in hex if it knows the size?  */
      tp = init_type (TYPE_CODE_INT,
		      gdbarch_int_bit (gdbarch) / TARGET_CHAR_BIT, 0,
		      "fixed decimal", objfile);
      break;

    case btFloatDec:
      tp = init_type (TYPE_CODE_ERROR,
		      gdbarch_double_bit (gdbarch) / TARGET_CHAR_BIT, 0,
		      "floating decimal", objfile);
      break;

    case btString:
      /* Is a "string" the way btString means it the same as TYPE_CODE_STRING?
	 FIXME.  */
      tp = init_type (TYPE_CODE_STRING, 1, 0,
		      "string", objfile);
      break;

    case btVoid:
      tp = objfile_type (objfile)->builtin_void;
      break;

    case btLong64:
      tp = init_type (TYPE_CODE_INT, 8, 0,
		      "long", objfile);
      break;

    case btULong64:
      tp = init_type (TYPE_CODE_INT, 8, TYPE_FLAG_UNSIGNED,
		      "unsigned long", objfile);
      break;

    case btLongLong64:
      tp = init_type (TYPE_CODE_INT, 8, 0,
		      "long long", objfile);
      break;

    case btULongLong64:
      tp = init_type (TYPE_CODE_INT, 8, TYPE_FLAG_UNSIGNED,
		      "unsigned long long", objfile);
      break;

    case btAdr64:
      tp = init_type (TYPE_CODE_PTR, 8, TYPE_FLAG_UNSIGNED,
		      "adr_64", objfile);
      TYPE_TARGET_TYPE (tp) = objfile_type (objfile)->builtin_void;
      break;

    case btInt64:
      tp = init_type (TYPE_CODE_INT, 8, 0,
		      "int", objfile);
      break;

    case btUInt64:
      tp = init_type (TYPE_CODE_INT, 8, TYPE_FLAG_UNSIGNED,
		      "unsigned int", objfile);
      break;

    default:
      tp = NULL;
      break;
    }

  map_bt[bt] = tp;
  return tp;
}

/* Parse the type information provided in the raw AX entries for
   the symbol SH.  Return the bitfield size in BS, in case.
   We must byte-swap the AX entries before we use them; BIGEND says whether
   they are big-endian or little-endian (from fh->fBigendian).  */

static struct type *
parse_type (int fd, union aux_ext *ax, unsigned int aux_index, int *bs,
	    int bigend, char *sym_name)
{
  TIR t[1];
  struct type *tp = 0;
  enum type_code type_code = TYPE_CODE_UNDEF;

  /* Handle undefined types, they have indexNil.  */
  if (aux_index == indexNil)
    return basic_type (btInt, mdebugread_objfile);

  /* Handle corrupt aux indices.  */
  if (aux_index >= (debug_info->fdr + fd)->caux)
    {
      index_complaint (sym_name);
      return basic_type (btInt, mdebugread_objfile);
    }
  ax += aux_index;

  /* Use aux as a type information record, map its basic type.  */
  (*debug_swap->swap_tir_in) (bigend, &ax->a_ti, t);
  tp = basic_type (t->bt, mdebugread_objfile);
  if (tp == NULL)
    {
      /* Cannot use builtin types -- build our own.  */
      switch (t->bt)
	{
	case btStruct:
	  type_code = TYPE_CODE_STRUCT;
	  break;
	case btUnion:
	  type_code = TYPE_CODE_UNION;
	  break;
	case btEnum:
	  type_code = TYPE_CODE_ENUM;
	  break;
	case btRange:
	  type_code = TYPE_CODE_RANGE;
	  break;
	case btSet:
	  type_code = TYPE_CODE_SET;
	  break;
	case btIndirect:
	  /* alpha cc -migrate uses this for typedefs.  The true type will
	     be obtained by crossreferencing below.  */
	  type_code = TYPE_CODE_ERROR;
	  break;
	case btTypedef:
	  /* alpha cc uses this for typedefs.  The true type will be
	     obtained by crossreferencing below.  */
	  type_code = TYPE_CODE_ERROR;
	  break;
	default:
	  basic_type_complaint (t->bt, sym_name);
	  return basic_type (btInt, mdebugread_objfile);
	}
    }

  /* Move on to next aux.  */
  ax++;

  if (t->fBitfield)
    {
      int width = AUX_GET_WIDTH (bigend, ax);

      /* Inhibit core dumps if TIR is corrupted.  */
      if (bs == (int *) NULL)
	{
	  /* Alpha cc -migrate encodes char and unsigned char types
	     as short and unsigned short types with a field width of 8.
	     Enum types also have a field width which we ignore for now.  */
	  if (t->bt == btShort && width == 8)
	    tp = basic_type (btChar, mdebugread_objfile);
	  else if (t->bt == btUShort && width == 8)
	    tp = basic_type (btUChar, mdebugread_objfile);
	  else if (t->bt == btEnum)
	    ;
	  else
	    complaint (&symfile_complaints,
		       _("can't handle TIR fBitfield for %s"),
		       sym_name);
	}
      else
	*bs = width;
      ax++;
    }

  /* A btIndirect entry cross references to an aux entry containing
     the type.  */
  if (t->bt == btIndirect)
    {
      RNDXR rn[1];
      int rf;
      FDR *xref_fh;
      int xref_fd;

      (*debug_swap->swap_rndx_in) (bigend, &ax->a_rndx, rn);
      ax++;
      if (rn->rfd == 0xfff)
	{
	  rf = AUX_GET_ISYM (bigend, ax);
	  ax++;
	}
      else
	rf = rn->rfd;

      if (rf == -1)
	{
	  complaint (&symfile_complaints,
		     _("unable to cross ref btIndirect for %s"), sym_name);
	  return basic_type (btInt, mdebugread_objfile);
	}
      xref_fh = get_rfd (fd, rf);
      xref_fd = xref_fh - debug_info->fdr;
      tp = parse_type (xref_fd, debug_info->external_aux + xref_fh->iauxBase,
		    rn->index, (int *) NULL, xref_fh->fBigendian, sym_name);
    }

  /* All these types really point to some (common) MIPS type
     definition, and only the type-qualifiers fully identify
     them.  We'll make the same effort at sharing.  */
  if (t->bt == btStruct ||
      t->bt == btUnion ||
      t->bt == btEnum ||

  /* btSet (I think) implies that the name is a tag name, not a typedef
     name.  This apparently is a MIPS extension for C sets.  */
      t->bt == btSet)
    {
      char *name;

      /* Try to cross reference this type, build new type on failure.  */
      ax += cross_ref (fd, ax, &tp, type_code, &name, bigend, sym_name);
      if (tp == (struct type *) NULL)
	tp = init_type (type_code, 0, 0, (char *) NULL, mdebugread_objfile);

      /* DEC c89 produces cross references to qualified aggregate types,
         dereference them.  */
      while (TYPE_CODE (tp) == TYPE_CODE_PTR
	     || TYPE_CODE (tp) == TYPE_CODE_ARRAY)
	tp = TYPE_TARGET_TYPE (tp);

      /* Make sure that TYPE_CODE(tp) has an expected type code.
         Any type may be returned from cross_ref if file indirect entries
         are corrupted.  */
      if (TYPE_CODE (tp) != TYPE_CODE_STRUCT
	  && TYPE_CODE (tp) != TYPE_CODE_UNION
	  && TYPE_CODE (tp) != TYPE_CODE_ENUM)
	{
	  unexpected_type_code_complaint (sym_name);
	}
      else
	{
	  /* Usually, TYPE_CODE(tp) is already type_code.  The main
	     exception is if we guessed wrong re struct/union/enum.
	     But for struct vs. union a wrong guess is harmless, so
	     don't complain().  */
	  if ((TYPE_CODE (tp) == TYPE_CODE_ENUM
	       && type_code != TYPE_CODE_ENUM)
	      || (TYPE_CODE (tp) != TYPE_CODE_ENUM
		  && type_code == TYPE_CODE_ENUM))
	    {
	      bad_tag_guess_complaint (sym_name);
	    }

	  if (TYPE_CODE (tp) != type_code)
	    {
	      TYPE_CODE (tp) = type_code;
	    }

	  /* Do not set the tag name if it is a compiler generated tag name
	     (.Fxx or .xxfake or empty) for unnamed struct/union/enums.  */
	  if (name[0] == '.' || name[0] == '\0')
	    TYPE_TAG_NAME (tp) = NULL;
	  else if (TYPE_TAG_NAME (tp) == NULL
		   || strcmp (TYPE_TAG_NAME (tp), name) != 0)
	    TYPE_TAG_NAME (tp)
	      = obstack_copy0 (&mdebugread_objfile->objfile_obstack,
			       name, strlen (name));
	}
    }

  /* All these types really point to some (common) MIPS type
     definition, and only the type-qualifiers fully identify
     them.  We'll make the same effort at sharing.
     FIXME: We are not doing any guessing on range types.  */
  if (t->bt == btRange)
    {
      char *name;

      /* Try to cross reference this type, build new type on failure.  */
      ax += cross_ref (fd, ax, &tp, type_code, &name, bigend, sym_name);
      if (tp == (struct type *) NULL)
	tp = init_type (type_code, 0, 0, (char *) NULL, mdebugread_objfile);

      /* Make sure that TYPE_CODE(tp) has an expected type code.
         Any type may be returned from cross_ref if file indirect entries
         are corrupted.  */
      if (TYPE_CODE (tp) != TYPE_CODE_RANGE)
	{
	  unexpected_type_code_complaint (sym_name);
	}
      else
	{
	  /* Usually, TYPE_CODE(tp) is already type_code.  The main
	     exception is if we guessed wrong re struct/union/enum.  */
	  if (TYPE_CODE (tp) != type_code)
	    {
	      bad_tag_guess_complaint (sym_name);
	      TYPE_CODE (tp) = type_code;
	    }
	  if (TYPE_NAME (tp) == NULL
	      || strcmp (TYPE_NAME (tp), name) != 0)
	    TYPE_NAME (tp)
	      = obstack_copy0 (&mdebugread_objfile->objfile_obstack,
			       name, strlen (name));
	}
    }
  if (t->bt == btTypedef)
    {
      char *name;

      /* Try to cross reference this type, it should succeed.  */
      ax += cross_ref (fd, ax, &tp, type_code, &name, bigend, sym_name);
      if (tp == (struct type *) NULL)
	{
	  complaint (&symfile_complaints,
		     _("unable to cross ref btTypedef for %s"), sym_name);
	  tp = basic_type (btInt, mdebugread_objfile);
	}
    }

  /* Deal with range types.  */
  if (t->bt == btRange)
    {
      TYPE_NFIELDS (tp) = 0;
      TYPE_RANGE_DATA (tp) = ((struct range_bounds *)
			  TYPE_ZALLOC (tp, sizeof (struct range_bounds)));
      TYPE_LOW_BOUND (tp) = AUX_GET_DNLOW (bigend, ax);
      ax++;
      TYPE_HIGH_BOUND (tp) = AUX_GET_DNHIGH (bigend, ax);
      ax++;
    }

  /* Parse all the type qualifiers now.  If there are more
     than 6 the game will continue in the next aux.  */

  while (1)
    {
#define PARSE_TQ(tq) \
      if (t->tq != tqNil) \
	ax += upgrade_type(fd, &tp, t->tq, ax, bigend, sym_name); \
      else \
	break;

      PARSE_TQ (tq0);
      PARSE_TQ (tq1);
      PARSE_TQ (tq2);
      PARSE_TQ (tq3);
      PARSE_TQ (tq4);
      PARSE_TQ (tq5);
#undef	PARSE_TQ

      /* mips cc 2.x and gcc never put out continued aux entries.  */
      if (!t->continued)
	break;

      (*debug_swap->swap_tir_in) (bigend, &ax->a_ti, t);
      ax++;
    }

  /* Complain for illegal continuations due to corrupt aux entries.  */
  if (t->continued)
    complaint (&symfile_complaints,
	       _("illegal TIR continued for %s"), sym_name);

  return tp;
}

/* Make up a complex type from a basic one.  Type is passed by
   reference in TPP and side-effected as necessary.  The type
   qualifier TQ says how to handle the aux symbols at AX for
   the symbol SX we are currently analyzing.  BIGEND says whether
   aux symbols are big-endian or little-endian.
   Returns the number of aux symbols we parsed.  */

static int
upgrade_type (int fd, struct type **tpp, int tq, union aux_ext *ax, int bigend,
	      char *sym_name)
{
  int off;
  struct type *t;

  /* Used in array processing.  */
  int rf, id;
  FDR *fh;
  struct type *range;
  struct type *indx;
  int lower, upper;
  RNDXR rndx;

  switch (tq)
    {
    case tqPtr:
      t = lookup_pointer_type (*tpp);
      *tpp = t;
      return 0;

    case tqProc:
      t = lookup_function_type (*tpp);
      *tpp = t;
      return 0;

    case tqArray:
      off = 0;

      /* Determine and record the domain type (type of index).  */
      (*debug_swap->swap_rndx_in) (bigend, &ax->a_rndx, &rndx);
      id = rndx.index;
      rf = rndx.rfd;
      if (rf == 0xfff)
	{
	  ax++;
	  rf = AUX_GET_ISYM (bigend, ax);
	  off++;
	}
      fh = get_rfd (fd, rf);

      indx = parse_type (fh - debug_info->fdr,
			 debug_info->external_aux + fh->iauxBase,
			 id, (int *) NULL, bigend, sym_name);

      /* The bounds type should be an integer type, but might be anything
         else due to corrupt aux entries.  */
      if (TYPE_CODE (indx) != TYPE_CODE_INT)
	{
	  complaint (&symfile_complaints,
		     _("illegal array index type for %s, assuming int"),
		     sym_name);
	  indx = objfile_type (mdebugread_objfile)->builtin_int;
	}

      /* Get the bounds, and create the array type.  */
      ax++;
      lower = AUX_GET_DNLOW (bigend, ax);
      ax++;
      upper = AUX_GET_DNHIGH (bigend, ax);
      ax++;
      rf = AUX_GET_WIDTH (bigend, ax);	/* bit size of array element */

      range = create_range_type ((struct type *) NULL, indx,
				 lower, upper);

      t = create_array_type ((struct type *) NULL, *tpp, range);

      /* We used to fill in the supplied array element bitsize
         here if the TYPE_LENGTH of the target type was zero.
         This happens for a `pointer to an array of anonymous structs',
         but in this case the array element bitsize is also zero,
         so nothing is gained.
         And we used to check the TYPE_LENGTH of the target type against
         the supplied array element bitsize.
         gcc causes a mismatch for `pointer to array of object',
         since the sdb directives it uses do not have a way of
         specifying the bitsize, but it does no harm (the
         TYPE_LENGTH should be correct) and we should be able to
         ignore the erroneous bitsize from the auxiliary entry safely.
         dbx seems to ignore it too.  */

      /* TYPE_TARGET_STUB now takes care of the zero TYPE_LENGTH problem.  */
      if (TYPE_LENGTH (*tpp) == 0)
	TYPE_TARGET_STUB (t) = 1;

      *tpp = t;
      return 4 + off;

    case tqVol:
      /* Volatile -- currently ignored */
      return 0;

    case tqConst:
      /* Const -- currently ignored */
      return 0;

    default:
      complaint (&symfile_complaints, _("unknown type qualifier 0x%x"), tq);
      return 0;
    }
}


/* Parse a procedure descriptor record PR.  Note that the procedure is
   parsed _after_ the local symbols, now we just insert the extra
   information we need into a MDEBUG_EFI_SYMBOL_NAME symbol that has
   already been placed in the procedure's main block.  Note also that
   images that have been partially stripped (ld -x) have been deprived
   of local symbols, and we have to cope with them here.  FIRST_OFF is
   the offset of the first procedure for this FDR; we adjust the
   address by this amount, but I don't know why.  SEARCH_SYMTAB is the symtab
   to look for the function which contains the MDEBUG_EFI_SYMBOL_NAME symbol
   in question, or NULL to use top_stack->cur_block.  */

static void parse_procedure (PDR *, struct symtab *, struct partial_symtab *);

static void
parse_procedure (PDR *pr, struct symtab *search_symtab,
		 struct partial_symtab *pst)
{
  struct symbol *s, *i;
  struct block *b;
  char *sh_name;

  /* Simple rule to find files linked "-x".  */
  if (cur_fdr->rss == -1)
    {
      if (pr->isym == -1)
	{
	  /* Static procedure at address pr->adr.  Sigh.  */
	  /* FIXME-32x64.  assuming pr->adr fits in long.  */
	  complaint (&symfile_complaints,
		     _("can't handle PDR for static proc at 0x%lx"),
		     (unsigned long) pr->adr);
	  return;
	}
      else
	{
	  /* external */
	  EXTR she;

	  (*debug_swap->swap_ext_in) (cur_bfd,
				      ((char *) debug_info->external_ext
				       + (pr->isym
					  * debug_swap->external_ext_size)),
				      &she);
	  sh_name = debug_info->ssext + she.asym.iss;
	}
    }
  else
    {
      /* Full symbols */
      SYMR sh;

      (*debug_swap->swap_sym_in) (cur_bfd,
				  ((char *) debug_info->external_sym
				   + ((cur_fdr->isymBase + pr->isym)
				      * debug_swap->external_sym_size)),
				  &sh);
      sh_name = debug_info->ss + cur_fdr->issBase + sh.iss;
    }

  if (search_symtab != NULL)
    {
#if 0
      /* This loses both in the case mentioned (want a static, find a global),
         but also if we are looking up a non-mangled name which happens to
         match the name of a mangled function.  */
      /* We have to save the cur_fdr across the call to lookup_symbol.
         If the pdr is for a static function and if a global function with
         the same name exists, lookup_symbol will eventually read in the symtab
         for the global function and clobber cur_fdr.  */
      FDR *save_cur_fdr = cur_fdr;

      s = lookup_symbol (sh_name, NULL, VAR_DOMAIN, 0);
      cur_fdr = save_cur_fdr;
#else
      s = mylookup_symbol
	(sh_name,
	 BLOCKVECTOR_BLOCK (BLOCKVECTOR (search_symtab), STATIC_BLOCK),
	 VAR_DOMAIN,
	 LOC_BLOCK);
#endif
    }
  else
    s = mylookup_symbol (sh_name, top_stack->cur_block,
			 VAR_DOMAIN, LOC_BLOCK);

  if (s != 0)
    {
      b = SYMBOL_BLOCK_VALUE (s);
    }
  else
    {
      complaint (&symfile_complaints, _("PDR for %s, but no symbol"), sh_name);
#if 1
      return;
#else
/* FIXME -- delete.  We can't do symbol allocation now; it's all done.  */
      s = new_symbol (sh_name);
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
      SYMBOL_CLASS (s) = LOC_BLOCK;
      /* Donno its type, hope int is ok.  */
      SYMBOL_TYPE (s)
	= lookup_function_type (objfile_type (pst->objfile)->builtin_int);
      add_symbol (s, top_stack->cur_st, top_stack->cur_block);
      /* Won't have symbols for this one.  */
      b = new_block (2);
      SYMBOL_BLOCK_VALUE (s) = b;
      BLOCK_FUNCTION (b) = s;
      BLOCK_START (b) = pr->adr;
      /* BOUND used to be the end of procedure's text, but the
         argument is no longer passed in.  */
      BLOCK_END (b) = bound;
      BLOCK_SUPERBLOCK (b) = top_stack->cur_block;
      add_block (b, top_stack->cur_st);
#endif
    }

  i = mylookup_symbol (MDEBUG_EFI_SYMBOL_NAME, b, LABEL_DOMAIN, LOC_CONST);

  if (i)
    {
      struct mdebug_extra_func_info *e;
      
      e = (struct mdebug_extra_func_info *) SYMBOL_VALUE_BYTES (i);
      e->pdr = *pr;

      /* GDB expects the absolute function start address for the
         procedure descriptor in e->pdr.adr.
         As the address in the procedure descriptor is usually relative,
         we would have to relocate e->pdr.adr with cur_fdr->adr and
         ANOFFSET (pst->section_offsets, SECT_OFF_TEXT (pst->objfile)).
         Unfortunately cur_fdr->adr and e->pdr.adr are both absolute
         in shared libraries on some systems, and on other systems
         e->pdr.adr is sometimes offset by a bogus value.
         To work around these problems, we replace e->pdr.adr with
         the start address of the function.  */
      e->pdr.adr = BLOCK_START (b);
    }

  /* It would be reasonable that functions that have been compiled
     without debugging info have a btNil type for their return value,
     and functions that are void and are compiled with debugging info
     have btVoid.
     gcc and DEC f77 put out btNil types for both cases, so btNil is mapped
     to TYPE_CODE_VOID in parse_type to get the `compiled with debugging info'
     case right.
     The glevel field in cur_fdr could be used to determine the presence
     of debugging info, but GCC doesn't always pass the -g switch settings
     to the assembler and GAS doesn't set the glevel field from the -g switch
     settings.
     To work around these problems, the return value type of a TYPE_CODE_VOID
     function is adjusted accordingly if no debugging info was found in the
     compilation unit.  */

  if (processing_gcc_compilation == 0
      && found_ecoff_debugging_info == 0
      && TYPE_CODE (TYPE_TARGET_TYPE (SYMBOL_TYPE (s))) == TYPE_CODE_VOID)
    SYMBOL_TYPE (s) = objfile_type (mdebugread_objfile)->nodebug_text_symbol;
}

/* Parse the external symbol ES.  Just call parse_symbol() after
   making sure we know where the aux are for it.
   BIGEND says whether aux entries are big-endian or little-endian.

   This routine clobbers top_stack->cur_block and ->cur_st.  */

static void parse_external (EXTR *, int, struct section_offsets *,
			    struct objfile *);

static void
parse_external (EXTR *es, int bigend, struct section_offsets *section_offsets,
		struct objfile *objfile)
{
  union aux_ext *ax;

  if (es->ifd != ifdNil)
    {
      cur_fd = es->ifd;
      cur_fdr = debug_info->fdr + cur_fd;
      ax = debug_info->external_aux + cur_fdr->iauxBase;
    }
  else
    {
      cur_fdr = debug_info->fdr;
      ax = 0;
    }

  /* Reading .o files */
  if (SC_IS_UNDEF (es->asym.sc) || es->asym.sc == scNil)
    {
      char *what;
      switch (es->asym.st)
	{
	case stNil:
	  /* These are generated for static symbols in .o files,
	     ignore them.  */
	  return;
	case stStaticProc:
	case stProc:
	  what = "procedure";
	  n_undef_procs++;
	  break;
	case stGlobal:
	  what = "variable";
	  n_undef_vars++;
	  break;
	case stLabel:
	  what = "label";
	  n_undef_labels++;
	  break;
	default:
	  what = "symbol";
	  break;
	}
      n_undef_symbols++;
      /* FIXME:  Turn this into a complaint?  */
      if (info_verbose)
	printf_filtered (_("Warning: %s `%s' is undefined (in %s)\n"),
			 what, debug_info->ssext + es->asym.iss,
			 fdr_name (cur_fdr));
      return;
    }

  switch (es->asym.st)
    {
    case stProc:
    case stStaticProc:
      /* There is no need to parse the external procedure symbols.
         If they are from objects compiled without -g, their index will
         be indexNil, and the symbol definition from the minimal symbol
         is preferrable (yielding a function returning int instead of int).
         If the index points to a local procedure symbol, the local
         symbol already provides the correct type.
         Note that the index of the external procedure symbol points
         to the local procedure symbol in the local symbol table, and
         _not_ to the auxiliary symbol info.  */
      break;
    case stGlobal:
    case stLabel:
      /* Global common symbols are resolved by the runtime loader,
         ignore them.  */
      if (SC_IS_COMMON (es->asym.sc))
	break;

      /* Note that the case of a symbol with indexNil must be handled
         anyways by parse_symbol().  */
      parse_symbol (&es->asym, ax, (char *) NULL,
		    bigend, section_offsets, objfile);
      break;
    default:
      break;
    }
}

/* Parse the line number info for file descriptor FH into
   GDB's linetable LT.  MIPS' encoding requires a little bit
   of magic to get things out.  Note also that MIPS' line
   numbers can go back and forth, apparently we can live
   with that and do not need to reorder our linetables.  */

static void parse_lines (FDR *, PDR *, struct linetable *, int,
			 struct partial_symtab *, CORE_ADDR);

static void
parse_lines (FDR *fh, PDR *pr, struct linetable *lt, int maxlines,
	     struct partial_symtab *pst, CORE_ADDR lowest_pdr_addr)
{
  unsigned char *base;
  int j, k;
  int delta, count, lineno = 0;

  if (fh->cbLine == 0)
    return;

  /* Scan by procedure descriptors.  */
  k = 0;
  for (j = 0; j < fh->cpd; j++, pr++)
    {
      CORE_ADDR l;
      CORE_ADDR adr;
      unsigned char *halt;

      /* No code for this one.  */
      if (pr->iline == ilineNil ||
	  pr->lnLow == -1 || pr->lnHigh == -1)
	continue;

      /* Determine start and end address of compressed line bytes for
         this procedure.  */
      base = debug_info->line + fh->cbLineOffset;
      if (j != (fh->cpd - 1))
	halt = base + pr[1].cbLineOffset;
      else
	halt = base + fh->cbLine;
      base += pr->cbLineOffset;

      adr = pst->textlow + pr->adr - lowest_pdr_addr;

      l = adr >> 2;		/* in words */
      for (lineno = pr->lnLow; base < halt;)
	{
	  count = *base & 0x0f;
	  delta = *base++ >> 4;
	  if (delta >= 8)
	    delta -= 16;
	  if (delta == -8)
	    {
	      delta = (base[0] << 8) | base[1];
	      if (delta >= 0x8000)
		delta -= 0x10000;
	      base += 2;
	    }
	  lineno += delta;	/* first delta is 0 */

	  /* Complain if the line table overflows.  Could happen
	     with corrupt binaries.  */
	  if (lt->nitems >= maxlines)
	    {
	      complaint (&symfile_complaints,
			 _("guessed size of linetable for %s incorrectly"),
			 fdr_name (fh));
	      break;
	    }
	  k = add_line (lt, lineno, l, k);
	  l += count + 1;
	}
    }
}

static void
function_outside_compilation_unit_complaint (const char *arg1)
{
  complaint (&symfile_complaints,
	     _("function `%s' appears to be defined "
	       "outside of all compilation units"),
	     arg1);
}

/* Use the STORAGE_CLASS to compute which section the given symbol
   belongs to, and then records this new minimal symbol.  */

static void
record_minimal_symbol (const char *name, const CORE_ADDR address,
                       enum minimal_symbol_type ms_type, int storage_class,
                       struct objfile *objfile)
{
  int section;

  switch (storage_class)
    {
      case scText:
        section = SECT_OFF_TEXT (objfile);
        break;
      case scData:
        section = SECT_OFF_DATA (objfile);
        break;
      case scBss:
        section = SECT_OFF_BSS (objfile);
        break;
      case scSData:
        section = get_section_index (objfile, ".sdata");
        break;
      case scSBss:
        section = get_section_index (objfile, ".sbss");
        break;
      case scRData:
        section = get_section_index (objfile, ".rdata");
        break;
      case scInit:
        section = get_section_index (objfile, ".init");
        break;
      case scXData:
        section = get_section_index (objfile, ".xdata");
        break;
      case scPData:
        section = get_section_index (objfile, ".pdata");
        break;
      case scFini:
        section = get_section_index (objfile, ".fini");
        break;
      case scRConst:
        section = get_section_index (objfile, ".rconst");
        break;
#ifdef scTlsData
      case scTlsData:
        section = get_section_index (objfile, ".tlsdata");
        break;
#endif
#ifdef scTlsBss
      case scTlsBss:
        section = get_section_index (objfile, ".tlsbss");
        break;
#endif
      default:
        /* This kind of symbol is not associated to a section.  */
        section = -1;
    }

  prim_record_minimal_symbol_and_info (name, address, ms_type,
                                       section, objfile);
}

/* Master parsing procedure for first-pass reading of file symbols
   into a partial_symtab.  */

static void
parse_partial_symbols (struct objfile *objfile)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  const bfd_size_type external_sym_size = debug_swap->external_sym_size;
  const bfd_size_type external_rfd_size = debug_swap->external_rfd_size;
  const bfd_size_type external_ext_size = debug_swap->external_ext_size;
  void (*const swap_ext_in) (bfd *, void *, EXTR *) = debug_swap->swap_ext_in;
  void (*const swap_sym_in) (bfd *, void *, SYMR *) = debug_swap->swap_sym_in;
  void (*const swap_rfd_in) (bfd *, void *, RFDT *) = debug_swap->swap_rfd_in;
  int f_idx, s_idx;
  HDRR *hdr = &debug_info->symbolic_header;
  /* Running pointers */
  FDR *fh;
  char *ext_out;
  char *ext_out_end;
  EXTR *ext_block;
  EXTR *ext_in;
  EXTR *ext_in_end;
  SYMR sh;
  struct partial_symtab *pst;
  int textlow_not_set = 1;
  int past_first_source_file = 0;

  /* List of current psymtab's include files.  */
  const char **psymtab_include_list;
  int includes_allocated;
  int includes_used;
  EXTR *extern_tab;
  struct pst_map *fdr_to_pst;
  /* Index within current psymtab dependency list.  */
  struct partial_symtab **dependency_list;
  int dependencies_used, dependencies_allocated;
  struct cleanup *old_chain;
  char *name;
  enum language prev_language;
  asection *text_sect;
  int relocatable = 0;

  /* Irix 5.2 shared libraries have a fh->adr field of zero, but
     the shared libraries are prelinked at a high memory address.
     We have to adjust the start address of the object file for this case,
     by setting it to the start address of the first procedure in the file.
     But we should do no adjustments if we are debugging a .o file, where
     the text section (and fh->adr) really starts at zero.  */
  text_sect = bfd_get_section_by_name (cur_bfd, ".text");
  if (text_sect != NULL
      && (bfd_get_section_flags (cur_bfd, text_sect) & SEC_RELOC))
    relocatable = 1;

  extern_tab = (EXTR *) obstack_alloc (&objfile->objfile_obstack,
				       sizeof (EXTR) * hdr->iextMax);

  includes_allocated = 30;
  includes_used = 0;
  psymtab_include_list = (const char **) alloca (includes_allocated *
						 sizeof (const char *));
  next_symbol_text_func = mdebug_next_symbol_text;

  dependencies_allocated = 30;
  dependencies_used = 0;
  dependency_list =
    (struct partial_symtab **) alloca (dependencies_allocated *
				       sizeof (struct partial_symtab *));

  set_last_source_file (NULL);

  /*
   * Big plan:
   *
   * Only parse the Local and External symbols, and the Relative FDR.
   * Fixup enough of the loader symtab to be able to use it.
   * Allocate space only for the file's portions we need to
   * look at.  (XXX)
   */

  max_gdbinfo = 0;
  max_glevel = MIN_GLEVEL;

  /* Allocate the map FDR -> PST.
     Minor hack: -O3 images might claim some global data belongs
     to FDR -1.  We`ll go along with that.  */
  fdr_to_pst = (struct pst_map *)
    xzalloc ((hdr->ifdMax + 1) * sizeof *fdr_to_pst);
  old_chain = make_cleanup (xfree, fdr_to_pst);
  fdr_to_pst++;
  {
    struct partial_symtab *pst = new_psymtab ("", objfile);

    fdr_to_pst[-1].pst = pst;
    FDR_IDX (pst) = -1;
  }

  /* Allocate the global pending list.  */
  pending_list =
    ((struct mdebug_pending **)
     obstack_alloc (&objfile->objfile_obstack,
		    hdr->ifdMax * sizeof (struct mdebug_pending *)));
  memset (pending_list, 0,
	  hdr->ifdMax * sizeof (struct mdebug_pending *));

  /* Pass 0 over external syms: swap them in.  */
  ext_block = (EXTR *) xmalloc (hdr->iextMax * sizeof (EXTR));
  make_cleanup (xfree, ext_block);

  ext_out = (char *) debug_info->external_ext;
  ext_out_end = ext_out + hdr->iextMax * external_ext_size;
  ext_in = ext_block;
  for (; ext_out < ext_out_end; ext_out += external_ext_size, ext_in++)
    (*swap_ext_in) (cur_bfd, ext_out, ext_in);

  /* Pass 1 over external syms: Presize and partition the list.  */
  ext_in = ext_block;
  ext_in_end = ext_in + hdr->iextMax;
  for (; ext_in < ext_in_end; ext_in++)
    {
      /* See calls to complain below.  */
      if (ext_in->ifd >= -1
	  && ext_in->ifd < hdr->ifdMax
	  && ext_in->asym.iss >= 0
	  && ext_in->asym.iss < hdr->issExtMax)
	fdr_to_pst[ext_in->ifd].n_globals++;
    }

  /* Pass 1.5 over files:  partition out global symbol space.  */
  s_idx = 0;
  for (f_idx = -1; f_idx < hdr->ifdMax; f_idx++)
    {
      fdr_to_pst[f_idx].globals_offset = s_idx;
      s_idx += fdr_to_pst[f_idx].n_globals;
      fdr_to_pst[f_idx].n_globals = 0;
    }

  /* ECOFF in ELF:

     For ECOFF in ELF, we skip the creation of the minimal symbols.
     The ECOFF symbols should be a subset of the Elf symbols, and the 
     section information of the elf symbols will be more accurate.
     FIXME!  What about Irix 5's native linker?

     By default, Elf sections which don't exist in ECOFF 
     get put in ECOFF's absolute section by the gnu linker.
     Since absolute sections don't get relocated, we 
     end up calculating an address different from that of 
     the symbol's minimal symbol (created earlier from the
     Elf symtab).

     To fix this, either :
     1) don't create the duplicate symbol
     (assumes ECOFF symtab is a subset of the ELF symtab;
     assumes no side-effects result from ignoring ECOFF symbol)
     2) create it, only if lookup for existing symbol in ELF's minimal 
     symbols fails
     (inefficient; 
     assumes no side-effects result from ignoring ECOFF symbol)
     3) create it, but lookup ELF's minimal symbol and use it's section
     during relocation, then modify "uniqify" phase to merge and 
     eliminate the duplicate symbol
     (highly inefficient)

     I've implemented #1 here...
     Skip the creation of the minimal symbols based on the ECOFF 
     symbol table.  */

  /* Pass 2 over external syms: fill in external symbols.  */
  ext_in = ext_block;
  ext_in_end = ext_in + hdr->iextMax;
  for (; ext_in < ext_in_end; ext_in++)
    {
      enum minimal_symbol_type ms_type = mst_text;
      CORE_ADDR svalue = ext_in->asym.value;

      /* The Irix 5 native tools seem to sometimes generate bogus
         external symbols.  */
      if (ext_in->ifd < -1 || ext_in->ifd >= hdr->ifdMax)
	{
	  complaint (&symfile_complaints,
		     _("bad ifd for external symbol: %d (max %ld)"),
		     ext_in->ifd, hdr->ifdMax);
	  continue;
	}
      if (ext_in->asym.iss < 0 || ext_in->asym.iss >= hdr->issExtMax)
	{
	  complaint (&symfile_complaints,
		     _("bad iss for external symbol: %ld (max %ld)"),
		     ext_in->asym.iss, hdr->issExtMax);
	  continue;
	}

      extern_tab[fdr_to_pst[ext_in->ifd].globals_offset
		 + fdr_to_pst[ext_in->ifd].n_globals++] = *ext_in;


      if (SC_IS_UNDEF (ext_in->asym.sc) || ext_in->asym.sc == scNil)
	continue;


      /* Pass 3 over files, over local syms: fill in static symbols.  */
      name = debug_info->ssext + ext_in->asym.iss;

      /* Process ECOFF Symbol Types and Storage Classes.  */
      switch (ext_in->asym.st)
	{
	case stProc:
	  /* Beginnning of Procedure */
	  svalue += ANOFFSET (objfile->section_offsets,
			      SECT_OFF_TEXT (objfile));
	  break;
	case stStaticProc:
	  /* Load time only static procs */
	  ms_type = mst_file_text;
	  svalue += ANOFFSET (objfile->section_offsets,
			      SECT_OFF_TEXT (objfile));
	  break;
	case stGlobal:
	  /* External symbol */
	  if (SC_IS_COMMON (ext_in->asym.sc))
	    {
	      /* The value of a common symbol is its size, not its address.
	         Ignore it.  */
	      continue;
	    }
	  else if (SC_IS_DATA (ext_in->asym.sc))
	    {
	      ms_type = mst_data;
	      svalue += ANOFFSET (objfile->section_offsets,
				  SECT_OFF_DATA (objfile));
	    }
	  else if (SC_IS_BSS (ext_in->asym.sc))
	    {
	      ms_type = mst_bss;
	      svalue += ANOFFSET (objfile->section_offsets,
				  SECT_OFF_BSS (objfile));
	    }
          else if (SC_IS_SBSS (ext_in->asym.sc))
            {
              ms_type = mst_bss;
              svalue += ANOFFSET (objfile->section_offsets, 
                                  get_section_index (objfile, ".sbss"));
            }
	  else
	    ms_type = mst_abs;
	  break;
	case stLabel:
	  /* Label */

          /* On certain platforms, some extra label symbols can be
             generated by the linker.  One possible usage for this kind
             of symbols is to represent the address of the begining of a
             given section.  For instance, on Tru64 5.1, the address of
             the _ftext label is the start address of the .text section.

             The storage class of these symbols is usually directly
             related to the section to which the symbol refers.  For
             instance, on Tru64 5.1, the storage class for the _fdata
             label is scData, refering to the .data section.

             It is actually possible that the section associated to the
             storage class of the label does not exist.  On True64 5.1
             for instance, the libm.so shared library does not contain
             any .data section, although it contains a _fpdata label
             which storage class is scData...  Since these symbols are
             usually useless for the debugger user anyway, we just
             discard these symbols.  */
          
	  if (SC_IS_TEXT (ext_in->asym.sc))
	    {
              if (objfile->sect_index_text == -1)
                continue;
                
	      ms_type = mst_file_text;
	      svalue += ANOFFSET (objfile->section_offsets,
				  SECT_OFF_TEXT (objfile));
	    }
	  else if (SC_IS_DATA (ext_in->asym.sc))
	    {
              if (objfile->sect_index_data == -1)
                continue;

	      ms_type = mst_file_data;
	      svalue += ANOFFSET (objfile->section_offsets,
				  SECT_OFF_DATA (objfile));
	    }
	  else if (SC_IS_BSS (ext_in->asym.sc))
	    {
              if (objfile->sect_index_bss == -1)
                continue;

	      ms_type = mst_file_bss;
	      svalue += ANOFFSET (objfile->section_offsets,
				  SECT_OFF_BSS (objfile));
	    }
          else if (SC_IS_SBSS (ext_in->asym.sc))
            {
              const int sbss_sect_index = get_section_index (objfile, ".sbss");

              if (sbss_sect_index == -1)
                continue;

              ms_type = mst_file_bss;
              svalue += ANOFFSET (objfile->section_offsets, sbss_sect_index);
            }
	  else
	    ms_type = mst_abs;
	  break;
	case stLocal:
	case stNil:
	  /* The alpha has the section start addresses in stLocal symbols
	     whose name starts with a `.'.  Skip those but complain for all
	     other stLocal symbols.
	     Irix6 puts the section start addresses in stNil symbols, skip
	     those too.  */
	  if (name[0] == '.')
	    continue;
	  /* Fall through.  */
	default:
	  ms_type = mst_unknown;
	  unknown_ext_complaint (name);
	}
      if (!ECOFF_IN_ELF (cur_bfd))
        record_minimal_symbol (name, svalue, ms_type, ext_in->asym.sc,
                               objfile);
    }

  /* Pass 3 over files, over local syms: fill in static symbols.  */
  for (f_idx = 0; f_idx < hdr->ifdMax; f_idx++)
    {
      struct partial_symtab *save_pst;
      EXTR *ext_ptr;
      CORE_ADDR textlow;

      cur_fdr = fh = debug_info->fdr + f_idx;

      if (fh->csym == 0)
	{
	  fdr_to_pst[f_idx].pst = NULL;
	  continue;
	}

      /* Determine the start address for this object file from the
         file header and relocate it, except for Irix 5.2 zero fh->adr.  */
      if (fh->cpd)
	{
	  textlow = fh->adr;
	  if (relocatable || textlow != 0)
	    textlow += ANOFFSET (objfile->section_offsets,
				 SECT_OFF_TEXT (objfile));
	}
      else
	textlow = 0;
      pst = start_psymtab_common (objfile, objfile->section_offsets,
				  fdr_name (fh),
				  textlow,
				  objfile->global_psymbols.next,
				  objfile->static_psymbols.next);
      pst->read_symtab_private = obstack_alloc (&objfile->objfile_obstack,
						sizeof (struct symloc));
      memset (pst->read_symtab_private, 0, sizeof (struct symloc));

      save_pst = pst;
      FDR_IDX (pst) = f_idx;
      CUR_BFD (pst) = cur_bfd;
      DEBUG_SWAP (pst) = debug_swap;
      DEBUG_INFO (pst) = debug_info;
      PENDING_LIST (pst) = pending_list;

      /* The way to turn this into a symtab is to call...  */
      pst->read_symtab = mdebug_read_symtab;

      /* Set up language for the pst.
         The language from the FDR is used if it is unambigious (e.g. cfront
         with native cc and g++ will set the language to C).
         Otherwise we have to deduce the language from the filename.
         Native ecoff has every header file in a separate FDR, so
         deduce_language_from_filename will return language_unknown for
         a header file, which is not what we want.
         But the FDRs for the header files are after the FDR for the source
         file, so we can assign the language of the source file to the
         following header files.  Then we save the language in the private
         pst data so that we can reuse it when building symtabs.  */
      prev_language = psymtab_language;

      switch (fh->lang)
	{
	case langCplusplusV2:
	  psymtab_language = language_cplus;
	  break;
	default:
	  psymtab_language = deduce_language_from_filename (fdr_name (fh));
	  break;
	}
      if (psymtab_language == language_unknown)
	psymtab_language = prev_language;
      PST_PRIVATE (pst)->pst_language = psymtab_language;

      pst->texthigh = pst->textlow;

      /* For stabs-in-ecoff files, the second symbol must be @@stab.
         This symbol is emitted by mips-tfile to signal that the
         current object file uses encapsulated stabs instead of mips
         ecoff for local symbols.  (It is the second symbol because
         the first symbol is the stFile used to signal the start of a
         file).  */
      processing_gcc_compilation = 0;
      if (fh->csym >= 2)
	{
	  (*swap_sym_in) (cur_bfd,
			  ((char *) debug_info->external_sym
			   + (fh->isymBase + 1) * external_sym_size),
			  &sh);
	  if (strcmp (debug_info->ss + fh->issBase + sh.iss,
		      stabs_symbol) == 0)
	    processing_gcc_compilation = 2;
	}

      if (processing_gcc_compilation != 0)
	{
	  for (cur_sdx = 2; cur_sdx < fh->csym; cur_sdx++)
	    {
	      int type_code;
	      const char *namestring;

	      (*swap_sym_in) (cur_bfd,
			      (((char *) debug_info->external_sym)
			    + (fh->isymBase + cur_sdx) * external_sym_size),
			      &sh);
	      type_code = ECOFF_UNMARK_STAB (sh.index);
	      if (!ECOFF_IS_STAB (&sh))
		{
		  if (sh.st == stProc || sh.st == stStaticProc)
		    {
		      CORE_ADDR procaddr;
		      long isym;

		      sh.value += ANOFFSET (objfile->section_offsets,
					    SECT_OFF_TEXT (objfile));
		      if (sh.st == stStaticProc)
			{
			  namestring = debug_info->ss + fh->issBase + sh.iss;
                          record_minimal_symbol (namestring, sh.value,
                                                 mst_file_text, sh.sc,
                                                 objfile);
			}
		      procaddr = sh.value;

		      isym = AUX_GET_ISYM (fh->fBigendian,
					   (debug_info->external_aux
					    + fh->iauxBase
					    + sh.index));
		      (*swap_sym_in) (cur_bfd,
				      ((char *) debug_info->external_sym
				       + ((fh->isymBase + isym - 1)
					  * external_sym_size)),
				      &sh);
		      if (sh.st == stEnd)
			{
			  CORE_ADDR high = procaddr + sh.value;

			  /* Kludge for Irix 5.2 zero fh->adr.  */
			  if (!relocatable
			  && (pst->textlow == 0 || procaddr < pst->textlow))
			    pst->textlow = procaddr;
			  if (high > pst->texthigh)
			    pst->texthigh = high;
			}
		    }
		  else if (sh.st == stStatic)
		    {
		      switch (sh.sc)
			{
			case scUndefined:
			case scSUndefined:
			case scNil:
			case scAbs:
			  break;

			case scData:
			case scSData:
			case scRData:
			case scPData:
			case scXData:
			  namestring = debug_info->ss + fh->issBase + sh.iss;
			  sh.value += ANOFFSET (objfile->section_offsets,
						SECT_OFF_DATA (objfile));
                          record_minimal_symbol (namestring, sh.value,
                                                 mst_file_data, sh.sc,
                                                 objfile);
			  break;

			default:
			  /* FIXME!  Shouldn't this use cases for bss, 
			     then have the default be abs?  */
			  namestring = debug_info->ss + fh->issBase + sh.iss;
			  sh.value += ANOFFSET (objfile->section_offsets,
						SECT_OFF_BSS (objfile));
                          record_minimal_symbol (namestring, sh.value,
                                                 mst_file_bss, sh.sc,
                                                 objfile);
			  break;
			}
		    }
		  continue;
		}
	      /* Handle stabs continuation.  */
	      {
		char *stabstring = debug_info->ss + fh->issBase + sh.iss;
		int len = strlen (stabstring);

		while (stabstring[len - 1] == '\\')
		  {
		    SYMR sh2;
		    char *stabstring1 = stabstring;
		    char *stabstring2;
		    int len2;

		    /* Ignore continuation char from 1st string.  */
		    len--;

		    /* Read next stabstring.  */
		    cur_sdx++;
		    (*swap_sym_in) (cur_bfd,
				    (((char *) debug_info->external_sym)
				     + (fh->isymBase + cur_sdx)
				     * external_sym_size),
				    &sh2);
		    stabstring2 = debug_info->ss + fh->issBase + sh2.iss;
		    len2 = strlen (stabstring2);

		    /* Concatinate stabstring2 with stabstring1.  */
		    if (stabstring
		     && stabstring != debug_info->ss + fh->issBase + sh.iss)
		      stabstring = xrealloc (stabstring, len + len2 + 1);
		    else
		      {
			stabstring = xmalloc (len + len2 + 1);
			strcpy (stabstring, stabstring1);
		      }
		    strcpy (stabstring + len, stabstring2);
		    len += len2;
		  }

		switch (type_code)
		  {
		    char *p;

		    /* Standard, external, non-debugger, symbols.  */

		  case N_TEXT | N_EXT:
		  case N_NBTEXT | N_EXT:
		    sh.value += ANOFFSET (objfile->section_offsets,
					  SECT_OFF_TEXT (objfile));
		    goto record_it;

		  case N_DATA | N_EXT:
		  case N_NBDATA | N_EXT:
		    sh.value += ANOFFSET (objfile->section_offsets,
					  SECT_OFF_DATA (objfile));
		    goto record_it;

		  case N_BSS:
		  case N_BSS | N_EXT:
		  case N_NBBSS | N_EXT:
		  case N_SETV | N_EXT:		/* FIXME, is this in BSS?  */
		    sh.value += ANOFFSET (objfile->section_offsets,
					  SECT_OFF_BSS (objfile));
		    goto record_it;

		  case N_ABS | N_EXT:
		  record_it:
		    continue;

		  /* Standard, local, non-debugger, symbols.  */

		  case N_NBTEXT:

		    /* We need to be able to deal with both N_FN or
		       N_TEXT, because we have no way of knowing
		       whether the sys-supplied ld or GNU ld was used
		       to make the executable.  Sequents throw in
		       another wrinkle -- they renumbered N_FN.  */

		  case N_FN:
		  case N_FN_SEQ:
		  case N_TEXT:
		    continue;

		  case N_DATA:
		    sh.value += ANOFFSET (objfile->section_offsets,
					  SECT_OFF_DATA (objfile));
		    goto record_it;

		  case N_UNDF | N_EXT:
		    continue;		/* Just undefined, not COMMON.  */

		  case N_UNDF:
		    continue;

		    /* Lots of symbol types we can just ignore.  */

		  case N_ABS:
		  case N_NBDATA:
		  case N_NBBSS:
		    continue;

		    /* Keep going . . .  */

		    /*
		     * Special symbol types for GNU
		     */
		  case N_INDR:
		  case N_INDR | N_EXT:
		  case N_SETA:
		  case N_SETA | N_EXT:
		  case N_SETT:
		  case N_SETT | N_EXT:
		  case N_SETD:
		  case N_SETD | N_EXT:
		  case N_SETB:
		  case N_SETB | N_EXT:
		  case N_SETV:
		    continue;

		    /*
		     * Debugger symbols
		     */

		  case N_SO:
		    {
		      CORE_ADDR valu;
		      static int prev_so_symnum = -10;
		      static int first_so_symnum;
		      const char *p;
		      int prev_textlow_not_set;

		      valu = sh.value + ANOFFSET (objfile->section_offsets,
						  SECT_OFF_TEXT (objfile));

		      prev_textlow_not_set = textlow_not_set;

		      /* A zero value is probably an indication for the
			 SunPRO 3.0 compiler.  end_psymtab explicitly tests
			 for zero, so don't relocate it.  */

		      if (sh.value == 0
			  && gdbarch_sofun_address_maybe_missing (gdbarch))
			{
			  textlow_not_set = 1;
			  valu = 0;
			}
		      else
			textlow_not_set = 0;

		      past_first_source_file = 1;

		      if (prev_so_symnum != symnum - 1)
			{		/* Here if prev stab wasn't N_SO.  */
			  first_so_symnum = symnum;

			  if (pst)
			    {
			      pst = (struct partial_symtab *) 0;
			      includes_used = 0;
			      dependencies_used = 0;
			    }
			}

		      prev_so_symnum = symnum;

		      /* End the current partial symtab and start a
			 new one.  */

		      /* SET_NAMESTRING ();*/
		      namestring = stabstring;

		      /* Null name means end of .o file.  Don't start a new
			 one.  */
		      if (*namestring == '\000')
			continue;

		      /* Some compilers (including gcc) emit a pair of
			 initial N_SOs.  The first one is a directory name;
			 the second the file name.  If pst exists, is
			 empty, and has a filename ending in '/', we assume
			 the previous N_SO was a directory name.  */
		      p = lbasename (namestring);
		      if (p != namestring && *p == '\000')
			continue;		/* Simply ignore directory
						   name SOs.  */

		      /* Some other compilers (C++ ones in particular) emit
			 useless SOs for non-existant .c files.  We ignore
			 all subsequent SOs that immediately follow the
			 first.  */

		      if (!pst)
			pst = save_pst;
		      continue;
		    }

		  case N_BINCL:
		    continue;

		  case N_SOL:
		    {
		      enum language tmp_language;

		      /* Mark down an include file in the current psymtab.  */

		      /* SET_NAMESTRING (); */
		      namestring = stabstring;

		      tmp_language
			= deduce_language_from_filename (namestring);

		      /* Only change the psymtab's language if we've
			 learned something useful (eg. tmp_language is not
			 language_unknown).  In addition, to match what
			 start_subfile does, never change from C++ to
			 C.  */
		      if (tmp_language != language_unknown
			  && (tmp_language != language_c
			      || psymtab_language != language_cplus))
			psymtab_language = tmp_language;

		      /* In C++, one may expect the same filename to come
			 round many times, when code is coming alternately
			 from the main file and from inline functions in
			 other files.  So I check to see if this is a file
			 we've seen before -- either the main source file,
			 or a previously included file.

			 This seems to be a lot of time to be spending on
			 N_SOL, but things like "break c-exp.y:435" need to
			 work (I suppose the psymtab_include_list could be
			 hashed or put in a binary tree, if profiling shows
			 this is a major hog).  */
		      if (pst && filename_cmp (namestring, pst->filename) == 0)
			continue;

		      {
			int i;

			for (i = 0; i < includes_used; i++)
			  if (filename_cmp (namestring,
					    psymtab_include_list[i]) == 0)
			    {
			      i = -1;
			      break;
			    }
			if (i == -1)
			  continue;
		      }

		      psymtab_include_list[includes_used++] = namestring;
		      if (includes_used >= includes_allocated)
			{
			  const char **orig = psymtab_include_list;

			  psymtab_include_list = (const char **)
			    alloca ((includes_allocated *= 2) *
				    sizeof (const char *));
			  memcpy (psymtab_include_list, orig,
				  includes_used * sizeof (const char *));
			}
		      continue;
		    }
		  case N_LSYM:	    /* Typedef or automatic variable.  */
		  case N_STSYM:	    /* Data seg var -- static  */
		  case N_LCSYM:	    /* BSS      "  */
		  case N_ROSYM:	    /* Read-only data seg var -- static.  */
		  case N_NBSTS:	    /* Gould nobase.  */
		  case N_NBLCS:	    /* symbols.  */
		  case N_FUN:
		  case N_GSYM:	    /* Global (extern) variable; can be
				       data or bss (sigh FIXME).  */

		    /* Following may probably be ignored; I'll leave them here
		       for now (until I do Pascal and Modula 2 extensions).  */

		  case N_PC:	    /* I may or may not need this; I
				       suspect not.  */
		  case N_M2C:	    /* I suspect that I can ignore this
				       here.  */
		  case N_SCOPE:	    /* Same.  */

		    /*    SET_NAMESTRING (); */
		    namestring = stabstring;
		    p = (char *) strchr (namestring, ':');
		    if (!p)
		      continue;	    /* Not a debugging symbol.  */



		    /* Main processing section for debugging symbols which
		       the initial read through the symbol tables needs to
		       worry about.  If we reach this point, the symbol
		       which we are considering is definitely one we are
		       interested in.  p must also contain the (valid)
		       index into the namestring which indicates the
		       debugging type symbol.  */

		    switch (p[1])
		      {
		      case 'S':
			sh.value += ANOFFSET (objfile->section_offsets,
					      SECT_OFF_DATA (objfile));

			if (gdbarch_static_transform_name_p (gdbarch))
			  namestring = gdbarch_static_transform_name
					 (gdbarch, namestring);

			add_psymbol_to_list (namestring, p - namestring, 1,
					     VAR_DOMAIN, LOC_STATIC,
					     &objfile->static_psymbols,
					     0, sh.value,
					     psymtab_language, objfile);
			continue;
		      case 'G':
			sh.value += ANOFFSET (objfile->section_offsets,
					      SECT_OFF_DATA (objfile));
			/* The addresses in these entries are reported
			   to be wrong.  See the code that reads 'G's
			   for symtabs.  */
			add_psymbol_to_list (namestring, p - namestring, 1,
					     VAR_DOMAIN, LOC_STATIC,
					     &objfile->global_psymbols,
					     0, sh.value,
					     psymtab_language, objfile);
			continue;

		      case 'T':
			/* When a 'T' entry is defining an anonymous enum, it
			   may have a name which is the empty string, or a
			   single space.  Since they're not really defining a
			   symbol, those shouldn't go in the partial symbol
			   table.  We do pick up the elements of such enums at
			   'check_enum:', below.  */
			if (p >= namestring + 2
			    || (p == namestring + 1
				&& namestring[0] != ' '))
			  {
			    add_psymbol_to_list (namestring, p - namestring, 1,
						 STRUCT_DOMAIN, LOC_TYPEDEF,
						 &objfile->static_psymbols,
						 sh.value, 0,
						 psymtab_language, objfile);
			    if (p[2] == 't')
			      {
				/* Also a typedef with the same name.  */
				add_psymbol_to_list (namestring,
						     p - namestring, 1,
						     VAR_DOMAIN, LOC_TYPEDEF,
						     &objfile->static_psymbols,
						     sh.value, 0,
						     psymtab_language,
						     objfile);
				p += 1;
			      }
			  }
			goto check_enum;
		      case 't':
			if (p != namestring)	/* a name is there, not
						   just :T...  */
			  {
			    add_psymbol_to_list (namestring, p - namestring, 1,
						 VAR_DOMAIN, LOC_TYPEDEF,
						 &objfile->static_psymbols,
						 sh.value, 0,
						 psymtab_language, objfile);
			  }
		      check_enum:
			/* If this is an enumerated type, we need to add
			   all the enum constants to the partial symbol
			   table.  This does not cover enums without names,
			   e.g. "enum {a, b} c;" in C, but fortunately
			   those are rare.  There is no way for GDB to find
			   those from the enum type without spending too
			   much time on it.  Thus to solve this problem,
			   the compiler needs to put out the enum in a
			   nameless type.  GCC2 does this.  */

			/* We are looking for something of the form
			   <name> ":" ("t" | "T") [<number> "="] "e"
			   {<constant> ":" <value> ","} ";".  */

			/* Skip over the colon and the 't' or 'T'.  */
			p += 2;
			/* This type may be given a number.  Also, numbers
			   can come in pairs like (0,26).  Skip over it.  */
			while ((*p >= '0' && *p <= '9')
			       || *p == '(' || *p == ',' || *p == ')'
			       || *p == '=')
			  p++;

			if (*p++ == 'e')
			  {
			    /* The aix4 compiler emits extra crud before
			       the members.  */
			    if (*p == '-')
			      {
				/* Skip over the type (?).  */
				while (*p != ':')
				  p++;

				/* Skip over the colon.  */
				p++;
			      }

			    /* We have found an enumerated type.  */
			    /* According to comments in read_enum_type
			       a comma could end it instead of a semicolon.
			       I don't know where that happens.
			       Accept either.  */
			    while (*p && *p != ';' && *p != ',')
			      {
				char *q;

				/* Check for and handle cretinous dbx
				   symbol name continuation!  */
				if (*p == '\\' || (*p == '?' && p[1] == '\0'))
				  p = next_symbol_text (objfile);

				/* Point to the character after the name
				   of the enum constant.  */
				for (q = p; *q && *q != ':'; q++)
				  ;
				/* Note that the value doesn't matter for
				   enum constants in psymtabs, just in
				   symtabs.  */
				add_psymbol_to_list (p, q - p, 1,
						     VAR_DOMAIN, LOC_CONST,
						     &objfile->static_psymbols,
						     0, 0, psymtab_language,
						     objfile);
				/* Point past the name.  */
				p = q;
				/* Skip over the value.  */
				while (*p && *p != ',')
				  p++;
				/* Advance past the comma.  */
				if (*p)
				  p++;
			      }
			  }
			continue;
		      case 'c':
			/* Constant, e.g. from "const" in Pascal.  */
			add_psymbol_to_list (namestring, p - namestring, 1,
					     VAR_DOMAIN, LOC_CONST,
					     &objfile->static_psymbols,
					     sh.value, 0, psymtab_language,
					     objfile);
			continue;

		      case 'f':
			if (! pst)
			  {
			    int name_len = p - namestring;
			    char *name = xmalloc (name_len + 1);

			    memcpy (name, namestring, name_len);
			    name[name_len] = '\0';
			    function_outside_compilation_unit_complaint (name);
			    xfree (name);
			  }
			sh.value += ANOFFSET (objfile->section_offsets,
					      SECT_OFF_TEXT (objfile));
			add_psymbol_to_list (namestring, p - namestring, 1,
					     VAR_DOMAIN, LOC_BLOCK,
					     &objfile->static_psymbols,
					     0, sh.value,
					     psymtab_language, objfile);
			continue;

			/* Global functions were ignored here, but now they
			   are put into the global psymtab like one would
			   expect.  They're also in the minimal symbol
			   table.  */
		      case 'F':
			if (! pst)
			  {
			    int name_len = p - namestring;
			    char *name = xmalloc (name_len + 1);

			    memcpy (name, namestring, name_len);
			    name[name_len] = '\0';
			    function_outside_compilation_unit_complaint (name);
			    xfree (name);
			  }
			sh.value += ANOFFSET (objfile->section_offsets,
					      SECT_OFF_TEXT (objfile));
			add_psymbol_to_list (namestring, p - namestring, 1,
					     VAR_DOMAIN, LOC_BLOCK,
					     &objfile->global_psymbols,
					     0, sh.value,
					     psymtab_language, objfile);
			continue;

			/* Two things show up here (hopefully); static
			   symbols of local scope (static used inside
			   braces) or extensions of structure symbols.  We
			   can ignore both.  */
		      case 'V':
		      case '(':
		      case '0':
		      case '1':
		      case '2':
		      case '3':
		      case '4':
		      case '5':
		      case '6':
		      case '7':
		      case '8':
		      case '9':
		      case '-':
		      case '#':		/* For symbol identification (used
					   in live ranges).  */
			continue;

		      case ':':
			/* It is a C++ nested symbol.  We don't need to
			   record it (I don't think); if we try to look up
			   foo::bar::baz, then symbols for the symtab
			   containing foo should get read in, I think.  */
			/* Someone says sun cc puts out symbols like
			   /foo/baz/maclib::/usr/local/bin/maclib,
			   which would get here with a symbol type of ':'.  */
			continue;

		      default:
			/* Unexpected symbol descriptor.  The second and
			   subsequent stabs of a continued stab can show up
			   here.  The question is whether they ever can
			   mimic a normal stab--it would be nice if not,
			   since we certainly don't want to spend the time
			   searching to the end of every string looking for
			   a backslash.  */

			complaint (&symfile_complaints,
				   _("unknown symbol descriptor `%c'"), p[1]);

			/* Ignore it; perhaps it is an extension that we don't
			   know about.  */
			continue;
		      }

		  case N_EXCL:
		    continue;

		  case N_ENDM:
		    /* Solaris 2 end of module, finish current partial
		       symbol table.  END_PSYMTAB will set
		       pst->texthigh to the proper value, which is
		       necessary if a module compiled without
		       debugging info follows this module.  */
		    if (pst
			&& gdbarch_sofun_address_maybe_missing (gdbarch))
		      {
			pst = (struct partial_symtab *) 0;
			includes_used = 0;
			dependencies_used = 0;
		      }
		    continue;

		  case N_RBRAC:
		    if (sh.value > save_pst->texthigh)
		      save_pst->texthigh = sh.value;
		    continue;
		  case N_EINCL:
		  case N_DSLINE:
		  case N_BSLINE:
		  case N_SSYM:		/* Claim: Structure or union
					   element.  Hopefully, I can
					   ignore this.  */
		  case N_ENTRY:		/* Alternate entry point; can
					   ignore.  */
		  case N_MAIN:		/* Can definitely ignore this.   */
		  case N_CATCH:		/* These are GNU C++ extensions.  */
		  case N_EHDECL:	/* that can safely be ignored here.  */
		  case N_LENG:
		  case N_BCOMM:
		  case N_ECOMM:
		  case N_ECOML:
		  case N_FNAME:
		  case N_SLINE:
		  case N_RSYM:
		  case N_PSYM:
		  case N_LBRAC:
		  case N_NSYMS:		/* Ultrix 4.0: symbol count */
		  case N_DEFD:			/* GNU Modula-2 */
		  case N_ALIAS:		/* SunPro F77: alias name, ignore
					   for now.  */

		  case N_OBJ:		/* Useless types from Solaris.  */
		  case N_OPT:
		    /* These symbols aren't interesting; don't worry about
		       them.  */

		    continue;

		  default:
		    /* If we haven't found it yet, ignore it.  It's
		       probably some new type we don't know about yet.  */
		    complaint (&symfile_complaints,
			       _("unknown symbol type %s"),
			       hex_string (type_code)); /* CUR_SYMBOL_TYPE */
		    continue;
		  }
		if (stabstring
		    && stabstring != debug_info->ss + fh->issBase + sh.iss)
		  xfree (stabstring);
	      }
	      /* end - Handle continuation */
	    }
	}
      else
	{
	  for (cur_sdx = 0; cur_sdx < fh->csym;)
	    {
	      char *name;
	      enum address_class class;

	      (*swap_sym_in) (cur_bfd,
			      ((char *) debug_info->external_sym
			       + ((fh->isymBase + cur_sdx)
				  * external_sym_size)),
			      &sh);

	      if (ECOFF_IS_STAB (&sh))
		{
		  cur_sdx++;
		  continue;
		}

	      /* Non absolute static symbols go into the minimal table.  */
	      if (SC_IS_UNDEF (sh.sc) || sh.sc == scNil
		  || (sh.index == indexNil
		      && (sh.st != stStatic || sh.sc == scAbs)))
		{
		  /* FIXME, premature?  */
		  cur_sdx++;
		  continue;
		}

	      name = debug_info->ss + fh->issBase + sh.iss;

	      switch (sh.sc)
		{
		case scText:
		case scRConst:
		  /* The value of a stEnd symbol is the displacement from the
		     corresponding start symbol value, do not relocate it.  */
		  if (sh.st != stEnd)
		    sh.value += ANOFFSET (objfile->section_offsets,
					  SECT_OFF_TEXT (objfile));
		  break;
		case scData:
		case scSData:
		case scRData:
		case scPData:
		case scXData:
		  sh.value += ANOFFSET (objfile->section_offsets,
					SECT_OFF_DATA (objfile));
		  break;
		case scBss:
		case scSBss:
		  sh.value += ANOFFSET (objfile->section_offsets,
					SECT_OFF_BSS (objfile));
		  break;
		}

	      switch (sh.st)
		{
		  CORE_ADDR high;
		  CORE_ADDR procaddr;
		  int new_sdx;

		case stStaticProc:
		  prim_record_minimal_symbol_and_info (name, sh.value,
						       mst_file_text,
						       SECT_OFF_TEXT (objfile),
						       objfile);

		  /* FALLTHROUGH */

		case stProc:
		  /* Ignore all parameter symbol records.  */
		  if (sh.index >= hdr->iauxMax)
		    {
		      /* Should not happen, but does when cross-compiling
		         with the MIPS compiler.  FIXME -- pull later.  */
		      index_complaint (name);
		      new_sdx = cur_sdx + 1;	/* Don't skip at all.  */
		    }
		  else
		    new_sdx = AUX_GET_ISYM (fh->fBigendian,
					    (debug_info->external_aux
					     + fh->iauxBase
					     + sh.index));

		  if (new_sdx <= cur_sdx)
		    {
		      /* This should not happen either... FIXME.  */
		      complaint (&symfile_complaints,
				 _("bad proc end in aux found from symbol %s"),
				 name);
		      new_sdx = cur_sdx + 1;	/* Don't skip backward.  */
		    }

                  /* For stProc symbol records, we need to check the
                     storage class as well, as only (stProc, scText)
                     entries represent "real" procedures - See the
                     Compaq document titled "Object File / Symbol Table
                     Format Specification" for more information.  If the
                     storage class is not scText, we discard the whole
                     block of symbol records for this stProc.  */
                  if (sh.st == stProc && sh.sc != scText)
                    goto skip;

		  /* Usually there is a local and a global stProc symbol
		     for a function.  This means that the function name
		     has already been entered into the mimimal symbol table
		     while processing the global symbols in pass 2 above.
		     One notable exception is the PROGRAM name from
		     f77 compiled executables, it is only put out as
		     local stProc symbol, and a global MAIN__ stProc symbol
		     points to it.  It doesn't matter though, as gdb is
		     still able to find the PROGRAM name via the partial
		     symbol table, and the MAIN__ symbol via the minimal
		     symbol table.  */
		  if (sh.st == stProc)
		    add_psymbol_to_list (name, strlen (name), 1,
					 VAR_DOMAIN, LOC_BLOCK,
					 &objfile->global_psymbols,
				    0, sh.value, psymtab_language, objfile);
		  else
		    add_psymbol_to_list (name, strlen (name), 1,
					 VAR_DOMAIN, LOC_BLOCK,
					 &objfile->static_psymbols,
				    0, sh.value, psymtab_language, objfile);

		  procaddr = sh.value;

		  cur_sdx = new_sdx;
		  (*swap_sym_in) (cur_bfd,
				  ((char *) debug_info->external_sym
				   + ((fh->isymBase + cur_sdx - 1)
				      * external_sym_size)),
				  &sh);
		  if (sh.st != stEnd)
		    continue;

		  /* Kludge for Irix 5.2 zero fh->adr.  */
		  if (!relocatable
		      && (pst->textlow == 0 || procaddr < pst->textlow))
		    pst->textlow = procaddr;

		  high = procaddr + sh.value;
		  if (high > pst->texthigh)
		    pst->texthigh = high;
		  continue;

		case stStatic:	/* Variable */
		  if (SC_IS_DATA (sh.sc))
		    prim_record_minimal_symbol_and_info (name, sh.value,
							 mst_file_data,
							 SECT_OFF_DATA (objfile),
							 objfile);
		  else
		    prim_record_minimal_symbol_and_info (name, sh.value,
							 mst_file_bss,
							 SECT_OFF_BSS (objfile),
							 objfile);
		  class = LOC_STATIC;
		  break;

		case stIndirect:	/* Irix5 forward declaration */
		  /* Skip forward declarations from Irix5 cc.  */
		  goto skip;

		case stTypedef:	/* Typedef */
		  /* Skip typedefs for forward declarations and opaque
		     structs from alpha and mips cc.  */
		  if (sh.iss == 0 || has_opaque_xref (fh, &sh))
		    goto skip;
		  class = LOC_TYPEDEF;
		  break;

		case stConstant:	/* Constant decl */
		  class = LOC_CONST;
		  break;

		case stUnion:
		case stStruct:
		case stEnum:
		case stBlock:	/* { }, str, un, enum */
		  /* Do not create a partial symbol for cc unnamed aggregates
		     and gcc empty aggregates.  */
		  if ((sh.sc == scInfo
		       || SC_IS_COMMON (sh.sc))
		      && sh.iss != 0
		      && sh.index != cur_sdx + 2)
		    {
		      add_psymbol_to_list (name, strlen (name), 1,
					   STRUCT_DOMAIN, LOC_TYPEDEF,
					   &objfile->static_psymbols,
					   0, (CORE_ADDR) 0,
					   psymtab_language, objfile);
		    }
		  handle_psymbol_enumerators (objfile, fh, sh.st, sh.value);

		  /* Skip over the block.  */
		  new_sdx = sh.index;
		  if (new_sdx <= cur_sdx)
		    {
		      /* This happens with the Ultrix kernel.  */
		      complaint (&symfile_complaints,
				 _("bad aux index at block symbol %s"), name);
		      new_sdx = cur_sdx + 1;	/* Don't skip backward.  */
		    }
		  cur_sdx = new_sdx;
		  continue;

		case stFile:	/* File headers */
		case stLabel:	/* Labels */
		case stEnd:	/* Ends of files */
		  goto skip;

		case stLocal:	/* Local variables */
		  /* Normally these are skipped because we skip over
		     all blocks we see.  However, these can occur
		     as visible symbols in a .h file that contains code.  */
		  goto skip;

		default:
		  /* Both complaints are valid:  one gives symbol name,
		     the other the offending symbol type.  */
		  complaint (&symfile_complaints, _("unknown local symbol %s"),
			     name);
		  complaint (&symfile_complaints, _("with type %d"), sh.st);
		  cur_sdx++;
		  continue;
		}
	      /* Use this gdb symbol.  */
	      add_psymbol_to_list (name, strlen (name), 1,
				   VAR_DOMAIN, class,
				   &objfile->static_psymbols,
				   0, sh.value, psymtab_language, objfile);
	    skip:
	      cur_sdx++;	/* Go to next file symbol.  */
	    }

	  /* Now do enter the external symbols.  */
	  ext_ptr = &extern_tab[fdr_to_pst[f_idx].globals_offset];
	  cur_sdx = fdr_to_pst[f_idx].n_globals;
	  PST_PRIVATE (save_pst)->extern_count = cur_sdx;
	  PST_PRIVATE (save_pst)->extern_tab = ext_ptr;
	  for (; --cur_sdx >= 0; ext_ptr++)
	    {
	      enum address_class class;
	      SYMR *psh;
	      char *name;
	      CORE_ADDR svalue;

	      if (ext_ptr->ifd != f_idx)
		internal_error (__FILE__, __LINE__,
				_("failed internal consistency check"));
	      psh = &ext_ptr->asym;

	      /* Do not add undefined symbols to the partial symbol table.  */
	      if (SC_IS_UNDEF (psh->sc) || psh->sc == scNil)
		continue;

	      svalue = psh->value;
	      switch (psh->sc)
		{
		case scText:
		case scRConst:
		  svalue += ANOFFSET (objfile->section_offsets,
				      SECT_OFF_TEXT (objfile));
		  break;
		case scData:
		case scSData:
		case scRData:
		case scPData:
		case scXData:
		  svalue += ANOFFSET (objfile->section_offsets,
				      SECT_OFF_DATA (objfile));
		  break;
		case scBss:
		case scSBss:
		  svalue += ANOFFSET (objfile->section_offsets,
				      SECT_OFF_BSS (objfile));
		  break;
		}

	      switch (psh->st)
		{
		case stNil:
		  /* These are generated for static symbols in .o files,
		     ignore them.  */
		  continue;
		case stProc:
		case stStaticProc:
		  /* External procedure symbols have been entered
		     into the minimal symbol table in pass 2 above.
		     Ignore them, as parse_external will ignore them too.  */
		  continue;
		case stLabel:
		  class = LOC_LABEL;
		  break;
		default:
		  unknown_ext_complaint (debug_info->ssext + psh->iss);
		  /* Fall through, pretend it's global.  */
		case stGlobal:
		  /* Global common symbols are resolved by the runtime loader,
		     ignore them.  */
		  if (SC_IS_COMMON (psh->sc))
		    continue;

		  class = LOC_STATIC;
		  break;
		}
	      name = debug_info->ssext + psh->iss;
	      add_psymbol_to_list (name, strlen (name), 1,
				   VAR_DOMAIN, class,
				   &objfile->global_psymbols,
				   0, svalue,
				   psymtab_language, objfile);
	    }
	}

      /* Link pst to FDR.  end_psymtab returns NULL if the psymtab was
         empty and put on the free list.  */
      fdr_to_pst[f_idx].pst = end_psymtab (objfile, save_pst,
					psymtab_include_list, includes_used,
					   -1, save_pst->texthigh,
		       dependency_list, dependencies_used, textlow_not_set);
      includes_used = 0;
      dependencies_used = 0;

      /* The objfile has its functions reordered if this partial symbol
         table overlaps any other partial symbol table.
         We cannot assume a reordered objfile if a partial symbol table
         is contained within another partial symbol table, as partial symbol
         tables for include files with executable code are contained
         within the partial symbol table for the including source file,
         and we do not want to flag the objfile reordered for these cases.

         This strategy works well for Irix-5.2 shared libraries, but we
         might have to use a more elaborate (and slower) algorithm for
         other cases.  */
      save_pst = fdr_to_pst[f_idx].pst;
      if (save_pst != NULL
	  && save_pst->textlow != 0
	  && !(objfile->flags & OBJF_REORDERED))
	{
	  ALL_OBJFILE_PSYMTABS (objfile, pst)
	  {
	    if (save_pst != pst
		&& save_pst->textlow >= pst->textlow
		&& save_pst->textlow < pst->texthigh
		&& save_pst->texthigh > pst->texthigh)
	      {
		objfile->flags |= OBJF_REORDERED;
		break;
	      }
	  }
	}
    }

  /* Now scan the FDRs for dependencies.  */
  for (f_idx = 0; f_idx < hdr->ifdMax; f_idx++)
    {
      fh = f_idx + debug_info->fdr;
      pst = fdr_to_pst[f_idx].pst;

      if (pst == (struct partial_symtab *) NULL)
	continue;

      /* This should catch stabs-in-ecoff.  */
      if (fh->crfd <= 1)
	continue;

      /* Skip the first file indirect entry as it is a self dependency for
         source files or a reverse .h -> .c dependency for header files.  */
      pst->number_of_dependencies = 0;
      pst->dependencies =
	((struct partial_symtab **)
	 obstack_alloc (&objfile->objfile_obstack,
			((fh->crfd - 1)
			 * sizeof (struct partial_symtab *))));
      for (s_idx = 1; s_idx < fh->crfd; s_idx++)
	{
	  RFDT rh;

	  (*swap_rfd_in) (cur_bfd,
			  ((char *) debug_info->external_rfd
			   + (fh->rfdBase + s_idx) * external_rfd_size),
			  &rh);
	  if (rh < 0 || rh >= hdr->ifdMax)
	    {
	      complaint (&symfile_complaints, _("bad file number %ld"), rh);
	      continue;
	    }

	  /* Skip self dependencies of header files.  */
	  if (rh == f_idx)
	    continue;

	  /* Do not add to dependeny list if psymtab was empty.  */
	  if (fdr_to_pst[rh].pst == (struct partial_symtab *) NULL)
	    continue;
	  pst->dependencies[pst->number_of_dependencies++]
	    = fdr_to_pst[rh].pst;
	}
    }

  /* Remove the dummy psymtab created for -O3 images above, if it is
     still empty, to enable the detection of stripped executables.  */
  if (objfile->psymtabs->next == NULL
      && objfile->psymtabs->number_of_dependencies == 0
      && objfile->psymtabs->n_global_syms == 0
      && objfile->psymtabs->n_static_syms == 0)
    objfile->psymtabs = NULL;
  do_cleanups (old_chain);
}

/* If the current psymbol has an enumerated type, we need to add
   all the enum constants to the partial symbol table.  */

static void
handle_psymbol_enumerators (struct objfile *objfile, FDR *fh, int stype,
			    CORE_ADDR svalue)
{
  const bfd_size_type external_sym_size = debug_swap->external_sym_size;
  void (*const swap_sym_in) (bfd *, void *, SYMR *) = debug_swap->swap_sym_in;
  char *ext_sym = ((char *) debug_info->external_sym
		   + ((fh->isymBase + cur_sdx + 1) * external_sym_size));
  SYMR sh;
  TIR tir;

  switch (stype)
    {
    case stEnum:
      break;

    case stBlock:
      /* It is an enumerated type if the next symbol entry is a stMember
         and its auxiliary index is indexNil or its auxiliary entry
         is a plain btNil or btVoid.
         Alpha cc -migrate enums are recognized by a zero index and
         a zero symbol value.
         DU 4.0 cc enums are recognized by a member type of btEnum without
         qualifiers and a zero symbol value.  */
      (*swap_sym_in) (cur_bfd, ext_sym, &sh);
      if (sh.st != stMember)
	return;

      if (sh.index == indexNil
	  || (sh.index == 0 && svalue == 0))
	break;
      (*debug_swap->swap_tir_in) (fh->fBigendian,
				  &(debug_info->external_aux
				    + fh->iauxBase + sh.index)->a_ti,
				  &tir);
      if ((tir.bt != btNil
	   && tir.bt != btVoid
	   && (tir.bt != btEnum || svalue != 0))
	  || tir.tq0 != tqNil)
	return;
      break;

    default:
      return;
    }

  for (;;)
    {
      char *name;

      (*swap_sym_in) (cur_bfd, ext_sym, &sh);
      if (sh.st != stMember)
	break;
      name = debug_info->ss + cur_fdr->issBase + sh.iss;

      /* Note that the value doesn't matter for enum constants
         in psymtabs, just in symtabs.  */
      add_psymbol_to_list (name, strlen (name), 1,
			   VAR_DOMAIN, LOC_CONST,
			   &objfile->static_psymbols, 0,
			   (CORE_ADDR) 0, psymtab_language, objfile);
      ext_sym += external_sym_size;
    }
}

/* Get the next symbol.  OBJFILE is unused.  */

static char *
mdebug_next_symbol_text (struct objfile *objfile)
{
  SYMR sh;

  cur_sdx++;
  (*debug_swap->swap_sym_in) (cur_bfd,
			      ((char *) debug_info->external_sym
			       + ((cur_fdr->isymBase + cur_sdx)
				  * debug_swap->external_sym_size)),
			      &sh);
  return debug_info->ss + cur_fdr->issBase + sh.iss;
}

/* Ancillary function to psymtab_to_symtab().  Does all the work
   for turning the partial symtab PST into a symtab, recurring
   first on all dependent psymtabs.  The argument FILENAME is
   only passed so we can see in debug stack traces what file
   is being read.

   This function has a split personality, based on whether the
   symbol table contains ordinary ecoff symbols, or stabs-in-ecoff.
   The flow of control and even the memory allocation differs.  FIXME.  */

static void
psymtab_to_symtab_1 (struct objfile *objfile,
		     struct partial_symtab *pst, const char *filename)
{
  bfd_size_type external_sym_size;
  bfd_size_type external_pdr_size;
  void (*swap_sym_in) (bfd *, void *, SYMR *);
  void (*swap_pdr_in) (bfd *, void *, PDR *);
  int i;
  struct symtab *st = NULL;
  FDR *fh;
  struct linetable *lines;
  CORE_ADDR lowest_pdr_addr = 0;
  int last_symtab_ended = 0;

  if (pst->readin)
    return;
  pst->readin = 1;

  /* Read in all partial symbtabs on which this one is dependent.
     NOTE that we do have circular dependencies, sigh.  We solved
     that by setting pst->readin before this point.  */

  for (i = 0; i < pst->number_of_dependencies; i++)
    if (!pst->dependencies[i]->readin)
      {
	/* Inform about additional files to be read in.  */
	if (info_verbose)
	  {
	    fputs_filtered (" ", gdb_stdout);
	    wrap_here ("");
	    fputs_filtered ("and ", gdb_stdout);
	    wrap_here ("");
	    printf_filtered ("%s...",
			     pst->dependencies[i]->filename);
	    wrap_here ("");	/* Flush output */
	    gdb_flush (gdb_stdout);
	  }
	/* We only pass the filename for debug purposes.  */
	psymtab_to_symtab_1 (objfile, pst->dependencies[i],
			     pst->dependencies[i]->filename);
      }

  /* Do nothing if this is a dummy psymtab.  */

  if (pst->n_global_syms == 0 && pst->n_static_syms == 0
      && pst->textlow == 0 && pst->texthigh == 0)
    return;

  /* Now read the symbols for this symtab.  */

  cur_bfd = CUR_BFD (pst);
  debug_swap = DEBUG_SWAP (pst);
  debug_info = DEBUG_INFO (pst);
  pending_list = PENDING_LIST (pst);
  external_sym_size = debug_swap->external_sym_size;
  external_pdr_size = debug_swap->external_pdr_size;
  swap_sym_in = debug_swap->swap_sym_in;
  swap_pdr_in = debug_swap->swap_pdr_in;
  mdebugread_objfile = objfile;
  cur_fd = FDR_IDX (pst);
  fh = ((cur_fd == -1)
	? (FDR *) NULL
	: debug_info->fdr + cur_fd);
  cur_fdr = fh;

  /* See comment in parse_partial_symbols about the @@stabs sentinel.  */
  processing_gcc_compilation = 0;
  if (fh != (FDR *) NULL && fh->csym >= 2)
    {
      SYMR sh;

      (*swap_sym_in) (cur_bfd,
		      ((char *) debug_info->external_sym
		       + (fh->isymBase + 1) * external_sym_size),
		      &sh);
      if (strcmp (debug_info->ss + fh->issBase + sh.iss,
		  stabs_symbol) == 0)
	{
	  /* We indicate that this is a GCC compilation so that certain
	     features will be enabled in stabsread/dbxread.  */
	  processing_gcc_compilation = 2;
	}
    }

  if (processing_gcc_compilation != 0)
    {
      struct gdbarch *gdbarch = get_objfile_arch (objfile);

      /* This symbol table contains stabs-in-ecoff entries.  */

      /* Parse local symbols first.  */

      if (fh->csym <= 2)	/* FIXME, this blows psymtab->symtab ptr.  */
	{
	  mdebugread_objfile = NULL;
	  return;
	}
      for (cur_sdx = 2; cur_sdx < fh->csym; cur_sdx++)
	{
	  SYMR sh;
	  char *name;
	  CORE_ADDR valu;

	  (*swap_sym_in) (cur_bfd,
			  (((char *) debug_info->external_sym)
			   + (fh->isymBase + cur_sdx) * external_sym_size),
			  &sh);
	  name = debug_info->ss + fh->issBase + sh.iss;
	  valu = sh.value;
	  /* XXX This is a hack.  It will go away!  */
	  if (ECOFF_IS_STAB (&sh) || (name[0] == '#'))
	    {
	      int type_code = ECOFF_UNMARK_STAB (sh.index);

	      /* We should never get non N_STAB symbols here, but they
	         should be harmless, so keep process_one_symbol from
	         complaining about them.  */
	      if (type_code & N_STAB)
		{
		  /* If we found a trailing N_SO with no name, process
                     it here instead of in process_one_symbol, so we
                     can keep a handle to its symtab.  The symtab
                     would otherwise be ended twice, once in
                     process_one_symbol, and once after this loop.  */
		  if (type_code == N_SO
		      && get_last_source_file ()
		      && previous_stab_code != (unsigned char) N_SO
		      && *name == '\000')
		    {
		      valu += ANOFFSET (pst->section_offsets,
					SECT_OFF_TEXT (objfile));
		      previous_stab_code = N_SO;
		      st = end_symtab (valu, objfile,
				       SECT_OFF_TEXT (objfile));
		      end_stabs ();
		      last_symtab_ended = 1;
		    }
		  else
		    {
		      last_symtab_ended = 0;
		      process_one_symbol (type_code, 0, valu, name,
					  pst->section_offsets, objfile);
		    }
		}
	      /* Similarly a hack.  */
	      else if (name[0] == '#')
		{
		  process_one_symbol (N_SLINE, 0, valu, name,
				      pst->section_offsets, objfile);
		}
	      if (type_code == N_FUN)
		{
		  /* Make up special symbol to contain
		     procedure specific info.  */
		  struct mdebug_extra_func_info *e =
		    ((struct mdebug_extra_func_info *)
		     obstack_alloc (&mdebugread_objfile->objfile_obstack,
				    sizeof (struct mdebug_extra_func_info)));
		  struct symbol *s = new_symbol (MDEBUG_EFI_SYMBOL_NAME);

		  memset (e, 0, sizeof (struct mdebug_extra_func_info));
		  SYMBOL_DOMAIN (s) = LABEL_DOMAIN;
		  SYMBOL_ACLASS_INDEX (s) = LOC_CONST;
		  SYMBOL_TYPE (s) = objfile_type (objfile)->builtin_void;
		  SYMBOL_VALUE_BYTES (s) = (gdb_byte *) e;
		  e->pdr.framereg = -1;
		  add_symbol_to_list (s, &local_symbols);
		}
	    }
	  else if (sh.st == stLabel)
	    {
	      if (sh.index == indexNil)
		{
		  /* This is what the gcc2_compiled and __gnu_compiled_*
		     show up as.  So don't complain.  */
		  ;
		}
	      else
		{
		  /* Handle encoded stab line number.  */
		  valu += ANOFFSET (pst->section_offsets,
				    SECT_OFF_TEXT (objfile));
		  record_line (current_subfile, sh.index,
			       gdbarch_addr_bits_remove (gdbarch, valu));
		}
	    }
	  else if (sh.st == stProc || sh.st == stStaticProc
		   || sh.st == stStatic || sh.st == stEnd)
	    /* These are generated by gcc-2.x, do not complain.  */
	    ;
	  else
	    complaint (&symfile_complaints,
		       _("unknown stabs symbol %s"), name);
	}

      if (! last_symtab_ended)
	{
	  st = end_symtab (pst->texthigh, objfile,
			   SECT_OFF_TEXT (objfile));
	  end_stabs ();
	}

      /* There used to be a call to sort_blocks here, but this should not
         be necessary for stabs symtabs.  And as sort_blocks modifies the
         start address of the GLOBAL_BLOCK to the FIRST_LOCAL_BLOCK,
         it did the wrong thing if the first procedure in a file was
         generated via asm statements.  */

      /* Fill in procedure info next.  */
      if (fh->cpd > 0)
	{
	  PDR *pr_block;
	  struct cleanup *old_chain;
	  char *pdr_ptr;
	  char *pdr_end;
	  PDR *pdr_in;
	  PDR *pdr_in_end;

	  pr_block = (PDR *) xmalloc (fh->cpd * sizeof (PDR));
	  old_chain = make_cleanup (xfree, pr_block);

	  pdr_ptr = ((char *) debug_info->external_pdr
		     + fh->ipdFirst * external_pdr_size);
	  pdr_end = pdr_ptr + fh->cpd * external_pdr_size;
	  pdr_in = pr_block;
	  for (;
	       pdr_ptr < pdr_end;
	       pdr_ptr += external_pdr_size, pdr_in++)
	    {
	      (*swap_pdr_in) (cur_bfd, pdr_ptr, pdr_in);

	      /* Determine lowest PDR address, the PDRs are not always
	         sorted.  */
	      if (pdr_in == pr_block)
		lowest_pdr_addr = pdr_in->adr;
	      else if (pdr_in->adr < lowest_pdr_addr)
		lowest_pdr_addr = pdr_in->adr;
	    }

	  pdr_in = pr_block;
	  pdr_in_end = pdr_in + fh->cpd;
	  for (; pdr_in < pdr_in_end; pdr_in++)
	    parse_procedure (pdr_in, st, pst);

	  do_cleanups (old_chain);
	}
    }
  else
    {
      /* This symbol table contains ordinary ecoff entries.  */

      int maxlines, size;
      EXTR *ext_ptr;

      if (fh == 0)
	{
	  maxlines = 0;
	  st = new_symtab ("unknown", 0, objfile);
	}
      else
	{
	  maxlines = 2 * fh->cline;
	  st = new_symtab (pst->filename, maxlines, objfile);

	  /* The proper language was already determined when building
	     the psymtab, use it.  */
	  st->language = PST_PRIVATE (pst)->pst_language;
	}

      psymtab_language = st->language;

      lines = LINETABLE (st);

      /* Get a new lexical context.  */

      push_parse_stack ();
      top_stack->cur_st = st;
      top_stack->cur_block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (st),
						STATIC_BLOCK);
      BLOCK_START (top_stack->cur_block) = pst->textlow;
      BLOCK_END (top_stack->cur_block) = 0;
      top_stack->blocktype = stFile;
      top_stack->cur_type = 0;
      top_stack->procadr = 0;
      top_stack->numargs = 0;
      found_ecoff_debugging_info = 0;

      if (fh)
	{
	  char *sym_ptr;
	  char *sym_end;

	  /* Parse local symbols first.  */
	  sym_ptr = ((char *) debug_info->external_sym
		     + fh->isymBase * external_sym_size);
	  sym_end = sym_ptr + fh->csym * external_sym_size;
	  while (sym_ptr < sym_end)
	    {
	      SYMR sh;
	      int c;

	      (*swap_sym_in) (cur_bfd, sym_ptr, &sh);
	      c = parse_symbol (&sh,
				debug_info->external_aux + fh->iauxBase,
				sym_ptr, fh->fBigendian,
				pst->section_offsets, objfile);
	      sym_ptr += c * external_sym_size;
	    }

	  /* Linenumbers.  At the end, check if we can save memory.
	     parse_lines has to look ahead an arbitrary number of PDR
	     structures, so we swap them all first.  */
	  if (fh->cpd > 0)
	    {
	      PDR *pr_block;
	      struct cleanup *old_chain;
	      char *pdr_ptr;
	      char *pdr_end;
	      PDR *pdr_in;
	      PDR *pdr_in_end;

	      pr_block = (PDR *) xmalloc (fh->cpd * sizeof (PDR));

	      old_chain = make_cleanup (xfree, pr_block);

	      pdr_ptr = ((char *) debug_info->external_pdr
			 + fh->ipdFirst * external_pdr_size);
	      pdr_end = pdr_ptr + fh->cpd * external_pdr_size;
	      pdr_in = pr_block;
	      for (;
		   pdr_ptr < pdr_end;
		   pdr_ptr += external_pdr_size, pdr_in++)
		{
		  (*swap_pdr_in) (cur_bfd, pdr_ptr, pdr_in);

		  /* Determine lowest PDR address, the PDRs are not always
		     sorted.  */
		  if (pdr_in == pr_block)
		    lowest_pdr_addr = pdr_in->adr;
		  else if (pdr_in->adr < lowest_pdr_addr)
		    lowest_pdr_addr = pdr_in->adr;
		}

	      parse_lines (fh, pr_block, lines, maxlines,
			   pst, lowest_pdr_addr);
	      if (lines->nitems < fh->cline)
		lines = shrink_linetable (lines);

	      /* Fill in procedure info next.  */
	      pdr_in = pr_block;
	      pdr_in_end = pdr_in + fh->cpd;
	      for (; pdr_in < pdr_in_end; pdr_in++)
		parse_procedure (pdr_in, 0, pst);

	      do_cleanups (old_chain);
	    }
	}

      size = lines->nitems;
      if (size > 1)
	--size;
      LINETABLE (st) = obstack_copy (&mdebugread_objfile->objfile_obstack,
				     lines,
				     (sizeof (struct linetable)
				      + size * sizeof (lines->item)));
      xfree (lines);

      /* .. and our share of externals.
         XXX use the global list to speed up things here.  How?
         FIXME, Maybe quit once we have found the right number of ext's?  */
      top_stack->cur_st = st;
      top_stack->cur_block
	= BLOCKVECTOR_BLOCK (BLOCKVECTOR (top_stack->cur_st),
			     GLOBAL_BLOCK);
      top_stack->blocktype = stFile;

      ext_ptr = PST_PRIVATE (pst)->extern_tab;
      for (i = PST_PRIVATE (pst)->extern_count; --i >= 0; ext_ptr++)
	parse_external (ext_ptr, fh->fBigendian,
			pst->section_offsets, objfile);

      /* If there are undefined symbols, tell the user.
         The alpha has an undefined symbol for every symbol that is
         from a shared library, so tell the user only if verbose is on.  */
      if (info_verbose && n_undef_symbols)
	{
	  printf_filtered (_("File %s contains %d unresolved references:"),
			   symtab_to_filename_for_display (st),
			   n_undef_symbols);
	  printf_filtered ("\n\t%4d variables\n\t%4d "
			   "procedures\n\t%4d labels\n",
			   n_undef_vars, n_undef_procs, n_undef_labels);
	  n_undef_symbols = n_undef_labels = n_undef_vars = n_undef_procs = 0;

	}
      pop_parse_stack ();

      st->primary = 1;

      sort_blocks (st);
    }

  /* Now link the psymtab and the symtab.  */
  pst->symtab = st;

  mdebugread_objfile = NULL;
}

/* Ancillary parsing procedures.  */

/* Return 1 if the symbol pointed to by SH has a cross reference
   to an opaque aggregate type, else 0.  */

static int
has_opaque_xref (FDR *fh, SYMR *sh)
{
  TIR tir;
  union aux_ext *ax;
  RNDXR rn[1];
  unsigned int rf;

  if (sh->index == indexNil)
    return 0;

  ax = debug_info->external_aux + fh->iauxBase + sh->index;
  (*debug_swap->swap_tir_in) (fh->fBigendian, &ax->a_ti, &tir);
  if (tir.bt != btStruct && tir.bt != btUnion && tir.bt != btEnum)
    return 0;

  ax++;
  (*debug_swap->swap_rndx_in) (fh->fBigendian, &ax->a_rndx, rn);
  if (rn->rfd == 0xfff)
    rf = AUX_GET_ISYM (fh->fBigendian, ax + 1);
  else
    rf = rn->rfd;
  if (rf != -1)
    return 0;
  return 1;
}

/* Lookup the type at relative index RN.  Return it in TPP
   if found and in any event come up with its name PNAME.
   BIGEND says whether aux symbols are big-endian or not (from fh->fBigendian).
   Return value says how many aux symbols we ate.  */

static int
cross_ref (int fd, union aux_ext *ax, struct type **tpp,
	   enum type_code type_code,
	   /* Use to alloc new type if none is found.  */
	   char **pname, int bigend, char *sym_name)
{
  RNDXR rn[1];
  unsigned int rf;
  int result = 1;
  FDR *fh;
  char *esh;
  SYMR sh;
  int xref_fd;
  struct mdebug_pending *pend;

  *tpp = (struct type *) NULL;

  (*debug_swap->swap_rndx_in) (bigend, &ax->a_rndx, rn);

  /* Escape index means 'the next one'.  */
  if (rn->rfd == 0xfff)
    {
      result++;
      rf = AUX_GET_ISYM (bigend, ax + 1);
    }
  else
    {
      rf = rn->rfd;
    }

  /* mips cc uses a rf of -1 for opaque struct definitions.
     Set TYPE_FLAG_STUB for these types so that check_typedef will
     resolve them if the struct gets defined in another compilation unit.  */
  if (rf == -1)
    {
      *pname = "<undefined>";
      *tpp = init_type (type_code, 0, TYPE_FLAG_STUB,
			(char *) NULL, mdebugread_objfile);
      return result;
    }

  /* mips cc uses an escaped rn->index of 0 for struct return types
     of procedures that were compiled without -g.  These will always remain
     undefined.  */
  if (rn->rfd == 0xfff && rn->index == 0)
    {
      *pname = "<undefined>";
      return result;
    }

  /* Find the relative file descriptor and the symbol in it.  */
  fh = get_rfd (fd, rf);
  xref_fd = fh - debug_info->fdr;

  if (rn->index >= fh->csym)
    {
      /* File indirect entry is corrupt.  */
      *pname = "<illegal>";
      bad_rfd_entry_complaint (sym_name, xref_fd, rn->index);
      return result;
    }

  /* If we have processed this symbol then we left a forwarding
     pointer to the type in the pending list.  If not, we`ll put
     it in a list of pending types, to be processed later when
     the file will be.  In any event, we collect the name for the
     type here.  */

  esh = ((char *) debug_info->external_sym
	 + ((fh->isymBase + rn->index)
	    * debug_swap->external_sym_size));
  (*debug_swap->swap_sym_in) (cur_bfd, esh, &sh);

  /* Make sure that this type of cross reference can be handled.  */
  if ((sh.sc != scInfo
       || (sh.st != stBlock && sh.st != stTypedef && sh.st != stIndirect
	   && sh.st != stStruct && sh.st != stUnion
	   && sh.st != stEnum))
      && (sh.st != stBlock || !SC_IS_COMMON (sh.sc)))
    {
      /* File indirect entry is corrupt.  */
      *pname = "<illegal>";
      bad_rfd_entry_complaint (sym_name, xref_fd, rn->index);
      return result;
    }

  *pname = debug_info->ss + fh->issBase + sh.iss;

  pend = is_pending_symbol (fh, esh);
  if (pend)
    *tpp = pend->t;
  else
    {
      /* We have not yet seen this type.  */

      if ((sh.iss == 0 && sh.st == stTypedef) || sh.st == stIndirect)
	{
	  TIR tir;

	  /* alpha cc puts out a stTypedef with a sh.iss of zero for
	     two cases:
	     a) forward declarations of structs/unions/enums which are not
	     defined in this compilation unit.
	     For these the type will be void.  This is a bad design decision
	     as cross referencing across compilation units is impossible
	     due to the missing name.
	     b) forward declarations of structs/unions/enums/typedefs which
	     are defined later in this file or in another file in the same
	     compilation unit.  Irix5 cc uses a stIndirect symbol for this.
	     Simply cross reference those again to get the true type.
	     The forward references are not entered in the pending list and
	     in the symbol table.  */

	  (*debug_swap->swap_tir_in) (bigend,
				      &(debug_info->external_aux
					+ fh->iauxBase + sh.index)->a_ti,
				      &tir);
	  if (tir.tq0 != tqNil)
	    complaint (&symfile_complaints,
		       _("illegal tq0 in forward typedef for %s"), sym_name);
	  switch (tir.bt)
	    {
	    case btVoid:
	      *tpp = init_type (type_code, 0, 0, (char *) NULL,
				mdebugread_objfile);
	      *pname = "<undefined>";
	      break;

	    case btStruct:
	    case btUnion:
	    case btEnum:
	      cross_ref (xref_fd,
			 (debug_info->external_aux
			  + fh->iauxBase + sh.index + 1),
			 tpp, type_code, pname,
			 fh->fBigendian, sym_name);
	      break;

	    case btTypedef:
	      /* Follow a forward typedef.  This might recursively
	         call cross_ref till we get a non typedef'ed type.
	         FIXME: This is not correct behaviour, but gdb currently
	         cannot handle typedefs without type copying.  Type
	         copying is impossible as we might have mutual forward
	         references between two files and the copied type would not
	         get filled in when we later parse its definition.  */
	      *tpp = parse_type (xref_fd,
				 debug_info->external_aux + fh->iauxBase,
				 sh.index,
				 (int *) NULL,
				 fh->fBigendian,
				 debug_info->ss + fh->issBase + sh.iss);
	      add_pending (fh, esh, *tpp);
	      break;

	    default:
	      complaint (&symfile_complaints,
			 _("illegal bt %d in forward typedef for %s"), tir.bt,
			 sym_name);
	      *tpp = init_type (type_code, 0, 0, (char *) NULL,
				mdebugread_objfile);
	      break;
	    }
	  return result;
	}
      else if (sh.st == stTypedef)
	{
	  /* Parse the type for a normal typedef.  This might recursively call
	     cross_ref till we get a non typedef'ed type.
	     FIXME: This is not correct behaviour, but gdb currently
	     cannot handle typedefs without type copying.  But type copying is
	     impossible as we might have mutual forward references between
	     two files and the copied type would not get filled in when
	     we later parse its definition.   */
	  *tpp = parse_type (xref_fd,
			     debug_info->external_aux + fh->iauxBase,
			     sh.index,
			     (int *) NULL,
			     fh->fBigendian,
			     debug_info->ss + fh->issBase + sh.iss);
	}
      else
	{
	  /* Cross reference to a struct/union/enum which is defined
	     in another file in the same compilation unit but that file
	     has not been parsed yet.
	     Initialize the type only, it will be filled in when
	     it's definition is parsed.  */
	  *tpp = init_type (type_code, 0, 0, (char *) NULL, mdebugread_objfile);
	}
      add_pending (fh, esh, *tpp);
    }

  /* We used one auxent normally, two if we got a "next one" rf.  */
  return result;
}


/* Quick&dirty lookup procedure, to avoid the MI ones that require
   keeping the symtab sorted.  */

static struct symbol *
mylookup_symbol (char *name, struct block *block,
		 domain_enum domain, enum address_class class)
{
  struct block_iterator iter;
  int inc;
  struct symbol *sym;

  inc = name[0];
  ALL_BLOCK_SYMBOLS (block, iter, sym)
    {
      if (SYMBOL_LINKAGE_NAME (sym)[0] == inc
	  && SYMBOL_DOMAIN (sym) == domain
	  && SYMBOL_CLASS (sym) == class
	  && strcmp (SYMBOL_LINKAGE_NAME (sym), name) == 0)
	return sym;
    }

  block = BLOCK_SUPERBLOCK (block);
  if (block)
    return mylookup_symbol (name, block, domain, class);
  return 0;
}


/* Add a new symbol S to a block B.  */

static void
add_symbol (struct symbol *s, struct symtab *symtab, struct block *b)
{
  SYMBOL_SYMTAB (s) = symtab;
  dict_add_symbol (BLOCK_DICT (b), s);
}

/* Add a new block B to a symtab S.  */

static void
add_block (struct block *b, struct symtab *s)
{
  struct blockvector *bv = BLOCKVECTOR (s);

  bv = (struct blockvector *) xrealloc ((void *) bv,
					(sizeof (struct blockvector)
					 + BLOCKVECTOR_NBLOCKS (bv)
					 * sizeof (bv->block)));
  if (bv != BLOCKVECTOR (s))
    BLOCKVECTOR (s) = bv;

  BLOCKVECTOR_BLOCK (bv, BLOCKVECTOR_NBLOCKS (bv)++) = b;
}

/* Add a new linenumber entry (LINENO,ADR) to a linevector LT.
   MIPS' linenumber encoding might need more than one byte
   to describe it, LAST is used to detect these continuation lines.

   Combining lines with the same line number seems like a bad idea.
   E.g: There could be a line number entry with the same line number after the
   prologue and GDB should not ignore it (this is a better way to find
   a prologue than mips_skip_prologue).
   But due to the compressed line table format there are line number entries
   for the same line which are needed to bridge the gap to the next
   line number entry.  These entries have a bogus address info with them
   and we are unable to tell them from intended duplicate line number
   entries.
   This is another reason why -ggdb debugging format is preferable.  */

static int
add_line (struct linetable *lt, int lineno, CORE_ADDR adr, int last)
{
  /* DEC c89 sometimes produces zero linenos which confuse gdb.
     Change them to something sensible.  */
  if (lineno == 0)
    lineno = 1;
  if (last == 0)
    last = -2;			/* Make sure we record first line.  */

  if (last == lineno)		/* Skip continuation lines.  */
    return lineno;

  lt->item[lt->nitems].line = lineno;
  lt->item[lt->nitems++].pc = adr << 2;
  return lineno;
}

/* Sorting and reordering procedures.  */

/* Blocks with a smaller low bound should come first.  */

static int
compare_blocks (const void *arg1, const void *arg2)
{
  LONGEST addr_diff;
  struct block **b1 = (struct block **) arg1;
  struct block **b2 = (struct block **) arg2;

  addr_diff = (BLOCK_START ((*b1))) - (BLOCK_START ((*b2)));
  if (addr_diff == 0)
    return (BLOCK_END ((*b2))) - (BLOCK_END ((*b1)));
  return addr_diff;
}

/* Sort the blocks of a symtab S.
   Reorder the blocks in the blockvector by code-address,
   as required by some MI search routines.  */

static void
sort_blocks (struct symtab *s)
{
  struct blockvector *bv = BLOCKVECTOR (s);

  if (BLOCKVECTOR_NBLOCKS (bv) <= FIRST_LOCAL_BLOCK)
    {
      /* Cosmetic */
      if (BLOCK_END (BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK)) == 0)
	BLOCK_START (BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK)) = 0;
      if (BLOCK_END (BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK)) == 0)
	BLOCK_START (BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK)) = 0;
      return;
    }
  /*
   * This is very unfortunate: normally all functions are compiled in
   * the order they are found, but if the file is compiled -O3 things
   * are very different.  It would be nice to find a reliable test
   * to detect -O3 images in advance.
   */
  if (BLOCKVECTOR_NBLOCKS (bv) > FIRST_LOCAL_BLOCK + 1)
    qsort (&BLOCKVECTOR_BLOCK (bv, FIRST_LOCAL_BLOCK),
	   BLOCKVECTOR_NBLOCKS (bv) - FIRST_LOCAL_BLOCK,
	   sizeof (struct block *),
	   compare_blocks);

  {
    CORE_ADDR high = 0;
    int i, j = BLOCKVECTOR_NBLOCKS (bv);

    for (i = FIRST_LOCAL_BLOCK; i < j; i++)
      if (high < BLOCK_END (BLOCKVECTOR_BLOCK (bv, i)))
	high = BLOCK_END (BLOCKVECTOR_BLOCK (bv, i));
    BLOCK_END (BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK)) = high;
  }

  BLOCK_START (BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK)) =
    BLOCK_START (BLOCKVECTOR_BLOCK (bv, FIRST_LOCAL_BLOCK));

  BLOCK_START (BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK)) =
    BLOCK_START (BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK));
  BLOCK_END (BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK)) =
    BLOCK_END (BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK));
}


/* Constructor/restructor/destructor procedures.  */

/* Allocate a new symtab for NAME.  Needs an estimate of how many
   linenumbers MAXLINES we'll put in it.  */

static struct symtab *
new_symtab (const char *name, int maxlines, struct objfile *objfile)
{
  struct symtab *s = allocate_symtab (name, objfile);

  LINETABLE (s) = new_linetable (maxlines);

  /* All symtabs must have at least two blocks.  */
  BLOCKVECTOR (s) = new_bvect (2);
  BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK)
    = new_block (NON_FUNCTION_BLOCK);
  BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK)
    = new_block (NON_FUNCTION_BLOCK);
  BLOCK_SUPERBLOCK (BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK)) =
    BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);

  s->debugformat = "ECOFF";
  return (s);
}

/* Allocate a new partial_symtab NAME.  */

static struct partial_symtab *
new_psymtab (char *name, struct objfile *objfile)
{
  struct partial_symtab *psymtab;

  psymtab = allocate_psymtab (name, objfile);
  psymtab->section_offsets = objfile->section_offsets;

  /* Keep a backpointer to the file's symbols.  */

  psymtab->read_symtab_private = obstack_alloc (&objfile->objfile_obstack,
						sizeof (struct symloc));
  memset (psymtab->read_symtab_private, 0, sizeof (struct symloc));
  CUR_BFD (psymtab) = cur_bfd;
  DEBUG_SWAP (psymtab) = debug_swap;
  DEBUG_INFO (psymtab) = debug_info;
  PENDING_LIST (psymtab) = pending_list;

  /* The way to turn this into a symtab is to call...  */
  psymtab->read_symtab = mdebug_read_symtab;
  return (psymtab);
}


/* Allocate a linetable array of the given SIZE.  Since the struct
   already includes one item, we subtract one when calculating the
   proper size to allocate.  */

static struct linetable *
new_linetable (int size)
{
  struct linetable *l;

  if (size > 1)
    --size;
  size = size * sizeof (l->item) + sizeof (struct linetable);
  l = (struct linetable *) xmalloc (size);
  l->nitems = 0;
  return l;
}

/* Oops, too big.  Shrink it.  This was important with the 2.4 linetables,
   I am not so sure about the 3.4 ones.

   Since the struct linetable already includes one item, we subtract one when
   calculating the proper size to allocate.  */

static struct linetable *
shrink_linetable (struct linetable *lt)
{
  return (struct linetable *) xrealloc ((void *) lt,
					(sizeof (struct linetable)
					 + ((lt->nitems - 1)
					    * sizeof (lt->item))));
}

/* Allocate and zero a new blockvector of NBLOCKS blocks.  */

static struct blockvector *
new_bvect (int nblocks)
{
  struct blockvector *bv;
  int size;

  size = sizeof (struct blockvector) + nblocks * sizeof (struct block *);
  bv = (struct blockvector *) xzalloc (size);

  BLOCKVECTOR_NBLOCKS (bv) = nblocks;

  return bv;
}

/* Allocate and zero a new block, and set its BLOCK_DICT.  If function
   is non-zero, assume the block is associated to a function, and make
   sure that the symbols are stored linearly; otherwise, store them
   hashed.  */

static struct block *
new_block (enum block_type type)
{
  /* FIXME: carlton/2003-09-11: This should use allocate_block to
     allocate the block.  Which, in turn, suggests that the block
     should be allocated on an obstack.  */
  struct block *retval = xzalloc (sizeof (struct block));

  if (type == FUNCTION_BLOCK)
    BLOCK_DICT (retval) = dict_create_linear_expandable ();
  else
    BLOCK_DICT (retval) = dict_create_hashed_expandable ();

  return retval;
}

/* Create a new symbol with printname NAME.  */

static struct symbol *
new_symbol (char *name)
{
  struct symbol *s = allocate_symbol (mdebugread_objfile);

  SYMBOL_SET_LANGUAGE (s, psymtab_language,
		       &mdebugread_objfile->objfile_obstack);
  SYMBOL_SET_NAMES (s, name, strlen (name), 1, mdebugread_objfile);
  return s;
}

/* Create a new type with printname NAME.  */

static struct type *
new_type (char *name)
{
  struct type *t;

  t = alloc_type (mdebugread_objfile);
  TYPE_NAME (t) = name;
  INIT_CPLUS_SPECIFIC (t);
  return t;
}

/* Read ECOFF debugging information from a BFD section.  This is
   called from elfread.c.  It parses the section into a
   ecoff_debug_info struct, and then lets the rest of the file handle
   it as normal.  */

void
elfmdebug_build_psymtabs (struct objfile *objfile,
			  const struct ecoff_debug_swap *swap, asection *sec)
{
  bfd *abfd = objfile->obfd;
  struct ecoff_debug_info *info;
  struct cleanup *back_to;

  /* FIXME: It's not clear whether we should be getting minimal symbol
     information from .mdebug in an ELF file, or whether we will.
     Re-initialize the minimal symbol reader in case we do.  */

  init_minimal_symbol_collection ();
  back_to = make_cleanup_discard_minimal_symbols ();

  info = ((struct ecoff_debug_info *)
	  obstack_alloc (&objfile->objfile_obstack,
			 sizeof (struct ecoff_debug_info)));

  if (!(*swap->read_debug_info) (abfd, sec, info))
    error (_("Error reading ECOFF debugging information: %s"),
	   bfd_errmsg (bfd_get_error ()));

  mdebug_build_psymtabs (objfile, swap, info);

  install_minimal_symbols (objfile);
  do_cleanups (back_to);
}

void
_initialize_mdebugread (void)
{
  basic_type_data = register_objfile_data ();

  mdebug_register_index
    = register_symbol_register_impl (LOC_REGISTER, &mdebug_register_funcs);
  mdebug_regparm_index
    = register_symbol_register_impl (LOC_REGPARM_ADDR, &mdebug_register_funcs);
}
@


1.142
log
@	* ada-lang.c (ada_decode_symbol): Check and set 'ada_mangled'.
	Use symbol's obstack, not an objfile.
	* coffread.c (process_coff_symbol): Update.
	* dwarf2read.c (fixup_go_packaging, new_symbol_full): Update.
	* jv-lang.c (add_class_symbol): Update.
	* mdebugread.c (new_symbol): Update.
	* minsyms.c (prim_record_minimal_symbol_full)
	(terminate_minimal_symbol_table): Update.
	* psymtab.c (add_psymbol_to_bcache): Clear entire symbol.  Update.
	* stabsread.c (define_symbol, read_enum_type): Update.
	* symtab.c (symbol_set_demangled_name, symbol_get_demangled_name):
	Handle Ada specially.
	(symbol_set_language): Add 'obstack' argument.
	(symbol_set_names): Update.
	(symbol_natural_name, symbol_demangled_name): Always use
	ada_decode_symbol.
	* symtab.h (struct general_symbol_info)
	<language_specific::obstack>: New field.
	<ada_mangled>: New field.
	(SYMBOL_SET_LANGUAGE): Add 'obstack' argument.
	(symbol_set_language): Update.
@
text
@a2258 1
  asection *bfd_section;
a2263 1
        bfd_section = bfd_get_section_by_name (cur_bfd, ".text");
a2266 1
        bfd_section = bfd_get_section_by_name (cur_bfd, ".data");
a2269 1
        bfd_section = bfd_get_section_by_name (cur_bfd, ".bss");
a2272 1
        bfd_section = bfd_get_section_by_name (cur_bfd, ".sdata");
a2275 1
        bfd_section = bfd_get_section_by_name (cur_bfd, ".sbss");
a2278 1
        bfd_section = bfd_get_section_by_name (cur_bfd, ".rdata");
a2281 1
        bfd_section = bfd_get_section_by_name (cur_bfd, ".init");
a2284 1
        bfd_section = bfd_get_section_by_name (cur_bfd, ".xdata");
a2287 1
        bfd_section = bfd_get_section_by_name (cur_bfd, ".pdata");
a2290 1
        bfd_section = bfd_get_section_by_name (cur_bfd, ".fini");
a2293 1
        bfd_section = bfd_get_section_by_name (cur_bfd, ".rconst");
a2297 1
        bfd_section = bfd_get_section_by_name (cur_bfd, ".tlsdata");
a2302 1
        bfd_section = bfd_get_section_by_name (cur_bfd, ".tlsbss");
a2307 1
        bfd_section = NULL;
d2311 1
a2311 1
                                       section, bfd_section, objfile);
d3498 1
a3498 1
						       NULL, objfile);
a3583 1
							 NULL,
a3588 1
							 NULL,
@


1.141
log
@	* coffread.c (process_coff_symbol, coff_read_enum_type): Call
	allocate_symbol.
	* dwarf2read.c (fixup_go_packaging): Call allocate_symbol.
	(read_func_scope): Call allocate_template_symbol.
	(new_symbol_full): Call allocate_symbol.
	* jit.c (finalize_symtab): Call allocate_symbol.
	* jv-lang.c (add_class_symbol): Call allocate_symbol.
	* mdebugread.c (parse_symbol, new_block): Call allocate_symbol.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_end): Call allocate_symbol.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): New functions.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): Declare.
	* xcoffread.c (process_xcoff_symbol): Call initialize_symbol.
@
text
@d4881 2
a4882 1
  SYMBOL_SET_LANGUAGE (s, psymtab_language);
@


1.140
log
@2013-03-20  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>

	PR symtab/8421:
	* coffread.c (coff_register_index): New global.
	(process_coff_symbol, coff_read_enum_type): Set
	SYMBOL_ACLASS_INDEX.
	(_initialize_coffread): Initialize new global.
	* dwarf2loc.c (locexpr_find_frame_base_location)
	(dwarf2_block_frame_base_locexpr_funcs)
	(loclist_find_frame_base_location)
	(dwarf2_block_frame_base_loclist_funcs): New.
	(dwarf_expr_frame_base_1): Call SYMBOL_BLOCK_OPS, remove internal_error.
	(dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Add location_has_loclist.
	* dwarf2loc.h (dwarf2_block_frame_base_locexpr_funcs)
	(dwarf2_block_frame_base_loclist_funcs): New.
	* dwarf2read.c (dwarf2_locexpr_index, dwarf2_loclist_index)
	(dwarf2_locexpr_block_index, dwarf2_loclist_block_index): New
	globals.
	(read_func_scope): Update.
	(fixup_go_packaging, mark_common_block_symbol_computed)
	(var_decode_location, new_symbol_full, dwarf2_const_value):
	Set SYMBOL_ACLASS_INDEX.
	(dwarf2_symbol_mark_computed): Likewise.  Add 'is_block' argument.
	(_initialize_dwarf2_read): Initialize new globals.
	* jit.c (finalize_symtab): Set SYMBOL_ACLASS_INDEX.
	* jv-lang.c (add_class_symbol): Set SYMBOL_ACLASS_INDEX.
	* mdebugread.c (mdebug_register_index, mdebug_regparm_index): New
	globals.
	(parse_symbol, psymtab_to_symtab_1): Set SYMBOL_ACLASS_INDEX.
	(_initialize_mdebugread): Initialize new globals.
	* psympriv.h (struct partial_symbol) <aclass>: Update comment.
	* stabsread.c (patch_block_stabs): Set SYMBOL_ACLASS_INDEX.
	(stab_register_index, stab_regparm_index): New globals.
	(define_symbol, read_enum_type, common_block_end): Set
	SYMBOL_ACLASS_INDEX.
	(_initialize_stabsread): Initialize new globals.
	* symtab.c (next_aclass_value, symbol_impl, symbol_impls): New
	globals.
	(MAX_SYMBOL_IMPLS): New define.
	(register_symbol_computed_impl, register_symbol_block_impl)
	(register_symbol_register_impl)
	(initialize_ordinary_address_classes): New functions.
	(_initialize_symtab): Call initialize_ordinary_address_classes.
	* symtab.h (enum address_class) <LOC_FINAL_VALUE>: New constant.
	(struct symbol_impl): New.
	(SYMBOL_ACLASS_BITS): New define.
	(struct symbol) <aclass, ops>: Remove fields.
	<aclass_index>: New field.
	(symbol_impls): Declare.
	(SYMBOL_CLASS, SYMBOL_COMPUTED_OPS, SYMBOL_REGISTER_OPS): Redefine.
	(SYMBOL_IMPL, SYMBOL_ACLASS_INDEX): New defines.
	(register_symbol_computed_impl, register_symbol_block_impl)
	(register_symbol_register_impl): Declare.
	(struct symbol_computed_ops): Add location_has_loclist.
	(struct symbol_block_ops): New.
	(SYMBOL_BLOCK_OPS): New.
	* xcoffread.c (process_xcoff_symbol): Set SYMBOL_ACLASS_INDEX.
@
text
@d1051 1
a1051 4
		enum_sym = ((struct symbol *)
			    obstack_alloc (&mdebugread_objfile->objfile_obstack,
					   sizeof (struct symbol)));
		memset (enum_sym, 0, sizeof (struct symbol));
d4879 1
a4879 3
  struct symbol *s = ((struct symbol *)
		      obstack_alloc (&mdebugread_objfile->objfile_obstack,
				     sizeof (struct symbol)));
a4880 1
  memset (s, 0, sizeof (*s));
@


1.139
log
@gdb/
	* ada-lang.c (user_select_syms): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	* breakpoint.c (print_breakpoint_location, resolve_sal_pc): Likewise.
	(clear_command): New variable sal_fullname, initialize it.  Replace
	compare_filenames_for_search by filename_cmp with sal_fullname.
	(say_where, update_static_tracepoint): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	* cli/cli-cmds.c (edit_command, list_command, ambiguous_line_spec):
	Likewise.
	* dwarf2read.c: Include source.h.
	(fixup_go_packaging): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* linespec.c (add_sal_to_sals): Rename variable filename to fullname.
	Replace symtab->filename refererences by symtab_to_filename_for_display
	calls.
	(create_sals_line_offset, convert_linespec_to_sals): New variable
	fullname, initialize it, replace symtab->filename reference by the
	variable.
	* linux-fork.c: Include source.h.
	(info_checkpoints_command): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* macroscope.c (sal_macro_scope): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	* mdebugread.c: Include source.h.
	(psymtab_to_symtab_1): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(mi_cmd_file_list_exec_source_files): Likewise.
	* printcmd.c: Include source.h.
	(build_address_symbolic): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* psymtab.c (partial_map_symtabs_matching_filename)
	(read_psymtabs_with_fullname): Call compare_filenames_for_search also
	with psymtab_to_fullname.
	* python/py-symtab.c (stpy_str): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	(stpy_get_filename): New variable filename, initialize it, use instead
	of symtab->filename refererences.
	(salpy_str): Make variable filename const char *.  Replace
	symtab->filename refererences by symtab_to_filename_for_display calls.
	* skip.c: Include source.h and filenames.h.
	(skip_file_command): Remove const from the symtab variable.  Replace
	symtab->filename refererences by symtab_to_fullname call.
	(function_name_is_marked_for_skip): New variables searched_for_fullname
	and fullname.  Use them to search also with symtab's fullname.
	* source.c (find_source_lines): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	(print_source_lines_base): New variable filename, use it instead of
	symtab->filename.  Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	(line_info, forward_search_command): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	(reverse_search_command): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.  New variable filename for it.
	* stack.c (frame_info): Likewise.
	* symmisc.c: Include source.h.
	(dump_objfile, dump_symtab_1, maintenance_print_symbols)
	(maintenance_info_symtabs): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* symtab.c (iterate_over_some_symtabs): Call
	compare_filenames_for_search also with symtab_to_fullname.
	(lookup_symbol_aux_quick, basic_lookup_transparent_type_quick): Replace
	symtab->filename refererences by symtab_to_filename_for_display calls.
	(find_line_symtab): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	(file_matches): Replace filename_cmp by compare_filenames_for_search.
	(print_symbol_info): Make the last parameter const char *.  New
	variable s_filename.  Use it in the function.
	(symtab_symbol_info): Make the last_filename variable const char *.
	Replace symtab->filename refererences by symtab_to_filename_for_display
	calls.
	(rbreak_command): New variable fullname.  Use it.  Replace
	symtab->filename refererence by symtab_to_filename_for_display call.
	* tracepoint.c (set_traceframe_context, trace_find_line_command)
	(print_one_static_tracepoint_marker): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	* tui/tui-source.c (tui_set_source_content): New variables filename and
	s_filename.  Replace symtab->filename refererences by this variable.
	Replace other symtab->filename refererences by
	symtab_to_filename_for_display calls.
@
text
@d545 5
d634 1
a634 4
	{
	  class = LOC_REGISTER;
	  SYMBOL_REGISTER_OPS (s) = &mdebug_register_funcs;
	}
d640 1
a640 1
      SYMBOL_CLASS (s) = class;
d669 1
a669 2
	  SYMBOL_CLASS (s) = LOC_REGISTER;
	  SYMBOL_REGISTER_OPS (s) = &mdebug_register_funcs;
d673 1
a673 1
	  SYMBOL_CLASS (s) = LOC_REF_ARG;
d677 1
a677 2
	  SYMBOL_CLASS (s) = LOC_REGPARM_ADDR;
	  SYMBOL_REGISTER_OPS (s) = &mdebug_register_funcs;
d681 1
a681 1
	  SYMBOL_CLASS (s) = LOC_ARG;
d692 1
a692 1
      SYMBOL_CLASS (s) = LOC_LABEL;	/* but not misused.  */
d734 1
a734 1
      SYMBOL_CLASS (s) = LOC_BLOCK;
d1059 1
a1059 1
		SYMBOL_CLASS (enum_sym) = LOC_CONST;
d1092 1
a1092 1
	SYMBOL_CLASS (s) = LOC_TYPEDEF;
d1148 1
a1148 1
	  SYMBOL_CLASS (s) = LOC_CONST;
d1288 1
a1288 1
      SYMBOL_CLASS (s) = LOC_TYPEDEF;
d4122 1
a4122 1
		  SYMBOL_CLASS (s) = LOC_CONST;
d4943 5
@


1.138
log
@	* symfile.h (obsavestring): Don't declare.
	* symfile.c (obsavestring): Remove.
	* ada-exp.y: Use obstack_copy0, not obsavestring.
	* ada-lang.c: Use obstack_copy0, not obsavestring.
	* coffread.c: Use obstack_copy0, not obsavestring.
	* cp-namespace.c: Use obstack_copy0, not obsavestring.
	* dbxread.c: Use obstack_copy0, not obsavestring.
	* dwarf2read.c: Use obstack_copy0, not obsavestring.
	* jit.c: Use obstack_copy0, not obsavestring.
	* mdebugread.c: Use obstack_copy0, not obsavestring.
	* psymtab.c: Use obstack_copy0, not obsavestring.
	* stabsread.c: Use obstack_copy0, not obsavestring.
	* xcoffread.c: Use obstack_copy0, not obsavestring.
@
text
@d61 1
d4347 2
a4348 1
			   st->filename, n_undef_symbols);
@


1.137
log
@	* buildsym.c (patch_subfile_names): Use set_last_source_file.
	(start_symtab): Make 'name' and 'dirname' const.  Use
	set_last_source_file.
	(restart_symtab, reset_symtab_globals): Use set_last_source_file.
	(last_source_file): Define.  Now static.
	(set_last_source_file, get_last_source_file): New functions.
	* buildsym.h (last_source_file): Don't declare.
	(start_symtab): Update.
	(set_last_source_file, get_last_source_file): Declare.
	* coffread.c (complete_symtab): Use set_last_source_file.
	(coff_end_symtab): Likewise.
	(coff_symtab_read): Use set_last_source_file, get_last_source_file.
	* dbxread.c (read_dbx_symtab, read_ofile_symtab): Use
	set_last_source_file.
	(process_one_symbol): Use get_last_source_file.
	* mdebugread.c (parse_partial_symbols): Use set_last_source_file.
	(psymtab_to_symtab_1): Use get_last_source_file.
	* xcoffread.c (process_linenos): Use get_last_source_file.
	(complete_symtab): Use set_last_source_file.
	(read_xcoff_symtab): Use set_last_source_file, get_last_source_file.
	(scan_xcoff_symtab): Use set_last_source_file.
@
text
@d1055 3
a1057 2
		  (enum_sym, obsavestring (f->name, strlen (f->name),
					   &mdebugread_objfile->objfile_obstack));
d1701 2
a1702 2
	      = obsavestring (name, strlen (name),
			      &mdebugread_objfile->objfile_obstack);
d1737 3
a1739 2
	    TYPE_NAME (tp) = obsavestring (name, strlen (name),
					   &mdebugread_objfile->objfile_obstack);
@


1.136
log
@gdb/
	* dbxread.c (dbx_psymtab_to_symtab): Delete the declaration.
	(dbx_read_symtab): New declaration.
	(dbx_psymtab_to_symtab): Delete.
	(dbx_read_symtab): Rename from dbx_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(start_psymtab): Caller update.
	* dwarf2read.c (dwarf2_psymtab_to_symtab): Delete the declaration.
	(dwarf2_read_symtab): New declaration.
	(dwarf2_psymtab_to_symtab): Delete.
	(dwarf2_read_symtab): Rename from dwarf2_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(create_partial_symtab): Caller update.
	* mdebugread.c (mdebug_psymtab_to_symtab): Delete.
	(mdebug_read_symtab): Rename from mdebug_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(parse_partial_symbols, new_psymtab): Caller update.
	* psympriv.h (struct partial_symtab) <read_symtab>: Exchange
	two parameters.
	* psymtab.c (psymtab_to_symtab): Caller update.
	* xcoffread.c (xcoff_psymtab_to_symtab): Delete.
	(xcoff_read_symtab): Rename from xcoff_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(xcoff_start_psymtab): Caller update.
@
text
@d2397 1
a2397 1
  last_source_file = NULL;
d4082 1
a4082 1
		      && last_source_file
@


1.135
log
@gdb/
2013-01-14  Yao Qi  <yao@@codesourcery.com>

	* dbxread.c (dbx_psymtab_to_symtab_1): Don't check PST is NULL.
	(dbx_psymtab_to_symtab): Likewise.
	* dwarf2read.c (dwarf2_psymtab_to_symtab): Likewise.
	* mdebugread.c (mdebug_psymtab_to_symtab): Likewise.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Likewise.
@
text
@d273 2
a274 2
/* Exported procedure: Builds a symtab from the PST partial one.
   Restores the environment in effect when PST was created, delegates
d276 1
a276 1
   and reorders the symtab list at the end.  PST is not NULL.  */
d279 1
a279 1
mdebug_psymtab_to_symtab (struct objfile *objfile, struct partial_symtab *pst)
d283 1
a283 1
      printf_filtered (_("Reading in symbols for %s..."), pst->filename);
d289 1
a289 1
  psymtab_to_symtab_1 (objfile, pst, pst->filename);
d2699 1
a2699 1
      pst->read_symtab = mdebug_psymtab_to_symtab;
d4799 1
a4799 1
  psymtab->read_symtab = mdebug_psymtab_to_symtab;
@


1.134
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d276 1
a276 1
   and reorders the symtab list at the end.  */
a280 3
  if (!pst)
    return;

@


1.133
log
@	* dbxread.c (read_dbx_symtab): Update.
	(end_psymtab, dbx_psymtab_to_symtab_1, dbx_psymtab_to_symtab)
	(read_ofile_symtab): Add 'objfile' argument.
	* dwarf2read.c (process_psymtab_comp_unit_reader)
	(build_type_psymtabs_reader): Update.
	(dwarf2_psymtab_to_symtab): Add 'objfile' argument.
	* mdebugread.c (mdebug_psymtab_to_symtab): Add 'objfile'
	argument.
	(parse_procedure, parse_partial_symbols): Update.
	(psymtab_to_symtab_1): Add 'objfile' argument.
	* psympriv.h (struct partial_symtab) <objfile>: Remove.
	<read_symtab>: Add 'objfile' argument.
	(sort_pst_symbols, discard_psymtab): Update.
	* psymtab.c (partial_map_expand_apply): Update.
	(find_pc_sect_psymtab_closer): Add 'objfile' argument.
	(find_pc_sect_psymtab, find_pc_sect_symtab_from_partial): Update.
	(find_pc_sect_psymbol): Add 'objfile' argument.
	(lookup_symbol_aux_psymtabs): Update.
	(match_partial_symbol, lookup_partial_symbol, psymtab_to_symtab):
	Add 'objfile' argument.
	(find_last_source_symtab_from_partial, dump_psymtab)
	(dump_psymtabs_for_objfile, read_symtabs_for_function)
	(expand_partial_symbol_tables, read_psymtabs_with_filename)
	(find_symbol_file_from_partial, map_matching_symbols_psymtab)
	(expand_symtabs_matching_via_partial): Update.
	(sort_pst_symbols): Add 'objfile' argument.
	(allocate_psymtab): Update.
	(discard_psymtab): Add 'objfile' argument.
	(maintenance_info_psymtabs, maintenance_check_symtabs): Update.
	* stabsread.h (end_psymtab): Update.
	* xcoffread.c (this_symtab_objfile): New global.
	(process_linenos, enter_line_range, xcoff_next_symbol_text):
	Update.
	(read_xcoff_symtab): Add 'objfile' argument.
	(read_symbol, read_symbol_lineno): Update.
	(xcoff_psymtab_to_symtab_1, xcoff_psymtab_to_symtab)
	(xcoff_end_psymtab): Add 'objfile' argument.
	(scan_xcoff_symtab): Update.
@
text
@d3 1
a3 2
   Copyright (C) 1986-1987, 1989-2004, 2007-2012 Free Software
   Foundation, Inc.
@


1.132
log
@	* coffread.c (coff_objfile_data_key): New global.
	(coff_symfile_init): Use set_objfile_data.
	(coff_symfile_read): Use objfile_data.
	(coff_symfile_finish): Don't free deprecated_sym_private.
	(coff_free_info): New function.
	(_initialize_coffread): Initialize coff_objfile_data_key.
	* mdebugread.c (pending_list): Update comment.
	* objfiles.h (struct objfile) <deprecated_sym_private>: Remove.
	* symfile.c (reread_symbols): Don't mention
	deprecated_sym_private.
	* xcoffread.c (xcoff_objfile_data_key): New global.
	(XCOFF_DATA): New macro.
	(process_linenos, enter_line_range, xcoff_next_symbol_text)
	(read_xcoff_symtab, coff_getfilename, read_symbol_lineno): Use
	XCOFF_DATA.
	(xcoff_new_init) Use set_objfile_data.
	(xcoff_symfile_finish): Don't free deprecated_sym_private.
	(init_stringtab, swap_sym, scan_xcoff_symtab)
	(xcoff_get_toc_offset, xcoff_initial_scan): Use XCOFF_DATA.
	(xcoff_free_info): New function.
	(_initialize_xcoffread): Initialize xcoff_objfile_data_key.
@
text
@d258 2
a259 1
static void psymtab_to_symtab_1 (struct partial_symtab *, const char *);
d280 1
a280 1
mdebug_psymtab_to_symtab (struct partial_symtab *pst)
d293 1
a293 1
  psymtab_to_symtab_1 (pst, pst->filename);
d297 1
a297 1
  scan_file_globals (pst->objfile);
d2073 1
a2073 1
    SYMBOL_TYPE (s) = objfile_type (pst->objfile)->nodebug_text_symbol;
d3772 1
a3772 1
      fdr_to_pst[f_idx].pst = end_psymtab (save_pst,
d3961 2
a3962 1
psymtab_to_symtab_1 (struct partial_symtab *pst, const char *filename)
d3999 1
a3999 1
	psymtab_to_symtab_1 (pst->dependencies[i],
d4019 1
a4019 1
  mdebugread_objfile = pst->objfile;
d4047 1
a4047 1
      struct gdbarch *gdbarch = get_objfile_arch (pst->objfile);
d4091 1
a4091 1
					SECT_OFF_TEXT (pst->objfile));
d4093 2
a4094 2
		      st = end_symtab (valu, pst->objfile,
				       SECT_OFF_TEXT (pst->objfile));
d4102 1
a4102 1
					  pst->section_offsets, pst->objfile);
d4109 1
a4109 1
				      pst->section_offsets, pst->objfile);
d4124 1
a4124 1
		  SYMBOL_TYPE (s) = objfile_type (pst->objfile)->builtin_void;
d4142 1
a4142 1
				    SECT_OFF_TEXT (pst->objfile));
d4158 2
a4159 2
	  st = end_symtab (pst->texthigh, pst->objfile,
			   SECT_OFF_TEXT (pst->objfile));
d4218 1
a4218 1
	  st = new_symtab ("unknown", 0, pst->objfile);
d4223 1
a4223 1
	  st = new_symtab (pst->filename, maxlines, pst->objfile);
d4266 1
a4266 1
				pst->section_offsets, pst->objfile);
d4340 1
a4340 1
			pst->section_offsets, pst->objfile);
@


1.131
log
@	* tracepoint.c (scope_info): Update.
	* symtab.c (lookup_block_symbol, iterate_over_symbols)
	(find_pc_sect_symtab, search_symbols)
	(default_make_symbol_completion_list_break_on)
	(make_file_symbol_completion_list): Update.
	* symmisc.c (dump_symtab_1): Update.
	* stack.c (print_frame_args, iterate_over_block_locals)
	(print_frame_labels, iterate_over_block_arg_vars): Update.
	* python/py-block.c (block_object) <dict>: Remove.
	<block>: New field.
	<iter>: Change type.
	(blpy_iter): Update.
	(blpy_block_syms_iternext): Update.
	* psymtab.c (map_block): Use block iterators.
	* objfiles.c (objfile_relocate1): Use ALL_DICT_SYMBOLS.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* mdebugread.c (parse_symbol, mylookup_symbol): Update.
	* infrun.c (check_exception_resume): Update.
	* cp-support.c (make_symbol_overload_list_block): Update.
	* coffread.c (patch_opaque_types): Update.
	* buildsym.c (finish_block, end_symtab): Use ALL_DICT_SYMBOLS.
	* block.h (struct block_iterator): New.
	(block_iterator_first, block_iterator_next, block_iter_name_first)
	(block_iter_name_next, block_iter_match_first)
	(block_iter_match_next): Declare.
	(ALL_BLOCK_SYMBOLS): Redefine.
	* block.c (block_iterator_first, block_iterator_next)
	(block_iter_name_first, block_iter_name_next)
	(block_iter_match_first, block_iter_match_next): New functions.
	* ada-lang.c (ada_add_block_symbols)
	(ada_make_symbol_completion_list): Use block iterator.
@
text
@d482 4
a485 6
/* The pending information is kept for an entire object file, and used
   to be in the deprecated_sym_private field.  I took it out when I
   split mdebugread from mipsread, because this might not be the only
   type of symbols read from an object file.  Instead, we allocate the
   pending information table when we create the partial symbols, and
   we store a pointer to the single table in each psymtab.  */
@


1.130
log
@gdb/
	PR symtab/7259:
	* ada-exp.y (convert_char_literal): Use TYPE_FIELD_ENUMVAL.
	* ada-lang.c (ada_discrete_type_high_bound)
	(ada_discrete_type_low_bound): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(ada_identical_enum_types_p): Use TYPE_FIELD_ENUMVAL.
	(pos_atr, value_val_atr): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* ada-typeprint.c (print_enum_type): Change variable lastval to LONGEST.
	Use TYPE_FIELD_ENUMVAL.
	* ada-valprint.c (print_optional_low_bound, ada_print_scalar)
	(ada_val_print_1): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* c-typeprint.c (c_type_print_base): Move variable lastval to inner
	block, change it to LONGEST.  Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* coffread.c (coff_read_enum_type): Use SET_FIELD_ENUMVAL.
	* dwarf2read.c (process_enumeration_scope): Likewise.
	* gdb-gdb.py (TypeFlagsPrinter): Use field.enumval instead of
	field.bitpos.
	(class StructMainTypePrettyPrinter): Support also
	FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.c (get_discrete_bounds): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(recursive_dump_type): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(copy_type_recursive): Support also FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.h (enum field_loc_kind): New FIELD_LOC_KIND_ENUMVAL.
	(struct main_type.flds_bnds.fields.loc): Adjust bitpos comment.  New
	field enumval.
	(struct main_type.flds_bnds.bields): Adjust loc_kind and bitsize to
	accommodate enumval.
	(struct call_site): Adjust loc_kind to accommodate enumval.
	(FIELD_ENUMVAL, FIELD_ENUMVAL_LVAL, SET_FIELD_ENUMVAL)
	(TYPE_FIELD_ENUMVAL): New macros.
	* m2-typeprint.c (m2_enum): Use TYPE_FIELD_ENUMVAL.
	* mdebugread.c (parse_symbol): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* python/lib/gdb/printing.py (class FlagEnumerationPrinter): Use
	enumval.
	* python/lib/gdb/types.py (make_enum_dict): Likewise.
	* python/py-type.c (convert_field): New variable addrstring.  Use
	TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(check_types_equal): Support also FIELD_LOC_KIND_ENUMVAL.
	* stabsread.c (read_enum_type): Use SET_FIELD_ENUMVAL.
	* typepint.c (print_type_scalar): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* valprint.c (generic_val_print): Likewise.

gdb/testsuite/
	PR symtab/7259:
	* gdb.base/enumval.c: New test case.
	* gdb.base/enumval.exp: New test case.
	* gdb.python/py-type.exp (test_enums): Use field.enumval instead of
	field.bitpos.
@
text
@d1187 1
a1187 1
		  struct dict_iterator iter;
d4610 1
a4610 1
  struct dict_iterator iter;
@


1.129
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@d1050 1
a1050 1
		SET_FIELD_BITPOS (*f, tsym.value);
@


1.128
log
@2012-01-19  Gary Benson  <gbenson@@redhat.com>

	* mdebugread.c (sort_blocks): Replace integer constants with ones
	derived from FIRST_LOCAL_BLOCK.
@
text
@d2362 1
a2362 1
  char **psymtab_include_list;
d2392 2
a2393 2
  psymtab_include_list = (char **) alloca (includes_allocated *
					   sizeof (char *));
d2757 1
a2757 1
	      char *namestring;
d3093 1
a3093 1
			  char **orig = psymtab_include_list;
d3095 1
a3095 1
			  psymtab_include_list = (char **)
d3097 1
a3097 1
				    sizeof (char *));
d3099 1
a3099 1
				  includes_used * sizeof (char *));
@


1.127
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d4716 1
a4716 1
  if (BLOCKVECTOR_NBLOCKS (bv) <= 2)
d4731 1
a4731 1
  if (BLOCKVECTOR_NBLOCKS (bv) > 3)
@


1.126
log
@	* defs.h (is_cplus_marker, set_demangling_style): Moved to ...
	* gdb-demangle.h: ... here.  New file.
	* demangle.c: #include "gdb-demangle.h".
	(_initialize_demangler): Use initialize_file_ftype for prototype.
	Move "set demangle" and "set asm-demangle" parameters here from utils.c
	(demangle, show_demangle, asm_demangle, show_asm_demangle): Move here
	from utils.c
	* utils.c: Update. #include "gdb-demangle.h".
	* symtab.h (asm_demangle): Delete.
	(demangle): Move declaration next to use.
	* breakpoint.c: #include "gdb-demangle.h" instead of "demangle.h".
	* dwarf2read.c: #include "gdb-demangle.h".
	* gnu-v2-abi.c: Ditto.
	* jv-typeprint.c: Ditto.
	* mdebugread.c: Ditto.
	* p-typeprint.c: Ditto.
	* stabsread.c: Ditto.
	* printcmd.c: Ditto.
	(asm_demangle): Delete declaration.
	* tui/tui-stack.c: #include "gdb-demangle.h".
@
text
@d3 2
a4 3
   Copyright (C) 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009, 2010,
   2011 Free Software Foundation, Inc.
@


1.126.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 2
   Copyright (C) 1986-1987, 1989-2004, 2007-2012 Free Software
   Foundation, Inc.
@


1.125
log
@	* coffread.c (coffread_objfile): Rename from current_objfile.
	* dbxread.c (dbxread_objfile): Rename from current_objfile.
	* mdebugread.c (mdebugread_objfile): Rename from current_objfile.
@
text
@d55 1
@


1.124
log
@	* symtab.h (current_objfile): Don't declare.
	* objfiles.h (current_objfile): Don't declare.
	* objfiles.c (current_objfile): Remove.
	* mdebugread.c (current_objfile): New file-scope global.
	* dbxread.c (current_objfile): New file-scope global.
	* coffread.c (current_objfile): New file-scope global.
@
text
@d84 1
a84 1
static struct objfile *current_objfile;
d518 1
a518 1
	   obstack_alloc (&current_objfile->objfile_obstack,
d1011 1
a1011 1
	  TYPE_TAG_NAME (t) = obconcat (&current_objfile->objfile_obstack,
d1056 1
a1056 1
			    obstack_alloc (&current_objfile->objfile_obstack,
d1061 1
a1061 1
					   &current_objfile->objfile_obstack));
d1152 1
a1152 1
	  SYMBOL_TYPE (s) = objfile_type (current_objfile)->builtin_void;
d1154 1
a1154 1
	       obstack_alloc (&current_objfile->objfile_obstack,
d1537 1
a1537 1
    return basic_type (btInt, current_objfile);
d1543 1
a1543 1
      return basic_type (btInt, current_objfile);
d1549 1
a1549 1
  tp = basic_type (t->bt, current_objfile);
d1582 1
a1582 1
	  return basic_type (btInt, current_objfile);
d1600 1
a1600 1
	    tp = basic_type (btChar, current_objfile);
d1602 1
a1602 1
	    tp = basic_type (btUChar, current_objfile);
d1638 1
a1638 1
	  return basic_type (btInt, current_objfile);
d1662 1
a1662 1
	tp = init_type (type_code, 0, 0, (char *) NULL, current_objfile);
d1706 1
a1706 1
			      &current_objfile->objfile_obstack);
d1721 1
a1721 1
	tp = init_type (type_code, 0, 0, (char *) NULL, current_objfile);
d1742 1
a1742 1
					   &current_objfile->objfile_obstack);
d1755 1
a1755 1
	  tp = basic_type (btInt, current_objfile);
d1866 1
a1866 1
	  indx = objfile_type (current_objfile)->builtin_int;
d4019 1
a4019 1
  current_objfile = pst->objfile;
d4055 1
a4055 1
	  current_objfile = NULL;
d4117 1
a4117 1
		     obstack_alloc (&current_objfile->objfile_obstack,
d4322 1
a4322 1
      LINETABLE (st) = obstack_copy (&current_objfile->objfile_obstack,
d4365 1
a4365 1
  current_objfile = NULL;
d4442 1
a4442 1
			(char *) NULL, current_objfile);
d4529 1
a4529 1
				current_objfile);
d4565 1
a4565 1
				current_objfile);
d4593 1
a4593 1
	  *tpp = init_type (type_code, 0, 0, (char *) NULL, current_objfile);
d4883 1
a4883 1
		      obstack_alloc (&current_objfile->objfile_obstack,
d4888 1
a4888 1
  SYMBOL_SET_NAMES (s, name, strlen (name), 1, current_objfile);
d4899 1
a4899 1
  t = alloc_type (current_objfile);
@


1.123
log
@	* mdebugread.c (psymtab_to_symtab_1): Copy linetable to obstack.
	(new_symtab): Don't set `free_code' on symtab.
	(new_linetable): Properly handle size==0.
	* symtab.h (struct symtab) <free_code, free_func>: Remove.
	* symmisc.c (free_symtab): Don't free the linetable.  Don't call
	free_func.
	* jv-lang.c (struct jv_per_objfile_data): New.
	(jv_per_objfile_free): Free the data.
	(get_dynamics_objfile): Allocate a jv_per_objfile_data.
	(get_java_class_symtab): Set the `dict' field on the
	jv_per_objfile_data.
	(free_class_block): Remove.
	* buildsym.c (end_symtab): Don't set `free_code' or `free_func' on
	the symtab.
@
text
@d81 5
@


1.122
log
@2011-03-23  Kai Tietz  <ktietz@@redhat.com>

	* breakpoint.c (clear_command): Use filename_cmp
	instead of strcmp for comparison.
	* buildsym.c (watch_main_source_file_lossage): Likewise.
	(patch_subfile_names): Use IS_DIR_SEPARATOR instead of
	checking just for slash.
	* dbxread.c (read_dbx_symtab): Use lbasename instead of
	strrchr and filename_cmp instead of strcmp for filenames.
	(add_old_header_file): Use filename_cmp
	instead of strcmp for comparison.
	* exec.c (exec_set_section_address): Likewise.
	* macrotab.c (macro_lookup_inclusion): Likewise.
	(macro_lookup_inclusion): Likewise.
	* elfread.c (_initialize_elfread): Likewise.
	(elfstab_offset_sections): Likewise.
	(elfstab_offset_sections): Use lbasename instead of
	strrchr.
	* mdebugread.c (parse_partial_symbols): Likewise.
	(arse_partial_symbols): Use filename_(n)cmp instead of
	str(n)cmp for comparison.
	* minsyms.c (lookup_minimal_symbol): Likewise.
	* psymtab.c (read_psymtabs_with_filename): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	(reload_shared_libraries_1): Likewise.
	* symmisc.c (maintenance_print_symbols): Likewise.
	* symfile.c (separate_debug_file_exists): Likewise.
	(reread_symbols): Likewise.
	(find_separate_debug_file_by_debuglink): Likewise.
	* remote-fileio.c (remote_fileio_func_rename): Likewise.
	* source.c (add_path): Likewise.
	* symtab.c (filename_seen): Likewise.
	(file_matches): Likewise.
	(print_symbol_info): Likewise.
	(maybe_add_partial_symtab_filename): Likewise.
	(make_source_files_completion_list): Likewise.
	* xml-syscall.c (init_sysinfo): Likewise.
	* windows-nat.c (_initialize_check_for_gdb_ini): Use
	IS_DIR_SEPARATOR for checking for trailing path separator.
@
text
@d4207 1
a4207 1
      int maxlines;
d4314 8
a4321 1
      LINETABLE (st) = lines;
a4772 1
  s->free_code = free_linetable;
d4812 3
a4814 1
  size = (size - 1) * sizeof (l->item) + sizeof (struct linetable);
@


1.121
log
@2011-03-05  Michael Snyder  <msnyder@@vmware.com>

	* dwarf2expr.c (execute_stack_op): Delete superfluous semicolon.
	* mdebugread.c (parse_symbol): Ditto.
	* parse.c (parse_exp_in_context): Ditto.
	* source.c (add_path): Ditto.
	* utils.c (gnu_debuglink_crc32): Ditto.
	* varobj.c (variable_language): Ditto.
@
text
@d48 1
d2963 1
a2963 1
		      char *p;
d3016 2
a3017 3

		      p = strrchr (namestring, '/');
		      if (p && *(p + 1) == '\000')
d3068 1
a3068 1
		      if (pst && strcmp (namestring, pst->filename) == 0)
d3075 2
a3076 2
			  if (strcmp (namestring,
				      psymtab_include_list[i]) == 0)
@


1.120
log
@2011-03-02  Michael Snyder  <msnyder@@vmware.com>

	* mdebugread.c (parse_partial_symbols): Fix indent.
@
text
@d946 1
a946 1
      end_of_fields:;
@


1.119
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@d2900 1
a2900 1
		  continue;
@


1.118
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* m2-exp.y: Comment cleanup, mostly periods and spaces.
	* m2-lang.c: Ditto.
	* m2-typeprint.c: Ditto.
	* m2-valprint.c: Ditto.
	* m32c-tdep.c: Ditto.
	* m32r-linux-nat.c: Ditto.
	* m32r-rom.c: Ditto.
	* m32r-tdep.c: Ditto.
	* m32r-tdep.h: Ditto.
	* m68hc11-tdep.c: Ditto.
	* m58klinux-nat.c: Ditto.
	* m68k-tdep.c: Ditto.
	* m88k-tdep.c: Ditto.
	* m88k-tdep.h: Ditto.
	* machoread.c: Ditto.
	* macrocmd.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* mdebugread.h: Ditto.
	* memattr.c: Ditto.
	* memattr.h: Ditto.
	* memory-map.h: Ditto.
	* mep-tdep.c: Ditto.
	* microblaze-rom.c: Ditto.
	* microblaze-tdep.c: Ditto.
	* minsyms.c: Ditto.
	* mips-irix-tdep.c: Ditto.
	* mips-linux-nat.c: Ditto.
	* mips-linux-tdep.c: Ditto.
	* mips-linux-tdep.h: Ditto.
	* mipsnbsd-nat.c: Ditto.
	* mipsnbsd-tdep.c: Ditto.
	* mipsread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mips-tdep.h: Ditto.
	* mn10300-linux-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* mn10300-tdep.h: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* moxie-tdep.c: Ditto.
	* moxie-tdep.h: Ditto.
	* mt-tdep.c: Ditto.
@
text
@d3863 1
a3863 1
   all the the enum constants to the partial symbol table.  */
@


1.117
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d64 1
a64 1
#include "coff/ecoff.h"		/* COFF-like aspects of ecoff files */
d68 1
a68 1
#include "aout/stab_gnu.h"	/* STABS information */
d74 1
a74 1
/* Provide a way to test if we have both ECOFF and ELF symbol tables.  
d122 1
a122 1
/* Various complaints about symbol reading that don't abort the process */
d162 1
a162 1
/* Macros and extra defs */
d164 1
a164 1
/* Puns: hard to find whether -g was used and how */
d171 1
a171 1
/* Things that really are local to this module */
d173 1
a173 1
/* Remember what we deduced to be the source language of this psymtab. */
d189 1
a189 1
/* Pointer to current file decriptor record, and its index */
d194 1
a194 1
/* Index of current symbol */
d199 1
a199 1
   to see at least one FDR with full symbols */
d204 1
a204 1
/* When examining .o files, report on undefined symbols */
d216 1
a216 1
/* Forward declarations */
d270 1
a270 1
   and reorders the symtab list at the end */
d289 1
a289 1
     after all of the symtabs and dependencies have been read in.   */
d296 1
a296 1
/* File-level interface functions */
d298 1
a298 1
/* Find a file descriptor given its index RF relative to a file CF */
d309 1
a309 1
  /* Object files do not have the RFD table, all refs are absolute */
d320 1
a320 1
/* Return a safer print NAME for a file descriptor */
d388 1
a388 1
/* Map of FDR indexes to partial symtabs */
d401 1
a401 1
   after use. */
d406 2
a407 2
    struct symtab *cur_st;	/* Current symtab. */
    struct block *cur_block;	/* Block in it. */
d417 4
a420 4
    struct type *cur_type;	/* Type we parse fields for. */
    int cur_field;		/* Field number in cur_type. */
    CORE_ADDR procadr;		/* Start addres of this procedure */
    int numargs;		/* Its argument count */
d426 1
a426 1
/* Enter a new lexical context */
d433 1
a433 1
  /* Reuse frames if possible */
d438 1
a438 1
  /* Initialize new frame with previous content */
d451 1
a451 1
/* Exit a lexical context */
d466 1
a466 1
   of lists of references indexed by file descriptor */
d485 1
a485 1
/* Check whether we already saw symbol SH in file FH */
d493 1
a493 1
  /* Linear search is ok, list is typically no more than 10 deep */
d500 1
a500 1
/* Add a new symbol SH of type T */
d508 1
a508 1
  /* Make sure we do not make duplicates */
d522 1
a522 1
/* Parsing Routines proper. */
d524 1
a524 1
/* Parse a single symbol. Mostly just make up a GDB symbol for it.
d597 1
a597 1
    case stGlobal:		/* external symbol, goes into global block */
d605 1
a605 1
    case stStatic:		/* static data, goes into current block. */
d622 1
a622 1
    case stLocal:		/* local variable, goes into current block */
d634 1
a634 1
    data:			/* Common code for symbols describing data */
d645 1
a645 1
      /* Value of a data symbol is its memory address */
d648 2
a649 1
    case stParam:		/* arg to procedure, goes into current block */
d656 1
a656 1
	name = "this";		/* FIXME, not alloc'd in obstack */
d687 1
a687 1
    case stLabel:		/* label, goes into current block */
d689 2
a690 2
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;	/* so that it can be used */
      SYMBOL_CLASS (s) = LOC_LABEL;	/* but not misused */
d696 2
a697 2
    case stProc:		/* Procedure, usually goes into global block */
    case stStaticProc:		/* Static procedure, goes into current block */
d733 1
a733 1
      /* Type of the return value */
d750 1
a750 2
	         instead. (davidm@@azstarnet.com)
	       */
d772 1
a772 1
      /* Make a type for the procedure itself */
d780 1
a780 1
      /* Create and enter a new lexical context */
d788 1
a788 1
      /* Not if we only have partial info */
d810 1
a810 1
    case stStruct:		/* Start a block defining a struct type */
d814 1
a814 1
    case stUnion:		/* Start a block defining a union type */
d818 1
a818 1
    case stEnum:		/* Start a block defining an enum type */
d822 1
a822 1
    case stBlock:		/* Either a lexical block, or some type */
d836 1
a836 1
	/* First count the number of fields and the highest value. */
d851 1
a851 1
                   methods are encoded as stProc. The scope of stProc
d929 1
a929 1
		   Just ignore it. */
d936 1
a936 1
		   Just ignore it. */
d979 1
a979 1
	   here.) */
d1019 1
a1019 1
	    /* This is a non-empty enum. */
d1064 1
a1064 1
		/* Skip the stMembers that we've handled. */
d1071 1
a1071 1
	/* make this the current type */
d1101 2
a1102 2
      /* beginnning of (code) block. Value of symbol
         is the displacement from procedure start */
d1142 1
a1142 1
	  /* Make up special symbol to contain procedure specific info */
d1174 1
a1174 1
	         type.  Set that from the type of the parameter symbols. */
d1205 1
a1205 1
	  /* End of (code) block. The value of the symbol is the
d1207 1
a1207 1
	     end of this block. */
d1226 1
a1226 1
      pop_parse_stack ();	/* restore previous lexical context */
d1262 2
a1263 2
      /* mips cc puts out a typedef with the name of the struct for forward
         declarations. These should not go into the symbol table and
d1517 1
a1517 1
   the symbol SH. Return the bitfield size in BS, in case.
d1529 1
a1529 1
  /* Handle undefined types, they have indexNil. */
d1546 1
a1546 1
      /* Cannot use builtin types -- build our own */
d1565 1
a1565 1
	  /* alpha cc -migrate uses this for typedefs. The true type will
d1570 1
a1570 1
	  /* alpha cc uses this for typedefs. The true type will be
d1580 1
a1580 1
  /* Move on to next aux */
d1642 1
a1642 1
     them.  We'll make the same effort at sharing. */
d1727 1
a1727 1
	     exception is if we guessed wrong re struct/union/enum. */
d1753 1
a1753 1
  /* Deal with range types */
d1765 2
a1766 2
  /* Parse all the type qualifiers now. If there are more
     than 6 the game will continue in the next aux */
d1801 1
a1801 1
   reference in TPP and side-effected as necessary. The type
d1805 1
a1805 1
   Returns the number of aux symbols we parsed. */
d1814 1
a1814 1
  /* Used in array processing */
d1837 1
a1837 1
      /* Determine and record the domain type (type of index) */
d1933 1
a1933 1
  /* Simple rule to find files linked "-x" */
d1938 1
a1938 1
	  /* Static procedure at address pr->adr.  Sigh. */
d2011 1
a2011 1
      /* Donno its type, hope int is ok */
d2015 1
a2015 1
      /* Wont have symbols for this one */
d2071 1
a2071 1
/* Parse the external symbol ES. Just call parse_symbol() after
d2075 1
a2075 1
   This routine clobbers top_stack->cur_block and ->cur_st. */
d2126 1
a2126 1
      /* FIXME:  Turn this into a complaint? */
d2169 1
a2169 1
   with that and do not need to reorder our linetables */
d2185 1
a2185 1
  /* Scan by procedure descriptors */
d2193 1
a2193 1
      /* No code for this one */
d2225 1
a2225 1
	  /* Complain if the line table overflows. Could happen
d2355 1
a2355 1
  /* List of current psymtab's include files */
d2361 1
a2361 1
  /* Index within current psymtab dependency list */
d2404 1
a2404 1
   * look at. (XXX)
d2412 1
a2412 1
     to FDR -1. We`ll go along with that */
d2442 1
a2442 1
  /* Pass 1 over external syms: Presize and partition the list */
d2455 1
a2455 1
  /* Pass 1.5 over files:  partition out global symbol space */
d2476 1
a2476 1
     Elf symtab).  
d2493 1
a2493 1
     symbol table. */
d2495 1
a2495 1
  /* Pass 2 over external syms: fill in external symbols */
d2528 1
a2528 1
      /* Pass 3 over files, over local syms: fill in static symbols */
d2531 1
a2531 1
      /* Process ECOFF Symbol Types and Storage Classes */
d2578 1
a2578 1
             generated by the linker. One possible usage for this kind
d2580 1
a2580 1
             given section. For instance, on Tru64 5.1, the address of
d2584 1
a2584 1
             related to the section to which the symbol refers. For
d2589 1
a2589 1
             storage class of the label does not exist. On True64 5.1
d2592 1
a2592 1
             which storage class is scData... Since these symbols are
d2594 1
a2594 2
             discard these symbols.
           */
d2639 1
a2639 1
	     whose name starts with a `.'. Skip those but complain for all
d2642 1
a2642 1
	     those too. */
d2655 1
a2655 1
  /* Pass 3 over files, over local syms: fill in static symbols */
d2697 1
a2697 1
      /* The way to turn this into a symtab is to call... */
d2709 1
a2709 1
         following header files. Then we save the language in the private
d2733 1
a2733 1
         file). */
d2822 1
a2822 1
			     then have the default be abs? */
d2834 1
a2834 1
	      /* Handle stabs continuation */
d2846 1
a2846 1
		    /* Ignore continuation char from 1st string */
d2849 1
a2849 1
		    /* Read next stabstring */
d2859 1
a2859 1
		    /* Concatinate stabstring2 with stabstring1 */
d2893 1
a2893 1
		  case N_SETV | N_EXT:		/* FIXME, is this in BSS? */
d2902 1
a2902 1
		  /* Standard, local, non-debugger, symbols */
d2923 1
a2923 1
		    continue;		/* Just undefined, not COMMON */
d2935 1
a2935 1
		    /* Keep going . . . */
d2971 1
a2971 1
			 SunPRO 3.0 compiler. end_psymtab explicitly tests
d2986 1
a2986 1
			{		/* Here if prev stab wasn't N_SO */
d2999 2
a3000 1
		      /* End the current partial symtab and start a new one */
d3006 1
a3006 1
			 one. */
d3014 1
a3014 1
			 the previous N_SO was a directory name. */
d3019 1
a3019 1
						   name SOs */
d3038 1
a3038 1
		      /* Mark down an include file in the current psymtab */
d3040 1
a3040 1
		      /* SET_NAMESTRING ();*/
d3059 1
a3059 1
			 other files. So I check to see if this is a file
d3098 1
a3098 1
		  case N_LSYM:	    /* Typedef or automatic variable. */
d3114 2
a3115 2
				       here. */
		  case N_SCOPE:	    /* Same.   */
d3117 1
a3117 1
		    /*    SET_NAMESTRING ();*/
d3121 1
a3121 1
		      continue;	    /* Not a debugging symbol.   */
d3152 3
a3154 2
			/* The addresses in these entries are reported to be
			   wrong.  See the code that reads 'G's for symtabs. */
d3194 1
a3194 1
						   just :T... */
d3206 1
a3206 1
			   e.g.  "enum {a, b} c;" in C, but fortunately
d3407 1
a3407 1
					   ignore. */
d3409 2
a3410 2
		  case N_CATCH:		/* These are GNU C++ extensions */
		  case N_EHDECL:	/* that can safely be ignored here. */
d3425 1
a3425 1
		  case N_OBJ:		/* useless types from Solaris */
d3428 1
a3428 1
		       them */
d3437 1
a3437 1
			       hex_string (type_code)); /*CUR_SYMBOL_TYPE*/
d3471 1
a3471 1
		  /* FIXME, premature? */
d3524 1
a3524 1
		      new_sdx = cur_sdx + 1;	/* Don't skip at all */
d3538 1
a3538 1
		      new_sdx = cur_sdx + 1;	/* Don't skip backward */
d3552 1
a3552 1
		     for a function. This means that the function name
d3611 1
a3611 1
		  /* Skip forward declarations from Irix5 cc */
d3631 1
a3631 1
		     and gcc empty aggregates. */
d3645 1
a3645 1
		  /* Skip over the block */
d3649 1
a3649 1
		      /* This happens with the Ultrix kernel. */
d3652 1
a3652 1
		      new_sdx = cur_sdx + 1;	/* Don't skip backward */
d3665 1
a3665 1
		     as visible symbols in a .h file that contains code. */
d3677 1
a3677 1
	      /* Use this gdb symbol */
d3683 1
a3683 1
	      cur_sdx++;	/* Go to next file symbol */
d3686 1
a3686 1
	  /* Now do enter the external symbols. */
d3766 1
a3766 1
      /* Link pst to FDR. end_psymtab returns NULL if the psymtab was
d3805 1
a3805 1
  /* Now scan the FDRs for dependencies */
d3814 1
a3814 1
      /* This should catch stabs-in-ecoff. */
d3930 1
a3930 1
/* Get the next symbol.  OBJFILE is unused. */
d3993 1
a3993 1
	/* We only pass the filename for debug purposes */
d4004 1
a4004 1
  /* Now read the symbols for this symtab */
d4021 1
a4021 1
  /* See comment in parse_partial_symbols about the @@stabs sentinel. */
d4046 1
a4046 1
      /* Parse local symbols first */
d4048 1
a4048 1
      if (fh->csym <= 2)	/* FIXME, this blows psymtab->symtab ptr */
d4079 1
a4079 1
                     process_one_symbol, and once after this loop. */
d4109 1
a4109 1
		     procedure specific info */
d4135 1
a4135 1
		  /* Handle encoded stab line number. */
d4144 1
a4144 1
	    /* These are generated by gcc-2.x, do not complain */
d4229 1
a4229 1
      /* Get a new lexical context */
d4248 1
a4248 1
	  /* Parse local symbols first */
d4317 2
a4318 2
         XXX use the global list to speed up things here. how?
         FIXME, Maybe quit once we have found the right number of ext's? */
d4356 1
a4356 1
/* Ancillary parsing procedures. */
d4391 1
a4391 1
   Return value says how many aux symbols we ate. */
d4396 1
a4396 1
	   /* Use to alloc new type if none is found. */
d4412 1
a4412 1
  /* Escape index means 'the next one' */
d4435 1
a4435 1
     of procedures that were compiled without -g. These will always remain
d4496 1
a4496 1
	     For these the type will be void. This is a bad design decision
d4501 1
a4501 1
	     compilation unit. Irix5 cc uses a stIndirect symbol for this.
d4532 1
a4532 1
	      /* Follow a forward typedef. This might recursively
d4535 1
a4535 1
	         cannot handle typedefs without type copying. Type
d4560 1
a4560 1
	  /* Parse the type for a normal typedef. This might recursively call
d4563 1
a4563 1
	     cannot handle typedefs without type copying. But type copying is
d4586 1
a4586 1
  /* We used one auxent normally, two if we got a "next one" rf. */
d4592 1
a4592 1
   keeping the symtab sorted */
d4628 1
a4628 1
/* Add a new block B to a symtab S */
d4655 1
a4655 1
   line number entry. These entries have a bogus address info with them
d4664 1
a4664 1
     Change them to something sensible. */
d4668 1
a4668 1
    last = -2;			/* make sure we record first line */
d4670 1
a4670 1
  if (last == lineno)		/* skip continuation lines */
d4678 1
a4678 1
/* Sorting and reordering procedures */
d4680 1
a4680 1
/* Blocks with a smaller low bound should come first */
d4697 1
a4697 1
   as required by some MI search routines */
d4745 1
a4745 1
/* Constructor/restructor/destructor procedures */
d4748 1
a4748 1
   linenumbers MAXLINES we'll put in it */
d4757 1
a4757 1
  /* All symtabs must have at least two blocks */
d4771 1
a4771 1
/* Allocate a new partial_symtab NAME */
d4781 1
a4781 1
  /* Keep a backpointer to the file's symbols */
d4791 1
a4791 1
  /* The way to turn this into a symtab is to call... */
d4812 1
a4812 1
/* Oops, too big. Shrink it.  This was important with the 2.4 linetables,
d4827 1
a4827 1
/* Allocate and zero a new blockvector of NBLOCKS blocks. */
d4864 1
a4864 1
/* Create a new symbol with printname NAME */
d4879 1
a4879 1
/* Create a new type with printname NAME */
@


1.116
log
@run copyright.sh for 2011.
@
text
@d145 2
a146 1
  complaint (&symfile_complaints, _("guessed tag type of %s incorrectly"), arg1);
d376 2
a377 1
	printf_unfiltered (_("\n%s not compiled with -g, debugging support is limited.\n"),
d379 2
a380 1
      printf_unfiltered (_("You should compile with -g2 or -g3 for best debugging support.\n"));
d941 2
a942 1
			   _("declaration block contains unhandled symbol type %d"),
d1005 2
a1006 2
	  TYPE_TAG_NAME (t) = obconcat (&current_objfile->objfile_obstack, name,
					(char *) NULL);
d1234 2
a1235 1
      FIELD_TYPE (*f) = parse_type (cur_fd, ax, sh->index, &bitsize, bigend, name);
d1600 2
a1601 1
	    complaint (&symfile_complaints, _("can't handle TIR fBitfield for %s"),
d1698 3
a1700 2
	    TYPE_TAG_NAME (tp) = obsavestring (name, strlen (name),
					    &current_objfile->objfile_obstack);
d1794 2
a1795 1
    complaint (&symfile_complaints, _("illegal TIR continued for %s"), sym_name);
d1858 2
a1859 1
		     _("illegal array index type for %s, assuming int"), sym_name);
d2157 2
a2158 1
      parse_symbol (&es->asym, ax, (char *) NULL, bigend, section_offsets, objfile);
d2244 2
a2245 1
	     _("function `%s' appears to be defined outside of all compilation units"),
d2413 2
a2414 1
  fdr_to_pst = (struct pst_map *) xzalloc ((hdr->ifdMax + 1) * sizeof *fdr_to_pst);
d2508 2
a2509 2
		     _("bad ifd for external symbol: %d (max %ld)"), ext_in->ifd,
		     hdr->ifdMax);
d2536 2
a2537 1
	  svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d2542 2
a2543 1
	  svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d2556 2
a2557 1
	      svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d2562 2
a2563 1
	      svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS (objfile));
d2603 2
a2604 1
	      svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d2612 2
a2613 1
	      svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d2621 2
a2622 1
	      svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS (objfile));
d2677 2
a2678 1
	    textlow += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d2766 2
a2767 1
		      sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d2814 2
a2815 1
			  sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d2825 2
a2826 1
			  sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS (objfile));
d2877 1
a2877 3
		    /*
		     * Standard, external, non-debugger, symbols
		     */
d2881 2
a2882 1
		    sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d2887 2
a2888 1
		    sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d2895 2
a2896 1
		    sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS (objfile));
d2907 5
a2911 4
		    /* We need to be able to deal with both N_FN or N_TEXT,
		       because we have no way of knowing whether the sys-supplied ld
		       or GNU ld was used to make the executable.  Sequents throw
		       in another wrinkle -- they renumbered N_FN.  */
d2919 2
a2920 1
		    sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d2924 1
a2924 1
		    continue;			/* Just undefined, not COMMON */
d2966 2
a2967 1
		      valu = sh.value + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d2971 3
a2973 3
		      /* A zero value is probably an indication for the SunPRO 3.0
			 compiler. end_psymtab explicitly tests for zero, so
			 don't relocate it.  */
d3005 2
a3006 1
		      /* Null name means end of .o file.  Don't start a new one. */
d3010 5
a3014 4
		      /* Some compilers (including gcc) emit a pair of initial N_SOs.
			 The first one is a directory name; the second the file name.
			 If pst exists, is empty, and has a filename ending in '/',
			 we assume the previous N_SO was a directory name. */
d3018 2
a3019 1
			continue;		/* Simply ignore directory name SOs */
d3021 4
a3024 3
		      /* Some other compilers (C++ ones in particular) emit useless
			 SOs for non-existant .c files.  We ignore all subsequent SOs that
			 immediately follow the first.  */
d3043 2
a3044 1
		      tmp_language = deduce_language_from_filename (namestring);
d3046 5
a3050 4
		      /* Only change the psymtab's language if we've learned
			 something useful (eg. tmp_language is not language_unknown).
			 In addition, to match what start_subfile does, never change
			 from C++ to C.  */
d3056 12
a3067 10
		      /* In C++, one may expect the same filename to come round many
			 times, when code is coming alternately from the main file
			 and from inline functions in other files. So I check to see
			 if this is a file we've seen before -- either the main
			 source file, or a previously included file.

			 This seems to be a lot of time to be spending on N_SOL, but
			 things like "break c-exp.y:435" need to work (I
			 suppose the psymtab_include_list could be hashed or put
			 in a binary tree, if profiling shows this is a major hog).  */
d3098 6
a3103 6
		  case N_LSYM:			/* Typedef or automatic variable. */
		  case N_STSYM:		/* Data seg var -- static  */
		  case N_LCSYM:		/* BSS      "  */
		  case N_ROSYM:		/* Read-only data seg var -- static.  */
		  case N_NBSTS:		/* Gould nobase.  */
		  case N_NBLCS:		/* symbols.  */
d3105 2
a3106 2
		  case N_GSYM:			/* Global (extern) variable; can be
						   data or bss (sigh FIXME).  */
d3111 5
a3115 4
		  case N_PC:			/* I may or may not need this; I
						   suspect not.  */
		  case N_M2C:			/* I suspect that I can ignore this here. */
		  case N_SCOPE:		/* Same.   */
d3121 1
a3121 1
		      continue;			/* Not a debugging symbol.   */
d3126 6
a3131 5
		       the initial read through the symbol tables needs to worry
		       about.  If we reach this point, the symbol which we are
		       considering is definitely one we are interested in.
		       p must also contain the (valid) index into the namestring
		       which indicates the debugging type symbol.  */
d3136 2
a3137 1
			sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d3150 2
a3151 1
			sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d3180 2
a3181 2
				add_psymbol_to_list (namestring, p - namestring,
						     1,
d3185 2
a3186 1
						     psymtab_language, objfile);
d3192 2
a3193 1
			if (p != namestring)	/* a name is there, not just :T... */
d3202 9
a3210 8
			/* If this is an enumerated type, we need to
			   add all the enum constants to the partial symbol
			   table.  This does not cover enums without names, e.g.
			   "enum {a, b} c;" in C, but fortunately those are
			   rare.  There is no way for GDB to find those from the
			   enum type without spending too much time on it.  Thus
			   to solve this problem, the compiler needs to put out the
			   enum in a nameless type.  GCC2 does this.  */
d3218 2
a3219 2
			/* This type may be given a number.  Also, numbers can come
			   in pairs like (0,26).  Skip over it.  */
d3227 2
a3228 1
			    /* The aix4 compiler emits extra crud before the members.  */
d3248 2
a3249 2
				/* Check for and handle cretinous dbx symbol name
				   continuation!  */
d3258 2
a3259 1
				   enum constants in psymtabs, just in symtabs.  */
d3262 3
a3264 2
						     &objfile->static_psymbols, 0,
						     0, psymtab_language, objfile);
d3280 3
a3282 2
					     &objfile->static_psymbols, sh.value,
					     0, psymtab_language, objfile);
d3296 2
a3297 1
			sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d3306 3
a3308 2
			   are put into the global psymtab like one would expect.
			   They're also in the minimal symbol table.  */
d3320 2
a3321 1
			sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d3329 4
a3332 3
			/* Two things show up here (hopefully); static symbols of
			   local scope (static used inside braces) or extensions
			   of structure symbols.  We can ignore both.  */
d3346 2
a3347 1
		      case '#':		/* for symbol identification (used in live ranges) */
d3351 4
a3354 4
			/* It is a C++ nested symbol.  We don't need to record it
			   (I don't think); if we try to look up foo::bar::baz,
			   then symbols for the symtab containing foo should get
			   read in, I think.  */
d3361 6
a3366 5
			/* Unexpected symbol descriptor.  The second and subsequent stabs
			   of a continued stab can show up here.  The question is
			   whether they ever can mimic a normal stab--it would be
			   nice if not, since we certainly don't want to spend the
			   time searching to the end of every string looking for
d3402 6
a3407 4
		  case N_SSYM:			/* Claim: Structure or union element.
						   Hopefully, I can ignore this.  */
		  case N_ENTRY:		/* Alternate entry point; can ignore. */
		  case N_MAIN:			/* Can definitely ignore this.   */
d3409 1
a3409 1
		  case N_EHDECL:		/* that can safely be ignored here. */
d3421 2
a3422 1
		  case N_ALIAS:		/* SunPro F77: alias name, ignore for now.  */
d3424 1
a3424 1
		  case N_OBJ:			/* useless types from Solaris */
d3426 2
a3427 1
		    /* These symbols aren't interesting; don't worry about them */
d3432 4
a3435 3
		    /* If we haven't found it yet, ignore it.  It's probably some
		       new type we don't know about yet.  */
		    complaint (&symfile_complaints, _("unknown symbol type %s"),
d3484 2
a3485 1
		    sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d3492 2
a3493 1
		  sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d3497 2
a3498 1
		  sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS (objfile));
d3511 2
a3512 2
						       SECT_OFF_TEXT (objfile), NULL,
						       objfile);
d3698 2
a3699 1
		internal_error (__FILE__, __LINE__, _("failed internal consistency check"));
d3711 2
a3712 1
		  svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d3719 2
a3720 1
		  svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA (objfile));
d3724 2
a3725 1
		  svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS (objfile));
d3817 2
a3818 2
      /* Skip the first file indirect entry as it is a self dependency
         for source files or a reverse .h -> .c dependency for header files.  */
d3846 2
a3847 1
	  pst->dependencies[pst->number_of_dependencies++] = fdr_to_pst[rh].pst;
d4135 2
a4136 1
		  valu += ANOFFSET (pst->section_offsets, SECT_OFF_TEXT (pst->objfile));
d4146 2
a4147 1
	    complaint (&symfile_complaints, _("unknown stabs symbol %s"), name);
d4152 2
a4153 1
	  st = end_symtab (pst->texthigh, pst->objfile, SECT_OFF_TEXT (pst->objfile));
d4259 2
a4260 1
				sym_ptr, fh->fBigendian, pst->section_offsets, pst->objfile);
d4298 2
a4299 1
	      parse_lines (fh, pr_block, lines, maxlines, pst, lowest_pdr_addr);
d4319 3
a4321 2
      top_stack->cur_block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (top_stack->cur_st),
						GLOBAL_BLOCK);
d4326 2
a4327 1
	parse_external (ext_ptr, fh->fBigendian, pst->section_offsets, pst->objfile);
d4336 2
a4337 1
	  printf_filtered ("\n\t%4d variables\n\t%4d procedures\n\t%4d labels\n",
d4393 3
a4395 1
cross_ref (int fd, union aux_ext *ax, struct type **tpp, enum type_code type_code,	/* Use to alloc new type if none is found. */
d4428 2
a4429 1
      *tpp = init_type (type_code, 0, TYPE_FLAG_STUB, (char *) NULL, current_objfile);
@


1.115
log
@	* symfile.h (allocate_symtab): Update.
	* symfile.c (allocate_symtab): Make 'filename' const.
	* psymtab.c (add_psymbol_to_bcache): Make 'name' const.
	(add_psymbol_to_list): Likewise.
	* psympriv.h (struct partial_symtab) <filename, dirname>: Now
	const.
	(add_psymbol_to_list): Update.
	* mdebugread.c (new_symtab): Make 'name' const.
	(psymtab_to_symtab_1): Make 'filename' const.
	* elfread.c (elfstab_offset_sections): Update.
	* dwarf2read.c (dwarf_decode_lines): Make 'comp_dir' const.
	(dwarf2_start_subfile): Make 'dirname' and 'comp_dir' const.
	(psymtab_include_file_name): Update.
	* dbxread.c (find_stab_function_addr): Make 'filename' const.
	* buildsym.h (start_subfile): Update.
	* buildsym.c (start_subfile): Make arguments const.
@
text
@d4 2
a5 2
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
@


1.114
log
@create and use symbol_set_language.

2010-08-09  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.h: Renamed SYMBOL_INIT_LANGUAGE_SPECIFIC to
	SYMBOL_SET_LANGUAGE.
	(symbol_init_language_specific): Renamed to symbol_set_language.
	* symtab.c (symbol_init_language_specific): Removed redundant check
	for language_cplus.
	Renamed to symbol_set_language.
	* stabsread.c (define_symbol): Updated.
	(read_enum_type): Updated
	* psymtab.c (add_psymbol_to_bcache): Updated.
	* minsyms.c (install_minimal_symbols): Updated.
	* coffread.c (process_coff_symbol): SYMBOL_SET_LANGUAGE instead of
	SYMBOL_LANGUAGE to set the language.
	* minsyms.c (prim_record_minimal_symbol_full): Ditto.
	* mdebugread.c (new_symbol): Ditto.
	* cp-namespace.c (check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol_full): Ditto.
	* jv-lang.c (add_class_symbol): Ditto.
@
text
@d235 1
a235 1
static struct symtab *new_symtab (char *, int, struct objfile *);
d251 1
a251 1
static void psymtab_to_symtab_1 (struct partial_symtab *, char *);
d3891 1
a3891 1
psymtab_to_symtab_1 (struct partial_symtab *pst, char *filename)
d4674 1
a4674 1
new_symtab (char *name, int maxlines, struct objfile *objfile)
@


1.113
log
@2010-05-15  Michael Snyder  <msnyder@@vmware.com>

	* m2-lang.c: White space.
	* m2-valprint.c: White space.
	* macrocmd.c: White space.
	* macroexp.c: White space.
	* macroscope.c: White space.
	* macrotab.c: White space.
	* main.c: White space.
	* maint.c: White space.
	* mdebugread.c: White space.
	* memattr.c: White space.
	* minsyms.c: White space.
	* monitor.c: White space.
@
text
@d4797 1
a4797 1
  SYMBOL_LANGUAGE (s) = psymtab_language;
@


1.112
log
@gdb/
	* dwarf2read.c (typename_concat): Use (char *) NULL terminated stdarg
	list for the obconcat call.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol, read_member_functions, read_cpp_abbrev):
	Likewise.
	* symfile.c (obconcat): Replace the s1, s2 and s3 parameters by `...'.
	New variable ap.  Remove variables len and val.
	* symfile.h (obconcat): Likewise for the prototype.
@
text
@a273 1

d755 1
d1157 1
d1178 1
d1581 1
a1668 1

d1973 1
d2407 1
d2816 1
d2853 1
d2960 1
a2960 1
			{			/* Here if prev stab wasn't N_SO */
d3006 1
d3035 1
d3038 1
d3244 1
d3266 1
d4045 3
a4047 3
		  ((struct mdebug_extra_func_info *)
		   obstack_alloc (&current_objfile->objfile_obstack,
				  sizeof (struct mdebug_extra_func_info)));
a4743 1

@


1.111
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* serial.c (serial_for_fd): Delete unused variable.
	* mdebugread.c (psymtab_to_symtab_1): Delete unused variable.
	* top.c (execute_command): Delete unused variable.
	(init_main): Delete unused variable.
	* utils.c (do_fclose_cleanup): Delete unused variable.
	(do_all_inferior_continuations): Delete unused variable.
	(initialize_utils): Delete unused variable.
	(internal_problem_mode): Delete unused global.
	* frame.c (get_prev_frame): Delete unused global.
	(get_frame_locals_address): Delete unused global.
	(get_frame_args_address): Delete unused global.
@
text
@d1001 2
a1002 2
	  TYPE_TAG_NAME (t) = obconcat (&current_objfile->objfile_obstack,
					"", "", name);
@


1.110
log
@	* xcoffread.c (xcoff_start_psymtab): Update.
	(xcoff_end_psymtab): Update.
	* psymtab.c (allocate_psymtab): Remove dead code.
	* psympriv.h (struct partial_symtab) <read_symtab_private>: Now
	void*.
	* mdebugread.c (parse_partial_symbols): Update.
	(new_psymtab): Likewise.
	* dwarf2read.c (process_psymtab_comp_unit): Update.
	(psymtab_to_symtab_1): Update.
	* dbxread.c (start_psymtab): Update.
	(end_psymtab): Likewise.
@
text
@a4126 1
      int f_max;
@


1.109
log
@gdb
	* xcoffread.c: Include psymtab.h.
	(xcoff_sym_fns): Update.
	* symtab.h (struct partial_symbol): Remove.
	(PSYMBOL_DOMAIN, PSYMBOL_CLASS): Remove.
	(struct partial_symtab): Remove.
	(PSYMTAB_TO_SYMTAB): Remove.
	(lookup_partial_symbol, lookup_partial_symtab, find_pc_psymtab)
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): Declare.
	(find_pc_psymtab, find_pc_sect_psymbol, psymtab_to_symtab)
	(find_main_psymtab): Remove.
	(find_main_filename): Declare.
	(fixup_psymbol_section): Remove.
	(fixup_section): Declare.
	* symtab.c: Include psymtab.h.
	(lookup_symtab): Use lookup_symtab method.
	(lookup_partial_symtab): Remove.
	(find_pc_sect_psymtab_closer): Remove.
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): New function.
	(find_pc_psymtab, find_pc_sect_psymbol, find_pc_psymbol): Remove.
	(fixup_section): No longer static.
	(fixup_psymbol_section): Remove.
	(lookup_symbol_aux): Use lookup_symbol_aux_quick.
	(lookup_global_symbol_from_objfile): Likewise.
	(lookup_symbol_aux_psymtabs): Remove.
	(lookup_symbol_aux_quick): New function.
	(lookup_symbol_global): Use lookup_symbol_aux_quick.
	(lookup_partial_symbol): Remove.
	(basic_lookup_transparent_type_quick): New function.
	(basic_lookup_transparent_type): Use it.
	(find_main_psymtab): Remove.
	(find_main_filename): New function.
	(find_pc_sect_symtab): Use find_pc_sect_symtab method.
	(find_line_symtab): Use expand_symtabs_with_filename method.
	(output_partial_symbol_filename): New function.
	(sources_info): Use map_partial_symbol_filenames.
	(struct search_symbols_data): New type.
	(search_symbols_file_matches): New function.
	(search_symbols_name_matches): Likewise.
	(search_symbols): Use expand_symtabs_matching method.
	(struct add_name_data): Rename from add_macro_name_data.
	(add_macro_name): Update.
	(add_partial_symbol_name): New function.
	(default_make_symbol_completion_list): Use
	map_partial_symbol_names.
	(struct add_partial_symbol_name): New type.
	(maybe_add_partial_symtab_filename): New function.
	(make_source_files_completion_list): Use
	map_partial_symbol_filenames.
	(expand_line_sal): Use expand_symtabs_with_filename method.
	* symmisc.c: Include psymtab.h.
	(print_objfile_statistics): Use print_stats method.
	(dump_objfile): Use dump method.
	(dump_psymtab, maintenance_print_psymbols)
	(maintenance_info_psymtabs, maintenance_check_symtabs)
	(extend_psymbol_list): Remove.
	* symfile.h (struct quick_symbol_functions): New struct.
	(struct sym_fns) <qf>: New field.
	(sort_pst_symbols): Remove.
	(increment_reading_symtab): Declare.
	* symfile.c: Include psymtab.h.
	(compare_psymbols, sort_pst_symbols): Remove.
	(psymtab_to_symtab): Remove.
	(increment_reading_symtab): New function.
	(symbol_file_add_with_addrs_or_offsets): Use expand_all_symtabs
	method.
	(set_initial_language): Use find_main_filename.
	(allocate_psymtab, discard_psymtab, cashier_psymtab): Remove.
	(free_named_symtabs): Remove unused code.
	(start_psymtab_common, add_psymbol_to_bcache)
	(append_psymbol_to_list, add_psymbol_to_list, init_psymbol_list):
	Remove.
	* stack.c: Include psymtab.h, symfile.h.
	(backtrace_command_1): Use find_pc_sect_symtab_via_partial.
	* source.h (psymtab_to_fullname): Don't declare.
	* source.c: Include psymtab.h.
	(select_source_symtab): Use find_last_source_symtab method.
	(forget_cached_source_info): Use forget_cached_source_info
	method.
	(find_and_open_source): No longer static.
	(psymtab_to_fullname): Remove.
	* somread.c: Include psymtab.h.
	(som_sym_fns): Update.
	* psympriv.h: New file.
	* psymtab.h: New file.
	* psymtab.c: New file.
	* objfiles.h: (ALL_OBJFILE_PSYMTABS): Remove.
	(ALL_PSYMTABS, ALL_PSPACE_PSYMTABS): Likewise.
	* objfiles.c: Include psymtab.h.
	(objfile_relocate1): Use relocate method.
	(objfile_has_partial_symbols): Use has_symbols method.
	* mipsread.c: Include psymtab.h.
	(ecoff_sym_fns): Update.
	* mi/mi-cmd-file.c: Include psymtab.h.
	(print_partial_file_name): New function.
	(mi_cmd_file_list_exec_source_files): Use
	map_partial_symbol_filenames.
	* mdebugread.c: Include psympriv.h.
	* machoread.c: Include psympriv.h.
	(macho_sym_fns): Update.
	* m2-exp.y (yylex): Use lookup_symtab.
	* elfread.c: Include psympriv.h.
	(elf_sym_fns): Update.
	* dwarf2read.c: Include psympriv.h.
	* dbxread.c: Include psympriv.h.
	(aout_sym_fns): Update.
	* cp-support.c: Include psymtab.h.
	(read_in_psymtabs): Remove.
	(make_symbol_overload_list_qualified): Use
	expand_symtabs_for_function method.
	* coffread.c: Include psympriv.h.
	(coff_sym_fns): Update.
	* blockframe.c: Include psymtab.h.
	(find_pc_partial_function): Use find_pc_sect_symtab method.
	* ada-lang.h (ada_update_initial_language): Update.
	* ada-lang.c: Include psymtab.h.
	(ada_update_initial_language): Remove 'main_pst' argument.
	(ada_lookup_partial_symbol): Remove.
	(struct ada_psym_data): New type.
	(ada_add_psyms): New function.
	(ada_add_non_local_symbols): Use map_ada_symtabs method.
	(struct add_partial_datum): New type.
	(ada_add_partial_symbol_completions): New function.
	(ada_make_symbol_completion_list): Use map_partial_symbol_names.
	(ada_exception_support_info_sniffer): Update.
	* Makefile.in (SFILES): Add psymtab.c.
	(COMMON_OBS): Add psymtab.o.
	(HFILES_NO_SRCDIR): Add psymtab.h, psympriv.h.
gdb/doc
	* gdbint.texinfo (Symbol Handling): Update.
@
text
@d2663 2
a2664 3
      pst->read_symtab_private = ((char *)
				  obstack_alloc (&objfile->objfile_obstack,
						 sizeof (struct symloc)));
d4696 2
a4697 3
  psymtab->read_symtab_private = ((char *)
				  obstack_alloc (&objfile->objfile_obstack,
						 sizeof (struct symloc)));
@


1.108
log
@gdb/ChangeLog:

        Add support for DW_AT_GNAT_descriptive_type.
        * gdbtypes.h (enum type_specific_kind): New enum.
        (struct main_type) [type_specific_field]: New component.
        [type_specific]: Add new component "gnat_stuff".
        (struct gnat_aux_type): New type.
        (INIT_CPLUS_SPECIFIC): Also set TYPE_SPECIFIC_FIELD (type).
        (HAVE_CPLUS_STRUCT): Also check TYPE_SPECIFIC_FIELD (type).
        (gnat_aux_default, allocate_gnat_aux_type): Add declaration.
        (INIT_GNAT_SPECIFIC, ALLOCATE_GNAT_AUX_TYPE, HAVE_GNAT_AUX_INFO)
        (TYPE_SPECIFIC_FIELD): New macros.
        (TYPE_CPLUS_SPECIFIC): Return cplus_struct_default if the given
        type does not hold any cplus-specific data.
        (TYPE_RAW_CPLUS_SPECIFIC): New macro.
        (TYPE_GNAT_SPECIFIC, TYPE_DESCRIPTIVE_TYPE): New macros.
        (TYPE_IS_OPAQUE): Use HAVE_CPLUS_STRUCT to check if type has
        cplus-specific data.
        * gdbtypes.c (allocate_cplus_struct_type): Minor stylistic rewrite.
        Set new component TYPE_SPECIFIC_FIELD (type).
        (gnat_aux_default): New constant.
        (allocate_gnat_aux_type): New function.
        (init_type): Add initialization the type-specific stuff for
        TYPE_CODE_FLT and TYPE_CODE_FUNC types.
        (print_gnat_stuff): New function.
        (recursive_dump_type): Use HAVE_CPLUS_STRUCT to check for cplus-
        specific data.  Adjust code that prints the contents of the
        type-specific union using the TYPE_SPECIFIC_FIELD value.
        * dwarf2read.c (dwarf2_attach_fields_to_type): Do not allocate
        the type cplus stuff for Ada types.
        (dwarf2_add_member_fn, dwarf2_attach_fn_fields_to_type):
        Error out if these routines are called with an Ada type.
        (read_structure_type, read_array_type, read_subrange_type):
        Add call to set_descriptive_type.
        (set_die_type): Initialize the gnat-specific data if necessary.
        (need_gnat_info, die_descriptive_type, set_descriptive_type):
        New functions.
        * ada-lang.c (decode_constrained_packed_array_type): Use
        decode_constrained_packed_array_type instead of doing a standard
        lookup to locate a parallel type.
        (find_parallel_type_by_descriptive_type): New function.
        (ada_find_parallel_type_with_name): New function.
        (ada_find_parallel_type): Reimplement using
        ada_find_parallel_type_with_name.
        * ada-valprint.c (print_field_values): Use HAVE_CPLUS_STRUCT
        to check if type has a cplus stuff.
        * linespec.c (total_number_of_methods): Likewise.
        * mdebugread.c (new_type): Likewise.

gdb/testsuite/ChangeLog:

        * gdb.base/maint.exp: Adjust the expected output for the
        "maint print type" test. Use gdb_test_multiple instead of
        gdb_sent/gdb_expect.
@
text
@d60 1
@


1.107
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d4803 1
a4803 1
  TYPE_CPLUS_SPECIFIC (t) = (struct cplus_struct_type *) &cplus_struct_default;
@


1.106
log
@* dwarf2read.c (struct attribute): Increase sizes of unsnd and snd
fields to allow larger integer sizes.
(read_subrange_type): Increase size of bound values.
Add logic to determine signedness based on base-type size, signedness.
(read_attribute_value): Change format for bad byte size in message.
(read_8_bytes): Increase size of result type.
(dump_die_shallow): Change format for value.
(dwarf2_get_attr_constant_value): Increase size of return type.
Correct comment.
* gdbtypes.c (create_range_type): Change API to increase size of
bounds. struct field -> union field.
Always take signedness from base type.
(check_typedef): Use new API for TYPE_LOW_BOUND, TYPE_HIGH_BOUND.
(recursive_dump_type, copy_type_recursive): Adjust to new
representation of range types.
* gdbtypes.h (fields_or_bounds): New union containing struct field and
new struct range_bounds, used for range types.
(TYPE_RANGE_DATA): New macro to access range_bounds member.
(TYPE_LOW_BOUND, TYPE_HIGH_BOUND): Represent with new TYPE_RANGE_DATA.
(TYPE_LOW_BOUND_UNDEFINED, TYPE_HIGH_BOUND_UNDEFINED): New macros,
taking over the job of TYPE_FIELD_ARTIFICIAL for range bounds.
(SET_TYPE_LOW_BOUND, SET_TYPE_HIGH_BOUND, SET_TYPE_LOW_BOUND_DEFINED)
(SET_TYPE_HIGH_BOUND_DEFINED): New macros.
(TYPE_FIELDS, TYPE_BASECLASS, TYPE_BASECLASS_NAME, TYPE_FIELD)
(TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED)
(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED, TYPE_ARRAY_UPPER_BOUND_VALUE)
(TYPE_ARRAY_LOWER_BOUND_VALUE):	Adjust to new representation.
(create_range_type): Adjust API.
* ada-lang.c (ada_modulus): Use new extended bound values.
(discrete_type_low_bound): Rename to...
(ada_discrete_type_low_bound): ... and make external.
(discrete_type_high_bound): Rename to...
(ada_discrete_type_high_bound): ... and make external.
(ada_value_slice_from_ptr, ada_array_bound_from_type)
(ada_evaluate_subexp, to_fixed_range_type):
Use ada_discrete_type_low_bound, ada_discrete_type_high_bound.
* ada-typeprint.c (print_range): Use ada_discrete_type_low_bound,
ada_discrete_type_high_bound.  Don't look at field count, which
is no longer meaningful.  Print bounds whenever argument is a range
or enumeration.
* ada-lang.h (ada_discrete_type_low_bound,ada_discrete_type_high_bound):
Declare.
* varobj.c (c_describe_child): Adjust to render larger values.
* mdebugread.c (parse_type): Use proper abstractions for range types:
TYPE_RANGE_DATA, SET_TYPE_LOW_BOUND_DEFINED,
SET_TYPE_HIGH_BOUND_DEFINED.
* p-typeprint.c (pascal_type_print_varspec_prefix): Use larger format
for bounds.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009
@


1.105
log
@	* xcoffread.c (scan_xcoff_symtab): Update.
	* symfile.h (add_psymbol_to_list): Update prototype.
	* symfile.c (add_psymbol_to_bcache): Add copy_name argument.
	(add_psymbol_to_list): Likewise.
	* stabsread.c (define_symbol): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	(handle_psymbol_enumerators): Update.
	(new_symbol): Update.
	* dbxread.c (read_dbx_symtab): Update.
	* coffread.c (process_coff_symbol): Update.
	* symtab.h (prim_record_minimal_symbol_full): Declare.
	(SYMBOL_SET_NAMES): Add copy_name argument.
	* symtab.c (struct demangled_name_entry): New struct.
	(hash_demangled_name_entry): New function.
	(eq_demangled_name_entry): Likewise.
	(create_demangled_names_hash): Use new functions.
	(symbol_set_names): Use struct demangled_name_entry.  Add
	copy_name argument.
	* minsyms.c (prim_record_minimal_symbol_full): New function.
	(prim_record_minimal_symbol_and_info): Use it.
	* elfread.c (record_minimal_symbol): Add name_len and copy_name
	arguments.  Call prim_record_minimal_symbol_full.
	(elf_symtab_read): Add copy_names argument.
	(elf_symfile_read): Update calls to elf_symtab_read.
	* dwarf2read.c (add_partial_symbol): Don't copy symbol names.
	(load_partial_dies): Likewise.
	(new_symbol): Likewise.
	* cp-namespace.c (check_one_possible_namespace_symbol): Don't save
	name on the obstack.  Update call to SYMBOL_SET_NAMES.
@
text
@d1746 3
a1748 4
      TYPE_NFIELDS (tp) = 2;
      TYPE_FIELDS (tp) = ((struct field *)
			  TYPE_ALLOC (tp, 2 * sizeof (struct field)));
      TYPE_FIELD_NAME (tp, 0) = "Low";
a1750 1
      TYPE_FIELD_NAME (tp, 1) = "High";
@


1.104
log
@	* symtab.h (SYMBOL_SET_LINKAGE_NAME): Update comment.
	* symfile.c (allocate_symtab): Don't use obsavestring on a
	constant string.
	* stabsread.c (define_symbol): Don't use obsavestring on a
	constant string.
	* mdebugread.c (parse_type): Don't use obsavestring on a constant
	string.
	(new_symtab): Likewise.
	* elfread.c (elf_symtab_read): Don't use obsavestring on a
	constant string.
@
text
@d3098 1
a3098 1
			add_psymbol_to_list (namestring, p - namestring,
d3108 1
a3108 1
			add_psymbol_to_list (namestring, p - namestring,
d3126 1
a3126 1
			    add_psymbol_to_list (namestring, p - namestring,
d3135 1
d3147 1
a3147 1
			    add_psymbol_to_list (namestring, p - namestring,
d3209 1
a3209 1
				add_psymbol_to_list (p, q - p,
d3226 1
a3226 1
			add_psymbol_to_list (namestring, p - namestring,
d3243 1
a3243 1
			add_psymbol_to_list (namestring, p - namestring,
d3264 1
a3264 1
			add_psymbol_to_list (namestring, p - namestring,
d3493 1
a3493 1
		    add_psymbol_to_list (name, strlen (name),
d3498 1
a3498 1
		    add_psymbol_to_list (name, strlen (name),
d3567 1
a3567 1
		      add_psymbol_to_list (name, strlen (name),
d3608 1
a3608 1
	      add_psymbol_to_list (name, strlen (name),
d3684 1
a3684 1
	      add_psymbol_to_list (name, strlen (name),
d3847 1
a3847 1
      add_psymbol_to_list (name, strlen (name),
d4792 1
a4792 1
  SYMBOL_SET_NAMES (s, name, strlen (name), current_objfile);
@


1.103
log
@	* gdbtypes.h (struct builtin_type): Remove builtin_core_addr,
	nodebug_text_symbol, nodebug_data_symbol, nodebug_unknown_symbol,
	and nodebug_tls_symbol members.
	(struct objfile_type): New data structure.
	(objfile_type): Add prototype.
	* gdbtypes.c (gdbtypes_post_init): Remove initialization code
	for types no longer in struct builtin_type.
	(objfile_type_data): New static variable.
	(_initialize_gdbtypes): Initialize it.
	(objfile_type): New function.

	* gdbtypes.h (builtin_type_error): Remove.
	* gdbtypes.c (build_complex): Do not use builtin_type_error.
	* symtab.c (builtin_type_error): Remove.
	(_initialize_symtab): Remove initialization.

	* stabsread.c (dbx_lookup_type, define_symbol, error_type,
	rs6000_builtin_type, read_range_type): Use per-objfile types
	instead of global or per-architecture builtin types.
	* coffread.c (decode_type): Likewise.
	* dwarf2read.c (read_array_type, read_tag_string_type,
	new_symbol, die_type): Likewise.
	* mdebugread.c (parse_symbol, basic_type, upgrade_type,
	parse_procedure, psymtab_to_symtab_1): Likewise.
	* xcoffread.c (process_xcoff_symbol): Likewise.
	* parse.c (write_exp_msymbol): Likewise.

	* stabsread.c (rs6000_builtin_type_data): New static variable.
	(_initialize_stabsread): Initialize it.
	(rs6000_builtin_type): Add OBJFILE argument.  Allocate builtin
	types per-objfile instead of globally.

	* stabsread.c (dbx_lookup_type): Add OBJFILE argument.  Use it
	instead of current_objfile; pass it to rs6000_builtin_type.
	(dbx_alloc_type, read_type, read_range_type): Update calls.
	(cleanup_undefined_types_noname): Add OBJFILE argument and
	pass it to dbx_lookup_type.
	(cleanup_undefined_types): Add OBJFILE argument and pass it
	to cleanup_undefined_types_noname.
	* stabsread.h (cleanup_undefined_types): Add OBJFILE argument.
	* buildsym.c (end_symtab): Update call.
@
text
@d1749 1
a1749 2
      TYPE_FIELD_NAME (tp, 0) = obsavestring ("Low", strlen ("Low"),
					    &current_objfile->objfile_obstack);
d1752 1
a1752 2
      TYPE_FIELD_NAME (tp, 1) = obsavestring ("High", strlen ("High"),
					    &current_objfile->objfile_obstack);
d4681 1
a4681 2
  s->debugformat = obsavestring ("ECOFF", 5,
				 &objfile->objfile_obstack);
@


1.102
log
@	* buildsym.c (record_line): Remove call to gdbarch_addr_bits_remove.

	* coffread.c (coff_symtab_read): Call gdbarch_addr_bits_remove before
	calling record_line.
	(enter_linenos): Likewise.
	* dbxread.c (process_one_symbol): Likewise.
	* dwarf2read.c (dwarf_decode_lines): Likewise.
	* mdebugread.c (psymtab_to_symtab_1): Likewise.
	* xcoffread.c (enter_line_range): Likewise.
@
text
@d639 1
a639 1
	SYMBOL_TYPE (s) = builtin_type (gdbarch)->nodebug_data_symbol;
d688 1
a688 1
      SYMBOL_TYPE (s) = builtin_type (gdbarch)->builtin_int;
d731 1
a731 1
	t = builtin_type (gdbarch)->builtin_int;
d1141 1
a1141 1
	  SYMBOL_TYPE (s) = builtin_type_void;
d1362 1
a1362 1
      tp = builtin_type_void;
d1368 1
a1368 1
      TYPE_TARGET_TYPE (tp) = builtin_type_void;
d1460 1
a1460 1
      tp = builtin_type_void;
d1486 1
a1486 1
      TYPE_TARGET_TYPE (tp) = builtin_type_void;
d1852 1
a1852 1
	  indx = builtin_type_int32;
a1920 1
  struct gdbarch *gdbarch = get_objfile_arch (pst->objfile);
d2004 1
a2004 1
	= lookup_function_type (builtin_type (gdbarch)->builtin_int);
d2059 1
a2059 1
    SYMBOL_TYPE (s) = builtin_type (gdbarch)->nodebug_text_symbol;
d4045 1
a4045 1
		  SYMBOL_TYPE (s) = builtin_type_void;
@


1.101
log
@	* symtab.h: Rename SYMBOL_OPS to SYMBOL_COMPUTED_OPS.
	* ax-gdb.c (gen_var_ref): Likewise.
	* findvar.c (read_var_value, symbol_read_needs_frame): Likewise.
	* printcmd.c (address_info): Likewise.
	* dwarf2loc.c (dwarf_expr_frame_base): Likewise.
	* dwarf2read.c (dwarf2_symbol_mark_computed): Likewise.
	* symtab.h: Rename struct symbol_ops to struct symbol_computed_ops.
	* dwarf2loc.h: Likewise.
	* dwarf2loc.c (dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Likewise.

	* symtab.h: (struct symbol_register_ops): New struct definition.
	(struct symbol): Make "ops" member a union of symbol_computed_ops and
	symbol_register_ops callback pointers.
	(SYMBOL_REGISTER_OPS): New macro.
	* tracepoint.c: Include "objfiles.h".
	(scope_info, collect_symbol): Use SYMBOL_REGISTER_OPS register_number
	callback to retrieve register numbers.
	* ax-gdb.c (gen_var_ref): Likewise.
	* findvar.c (read_var_value): Likewise.
	* printcmd.c (address_info): Likewise.

	* coffread.c (coff_reg_to_regnum): New function.
	(coff_register_funcs): New static variable.
	(process_coff_symbol): Do not call gdbarch_sdb_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
	* mdebugread.c (mdebug_reg_to_regnum): New function.
	(mdebug_register_funcs): New static variable.
	(parse_symbol): Do not call gdbarch_ecoff_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
	* stabsread.c (stab_reg_to_regnum): New function.
	(stab_register_funcs): New static variable.
	(define_symbol): Do not call gdbarch_stab_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
@
text
@d3969 1
d4064 2
a4065 1
		  record_line (current_subfile, sh.index, valu);
@


1.100
log
@ChangeLog:

	* mdebugread.c (mdebug_type_void, mdebug_type_char, mdebug_type_short,
	mdebug_type_int, mdebug_type_int_32, mdebug_type_int_64,
	mdebug_type_long_32, mdebug_type_long_64, mdebug_type_long_long_64,
	mdebug_type_unsigned_char, mdebug_type_unsigned_short,
	mdebug_type_unsigned_int_32, mdebug_type_unsigned_int_64,
	mdebug_type_unsigned_long_32, mdebug_type_unsigned_long_64,
	mdebug_type_unsigned_long_long_64, mdebug_type_adr_32,
	mdebug_type_adr_64, mdebug_type_float, mdebug_type_double,
	mdebug_type_complex, mdebug_type_double_complex,
	mdebug_type_fixed_dec, mdebug_type_float_dec, mdebug_type_string):
	Remove.

	(basic_type_data): New global variable.
	(basic_type): New function.
	(parse_type): Remove static basic type map map_bt.  Call basic_type
	to get basic types instead of using mdebug_type_ variables.

	(parse_symbol): Use builtin types instead of mdebug_type_ variables.
	(upgrade_type): Likewise.
	(parse_procedure): Likewise.
	(psymtab_to_symtab_1): Likewise.

	(_initialize_mdebugread): Do not initialize mdebug_type_ variables.
	Initialize basic_type_data.

include/coff/ChangeLog:

	* symconst.h (btLong64, btULong64, btLongLong64, btULongLong64,
	btAdr64, btInt64, btUInt64): New defines.
@
text
@d531 10
d620 3
d626 1
a626 1
	  svalue = gdbarch_ecoff_reg_to_regnum (current_gdbarch, svalue);
a629 3
      b = top_stack->cur_block;
      s = new_symbol (name);
      SYMBOL_VALUE (s) = svalue;
d662 1
a662 1
	  svalue = gdbarch_ecoff_reg_to_regnum (current_gdbarch, svalue);
d671 1
a671 1
	  svalue = gdbarch_ecoff_reg_to_regnum (current_gdbarch, svalue);
@


1.99
log
@        * mdebugread.c (parse_symbol): Save the symbol private data
        using SYMBOL_VALUE_BYTES instead of SYMBOL_VALUE.
        (psymtab_to_symtab_1): Likewise.
        (parse_procedure): Declare variable "e" only in the scope
        where it is used. Extract the symbol private data using
        SYMBOL_VALUE_BYTES.
@
text
@a209 28
/* Types corresponding to mdebug format bt* basic types.  */

static struct type *mdebug_type_void;
static struct type *mdebug_type_char;
static struct type *mdebug_type_short;
static struct type *mdebug_type_int_32;
#define mdebug_type_int mdebug_type_int_32
static struct type *mdebug_type_int_64;
static struct type *mdebug_type_long_32;
static struct type *mdebug_type_long_64;
static struct type *mdebug_type_long_long_64;
static struct type *mdebug_type_unsigned_char;
static struct type *mdebug_type_unsigned_short;
static struct type *mdebug_type_unsigned_int_32;
static struct type *mdebug_type_unsigned_int_64;
static struct type *mdebug_type_unsigned_long_32;
static struct type *mdebug_type_unsigned_long_64;
static struct type *mdebug_type_unsigned_long_long_64;
static struct type *mdebug_type_adr_32;
static struct type *mdebug_type_adr_64;
static struct type *mdebug_type_float;
static struct type *mdebug_type_double;
static struct type *mdebug_type_complex;
static struct type *mdebug_type_double_complex;
static struct type *mdebug_type_fixed_dec;
static struct type *mdebug_type_float_dec;
static struct type *mdebug_type_string;

d678 1
a678 1
      SYMBOL_TYPE (s) = mdebug_type_int;
d721 1
a721 1
	t = mdebug_type_int;
d1131 1
a1131 1
	  SYMBOL_TYPE (s) = mdebug_type_void;
d1325 173
a1506 42
  /* Null entries in this map are treated specially */
  static struct type **map_bt[] =
  {
    &mdebug_type_void,		/* btNil */
    &mdebug_type_adr_32,	/* btAdr */
    &mdebug_type_char,		/* btChar */
    &mdebug_type_unsigned_char,	/* btUChar */
    &mdebug_type_short,		/* btShort */
    &mdebug_type_unsigned_short,	/* btUShort */
    &mdebug_type_int_32,	/* btInt */
    &mdebug_type_unsigned_int_32,	/* btUInt */
    &mdebug_type_long_32,	/* btLong */
    &mdebug_type_unsigned_long_32,	/* btULong */
    &mdebug_type_float,		/* btFloat */
    &mdebug_type_double,	/* btDouble */
    0,				/* btStruct */
    0,				/* btUnion */
    0,				/* btEnum */
    0,				/* btTypedef */
    0,				/* btRange */
    0,				/* btSet */
    &mdebug_type_complex,	/* btComplex */
    &mdebug_type_double_complex,	/* btDComplex */
    0,				/* btIndirect */
    &mdebug_type_fixed_dec,	/* btFixedDec */
    &mdebug_type_float_dec,	/* btFloatDec */
    &mdebug_type_string,	/* btString */
    0,				/* btBit */
    0,				/* btPicture */
    &mdebug_type_void,		/* btVoid */
    0,				/* DEC C++:  Pointer to member */
    0,				/* DEC C++:  Virtual function table */
    0,				/* DEC C++:  Class (Record) */
    &mdebug_type_long_64,	/* btLong64  */
    &mdebug_type_unsigned_long_64,	/* btULong64 */
    &mdebug_type_long_long_64,	/* btLongLong64  */
    &mdebug_type_unsigned_long_long_64,		/* btULongLong64 */
    &mdebug_type_adr_64,	/* btAdr64 */
    &mdebug_type_int_64,	/* btInt64  */
    &mdebug_type_unsigned_int_64,	/* btUInt64 */
  };

d1513 1
a1513 1
    return mdebug_type_int;
d1519 1
a1519 1
      return mdebug_type_int;
d1525 2
a1526 6
  if (t->bt >= (sizeof (map_bt) / sizeof (*map_bt)))
    {
      basic_type_complaint (t->bt, sym_name);
      return mdebug_type_int;
    }
  if (map_bt[t->bt])
a1527 5
      tp = *map_bt[t->bt];
    }
  else
    {
      tp = NULL;
d1558 1
a1558 1
	  return mdebug_type_int;
d1575 1
a1575 1
	    tp = mdebug_type_char;
d1577 1
a1577 1
	    tp = mdebug_type_unsigned_char;
d1612 1
a1612 1
	  return mdebug_type_int;
d1729 1
a1729 1
	  tp = mdebug_type_int;
d1842 1
a1842 1
	  indx = mdebug_type_int;
d1994 2
a1995 1
      SYMBOL_TYPE (s) = lookup_function_type (mdebug_type_int);
d4035 1
a4035 1
		  SYMBOL_TYPE (s) = mdebug_type_void;
d4837 1
a4837 111
  mdebug_type_void =
    init_type (TYPE_CODE_VOID, 1,
	       0,
	       "void", (struct objfile *) NULL);
  mdebug_type_char =
    init_type (TYPE_CODE_INT, 1,
	       0,
	       "char", (struct objfile *) NULL);
  mdebug_type_unsigned_char =
    init_type (TYPE_CODE_INT, 1,
	       TYPE_FLAG_UNSIGNED,
	       "unsigned char", (struct objfile *) NULL);
  mdebug_type_short =
    init_type (TYPE_CODE_INT, 2,
	       0,
	       "short", (struct objfile *) NULL);
  mdebug_type_unsigned_short =
    init_type (TYPE_CODE_INT, 2,
	       TYPE_FLAG_UNSIGNED,
	       "unsigned short", (struct objfile *) NULL);
  mdebug_type_int_32 =
    init_type (TYPE_CODE_INT, 4,
	       0,
	       "int", (struct objfile *) NULL);
  mdebug_type_unsigned_int_32 =
    init_type (TYPE_CODE_INT, 4,
	       TYPE_FLAG_UNSIGNED,
	       "unsigned int", (struct objfile *) NULL);
  mdebug_type_int_64 =
    init_type (TYPE_CODE_INT, 8,
	       0,
	       "int", (struct objfile *) NULL);
  mdebug_type_unsigned_int_64 =
    init_type (TYPE_CODE_INT, 8,
	       TYPE_FLAG_UNSIGNED,
	       "unsigned int", (struct objfile *) NULL);
  mdebug_type_long_32 =
    init_type (TYPE_CODE_INT, 4,
	       0,
	       "long", (struct objfile *) NULL);
  mdebug_type_unsigned_long_32 =
    init_type (TYPE_CODE_INT, 4,
	       TYPE_FLAG_UNSIGNED,
	       "unsigned long", (struct objfile *) NULL);
  mdebug_type_long_64 =
    init_type (TYPE_CODE_INT, 8,
	       0,
	       "long", (struct objfile *) NULL);
  mdebug_type_unsigned_long_64 =
    init_type (TYPE_CODE_INT, 8,
	       TYPE_FLAG_UNSIGNED,
	       "unsigned long", (struct objfile *) NULL);
  mdebug_type_long_long_64 =
    init_type (TYPE_CODE_INT, 8,
	       0,
	       "long long", (struct objfile *) NULL);
  mdebug_type_unsigned_long_long_64 =
    init_type (TYPE_CODE_INT, 8,
	       TYPE_FLAG_UNSIGNED,
	       "unsigned long long", (struct objfile *) NULL);
  mdebug_type_adr_32 =
    init_type (TYPE_CODE_PTR, 4,
	       TYPE_FLAG_UNSIGNED,
	       "adr_32", (struct objfile *) NULL);
  TYPE_TARGET_TYPE (mdebug_type_adr_32) = mdebug_type_void;
  mdebug_type_adr_64 =
    init_type (TYPE_CODE_PTR, 8,
	       TYPE_FLAG_UNSIGNED,
	       "adr_64", (struct objfile *) NULL);
  TYPE_TARGET_TYPE (mdebug_type_adr_64) = mdebug_type_void;
  mdebug_type_float =
    init_type (TYPE_CODE_FLT,
	       gdbarch_float_bit (current_gdbarch) / TARGET_CHAR_BIT,
	       0, "float", (struct objfile *) NULL);
  mdebug_type_double =
    init_type (TYPE_CODE_FLT,
	       gdbarch_double_bit (current_gdbarch) / TARGET_CHAR_BIT,
	       0, "double", (struct objfile *) NULL);
  mdebug_type_complex =
    init_type (TYPE_CODE_COMPLEX,
	       2 * gdbarch_float_bit (current_gdbarch) / TARGET_CHAR_BIT,
	       0, "complex", (struct objfile *) NULL);
  TYPE_TARGET_TYPE (mdebug_type_complex) = mdebug_type_float;
  mdebug_type_double_complex =
    init_type (TYPE_CODE_COMPLEX,
	       2 * gdbarch_double_bit (current_gdbarch) / TARGET_CHAR_BIT,
	       0, "double complex", (struct objfile *) NULL);
  TYPE_TARGET_TYPE (mdebug_type_double_complex) = mdebug_type_double;

  /* Is a "string" the way btString means it the same as TYPE_CODE_STRING?
     FIXME.  */
  mdebug_type_string =
    init_type (TYPE_CODE_STRING,
	       TARGET_CHAR_BIT / TARGET_CHAR_BIT,
	       0, "string",
	       (struct objfile *) NULL);

  /* We use TYPE_CODE_INT to print these as integers.  Does this do any
     good?  Would we be better off with TYPE_CODE_ERROR?  Should
     TYPE_CODE_ERROR print things in hex if it knows the size?  */
  mdebug_type_fixed_dec =
    init_type (TYPE_CODE_INT,
	       gdbarch_int_bit (current_gdbarch) / TARGET_CHAR_BIT,
	       0, "fixed decimal",
	       (struct objfile *) NULL);

  mdebug_type_float_dec =
    init_type (TYPE_CODE_ERROR,
	       gdbarch_double_bit (current_gdbarch) / TARGET_CHAR_BIT,
	       0, "floating decimal",
	       (struct objfile *) NULL);
@


1.98
log
@        Updated copyright notices for most files.
@
text
@d1164 1
a1164 1
	  SYMBOL_VALUE (s) = (long) e;
a1819 1
  struct mdebug_extra_func_info *e;
d1919 3
a1921 1
      e = (struct mdebug_extra_func_info *) SYMBOL_VALUE (i);
a1922 1
      e->pdr.isym = (long) s;
d3941 1
a3941 1
		  SYMBOL_VALUE (s) = (long) e;
@


1.97
log
@	Fix TYPE_HIGH_BOUND for TYPE_CODE_RANGE using arbitrary TYPE_NFIELDS in
	preparation for supporting DW_AT_byte_stride.
	* ada-lang.c (packed_array_type, ada_index_type): Use TYPE_INDEX_TYPE.
	(ada_array_bound_from_type): Move `index_type' declaration to the
	function start.  New variable `retval'.  Return the bounds for
	TYPE_CODE_RANGE using TYPE_LOW_BOUND and TYPE_HIGH_BOUND.  Abort on
	invalid index type codes.
	* ada-typeprint.c (print_range): Set `upper_bound' for TYPE_CODE_RANGE
	now using TYPE_HIGH_BOUND.
	* ada-valprint.c (val_print_packed_array_elements): Use `index_type'.
	* eval.c (evaluate_subexp_standard): Use TYPE_INDEX_TYPE.
	* gdbtypes.c (create_range_type): Use TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	refer to the number of fields only through TYPE_NFIELDS.
	(create_array_type): Use TYPE_INDEX_TYPE.
	(check_typedef): Use TYPE_INDEX_TYPE, TYPE_LOW_BOUND, TYPE_HIGH_BOUND.
	* gdbtypes.h (TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED)
	(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED): Use TYPE_INDEX_TYPE.
	(TYPE_ARRAY_UPPER_BOUND_VALUE, TYPE_ARRAY_LOWER_BOUND_VALUE): Use
	TYPE_INDEX_TYPE, TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	* hppa-tdep.c (hppa_alignof <TYPE_CODE_ARRAY>): Use TYPE_INDEX_TYPE.
	* mdebugread.c (parse_type): Use TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	* valarith.c (value_bit_index): Use TYPE_INDEX_TYPE.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008
@


1.96
log
@	Convert static_kind into loc_kind enum.
	* gdbtypes.h (enum field_loc_kind): New.
	(union field_location): New field dwarf_block.
	(struct field): Rename static_kind as loc_kind.
	(FIELD_STATIC_KIND): Rename to ...
	(FIELD_LOC_KIND): ... here.
	(TYPE_FIELD_STATIC_KIND): Rename to ...
	(TYPE_FIELD_LOC_KIND): ... here and use there now new FIELD_LOC_KIND.
	(TYPE_FIELD_STATIC_HAS_ADDR): Remove.
	(TYPE_FIELD_STATIC): Remove.
	(TYPE_FIELD_BITPOS): Reformat.
	(SET_FIELD_BITPOS): New.
	(FIELD_PHYSADDR): Rename to ...
	(FIELD_STATIC_PHYSADDR): ... here.
	(TYPE_FIELD_STATIC_PHYSADDR): Follow the FIELD_PHYSADDR rename.
	(SET_FIELD_PHYSADDR): Use new FIELD_LOC_KIND.
	(FIELD_PHYSNAME): Rename to ...
	(FIELD_STATIC_PHYSNAME): ... here.
	(TYPE_FIELD_STATIC_PHYSNAME): Follow the FIELD_PHYSNAME rename.
	(SET_FIELD_PHYSNAME): Use new FIELD_LOC_KIND.
	(FIELD_DWARF_BLOCK, TYPE_FIELD_DWARF_BLOCK, SET_FIELD_DWARF_BLOCK): New.
	(field_is_static): New declaration.
	* gdbtypes.c (field_is_static): New function.
	(copy_type_recursive): Update throughout.
	* amd64-tdep.c, c-typeprint.c, coffread.c, cp-valprint.c, dwarf2read.c,
	eval.c, jv-typeprint.c, jv-valprint.c, mdebugread.c, p-typeprint.c,
	p-valprint.c, valops.c, value.c, varobj.c: Update throughout.
@
text
@d1647 1
a1647 1
      TYPE_FIELD_BITPOS (tp, 0) = AUX_GET_DNLOW (bigend, ax);
d1651 1
a1651 1
      TYPE_FIELD_BITPOS (tp, 1) = AUX_GET_DNHIGH (bigend, ax);
@


1.95
log
@	* xcoffread.c (RECORD_MINIMAL_SYMBOL): Update.
	(scan_xcoff_symtab): Update.
	* mdebugread.c (record_minimal_symbol): Update.
	(parse_partial_symbols): Update.
	* elfread.c (record_minimal_symbol): Update.
	* dbxread.c (record_minimal_symbol): Update.
	* coffread.c (record_minimal_symbol): Update.
	* sh64-tdep.c (MSYMBOL_IS_SPECIAL): Redefine.
	(sh64_elf_make_msymbol_special): Update.
	* mips-tdep.c (mips_elf_make_msymbol_special): Use
	MSYMBOL_TARGET_FLAG_1.
	(mips_elf_make_msymbol_special): Likewise.
	(msymbol_is_special): Likewise.
	* minsyms.c (prim_record_minimal_symbol_and_info): Update.
	(install_minimal_symbols): Likewise.
	(prim_record_minimal_symbol): Update.
	(prim_record_minimal_symbol_and_info): Remove 'info' argument.
	* m68hc11-tdep.c (MSYMBOL_SET_RTC): Redefine.
	(MSYMBOL_SET_RTI): Redefine.
	(MSYMBOL_IS_RTC): Redefine.
	(MSYMBOL_IS_RTI): Redefine.
	* arm-tdep.c (MSYMBOL_SET_SPECIAL): Redefine.
	(MSYMBOL_IS_SPECIAL): Redefine.
	* symtab.h (struct minimal_symbol) <info>: Remove.
	<target_flag_1, target_flag_2>: New fields.
	(MSYMBOL_INFO): Remove.
	(MSYMBOL_TARGET_FLAG_1): New macro.
	(MSYMBOL_TARGET_FLAG_2): Likewise.
	(prim_record_minimal_symbol_and_info): Update.
@
text
@d1057 1
a1057 1
		FIELD_BITPOS (*f) = tsym.value;
a1060 1
		FIELD_STATIC_KIND (*f) = 0;
d1243 1
a1243 1
      FIELD_BITPOS (*f) = sh->value;
a1246 1
      FIELD_STATIC_KIND (*f) = 0;
d1778 1
a1778 2
      /* TYPE_FLAG_TARGET_STUB now takes care of the zero TYPE_LENGTH
         problem.  */
d1780 1
a1780 3
	{
	  TYPE_TARGET_STUB (t) = 1;
	}
@


1.94
log
@gdb:
	* xml-tdesc.c (tdesc_end_union): Update.
	* stabsread.c (define_symbol): Update.
	(read_type): Update.
	(read_struct_type): Update.
	(read_enum_type): Update.
	* spu-tdep.c (spu_builtin_type_vec128): Update.
	* sh-tdep.c (sh_push_dummy_call_fpu): Update.
	(sh_push_dummy_call_nofpu): Update.
	* mdebugread.c (parse_symbol): Update.
	(parse_symbol): Update.
	(parse_symbol): Update.
	(upgrade_type): Update.
	* jv-lang.c (java_lookup_class): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address): Update.
	* i386-tdep.c (i386_mmx_type): Update.
	(i386_sse_type): Update.
	* gdbtypes.h (enum type_flag_value): New enum.
	(enum type_instance_flag_value): New enum.
	(TYPE_FLAG_UNSIGNED, TYPE_FLAG_NOSIGN, TYPE_FLAG_STUB,
	TYPE_FLAG_TARGET_STUB, TYPE_FLAG_STATIC, TYPE_FLAG_PROTOTYPED,
	TYPE_FLAG_INCOMPLETE, TYPE_FLAG_VARARGS, TYPE_FLAG_VECTOR,
	TYPE_FLAG_FIXED_INSTANCE, TYPE_FLAG_STUB_SUPPORTED,
	TYPE_FLAG_NOTTEXT): Now enum constants.
	(TYPE_FLAG_CONST, TYPE_FLAG_VOLATILE, TYPE_FLAG_CODE_SPACE,
	TYPE_FLAG_DATA_SPACE, TYPE_FLAG_ADDRESS_CLASS_1,
	TYPE_FLAG_ADDRESS_CLASS_2): Remove.
	(TYPE_INSTANCE_FLAG_CONST, TYPE_INSTANCE_FLAG_VOLATILE,
	TYPE_INSTANCE_FLAG_CODE_SPACE, TYPE_INSTANCE_FLAG_DATA_SPACE,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_2): New constants.
	(TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB, TYPE_TARGET_STUB,
	TYPE_STATIC, TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_VARARGS,
	TYPE_VECTOR, TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED,
	TYPE_NOTTEXT): Update.
	(TYPE_FLAG_ADDRESS_CLASS_ALL): Remove.
	(TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL): New define.
	(TYPE_VOLATILE, TYPE_CODE_SPACE, TYPE_DATA_SPACE,
	TYPE_ADDRESS_CLASS_1, TYPE_ADDRESS_CLASS_2,
	TYPE_ADDRESS_CLASS_ALL): Update.
	(struct main_type) <flags>: Remove.
	<flag_unsigned, flag_nosign, flag_stub, flag_target_stub,
	flag_static, flag_prototyped, flag_incomplete, flag_varargs,
	flag_vector, flag_stub_supported, flag_nottext,
	flag_fixed_instance>: New fields.
	<nfields, vptr_fieldno>: Move earlier.
	(TYPE_FLAGS): Remove.
	* gdbtypes.c (make_pointer_type): Update.
	(address_space_name_to_int): Update.
	(address_space_int_to_name): Update.
	(make_type_with_address_space): Update.
	(make_cv_type): Update.
	(create_range_type): Update.
	(get_discrete_bounds): Update.
	(create_set_type): Update.
	(make_vector_type): Update.
	(smash_to_method_type): Update.
	(check_typedef): Update.
	(check_stub_method): Update.
	(init_type): Individually assign flag fields.
	(recursive_dump_type): Don't print entire TYPE_FLAGS field.  Do
	print TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED, and TYPE_NOTTEXT.
	(copy_type_recursive): Copy the entire main type.  Don't use
	TYPE_FLAGS.
	* features/rs6000/powerpc-altivec64l.c
	(initialize_tdesc_powerpc_altivec64l): Update.
	* features/rs6000/powerpc-altivec64.c
	(initialize_tdesc_powerpc_altivec64): Update.
	* features/rs6000/powerpc-altivec32l.c
	(initialize_tdesc_powerpc_altivec32l): Update.
	* features/rs6000/powerpc-altivec32.c
	(initialize_tdesc_powerpc_altivec32): Update.
	* features/rs6000/powerpc-7400.c (initialize_tdesc_powerpc_7400):
	Update.
	* features/arm-with-iwmmxt.c (initialize_tdesc_arm_with_iwmmxt):
	Update.
	* dwarf2read.c (read_structure_type): Update.
	(read_enumeration_type): Likewise.
	(process_enumeration_scope): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_base_type): Likewise.
	* coffread.c (coff_read_enum_type): Update.
	* ada-valprint.c (adjust_type_signedness): Update.
	* ada-typeprint.c (print_record_field_types): Update.
	* ada-lang.c (packed_array_type): Update.
	(empty_record): Don't reset TYPE_FLAGS.
	(ada_template_to_fixed_record_type_1): Update.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_record_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_static_fixed_type): Likewise.
gdb/testsuite:
	* gdb.base/maint.exp: Update "maint print type".
@
text
@d2214 1
a2214 1
  prim_record_minimal_symbol_and_info (name, address, ms_type, NULL,
d3343 1
a3343 1
						       mst_file_text, NULL,
d3429 1
a3429 1
							 mst_file_data, NULL,
d3435 1
a3435 1
							 mst_file_bss, NULL,
@


1.93
log
@	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME.
	* blockframe.c (find_pc_partial_function): Likewise.
	* buildsym.c (find_symbol_in_list): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* coffread.c (patch_opaque_types, process_coff_symbol): Likewise.
	(coff_read_enum_type): Likewise.  Use SYMBOL_SET_LINKAGE_NAME.
	* cp-support.c (cp_remove_params): Renamed from remove_params and
	made global.
	(overload_list_add_symbol): Update call to remove_params.
	* cp-support.h (cp_remove_params): Declare.
	* dwarf2read.c (process_enumeration_scope): Use SYMBOL_LINKAGE_NAME.
	(dwarf2_const_value): Use SYMBOL_PRINT_NAME.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* f-valprint.c (info_common_command, there_is_a_visible_common_named):
	Use SYMBOL_LINKAGE_NAME to find symbols and SYMBOL_PRINT_NAME
	for messages.
	* findvar.c (read_var_value): Use SYMBOL_LINKAGE_NAME.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa_hpux_skip_trampoline_code): Use SYMBOL_LINKAGE_NAME to find
	symbols and SYMBOL_PRINT_NAME for messages.
	* jv-lang.c (add_class_symbol): Use SYMBOL_SET_LINKAGE_NAME.
	* linespec.c (decode_line_2): Use SYMBOL_LINKAGE_NAME.
	* mdebugread.c (parse_symbol): Use SYMBOL_LINKAGE_NAME and
	SYMBOL_SET_LINKAGE_NAME.
	(mylookup_symbol): Use SYMBOL_LINKAGE_NAME.
	* minsyms.c (add_minsym_to_demangled_hash_table): Use
	SYMBOL_SEARCH_NAME.
	(lookup_minimal_symbol): Use SYMBOL_LINKAGE_NAME or
	SYMBOL_MATCHES_SEARCH_NAME, depending on the pass.
	* objfiles.h (ALL_OBJFILE_MSYMBOLS): Use SYMBOL_LINKAGE_NAME.
	* printcmd.c (build_address_symbolic): Use SYMBOL_LINKAGE_NAME.
	(address_info): Use SYMBOL_PRINT_NAME for messages and
	SYMBOL_LINKAGE_NAME for lookups.
	* sol-thread.c (info_cb): Use SYMBOL_PRINT_NAME for messages.
	* stabsread.c (patch_block_stabs, define_symbol)
	(read_type, read_enum_type, common_block_end)
	(cleanup_undefined_types_1, scan_file_globals): Use
	SYMBOL_LINKAGE_NAME, SYMBOL_SET_LINKAGE_NAME, ALL_OBJFILE_MSYMBOLS,
	and SYMBOL_PRINT_NAME.
	* stack.c (print_frame_args): Use SYMBOL_LINKAGE_NAME.
	(print_frame, frame_info): Use SYMBOL_PRINT_NAME for output.  Use
	cp_remove_params instead of cplus_demangle.
	(print_block_frame_labels, print_frame_arg_vars): Use
	SYMBOL_LINKAGE_NAME.
	* symmisc.c (dump_msymbols): Use ALL_OBJFILE_MSYMBOLS and
	SYMBOL_LINKAGE_NAME.
	(dump_symtab_1, print_symbol, print_partial_symbols)
	(maintenance_check_symtabs): Use SYMBOL_LINKAGE_NAME.
	* symtab.h (DEPRECATED_SYMBOL_NAME): Delete.
	(SYMBOL_SET_LINKAGE_NAME): New.
	(SYMBOL_SET_NAMES): Add a comment.
	* tracepoint.c (set_traceframe_context, validate_actionline)
	(collect_symbol, scope_info): Use SYMBOL_LINKAGE_NAME for
	lookups and SYMBOL_PRINT_NAME for output.
	* typeprint.c (typedef_print): Use SYMBOL_LINKAGE_NAME.
	* xcoffread.c (process_xcoff_symbol): Use SYMBOL_SET_LINKAGE_NAME.
@
text
@d792 1
a792 1
	TYPE_FLAGS (SYMBOL_TYPE (s)) |= TYPE_FLAG_PROTOTYPED;
d1083 1
a1083 1
	      TYPE_FLAGS (t) |= TYPE_FLAG_UNSIGNED;
d1097 1
a1097 1
	    TYPE_FLAGS (t) |= TYPE_FLAG_STUB;
d1784 1
a1784 1
	  TYPE_FLAGS (t) |= TYPE_FLAG_TARGET_STUB;
@


1.92
log
@        Set the symtab field of symbols read from ECOFF debugging entries.
        * mdebugread.c (add_symbol): Add new parameter symtab.
        (parse_symbol): Update calls to add_symbol throughout.
@
text
@d629 1
a629 1
	  int bucket = hashname (DEPRECATED_SYMBOL_NAME (s));
d1067 3
a1069 3
		DEPRECATED_SYMBOL_NAME (enum_sym) =
		  obsavestring (f->name, strlen (f->name),
				&current_objfile->objfile_obstack);
d1331 1
a1331 1
	    TYPE_NAME (SYMBOL_TYPE (s)) = DEPRECATED_SYMBOL_NAME (s);
d4420 1
a4420 1
      if (DEPRECATED_SYMBOL_NAME (sym)[0] == inc
d4423 1
a4423 1
	  && strcmp (DEPRECATED_SYMBOL_NAME (sym), name) == 0)
@


1.91
log
@	* symtab.h (enum address_class): Remove LOC_REGPARM and
	LOC_COMPUTED_ARG.
	(struct symbol): Add is_argument.
	(SYMBOL_IS_ARGUMENT): Define.

	* ada-lang.c (ada_add_block_symbols): Use SYMBOL_IS_ARGUMENT.
	* buildsym.c (finish_block): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals)
	(print_frame_arg_vars): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (add_local_symbols): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.

	* coffread.c (process_coff_symbol): Set SYMBOL_IS_ARGUMENT.
	* dwarf2read.c (new_symbol): Likewise.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.

	* ada-exp.y (select_possible_type_sym): Don't handle LOC_REGPARM
	and LOC_COMPUTED_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* eval.c (evaluate_subexp_for_address): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* printcmd.c (address_info): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* tracepoint.c (collect_symbol, scope_info): Likewise.

testsuite/:
	* gdb.base/frame-args.exp: Handle arguments that are optimized
	out.
@
text
@d282 1
a282 1
static void add_symbol (struct symbol *, struct block *);
d652 1
a652 1
      add_symbol (s, b);
d698 1
a698 1
      add_symbol (s, top_stack->cur_block);
d707 1
a707 1
      add_symbol (s, top_stack->cur_block);
d784 1
a784 1
      add_symbol (s, b);
d1076 1
a1076 1
		add_symbol (enum_sym, top_stack->cur_block);
d1106 1
a1106 1
	add_symbol (s, top_stack->cur_block);
d1168 1
a1168 1
	  add_symbol (s, top_stack->cur_block);
d1300 1
a1300 1
      add_symbol (s, top_stack->cur_block);
d1907 1
a1907 1
      add_symbol (s, top_stack->cur_block);
d4437 1
a4437 1
add_symbol (struct symbol *s, struct block *b)
d4439 1
@


1.90
log
@	* symtab.h (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	* symtab.c (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	(search_symbols): Update.

	* linespec.c (find_methods, collect_methods): Update.
	(add_matching_methods, add_constructors): Update.
	(decode_compound, decode_dollar, decode_variable): Update.
	(lookup_prefix_sym): Update.

	(symbol_found): Remove SYM_SYMTAB parameter.
	Use SYMBOL_SYMTAB (sym) instead.

	* gdbtypes.c (lookup_typename): Update.
	(lookup_struct, lookup_union, lookup_enum): Update.
	(lookup_template_type): Update.
	(check_typedef): Update.
	* language.c (lang_bool_type): Update.
	* mdebugread.c (parse_procedure): Update.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* parse.c (write_dollar_variable): Update.
	* printcmd.c (address_info): Update.
	* source.c (select_source_symtab): Update.
	* stack.c (print_frame_args, print_frame_arg_vars): Update.
	* valops.c (find_function_in_inferior): Update.
	(value_struct_elt_for_reference): Update.
	* value.c (value_static_field, value_fn_field): Update.

	* alpha-mdebug-tdep.c (find_proc_desc): Update.
	* arm-tdep.c (arm_skip_prologue): Update.
	* mt-tdep.c (mt_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Update.

	* ada-lang.h (struct ada_symbol_info): Remove SYMTAB member.
	* ada-lang.c (ada_add_block_symbols): Remove SYMTAB parameter.
	(add_defn_to_vec): Likewise.
	(ada_add_block_symbols): Likewise.
	(lookup_cached_symbol, cache_symbol): Likewise.
	(standard_lookup): Update.
	(ada_lookup_symbol_list): Update.

	* c-valprint.c (c_val_print): Update.
	* cp-support.c (cp_lookup_rtti_type): Update.
	* jv-lang.c (java_lookup_class, get_java_object_type): Update.
	* objc-lang.c (lookup_struct_typedef, find_imps): Update.
	* p-valprint.c (pascal_val_print): Update.
	* scm-lang.c (scm_lookup_name): Update.

	* c-exp.y: Update.
	* f-exp.y: Update.
	* jv-exp.y: Update.
	* m2-exp.y: Update.
	* objc-exp.y: Update.
	* p-exp.y: Update.
@
text
@d674 1
d679 1
a679 1
	  SYMBOL_CLASS (s) = LOC_REGPARM;
d1205 1
a1205 1
		      switch (SYMBOL_CLASS (sym))
a1206 4
			case LOC_ARG:
			case LOC_REF_ARG:
			case LOC_REGPARM:
			case LOC_REGPARM_ADDR:
a1209 3
			  break;
			default:
			  break;
@


1.89
log
@	* objfiles.h (struct objfile): New GDBARCH member.
	(get_objfile_arch): Add prototype.
	* objfiles.c: Include "arch-utils.h".
	(allocate_objfile): Look up gdbarch associated with bfd.
	(get_objfile_arch): New function.
	* Makefile (objfiles.o): Update dependencies.

	* dwarf2-frame.c (decode_frame_entry_1): Replace current_gdbarch
	by objfile arch.
	* dwarf2loc.c (dwarf_expr_read_reg): Replace current_gdbarch
	by frame arch.
	(locexpr_describe_location): Replace current_gdbarch by
	objfile arch.
	* dwarf2read.c (die_type): Replace current_gdbarch by objfile arch.
	(dwarf2_add_field): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_base_type): Likewise.
	(new_symbol): Likewise.

	* coffread.c (decode_type): Add OBJFILE argument.  Update callers.
	(decode_base_type, decode_function_type): Likewise.
	(coff_read_struct_type, coff_read_enum_type): Likewise.
	(coff_symtab_read): Replace current_gdbarch by objfile arch.
	(decode_base_type): Likewise.
	(coff_read_enum_type): Likewise.
	(coff_read_struct_type): Replace current_objfile by OBJFILE argument.
	(coff_read_enum_type): Likewise.

	* dbxread.c (read_dbx_symtab): Replace current_gdbarch by objfile arch.
	(end_psymtab): Likewise.
	(process_one_symbol): Likewise.

	* mdebugread.c (parse_symbol): Replace current_gdbarch by objfile arch.
	(parse_procedure): Likewise.
	(parse_partial_symbols): Likewise.

	* somread.c (som_symtab_read): Replace current_gdbarch by objfile arch.

	* stabsread.c (define_symbol): Replace current_gdbarch by objfile arch.
	Replace static pcc_promotion_type and pcc_unsigned_promotion_type by
	built-in types.
	(read_range_type): Replace current_gdbarch by objfile arch.  Replace
	static range_index_type by built-in type.
	(read_one_struct_field): Replace current_gdbarch by objfile arch.
	(read_enum_type): Likewise.

	* xcoffread.c (read_xcoff_symtab): Replace current_gdbarch by
	objfile arch.
@
text
@d1883 1
a1883 1
      s = lookup_symbol (sh_name, NULL, VAR_DOMAIN, 0, NULL);
@


1.88
log
@	Updated copyright notices for most files.
@
text
@d562 1
d657 1
a657 1
	SYMBOL_TYPE (s) = builtin_type (current_gdbarch)->nodebug_data_symbol;
d1043 1
a1043 2
	      TYPE_LENGTH (t) = 
		gdbarch_int_bit (current_gdbarch) / HOST_CHAR_BIT;
d1828 1
d1966 1
a1966 1
    SYMBOL_TYPE (s) = builtin_type (current_gdbarch)->nodebug_text_symbol;
d2230 1
d2854 1
a2854 2
			  && gdbarch_sofun_address_maybe_missing
			      (current_gdbarch))
d3003 1
a3003 1
			if (gdbarch_static_transform_name_p (current_gdbarch))
d3005 1
a3005 1
					 (current_gdbarch, namestring);
d3234 1
a3234 2
			&& gdbarch_sofun_address_maybe_missing
			     (current_gdbarch))
@


1.87
log
@
	* gdbarch.sh (sofun_address_maybe_missing): New gdbarch variable.
	* gdbarch.c, gdbarch.h: Regenerate.
	* dbxread.c (find_stab_function_addr): Define unconditionally.
	(read_dbx_symtab): Use gdbarch_sofun_address_maybe_missing
	instead of SOFUN_ADDRESS_MAYBE_MISSING.
	(end_psymtab): Likewise.
	(process_one_symbol): Likewise.
	* mdebugread.c (parse_partial_symbols): Likewise.

	* symtab.h (struct minimal_symbol): Always define "filename" member.
	* elfread.c (elf_symtab_read): Use msym->filename unconditionally.
	* minsyms.c (lookup_minimal_symbol): Likewise.
	* symmisc.c (dump_msymbols): Likewise.

	* config/i386/i386sol2.mt (DEPRECATED_TM_FILE): Remove.
	* config/i386/linux.mt (DEPRECATED_TM_FILE): Remove.
	* config/i386/tm-i386sol2.h: Remove file.
	* config/i386/tm-linux.h: Remove file.
	* i386-linux-tdep.c (i386_linux_init_abi): Add call to
	set_gdbarch_sofun_address_maybe_missing.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Likewise.

	* config/powerpc/linux.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/nbsd.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/obsd.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/ppc-eabi.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/ppc-sim.mt (DEPRECATED_TM_FILE): Remove.
	* config/powerpc/tm-ppc-eabi.h: Remove file.
	* rs6000-tdep.c (rs6000_gdbarch_init): Add call to
	set_gdbarch_sofun_address_maybe_missing.

	* config/sparc/sol2-64.mt (DEPRECATED_TM_FILE): Remove.
	* config/sparc/sol2.mt (DEPRECATED_TM_FILE): Remove.
	* config/sparc/tm-sol2.h: Remove file.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Add call to
	set_gdbarch_sofun_address_maybe_missing.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Likewise.

doc/ChangeLog:

	* gdbarch.texi (Target Conditionals): Remove documentation of
	SOFUN_ADDRESS_MAYBE_MISSING, replaced by ...
	(Compiler Characteristics): ... documentation of
	set_gdbarch_sofun_address_maybe_missing.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007
@


1.86
log
@	* gdbarch.sh (static_transform_name): New gdbarch callback.
	* gdbarch.c, gdbarch.h: Regenerate.
	* dbxread.c (read_dbx_symtab): Use gdbarch_static_transform_name
	instead of STATIC_TRANSFORM_NAME.
	* mdebugread.c (parse_partial_symbols): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* xcoffread.c (scan_xcoff_symtab): Likewise.

	* config/i368/tm-i386sol2.h (STATIC_TRANSFORM_NAME): Remove.
	(IS_STATIC_TRANSFORM_NAME): Remove.
	* i386-tdep.c (sunpro_static_transform_name): Remove, move to ...
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): ... here.
	(i386_sol2_init_abi): Install it.

	* config/sparc/tm-sol2.h (STATIC_TRANSFORM_NAME): Remove.
	(IS_STATIC_TRANSFORM_NAME): Remove.
	* sparc-tdep.c (sparc_stabs_unglobalize_name): Remove, move to ...
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): ... here.
	(sparc32_sol2_init_abi): Install it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Likewise.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Add prototype.
@
text
@a2846 1
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
d2851 3
a2853 1
		      if (sh.value == 0)
d2860 1
a2860 3
#else
		      textlow_not_set = 0;
#endif
a3226 1
#ifdef SOFUN_ADDRESS_MAYBE_MISSING
d3232 3
a3234 1
		    if (pst)
a3239 1
#endif
@


1.85
log
@	* alpha-mdebug-tdep.c: Include "gdb_string.h".
	(find_proc_desc): Add fix-up code for setjmp procedure descriptor.
	* mdebugread.c (parse_procedure): Remove setjmp fix-up code.
	* Makefile.in (alpha-mdebug-tdep.o): Update dependencies.

	* config/alpha/alpha.mt (DEPRECATED_TM_FILE): Remove.
	* config/alpha/alpha-linux.mt (DEPRECATED_TM_FILE): Remove.
	* config/alpha/alpha-osf1.mt (DEPRECATED_TM_FILE): Remove.
	* config/alpha/fbsd.mt (DEPRECATED_TM_FILE): Remove.
	* config/alpha/tm-alpha.h: Remove file.
@
text
@d3002 5
a3006 3
#ifdef STATIC_TRANSFORM_NAME
			namestring = STATIC_TRANSFORM_NAME (namestring);
#endif
@


1.84
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@a1944 15

      /* Correct incorrect setjmp procedure descriptor from the library
         to make backtrace through setjmp work.  */
      if (e->pdr.pcreg == 0
	  && strcmp (sh_name, "setjmp") == 0)
	{
	  complaint (&symfile_complaints, _("fixing bad setjmp PDR from libc"));
#ifdef RA_REGNUM
	  e->pdr.pcreg = RA_REGNUM;
#else
	  e->pdr.pcreg = 0;
#endif
	  e->pdr.regmask = 0x80000000;
	  e->pdr.regoffset = -4;
	}
@


1.83
log
@	* gdbtypes.h (struct builtin_type): New members nodebug_text_symbol,
	nodebug_data_symbol, nodebug_unknown_symbol, and nodebug_tls_symbol.
	* gdbtypes.c (gdbtypes_post_init): Initialize nodebug_ default types.

	* parse.c (msym_text_symbol_type, msym_data_symbol_type): Remove.
	(msym_unknown_symbol_type, msym_tls_symbol_type): Remove.
	(write_exp_msymbol): Use builtin nodebug_ types instead of them.
	(build_parse): Remove.
	(_initialize_parse): Do not call build_parse.  Do not register
	msym_ types for gdbarch-swapping.

	* dwarf2read.c (new_symbol): Use default nodebug_data_symbol type
	instead of creating private type.

	* xcoffread.c (func_symbol_type, var_symbol_type): Remove.
	(_initialize_xcoffread): Do not initialized them.
	(process_xcoff_symbol): Use builtin nodebug_ types instead of them.

	* mdebugread.c (nodebug_func_symbol_type): Remove.
	(nodebug_var_symbol_type): Remove.
	(_initialize_mdebugread): Do not initialize them.
	(parse_symbol): Use builtin nodebug_ type instead of them.
	(parse_procedure): Likewise.
@
text
@d15 1
a15 1
   the Free Software Foundation; either version 2 of the License, or
d24 1
a24 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.82
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (STAB_REG_TO_REGNUM): Replace by
	gdbarch_stab_reg_to_regnum.
	* stabsread.c (define_symbol): Likewise.
	* gdbarch.sh (ECOFF_REG_TO_REGNUM): Replace by
	gdbarch_ecoff_reg_to_regnum.
	* mdebugread.c (parse_symbol): Likewise.
	* i386-tdep.c (i386_gdbarch_init): Likewise (comment).
	* gdbarch.sh (DWARF_REG_TO_REGNUM): Replace by
	gdbarch_dwarf_reg_to_regnum.
	* gdbarch.sh (SDB_REG_TO_REGNUM): Replace by gdbarch_sdb_reg_to_regnum.
	* coffread.c (process_coff_symbol): Likewise.
	* gdbarch.sh (DWARF2_REG_TO_REGNUM): Replace by
	gdbarch_dwarf2_reg_to_regnum.
	* dwarf2loc.c (dwarf_expr_read_reg,dwarf2_evaluate_loc_desc)
	(locexpr_describe_location): Likewise.
	* dwarf2-frame.c (read_reg,execute_cfa_program,dwarf2_frame_cache)
	(dwarf2_frame_prev_register,dwarf2_signal_frame_this_id): Likewise.
	* dwarf2loc.c (DWARF2_REG_TO_REGNUM): Remove macro.
	* dwarf2read.c (DWARF2_REG_TO_REGNUM): Remove macro.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@a239 5
/* Types for symbols from files compiled without debugging info.  */

static struct type *nodebug_func_symbol_type;
static struct type *nodebug_var_symbol_type;

d658 1
a658 1
	SYMBOL_TYPE (s) = nodebug_var_symbol_type;
d1982 1
a1982 1
    SYMBOL_TYPE (s) = nodebug_func_symbol_type;
a4878 8

  nodebug_func_symbol_type = init_type (TYPE_CODE_FUNC, 1, 0,
					"<function, no debug info>", NULL);
  TYPE_TARGET_TYPE (nodebug_func_symbol_type) = mdebug_type_int;
  nodebug_var_symbol_type =
    init_type (TYPE_CODE_INT, 
	       gdbarch_int_bit (current_gdbarch) / HOST_CHAR_BIT, 0,
	       "<variable, no debug info>", NULL);
@


1.81
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_FLOAT_BIT): Replace by gdbarch_float_bit.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* mdebugread.c (_initialize_mdebugread): Likewise.
	* m2-lang.c (m2_create_fundamental_type)
	(_initialize_m2_language): Likewise.
	* gdbtypes.c (build_gdbtypes): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbarch.sh (TARGET_FLOAT_FORMAT): Replace by gdbarch_float_format.
	* value.c (unpack_double): Likewise (comment).
	* gdbtypes.c (build_gdbtypes): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* gdbarch.sh (TARGET_DOUBLE_BIT): Replace by gdbarch_double_bit.
	* valarith.c (value_binop): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* mdebugread.c (_initialize_mdebugread): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* gdbtypes.c (build_gdbtypes): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* cris-tdep.c (cris_gdbarch_init): Likewise (comment).
	* c-lang.c (c_create_fundamental_type): Likewise.
	* ada-lex.l (processReal): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbarch.sh (TARGET_DOUBLE_FORMAT): Replace by gdbarch_double_format.
	* value.c (unpack_double): Likewise (comment).
	* gdbtypes.c (build_gdbtypes): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* gdbarch.sh (TARGET_LONG_DOUBLE_BIT): Replace by
	gdbarch_long_double_bit.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* gdbtypes.c (build_gdbtypes): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* ada-lex.l (processReal): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbarch.sh (TARGET_LONG_DOUBLE_FORMAT): Replace by
	gdbarch_long_double_format.
	* gdbtypes.c (build_gdbtypes): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d647 1
a647 1
	  svalue = ECOFF_REG_TO_REGNUM (svalue);
d685 1
a685 1
	  svalue = ECOFF_REG_TO_REGNUM (svalue);
d694 1
a694 1
	  svalue = ECOFF_REG_TO_REGNUM (svalue);
@


1.80
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_SHORT_BIT): Replace by gdbarch_int_bit.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* gdbarch.sh (TARGET_INT_BIT): Replace by gdbarch_int_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type, ada_language_arch_info)
	(gdbtypes_post_init, build_gdbtypes): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* parse.c (build_parse): Likewise.
	* xcoffread.c (_initialize_xcoffread): Likewise.
	* stabsread.c (define_symbol, read_one_struct_field, read_enum_type)
	(read_range_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* f-lang.c (build_fortran_types, f_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type, _initialize_m2_language)
	(m2_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (coff_read_enum_type): Likewise.
	* mdebugread.c (parse_symbol, _initialize_mdebugread): Likewise.
	* dwarf2read.c (new_symbol): Likewise.
	* gdbarch.sh (TARGET_LONG_BIT): Replace by gdbarch_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* valarith.c (value_binop): Likewise.
	* symfile.c (read_target_long_array, simple_overlay_update_1): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* symfile.c (TARGET_LONG_BYTES): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (decode_base_type): Likewise.
	* gdbarch.sh (TARGET_LONG_LONG_BIT): Replace by gdbarch_long_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (gdbtypes_post_init, build_gdbtypes): Likewise.
	* stabsread.c (read_range_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d4844 3
a4846 3
    init_type (TYPE_CODE_FLT, TARGET_FLOAT_BIT / TARGET_CHAR_BIT,
	       0,
	       "float", (struct objfile *) NULL);
d4848 3
a4850 3
    init_type (TYPE_CODE_FLT, TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
	       0,
	       "double", (struct objfile *) NULL);
d4852 3
a4854 3
    init_type (TYPE_CODE_COMPLEX, 2 * TARGET_FLOAT_BIT / TARGET_CHAR_BIT,
	       0,
	       "complex", (struct objfile *) NULL);
d4857 3
a4859 3
    init_type (TYPE_CODE_COMPLEX, 2 * TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
	       0,
	       "double complex", (struct objfile *) NULL);
d4881 1
a4881 1
	       TARGET_DOUBLE_BIT / TARGET_CHAR_BIT,
@


1.79
log
@Copyright updates for 2007.
@
text
@d1049 2
a1050 1
	      TYPE_LENGTH (t) = TARGET_INT_BIT / HOST_CHAR_BIT;
d4875 1
a4875 1
	       TARGET_INT_BIT / TARGET_CHAR_BIT,
d4889 2
a4890 1
    init_type (TYPE_CODE_INT, TARGET_INT_BIT / HOST_CHAR_BIT, 0,
@


1.78
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 3
a5 3
   Copyright (C) 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
@


1.77
log
@        * mdebugread.c (record_minimal_symbol): New procedure.
        (parse_partial_symbols): Use record_minimal_symbol to record
        the new minimal symbols instead of prim_record_minimal_symbol
        and prim_record_minimal_symbol_and_info.
@
text
@d3 1
a3 1
   Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
d25 2
a26 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.76
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d2165 79
d2558 2
a2559 1
	prim_record_minimal_symbol (name, svalue, ms_type, objfile);
d2676 3
a2678 7
			  prim_record_minimal_symbol_and_info (namestring,
							       sh.value,
							       mst_file_text,
							       NULL,
							       SECT_OFF_TEXT (objfile),
							       NULL,
							       objfile);
d2720 3
a2722 7
			  prim_record_minimal_symbol_and_info (namestring,
							       sh.value,
							       mst_file_data,
							       NULL,
							       SECT_OFF_DATA (objfile),
							       NULL,
							       objfile);
d2730 3
a2732 7
			  prim_record_minimal_symbol_and_info (namestring,
							       sh.value,
							       mst_file_bss,
							       NULL,
							       SECT_OFF_BSS (objfile),
							       NULL,
							       objfile);
@


1.75
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d314 1
a314 1
      printf_filtered ("Reading in symbols for %s...", pst->filename);
d327 1
a327 1
    printf_filtered ("done.\n");
d410 1
a410 1
	printf_unfiltered ("\n%s not compiled with -g, debugging support is limited.\n",
d412 1
a412 1
      printf_unfiltered ("You should compile with -g2 or -g3 for best debugging support.\n");
d2046 1
a2046 1
	printf_filtered ("Warning: %s `%s' is undefined (in %s)\n",
d4112 1
a4112 1
	  printf_filtered ("File %s contains %d unresolved references:",
@


1.74
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d127 1
a127 1
  complaint (&symfile_complaints, "bad aux index at symbol %s", arg1);
d133 1
a133 1
  complaint (&symfile_complaints, "unknown external symbol %s", arg1);
d139 1
a139 1
  complaint (&symfile_complaints, "cannot map ECOFF basic type 0x%x for %s",
d146 1
a146 1
  complaint (&symfile_complaints, "guessed tag type of %s incorrectly", arg1);
d152 1
a152 1
  complaint (&symfile_complaints, "bad rfd entry for %s: file %d, index %d",
d159 1
a159 1
  complaint (&symfile_complaints, "unexpected type code for %s", arg1);
d743 1
a743 1
                               "unknown symbol type 0x%x", sh->st);
d960 1
a960 1
			   "declaration block contains unhandled symbol type %d",
d1248 1
a1248 1
		   "stEnd with storage class %d not handled", sh->sc);
d1360 1
a1360 1
      complaint (&symfile_complaints, "unknown symbol type 0x%x", sh->st);
d1501 1
a1501 1
	    complaint (&symfile_complaints, "can't handle TIR fBitfield for %s",
d1531 1
a1531 1
		     "unable to cross ref btIndirect for %s", sym_name);
d1648 1
a1648 1
		     "unable to cross ref btTypedef for %s", sym_name);
d1698 1
a1698 1
    complaint (&symfile_complaints, "illegal TIR continued for %s", sym_name);
d1761 1
a1761 1
		     "illegal array index type for %s, assuming int", sym_name);
d1811 1
a1811 1
      complaint (&symfile_complaints, "unknown type qualifier 0x%x", tq);
d1847 1
a1847 1
		     "can't handle PDR for static proc at 0x%lx",
d1908 1
a1908 1
      complaint (&symfile_complaints, "PDR for %s, but no symbol", sh_name);
d1957 1
a1957 1
	  complaint (&symfile_complaints, "fixing bad setjmp PDR from libc");
d2147 1
a2147 1
			 "guessed size of linetable for %s incorrectly",
d2161 1
a2161 1
	     "function `%s' appears to be defined outside of all compilation units",
d2342 1
a2342 1
		     "bad ifd for external symbol: %d (max %ld)", ext_in->ifd,
d2349 1
a2349 1
		     "bad iss for external symbol: %ld (max %ld)",
d3168 1
a3168 1
				   "unknown symbol descriptor `%c'", p[1]);
d3229 1
a3229 1
		    complaint (&symfile_complaints, "unknown symbol type %s",
d3326 1
a3326 1
				 "bad proc end in aux found from symbol %s",
d3441 1
a3441 1
				 "bad aux index at block symbol %s", name);
d3461 1
a3461 1
		  complaint (&symfile_complaints, "unknown local symbol %s",
d3463 1
a3463 1
		  complaint (&symfile_complaints, "with type %d", sh.st);
d3489 1
a3489 1
		internal_error (__FILE__, __LINE__, "failed internal consistency check");
d3622 1
a3622 1
	      complaint (&symfile_complaints, "bad file number %ld", rh);
d3929 1
a3929 1
	    complaint (&symfile_complaints, "unknown stabs symbol %s", name);
d4285 1
a4285 1
		       "illegal tq0 in forward typedef for %s", sym_name);
d4323 1
a4323 1
			 "illegal bt %d in forward typedef for %s", tir.bt,
@


1.73
log
@2005-02-03  Andrew Cagney  <cagney@@gnu.org>

	* utils.c (xzalloc): New function.
	* defs.h (XZALLOC): Use xzalloc.
	(xzalloc): Declare.
	* value.c (allocate_value): Allocate a zeroed buffer.
	* mdebugread.c (xzalloc): Delete.
@
text
@d4692 1
a4692 1
    error ("Error reading ECOFF debugging information: %s",
@


1.72
log
@2005-01-13  Michael Snyder  <msnyder@@redhat.com>

	* mdebugread.c: Whitespace tweaks.
@
text
@a299 11
/* Allocate zeroed memory */

static void *
xzalloc (unsigned int size)
{
  void *p = xmalloc (size);

  memset (p, 0, size);
  return p;
}

@


1.71
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* mdebugread.h (MDEBUG_EFI_SYMBOL_NAME): Define.
	* mdebugread.c (MDEBUG_EFI_SYMBOL_NAME): Delete.
	* config/alpha/tm-alpha.h (MDEBUG_EFI_SYMBOL_NAME): Delete.
	* config/mips/tm-mips.h (MDEBUG_EFI_SYMBOL_NAME): Delete.
@
text
@d791 1
a791 1
	     global). */
@


1.70
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* mdebugread.h (ecoff_relocate_efi): Delete declaration.
	* mdebugread.c (ecoff_relocate_efi): Delete function.
	* objfiles.c (objfile_relocate): Delete #ifdef
	MDEBUG_EFI_SYMBOL_NAME code.
@
text
@a59 8

/* These are needed if the tm.h file does not contain the necessary
   mips specific definitions.  */

#ifndef MDEBUG_EFI_SYMBOL_NAME
#define MDEBUG_EFI_SYMBOL_NAME "__GDB_EFI_INFO__"
#endif

@


1.69
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* mdebugread.c (parse_procedure): Wrap use of RA_REGNUM in #ifdef.
@
text
@a2007 12
/* Relocate the extra function info pointed to by the symbol table.  */

void
ecoff_relocate_efi (struct symbol *sym, CORE_ADDR delta)
{
  struct mdebug_extra_func_info *e;

  e = (struct mdebug_extra_func_info *) SYMBOL_VALUE (sym);

  e->pdr.adr += delta;
}

@


1.68
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* mdebugread.h: Include "coff/sym.h" and "coff/symconst.h".
	(struct mdebug_extra_func_info): Define.
	* config/alpha/tm-alpha.h: Delete same.
	* config/mips/tm-mips.h: Delete same.
	* mdebugread.c: Delete same.
	* Makefile.in: Update dependencies.
	* mips-mdebug-tdep.c: Include "mdebugread.h".
@
text
@a65 3
#ifndef RA_REGNUM
#define RA_REGNUM 0
#endif
d1977 1
d1979 3
@


1.67
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* objfiles.c: Include "mdebugread.h".
	* mdebugread.c: Include "mdebugread.h".
	(ecoff_relocate_cfi): Delete.
	* config/alpha/tm-alpha.h (ecoff_relcate_cfi): Delete.
	* config/mips/tm-mips.h (ecoff_relcate_cfi): Delete.
	* mdebugread.h (ecoff_relocate_efi): New file.
	* Makefile.in: Update dependencies.
@
text
@a65 7
#include "coff/sym.h"
#include "coff/symconst.h"
struct mdebug_extra_func_info
{
  long numargs;
  PDR pdr;
};
@


1.66
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* config/alpha/tm-alpha.h (MDEBUG_EFI_SYMBOL_NAME): Rename
	MIPS_EFI_SYMBOL_NAME.
	(mips_extra_func_info_t, mips_extra_func_info): Delete.
	(struct mdebug_extra_func_info): Replace struct
	alpha_extra_func_info and alpha_extra_func_info_t.
	* config/mips/tm-mips.h (MDEBUG_EFI_SYMBOL_NAME): Rename
	MIPS_EFI_SYMBOL_NAME.
	(struct mdebug_extra_func_info): Replace struct
	alpha_extra_func_info and alpha_extra_func_info_t.
	* objfiles.c, mips-tdep.c, mips-mdebug-tdep.c: Update.
	* mdebugread.c, alpha-mdebug-tdep.c:
@
text
@d59 1
a65 1
extern void ecoff_relocate_efi (struct symbol *, CORE_ADDR);
@


1.65
log
@2004-10-23  Andrew Cagney  <cagney@@gnu.org>

	* objfiles.h (struct objfile): Rename obj_private to
	deprecated_obj_private, sym_private to deprecated_sym_private, and
	sym_stab_info to deprecated_sym_stab_info.
	* gdb-stabs.h: Update.
	* elfread.c: Update.
	* dbxread.c: Update.
	* coffread.c: Update.
	* xcoffread.c: Update.
	* symfile.c: Update.
	* somread.c: Update.
	* nlmread.c: Update.
	* mdebugread.c: Update.
	* hpread.c: Update.
	* coffread.c: Update.
@
text
@d63 2
a64 2
#ifndef MIPS_EFI_SYMBOL_NAME
#define MIPS_EFI_SYMBOL_NAME "__GDB_EFI_INFO__"
d68 5
a72 6
typedef struct mips_extra_func_info
  {
    long numargs;
    PDR pdr;
  }
 *mips_extra_func_info_t;
d1183 1
a1183 1
	  struct mips_extra_func_info *e;
d1191 1
a1191 1
	  s = new_symbol (MIPS_EFI_SYMBOL_NAME);
d1195 1
a1195 1
	  e = ((struct mips_extra_func_info *)
d1197 2
a1198 2
			      sizeof (struct mips_extra_func_info)));
	  memset (e, 0, sizeof (struct mips_extra_func_info));
d1848 1
a1848 1
   information we need into a MIPS_EFI_SYMBOL_NAME symbol that has
d1854 1
a1854 1
   to look for the function which contains the MIPS_EFI_SYMBOL_NAME symbol
d1865 1
a1865 1
  struct mips_extra_func_info *e;
d1961 1
a1961 1
  i = mylookup_symbol (MIPS_EFI_SYMBOL_NAME, b, LABEL_DOMAIN, LOC_CONST);
d1965 1
a1965 1
      e = (struct mips_extra_func_info *) SYMBOL_VALUE (i);
d2019 1
a2019 1
  struct mips_extra_func_info *e;
d2021 1
a2021 1
  e = (struct mips_extra_func_info *) SYMBOL_VALUE (sym);
d3931 2
a3932 2
		  struct mips_extra_func_info *e =
		  ((struct mips_extra_func_info *)
d3934 2
a3935 2
				  sizeof (struct mips_extra_func_info)));
		  struct symbol *s = new_symbol (MIPS_EFI_SYMBOL_NAME);
d3937 1
a3937 1
		  memset (e, 0, sizeof (struct mips_extra_func_info));
@


1.64
log
@* language.c (local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string, use C format, and move to
utils.c
(local_hex_string_custom): Rename to hex_string_custom and change
interface.  Now uses C format.  Move to utils.c
(local_octal_format_custom): Remove.
(local_decimal_format_custom): Remove.
(unknown_language_defn): Remove language-specific number
formatting entries.
(auto_language_defn): Ditto.
(local_language_defn): Ditto.
* language.h (struct language_format_info): Delete declaration.
(struct language_defn): Remove language_format_info fields
la_binary_format, la_octal_format, la_decimal_format, la_hex_format.
(local_binary_format): Remove macro.
(local_binary_format_prefix): Remove macro.
(local_binary_format_specifier): Remove macro.
(local_binary_format_suffix): Remove macro.
(local_octal_format): Remove macro.
(local_octal_format_prefix): Remove macro.
(local_octal_format_specifier): Remove macro.
(local_octal_format_suffix): Remove macro.
(local_decimal_format): Remove macro.
(local_decimal_format_prefix): Remove macro.
(local_decimal_format_specifier): Remove macro.
(local_decimal_format_suffix): Remove macro.
(local_hex_format): Remove macro.
(local_hex_format_prefix): Remove macro.
(local_hex_format_specifier): Remove macro.
(local_hex_format_suffix): Remove macro.
(local_decimal_format_custom): Remove.
(local_octal_format_custom): Remove.
(local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string and move to defs.h.
(local_hex_string_custom): Rename to hex_string_custom, change
interface, and move to defs.h.
* utils.c: (int_string): New function.
(hex_string): New function (from language.c).
(hex_string_custom): New function (from language.c).
(octal2str): New function.
(decimal2str): Add width parameter.
(paddr_u): Use new decimal2str interface.
(paddr_d): Ditto.
* defs.h (hex_string): Declare.
(hex_string_custom): Declare.
(int_string): Declare.
* printcmd.c (print_scalar_formatted): Remove localized binary
formatting.
* valprint.c (print_longest): Use int_string.
(print_floating): Use C hex format.
(print_hex_chars): Ditto.
(print_binary_chars): Remove language-specific formatting.
(print_octal_chars): Use C octal format.
(print_decimal_chars): Delocalize format.
(print_decimal): Remove.
* ada-lang.c (ada_language_defn): Remove language-specific number
formatting entries.
* p-lang.c (pascal_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* f-lang.c (f_language_defn): Ditto.
* jv-lang.c (java_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* scm-lang.c (scm_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.
* memattr.c (mem_info_command): Use renamed hex_string_custom with
new interface.
* pa64solib.c (pa64_sharedlibrary_info_command): Ditto.
* ui-out.c (ui_out_field_core_addr): Ditto.
* breakpoint.c (breakpoint_adjustment_warning): Ditto.
* exec.c (print_section_info): Ditto.
* i387-tdep.c (print_i387_status_word): Ditto.
(print_i387_control_word): Ditto.
(i387_print_float_info): Ditto.
* maint.c (maint_print_section_info): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* somsolib.c (som_sharedlibrary_info_command): Ditto.
* symtab.c (print_msymbol_info): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* solib-frv.c (lm_base): Ditto.
(frv_current_sos): Ditto.
(enable_break2): Ditto.
(enable_break): Ditto.
* dbxread.c (read_dbx_symtab): Use renamed hex_string.
(process_one_symbol): Ditto.
* infcmd.c (program_info): Ditto.
* mdebugread.c (parse_partial_symbols): Ditto.
* symfile.c (add_symbol_file_command): Ditto.
* cli/cli-cmds.c (edit_command): Ditto.
(list_command): Ditto.
* infcall.c (call_function_by_hand): Ditto.
* remote-vx.c (vx_run_files_info): Ditto.
(vx_wait): Ditto.
(vx_attach): Ditto.
(vx_detach): Ditto.
(vx_kill): Ditto.
* aix-thread.c (pdc_symbol_addrs): Ditto.
(pdc_read_regs): Ditto.
(pdc_write_regs): Ditto.
(pdc_read_data): Ditto.
(pdc_write_data): Ditto.
* d10v-tdep.c (display_trace): Ditto.
* rs6000-nat.c (find_toc_address): Ditto.
* aix-thread.c: Don't include language.h.
* buildsym.c: Ditto.
* dbxread.c: Ditto.
* mdebugread.c: Ditto.
* rs6000-nat.c: Ditto.
* buildsym.c (make_blockvector): Use renamed hex_string.
@
text
@d539 3
a541 3
   to be in the sym_private field.  I took it out when I split
   mdebugread from mipsread, because this might not be the only type
   of symbols read from an object file.  Instead, we allocate the
@


1.63
log
@2004-09-07  Andrew Cagney  <cagney@@gnu.org>

	* vx-share/wait.h: Delete #ifdef USG.
	* utils.c (request_quit): Ditto.
	* tui/tui.c (tui_reset): Ditto.
	* remote.c: Ditto.
	* remote-sds.c: Ditto.
	* remote-rdi.c: Ditto.
	* mdebugread.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* infttrace.c: Ditto.
	* infptrace.c: Ditto.
	* i386v-nat.c: Ditto.
	* exec.c: Ditto.
	* dbxread.c: Ditto.
	* core-aout.c: Ditto.
@
text
@a90 1
#include "language.h"		/* For local_hex_string() */
d3268 1
a3268 1
			       local_hex_string (type_code)); /*CUR_SYMBOL_TYPE*/
@


1.62
log
@2004-05-07  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Delete unused fields
	deprecated_entry_file_lowpc and deprecated_entry_file_highpc.
	* objfiles.c (init_entry_point_info, objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab, read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@a78 4
#ifdef USG
#include <sys/types.h>
#endif

@


1.61
log
@2004-04-30  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_pc_in_sigtramp): Delete.
	(mips_gdbarch_init): Do not set pc_in_sigtramp.
	* mipsread.c (sigtramp_address): Delete extern variable.
	(mipscoff_new_init): Delete reference.
	* mdebugread.c (sigtramp_address, sigtramp_end): Delete variables.
	(fixup_sigtramp): Delete function.
	* config/mips/tm-mips.h (sigtramp_address, sigtramp_end)
	(fixup_sigtramp): Delete declarations.
@
text
@a3603 7
      if (objfile->ei.entry_point >= save_pst->textlow &&
	  objfile->ei.entry_point < save_pst->texthigh)
	{
	  objfile->ei.deprecated_entry_file_lowpc = save_pst->textlow;
	  objfile->ei.deprecated_entry_file_highpc = save_pst->texthigh;
	}

@


1.60
log
@2004-02-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symfile.c (init_entry_point_info, entry_point_address): Move
	from here...
	* objfiles.c (init_entry_point_info, entry_point_address):..to
	here.
	* symfile.h (init_entry_point_info, entry_point_address): Remove
	prototypes.
	* objfiles.h (init_entry_point_info, entry_point_address):Add
	prototypes.
	* cris-tdep.c: Remove include of symfile.h. Add include of
	objfiles.h.
	* infcall.c: Ditto.
	* mcore-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
 	* v850-tdep.c: Ditto.
	* arm-tdep.c: Remove include of symfile.h.
	* blockframe.c: Ditto.
	* coffread.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* frv-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* mipsread.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* s390-tdep.c: Ditto.
	* sh-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* gdbarch.sh: Remove include of symfile.h.
	* gdbarch.c: Regenerate.
	* solib-irix.c (enable_break): Use entry_point_address().
	Add comment about include file.
	* xcoffread.c: Add comment about include file.
	* Makefile.in (arm-tdep.o, blockframe.o, coffread.o, cris-tdep.o)
	(dbxread.o, dwarf2read.o, dwarfread.o, frv-tdep.o, gdbarch.o)
	(ia64-tdep.o, infcall.o, mcore-tdep.o, mdebugread.o, mipsread.o)
	(mn10300-tdep.o, rs6000-nat.o, s390-tdep.o, sh64-tdep.o)
	(sh-tdep.o, v850-tdep.o, xstormy16-tdep.o): Update dependencies.
@
text
@a323 4
/* Address bounds for the signal trampoline in inferior, if any */

CORE_ADDR sigtramp_address, sigtramp_end;

a4749 120


/* Things used for calling functions in the inferior.
   These functions are exported to our companion
   mips-tdep.c file and are here because they play
   with the symbol-table explicitly. */

/* Sigtramp: make sure we have all the necessary information
   about the signal trampoline code. Since the official code
   from MIPS does not do so, we make up that information ourselves.
   If they fix the library (unlikely) this code will neutralize itself. */

/* FIXME: This function is called only by mips-tdep.c.  It needs to be
   here because it calls functions defined in this file, but perhaps
   this could be handled in a better way.  Only compile it in when
   tm-mips.h is included. */

#ifdef TM_MIPS_H

void
fixup_sigtramp (void)
{
  struct symbol *s;
  struct symtab *st;
  struct block *b, *b0 = NULL;

  sigtramp_address = -1;

  /* We have to handle the following cases here:
     a) The Mips library has a sigtramp label within sigvec.
     b) Irix has a _sigtramp which we want to use, but it also has sigvec.  */
  s = lookup_symbol ("sigvec", 0, VAR_DOMAIN, 0, NULL);
  if (s != 0)
    {
      b0 = SYMBOL_BLOCK_VALUE (s);
      s = lookup_symbol ("sigtramp", b0, VAR_DOMAIN, 0, NULL);
    }
  if (s == 0)
    {
      /* No sigvec or no sigtramp inside sigvec, try _sigtramp.  */
      s = lookup_symbol ("_sigtramp", 0, VAR_DOMAIN, 0, NULL);
    }

  /* But maybe this program uses its own version of sigvec */
  if (s == 0)
    return;

  /* Did we or MIPSco fix the library ? */
  if (SYMBOL_CLASS (s) == LOC_BLOCK)
    {
      sigtramp_address = BLOCK_START (SYMBOL_BLOCK_VALUE (s));
      sigtramp_end = BLOCK_END (SYMBOL_BLOCK_VALUE (s));
      return;
    }

  sigtramp_address = SYMBOL_VALUE (s);
  sigtramp_end = sigtramp_address + 0x88;	/* black magic */

  /* But what symtab does it live in ? */
  st = find_pc_symtab (SYMBOL_VALUE (s));

  /*
   * Ok, there goes the fix: turn it into a procedure, with all the
   * needed info.  Note we make it a nested procedure of sigvec,
   * which is the way the (assembly) code is actually written.
   */
  SYMBOL_DOMAIN (s) = VAR_DOMAIN;
  SYMBOL_CLASS (s) = LOC_BLOCK;
  SYMBOL_TYPE (s) = init_type (TYPE_CODE_FUNC, 4, 0, (char *) NULL,
			       st->objfile);
  TYPE_TARGET_TYPE (SYMBOL_TYPE (s)) = mdebug_type_void;

  /* Need a block to allocate MIPS_EFI_SYMBOL_NAME in */
  b = new_block (NON_FUNCTION_BLOCK);
  SYMBOL_BLOCK_VALUE (s) = b;
  BLOCK_START (b) = sigtramp_address;
  BLOCK_END (b) = sigtramp_end;
  BLOCK_FUNCTION (b) = s;
  BLOCK_SUPERBLOCK (b) = BLOCK_SUPERBLOCK (b0);
  add_block (b, st);
  sort_blocks (st);

  /* Make a MIPS_EFI_SYMBOL_NAME entry for it */
  {
    struct mips_extra_func_info *e =
    ((struct mips_extra_func_info *)
     xzalloc (sizeof (struct mips_extra_func_info)));

    e->numargs = 0;		/* the kernel thinks otherwise */
    e->pdr.frameoffset = 32;
    e->pdr.framereg = SP_REGNUM;
    /* Note that setting pcreg is no longer strictly necessary as
       mips_frame_saved_pc is now aware of signal handler frames.  */
    e->pdr.pcreg = PC_REGNUM;
    e->pdr.regmask = -2;
    /* Offset to saved r31, in the sigtramp case the saved registers
       are above the frame in the sigcontext.
       We have 4 alignment bytes, 12 bytes for onstack, mask and pc,
       32 * 4 bytes for the general registers, 12 bytes for mdhi, mdlo, ownedfp
       and 32 * 4 bytes for the floating point registers.  */
    e->pdr.regoffset = 4 + 12 + 31 * 4;
    e->pdr.fregmask = -1;
    /* Offset to saved f30 (first saved *double* register).  */
    e->pdr.fregoffset = 4 + 12 + 32 * 4 + 12 + 30 * 4;
    e->pdr.isym = (long) s;
    e->pdr.adr = sigtramp_address;

    current_objfile = st->objfile;	/* Keep new_symbol happy */
    s = new_symbol (MIPS_EFI_SYMBOL_NAME);
    SYMBOL_VALUE (s) = (long) e;
    SYMBOL_DOMAIN (s) = LABEL_DOMAIN;
    SYMBOL_CLASS (s) = LOC_CONST;
    SYMBOL_TYPE (s) = mdebug_type_void;
    current_objfile = NULL;
  }

  dict_add_symbol (BLOCK_DICT (b), s);
}

#endif /* TM_MIPS_H */
@


1.60.2.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d79 4
d95 1
d324 4
d3277 1
a3277 1
			       hex_string (type_code)); /*CUR_SYMBOL_TYPE*/
d3608 7
d4754 120
@


1.59
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* buildsym.c (free_pending_blocks, finish_block)
	(record_pending_block, make_blockvector, end_symtab): Replace
	symbol_obstack with objfile_obstack.
	* coffread.c (process_coff_symbol, coff_read_struct_type)
	(coff_read_enum_type): Ditto.
	* cp-namespace.c (initialize_namespace_symtab)
	(check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol, dwarf2_const_value, macro_start_file)
	(dwarf2_symbol_mark_computed): Ditto.
	* dwarfread.c (enum_type, new_symbol, synthesize_typedef): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* hpread.c (hpread_symfile_init, hpread_symfile_init)
	(hpread_read_enum_type, hpread_read_function_type)
	(hpread_read_doc_function_type, hpread_process_one_debug_symbol):
	Ditto.
	* jv-lang.c (get_java_class_symtab, add_class_symbol)
	(java_link_class_type): Ditto.
	* mdebugread.c (parse_symbol, psymtab_to_symtab_1, new_symtab)
	(new_symbol): Ditto.
	* minsyms.c (install_minimal_symbols): Ditto.
	* objfiles.c (allocate_objfile): Remove init of symbol_obstack.
	(terminate_minimal_symbol_table): Replace symbol_obstack with
	objfile_obstack.
	(free_objfile): Remove freeing of symbol_obstack.
	* objfiles.h: Remove symbol_obstack field.
	* pa64solib.c (add_to_solist): Replace symbol_obstack with
	objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
	symbol_obstack.
	(solib_add_common_symbols): Replace symbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add): Ditto.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_start, common_block_end): Ditto.
	* symfile.c (reread_symbols): Remove freeing and init of
	symbol_obstack.
	(allocate_symtab): Rename symbol_obstack to objfile_obstack.
	* symfile.h: Update comment.
	* symmisc.c (print_objfile_statistics): Remove symbol_obstack
	stats printing.
	* symtab.c (symbol_set_names): Replace symbol_obstack with
	objfile_obstack.
	* symtab.h (struct general_symbol_info, struct minimal_symbol):
	Update comments.
	* xcoffread.c (read_xcoff_symtab, SYMBOL_DUP, SYMNAME_ALLOC)
	(init_stringtab, xcoff_initial_scan): Replace symbol_obstack with
	objfile_obstack.
@
text
@a49 1
#include "symfile.h"
@


1.58
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* dbxread.c (dbx_symfile_init, start_psymtab, end_psymtab,
	coffstab_build_psymtabs, elfstab_build_psymtabs)
	(stabsect_build_psymtabs): Replace psymbol_obstack with
	objfile_obstack.
	* dwarf2-frame.c (decode_frame_entry_1): Ditto.
	* dwarf2read.c (dwarf2_build_psymtabs_hard, dwarf2_read_section):
	Ditto.
	* dwarfread.c (scan_compilation_units): Ditto.
	* elfread.c (elfstab_offset_sections): Ditto.
	* hppa-tdep.c (read_unwind_info): Ditto.
	* hpread.c (hpread_build_psymtabs, hpread_start_psymtab)
	(hpread_end_psymtab): Ditto.
	* mdebugread.c (mdebug_build_psymtabs, add_pending)
	(parse_partial_symbols, new_psymtab, elfmdebug_build_psymtabs):
	Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* objfiles.c (add_to_objfile_sections)
	(build_objfile_section_table): Ditto.
	(allocate_objfile): Remove init of psymbol_obstack.
	(free_objfile): Remove freeing of psymbol_obstack.
	* objfiles.h (struct objfile): Remove field
	psymbol_obstack. Update comments.
	* pa64solib.c (pa64_solib_add_solib_objfile): Replace
	psymbol_obstack with objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
        psymbol_obstack.
	* somread.c (som_symfile_offsets, init_import_symbols)
	(init_export_symbols): Replace psymbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
	* symfile.c (default_symfile_offsets, syms_from_objfile)
	(reread_symbols): Remove freeing and init of psymbol_obstack.
	(cashier_psymtab): Update comment.
	* symmisc.c (print_objfile_statistics): Don't report stats for
	psymbol obstack.
	* symtab.h (struct general_symbol_info, struct partial_symtab):
	Update comments.
	* xcoffread.c (xcoff_start_psymtab, xcoff_end_psymtab, swap_sym)
	(xcoff_symfile_offsets): Replace psymbol_obstack with
	objfile_obstack.
@
text
@d1063 1
a1063 1
	  TYPE_TAG_NAME (t) = obconcat (&current_objfile->symbol_obstack,
d1109 1
a1109 1
			    obstack_alloc (&current_objfile->symbol_obstack,
d1114 1
a1114 1
				&current_objfile->symbol_obstack);
d1207 1
a1207 1
	       obstack_alloc (&current_objfile->symbol_obstack,
d3951 1
a3951 1
		   obstack_alloc (&current_objfile->symbol_obstack,
d4595 1
a4595 1
				 &objfile->symbol_obstack);
d4700 1
a4700 1
		      obstack_alloc (&current_objfile->symbol_obstack,
@


1.57
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

        * objfiles.h (struct objfile): Add objfile_obstack field.
        Remove type_obstack field.

        * dwarf2read.c (dwarf2_add_field,dwarf2_add_member_fn,
        read_structure_scope read_enumeration, new_symbol): Replace
        type_obstack with objfile_obstack.
        * dwarfread.c (struct_type, enum_type): Ditto.
        * gdbtypes.c (alloc_type, alloc_type_instance, init_type)
        (lookup_fundamental_type): Ditto.
        * gdbtypes.h (TYPE_ALLOC): Ditto.
        * hpread.c (hpread_read_enum_type, hpread_read_function_type)
        (hpread_read_doc_function_type, hpread_read_struct_type)
        (fix_static_member_physnames, hpread_read_array_type)
        (hpread_read_subrange_type, hpread_type_lookup): Ditto.
        * jv-lang.c (java_lookup_class, type_from_class, type_from_class)
        (java_link_class_type): Ditto.
        * mdebugread.c (parse_type): Ditto.
        * objfiles.c (allocate_objfile, free_objfile): Ditto.
        * solib-sunos.c (solib_add_common_symbols): Ditto.
        * stabsread.c (define_symbol, read_type, read_member_functions,
        read_cpp_abbrev, read_one_struct_field): Ditto.
        * symfile.c (reread_symbols): Ditto.
        * symmisc.c (print_objfile_statistics): Ditto.
@
text
@d431 1
a431 1
      info->fdr = (FDR *) obstack_alloc (&objfile->psymbol_obstack,
d584 1
a584 1
	   obstack_alloc (&current_objfile->psymbol_obstack,
d2265 1
a2265 1
  extern_tab = (EXTR *) obstack_alloc (&objfile->psymbol_obstack,
d2309 1
a2309 1
     obstack_alloc (&objfile->psymbol_obstack,
d2561 1
a2561 1
				  obstack_alloc (&objfile->psymbol_obstack,
d3664 1
a3664 1
	 obstack_alloc (&objfile->psymbol_obstack,
d4612 1
a4612 1
				  obstack_alloc (&objfile->psymbol_obstack,
d4743 1
a4743 1
	  obstack_alloc (&objfile->psymbol_obstack,
@


1.56
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* mdebugread.c (compare_blocks): Make addr_diff a LONGEST.
	* block.h: Make GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOOCK
	enums.
@
text
@d1640 1
a1640 1
					    &current_objfile->type_obstack);
d1676 1
a1676 1
					   &current_objfile->type_obstack);
d1700 1
a1700 1
					    &current_objfile->type_obstack);
d1704 1
a1704 1
					    &current_objfile->type_obstack);
@


1.55
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* mdebugread.c: Update copyright.
	(parse_symbol): Replace DEPRECATED_STREQ with strcmp.
	(parse_type, parse_procedure): Ditto.
	(parse_partial_symbols, psymtab_to_symtab_1): Ditto.
@
text
@d4512 1
a4512 1
  int addr_diff;
@


1.54
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_command): Replace STREQ with strcmp.
	* defs.h (DEPRECATED_STREQN): Rename STREQN.
	(DEPRECATED_STREQ): Rename STREQ.
	* ada-exp.y, ada-lang.c, ada-lex.l, coffread.c: Update.
	* config/mips/tm-irix5.h, config/mips/tm-irix6.h: Update.
	* config/mips/tm-mipsv4.h, config/sparc/tm-sun4sol2.h: Update.
	* dbxread.c, dwarf2read.c, dwarfread.c, environ.c: Update.
	* eval.c, exec.c, f-lang.c, hppa-tdep.c, hpread.c: Update.
	* jv-exp.y, language.c, m2-exp.y, mcore-rom.c: Update.
	* mdebugread.c, mipsread.c, objc-exp.y, objfiles.c: Update.
	* p-exp.y, p-typeprint.c, p-valprint.c, rs6000-nat.c: Update.
	* source.c, sparc-tdep.c, stack.c, target.c: Update.
@
text
@d2 5
a6 3
   Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d798 2
a799 1
	  if (DEPRECATED_STREQ (name, "malloc") && TYPE_CODE (t) == TYPE_CODE_VOID)
d1673 2
a1674 1
	  if (TYPE_NAME (tp) == NULL || !DEPRECATED_STREQ (TYPE_NAME (tp), name))
d1994 2
a1995 1
      if (e->pdr.pcreg == 0 && DEPRECATED_STREQ (sh_name, "setjmp"))
d2616 2
a2617 1
	  if (DEPRECATED_STREQ (debug_info->ss + fh->issBase + sh.iss, stabs_symbol))
d2938 1
a2938 1
		      if (pst && DEPRECATED_STREQ (namestring, pst->filename))
d2943 2
a2944 1
			  if (DEPRECATED_STREQ (namestring, psymtab_include_list[i]))
d3871 2
a3872 2
      if (DEPRECATED_STREQ (debug_info->ss + fh->issBase + sh.iss,
		 stabs_symbol))
@


1.53
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@d796 1
a796 1
	  if (STREQ (name, "malloc") && TYPE_CODE (t) == TYPE_CODE_VOID)
d1670 1
a1670 1
	  if (TYPE_NAME (tp) == NULL || !STREQ (TYPE_NAME (tp), name))
d1990 1
a1990 1
      if (e->pdr.pcreg == 0 && STREQ (sh_name, "setjmp"))
d2611 1
a2611 1
	  if (STREQ (debug_info->ss + fh->issBase + sh.iss, stabs_symbol))
d2932 1
a2932 1
		      if (pst && STREQ (namestring, pst->filename))
d2937 1
a2937 1
			  if (STREQ (namestring, psymtab_include_list[i]))
d3864 1
a3864 1
      if (STREQ (debug_info->ss + fh->issBase + sh.iss,
@


1.52
log
@2003-10-06  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c, breakpoint.h: Remove obsolete code and comments.
	* buildsym.c, dbxread.c, gdbtypes.c, mdebugread.c: Ditto.
	* monitor.c, sparc-tdep.c, stabsread.c: Ditto.
	* stabsread.h, xcoffread.c: Ditto.
@
text
@d1635 1
a1635 1
		   || !STREQ (TYPE_TAG_NAME (tp), name))
@


1.51
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@a1524 4
#if 0 /* OBSOLETE CFront */
// OBSOLETE      /* Inhibit core dumps with some cfront generated objects that
// OBSOLETE         corrupt the TIR.  */
#endif /* OBSOLETE CFront */
a3041 16
#if 0 /* OBSOLETE CFront */
// OBSOLETE  			    /* The semantics of C++ state that "struct foo { ... }"
// OBSOLETE  			       also defines a typedef for "foo".  Unfortuantely, cfront
// OBSOLETE  			       never makes the typedef when translating from C++ to C.
// OBSOLETE  			       We make the typedef here so that "ptype foo" works as
// OBSOLETE  			       expected for cfront translated code.  */
// OBSOLETE  			    else if (psymtab_language == language_cplus)
// OBSOLETE  			      {
// OBSOLETE  				/* Also a typedef with the same name.  */
// OBSOLETE  				add_psymbol_to_list (namestring, p - namestring,
// OBSOLETE  						     VAR_DOMAIN, LOC_TYPEDEF,
// OBSOLETE  						     &objfile->static_psymbols,
// OBSOLETE  						     sh.value, 0,
// OBSOLETE  						     psymtab_language, objfile);
// OBSOLETE  			      }
#endif /* OBSOLETE CFront */
a3187 5
#if 0 /* OBSOLETE CFront */
// OBSOLETE 			/* added to support cfront stabs strings */
// OBSOLETE 		      case 'Z':		/* for definition continuations */
// OBSOLETE 		      case 'P':		/* for prototypes */
#endif /* OBSOLETE CFront */
@


1.50
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d511 1
a511 1
      register struct parse_stack *prev = new->prev;
d2939 1
a2939 1
			register int i;
d4441 1
a4441 1
mylookup_symbol (char *name, register struct block *block,
d4571 2
a4572 2
    register CORE_ADDR high = 0;
    register int i, j = BLOCKVECTOR_NBLOCKS (bv);
@


1.49
log
@2003-09-12  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Deprecate "entry_file_lowpc" and
	"entry_file_highpc".  Update comments.
	* defs.h (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* blockframe.c (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* frame.c (get_prev_frame): Update.  Use if 0 instead of #if 0.
	* vax-tdep.c (vax_frame_chain): Update.
	* sh64-tdep.c (sh64_frame_chain): Update.
	* sh-tdep.c (sh_frame_chain): Update.
	* rs6000-tdep.c (rs6000_frame_chain): Update.
	* ns32k-tdep.c (ns32k_frame_chain): Update.
	* mips-tdep.c (mips_frame_chain): Update.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Update.
	* m32r-tdep.c (m32r_frame_this_id): Update.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Update.
	* frv-tdep.c (frv_frame_this_id): Update.
	* d10v-tdep.c (d10v_frame_this_id): Update.
	* cris-tdep.c (cris_frame_chain): Update.
	* blockframe.c (legacy_frame_chain_valid): Update.
	* avr-tdep.c (avr_frame_this_id): Update.
	* arm-tdep.c (arm_prologue_this_id): Update.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Update.
	* objfiles.c (objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	(mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab): Update.
	(read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d376 1
a376 1
  register FDR *f;
d561 1
a561 1
  register struct mdebug_pending *p;
d2231 1
a2231 1
  register EXTR *ext_in;
d4530 1
a4530 1
  register int addr_diff;
@


1.48
log
@2003-09-11  David Carlton  <carlton@@kealia.com>

	* buildsym.c (finish_block): Use allocate_block to allocate the
	block.
	* mdebugread.c (new_block): Add FIXME.
@
text
@d3630 2
a3631 2
	  objfile->ei.entry_file_lowpc = save_pst->textlow;
	  objfile->ei.entry_file_highpc = save_pst->texthigh;
@


1.47
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* dictionary.h: New.
	* dictionary.c: New.
	* block.h: Add opaque declaration for struct dictionary.
	(struct block): Add 'dict' member; delete 'hashtable', 'nsyms',
	'sym' members.
	(BLOCK_DICT): New macro.
	Delete macros BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM,
	BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE,
	BLOCK_SHOULD_SORT.
	(ALL_BLOCK_SYMBOLS): Update definition.
	* Makefile.in (SFILES): Add dictionary.c.
	(dictionary_h): New.
	(COMMON_OBS): Add dictionary.o.
	(dictionary.o): New.
	(ada-lang.o): Depend on dictionary_h.
	(buildsym.o, coffread.o, jv-lang.o, mdebugread.o, objfiles.o)
	(stack.o, symmisc.o, symtab.o, tracepoint.o, valops.o)
	(mi-cmd-stack.o): Ditto.
	(gdbtk-cmds.o): Update dependencies.
	(gdbtk-stack.o): Ditto.
	* ada-lang.c: Include dictionary.h.
	(symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(fill_in_ada_prototype, debug_print_block): Ditto.
	(ada_add_block_symbols): Update uses of ALL_BLOCK_SYMBOLS; replace
	explicit iteration by use of ALL_BLOCK_SYMBOLS.  Delete variable
	'is_sorted'.
	* mdebugread.c: Include dictionary.h.
	(struct parse_stack): Delete 'maxsyms' member.
	(parse_symbol): Update calls to new_block.  Delete calls to
	shrink_block.  Use dictionary methods.
	(psymtab_to_symtab_1): Delete calls to sort_symtab_syms.
	Update calls to new_symtab.  Don't maintain maxsyms data.
	(mylookup_symbol): Update use of ALL_BLOCK_SYMBOLS.
	(add_symbol): Just call dict_add_symbol.
	(new_symtab): Delete 'maxsyms' argument.
	(new_symtab): Update calls to new_block.
	(new_block): Delete 'maxsyms' argument; add 'function' argument.
	(shrink_block): Delete function.
	(fixup_sigtramp): Update call to new_block.  Add symbol via
	dict_add_symbol.
	* jv-lang.c: Include dictionary.h.
	(get_java_class_symtab): Set the BLOCK_DICT of the blocks
	appropriately.  Set class_symtab->free_func.  Make sure the
	blockvector is big enough to hold two blocks.
	(add_class_symtab_symbol): Use dictionary methods.
	(free_class_block): New function.
	(type_from_class): Replace explicit iteration by
	ALL_BLOCK_SYMBOLS.
	* symtab.h (struct symtab): Replace 'free_ptr' method by
	'free_func'.
	* dwarf2read.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* dwarfread.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Delete call to sort_symtab_syms.
	Include dictionary.h.
	(patch_opaque_types): Update use of ALL_BLOCK_SYMBOLS.
	* dbxread.c (dbx_psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* objfiles.c: Include dictionary.h.
	(objfile_relocate): Update use of ALL_BLOCK_SYMBOLS.
	* buildsym.c: Include dictionary.h.
	(finish_block): Use dictionary methods.
	(end_symtab): Set free_func to NULL, not free_ptr.
	* tracepoint.c: Include dictionary.h.
	(add_local_symbols): Update use of ALL_BLOCK_SYMBOLS.
	(scope_info): Ditto.
	* stack.c: Include dictionary.h.
	(print_block_frame_locals): Update use of ALL_BLOCK_SYMBOLS.
	(print_block_frame_labels, print_frame_arg_vars)
	(print_frame_args): Ditto.
	* symmisc.c (free_symtab_block): Use dictionary methods.
	(dump_symtab): Ditto.
	(free_symtab): Replace use of 'free_ptr' by 'free_func'.
	Include	dictionary.h.
	* symfile.h: Delete declarations of sort_block_syms,
	sort_symtab_syms.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Delete.
	* symtab.c: Include dictionary.h.
	(lookup_block_symbol): Use dictionary iterators.
	(find_pc_sect_symtab): Update use of ALL_BLOCK_SYMBOLS.
	(search_symbols, make_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* valops.c (value_of_local): Use dict_empty.
	Include dictionary.h.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* generic/gdbtk-stack.c: Include dictionary.h.
	(gdb_block_vars): Update use of ALL_BLOCK_SYMBOLS.
	(gdb_get_blocks, gdb_get_vars_command): Ditto.
	* generic/gdbtk-cmds.c: Include dictionary.h.
	(gdb_listfuncs): Update use of ALL_BLOCK_SYMBOLS.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* mi-cmd-stack.c: Include dictionary.h.
	(list_args_or_locals): Update use of ALL_BLOCK_SYMBOLS.
@
text
@d4699 3
@


1.46
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* block.h (BLOCK_SHOULD_SORT): Delete.
	* symtab.c (lookup_block_symbol): Don't worry about sorted linear
	blocks.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Ditto.
	* symfile.h: Delete sort_symtabs_syms and sort_block_syms
	declarations.
	* coffread.c (coff_symfile_read): Don't call sort_symtab_syms.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
@
text
@d57 1
d288 1
a288 1
static struct block *new_block (int);
d290 3
a292 1
static struct symtab *new_symtab (char *, int, int, struct objfile *);
a303 2
static struct block *shrink_block (struct block *, struct symtab *);

a486 1
    int maxsyms;		/* Max symbols in this block. */
d837 1
a837 1
      b = new_block (top_stack->maxsyms);
d1172 1
a1172 1
      b = new_block (top_stack->maxsyms);
d1192 1
a1192 1
	  struct block *b;
a1211 3
	  /* Reallocate symbols, saving memory */
	  b = shrink_block (top_stack->cur_block, top_stack->cur_st);

d1236 1
d1241 2
a1242 1
		  for (i = iparams = 0; iparams < nparams; i++)
d1244 3
a1246 1
		      sym = BLOCK_SYM (b, i);
a1269 1
	  shrink_block (top_stack->cur_block, top_stack->cur_st);
a4063 3
      /* How many symbols will we need */
      /* FIXME, this does not count enum values. */
      f_max = pst->n_global_syms + pst->n_static_syms;
d4067 1
a4067 1
	  st = new_symtab ("unknown", f_max, 0, pst->objfile);
a4070 1
	  f_max += fh->csym + fh->cpd;
d4072 1
a4072 1
	  st = new_symtab (pst->filename, 2 * f_max, maxlines, pst->objfile);
a4091 1
      top_stack->maxsyms = 2 * f_max;
a4174 4
      top_stack->maxsyms
	= (debug_info->symbolic_header.isymMax
	   + debug_info->symbolic_header.ipdMax
	   + debug_info->symbolic_header.iextMax);
d4444 2
a4445 1
  int i, inc;
d4449 1
a4449 1
  ALL_BLOCK_SYMBOLS (block, i, sym)
d4465 1
a4465 4
/* Add a new symbol S to a block B.
   Infrequently, we will need to reallocate the block to make it bigger.
   We only detect this case when adding to top_stack->cur_block, since
   that's the only time we know how big the block is.  FIXME.  */
d4470 1
a4470 27
  int nsyms = BLOCK_NSYMS (b)++;
  struct block *origb;
  struct parse_stack *stackp;

  if (b == top_stack->cur_block &&
      nsyms >= top_stack->maxsyms)
    {
      complaint (&symfile_complaints, "block containing %s overfilled",
		 DEPRECATED_SYMBOL_NAME (s));
      /* In this case shrink_block is actually grow_block, since
         BLOCK_NSYMS(b) is larger than its current size.  */
      origb = b;
      b = shrink_block (top_stack->cur_block, top_stack->cur_st);

      /* Now run through the stack replacing pointers to the
         original block.  shrink_block has already done this
         for the blockvector and BLOCK_FUNCTION.  */
      for (stackp = top_stack; stackp; stackp = stackp->next)
	{
	  if (stackp->cur_block == origb)
	    {
	      stackp->cur_block = b;
	      stackp->maxsyms = BLOCK_NSYMS (b);
	    }
	}
    }
  BLOCK_SYM (b, nsyms) = s;
d4592 2
a4593 2
/* Allocate a new symtab for NAME.  Needs an estimate of how many symbols
   MAXSYMS and linenumbers MAXLINES we'll put in it */
d4596 1
a4596 1
new_symtab (char *name, int maxsyms, int maxlines, struct objfile *objfile)
d4604 4
a4607 2
  BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK) = new_block (maxsyms);
  BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK) = new_block (maxsyms);
d4691 4
a4694 1
/* Allocate and zero a new block of MAXSYMS symbols */
d4697 1
a4697 1
new_block (int maxsyms)
d4699 1
a4699 1
  int size = sizeof (struct block) + (maxsyms - 1) * sizeof (struct symbol *);
d4701 4
a4704 14
  return (struct block *) xzalloc (size);
}

/* Ooops, too big. Shrink block B in symtab S to its minimal size.
   Shrink_block can also be used by add_symbol to grow a block.  */

static struct block *
shrink_block (struct block *b, struct symtab *s)
{
  struct block *new;
  struct blockvector *bv = BLOCKVECTOR (s);
  int i;

  /* Just reallocate it and fix references to the old one */
d4706 1
a4706 20
  new = (struct block *) xrealloc ((void *) b,
				   (sizeof (struct block)
				    + ((BLOCK_NSYMS (b) - 1)
				       * sizeof (struct symbol *))));

  /* FIXME: Not worth hashing this block as it's built.  */
  /* All callers should have created the block with new_block (), which
     would mean it was not previously hashed.  Make sure.  */
  gdb_assert (BLOCK_HASHTABLE (new) == 0);

  /* Should chase pointers to old one.  Fortunately, that`s just
     the block`s function and inferior blocks */
  if (BLOCK_FUNCTION (new) && SYMBOL_BLOCK_VALUE (BLOCK_FUNCTION (new)) == b)
    SYMBOL_BLOCK_VALUE (BLOCK_FUNCTION (new)) = new;
  for (i = 0; i < BLOCKVECTOR_NBLOCKS (bv); i++)
    if (BLOCKVECTOR_BLOCK (bv, i) == b)
      BLOCKVECTOR_BLOCK (bv, i) = new;
    else if (BLOCK_SUPERBLOCK (BLOCKVECTOR_BLOCK (bv, i)) == b)
      BLOCK_SUPERBLOCK (BLOCKVECTOR_BLOCK (bv, i)) = new;
  return new;
d4843 1
a4843 1
  b = new_block (1);
d4886 1
a4886 1
  BLOCK_SYM (b, BLOCK_NSYMS (b)++) = s;
@


1.45
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@a4010 4
      /* Sort the symbol table now, we are done adding symbols to it.
         We must do this before parse_procedure calls lookup_symbol.  */
      sort_symtab_syms (st);

a4203 3

      /* Sort the symbol table now, we are done adding symbols to it. */
      sort_symtab_syms (st);
@


1.44
log
@	* mdebugread.c (parse_symbol): For stEnd, we're done counting
	when iss is issNull.
@
text
@d298 1
a298 1
static struct symbol *mylookup_symbol (char *, struct block *, namespace_enum,
d694 1
a694 1
      SYMBOL_NAMESPACE (s) = VAR_NAMESPACE;
d717 1
a717 1
      SYMBOL_NAMESPACE (s) = VAR_NAMESPACE;
d746 1
a746 1
      SYMBOL_NAMESPACE (s) = VAR_NAMESPACE;	/* so that it can be used */
d788 1
a788 1
      SYMBOL_NAMESPACE (s) = VAR_NAMESPACE;
d1114 1
a1114 1
		SYMBOL_NAMESPACE (enum_sym) = VAR_NAMESPACE;
d1144 1
a1144 1
	SYMBOL_NAMESPACE (s) = STRUCT_NAMESPACE;
d1200 1
a1200 1
	  SYMBOL_NAMESPACE (s) = LABEL_NAMESPACE;
d1345 1
a1345 1
      SYMBOL_NAMESPACE (s) = VAR_NAMESPACE;
d1928 1
a1928 1
      s = lookup_symbol (sh_name, NULL, VAR_NAMESPACE, 0, NULL);
d1934 1
a1934 1
	 VAR_NAMESPACE,
d1940 1
a1940 1
			 VAR_NAMESPACE, LOC_BLOCK);
d1954 1
a1954 1
      SYMBOL_NAMESPACE (s) = VAR_NAMESPACE;
d1972 1
a1972 1
  i = mylookup_symbol (MIPS_EFI_SYMBOL_NAME, b, LABEL_NAMESPACE, LOC_CONST);
d3004 1
a3004 1
					     VAR_NAMESPACE, LOC_STATIC,
d3014 1
a3014 1
					     VAR_NAMESPACE, LOC_STATIC,
d3032 1
a3032 1
						 STRUCT_NAMESPACE, LOC_TYPEDEF,
d3040 1
a3040 1
						     VAR_NAMESPACE, LOC_TYPEDEF,
d3056 1
a3056 1
// OBSOLETE  						     VAR_NAMESPACE, LOC_TYPEDEF,
d3068 1
a3068 1
						 VAR_NAMESPACE, LOC_TYPEDEF,
d3130 1
a3130 1
						     VAR_NAMESPACE, LOC_CONST,
d3147 1
a3147 1
					     VAR_NAMESPACE, LOC_CONST,
d3164 1
a3164 1
					     VAR_NAMESPACE, LOC_BLOCK,
d3185 1
a3185 1
					     VAR_NAMESPACE, LOC_BLOCK,
d3420 1
a3420 1
					 VAR_NAMESPACE, LOC_BLOCK,
d3425 1
a3425 1
					 VAR_NAMESPACE, LOC_BLOCK,
d3494 1
a3494 1
					   STRUCT_NAMESPACE, LOC_TYPEDEF,
d3535 1
a3535 1
				   VAR_NAMESPACE, class,
d3611 1
a3611 1
				   VAR_NAMESPACE, class,
d3781 1
a3781 1
			   VAR_NAMESPACE, LOC_CONST,
d3974 1
a3974 1
		  SYMBOL_NAMESPACE (s) = LABEL_NAMESPACE;
d4458 1
a4458 1
		 namespace_enum namespace, enum address_class class)
d4467 1
a4467 1
	  && SYMBOL_NAMESPACE (sym) == namespace
d4475 1
a4475 1
    return mylookup_symbol (name, block, namespace, class);
d4869 1
a4869 1
  s = lookup_symbol ("sigvec", 0, VAR_NAMESPACE, 0, NULL);
d4873 1
a4873 1
      s = lookup_symbol ("sigtramp", b0, VAR_NAMESPACE, 0, NULL);
d4878 1
a4878 1
      s = lookup_symbol ("_sigtramp", 0, VAR_NAMESPACE, 0, NULL);
d4904 1
a4904 1
  SYMBOL_NAMESPACE (s) = VAR_NAMESPACE;
d4948 1
a4948 1
    SYMBOL_NAMESPACE (s) = LABEL_NAMESPACE;
@


1.44.8.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d298 1
a298 1
static struct symbol *mylookup_symbol (char *, struct block *, domain_enum,
d694 1
a694 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d717 1
a717 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d746 1
a746 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;	/* so that it can be used */
d788 1
a788 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d1114 1
a1114 1
		SYMBOL_DOMAIN (enum_sym) = VAR_DOMAIN;
d1144 1
a1144 1
	SYMBOL_DOMAIN (s) = STRUCT_DOMAIN;
d1200 1
a1200 1
	  SYMBOL_DOMAIN (s) = LABEL_DOMAIN;
d1345 1
a1345 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d1928 1
a1928 1
      s = lookup_symbol (sh_name, NULL, VAR_DOMAIN, 0, NULL);
d1934 1
a1934 1
	 VAR_DOMAIN,
d1940 1
a1940 1
			 VAR_DOMAIN, LOC_BLOCK);
d1954 1
a1954 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d1972 1
a1972 1
  i = mylookup_symbol (MIPS_EFI_SYMBOL_NAME, b, LABEL_DOMAIN, LOC_CONST);
d3004 1
a3004 1
					     VAR_DOMAIN, LOC_STATIC,
d3014 1
a3014 1
					     VAR_DOMAIN, LOC_STATIC,
d3032 1
a3032 1
						 STRUCT_DOMAIN, LOC_TYPEDEF,
d3040 1
a3040 1
						     VAR_DOMAIN, LOC_TYPEDEF,
d3056 1
a3056 1
// OBSOLETE  						     VAR_DOMAIN, LOC_TYPEDEF,
d3068 1
a3068 1
						 VAR_DOMAIN, LOC_TYPEDEF,
d3130 1
a3130 1
						     VAR_DOMAIN, LOC_CONST,
d3147 1
a3147 1
					     VAR_DOMAIN, LOC_CONST,
d3164 1
a3164 1
					     VAR_DOMAIN, LOC_BLOCK,
d3185 1
a3185 1
					     VAR_DOMAIN, LOC_BLOCK,
d3420 1
a3420 1
					 VAR_DOMAIN, LOC_BLOCK,
d3425 1
a3425 1
					 VAR_DOMAIN, LOC_BLOCK,
d3494 1
a3494 1
					   STRUCT_DOMAIN, LOC_TYPEDEF,
d3535 1
a3535 1
				   VAR_DOMAIN, class,
d3611 1
a3611 1
				   VAR_DOMAIN, class,
d3781 1
a3781 1
			   VAR_DOMAIN, LOC_CONST,
d3974 1
a3974 1
		  SYMBOL_DOMAIN (s) = LABEL_DOMAIN;
d4458 1
a4458 1
		 domain_enum domain, enum address_class class)
d4467 1
a4467 1
	  && SYMBOL_DOMAIN (sym) == domain
d4475 1
a4475 1
    return mylookup_symbol (name, block, domain, class);
d4869 1
a4869 1
  s = lookup_symbol ("sigvec", 0, VAR_DOMAIN, 0, NULL);
d4873 1
a4873 1
      s = lookup_symbol ("sigtramp", b0, VAR_DOMAIN, 0, NULL);
d4878 1
a4878 1
      s = lookup_symbol ("_sigtramp", 0, VAR_DOMAIN, 0, NULL);
d4904 1
a4904 1
  SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d4948 1
a4948 1
    SYMBOL_DOMAIN (s) = LABEL_DOMAIN;
@


1.43
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d919 7
a925 3
                   this check stops the count on the StEnd of a method.  */
                if (strcmp (debug_info->ss + cur_fdr->issBase + tsym.iss,
                            name) == 0)
@


1.42
log
@	* coffread.c (coff_symfile_read): Clean up minimal symbols earlier.
	* dbxread.c (elfstab_build_psymtabs): Don't call
	install_minimal_symbols.
	(stabsect_build_psymtabs): Likewise.
	* elfread.c (elf_symfile_read): Call install_minimal_symbols
	earlier.
	* somread.c (som_symfile_read): Call install_minimal_symbols
	and do_cleanups earlier.
	* nlmread.c (nlm_symfile_read): Likewise.
	* mdebugread.c (elfmdebug_build_psymtabs): Call
	install_minimal_symbols and make appropriate cleanups.
@
text
@d673 1
a673 1
	  int bucket = hashname (SYMBOL_NAME (s));
d1105 1
a1105 1
		SYMBOL_NAME (enum_sym) =
d1376 1
a1376 1
	    TYPE_NAME (SYMBOL_TYPE (s)) = SYMBOL_NAME (s);
d4462 1
a4462 1
      if (SYMBOL_NAME (sym)[0] == inc
d4465 1
a4465 1
	  && strcmp (SYMBOL_NAME (sym), name) == 0)
d4492 1
a4492 1
		 SYMBOL_NAME (s));
@


1.41
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d4812 8
d4830 3
@


1.40
log
@	* defs.h (streq): Add prototype.
	* utils.c (streq): New function.

	* dwarf2read.c (new_symbol): Use SYMBOL_SET_NAMES instead of
	SYMBOL_NAME and SYMBOL_INIT_DEMANGLED_NAME.
	* mdebugread.c (new_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* dwarfread.c (new_symbol): Likewise.

	* minsyms.c (prim_record_minimal_symbol_and_info): Use
	SYMBOL_SET_NAMES instead of setting SYMBOL_NAME.  Set the language
	here.
	(install_minimal_symbols): Don't set SYMBOL_LANGUAGE or call
	SYMBOL_INIT_DEMANGLED_NAME.
	* objfiles.c: Include "hashtab.h".
	(allocate_objfile): Call htab_set_functions_ex for the
	demangled_names_hash.
	(free_objfile): Call htab_delete for the demangled_names_hash.
	* objfiles.h (struct htab): Add declaration.
	(struct objfile): Add demangled_names_hash.
	* symfile.c: Include "hashtab.h".
	(reread_symbols): Call htab_delete for the demangled_names_hash.
	(add_psymbol_to_list): Use SYMBOL_SET_NAMES instead of putting
	SYMBOL_NAME in the bcache.
	* symtab.c: Include "hashtab.h".  Update comments.
	(create_demangled_names_hash, symbol_set_names): New functions.
	(symbol_find_demangled_name): New function, broken out from
	symbol_init_demangled_names.
	(symbol_init_demangled_names): Use it.
	* symtab.h (SYMBOL_INIT_DEMANGLED_NAME): Add missing parentheses.
	(SYMBOL_SET_NAMES): New macro.
	(symbol_set_names): Add prototype.
@
text
@d56 1
@


1.39
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@a4781 2
  SYMBOL_NAME (s) = obsavestring (name, strlen (name),
				  &current_objfile->symbol_obstack);
d4783 1
a4783 1
  SYMBOL_INIT_DEMANGLED_NAME (s, &current_objfile->symbol_obstack);
@


1.38
log
@2003-01-13  Elena Zannoni  <ezannoni@@redhat.com>

	* stabsread.h (process_later, resolve_cfront_continuation):
	Obsolete.
	Update copyright years.
	* buildsym.c (start_subfile): Obsolete comment pertinent to Cfront.
	Update copyright year.
	* dbxread.c(struct cont_elem): Obsolete.
	(process_later, process_now): Obsolete functions.
	(read_dbx_symtab, read_ofile_symtab): Obsolete cfront support.
	Update copyright year.
	* gdbtypes.c (INIT_EXTRA, ADD_EXTRA): Obsolete macros.
	(add_name, add_mangled_type, cfront_mangle_name): Obsolete functions.
	* mdebugread.c (parse_type): Obsolete comment pertinent to Cfront.
	(parse_partial_symbols): Obsolete cfront support.
	* stabsread.c
	(CFRONT_VISIBILITY_PRIVATE,CFRONT_VISIBILITY_PUBLIC): Obsolete
	macros.
	(get_substring, get_cfront_method_physname, msg_unknown_complaint,
	read_cfront_baseclasses, read_cfront_member_functions,
	resolve_cfront_continuation,read_cfront_static_fields,
	copy_cfront_struct_fields): Obsolete functions.
	(define_symbol, read_one_struct_field): Obsolete cfront support.
	* xcoffread.c (scan_xcoff_symtab): Obsolete CFront support.
	Update Copyright year.
@
text
@d2953 1
a2953 1
			  memcpy ((PTR) psymtab_include_list, (PTR) orig,
@


1.37
log
@       * mdebugread.c (parse_symbol): Skip stProc entries which storage
       class is not scText. These do not define "real" procedures.
       (parse_partial_symbols): Likewise.
@
text
@d1520 5
a1524 3

      /* Inhibit core dumps with some cfront generated objects that
         corrupt the TIR.  */
d3041 16
a3056 14
			    /* The semantics of C++ state that "struct foo { ... }"
			       also defines a typedef for "foo".  Unfortuantely, cfront
			       never makes the typedef when translating from C++ to C.
			       We make the typedef here so that "ptype foo" works as
			       expected for cfront translated code.  */
			    else if (psymtab_language == language_cplus)
			      {
				/* Also a typedef with the same name.  */
				add_psymbol_to_list (namestring, p - namestring,
						     VAR_NAMESPACE, LOC_TYPEDEF,
						     &objfile->static_psymbols,
						     sh.value, 0,
						     psymtab_language, objfile);
			      }
d3203 5
a3207 3
			/* added to support cfront stabs strings */
		      case 'Z':		/* for definition continuations */
		      case 'P':		/* for prototypes */
@


1.36
log
@gdb/
	* buildsym.h (processing_hp_compilation): Remove obsolete variable.
	* gdbarch.sh Remove include of "value.h" in gdbarch.h.
	(COERCE_FLOAT_TO_DOUBLE): Remove.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* Makefile.in: Remove value_h from gdbarch_h.
	* valops.c (coerce_float_to_double): New variable.
	(default_coerce_float_to_double): Remove.
	(standard_coerce_float_to_double): Remove.
	(value_arg_coerce): Use coerce_float_to_double.
	(_initialize_valops): Add "set coerce-float-to-double".
	* value.h (default_coerce_float_to_double): Remove prototype.
	(standard_coerce_float_to_double): Remove prototype.

	* hpread.c (hpread_process_one_debug_symbol): Mark C++ functions as
	prototyped.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Mark all functions as prototyped.

	* hppa-tdep.c (hppa_coerce_float_to_double): Remove.
	* alpha-tdep.c (alpha_gdbarch_init): Remove call to
	set_gdbarch_coerce_float_to_double.
	* arm-tdep.c (arm_gdbarch_init): Likewise.
	* frv-tdep.c (frv_gdbarch_init): Likewise.
	* h8300-tdep.c (h8300_gdbarch_init): Likewise (commented out).
	* i386-sol2-tdep.c (i386_sol2_init_abi): Likewise.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	(mips_coerce_float_to_double): Remove.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	(rs6000_coerce_float_to_double): Remove.
	* s390-tdep.c (s390_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	(sh_coerce_float_to_double): Remove.
	* sparc-tdep.c (sparc_gdbarch_init): Likewise.
	(sparc_coerce_float_to_double): Remove.
	* v850-tdep.c (v850_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.
	* config/m32r/tm-m32r.h (COERCE_FLOAT_TO_DOUBLE): Remove.
	* config/pa/tm-hppa.h: (COERCE_FLOAT_TO_DOUBLE): Remove.
	(hppa_coerce_float_to_double): Remove prototype.
	* config/sparc/tm-sparc.h (COERCE_FLOAT_TO_DOUBLE): Remove.
doc/
	* gdb.texinfo (Controlling GDB): Add ABI section.  Document
	"set coerce-float-to-double".
	* gdbint.texinfo (COERCE_FLOAT_TO_DOUBLE): Remove documentation.
testsuite/
	* gdb.base/callfuncs.exp: Don't XFAIL unprototyped functions for
	stabs.
	* gdb.base/completion.exp: Allow marker1(void) as well as marker1().
	* gdb.base/whatis.exp: Always allow (void) after function names.
@
text
@d754 32
d3363 33
a3417 13
		  /* Skip over procedure to next one. */
		  if (sh.index >= hdr->iauxMax)
		    {
		      /* Should not happen, but does when cross-compiling
		         with the MIPS compiler.  FIXME -- pull later.  */
		      index_complaint (name);
		      new_sdx = cur_sdx + 1;	/* Don't skip at all */
		    }
		  else
		    new_sdx = AUX_GET_ISYM (fh->fBigendian,
					    (debug_info->external_aux
					     + fh->iauxBase
					     + sh.index));
a3418 9

		  if (new_sdx <= cur_sdx)
		    {
		      /* This should not happen either... FIXME.  */
		      complaint (&symfile_complaints,
				 "bad proc end in aux found from symbol %s",
				 name);
		      new_sdx = cur_sdx + 1;	/* Don't skip backward */
		    }
@


1.35
log
@Revert the previous change, as it was checked in by mistake.
@
text
@d3 1
a3 1
   1997, 1998, 1999, 2000, 2001, 2002
d797 5
@


1.34
log
@(parse_symbol): Skip stProc entries which storage class is not scText.
 These do not define "real" procedures.
(parse_partial_symbols): Likewise.
Fixes [C102-001].
@
text
@a753 27
      /* Make sure this is a "real" procedure.  Otherwise, skip it.  */
      if (sh->st == stProc && sh->sc != scText)
        {
          char *ext_tsym = ext_sh;
          int keep_counting = 1;
          SYMR tsym;

          while (keep_counting)
            {
              ext_tsym += external_sym_size;
              (*swap_sym_in) (cur_bfd, ext_tsym, &tsym);
              count++;
              switch (tsym.st)
                {
                  case stParam:
                    break;
                  case stEnd:
                    keep_counting = 0;
                    break;
                  default:
                    complaint (&symfile_complaints,
                               "unknown symbol type 0x%x", sh->st);
                    break;
                }
            }
          break;
        }
a3325 28
		  /* Ignore all parameter symbol records.  */
		  if (sh.index >= hdr->iauxMax)
		    {
		      /* Should not happen, but does when cross-compiling
		         with the MIPS compiler.  FIXME -- pull later.  */
		      index_complaint (name);
		      new_sdx = cur_sdx + 1;	/* Don't skip at all */
		    }
		  else
		    new_sdx = AUX_GET_ISYM (fh->fBigendian,
					    (debug_info->external_aux
					     + fh->iauxBase
					     + sh.index));

		  if (new_sdx <= cur_sdx)
		    {
		      /* This should not happen either... FIXME.  */
		      complaint (&symfile_complaints,
				 "bad proc end in aux found from symbol %s",
				 name);
		      new_sdx = cur_sdx + 1;	/* Don't skip backward */
		    }

                  /* Make sure that this stProc entry represents a "real"
                     procedure.  If not, ignore it.  */
                  if (sh.st == stProc && sh.sc != scText)
                    goto skip;

d3348 13
d3362 9
@


1.33
log
@        * mdebugread.c (parse_symbol): Count until the stEnd matching
        the structure name.
@
text
@d754 27
d3353 28
a3402 13
		  /* Skip over procedure to next one. */
		  if (sh.index >= hdr->iauxMax)
		    {
		      /* Should not happen, but does when cross-compiling
		         with the MIPS compiler.  FIXME -- pull later.  */
		      index_complaint (name);
		      new_sdx = cur_sdx + 1;	/* Don't skip at all */
		    }
		  else
		    new_sdx = AUX_GET_ISYM (fh->fBigendian,
					    (debug_info->external_aux
					     + fh->iauxBase
					     + sh.index));
a3403 9

		  if (new_sdx <= cur_sdx)
		    {
		      /* This should not happen either... FIXME.  */
		      complaint (&symfile_complaints,
				 "bad proc end in aux found from symbol %s",
				 name);
		      new_sdx = cur_sdx + 1;	/* Don't skip backward */
		    }
@


1.32
log
@Replace complain() with complaint().
@
text
@d868 18
a885 1
		goto end_of_fields;
@


1.31
log
@	* gdbtypes.h (struct main_type): Move artificial flag out of
	loc.  New member of ``struct field'' named static_kind.  Reduce
	overloaded meaning of bitsize.
	(FIELD_ARTIFICIAL, SET_FIELD_PHYSNAME, SET_FIELD_PHYSADDR)
	(TYPE_FIELD_STATIC, TYPE_FIELD_STATIC_HAS_ADDR): Likewise.
	(FIELD_STATIC_KIND, TYPE_FIELD_STATIC_KIND): New macros.

	* ada-lang.c (fill_in_ada_prototype): Initialize static_kind for
	new fields.
	(template_to_fixed_record_type, template_to_static_fixed_type)
	(to_record_with_fixed_variant_part): Likewise.
	* coffread.c (coff_read_struct_type, coff_read_enum_type): Likewise.
	* dwarf2read.c (dwarf2_add_field, read_enumeration): Likewise.
	* dwarfread.c (struct_type, enum_type): Likewise.
	* hpread.c (hpread_read_enum_type)
	(hpread_read_function_type, hpread_read_doc_function_type)
	(hpread_read_struct_type): Likewise.
	* mdebugread.c (parse_symbol): Likewise.
@
text
@d145 5
d151 5
a155 2
static struct deprecated_complaint bad_file_number_complaint =
{"bad file number %d", 0, 0};
d157 6
a162 2
static struct deprecated_complaint index_complaint =
{"bad aux index at symbol %s", 0, 0};
d164 5
a168 2
static struct deprecated_complaint aux_index_complaint =
{"bad proc end in aux found from symbol %s", 0, 0};
d170 6
a175 2
static struct deprecated_complaint block_index_complaint =
{"bad aux index at block symbol %s", 0, 0};
d177 5
a181 77
static struct deprecated_complaint unknown_ext_complaint =
{"unknown external symbol %s", 0, 0};

static struct deprecated_complaint unknown_sym_complaint =
{"unknown local symbol %s", 0, 0};

static struct deprecated_complaint unknown_st_complaint =
{"with type %d", 0, 0};

static struct deprecated_complaint block_overflow_complaint =
{"block containing %s overfilled", 0, 0};

static struct deprecated_complaint basic_type_complaint =
{"cannot map ECOFF basic type 0x%x for %s", 0, 0};

static struct deprecated_complaint unknown_type_qual_complaint =
{"unknown type qualifier 0x%x", 0, 0};

static struct deprecated_complaint array_index_type_complaint =
{"illegal array index type for %s, assuming int", 0, 0};

static struct deprecated_complaint bad_tag_guess_complaint =
{"guessed tag type of %s incorrectly", 0, 0};

static struct deprecated_complaint block_member_complaint =
{"declaration block contains unhandled symbol type %d", 0, 0};

static struct deprecated_complaint stEnd_complaint =
{"stEnd with storage class %d not handled", 0, 0};

static struct deprecated_complaint unknown_mdebug_symtype_complaint =
{"unknown symbol type 0x%x", 0, 0};

static struct deprecated_complaint stab_unknown_complaint =
{"unknown stabs symbol %s", 0, 0};

static struct deprecated_complaint pdr_for_nonsymbol_complaint =
{"PDR for %s, but no symbol", 0, 0};

static struct deprecated_complaint pdr_static_symbol_complaint =
{"can't handle PDR for static proc at 0x%lx", 0, 0};

static struct deprecated_complaint bad_setjmp_pdr_complaint =
{"fixing bad setjmp PDR from libc", 0, 0};

static struct deprecated_complaint bad_fbitfield_complaint =
{"can't handle TIR fBitfield for %s", 0, 0};

static struct deprecated_complaint bad_continued_complaint =
{"illegal TIR continued for %s", 0, 0};

static struct deprecated_complaint bad_rfd_entry_complaint =
{"bad rfd entry for %s: file %d, index %d", 0, 0};

static struct deprecated_complaint unexpected_type_code_complaint =
{"unexpected type code for %s", 0, 0};

static struct deprecated_complaint unable_to_cross_ref_complaint =
{"unable to cross ref btTypedef for %s", 0, 0};

static struct deprecated_complaint bad_indirect_xref_complaint =
{"unable to cross ref btIndirect for %s", 0, 0};

static struct deprecated_complaint illegal_forward_tq0_complaint =
{"illegal tq0 in forward typedef for %s", 0, 0};

static struct deprecated_complaint illegal_forward_bt_complaint =
{"illegal bt %d in forward typedef for %s", 0, 0};

static struct deprecated_complaint bad_linetable_guess_complaint =
{"guessed size of linetable for %s incorrectly", 0, 0};

static struct deprecated_complaint bad_ext_ifd_complaint =
{"bad ifd for external symbol: %d (max %d)", 0, 0};

static struct deprecated_complaint bad_ext_iss_complaint =
{"bad iss for external symbol: %ld (max %ld)", 0, 0};
d937 3
a939 1
		complain (&block_member_complaint, tsym.st);
d1225 2
a1226 1
	complain (&stEnd_complaint, sh->sc);
d1338 1
a1338 1
      complain (&unknown_mdebug_symtype_complaint, sh->st);
d1407 1
a1407 1
      complain (&index_complaint, sym_name);
d1416 1
a1416 1
      complain (&basic_type_complaint, t->bt, sym_name);
d1455 1
a1455 1
	  complain (&basic_type_complaint, t->bt, sym_name);
d1481 2
a1482 1
	    complain (&bad_fbitfield_complaint, sym_name);
d1510 2
a1511 1
	  complain (&bad_indirect_xref_complaint, sym_name);
d1551 1
a1551 1
	  complain (&unexpected_type_code_complaint, sym_name);
d1565 1
a1565 1
	      complain (&bad_tag_guess_complaint, sym_name);
d1602 1
a1602 1
	  complain (&unexpected_type_code_complaint, sym_name);
d1610 1
a1610 1
	      complain (&bad_tag_guess_complaint, sym_name);
d1626 2
a1627 1
	  complain (&unable_to_cross_ref_complaint, sym_name);
d1677 1
a1677 1
    complain (&bad_continued_complaint, sym_name);
d1739 2
a1740 1
	  complain (&array_index_type_complaint, sym_name);
d1790 1
a1790 1
      complain (&unknown_type_qual_complaint, tq);
d1825 3
a1827 1
	  complain (&pdr_static_symbol_complaint, (unsigned long) pr->adr);
d1887 1
a1887 1
      complain (&pdr_for_nonsymbol_complaint, sh_name);
d1935 1
a1935 1
	  complain (&bad_setjmp_pdr_complaint, 0);
d2132 3
a2134 1
	      complain (&bad_linetable_guess_complaint, fdr_name (fh));
d2143 8
d2327 3
a2329 1
	  complain (&bad_ext_ifd_complaint, ext_in->ifd, hdr->ifdMax);
d2334 3
a2336 2
	  complain (&bad_ext_iss_complaint, ext_in->asym.iss,
		    hdr->issExtMax);
d2462 1
a2462 1
	  complain (&unknown_ext_complaint, name);
a2693 3
		    static struct deprecated_complaint function_outside_compilation_unit = {
		      "function `%s' appears to be defined outside of all compilation units", 0, 0
		    };
d3096 1
a3096 1
			    complain (&function_outside_compilation_unit, name);
d3117 1
a3117 1
			    complain (&function_outside_compilation_unit, name);
d3168 2
a3169 1
			complain (&unknown_symchar_complaint, p[1]);
d3230 2
a3231 2
		    complain (&unknown_symtype_complaint,
			      local_hex_string (type_code)); /*CUR_SYMBOL_TYPE*/
d3336 1
a3336 1
		      complain (&index_complaint, name);
d3349 3
a3351 1
		      complain (&aux_index_complaint, name);
d3430 2
a3431 1
		      complain (&block_index_complaint, name);
d3451 3
a3453 2
		  complain (&unknown_sym_complaint, name);
		  complain (&unknown_st_complaint, sh.st);
d3522 1
a3522 2
		  complain (&unknown_ext_complaint,
			    debug_info->ssext + psh->iss);
d3619 1
a3619 1
	      complain (&bad_file_number_complaint, rh);
d3926 1
a3926 1
	    complain (&stab_unknown_complaint, name);
d4237 1
a4237 2
      complain (&bad_rfd_entry_complaint,
		sym_name, xref_fd, rn->index);
d4261 1
a4261 2
      complain (&bad_rfd_entry_complaint,
		sym_name, xref_fd, rn->index);
d4297 2
a4298 1
	    complain (&illegal_forward_tq0_complaint, sym_name);
d4335 3
a4337 1
	      complain (&illegal_forward_bt_complaint, tir.bt, sym_name);
d4419 2
a4420 1
      complain (&block_overflow_complaint, SYMBOL_NAME (s));
@


1.30
log
@2002-10-25  Andrew Cagney  <cagney@@redhat.com>

	* complaints.h (struct deprecated_complaint): Rename `struct
	complaint'.
	* complaints.c (complain): Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Delete
	incorrect comment indicating that "symfile.h" was being included
	for the `struct complaint' definition.
	* remote-vx.c: Update.
	* objc-lang.c: Update.
	* xcoffread.c: Update.
	* hpread.c: Update.
	* mdebugread.c: Update.
	* stabsread.c: Update.
	* dwarf2read.c: Update.
	* dwarfread.c: Update.
	* elfread.c: Update.
	* coffread.c: Update.
	* stabsread.h: Update.
	* dbxread.c: Update.
	* buildsym.c: Update.
	* gdbtypes.c: Update.
	* macrotab.c: Update.
@
text
@d1095 1
d1288 1
@


1.29
log
@* dbxread.c, mdebugread.c: Revert my change of 2001-10-23.  Moving
texthigh and textlow to reader-specific structs caused
objfile_relocate to miss them.  This is fixable, but the work that
the change was supposed to prepare GDB for never got done anyway.
@
text
@d146 1
a146 1
static struct complaint bad_file_number_complaint =
d149 1
a149 1
static struct complaint index_complaint =
d152 1
a152 1
static struct complaint aux_index_complaint =
d155 1
a155 1
static struct complaint block_index_complaint =
d158 1
a158 1
static struct complaint unknown_ext_complaint =
d161 1
a161 1
static struct complaint unknown_sym_complaint =
d164 1
a164 1
static struct complaint unknown_st_complaint =
d167 1
a167 1
static struct complaint block_overflow_complaint =
d170 1
a170 1
static struct complaint basic_type_complaint =
d173 1
a173 1
static struct complaint unknown_type_qual_complaint =
d176 1
a176 1
static struct complaint array_index_type_complaint =
d179 1
a179 1
static struct complaint bad_tag_guess_complaint =
d182 1
a182 1
static struct complaint block_member_complaint =
d185 1
a185 1
static struct complaint stEnd_complaint =
d188 1
a188 1
static struct complaint unknown_mdebug_symtype_complaint =
d191 1
a191 1
static struct complaint stab_unknown_complaint =
d194 1
a194 1
static struct complaint pdr_for_nonsymbol_complaint =
d197 1
a197 1
static struct complaint pdr_static_symbol_complaint =
d200 1
a200 1
static struct complaint bad_setjmp_pdr_complaint =
d203 1
a203 1
static struct complaint bad_fbitfield_complaint =
d206 1
a206 1
static struct complaint bad_continued_complaint =
d209 1
a209 1
static struct complaint bad_rfd_entry_complaint =
d212 1
a212 1
static struct complaint unexpected_type_code_complaint =
d215 1
a215 1
static struct complaint unable_to_cross_ref_complaint =
d218 1
a218 1
static struct complaint bad_indirect_xref_complaint =
d221 1
a221 1
static struct complaint illegal_forward_tq0_complaint =
d224 1
a224 1
static struct complaint illegal_forward_bt_complaint =
d227 1
a227 1
static struct complaint bad_linetable_guess_complaint =
d230 1
a230 1
static struct complaint bad_ext_ifd_complaint =
d233 1
a233 1
static struct complaint bad_ext_iss_complaint =
d2723 1
a2723 1
		    static struct complaint function_outside_compilation_unit = {
@


1.29.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003
a55 2
#include "block.h"
#include "dictionary.h"
a144 5
static void
index_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "bad aux index at symbol %s", arg1);
}
d146 77
a222 5
static void
unknown_ext_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "unknown external symbol %s", arg1);
}
d224 2
a225 6
static void
basic_type_complaint (int arg1, const char *arg2)
{
  complaint (&symfile_complaints, "cannot map ECOFF basic type 0x%x for %s",
	     arg1, arg2);
}
d227 2
a228 5
static void
bad_tag_guess_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "guessed tag type of %s incorrectly", arg1);
}
d230 2
a231 6
static void
bad_rfd_entry_complaint (const char *arg1, int arg2, int arg3)
{
  complaint (&symfile_complaints, "bad rfd entry for %s: file %d, index %d",
	     arg1, arg2, arg3);
}
d233 2
a234 5
static void
unexpected_type_code_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "unexpected type code for %s", arg1);
}
d339 1
a339 3
enum block_type { FUNCTION_BLOCK, NON_FUNCTION_BLOCK };

static struct block *new_block (enum block_type);
d341 1
a341 1
static struct symtab *new_symtab (char *, int, struct objfile *);
d350 1
a350 1
static struct symbol *mylookup_symbol (char *, struct block *, domain_enum,
d353 2
d427 1
a427 1
  FDR *f;
d538 1
d563 1
a563 1
      struct parse_stack *prev = new->prev;
d613 1
a613 1
  struct mdebug_pending *p;
d725 1
a725 1
	  int bucket = hashname (DEPRECATED_SYMBOL_NAME (s));
d746 1
a746 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d769 1
a769 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d798 1
a798 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;	/* so that it can be used */
a806 32
      /* For stProc symbol records, we need to check the storage class
         as well, as only (stProc, scText) entries represent "real"
         procedures - See the Compaq document titled "Object File /
         Symbol Table Format Specification" for more information.
         If the storage class is not scText, we discard the whole block
         of symbol records for this stProc.  */
      if (sh->st == stProc && sh->sc != scText)
        {
          char *ext_tsym = ext_sh;
          int keep_counting = 1;
          SYMR tsym;

          while (keep_counting)
            {
              ext_tsym += external_sym_size;
              (*swap_sym_in) (cur_bfd, ext_tsym, &tsym);
              count++;
              switch (tsym.st)
                {
                  case stParam:
                    break;
                  case stEnd:
                    keep_counting = 0;
                    break;
                  default:
                    complaint (&symfile_complaints,
                               "unknown symbol type 0x%x", sh->st);
                    break;
                }
            }
          break;
        }
d808 1
a808 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d816 1
a816 1
	  if (DEPRECATED_STREQ (name, "malloc") && TYPE_CODE (t) == TYPE_CODE_VOID)
a850 5
      /* All functions in C++ have prototypes.  For C we don't have enough
         information in the debug info.  */
      if (SYMBOL_LANGUAGE (s) == language_cplus)
	TYPE_FLAGS (SYMBOL_TYPE (s)) |= TYPE_FLAG_PROTOTYPED;

d852 1
a852 1
      b = new_block (FUNCTION_BLOCK);
d921 1
a921 22
                /* C++ encodes class types as structures where there the
                   methods are encoded as stProc. The scope of stProc
                   symbols also ends with stEnd, thus creating a risk of
                   taking the wrong stEnd symbol record as the end of
                   the current struct, which would cause GDB to undercount
                   the real number of fields in this struct.  To make sure
                   we really reached the right stEnd symbol record, we
                   check the associated name, and match it against the
                   struct name.  Since method names are mangled while
                   the class name is not, there is no risk of having a
                   method whose name is identical to the class name
                   (in particular constructor method names are different
                   from the class name).  There is therefore no risk that
                   this check stops the count on the StEnd of a method.
		   
		   Also, assume that we're really at the end when tsym.iss
		   is 0 (issNull).  */
                if (tsym.iss == issNull
		    || strcmp (debug_info->ss + cur_fdr->issBase + tsym.iss,
                               name) == 0)
                  goto end_of_fields;
                break;
d990 1
a990 3
		complaint (&symfile_complaints,
			   "declaration block contains unhandled symbol type %d",
			   tsym.st);
a1094 1
		FIELD_STATIC_KIND (*f) = 0;
d1100 1
a1100 1
		DEPRECATED_SYMBOL_NAME (enum_sym) =
d1105 1
a1105 1
		SYMBOL_DOMAIN (enum_sym) = VAR_DOMAIN;
d1135 1
a1135 1
	SYMBOL_DOMAIN (s) = STRUCT_DOMAIN;
d1163 1
a1163 1
      b = new_block (NON_FUNCTION_BLOCK);
d1183 1
a1183 1
	  struct block *b = top_stack->cur_block;
d1191 1
a1191 1
	  SYMBOL_DOMAIN (s) = LABEL_DOMAIN;
d1203 3
a1229 1
		  struct dict_iterator iter;
d1234 1
a1234 2
		  iparams = 0;
		  ALL_BLOCK_SYMBOLS (b, iter, sym)
d1236 1
a1236 3
		      if (iparams == nparams)
			break;

d1260 1
d1275 1
a1275 2
	complaint (&symfile_complaints,
		   "stEnd with storage class %d not handled", sh->sc);
a1286 1
      FIELD_STATIC_KIND (*f) = 0;
d1334 1
a1334 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d1369 1
a1369 1
	    TYPE_NAME (SYMBOL_TYPE (s)) = DEPRECATED_SYMBOL_NAME (s);
d1386 1
a1386 1
      complaint (&symfile_complaints, "unknown symbol type 0x%x", sh->st);
d1455 1
a1455 1
      index_complaint (sym_name);
d1464 1
a1464 1
      basic_type_complaint (t->bt, sym_name);
d1503 1
a1503 1
	  basic_type_complaint (t->bt, sym_name);
d1514 3
a1516 1
      /* Inhibit core dumps if TIR is corrupted.  */
d1529 1
a1529 2
	    complaint (&symfile_complaints, "can't handle TIR fBitfield for %s",
		       sym_name);
d1557 1
a1557 2
	  complaint (&symfile_complaints,
		     "unable to cross ref btIndirect for %s", sym_name);
d1597 1
a1597 1
	  unexpected_type_code_complaint (sym_name);
d1611 1
a1611 1
	      bad_tag_guess_complaint (sym_name);
d1624 1
a1624 1
		   || strcmp (TYPE_TAG_NAME (tp), name) != 0)
d1648 1
a1648 1
	  unexpected_type_code_complaint (sym_name);
d1656 1
a1656 1
	      bad_tag_guess_complaint (sym_name);
d1659 1
a1659 1
	  if (TYPE_NAME (tp) == NULL || !DEPRECATED_STREQ (TYPE_NAME (tp), name))
d1672 1
a1672 2
	  complaint (&symfile_complaints,
		     "unable to cross ref btTypedef for %s", sym_name);
d1722 1
a1722 1
    complaint (&symfile_complaints, "illegal TIR continued for %s", sym_name);
d1784 1
a1784 2
	  complaint (&symfile_complaints,
		     "illegal array index type for %s, assuming int", sym_name);
d1834 1
a1834 1
      complaint (&symfile_complaints, "unknown type qualifier 0x%x", tq);
d1869 1
a1869 3
	  complaint (&symfile_complaints,
		     "can't handle PDR for static proc at 0x%lx",
		     (unsigned long) pr->adr);
d1909 1
a1909 1
      s = lookup_symbol (sh_name, NULL, VAR_DOMAIN, 0, NULL);
d1915 1
a1915 1
	 VAR_DOMAIN,
d1921 1
a1921 1
			 VAR_DOMAIN, LOC_BLOCK);
d1929 1
a1929 1
      complaint (&symfile_complaints, "PDR for %s, but no symbol", sh_name);
d1935 1
a1935 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d1953 1
a1953 1
  i = mylookup_symbol (MIPS_EFI_SYMBOL_NAME, b, LABEL_DOMAIN, LOC_CONST);
d1975 1
a1975 1
      if (e->pdr.pcreg == 0 && DEPRECATED_STREQ (sh_name, "setjmp"))
d1977 1
a1977 1
	  complaint (&symfile_complaints, "fixing bad setjmp PDR from libc");
d2174 1
a2174 3
	      complaint (&symfile_complaints,
			 "guessed size of linetable for %s incorrectly",
			 fdr_name (fh));
a2182 8
static void
function_outside_compilation_unit_complaint (const char *arg1)
{
  complaint (&symfile_complaints,
	     "function `%s' appears to be defined outside of all compilation units",
	     arg1);
}

d2202 1
a2202 1
  EXTR *ext_in;
d2359 1
a2359 3
	  complaint (&symfile_complaints,
		     "bad ifd for external symbol: %d (max %ld)", ext_in->ifd,
		     hdr->ifdMax);
d2364 2
a2365 3
	  complaint (&symfile_complaints,
		     "bad iss for external symbol: %ld (max %ld)",
		     ext_in->asym.iss, hdr->issExtMax);
d2491 1
a2491 1
	  unknown_ext_complaint (name);
d2583 1
a2583 1
	  if (DEPRECATED_STREQ (debug_info->ss + fh->issBase + sh.iss, stabs_symbol))
d2723 3
d2907 1
a2907 1
		      if (pst && DEPRECATED_STREQ (namestring, pst->filename))
d2910 1
a2910 1
			int i;
d2912 1
a2912 1
			  if (DEPRECATED_STREQ (namestring, psymtab_include_list[i]))
d2929 1
a2929 1
			  memcpy (psymtab_include_list, orig,
d2975 1
a2975 1
					     VAR_DOMAIN, LOC_STATIC,
d2985 1
a2985 1
					     VAR_DOMAIN, LOC_STATIC,
d3003 1
a3003 1
						 STRUCT_DOMAIN, LOC_TYPEDEF,
d3011 1
a3011 1
						     VAR_DOMAIN, LOC_TYPEDEF,
d3017 14
d3037 1
a3037 1
						 VAR_DOMAIN, LOC_TYPEDEF,
d3099 1
a3099 1
						     VAR_DOMAIN, LOC_CONST,
d3116 1
a3116 1
					     VAR_DOMAIN, LOC_CONST,
d3128 1
a3128 1
			    function_outside_compilation_unit_complaint (name);
d3133 1
a3133 1
					     VAR_DOMAIN, LOC_BLOCK,
d3149 1
a3149 1
			    function_outside_compilation_unit_complaint (name);
d3154 1
a3154 1
					     VAR_DOMAIN, LOC_BLOCK,
d3177 3
d3200 1
a3200 2
			complaint (&symfile_complaints,
				   "unknown symbol descriptor `%c'", p[1]);
d3261 2
a3262 2
		    complaint (&symfile_complaints, "unknown symbol type %s",
			       local_hex_string (type_code)); /*CUR_SYMBOL_TYPE*/
a3339 33
		  /* Ignore all parameter symbol records.  */
		  if (sh.index >= hdr->iauxMax)
		    {
		      /* Should not happen, but does when cross-compiling
		         with the MIPS compiler.  FIXME -- pull later.  */
		      index_complaint (name);
		      new_sdx = cur_sdx + 1;	/* Don't skip at all */
		    }
		  else
		    new_sdx = AUX_GET_ISYM (fh->fBigendian,
					    (debug_info->external_aux
					     + fh->iauxBase
					     + sh.index));

		  if (new_sdx <= cur_sdx)
		    {
		      /* This should not happen either... FIXME.  */
		      complaint (&symfile_complaints,
				 "bad proc end in aux found from symbol %s",
				 name);
		      new_sdx = cur_sdx + 1;	/* Don't skip backward */
		    }

                  /* For stProc symbol records, we need to check the
                     storage class as well, as only (stProc, scText)
                     entries represent "real" procedures - See the
                     Compaq document titled "Object File / Symbol Table
                     Format Specification" for more information.  If the
                     storage class is not scText, we discard the whole
                     block of symbol records for this stProc.  */
                  if (sh.st == stProc && sh.sc != scText)
                    goto skip;

d3353 1
a3353 1
					 VAR_DOMAIN, LOC_BLOCK,
d3358 1
a3358 1
					 VAR_DOMAIN, LOC_BLOCK,
d3362 13
d3377 7
d3447 1
a3447 1
					   STRUCT_DOMAIN, LOC_TYPEDEF,
d3459 1
a3459 2
		      complaint (&symfile_complaints,
				 "bad aux index at block symbol %s", name);
d3479 2
a3480 3
		  complaint (&symfile_complaints, "unknown local symbol %s",
			     name);
		  complaint (&symfile_complaints, "with type %d", sh.st);
d3486 1
a3486 1
				   VAR_DOMAIN, class,
d3549 2
a3550 1
		  unknown_ext_complaint (debug_info->ssext + psh->iss);
d3563 1
a3563 1
				   VAR_DOMAIN, class,
d3582 2
a3583 2
	  objfile->ei.deprecated_entry_file_lowpc = save_pst->textlow;
	  objfile->ei.deprecated_entry_file_highpc = save_pst->texthigh;
d3647 1
a3647 1
	      complaint (&symfile_complaints, "bad file number %ld", rh);
d3733 1
a3733 1
			   VAR_DOMAIN, LOC_CONST,
d3841 1
a3841 1
      if (DEPRECATED_STREQ (debug_info->ss + fh->issBase + sh.iss,
d3926 1
a3926 1
		  SYMBOL_DOMAIN (s) = LABEL_DOMAIN;
d3954 1
a3954 1
	    complaint (&symfile_complaints, "unknown stabs symbol %s", name);
d3963 4
d4020 3
d4026 1
a4026 1
	  st = new_symtab ("unknown", 0, pst->objfile);
d4030 1
d4032 1
a4032 1
	  st = new_symtab (pst->filename, maxlines, pst->objfile);
d4052 1
d4136 4
d4161 3
d4265 2
a4266 1
      bad_rfd_entry_complaint (sym_name, xref_fd, rn->index);
d4290 2
a4291 1
      bad_rfd_entry_complaint (sym_name, xref_fd, rn->index);
d4327 1
a4327 2
	    complaint (&symfile_complaints,
		       "illegal tq0 in forward typedef for %s", sym_name);
d4364 1
a4364 3
	      complaint (&symfile_complaints,
			 "illegal bt %d in forward typedef for %s", tir.bt,
			 sym_name);
d4408 2
a4409 2
mylookup_symbol (char *name, struct block *block,
		 domain_enum domain, enum address_class class)
d4411 1
a4411 2
  struct dict_iterator iter;
  int inc;
d4415 1
a4415 1
  ALL_BLOCK_SYMBOLS (block, iter, sym)
d4417 2
a4418 2
      if (DEPRECATED_SYMBOL_NAME (sym)[0] == inc
	  && SYMBOL_DOMAIN (sym) == domain
d4420 1
a4420 1
	  && strcmp (DEPRECATED_SYMBOL_NAME (sym), name) == 0)
d4426 1
a4426 1
    return mylookup_symbol (name, block, domain, class);
d4431 4
a4434 1
/* Add a new symbol S to a block B.  */
d4439 26
a4464 1
  dict_add_symbol (BLOCK_DICT (b), s);
d4524 1
a4524 1
  int addr_diff;
d4565 2
a4566 2
    CORE_ADDR high = 0;
    int i, j = BLOCKVECTOR_NBLOCKS (bv);
d4586 2
a4587 2
/* Allocate a new symtab for NAME.  Needs an estimate of how many
   linenumbers MAXLINES we'll put in it */
d4590 1
a4590 1
new_symtab (char *name, int maxlines, struct objfile *objfile)
d4598 2
a4599 4
  BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK)
    = new_block (NON_FUNCTION_BLOCK);
  BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK)
    = new_block (NON_FUNCTION_BLOCK);
d4683 12
a4694 4
/* Allocate and zero a new block, and set its BLOCK_DICT.  If function
   is non-zero, assume the block is associated to a function, and make
   sure that the symbols are stored linearly; otherwise, store them
   hashed.  */
d4697 1
a4697 1
new_block (enum block_type type)
d4699 3
a4701 4
  /* FIXME: carlton/2003-09-11: This should use allocate_block to
     allocate the block.  Which, in turn, suggests that the block
     should be allocated on an obstack.  */
  struct block *retval = xzalloc (sizeof (struct block));
d4703 1
a4703 4
  if (type == FUNCTION_BLOCK)
    BLOCK_DICT (retval) = dict_create_linear_expandable ();
  else
    BLOCK_DICT (retval) = dict_create_hashed_expandable ();
d4705 20
a4724 1
  return retval;
d4737 2
d4740 1
a4740 1
  SYMBOL_SET_NAMES (s, name, strlen (name), current_objfile);
a4767 8
  struct cleanup *back_to;

  /* FIXME: It's not clear whether we should be getting minimal symbol
     information from .mdebug in an ELF file, or whether we will.
     Re-initialize the minimal symbol reader in case we do.  */

  init_minimal_symbol_collection ();
  back_to = make_cleanup_discard_minimal_symbols ();
a4777 3

  install_minimal_symbols (objfile);
  do_cleanups (back_to);
d4810 1
a4810 1
  s = lookup_symbol ("sigvec", 0, VAR_DOMAIN, 0, NULL);
d4814 1
a4814 1
      s = lookup_symbol ("sigtramp", b0, VAR_DOMAIN, 0, NULL);
d4819 1
a4819 1
      s = lookup_symbol ("_sigtramp", 0, VAR_DOMAIN, 0, NULL);
d4845 1
a4845 1
  SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d4852 1
a4852 1
  b = new_block (NON_FUNCTION_BLOCK);
d4889 1
a4889 1
    SYMBOL_DOMAIN (s) = LABEL_DOMAIN;
d4895 1
a4895 1
  dict_add_symbol (BLOCK_DICT (b), s);
@


1.29.4.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d2 3
a4 5

   Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.

d429 1
a429 1
      info->fdr = (FDR *) obstack_alloc (&objfile->objfile_obstack,
d582 1
a582 1
	   obstack_alloc (&current_objfile->objfile_obstack,
d796 1
a796 2
	  if (strcmp (name, "malloc") == 0
	      && TYPE_CODE (t) == TYPE_CODE_VOID)
d1060 1
a1060 1
	  TYPE_TAG_NAME (t) = obconcat (&current_objfile->objfile_obstack,
d1106 1
a1106 1
			    obstack_alloc (&current_objfile->objfile_obstack,
d1111 1
a1111 1
				&current_objfile->objfile_obstack);
d1204 1
a1204 1
	       obstack_alloc (&current_objfile->objfile_obstack,
d1637 1
a1637 1
					    &current_objfile->objfile_obstack);
d1670 1
a1670 2
	  if (TYPE_NAME (tp) == NULL
	      || strcmp (TYPE_NAME (tp), name) != 0)
d1672 1
a1672 1
					   &current_objfile->objfile_obstack);
d1696 1
a1696 1
					    &current_objfile->objfile_obstack);
d1700 1
a1700 1
					    &current_objfile->objfile_obstack);
d1990 1
a1990 2
      if (e->pdr.pcreg == 0
	  && strcmp (sh_name, "setjmp") == 0)
d2260 1
a2260 1
  extern_tab = (EXTR *) obstack_alloc (&objfile->objfile_obstack,
d2304 1
a2304 1
     obstack_alloc (&objfile->objfile_obstack,
d2556 1
a2556 1
				  obstack_alloc (&objfile->objfile_obstack,
d2611 1
a2611 2
	  if (strcmp (debug_info->ss + fh->issBase + sh.iss,
		      stabs_symbol) == 0)
d2932 1
a2932 1
		      if (pst && strcmp (namestring, pst->filename) == 0)
d2937 1
a2937 2
			  if (strcmp (namestring,
				      psymtab_include_list[i]) == 0)
d3657 1
a3657 1
	 obstack_alloc (&objfile->objfile_obstack,
d3864 2
a3865 2
      if (strcmp (debug_info->ss + fh->issBase + sh.iss,
		  stabs_symbol) == 0)
d3944 1
a3944 1
		   obstack_alloc (&current_objfile->objfile_obstack,
d4505 1
a4505 1
  LONGEST addr_diff;
d4588 1
a4588 1
				 &objfile->objfile_obstack);
d4605 1
a4605 1
				  obstack_alloc (&objfile->objfile_obstack,
d4693 1
a4693 1
		      obstack_alloc (&current_objfile->objfile_obstack,
d4736 1
a4736 1
	  obstack_alloc (&objfile->objfile_obstack,
@


1.29.2.1
log
@2002-09-18  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h: Delete BLOCK_SHOULD_SORT.
	* symtab.c (lookup_block_symbol): Assume non-hashed blocks aren't
	sorted.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.h: Delete prototypes for sort_block_syms and
	sort_symtab_syms.
	* symfile.c: Delete functions sort_block_syms and
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Remove call to
	sort_symtab_syms.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.

2002-09-20  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (c-lang.o): Correct dependencies.
	(utils.o): Gather dependencies.
	(charset.o): Move.
@
text
@d3963 4
d4160 3
@


1.29.2.2
log
@2002-09-20  David Carlton  <carlton@@math.stanford.edu>

	* jv-lang.c (get_java_class_symtab): Use xmalloc to allocate
	GLOBAL_BLOCK rather than xmmalloc.
	(free_class_block): Use xfree rather than xmfree.
	* mdebugread.c: #include "dictionary.h"
	(new_block): Remove argument.  Initialize BLOCK_DICT.
	(parse_symbol): Update call to new_block.
	(new_symtab): Ditto.
	(fixup_sigtramp): Ditto.
	Delete MAXSYMS member of struct parse_stack.
	(psymtab_to_symtab_1): Don't set maxsyms.
	(new_symtab): Remove maxsyms argument.
	(psymtab_to_symtab_1): Update call to new_symtab.
	(shrink_block): Delete function.
	(add_symbol): Add symbols via dict_add_symbol_block.
	* jv-lang.c (add_class_symtab_symbol): Add symbols via
	dict_add_symbol_block.
	Delete variable class_symtab_space.
	* Makefile.in (jv-lang.o): Add dictionary_h.
	* jv-lang.c: #include "dictionary.h"
	* symmisc.c (free_symtab): Call free_func rather than freeing free_ptr.
	* jv-lang.c (get_java_class_symtab): Initialize free_func rather
	than free_ptr.
	(free_class_block): New function.
	(add_class_symtab_symbol): Delete reference to free_ptr.
	* buildsym.c (end_symtab): Initialize free_func rather than free_ptr.
	* symtab.h (struct symtab): Replace free_ptr by free_func.
	* jv-lang.c (get_java_class_symtab): Add DICT_BLOCK assignments.
	* Makefile.in (buildsym.o): Add dictionary_h.
	* buildsym.c (finish_block): Initialize BLOCK_DICT (block).
	#include "dictionary.h"
	* symtab.h (struct block): Add 'dict' member.
	(BLOCK_DICT): New macro.
	* dictionary.c: New file.
	* dictionary.h: New file.
	* Makefile.in (SFILES): Add dictionary.c
	(dictionary_h): New variable.
	(COMMON_OBS): Add dictionary.o.
	(dictionary.o): New rule.
	(carlton): New rule.
@
text
@a55 1
#include "dictionary.h"
d339 1
a339 1
static struct block *new_block (void);
d341 1
a341 1
static struct symtab *new_symtab (char *, int, struct objfile *);
d353 2
d538 1
d852 1
a852 1
      b = new_block ();
d1163 1
a1163 1
      b = new_block ();
d1183 1
a1183 1
	  struct block *b = top_stack->cur_block;
d1203 3
d1260 1
d1941 1
a1941 1
      b = new_block ();
d4018 1
d4022 1
a4022 1
	  st = new_symtab ("unknown", 0, pst->objfile);
d4026 1
d4028 1
a4028 1
	  st = new_symtab (pst->filename, maxlines, pst->objfile);
d4048 1
d4132 4
d4424 4
a4427 1
/* Add a new symbol S to a block B.  */
d4433 1
a4433 1
  struct block *newb;
d4436 2
a4437 4
  newb = dict_add_symbol_block (BLOCK_DICT (b), s);

  /* Update all the pointers to b that we can find.  */
  if (newb != b)
d4439 5
a4443 2
      int i;
      struct blockvector *bv = BLOCKVECTOR (top_stack->cur_st);
a4444 8
      if (BLOCK_FUNCTION (newb)
	  && SYMBOL_BLOCK_VALUE (BLOCK_FUNCTION (newb)) == b)
	SYMBOL_BLOCK_VALUE (BLOCK_FUNCTION (newb)) = newb;
      for (i = 0; i < BLOCKVECTOR_NBLOCKS (bv); i++)
	if (BLOCKVECTOR_BLOCK (bv, i) == b)
	  BLOCKVECTOR_BLOCK (bv, i) = newb;
	else if (BLOCK_SUPERBLOCK (BLOCKVECTOR_BLOCK (bv, i)) == b)
	  BLOCK_SUPERBLOCK (BLOCKVECTOR_BLOCK (bv, i)) = newb;
d4446 2
a4447 1
         original block.  */
d4450 1
a4450 1
	  if (stackp->cur_block == b)
d4452 2
a4453 1
	      stackp->cur_block = newb;
d4457 1
d4580 1
a4580 1
   and linenumbers MAXLINES we'll put in it */
d4583 1
a4583 1
new_symtab (char *name, int maxlines, struct objfile *objfile)
a4585 2
  struct block *global_block;
  struct block *static_block;
d4591 4
a4594 5
  global_block = new_block ();
  static_block = new_block ();
  BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK) = global_block;
  BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK) = static_block;
  BLOCK_SUPERBLOCK (static_block) = global_block;
d4676 12
a4687 1
/* Allocate and zero a new block.  Set its BLOCK_DICT.  */
d4690 1
a4690 1
new_block (void)
d4692 5
a4696 2
  struct block *retval = xzalloc (sizeof (struct block));
  BLOCK_DICT (retval) = dict_create_block_expandable (retval);
d4698 20
a4717 1
  return retval;
d4845 1
a4845 1
  b = new_block ();
@


1.29.2.3
log
@2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c (struct dict_vtbl): 'add_symbol' field.
	(add_symbol_generic): New function.
	(free_obstack): New function.
	(dict_create_hashed): New function.
	(lookup_hashed): New function.
	(iterator_first_hashed): New function.
	(iterator_hashed_advance): New function.
	(iterator_next_hashed): New function.
	* dictionary.h: A few more declarations.
	* mdebugread.c (parse_symbol): Use dict_iterator when finding
	parameters.
	* Makefile.in (valops.o): Depend on dictionary_h.
	* valops.c (value_of_this): Check empty block via dict_empty.
	#include "dictionary.h"
	* symfile.c (free_named_symtabs): Check empty block via dict_empty.
	* dictionary.h: Declare dict_empty.
	* symmisc.c (dump_symtab): Don't print out number of
	symbols/buckets.
	* printcmd.c (print_frame_args): Delete assertion that block isn't
	a hashtable.
	* symmisc.c (free_symtab_block): Update to use dictionary
	methods.
	* symtab.h (struct symtab): Comment on free_contents.
	* jv-lang.c (get_java_class_symtab): Set class_symtab->free_code.
	* mdebugread.c (add_symbol): Delete 'nsyms' variable.
	(fixup_sigtramp): Add symbol via dict_add_symbol_block.
	* Makefile.in (mi-cmd-stack.o): Depend on dictionary_h.
	* ada-lang.c (symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(ada_add_block_symbols): Ditto.
	(debug_print_block): Ditto.
	(fill_in_ada_prototype): Ditto.
	* breakpoint.c (get_catch_sals): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	(scope_info): Ditto.
	* symtab.c (find_pc_sect_symtab): Ditto.
	(search_symbols): Ditto.
	(make_symbol_completion_list): Ditto.
	(find_addr_symbol): Ditto.
	(make_file_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* symmisc.c (dump_symtab): Ditto.
	* stack.c (print_block_frame_locals): Ditto.
	(print_block_frame_labels): Ditto.
	(print_frame_arg_vars): Ditto.
	* printcmd.c (print_frame_args): Ditto.
	* objfiles.c (objfile_relocate): Ditto.
	* mdebugread.c (mylookup_symbol): Ditto.
	* Makefile.in (ada-lang.o): Depend on dictionary_h.
	* Makefile.in (tracepoint.o): Ditto.
	* Makefile.in (symmisc.o): Ditto.
	* Makefile.in (stack.o): Ditto.
	* Makefile.in (printcmd.o): Ditto.
	* Makefile.in (objfiles.o): Ditto.
	* Makefile.in (coffread.o): Ditto.
	* Makefile.in (breakpoint.o): Ditto.
	* ada-lang.c: #include "dictionary.h"
	* tracepoint.c: Ditto.
	* symmisc.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* coffread.c: Ditto.
	* breakpoint.c: Ditto.
	* symtab.h: Comment out ALL_BLOCK_SYMBOLS.  (Moved to
	dictionary.h.)
	* dictionary.c: Dict_iterator accessor macros.
	(struct dict_vtbl): Add iterator_first, iterator_next.
	(dict_iterator_first): New function.
	(dict_iterator_next): New function.
	(iterator_first_block): New function.
	(iterator_next_block): New function.
	(iterator_block_hashed_advance): New function.
	* dictionary.h: Add dict_iterator stuff.
	* Makefile.in (symtab.o): Depend on dictionary_h.
	* symtab.c: #include "dictionary.h"
	* dictionary.c: Move down #include "dictionary.h", for now...
	(free_block): Rename from dict_free_block.
	(struct dict_vtbl): Add LOOKUP member.
	(dict_lookup): New function.
	(lookup_block): New function.
	* dictionary.h: Declare dict_lookup.
	* symtab.c (lookup_block_symbol): Use dict_lookup.

2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c (list_args_or_locals): Update use of
	ALL_BLOCK_SYMBOLS.
	#include "dictionary.h"
@
text
@a1227 1
		  struct dict_iterator iter;
d1229 1
a1229 4
		  for (sym = dict_iterator_first (BLOCK_DICT (b), &iter),
			 iparams = 0;
		       iparams < nparams;
		       sym = dict_iterator_next (&iter))
d1231 1
a1231 1
		      gdb_assert (sym != NULL);
d4391 1
a4391 2
  struct dict_iterator iter;
  int inc;
d4395 1
a4395 1
  ALL_BLOCK_SYMBOLS (block, iter, sym)
d4416 1
d4809 2
d4846 1
a4846 3
  b = dict_add_symbol_block (BLOCK_DICT (b), s);
  add_block (b, st);
  sort_blocks (st);
@


1.29.2.4
log
@2002-09-24  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c: Comment out block-specific stuff.
	* jv-lang.c (get_java_class_symtab): Allocate GLOBAL_BLOCK on
	obstack.
	(free_class_block): Don't free GLOBAL_BLOCK.
	* dictionary.h: Comment out block-specific stuff.
	* symtab.h: Comment out the members of struct block that
	BLOCK_DICT obsoletes, and their accessors.
	* Makefile.in (buildsym.o): Depend on gdb_assert_h.
	* buildsym.c (finish_block): Don't count number of symbols.
	(finish_block): Replace BLOCK_SYM reference with use of iterator.
	#include "gdb_assert.h"
	* symfile.c (free_named_symtabs): Fix calls to dict_empty
	(which would seem to be #if'd out; oops...).
	* buildsym.c (finish_block): Don't set BLOCK_HASHTABLE.
	* jv-lang.c (get_java_class_symtab): Don't set BLOCK_HASHTABLE and
	BLOCK_NSYMS.
	* mdebugread.c (new_block): Allocate BLOCK_DICT via
	dict_create_linear_expandable.
	(add_symbol): Add symbol via dict_add_symbol; no need to chase
	pointers.
	(fixup_sigtramp): Add symbol via dict_add_symbol.
	(new_symtab): Add FIXME comment on freeing blocks.
	* jv-lang.c (get_java_class_symtab): Allocate GLOBAL_BLOCK's dict
	using dict_create_linear_expandable.
	(add_class_symtab_symbol): Add symbol using dict_add_symbol.
	* dictionary.c (struct dictionary_linear_expandable): New struct.
	(struct dictionary): Added member 'linear_expandable'.
	(DICT_LINEAR_EXPANDABLE_MAXSYMS): New macro.
	New variable dict_block_vtbl.  Made all the _vtbl variables static.
	Renamed all 'maxsyms' to 'capacity'.
	(dict_create_linear_expandable): New function.
	(add_symbol_linear_expandable): New function.
	(free_linear_expandable): New function.
	* jv-lang.c (get_java_class_symtab): Create static block's
	dictionary with dict_create_linear.
	* buildsym.c (finish_block): Create function blocks' dictionaries
	with dict_create_linear.
	* dictionary.c (lookup_linear): New function.
	(iterator_first_linear): New function.
	(iterator_next_linear): New function.
	* dictionary.h: Moved comment.
	* dictionary.c (struct dictionary_linear): New struct.
	(struct dictionary): Added 'linear' member.
	(DICT_LINEAR_NSYMS): New macro.
	(DICT_LINEAR_SYMS): New macro.
	(DICT_LINEAR_SYM): New macro.
	New variable dict_linear_vtbl.
	(dict_create_linear): New function.
@
text
@d4424 26
a4449 1
  dict_add_symbol (BLOCK_DICT (b), s);
a4590 2
  /* FIXME: carlton/2002-09-24: But how do the blocks get freed?
     Oy.  */
d4677 1
a4677 1
  BLOCK_DICT (retval) = dict_create_linear_expandable ();
d4848 1
a4848 1
  dict_add_symbol (BLOCK_DICT (b), s);
@


1.29.2.5
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a45 1
#include "block.h"
@


1.29.2.6
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d148 1
a148 1
static struct deprecated_complaint bad_file_number_complaint =
d151 1
a151 1
static struct deprecated_complaint index_complaint =
d154 1
a154 1
static struct deprecated_complaint aux_index_complaint =
d157 1
a157 1
static struct deprecated_complaint block_index_complaint =
d160 1
a160 1
static struct deprecated_complaint unknown_ext_complaint =
d163 1
a163 1
static struct deprecated_complaint unknown_sym_complaint =
d166 1
a166 1
static struct deprecated_complaint unknown_st_complaint =
d169 1
a169 1
static struct deprecated_complaint block_overflow_complaint =
d172 1
a172 1
static struct deprecated_complaint basic_type_complaint =
d175 1
a175 1
static struct deprecated_complaint unknown_type_qual_complaint =
d178 1
a178 1
static struct deprecated_complaint array_index_type_complaint =
d181 1
a181 1
static struct deprecated_complaint bad_tag_guess_complaint =
d184 1
a184 1
static struct deprecated_complaint block_member_complaint =
d187 1
a187 1
static struct deprecated_complaint stEnd_complaint =
d190 1
a190 1
static struct deprecated_complaint unknown_mdebug_symtype_complaint =
d193 1
a193 1
static struct deprecated_complaint stab_unknown_complaint =
d196 1
a196 1
static struct deprecated_complaint pdr_for_nonsymbol_complaint =
d199 1
a199 1
static struct deprecated_complaint pdr_static_symbol_complaint =
d202 1
a202 1
static struct deprecated_complaint bad_setjmp_pdr_complaint =
d205 1
a205 1
static struct deprecated_complaint bad_fbitfield_complaint =
d208 1
a208 1
static struct deprecated_complaint bad_continued_complaint =
d211 1
a211 1
static struct deprecated_complaint bad_rfd_entry_complaint =
d214 1
a214 1
static struct deprecated_complaint unexpected_type_code_complaint =
d217 1
a217 1
static struct deprecated_complaint unable_to_cross_ref_complaint =
d220 1
a220 1
static struct deprecated_complaint bad_indirect_xref_complaint =
d223 1
a223 1
static struct deprecated_complaint illegal_forward_tq0_complaint =
d226 1
a226 1
static struct deprecated_complaint illegal_forward_bt_complaint =
d229 1
a229 1
static struct deprecated_complaint bad_linetable_guess_complaint =
d232 1
a232 1
static struct deprecated_complaint bad_ext_ifd_complaint =
d235 1
a235 1
static struct deprecated_complaint bad_ext_iss_complaint =
a1093 1
		FIELD_STATIC_KIND (*f) = 0;
a1285 1
      FIELD_STATIC_KIND (*f) = 0;
d2722 1
a2722 1
		    static struct deprecated_complaint function_outside_compilation_unit = {
@


1.29.2.7
log
@2002-12-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_minsyms): Don't call
	lookup_symbol_aux from within this.
	* values.c (value_static_field): lookup_symbol_linkage.
	(value_fn_field): lookup_symbol_linkage.
	* valops.c (value_struct_elt_for_reference): lookup_symbol_linkage.
	* blockframe.c (inside_main_func): lookup_symbol_linkage.
	* source.c (select_source_symtab): lookup_symbol_linkage.
	* nlmread.c (nlm_symfile_read): Call lookup_symbol_linkage.
	* nindy-tdep.c (nindy_frame_chain_valid): Call
	lookup_symbol_linkage.
	* linespec.c (count_methods): Call lookup_symbol_linkage.
	(add_matching_methods): Ditto.
	(add_constructors): Ditto.
	* hppa-tdep.c (find_stub_with_shl_get): Call
	lookup_symbol_linkage.  Delete symbol2.
	(initialize_hp_cxx_exception_support): Call lookup_symbol_linkage.
	* cli/cli-cmds.c (edit_command): SYMBOL_PRINT_NAME.
	(list_command): SYMBOL_PRINT_NAME.
	* valops.c (value_of_variable): SYMBOL_PRINT_NAME
	(hand_function_call): SYMBOL_PRINT_NAME.
	* typeprint.c (typedef_print): SYMBOL_PRINT_NAME.
	* tracepoint.c (tracepoints_info): SYMBOL_PRINT_NAME.
	* symtab.c (lookup_partial_symbol): SYMBOL_BEST_NAME.
	(compare_search_syms): SYMBOL_BEST_NAME.
	(print_symbol_info): SYMBOL_PRINT_NAME.
	(print_msymbol_info): SYMBOL_PRINT_NAME.
	(rbreak_command): SYMBOL_PRINT_NAME.
	* symmisc.c (print_symbol): SYMBOL_PRINT_NAME.
	* stack.c (print_frame): SYMBOL_PRINT_NAME.
	(frame_info): SYMBOL_PRINT_NAME.
	(print_block_frame_locals): SYMBOL_PRINT_NAME.
	(print_block_frame_labels): SYMBOL_PRINT_NAME.
	(print_frame_arg_vars): SYMBOL_PRINT_NAME.
	(return_command): SYMBOL_PRINT_NAME.
	* stabsread.c (define_symbol): SYMBOL_PRINT_NAME.
	* p-valprint.c (pascal_val_print): SYMBOL_PRINT_NAME.
	* printcmd.c (build_address_symbolic): SYMBOL_PRINT_NAME.
	(sym_info): SYMBOL_PRINT_NAME.
	(print_frame_args): SYMBOL_PRINT_NAME.
	* objc-lang.c (compare_selectors): SYMBOL_BEST_NAME.
	(compare_classes): SYMBOL_BEST_NAME.
	* maint.c (maintenance_translate_address): SYMBOL_PRINT_NAME.
	* linespec.c (find_method): SYMBOL_PRINT_NAME.
	(select_symbols): SYMBOL_PRINT_NAME.
	* infcmd.c (jump_command): SYMBOL_PRINT_NAME.
	* findvar.c (locate_var_value): SYMBOL_PRINT_NAME.
	* expprint.c (print_subexp): SYMBOL_PRINT_NAME.
	* c-valprint.c (c_val_print): SYMBOL_PRINT_NAME.
	* buildsym.c (finish_block): SYMBOL_PRINT_NAME.
	* breakpoint.c (print_one_breakpoint): SYMBOL_PRINT_NAME.
	* ax-gdb.c (gen_var_ref): SYMBOL_PRINT_NAME.
	* ada-typeprint.c (ada_typedef_print): SYMBOL_PRINT_NAME.
	* ada-lang.c (user_select_syms): Use SYMBOL_PRINT_NAME instead of
	SYMBOL_SOURCE_NAME.
	(user_select_syms):
	(ada_finish_decode_line_1): Use SYMBOL_BEST_NAME instead of
	SYMBOL_SOURCE_NAME.
	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME.
	* symfile.c (compare_symbols): Use SYMBOL_BEST_NAME, not
	SYMBOL_SOURCE_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_symbol_linkage): New function.
	* symtab.h: Declare lookup_symbol_linkage.
	* c-valprint.c (c_val_print): Call lookup_symbol_minsym.
	* symtab.c (lookup_symbol_aux_minsyms): Call minsym_static.
	* minsyms.c (minsym_static): New function.
	* symtab.h: Declare minsym_static.
	* symtab.c (lookup_symbol_minsym): New function.
	(search_symbols): Call lookup_symbol_minsym instead of
	lookup_symbol.
	(lookup_symbol_namespace): Don't take apart NAME.
	* symtab.h: Declare lookup_symbol_minsym.
	* printcmd.c (build_address_symbolic): Don't use old version of
	SYMBOL_LINKAGE_NAME.
	* symtab.c (lookup_block_symbol): Change mangled names to linkage
	name, and use SYMBOL_LINKAGE_NAME as appropriate.
	* symtab.h (SYMBOL_LINKAGE_NAME): New macro, with a different
	meaning from the old macro of the same name.  Also, add comments
	about proper uses of names.
@
text
@d4745 1
a4745 1
  s = lookup_symbol_linkage ("sigvec");
d4749 1
a4749 1
      s = lookup_symbol_linkage ("sigtramp");
d4754 1
a4754 1
      s = lookup_symbol_linkage ("_sigtramp");
@


1.29.2.8
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a146 5
static void
index_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "bad aux index at symbol %s", arg1);
}
d148 77
a224 5
static void
unknown_ext_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "unknown external symbol %s", arg1);
}
d226 2
a227 6
static void
basic_type_complaint (int arg1, const char *arg2)
{
  complaint (&symfile_complaints, "cannot map ECOFF basic type 0x%x for %s",
	     arg1, arg2);
}
d229 2
a230 5
static void
bad_tag_guess_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "guessed tag type of %s incorrectly", arg1);
}
d232 2
a233 6
static void
bad_rfd_entry_complaint (const char *arg1, int arg2, int arg3)
{
  complaint (&symfile_complaints, "bad rfd entry for %s: file %d, index %d",
	     arg1, arg2, arg3);
}
d235 2
a236 5
static void
unexpected_type_code_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "unexpected type code for %s", arg1);
}
d989 1
a989 3
		complaint (&symfile_complaints,
			   "declaration block contains unhandled symbol type %d",
			   tsym.st);
d1275 1
a1275 2
	complaint (&symfile_complaints,
		   "stEnd with storage class %d not handled", sh->sc);
d1387 1
a1387 1
      complaint (&symfile_complaints, "unknown symbol type 0x%x", sh->st);
d1456 1
a1456 1
      index_complaint (sym_name);
d1465 1
a1465 1
      basic_type_complaint (t->bt, sym_name);
d1504 1
a1504 1
	  basic_type_complaint (t->bt, sym_name);
d1530 1
a1530 2
	    complaint (&symfile_complaints, "can't handle TIR fBitfield for %s",
		       sym_name);
d1558 1
a1558 2
	  complaint (&symfile_complaints,
		     "unable to cross ref btIndirect for %s", sym_name);
d1598 1
a1598 1
	  unexpected_type_code_complaint (sym_name);
d1612 1
a1612 1
	      bad_tag_guess_complaint (sym_name);
d1649 1
a1649 1
	  unexpected_type_code_complaint (sym_name);
d1657 1
a1657 1
	      bad_tag_guess_complaint (sym_name);
d1673 1
a1673 2
	  complaint (&symfile_complaints,
		     "unable to cross ref btTypedef for %s", sym_name);
d1723 1
a1723 1
    complaint (&symfile_complaints, "illegal TIR continued for %s", sym_name);
d1785 1
a1785 2
	  complaint (&symfile_complaints,
		     "illegal array index type for %s, assuming int", sym_name);
d1835 1
a1835 1
      complaint (&symfile_complaints, "unknown type qualifier 0x%x", tq);
d1870 1
a1870 3
	  complaint (&symfile_complaints,
		     "can't handle PDR for static proc at 0x%lx",
		     (unsigned long) pr->adr);
d1930 1
a1930 1
      complaint (&symfile_complaints, "PDR for %s, but no symbol", sh_name);
d1978 1
a1978 1
	  complaint (&symfile_complaints, "fixing bad setjmp PDR from libc");
d2175 1
a2175 3
	      complaint (&symfile_complaints,
			 "guessed size of linetable for %s incorrectly",
			 fdr_name (fh));
a2183 8
static void
function_outside_compilation_unit_complaint (const char *arg1)
{
  complaint (&symfile_complaints,
	     "function `%s' appears to be defined outside of all compilation units",
	     arg1);
}

d2360 1
a2360 3
	  complaint (&symfile_complaints,
		     "bad ifd for external symbol: %d (max %ld)", ext_in->ifd,
		     hdr->ifdMax);
d2365 2
a2366 3
	  complaint (&symfile_complaints,
		     "bad iss for external symbol: %ld (max %ld)",
		     ext_in->asym.iss, hdr->issExtMax);
d2492 1
a2492 1
	  unknown_ext_complaint (name);
d2724 3
d3129 1
a3129 1
			    function_outside_compilation_unit_complaint (name);
d3150 1
a3150 1
			    function_outside_compilation_unit_complaint (name);
d3201 1
a3201 2
			complaint (&symfile_complaints,
				   "unknown symbol descriptor `%c'", p[1]);
d3262 2
a3263 2
		    complaint (&symfile_complaints, "unknown symbol type %s",
			       local_hex_string (type_code)); /*CUR_SYMBOL_TYPE*/
d3368 1
a3368 1
		      index_complaint (name);
d3381 1
a3381 3
		      complaint (&symfile_complaints,
				 "bad proc end in aux found from symbol %s",
				 name);
d3460 1
a3460 2
		      complaint (&symfile_complaints,
				 "bad aux index at block symbol %s", name);
d3480 2
a3481 3
		  complaint (&symfile_complaints, "unknown local symbol %s",
			     name);
		  complaint (&symfile_complaints, "with type %d", sh.st);
d3550 2
a3551 1
		  unknown_ext_complaint (debug_info->ssext + psh->iss);
d3648 1
a3648 1
	      complaint (&symfile_complaints, "bad file number %ld", rh);
d3955 1
a3955 1
	    complaint (&symfile_complaints, "unknown stabs symbol %s", name);
d4252 2
a4253 1
      bad_rfd_entry_complaint (sym_name, xref_fd, rn->index);
d4277 2
a4278 1
      bad_rfd_entry_complaint (sym_name, xref_fd, rn->index);
d4314 1
a4314 2
	    complaint (&symfile_complaints,
		       "illegal tq0 in forward typedef for %s", sym_name);
d4351 1
a4351 3
	      complaint (&symfile_complaints,
			 "illegal bt %d in forward typedef for %s", tir.bt,
			 sym_name);
@


1.29.2.9
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003
a752 32
      /* For stProc symbol records, we need to check the storage class
         as well, as only (stProc, scText) entries represent "real"
         procedures - See the Compaq document titled "Object File /
         Symbol Table Format Specification" for more information.
         If the storage class is not scText, we discard the whole block
         of symbol records for this stProc.  */
      if (sh->st == stProc && sh->sc != scText)
        {
          char *ext_tsym = ext_sh;
          int keep_counting = 1;
          SYMR tsym;

          while (keep_counting)
            {
              ext_tsym += external_sym_size;
              (*swap_sym_in) (cur_bfd, ext_tsym, &tsym);
              count++;
              switch (tsym.st)
                {
                  case stParam:
                    break;
                  case stEnd:
                    keep_counting = 0;
                    break;
                  default:
                    complaint (&symfile_complaints,
                               "unknown symbol type 0x%x", sh->st);
                    break;
                }
            }
          break;
        }
a796 5
      /* All functions in C++ have prototypes.  For C we don't have enough
         information in the debug info.  */
      if (SYMBOL_LANGUAGE (s) == language_cplus)
	TYPE_FLAGS (SYMBOL_TYPE (s)) |= TYPE_FLAG_PROTOTYPED;

d867 1
a867 18
                /* C++ encodes class types as structures where there the
                   methods are encoded as stProc. The scope of stProc
                   symbols also ends with stEnd, thus creating a risk of
                   taking the wrong stEnd symbol record as the end of
                   the current struct, which would cause GDB to undercount
                   the real number of fields in this struct.  To make sure
                   we really reached the right stEnd symbol record, we
                   check the associated name, and match it against the
                   struct name.  Since method names are mangled while
                   the class name is not, there is no risk of having a
                   method whose name is identical to the class name
                   (in particular constructor method names are different
                   from the class name).  There is therefore no risk that
                   this check stops the count on the StEnd of a method.  */
                if (strcmp (debug_info->ss + cur_fdr->issBase + tsym.iss,
                            name) == 0)
                  goto end_of_fields;
                break;
d1465 3
a1467 5
#if 0 /* OBSOLETE CFront */
// OBSOLETE      /* Inhibit core dumps with some cfront generated objects that
// OBSOLETE         corrupt the TIR.  */
#endif /* OBSOLETE CFront */
      /* Inhibit core dumps if TIR is corrupted.  */
d2896 1
a2896 1
			  memcpy (psymtab_include_list, orig,
d2984 14
a2997 16
#if 0 /* OBSOLETE CFront */
// OBSOLETE  			    /* The semantics of C++ state that "struct foo { ... }"
// OBSOLETE  			       also defines a typedef for "foo".  Unfortuantely, cfront
// OBSOLETE  			       never makes the typedef when translating from C++ to C.
// OBSOLETE  			       We make the typedef here so that "ptype foo" works as
// OBSOLETE  			       expected for cfront translated code.  */
// OBSOLETE  			    else if (psymtab_language == language_cplus)
// OBSOLETE  			      {
// OBSOLETE  				/* Also a typedef with the same name.  */
// OBSOLETE  				add_psymbol_to_list (namestring, p - namestring,
// OBSOLETE  						     VAR_NAMESPACE, LOC_TYPEDEF,
// OBSOLETE  						     &objfile->static_psymbols,
// OBSOLETE  						     sh.value, 0,
// OBSOLETE  						     psymtab_language, objfile);
// OBSOLETE  			      }
#endif /* OBSOLETE CFront */
d3144 3
a3146 5
#if 0 /* OBSOLETE CFront */
// OBSOLETE 			/* added to support cfront stabs strings */
// OBSOLETE 		      case 'Z':		/* for definition continuations */
// OBSOLETE 		      case 'P':		/* for prototypes */
#endif /* OBSOLETE CFront */
a3307 33
		  /* Ignore all parameter symbol records.  */
		  if (sh.index >= hdr->iauxMax)
		    {
		      /* Should not happen, but does when cross-compiling
		         with the MIPS compiler.  FIXME -- pull later.  */
		      index_complaint (name);
		      new_sdx = cur_sdx + 1;	/* Don't skip at all */
		    }
		  else
		    new_sdx = AUX_GET_ISYM (fh->fBigendian,
					    (debug_info->external_aux
					     + fh->iauxBase
					     + sh.index));

		  if (new_sdx <= cur_sdx)
		    {
		      /* This should not happen either... FIXME.  */
		      complaint (&symfile_complaints,
				 "bad proc end in aux found from symbol %s",
				 name);
		      new_sdx = cur_sdx + 1;	/* Don't skip backward */
		    }

                  /* For stProc symbol records, we need to check the
                     storage class as well, as only (stProc, scText)
                     entries represent "real" procedures - See the
                     Compaq document titled "Object File / Symbol Table
                     Format Specification" for more information.  If the
                     storage class is not scText, we discard the whole
                     block of symbol records for this stProc.  */
                  if (sh.st == stProc && sh.sc != scText)
                    goto skip;

d3330 13
d3345 9
d4643 2
d4646 1
a4646 1
  SYMBOL_SET_NAMES (s, name, strlen (name), current_objfile);
@


1.29.2.10
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mdebugread.c (new_block): Add 'function' arg.
	(parse_symbol): New arg to new_block.
	(new_symtab): Ditto.
	(fixup_sigtramp): Ditto.
	* cp-support.c (initialize_namespace_blocks): Use
	dict_hashed_expandable instead of dict_linear_expandable.
	* jv-lang.c (get_java_class_symtab): Ditto.
	* dictionary.c (enum dict_type): Add DICT_HASHED_EXPANDABLE.
	(struct dictionary_hashed_expandable): New.
	(struct dictionary): Add hashed_expandable member.
	(DICT_EXPANDABLE_INITIAL_CAPACITY): Rename from
	DICT_LINEAR_EXPANDABLE_INITIAL_CAPACITY.
	(dict_create_linear_expandable): Use
	DICT_EXPANDABLE_INITIAL_CAPACITY.
	(dict_linear_vtbl): New.
	(dict_create_hashed_expandable): New.
	(add_symbol_hashed_expandable): New.
	(dict_create_hashed): Move code into insert_symbol_hashed.
	(insert_symbol_hashed): New.
	(expand_hashtable): New.
	* dictionary.h: Declare dict_create_hashed_expandable.
@
text
@d288 1
a288 1
static struct block *new_block (int function);
d835 1
a835 1
      b = new_block (1);
d1166 1
a1166 1
      b = new_block (0);
d4605 2
a4606 2
  global_block = new_block (0);
  static_block = new_block (0);
d4693 1
a4693 4
/* Allocate and zero a new block, and set its BLOCK_DICT.  If function
   is non-zero, assume the block is associated to a function, and make
   sure that the symbols are stored linearly; otherwise, store them
   hashed.  */
d4696 1
a4696 1
new_block (int function)
d4699 1
a4699 5

  if (function)
    BLOCK_DICT (retval) = dict_create_linear_expandable ();
  else
    BLOCK_DICT (retval) = dict_create_hashed_expandable ();
d4827 1
a4827 1
  b = new_block (0);
@


1.29.2.11
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d46 1
a56 1
#include "block.h"
d671 1
a671 1
	  int bucket = hashname (DEPRECATED_SYMBOL_NAME (s));
d1103 1
a1103 1
		DEPRECATED_SYMBOL_NAME (enum_sym) =
d1374 1
a1374 1
	    TYPE_NAME (SYMBOL_TYPE (s)) = DEPRECATED_SYMBOL_NAME (s);
d4447 1
a4447 1
      if (DEPRECATED_SYMBOL_NAME (sym)[0] == inc
d4450 1
a4450 1
	  && strcmp (DEPRECATED_SYMBOL_NAME (sym), name) == 0)
a4749 8
  struct cleanup *back_to;

  /* FIXME: It's not clear whether we should be getting minimal symbol
     information from .mdebug in an ELF file, or whether we will.
     Re-initialize the minimal symbol reader in case we do.  */

  init_minimal_symbol_collection ();
  back_to = make_cleanup_discard_minimal_symbols ();
a4759 3

  install_minimal_symbols (objfile);
  do_cleanups (back_to);
@


1.29.2.12
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d917 3
a919 7
                   this check stops the count on the StEnd of a method.
		   
		   Also, assume that we're really at the end when tsym.iss
		   is 0 (issNull).  */
                if (tsym.iss == issNull
		    || strcmp (debug_info->ss + cur_fdr->issBase + tsym.iss,
                               name) == 0)
@


1.29.2.13
log
@2003-04-18  David Carlton  <carlton@@bactrian.org>

	* mdebugread.c (parse_symbol): Move up declaration of 'iter'.
	* dwarf2read.c (add_partial_namespace): Move up declaration of
	'full_name'.
	* cp-support.c (cp_find_first_component): Accept 'operator' in
	more locations.

2003-04-18  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/maint.exp (test_first_component): Add tests for
	'operator' in more locations.
@
text
@a1233 1
		  struct dict_iterator iter;
d1237 1
@


1.29.2.14
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d299 1
a299 1
static struct symbol *mylookup_symbol (char *, struct block *, domain_enum,
d692 1
a692 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d715 1
a715 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d744 1
a744 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;	/* so that it can be used */
d786 1
a786 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d1112 1
a1112 1
		SYMBOL_DOMAIN (enum_sym) = VAR_DOMAIN;
d1142 1
a1142 1
	SYMBOL_DOMAIN (s) = STRUCT_DOMAIN;
d1198 1
a1198 1
	  SYMBOL_DOMAIN (s) = LABEL_DOMAIN;
d1343 1
a1343 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d1926 1
a1926 1
      s = lookup_symbol (sh_name, NULL, VAR_DOMAIN, 0, NULL);
d1932 1
a1932 1
	 VAR_DOMAIN,
d1938 1
a1938 1
			 VAR_DOMAIN, LOC_BLOCK);
d1952 1
a1952 1
      SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d1970 1
a1970 1
  i = mylookup_symbol (MIPS_EFI_SYMBOL_NAME, b, LABEL_DOMAIN, LOC_CONST);
d3002 1
a3002 1
					     VAR_DOMAIN, LOC_STATIC,
d3012 1
a3012 1
					     VAR_DOMAIN, LOC_STATIC,
d3030 1
a3030 1
						 STRUCT_DOMAIN, LOC_TYPEDEF,
d3038 1
a3038 1
						     VAR_DOMAIN, LOC_TYPEDEF,
d3054 1
a3054 1
// OBSOLETE  						     VAR_DOMAIN, LOC_TYPEDEF,
d3066 1
a3066 1
						 VAR_DOMAIN, LOC_TYPEDEF,
d3128 1
a3128 1
						     VAR_DOMAIN, LOC_CONST,
d3145 1
a3145 1
					     VAR_DOMAIN, LOC_CONST,
d3162 1
a3162 1
					     VAR_DOMAIN, LOC_BLOCK,
d3183 1
a3183 1
					     VAR_DOMAIN, LOC_BLOCK,
d3418 1
a3418 1
					 VAR_DOMAIN, LOC_BLOCK,
d3423 1
a3423 1
					 VAR_DOMAIN, LOC_BLOCK,
d3492 1
a3492 1
					   STRUCT_DOMAIN, LOC_TYPEDEF,
d3533 1
a3533 1
				   VAR_DOMAIN, class,
d3609 1
a3609 1
				   VAR_DOMAIN, class,
d3779 1
a3779 1
			   VAR_DOMAIN, LOC_CONST,
d3972 1
a3972 1
		  SYMBOL_DOMAIN (s) = LABEL_DOMAIN;
d4442 1
a4442 1
		 domain_enum domain, enum address_class class)
d4452 1
a4452 1
	  && SYMBOL_DOMAIN (sym) == domain
d4460 1
a4460 1
    return mylookup_symbol (name, block, domain, class);
d4842 1
a4842 1
  SYMBOL_DOMAIN (s) = VAR_DOMAIN;
d4884 1
a4884 1
    SYMBOL_DOMAIN (s) = LABEL_DOMAIN;
@


1.29.2.15
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d288 1
a288 3
enum block_type { FUNCTION_BLOCK, NON_FUNCTION_BLOCK };

static struct block *new_block (enum block_type);
d835 1
a835 1
      b = new_block (FUNCTION_BLOCK);
d1170 1
a1170 1
      b = new_block (NON_FUNCTION_BLOCK);
d1239 4
a1242 2
		  iparams = 0;
		  ALL_BLOCK_SYMBOLS (b, iter, sym)
d1244 1
a1244 3
		      if (iparams == nparams)
			break;

d4062 2
d4470 3
d4595 2
a4596 2
/* Allocate a new symtab for NAME.  Needs an estimate of how many
   linenumbers MAXLINES we'll put in it */
d4609 5
a4613 6
  BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK)
    = new_block (NON_FUNCTION_BLOCK);
  BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK)
    = new_block (NON_FUNCTION_BLOCK);
  BLOCK_SUPERBLOCK (BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK)) =
    BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
d4703 1
a4703 1
new_block (enum block_type type)
d4707 1
a4707 1
  if (type == FUNCTION_BLOCK)
d4849 1
a4849 1
  b = new_block (NON_FUNCTION_BLOCK);
d4891 2
@


1.29.2.16
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d376 1
a376 1
  FDR *f;
d511 1
a511 1
      struct parse_stack *prev = new->prev;
d561 1
a561 1
  struct mdebug_pending *p;
d2231 1
a2231 1
  EXTR *ext_in;
d2939 1
a2939 1
			int i;
d3630 2
a3631 2
	  objfile->ei.deprecated_entry_file_lowpc = save_pst->textlow;
	  objfile->ei.deprecated_entry_file_highpc = save_pst->texthigh;
d4441 1
a4441 1
mylookup_symbol (char *name, struct block *block,
d4530 1
a4530 1
  int addr_diff;
d4571 2
a4572 2
    CORE_ADDR high = 0;
    int i, j = BLOCKVECTOR_NBLOCKS (bv);
a4702 3
  /* FIXME: carlton/2003-09-11: This should use allocate_block to
     allocate the block.  Which, in turn, suggests that the block
     should be allocated on an obstack.  */
@


1.29.2.17
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1525 4
d1639 1
a1639 1
		   || strcmp (TYPE_TAG_NAME (tp), name) != 0)
d3046 16
d3208 5
@


1.29.2.18
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d796 1
a796 1
	  if (DEPRECATED_STREQ (name, "malloc") && TYPE_CODE (t) == TYPE_CODE_VOID)
d1670 1
a1670 1
	  if (TYPE_NAME (tp) == NULL || !DEPRECATED_STREQ (TYPE_NAME (tp), name))
d1990 1
a1990 1
      if (e->pdr.pcreg == 0 && DEPRECATED_STREQ (sh_name, "setjmp"))
d2611 1
a2611 1
	  if (DEPRECATED_STREQ (debug_info->ss + fh->issBase + sh.iss, stabs_symbol))
d2932 1
a2932 1
		      if (pst && DEPRECATED_STREQ (namestring, pst->filename))
d2937 1
a2937 1
			  if (DEPRECATED_STREQ (namestring, psymtab_include_list[i]))
d3864 1
a3864 1
      if (DEPRECATED_STREQ (debug_info->ss + fh->issBase + sh.iss,
@


1.29.2.19
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2 3
a4 5

   Copyright 1986, 1987, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.

d796 1
a796 2
	  if (strcmp (name, "malloc") == 0
	      && TYPE_CODE (t) == TYPE_CODE_VOID)
d1670 1
a1670 2
	  if (TYPE_NAME (tp) == NULL
	      || strcmp (TYPE_NAME (tp), name) != 0)
d1990 1
a1990 2
      if (e->pdr.pcreg == 0
	  && strcmp (sh_name, "setjmp") == 0)
d2611 1
a2611 2
	  if (strcmp (debug_info->ss + fh->issBase + sh.iss,
		      stabs_symbol) == 0)
d2932 1
a2932 1
		      if (pst && strcmp (namestring, pst->filename) == 0)
d2937 1
a2937 2
			  if (strcmp (namestring,
				      psymtab_include_list[i]) == 0)
d3864 2
a3865 2
      if (strcmp (debug_info->ss + fh->issBase + sh.iss,
		  stabs_symbol) == 0)
d4505 1
a4505 1
  LONGEST addr_diff;
@


1.28
log
@2002-07-29  Andrew Cagney  <ac131313@@redhat.com>

* gdb_obstack.h: New file.
* symtab.h: Include "gdb_obstack.h" instead of "obstack.h".
(obstack_chunk_alloc, obstack_chunk_free): Delete macros.
* objfiles.h: Include "gdb_obstack.h".
* Makefile.in (gdb_obstack_h): Define.
(symtab_h): Add $(gdb_obstack_h).
(objfiles_h): Add $(gdb_obstack_h).

* objfiles.c: Include "gdb_obstack.h" instead of "obstack.h".
* macrotab.c, cp-valprint.c, dbxread.c: Ditto.
* ch-typeprint.c, ch-valprint.c, dstread.c: Ditto.
* macroexp.c, p-typeprint.c, stabsread.c: Ditto.
* symtab.c, f-typeprint.c, mdebugread.c: Ditto.
* p-valprint.c, symmisc.c, typeprint.c: Ditto.
* symfile.c, coffread.c, c-typeprint.c: Ditto.
* buildsym.c, bcache.c, ada-typeprint.c: Ditto.

* Makefile.in (bcache.o): Update dependencies.
(buildsym.o, c-typeprint.o, ch-typeprint.o): Ditto.
(ch-valprint.o, coffread.o, cp-valprint.o): Ditto.
(dbxread.o, dstread.o, f-typeprint.o): Ditto.
(objfiles.o, p-typeprint.o, p-valprint.o): Ditto.
(stabsread.o, symfile.o, symmisc.o): Ditto.
(symtab.o, typeprint.o, macroexp.o): Ditto.
(macrotab.o, mdebugread.o): Ditto.
(f_lang_h, coff_sym_h, coff_symconst_h): Define.
(coff_ecoff_h, aout_aout64_h): Define.
(aout_stabs_gnu_h, libaout_h): Define.
@
text
@a108 5
    /* Our running best guess as to the range of text addresses for
       this psymtab.  After we've read everything in, we use this to
       build pst->text_addrs.  */
    CORE_ADDR textlow, texthigh;

a123 2
#define TEXTLOW(p) (PST_PRIVATE(p)->textlow)
#define TEXTHIGH(p) (PST_PRIVATE(p)->texthigh)
a492 13
  /* Take the text ranges the partial symbol scanner computed for each
     of the psymtabs and convert it into the canonical form for
     psymtabs.  */
  {
    struct partial_symtab *p;

    ALL_OBJFILE_PSYMTABS (objfile, p)
      {
        p->textlow = TEXTLOW (p);
        p->texthigh = TEXTHIGH (p);
      }
  }

d2152 1
a2152 1
      adr = TEXTLOW (pst) + pr->adr - lowest_pdr_addr;
a2532 2
      TEXTLOW (pst) = pst->textlow;
      TEXTHIGH (pst) = pst->texthigh;
d2568 1
a2568 1
      TEXTHIGH (pst) = TEXTLOW (pst);
d2635 4
a2638 4
			  && (TEXTLOW (pst) == 0 || procaddr < TEXTLOW (pst)))
			    TEXTLOW (pst) = procaddr;
			  if (high > TEXTHIGH (pst))
			    TEXTHIGH (pst) = high;
d3212 5
a3216 4
		    /* Solaris 2 end of module, finish current partial symbol table.
		       END_PSYMTAB will set TEXTHIGH (pst) to the proper value, which
		       is necessary if a module compiled without debugging info
		       follows this module.  */
d3227 2
a3228 2
		    if (sh.value > TEXTHIGH (save_pst))
		      TEXTHIGH (save_pst) = sh.value;
d3395 2
a3396 2
		      && (TEXTLOW (pst) == 0 || procaddr < TEXTLOW (pst)))
		    TEXTLOW (pst) = procaddr;
d3399 2
a3400 2
		  if (high > TEXTHIGH (pst))
		    TEXTHIGH (pst) = high;
d3574 1
a3574 1
					   -1, TEXTHIGH (save_pst),
d3579 2
a3580 2
      if (objfile->ei.entry_point >= TEXTLOW (save_pst) &&
	  objfile->ei.entry_point < TEXTHIGH (save_pst))
d3582 2
a3583 2
	  objfile->ei.entry_file_lowpc = TEXTLOW (save_pst);
	  objfile->ei.entry_file_highpc = TEXTHIGH (save_pst);
d3599 1
a3599 1
	  && TEXTLOW (save_pst) != 0
d3605 3
a3607 3
		&& TEXTLOW (save_pst) >= TEXTLOW (pst)
		&& TEXTLOW (save_pst) < TEXTHIGH (pst)
		&& TEXTHIGH (save_pst) > TEXTHIGH (pst))
d3811 1
a3811 1
      && TEXTLOW (pst) == 0 && TEXTHIGH (pst) == 0)
d3959 1
a3959 1
	  st = end_symtab (TEXTHIGH (pst), pst->objfile, SECT_OFF_TEXT (pst->objfile));
d4049 1
a4049 1
      BLOCK_START (top_stack->cur_block) = TEXTLOW (pst);
@


1.28.6.1
log
@* dbxread.c, mdebugread.c: Revert my change of 2001-10-23.  Moving
texthigh and textlow to reader-specific structs caused
objfile_relocate to miss them.  This is fixable, but the work that
the change was supposed to prepare GDB for never got done anyway.
@
text
@d109 5
d129 2
d500 13
d2172 1
a2172 1
      adr = pst->textlow + pr->adr - lowest_pdr_addr;
d2553 2
d2590 1
a2590 1
      pst->texthigh = pst->textlow;
d2657 4
a2660 4
			  && (pst->textlow == 0 || procaddr < pst->textlow))
			    pst->textlow = procaddr;
			  if (high > pst->texthigh)
			    pst->texthigh = high;
d3234 4
a3237 5
		    /* Solaris 2 end of module, finish current partial
		       symbol table.  END_PSYMTAB will set
		       pst->texthigh to the proper value, which is
		       necessary if a module compiled without
		       debugging info follows this module.  */
d3248 2
a3249 2
		    if (sh.value > save_pst->texthigh)
		      save_pst->texthigh = sh.value;
d3416 2
a3417 2
		      && (pst->textlow == 0 || procaddr < pst->textlow))
		    pst->textlow = procaddr;
d3420 2
a3421 2
		  if (high > pst->texthigh)
		    pst->texthigh = high;
d3595 1
a3595 1
					   -1, save_pst->texthigh,
d3600 2
a3601 2
      if (objfile->ei.entry_point >= save_pst->textlow &&
	  objfile->ei.entry_point < save_pst->texthigh)
d3603 2
a3604 2
	  objfile->ei.entry_file_lowpc = save_pst->textlow;
	  objfile->ei.entry_file_highpc = save_pst->texthigh;
d3620 1
a3620 1
	  && save_pst->textlow != 0
d3626 3
a3628 3
		&& save_pst->textlow >= pst->textlow
		&& save_pst->textlow < pst->texthigh
		&& save_pst->texthigh > pst->texthigh)
d3832 1
a3832 1
      && pst->textlow == 0 && pst->texthigh == 0)
d3980 1
a3980 1
	  st = end_symtab (pst->texthigh, pst->objfile, SECT_OFF_TEXT (pst->objfile));
d4070 1
a4070 1
      BLOCK_START (top_stack->cur_block) = pst->textlow;
@


1.27
log
@2002-07-11  Daniel Jacobowitz  <drow@@mvista.com>

	Based on patch from Daniel Berlin <dberlin@@dberlin.org>.
	* buildsym.c: Include "demangle.h" for SYMBOL_INIT_DEMANGLED_NAME.
	(finish_block) For non-function blocks, hash the symbol table.  For
	function blocks, mark the symbol table as unhashed.
	* minsyms.c (msymbol_hash): Return hash value without taking modulus.
	(msymbol_hash_iw): Likewise.
	(add_minsym_to_hash_table): Take modulus of msymbol_hash's return
	value.
	(add_minsym_to_demangled_hash_table): Likewise for msymbol_hash_iw.
	(lookup_minimal_symbol): Likewise for both.
	* symtab.h (struct block): Add `hashtable' flag.  Comment the
	hashtable.
	(BLOCK_HASHTABLE, BLOCK_BUCKETS, BLOCK_BUCKET): New macro.
	(ALL_BLOCK_SYMBOLS): Update.
	(BLOCK_SHOULD_SORT): Do not sort hashed blocks.
	(struct symbol): Add `hash_next' pointer.
	* symtab.c (lookup_block_symbol): Search using the hash table when
	possible.
	(find_pc_sect_symtab): Use ALL_BLOCK_SYMBOLS.
	(search_symbols, find_addr_symbol): Likewise.

	* dstread.c (process_dst_block): Clear hashtable bit for new block.
	(read_dst_symtab): Likewise.
	* jv-lang.c (get_java_class_symtab): Likewise.
	* mdebugread.c: Include "gdb_assert.h".
	(shrink_block): Assert that the block being modified is not hashed.
	* coffread.c (patch_opaque_types): Use ALL_BLOCK_SYMBOLS.
	* symmisc.c (free_symtab_block): Walk the hash table when freeing
	symbols.
	(dump_symtab): Recognize hashed blocks.
	* printcmd.c (print_frame_args):  Assert that function blocks do not
	have hashed symbol tables.
	* ada-lang.c (symtab_for_sym): Use ALL_BLOCK_SYMBOLS.
	(fill_in_ada_prototype, debug_print_block): Likewise.
	(ada_add_block_symbols): Use ALL_BLOCK_SYMBOLS.  Handle hash tables.
@
text
@d50 1
a50 1
#include "obstack.h"
@


1.26
log
@2002-05-13  Daniel Jacobowitz  <drow@@mvista.com>

        * ax-gdb.c (gen_sign_extend, gen_fetch, gen_usual_unary)
        (gen_cast, gen_scale, gen_add, gen_sub, gen_binop, gen_deref)
        (gen_address_of, gen_struct_ref, gen_repeat): Use type
        access macros.
        * c-typeprint.c (cp_type_print_method_args): Likewise.
        (c_type_print_args): Likewise.
        * d10v-tdep.c (d10v_push_arguments): Likewise.
        (d10v_extract_return_value): Likewise.
        * expprint.c (print_subexp): Likewise.
        * gdbtypes.c (lookup_primitive_typename): Likewise.
        (lookup_template_type, add_mangled_type, print_arg_types): Likewise.
        * gdbtypes.h (TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB)
        (TYPE_TARGET_STUB, TYPE_STATIC, TYPE_CONST, TYPE_VOLATILE)
        (TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_CODE_SPACE, TYPE_VARARGS)
        (TYPE_VECTOR): Likewise.
        * hpread.c (hpread_read_struct_type)
        (fix_static_member_physnames, fixup_class_method_type)
        (hpread_type_lookup): Likewise.
        * mdebugread.c (parse_symbol, parse_type): Likewise.
        * p-lang.c (is_pascal_string_type): Likewise.
        * valops.c (hand_function_call): Likewise.
        * x86-64-tdep.c (classify_argument): Likewise.

        * hpread.c (hpread_read_function_type)
        (hpread_read_doc_function_type): Call replace_type.
        * dstread.c (create_new_type): Delete.
        (decode_dst_structure, process_dst_function): Call alloc_type.
        Use type access macros.
@
text
@d55 1
d4730 5
@


1.26.4.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a54 1
#include "gdb_assert.h"
a4728 5

  /* FIXME: Not worth hashing this block as it's built.  */
  /* All callers should have created the block with new_block (), which
     would mean it was not previously hashed.  Make sure.  */
  gdb_assert (BLOCK_HASHTABLE (new) == 0);
@


1.26.4.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d50 1
a50 1
#include "gdb_obstack.h"
@


1.26.4.3
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d109 5
d129 2
d500 13
d2172 1
a2172 1
      adr = pst->textlow + pr->adr - lowest_pdr_addr;
d2553 2
d2590 1
a2590 1
      pst->texthigh = pst->textlow;
d2657 4
a2660 4
			  && (pst->textlow == 0 || procaddr < pst->textlow))
			    pst->textlow = procaddr;
			  if (high > pst->texthigh)
			    pst->texthigh = high;
d3234 4
a3237 5
		    /* Solaris 2 end of module, finish current partial
		       symbol table.  END_PSYMTAB will set
		       pst->texthigh to the proper value, which is
		       necessary if a module compiled without
		       debugging info follows this module.  */
d3248 2
a3249 2
		    if (sh.value > save_pst->texthigh)
		      save_pst->texthigh = sh.value;
d3416 2
a3417 2
		      && (pst->textlow == 0 || procaddr < pst->textlow))
		    pst->textlow = procaddr;
d3420 2
a3421 2
		  if (high > pst->texthigh)
		    pst->texthigh = high;
d3595 1
a3595 1
					   -1, save_pst->texthigh,
d3600 2
a3601 2
      if (objfile->ei.entry_point >= save_pst->textlow &&
	  objfile->ei.entry_point < save_pst->texthigh)
d3603 2
a3604 2
	  objfile->ei.entry_file_lowpc = save_pst->textlow;
	  objfile->ei.entry_file_highpc = save_pst->texthigh;
d3620 1
a3620 1
	  && save_pst->textlow != 0
d3626 3
a3628 3
		&& save_pst->textlow >= pst->textlow
		&& save_pst->textlow < pst->texthigh
		&& save_pst->texthigh > pst->texthigh)
d3832 1
a3832 1
      && pst->textlow == 0 && pst->texthigh == 0)
d3980 1
a3980 1
	  st = end_symtab (pst->texthigh, pst->objfile, SECT_OFF_TEXT (pst->objfile));
d4070 1
a4070 1
      BLOCK_START (top_stack->cur_block) = pst->textlow;
@


1.26.4.4
log
@merge from mainline
@
text
@d146 1
a146 1
static struct deprecated_complaint bad_file_number_complaint =
d149 1
a149 1
static struct deprecated_complaint index_complaint =
d152 1
a152 1
static struct deprecated_complaint aux_index_complaint =
d155 1
a155 1
static struct deprecated_complaint block_index_complaint =
d158 1
a158 1
static struct deprecated_complaint unknown_ext_complaint =
d161 1
a161 1
static struct deprecated_complaint unknown_sym_complaint =
d164 1
a164 1
static struct deprecated_complaint unknown_st_complaint =
d167 1
a167 1
static struct deprecated_complaint block_overflow_complaint =
d170 1
a170 1
static struct deprecated_complaint basic_type_complaint =
d173 1
a173 1
static struct deprecated_complaint unknown_type_qual_complaint =
d176 1
a176 1
static struct deprecated_complaint array_index_type_complaint =
d179 1
a179 1
static struct deprecated_complaint bad_tag_guess_complaint =
d182 1
a182 1
static struct deprecated_complaint block_member_complaint =
d185 1
a185 1
static struct deprecated_complaint stEnd_complaint =
d188 1
a188 1
static struct deprecated_complaint unknown_mdebug_symtype_complaint =
d191 1
a191 1
static struct deprecated_complaint stab_unknown_complaint =
d194 1
a194 1
static struct deprecated_complaint pdr_for_nonsymbol_complaint =
d197 1
a197 1
static struct deprecated_complaint pdr_static_symbol_complaint =
d200 1
a200 1
static struct deprecated_complaint bad_setjmp_pdr_complaint =
d203 1
a203 1
static struct deprecated_complaint bad_fbitfield_complaint =
d206 1
a206 1
static struct deprecated_complaint bad_continued_complaint =
d209 1
a209 1
static struct deprecated_complaint bad_rfd_entry_complaint =
d212 1
a212 1
static struct deprecated_complaint unexpected_type_code_complaint =
d215 1
a215 1
static struct deprecated_complaint unable_to_cross_ref_complaint =
d218 1
a218 1
static struct deprecated_complaint bad_indirect_xref_complaint =
d221 1
a221 1
static struct deprecated_complaint illegal_forward_tq0_complaint =
d224 1
a224 1
static struct deprecated_complaint illegal_forward_bt_complaint =
d227 1
a227 1
static struct deprecated_complaint bad_linetable_guess_complaint =
d230 1
a230 1
static struct deprecated_complaint bad_ext_ifd_complaint =
d233 1
a233 1
static struct deprecated_complaint bad_ext_iss_complaint =
d2723 1
a2723 1
		    static struct deprecated_complaint function_outside_compilation_unit = {
@


1.25
log
@        * symfile.h (get_section_index): Define.
        * symfile.c (get_section_index): New function.
        * mdebugread.c (SC_IS_SBSS): New macro.
        (SC_IS_BSS): Return true for the scBss storage class only, as
        the scSBss storage class refers to the .sbss section.
        (parse_partial_symbols): Discard the symbols which associated
        section does not exist.
        Make sure to use the .sbss section index for symbols which
        storage class is scBss, rather than using the .bss section index.
@
text
@d835 1
a835 1
	  if (STREQ (name, "malloc") && t->code == TYPE_CODE_VOID)
d1607 1
a1607 1
	tp = tp->target_type;
@


1.24
log
@* coffread.c: Remove redundant static declarations.  Replace
occurrences of `PTR' with `void *'.
* elfread.c, mdebugread.c, minsyms.c, mipsread.c: Likewise.
* top.h (quit_cover): Likewise.
* defs.h (catch_errors): Likewise.
@
text
@d146 2
a147 1
#define SC_IS_BSS(sc) ((sc) == scBss || (sc) == scSBss)
d2429 6
d2440 21
d2463 3
d2471 3
d2479 3
d2485 10
@


1.23
log
@Approved by msynder@@redhat.com

	2002-01-23  Fred Fish  <fnf@@redhat.com>
	* mdebugread.c (parse_partial_symbols): Only copy stabstring1 to
	stabstring on initial malloc.  Reallocing will copy it for us,
	if necessary.
@
text
@d330 2
a331 14
static void add_pending (FDR *, char *, struct type *);

static struct mdebug_pending *is_pending_symbol (FDR *, char *);

static void pop_parse_stack (void);

static void push_parse_stack (void);

static char *fdr_name (FDR *);

static void mdebug_psymtab_to_symtab (struct partial_symtab *);

static int
upgrade_type (int, struct type **, int, union aux_ext *, int, char *);
a334 2
static FDR * get_rfd (int, int);

d337 2
a338 3
static int
cross_ref (int, union aux_ext *, struct type **, enum type_code,
	   char **, int, char *);
a351 4
static int
parse_symbol (SYMR *, union aux_ext *, char *, int, struct section_offsets *,
	      struct objfile *);

a359 2
static PTR xzalloc (unsigned int);

a361 2
static int compare_blocks (const PTR, const PTR);

d374 2
a375 2
static void
handle_psymbol_enumerators (struct objfile *, FDR *, int, CORE_ADDR);
d385 1
a385 1
static PTR
d388 1
a388 1
  PTR p = xmalloc (size);
d678 1
a678 1
  void (*const swap_sym_in) (bfd *, PTR, SYMR *) = debug_swap->swap_sym_in;
d1117 1
a1117 1
		memset ((PTR) enum_sym, 0, sizeof (struct symbol));
d1215 1
a1215 1
	  memset ((PTR) e, 0, sizeof (struct mips_extra_func_info));
d2210 3
a2212 3
  void (*const swap_ext_in) (bfd *, PTR, EXTR *) = debug_swap->swap_ext_in;
  void (*const swap_sym_in) (bfd *, PTR, SYMR *) = debug_swap->swap_sym_in;
  void (*const swap_rfd_in) (bfd *, PTR, RFDT *) = debug_swap->swap_rfd_in;
d2299 1
a2299 1
  memset ((PTR) pending_list, 0,
d2502 1
a2502 1
      memset ((PTR) pst->read_symtab_private, 0, sizeof (struct symloc));
d3653 1
a3653 1
  void (*const swap_sym_in) (bfd *, PTR, SYMR *) = debug_swap->swap_sym_in;
d3744 2
a3745 2
  void (*swap_sym_in) (bfd *, PTR, SYMR *);
  void (*swap_pdr_in) (bfd *, PTR, PDR *);
d3898 1
a3898 1
		  memset ((PTR) e, 0, sizeof (struct mips_extra_func_info));
d4447 1
a4447 1
  bv = (struct blockvector *) xrealloc ((PTR) bv,
d4495 1
a4495 1
compare_blocks (const PTR arg1, const PTR arg2)
d4597 1
a4597 1
  memset ((PTR) psymtab->read_symtab_private, 0, sizeof (struct symloc));
d4634 1
a4634 1
  return (struct linetable *) xrealloc ((PTR) lt,
d4678 1
a4678 1
  new = (struct block *) xrealloc ((PTR) b,
d4704 1
a4704 1
  memset ((PTR) s, 0, sizeof (*s));
@


1.23.2.1
log
@* coffread.c: Remove redundant static declarations.  Replace
occurrences of `PTR' with `void *'.
* elfread.c, mdebugread.c, minsyms.c, mipsread.c: Likewise.
* top.h (quit_cover): Likewise.
* defs.h (catch_errors): Likewise.
@
text
@d330 14
a343 2
static int upgrade_type (int, struct type **, int, union aux_ext *,
			 int, char *);
d347 2
d351 3
a353 2
static int cross_ref (int, union aux_ext *, struct type **, enum type_code,
		      char **, int, char *);
d367 4
d379 2
d383 2
d397 2
a398 2
static void handle_psymbol_enumerators (struct objfile *, FDR *, int,
					CORE_ADDR);
d408 1
a408 1
static void *
d411 1
a411 1
  void *p = xmalloc (size);
d701 1
a701 1
  void (*const swap_sym_in) (bfd *, void *, SYMR *) = debug_swap->swap_sym_in;
d1140 1
a1140 1
		memset (enum_sym, 0, sizeof (struct symbol));
d1238 1
a1238 1
	  memset (e, 0, sizeof (struct mips_extra_func_info));
d2233 3
a2235 3
  void (*const swap_ext_in) (bfd *, void *, EXTR *) = debug_swap->swap_ext_in;
  void (*const swap_sym_in) (bfd *, void *, SYMR *) = debug_swap->swap_sym_in;
  void (*const swap_rfd_in) (bfd *, void *, RFDT *) = debug_swap->swap_rfd_in;
d2322 1
a2322 1
  memset (pending_list, 0,
d2525 1
a2525 1
      memset (pst->read_symtab_private, 0, sizeof (struct symloc));
d3676 1
a3676 1
  void (*const swap_sym_in) (bfd *, void *, SYMR *) = debug_swap->swap_sym_in;
d3767 2
a3768 2
  void (*swap_sym_in) (bfd *, void *, SYMR *);
  void (*swap_pdr_in) (bfd *, void *, PDR *);
d3921 1
a3921 1
		  memset (e, 0, sizeof (struct mips_extra_func_info));
d4470 1
a4470 1
  bv = (struct blockvector *) xrealloc ((void *) bv,
d4518 1
a4518 1
compare_blocks (const void *arg1, const void *arg2)
d4620 1
a4620 1
  memset (psymtab->read_symtab_private, 0, sizeof (struct symloc));
d4657 1
a4657 1
  return (struct linetable *) xrealloc ((void *) lt,
d4701 1
a4701 1
  new = (struct block *) xrealloc ((void *) b,
d4727 1
a4727 1
  memset (s, 0, sizeof (*s));
@


1.23.2.2
log
@* NEWS: Mention below.

Merge from mainline:
2002-04-22 J. Brobecker <brobecker@@gnat.com>:
* symfile.h (get_section_index): Define.
* symfile.c (get_section_index): New function.
* mdebugread.c (SC_IS_SBSS): New macro.
(SC_IS_BSS): Return true for the scBss storage class only, as
the scSBss storage class refers to the .sbss section.
(parse_partial_symbols): Discard the symbols which associated
section does not exist.
Make sure to use the .sbss section index for symbols which
storage class is scBss, rather than using the .bss section index.
@
text
@d146 1
a146 2
#define SC_IS_BSS(sc) ((sc) == scBss)
#define SC_IS_SBSS(sc) ((sc) == scSBss)
a2427 6
          else if (SC_IS_SBSS (ext_in->asym.sc))
            {
              ms_type = mst_bss;
              svalue += ANOFFSET (objfile->section_offsets, 
                                  get_section_index (objfile, ".sbss"));
            }
a2432 21

          /* On certain platforms, some extra label symbols can be
             generated by the linker. One possible usage for this kind
             of symbols is to represent the address of the begining of a
             given section. For instance, on Tru64 5.1, the address of
             the _ftext label is the start address of the .text section.

             The storage class of these symbols is usually directly
             related to the section to which the symbol refers. For
             instance, on Tru64 5.1, the storage class for the _fdata
             label is scData, refering to the .data section.

             It is actually possible that the section associated to the
             storage class of the label does not exist. On True64 5.1
             for instance, the libm.so shared library does not contain
             any .data section, although it contains a _fpdata label
             which storage class is scData... Since these symbols are
             usually useless for the debugger user anyway, we just
             discard these symbols.
           */
          
a2434 3
              if (objfile->sect_index_text == -1)
                continue;
                
a2439 3
              if (objfile->sect_index_data == -1)
                continue;

a2444 3
              if (objfile->sect_index_bss == -1)
                continue;

a2447 10
          else if (SC_IS_SBSS (ext_in->asym.sc))
            {
              const int sbss_sect_index = get_section_index (objfile, ".sbss");

              if (sbss_sect_index == -1)
                continue;

              ms_type = mst_file_bss;
              svalue += ANOFFSET (objfile->section_offsets, sbss_sect_index);
            }
@


1.22
log
@2002-01-20  Daniel Jacobowitz  <drow@@mvista.com>

	* buildsym.c: Update copyright years.
	* c-typeprint.c: Likewise.
	* dwarf2read.c: Likewise.
	* f-typeprint.c: Likewise.
	* gdbtypes.c: Likewise.
	* gdbtypes.h: Likewise.
	* hp-symtab-read.c: Likewise.
	* hpread.c: Likewise.
	* mdebugread.c: Likewise.
	* p-typeprint.c: Likewise.
@
text
@d2710 4
a2713 2
		      stabstring = xmalloc (len + len2 + 1);
		    strcpy (stabstring, stabstring1);
@


1.21
log
@2002-01-15  Daniel Jacobowitz  <drow@@mvista.com>

	* gdbtypes.h (struct type): Fix whitespace.  Remove obsolete
	comment.  Add ``artificial'' to ``union field_location''.

	* dwarf2read.c: Remove ad-hoc TYPE_FIELD_ARTIFICIAL.

	* buildsym.c (finish_block): Initialize TYPE_FIELD_ARTIFICIAL to 0.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* hp-symtab-read.c (hpread_function_type): Likewise, instead of
	initializing TYPE_FIELD_BITPOS to n (obsolete).
	(hpread_doc_function_type): Likewise.
	* hpread.c (hpread_function_type): Likewise.
@
text
@d3 1
a3 1
   1997, 1998, 1999, 2000, 2001
@


1.20
log
@Approved by Elena Zannoni:

	2001-12-09  Fred Fish  <fnf@@redhat.com>
	* mdebugread.c (cross_ref): Pass TYPE_FLAG_STUB to init_type()
	rather than setting it after the type is created.
@
text
@d1285 1
@


1.19
log
@	2001-11-06  Fred Fish  <fnf@@redhat.com>
	* complaints.c (info_verbose): Remove unneeded decl, is in defs.h.
	* dbxread.c: Ditto
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* exec.c: Ditto.
	* hpread.c: Ditto.
	* hpread.h: Ditto.
	* mdebugread.c: Ditto.
	* os9kread.c: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* tracepoint.c: Ditto.
@
text
@d4237 1
a4237 2
      *tpp = init_type (type_code, 0, 0, (char *) NULL, current_objfile);
      TYPE_FLAGS (*tpp) |= TYPE_FLAG_STUB;
@


1.18
log
@2001-11-06  Elena Zannoni <ezannoni@@redhat.com>

        * mdebugread.c (CUR_SYMBOL_TYPE, CUR_SYMBOL_VALUE, START_PSYMTAB,
        END_PSYMTAB, SET_NAMESTRING, HANDLE_RBRAC): Delete definitions.
        (parse_partial_symbols): Don't include partial-stab.h any
        more. Don't reuse code in partial-stab.h, include the code
        directly, instead. Simplify code from partial-stab.h eliminating
        ifdef DBXREAD_ONLY code.

        * Makefile.in (mdebugread.o): Remove dependency on partial-stab.h.
@
text
@a148 5

/* Things we import explicitly from other modules */

extern int info_verbose;

@


1.17
log
@Isolate STABS readers' use of the `textlow' and `texthigh' fields
of `struct partial_symtab' to only a few locations.  This change
is not supposed to affect the way the values are computed, only
where they live.

* dbxread.c (struct symloc): Add `textlow' and `texthigh' fields
to the reader-specific structure.
* mdebugread.c (struct symloc): Same.
* dbxread.c (TEXTLOW, TEXTHIGH): New accessor macros.
* mdebugread.c (TEXTLOW, TEXTHIGH): Same.
* dbxread.c (dbx_symfile_read): After we've built all our partial
symbol tables, set each partial symtab's `textlow' and `texthigh'
fields from our reader-specific structure.
* mdebugread.c (mdebug_build_psymtabs): Same.
* dbxread.c (start_psymtab): Initialize the reader-specific
structure's `textlow' and `texthigh' from the new psymtab's.
* mdebugread.c (parse_partial_symbols, new_psymtab): Same.
* dbxread.c (read_dbx_symtab, end_psymtab, read_ofile_symtab): Use
the reader-specific `textlow' and `texthigh', not the generic
psymtab fields.
* mdebugread.c (parse_lines, parse_partial_symbols,
psymtab_to_symtab_1): Same.
* partial-stab.h: Same.
@
text
@d91 1
a91 1
#include "language.h"		/* Needed inside partial-stab.h */
d2720 156
a2875 10
#define SET_NAMESTRING() \
  namestring = stabstring
#define CUR_SYMBOL_TYPE type_code
#define CUR_SYMBOL_VALUE sh.value
#define START_PSYMTAB(ofile,fname,low,symoff,global_syms,static_syms)\
  (pst = save_pst)
#define END_PSYMTAB(pst,ilist,ninc,c_off,c_text,dep_list,n_deps,textlow_not_set) (void)0
#define HANDLE_RBRAC(val) \
  if ((val) > TEXTHIGH (save_pst)) TEXTHIGH (save_pst) = (val);
#include "partial-stab.h"
d2877 386
@


1.16
log
@2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * symtab.h (struct block): (ALL_BLOCK_SYMBOLS): New macro.

        * symtab.c (find_pc_sect_symtab): Use ALL_BLOCK_SYMBOLS.
        (make_symbol_completion_list): Likewise.
        (make_symbol_overload_list): Likewise.
        * buildsym.c (finish_block): Likewise.
        * breakpoint.c (get_catch_sals):  Likewise.
        * mdebugread.c (mylookup_symbol): Likewise.
        * objfiles.c (objfile_relocate): Likewise.
        * printcmd.c (print_frame_args): Likewise.
        * stack.c (print_block_frame_locals): Likewise.
        (print_block_frame_labels): Likewise.
        (print_frame_arg_vars): Likewise.
        * symmisc.c (dump_symtab): Likewise.
        * tracepoint.c (add_local_symbols): Likewise.
        (scope_info): Likewise.

2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * mi-cmd-stack.c (list_args_or_locals): Use ALL_BLOCK_SYMBOLS.

2001-10-12  Daniel Jacobowitz  <drow@@mvista.com>

        * generic/gdbtk-cmds.c (gdb_listfuncs): Use ALL_BLOCK_SYMBOLS.
        * generic/gdbtk-stack.c (gdb_block_vars): Likewise.
        (gdb_get_blocks): Likewise.
        (gdb_get_vars_command): Likewise.
5~
@
text
@d108 5
d128 2
d526 13
d2197 1
a2197 1
      adr = pst->textlow + pr->adr - lowest_pdr_addr;
d2532 2
d2569 1
a2569 1
      pst->texthigh = pst->textlow;
d2636 4
a2639 4
			  && (pst->textlow == 0 || procaddr < pst->textlow))
			    pst->textlow = procaddr;
			  if (high > pst->texthigh)
			    pst->texthigh = high;
d2728 1
a2728 1
  if ((val) > save_pst->texthigh) save_pst->texthigh = (val);
d2861 2
a2862 2
		      && (pst->textlow == 0 || procaddr < pst->textlow))
		    pst->textlow = procaddr;
d2865 2
a2866 2
		  if (high > pst->texthigh)
		    pst->texthigh = high;
d3040 1
a3040 1
					   -1, save_pst->texthigh,
d3045 2
a3046 2
      if (objfile->ei.entry_point >= save_pst->textlow &&
	  objfile->ei.entry_point < save_pst->texthigh)
d3048 2
a3049 2
	  objfile->ei.entry_file_lowpc = save_pst->textlow;
	  objfile->ei.entry_file_highpc = save_pst->texthigh;
d3065 1
a3065 1
	  && save_pst->textlow != 0
d3071 3
a3073 3
		&& save_pst->textlow >= pst->textlow
		&& save_pst->textlow < pst->texthigh
		&& save_pst->texthigh > pst->texthigh)
d3277 1
a3277 1
      && pst->textlow == 0 && pst->texthigh == 0)
d3425 1
a3425 1
	  st = end_symtab (pst->texthigh, pst->objfile, SECT_OFF_TEXT (pst->objfile));
d3515 1
a3515 1
      BLOCK_START (top_stack->cur_block) = pst->textlow;
@


1.15
log
@2001-09-04  Elena Zannoni  <ezannoni@@redhat.com>

	From Daniel Jacobowitz  <drow@@mvista.com>
	* dbxread.c (free_header_files): Make global.
	(init_header_files): Likewise.
	* stabsread.h (free_header_files): Add prototype.
	(init_header_files): Likewise.
	* mdebugread.c (mdebug_build_psymtabs): Initialize
	properly before using the stabs debug reader.
@
text
@d3856 2
a3857 2
  register int bot, top, inc;
  register struct symbol *sym;
a3858 2
  bot = 0;
  top = BLOCK_NSYMS (block);
d3860 1
a3860 1
  while (bot < top)
a3861 1
      sym = BLOCK_SYM (block, bot);
a3866 1
      bot++;
d3868 1
@


1.14
log
@2001-09-04  Elena Zannoni  <ezannoni@@redhat.com>

	From Daniel Jacobowitz  <drow@@mvista.com>
	* mdebugread.c (psymtab_to_symtab_1): Handle N_SO stabs without
	a name specially.
@
text
@d494 5
@


1.13
log
@* symfile.c (compare_psymbols, compare_symbols): Declare using
PTR, as in the definition.
* minsyms.c (compare_minimal_symbols): Likewise.
* coffread.c (find_targ_sec): Likewise.
* elfread.c (free_elfinfo, elf_locate_sections): Likewise.
* mipsread.c (alphacoff_locate_sections): Likewise.
* mdebugread.c (compare_blocks): Likewise.
@
text
@d3213 1
a3213 1
  struct symtab *st;
d3217 1
d3323 24
a3346 2
		  process_one_symbol (type_code, 0, valu, name,
				      pst->section_offsets, pst->objfile);
d3395 6
a3400 2
      st = end_symtab (pst->texthigh, pst->objfile, SECT_OFF_TEXT (pst->objfile));
      end_stabs ();
@


1.13.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d837 1
a837 1
	  if (STREQ (name, "malloc") && TYPE_CODE(t) == TYPE_CODE_VOID)
d849 1
a849 1
	      t = (struct type *) make_pointer_type (NULL, t);
a1135 1
#if TYPEFIX
a1137 1
#endif
d1606 3
a1608 7
      while (TYPE_CODE (tp) == TYPE_CODE_PTR || TYPE_CODE (tp) == TYPE_CODE_ARRAY)
	{
	  while (TYPE_CODE (tp) == TYPE_CODE_PTR)
	    tp = POINTER_TARGET_TYPE (tp);
	  while (TYPE_CODE (tp) == TYPE_CODE_ARRAY)
	    tp = ARRAY_ELEMENT_TYPE(tp);
	}
d1764 1
a1764 1
  struct range_type *range;
d1816 1
a1816 1
      range = make_range_type (NULL, indx,
d1819 1
a1819 1
      t = (struct type *)make_array_type (NULL,  *tpp, range);
d4250 1
a4250 1
#if TYPEFIX
d4261 1
a4261 1
#endif
a4313 1
#if TYPEFIX
d4426 3
a4428 2
  nodebug_func_symbol_type = (struct type *) make_function_type (NULL, mdebug_type_int, 0, NULL, 0, 0);
  TYPE_NAME (nodebug_func_symbol_type)  = "<function, no debug info>";
a4431 1
#endif
@


1.12
log
@2001-03-06  J.T. Conklin  <jtc@@redback.com>

        * symtab.h (decode_line_1): Removed declaration.

        * symfile.c (#include <assert.h>): Removed.

        * arch-utils.c (#include <ctype.h>): Removed.
        * c-typeprint.c: Likewise.
        * dbxread.c: Likewise.
        * gdbtypes.c: Likewise.
        * target.c: Likewise.
        * os9kread.c: Likewise.

        * c-valprint.c (#include "demangle.h"): Removed.
        * ch-typeprint.c: Likewise.
        * eval.c: Likewise.
        * f-typeprint.c: Likewise.
        * f-valprint.c: Likewise.
        * m2-typeprint.c: Likewise.
        * typeprint.c: Likewise.
        * p-typeprint.c: Likewise.
        * valarith.c: Likewise.
        * valprint.c: Likewise.

        * m2-typeprint.c (#include "gdb_string.h"): Removed.
        * nlmread.c: Likewise.

        * mdebugread.c (#include "gdb-stabs.h"): Removed.
        * minsyms.c: Likewise.
        * mipsread.c: Likewise.
        * nlmread.c: Likewise.

        * m2-typeprint.c (#include "obstack.h"): Removed.
        * m2-valprint.c: Likewise.

        * event-loop.c (#include <setjmp.h>): Removed.
@
text
@d381 1
a381 1
static int compare_blocks (const void *, const void *);
@


1.11
log
@Update/correct copyright notices.
@
text
@a81 2
#include "gdb-stabs.h"

@


1.10
log
@Replace calls to abort() with calls to internal_error().
@
text
@d2 2
a3 1
   Copyright 1986, 87, 89, 90, 91, 92, 93, 94, 95, 96, 97, 1998
@


1.9
log
@Replace free() with xfree().
@
text
@d2946 1
a2946 1
		abort ();
@


1.8
log
@Multiarch STAB_REG_TO_REGNUM, ECOFF_REG_TO_REGNUM,
DWARF_REG_TO_REGNUM, SDB_REG_TO_REGNUM, DWARF2_REG_TO_REGNUM.
@
text
@d2289 1
a2289 1
  old_chain = make_cleanup (free, fdr_to_pst);
d2307 1
a2307 1
  make_cleanup (free, ext_block);
d2707 1
a2707 1
		  free (stabstring);
d3397 1
a3397 1
	  old_chain = make_cleanup (free, pr_block);
d3506 1
a3506 1
	      old_chain = make_cleanup (free, pr_block);
@


1.7
log
@Protoization.
@
text
@a95 5
/* Provide a default mapping from a ecoff register number to a gdb REGNUM.  */
#ifndef ECOFF_REG_TO_REGNUM
#define ECOFF_REG_TO_REGNUM(num) (num)
#endif

@


1.6
log
@Protoization.
@
text
@d3185 2
d3188 1
a3188 2
mdebug_next_symbol_text (objfile)
     struct objfile *objfile;	/* argument objfile is currently unused */
@


1.5
log
@Eliminate PARAMS from function pointer declarations.
@
text
@d413 1
a413 2
xzalloc (size)
     unsigned int size;
d427 1
a427 2
mdebug_psymtab_to_symtab (pst)
     struct partial_symtab *pst;
d456 1
a456 2
get_rfd (cf, rf)
     int cf, rf;
d478 1
a478 2
fdr_name (f)
     FDR *f;
d492 3
a494 4
mdebug_build_psymtabs (objfile, swap, info)
     struct objfile *objfile;
     const struct ecoff_debug_swap *swap;
     struct ecoff_debug_info *info;
d578 1
a578 1
push_parse_stack ()
d603 1
a603 1
pop_parse_stack ()
d637 1
a637 3
is_pending_symbol (fh, sh)
     FDR *fh;
     char *sh;
d652 1
a652 4
add_pending (fh, sh, t)
     FDR *fh;
     char *sh;
     struct type *t;
d683 2
a684 7
parse_symbol (sh, ax, ext_sh, bigend, section_offsets, objfile)
     SYMR *sh;
     union aux_ext *ax;
     char *ext_sh;
     int bigend;
     struct section_offsets *section_offsets;
     struct objfile *objfile;
d1425 2
a1426 7
parse_type (fd, ax, aux_index, bs, bigend, sym_name)
     int fd;
     union aux_ext *ax;
     unsigned int aux_index;
     int *bs;
     int bigend;
     char *sym_name;
d1761 2
a1762 7
upgrade_type (fd, tpp, tq, ax, bigend, sym_name)
     int fd;
     struct type **tpp;
     int tq;
     union aux_ext *ax;
     int bigend;
     char *sym_name;
d1880 2
a1881 4
parse_procedure (pr, search_symtab, pst)
     PDR *pr;
     struct symtab *search_symtab;
     struct partial_symtab *pst;
d2034 1
a2034 3
ecoff_relocate_efi (sym, delta)
     struct symbol *sym;
     CORE_ADDR delta;
d2053 2
a2054 5
parse_external (es, bigend, section_offsets, objfile)
     EXTR *es;
     int bigend;
     struct section_offsets *section_offsets;
     struct objfile *objfile;
d2146 2
a2147 7
parse_lines (fh, pr, lt, maxlines, pst, lowest_pdr_addr)
     FDR *fh;
     PDR *pr;
     struct linetable *lt;
     int maxlines;
     struct partial_symtab *pst;
     CORE_ADDR lowest_pdr_addr;
d2213 1
a2213 2
parse_partial_symbols (objfile)
     struct objfile *objfile;
d3121 2
a3122 5
handle_psymbol_enumerators (objfile, fh, stype, svalue)
     struct objfile *objfile;
     FDR *fh;
     int stype;
     CORE_ADDR svalue;
d3211 1
a3211 3
psymtab_to_symtab_1 (pst, filename)
     struct partial_symtab *pst;
     char *filename;
d3596 1
a3596 3
has_opaque_xref (fh, sh)
     FDR *fh;
     SYMR *sh;
d3628 2
a3629 8
cross_ref (fd, ax, tpp, type_code, pname, bigend, sym_name)
     int fd;
     union aux_ext *ax;
     struct type **tpp;
     enum type_code type_code;	/* Use to alloc new type if none is found. */
     char **pname;
     int bigend;
     char *sym_name;
d3826 2
a3827 5
mylookup_symbol (name, block, namespace, class)
     char *name;
     register struct block *block;
     namespace_enum namespace;
     enum address_class class;
d3858 1
a3858 3
add_symbol (s, b)
     struct symbol *s;
     struct block *b;
d3891 1
a3891 3
add_block (b, s)
     struct block *b;
     struct symtab *s;
d3921 1
a3921 5
add_line (lt, lineno, adr, last)
     struct linetable *lt;
     int lineno;
     CORE_ADDR adr;
     int last;
d3943 1
a3943 3
compare_blocks (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
d3960 1
a3960 2
sort_blocks (s)
     struct symtab *s;
d4011 1
a4011 5
new_symtab (name, maxsyms, maxlines, objfile)
     char *name;
     int maxsyms;
     int maxlines;
     struct objfile *objfile;
d4033 1
a4033 3
new_psymtab (name, objfile)
     char *name;
     struct objfile *objfile;
d4062 1
a4062 2
new_linetable (size)
     int size;
d4079 1
a4079 2
shrink_linetable (lt)
     struct linetable *lt;
d4091 1
a4091 2
new_bvect (nblocks)
     int nblocks;
d4107 1
a4107 2
new_block (maxsyms)
     int maxsyms;
d4118 1
a4118 3
shrink_block (b, s)
     struct block *b;
     struct symtab *s;
d4146 1
a4146 2
new_symbol (name)
     char *name;
d4163 1
a4163 2
new_type (name)
     char *name;
d4179 2
a4180 4
elfmdebug_build_psymtabs (objfile, swap, sec)
     struct objfile *objfile;
     const struct ecoff_debug_swap *swap;
     asection *sec;
d4215 1
a4215 1
fixup_sigtramp ()
d4317 1
a4317 1
_initialize_mdebugread ()
@


1.4
log
@PARAMS removal.
@
text
@d702 1
a702 2
  void (*const swap_sym_in) PARAMS ((bfd *, PTR, SYMR *)) =
  debug_swap->swap_sym_in;
d2256 3
a2258 6
  void (*const swap_ext_in) PARAMS ((bfd *, PTR, EXTR *))
  = debug_swap->swap_ext_in;
  void (*const swap_sym_in) PARAMS ((bfd *, PTR, SYMR *))
  = debug_swap->swap_sym_in;
  void (*const swap_rfd_in) PARAMS ((bfd *, PTR, RFDT *))
  = debug_swap->swap_rfd_in;
d3166 1
a3166 2
  void (*const swap_sym_in) PARAMS ((bfd *, PTR, SYMR *))
  = debug_swap->swap_sym_in;
d3258 2
a3259 2
  void (*swap_sym_in) PARAMS ((bfd *, PTR, SYMR *));
  void (*swap_pdr_in) PARAMS ((bfd *, PTR, PDR *));
@


1.3
log
@Fix IRIX cc warnings.  Fix ui_out functions that didn't return a value.
@
text
@d60 1
a60 1
extern void ecoff_relocate_efi PARAMS ((struct symbol *, CORE_ADDR));
d94 1
a94 1
extern void _initialize_mdebugread PARAMS ((void));
d334 1
a334 2
static void
add_pending PARAMS ((FDR *, char *, struct type *));
d336 1
a336 2
static struct mdebug_pending *
  is_pending_symbol PARAMS ((FDR *, char *));
d338 1
a338 2
static void
pop_parse_stack PARAMS ((void));
d340 1
a340 2
static void
push_parse_stack PARAMS ((void));
d342 1
a342 2
static char *
  fdr_name PARAMS ((FDR *));
d344 1
a344 2
static void
mdebug_psymtab_to_symtab PARAMS ((struct partial_symtab *));
d347 1
a347 1
upgrade_type PARAMS ((int, struct type **, int, union aux_ext *, int, char *));
d349 1
a349 2
static void
parse_partial_symbols PARAMS ((struct objfile *));
d351 1
a351 2
static FDR
* get_rfd PARAMS ((int, int));
d353 1
a353 2
static int
has_opaque_xref PARAMS ((FDR *, SYMR *));
d356 2
a357 2
cross_ref PARAMS ((int, union aux_ext *, struct type **, enum type_code,
		   char **, int, char *));
d359 1
a359 2
static struct symbol *
  new_symbol PARAMS ((char *));
d361 1
a361 2
static struct type *
  new_type PARAMS ((char *));
d363 1
a363 2
static struct block *
  new_block PARAMS ((int));
d365 1
a365 2
static struct symtab *
  new_symtab PARAMS ((char *, int, int, struct objfile *));
d367 1
a367 2
static struct linetable *
  new_linetable PARAMS ((int));
d369 1
a369 2
static struct blockvector *
  new_bvect PARAMS ((int));
d372 2
a373 1
parse_symbol PARAMS ((SYMR *, union aux_ext *, char *, int, struct section_offsets *, struct objfile *));
d375 2
a376 2
static struct type *
  parse_type PARAMS ((int, union aux_ext *, unsigned int, int *, int, char *));
d378 2
a379 3
static struct symbol *
  mylookup_symbol PARAMS ((char *, struct block *, namespace_enum,
			   enum address_class));
d381 1
a381 2
static struct block *
  shrink_block PARAMS ((struct block *, struct symtab *));
d383 1
a383 2
static PTR
  xzalloc PARAMS ((unsigned int));
d385 1
a385 2
static void
sort_blocks PARAMS ((struct symtab *));
d387 1
a387 2
static int
compare_blocks PARAMS ((const void *, const void *));
d389 1
a389 2
static struct partial_symtab *
  new_psymtab PARAMS ((char *, struct objfile *));
d391 1
a391 2
static void
psymtab_to_symtab_1 PARAMS ((struct partial_symtab *, char *));
d393 1
a393 2
static void
add_block PARAMS ((struct block *, struct symtab *));
d395 1
a395 2
static void
add_symbol PARAMS ((struct symbol *, struct block *));
d397 1
a397 2
static int
add_line PARAMS ((struct linetable *, int, CORE_ADDR, int));
d399 1
a399 2
static struct linetable *
  shrink_linetable PARAMS ((struct linetable *));
d402 1
a402 1
handle_psymbol_enumerators PARAMS ((struct objfile *, FDR *, int, CORE_ADDR));
d404 1
a404 2
static char *
  mdebug_next_symbol_text PARAMS ((struct objfile *));
d1903 1
a1903 2
static void parse_procedure PARAMS ((PDR *, struct symtab *,
				     struct partial_symtab *));
d2079 2
a2080 1
static void parse_external PARAMS ((EXTR *, int, struct section_offsets *, struct objfile *));
d2175 2
a2176 2
static void parse_lines PARAMS ((FDR *, PDR *, struct linetable *, int,
				 struct partial_symtab *, CORE_ADDR));
@


1.2
log
@Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * objfiles.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Define as functions of OBJFILE.  Add
        sect_index_text, sect_index_data, sect_index_rodata,
        sect_index_bss to objfile structure.
        * gdb-stabs.h (SECT_OFF_DATA, SECT_OFF_TEXT, SECT_OFF_BSS,
        SECT_OFF_RODATA): Remove.
        * objfiles.c (allocate_objfile): Initialize
        sect_index_{text,data,bss,rodata} to -1, for error detection.

        * symfile.c (default_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata} from bfd information.
        * xcoffread.c (xcoff_symfile_offsets): Ditto.
        * somread.c (som_symfile_offsets): Initialize
        sect_index_{text,data,bss,rodata}.

        * coffread.c, dbxread.c, elfread.c, hp-psymtab-read.c,
        hp-symtab-read.c, hpread.c, mdebugread.c, minsyms.c,
        mipsread.c, objfiles.c, os9kread.c, pa64solib.c, partial-stab.h,
        remote-os9k.c, remote-vx.c, remote.c, rs6000-nat.c, somsolib.c,
        stabsread.c, symfile.c, xcoffread.c:
        Update use of SECT_OFF_{TEXT,DATA,BSS,RODATA} to depend on the
        current objfile.

        * xcoffread.c: Add new field objfile to find_targ_sec_arg.
@
text
@d2772 1
a2772 1
  pst = save_pst
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
This file is part of GDB.
d10 14
a23 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d63 6
a68 4
typedef struct mips_extra_func_info {
        long    numargs;
        PDR     pdr;
} *mips_extra_func_info_t;
d94 1
d107 1
a108 1

d113 14
a126 14
{
  /* Index of the FDR that this psymtab represents.  */
  int fdr_idx;
  /* The BFD that the psymtab was created from.  */
  bfd *cur_bfd;
  const struct ecoff_debug_swap *debug_swap;
  struct ecoff_debug_info *debug_info;
  struct mdebug_pending **pending_list;
  /* Pointer to external symbols for this file.  */
  EXTR *extern_tab;
  /* Size of extern_tab.  */
  int extern_count;
  enum language pst_language;
};
a146 1
                                      
d148 1
d338 1
a338 1
is_pending_symbol PARAMS ((FDR *, char *));
d347 1
a347 1
fdr_name PARAMS ((FDR *));
d356 1
a356 2
parse_partial_symbols PARAMS ((struct objfile *,
			       struct section_offsets *));
d359 1
a359 1
*get_rfd PARAMS ((int, int));
d369 1
a369 1
new_symbol PARAMS ((char *));
d372 1
a372 1
new_type PARAMS ((char *));
d375 1
a375 1
new_block PARAMS ((int));
d378 1
a378 1
new_symtab PARAMS ((char *, int, int, struct objfile *));
d381 1
a381 1
new_linetable PARAMS ((int));
d384 1
a384 1
new_bvect PARAMS ((int));
d387 1
a387 1
parse_symbol PARAMS ((SYMR *, union aux_ext *, char *, int, struct section_offsets *));
d390 1
a390 1
parse_type PARAMS ((int, union aux_ext *, unsigned int, int *, int, char *));
d393 2
a394 2
mylookup_symbol PARAMS ((char *, struct block *, namespace_enum,
			 enum address_class));
d397 1
a397 1
shrink_block PARAMS ((struct block *, struct symtab *));
d400 1
a400 1
xzalloc PARAMS ((unsigned int));
d409 1
a409 1
new_psymtab PARAMS ((char *, struct objfile *, struct section_offsets *));
d424 1
a424 1
shrink_linetable PARAMS ((struct linetable *));
d430 1
a430 1
mdebug_next_symbol_text PARAMS ((struct objfile *));
d497 4
a500 4
			     ((char *) debug_info->external_rfd
			      + ((f->rfdBase + rf)
				 * debug_swap->external_rfd_size)),
			     &rfd);
d522 1
a522 1
mdebug_build_psymtabs (objfile, swap, info, section_offsets)
a525 1
     struct section_offsets *section_offsets;
d549 1
a549 1
  parse_partial_symbols (objfile, section_offsets);
d558 1
a558 1
		 objfile->name);
d583 19
a601 19
{
  struct parse_stack *next, *prev;
  struct symtab *cur_st;	/* Current symtab. */
  struct block *cur_block;	/* Block in it. */

  /* What are we parsing.  stFile, or stBlock are for files and
     blocks.  stProc or stStaticProc means we have seen the start of a
     procedure, but not the start of the block within in.  When we see
     the start of that block, we change it to stNil, without pushing a
     new block, i.e. stNil means both a procedure and a block.  */

  int blocktype;

  int maxsyms;			/* Max symbols in this block. */
  struct type *cur_type;	/* Type we parse fields for. */
  int cur_field;		/* Field number in cur_type. */
  CORE_ADDR procadr;		/* Start addres of this procedure */
  int numargs;			/* Its argument count */
}
d719 1
a719 1
parse_symbol (sh, ax, ext_sh, bigend, section_offsets)
d725 1
d728 2
a729 2
  void (* const swap_sym_in) PARAMS ((bfd *, PTR, SYMR *)) =
    debug_swap->swap_sym_in;
d752 4
a755 4
	 The value of a stEnd symbol is the displacement from the
	 corresponding start symbol value.
	 The value of a stBlock symbol is the displacement from the
	 procedure address.  */
d757 1
a757 1
	sh->value += ANOFFSET (section_offsets, SECT_OFF_TEXT);
d764 1
a764 1
      sh->value += ANOFFSET (section_offsets, SECT_OFF_DATA);
d768 1
a768 1
      sh->value += ANOFFSET (section_offsets, SECT_OFF_BSS);
d789 1
a789 1
      if (SC_IS_COMMON(sh->sc))
d820 1
a820 1
      if (SC_IS_UNDEF(sh->sc)
d843 1
a843 1
	  SYMBOL_CLASS(s) = LOC_REGPARM;
d848 1
a848 1
	  SYMBOL_CLASS(s) = LOC_REF_ARG;
d852 1
a852 1
	  SYMBOL_CLASS(s) = LOC_REGPARM_ADDR;
d857 1
a857 1
	  SYMBOL_CLASS(s) = LOC_ARG;
d880 1
a880 1
      if (SC_IS_UNDEF(sh->sc) || sh->sc == scNil)
d885 1
a885 1
	  if (STREQ(name, "malloc") && t->code == TYPE_CODE_VOID)
d888 9
a896 9
		 when linking against a malloc without debugging
		 symbols, its read as a function returning void---this
		 is bad because it means we cannot call functions with
		 string arguments interactively; i.e., "call
		 printf("howdy\n")" would fail with the error message
		 "program has no memory available".  To avoid this, we
		 patch up the type and make it void*
		 instead. (davidm@@azstarnet.com)
		 */
d929 1
a929 1
      if (SC_IS_UNDEF(sh->sc) || sh->sc == scNil)
d942 1
a942 1
	       They all share a common set of local variables, defined here.  */
d963 1
a963 1
	if (sh->sc != scInfo && !SC_IS_COMMON(sh->sc))
d994 22
a1015 20
		  /* If the type of the member is Nil (or Void),
		     without qualifiers, assume the tag is an
		     enumeration.
		     Alpha cc -migrate enums are recognized by a zero
		     index and a zero symbol value.
		     DU 4.0 cc enums are recognized by a member type of
		     btEnum without qualifiers and a zero symbol value.  */
		  if (tsym.index == indexNil
		      || (tsym.index == 0 && sh->value == 0))
		    type_code = TYPE_CODE_ENUM;
		  else
		    {
		      (*debug_swap->swap_tir_in) (bigend,
						  &ax[tsym.index].a_ti,
						  &tir);
		      if ((tir.bt == btNil || tir.bt == btVoid
			   || (tir.bt == btEnum && sh->value == 0))
			  && tir.tq0 == tqNil)
			type_code = TYPE_CODE_ENUM;
		    }
d1029 1
a1029 1
		  if (tsym.sc == scVariant);	/*UNIMPLEMENTED*/
d1034 3
a1036 3
			 struct.  Skip over the fields of the inner
			 struct.  The -1 is because the for loop will
			 increment ext_tsym.  */
d1098 6
a1103 4
	  if (nfields > 1 && max_value == 0)
	    type_code = TYPE_CODE_UNION;
	  else
	    type_code = TYPE_CODE_STRUCT;
d1218 1
a1218 1
	 is the displacement from procedure start */
d1222 2
a1223 2
	 procedure.  This allows the LOC_BLOCK symbol to point to the
	 block with the local variables, so funcname::var works.  */
d1240 1
a1240 1
      if (sh->sc == scInfo || SC_IS_COMMON(sh->sc))
d1292 1
a1292 1
		 type.  Set that from the type of the parameter symbols. */
d1302 1
a1302 1
						    
d1359 1
a1359 1
	 skip them.  */
d1366 1
a1366 1
	 are handled by cross_ref, skip them.  */
d1374 1
a1374 1
	  t = parse_type (cur_fd, ax, sh->index, (int *)NULL, bigend, name);
d1381 14
a1394 14
	 declarations. These should not go into the symbol table and
	 TYPE_NAME should not be set for them.
	 They can't be distinguished from an intentional typedef to
	 the same name however:
	 x.h:
		struct x { int ix; int jx; };
		struct xx;
	 x.c:
		typedef struct x x;
		struct xx {int ixx; int jxx; };
	 generates a cross referencing stTypedef for x and xx.
	 The user visible effect of this is that the type of a pointer
	 to struct foo sometimes is given as `foo *' instead of `struct foo *'.
	 The problem is fixed with alpha cc and Irix5 cc.  */
d1397 1
a1397 1
	 is safe to omit it from the symbol table.  */
d1411 1
a1411 1
              || (TYPE_CODE (SYMBOL_TYPE (s)) != TYPE_CODE_STRUCT
d1418 12
a1429 12
		 foo" or "function returning foo", we better not set
		 the TYPE_NAME.  If the program contains "typedef char
		 *caddr_t;", we don't want all variables of type char
		 * to print as caddr_t.  This is not just a
		 consequence of GDB's type management; CC and GCC (at
		 least through version 2.4) both output variables of
		 either type char * or caddr_t with the type
		 refering to the stTypedef symbol for caddr_t.  If a future
		 compiler cleans this up it GDB is not ready for it
		 yet, but if it becomes ready we somehow need to
		 disable this check (without breaking the PCC/GCC2.4
		 case).
d1431 1
a1431 1
		 Sigh.
d1433 2
a1434 2
		 Fortunately, this check seems not to be necessary
		 for anything except pointers or functions.  */
d1478 5
a1482 5
    &mdebug_type_void,			/* btNil */
    &mdebug_type_adr_32,		/* btAdr */
    &mdebug_type_char,			/* btChar */
    &mdebug_type_unsigned_char,		/* btUChar */
    &mdebug_type_short,			/* btShort */
d1484 1
a1484 1
    &mdebug_type_int_32,		/* btInt */
d1486 1
a1486 1
    &mdebug_type_long_32,		/* btLong */
d1488 9
a1496 9
    &mdebug_type_float,			/* btFloat */
    &mdebug_type_double,		/* btDouble */
    0,					/* btStruct */
    0,					/* btUnion */
    0,					/* btEnum */
    0,					/* btTypedef */
    0,					/* btRange */
    0,					/* btSet */
    &mdebug_type_complex,		/* btComplex */
d1498 11
a1508 11
    0,					/* btIndirect */
    &mdebug_type_fixed_dec,		/* btFixedDec */
    &mdebug_type_float_dec,		/* btFloatDec */
    &mdebug_type_string,		/* btString */
    0,					/* btBit */
    0,					/* btPicture */
    &mdebug_type_void,			/* btVoid */
    0,					/* DEC C++:  Pointer to member */
    0,					/* DEC C++:  Virtual function table */
    0,					/* DEC C++:  Class (Record) */
    &mdebug_type_long_64,		/* btLong64  */
d1510 4
a1513 4
    &mdebug_type_long_long_64,		/* btLongLong64  */
    &mdebug_type_unsigned_long_long_64,	/* btULongLong64 */
    &mdebug_type_adr_64,		/* btAdr64 */
    &mdebug_type_int_64,		/* btInt64  */
d1589 2
a1590 2
	 corrupt the TIR.  */
      if (bs == (int *)NULL)
d1605 1
a1605 1
        *bs = width;
d1636 1
a1636 1
		       rn->index, (int *) NULL, xref_fh->fBigendian, sym_name);
d1646 2
a1647 2
      /* btSet (I think) implies that the name is a tag name, not a typedef
	 name.  This apparently is a MIPS extension for C sets.  */
d1658 1
a1658 1
	 dereference them.  */
d1664 2
a1665 2
	 Any type may be returned from cross_ref if file indirect entries
	 are corrupted.  */
d1693 1
a1693 1
	      (.Fxx or .xxfake or empty) for unnamed struct/union/enums.  */
d1699 1
a1699 1
					       &current_objfile->type_obstack);
d1717 2
a1718 2
	 Any type may be returned from cross_ref if file indirect entries
	 are corrupted.  */
d1757 1
a1757 1
					      &current_objfile->type_obstack);
d1761 1
a1761 1
					      &current_objfile->type_obstack);
d1796 1
a1796 1
 
d1859 1
a1859 1
	 else due to corrupt aux entries.  */
d1880 12
a1891 12
	 here if the TYPE_LENGTH of the target type was zero.
	 This happens for a `pointer to an array of anonymous structs',
	 but in this case the array element bitsize is also zero,
	 so nothing is gained.
	 And we used to check the TYPE_LENGTH of the target type against
	 the supplied array element bitsize.
	 gcc causes a mismatch for `pointer to array of object',
	 since the sdb directives it uses do not have a way of
	 specifying the bitsize, but it does no harm (the
	 TYPE_LENGTH should be correct) and we should be able to
	 ignore the erroneous bitsize from the auxiliary entry safely.
	 dbx seems to ignore it too.  */
d1894 1
a1894 1
	 problem.  */
d1957 1
a1957 1
	  
d1983 2
a1984 2
	 but also if we are looking up a non-mangled name which happens to
	 match the name of a mangled function.  */
d1986 3
a1988 3
	 If the pdr is for a static function and if a global function with
	 the same name exists, lookup_symbol will eventually read in the symtab
	 for the global function and clobber cur_fdr.  */
d2027 1
a2027 1
	 argument is no longer passed in.  */
d2043 9
a2051 9
	 procedure descriptor in e->pdr.adr.
	 As the address in the procedure descriptor is usually relative,
	 we would have to relocate e->pdr.adr with cur_fdr->adr and
	 ANOFFSET (pst->section_offsets, SECT_OFF_TEXT).
	 Unfortunately cur_fdr->adr and e->pdr.adr are both absolute
	 in shared libraries on some systems, and on other systems
	 e->pdr.adr is sometimes offset by a bogus value.
	 To work around these problems, we replace e->pdr.adr with
	 the start address of the function.  */
d2055 1
a2055 1
	 to make backtrace through setjmp work.  */
d2079 1
a2079 1
 
d2096 1
a2096 1
  
d2106 1
a2106 1
static void parse_external PARAMS ((EXTR *, int, struct section_offsets *));
d2109 1
a2109 1
parse_external (es, bigend, section_offsets)
d2113 1
d2130 1
a2130 1
  if (SC_IS_UNDEF(es->asym.sc) || es->asym.sc == scNil)
d2170 8
a2177 8
	 If they are from objects compiled without -g, their index will
	 be indexNil, and the symbol definition from the minimal symbol
	 is preferrable (yielding a function returning int instead of int).
	 If the index points to a local procedure symbol, the local
	 symbol already provides the correct type.
	 Note that the index of the external procedure symbol points
	 to the local procedure symbol in the local symbol table, and
	 _not_ to the auxiliary symbol info.  */
d2182 2
a2183 2
	 ignore them.  */
      if (SC_IS_COMMON(es->asym.sc))
d2187 2
a2188 2
	 anyways by parse_symbol().  */
      parse_symbol (&es->asym, ax, (char *) NULL, bigend, section_offsets);
d2234 1
a2234 1
	 this procedure.  */
d2237 1
a2237 1
 	halt = base + pr[1].cbLineOffset;
d2239 1
a2239 1
 	halt = base + fh->cbLine;
d2245 1
a2245 1
      for (lineno = pr->lnLow; base < halt; )
d2277 1
a2277 1
parse_partial_symbols (objfile, section_offsets)
a2278 1
     struct section_offsets *section_offsets;
d2283 6
a2288 6
  void (* const swap_ext_in) PARAMS ((bfd *, PTR, EXTR *))
    = debug_swap->swap_ext_in;
  void (* const swap_sym_in) PARAMS ((bfd *, PTR, SYMR *))
    = debug_swap->swap_sym_in;
  void (* const swap_rfd_in) PARAMS ((bfd *, PTR, RFDT *))
    = debug_swap->swap_rfd_in;
d2365 1
a2365 1
    struct partial_symtab *pst = new_psymtab ("", objfile, section_offsets);
d2426 2
a2427 2
	 (assumes ECOFF symtab is a subset of the ELF symtab;
	 assumes no side-effects result from ignoring ECOFF symbol)
d2429 3
a2431 3
        symbols fails
	 (inefficient; 
	 assumes no side-effects result from ignoring ECOFF symbol)
d2433 3
a2435 3
        during relocation, then modify "uniqify" phase to merge and 
        eliminate the duplicate symbol
	 (highly inefficient)
d2441 21
a2461 7
    /* Pass 2 over external syms: fill in external symbols */
    ext_in = ext_block;
    ext_in_end = ext_in + hdr->iextMax;
    for (; ext_in < ext_in_end; ext_in++)
      {
	enum minimal_symbol_type ms_type = mst_text;
	CORE_ADDR svalue = ext_in->asym.value;
d2463 2
a2464 13
	/* The Irix 5 native tools seem to sometimes generate bogus
	   external symbols.  */
	if (ext_in->ifd < -1 || ext_in->ifd >= hdr->ifdMax)
	  {
	    complain (&bad_ext_ifd_complaint, ext_in->ifd, hdr->ifdMax);
	    continue;
	  }
	if (ext_in->asym.iss < 0 || ext_in->asym.iss >= hdr->issExtMax)
	  {
	    complain (&bad_ext_iss_complaint, ext_in->asym.iss,
			hdr->issExtMax);
	    continue;
	  }
a2465 2
	extern_tab[fdr_to_pst[ext_in->ifd].globals_offset
		   + fdr_to_pst[ext_in->ifd].n_globals++] = *ext_in;
d2467 2
a2469 2
	if (SC_IS_UNDEF(ext_in->asym.sc) || ext_in->asym.sc == scNil)
	  continue;
d2471 2
a2472 3
    
	/* Pass 3 over files, over local syms: fill in static symbols */
	name = debug_info->ssext + ext_in->asym.iss;
d2474 18
a2491 61
	/* Process ECOFF Symbol Types and Storage Classes */
	switch (ext_in->asym.st)
	  {
	  case stProc:
	    /* Beginnning of Procedure */
	    svalue += ANOFFSET (section_offsets, SECT_OFF_TEXT);
	    break;
	  case stStaticProc:
	    /* Load time only static procs */
	    ms_type = mst_file_text;
	    svalue += ANOFFSET (section_offsets, SECT_OFF_TEXT);
	    break;
	  case stGlobal:
	    /* External symbol */
	    if (SC_IS_COMMON (ext_in->asym.sc))
	      {
		/* The value of a common symbol is its size, not its address.
		   Ignore it.  */
		continue;
	      }
	    else if (SC_IS_DATA (ext_in->asym.sc))
	      {
		ms_type = mst_data;
		svalue += ANOFFSET (section_offsets, SECT_OFF_DATA);
	      }
	    else if (SC_IS_BSS (ext_in->asym.sc))
	      {
		ms_type = mst_bss;
		svalue += ANOFFSET (section_offsets, SECT_OFF_BSS);
	      }
	    else
	      ms_type = mst_abs;
	    break;
	  case stLabel:
	    /* Label */
	    if (SC_IS_TEXT (ext_in->asym.sc))
	      {
		ms_type = mst_file_text;
		svalue += ANOFFSET (section_offsets, SECT_OFF_TEXT);
	      }
	    else if (SC_IS_DATA (ext_in->asym.sc))
	      {
		ms_type = mst_file_data;
		svalue += ANOFFSET (section_offsets, SECT_OFF_DATA);
	      }
	    else if (SC_IS_BSS (ext_in->asym.sc))
	      {
		ms_type = mst_file_bss;
		svalue += ANOFFSET (section_offsets, SECT_OFF_BSS);
	      }
	    else
	      ms_type = mst_abs;
	    break;
	  case stLocal:
	  case stNil:
	    /* The alpha has the section start addresses in stLocal symbols
		 whose name starts with a `.'. Skip those but complain for all
		 other stLocal symbols.
		 Irix6 puts the section start addresses in stNil symbols, skip
		 those too.*/
	    if (name[0] == '.')
d2493 51
a2543 8
	    /* Fall through.  */
	  default:
	    ms_type = mst_unknown;
	    complain (&unknown_ext_complaint, name);
	  }
        if (!ECOFF_IN_ELF(cur_bfd))
	  prim_record_minimal_symbol (name, svalue, ms_type, objfile);
      }
d2561 1
a2561 1
	 file header and relocate it, except for Irix 5.2 zero fh->adr.  */
d2566 1
a2566 1
	    textlow += ANOFFSET (section_offsets, SECT_OFF_TEXT);
d2570 1
a2570 1
      pst = start_psymtab_common (objfile, section_offsets,
d2592 9
a2600 9
	 with native cc and g++ will set the language to C).
	 Otherwise we have to deduce the language from the filename.
	 Native ecoff has every header file in a separate FDR, so
	 deduce_language_from_filename will return language_unknown for
	 a header file, which is not what we want.
	 But the FDRs for the header files are after the FDR for the source
	 file, so we can assign the language of the source file to the
	 following header files. Then we save the language in the private
	 pst data so that we can reuse it when building symtabs.  */
d2619 5
a2623 5
	 This symbol is emitted by mips-tfile to signal that the
	 current object file uses encapsulated stabs instead of mips
	 ecoff for local symbols.  (It is the second symbol because
	 the first symbol is the stFile used to signal the start of a
	 file). */
d2644 1
a2644 1
			       + (fh->isymBase + cur_sdx) * external_sym_size),
d2653 2
a2654 2
	
		      sh.value += ANOFFSET (section_offsets, SECT_OFF_TEXT);
d2662 1
a2662 1
							       SECT_OFF_TEXT,
d2681 1
a2681 1
	      		  /* Kludge for Irix 5.2 zero fh->adr.  */
d2683 1
a2683 1
			      && (pst->textlow == 0 || procaddr < pst->textlow))
d2705 1
a2705 1
		          sh.value += ANOFFSET (section_offsets, SECT_OFF_DATA);
d2710 1
a2710 1
							       SECT_OFF_DATA,
d2719 1
a2719 1
		          sh.value += ANOFFSET (section_offsets, SECT_OFF_BSS);
d2724 1
a2724 1
							       SECT_OFF_BSS,
d2736 1
a2736 1
		while (stabstring[len-1] == '\\')
d2750 1
a2750 1
				     + (fh->isymBase + cur_sdx) 
d2758 1
a2758 1
			&& stabstring != debug_info->ss + fh->issBase + sh.iss)
d2771 1
a2771 1
#define START_PSYMTAB(ofile,secoff,fname,low,symoff,global_syms,static_syms)\
d2778 1
a2778 1
	        if (stabstring 
d2782 1
a2782 1
	    /* end - Handle continuation */
d2805 1
a2805 1
	      if (SC_IS_UNDEF(sh.sc) || sh.sc == scNil
d2823 1
a2823 1
		    sh.value += ANOFFSET (section_offsets, SECT_OFF_TEXT);
d2830 1
a2830 1
		  sh.value += ANOFFSET (section_offsets, SECT_OFF_DATA);
d2834 1
a2834 1
		  sh.value += ANOFFSET (section_offsets, SECT_OFF_BSS);
d2847 1
a2847 1
						       SECT_OFF_TEXT, NULL,
d2868 1
a2868 1
					 0, sh.value, psymtab_language, objfile);
d2873 1
a2873 1
					 0, sh.value, psymtab_language, objfile);
d2879 1
a2879 1
			   with the MIPS compiler.  FIXME -- pull later.  */
d2917 1
a2917 1
          	  if (SC_IS_DATA (sh.sc))
d2920 1
a2920 1
							 SECT_OFF_DATA,
d2926 1
a2926 1
							 SECT_OFF_BSS,
d2932 1
a2932 1
		case stIndirect:/* Irix5 forward declaration */
d2936 1
a2936 1
		case stTypedef:/* Typedef */
d2951 1
a2951 1
		case stBlock:	/* { }, str, un, enum*/
d2955 1
a2955 1
		       || SC_IS_COMMON(sh.sc))
d3023 1
a3023 1
	      if (SC_IS_UNDEF(psh->sc) || psh->sc == scNil)
d3031 1
a3031 1
		  svalue += ANOFFSET (section_offsets, SECT_OFF_TEXT);
d3038 1
a3038 1
		  svalue += ANOFFSET (section_offsets, SECT_OFF_DATA);
d3042 1
a3042 1
		  svalue += ANOFFSET (section_offsets, SECT_OFF_BSS);
d3068 1
a3068 1
		  if (SC_IS_COMMON(psh->sc))
d3084 1
a3084 1
	 empty and put on the free list.  */
d3086 1
a3086 1
					   psymtab_include_list, includes_used,
d3088 1
a3088 1
					   dependency_list, dependencies_used, textlow_not_set);
d3100 10
a3109 10
	 table overlaps any other partial symbol table.
	 We cannot assume a reordered objfile if a partial symbol table
	 is contained within another partial symbol table, as partial symbol
	 tables for include files with executable code are contained
	 within the partial symbol table for the including source file,
	 and we do not want to flag the objfile reordered for these cases.

	 This strategy works well for Irix-5.2 shared libraries, but we
	 might have to use a more elaborate (and slower) algorithm for
	 other cases.  */
d3116 10
a3125 10
	    {
	      if (save_pst != pst
		  && save_pst->textlow >= pst->textlow
		  && save_pst->textlow < pst->texthigh
		  && save_pst->texthigh > pst->texthigh)
		{
		  objfile->flags |= OBJF_REORDERED;
		  break;
		}
	    }
d3135 1
a3135 1
      if (pst == (struct partial_symtab *)NULL)
d3143 1
a3143 1
	 for source files or a reverse .h -> .c dependency for header files.  */
d3169 1
a3169 1
	  if (fdr_to_pst[rh].pst == (struct partial_symtab *)NULL)
d3196 2
a3197 2
  void (* const swap_sym_in) PARAMS ((bfd *, PTR, SYMR *))
    = debug_swap->swap_sym_in;
d3199 1
a3199 1
		  + ((fh->isymBase + cur_sdx + 1) * external_sym_size));
d3210 6
a3215 6
	 and its auxiliary index is indexNil or its auxiliary entry
	 is a plain btNil or btVoid.
	 Alpha cc -migrate enums are recognized by a zero index and
	 a zero symbol value.
	 DU 4.0 cc enums are recognized by a member type of btEnum without
	 qualifiers and a zero symbol value.  */
d3248 1
a3248 1
	 in psymtabs, just in symtabs.  */
d3397 2
a3398 2
		 should be harmless, so keep process_one_symbol from
		 complaining about them.  */
d3415 3
a3417 3
		    ((struct mips_extra_func_info *)
		     obstack_alloc (&current_objfile->symbol_obstack,
				    sizeof (struct mips_extra_func_info)));
d3440 1
a3440 1
		  valu += ANOFFSET (pst->section_offsets, SECT_OFF_TEXT);
d3451 1
a3451 1
      st = end_symtab (pst->texthigh, pst->objfile, SECT_OFF_TEXT);
d3455 1
a3455 1
	 We must do this before parse_procedure calls lookup_symbol.  */
d3459 4
a3462 4
	 be necessary for stabs symtabs.  And as sort_blocks modifies the
	 start address of the GLOBAL_BLOCK to the FIRST_LOCAL_BLOCK,
	 it did the wrong thing if the first procedure in a file was
	 generated via asm statements.  */
d3488 1
a3488 1
		 sorted.  */
d3566 1
a3566 1
				sym_ptr, fh->fBigendian, pst->section_offsets);
d3621 2
a3622 2
	 XXX use the global list to speed up things here. how?
	 FIXME, Maybe quit once we have found the right number of ext's? */
d3634 1
a3634 1
	parse_external (ext_ptr, fh->fBigendian, pst->section_offsets);
d3637 2
a3638 2
	 The alpha has an undefined symbol for every symbol that is
	 from a shared library, so tell the user only if verbose is on.  */
d3652 1
a3652 1
      /* Sort the symbol table now, we are done adding symbols to it.*/
d3722 1
a3722 1
  *tpp = (struct type *)NULL;
d3786 1
a3786 1
      && (sh.st != stBlock || !SC_IS_COMMON(sh.sc)))
d3811 4
a3814 4
		defined in this compilation unit.
		For these the type will be void. This is a bad design decision
		as cross referencing across compilation units is impossible
		due to the missing name.
d3816 3
a3818 3
		are defined later in this file or in another file in the same
		compilation unit. Irix5 cc uses a stIndirect symbol for this.
		Simply cross reference those again to get the true type.
d3833 1
a3833 1
    	      *pname = "<undefined>";
d3848 6
a3853 6
		 call cross_ref till we get a non typedef'ed type.
		 FIXME: This is not correct behaviour, but gdb currently
		 cannot handle typedefs without type copying. Type
		 copying is impossible as we might have mutual forward
		 references between two files and the copied type would not
		 get filled in when we later parse its definition.  */
d3857 1
a3857 1
				 (int *)NULL,
d3883 1
a3883 1
			     (int *)NULL,
d3956 1
a3956 1
		   BLOCK_NSYMS(b) is larger than its current size.  */
d3961 2
a3962 2
	 original block.  shrink_block has already done this
	 for the blockvector and BLOCK_FUNCTION.  */
d4126 1
a4126 1
				 &objfile -> symbol_obstack);
d4133 1
a4133 1
new_psymtab (name, objfile, section_offsets)
a4135 1
     struct section_offsets *section_offsets;
d4140 1
a4140 1
  psymtab->section_offsets = section_offsets;
d4240 1
a4240 1
	   the block`s function and inferior blocks */
d4289 1
a4289 1
elfmdebug_build_psymtabs (objfile, swap, sec, section_offsets)
a4292 1
     struct section_offsets *section_offsets;
d4305 1
a4305 1
  mdebug_build_psymtabs (objfile, swap, info, section_offsets);
d4392 2
a4393 2
      ((struct mips_extra_func_info *)
       xzalloc (sizeof (struct mips_extra_func_info)));
d4426 1
a4426 1
#endif	/* TM_MIPS_H */
d4487 1
a4487 1
  mdebug_type_unsigned_long_long_64 = 
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d991 20
a1010 22
		  {
		    /* If the type of the member is Nil (or Void),
		       without qualifiers, assume the tag is an
		       enumeration.
		       Alpha cc -migrate enums are recognized by a zero
		       index and a zero symbol value.
		       DU 4.0 cc enums are recognized by a member type of
		       btEnum without qualifiers and a zero symbol value.  */
		    if (tsym.index == indexNil
			|| (tsym.index == 0 && sh->value == 0))
		      type_code = TYPE_CODE_ENUM;
		    else
		      {
			(*debug_swap->swap_tir_in) (bigend,
						    &ax[tsym.index].a_ti,
						    &tir);
			if ((tir.bt == btNil || tir.bt == btVoid
			     || (tir.bt == btEnum && sh->value == 0))
			    && tir.tq0 == tqNil)
			  type_code = TYPE_CODE_ENUM;
		      }
		  }
d1093 4
a1096 6
	  {
	    if (nfields > 1 && max_value == 0)
	      type_code = TYPE_CODE_UNION;
	    else
	      type_code = TYPE_CODE_STRUCT;
	  }
@


1.1.1.3
log
@import gdb-1999-05-25 snapshot
@
text
@a90 1
extern void _initialize_mdebugread PARAMS ((void));
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d8 1
a8 1
   This file is part of GDB.
d10 13
a22 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d62 4
a65 6
typedef struct mips_extra_func_info
  {
    long numargs;
    PDR pdr;
  }
 *mips_extra_func_info_t;
d104 1
a105 1

d110 14
a123 14
  {
    /* Index of the FDR that this psymtab represents.  */
    int fdr_idx;
    /* The BFD that the psymtab was created from.  */
    bfd *cur_bfd;
    const struct ecoff_debug_swap *debug_swap;
    struct ecoff_debug_info *debug_info;
    struct mdebug_pending **pending_list;
    /* Pointer to external symbols for this file.  */
    EXTR *extern_tab;
    /* Size of extern_tab.  */
    int extern_count;
    enum language pst_language;
  };
d144 1
a145 1

d335 1
a335 1
  is_pending_symbol PARAMS ((FDR *, char *));
d344 1
a344 1
  fdr_name PARAMS ((FDR *));
d357 1
a357 1
* get_rfd PARAMS ((int, int));
d367 1
a367 1
  new_symbol PARAMS ((char *));
d370 1
a370 1
  new_type PARAMS ((char *));
d373 1
a373 1
  new_block PARAMS ((int));
d376 1
a376 1
  new_symtab PARAMS ((char *, int, int, struct objfile *));
d379 1
a379 1
  new_linetable PARAMS ((int));
d382 1
a382 1
  new_bvect PARAMS ((int));
d388 1
a388 1
  parse_type PARAMS ((int, union aux_ext *, unsigned int, int *, int, char *));
d391 2
a392 2
  mylookup_symbol PARAMS ((char *, struct block *, namespace_enum,
			   enum address_class));
d395 1
a395 1
  shrink_block PARAMS ((struct block *, struct symtab *));
d398 1
a398 1
  xzalloc PARAMS ((unsigned int));
d407 1
a407 1
  new_psymtab PARAMS ((char *, struct objfile *, struct section_offsets *));
d422 1
a422 1
  shrink_linetable PARAMS ((struct linetable *));
d428 1
a428 1
  mdebug_next_symbol_text PARAMS ((struct objfile *));
d495 4
a498 4
			      ((char *) debug_info->external_rfd
			       + ((f->rfdBase + rf)
				  * debug_swap->external_rfd_size)),
			      &rfd);
d557 1
a557 1
			   objfile->name);
d582 19
a600 19
  {
    struct parse_stack *next, *prev;
    struct symtab *cur_st;	/* Current symtab. */
    struct block *cur_block;	/* Block in it. */

    /* What are we parsing.  stFile, or stBlock are for files and
       blocks.  stProc or stStaticProc means we have seen the start of a
       procedure, but not the start of the block within in.  When we see
       the start of that block, we change it to stNil, without pushing a
       new block, i.e. stNil means both a procedure and a block.  */

    int blocktype;

    int maxsyms;		/* Max symbols in this block. */
    struct type *cur_type;	/* Type we parse fields for. */
    int cur_field;		/* Field number in cur_type. */
    CORE_ADDR procadr;		/* Start addres of this procedure */
    int numargs;		/* Its argument count */
  }
d726 2
a727 2
  void (*const swap_sym_in) PARAMS ((bfd *, PTR, SYMR *)) =
  debug_swap->swap_sym_in;
d750 4
a753 4
         The value of a stEnd symbol is the displacement from the
         corresponding start symbol value.
         The value of a stBlock symbol is the displacement from the
         procedure address.  */
d787 1
a787 1
      if (SC_IS_COMMON (sh->sc))
d818 1
a818 1
      if (SC_IS_UNDEF (sh->sc)
d841 1
a841 1
	  SYMBOL_CLASS (s) = LOC_REGPARM;
d846 1
a846 1
	  SYMBOL_CLASS (s) = LOC_REF_ARG;
d850 1
a850 1
	  SYMBOL_CLASS (s) = LOC_REGPARM_ADDR;
d855 1
a855 1
	  SYMBOL_CLASS (s) = LOC_ARG;
d878 1
a878 1
      if (SC_IS_UNDEF (sh->sc) || sh->sc == scNil)
d883 1
a883 1
	  if (STREQ (name, "malloc") && t->code == TYPE_CODE_VOID)
d886 9
a894 9
	         when linking against a malloc without debugging
	         symbols, its read as a function returning void---this
	         is bad because it means we cannot call functions with
	         string arguments interactively; i.e., "call
	         printf("howdy\n")" would fail with the error message
	         "program has no memory available".  To avoid this, we
	         patch up the type and make it void*
	         instead. (davidm@@azstarnet.com)
	       */
d927 1
a927 1
      if (SC_IS_UNDEF (sh->sc) || sh->sc == scNil)
d940 1
a940 1
         They all share a common set of local variables, defined here.  */
d961 1
a961 1
	if (sh->sc != scInfo && !SC_IS_COMMON (sh->sc))
d1027 1
a1027 1
		  if (tsym.sc == scVariant);	/*UNIMPLEMENTED */
d1032 3
a1034 3
		         struct.  Skip over the fields of the inner
		         struct.  The -1 is because the for loop will
		         increment ext_tsym.  */
d1216 1
a1216 1
         is the displacement from procedure start */
d1220 2
a1221 2
         procedure.  This allows the LOC_BLOCK symbol to point to the
         block with the local variables, so funcname::var works.  */
d1238 1
a1238 1
      if (sh->sc == scInfo || SC_IS_COMMON (sh->sc))
d1290 1
a1290 1
	         type.  Set that from the type of the parameter symbols. */
d1300 1
a1300 1

d1357 1
a1357 1
         skip them.  */
d1364 1
a1364 1
         are handled by cross_ref, skip them.  */
d1372 1
a1372 1
	  t = parse_type (cur_fd, ax, sh->index, (int *) NULL, bigend, name);
d1379 14
a1392 14
         declarations. These should not go into the symbol table and
         TYPE_NAME should not be set for them.
         They can't be distinguished from an intentional typedef to
         the same name however:
         x.h:
         struct x { int ix; int jx; };
         struct xx;
         x.c:
         typedef struct x x;
         struct xx {int ixx; int jxx; };
         generates a cross referencing stTypedef for x and xx.
         The user visible effect of this is that the type of a pointer
         to struct foo sometimes is given as `foo *' instead of `struct foo *'.
         The problem is fixed with alpha cc and Irix5 cc.  */
d1395 1
a1395 1
         is safe to omit it from the symbol table.  */
d1409 1
a1409 1
	      || (TYPE_CODE (SYMBOL_TYPE (s)) != TYPE_CODE_STRUCT
d1416 12
a1427 12
	         foo" or "function returning foo", we better not set
	         the TYPE_NAME.  If the program contains "typedef char
	         *caddr_t;", we don't want all variables of type char
	         * to print as caddr_t.  This is not just a
	         consequence of GDB's type management; CC and GCC (at
	         least through version 2.4) both output variables of
	         either type char * or caddr_t with the type
	         refering to the stTypedef symbol for caddr_t.  If a future
	         compiler cleans this up it GDB is not ready for it
	         yet, but if it becomes ready we somehow need to
	         disable this check (without breaking the PCC/GCC2.4
	         case).
d1429 1
a1429 1
	         Sigh.
d1431 2
a1432 2
	         Fortunately, this check seems not to be necessary
	         for anything except pointers or functions.  */
d1476 5
a1480 5
    &mdebug_type_void,		/* btNil */
    &mdebug_type_adr_32,	/* btAdr */
    &mdebug_type_char,		/* btChar */
    &mdebug_type_unsigned_char,	/* btUChar */
    &mdebug_type_short,		/* btShort */
d1482 1
a1482 1
    &mdebug_type_int_32,	/* btInt */
d1484 1
a1484 1
    &mdebug_type_long_32,	/* btLong */
d1486 9
a1494 9
    &mdebug_type_float,		/* btFloat */
    &mdebug_type_double,	/* btDouble */
    0,				/* btStruct */
    0,				/* btUnion */
    0,				/* btEnum */
    0,				/* btTypedef */
    0,				/* btRange */
    0,				/* btSet */
    &mdebug_type_complex,	/* btComplex */
d1496 11
a1506 11
    0,				/* btIndirect */
    &mdebug_type_fixed_dec,	/* btFixedDec */
    &mdebug_type_float_dec,	/* btFloatDec */
    &mdebug_type_string,	/* btString */
    0,				/* btBit */
    0,				/* btPicture */
    &mdebug_type_void,		/* btVoid */
    0,				/* DEC C++:  Pointer to member */
    0,				/* DEC C++:  Virtual function table */
    0,				/* DEC C++:  Class (Record) */
    &mdebug_type_long_64,	/* btLong64  */
d1508 4
a1511 4
    &mdebug_type_long_long_64,	/* btLongLong64  */
    &mdebug_type_unsigned_long_long_64,		/* btULongLong64 */
    &mdebug_type_adr_64,	/* btAdr64 */
    &mdebug_type_int_64,	/* btInt64  */
d1587 2
a1588 2
         corrupt the TIR.  */
      if (bs == (int *) NULL)
d1603 1
a1603 1
	*bs = width;
d1634 1
a1634 1
		    rn->index, (int *) NULL, xref_fh->fBigendian, sym_name);
d1644 2
a1645 2
  /* btSet (I think) implies that the name is a tag name, not a typedef
     name.  This apparently is a MIPS extension for C sets.  */
d1656 1
a1656 1
         dereference them.  */
d1662 2
a1663 2
         Any type may be returned from cross_ref if file indirect entries
         are corrupted.  */
d1691 1
a1691 1
	     (.Fxx or .xxfake or empty) for unnamed struct/union/enums.  */
d1697 1
a1697 1
					    &current_objfile->type_obstack);
d1715 2
a1716 2
         Any type may be returned from cross_ref if file indirect entries
         are corrupted.  */
d1755 1
a1755 1
					    &current_objfile->type_obstack);
d1759 1
a1759 1
					    &current_objfile->type_obstack);
d1794 1
a1794 1

d1857 1
a1857 1
         else due to corrupt aux entries.  */
d1878 12
a1889 12
         here if the TYPE_LENGTH of the target type was zero.
         This happens for a `pointer to an array of anonymous structs',
         but in this case the array element bitsize is also zero,
         so nothing is gained.
         And we used to check the TYPE_LENGTH of the target type against
         the supplied array element bitsize.
         gcc causes a mismatch for `pointer to array of object',
         since the sdb directives it uses do not have a way of
         specifying the bitsize, but it does no harm (the
         TYPE_LENGTH should be correct) and we should be able to
         ignore the erroneous bitsize from the auxiliary entry safely.
         dbx seems to ignore it too.  */
d1892 1
a1892 1
         problem.  */
d1955 1
a1955 1

d1981 2
a1982 2
         but also if we are looking up a non-mangled name which happens to
         match the name of a mangled function.  */
d1984 3
a1986 3
         If the pdr is for a static function and if a global function with
         the same name exists, lookup_symbol will eventually read in the symtab
         for the global function and clobber cur_fdr.  */
d2025 1
a2025 1
         argument is no longer passed in.  */
d2041 9
a2049 9
         procedure descriptor in e->pdr.adr.
         As the address in the procedure descriptor is usually relative,
         we would have to relocate e->pdr.adr with cur_fdr->adr and
         ANOFFSET (pst->section_offsets, SECT_OFF_TEXT).
         Unfortunately cur_fdr->adr and e->pdr.adr are both absolute
         in shared libraries on some systems, and on other systems
         e->pdr.adr is sometimes offset by a bogus value.
         To work around these problems, we replace e->pdr.adr with
         the start address of the function.  */
d2053 1
a2053 1
         to make backtrace through setjmp work.  */
d2077 1
a2077 1

d2094 1
a2094 1

d2127 1
a2127 1
  if (SC_IS_UNDEF (es->asym.sc) || es->asym.sc == scNil)
d2167 8
a2174 8
         If they are from objects compiled without -g, their index will
         be indexNil, and the symbol definition from the minimal symbol
         is preferrable (yielding a function returning int instead of int).
         If the index points to a local procedure symbol, the local
         symbol already provides the correct type.
         Note that the index of the external procedure symbol points
         to the local procedure symbol in the local symbol table, and
         _not_ to the auxiliary symbol info.  */
d2179 2
a2180 2
         ignore them.  */
      if (SC_IS_COMMON (es->asym.sc))
d2184 1
a2184 1
         anyways by parse_symbol().  */
d2231 1
a2231 1
         this procedure.  */
d2234 1
a2234 1
	halt = base + pr[1].cbLineOffset;
d2236 1
a2236 1
	halt = base + fh->cbLine;
d2242 1
a2242 1
      for (lineno = pr->lnLow; base < halt;)
d2281 6
a2286 6
  void (*const swap_ext_in) PARAMS ((bfd *, PTR, EXTR *))
  = debug_swap->swap_ext_in;
  void (*const swap_sym_in) PARAMS ((bfd *, PTR, SYMR *))
  = debug_swap->swap_sym_in;
  void (*const swap_rfd_in) PARAMS ((bfd *, PTR, RFDT *))
  = debug_swap->swap_rfd_in;
d2424 2
a2425 2
     (assumes ECOFF symtab is a subset of the ELF symtab;
     assumes no side-effects result from ignoring ECOFF symbol)
d2427 3
a2429 3
     symbols fails
     (inefficient; 
     assumes no side-effects result from ignoring ECOFF symbol)
d2431 3
a2433 3
     during relocation, then modify "uniqify" phase to merge and 
     eliminate the duplicate symbol
     (highly inefficient)
d2439 7
a2445 7
  /* Pass 2 over external syms: fill in external symbols */
  ext_in = ext_block;
  ext_in_end = ext_in + hdr->iextMax;
  for (; ext_in < ext_in_end; ext_in++)
    {
      enum minimal_symbol_type ms_type = mst_text;
      CORE_ADDR svalue = ext_in->asym.value;
d2447 13
a2459 13
      /* The Irix 5 native tools seem to sometimes generate bogus
         external symbols.  */
      if (ext_in->ifd < -1 || ext_in->ifd >= hdr->ifdMax)
	{
	  complain (&bad_ext_ifd_complaint, ext_in->ifd, hdr->ifdMax);
	  continue;
	}
      if (ext_in->asym.iss < 0 || ext_in->asym.iss >= hdr->issExtMax)
	{
	  complain (&bad_ext_iss_complaint, ext_in->asym.iss,
		    hdr->issExtMax);
	  continue;
	}
d2461 2
a2462 2
      extern_tab[fdr_to_pst[ext_in->ifd].globals_offset
		 + fdr_to_pst[ext_in->ifd].n_globals++] = *ext_in;
d2465 2
a2466 2
      if (SC_IS_UNDEF (ext_in->asym.sc) || ext_in->asym.sc == scNil)
	continue;
d2468 3
d2472 61
a2532 21
      /* Pass 3 over files, over local syms: fill in static symbols */
      name = debug_info->ssext + ext_in->asym.iss;

      /* Process ECOFF Symbol Types and Storage Classes */
      switch (ext_in->asym.st)
	{
	case stProc:
	  /* Beginnning of Procedure */
	  svalue += ANOFFSET (section_offsets, SECT_OFF_TEXT);
	  break;
	case stStaticProc:
	  /* Load time only static procs */
	  ms_type = mst_file_text;
	  svalue += ANOFFSET (section_offsets, SECT_OFF_TEXT);
	  break;
	case stGlobal:
	  /* External symbol */
	  if (SC_IS_COMMON (ext_in->asym.sc))
	    {
	      /* The value of a common symbol is its size, not its address.
	         Ignore it.  */
d2534 8
a2541 51
	    }
	  else if (SC_IS_DATA (ext_in->asym.sc))
	    {
	      ms_type = mst_data;
	      svalue += ANOFFSET (section_offsets, SECT_OFF_DATA);
	    }
	  else if (SC_IS_BSS (ext_in->asym.sc))
	    {
	      ms_type = mst_bss;
	      svalue += ANOFFSET (section_offsets, SECT_OFF_BSS);
	    }
	  else
	    ms_type = mst_abs;
	  break;
	case stLabel:
	  /* Label */
	  if (SC_IS_TEXT (ext_in->asym.sc))
	    {
	      ms_type = mst_file_text;
	      svalue += ANOFFSET (section_offsets, SECT_OFF_TEXT);
	    }
	  else if (SC_IS_DATA (ext_in->asym.sc))
	    {
	      ms_type = mst_file_data;
	      svalue += ANOFFSET (section_offsets, SECT_OFF_DATA);
	    }
	  else if (SC_IS_BSS (ext_in->asym.sc))
	    {
	      ms_type = mst_file_bss;
	      svalue += ANOFFSET (section_offsets, SECT_OFF_BSS);
	    }
	  else
	    ms_type = mst_abs;
	  break;
	case stLocal:
	case stNil:
	  /* The alpha has the section start addresses in stLocal symbols
	     whose name starts with a `.'. Skip those but complain for all
	     other stLocal symbols.
	     Irix6 puts the section start addresses in stNil symbols, skip
	     those too. */
	  if (name[0] == '.')
	    continue;
	  /* Fall through.  */
	default:
	  ms_type = mst_unknown;
	  complain (&unknown_ext_complaint, name);
	}
      if (!ECOFF_IN_ELF (cur_bfd))
	prim_record_minimal_symbol (name, svalue, ms_type, objfile);
    }
d2559 1
a2559 1
         file header and relocate it, except for Irix 5.2 zero fh->adr.  */
d2590 9
a2598 9
         with native cc and g++ will set the language to C).
         Otherwise we have to deduce the language from the filename.
         Native ecoff has every header file in a separate FDR, so
         deduce_language_from_filename will return language_unknown for
         a header file, which is not what we want.
         But the FDRs for the header files are after the FDR for the source
         file, so we can assign the language of the source file to the
         following header files. Then we save the language in the private
         pst data so that we can reuse it when building symtabs.  */
d2617 5
a2621 5
         This symbol is emitted by mips-tfile to signal that the
         current object file uses encapsulated stabs instead of mips
         ecoff for local symbols.  (It is the second symbol because
         the first symbol is the stFile used to signal the start of a
         file). */
d2642 1
a2642 1
			    + (fh->isymBase + cur_sdx) * external_sym_size),
d2651 1
a2651 1

d2679 1
a2679 1
			  /* Kludge for Irix 5.2 zero fh->adr.  */
d2681 1
a2681 1
			  && (pst->textlow == 0 || procaddr < pst->textlow))
d2703 1
a2703 1
			  sh.value += ANOFFSET (section_offsets, SECT_OFF_DATA);
d2717 1
a2717 1
			  sh.value += ANOFFSET (section_offsets, SECT_OFF_BSS);
d2734 1
a2734 1
		while (stabstring[len - 1] == '\\')
d2748 1
a2748 1
				     + (fh->isymBase + cur_sdx)
d2756 1
a2756 1
		     && stabstring != debug_info->ss + fh->issBase + sh.iss)
d2776 1
a2776 1
		if (stabstring
d2780 1
a2780 1
	      /* end - Handle continuation */
d2803 1
a2803 1
	      if (SC_IS_UNDEF (sh.sc) || sh.sc == scNil
d2866 1
a2866 1
				    0, sh.value, psymtab_language, objfile);
d2871 1
a2871 1
				    0, sh.value, psymtab_language, objfile);
d2877 1
a2877 1
		         with the MIPS compiler.  FIXME -- pull later.  */
d2915 1
a2915 1
		  if (SC_IS_DATA (sh.sc))
d2930 1
a2930 1
		case stIndirect:	/* Irix5 forward declaration */
d2934 1
a2934 1
		case stTypedef:	/* Typedef */
d2949 1
a2949 1
		case stBlock:	/* { }, str, un, enum */
d2953 1
a2953 1
		       || SC_IS_COMMON (sh.sc))
d3021 1
a3021 1
	      if (SC_IS_UNDEF (psh->sc) || psh->sc == scNil)
d3066 1
a3066 1
		  if (SC_IS_COMMON (psh->sc))
d3082 1
a3082 1
         empty and put on the free list.  */
d3084 1
a3084 1
					psymtab_include_list, includes_used,
d3086 1
a3086 1
		       dependency_list, dependencies_used, textlow_not_set);
d3098 10
a3107 10
         table overlaps any other partial symbol table.
         We cannot assume a reordered objfile if a partial symbol table
         is contained within another partial symbol table, as partial symbol
         tables for include files with executable code are contained
         within the partial symbol table for the including source file,
         and we do not want to flag the objfile reordered for these cases.

         This strategy works well for Irix-5.2 shared libraries, but we
         might have to use a more elaborate (and slower) algorithm for
         other cases.  */
d3114 10
a3123 10
	  {
	    if (save_pst != pst
		&& save_pst->textlow >= pst->textlow
		&& save_pst->textlow < pst->texthigh
		&& save_pst->texthigh > pst->texthigh)
	      {
		objfile->flags |= OBJF_REORDERED;
		break;
	      }
	  }
d3133 1
a3133 1
      if (pst == (struct partial_symtab *) NULL)
d3141 1
a3141 1
         for source files or a reverse .h -> .c dependency for header files.  */
d3167 1
a3167 1
	  if (fdr_to_pst[rh].pst == (struct partial_symtab *) NULL)
d3194 2
a3195 2
  void (*const swap_sym_in) PARAMS ((bfd *, PTR, SYMR *))
  = debug_swap->swap_sym_in;
d3197 1
a3197 1
		   + ((fh->isymBase + cur_sdx + 1) * external_sym_size));
d3208 6
a3213 6
         and its auxiliary index is indexNil or its auxiliary entry
         is a plain btNil or btVoid.
         Alpha cc -migrate enums are recognized by a zero index and
         a zero symbol value.
         DU 4.0 cc enums are recognized by a member type of btEnum without
         qualifiers and a zero symbol value.  */
d3246 1
a3246 1
         in psymtabs, just in symtabs.  */
d3395 2
a3396 2
	         should be harmless, so keep process_one_symbol from
	         complaining about them.  */
d3413 3
a3415 3
		  ((struct mips_extra_func_info *)
		   obstack_alloc (&current_objfile->symbol_obstack,
				  sizeof (struct mips_extra_func_info)));
d3453 1
a3453 1
         We must do this before parse_procedure calls lookup_symbol.  */
d3457 4
a3460 4
         be necessary for stabs symtabs.  And as sort_blocks modifies the
         start address of the GLOBAL_BLOCK to the FIRST_LOCAL_BLOCK,
         it did the wrong thing if the first procedure in a file was
         generated via asm statements.  */
d3486 1
a3486 1
	         sorted.  */
d3564 1
a3564 1
			     sym_ptr, fh->fBigendian, pst->section_offsets);
d3619 2
a3620 2
         XXX use the global list to speed up things here. how?
         FIXME, Maybe quit once we have found the right number of ext's? */
d3635 2
a3636 2
         The alpha has an undefined symbol for every symbol that is
         from a shared library, so tell the user only if verbose is on.  */
d3650 1
a3650 1
      /* Sort the symbol table now, we are done adding symbols to it. */
d3720 1
a3720 1
  *tpp = (struct type *) NULL;
d3784 1
a3784 1
      && (sh.st != stBlock || !SC_IS_COMMON (sh.sc)))
d3809 4
a3812 4
	     defined in this compilation unit.
	     For these the type will be void. This is a bad design decision
	     as cross referencing across compilation units is impossible
	     due to the missing name.
d3814 3
a3816 3
	     are defined later in this file or in another file in the same
	     compilation unit. Irix5 cc uses a stIndirect symbol for this.
	     Simply cross reference those again to get the true type.
d3831 1
a3831 1
	      *pname = "<undefined>";
d3846 6
a3851 6
	         call cross_ref till we get a non typedef'ed type.
	         FIXME: This is not correct behaviour, but gdb currently
	         cannot handle typedefs without type copying. Type
	         copying is impossible as we might have mutual forward
	         references between two files and the copied type would not
	         get filled in when we later parse its definition.  */
d3855 1
a3855 1
				 (int *) NULL,
d3881 1
a3881 1
			     (int *) NULL,
d3954 1
a3954 1
         BLOCK_NSYMS(b) is larger than its current size.  */
d3959 2
a3960 2
         original block.  shrink_block has already done this
         for the blockvector and BLOCK_FUNCTION.  */
d4124 1
a4124 1
				 &objfile->symbol_obstack);
d4239 1
a4239 1
     the block`s function and inferior blocks */
d4392 2
a4393 2
    ((struct mips_extra_func_info *)
     xzalloc (sizeof (struct mips_extra_func_info)));
d4426 1
a4426 1
#endif /* TM_MIPS_H */
d4487 1
a4487 1
  mdebug_type_unsigned_long_long_64 =
@


1.1.1.5
log
@import gdb-1999-09-08 snapshot
@
text
@d356 2
a357 1
parse_partial_symbols PARAMS ((struct objfile *));
d410 1
a410 1
  new_psymtab PARAMS ((char *, struct objfile *));
d523 1
a523 1
mdebug_build_psymtabs (objfile, swap, info)
d527 1
d551 1
a551 1
  parse_partial_symbols (objfile);
d2277 1
a2277 1
parse_partial_symbols (objfile)
d2279 1
d2366 1
a2366 1
    struct partial_symtab *pst = new_psymtab ("", objfile);
d2480 1
a2480 1
	  svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d2485 1
a2485 1
	  svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d2498 1
a2498 1
	      svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA);
d2503 1
a2503 1
	      svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS);
d2513 1
a2513 1
	      svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d2518 1
a2518 1
	      svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA);
d2523 1
a2523 1
	      svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS);
d2567 1
a2567 1
	    textlow += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d2571 1
a2571 1
      pst = start_psymtab_common (objfile, objfile->section_offsets,
d2655 1
a2655 1
		      sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d2706 1
a2706 1
			  sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA);
d2720 1
a2720 1
			  sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS);
d2772 1
a2772 1
#define START_PSYMTAB(ofile,fname,low,symoff,global_syms,static_syms)\
d2824 1
a2824 1
		    sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d2831 1
a2831 1
		  sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA);
d2835 1
a2835 1
		  sh.value += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS);
d3032 1
a3032 1
		  svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT);
d3039 1
a3039 1
		  svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_DATA);
d3043 1
a3043 1
		  svalue += ANOFFSET (objfile->section_offsets, SECT_OFF_BSS);
d3567 1
a3567 1
				sym_ptr, fh->fBigendian, pst->section_offsets);
d4134 1
a4134 1
new_psymtab (name, objfile)
d4137 1
d4142 1
a4142 1
  psymtab->section_offsets = objfile->section_offsets;
d4291 1
a4291 1
elfmdebug_build_psymtabs (objfile, swap, sec)
d4295 1
d4308 1
a4308 1
  mdebug_build_psymtabs (objfile, swap, info);
@


1.1.1.5.2.1
log
@Fix IRIX cc warnings.  Fix ui_out functions that didn't return a value.
@
text
@d2770 1
a2770 1
  (pst = save_pst)
@


