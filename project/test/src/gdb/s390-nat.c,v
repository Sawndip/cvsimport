head	1.45;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.42
	gdb_7_6-2013-04-26-release:1.42
	gdb_7_6-branch:1.42.0.2
	gdb_7_6-2013-03-12-branchpoint:1.42
	gdb_7_5_1-2012-11-29-release:1.40
	gdb_7_5-2012-08-17-release:1.40
	gdb_7_5-branch:1.40.0.2
	gdb_7_5-2012-07-18-branchpoint:1.40
	gdb_7_4_1-2012-04-26-release:1.35.2.2
	gdb_7_4-2012-01-24-release:1.35.2.2
	gdb_7_4-branch:1.35.0.2
	gdb_7_4-2011-12-13-branchpoint:1.35
	gdb_7_3_1-2011-09-04-release:1.32
	gdb_7_3-2011-07-26-release:1.32
	gdb_7_3-branch:1.32.0.4
	gdb_7_3-2011-04-01-branchpoint:1.32
	gdb_7_2-2010-09-02-release:1.32
	gdb_7_2-branch:1.32.0.2
	gdb_7_2-2010-07-07-branchpoint:1.32
	gdb_7_1-2010-03-18-release:1.31
	gdb_7_1-branch:1.31.0.2
	gdb_7_1-2010-02-18-branchpoint:1.31
	gdb_7_0_1-2009-12-22-release:1.28
	gdb_7_0-2009-10-06-release:1.28
	gdb_7_0-branch:1.28.0.4
	gdb_7_0-2009-09-16-branchpoint:1.28
	arc-sim-20090309:1.27
	msnyder-checkpoint-072509-branch:1.28.0.2
	msnyder-checkpoint-072509-branchpoint:1.28
	arc-insight_6_8-branch:1.27.0.16
	arc-insight_6_8-branchpoint:1.27
	insight_6_8-branch:1.27.0.14
	insight_6_8-branchpoint:1.27
	reverse-20081226-branch:1.27.0.12
	reverse-20081226-branchpoint:1.27
	multiprocess-20081120-branch:1.27.0.10
	multiprocess-20081120-branchpoint:1.27
	reverse-20080930-branch:1.27.0.8
	reverse-20080930-branchpoint:1.27
	reverse-20080717-branch:1.27.0.6
	reverse-20080717-branchpoint:1.27
	msnyder-reverse-20080609-branch:1.27.0.4
	msnyder-reverse-20080609-branchpoint:1.27
	drow-reverse-20070409-branch:1.21.0.2
	drow-reverse-20070409-branchpoint:1.21
	gdb_6_8-2008-03-27-release:1.27
	gdb_6_8-branch:1.27.0.2
	gdb_6_8-2008-02-26-branchpoint:1.27
	gdb_6_7_1-2007-10-29-release:1.25
	gdb_6_7-2007-10-10-release:1.25
	gdb_6_7-branch:1.25.0.2
	gdb_6_7-2007-09-07-branchpoint:1.25
	insight_6_6-20070208-release:1.20
	gdb_6_6-2006-12-18-release:1.20
	gdb_6_6-branch:1.20.0.12
	gdb_6_6-2006-11-15-branchpoint:1.20
	insight_6_5-20061003-release:1.20
	gdb-csl-symbian-6_4_50_20060226-12:1.18
	gdb-csl-sourcerygxx-3_4_4-25:1.15
	nickrob-async-20060828-mergepoint:1.20
	gdb-csl-symbian-6_4_50_20060226-11:1.18
	gdb-csl-sourcerygxx-4_1-17:1.18
	gdb-csl-20060226-branch-local-2:1.18
	gdb-csl-sourcerygxx-4_1-14:1.18
	gdb-csl-sourcerygxx-4_1-13:1.18
	gdb-csl-sourcerygxx-4_1-12:1.18
	gdb-csl-sourcerygxx-3_4_4-21:1.18
	gdb_6_5-20060621-release:1.20
	gdb-csl-sourcerygxx-4_1-9:1.18
	gdb-csl-sourcerygxx-4_1-8:1.18
	gdb-csl-sourcerygxx-4_1-7:1.18
	gdb-csl-arm-2006q1-6:1.18
	gdb-csl-sourcerygxx-4_1-6:1.18
	gdb-csl-symbian-6_4_50_20060226-10:1.18
	gdb-csl-symbian-6_4_50_20060226-9:1.18
	gdb-csl-symbian-6_4_50_20060226-8:1.18
	gdb-csl-coldfire-4_1-11:1.18
	gdb-csl-sourcerygxx-3_4_4-19:1.18
	gdb-csl-coldfire-4_1-10:1.18
	gdb_6_5-branch:1.20.0.10
	gdb_6_5-2006-05-14-branchpoint:1.20
	gdb-csl-sourcerygxx-4_1-5:1.18
	nickrob-async-20060513-branch:1.20.0.8
	nickrob-async-20060513-branchpoint:1.20
	gdb-csl-sourcerygxx-4_1-4:1.18
	msnyder-reverse-20060502-branch:1.20.0.6
	msnyder-reverse-20060502-branchpoint:1.20
	gdb-csl-morpho-4_1-4:1.18
	gdb-csl-sourcerygxx-3_4_4-17:1.18
	readline_5_1-import-branch:1.20.0.4
	readline_5_1-import-branchpoint:1.20
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.18
	gdb-csl-symbian-20060226-branch:1.18.0.6
	gdb-csl-symbian-20060226-branchpoint:1.18
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.18
	msnyder-reverse-20060331-branch:1.20.0.2
	msnyder-reverse-20060331-branchpoint:1.20
	gdb-csl-available-20060303-branch:1.18.0.4
	gdb-csl-available-20060303-branchpoint:1.18
	gdb-csl-20060226-branch:1.18.0.2
	gdb-csl-20060226-branchpoint:1.18
	gdb_6_4-20051202-release:1.15
	msnyder-fork-checkpoint-branch:1.15.0.8
	msnyder-fork-checkpoint-branchpoint:1.15
	gdb-csl-gxxpro-6_3-branch:1.15.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.15
	gdb_6_4-branch:1.15.0.4
	gdb_6_4-2005-11-01-branchpoint:1.15
	gdb-csl-arm-20051020-branch:1.15.0.2
	gdb-csl-arm-20051020-branchpoint:1.15
	msnyder-tracepoint-checkpoint-branch:1.13.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.13
	gdb-csl-arm-20050325-2005-q1b:1.13
	gdb-csl-arm-20050325-2005-q1a:1.13
	csl-arm-20050325-branch:1.13.0.2
	csl-arm-20050325-branchpoint:1.13
	gdb-post-i18n-errorwarning-20050211:1.12
	gdb-pre-i18n-errorwarning-20050211:1.12
	gdb_6_3-20041109-release:1.12
	gdb_6_3-branch:1.12.0.12
	gdb_6_3-20041019-branchpoint:1.12
	drow_intercu-merge-20040921:1.12
	drow_intercu-merge-20040915:1.12
	jimb-gdb_6_2-e500-branch:1.12.0.14
	jimb-gdb_6_2-e500-branchpoint:1.12
	gdb_6_2-20040730-release:1.12
	gdb_6_2-branch:1.12.0.10
	gdb_6_2-2004-07-10-gmt-branchpoint:1.12
	gdb_6_1_1-20040616-release:1.12
	gdb_6_1-2004-04-05-release:1.12
	drow_intercu-merge-20040402:1.12
	drow_intercu-merge-20040327:1.12
	ezannoni_pie-20040323-branch:1.12.0.8
	ezannoni_pie-20040323-branchpoint:1.12
	cagney_tramp-20040321-mergepoint:1.12
	cagney_tramp-20040309-branch:1.12.0.6
	cagney_tramp-20040309-branchpoint:1.12
	gdb_6_1-branch:1.12.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.12
	drow_intercu-20040221-branch:1.12.0.2
	drow_intercu-20040221-branchpoint:1.12
	cagney_bfdfile-20040213-branch:1.9.0.12
	cagney_bfdfile-20040213-branchpoint:1.9
	drow-cplus-merge-20040208:1.9
	carlton_dictionary-20040126-merge:1.9
	cagney_bigcore-20040122-branch:1.9.0.10
	cagney_bigcore-20040122-branchpoint:1.9
	drow-cplus-merge-20040113:1.9
	drow-cplus-merge-20031224:1.9
	drow-cplus-merge-20031220:1.9
	carlton_dictionary-20031215-merge:1.9
	drow-cplus-merge-20031214:1.9
	carlton-dictionary-20031111-merge:1.9
	gdb_6_0-2003-10-04-release:1.9
	kettenis_sparc-20030918-branch:1.9.0.8
	kettenis_sparc-20030918-branchpoint:1.9
	carlton_dictionary-20030917-merge:1.9
	ezannoni_pie-20030916-branchpoint:1.9
	ezannoni_pie-20030916-branch:1.9.0.6
	cagney_x86i386-20030821-branch:1.9.0.4
	cagney_x86i386-20030821-branchpoint:1.9
	carlton_dictionary-20030805-merge:1.9
	carlton_dictionary-20030627-merge:1.9
	gdb_6_0-branch:1.9.0.2
	gdb_6_0-2003-06-23-branchpoint:1.9
	jimb-ppc64-linux-20030613-branch:1.8.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.8
	cagney_convert-20030606-branch:1.8.0.2
	cagney_convert-20030606-branchpoint:1.8
	cagney_writestrings-20030508-branch:1.7.0.10
	cagney_writestrings-20030508-branchpoint:1.7
	jimb-ppc64-linux-20030528-branch:1.7.0.8
	jimb-ppc64-linux-20030528-branchpoint:1.7
	carlton_dictionary-20030523-merge:1.7
	cagney_fileio-20030521-branch:1.7.0.6
	cagney_fileio-20030521-branchpoint:1.7
	kettenis_i386newframe-20030517-mergepoint:1.7
	jimb-ppc64-linux-20030509-branch:1.7.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.7
	kettenis_i386newframe-20030504-mergepoint:1.7
	carlton_dictionary-20030430-merge:1.7
	kettenis_i386newframe-20030419-branch:1.7.0.2
	kettenis_i386newframe-20030419-branchpoint:1.7
	carlton_dictionary-20030416-merge:1.7
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.28
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.26
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.24
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.22
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.20
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.18
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.16
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030203-mergepoint:1.6
	interps-20030202-branch:1.6.0.14
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.12
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.6
	carlton_dictionary-20021115-merge:1.6
	kseitz_interps-20021105-merge:1.6
	kseitz_interps-20021103-merge:1.6
	drow-cplus-merge-20021020:1.6
	drow-cplus-merge-20021025:1.6
	carlton_dictionary-20021025-merge:1.6
	carlton_dictionary-20021011-merge:1.6
	drow-cplus-branch:1.6.0.10
	drow-cplus-branchpoint:1.6
	kseitz_interps-20020930-merge:1.6
	carlton_dictionary-20020927-merge:1.6
	carlton_dictionary-branch:1.6.0.8
	carlton_dictionary-20020920-branchpoint:1.6
	gdb_5_3-branch:1.6.0.6
	gdb_5_3-2002-09-04-branchpoint:1.6
	kseitz_interps-20020829-merge:1.6
	cagney_sysregs-20020825-branch:1.6.0.4
	cagney_sysregs-20020825-branchpoint:1.6
	readline_4_3-import-branch:1.6.0.2
	readline_4_3-import-branchpoint:1.6
	gdb_5_2_1-2002-07-23-release:1.5.2.1
	kseitz_interps-20020528-branch:1.5.0.8
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.6
	cagney_regbuf-20020515-branchpoint:1.5
	jimb-macro-020506-branch:1.5.0.4
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.5
	gdb_5_2-branch:1.5.0.2
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.1.4.1
	gdb_5_1_0_1-2002-01-03-release:1.1.4.1
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.4.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.4.1.0.2
	gdb_5_1-2001-11-21-release:1.1.4.1
	gdb_5_1-2001-07-29-branch:1.1.0.4
	gdb_s390-2001-09-26-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.45
date	2013.09.30.11.50.12;	author luisgpm;	state Exp;
branches;
next	1.44;

1.44
date	2013.09.13.14.17.29;	author uweigand;	state Exp;
branches;
next	1.43;

1.43
date	2013.09.13.14.11.15;	author uweigand;	state Exp;
branches;
next	1.42;

1.42
date	2013.01.01.06.32.50;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2012.11.09.19.58.00;	author tromey;	state Exp;
branches;
next	1.40;

1.40
date	2012.03.05.19.05.09;	author brobecke;	state Exp;
branches;
next	1.39;

1.39
date	2012.01.04.08.17.10;	author brobecke;	state Exp;
branches;
next	1.38;

1.38
date	2012.01.02.15.37.33;	author brobecke;	state Exp;
branches;
next	1.37;

1.37
date	2011.12.17.09.43.53;	author jkratoch;	state Exp;
branches;
next	1.36;

1.36
date	2011.12.14.17.20.31;	author palves;	state Exp;
branches;
next	1.35;

1.35
date	2011.12.06.14.14.47;	author uweigand;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2011.11.30.16.06.54;	author uweigand;	state Exp;
branches;
next	1.33;

1.33
date	2011.10.07.17.15.15;	author palves;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.07.16.15.16;	author bauermann;	state Exp;
branches;
next	1.31;

1.31
date	2010.01.04.15.02.59;	author uweigand;	state Exp;
branches;
next	1.30;

1.30
date	2009.11.27.16.11.59;	author uweigand;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.11.19.38.34;	author msnyder;	state Exp;
branches;
next	1.28;

1.28
date	2009.02.23.00.03.50;	author palves;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.07.06.36.57;	author deuling;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.01.00.22.50;	author drow;	state Exp;
branches;
next	1.25;

1.25
date	2007.08.23.18.08.37;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.13.17.30.01;	author uweigand;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.06.14.34.38;	author uweigand;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.06.14.32.31;	author uweigand;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.28.21.41.02;	author uweigand;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.29.18.27.00;	author uweigand;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.24.23.08.16;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.08.07.00.06;	author woodzltc;	state Exp;
branches;
next	1.17;

1.17
date	2006.02.08.06.43.00;	author woodzltc;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.17.22.34.02;	author eliz;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.11.21.54.58;	author uweigand;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.10.18.11.04;	author drow;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.11.18.13.52;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.18.04.17.35;	author jimb;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.18.03.47.35;	author jimb;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.18.03.42.50;	author jimb;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.20.13.57.28;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.03.05.36.52;	author jimb;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.14.14.21.07;	author ezannoni;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.15.16.50.51;	author cagney;	state Exp;
branches
	1.6.8.1
	1.6.10.1;
next	1.5;

1.5
date	2001.11.06.22.18.13;	author jimb;	state Exp;
branches
	1.5.2.1
	1.5.8.1;
next	1.4;

1.4
date	2001.11.06.21.28.29;	author jimb;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.01.02.53.05;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.13.22.13.35;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.27.00.13.29;	author cagney;	state dead;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.35.2.1
date	2012.01.06.04.18.54;	author brobecke;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2012.01.06.04.43.29;	author brobecke;	state Exp;
branches;
next	;

1.6.8.1
date	2003.04.16.19.56.54;	author carlton;	state Exp;
branches;
next	1.6.8.2;

1.6.8.2
date	2003.06.27.21.50.08;	author carlton;	state Exp;
branches;
next	;

1.6.10.1
date	2003.12.14.20.27.29;	author drow;	state Exp;
branches;
next	;

1.5.2.1
date	2002.07.15.16.51.09;	author cagney;	state Exp;
branches;
next	;

1.5.8.1
date	2002.07.22.21.47.02;	author kseitz;	state Exp;
branches;
next	;

1.1.2.1
date	2001.09.27.00.13.29;	author cagney;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.10.13.21.02.07;	author cagney;	state Exp;
branches;
next	;

1.1.4.1
date	2001.10.13.22.13.05;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.45
log
@	* aarch64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* aix-thread.c (BUILD_THREAD, BUILD_LWP): Remove.
	Replace BUILD_THREAD with ptid_build.
	Replace BUILD_LWP with ptid_build.
	Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* alphabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* amd64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* amd64bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* arm-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* armnbsd-nat.c: Replace PIDGET with ptid_get_pid.
	* auxv.c: Likewise.
	* breakpoint.c: Likewise.
	* common/ptid.c (ptid_is_pid): Condense check for
	null_ptid and minus_one_ptid.
	(ptid_lwp_p): New function.
	(ptid_tid_p): New function.
	* common/ptid.h: Update comments for accessors.
	(ptid_lwp_p): New prototype.
	(ptid_tid_p): New prototype.
	* defs.h (PIDGET, TIDGET, MERGEPID): Do not define.
	* gcore.c: Replace PIDGET with ptid_get_pid.
	* gdbthread.h: Likewise.
	* gnu-nat.c: Likewise.
	* hppa-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* hppabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* hppanbsd-nat.c: Likewise.
	* i386-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* i386bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* ia64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	* infcmd.c: Likewise.
	* inferior.h: Likewise.
	* inflow.c: Likewise.
	* infrun.c: Likewise.
	* linux-fork.c: Likewise.
	* linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace GET_PID with ptid_get_pid.
	Replace is_lwp with ptid_lwp_p.
	Replace GET_LWP with ptid_get_lwp.
	Replace BUILD_LWP with ptid_build.
@
text
@/* S390 native-dependent code for GDB, the GNU debugger.
   Copyright (C) 2001-2013 Free Software Foundation, Inc.

   Contributed by D.J. Barrow (djbarrow@@de.ibm.com,barrow_dj@@yahoo.com)
   for IBM Deutschland Entwicklung GmbH, IBM Corporation.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "regcache.h"
#include "inferior.h"
#include "target.h"
#include "linux-nat.h"
#include "auxv.h"
#include "gregset.h"

#include "s390-tdep.h"
#include "elf/common.h"

#include <asm/ptrace.h>
#include <sys/ptrace.h>
#include <asm/types.h>
#include <sys/procfs.h>
#include <sys/ucontext.h>
#include <elf.h>

#ifndef PTRACE_GETREGSET
#define PTRACE_GETREGSET 0x4204
#endif

#ifndef PTRACE_SETREGSET
#define PTRACE_SETREGSET 0x4205
#endif

static int have_regset_last_break = 0;
static int have_regset_system_call = 0;
static int have_regset_tdb = 0;

/* Map registers to gregset/ptrace offsets.
   These arrays are defined in s390-tdep.c.  */

#ifdef __s390x__
#define regmap_gregset s390x_regmap_gregset
#else
#define regmap_gregset s390_regmap_gregset
#endif

#define regmap_fpregset s390_regmap_fpregset

/* Fill the regset described by MAP into REGCACHE, using the values
   from REGP.  The MAP array represents each register as a pair
   (offset, regno) of short integers and is terminated with -1. */

static void
s390_native_supply (struct regcache *regcache, const short *map,
		    const gdb_byte *regp)
{
  for (; map[0] >= 0; map += 2)
    regcache_raw_supply (regcache, map[1], regp ? regp + map[0] : NULL);
}

/* Collect the register REGNO out of the regset described by MAP from
   REGCACHE into REGP.  If REGNO == -1, do this for all registers in
   this regset. */

static void
s390_native_collect (const struct regcache *regcache, const short *map,
		     int regno, gdb_byte *regp)
{
  for (; map[0] >= 0; map += 2)
    if (regno == -1 || regno == map[1])
      regcache_raw_collect (regcache, map[1], regp + map[0]);
}

/* Fill GDB's register array with the general-purpose register values
   in *REGP.

   When debugging a 32-bit executable running under a 64-bit kernel,
   we have to fix up the 64-bit registers we get from the kernel to
   make them look like 32-bit registers.  */

void
supply_gregset (struct regcache *regcache, const gregset_t *regp)
{
#ifdef __s390x__
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  if (gdbarch_ptr_bit (gdbarch) == 32)
    {
      enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
      ULONGEST pswm = 0, pswa = 0;
      gdb_byte buf[4];
      const short *map;

      for (map = regmap_gregset; map[0] >= 0; map += 2)
	{
	  const gdb_byte *p = (const gdb_byte *) regp + map[0];
	  int regno = map[1];

	  if (regno == S390_PSWM_REGNUM)
	    pswm = extract_unsigned_integer (p, 8, byte_order);
	  else if (regno == S390_PSWA_REGNUM)
	    pswa = extract_unsigned_integer (p, 8, byte_order);
	  else
	    {
	      if ((regno >= S390_R0_REGNUM && regno <= S390_R15_REGNUM)
		  || regno == S390_ORIG_R2_REGNUM)
		p += 4;
	      regcache_raw_supply (regcache, regno, p);
	    }
	}

      store_unsigned_integer (buf, 4, byte_order, (pswm >> 32) | 0x80000);
      regcache_raw_supply (regcache, S390_PSWM_REGNUM, buf);
      store_unsigned_integer (buf, 4, byte_order,
			      (pswa & 0x7fffffff) | (pswm & 0x80000000));
      regcache_raw_supply (regcache, S390_PSWA_REGNUM, buf);
      return;
    }
#endif

  s390_native_supply (regcache, regmap_gregset, (const gdb_byte *) regp);
}

/* Fill register REGNO (if it is a general-purpose register) in
   *REGP with the value in GDB's register array.  If REGNO is -1,
   do this for all registers.  */

void
fill_gregset (const struct regcache *regcache, gregset_t *regp, int regno)
{
#ifdef __s390x__
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  if (gdbarch_ptr_bit (gdbarch) == 32)
    {
      gdb_byte *psw_p[2];
      const short *map;

      for (map = regmap_gregset; map[0] >= 0; map += 2)
	{
	  gdb_byte *p = (gdb_byte *) regp + map[0];
	  int reg = map[1];

	  if (reg >= S390_PSWM_REGNUM && reg <= S390_PSWA_REGNUM)
	    psw_p[reg - S390_PSWM_REGNUM] = p;

	  else if (regno == -1 || regno == reg)
	    {
	      if ((reg >= S390_R0_REGNUM && reg <= S390_R15_REGNUM)
		  || reg == S390_ORIG_R2_REGNUM)
		{
		  memset (p, 0, 4);
		  p += 4;
		}
	      regcache_raw_collect (regcache, reg, p + 4);
	    }
	}

      if (regno == -1
	  || regno == S390_PSWM_REGNUM || regno == S390_PSWA_REGNUM)
	{
	  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
	  ULONGEST pswa, pswm;
	  gdb_byte buf[4];

	  regcache_raw_collect (regcache, S390_PSWM_REGNUM, buf);
	  pswm = extract_unsigned_integer (buf, 4, byte_order);
	  regcache_raw_collect (regcache, S390_PSWA_REGNUM, buf);
	  pswa = extract_unsigned_integer (buf, 4, byte_order);

	  if (regno == -1 || regno == S390_PSWM_REGNUM)
	    store_unsigned_integer (psw_p[0], 8, byte_order,
				    ((pswm & 0xfff7ffff) << 32) |
				    (pswa & 0x80000000));
	  if (regno == -1 || regno == S390_PSWA_REGNUM)
	    store_unsigned_integer (psw_p[1], 8, byte_order,
				    pswa & 0x7fffffff);
	}
      return;
    }
#endif

  s390_native_collect (regcache, regmap_gregset, regno, (gdb_byte *) regp);
}

/* Fill GDB's register array with the floating-point register values
   in *REGP.  */
void
supply_fpregset (struct regcache *regcache, const fpregset_t *regp)
{
  s390_native_supply (regcache, regmap_fpregset, (const gdb_byte *) regp);
}

/* Fill register REGNO (if it is a general-purpose register) in
   *REGP with the value in GDB's register array.  If REGNO is -1,
   do this for all registers.  */
void
fill_fpregset (const struct regcache *regcache, fpregset_t *regp, int regno)
{
  s390_native_collect (regcache, regmap_fpregset, regno, (gdb_byte *) regp);
}

/* Find the TID for the current inferior thread to use with ptrace.  */
static int
s390_inferior_tid (void)
{
  /* GNU/Linux LWP ID's are process ID's.  */
  int tid = ptid_get_lwp (inferior_ptid);
  if (tid == 0)
    tid = ptid_get_pid (inferior_ptid); /* Not a threaded program.  */

  return tid;
}

/* Fetch all general-purpose registers from process/thread TID and
   store their values in GDB's register cache.  */
static void
fetch_regs (struct regcache *regcache, int tid)
{
  gregset_t regs;
  ptrace_area parea;

  parea.len = sizeof (regs);
  parea.process_addr = (addr_t) &regs;
  parea.kernel_addr = offsetof (struct user_regs_struct, psw);
  if (ptrace (PTRACE_PEEKUSR_AREA, tid, (long) &parea) < 0)
    perror_with_name (_("Couldn't get registers"));

  supply_gregset (regcache, (const gregset_t *) &regs);
}

/* Store all valid general-purpose registers in GDB's register cache
   into the process/thread specified by TID.  */
static void
store_regs (const struct regcache *regcache, int tid, int regnum)
{
  gregset_t regs;
  ptrace_area parea;

  parea.len = sizeof (regs);
  parea.process_addr = (addr_t) &regs;
  parea.kernel_addr = offsetof (struct user_regs_struct, psw);
  if (ptrace (PTRACE_PEEKUSR_AREA, tid, (long) &parea) < 0)
    perror_with_name (_("Couldn't get registers"));

  fill_gregset (regcache, &regs, regnum);

  if (ptrace (PTRACE_POKEUSR_AREA, tid, (long) &parea) < 0)
    perror_with_name (_("Couldn't write registers"));
}

/* Fetch all floating-point registers from process/thread TID and store
   their values in GDB's register cache.  */
static void
fetch_fpregs (struct regcache *regcache, int tid)
{
  fpregset_t fpregs;
  ptrace_area parea;

  parea.len = sizeof (fpregs);
  parea.process_addr = (addr_t) &fpregs;
  parea.kernel_addr = offsetof (struct user_regs_struct, fp_regs);
  if (ptrace (PTRACE_PEEKUSR_AREA, tid, (long) &parea) < 0)
    perror_with_name (_("Couldn't get floating point status"));

  supply_fpregset (regcache, (const fpregset_t *) &fpregs);
}

/* Store all valid floating-point registers in GDB's register cache
   into the process/thread specified by TID.  */
static void
store_fpregs (const struct regcache *regcache, int tid, int regnum)
{
  fpregset_t fpregs;
  ptrace_area parea;

  parea.len = sizeof (fpregs);
  parea.process_addr = (addr_t) &fpregs;
  parea.kernel_addr = offsetof (struct user_regs_struct, fp_regs);
  if (ptrace (PTRACE_PEEKUSR_AREA, tid, (long) &parea) < 0)
    perror_with_name (_("Couldn't get floating point status"));

  fill_fpregset (regcache, &fpregs, regnum);

  if (ptrace (PTRACE_POKEUSR_AREA, tid, (long) &parea) < 0)
    perror_with_name (_("Couldn't write floating point status"));
}

/* Fetch all registers in the kernel's register set whose number is REGSET,
   whose size is REGSIZE, and whose layout is described by REGMAP, from
   process/thread TID and store their values in GDB's register cache.  */
static void
fetch_regset (struct regcache *regcache, int tid,
	      int regset, int regsize, const short *regmap)
{
  gdb_byte *buf = alloca (regsize);
  struct iovec iov;

  iov.iov_base = buf;
  iov.iov_len = regsize;

  if (ptrace (PTRACE_GETREGSET, tid, (long) regset, (long) &iov) < 0)
    {
      if (errno == ENODATA)
	s390_native_supply (regcache, regmap, NULL);
      else
	perror_with_name (_("Couldn't get register set"));
    }
  else
    s390_native_supply (regcache, regmap, buf);
}

/* Store all registers in the kernel's register set whose number is REGSET,
   whose size is REGSIZE, and whose layout is described by REGMAP, from
   GDB's register cache back to process/thread TID.  */
static void
store_regset (struct regcache *regcache, int tid,
	      int regset, int regsize, const short *regmap)
{
  gdb_byte *buf = alloca (regsize);
  struct iovec iov;

  iov.iov_base = buf;
  iov.iov_len = regsize;

  if (ptrace (PTRACE_GETREGSET, tid, (long) regset, (long) &iov) < 0)
    perror_with_name (_("Couldn't get register set"));

  s390_native_collect (regcache, regmap, -1, buf);

  if (ptrace (PTRACE_SETREGSET, tid, (long) regset, (long) &iov) < 0)
    perror_with_name (_("Couldn't set register set"));
}

/* Check whether the kernel provides a register set with number REGSET
   of size REGSIZE for process/thread TID.  */
static int
check_regset (int tid, int regset, int regsize)
{
  gdb_byte *buf = alloca (regsize);
  struct iovec iov;

  iov.iov_base = buf;
  iov.iov_len = regsize;

  if (ptrace (PTRACE_GETREGSET, tid, (long) regset, (long) &iov) >= 0
      || errno == ENODATA)
    return 1;
  return 0;
}

/* Fetch register REGNUM from the child process.  If REGNUM is -1, do
   this for all registers.  */
static void
s390_linux_fetch_inferior_registers (struct target_ops *ops,
				     struct regcache *regcache, int regnum)
{
  int tid = s390_inferior_tid ();

  if (regnum == -1 || S390_IS_GREGSET_REGNUM (regnum))
    fetch_regs (regcache, tid);

  if (regnum == -1 || S390_IS_FPREGSET_REGNUM (regnum))
    fetch_fpregs (regcache, tid);

  if (have_regset_last_break)
    if (regnum == -1 || regnum == S390_LAST_BREAK_REGNUM)
      fetch_regset (regcache, tid, NT_S390_LAST_BREAK, 8,
		    (gdbarch_ptr_bit (get_regcache_arch (regcache)) == 32
		     ? s390_regmap_last_break : s390x_regmap_last_break));

  if (have_regset_system_call)
    if (regnum == -1 || regnum == S390_SYSTEM_CALL_REGNUM)
      fetch_regset (regcache, tid, NT_S390_SYSTEM_CALL, 4,
		    s390_regmap_system_call);

  if (have_regset_tdb)
    if (regnum == -1 || S390_IS_TDBREGSET_REGNUM (regnum))
      fetch_regset (regcache, tid, NT_S390_TDB, s390_sizeof_tdbregset,
		    s390_regmap_tdb);
}

/* Store register REGNUM back into the child process.  If REGNUM is
   -1, do this for all registers.  */
static void
s390_linux_store_inferior_registers (struct target_ops *ops,
				     struct regcache *regcache, int regnum)
{
  int tid = s390_inferior_tid ();

  if (regnum == -1 || S390_IS_GREGSET_REGNUM (regnum))
    store_regs (regcache, tid, regnum);

  if (regnum == -1 || S390_IS_FPREGSET_REGNUM (regnum))
    store_fpregs (regcache, tid, regnum);

  /* S390_LAST_BREAK_REGNUM is read-only.  */

  if (have_regset_system_call)
    if (regnum == -1 || regnum == S390_SYSTEM_CALL_REGNUM)
      store_regset (regcache, tid, NT_S390_SYSTEM_CALL, 4,
		    s390_regmap_system_call);
}


/* Hardware-assisted watchpoint handling.  */

/* We maintain a list of all currently active watchpoints in order
   to properly handle watchpoint removal.

   The only thing we actually need is the total address space area
   spanned by the watchpoints.  */

struct watch_area
{
  struct watch_area *next;
  CORE_ADDR lo_addr;
  CORE_ADDR hi_addr;
};

static struct watch_area *watch_base = NULL;

static int
s390_stopped_by_watchpoint (void)
{
  per_lowcore_bits per_lowcore;
  ptrace_area parea;
  int result;

  /* Speed up common case.  */
  if (!watch_base)
    return 0;

  parea.len = sizeof (per_lowcore);
  parea.process_addr = (addr_t) & per_lowcore;
  parea.kernel_addr = offsetof (struct user_regs_struct, per_info.lowcore);
  if (ptrace (PTRACE_PEEKUSR_AREA, s390_inferior_tid (), &parea) < 0)
    perror_with_name (_("Couldn't retrieve watchpoint status"));

  result = (per_lowcore.perc_storage_alteration == 1
	    && per_lowcore.perc_store_real_address == 0);

  if (result)
    {
      /* Do not report this watchpoint again.  */
      memset (&per_lowcore, 0, sizeof (per_lowcore));
      if (ptrace (PTRACE_POKEUSR_AREA, s390_inferior_tid (), &parea) < 0)
	perror_with_name (_("Couldn't clear watchpoint status"));
    }

  return result;
}

static void
s390_fix_watch_points (struct lwp_info *lp)
{
  int tid;

  per_struct per_info;
  ptrace_area parea;

  CORE_ADDR watch_lo_addr = (CORE_ADDR)-1, watch_hi_addr = 0;
  struct watch_area *area;

  tid = ptid_get_lwp (lp->ptid);
  if (tid == 0)
    tid = ptid_get_pid (lp->ptid);

  for (area = watch_base; area; area = area->next)
    {
      watch_lo_addr = min (watch_lo_addr, area->lo_addr);
      watch_hi_addr = max (watch_hi_addr, area->hi_addr);
    }

  parea.len = sizeof (per_info);
  parea.process_addr = (addr_t) & per_info;
  parea.kernel_addr = offsetof (struct user_regs_struct, per_info);
  if (ptrace (PTRACE_PEEKUSR_AREA, tid, &parea) < 0)
    perror_with_name (_("Couldn't retrieve watchpoint status"));

  if (watch_base)
    {
      per_info.control_regs.bits.em_storage_alteration = 1;
      per_info.control_regs.bits.storage_alt_space_ctl = 1;
    }
  else
    {
      per_info.control_regs.bits.em_storage_alteration = 0;
      per_info.control_regs.bits.storage_alt_space_ctl = 0;
    }
  per_info.starting_addr = watch_lo_addr;
  per_info.ending_addr = watch_hi_addr;

  if (ptrace (PTRACE_POKEUSR_AREA, tid, &parea) < 0)
    perror_with_name (_("Couldn't modify watchpoint status"));
}

static int
s390_insert_watchpoint (CORE_ADDR addr, int len, int type,
			struct expression *cond)
{
  struct lwp_info *lp;
  struct watch_area *area = xmalloc (sizeof (struct watch_area));

  if (!area)
    return -1; 

  area->lo_addr = addr;
  area->hi_addr = addr + len - 1;
 
  area->next = watch_base;
  watch_base = area;

  ALL_LWPS (lp)
    s390_fix_watch_points (lp);
  return 0;
}

static int
s390_remove_watchpoint (CORE_ADDR addr, int len, int type,
			struct expression *cond)
{
  struct lwp_info *lp;
  struct watch_area *area, **parea;

  for (parea = &watch_base; *parea; parea = &(*parea)->next)
    if ((*parea)->lo_addr == addr
	&& (*parea)->hi_addr == addr + len - 1)
      break;

  if (!*parea)
    {
      fprintf_unfiltered (gdb_stderr,
			  "Attempt to remove nonexistent watchpoint.\n");
      return -1;
    }

  area = *parea;
  *parea = area->next;
  xfree (area);

  ALL_LWPS (lp)
    s390_fix_watch_points (lp);
  return 0;
}

static int
s390_can_use_hw_breakpoint (int type, int cnt, int othertype)
{
  return type == bp_hardware_watchpoint;
}

static int
s390_region_ok_for_hw_watchpoint (CORE_ADDR addr, int cnt)
{
  return 1;
}

static int
s390_target_wordsize (void)
{
  int wordsize = 4;

  /* Check for 64-bit inferior process.  This is the case when the host is
     64-bit, and in addition bit 32 of the PSW mask is set.  */
#ifdef __s390x__
  long pswm;

  errno = 0;
  pswm = (long) ptrace (PTRACE_PEEKUSER, s390_inferior_tid (), PT_PSWMASK, 0);
  if (errno == 0 && (pswm & 0x100000000ul) != 0)
    wordsize = 8;
#endif

  return wordsize;
}

static int
s390_auxv_parse (struct target_ops *ops, gdb_byte **readptr,
		 gdb_byte *endptr, CORE_ADDR *typep, CORE_ADDR *valp)
{
  int sizeof_auxv_field = s390_target_wordsize ();
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());
  gdb_byte *ptr = *readptr;

  if (endptr == ptr)
    return 0;

  if (endptr - ptr < sizeof_auxv_field * 2)
    return -1;

  *typep = extract_unsigned_integer (ptr, sizeof_auxv_field, byte_order);
  ptr += sizeof_auxv_field;
  *valp = extract_unsigned_integer (ptr, sizeof_auxv_field, byte_order);
  ptr += sizeof_auxv_field;

  *readptr = ptr;
  return 1;
}

#ifdef __s390x__
static unsigned long
s390_get_hwcap (void)
{
  CORE_ADDR field;

  if (target_auxv_search (&current_target, AT_HWCAP, &field))
    return (unsigned long) field;

  return 0;
}
#endif

static const struct target_desc *
s390_read_description (struct target_ops *ops)
{
  int tid = s390_inferior_tid ();

  have_regset_last_break
    = check_regset (tid, NT_S390_LAST_BREAK, 8);
  have_regset_system_call
    = check_regset (tid, NT_S390_SYSTEM_CALL, 4);
  have_regset_tdb
    = check_regset (tid, NT_S390_TDB, s390_sizeof_tdbregset);

#ifdef __s390x__
  /* If GDB itself is compiled as 64-bit, we are running on a machine in
     z/Architecture mode.  If the target is running in 64-bit addressing
     mode, report s390x architecture.  If the target is running in 31-bit
     addressing mode, but the kernel supports using 64-bit registers in
     that mode, report s390 architecture with 64-bit GPRs.  */

  if (s390_target_wordsize () == 8)
    return (have_regset_tdb ? tdesc_s390x_te_linux64 :
	    have_regset_system_call? tdesc_s390x_linux64v2 :
	    have_regset_last_break? tdesc_s390x_linux64v1 :
	    tdesc_s390x_linux64);

  if (s390_get_hwcap () & HWCAP_S390_HIGH_GPRS)
    return (have_regset_tdb ? tdesc_s390_te_linux64 :
	    have_regset_system_call? tdesc_s390_linux64v2 :
	    have_regset_last_break? tdesc_s390_linux64v1 :
	    tdesc_s390_linux64);
#endif

  /* If GDB itself is compiled as 31-bit, or if we're running a 31-bit inferior
     on a 64-bit kernel that does not support using 64-bit registers in 31-bit
     mode, report s390 architecture with 32-bit GPRs.  */
  return (have_regset_system_call? tdesc_s390_linux32v2 :
	  have_regset_last_break? tdesc_s390_linux32v1 :
	  tdesc_s390_linux32);
}

void _initialize_s390_nat (void);

void
_initialize_s390_nat (void)
{
  struct target_ops *t;

  /* Fill in the generic GNU/Linux methods.  */
  t = linux_target ();

  /* Add our register access methods.  */
  t->to_fetch_registers = s390_linux_fetch_inferior_registers;
  t->to_store_registers = s390_linux_store_inferior_registers;

  /* Add our watchpoint methods.  */
  t->to_can_use_hw_breakpoint = s390_can_use_hw_breakpoint;
  t->to_region_ok_for_hw_watchpoint = s390_region_ok_for_hw_watchpoint;
  t->to_have_continuable_watchpoint = 1;
  t->to_stopped_by_watchpoint = s390_stopped_by_watchpoint;
  t->to_insert_watchpoint = s390_insert_watchpoint;
  t->to_remove_watchpoint = s390_remove_watchpoint;

  /* Detect target architecture.  */
  t->to_read_description = s390_read_description;
  t->to_auxv_parse = s390_auxv_parse;

  /* Register the target.  */
  linux_nat_add_target (t);
  linux_nat_set_new_thread (t, s390_fix_watch_points);
}
@


1.44
log
@gdb/ChangeLog:
2013-09-13  Andreas Arnez  <arnez@@linux.vnet.ibm.com>

	* NEWS: Mention TDB support.
	* features/s390-tdb.xml: New file.
	* features/s390-te-linux64.xml: New file.
	* features/s390x-te-linux64.xml: New file.
	* features/Makefile (WHICH): Add new tdescs above.
	(s390-te-linux64-expedite): Set.
	(s390x-te-linux64-expedite): Set.
	* features/s390-te-linux64.c: New file (generated).
	* features/s390x-te-linux64.c: New file (generated).
	* regformats/s390-te-linux64.dat: New file (generated).
	* regformats/s390x-te-linux64.dat: New file (generated).
	* s390-tdep.h (HWCAP_S390_HIGH_GPRS): Define.
	(HWCAP_S390_TE): Likewise.
	(S390_TDB_DWORD0_REGNUM): Likewise.
	(S390_TDB_DWORD0_REGNUM): Likewise.
	(S390_TDB_ABORT_CODE_REGNUM): Likewise.
	(S390_TDB_CONFLICT_TOKEN_REGNUM): Likewise.
	(S390_TDB_ATIA_REGNUM): Likewise.
	(S390_TDB_R0_REGNUM): Likewise.
	(S390_TDB_R1_REGNUM): Likewise.
	(S390_TDB_R2_REGNUM): Likewise.
	(S390_TDB_R3_REGNUM): Likewise.
	(S390_TDB_R4_REGNUM): Likewise.
	(S390_TDB_R5_REGNUM): Likewise.
	(S390_TDB_R6_REGNUM): Likewise.
	(S390_TDB_R7_REGNUM): Likewise.
	(S390_TDB_R8_REGNUM): Likewise.
	(S390_TDB_R9_REGNUM): Likewise.
	(S390_TDB_R10_REGNUM): Likewise.
	(S390_TDB_R11_REGNUM): Likewise.
	(S390_TDB_R12_REGNUM): Likewise.
	(S390_TDB_R13_REGNUM): Likewise.
	(S390_TDB_R14_REGNUM): Likewise.
	(S390_TDB_R15_REGNUM): Likewise.
	(S390_NUM_REGS): Increase.
	(S390_IS_TDBREGSET_REGNUM): New macro.
	(s390_regmap_tdb): Declare.
	(s390_sizeof_tdbregset): Define.
	(tdesc_s390_te_linux64): Declare.
	(tdesc_s390x_te_linux64): Likewise.
	* s390-tdep.c: Add includes for "auxv.h", <elf.h>,
	"features/s390-te-linux64.c", and "features/s390x-te-linux64.c".
	(s390_regmap_tdb): New regmap.
	(s390_supply_tdb_regset): New function.
	(s390_tdb_regset): New regset.
	(s390_linux64v2_regset_sections): Add TDB regset to list.
	(s390x_linux64v2_regset_sections): Likewise.
	(s390_regset_from_core_section): Recognize TDB core note section.
	(s390_core_read_description): If HWCAP indicates TE support,
	select tdesc_s390_te_linux64 or tdesc_s390_s390x_te_linux64.
	(s390_gdbarch_init): Handle TDB regset.
	(_initialize_s390_tdep): Initialize new tdescs.
	* s390-nat.c (HWCAP_S390_HIGH_GPRS): Remove define.
	(have_regset_tdb): New variable.
	(s390_native_supply): Support register invalidation.
	(fetch_regset): Invalidate registers if ptrace yields ENODATA.
	(check_regset): Treat ENODATA as "regset exists".
	(s390_linux_fetch_inferior_registers): Add TDB.
	(s390_read_description): Check for TDB existence and select
	appropriate tdesc.
	* gdbserver/Makefile.in (clean): Add removal of new makefile
	targets.
	(s390-te-linux64.c): New makefile target.
	(s390x-te-linux64.c): Likewise.
	* gdbserver/configure.srv (srv_regobj): Append new objects
	s390-te-linux64.o and s390x-te-linux64.o.
	(srv_xmlfiles): Append new files s390-te-linux64.xml,
	s390x-te-linux64.xml, and s390-tdb.xml.
	* gdbserver/linux-s390-low.c (init_registers_s390_te_linux64): New
	declaration.
	(tdesc_s390_te_linux64): Likewise.
	(init_registers_s390x_te_linux64): Likewise.
	(tdesc_s390x_te_linux64): Likewise.
	(s390_check_regset): Treat ENODATA as "regset exists".
	(s390_arch_setup): Add TDB regset support.
	(initialize_low_arch): Initialize registers for new tdescs.

gdb/doc/ChangeLog:
2013-09-13  Andreas Arnez  <arnez@@linux.vnet.ibm.com>

	* gdb.texinfo (Decimal Floating Point format): Mention S/390.
	(Standard Target Features): Add new node to menu.
	(S/390 and System z Features): New node.

gdb/testsuite/ChangeLog:
2013-09-13  Andreas Arnez  <arnez@@linux.vnet.ibm.com>

	* gdb.arch/s390-tdbregs.c: New file.
	* gdb.arch/s390-tdbregs.exp: New file.
@
text
@d220 1
a220 1
  int tid = TIDGET (inferior_ptid);
d222 1
a222 1
    tid = PIDGET (inferior_ptid); /* Not a threaded program.  */
d477 1
a477 1
  tid = TIDGET (lp->ptid);
d479 1
a479 1
    tid = PIDGET (lp->ptid);
@


1.43
log
@2013-09-13  Andreas Arnez  <arnez@@linux.vnet.ibm.com>

	* s390-tdep.h (S390_IS_GREGSET_REGNUM): New macro.
	(S390_IS_FPREGSET_REGNUM): New macro.
	* s390-tdep.c (s390_dwarf_regmap): Make const.
	(regnum_is_gpr_full): New function for replacing repeated code.
	(s390_pseudo_register_name): Use it.
	(s390_pseudo_register_type): Likewise.
	(s390_pseudo_register_read): Likewise.
	(s390_pseudo_register_write): Likewise.
	(s390_unwind_pseudo_register): Likewise.
	(s390_regmap_gregset): New format for regmap.
	(s390x_regmap_gregset): Likewise.
	(s390_regmap_fpregset): Likewise.
	(s390_regmap_upper): Likewise.
	(s390_regmap_last_break): Likewise.
	(s390_regmap_system_call): Likewise.
	(s390_supply_regset): Adjust to new regmap format.
	(s390_collect_regset): Likewise.
	* s390-nat.c (s390_native_supply): Adjust to new regmap format.
	(s390_native_collect): Likewise.
	(supply_gregset): Likewise.
	(fill_gregset): Likewise.
	(supply_fpregset): Likewise.
	(fill_fpregset): Likewise.
	(fetch_regset): Likewise.
	(store_regset): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
@
text
@a39 4
#ifndef HWCAP_S390_HIGH_GPRS
#define HWCAP_S390_HIGH_GPRS 512
#endif

d50 1
d72 1
a72 1
    regcache_raw_supply (regcache, map[1], regp + map[0]);
d315 8
a322 3
    perror_with_name (_("Couldn't get register set"));

  s390_native_supply (regcache, regmap, buf);
d358 2
a359 3
  if (ptrace (PTRACE_GETREGSET, tid, (long) regset, (long) &iov) < 0)
    return 0;
  else
d361 1
d388 5
d635 2
d646 2
a647 1
    return (have_regset_system_call? tdesc_s390x_linux64v2 :
d652 2
a653 1
    return (have_regset_system_call? tdesc_s390_linux64v2 :
@


1.42
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d66 3
a68 3
/* When debugging a 32-bit executable running under a 64-bit kernel,
   we have to fix up the 64-bit registers we get from the kernel
   to make them look like 32-bit registers.  */
d71 2
a72 2
s390_native_supply (struct regcache *regcache, int regno,
		    const gdb_byte *regp, int *regmap)
d74 7
a80 1
  int offset = regmap[regno];
d82 19
d103 1
a103 1
  if (offset != -1 && gdbarch_ptr_bit (gdbarch) == 32)
d106 3
d110 1
a110 14
      if (regno == S390_PSWM_REGNUM)
	{
	  ULONGEST pswm;
	  gdb_byte buf[4];

	  pswm = extract_unsigned_integer (regp + regmap[S390_PSWM_REGNUM],
					   8, byte_order);

	  store_unsigned_integer (buf, 4, byte_order, (pswm >> 32) | 0x80000);
	  regcache_raw_supply (regcache, regno, buf);
	  return;
	}

      if (regno == S390_PSWA_REGNUM)
d112 2
a113 2
	  ULONGEST pswm, pswa;
	  gdb_byte buf[4];
d115 11
a125 9
	  pswa = extract_unsigned_integer (regp + regmap[S390_PSWA_REGNUM],
					   8, byte_order);
	  pswm = extract_unsigned_integer (regp + regmap[S390_PSWM_REGNUM],
					   8, byte_order);

	  store_unsigned_integer (buf, 4, byte_order,
				  (pswa & 0x7fffffff) | (pswm & 0x80000000));
	  regcache_raw_supply (regcache, regno, buf);
	  return;
d128 6
a133 3
      if ((regno >= S390_R0_REGNUM && regno <= S390_R15_REGNUM)
	  || regno == S390_ORIG_R2_REGNUM)
	offset += 4;
d137 1
a137 2
  if (offset != -1)
    regcache_raw_supply (regcache, regno, regp + offset);
d140 6
a145 3
static void
s390_native_collect (const struct regcache *regcache, int regno,
		     gdb_byte *regp, int *regmap)
a146 2
  int offset = regmap[regno];

d149 1
a149 1
  if (offset != -1 && gdbarch_ptr_bit (gdbarch) == 32)
d151 2
a152 1
      enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
d154 1
a154 1
      if (regno == S390_PSWM_REGNUM)
d156 2
a157 2
	  ULONGEST pswm;
	  gdb_byte buf[4];
d159 2
a160 2
	  regcache_raw_collect (regcache, regno, buf);
	  pswm = extract_unsigned_integer (buf, 4, byte_order);
d162 10
a171 6
	  /* We don't know the final addressing mode until the PSW address
	     is known, so leave it as-is.  When the PSW address is collected
	     (below), the addressing mode will be updated.  */
	  store_unsigned_integer (regp + regmap[S390_PSWM_REGNUM],
				  4, byte_order, pswm & 0xfff7ffff);
	  return;
d174 2
a175 1
      if (regno == S390_PSWA_REGNUM)
d177 2
a178 1
	  ULONGEST pswa;
d181 3
a183 1
	  regcache_raw_collect (regcache, regno, buf);
d186 7
a192 14
	  store_unsigned_integer (regp + regmap[S390_PSWA_REGNUM],
				  8, byte_order, pswa & 0x7fffffff);

	  /* Update basic addressing mode bit in PSW mask, see above.  */
	  store_unsigned_integer (regp + regmap[S390_PSWM_REGNUM] + 4,
				  4, byte_order, pswa & 0x80000000);
	  return;
	}

      if ((regno >= S390_R0_REGNUM && regno <= S390_R15_REGNUM)
	  || regno == S390_ORIG_R2_REGNUM)
	{
	  memset (regp + offset, 0, 4);
	  offset += 4;
d194 1
d198 1
a198 24
  if (offset != -1)
    regcache_raw_collect (regcache, regno, regp + offset);
}

/* Fill GDB's register array with the general-purpose register values
   in *REGP.  */
void
supply_gregset (struct regcache *regcache, const gregset_t *regp)
{
  int i;
  for (i = 0; i < S390_NUM_REGS; i++)
    s390_native_supply (regcache, i, (const gdb_byte *) regp, regmap_gregset);
}

/* Fill register REGNO (if it is a general-purpose register) in
   *REGP with the value in GDB's register array.  If REGNO is -1,
   do this for all registers.  */
void
fill_gregset (const struct regcache *regcache, gregset_t *regp, int regno)
{
  int i;
  for (i = 0; i < S390_NUM_REGS; i++)
    if (regno == -1 || regno == i)
      s390_native_collect (regcache, i, (gdb_byte *) regp, regmap_gregset);
d206 1
a206 3
  int i;
  for (i = 0; i < S390_NUM_REGS; i++)
    s390_native_supply (regcache, i, (const gdb_byte *) regp, regmap_fpregset);
d215 1
a215 4
  int i;
  for (i = 0; i < S390_NUM_REGS; i++)
    if (regno == -1 || regno == i)
      s390_native_collect (regcache, i, (gdb_byte *) regp, regmap_fpregset);
d309 1
a309 1
	      int regset, int regsize, int *regmap)
a310 1
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
a312 1
  int i;
d320 1
a320 2
  for (i = 0; i < S390_NUM_REGS; i++)
    s390_native_supply (regcache, i, buf, regmap);
d328 1
a328 1
	      int regset, int regsize, int *regmap)
a329 1
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
a331 1
  int i;
d339 1
a339 2
  for (i = 0; i < S390_NUM_REGS; i++)
    s390_native_collect (regcache, i, buf, regmap);
d370 1
a370 2
  if (regnum == -1 
      || (regnum < S390_NUM_REGS && regmap_gregset[regnum] != -1))
d373 1
a373 2
  if (regnum == -1 
      || (regnum < S390_NUM_REGS && regmap_fpregset[regnum] != -1))
d396 1
a396 2
  if (regnum == -1 
      || (regnum < S390_NUM_REGS && regmap_gregset[regnum] != -1))
d399 1
a399 2
  if (regnum == -1 
      || (regnum < S390_NUM_REGS && regmap_fpregset[regnum] != -1))
@


1.41
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d2 1
a2 2
   Copyright (C) 2001, 2003-2007, 2009, 2012 Free Software Foundation,
   Inc.
@


1.40
log
@Include "gregset.h" in s390-nat.c (-Wmissing-prototypes).

gdb/ChangeLog:

        * s390-nat.c: Include "gregset.h".
@
text
@d604 1
a604 1
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch);
@


1.39
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d29 1
@


1.38
log
@Update the copyright header of various files...

... to follow the correct syntax (according to the gospel of
gnulib's update-copyright). In other words:
  - no comma after the last year;
  - FSF spelled exactly "Free Software Foundation, Inc.", with
    the comma and the period at the end.

sim/common/ChangeLog:

	* dv-sockser.h, sim-assert.h, sim-fpu.c: Reformat the copyright
	header.

sim/m32c/ChangeLog:

	* blinky.S, gloss.S, sample.S: Reformat copyright header.

sim/mn10300/ChangeLog:

	* sim-main.h: Reformat copyright header.

sim/ppc/ChangeLog:

	* dp-bit.c: Reformat copyright header.

gdb/ChangeLog:

        * gdb/common/gdb_thread_db.h, gdb/dbxread.c, gdb/environ.c,
        gdb/gcore.h, gdb/rs6000-tdep.h, gdb/s390-nat.c, gdb/tic6x-tdep.c:
        Reformat the copyright header.

gdb/gdbserver/ChangeLog:

	* terminal.h: Reformat copyright header.

gdb/testsuite/ChangeLog:

	* dg-extract-results.sh, gdb.arch/gcore.c, gdb.arch/gdb1558.c,
	gdb.arch/i386-gnu-cfi.c, gdb.base/complex.c, gdb.base/cvexpr.c,
	gdb.base/gcore.c, gdb.base/gdb1555-main.c, gdb.base/gdb1555.c,
	gdb.base/gdb1821.c, gdb.base/long_long.c, gdb.base/restore.c,
	gdb.base/sepdebug.c, gdb.base/type-opaque-lib.c,
	gdb.base/type-opaque-main.c, gdb.cp/maint.exp, gdb.cp/namespace1.cc,
	gdb.cp/pr9631.cc, gdb.cp/psmang1.cc, gdb.cp/psmang2.cc,
	gdb.cp/try_catch.cc, gdb.cp/virtfunc.cc, gdb.hp/gdb.base-hp/reg.exp,
	gdb.mi/basics.c, gdb.mi/mi-stack.c, gdb.mi/mi-var-child.c,
	gdb.mi/mi2-var-child.exp, gdb.mi/var-cmd.c,
	gdb.threads/thread_check.c: Reformat copyright header.
@
text
@d2 2
a3 2
   Copyright (C) 2001, 2003, 2004, 2005, 2006, 2007, 2009
   Free Software Foundation, Inc.
@


1.37
log
@gdb/
	Fix build regression from the PR threads/10729 fix.
	* s390-nat.c (s390_insert_watchpoint, s390_remove_watchpoint): Use LP,
	not LP->PTID.
@
text
@d3 1
a3 1
   Free Software Foundation, Inc
@


1.36
log
@gdb/
2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	PR threads/10729

	* linux-nat.c (linux_nat_new_thread): Change parameter to an lwp
	pointer.
	(linux_nat_prepare_to_resume): New global.
	(lwp_free): New.
	(purge_lwp_list): Use it.
	(add_lwp): Call linux_nat_new_thread even on the first LWP.
	Adjust to interface change.
	(delete_lwp): Call lwp_free instead of xfree.
	(detach_callback, linux_nat_detach, resume_lwp, linux_nat_resume)
	(linux_handle_syscall_trap, linux_handle_extended_wait)
	(linux_nat_filter_event, resume_stopped_resumed_lwps): Call
	linux_nat_prepare_to_resume before resuming.
	(linux_stop_lwp): New.
	(linux_nat_set_new_thread): Adjust.
	(linux_nat_set_prepare_to_resume): New.
	* linux-nat.h (struct arch_lwp_info): Forward declare.
	(struct lwp_info) <arch_private>: New field.
	(linux_stop_lwp): Declare.
	(linux_nat_set_new_thread): Adjust.
	(linux_nat_set_prepare_to_resume): New.

	* i386-nat.c (DR_NADDR, DR_STATUS, DR_CONTROL)
	(struct i386_debug_reg_state): Move to i386-nat.h.
	(dr_mirror): Comment.
	(i386_debug_reg_state): New.
	(i386_update_inferior_debug_regs): Simplify.
	(i386_stopped_data_address): Use the debug register state from the
	inferior, not from the local cache.
	* i386-nat.h (struct i386_dr_low_type): Delete reset_addr and
	unset_status fields.  New get_addr and get_control fields.
	(DR_FIRSTADDR, DR_LASTADDR, DR_CONTROL): Moved from i386-nat.c.
	(DR_NADDR, DR_STATUS): New.
	(struct i386_debug_reg_state): Moved from i386-nat.c.

	* amd64-linux-nat.c (struct arch_lwp_info): New.
	(amd64_linux_dr): Delete global.
	(amd64_linux_dr_get_addr): New.
	(amd64_linux_dr_get_control): New.
	(amd64_linux_dr_unset_status): Delete.
	(amd64_linux_dr_set_addr): Reimplement.
	(amd64_linux_dr_reset_addr): Delete.
	(update_debug_registers_callback): New.
	(amd64_linux_dr_set_control): Reimplement.
	(amd64_linux_dr_set_addr): Reimplement.
	(amd64_linux_prepare_to_resume): New.
	(amd64_linux_new_thread): Change parameter to an lwp pointer.
	Reimplement.
	(_initialize_amd64_linux_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	amd64_linux_dr_get_control as i386_dr_low.get_control.  Install
	amd64_linux_dr_get_addr as i386_dr_low.get_addr.  Install
	amd64_linux_prepare_to_resume.
	* i386-linux-nat.c (DR_FIRSTADDR, DR_LASTADDR, DR_STATUS)
	(DR_CONTROL): Delete.
	(struct arch_lwp_info): New.
	(i386_linux_dr): Delete global.
	(i386_linux_dr_set_control): Reimplement.
	(i386_linux_dr_get_addr): New.
	(i386_linux_dr_set_addr): Reimplement.
	(i386_linux_dr_get_control): New.
	(update_debug_registers_callback): New.
	(i386_linux_dr_unset_status): Delete.
	(i386_linux_dr_set_addr): Reimplement.
	(i386_linux_prepare_to_resume): New.
	(i386_linux_new_thread): Change parameter to an lwp pointer.
	Reimplement.
	(_initialize_i386_linux_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	i386_linux_dr_get_control as i386_dr_low.get_control.  Install
	i386_linux_dr_get_addr as i386_dr_low.get_addr.  Install
	i386_linux_prepare_to_resume.

	* arm-linux-nat.c (arm_linux_new_thread): Change parameter to an
	lwp pointer.  Adjust.
	* ia64-linux-nat.c (ia64_linux_new_thread): Likewise.
	* mips-linux-nat.c (mips_linux_new_thread): Likewise.
	* ppc-linux-nat.c (ppc_linux_new_thread): Likewise.
	* s390-nat.c (s390_fix_watch_points): Likewise.

	* i386-darwin-nat.c (DR_FIRSTADDR, DR_LASTADDR, DR_STATUS)
	(DR_CONTROL): Delete.
	(i386_darwin_dr_reset_addr): Delete.
	(i386_darwin_dr_get_addr): New.
	(i386_darwin_dr_get_control): New.
	* go32-nat.c
	(go32_get_dr7, go32_get_dr): New.
	(init_go32_ops): No longer install i386_dr_low.reset_addr.
	Install go32_get_dr7 as i386_dr_low.get_control.  Install
	go32_get_dr as i386_dr_low.get_addr.
	* i386bsd-nat.c (i386bsd_dr_get): New.
	(i386bsd_dr_reset_addr): Delete.
	(i386bsd_dr_get_addr): New.
	(i386bsd_dr_get_status): Use i386bsd_dr_get.
	(i386bsd_dr_get_control): New.
	* i386bsd-nat.h (i386bsd_dr_reset_addr): Delete.
	(i386bsd_dr_get_addr): New.
	(i386bsd_dr_get_control): New.
	* i386fbsd-nat.c (_initialize_i386fbsd_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	i386bsd_dr_get_control as i386_dr_low.get_control.  Install
	i386bsd_dr_get_addr as i386_dr_low.get_addr.
	* windows-nat.c (init_windows_ops): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	cygwin_get_dr7 as i386_dr_low.get_control.  Install cygwin_get_dr
	as i386_dr_low.get_addr.
	(cygwin_get_dr): New.
	(cygwin_get_dr7): New.

gdb/testsuite/
2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	PR threads/10729

	* gdb.mi/watch-nonstop.c: New file.
 	* gdb.mi/mi-watch-nonstop.exp: New file.
@
text
@d535 1
a535 1
    s390_fix_watch_points (lp->ptid);
d563 1
a563 1
    s390_fix_watch_points (lp->ptid);
@


1.35
log
@ChangeLog:

	* s390-tdep.h (S390_ORIG_R2_REGNUM): Define.
	(S390_LAST_BREAK_REGNUM): Likewise.
	(S390_SYSTEM_CALL_REGNUM): Likewise.
	(S390_NUM_REGS): Update.

	(s390_regmap_last_break): Add declaration.
	(s390x_regmap_last_break): Likewise.
	(s390_regmap_system_call): Likewise.

	(tdesc_s390_linux32v1): Add declaration.
	(tdesc_s390_linux32v2): Likewise.
	(tdesc_s390_linux64v1): Likewise.
	(tdesc_s390_linux64v2): Likewise.
	(tdesc_s390x_linux64v1): Likewise.
	(tdesc_s390x_linux64v2): Likewise.

	* s390-tdep.c: Include new target description files
	"features/s390-linux32v1.c", "features/s390-linux32v2.c",
	"features/s390-linux64v1.c", "features/s390-linux64v2.c",
	"features/s390x-linux64v1.c", and "features/s390x-linux64v2.c".
	(s390_cannot_store_register): New function.
	(s390_write_pc): Likewise.
	(s390_dwarf_regmap): Add fields for new registers.
	(s390_regmap_gregset): Likewise.
	(s390x_regmap_gregset): Likewise.
	(s390_regmap_fpregset): Likewise.
	(s390_regmap_upper): Likewise.
	(s390_regmap_last_break): New variable.
	(s390x_regmap_last_break): Likewise.
	(s390_regmap_system_call): Likewise.
	(s390_last_break_regset): Likewise.
	(s390x_last_break_regset): Likewise.
	(s390_system_call_regset): Likewise.
	(s390_upper_regset_sections): Rename to ...
	(s390_linux64_regset_sections): ... this.
	(s390_linux32_regset_sections): New variable.
	(s390x_linux64_regset_sections): Likewise.
	(s390_linux32v1_regset_sections): Likewise.
	(s390_linux32v2_regset_sections): Likewise.
	(s390_linux64v1_regset_sections): Likewise.
	(s390_linux64v2_regset_sections): Likewise.
	(s390x_linux64v1_regset_sections): Likewise.
	(s390x_linux64v2_regset_sections): Likewise.
	(s390_regset_from_core_section): Handle .reg-s390-last-break and
	.reg-s390-system-call core file sections.
	(s390_core_read_description): Check for presence of
	.reg-s390-last-break and .reg-s390-system-call core file
	sections and return appropriate target description.
	(s390_gdbarch_init): Detect Linux-specific registers "orig_r2",
	"last_break" and "system_call" in target description.  Install
	appropriate gdbarch_core_regset_sections array.
	Call set_gdbarch_cannot_store_register and set_gdbarch_write_pc.
	(_initialize_s390_tdep): Initialize additional target descriptions.

	* s390-nat.c: Include "elf/common.h".
	(PTRACE_GETREGSET, PTRACE_SETREGSET): Define if undefined.
	(have_regset_last_break): New static variable.
	(have_regset_system_call): Likewise.
	(s390_native_supply): Handle S390_ORIG_R2_REGNUM.
	(s390_native_collect): Likewise.
	(fetch_regset, store_regset, check_regset): New functions.
	(s390_linux_fetch_inferior_registers): Handle S390_LAST_BREAK_REGNUM
	and S390_SYSTEM_CALL_REGNUM.
	(s390_linux_store_inferior_registers): Likewise.
	(s390_read_description): Check for presence of NT_S390_LAST_BREAK
	and NT_S390_SYSTEM_CALL regsets and use appropriate description.

	* features/Makefile (WHICH): Add s390-linux32v1, s390-linux64v1,
	s390x-linux64v1, s390-linux32v2, s390-linux64v2, and s390x-linux64v2.
	(s390-linux32v1-expedite): Define.
	(s390-linux32v2-expedite): Likewise.
	(s390-linux64v1-expedite): Likewise.
	(s390-linux64v2-expedite): Likewise.
	(s390x-linux64v1-expedite): Likewise.
	(s390x-linux64v2-expedite): Likewise.

	* features/s390-linux32.xml: Add orig_r2 register.
	* features/s390-linux64.xml: Likewise.
	* features/s390x-linux64.xml: Likewise.
	* features/s390-linux32v1.xml: New file.
	* features/s390-linux32v2.xml: Likewise.
	* features/s390-linux64v1.xml: Likewise.
	* features/s390-linux64v2.xml: Likewise.
	* features/s390x-linux64v1.xml: Likewise.
	* features/s390x-linux64v2.xml: Likewise.

	* features/s390-linux32.c: Regenerate.
	* features/s390-linux64.c: Likewise.
	* features/s390x-linux64.c: Likewise.
	* features/s390-linux32v1.c: New generated file.
	* features/s390-linux32v2.c: Likewise.
	* features/s390-linux64v1.c: Likewise.
	* features/s390-linux64v2.c: Likewise.
	* features/s390x-linux64v1.c: Likewise.
	* features/s390x-linux64v2.c: Likewise.

	* regformats/s390-linux32.dat: Regenerate.
	* regformats/s390-linux64.dat: Regenerate.
	* regformats/s390x-linux64.dat: Regenerate.
	* regformats/s390-linux32v1.dat: New generated file.
	* regformats/s390-linux32v2.dat: Likewise.
	* regformats/s390-linux64v1.dat: Likewise.
	* regformats/s390-linux64v2.dat: Likewise.
	* regformats/s390x-linux64v1.dat: Likewise.
	* regformats/s390x-linux64v2.dat: Likewise.

gdbserver/ChangeLog:

	* Makefile.in (s390-linux32v1.o, s390-linux32v1.c): New rules.
	(s390-linux32v2.o, s390-linux32v2.c): Likewise.
	(s390-linux64v1.o, s390-linux64v1.c): Likewise.
	(s390-linux64v2.o, s390-linux64v2.c): Likewise.
	(s390x-linux64v1.o, s390x-linux64v1.c): Likewise.
	(s390x-linux64v2.o, s390x-linux64v2.c): Likewise.
	* configure.srv [s390*-*-linux*] (srv_regobj): Add new objects.
	(srv_xmlfiles): Add new XML files.

	* linux-s390-low.c: Include "elf/common.h", <sys/ptrace.h>,
	and <sys/uio.h>.
	(PTRACE_GETREGSET, PTRACE_SETREGSET): Define if undefined.
	(init_registers_s390_linux32v1): Add prototype.
	(init_registers_s390_linux32v2): Likewise.
	(init_registers_s390_linux64v1): Likewise.
	(init_registers_s390_linux64v2): Likewise.
	(init_registers_s390x_linux64v1): Likewise.
	(init_registers_s390x_linux64v2): Likewise.
	(s390_num_regs): Increment to 52.
	(s390_regmap): Add orig_r2 register.
	(s390_num_regs_3264): Increment to 68.
	(s390_regmap_3264): Add orig_r2 register.
	(s390_collect_ptrace_register): Handle orig_r2 register.
	(s390_supply_ptrace_register): Likewise.
	(s390_fill_last_break): New function.
	(s390_store_last_break): Likewise.
	(s390_fill_system_call): New function.
	(s390_store_system_call): Likewise.
	(target_regsets): Handle NT_S390_LAST_BREAK and NT_S390_SYSTEM_CALL
	register sets.
	(s390_check_regset): New function.
	(s390_arch_setup): Check for presence of NT_S390_LAST_BREAK and
	NT_S390_SYSTEM_CALL regsets and use appropriate description.
	Update target_regsets for available register sets.

testsuite/ChangeLog:

	* gdb.base/callfuncs.exp (fetch_all_registers): Filter out read-only
	last_break register on s390*-*-* targets.
@
text
@d475 1
a475 1
s390_fix_watch_points (ptid_t ptid)
d485 1
a485 1
  tid = TIDGET (ptid);
d487 1
a487 1
    tid = PIDGET (ptid);
@


1.35.2.1
log
@Update the copyright header of various files...

... to follow the correct syntax (according to the gospel of
gnulib's update-copyright). In other words:
  - no comma after the last year;
  - FSF spelled exactly "Free Software Foundation, Inc.", with
    the comma and the period at the end.

sim/common/ChangeLog:

	* dv-sockser.h, sim-assert.h, sim-fpu.c: Reformat the copyright
	header.

sim/m32c/ChangeLog:

	* blinky.S, gloss.S, sample.S: Reformat copyright header.

sim/mn10300/ChangeLog:

	* sim-main.h: Reformat copyright header.

sim/ppc/ChangeLog:

	* dp-bit.c: Reformat copyright header.

gdb/ChangeLog:

        * gdb/common/gdb_thread_db.h, gdb/dbxread.c, gdb/environ.c,
        gdb/gcore.h, gdb/rs6000-tdep.h, gdb/s390-nat.c, gdb/tic6x-tdep.c:
        Reformat the copyright header.

gdb/gdbserver/ChangeLog:

	* terminal.h: Reformat copyright header.

gdb/testsuite/ChangeLog:

	* dg-extract-results.sh, gdb.arch/gcore.c, gdb.arch/gdb1558.c,
	gdb.arch/i386-gnu-cfi.c, gdb.base/complex.c, gdb.base/cvexpr.c,
	gdb.base/gcore.c, gdb.base/gdb1555-main.c, gdb.base/gdb1555.c,
	gdb.base/gdb1821.c, gdb.base/long_long.c, gdb.base/restore.c,
	gdb.base/sepdebug.c, gdb.base/type-opaque-lib.c,
	gdb.base/type-opaque-main.c, gdb.cp/maint.exp, gdb.cp/namespace1.cc,
	gdb.cp/pr9631.cc, gdb.cp/psmang1.cc, gdb.cp/psmang2.cc,
	gdb.cp/try_catch.cc, gdb.cp/virtfunc.cc, gdb.hp/gdb.base-hp/reg.exp,
	gdb.mi/basics.c, gdb.mi/mi-stack.c, gdb.mi/mi-var-child.c,
	gdb.mi/mi2-var-child.exp, gdb.mi/var-cmd.c,
	gdb.threads/thread_check.c: Reformat copyright header.
@
text
@d3 1
a3 1
   Free Software Foundation, Inc.
@


1.35.2.2
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright (C) 2001, 2003-2007, 2009, 2012 Free Software Foundation,
   Inc.
@


1.34
log
@ChangeLog:

	* s390-nat.c (SUBOFF): Remove.
	(s390_native_supply, s390_native_collect): New functions.
	(supply_gregset, supply_fpregset): Use s390_native_supply.
	(fill_gregset, fill_fpregset): Use s390_native_collect.

	* s390-tdep.c (s390_pseudo_register_reggroup_p): Update comment.
	(s390_unwind_pseudo_register): New function.
	(s390_prologue_frame_unwind_cache): Unwind PSW address and mask
	registers instead of PC and CC.
	(s390_backchain_frame_unwind_cache): Likewise.
	(s390_sigtramp_frame_unwind_cache): Do not unwind PC, CC, or
	full GPR pseudos.
	(s390_trad_frame_prev_register): New function.
	(s390_frame_prev_register): Use it.
	(s390_sigtramp_frame_prev_register): Likewise.
	(s390_dwarf2_prev_register): Use s390_unwind_pseudo_register.
	(s390_dwarf2_frame_init_reg): Unwind PSW address and mask.  Use
	special callback to unwind any pseudo.

	* features/s390-core32.xml: Add pswm/pswa to save/restore group.
	* features/s390-core64.xml: Likewise.
	* features/s390x-core64.xml: Likewise.
	* features/s390-linux32.c: Regenerate.
	* features/s390-linux64.c: Likewise.
	* features/s390x-linux64.c: Likewise.

gdbserver/ChangeLog:

	* linux-s390-low.c (s390_collect_ptrace_register): Fully convert
	PSW address/mask between 8-byte and 16-byte formats.
	(s390_supply_ptrace_register): Likewise.
	(s390_get_pc, s390_set_pc): 4-byte PSW address always includes
	basic addressing mode bit.
@
text
@d31 1
d44 10
d111 2
a112 1
      if (regno >= S390_R0_REGNUM && regno <= S390_R15_REGNUM)
d166 2
a167 1
      if (regno >= S390_R0_REGNUM && regno <= S390_R15_REGNUM)
d309 64
d388 11
d416 7
d637 7
d652 3
a654 1
    return tdesc_s390x_linux64;
d657 3
a659 1
    return tdesc_s390_linux64;
d665 3
a667 1
  return tdesc_s390_linux32;
@


1.33
log
@2011-10-07  Pedro Alves  <pedro@@codesourcery.com>

	* linux-nat.h (ALL_LWPS): Remove the ptid parameter.
	* amd64-linux-nat.c (amd64_linux_dr_set_control)
	(amd64_linux_dr_set_addr, amd64_linux_dr_unset_status): Adjust.
	* arm-linux-nat.c (arm_linux_insert_hw_breakpoint)
	(arm_linux_remove_hw_breakpoint, arm_linux_insert_watchpoint)
	(arm_linux_remove_watchpoint): Adjust.
	* i386-linux-nat.c (i386_linux_dr_set_control)
	(i386_linux_dr_set_addr, i386_linux_dr_unset_status): Adjust.
	* ia64-linux-nat.c (ia64_linux_insert_watchpoint)
	(ia64_linux_remove_watchpoint): Adjust.
	* mips-linux-nat.c (write_watchpoint_regs): Adjust.
	* ppc-linux-nat.c (ppc_linux_insert_hw_breakpoint)
	(ppc_linux_insert_hw_breakpoint, ppc_linux_remove_hw_breakpoint)
	(ppc_linux_insert_mask_watchpoint)
	(ppc_linux_remove_mask_watchpoint, ppc_linux_insert_watchpoint)
	(ppc_linux_remove_watchpoint): Adjust.
	* s390-nat.c (s390_insert_watchpoint, s390_remove_watchpoint):
	Adjust.
@
text
@d58 57
d116 44
a159 6
#define SUBOFF(gdbarch, i) \
	((gdbarch_ptr_bit (gdbarch) == 32 \
	  && ((i) == S390_PSWA_REGNUM \
	      || ((i) >= S390_R0_REGNUM && (i) <= S390_R15_REGNUM)))? 4 : 0)
#else
#define SUBOFF(gdbarch, i) 0
d162 3
a170 1
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
d173 1
a173 4
    if (regmap_gregset[i] != -1)
      regcache_raw_supply (regcache, i, 
			   (const char *)regp + regmap_gregset[i]
			     + SUBOFF (gdbarch, i));
a181 1
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
d184 2
a185 5
    if (regmap_gregset[i] != -1)
      if (regno == -1 || regno == i)
	regcache_raw_collect (regcache, i, 
			      (char *)regp + regmap_gregset[i]
				+ SUBOFF (gdbarch, i));
d195 1
a195 3
    if (regmap_fpregset[i] != -1)
      regcache_raw_supply (regcache, i,
			   (const char *)regp + regmap_fpregset[i]);
d206 2
a207 4
    if (regmap_fpregset[i] != -1)
      if (regno == -1 || regno == i)
        regcache_raw_collect (regcache, i, 
			      (char *)regp + regmap_fpregset[i]);
@


1.32
log
@2010-07-07  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Support for hw accelerated condition watchpoints in booke powerpc.

	* breakpoint.c (fetch_watchpoint_value): Rename to fetch_subexp_value
	and move to eval.c.  Change callers.
	(insert_bp_location): Pass watchpoint condition in
	target_insert_watchpoint.
	(remove_breakpoint_1) Pass watchpoint condition in
	target_remove_watchpoint.
	(watchpoint_locations_match): Call
	target_can_accel_watchpoint_condition.
	* eval.c: Include wrapper.h.
	(fetch_subexp_value): Moved from breakpoint.c.
	* ppc-linux-nat.c (ppc_linux_region_ok_for_hw_watchpoint):
	Formatting fix.
	(can_use_watchpoint_cond_accel): New function.
	(calculate_dvc): Likewise.
	(num_memory_accesses): Likewise.
	(check_condition): Likewise.
	(ppc_linux_can_accel_watchpoint_condition): Likewise
	(ppc_linux_insert_watchpoint): Call can_use_watchpoint_cond_accel,
	check_condition and calculate_dvc.
	(ppc_linux_remove_watchpoint): Likewise.
	(_initialize_ppc_linux_nat): Set to_can_accel_watchpoint_condition to
	ppc_linux_can_accel_watchpoint_condition
	* target.c (debug_to_insert_watchpoint): Add argument for watchpoint
	condition.
	(debug_to_remove_watchpoint): Likewise.
	(debug_to_can_accel_watchpoint_condition): New function.
	(update_current_target): Set to_can_accel_watchpoint_condition.
	(setup_target_debug): Set to_can_accel_watchpoint_condition.
	* target.h: Add opaque declaration for struct expression.
	(struct target_ops) <to_insert_watchpoint>,
	<to_remove_watchpoint>: Add new arguments to pass the watchpoint
	<to_can_accel_watchpoint_condition>: New member.
	condition.  Update all callers and implementations.
	(target_can_accel_watchpoint_condition): New macro.
	* value.c (free_value_chain): New function.
	* value.h (fetch_subexp_value): New prototype.
	(free_value_chain): Likewise.
@
text
@a341 1
  ptid_t ptid;
d353 2
a354 2
  ALL_LWPS (lp, ptid)
    s390_fix_watch_points (ptid);
a362 1
  ptid_t ptid;
d381 2
a382 2
  ALL_LWPS (lp, ptid)
    s390_fix_watch_points (ptid);
@


1.31
log
@        * features/Makefile (WHICH): Add s390-linux32, s390-linux64,
	and s390x-linux64.
	(s390-linux32-expedite): Define.
	(s390-linux64-expedite): Define.
	(s390x-linux64-expedite): Define.
	* features/s390-acr.xml: New file.
	* features/s390-fpr.xml: New file.
	* features/s390-core32.xml: New file.
	* features/s390-core64.xml: New file.
	* features/s390x-core64.xml: New file.
	* features/s390-linux32.xml: New file.
	* features/s390-linux64.xml: New file.
	* features/s390x-linux64.xml: New file.
	* features/s390-linux32.c: New generated file.
	* features/s390-linux64.c: New generated file.
	* features/s390x-linux64.c: New generated file.

	* regformats/s390-linux32.dat: New generated file.
	* regformats/s390-linux64.dat: New generated file.
	* regformats/s390x-linux64.dat: New generated file.
	* regformats/reg-s390.dat: Remove.
	* regformats/reg-s390x.dat: Remove.

	* s390-nat.c: Include "auxv.h" and <elf.h>.
	(HWCAP_S390_HIGH_GPRS): Define if undefined.
	(s390_target_wordsize): New function.
	(s390_auxv_parse): Likewise.
	(s390_get_hwcap): Likewise.
	(s390_read_description): Likewise.
	(_initialize_s390_nat): Install s390_auxv_parse and
	s390_read_description.

	* s390-tdep.c: Include "features/s390-linux32.c",
	"features/s390-linux64.c", and "features/s390x-linux64.c".
	(struct gdbarch_tdep): Add gpr_full_regnum, pc_regnum, and cc_regnum.
	(s390_register_call_saved): New function.
	(s390_register_name): Remove.
	(s390_register_type): Remove.
	(s390_dwarf_regmap): Add lower half GPR pseudo DWARF CFI regnums.
	(s390_dwarf_reg_to_regnum): Remap GPR regnums to full GPRs.
	(s390_adjust_frame_regnum): Remap GPR regnums to lower halves for CFI.
	(s390_pseudo_register_name): New function.
	(s390_pseudo_register_type): New function.
	(s390_pseudo_register_read): Handle both 32-bit and 64-bit cases.
	Handle full GPR pesudos and varying pseudo register numbers.
	(s390_pseudo_register_write): Likewise
	(s390x_pseudo_register_read): Remove.
	(s390x_pseudo_register_write): Likewise.
	(s390_register_group): Remove.
	(s390_pseudo_register_group): New function.
	(s390_regmap_gregset): Add GPR upper halves.
	(s390x_regmap_gregset): Likewise.
	(s390_regmap_fpregset): Likewise.
	(s390_regmap_upper): New global variable.
	(s390_upper_regset): New global variable.
	(s390_upper_regset_sections): New global variable.
	(s390_regset_from_core_section): Handle GPR upper halves.
	(s390_core_read_description): New function.
	(s390_prologue_frame_unwind_cache): Set up ABI call-saved/clobbered
	register information.  Handle varying pseudo register numbers.
	(s390_backchain_frame_unwind_cache): Likewise.
	(s390_frame_prev_register): Unwind full GPRs to show lower halves.
	(s390_stub_frame_unwind_cache): Handle varying pseudo register numbers.
	(s390_sigtramp_frame_unwind_cache): Unwind PSWM and PSWA as well as
	PC and CC pseudos.  Unwind upper halves and full GPRs as appropriate.
	Handle varying pseudo register numbers.
	(s390_unwind_pc): Handle varying pseudo register numbers.
	(s390_dwarf2_prev_register): New function.
	(s390_dwarf2_frame_init_reg): Set up ABI call-saved/clobbered
	register information.  Handle varying pseudo register numbers.
	Install s390_dwarf2_prev_register to unwind full GPRs.
	(s390_gdbarch_init): Handle target descriptions.  Assign varying
	pseudo register numbers.  Install s390_adjust_frame_regnum.
	(_initialize_s390_tdep): Initialize target descriptions.

	* s390-tdep.h (S390_R0_UPPER_REGNUM .. S390_R15_UPPER_REGNUM): Define.
	(S390_NUM_REGS): Redefine to include upper half registers.
	(S390_PC_REGNUM, S390_CC_REGNUM): Remove.
	(S390_NUM_PSEUDO_REGS, S390_NUM_TOTAL_REGS): Likewise.
	(tdesc_s390_linux32): Add declaration.
	(tdesc_s390_linux64): Likewise.
	(tdesc_s390x_linux64): Likewise.

gdb/testsuite/
	* gdb.xml/tdesc-regs.exp: Support s390*-*-* targets.

gdbserver/
	* Makefile.in (clean): Remove new generated files.
	(reg-s390.o, reg-s390.c): Remove rules.
	(reg-s390x.o, reg-s390x.c): Likewise.
	(s390-linux32.o, s390-linux32.c): Add rules.
	(s390-linux64.o, s390-linux64.c): Likewise.
	(s390x-linux64.o, s390x-linux64.c): Likewise.
	* configure.srv (s390*-*-linux*): Update srv_regobj and srv_xmlfiles.
	* linux-s390-low.c: Include <elf.h>.
	(HWCAP_S390_HIGH_GPRS): Define if undefined.
	(init_registers_s390): Remove prototype.
	(init_registers_s390x): Likewise.
	(init_registers_s390_linux32): Add prototype.
	(init_registers_s390_linux64): Likewise.
	(init_registers_s390x_linux64): Likewise.
	(s390_num_regs_3264): New define.
	(s390_regmap_3264): New global variable.
	(s390_cannot_fetch_register): Remove obsolete check.
	(s390_cannot_store_register): Likewise.
	(s390_collect_ptrace_register): Handle upper/lower register halves.
	(s390_supply_ptrace_register): Likewise.
	(s390_fill_gregset): Update to register number changes.
	(s390_get_hwcap): New routine.
	(s390_arch_setup): Detect 32-bit process running on 64-bit system.
	Install appropriate regmap and register set.
@
text
@d338 2
a339 1
s390_insert_watchpoint (CORE_ADDR addr, int len, int type)
d360 2
a361 1
s390_remove_watchpoint (CORE_ADDR addr, int len, int type)
@


1.30
log
@gdb/
	* s390-nat.c (s390_can_use_hw_breakpoint): Only support breakpoints
	of type bp_hardware_watchpoint.

gdb/testsuite/

	* gdb.base/hbreak.exp: Disable for s390*-*-* targets.
	* gdb.base/watchpoint-hw-hit-once.exp: Likewise.
	* gdb.threads/watchthreads-reorder.exp: Likewise.
@
text
@d28 1
d37 5
d398 77
d498 4
@


1.29
log
@2009-11-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-nat.c: Update copyright.
@
text
@d383 1
a383 1
  return 1;
@


1.28
log
@	* corelow.c (get_core_registers): Adjust.
	(core_file_thread_alive): Rename to...
	(core_thread_alive): ... this.
	(core_pid_to_str): Try gdbarch_core_pid_to_str first.
	(init_core_ops): Adjust.
	(coreops_suppress_target): Delete.
	(_initialize_corelow): Unconditionally add core_ops.
	* procfs.c: Include "inf-child.h".
	(procfs_ops): Delete.
	(init_procfs_ops): Delete.  Reimplement as...
	(procfs_target): ... this, inheriting from inf-child.
	(procfs_attach, procfs_detach, procfs_fetch_registers): Adjust.
	(procfs_prepare_to_store): Delete.
	(procfs_store_registers, procfs_resume): Adjust.
	(procfs_open): Delete.
	(procfs_suppress_run): Delete.
	(procfs_can_run): Delete.
	(procfs_mourn_inferior): Adjust.
	(procfs_init_inferior): Add target_ops parameter.  Adjust.
	(procfs_create_inferior): Don't pass procfs_init_inferior to
	fork_inferior.  Instead call it after fork_inferior returns.
	(procfs_find_new_threads): Adjust.
	(_initialize_procfs): Adjust to use procfs_target instead of
	init_procfs_ops.
	* sol-thread.c (orig_core_ops, sol_core_ops): Delete.
	(lwp_to_thread): Use target_thread_alive.
	(sol_thread_open): Delete.
	(sol_thread_attach): Delete.
	(sol_thread_detach, sol_thread_resume, sol_thread_wait)
	(sol_thread_fetch_registers, sol_thread_store_registers): Adjust
	to use find_target_beneath.
	(sol_thread_prepare_to_store, sol_thread_xfer_memory): Delete.
	(sol_thread_xfer_partial): Adjust to use find_target_beneath.
	(sol_thread_files_info, sol_thread_kill_inferior): Delete.
	(check_for_thread_db): New.
	(sol_thread_notice_signals, sol_thread_create_inferior): Delete.
	(sol_thread_new_objfile): Call check_for_thread_db.
	(sol_thread_mourn_inferior): Adjust to use find_target_beneath.
	(sol_thread_can_run): Delete.
	(sol_thread_alive): Adjust to use find_target_beneath.
	(sol_thread_stop): Delete.
	(rw_common): Use target_write_memory or target_read_memory.
	(ps_lgetregs, ps_lgetfpregs): Use target_fetch_registers.
	(ps_lsetregs, ps_lsetfpregs): Use target_store_registers.
	(solaris_pid_to_str): Remove check for libthread_db initialization
	failing.
	(sol_find_new_threads): Remove check for libthread_db
	initialization failing, or for an invalid inferior_ptid.  Adjust
	to use find_target_beneath.
	(sol_core_open, sol_core_close, sol_core_detach,
	sol_core_files_info, sol_find_memory_regions,
	sol_make_note_section, ignore): Delete.
	(init_sol_thread_ops): Make it a thread_stratum target.  Remove
	unneeded callback settings.
	(init_sol_core_ops): Delete.
	(_initialize_sol_thread): No longer call init_sol_core_ops, set
	procfs_suppress_run, or hack with core_ops.

	* target.h (struct target_ops): Add a target_ops * parameter to
	to_resume, to_fetch_registers, to_store_registers, to_thread_alive
	and to_find_new_threads.
	(target_fetch_registers, target_store_registers)
	(target_thread_alive, target_find_new_threads): Redeclare as
	function.

	* target.c (update_current_target): Do not inherit or de_fault
	to_resume, to_fetch_registers, to_store_registers,
	to_thread_alive, to_find_new_threads.
	(target_resume): Adjust.
	(target_thread_alive, target_find_new_threads): New.
	(debug_to_resume, debug_to_fetch_registers): Delete.
	(target_fetch_registers): New.
	(debug_to_store_registers): Delete.
	(target_store_registers): New.
	(debug_to_thread_alive, debug_to_find_new_threads): Delete.
	(setup_target_debug): Adjust.

	* gdbcore.h (core_ops): Delete declaration.

	* inf-ptrace.c, linux-nat.c, remote.c, amd64-linux-nat.c,
	inf-child.c, linux-thread-db.c, bsd-uthread.c, inf-ttrace.c,
	i386-sol2-tdep.c, darwin-nat.c, gnu-nat.c, go32-nat.c,
	hpux-thread.c, i386-linux-nat.c, i386fbsd-nat.c, monitor.c,
	nto-procfs.c, remote-m32r-sdi.c, remote-mips.c, windows-nat.c,
	alphabsd-nat.c, amd64bsd-nat.c, arm-linux-nat.c, armnbsd-nat.c,
	bsd-kvm.c, hppa-hpux-nat.c, hppa-linux-nat.c, hppabsd-nat.c,
	hppanbsd-nat.c, i386-darwin-nat.c, i386bsd-nat.c,
	ia64-linux-nat.c, m32r-linux-nat.c, m68kbsd-nat.c,
	m68klinux-nat.c, m88kbsd-nat.c, mips-linux-nat.c,
	mips64obsd-nat.c, mipsnbsd-nat.c, ppc-linux-nat.c, ppcnbsd-nat.c,
	ppcobsd-nat.c, remote-sim.c, rs6000-nat.c, s390-nat.c,
	shnbsd-nat.c, sparc-nat.c, sparc-nat.h, spu-linux-nat.c,
	vaxbsd-nat.c, xtensa-linux-nat.c: Adjust to target_ops changes.

	* gdbarch.sh (core_pid_to_str): New gdbarch callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* sol2-tdep.c: Include "inferior.h".
	(sol2_core_pid_to_str): New.
	* sol2-tdep.h (sol2_core_pid_to_str): Declare.

	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Set it.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Set it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Set it.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Set it.
@
text
@d2 1
a2 1
   Copyright (C) 2001, 2003, 2004, 2005, 2006
@


1.27
log
@2007-11-07  Markus Deuling  <deuling@@de.ibm.com>

	* s390-nat.c (supply_gregset, fill_gregset): Use get_regcache_arch to
	get at the current architecture by regcache.
	(SUBOFF): Add gdbarch to macro definition.
@
text
@d207 2
a208 1
s390_linux_fetch_inferior_registers (struct regcache *regcache, int regnum)
d224 2
a225 1
s390_linux_store_inferior_registers (struct regcache *regcache, int regnum)
@


1.26
log
@	* linux-nat.c (linux_nat_new_thread): New variable.
	(linux_child_follow_fork): Set inferior_ptid to include LWP ID.  Use
	linux_nat_switch_fork.
	(lwp_list): Make public.
	(add_lwp): Call linux_nat_new_thread.
	(lin_lwp_attach_lwp, linux_nat_attach): Call add_lwp after stopping
	the new thread.
	(resume_callback): Clear lp->siginfo.  Remove unused variable.
	(linux_nat_resume): Assert that the LWP list is already initialized.
	Clear lp->siginfo.
	(save_siginfo): New.
	(stop_wait_callback, linux_nat_wait): Call it.
	(linux_nat_set_new_thread, linux_nat_get_siginfo): New.
	* linux-nat.h (struct lwp_info): Add siginfo.
	(lwp_list, linux_nat_set_new_thread, linux_nat_get_siginfo): Declare.
	(ALL_LWPS): Define.

	* amd64-linux-nat.c (amd64_linux_dr): New.
	(amd64_linux_dr_get): Take a PTID argument.  Correct typo.
	(amd64_linux_dr_set): Take a PTID argument.
	(amd64_linux_dr_set_control, amd64_linux_dr_set_addr): Use ALL_LWPS.
	(amd64_linux_dr_reset_addr): Use amd64_linux_dr_set_addr.
	(amd64_linux_dr_get_status): Pass inferior_ptid to amd64_linux_dr_get.
	(amd64_linux_new_thread): New.
	(_initialize_amd64_linux_nat): Call linux_nat_set_new_thread.
	* i386-linux-nat.c (i386_linux_dr): New.
	(i386_linux_dr_get, i386_linux_dr_set): Take a PTID argument.
	(i386_linux_dr_set_control, i386_linux_dr_set_addr): Use ALL_LWPS.
	(i386_linux_dr_reset_addr): Use i386_linux_dr_set_addr.
	(i386_linux_dr_get_status): Pass inferior_ptid to i386_linux_dr_get.
	(i386_linux_new_thread): New.
	(i386_linux_resume): Remove unnecessary PID check.
	(_initialize_i386_linux_nat): Call linux_nat_set_new_thread.
	* ia64-linux-nat.c (enable_watchpoints_in_psr): Take PTID argument.
	(fetch_debug_register, fetch_debug_register_pair): Delete.
	(debug_registers): New.
	(ia64_linux_insert_watchpoint, ia64_linux_remove_watchpoint): Use
	ALL_LWPS and debug_registers.
	(ia64_linux_new_thread): New.
	(ia64_linux_stopped_data_address): Use linux_nat_get_siginfo.
	(_initialize_ia64_linux_nat): Call linux_nat_set_new_thread.
	* ppc-linux-nat.c (last_stopped_data_address): Delete.
	(saved_dabr_value): New.
	(ppc_linux_insert_watchpoint, ppc_linux_remove_watchpoint): Use
	ALL_LWPS.
	(ppc_linux_new_thread): New.
	(ppc_linux_stopped_data_address): Use linux_nat_get_siginfo.
	(ppc_linux_stopped_by_watchpoint): Call ppc_linux_stopped_data_address.
	(_initialize_ppc_linux_nat): Call linux_nat_set_new_thread.
	* s390-nat.c (s390_stopped_by_watchpoint): Clear the watchpoint status
	after reading it.
	(s390_fix_watch_points): Take a PTID argument.
	(s390_insert_watchpoint, s390_remove_watchpoint): Use ALL_LWPS.
	(_initialize_s390_nat): Call linux_nat_set_new_thread.
@
text
@d53 2
a54 2
#define SUBOFF(i) \
	((gdbarch_ptr_bit (current_gdbarch) == 32 \
d58 1
a58 1
#define SUBOFF(i) 0
d67 1
d72 2
a73 1
			   (const char *)regp + regmap_gregset[i] + SUBOFF (i));
d82 1
d88 2
a89 1
			      (char *)regp + regmap_gregset[i] + SUBOFF (i));
@


1.25
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d255 1
d267 12
a278 2
  return per_lowcore.perc_storage_alteration == 1
	 && per_lowcore.perc_store_real_address == 0;
d282 1
a282 1
s390_fix_watch_points (void)
d284 1
a284 1
  int tid = s390_inferior_tid ();
d292 4
d328 2
d331 1
d341 2
a342 1
  s390_fix_watch_points ();
d349 2
d369 2
a370 1
  s390_fix_watch_points ();
d411 1
@


1.24
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_PTR_BIT): Replace with gdbarch_ptr_bit.
	* solib-svr4.c (svr4_truncate_ptr): Likewise.
	* solib-pa64.c (read_dynamic_info): Likewise.
	* solib-legacy.c (legacy_svr4_fetch_link_map_offsets): Likewise.
	* solib.c (info_sharedlibrary_command): Likewise.
	* s390-nat.c (SUBOFF): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	* procfs.c (info_proc_mappings): Likewise.
	* printcmd.c (decode_format): Likewise.
	* nto-tdep.c (nto_truncate_ptr): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips64_linux_get_longjmp_target): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* jv-valprint.c (java_value_print): Likewise.
	* jv-lang.c (get_java_object_header_size): Likewise.
	* hppa-tdep.c (skip_prologue_hard_way, hppa_frame_cache): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code)
	(hppa_hpux_unwind_adjust_stub): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
	* gdbtypes.c (make_pointer_type, make_reference_type)
	(smash_to_memberptr_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d21 1
a21 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.23
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@d56 1
a56 1
	((TARGET_PTR_BIT == 32 \
@


1.22
log
@	* gregset.h (struct regcache): Add forward declaration.
	(supply_gregset): Add REGCACHE parameter, make GREGS const.
	(supply_fpregset): Add REGCACHE parameter, make FPREGS const.
	(supply_fpxregset): Add REGCACHE parameter, make FPXREGS const.
	(fill_gregset): Add REGCACHE parameter.
	(fill_fpregset): Likewise.
	(fill_fpxregset): Likewise.

	Update all definitions accordingly:
	* alphabsd-nat.c, alpha-linux-nat.c, alpha-nat.c, amd64-linux-nat.c,
	arm-linux-nat.c, hppa-linux-nat.c, i386gnu-nat.c, i386-linux-nat.c,
	i386-sol2-nat.c, i386v4-nat.c, ia64-linux-nat.c, irix5-nat.c,
	m32r-linux-nat.c, m68klinux-nat.c, mips-linux-nat.c, ppc-linux-nat.c,
	s390-nat.c, sparc64-linux-nat.c, sparc-linux-nat.c, sparc-sol2-nat.c
	(supply_gregset): Add REGCACHE parameter, use it instead of
	current_regcache.  Make GREGSETP parameter const, adapt casts.
	(supply_fpregset): Add REGCACHE parameter, use it instead of
	current_regcache.  Make FPREGSETP parameter const, adapt casts.
	(fill_gregset): Add REGCACHE parameter, use it instead of
	current_regcache.
	(fill_fpregset): Likewise.

	Update all callers to pass in current_regcache as the new argument:
	* core-regset.c: Include "regcache.h".
	(fetch_core_registers): Update supply_gregset,and supply_fpregset calls.
	* procfs.c: Include "regcache.h".
	(procfs_fetch_registers): Update supply_gregset, supply_fpregset calls.
	(procfs_store_registers): Update fill_gregset, fill_fpregset calls.
	(procfs_do_thread_registers): Likewise.
	(procfs_make_note_section): Likewise.
	* proc-service.c: Include "regcache.h".
	(ps_lgetregs): Update fill_gregset call.
	(ps_lsetregs): Update supply_gregset call.
	(ps_lgetfpregs): Update fill_fpregset call.
	(ps_lsetfpregs): Update supply_fpregset call.
	* sol-thread.c (sol_thread_fetch_registers): Update supply_gregset,
	supply_fpregset calls.
	(sol_thread_store_registers): Update fill_gregset, fill_fpregset calls.
	(ps_lgetregs): Update fill_gregset call.
	(ps_lsetregs): Update supply_gregset call.
	(ps_lgetfpregs): Update fill_fpregset call.
	(ps_lsetfpregs): Update supply_fpregset call.

	* linux-nat.c (linux_nat_do_thread_registers): Update fill_gregset,
	fill_fpregset, and fill_fpxregset calls.
	* i386-linux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.
	(fetch_fpxregs): Update supply_fpxregset call.
	(store_fpxregs): Update fill_fpxregset call.
	* m32r-linux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	* m68klinux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.
	(fetch_core_registers): Update supply_gregset, supply_fpregset calls.
	* s390-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.

	* Makefile.in (core-regset.o, procfs.o, proc-service.o): Update
	dependencies.
@
text
@d131 1
a131 1
fetch_regs (int tid)
d142 1
a142 1
  supply_gregset (current_regcache, (const gregset_t *) &regs);
d148 1
a148 1
store_regs (int tid, int regnum)
d159 1
a159 1
  fill_gregset (current_regcache, &regs, regnum);
d168 1
a168 1
fetch_fpregs (int tid)
d179 1
a179 1
  supply_fpregset (current_regcache, (const fpregset_t *) &fpregs);
d185 1
a185 1
store_fpregs (int tid, int regnum)
d196 1
a196 1
  fill_fpregset (current_regcache, &fpregs, regnum);
d205 1
a205 1
s390_linux_fetch_inferior_registers (int regnum)
d211 1
a211 1
    fetch_regs (tid);
d215 1
a215 1
    fetch_fpregs (tid);
d221 1
a221 1
s390_linux_store_inferior_registers (int regnum)
d227 1
a227 1
    store_regs (tid, regnum);
d231 1
a231 1
    store_fpregs (tid, regnum);
@


1.21
log
@	* config/tm-linux.h: Delete file.
	* config/alpha/alpha-linux.mt (DEPRECATED_TM_FILE): Set to tm-alpha.h.
	* config/alpha/tm-alphalinux.h: Delete file.
	* config/arm/linux.mt (DEPRECATED_TM_FILE): Set to tm-arm.h
	* config/arm/tm-linux.h: Delete file.
	* config/i386/tm-linux.h: Do not include "config/tm-linux.h".
	* config/ia64/tm-linux.h: Do not include "config/tm-linux.h".
	* config/m32r/linux.mt (DEPRECATED_TM_FILE): Remove.
	* config/mips/tm-linux.h:  Do not include "config/tm-linux.h".
	* config/pa/linux.mt (DEPRECATED_TM_FILE): Set to tm-hppa.h.
	* config/pa/tm-linux.h: Delete file.
	* config/powerpc/tm-linux.h: Do not include "config/tm-linux.h".
	* config/s390/linux.mt (DEPRECATED_TM_FILE): Remove.
	* config/sh/linux.mt (DEPRECATED_TM_FILE): Set to tm-sh.h.
	* config/sh/tm-linux.h: Delete file.
	* alpha-linux-tdep.c: Include "symtab.h".
	(alpha_linux_init_abi): Call set_gdbarch_skip_trampoline_code.
	* i386-linux-tdep.c: Include "symtab.h".
	(i386_linux_init_abi): Call set_gdbarch_skip_trampoline_code.
	* ia64-linux-tdep.c: Include "symtab.h".
	(ia64_linux_init_abi): Call set_gdbarch_skip_trampoline_code.
	* m32r-linux-tdep.c: Include "symtab.h".
	(m32r_linux_init_abi): Call set_gdbarch_skip_trampoline_code.
	* mips-linux-tdep.c: Include "symtab.h".
	(mips_linux_init_abi): Call set_gdbarch_skip_trampoline_code.
	* sh-linux-tdep.c: Include "symtab.h".
	(sh_linux_init_abi): Call set_gdbarch_skip_trampoline_code.
	* s390-tdep.c (s390_gdbarch_init): Call
	set_gdbarch_skip_trampoline_code.
	* s390-nat.c: Do not include "tm.h".
	* Makefile.in (alpha-linux-tdep.o): Add dependency on $(symtab_h).
	(i386-linux-tdep.o): Likewise.
	(ia64-linux-tdep.o): Likewise.
	(m32r-linux-tdep.o): Likewise.
	(mips-linux-tdep.o): Likewise.
	(sh-linux-tdep.o): Likewise.
	(s390-nat.o): Remove dependency on $(tm_h).
@
text
@d67 1
a67 1
supply_gregset (gregset_t *regp)
d72 2
a73 2
      regcache_raw_supply (current_regcache, i, 
			   (char *)regp + regmap_gregset[i] + SUBOFF (i));
d80 1
a80 1
fill_gregset (gregset_t *regp, int regno)
d86 1
a86 1
	regcache_raw_collect (current_regcache, i, 
d93 1
a93 1
supply_fpregset (fpregset_t *regp)
d98 2
a99 2
      regcache_raw_supply (current_regcache, i,
			   ((char *)regp) + regmap_fpregset[i]);
d106 1
a106 1
fill_fpregset (fpregset_t *regp, int regno)
d112 2
a113 2
        regcache_raw_collect (current_regcache, i, 
			      ((char *)regp) + regmap_fpregset[i]);
d142 1
a142 1
  supply_gregset (&regs);
d159 1
a159 1
  fill_gregset (&regs, regnum);
d179 1
a179 1
  supply_fpregset (&fpregs);
d196 1
a196 1
  fill_fpregset (&fpregs, regnum);
@


1.20
log
@	* s390-nat.c (s390_insert_watchpoint): Add missing argument.
	(s390_remove_watchpoint): Likewise.
@
text
@a25 1
#include "tm.h"
@


1.19
log
@	* linux-nat.c (linux_ops_saved): New.
	(super_mourn_inferior, kill_inferior, threaded, linux_nat_ops)
	(child_mourn_inferior, child_wait, linux_nat_create_inferior)
	(linux_nat_fetch_registers, linux_nat_store_registers)
	(linux_nat_child_post_startup_inferior, init_linux_nat_ops): Delete.
	(init_lwp_list): Don't set threaded.
	(add_lwp): Don't modify threaded.
	(delete_lwp): Don't mention non-threaded mode.
	(linux_nat_switch_fork): New.
	(linux_nat_attach): Update inferior_ptid.
	(linux_nat_wait): Handle num_lwps == 0 at entry.  Don't check
	threaded flag.
	(linux_nat_kill): Handle pending forks and saved forks.
	(linux_nat_mourn_inferior): Handle saved forks.
	(linux_nat_pid_to_str): Don't use the LWP form when there is
	only one thread.
	(linux_target): Don't set to_wait, to_kill, or to_mourn_inferior.
	(linux_nat_add_target): New.
	(_initialize_linux_nat): Don't initialize the linux native target
	here.
	* linux-nat.h (linux_nat_add_target, linux_nat_switch_fork): New
	prototypes.
	* linux-fork.c: Include "linux-nat.h".
	(add_fork): Update initial PID.
	(fork_load_infrun_state): Call linux_nat_switch_fork.
	* Makefile.in (linux-fork.o): Update.

	* alpha-linux-nat.c (_initialize_alpha_linux_nat): Use
	linux_nat_add_target instead of add_target.
	* amd64-linux-nat.c (_initialize_amd64_linux_nat): Likewise.
	* arm-linux-nat.c (_initialize_arm_linux_nat): Likewise.
	* hppa-linux-nat.c (_initialize_hppa_linux_nat): Likewise.
	* ia64-linux-nat.c (_initialize_ia64_linux_nat): Likewise.
	* i386-linux-nat.c (_initialize_i386_linux_nat): Likewise.
	* m32r-linux-nat.c (_initialize_m32r_linux_nat): Likewise.
	* m68klinux-nat.c (_initialize_m68k_linux_nat): Likewise.
	* mips-linux-nat.c (_initialize_mips_linux_nat): Likewise.
	* ppc-linux-nat.c (_initialize_ppc_linux_nat): Likewise.
	* s390-nat.c (_initialize_s390_nat): Likewise.
	* sparc-linux-nat.c (_initialize_sparc_linux_nat): Likewise.
	* sparc64-linux-nat.c (_initialize_sparc64_linux_nat): Likewise.
@
text
@d314 1
a314 1
s390_insert_watchpoint (CORE_ADDR addr, int len)
d331 1
a331 1
s390_remove_watchpoint (CORE_ADDR addr, int len)
@


1.18
log
@	* config/i386/nm-i386sol2.h: Update copyright year.
        * config/mips/nm-irix5.h: Ditto.
        * config/sparc/nm-sol2.h: Ditto.
        * s390-nat.c: Ditto.
        * ppc-linux-nat.c: Ditto.
@
text
@d391 1
a391 1
  add_target (t);
@


1.17
log
@	* breakpoint.c (TARGET_REGION_OK_FOR_HW_WATCHPOINT): Delete.
	* config/i386/nm-i386sol2.h (TARGET_REGION_OK_FOR_HW_WATCHPOINT): New.
	(TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT): Delete.
	* config/mips/nm-irix5.h (TARGET_REGION_OK_FOR_HW_WATCHPOINT): New.
	(TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT): Delete.
	* config/sparc/nm-sol2.h (TARGET_REGION_OK_FOR_HW_WATCHPOINT): New.
	(TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT): Delete.
	* inf-ttrace.c (inf_ttrace_region_ok_for_hw_watchpoint): New.
	(inf_ttrace_region_size_ok_for_hw_watchpoint): Delete.
	(inf_ttrace_target): Delete to_region_size_ok_for_hw_watchpoint and
	add to_region_ok_for_hw_watchpoint.
	* s390-nat.c (s390_region_size_ok_for_hw_watchpoint): Delete.
	(s390_region_ok_for_hw_watchpoint): New.
	(_initialize_s390_nat): Delete to_region_size_ok_for_hw_watchpoint
	and add to_region_ok_for_hw_watchpoint.
	* target.c (default_region_size_ok_for_hw_watchpoint,
	debug_to_region_size_ok_for_hw_watchpoint): Delete prototype.
	(update_current_target): Delete to_region_size_ok_for_hw_watchpoint
	inheritance and default_region_size_ok_for_hw_watchpoint.
	(default_region_ok_for_hw_watchpoint): If len is less than or equal
	the length of void pointer, return ok.
	(default_region_size_ok_for_hw_watchpoint): Delete.
	(debug_to_region_size_ok_for_hw_watchpoint): Delete.
	(setup_target_debug): Delete to_region_size_ok_for_hw_watchpoint.
	* target.h (struct target_ops): Delete
	to_region_size_ok_for_hw_watchpoint.
	(TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT): Delete.
@
text
@d2 2
a3 1
   Copyright (C) 2001, 2003, 2004, 2005 Free Software Foundation, Inc
@


1.16
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d361 1
a361 1
s390_region_size_ok_for_hw_watchpoint (int cnt)
d383 1
a383 1
  t->to_region_size_ok_for_hw_watchpoint = s390_region_size_ok_for_hw_watchpoint;
@


1.15
log
@	* config/s390/nm-linux.h (KERNEL_U_SIZE): Remove.
	(PTRACE_ARG3_TYPE, PTRACE_XFER_TYPE): Likewise.
	(s390_stopped_by_watchpoint, s390_insert_watchpoint,
	s390_remove_watchpoint, TARGET_CAN_USE_HARDWARE_WATCHPOINT,
	TARGET_REGION_OK_FOR_HW_WATCHPOINT, HAVE_CONTINUABLE_WATCHPOINT,
	STOPPED_BY_WATCHPOINT, target_insert_watchpoint,
	target_remove_watchpoint): Likewise.
	* s390-nat.c: Remove include of <sys/user.h>.
	(kernel_u_size): Remove.
	(s390_stopped_by_watchpoint): Make static.
	(s390_insert_watchpoint, s390_remove_watchpoint): Likewise.
	(s390_can_use_hw_breakpoint): New function.
	(s390_region_size_ok_for_hw_watchpoint): Likewise.
	(_initialize_s390_nat): Add watchpoint methods to target.
@
text
@d2 1
a2 1
   Copyright 2001, 2003, 2004, 2005 Free Software Foundation, Inc
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.14
log
@	* Makefile.in (ALLDEPFILES): Update.
	(alpha-linux-nat.o, sparc-linux-nat.o): New rules.
	(amd64-linux-nat.o, arm-linux-nat.o, hppa-linux-nat.o)
	(i386-linux-nat.o, ia64-linux-nat.o, linux-nat.o, m32r-linux-nat.o)
	(m68klinux-nat.o, mips-linux-nat.o, ppc-linux-nat.o, s390-nat.o)
	(sparc64-linux-nat.o): Update dependencies.
	* alpha-linux-nat.c, sparc-linux-nat.c: New files.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(amd64_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(amd64_linux_child_post_start_inferior): Renamed from
	child_post_startup_inferior and made static.  Call
	super_post_startup_inferior.
	(super_post_startup_inferior): New.
	(_initialize_amd64_linux_nat): Set it.  Call linux_target and
	add_target.
	* arm-linux-nat.c (arm_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(arm_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_arm_linux_nat): Add a prototype.  Use linux_target and
	add_target.
	* hppa-linux-nat.c (hppa_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(hppa_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_hppa_linux_nat): New function.
	* i386-linux-nat.c (i386_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(i386_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(i386_linux_resume): Renamed from child_resume and made static.
	(i386_linux_child_post_start_inferior): Renamed from
	child_post_startup_inferior and made static.  Call
	super_post_startup_inferior.
	(super_post_startup_inferior): New.
	(_initialize_i386_linux_nat): New function.
	* i386-nat.c: Remove LINUX_CHILD_POST_STARTUP_INFERIOR #ifndef.
	* ia64-linux-nat.c (ia64_linux_xfer_unwind_table): Remove.
	(super_xfer_partial): New.
	(ia64_linux_xfer_partial): New function.  Use it.
	(_initialize_ia64_linux_nat): New function.
	* ia64-tdep.c (getunwind_table): Revert 2005-06-08 change; use
	target_read_partial and document the problem.
	* inf-ptrace.c (inf_ptrace_fetch_register): Use
	CANNOT_FETCH_REGISTER.  Fix some comments.
	(inf_ptrace_store_register): Use CANNOT_STORE_REGISTER.  Fix some
	comments.
	* linux-nat.c: Include "inf-ptrace.h" and "auxv.h".
	(linux_ops, super_xfer_partial): New variables.
	(linux_child_post_startup_inferior): Make static.
	(child_post_startup_inferior): Delete.
	(linux_nat_attach, linux_nat_detach, resume_callback)
	(linux_nat_resume, linux_nat_wait, linux_nat_create_inferior)
	(linux_nat_mourn_inferior): Use linux_ops instead of
	deprecated_child_ops.
	(child_wait): Do not depend on CHILD_WAIT.
	(linux_nat_xfer_memory): Remove, replace by ...
	(linux_nat_xfer_partial): ... this.  Use linux_ops->to_xfer_partial
	instead of linux_proc_xfer_memory and child_xfer_memory.
	(linux_nat_fetch_registers, linux_nat_store_registers)
	(linux_nat_child_post_startup_inferior): New functions.
	(init_linux_nat_ops): Use the new functions.
	(linux_proc_xfer_memory): Remove, replace by ...
	(linux_proc_xfer_partial): ... this.  Make static.
	(linux_xfer_partial, linux_register_u_offset, linux_target): New
	functions.
	(_initialize_linux_nat): Do not modify deprecated_child_ops.
	* linux-nat.h (linux_proc_xfer_memory): Remove prototype.
	(struct mem_attrib, struct target_ops): Remove forward declarations.
	(linux_child_post_startup_inferior): Remove prototype.
	(linux_target): Add prototype.
	* linux-thread-db.c (thread_db_xfer_memory): Remove, replace by ...
	(thread_db_xfer_partial): ... this.
	(init_thread_db_ops): Set to_xfer_partial instead of
	deprecated_xfer_memory.
	* m32r-linux-nat.c (m32r_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(m32r_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_m32r_linux_nat): New function.
	* m68klinux-nat.c (m68k_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(m68k_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(old_fetch_inferior_registers, old_store_inferior_registers): Made
	static.
	(_initialize_m68k_linux_nat): Use linux_target and add_target.
	* mips-linux-nat.c (_initialize_mips_linux_nat): New function.
	* ppc-linux-nat.c (ppc_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(ppc_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_ppc_linux_nat): New function.
	* s390-nat.c (s390_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(s390_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_s390_nat): New function.
	* sparc64-linux-nat.c (_initialize_sparc64_linux_nat): Use
	linux_target and add_target.
	* config/nm-linux.h: Don't include "auxv.h".
	(struct target_waitstatus, child_wait, CHILD_WAIT)
	(CHILD_PID_TO_EXEC_FILE, CHILD_INSERT_FORK_CATCHPOINT)
	(CHILD_INSERT_VFORK_CATCHPOINT, CHILD_INSERT_EXEC_CATCHPOINT)
	(CHILD_POST_STARTUP_INFERIOR, CHILD_POST_ATTACH, CHILD_FOLLOW_FORK)
	(DEPRECATED_KILL_INFERIOR, NATIVE_XFER_AUXV): Delete.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Replace infptrace.o
	and inftarg.o with inf-ptrace.o and alpha-linux-nat.o.
	* config/sparc/linux.mh (NATDEPFILES): Replace infptrace.o and
	inftarg.o with sparc-linux-nat.o.
	* config/sparc/linux64.mh (NATDEPFILES): Remove infptrace.o and
	inftarg.o.
	* config/arm/linux.mh (NATDEPFILES): Replace infptrace.o and
	inftarg.o with inf-ptrace.o.
	* config/i386/linux.mh (NATDEPFILES): Likewise.
	* config/i386/linux64.mh (NATDEPFILES): Likewise.
	* config/ia64/linux.mh (NATDEPFILES): Likewise.
	* config/m32r/linux.mh (NATDEPFILES): Likewise.
	* config/m68k/linux.mh (NATDEPFILES): Likewise.
	* config/mips/linux.mh (NATDEPFILES): Likewise.
	* config/pa/linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Likewise.
	* config/s390/s390.mh (NATDEPFILES): Likewise.
	* config/i386/nm-linux.h (DEPRECATED_CHILD_RESUME): Don't define.
	(LINUX_CHILD_POST_STARTUP_INFERIOR): Don't define.
	* config/i386/nm-linux64.h (LINUX_CHILD_POST_STARTUP_INFERIOR):
	Don't define.
	* config/ia64/nm-linux.h: Don't include "target.h".
	(NATIVE_XFER_UNWIND_TABLE, ia64_linux_xfer_unwind_table): Remove.
	* config/djgpp/fnchange.lst: Add alpha-linux-tdep.c,
	alpha-linux-nat.c, sparc-linux-tdep.c, and sparc-linux-nat.c.
@
text
@a36 1
#include <sys/user.h>
d252 1
a252 1
int
d312 1
a312 1
int
d329 1
a329 1
int
d354 5
d360 2
a361 2
int
kernel_u_size (void)
d363 1
a363 1
  return sizeof (struct user);
d366 1
d381 8
@


1.13
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d2 1
a2 1
   Copyright 2001, 2003 Free Software Foundation, Inc
d28 2
d205 2
a206 2
void
fetch_inferior_registers (int regnum)
d221 2
a222 2
void
store_inferior_registers (int regnum)
d362 17
@


1.12
log
@2004-02-17  Ulrich Weigand <Ulrich.Weigand@@de.ibm.com>

	Committed by Jim Blandy  <jimb@@redhat.com>.

	* s390-nat.c (SUBOFF): New macro.
	(supply_gregset, fill_gregset): Use it to handle debugging
	of 32-bit exectuables running under a 64-bit kernel.
	* s390-tdep.c: Include "solib-svr4.h".
	(s390_svr4_fetch_link_map_offset): New function.
	(s390x_svr_fetch_link_map_offset): Likewise.
	(s390_gdbarch_init): Call set_solib_svr4_fetch_link_map_offsets.
	* Makefile.in (s390-tdep.o): Update dependencies.
@
text
@d139 1
a139 1
    perror_with_name ("Couldn't get registers");
d156 1
a156 1
    perror_with_name ("Couldn't get registers");
d161 1
a161 1
    perror_with_name ("Couldn't write registers");
d176 1
a176 1
    perror_with_name ("Couldn't get floating point status");
d193 1
a193 1
    perror_with_name ("Couldn't get floating point status");
d198 1
a198 1
    perror_with_name ("Couldn't write floating point status");
d265 1
a265 1
    perror_with_name ("Couldn't retrieve watchpoint status");
d292 1
a292 1
    perror_with_name ("Couldn't retrieve watchpoint status");
d308 1
a308 1
    perror_with_name ("Couldn't modify watchpoint status");
@


1.11
log
@2004-02-17  Ulrich Weigand <Ulrich.Weigand@@de.ibm.com>

	Committed by Jim Blandy  <jimb@@redhat.com>.

	* config/s390/nm-linux.h: Update comments.
	(target_insert_watchpoint, target_remove_watchpoint): Redefine.
	(STOPPED_BY_WATCHPOINT): Redefine.
	(TARGET_CAN_USE_HARDWARE_WATCHPOINT): Redefine to 1.
	(s390_insert_watchpoint, s390_remove_watchpoint): Update prototype.
	(s390_stopped_by_watchpoint): Likewise.
	(watch_area_cnt): Remove.
	* s390-nat.c: Update comments.
	(watch_area): Remove typedef.
	Global replace watch_area by struct watch_area.
	(watch_area_cnt, watch_lo_addr, watch_hi_addr): Remove.
	(s390_stopped_by_watchpoint): Remove pid argument,
	use s390_inferior_tid.  Add short-cut for the no watchpoint case.
	(s390_fix_watch_points): Remove pid argument,
	use s390_inferior_tid.  Recompute area spanned by watchpoints.
	(s390_insert_watchpoint, s390_remove_watchpoint): Remove pid
	argument.  Reimplement.
@
text
@d50 12
d72 1
a72 1
			   (char *)regp + regmap_gregset[i]);
d86 1
a86 1
			      (char *)regp + regmap_gregset[i]);
@


1.10
log
@2004-02-17  Ulrich Weigand <Ulrich.Weigand@@de.ibm.com>

	Committed by Jim Blandy  <jimb@@redhat.com>.
	* config/s390/nm-linux.h: Update comments.  Do not include "solib.h".
	(KERNEL_U_ADDR, REGISTER_U_ADDR, U_REGS_OFFSET): Remove.
	(FETCH_INFERIOR_REGISTERS): Define.
	* config/s390/s390.mh (NATDEPFILES): Remove core-aout.o and
	core-regset.o.
	* config/s390/s390x.mt: Remove.
	* config/s390/tm-s390.h: Remove.
	* config/s390/tm-linux.h: Do not include "s390/tm-s390.h".
	(TARGET_ELF64): Remove.
	(SKIP_TRAMPOLINE_CODE): Do not undefine.
	* configure.tgt [s390-*-*, s390x-*-*]: Merge into single
	s390*-*-* case; always set gdb_target to s390.
	* regformats/reg-s390.dat: Remove control registers.
	* regformats/reg-s390x.dat: Likewise.
	* s390-tdep.h: New file.
	* s390-nat.c: Do not include <asm/processor.h> or <value.h>.
	Include "inferior.h" and "s390-tdep.h".
	Remove private definition of offsetof.
	(s390_register_u_addr): Remove.
	(regmap_gregset, regmap_fpregset): Define.
	(supply_gregset, fill_gregset): Reimplement.
	(supply_fpregset, fill_fpregset): Likewise.
	(s390_inferior_tid): New function.
	(fetch_regs, store_regs, fetch_fpregs, store_fpregs): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* s390-tdep.c: Do not define S390_TDEP.  Include "defs.h" instead
	of <defs.h>.  Include "reggroups.h", "regset.h", and "s390-tdep.h".
	Global replace of S390_GP0_REGNUM by S390_R0_REGNUM.
	Global replace of S390_FP0_REGNUM by S390_F0_REGNUM.
	(struct gdbarch_tdep): Define.
	(struct s390_register_info): Define.
	(s390_register_info): New variable.
	(s390_register_name): Reimplement.
	(s390_register_type): New function.
	(s390_register_raw_size, s390x_register_raw_size): Remove.
	(s390_cannot_fetch_register): Remove.
	(s390_register_byte): Remove.
	(s390_register_virtual_type, s390x_register_virtual_type): Remove.
	(s390_dwarf_regmap): New variable.
	(s390_dwarf_reg_to_regnum): New function.
	(s390_stab_reg_to_regnum): Remove.
	(s390_pseudo_register_read, s390_pseudo_register_write): New functions.
	(s390x_pseudo_register_read, s390x_pseudo_register_write): Likewise.
	(s390_convert_register_p): Likewise.
	(s390_register_to_value, s390_value_to_register): Likewise.
	(s390_register_reggroup_p): Likewise.
	(s390_regmap_gregset, s390x_regmap_gregset, s390_regmap_fpregset,
	s390_gregset, s390x_gregset, s390_fpregset): New variables.
	(s390_supply_regset, s390_regset_from_core_section): New functions.
	(GDB_TARGET_IS_ESAME): Move here from tm-s390.h.
	(S390_FPR_SIZE): Likewise.
	(S390_GPR_SIZE): Likewise.  Redefine in terms of GDB_TARGET_IS_ESAME.
	Global replace of DEPRECATED_REGISTER_SIZE by S390_GPR_SIZE.
	(S390_NUM_GPRS): Move here from tm-s390.h.
	(S390_NUM_FPRS): Likewise.
	(s390_in_function_epilogue_p): New function.
	(s390_is_sigreturn): Replace S390_PSW_ADDR_SIZE by S390_GPR_SIZE.
	Replace S390_PC_REGNUM by S390_PSWA_REGNUM.
	(s390_gdbarch_init): Allocate and set up gdbarch_tdep structure.
	Replace s390_stab_reg_to_regnum by s390_dwarf_reg_to_regnum.
	Replace S390_FP_REGNUM by S390_SP_REGNUM.
	Remove calls to:
	set_gdbarch_deprecated_max_register_raw_size,
	set_gdbarch_deprecated_max_register_virtual_size,
	set_gdbarch_deprecated_register_byte,
	set_gdbarch_cannot_fetch_register,
	set_gdbarch_cannot_store_register,
	set_gdbarch_deprecated_register_size,
	set_gdbarch_deprecated_register_raw_size,
	set_gdbarch_deprecated_register_virtual_size,
	set_gdbarch_deprecated_register_virtual_type,
	set_gdbarch_deprecated_register_bytes.
	Add calls to:
	set_gdbarch_num_pseudo_regs,
	set_gdbarch_register_type,
	set_gdbarch_convert_register_p,
	set_gdbarch_register_to_value,
	set_gdbarch_value_to_register,
	set_gdbarch_register_reggroup_p,
	set_gdbarch_regset_from_core_section,
	set_gdbarch_pseudo_register_read,
	set_gdbarch_pseudo_register_write,
	set_gdbarch_in_function_epilogue_p.
	* Makefile.in (s390-nat.o, s390-tdep.o): Update dependencies.
	(s390_tdep_h): New variable.
@
text
@d222 8
a229 7
/* watch_areas are required if you put 2 or more watchpoints on the same 
   address or overlapping areas gdb will call us to delete the watchpoint 
   more than once when we try to delete them.
   attempted reference counting to reduce the number of areas unfortunately
   they didn't shrink when areas had to be split overlapping occurs. */
struct watch_area;
typedef struct watch_area watch_area;
d232 1
a232 1
  watch_area *next;
d237 1
a237 3
static watch_area *watch_base = NULL;
int watch_area_cnt = 0;
static CORE_ADDR watch_lo_addr = 0, watch_hi_addr = 0;
d239 2
a240 4


CORE_ADDR
s390_stopped_by_watchpoint (int pid)
d245 4
d252 5
a256 3
  ptrace (PTRACE_PEEKUSR_AREA, pid, &parea);
  return ((per_lowcore.perc_storage_alteration == 1) &&
	  (per_lowcore.perc_store_real_address == 0));
d259 4
a263 3
void
s390_fix_watch_points (int pid)
{
d267 9
d278 5
a282 6
  parea.kernel_addr = PT_CR_9;
  ptrace (PTRACE_PEEKUSR_AREA, pid, &parea);
  /* The kernel automatically sets the psw for per depending */
  /* on whether the per control registers are set for event recording */
  /* & sets cr9 & cr10 appropriately also */
  if (watch_area_cnt)
d294 3
a296 1
  ptrace (PTRACE_POKEUSR_AREA, pid, &parea);
d300 1
a300 1
s390_insert_watchpoint (int pid, CORE_ADDR addr, int len, int rw)
d302 9
a310 3
  CORE_ADDR hi_addr = addr + len - 1;
  watch_area *newarea = (watch_area *) xmalloc (sizeof (watch_area));

d312 2
a313 17
  if (newarea)
    {
      newarea->next = watch_base;
      watch_base = newarea;
      watch_lo_addr = min (watch_lo_addr, addr);
      watch_hi_addr = max (watch_hi_addr, hi_addr);
      newarea->lo_addr = addr;
      newarea->hi_addr = hi_addr;
      if (watch_area_cnt == 0)
	{
	  watch_lo_addr = newarea->lo_addr;
	  watch_hi_addr = newarea->hi_addr;
	}
      watch_area_cnt++;
      s390_fix_watch_points (pid);
    }
  return newarea ? 0 : -1;
a315 1

d317 1
a317 1
s390_remove_watchpoint (int pid, CORE_ADDR addr, int len)
d319 8
a326 58
  watch_area *curr = watch_base, *prev, *matchCurr;
  CORE_ADDR hi_addr = addr + len - 1;
  CORE_ADDR watch_second_lo_addr = 0xffffffffUL, watch_second_hi_addr = 0;
  int lo_addr_ref_cnt, hi_addr_ref_cnt;
  prev = matchCurr = NULL;
  lo_addr_ref_cnt = (addr == watch_lo_addr);
  hi_addr_ref_cnt = (addr == watch_hi_addr);
  while (curr)
    {
      if (matchCurr == NULL)
	{
	  if (curr->lo_addr == addr && curr->hi_addr == hi_addr)
	    {
	      matchCurr = curr;
	      if (prev)
		prev->next = curr->next;
	      else
		watch_base = curr->next;
	    }
	  prev = curr;
	}
      if (lo_addr_ref_cnt)
	{
	  if (watch_lo_addr == curr->lo_addr)
	    lo_addr_ref_cnt++;
	  if (curr->lo_addr > watch_lo_addr &&
	      curr->lo_addr < watch_second_lo_addr)
	    watch_second_lo_addr = curr->lo_addr;
	}
      if (hi_addr_ref_cnt)
	{
	  if (watch_hi_addr == curr->hi_addr)
	    hi_addr_ref_cnt++;
	  if (curr->hi_addr < watch_hi_addr &&
	      curr->hi_addr > watch_second_hi_addr)
	    watch_second_hi_addr = curr->hi_addr;
	}
      curr = curr->next;
    }
  if (matchCurr)
    {
      xfree (matchCurr);
      watch_area_cnt--;
      if (watch_area_cnt)
	{
	  if (lo_addr_ref_cnt == 2)
	    watch_lo_addr = watch_second_lo_addr;
	  if (hi_addr_ref_cnt == 2)
	    watch_hi_addr = watch_second_hi_addr;
	}
      else
	{
	  watch_lo_addr = watch_hi_addr = 0;
	}
      s390_fix_watch_points (pid);
      return 0;
    }
  else
d329 1
a329 1
			  "Attempt to remove nonexistent watchpoint in s390_remove_watchpoint\n");
d332 7
d340 1
@


1.9
log
@	* config/arm/linux.mt: Remove code protected by GDBSERVER define.
	* config/arm/nm-linux.h: Likewise.
	* config/arm/tm-linux.h: Likewise.
	* config/ia64/nm-linux.h: Likewise.
	* config/ia64/tm-ia64.h: Likewise.
	* config/s390/tm-linux.h: Likewise.
	* config/s390/tm-s390.h: Likewise.
	* s390-nat.c: Likewise.
	* s390-tdep.c: Likewise.

	* config/i386/linux.mt: Don't set GDBSERVER_DEPFILES.
	* config/ia64/linux.mt: Likewise.
	* config/m68k/linux.mh: Likewise.
	* config/mips/linux.mt: Likewise.
	* config/powerpc/linux.mh: Likewise.
	* config/sh/linux.mt: Likewise.
@
text
@d2 2
a3 1
   Copyright 2001 Free Software Foundation, Inc
d6 1
d27 4
a32 1
#include <asm/processor.h>
a35 1
#include <value.h>
d37 9
a45 2
#ifndef offsetof
#define offsetof(type,member) ((size_t) &((type *)0)->member)
d48 66
d115 94
a208 2
int
s390_register_u_addr (int blockend, int regnum)
d210 1
a210 1
  int retval;
d212 7
a218 26
  if (regnum >= S390_GP0_REGNUM && regnum <= S390_GP_LAST_REGNUM)
    retval = PT_GPR0 + ((regnum - S390_GP0_REGNUM) * S390_GPR_SIZE);
  else if (regnum >= S390_PSWM_REGNUM && regnum <= S390_PC_REGNUM)
    retval = PT_PSWMASK + ((regnum - S390_PSWM_REGNUM) * S390_PSW_MASK_SIZE);
  else if (regnum == S390_FPC_REGNUM)
    retval = PT_FPC;
  else if (regnum >= S390_FP0_REGNUM && regnum <= S390_FPLAST_REGNUM)
    retval =
#if CONFIG_ARCH_S390X
      PT_FPR0
#else
      PT_FPR0_HI
#endif
      + ((regnum - S390_FP0_REGNUM) * S390_FPR_SIZE);
  else if (regnum >= S390_FIRST_ACR && regnum <= S390_LAST_ACR)
    retval = PT_ACR0 + ((regnum - S390_FIRST_ACR) * S390_ACR_SIZE);
  else if (regnum >= (S390_FIRST_CR + 9) && regnum <= (S390_FIRST_CR + 11))
    retval = PT_CR_9 + ((regnum - (S390_FIRST_CR + 9)) * S390_CR_SIZE);
  else
    {
      internal_error (__FILE__, __LINE__,
                      "s390_register_u_addr invalid regnum regnum=%d",
                      regnum);
      retval = 0;
    }
  return retval + blockend;
d221 1
a385 124

#if  (defined (S390_FP0_REGNUM) && defined (HAVE_FPREGSET_T) && defined(HAVE_SYS_PROCFS_H) && defined (HAVE_GREGSET_T))
void
supply_gregset (gregset_t * gregsetp)
{
  int regi;
  greg_t *gregp = (greg_t *) gregsetp;

  supply_register (S390_PSWM_REGNUM, (char *) &gregp[S390_PSWM_REGNUM]);
  supply_register (S390_PC_REGNUM, (char *) &gregp[S390_PC_REGNUM]);
  for (regi = 0; regi < S390_NUM_GPRS; regi++)
    supply_register (S390_GP0_REGNUM + regi,
		     (char *) &gregp[S390_GP0_REGNUM + regi]);

#if defined (CONFIG_ARCH_S390X)
  /* On the s390x, each element of gregset_t is 8 bytes long, but
     each access register is still only 32 bits long.  So they're
     packed two per element.  It's apparently traditional that
     gregset_t must be an array, so when the registers it provides
     have different sizes, something has to get strange
     somewhere.  */
  {
    unsigned int *acrs = (unsigned int *) &gregp[S390_FIRST_ACR];

    for (regi = 0; regi < S390_NUM_ACRS; regi++)
      supply_register (S390_FIRST_ACR + regi, (char *) &acrs[regi]);
  }
#else
  for (regi = 0; regi < S390_NUM_ACRS; regi++)
    supply_register (S390_FIRST_ACR + regi,
                     (char *) &gregp[S390_FIRST_ACR + regi]);
#endif

  /* unfortunately this isn't in gregsetp */
  for (regi = 0; regi < S390_NUM_CRS; regi++)
    supply_register (S390_FIRST_CR + regi, NULL);
}


void
supply_fpregset (fpregset_t * fpregsetp)
{
  int regi;

  supply_register (S390_FPC_REGNUM, (char *) &fpregsetp->fpc);
  for (regi = 0; regi < S390_NUM_FPRS; regi++)
    supply_register (S390_FP0_REGNUM + regi, (char *) &fpregsetp->fprs[regi]);

}

void
fill_gregset (gregset_t * gregsetp, int regno)
{
  int regi;
  greg_t *gregp = (greg_t *) gregsetp;

  if (regno < 0) 
    {
      regcache_collect (S390_PSWM_REGNUM, &gregp[S390_PSWM_REGNUM]);
      regcache_collect (S390_PC_REGNUM, &gregp[S390_PC_REGNUM]);
      for (regi = 0; regi < S390_NUM_GPRS; regi++)
        regcache_collect (S390_GP0_REGNUM + regi,
			  &gregp[S390_GP0_REGNUM + regi]);
#if defined (CONFIG_ARCH_S390X)
      /* See the comments about the access registers in
         supply_gregset, above.  */
      {
        unsigned int *acrs = (unsigned int *) &gregp[S390_FIRST_ACR];
        
        for (regi = 0; regi < S390_NUM_ACRS; regi++)
          regcache_collect (S390_FIRST_ACR + regi, &acrs[regi]);
      }
#else
      for (regi = 0; regi < S390_NUM_ACRS; regi++)
        regcache_collect (S390_FIRST_ACR + regi,
			  &gregp[S390_FIRST_ACR + regi]);
#endif
    }
  else if (regno >= S390_PSWM_REGNUM && regno < S390_FIRST_ACR)
    regcache_collect (regno, &gregp[regno]);
  else if (regno >= S390_FIRST_ACR && regno <= S390_LAST_ACR)
    {
#if defined (CONFIG_ARCH_S390X)
      /* See the comments about the access registers in
         supply_gregset, above.  */
      unsigned int *acrs = (unsigned int *) &gregp[S390_FIRST_ACR];
        
      regcache_collect (regno, &acrs[regno - S390_FIRST_ACR]);
#else
      regcache_collect (regno, &gregp[regno]);
#endif
    }
}

/*  Given a pointer to a floating point register set in /proc format
   (fpregset_t *), update the register specified by REGNO from gdb's idea
   of the current floating point register set.  If REGNO is -1, update
   them all. */

void
fill_fpregset (fpregset_t * fpregsetp, int regno)
{
  int regi;

  if (regno < 0) 
    {
      regcache_collect (S390_FPC_REGNUM, &fpregsetp->fpc);
      for (regi = 0; regi < S390_NUM_FPRS; regi++)
        regcache_collect (S390_FP0_REGNUM + regi, &fpregsetp->fprs[regi]);
    }
  else if (regno == S390_FPC_REGNUM)
    regcache_collect (S390_FPC_REGNUM, &fpregsetp->fpc);
  else if (regno >= S390_FP0_REGNUM && regno <= S390_FPLAST_REGNUM)
    regcache_collect (regno, &fpregsetp->fprs[regno - S390_FP0_REGNUM]);
}


#else
#error "There are a few possibilities here"
#error "1) You aren't compiling for linux & don't need a core dumps to work."
#error "2) The header files sys/elf.h sys/user.h sys/ptrace.h & sys/procfs.h"
#error "libc files are inconsistent with linux/include/asm-s390/"
#error "3) you didn't do a completely clean build & delete config.cache."
#endif
@


1.8
log
@* s390-nat.c (supply_gregset, fill_gregset): On the s390x, the
elements of gregset_t are 64 bits each, but access registers
are still 32 bits, so they're packed two per gregset_t
element.  Unpack/pack them properly.
@
text
@a62 4
#ifdef GDBSERVER
      error ("s390_register_u_addr invalid regnum %s %d regnum=%d",
             __FILE__, (int) __LINE__, regnum);
#else
a65 1
#endif
a70 1
#ifndef GDBSERVER
a358 1
#endif /* GDBSERVER */
@


1.7
log
@2003-04-08  Elena Zannoni  <ezannoni@@redhat.com>

	* s390-nat.c: Include asm/types.h for addr_t.
@
text
@d254 15
d271 3
a273 1
		     (char *) &gregp[S390_FIRST_ACR + regi]);
d304 10
d317 1
d319 1
a319 1
  else if (regno >= S390_PSWM_REGNUM && regno <= S390_LAST_ACR)
d321 12
@


1.6
log
@From Gerhard Tonn <TON@@de.ibm.com>:
* s390-nat.c (fill_fpregset, fill_gregset): Use regcache_collect
instead of supply_register.
@
text
@d28 1
@


1.6.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a27 1
#include <asm/types.h>
d62 4
d69 1
d75 1
a252 15

#if defined (CONFIG_ARCH_S390X)
  /* On the s390x, each element of gregset_t is 8 bytes long, but
     each access register is still only 32 bits long.  So they're
     packed two per element.  It's apparently traditional that
     gregset_t must be an array, so when the registers it provides
     have different sizes, something has to get strange
     somewhere.  */
  {
    unsigned int *acrs = (unsigned int *) &gregp[S390_FIRST_ACR];

    for (regi = 0; regi < S390_NUM_ACRS; regi++)
      supply_register (S390_FIRST_ACR + regi, (char *) &acrs[regi]);
  }
#else
d255 1
a255 3
                     (char *) &gregp[S390_FIRST_ACR + regi]);
#endif

a285 10
#if defined (CONFIG_ARCH_S390X)
      /* See the comments about the access registers in
         supply_gregset, above.  */
      {
        unsigned int *acrs = (unsigned int *) &gregp[S390_FIRST_ACR];
        
        for (regi = 0; regi < S390_NUM_ACRS; regi++)
          regcache_collect (S390_FIRST_ACR + regi, &acrs[regi]);
      }
#else
a288 1
#endif
d290 1
a290 1
  else if (regno >= S390_PSWM_REGNUM && regno < S390_FIRST_ACR)
a291 12
  else if (regno >= S390_FIRST_ACR && regno <= S390_LAST_ACR)
    {
#if defined (CONFIG_ARCH_S390X)
      /* See the comments about the access registers in
         supply_gregset, above.  */
      unsigned int *acrs = (unsigned int *) &gregp[S390_FIRST_ACR];
        
      regcache_collect (regno, &acrs[regno - S390_FIRST_ACR]);
#else
      regcache_collect (regno, &gregp[regno]);
#endif
    }
d324 1
@


1.6.8.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a27 1
#include <asm/types.h>
@


1.6.8.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d63 4
d70 1
d76 1
a253 15

#if defined (CONFIG_ARCH_S390X)
  /* On the s390x, each element of gregset_t is 8 bytes long, but
     each access register is still only 32 bits long.  So they're
     packed two per element.  It's apparently traditional that
     gregset_t must be an array, so when the registers it provides
     have different sizes, something has to get strange
     somewhere.  */
  {
    unsigned int *acrs = (unsigned int *) &gregp[S390_FIRST_ACR];

    for (regi = 0; regi < S390_NUM_ACRS; regi++)
      supply_register (S390_FIRST_ACR + regi, (char *) &acrs[regi]);
  }
#else
d256 1
a256 3
                     (char *) &gregp[S390_FIRST_ACR + regi]);
#endif

a286 10
#if defined (CONFIG_ARCH_S390X)
      /* See the comments about the access registers in
         supply_gregset, above.  */
      {
        unsigned int *acrs = (unsigned int *) &gregp[S390_FIRST_ACR];
        
        for (regi = 0; regi < S390_NUM_ACRS; regi++)
          regcache_collect (S390_FIRST_ACR + regi, &acrs[regi]);
      }
#else
a289 1
#endif
d291 1
a291 1
  else if (regno >= S390_PSWM_REGNUM && regno < S390_FIRST_ACR)
a292 12
  else if (regno >= S390_FIRST_ACR && regno <= S390_LAST_ACR)
    {
#if defined (CONFIG_ARCH_S390X)
      /* See the comments about the access registers in
         supply_gregset, above.  */
      unsigned int *acrs = (unsigned int *) &gregp[S390_FIRST_ACR];
        
      regcache_collect (regno, &acrs[regno - S390_FIRST_ACR]);
#else
      regcache_collect (regno, &gregp[regno]);
#endif
    }
d325 1
@


1.5
log
@* s390-nat.c: #include "regcache.h", to get declaration for
`supply_register'.  (The last change already added the dependency
of s390-nat.o on regcache.h.  Oops.)
@
text
@d276 1
d279 13
a291 6
  if (regno >= S390_FIRST_CR && regno <= S390_LAST_CR)
    supply_register (regno, NULL);
  else if (regno != -1)
    supply_register (regno, (char *) &gregp[regno]);
  else
    supply_gregset (gregsetp);
d302 12
a313 6
  if (regno == -1)
    supply_fpregset (fpregsetp);
  else
    supply_register (regno,
		     &((char *) fpregsetp)[REGISTER_BYTE (regno) -
					   REGISTER_BYTE (S390_FPC_REGNUM)]);
@


1.5.8.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a275 1
  int regi;
d278 6
a283 13
  if (regno < 0) 
    {
      regcache_collect (S390_PSWM_REGNUM, &gregp[S390_PSWM_REGNUM]);
      regcache_collect (S390_PC_REGNUM, &gregp[S390_PC_REGNUM]);
      for (regi = 0; regi < S390_NUM_GPRS; regi++)
        regcache_collect (S390_GP0_REGNUM + regi,
			  &gregp[S390_GP0_REGNUM + regi]);
      for (regi = 0; regi < S390_NUM_ACRS; regi++)
        regcache_collect (S390_FIRST_ACR + regi,
			  &gregp[S390_FIRST_ACR + regi]);
    }
  else if (regno >= S390_PSWM_REGNUM && regno <= S390_LAST_ACR)
    regcache_collect (regno, &gregp[regno]);
d294 6
a299 12
  int regi;

  if (regno < 0) 
    {
      regcache_collect (S390_FPC_REGNUM, &fpregsetp->fpc);
      for (regi = 0; regi < S390_NUM_FPRS; regi++)
        regcache_collect (S390_FP0_REGNUM + regi, &fpregsetp->fprs[regi]);
    }
  else if (regno == S390_FPC_REGNUM)
    regcache_collect (S390_FPC_REGNUM, &fpregsetp->fpc);
  else if (regno >= S390_FP0_REGNUM && regno <= S390_FPLAST_REGNUM)
    regcache_collect (regno, &fpregsetp->fprs[regno - S390_FP0_REGNUM]);
@


1.5.2.1
log
@From Gerhard Tonn <TON@@de.ibm.com>:
* s390-nat.c (fill_fpregset, fill_gregset): Use regcache_collect
instead of supply_register.
@
text
@a275 1
  int regi;
d278 6
a283 13
  if (regno < 0) 
    {
      regcache_collect (S390_PSWM_REGNUM, &gregp[S390_PSWM_REGNUM]);
      regcache_collect (S390_PC_REGNUM, &gregp[S390_PC_REGNUM]);
      for (regi = 0; regi < S390_NUM_GPRS; regi++)
        regcache_collect (S390_GP0_REGNUM + regi,
			  &gregp[S390_GP0_REGNUM + regi]);
      for (regi = 0; regi < S390_NUM_ACRS; regi++)
        regcache_collect (S390_FIRST_ACR + regi,
			  &gregp[S390_FIRST_ACR + regi]);
    }
  else if (regno >= S390_PSWM_REGNUM && regno <= S390_LAST_ACR)
    regcache_collect (regno, &gregp[regno]);
d294 6
a299 12
  int regi;

  if (regno < 0) 
    {
      regcache_collect (S390_FPC_REGNUM, &fpregsetp->fpc);
      for (regi = 0; regi < S390_NUM_FPRS; regi++)
        regcache_collect (S390_FP0_REGNUM + regi, &fpregsetp->fprs[regi]);
    }
  else if (regno == S390_FPC_REGNUM)
    regcache_collect (S390_FPC_REGNUM, &fpregsetp->fpc);
  else if (regno >= S390_FP0_REGNUM && regno <= S390_FPLAST_REGNUM)
    regcache_collect (regno, &fpregsetp->fprs[regno - S390_FP0_REGNUM]);
@


1.4
log
@* gdb/s390-nat.c (s390_register_u_addr): Pass proper arguments to
internal_error.
@
text
@d24 1
@


1.3
log
@use xmalloc() and xfree().
@
text
@d62 2
a63 1
      error
d65 3
a67 1
      internal_error
a68 2
	("s390_register_u_addr invalid regnum %s %d regnum=%d", __FILE__,
	 (int) __LINE__, regnum);
@


1.2
log
@S/390 31 & 64 bit target and GNU/Linux native support.
Contributed by D.J. Barrow <djbarrow@@de.ibm.com> of IBM.
* s390-nat.c, s390-tdep.c: New file.
* config/s390/nm-linux.h, config/s390/s390.mh: New file.
* config/s390/s390.mt, config/s390/s390x.mt: New file.
* config/s390/tm-linux.h, config/s390/tm-s390.h: New file.
* config/s390/xm-linux.h: New file.
* NEWS: Update.
* MAINTAINERS: Update.
@
text
@d141 1
a141 1
  watch_area *newarea = (watch_area *) malloc (sizeof (watch_area));
d208 1
a208 1
      free (matchCurr);
@


1.1
log
@file s390-nat.c was initially added on branch gdb_s390-2001-09-26-branch.
@
text
@d1 308
@


1.1.4.1
log
@S/390 31 & 64 bit target and GNU/Linux native support.
Contributed by D.J. Barrow <djbarrow@@de.ibm.com> of IBM.
* s390-nat.c, s390-tdep.c: New file.
* config/s390/nm-linux.h, config/s390/s390.mh: New file.
* config/s390/s390.mt, config/s390/s390x.mt: New file.
* config/s390/tm-linux.h, config/s390/tm-s390.h: New file.
* config/s390/xm-linux.h: New file.
* NEWS: Update.
* MAINTAINERS: Update.
@
text
@a0 308
/* S390 native-dependent code for GDB, the GNU debugger.
   Copyright 2001 Free Software Foundation, Inc
   Contributed by D.J. Barrow (djbarrow@@de.ibm.com,barrow_dj@@yahoo.com)
   for IBM Deutschland Entwicklung GmbH, IBM Corporation.
   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "defs.h"
#include "tm.h"
#include <asm/ptrace.h>
#include <sys/ptrace.h>
#include <asm/processor.h>
#include <sys/procfs.h>
#include <sys/user.h>
#include <value.h>
#include <sys/ucontext.h>
#ifndef offsetof
#define offsetof(type,member) ((size_t) &((type *)0)->member)
#endif


int
s390_register_u_addr (int blockend, int regnum)
{
  int retval;

  if (regnum >= S390_GP0_REGNUM && regnum <= S390_GP_LAST_REGNUM)
    retval = PT_GPR0 + ((regnum - S390_GP0_REGNUM) * S390_GPR_SIZE);
  else if (regnum >= S390_PSWM_REGNUM && regnum <= S390_PC_REGNUM)
    retval = PT_PSWMASK + ((regnum - S390_PSWM_REGNUM) * S390_PSW_MASK_SIZE);
  else if (regnum == S390_FPC_REGNUM)
    retval = PT_FPC;
  else if (regnum >= S390_FP0_REGNUM && regnum <= S390_FPLAST_REGNUM)
    retval =
#if CONFIG_ARCH_S390X
      PT_FPR0
#else
      PT_FPR0_HI
#endif
      + ((regnum - S390_FP0_REGNUM) * S390_FPR_SIZE);
  else if (regnum >= S390_FIRST_ACR && regnum <= S390_LAST_ACR)
    retval = PT_ACR0 + ((regnum - S390_FIRST_ACR) * S390_ACR_SIZE);
  else if (regnum >= (S390_FIRST_CR + 9) && regnum <= (S390_FIRST_CR + 11))
    retval = PT_CR_9 + ((regnum - (S390_FIRST_CR + 9)) * S390_CR_SIZE);
  else
    {
#ifdef GDBSERVER
      error
#else
      internal_error
#endif
	("s390_register_u_addr invalid regnum %s %d regnum=%d", __FILE__,
	 (int) __LINE__, regnum);
      retval = 0;
    }
  return retval + blockend;
}

#ifndef GDBSERVER
/* watch_areas are required if you put 2 or more watchpoints on the same 
   address or overlapping areas gdb will call us to delete the watchpoint 
   more than once when we try to delete them.
   attempted reference counting to reduce the number of areas unfortunately
   they didn't shrink when areas had to be split overlapping occurs. */
struct watch_area;
typedef struct watch_area watch_area;
struct watch_area
{
  watch_area *next;
  CORE_ADDR lo_addr;
  CORE_ADDR hi_addr;
};

static watch_area *watch_base = NULL;
int watch_area_cnt = 0;
static CORE_ADDR watch_lo_addr = 0, watch_hi_addr = 0;



CORE_ADDR
s390_stopped_by_watchpoint (int pid)
{
  per_lowcore_bits per_lowcore;
  ptrace_area parea;

  parea.len = sizeof (per_lowcore);
  parea.process_addr = (addr_t) & per_lowcore;
  parea.kernel_addr = offsetof (struct user_regs_struct, per_info.lowcore);
  ptrace (PTRACE_PEEKUSR_AREA, pid, &parea);
  return ((per_lowcore.perc_storage_alteration == 1) &&
	  (per_lowcore.perc_store_real_address == 0));
}


void
s390_fix_watch_points (int pid)
{
  per_struct per_info;
  ptrace_area parea;

  parea.len = sizeof (per_info);
  parea.process_addr = (addr_t) & per_info;
  parea.kernel_addr = PT_CR_9;
  ptrace (PTRACE_PEEKUSR_AREA, pid, &parea);
  /* The kernel automatically sets the psw for per depending */
  /* on whether the per control registers are set for event recording */
  /* & sets cr9 & cr10 appropriately also */
  if (watch_area_cnt)
    {
      per_info.control_regs.bits.em_storage_alteration = 1;
      per_info.control_regs.bits.storage_alt_space_ctl = 1;
    }
  else
    {
      per_info.control_regs.bits.em_storage_alteration = 0;
      per_info.control_regs.bits.storage_alt_space_ctl = 0;
    }
  per_info.starting_addr = watch_lo_addr;
  per_info.ending_addr = watch_hi_addr;
  ptrace (PTRACE_POKEUSR_AREA, pid, &parea);
}

int
s390_insert_watchpoint (int pid, CORE_ADDR addr, int len, int rw)
{
  CORE_ADDR hi_addr = addr + len - 1;
  watch_area *newarea = (watch_area *) malloc (sizeof (watch_area));


  if (newarea)
    {
      newarea->next = watch_base;
      watch_base = newarea;
      watch_lo_addr = min (watch_lo_addr, addr);
      watch_hi_addr = max (watch_hi_addr, hi_addr);
      newarea->lo_addr = addr;
      newarea->hi_addr = hi_addr;
      if (watch_area_cnt == 0)
	{
	  watch_lo_addr = newarea->lo_addr;
	  watch_hi_addr = newarea->hi_addr;
	}
      watch_area_cnt++;
      s390_fix_watch_points (pid);
    }
  return newarea ? 0 : -1;
}


int
s390_remove_watchpoint (int pid, CORE_ADDR addr, int len)
{
  watch_area *curr = watch_base, *prev, *matchCurr;
  CORE_ADDR hi_addr = addr + len - 1;
  CORE_ADDR watch_second_lo_addr = 0xffffffffUL, watch_second_hi_addr = 0;
  int lo_addr_ref_cnt, hi_addr_ref_cnt;
  prev = matchCurr = NULL;
  lo_addr_ref_cnt = (addr == watch_lo_addr);
  hi_addr_ref_cnt = (addr == watch_hi_addr);
  while (curr)
    {
      if (matchCurr == NULL)
	{
	  if (curr->lo_addr == addr && curr->hi_addr == hi_addr)
	    {
	      matchCurr = curr;
	      if (prev)
		prev->next = curr->next;
	      else
		watch_base = curr->next;
	    }
	  prev = curr;
	}
      if (lo_addr_ref_cnt)
	{
	  if (watch_lo_addr == curr->lo_addr)
	    lo_addr_ref_cnt++;
	  if (curr->lo_addr > watch_lo_addr &&
	      curr->lo_addr < watch_second_lo_addr)
	    watch_second_lo_addr = curr->lo_addr;
	}
      if (hi_addr_ref_cnt)
	{
	  if (watch_hi_addr == curr->hi_addr)
	    hi_addr_ref_cnt++;
	  if (curr->hi_addr < watch_hi_addr &&
	      curr->hi_addr > watch_second_hi_addr)
	    watch_second_hi_addr = curr->hi_addr;
	}
      curr = curr->next;
    }
  if (matchCurr)
    {
      free (matchCurr);
      watch_area_cnt--;
      if (watch_area_cnt)
	{
	  if (lo_addr_ref_cnt == 2)
	    watch_lo_addr = watch_second_lo_addr;
	  if (hi_addr_ref_cnt == 2)
	    watch_hi_addr = watch_second_hi_addr;
	}
      else
	{
	  watch_lo_addr = watch_hi_addr = 0;
	}
      s390_fix_watch_points (pid);
      return 0;
    }
  else
    {
      fprintf_unfiltered (gdb_stderr,
			  "Attempt to remove nonexistent watchpoint in s390_remove_watchpoint\n");
      return -1;
    }
}

int
kernel_u_size (void)
{
  return sizeof (struct user);
}


#if  (defined (S390_FP0_REGNUM) && defined (HAVE_FPREGSET_T) && defined(HAVE_SYS_PROCFS_H) && defined (HAVE_GREGSET_T))
void
supply_gregset (gregset_t * gregsetp)
{
  int regi;
  greg_t *gregp = (greg_t *) gregsetp;

  supply_register (S390_PSWM_REGNUM, (char *) &gregp[S390_PSWM_REGNUM]);
  supply_register (S390_PC_REGNUM, (char *) &gregp[S390_PC_REGNUM]);
  for (regi = 0; regi < S390_NUM_GPRS; regi++)
    supply_register (S390_GP0_REGNUM + regi,
		     (char *) &gregp[S390_GP0_REGNUM + regi]);
  for (regi = 0; regi < S390_NUM_ACRS; regi++)
    supply_register (S390_FIRST_ACR + regi,
		     (char *) &gregp[S390_FIRST_ACR + regi]);
  /* unfortunately this isn't in gregsetp */
  for (regi = 0; regi < S390_NUM_CRS; regi++)
    supply_register (S390_FIRST_CR + regi, NULL);
}


void
supply_fpregset (fpregset_t * fpregsetp)
{
  int regi;

  supply_register (S390_FPC_REGNUM, (char *) &fpregsetp->fpc);
  for (regi = 0; regi < S390_NUM_FPRS; regi++)
    supply_register (S390_FP0_REGNUM + regi, (char *) &fpregsetp->fprs[regi]);

}

void
fill_gregset (gregset_t * gregsetp, int regno)
{
  greg_t *gregp = (greg_t *) gregsetp;

  if (regno >= S390_FIRST_CR && regno <= S390_LAST_CR)
    supply_register (regno, NULL);
  else if (regno != -1)
    supply_register (regno, (char *) &gregp[regno]);
  else
    supply_gregset (gregsetp);
}

/*  Given a pointer to a floating point register set in /proc format
   (fpregset_t *), update the register specified by REGNO from gdb's idea
   of the current floating point register set.  If REGNO is -1, update
   them all. */

void
fill_fpregset (fpregset_t * fpregsetp, int regno)
{
  if (regno == -1)
    supply_fpregset (fpregsetp);
  else
    supply_register (regno,
		     &((char *) fpregsetp)[REGISTER_BYTE (regno) -
					   REGISTER_BYTE (S390_FPC_REGNUM)]);
}


#else
#error "There are a few possibilities here"
#error "1) You aren't compiling for linux & don't need a core dumps to work."
#error "2) The header files sys/elf.h sys/user.h sys/ptrace.h & sys/procfs.h"
#error "libc files are inconsistent with linux/include/asm-s390/"
#error "3) you didn't do a completely clean build & delete config.cache."
#endif
#endif /* GDBSERVER */
@


1.1.2.1
log
@http://www10.software.ibm.com/developerworks/opensource/linux390/exp_src.html
Patch:    gdb-5.1pre-050901-s390.tar.gz (09/11/2001)
MD5: 886251f3719a754dd65a69df462ceac1
@
text
@a0 308
/* S390 native-dependent code for GDB, the GNU debugger.
   Copyright 1999-2001 Free Software Foundation, Inc
   Contributed by D.J. Barrow (djbarrow@@de.ibm.com,barrow_dj@@yahoo.com)
   for IBM Deutschland Entwicklung GmbH, IBM Corporation.
   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#include "defs.h"
#include "tm.h"
#include <asm/ptrace.h>
#include <sys/ptrace.h>
#include <asm/processor.h>
#include <sys/procfs.h>
#include <sys/user.h>
#include <value.h>
#include <sys/ucontext.h>
#ifndef offsetof
#define offsetof(type,member) ((size_t) &((type *)0)->member)
#endif


int
s390_register_u_addr (int blockend, int regnum)
{
  int retval;

  if (regnum >= S390_GP0_REGNUM && regnum <= S390_GP_LAST_REGNUM)
    retval = PT_GPR0 + ((regnum - S390_GP0_REGNUM) * S390_GPR_SIZE);
  else if (regnum >= S390_PSWM_REGNUM && regnum <= S390_PC_REGNUM)
    retval = PT_PSWMASK + ((regnum - S390_PSWM_REGNUM) * S390_PSW_MASK_SIZE);
  else if (regnum == S390_FPC_REGNUM)
    retval = PT_FPC;
  else if (regnum >= S390_FP0_REGNUM && regnum <= S390_FPLAST_REGNUM)
    retval =
#if CONFIG_ARCH_S390X
      PT_FPR0
#else
      PT_FPR0_HI
#endif
      + ((regnum - S390_FP0_REGNUM) * S390_FPR_SIZE);
  else if (regnum >= S390_FIRST_ACR && regnum <= S390_LAST_ACR)
    retval = PT_ACR0 + ((regnum - S390_FIRST_ACR) * S390_ACR_SIZE);
  else if (regnum >= (S390_FIRST_CR + 9) && regnum <= (S390_FIRST_CR + 11))
    retval = PT_CR_9 + ((regnum - (S390_FIRST_CR + 9)) * S390_CR_SIZE);
  else
    {
#ifdef GDBSERVER
      error
#else
      internal_error
#endif
	("s390_register_u_addr invalid regnum %s %d regnum=%d", __FILE__,
	 (int) __LINE__, regnum);
      retval = 0;
    }
  return retval + blockend;
}

#ifndef GDBSERVER
/* watch_areas are required if you put 2 or more watchpoints on the same 
   address or overlapping areas gdb will call us to delete the watchpoint 
   more than once when we try to delete them.
   attempted reference counting to reduce the number of areas unfortunately
   they didn't shrink when areas had to be split overlapping occurs. */
struct watch_area;
typedef struct watch_area watch_area;
struct watch_area
{
  watch_area *next;
  CORE_ADDR lo_addr;
  CORE_ADDR hi_addr;
};

static watch_area *watch_base = NULL;
int watch_area_cnt = 0;
static CORE_ADDR watch_lo_addr = 0, watch_hi_addr = 0;



CORE_ADDR
s390_stopped_by_watchpoint (int pid)
{
  per_lowcore_bits per_lowcore;
  ptrace_area parea;

  parea.len = sizeof (per_lowcore);
  parea.process_addr = (addr_t) & per_lowcore;
  parea.kernel_addr = offsetof (struct user_regs_struct, per_info.lowcore);
  ptrace (PTRACE_PEEKUSR_AREA, pid, &parea);
  return ((per_lowcore.perc_storage_alteration == 1) &&
	  (per_lowcore.perc_store_real_address == 0));
}


void
s390_fix_watch_points (int pid)
{
  per_struct per_info;
  ptrace_area parea;

  parea.len = sizeof (per_info);
  parea.process_addr = (addr_t) & per_info;
  parea.kernel_addr = PT_CR_9;
  ptrace (PTRACE_PEEKUSR_AREA, pid, &parea);
  /* The kernel automatically sets the psw for per depending */
  /* on whether the per control registers are set for event recording */
  /* & sets cr9 & cr10 appropriately also */
  if (watch_area_cnt)
    {
      per_info.control_regs.bits.em_storage_alteration = 1;
      per_info.control_regs.bits.storage_alt_space_ctl = 1;
    }
  else
    {
      per_info.control_regs.bits.em_storage_alteration = 0;
      per_info.control_regs.bits.storage_alt_space_ctl = 0;
    }
  per_info.starting_addr = watch_lo_addr;
  per_info.ending_addr = watch_hi_addr;
  ptrace (PTRACE_POKEUSR_AREA, pid, &parea);
}

int
s390_insert_watchpoint (int pid, CORE_ADDR addr, int len, int rw)
{
  CORE_ADDR hi_addr = addr + len - 1;
  watch_area *newarea = (watch_area *) malloc (sizeof (watch_area));


  if (newarea)
    {
      newarea->next = watch_base;
      watch_base = newarea;
      watch_lo_addr = min (watch_lo_addr, addr);
      watch_hi_addr = max (watch_hi_addr, hi_addr);
      newarea->lo_addr = addr;
      newarea->hi_addr = hi_addr;
      if (watch_area_cnt == 0)
	{
	  watch_lo_addr = newarea->lo_addr;
	  watch_hi_addr = newarea->hi_addr;
	}
      watch_area_cnt++;
      s390_fix_watch_points (pid);
    }
  return newarea ? 0 : -1;
}


int
s390_remove_watchpoint (int pid, CORE_ADDR addr, int len)
{
  watch_area *curr = watch_base, *prev, *matchCurr;
  CORE_ADDR hi_addr = addr + len - 1;
  CORE_ADDR watch_second_lo_addr = 0xffffffffUL, watch_second_hi_addr = 0;
  int lo_addr_ref_cnt, hi_addr_ref_cnt;
  prev = matchCurr = NULL;
  lo_addr_ref_cnt = (addr == watch_lo_addr);
  hi_addr_ref_cnt = (addr == watch_hi_addr);
  while (curr)
    {
      if (matchCurr == NULL)
	{
	  if (curr->lo_addr == addr && curr->hi_addr == hi_addr)
	    {
	      matchCurr = curr;
	      if (prev)
		prev->next = curr->next;
	      else
		watch_base = curr->next;
	    }
	  prev = curr;
	}
      if (lo_addr_ref_cnt)
	{
	  if (watch_lo_addr == curr->lo_addr)
	    lo_addr_ref_cnt++;
	  if (curr->lo_addr > watch_lo_addr &&
	      curr->lo_addr < watch_second_lo_addr)
	    watch_second_lo_addr = curr->lo_addr;
	}
      if (hi_addr_ref_cnt)
	{
	  if (watch_hi_addr == curr->hi_addr)
	    hi_addr_ref_cnt++;
	  if (curr->hi_addr < watch_hi_addr &&
	      curr->hi_addr > watch_second_hi_addr)
	    watch_second_hi_addr = curr->hi_addr;
	}
      curr = curr->next;
    }
  if (matchCurr)
    {
      free (matchCurr);
      watch_area_cnt--;
      if (watch_area_cnt)
	{
	  if (lo_addr_ref_cnt == 2)
	    watch_lo_addr = watch_second_lo_addr;
	  if (hi_addr_ref_cnt == 2)
	    watch_hi_addr = watch_second_hi_addr;
	}
      else
	{
	  watch_lo_addr = watch_hi_addr = 0;
	}
      s390_fix_watch_points (pid);
      return 0;
    }
  else
    {
      fprintf_unfiltered (gdb_stderr,
			  "Attempt to remove nonexistent watchpoint in s390_remove_watchpoint\n");
      return -1;
    }
}

int
kernel_u_size (void)
{
  return sizeof (struct user);
}


#if  (defined (S390_FP0_REGNUM) && defined (HAVE_FPREGSET_T) && defined(HAVE_SYS_PROCFS_H) && defined (HAVE_GREGSET_T))
void
supply_gregset (gregset_t * gregsetp)
{
  int regi;
  greg_t *gregp = (greg_t *) gregsetp;

  supply_register (S390_PSWM_REGNUM, (char *) &gregp[S390_PSWM_REGNUM]);
  supply_register (S390_PC_REGNUM, (char *) &gregp[S390_PC_REGNUM]);
  for (regi = 0; regi < S390_NUM_GPRS; regi++)
    supply_register (S390_GP0_REGNUM + regi,
		     (char *) &gregp[S390_GP0_REGNUM + regi]);
  for (regi = 0; regi < S390_NUM_ACRS; regi++)
    supply_register (S390_FIRST_ACR + regi,
		     (char *) &gregp[S390_FIRST_ACR + regi]);
  /* unfortunately this isn't in gregsetp */
  for (regi = 0; regi < S390_NUM_CRS; regi++)
    supply_register (S390_FIRST_CR + regi, NULL);
}


void
supply_fpregset (fpregset_t * fpregsetp)
{
  int regi;

  supply_register (S390_FPC_REGNUM, (char *) &fpregsetp->fpc);
  for (regi = 0; regi < S390_NUM_FPRS; regi++)
    supply_register (S390_FP0_REGNUM + regi, (char *) &fpregsetp->fprs[regi]);

}

void
fill_gregset (gregset_t * gregsetp, int regno)
{
  greg_t *gregp = (greg_t *) gregsetp;

  if (regno >= S390_FIRST_CR && regno <= S390_LAST_CR)
    supply_register (regno, NULL);
  else if (regno != -1)
    supply_register (regno, (char *) &gregp[regno]);
  else
    supply_gregset (gregsetp);
}

/*  Given a pointer to a floating point register set in /proc format
   (fpregset_t *), update the register specified by REGNO from gdb's idea
   of the current floating point register set.  If REGNO is -1, update
   them all. */

void
fill_fpregset (fpregset_t * fpregsetp, int regno)
{
  if (regno == -1)
    supply_fpregset (fpregsetp);
  else
    supply_register (regno,
		     &((char *) fpregsetp)[REGISTER_BYTE (regno) -
					   REGISTER_BYTE (S390_FPC_REGNUM)]);
}


#else
#error "There are a few possibilities here"
#error "1) You aren't compiling for linux & don't need a core dumps to work."
#error "2) The header files sys/elf.h sys/user.h sys/ptrace.h & sys/procfs.h"
#error "libc files are inconsistent with linux/include/asm-s390/"
#error "3) you didn't do a completely clean build & delete config.cache."
#endif
#endif /* GDBSERVER */
@


1.1.2.2
log
@* s390-tdep.c, s390-nat.c: Update copyright.
* config/s390/tm-s390.h, config/s390/xm-linux.h: Ditto.
* config/s390/tm-linux.h, config/s390/nm-linux.h: Ditto.
@
text
@d2 1
a2 1
   Copyright 2001 Free Software Foundation, Inc
@


