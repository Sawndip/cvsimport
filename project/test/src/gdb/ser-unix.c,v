head	1.43;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.42
	gdb_7_6-2013-04-26-release:1.42
	gdb_7_6-branch:1.42.0.2
	gdb_7_6-2013-03-12-branchpoint:1.42
	gdb_7_5_1-2012-11-29-release:1.41
	gdb_7_5-2012-08-17-release:1.41
	gdb_7_5-branch:1.41.0.2
	gdb_7_5-2012-07-18-branchpoint:1.41
	gdb_7_4_1-2012-04-26-release:1.40.4.1
	gdb_7_4-2012-01-24-release:1.40.4.1
	gdb_7_4-branch:1.40.0.4
	gdb_7_4-2011-12-13-branchpoint:1.40
	gdb_7_3_1-2011-09-04-release:1.40
	gdb_7_3-2011-07-26-release:1.40
	gdb_7_3-branch:1.40.0.2
	gdb_7_3-2011-04-01-branchpoint:1.40
	gdb_7_2-2010-09-02-release:1.35
	gdb_7_2-branch:1.35.0.2
	gdb_7_2-2010-07-07-branchpoint:1.35
	gdb_7_1-2010-03-18-release:1.34
	gdb_7_1-branch:1.34.0.2
	gdb_7_1-2010-02-18-branchpoint:1.34
	gdb_7_0_1-2009-12-22-release:1.33
	gdb_7_0-2009-10-06-release:1.33
	gdb_7_0-branch:1.33.0.4
	gdb_7_0-2009-09-16-branchpoint:1.33
	arc-sim-20090309:1.31
	msnyder-checkpoint-072509-branch:1.33.0.2
	msnyder-checkpoint-072509-branchpoint:1.33
	arc-insight_6_8-branch:1.31.0.16
	arc-insight_6_8-branchpoint:1.31
	insight_6_8-branch:1.31.0.14
	insight_6_8-branchpoint:1.31
	reverse-20081226-branch:1.31.0.12
	reverse-20081226-branchpoint:1.31
	multiprocess-20081120-branch:1.31.0.10
	multiprocess-20081120-branchpoint:1.31
	reverse-20080930-branch:1.31.0.8
	reverse-20080930-branchpoint:1.31
	reverse-20080717-branch:1.31.0.6
	reverse-20080717-branchpoint:1.31
	msnyder-reverse-20080609-branch:1.31.0.4
	msnyder-reverse-20080609-branchpoint:1.31
	drow-reverse-20070409-branch:1.28.0.2
	drow-reverse-20070409-branchpoint:1.28
	gdb_6_8-2008-03-27-release:1.31
	gdb_6_8-branch:1.31.0.2
	gdb_6_8-2008-02-26-branchpoint:1.31
	gdb_6_7_1-2007-10-29-release:1.30
	gdb_6_7-2007-10-10-release:1.30
	gdb_6_7-branch:1.30.0.2
	gdb_6_7-2007-09-07-branchpoint:1.30
	insight_6_6-20070208-release:1.27
	gdb_6_6-2006-12-18-release:1.27
	gdb_6_6-branch:1.27.0.18
	gdb_6_6-2006-11-15-branchpoint:1.27
	insight_6_5-20061003-release:1.27
	gdb-csl-symbian-6_4_50_20060226-12:1.27
	gdb-csl-sourcerygxx-3_4_4-25:1.25
	nickrob-async-20060828-mergepoint:1.27
	gdb-csl-symbian-6_4_50_20060226-11:1.27
	gdb-csl-sourcerygxx-4_1-17:1.27
	gdb-csl-20060226-branch-local-2:1.27
	gdb-csl-sourcerygxx-4_1-14:1.27
	gdb-csl-sourcerygxx-4_1-13:1.27
	gdb-csl-sourcerygxx-4_1-12:1.27
	gdb-csl-sourcerygxx-3_4_4-21:1.27
	gdb_6_5-20060621-release:1.27
	gdb-csl-sourcerygxx-4_1-9:1.27
	gdb-csl-sourcerygxx-4_1-8:1.27
	gdb-csl-sourcerygxx-4_1-7:1.27
	gdb-csl-arm-2006q1-6:1.27
	gdb-csl-sourcerygxx-4_1-6:1.27
	gdb-csl-symbian-6_4_50_20060226-10:1.27
	gdb-csl-symbian-6_4_50_20060226-9:1.27
	gdb-csl-symbian-6_4_50_20060226-8:1.27
	gdb-csl-coldfire-4_1-11:1.27
	gdb-csl-sourcerygxx-3_4_4-19:1.27
	gdb-csl-coldfire-4_1-10:1.27
	gdb_6_5-branch:1.27.0.16
	gdb_6_5-2006-05-14-branchpoint:1.27
	gdb-csl-sourcerygxx-4_1-5:1.27
	nickrob-async-20060513-branch:1.27.0.14
	nickrob-async-20060513-branchpoint:1.27
	gdb-csl-sourcerygxx-4_1-4:1.27
	msnyder-reverse-20060502-branch:1.27.0.12
	msnyder-reverse-20060502-branchpoint:1.27
	gdb-csl-morpho-4_1-4:1.27
	gdb-csl-sourcerygxx-3_4_4-17:1.27
	readline_5_1-import-branch:1.27.0.10
	readline_5_1-import-branchpoint:1.27
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.27
	gdb-csl-symbian-20060226-branch:1.27.0.8
	gdb-csl-symbian-20060226-branchpoint:1.27
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.27
	msnyder-reverse-20060331-branch:1.27.0.6
	msnyder-reverse-20060331-branchpoint:1.27
	gdb-csl-available-20060303-branch:1.27.0.4
	gdb-csl-available-20060303-branchpoint:1.27
	gdb-csl-20060226-branch:1.27.0.2
	gdb-csl-20060226-branchpoint:1.27
	gdb_6_4-20051202-release:1.25
	msnyder-fork-checkpoint-branch:1.25.0.10
	msnyder-fork-checkpoint-branchpoint:1.25
	gdb-csl-gxxpro-6_3-branch:1.25.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.25
	gdb_6_4-branch:1.25.0.6
	gdb_6_4-2005-11-01-branchpoint:1.25
	gdb-csl-arm-20051020-branch:1.25.0.4
	gdb-csl-arm-20051020-branchpoint:1.25
	msnyder-tracepoint-checkpoint-branch:1.25.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.25
	gdb-csl-arm-20050325-2005-q1b:1.22.2.3
	gdb-csl-arm-20050325-2005-q1a:1.22.2.3
	csl-arm-20050325-branch:1.22.0.2
	csl-arm-20050325-branchpoint:1.22
	gdb-post-i18n-errorwarning-20050211:1.22
	gdb-pre-i18n-errorwarning-20050211:1.21
	gdb_6_3-20041109-release:1.20
	gdb_6_3-branch:1.20.0.4
	gdb_6_3-20041019-branchpoint:1.20
	drow_intercu-merge-20040921:1.20
	drow_intercu-merge-20040915:1.20
	jimb-gdb_6_2-e500-branch:1.20.0.6
	jimb-gdb_6_2-e500-branchpoint:1.20
	gdb_6_2-20040730-release:1.20
	gdb_6_2-branch:1.20.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.20
	gdb_6_1_1-20040616-release:1.18
	gdb_6_1-2004-04-05-release:1.18
	drow_intercu-merge-20040402:1.18
	drow_intercu-merge-20040327:1.18
	ezannoni_pie-20040323-branch:1.18.0.12
	ezannoni_pie-20040323-branchpoint:1.18
	cagney_tramp-20040321-mergepoint:1.18
	cagney_tramp-20040309-branch:1.18.0.10
	cagney_tramp-20040309-branchpoint:1.18
	gdb_6_1-branch:1.18.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.18
	drow_intercu-20040221-branch:1.18.0.6
	drow_intercu-20040221-branchpoint:1.18
	cagney_bfdfile-20040213-branch:1.18.0.4
	cagney_bfdfile-20040213-branchpoint:1.18
	drow-cplus-merge-20040208:1.18
	carlton_dictionary-20040126-merge:1.18
	cagney_bigcore-20040122-branch:1.18.0.2
	cagney_bigcore-20040122-branchpoint:1.18
	drow-cplus-merge-20040113:1.18
	drow-cplus-merge-20031224:1.16
	drow-cplus-merge-20031220:1.16
	carlton_dictionary-20031215-merge:1.16
	drow-cplus-merge-20031214:1.16
	carlton-dictionary-20031111-merge:1.16
	gdb_6_0-2003-10-04-release:1.16
	kettenis_sparc-20030918-branch:1.16.0.16
	kettenis_sparc-20030918-branchpoint:1.16
	carlton_dictionary-20030917-merge:1.16
	ezannoni_pie-20030916-branchpoint:1.16
	ezannoni_pie-20030916-branch:1.16.0.14
	cagney_x86i386-20030821-branch:1.16.0.12
	cagney_x86i386-20030821-branchpoint:1.16
	carlton_dictionary-20030805-merge:1.16
	carlton_dictionary-20030627-merge:1.16
	gdb_6_0-branch:1.16.0.10
	gdb_6_0-2003-06-23-branchpoint:1.16
	jimb-ppc64-linux-20030613-branch:1.16.0.8
	jimb-ppc64-linux-20030613-branchpoint:1.16
	cagney_convert-20030606-branch:1.16.0.6
	cagney_convert-20030606-branchpoint:1.16
	cagney_writestrings-20030508-branch:1.15.0.48
	cagney_writestrings-20030508-branchpoint:1.15
	jimb-ppc64-linux-20030528-branch:1.16.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.16
	carlton_dictionary-20030523-merge:1.16
	cagney_fileio-20030521-branch:1.16.0.2
	cagney_fileio-20030521-branchpoint:1.16
	kettenis_i386newframe-20030517-mergepoint:1.16
	jimb-ppc64-linux-20030509-branch:1.15.0.46
	jimb-ppc64-linux-20030509-branchpoint:1.15
	kettenis_i386newframe-20030504-mergepoint:1.15
	carlton_dictionary-20030430-merge:1.15
	kettenis_i386newframe-20030419-branch:1.15.0.44
	kettenis_i386newframe-20030419-branchpoint:1.15
	carlton_dictionary-20030416-merge:1.15
	cagney_frameaddr-20030409-mergepoint:1.15
	kettenis_i386newframe-20030406-branch:1.15.0.42
	kettenis_i386newframe-20030406-branchpoint:1.15
	cagney_frameaddr-20030403-branchpoint:1.15
	cagney_frameaddr-20030403-branch:1.15.0.40
	cagney_framebase-20030330-mergepoint:1.15
	cagney_framebase-20030326-branch:1.15.0.38
	cagney_framebase-20030326-branchpoint:1.15
	cagney_lazyid-20030317-branch:1.15.0.36
	cagney_lazyid-20030317-branchpoint:1.15
	kettenis-i386newframe-20030316-mergepoint:1.15
	offbyone-20030313-branch:1.15.0.34
	offbyone-20030313-branchpoint:1.15
	kettenis-i386newframe-20030308-branch:1.15.0.32
	kettenis-i386newframe-20030308-branchpoint:1.15
	carlton_dictionary-20030305-merge:1.15
	cagney_offbyone-20030303-branch:1.15.0.30
	cagney_offbyone-20030303-branchpoint:1.15
	carlton_dictionary-20030207-merge:1.15
	interps-20030203-mergepoint:1.15
	interps-20030202-branch:1.15.0.28
	interps-20030202-branchpoint:1.15
	cagney-unwind-20030108-branch:1.15.0.26
	cagney-unwind-20030108-branchpoint:1.15
	carlton_dictionary-20021223-merge:1.15
	gdb_5_3-2002-12-12-release:1.15
	carlton_dictionary-20021115-merge:1.15
	kseitz_interps-20021105-merge:1.15
	kseitz_interps-20021103-merge:1.15
	drow-cplus-merge-20021020:1.15
	drow-cplus-merge-20021025:1.15
	carlton_dictionary-20021025-merge:1.15
	carlton_dictionary-20021011-merge:1.15
	drow-cplus-branch:1.15.0.24
	drow-cplus-branchpoint:1.15
	kseitz_interps-20020930-merge:1.15
	carlton_dictionary-20020927-merge:1.15
	carlton_dictionary-branch:1.15.0.22
	carlton_dictionary-20020920-branchpoint:1.15
	gdb_5_3-branch:1.15.0.20
	gdb_5_3-2002-09-04-branchpoint:1.15
	kseitz_interps-20020829-merge:1.15
	cagney_sysregs-20020825-branch:1.15.0.18
	cagney_sysregs-20020825-branchpoint:1.15
	readline_4_3-import-branch:1.15.0.16
	readline_4_3-import-branchpoint:1.15
	gdb_5_2_1-2002-07-23-release:1.15
	kseitz_interps-20020528-branch:1.15.0.14
	kseitz_interps-20020528-branchpoint:1.15
	cagney_regbuf-20020515-branch:1.15.0.12
	cagney_regbuf-20020515-branchpoint:1.15
	jimb-macro-020506-branch:1.15.0.10
	jimb-macro-020506-branchpoint:1.15
	gdb_5_2-2002-04-29-release:1.15
	gdb_5_2-branch:1.15.0.8
	gdb_5_2-2002-03-03-branchpoint:1.15
	gdb_5_1_1-2002-01-24-release:1.15
	gdb_5_1_0_1-2002-01-03-release:1.15
	cygnus_cvs_20020108_pre:1.15
	gdb_5_1_0_1-2002-01-03-branchpoint:1.15
	gdb_5_1_0_1-2002-01-03-branch:1.15.0.6
	gdb_5_1-2001-11-21-release:1.15
	gdb_s390-2001-09-26-branch:1.15.0.4
	gdb_s390-2001-09-26-branchpoint:1.15
	gdb_5_1-2001-07-29-branch:1.15.0.2
	gdb_5_1-2001-07-29-branchpoint:1.15
	dberlin-typesystem-branch:1.13.0.2
	dberlin-typesystem-branchpoint:1.13
	gdb-post-ptid_t-2001-05-03:1.12
	gdb-pre-ptid_t-2001-05-03:1.12
	insight-precleanup-2001-01-01:1.9
	gdb-post-protoization-2000-07-29:1.5
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.3.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.3
	repo-unification-2000-02-06:1.1.1.9
	insight-2000-02-04:1.1.1.9
	gdb-2000-02-04:1.1.1.9
	gdb-2000-02-02:1.1.1.9
	gdb-2000-02-01:1.1.1.9
	gdb-2000-01-31:1.1.1.8
	gdb-2000-01-26:1.1.1.8
	gdb-2000-01-24:1.1.1.8
	gdb-2000-01-17:1.1.1.8
	gdb-2000-01-10:1.1.1.8
	gdb-2000-01-05:1.1.1.8
	gdb-1999-12-21:1.1.1.8
	gdb-1999-12-13:1.1.1.8
	gdb-1999-12-07:1.1.1.8
	gdb-1999-12-06:1.1.1.8
	gdb-1999-11-16:1.1.1.8
	gdb-1999-11-08:1.1.1.8
	gdb-1999-11-01:1.1.1.8
	gdb-1999-10-25:1.1.1.8
	gdb-1999-10-18:1.1.1.8
	gdb-1999-10-11:1.1.1.8
	gdb-1999-10-04:1.1.1.8
	gdb-1999-09-28:1.1.1.7
	gdb-1999-09-21:1.1.1.7
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.6
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.5
	gdb-1999-08-09:1.1.1.5
	gdb-1999-08-02:1.1.1.5
	gdb-1999-07-26:1.1.1.5
	gdb-1999-07-19:1.1.1.5
	gdb-1999-07-12:1.1.1.5
	gdb-post-reformat-19990707:1.1.1.5
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.5
	gdb-pre-reformat-19990707:1.1.1.4
	gdb-1999-07-07:1.1.1.4
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.43
date	2013.04.22.16.46.15;	author tromey;	state Exp;
branches;
next	1.42;

1.42
date	2013.01.01.06.32.50;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2012.01.04.08.17.10;	author brobecke;	state Exp;
branches;
next	1.40;

1.40
date	2011.03.07.19.53.34;	author msnyder;	state Exp;
branches
	1.40.4.1;
next	1.39;

1.39
date	2011.03.04.19.23.42;	author uweigand;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.11.21.53.23;	author msnyder;	state Exp;
branches;
next	1.37;

1.37
date	2011.01.05.22.22.50;	author msnyder;	state Exp;
branches;
next	1.36;

1.36
date	2011.01.01.15.33.14;	author brobecke;	state Exp;
branches;
next	1.35;

1.35
date	2010.05.16.23.49.58;	author msnyder;	state Exp;
branches;
next	1.34;

1.34
date	2010.01.01.07.31.41;	author brobecke;	state Exp;
branches;
next	1.33;

1.33
date	2009.03.24.01.37.48;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.31;

1.31
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.30;

1.30
date	2007.08.23.18.08.37;	author brobecke;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.22.10.57.12;	author macro;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.09.17.58.58;	author drow;	state Exp;
branches;
next	1.27;

1.27
date	2006.02.10.22.01.43;	author drow;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.17.22.34.02;	author eliz;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.21.05.34.33;	author mmitchel;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.25.20.06.36;	author mmitchel;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.25.19.47.23;	author mmitchel;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.11.04.06.04;	author cagney;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2005.01.14.01.59.20;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.25.19.46.08;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.24.21.51.49;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.09.20.42.10;	author cagney;	state Exp;
branches
	1.18.6.1;
next	1.17;

1.17
date	2004.01.05.23.09.45;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.13.19.40.11;	author ian;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.15.20.34.14;	author cagney;	state Exp;
branches
	1.15.22.1
	1.15.24.1
	1.15.44.1;
next	1.14;

1.14
date	2001.07.11.17.52.32;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.11.18.34.13;	author fnasser;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.06.08.21.16;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.06.21.39.46;	author msokolov;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.02.19.14.33;	author jtc;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.02.14.56.20;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.30.21.50.57;	author jtc;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.25.14.19.38;	author fnasser;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.15.20.40.15;	author fnasser;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.01.08.02.53;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.28.08.24.28;	author cagney;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.02.09.08.52.47;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.40.4.1
date	2012.01.06.04.43.29;	author brobecke;	state Exp;
branches;
next	;

1.22.2.1
date	2005.03.28.18.31.44;	author mmitchel;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2005.03.28.18.33.30;	author mmitchel;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2005.03.28.18.46.22;	author mmitchel;	state Exp;
branches;
next	;

1.18.6.1
date	2004.09.16.17.01.19;	author drow;	state Exp;
branches;
next	;

1.15.22.1
date	2003.05.23.18.40.44;	author carlton;	state Exp;
branches;
next	1.15.22.2;

1.15.22.2
date	2004.01.26.19.11.30;	author carlton;	state Exp;
branches;
next	;

1.15.24.1
date	2003.12.14.20.27.30;	author drow;	state Exp;
branches;
next	1.15.24.2;

1.15.24.2
date	2004.01.13.16.11.59;	author drow;	state Exp;
branches;
next	;

1.15.44.1
date	2003.05.18.09.44.20;	author kettenis;	state Exp;
branches;
next	;

1.3.2.1
date	2000.07.01.08.04.29;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.15;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.05.17.53.53;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.17.23.05;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.07.20.09.50;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.08.31.01.05.58;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.09.22.03.25.00;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.10.05.23.08.47;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2000.02.02.00.21.10;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.43
log
@	PR gdb/7912:
	* Makefile.in (SFILES): Add filestuff.c
	(COMMON_OBS): Add filestuff.o.
	(filestuff.o): New target.
	* auto-load.c (auto_load_objfile_script_1): Use
	gdb_fopen_cloexec.
	* auxv.c (procfs_xfer_auxv): Use gdb_open_cloexec.
	* cli/cli-cmds.c (shell_escape): Call close_most_fds.
	* cli/cli-dump.c (fopen_with_cleanup): Use gdb_fopen_cloexec.
	* common/agent.c (gdb_connect_sync_socket): Use
	gdb_socket_cloexec.
	* common/filestuff.c: New file.
	* common/filestuff.h: New file.
	* common/linux-osdata.c (linux_common_core_of_thread)
	(command_from_pid, commandline_from_pid, print_source_lines)
	(linux_xfer_osdata_shm, linux_xfer_osdata_sem)
	(linux_xfer_osdata_msg, linux_xfer_osdata_modules): Use
	gdb_fopen_cloexec.
	* common/linux-procfs.c (linux_proc_get_int)
	(linux_proc_pid_has_state): Use gdb_fopen_cloexec.
	* config.in, configure: Rebuild.
	* configure.ac: Don't check for sys/socket.h.  Check for
	fdwalk, pipe2.
	* corelow.c (core_open): Use gdb_open_cloexec.
	* dwarf2read.c (write_psymtabs_to_index): Use gdb_fopen_cloexec.
	* fork-child.c (fork_inferior): Call close_most_fds.
	* gdb_bfd.c (gdb_bfd_open): Use gdb_open_cloexec.
	* inf-child.c (inf_child_fileio_readlink): Use gdb_open_cloexec.
	* linux-nat.c (linux_nat_thread_name, linux_proc_pending_signals):
	Use gdb_fopen_cloexec.
	(linux_proc_xfer_partial, linux_proc_xfer_spu): Use
	gdb_open_cloexec.
	(linux_async_pipe): Use gdb_pipe_cloexec.
	* remote-fileio.c (remote_fileio_func_open): Use
	gdb_open_cloexec.
	* remote.c (remote_file_put, remote_file_get): Use
	gdb_fopen_cloexec.
	* ser-pipe.c (pipe_open): Use gdb_socketpair_cloexec,
	close_most_fds.
	* ser-tcp.c (net_open): Use gdb_socket_cloexec.
	* ser-unix.c (hardwire_open): Use gdb_open_cloexec.
	* solib.c (solib_find): Use gdb_open_cloexec.
	* source.c (openp, find_and_open_source): Use gdb_open_cloexec.
	* tracepoint.c (tfile_start): Use gdb_fopen_cloexec.
	(tfile_open): Use gdb_open_cloexec.
	* tui/tui-io.c (tui_initialize_io): Use gdb_pipe_cloexec.
	* ui-file.c (gdb_fopen): Use gdb_fopen_cloexec.
	* xml-support.c (xml_fetch_content_from_file): Use
	gdb_fopen_cloexec.
	* main.c (captured_main): Call notice_open_fds.
gdbserver
	* Makefile.in (SFILES): Add filestuff.c.
	(OBS): Add filestuff.o.
	(filestuff.o): New target.
	* config.in, configure: Rebuild.
	* configure.ac: Check for fdwalk, pipe2.
@
text
@/* Serial interface for local (hardwired) serial ports on Un*x like systems

   Copyright (C) 1992-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "serial.h"
#include "ser-base.h"
#include "ser-unix.h"

#include <fcntl.h>
#include <sys/types.h>
#include "terminal.h"
#include <sys/socket.h>
#include <sys/time.h>

#include "gdb_select.h"
#include "gdb_string.h"
#include "gdbcmd.h"
#include "filestuff.h"

#ifdef HAVE_TERMIOS

struct hardwire_ttystate
  {
    struct termios termios;
  };

#ifdef CRTSCTS
/* Boolean to explicitly enable or disable h/w flow control.  */
static int serial_hwflow;
static void
show_serial_hwflow (struct ui_file *file, int from_tty,
		    struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Hardware flow control is %s.\n"), value);
}
#endif

#endif /* termios */

#ifdef HAVE_TERMIO

/* It is believed that all systems which have added job control to SVR3
   (e.g. sco) have also added termios.  Even if not, trying to figure out
   all the variations (TIOCGPGRP vs. TCGETPGRP, etc.) would be pretty
   bewildering.  So we don't attempt it.  */

struct hardwire_ttystate
  {
    struct termio termio;
  };
#endif /* termio */

#ifdef HAVE_SGTTY
struct hardwire_ttystate
  {
    struct sgttyb sgttyb;
    struct tchars tc;
    struct ltchars ltc;
    /* Line discipline flags.  */
    int lmode;
  };
#endif /* sgtty */

static int hardwire_open (struct serial *scb, const char *name);
static void hardwire_raw (struct serial *scb);
static int wait_for (struct serial *scb, int timeout);
static int hardwire_readchar (struct serial *scb, int timeout);
static int do_hardwire_readchar (struct serial *scb, int timeout);
static int rate_to_code (int rate);
static int hardwire_setbaudrate (struct serial *scb, int rate);
static void hardwire_close (struct serial *scb);
static int get_tty_state (struct serial *scb,
			  struct hardwire_ttystate * state);
static int set_tty_state (struct serial *scb,
			  struct hardwire_ttystate * state);
static serial_ttystate hardwire_get_tty_state (struct serial *scb);
static int hardwire_set_tty_state (struct serial *scb, serial_ttystate state);
static int hardwire_noflush_set_tty_state (struct serial *, serial_ttystate,
					   serial_ttystate);
static void hardwire_print_tty_state (struct serial *, serial_ttystate,
				      struct ui_file *);
static int hardwire_drain_output (struct serial *);
static int hardwire_flush_output (struct serial *);
static int hardwire_flush_input (struct serial *);
static int hardwire_send_break (struct serial *);
static int hardwire_setstopbits (struct serial *, int);

void _initialize_ser_hardwire (void);

/* Open up a real live device for serial I/O.  */

static int
hardwire_open (struct serial *scb, const char *name)
{
  scb->fd = gdb_open_cloexec (name, O_RDWR, 0);
  if (scb->fd < 0)
    return -1;

  return 0;
}

static int
get_tty_state (struct serial *scb, struct hardwire_ttystate *state)
{
#ifdef HAVE_TERMIOS
  if (tcgetattr (scb->fd, &state->termios) < 0)
    return -1;

  return 0;
#endif

#ifdef HAVE_TERMIO
  if (ioctl (scb->fd, TCGETA, &state->termio) < 0)
    return -1;
  return 0;
#endif

#ifdef HAVE_SGTTY
  if (ioctl (scb->fd, TIOCGETP, &state->sgttyb) < 0)
    return -1;
  if (ioctl (scb->fd, TIOCGETC, &state->tc) < 0)
    return -1;
  if (ioctl (scb->fd, TIOCGLTC, &state->ltc) < 0)
    return -1;
  if (ioctl (scb->fd, TIOCLGET, &state->lmode) < 0)
    return -1;

  return 0;
#endif
}

static int
set_tty_state (struct serial *scb, struct hardwire_ttystate *state)
{
#ifdef HAVE_TERMIOS
  if (tcsetattr (scb->fd, TCSANOW, &state->termios) < 0)
    return -1;

  return 0;
#endif

#ifdef HAVE_TERMIO
  if (ioctl (scb->fd, TCSETA, &state->termio) < 0)
    return -1;
  return 0;
#endif

#ifdef HAVE_SGTTY
  if (ioctl (scb->fd, TIOCSETN, &state->sgttyb) < 0)
    return -1;
  if (ioctl (scb->fd, TIOCSETC, &state->tc) < 0)
    return -1;
  if (ioctl (scb->fd, TIOCSLTC, &state->ltc) < 0)
    return -1;
  if (ioctl (scb->fd, TIOCLSET, &state->lmode) < 0)
    return -1;

  return 0;
#endif
}

static serial_ttystate
hardwire_get_tty_state (struct serial *scb)
{
  struct hardwire_ttystate *state;

  state = (struct hardwire_ttystate *) xmalloc (sizeof *state);

  if (get_tty_state (scb, state))
    {
      xfree (state);
      return NULL;
    }

  return (serial_ttystate) state;
}

static serial_ttystate
hardwire_copy_tty_state (struct serial *scb, serial_ttystate ttystate)
{
  struct hardwire_ttystate *state;

  state = (struct hardwire_ttystate *) xmalloc (sizeof *state);
  *state = *(struct hardwire_ttystate *) ttystate;

  return (serial_ttystate) state;
}

static int
hardwire_set_tty_state (struct serial *scb, serial_ttystate ttystate)
{
  struct hardwire_ttystate *state;

  state = (struct hardwire_ttystate *) ttystate;

  return set_tty_state (scb, state);
}

static int
hardwire_noflush_set_tty_state (struct serial *scb,
				serial_ttystate new_ttystate,
				serial_ttystate old_ttystate)
{
  struct hardwire_ttystate new_state;
#ifdef HAVE_SGTTY
  struct hardwire_ttystate *state = (struct hardwire_ttystate *) old_ttystate;
#endif

  new_state = *(struct hardwire_ttystate *) new_ttystate;

  /* Don't change in or out of raw mode; we don't want to flush input.
     termio and termios have no such restriction; for them flushing input
     is separate from setting the attributes.  */

#ifdef HAVE_SGTTY
  if (state->sgttyb.sg_flags & RAW)
    new_state.sgttyb.sg_flags |= RAW;
  else
    new_state.sgttyb.sg_flags &= ~RAW;

  /* I'm not sure whether this is necessary; the manpage just mentions
     RAW not CBREAK.  */
  if (state->sgttyb.sg_flags & CBREAK)
    new_state.sgttyb.sg_flags |= CBREAK;
  else
    new_state.sgttyb.sg_flags &= ~CBREAK;
#endif

  return set_tty_state (scb, &new_state);
}

static void
hardwire_print_tty_state (struct serial *scb,
			  serial_ttystate ttystate,
			  struct ui_file *stream)
{
  struct hardwire_ttystate *state = (struct hardwire_ttystate *) ttystate;
  int i;

#ifdef HAVE_TERMIOS
  fprintf_filtered (stream, "c_iflag = 0x%x, c_oflag = 0x%x,\n",
		    (int) state->termios.c_iflag,
		    (int) state->termios.c_oflag);
  fprintf_filtered (stream, "c_cflag = 0x%x, c_lflag = 0x%x\n",
		    (int) state->termios.c_cflag,
		    (int) state->termios.c_lflag);
#if 0
  /* This not in POSIX, and is not really documented by those systems
     which have it (at least not Sun).  */
  fprintf_filtered (stream, "c_line = 0x%x.\n", state->termios.c_line);
#endif
  fprintf_filtered (stream, "c_cc: ");
  for (i = 0; i < NCCS; i += 1)
    fprintf_filtered (stream, "0x%x ", state->termios.c_cc[i]);
  fprintf_filtered (stream, "\n");
#endif

#ifdef HAVE_TERMIO
  fprintf_filtered (stream, "c_iflag = 0x%x, c_oflag = 0x%x,\n",
		    state->termio.c_iflag, state->termio.c_oflag);
  fprintf_filtered (stream, "c_cflag = 0x%x, c_lflag = 0x%x, c_line = 0x%x.\n",
		    state->termio.c_cflag, state->termio.c_lflag,
		    state->termio.c_line);
  fprintf_filtered (stream, "c_cc: ");
  for (i = 0; i < NCC; i += 1)
    fprintf_filtered (stream, "0x%x ", state->termio.c_cc[i]);
  fprintf_filtered (stream, "\n");
#endif

#ifdef HAVE_SGTTY
  fprintf_filtered (stream, "sgttyb.sg_flags = 0x%x.\n",
		    state->sgttyb.sg_flags);

  fprintf_filtered (stream, "tchars: ");
  for (i = 0; i < (int) sizeof (struct tchars); i++)
    fprintf_filtered (stream, "0x%x ", ((unsigned char *) &state->tc)[i]);
  fprintf_filtered (stream, "\n");

  fprintf_filtered (stream, "ltchars: ");
  for (i = 0; i < (int) sizeof (struct ltchars); i++)
    fprintf_filtered (stream, "0x%x ", ((unsigned char *) &state->ltc)[i]);
  fprintf_filtered (stream, "\n");

  fprintf_filtered (stream, "lmode:  0x%x\n", state->lmode);
#endif
}

/* Wait for the output to drain away, as opposed to flushing
   (discarding) it.  */

static int
hardwire_drain_output (struct serial *scb)
{
#ifdef HAVE_TERMIOS
  return tcdrain (scb->fd);
#endif

#ifdef HAVE_TERMIO
  return ioctl (scb->fd, TCSBRK, 1);
#endif

#ifdef HAVE_SGTTY
  /* Get the current state and then restore it using TIOCSETP,
     which should cause the output to drain and pending input
     to be discarded.  */
  {
    struct hardwire_ttystate state;

    if (get_tty_state (scb, &state))
      {
	return (-1);
      }
    else
      {
	return (ioctl (scb->fd, TIOCSETP, &state.sgttyb));
      }
  }
#endif
}

static int
hardwire_flush_output (struct serial *scb)
{
#ifdef HAVE_TERMIOS
  return tcflush (scb->fd, TCOFLUSH);
#endif

#ifdef HAVE_TERMIO
  return ioctl (scb->fd, TCFLSH, 1);
#endif

#ifdef HAVE_SGTTY
  /* This flushes both input and output, but we can't do better.  */
  return ioctl (scb->fd, TIOCFLUSH, 0);
#endif
}

static int
hardwire_flush_input (struct serial *scb)
{
  ser_base_flush_input (scb);

#ifdef HAVE_TERMIOS
  return tcflush (scb->fd, TCIFLUSH);
#endif

#ifdef HAVE_TERMIO
  return ioctl (scb->fd, TCFLSH, 0);
#endif

#ifdef HAVE_SGTTY
  /* This flushes both input and output, but we can't do better.  */
  return ioctl (scb->fd, TIOCFLUSH, 0);
#endif
}

static int
hardwire_send_break (struct serial *scb)
{
#ifdef HAVE_TERMIOS
  return tcsendbreak (scb->fd, 0);
#endif

#ifdef HAVE_TERMIO
  return ioctl (scb->fd, TCSBRK, 0);
#endif

#ifdef HAVE_SGTTY
  {
    int status;

    status = ioctl (scb->fd, TIOCSBRK, 0);

    /* Can't use usleep; it doesn't exist in BSD 4.2.  */
    /* Note that if this gdb_select() is interrupted by a signal it will not
       wait the full length of time.  I think that is OK.  */
    gdb_usleep (250000);
    status = ioctl (scb->fd, TIOCCBRK, 0);
    return status;
  }
#endif
}

static void
hardwire_raw (struct serial *scb)
{
  struct hardwire_ttystate state;

  if (get_tty_state (scb, &state))
    fprintf_unfiltered (gdb_stderr, "get_tty_state failed: %s\n",
			safe_strerror (errno));

#ifdef HAVE_TERMIOS
  state.termios.c_iflag = 0;
  state.termios.c_oflag = 0;
  state.termios.c_lflag = 0;
  state.termios.c_cflag &= ~(CSIZE | PARENB);
  state.termios.c_cflag |= CLOCAL | CS8;
#ifdef CRTSCTS
  /* h/w flow control.  */
  if (serial_hwflow)
    state.termios.c_cflag |= CRTSCTS;
  else
    state.termios.c_cflag &= ~CRTSCTS;
#ifdef CRTS_IFLOW
  if (serial_hwflow)
    state.termios.c_cflag |= CRTS_IFLOW;
  else
    state.termios.c_cflag &= ~CRTS_IFLOW;
#endif
#endif
  state.termios.c_cc[VMIN] = 0;
  state.termios.c_cc[VTIME] = 0;
#endif

#ifdef HAVE_TERMIO
  state.termio.c_iflag = 0;
  state.termio.c_oflag = 0;
  state.termio.c_lflag = 0;
  state.termio.c_cflag &= ~(CSIZE | PARENB);
  state.termio.c_cflag |= CLOCAL | CS8;
  state.termio.c_cc[VMIN] = 0;
  state.termio.c_cc[VTIME] = 0;
#endif

#ifdef HAVE_SGTTY
  state.sgttyb.sg_flags |= RAW | ANYP;
  state.sgttyb.sg_flags &= ~(CBREAK | ECHO);
#endif

  scb->current_timeout = 0;

  if (set_tty_state (scb, &state))
    fprintf_unfiltered (gdb_stderr, "set_tty_state failed: %s\n",
			safe_strerror (errno));
}

/* Wait for input on scb, with timeout seconds.  Returns 0 on success,
   otherwise SERIAL_TIMEOUT or SERIAL_ERROR.

   For termio{s}, we actually just setup VTIME if necessary, and let the
   timeout occur in the read() in hardwire_read().  */

/* FIXME: cagney/1999-09-16: Don't replace this with the equivalent
   ser_base*() until the old TERMIOS/SGTTY/... timer code has been
   flushed. .  */

/* NOTE: cagney/1999-09-30: Much of the code below is dead.  The only
   possible values of the TIMEOUT parameter are ONE and ZERO.
   Consequently all the code that tries to handle the possability of
   an overflowed timer is unnecessary.  */

static int
wait_for (struct serial *scb, int timeout)
{
#ifdef HAVE_SGTTY
  while (1)
    {
      struct timeval tv;
      fd_set readfds;
      int numfds;

      /* NOTE: Some OS's can scramble the READFDS when the select()
         call fails (ex the kernel with Red Hat 5.2).  Initialize all
         arguments before each call.  */

      tv.tv_sec = timeout;
      tv.tv_usec = 0;

      FD_ZERO (&readfds);
      FD_SET (scb->fd, &readfds);

      if (timeout >= 0)
	numfds = gdb_select (scb->fd + 1, &readfds, 0, 0, &tv);
      else
	numfds = gdb_select (scb->fd + 1, &readfds, 0, 0, 0);

      if (numfds <= 0)
	if (numfds == 0)
	  return SERIAL_TIMEOUT;
	else if (errno == EINTR)
	  continue;
	else
	  return SERIAL_ERROR;	/* Got an error from select or poll.  */

      return 0;
    }
#endif /* HAVE_SGTTY */

#if defined HAVE_TERMIO || defined HAVE_TERMIOS
  if (timeout == scb->current_timeout)
    return 0;

  scb->current_timeout = timeout;

  {
    struct hardwire_ttystate state;

    if (get_tty_state (scb, &state))
      fprintf_unfiltered (gdb_stderr, "get_tty_state failed: %s\n",
			  safe_strerror (errno));

#ifdef HAVE_TERMIOS
    if (timeout < 0)
      {
	/* No timeout.  */
	state.termios.c_cc[VTIME] = 0;
	state.termios.c_cc[VMIN] = 1;
      }
    else
      {
	state.termios.c_cc[VMIN] = 0;
	state.termios.c_cc[VTIME] = timeout * 10;
	if (state.termios.c_cc[VTIME] != timeout * 10)
	  {

	    /* If c_cc is an 8-bit signed character, we can't go 
	       bigger than this.  If it is always unsigned, we could use
	       25.  */

	    scb->current_timeout = 12;
	    state.termios.c_cc[VTIME] = scb->current_timeout * 10;
	    scb->timeout_remaining = timeout - scb->current_timeout;
	  }
      }
#endif

#ifdef HAVE_TERMIO
    if (timeout < 0)
      {
	/* No timeout.  */
	state.termio.c_cc[VTIME] = 0;
	state.termio.c_cc[VMIN] = 1;
      }
    else
      {
	state.termio.c_cc[VMIN] = 0;
	state.termio.c_cc[VTIME] = timeout * 10;
	if (state.termio.c_cc[VTIME] != timeout * 10)
	  {
	    /* If c_cc is an 8-bit signed character, we can't go 
	       bigger than this.  If it is always unsigned, we could use
	       25.  */

	    scb->current_timeout = 12;
	    state.termio.c_cc[VTIME] = scb->current_timeout * 10;
	    scb->timeout_remaining = timeout - scb->current_timeout;
	  }
      }
#endif

    if (set_tty_state (scb, &state))
      fprintf_unfiltered (gdb_stderr, "set_tty_state failed: %s\n",
			  safe_strerror (errno));

    return 0;
  }
#endif /* HAVE_TERMIO || HAVE_TERMIOS */
}

/* Read a character with user-specified timeout.  TIMEOUT is number of
   seconds to wait, or -1 to wait forever.  Use timeout of 0 to effect
   a poll.  Returns char if successful.  Returns SERIAL_TIMEOUT if
   timeout expired, EOF if line dropped dead, or SERIAL_ERROR for any
   other error (see errno in that case).  */

/* FIXME: cagney/1999-09-16: Don't replace this with the equivalent
   ser_base*() until the old TERMIOS/SGTTY/... timer code has been
   flushed.  */

/* NOTE: cagney/1999-09-16: This function is not identical to
   ser_base_readchar() as part of replacing it with ser_base*()
   merging will be required - this code handles the case where read()
   times out due to no data while ser_base_readchar() doesn't expect
   that.  */

static int
do_hardwire_readchar (struct serial *scb, int timeout)
{
  int status, delta;
  int detach = 0;

  if (timeout > 0)
    timeout++;

  /* We have to be able to keep the GUI alive here, so we break the
     original timeout into steps of 1 second, running the "keep the
     GUI alive" hook each time through the loop.

     Also, timeout = 0 means to poll, so we just set the delta to 0,
     so we will only go through the loop once.  */

  delta = (timeout == 0 ? 0 : 1);
  while (1)
    {

      /* N.B. The UI may destroy our world (for instance by calling
         remote_stop,) in which case we want to get out of here as
         quickly as possible.  It is not safe to touch scb, since
         someone else might have freed it.  The
         deprecated_ui_loop_hook signals that we should exit by
         returning 1.  */

      if (deprecated_ui_loop_hook)
	detach = deprecated_ui_loop_hook (0);

      if (detach)
	return SERIAL_TIMEOUT;

      scb->timeout_remaining = (timeout < 0 ? timeout : timeout - delta);
      status = wait_for (scb, delta);

      if (status < 0)
	return status;

      status = read (scb->fd, scb->buf, BUFSIZ);

      if (status <= 0)
	{
	  if (status == 0)
	    {
	      /* Zero characters means timeout (it could also be EOF, but
	         we don't (yet at least) distinguish).  */
	      if (scb->timeout_remaining > 0)
		{
		  timeout = scb->timeout_remaining;
		  continue;
		}
	      else if (scb->timeout_remaining < 0)
		continue;
	      else
		return SERIAL_TIMEOUT;
	    }
	  else if (errno == EINTR)
	    continue;
	  else
	    return SERIAL_ERROR;	/* Got an error from read.  */
	}

      scb->bufcnt = status;
      scb->bufcnt--;
      scb->bufp = scb->buf;
      return *scb->bufp++;
    }
}

static int
hardwire_readchar (struct serial *scb, int timeout)
{
  return generic_readchar (scb, timeout, do_hardwire_readchar);
}


#ifndef B19200
#define B19200 EXTA
#endif

#ifndef B38400
#define B38400 EXTB
#endif

/* Translate baud rates from integers to damn B_codes.  Unix should
   have outgrown this crap years ago, but even POSIX wouldn't buck it.  */

static struct
{
  int rate;
  int code;
}
baudtab[] =
{
  {
    50, B50
  }
  ,
  {
    75, B75
  }
  ,
  {
    110, B110
  }
  ,
  {
    134, B134
  }
  ,
  {
    150, B150
  }
  ,
  {
    200, B200
  }
  ,
  {
    300, B300
  }
  ,
  {
    600, B600
  }
  ,
  {
    1200, B1200
  }
  ,
  {
    1800, B1800
  }
  ,
  {
    2400, B2400
  }
  ,
  {
    4800, B4800
  }
  ,
  {
    9600, B9600
  }
  ,
  {
    19200, B19200
  }
  ,
  {
    38400, B38400
  }
  ,
#ifdef B57600
  {
    57600, B57600
  }
  ,
#endif
#ifdef B115200
  {
    115200, B115200
  }
  ,
#endif
#ifdef B230400
  {
    230400, B230400
  }
  ,
#endif
#ifdef B460800
  {
    460800, B460800
  }
  ,
#endif
  {
    -1, -1
  }
  ,
};

static int
rate_to_code (int rate)
{
  int i;

  for (i = 0; baudtab[i].rate != -1; i++)
    {
      /* test for perfect macth.  */
      if (rate == baudtab[i].rate)
        return baudtab[i].code;
      else
        {
	  /* check if it is in between valid values.  */
          if (rate < baudtab[i].rate)
	    {
	      if (i)
	        {
	          warning (_("Invalid baud rate %d.  "
			     "Closest values are %d and %d."),
			   rate, baudtab[i - 1].rate, baudtab[i].rate);
		}
	      else
	        {
	          warning (_("Invalid baud rate %d.  Minimum value is %d."),
			   rate, baudtab[0].rate);
		}
	      return -1;
	    }
        }
    }
 
  /* The requested speed was too large.  */
  warning (_("Invalid baud rate %d.  Maximum value is %d."),
            rate, baudtab[i - 1].rate);
  return -1;
}

static int
hardwire_setbaudrate (struct serial *scb, int rate)
{
  struct hardwire_ttystate state;
  int baud_code = rate_to_code (rate);
  
  if (baud_code < 0)
    {
      /* The baud rate was not valid.
         A warning has already been issued.  */
      errno = EINVAL;
      return -1;
    }

  if (get_tty_state (scb, &state))
    return -1;

#ifdef HAVE_TERMIOS
  cfsetospeed (&state.termios, baud_code);
  cfsetispeed (&state.termios, baud_code);
#endif

#ifdef HAVE_TERMIO
#ifndef CIBAUD
#define CIBAUD CBAUD
#endif

  state.termio.c_cflag &= ~(CBAUD | CIBAUD);
  state.termio.c_cflag |= baud_code;
#endif

#ifdef HAVE_SGTTY
  state.sgttyb.sg_ispeed = baud_code;
  state.sgttyb.sg_ospeed = baud_code;
#endif

  return set_tty_state (scb, &state);
}

static int
hardwire_setstopbits (struct serial *scb, int num)
{
  struct hardwire_ttystate state;
  int newbit;

  if (get_tty_state (scb, &state))
    return -1;

  switch (num)
    {
    case SERIAL_1_STOPBITS:
      newbit = 0;
      break;
    case SERIAL_1_AND_A_HALF_STOPBITS:
    case SERIAL_2_STOPBITS:
      newbit = 1;
      break;
    default:
      return 1;
    }

#ifdef HAVE_TERMIOS
  if (!newbit)
    state.termios.c_cflag &= ~CSTOPB;
  else
    state.termios.c_cflag |= CSTOPB;	/* two bits */
#endif

#ifdef HAVE_TERMIO
  if (!newbit)
    state.termio.c_cflag &= ~CSTOPB;
  else
    state.termio.c_cflag |= CSTOPB;	/* two bits */
#endif

#ifdef HAVE_SGTTY
  return 0;			/* sgtty doesn't support this */
#endif

  return set_tty_state (scb, &state);
}

static void
hardwire_close (struct serial *scb)
{
  if (scb->fd < 0)
    return;

  close (scb->fd);
  scb->fd = -1;
}


void
_initialize_ser_hardwire (void)
{
  struct serial_ops *ops = XMALLOC (struct serial_ops);

  memset (ops, 0, sizeof (struct serial_ops));
  ops->name = "hardwire";
  ops->next = 0;
  ops->open = hardwire_open;
  ops->close = hardwire_close;
  /* FIXME: Don't replace this with the equivalent ser_base*() until
     the old TERMIOS/SGTTY/... timer code has been flushed.  cagney
     1999-09-16.  */
  ops->readchar = hardwire_readchar;
  ops->write = ser_base_write;
  ops->flush_output = hardwire_flush_output;
  ops->flush_input = hardwire_flush_input;
  ops->send_break = hardwire_send_break;
  ops->go_raw = hardwire_raw;
  ops->get_tty_state = hardwire_get_tty_state;
  ops->copy_tty_state = hardwire_copy_tty_state;
  ops->set_tty_state = hardwire_set_tty_state;
  ops->print_tty_state = hardwire_print_tty_state;
  ops->noflush_set_tty_state = hardwire_noflush_set_tty_state;
  ops->setbaudrate = hardwire_setbaudrate;
  ops->setstopbits = hardwire_setstopbits;
  ops->drain_output = hardwire_drain_output;
  ops->async = ser_base_async;
  ops->read_prim = ser_unix_read_prim;
  ops->write_prim = ser_unix_write_prim;
  serial_add_interface (ops);

#ifdef HAVE_TERMIOS
#ifdef CRTSCTS
  add_setshow_boolean_cmd ("remoteflow", no_class,
			   &serial_hwflow, _("\
Set use of hardware flow control for remote serial I/O."), _("\
Show use of hardware flow control for remote serial I/O."), _("\
Enable or disable hardware flow control (RTS/CTS) on the serial port\n\
when debugging using remote targets."),
			   NULL,
			   show_serial_hwflow,
			   &setlist, &showlist);
#endif
#endif
}

int
ser_unix_read_prim (struct serial *scb, size_t count)
{
  int status;

  while (1)
    {
      status = read (scb->fd, scb->buf, count);
      if (status != -1 || errno != EINTR)
	break;
    }
  return status;
}

int
ser_unix_write_prim (struct serial *scb, const void *buf, size_t len)
{
  /* ??? Historically, GDB has not retried calls to "write" that
     result in EINTR.  */
  return write (scb->fd, buf, len);
}
@


1.42
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d34 1
d111 1
a111 1
  scb->fd = open (name, O_RDWR);
@


1.41
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 2
   Copyright (C) 1992-1996, 1998-2001, 2003-2005, 2007-2012 Free
   Software Foundation, Inc.
@


1.40
log
@2011-03-05  Michael Snyder  <msnyder@@vmware.com>

	* ser-unix.c (hardwire_get_tty_state): Stop memory leak.
@
text
@d3 2
a4 2
   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2003,
   2004, 2005, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.40.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 2
   Copyright (C) 1992-1996, 1998-2001, 2003-2005, 2007-2012 Free
   Software Foundation, Inc.
@


1.39
log
@	* inflow.c (terminal_init_inferior_with_pgrp): Copy ttystate.
	(terminal_save_ours): Remove misleading comment.
	(inflow_inferior_data_cleanup): Free ttystate.
	(inflow_inferior_exit): Likewise.
	(copy_terminal_info): Copy ttystate.

	* serial.c (serial_copy_tty_state): New function.
	* serial.h (serial_copy_tty_state): Add prototype.
	(struct serial_ops): Add copy_tty_state callback.
	* ser-base.c (ser_base_copy_tty_state): New function.
	* ser-base.h (ser_base_copy_tty_state): Add prototype.
	* ser-go32.c (dos_copy_tty_state): New function.
	(dos_ops): Install copy_tty_state callback.
	* ser-mingw.c (_initialize_ser_windows): Likewise.
	* ser-pipe.c (_initialize_ser_pipe): Likewise.
	* ser-unix.c (hardwire_copy_tty_state): New function.
	(_initialize_ser_hardwire): Install it.
@
text
@d186 4
a189 1
    return NULL;
@


1.38
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d191 11
d925 1
@


1.37
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d106 1
a106 1
/* Open up a real live device for serial I/O */
d290 2
a291 1
/* Wait for the output to drain away, as opposed to flushing (discarding) it */
d307 1
a307 1
     to be discarded. */
d444 1
a444 2
   timeout occur in the read() in hardwire_read().
 */
d448 1
a448 1
   flushed. . */
d453 1
a453 1
   an overflowed timer is unnecessary. */
d467 1
a467 1
         arguments before each call. */
d486 1
a486 1
	  return SERIAL_ERROR;	/* Got an error from select or poll */
d571 1
a571 1
   flushed. */
d577 1
a577 1
   that. */
d771 1
a771 1
      /* test for perfect macth. */
d776 1
a776 1
	  /* check if it is in between valid values. */
d795 1
a795 1
  /* The requested speed was too large. */
d810 1
a810 1
         A warning has already been issued. */
d905 2
a906 2
     the old TERMIOS/SGTTY/... timer code has been flushed. cagney
     1999-09-16. */
@


1.36
log
@run copyright.sh for 2011.
@
text
@d391 2
a392 1
    fprintf_unfiltered (gdb_stderr, "get_tty_state failed: %s\n", safe_strerror (errno));
d435 2
a436 1
    fprintf_unfiltered (gdb_stderr, "set_tty_state failed: %s\n", safe_strerror (errno));
d502 2
a503 1
      fprintf_unfiltered (gdb_stderr, "get_tty_state failed: %s\n", safe_strerror (errno));
d555 2
a556 1
      fprintf_unfiltered (gdb_stderr, "set_tty_state failed: %s\n", safe_strerror (errno));
d563 5
a567 4
/* Read a character with user-specified timeout.  TIMEOUT is number of seconds
   to wait, or -1 to wait forever.  Use timeout of 0 to effect a poll.  Returns
   char if successful.  Returns SERIAL_TIMEOUT if timeout expired, EOF if line
   dropped dead, or SERIAL_ERROR for any other error (see errno in that case).  */
d639 1
a639 1
	    return SERIAL_ERROR;	/* Got an error from read */
d781 3
a783 2
	          warning (_("Invalid baud rate %d.  Closest values are %d and %d."),
	                    rate, baudtab[i - 1].rate, baudtab[i].rate);
d788 1
a788 1
	                    rate, baudtab[0].rate);
@


1.35
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* scm-exp.c: White space.
	* scm-lang.c: White space.
	* scm-valprint.c: White space.
	* sentinel-frame.c: White space.
	* ser-base.c: White space.
	* ser-go32.c: White space.
	* serial.c: White space.
	* ser-mingw.c: White space.
	* ser-pipe.c: White space.
	* ser-tcp.c: White space.
	* ser-unix.c: White space.
	* solib.c: White space.
	* solib-darwin.c: White space.
	* solib-frv.c: White space.
	* solib-irix.c: White space.
	* solib-osf.c: White space.
	* solib-pa64.c: White space.
	* solib-som.c: White space.
	* solib-spu.c: White space.
	* solib-svr4.c: White space.
	* solib-target.c: White space.
	* source.c: White space.
	* stabsread.c: White space.
	* stack.c: White space.
	* std-regs.c: White space.
	* symfile.c: White space.
	* symmisc.c: White space.
	* symtab.c: White space.
@
text
@d4 1
a4 1
   2004, 2005, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.34
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d309 1
d892 1
@


1.33
log
@            * gdb_usleep.h, gdb_usleep.c: New files.
            * Makefile.in (SFILES): Add gdb_usleep.c.
            (HFILES_NO_SRCDIR): Add gdb_usleep.h.
            (COMMON_OBS): Add gdb_usleep.o.
            * ser-unix.c (hardwire_send_break): Replace call to gdb_select
            by call to gdb_usleep.
@
text
@d4 1
a4 1
   2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.32
log
@        Updated copyright notices for most files.
@
text
@a370 1
    struct timeval timeout;
d375 3
a377 5
    /* Note that if this select() is interrupted by a signal it will not wait
       the full length of time.  I think that is OK.  */
    timeout.tv_sec = 0;
    timeout.tv_usec = 250000;
    gdb_select (0, 0, 0, 0, &timeout);
@


1.31
log
@	Updated copyright notices for most files.
@
text
@d4 1
a4 1
   2004, 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.30
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d4 1
a4 1
   2004, 2005, 2007 Free Software Foundation, Inc.
@


1.29
log
@gdb/:
* ser-unix.c (show_serial_hwflow): New function.
(hardwire_raw): Add hardware flow control support.
(_initialize_ser_hardwire): Add "set/show remoteflow".
* Makefile.in (ser-unix.o): Depend on $(gdbcmd_h).
* NEWS: Document the new command.

gdb/doc/:
* gdb.texinfo (Remote Configuration): Document "set/show
remoteflow".
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.28
log
@Copyright updates for 2007.
@
text
@d36 1
d44 12
d403 13
d921 14
@


1.27
log
@	* NEWS: Mention native Windows support.
	* Makefile.in (gdb_select_h, ser_tcp_h): New.
	(ALLDEPFILES): Add ser-mingw.c.
	(event-loop.o, inflow.o, mingw-hdep.o, posix-hdep.o, ser-base.o)
	(ser-tcp.o, ser-unix.o): Update.
	(ser-mingw.o): New rule.
	* configure: Regenerated.
	* configure.ac: Add ser-mingw.o for mingw32.
	* ser-mingw.c: New file.
	* event-loop.c: Include "gdb_select.h".
	(gdb_select): Remove, moved to mingw-hdep.c and posix-hdep.c.
	* ser-base.c: Include "gdb_select.h".
	(ser_base_wait_for): Use gdb_select.
	* serial.c (serial_for_fd): New function.
	(serial_fdopen): Try "terminal" before "hardwire".  Initialize
	the allocated struct serial.
	(serial_wait_handle): New function.
	* serial.h (serial_for_fd, serial_wait_handle): New prototypes.
	(struct serial_ops) [USE_WIN32API]: Add wait_handle.
	* gdb_select.h: New file.
	* ser-tcp.c: Include "ser-tcp.h".  Remove unused "ser-unix.h" include.
	(net_close, net_read_prim, net_write_prim): Make global.
	(net_open): Likewise.  Pass an exception set to select.  Whitespace fix.
	Document why we can not use gdb_select.
	(_initialize_ser_tcp) [USE_WIN32API]: Do not register TCP support here.
	* ser-tcp.h: New file.
	* inflow.c (gdb_has_a_terminal): Don't initialize stdin_serial here.
	(handle_sigio): Use gdb_select.
	(initialize_stdin_serial): New function.
	* terminal.h (initialize_stdin_serial): New prototype.
	* top.c (gdb_init): Call initialize_stdin_serial.
	* mingw-hdep.c (gdb_select): New function, moved from gdb_select in
	event-loop.c.  Add exception condition support.  Use serial_for_fd
	and serial_wait_handle.  Fix timeout handling.
	* posix-hdep.c: Include "gdb_select.h".
	(gdb_select): New function.
	* remote-st.c (connect_command): Use gdb_select.
	* ser-unix.c: Include "gdb_select.h".
	(hardwire_send_break, wait_for): Use gdb_select.
@
text
@d3 2
a4 2
   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
   2003, 2004, 2005 Free Software Foundation, Inc.
@


1.26
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d34 1
d369 1
a369 1
    select (0, 0, 0, 0, &timeout);
d452 1
a452 1
	numfds = select (scb->fd + 1, &readfds, 0, 0, &tv);
d454 1
a454 1
	numfds = select (scb->fd + 1, &readfds, 0, 0, 0);
@


1.25
log
@	* configure.ac: On MinGW, define USE_WIN32API and link with
	-lws2_32.
	* ser-tcp.c (<winsock2.h>): Include, for Windows.
	(ETIMEDOUT): Define, for Windows.
	(ioctl): Likewise.
	(closesocket): Define, for POSIX.
	(net_open): Adjust for differences in socket functions between
	Windows and UNIX.
	(net_close): Likweise.
	(net_read_prim): New function.
	(net_write_prim): Likewise.
	(_initialize_ser_tcp): Initialize winsock.  Fill in read_prim and
	write_prim.
	* ser-unix.h (ser_unix_readcchar): Remove.
	(ser_unix_read_prim): Declare.
	(ser_unix_write_prim): Likewise.
	* ser-unix.c (generic_readchar): Move to ser-base.c.
	(ser_unix_wait_for): Likewise.
	(do_unix_readchar): Likewise.
	(ser_unix_readchar): Likewise.
	(_initialize_ser_hardwire): Initialize read_prim and write_prim.
	(ser_unix_read_prim): New function.
	(ser_unix_write_prim): Likewise.
	* ser-base.h (generic_readchar): Declare.
	(ser_base_readchar): Likewise.
	* ser-base.c (<winsock2.h>): Include, for windows.
	(fd_event): Use the read primitive specified by the serial
	interface.
	(ser_base_wait_for): Moved from ser-unix.c
	(do_ser_base_read_char): Likewise.
	(generic_readchar): Likewise.
	(ser_base_readchar): Likewise.
	(ser_base_write): Use the write primitive specified by the serial
	interface.
	* ser-pipe.c (_initialize_ser_pipe): Use ser_base_readchar, not
	ser_unix_readchar.  Initialize read_prim and write_prim.
	* serial.c (struct serial_ops): Add read_prim and write_prim.
	* configure: Regenerate.
@
text
@d3 1
a3 1
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.24
log
@	* ser-base.c (ser_unix_write): Rename to ...
	(ser_base_write): ... this.
	(ser_unix_nop_flush_output): Rename to ...
	(ser_base_flush_output): ... this.
	(ser_unix_flush_input): Rename to ...
	(ser_base_flush_input): ... this.
	(ser_unix_nop_send_break): Rename to ...
	(ser_base_send_break): ... this.
	(ser_unix_nop_drain_output): Rename to ...
	(ser_base_drain_output): ... this.
	(ser_unix_nop_raw): Rename to ...
	(ser_base_raw): ... this.
	(ser_unix_nop_get_tty_state): Rename to ...
	(ser_base_set_tty_state): ... this.
	(ser_unix_nop_noflush_set_tty_state): Rename to ...
	(ser_base_noflush_set_tty_state): ... this.
	(ser_unix_nop_print_tty_state): Rename to ...
	(ser_base_print_tty_state): ... this.
	(ser_unix_nop_setbaudrate): Rename to ...
	(ser_base_setbaudrate): ... this.
	(ser_unix_nop_setstopbits): Rename to ...
	(ser_base_setstopbits): ... this.
	(ser_unix_async): Rename to ...
	(ser_base_async): ... this.
	* ser-base.h (ser_unix_write): Rename to ...
	(ser_base_write): ... this.
	(ser_unix_nop_flush_output): Rename to ...
	(ser_base_flush_output): ... this.
	(ser_unix_flush_input): Rename to ...
	(ser_base_flush_input): ... this.
	(ser_unix_nop_send_break): Rename to ...
	(ser_base_send_break): ... this.
	(ser_unix_nop_drain_output): Rename to ...
	(ser_base_drain_output): ... this.
	(ser_unix_nop_raw): Rename to ...
	(ser_base_raw): ... this.
	(ser_unix_nop_get_tty_state): Rename to ...
	(ser_base_set_tty_state): ... this.
	(ser_unix_nop_noflush_set_tty_state): Rename to ...
	(ser_base_noflush_set_tty_state): ... this.
	(ser_unix_nop_print_tty_state): Rename to ...
	(ser_base_print_tty_state): ... this.
	(ser_unix_nop_setbaudrate): Rename to ...
	(ser_base_setbaudrate): ... this.
	(ser_unix_nop_setstopbits): Rename to ...
	(ser_base_setstopbits): ... this.
	(ser_unix_async): Rename to ...
	(ser_base_async): ... this.
	* ser-pipe.c (_initialize_ser_pipe): Update accordingly.
	* ser-tcp.c (_initialize_ser_tcp): Likewise.
	* ser-unix.c (hardwire_flush_input): Likewise.
	(_initializer_ser_hardwire): Likewise.
@
text
@a72 3
static int generic_readchar (struct serial *scb, int timeout,
			     int (*do_readchar) (struct serial *scb,
						 int timeout));
d422 1
a422 1
   ser_unix*() until the old TERMIOS/SGTTY/... timer code has been
d542 1
a542 1
   ser_unix*() until the old TERMIOS/SGTTY/... timer code has been
d546 1
a546 1
   ser_unix_readchar() as part of replacing it with ser_unix*()
d548 1
a548 1
   times out due to no data while ser_unix_readchar() doesn't expect
a862 1

a863 183
/* Wait for input on scb, with timeout seconds.  Returns 0 on success,
   otherwise SERIAL_TIMEOUT or SERIAL_ERROR. */

static int
ser_unix_wait_for (struct serial *scb, int timeout)
{
  while (1)
    {
      int numfds;
      struct timeval tv;
      fd_set readfds, exceptfds;

      /* NOTE: Some OS's can scramble the READFDS when the select()
         call fails (ex the kernel with Red Hat 5.2).  Initialize all
         arguments before each call. */

      tv.tv_sec = timeout;
      tv.tv_usec = 0;

      FD_ZERO (&readfds);
      FD_ZERO (&exceptfds);
      FD_SET (scb->fd, &readfds);
      FD_SET (scb->fd, &exceptfds);

      if (timeout >= 0)
	numfds = select (scb->fd + 1, &readfds, 0, &exceptfds, &tv);
      else
	numfds = select (scb->fd + 1, &readfds, 0, &exceptfds, 0);

      if (numfds <= 0)
	{
	  if (numfds == 0)
	    return SERIAL_TIMEOUT;
	  else if (errno == EINTR)
	    continue;
	  else
	    return SERIAL_ERROR;	/* Got an error from select or poll */
	}

      return 0;
    }
}

/* Read a character with user-specified timeout.  TIMEOUT is number of seconds
   to wait, or -1 to wait forever.  Use timeout of 0 to effect a poll.  Returns
   char if successful.  Returns -2 if timeout expired, EOF if line dropped
   dead, or -3 for any other error (see errno in that case). */

static int
do_unix_readchar (struct serial *scb, int timeout)
{
  int status;
  int delta;

  /* We have to be able to keep the GUI alive here, so we break the
     original timeout into steps of 1 second, running the "keep the
     GUI alive" hook each time through the loop.

     Also, timeout = 0 means to poll, so we just set the delta to 0,
     so we will only go through the loop once.  */

  delta = (timeout == 0 ? 0 : 1);
  while (1)
    {

      /* N.B. The UI may destroy our world (for instance by calling
         remote_stop,) in which case we want to get out of here as
         quickly as possible.  It is not safe to touch scb, since
         someone else might have freed it.  The
         deprecated_ui_loop_hook signals that we should exit by
         returning 1.  */

      if (deprecated_ui_loop_hook)
	{
	  if (deprecated_ui_loop_hook (0))
	    return SERIAL_TIMEOUT;
	}

      status = ser_unix_wait_for (scb, delta);
      if (timeout > 0)
        timeout -= delta;

      /* If we got a character or an error back from wait_for, then we can 
         break from the loop before the timeout is completed. */

      if (status != SERIAL_TIMEOUT)
	{
	  break;
	}

      /* If we have exhausted the original timeout, then generate
         a SERIAL_TIMEOUT, and pass it out of the loop. */

      else if (timeout == 0)
	{
	  status = SERIAL_TIMEOUT;
	  break;
	}
    }

  if (status < 0)
    return status;

  while (1)
    {
      status = read (scb->fd, scb->buf, BUFSIZ);
      if (status != -1 || errno != EINTR)
	break;
    }

  if (status <= 0)
    {
      if (status == 0)
	return SERIAL_TIMEOUT;	/* 0 chars means timeout [may need to
				   distinguish between EOF & timeouts
				   someday] */
      else
	return SERIAL_ERROR;	/* Got an error from read */
    }

  scb->bufcnt = status;
  scb->bufcnt--;
  scb->bufp = scb->buf;
  return *scb->bufp++;
}

/* Perform operations common to both old and new readchar. */

/* Return the next character from the input FIFO.  If the FIFO is
   empty, call the SERIAL specific routine to try and read in more
   characters.

   Initially data from the input FIFO is returned (fd_event()
   pre-reads the input into that FIFO.  Once that has been emptied,
   further data is obtained by polling the input FD using the device
   specific readchar() function.  Note: reschedule() is called after
   every read.  This is because there is no guarentee that the lower
   level fd_event() poll_event() code (which also calls reschedule())
   will be called. */

static int
generic_readchar (struct serial *scb, int timeout,
		  int (do_readchar) (struct serial *scb, int timeout))
{
  int ch;
  if (scb->bufcnt > 0)
    {
      ch = *scb->bufp;
      scb->bufcnt--;
      scb->bufp++;
    }
  else if (scb->bufcnt < 0)
    {
      /* Some errors/eof are are sticky. */
      ch = scb->bufcnt;
    }
  else
    {
      ch = do_readchar (scb, timeout);
      if (ch < 0)
	{
	  switch ((enum serial_rc) ch)
	    {
	    case SERIAL_EOF:
	    case SERIAL_ERROR:
	      /* Make the error/eof stick. */
	      scb->bufcnt = ch;
	      break;
	    case SERIAL_TIMEOUT:
	      scb->bufcnt = 0;
	      break;
	    }
	}
    }
  reschedule (scb);
  return ch;
}

int
ser_unix_readchar (struct serial *scb, int timeout)
{
  return generic_readchar (scb, timeout, do_unix_readchar);
}
d874 1
a874 1
  /* FIXME: Don't replace this with the equivalent ser_unix*() until
d891 2
d895 22
@


1.23
log
@	* Makefile.in (SFILES): Add ser-base.c.
	(ser_base_h): New variable.
	(ser-base.o): New target.
	(ser-pipe.o): Depend on $(ser_base_h).
	(ser-tcp.o): Likewise.
	(ser-unix.o): Likewise.  Do not depend on $(event_loop_h).
	* configure.ac (SER_HARDWIRE): Include ser-base.o where
	appropriate.
	* ser-base.c: New file.
	(push_event): Move from ser-unix.c.
	(fd_event): Likewise.
	(reschedule): Likewise.
	(ser_unix_write): Likewise.
	(ser_unix_nop_flush_output): Likewise.
	(ser_unix_flush_input): Likewise.
	(ser_unix_nop_send_break): Likewise.
	(ser_unix_nop_drain_output): Likewise.
	(ser_unix_nop_raw): Likewise.
	(ser_unix_nop_get_tty_state): Likewise.
	(ser_unix_nop_set_tty_state): Likewise.
	(ser_unix_nop_noflush_set_tty_state): Likewise.
	(ser_unix_nop_print_tty_state): Likewise.
	(ser_unix_nop_setbaudrate): Likewise.
	(ser_unix_nop_setstopbits): Likewise.
	(ser_unix_async): Likewise.
	* ser-base.h: New file.
	* ser-pipe.c (ser-base.h): Include it.
	* ser-tcp.c (ser-base.h): Likewise.
	* ser-unix.h (ser_unix_nop_flush_output): Remove.
	(ser_unix_flush_input): Likewise.
	(ser_unix_nop_send_break): Likewise.
	(ser_unix_nop_raw): Likewise.
	(ser_unix_nop_get_tty_state): Likewise.
	(ser_unix_nop_set_tty_state): Likewise.
	(ser_unix_nop_print_tty_state): Likewise.
	(ser_unix_nop_noflush_set_tty_state): Likewise.
	(ser_unix_nop_setbaudrate): Likewise.
	(ser_unix_nop_setstopbits): Likewise.
	(ser_unix_nop_drain_output): Likewise.
	(ser_unix_wait_for): Likewise.
	(ser_unix_write): Likewise.
	(ser_unix_async): Likewise.
	* ser-unix.c (event-loop.h): Do not include it.
	(push_event): Move to ser-base.c.
	(fd_event): Likewise.
	(reschedule): Likewise.
	(ser_unix_write): Likewise.
	(ser_unix_nop_flush_output): Likewise.
	(ser_unix_flush_input): Likewise.
	(ser_unix_nop_send_break): Likewise.
	(ser_unix_nop_drain_output): Likewise.
	(ser_unix_nop_raw): Likewise.
	(ser_unix_nop_get_tty_state): Likewise.
	(ser_unix_nop_set_tty_state): Likewise.
	(ser_unix_nop_noflush_set_tty_state): Likewise.
	(ser_unix_nop_print_tty_state): Likewise.
	(ser_unix_nop_setbaudrate): Likewise.
	(ser_unix_nop_setstopbits): Likewise.
	(ser_unix_async): Likewise.
	(ser_unix_wait_for): Make it static.
	* configure: Regenerated.
@
text
@d332 1
a332 1
  ser_unix_flush_input (scb);
d1065 1
a1065 1
  ops->write = ser_unix_write;
d1077 1
a1077 1
  ops->async = ser_unix_async;
@


1.22
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d4 1
a4 1
   2003, 2004 Free Software Foundation, Inc.
d25 1
a34 1
#include "event-loop.h"
a94 5
static int do_unix_readchar (struct serial *scb, int timeout);
static timer_handler_func push_event;
static handler_func fd_event;
static void reschedule (struct serial *scb);

a867 21
/* Generic operations used by all UNIX/FD based serial interfaces. */

serial_ttystate
ser_unix_nop_get_tty_state (struct serial *scb)
{
  /* allocate a dummy */
  return (serial_ttystate) XMALLOC (int);
}

int
ser_unix_nop_set_tty_state (struct serial *scb, serial_ttystate ttystate)
{
  return 0;
}

void
ser_unix_nop_raw (struct serial *scb)
{
  return;			/* Always in raw mode */
}

d871 1
a871 1
int
a1050 79

int
ser_unix_nop_noflush_set_tty_state (struct serial *scb,
				    serial_ttystate new_ttystate,
				    serial_ttystate old_ttystate)
{
  return 0;
}

void
ser_unix_nop_print_tty_state (struct serial *scb, 
			      serial_ttystate ttystate,
			      struct ui_file *stream)
{
  /* Nothing to print.  */
  return;
}

int
ser_unix_nop_setbaudrate (struct serial *scb, int rate)
{
  return 0;			/* Never fails! */
}

int
ser_unix_nop_setstopbits (struct serial *scb, int num)
{
  return 0;			/* Never fails! */
}

int
ser_unix_write (struct serial *scb, const char *str, int len)
{
  int cc;

  while (len > 0)
    {
      cc = write (scb->fd, str, len);

      if (cc < 0)
	return 1;
      len -= cc;
      str += cc;
    }
  return 0;
}

int
ser_unix_nop_flush_output (struct serial *scb)
{
  return 0;
}

int
ser_unix_flush_input (struct serial *scb)
{
  if (scb->bufcnt >= 0)
    {
      scb->bufcnt = 0;
      scb->bufp = scb->buf;
      return 0;
    }
  else
    return SERIAL_ERROR;
}

int
ser_unix_nop_send_break (struct serial *scb)
{
  return 0;
}

int
ser_unix_nop_drain_output (struct serial *scb)
{
  return 0;
}


a1051 181
/* Event handling for ASYNC serial code.

   At any time the SERIAL device either: has an empty FIFO and is
   waiting on a FD event; or has a non-empty FIFO/error condition and
   is constantly scheduling timer events.

   ASYNC only stops pestering its client when it is de-async'ed or it
   is told to go away. */

/* Value of scb->async_state: */
enum {
  /* >= 0 (TIMER_SCHEDULED) */
  /* The ID of the currently scheduled timer event. This state is
     rarely encountered.  Timer events are one-off so as soon as the
     event is delivered the state is shanged to NOTHING_SCHEDULED. */
  FD_SCHEDULED = -1,
  /* The fd_event() handler is scheduled.  It is called when ever the
     file descriptor becomes ready. */
  NOTHING_SCHEDULED = -2
  /* Either no task is scheduled (just going into ASYNC mode) or a
     timer event has just gone off and the current state has been
     forced into nothing scheduled. */
};

/* Identify and schedule the next ASYNC task based on scb->async_state
   and scb->buf* (the input FIFO).  A state machine is used to avoid
   the need to make redundant calls into the event-loop - the next
   scheduled task is only changed when needed. */

static void
reschedule (struct serial *scb)
{
  if (serial_is_async_p (scb))
    {
      int next_state;
      switch (scb->async_state)
	{
	case FD_SCHEDULED:
	  if (scb->bufcnt == 0)
	    next_state = FD_SCHEDULED;
	  else
	    {
	      delete_file_handler (scb->fd);
	      next_state = create_timer (0, push_event, scb);
	    }
	  break;
	case NOTHING_SCHEDULED:
	  if (scb->bufcnt == 0)
	    {
	      add_file_handler (scb->fd, fd_event, scb);
	      next_state = FD_SCHEDULED;
	    }
	  else
	    {
	      next_state = create_timer (0, push_event, scb);
	    }
	  break;
	default: /* TIMER SCHEDULED */
	  if (scb->bufcnt == 0)
	    {
	      delete_timer (scb->async_state);
	      add_file_handler (scb->fd, fd_event, scb);
	      next_state = FD_SCHEDULED;
	    }
	  else
	    next_state = scb->async_state;
	  break;
	}
      if (serial_debug_p (scb))
	{
	  switch (next_state)
	    {
	    case FD_SCHEDULED:
	      if (scb->async_state != FD_SCHEDULED)
		fprintf_unfiltered (gdb_stdlog, "[fd%d->fd-scheduled]\n",
				    scb->fd);
	      break;
	    default: /* TIMER SCHEDULED */
	      if (scb->async_state == FD_SCHEDULED)
		fprintf_unfiltered (gdb_stdlog, "[fd%d->timer-scheduled]\n",
				    scb->fd);
	      break;
	    }
	}
      scb->async_state = next_state;
    }
}

/* FD_EVENT: This is scheduled when the input FIFO is empty (and there
   is no pending error).  As soon as data arrives, it is read into the
   input FIFO and the client notified.  The client should then drain
   the FIFO using readchar().  If the FIFO isn't immediatly emptied,
   push_event() is used to nag the client until it is. */

static void
fd_event (int error, void *context)
{
  struct serial *scb = context;
  if (error != 0)
    {
      scb->bufcnt = SERIAL_ERROR;
    }
  else if (scb->bufcnt == 0)
    {
      /* Prime the input FIFO.  The readchar() function is used to
         pull characters out of the buffer.  See also
         generic_readchar(). */
      int nr;
      do
	{
	  nr = read (scb->fd, scb->buf, BUFSIZ);
	}
      while (nr == -1 && errno == EINTR);
      if (nr == 0)
	{
	  scb->bufcnt = SERIAL_EOF;
	}
      else if (nr > 0)
	{
	  scb->bufcnt = nr;
	  scb->bufp = scb->buf;
	}
      else
	{
	  scb->bufcnt = SERIAL_ERROR;
	}
    }
  scb->async_handler (scb, scb->async_context);
  reschedule (scb);
}

/* PUSH_EVENT: The input FIFO is non-empty (or there is a pending
   error).  Nag the client until all the data has been read.  In the
   case of errors, the client will need to close or de-async the
   device before naging stops. */

static void
push_event (void *context)
{
  struct serial *scb = context;
  scb->async_state = NOTHING_SCHEDULED; /* Timers are one-off */
  scb->async_handler (scb, scb->async_context);
  /* re-schedule */
  reschedule (scb);
}

/* Put the SERIAL device into/out-of ASYNC mode.  */

void
ser_unix_async (struct serial *scb,
		int async_p)
{
  if (async_p)
    {
      /* Force a re-schedule. */
      scb->async_state = NOTHING_SCHEDULED;
      if (serial_debug_p (scb))
	fprintf_unfiltered (gdb_stdlog, "[fd%d->asynchronous]\n",
			    scb->fd);
      reschedule (scb);
    }
  else
    {
      if (serial_debug_p (scb))
	fprintf_unfiltered (gdb_stdlog, "[fd%d->synchronous]\n",
			    scb->fd);
      /* De-schedule whatever tasks are currently scheduled. */
      switch (scb->async_state)
	{
	case FD_SCHEDULED:
	  delete_file_handler (scb->fd);
	  break;
	case NOTHING_SCHEDULED:
	  break;
	default: /* TIMER SCHEDULED */
	  delete_timer (scb->async_state);
	  break;
	}
    }
}

@


1.22.2.1
log
@	Backport from mainline.
	2005-03-22  Mark Mitchell  <mark@@codesourcery.com>
	* Makefile.in (SFILES): Add ser-base.c.
	(ser_base_h): New variable.
	(ser-base.o): New target.
	(ser-pipe.o): Depend on $(ser_base_h).
	(ser-tcp.o): Likewise.
	(ser-unix.o): Likewise.  Do not depend on $(event_loop_h).
	* configure.ac (SER_HARDWIRE): Include ser-base.o where
	appropriate.
	* ser-base.c: New file.
	(push_event): Move from ser-unix.c.
	(fd_event): Likewise.
	(reschedule): Likewise.
	(ser_unix_write): Likewise.
	(ser_unix_nop_flush_output): Likewise.
	(ser_unix_flush_input): Likewise.
	(ser_unix_nop_send_break): Likewise.
	(ser_unix_nop_drain_output): Likewise.
	(ser_unix_nop_raw): Likewise.
	(ser_unix_nop_get_tty_state): Likewise.
	(ser_unix_nop_set_tty_state): Likewise.
	(ser_unix_nop_noflush_set_tty_state): Likewise.
	(ser_unix_nop_print_tty_state): Likewise.
	(ser_unix_nop_setbaudrate): Likewise.
	(ser_unix_nop_setstopbits): Likewise.
	(ser_unix_async): Likewise.
	* ser-base.h: New file.
	* ser-pipe.c (ser-base.h): Include it.
	* ser-tcp.c (ser-base.h): Likewise.
	* ser-unix.h (ser_unix_nop_flush_output): Remove.
	(ser_unix_flush_input): Likewise.
	(ser_unix_nop_send_break): Likewise.
	(ser_unix_nop_raw): Likewise.
	(ser_unix_nop_get_tty_state): Likewise.
	(ser_unix_nop_set_tty_state): Likewise.
	(ser_unix_nop_print_tty_state): Likewise.
	(ser_unix_nop_noflush_set_tty_state): Likewise.
	(ser_unix_nop_setbaudrate): Likewise.
	(ser_unix_nop_setstopbits): Likewise.
	(ser_unix_nop_drain_output): Likewise.
	(ser_unix_wait_for): Likewise.
	(ser_unix_write): Likewise.
	(ser_unix_async): Likewise.
	* ser-unix.c (event-loop.h): Do not include it.
	(push_event): Move to ser-base.c.
	(fd_event): Likewise.
	(reschedule): Likewise.
	(ser_unix_write): Likewise.
	(ser_unix_nop_flush_output): Likewise.
	(ser_unix_flush_input): Likewise.
	(ser_unix_nop_send_break): Likewise.
	(ser_unix_nop_drain_output): Likewise.
	(ser_unix_nop_raw): Likewise.
	(ser_unix_nop_get_tty_state): Likewise.
	(ser_unix_nop_set_tty_state): Likewise.
	(ser_unix_nop_noflush_set_tty_state): Likewise.
	(ser_unix_nop_print_tty_state): Likewise.
	(ser_unix_nop_setbaudrate): Likewise.
	(ser_unix_nop_setstopbits): Likewise.
	(ser_unix_async): Likewise.
	(ser_unix_wait_for): Make it static.
@
text
@d4 1
a4 1
   2003, 2004, 2005 Free Software Foundation, Inc.
a24 1
#include "ser-base.h"
d34 1
d95 5
d873 21
d897 1
a897 1
static int
d1077 79
d1157 181
@


1.22.2.2
log
@	Backport from mainline:
        2005-03-25  Mark Mitchell  <mark@@codesourcery.com>
	* ser-base.c (ser_unix_write): Rename to ...
	(ser_base_write): ... this.
	(ser_unix_nop_flush_output): Rename to ...
	(ser_base_flush_output): ... this.
	(ser_unix_flush_input): Rename to ...
	(ser_base_flush_input): ... this.
	(ser_unix_nop_send_break): Rename to ...
	(ser_base_send_break): ... this.
	(ser_unix_nop_drain_output): Rename to ...
	(ser_base_drain_output): ... this.
	(ser_unix_nop_raw): Rename to ...
	(ser_base_raw): ... this.
	(ser_unix_nop_get_tty_state): Rename to ...
	(ser_base_set_tty_state): ... this.
	(ser_unix_nop_noflush_set_tty_state): Rename to ...
	(ser_base_noflush_set_tty_state): ... this.
	(ser_unix_nop_print_tty_state): Rename to ...
	(ser_base_print_tty_state): ... this.
	(ser_unix_nop_setbaudrate): Rename to ...
	(ser_base_setbaudrate): ... this.
	(ser_unix_nop_setstopbits): Rename to ...
	(ser_base_setstopbits): ... this.
	(ser_unix_async): Rename to ...
	(ser_base_async): ... this.
	* ser-base.h (ser_unix_write): Rename to ...
	(ser_base_write): ... this.
	(ser_unix_nop_flush_output): Rename to ...
	(ser_base_flush_output): ... this.
	(ser_unix_flush_input): Rename to ...
	(ser_base_flush_input): ... this.
	(ser_unix_nop_send_break): Rename to ...
	(ser_base_send_break): ... this.
	(ser_unix_nop_drain_output): Rename to ...
	(ser_base_drain_output): ... this.
	(ser_unix_nop_raw): Rename to ...
	(ser_base_raw): ... this.
	(ser_unix_nop_get_tty_state): Rename to ...
	(ser_base_set_tty_state): ... this.
	(ser_unix_nop_noflush_set_tty_state): Rename to ...
	(ser_base_noflush_set_tty_state): ... this.
	(ser_unix_nop_print_tty_state): Rename to ...
	(ser_base_print_tty_state): ... this.
	(ser_unix_nop_setbaudrate): Rename to ...
	(ser_base_setbaudrate): ... this.
	(ser_unix_nop_setstopbits): Rename to ...
	(ser_base_setstopbits): ... this.
	(ser_unix_async): Rename to ...
	(ser_base_async): ... this.
	* ser-pipe.c (_initialize_ser_pipe): Update accordingly.
	* ser-tcp.c (_initialize_ser_tcp): Likewise.
	* ser-unix.c (hardwire_flush_input): Likewise.
	(_initializer_ser_hardwire): Likewise.
@
text
@d332 1
a332 1
  ser_base_flush_input (scb);
d1065 1
a1065 1
  ops->write = ser_base_write;
d1077 1
a1077 1
  ops->async = ser_base_async;
@


1.22.2.3
log
@	* gdb/configure.ac: Link with -lws2_32 on mingw.
	* gdb/configure: Regenerated.
	* gdb/defs.h (WINAPI): Define, conditionally.
	* gdb/ser-base.c (winsock2.h): Include it.
	(fd_event): Use read_prim.
	(ser_base_wait_for): Moved here from ser-unix.c.
	(do_ser_base_readchar): Likewise.
	(generic_readchar): Likewise.
	(ser_base_readchar): Likewise.
	* gdb/ser-base.h (generic_readchar): Declare.
	(ser_base_readchar): Likewise.
	* gdb/ser-pipe.c (_initialize_ser_pipe): Adjust for name changes.
	* gdb/ser-tcp.c (winsock2.h): Include it.
	(ETIMEDOUT): Define on Windows.
	(closesocket): Define on UNIX.
	(ioctlsocket): Likewise.
	(net_open): Adjust for differences in socket functions between
	Windows and UNIX.
	(_initialize_ser_tcp): Adjust for name changes.
	(net_read_prim): New function.
	(net_write_prim): Likewise.
	* gdb/ser-unix.c (generic_readchar): Remove.
	(ser_unix_wait_for): Likewise.
	(do_unix_readchar): Likewise.
	(ser_unix_readchar): Likewise.
	(_initialize_ser_hardwire): Adjust for name changes.
	(ser_unix_read_prim): New function.
	(ser_unix_write_prim): New function.
	* gdb/ser-unix.h (ser_unix_readchar): Remove.
	(ser_unix_read_prim): Declare.
	(ser_unix_write_prim): Declare.
	* gdb/serial.h (struct serial_ops): Add read_prim and write_prim.
	* gdb/utils.c (winerror.h): Include it.
	(safe_strerror): Handle winsock errors.
@
text
@d73 3
d425 1
a425 1
   ser_base*() until the old TERMIOS/SGTTY/... timer code has been
d545 1
a545 1
   ser_base*() until the old TERMIOS/SGTTY/... timer code has been
d549 1
a549 1
   ser_base_readchar() as part of replacing it with ser_base*()
d551 1
a551 1
   times out due to no data while ser_base_readchar() doesn't expect
d866 1
d868 183
d1061 1
a1061 1
  /* FIXME: Don't replace this with the equivalent ser_base*() until
a1077 2
  ops->read_prim = ser_unix_read_prim;
  ops->write_prim = ser_unix_write_prim;
a1079 22

int
ser_unix_read_prim (struct serial *scb, size_t count)
{
  int status;

  while (1)
    {
      status = read (scb->fd, scb->buf, count);
      if (status != -1 || errno != EINTR)
	break;
    }
  return status;
}

int
ser_unix_write_prim (struct serial *scb, const void *buf, size_t len)
{
  /* ??? Historically, GDB has not retried calls to "write" that
     result in EINTR.  */
  return write (scb->fd, buf, len);
}
@


1.21
log
@2005-01-13  Michael Snyder  <msnyder@@redhat.com>

	* ser-tcp.c: Whitespace tweaks.
	* ser-unix.c: Whitespace tweaks.
	* serial.h: Whitespace tweaks.
@
text
@d761 1
a761 1
	          warning ("Invalid baud rate %d.  Closest values are %d and %d.",
d766 1
a766 1
	          warning ("Invalid baud rate %d.  Minimum value is %d.",
d775 1
a775 1
  warning ("Invalid baud rate %d.  Maximum value is %d.",
@


1.20
log
@2004-06-25  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (deprecated_ui_loop_hook): Deprecated.
	* wince.c (child_wait): Update.
	* win32-nat.c (child_wait): Update.
	* v850ice.c (v850ice_wait): Update.
	* top.c (deprecated_ui_loop_hook): Update.
	* serial.h: Update.
	* ser-unix.c (do_hardwire_readchar, do_hardwire_readchar)
	(do_unix_readchar): Update.
	* ser-tcp.c (net_open): Update.
	* remote-sim.c (gdb_os_poll_quit): Update.
	* rdi-share/ardi.c (angel_RDI_ExecuteOrStep): Update.
@
text
@d568 6
a573 5
  /* We have to be able to keep the GUI alive here, so we break the original
     timeout into steps of 1 second, running the "keep the GUI alive" hook 
     each time through the loop.
     Also, timeout = 0 means to poll, so we just set the delta to 0, so we
     will only go through the loop once. */
d948 3
a950 3
  /* We have to be able to keep the GUI alive here, so we break the original
     timeout into steps of 1 second, running the "keep the GUI alive" hook 
     each time through the loop.
d952 2
a953 2
     Also, timeout = 0 means to poll, so we just set the delta to 0, so we
     will only go through the loop once. */
@


1.19
log
@2004-06-24  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (post_add_symbol_hook, pre_add_symbol_hook)
	(ui_loop_hook, selected_frame_level_changed_hook): Declare.
	* wince.c (ui_loop_hook): Delete extern declaration.
	* win32-nat.c (ui_loop_hook): Delete extern declaration..
	* v850ice.c (ui_loop_hook): Delete extern declaration..
	* ser-unix.c (ui_loop_hook): Delete extern declaration..
	* ser-tcp.c (ui_loop_hook): Delete extern declaration..
	* remote-sim.c (ui_loop_hook): Delete extern declaration..
	* rdi-share/ardi.c (angel_RDI_ExecuteOrStep): Delete extern.
	ui_loop_hook declaration.
@
text
@d581 3
a583 2
         someone else might have freed it.  The ui_loop_hook signals that 
         we should exit by returning 1. */
d585 2
a586 2
      if (ui_loop_hook)
	detach = ui_loop_hook (0);
d961 3
a963 2
         someone else might have freed it.  The ui_loop_hook signals that 
         we should exit by returning 1. */
d965 1
a965 1
      if (ui_loop_hook)
d967 1
a967 1
	  if (ui_loop_hook (0))
@


1.18
log
@2004-01-09  Andrew Cagney  <cagney@@redhat.com>

	* jv-valprint.c, ser-unix.c: Add missing copyright years.
@
text
@a101 2
extern int (*ui_loop_hook) (int);

@


1.18.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d102 2
d583 2
a584 3
         someone else might have freed it.  The
         deprecated_ui_loop_hook signals that we should exit by
         returning 1.  */
d586 2
a587 2
      if (deprecated_ui_loop_hook)
	detach = deprecated_ui_loop_hook (0);
d962 2
a963 3
         someone else might have freed it.  The
         deprecated_ui_loop_hook signals that we should exit by
         returning 1.  */
d965 1
a965 1
      if (deprecated_ui_loop_hook)
d967 1
a967 1
	  if (deprecated_ui_loop_hook (0))
@


1.17
log
@2004-01-05  Andrew Cagney  <cagney@@redhat.com>

	* ser-unix.c (ser_unix_async): Fix tipo, "NOTHING_SECHEDULED"
	should be a switch case and not a label.
	* mips-tdep.c (mips32_next_pc): Delete unused labels
	"greater_equal_branch" and "less_zero_branch".
	* jv-valprint.c (java_print_value_fields): Delete unused label
	"flush_it".
@
text
@d2 3
a4 2
   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.16
log
@	* ser-pipe.c (_initialize_ser_pipe): Correct call to memset--swap
	second and third arguments.
	* ser-tcp.c (_initialize_ser_tcp): Likewise.
	* ser-unix.c (_initialize_ser_hardwire): Likewise.
@
text
@d1327 1
a1327 1
	NOTHING_SCHEDULED:
@


1.15
log
@* serial.h (SERIAL_ASYNC): Delete.
(DEPRECATED_SERIAL_FD): Delete.
(SERIAL_DEBUG): Delete.
(SERIAL_DEBUG_P): Delete.
(SERIAL_DRAIN_OUTPUT): Delete.
(SERIAL_FLUSH_OUTPUT): Delete.
(SERIAL_FLUSH_INPUT): Delete.
(SERIAL_SEND_BREAK): Delete.
(SERIAL_RAW): Delete.
(SERIAL_GET_TTY_STATE): Delete.
(SERIAL_SET_TTY_STATE): Delete.
(SERIAL_PRINT_TTY_STATE): Delete.
(SERIAL_NOFLUSH_SET_TTY_STATE): Delete.
(SERIAL_SETBAUDRATE): Delete.
(SERIAL_SETSTOPBITS): Delete.
(SERIAL_CAN_ASYNC_P): Delete.
(SERIAL_IS_ASYNC_P): Delete.
(SERIAL_UN_FDOPEN): Delete.
(SERIAL_READCHAR): Delete.
(SERIAL_CLOSE): Delete.
(SERIAL_FDOPEN): Delete.
(SERIAL_OPEN): Delete.
@
text
@d1340 1
a1340 1
  memset (ops, sizeof (struct serial_ops), 0);
@


1.15.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1340 1
a1340 1
  memset (ops, 0, sizeof (struct serial_ops));
@


1.15.24.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d2 2
a3 3

   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
   2003, 2004 Free Software Foundation, Inc.
d1327 1
a1327 1
	case NOTHING_SCHEDULED:
@


1.15.22.1
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d1340 1
a1340 1
  memset (ops, 0, sizeof (struct serial_ops));
@


1.15.22.2
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2 2
a3 3

   Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
   2003, 2004 Free Software Foundation, Inc.
d1327 1
a1327 1
	case NOTHING_SCHEDULED:
@


1.15.44.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1340 1
a1340 1
  memset (ops, 0, sizeof (struct serial_ops));
@


1.14
log
@s/typedef serial_t/struct serial */
@
text
@d1187 1
a1187 1
  if (SERIAL_IS_ASYNC_P (scb))
d1223 1
a1223 1
      if (SERIAL_DEBUG_P (scb))
d1311 1
a1311 1
      if (SERIAL_DEBUG_P (scb))
d1318 1
a1318 1
      if (SERIAL_DEBUG_P (scb))
@


1.13
log
@2001-05-11  Fernando Nasser  <fnasser@@redhat.com>

	* ser-unix.c (rate_to_code): Issue warning if baud rate is invalid.
	(hardwire_setbaudrate): Set errno to EINVAL and return with error
	if the conversion of the baud rate to code fails.
@
text
@d67 8
a74 6
static int hardwire_open (serial_t scb, const char *name);
static void hardwire_raw (serial_t scb);
static int wait_for (serial_t scb, int timeout);
static int hardwire_readchar (serial_t scb, int timeout);
static int do_hardwire_readchar (serial_t scb, int timeout);
static int generic_readchar (serial_t scb, int timeout, int (*do_readchar) (serial_t scb, int timeout));
d76 17
a92 14
static int hardwire_setbaudrate (serial_t scb, int rate);
static void hardwire_close (serial_t scb);
static int get_tty_state (serial_t scb, struct hardwire_ttystate * state);
static int set_tty_state (serial_t scb, struct hardwire_ttystate * state);
static serial_ttystate hardwire_get_tty_state (serial_t scb);
static int hardwire_set_tty_state (serial_t scb, serial_ttystate state);
static int hardwire_noflush_set_tty_state (serial_t, serial_ttystate,
						   serial_ttystate);
static void hardwire_print_tty_state (serial_t, serial_ttystate, struct ui_file *);
static int hardwire_drain_output (serial_t);
static int hardwire_flush_output (serial_t);
static int hardwire_flush_input (serial_t);
static int hardwire_send_break (serial_t);
static int hardwire_setstopbits (serial_t, int);
d94 1
a94 1
static int do_unix_readchar (serial_t scb, int timeout);
d97 1
a97 1
static void reschedule (serial_t scb);
d106 1
a106 1
hardwire_open (serial_t scb, const char *name)
d116 1
a116 1
get_tty_state (serial_t scb, struct hardwire_ttystate *state)
d146 1
a146 1
set_tty_state (serial_t scb, struct hardwire_ttystate *state)
d176 1
a176 1
hardwire_get_tty_state (serial_t scb)
d189 1
a189 1
hardwire_set_tty_state (serial_t scb, serial_ttystate ttystate)
d199 1
a199 1
hardwire_noflush_set_tty_state (serial_t scb,
d232 1
a232 1
hardwire_print_tty_state (serial_t scb,
d290 1
a290 1
hardwire_drain_output (serial_t scb)
d319 1
a319 1
hardwire_flush_output (serial_t scb)
d336 1
a336 1
hardwire_flush_input (serial_t scb)
d355 1
a355 1
hardwire_send_break (serial_t scb)
d385 1
a385 1
hardwire_raw (serial_t scb)
d440 1
a440 1
wait_for (serial_t scb, int timeout)
d561 1
a561 1
do_hardwire_readchar (serial_t scb, int timeout)
d629 1
a629 1
hardwire_readchar (serial_t scb, int timeout)
d780 1
a780 1
hardwire_setbaudrate (serial_t scb, int rate)
d819 1
a819 1
hardwire_setstopbits (serial_t scb, int num)
d862 1
a862 1
hardwire_close (serial_t scb)
d875 1
a875 1
ser_unix_nop_get_tty_state (serial_t scb)
d882 1
a882 1
ser_unix_nop_set_tty_state (serial_t scb, serial_ttystate ttystate)
d888 1
a888 1
ser_unix_nop_raw (serial_t scb)
d897 1
a897 1
ser_unix_wait_for (serial_t scb, int timeout)
d942 1
a942 1
do_unix_readchar (serial_t scb, int timeout)
d1033 2
a1034 2
generic_readchar (serial_t scb, int timeout,
		  int (do_readchar) (serial_t scb, int timeout))
d1071 1
a1071 1
ser_unix_readchar (serial_t scb, int timeout)
d1077 1
a1077 1
ser_unix_nop_noflush_set_tty_state (serial_t scb,
d1085 1
a1085 1
ser_unix_nop_print_tty_state (serial_t scb, 
d1094 1
a1094 1
ser_unix_nop_setbaudrate (serial_t scb, int rate)
d1100 1
a1100 1
ser_unix_nop_setstopbits (serial_t scb, int num)
d1106 1
a1106 1
ser_unix_write (serial_t scb, const char *str, int len)
d1123 1
a1123 1
ser_unix_nop_flush_output (serial_t scb)
d1129 1
a1129 1
ser_unix_flush_input (serial_t scb)
d1142 1
a1142 1
ser_unix_nop_send_break (serial_t scb)
d1148 1
a1148 1
ser_unix_nop_drain_output (serial_t scb)
d1185 1
a1185 1
reschedule (serial_t scb)
d1252 1
a1252 1
  serial_t scb = context;
d1294 1
a1294 1
  serial_t scb = context;
d1304 1
a1304 1
ser_unix_async (serial_t scb,
@


1.12
log
@Update/correct copyright notices.
@
text
@d744 27
a770 3
    if (rate == baudtab[i].rate)
      return baudtab[i].code;

d778 9
d792 2
a793 2
  cfsetospeed (&state.termios, rate_to_code (rate));
  cfsetispeed (&state.termios, rate_to_code (rate));
d802 1
a802 1
  state.termio.c_cflag |= rate_to_code (rate);
d806 2
a807 2
  state.sgttyb.sg_ispeed = rate_to_code (rate);
  state.sgttyb.sg_ospeed = rate_to_code (rate);
@


1.11
log
@	* ser-unix.c (hardware_print_tty_state) [HAVE_SGTTY]: Call
	fprintf_filtered with correct arguments.
@
text
@d2 2
a3 1
   Copyright 1992-1994, 1998-2000, 2001 Free Software Foundation, Inc.
@


1.10
log
@* monitor.c (#include "gdb_wait.h"): Removed.
* ocd.c: Likewise.
* ppc-bdm.c: Likewise.
* remote-adapt.c: Likewise.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-eb.c: Likewise.
* remote-es.c: Likewise.
* remote-mips.c: Likewise.
* remote-mm.c: Likewise.
* remote-nindy.c: Likewise.
* remote-os9k.c: Likewise.
* remote-rdi.c: Likewise.
* remote-rdp.c: Likewise.
* remote-sds.c: Likewise.
* remote-sim.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
* remote.c: Likewise.
* ser-pipe.c: Likewise.
* ser-unix.c: Likewise.
* Makefile.in: Updated dependencies.
-------------------------------------------------------------------
@
text
@d270 1
a270 1
  fprintf_filtered ("\n");
@


1.9
log
@* ser-unix.c (wait_for): Initialize the FD_SET before every select
call.
(ser_unix_wait_for): Ditto.
@
text
@d2 1
a2 1
   Copyright 1992-1994, 1998-2000 Free Software Foundation, Inc.
a27 1
#include "gdb_wait.h"
@


1.8
log
@* gdbarch.sh, hp-psymtab-read.c, hpread.c, m3-nat.c, mcore-tdep.c,
mips-tdep.c, monitor.c, regcache.c, remote-es.c, ser-unix.c,
somread.c, tracepoint.c: Fix spelling errors in comments.
* gdbarch.c: Regenerate.

* gnu-nat.c (S_exception_raise_request): Fix typos and spelling
errors in strings.
* m3-nat.c (intercept_exec_calls, mach_thread_parse_id): Likewise.
* mcore-tdep.c (mcore_analyze_prologue): Likewise.
* mips-tdep.c (mips16_next_pc, _initialize_mips_tdep): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-rdp.c (handle_swi): Likewise.
* remote-vx.c (vx_load_command): Likewise.
* sh-tdep.c (sh_do_pseudo_register): Likewise.
* sol-thread.c (td_err_string): Likewise.
* symtab.c (decode_line_2): Likewise.
-------------------------------------------------------------------
@
text
@d438 26
a463 17
  {
    struct timeval tv;
    fd_set readfds;

    FD_ZERO (&readfds);

    tv.tv_sec = timeout;
    tv.tv_usec = 0;

    FD_SET (scb->fd, &readfds);

    while (1)
      {
	int numfds;

	if (timeout >= 0)
	  numfds = select (scb->fd + 1, &readfds, 0, 0, &tv);
d465 1
a465 1
	  numfds = select (scb->fd + 1, &readfds, 0, 0, 0);
d467 2
a468 11
	if (numfds <= 0)
	  if (numfds == 0)
	    return SERIAL_TIMEOUT;
	  else if (errno == EINTR)
	    continue;
	  else
	    return SERIAL_ERROR;	/* Got an error from select or poll */

	return 0;
      }
  }
a860 13
  int numfds;
  struct timeval tv;
  fd_set readfds, exceptfds;

  FD_ZERO (&readfds);
  FD_ZERO (&exceptfds);

  tv.tv_sec = timeout;
  tv.tv_usec = 0;

  FD_SET (scb->fd, &readfds);
  FD_SET (scb->fd, &exceptfds);

d863 16
@


1.7
log
@2000-10-25  Fernando Nasser  <fnasser@@cygnus.com>

        * ser-unix.c (do_unix_readchar): Coding style improvement only.
@
text
@d1280 1
a1280 1
      /* De-schedule what ever tasks are currently scheduled. */
@


1.6
log
@2000-09-15  Fernando Nasser  <fnasser@@cygnus.com>

	* ser-unix.c (do_unix_readchar): Prevent infinite read wait to be
	interrupted after 32K seconds.
@
text
@d930 2
a931 1
      timeout = (timeout <= 0) ? timeout : (timeout - delta);
@


1.5
log
@Protoization.
@
text
@d930 1
a930 1
      timeout -= delta;
@


1.4
log
@Revert previous ser-unix change.  Locks up serial device.
@
text
@d781 1
a781 3
hardwire_setstopbits (scb, num)
     serial_t scb;
     int num;
@


1.3
log
@From Jonathan L.  Fix ser-unix.c timing out when there was no timeout.
@
text
@d913 1
a913 1
     will only go through the loop once. timeout < 0 means to wait forever. */
d915 1
a915 1
  delta = (timeout <= 0 ? 0 : 1);
d931 1
a931 1
      status = ser_unix_wait_for (scb, timeout < 0 ? timeout : delta);
d934 2
a935 1
      /* If we got an error back from wait_for, then we can return */
d937 4
a940 2
      if (status == SERIAL_ERROR)
        return status;
d942 2
a943 1
      status = read (scb->fd, scb->buf, BUFSIZ);
d945 4
a948 15
      if (status <= 0)
        {
          if (status == 0)
            {
              if (timeout != 0)
                continue;
              else
                return SERIAL_TIMEOUT;	/* 0 chars means timeout [may need to
					   distinguish between EOF & timeouts
					   someday] */
            }
	  else if (errno == EINTR)
            continue;
          else
	    return SERIAL_ERROR;	/* Got an error from read */
d950 4
d955 15
a969 4
      scb->bufcnt = status;
      scb->bufcnt--;
      scb->bufp = scb->buf;
      return *scb->bufp++;
d971 5
@


1.3.2.1
log
@Revert 28mar change.  Can lock up serial device.
@
text
@d913 1
a913 1
     will only go through the loop once. */
d915 1
a915 1
  delta = (timeout == 0 ? 0 : 1);
d931 1
a931 1
      status = ser_unix_wait_for (scb, delta);
d934 1
a934 2
      /* If we got a character or an error back from wait_for, then we can 
         break from the loop before the timeout is completed. */
d936 2
a937 4
      if (status != SERIAL_TIMEOUT)
	{
	  break;
	}
d939 1
a939 2
      /* If we have exhausted the original timeout, then generate
         a SERIAL_TIMEOUT, and pass it out of the loop. */
d941 15
a955 4
      else if (timeout == 0)
	{
	  status = SERIAL_TIMEOUT;
	  break;
a956 4
    }

  if (status < 0)
    return status;
d958 4
a961 15
  while (1)
    {
      status = read (scb->fd, scb->buf, BUFSIZ);
      if (status != -1 || errno != EINTR)
	break;
    }

  if (status <= 0)
    {
      if (status == 0)
	return SERIAL_TIMEOUT;	/* 0 chars means timeout [may need to
				   distinguish between EOF & timeouts
				   someday] */
      else
	return SERIAL_ERROR;	/* Got an error from read */
a962 5

  scb->bufcnt = status;
  scb->bufcnt--;
  scb->bufp = scb->buf;
  return *scb->bufp++;
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d913 1
a913 1
     will only go through the loop once. */
d915 1
a915 1
  delta = (timeout == 0 ? 0 : 1);
d931 1
a931 1
      status = ser_unix_wait_for (scb, delta);
d934 1
a934 2
      /* If we got a character or an error back from wait_for, then we can 
         break from the loop before the timeout is completed. */
d936 2
a937 4
      if (status != SERIAL_TIMEOUT)
	{
	  break;
	}
d939 1
a939 2
      /* If we have exhausted the original timeout, then generate
         a SERIAL_TIMEOUT, and pass it out of the loop. */
d941 15
a955 4
      else if (timeout == 0)
	{
	  status = SERIAL_TIMEOUT;
	  break;
a956 4
    }

  if (status < 0)
    return status;
d958 4
a961 15
  while (1)
    {
      status = read (scb->fd, scb->buf, BUFSIZ);
      if (status != -1 || errno != EINTR)
	break;
    }

  if (status <= 0)
    {
      if (status == 0)
	return SERIAL_TIMEOUT;	/* 0 chars means timeout [may need to
				   distinguish between EOF & timeouts
				   someday] */
      else
	return SERIAL_ERROR;	/* Got an error from read */
a962 5

  scb->bufcnt = status;
  scb->bufcnt--;
  scb->bufp = scb->buf;
  return *scb->bufp++;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1998 Free Software Foundation, Inc.
d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d23 2
d28 6
a33 3
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
d38 3
a40 3
{
  struct termios termios;
};
d51 3
a53 3
{
  struct termio termio;
};
a56 4
/* Needed for the code which uses select().  We would include <sys/select.h>
   too if it existed on all systems.  */
#include <sys/time.h>

d58 7
a64 7
{
  struct sgttyb sgttyb;
  struct tchars tc;
  struct ltchars ltc;
  /* Line discipline flags.  */
  int lmode;
};
d67 26
a92 20
static int hardwire_open PARAMS ((serial_t scb, const char *name));
static void hardwire_raw PARAMS ((serial_t scb));
static int wait_for PARAMS ((serial_t scb, int timeout));
static int hardwire_readchar PARAMS ((serial_t scb, int timeout));
static int rate_to_code PARAMS ((int rate));
static int hardwire_setbaudrate PARAMS ((serial_t scb, int rate));
static int hardwire_write PARAMS ((serial_t scb, const char *str, int len));
static void hardwire_close PARAMS ((serial_t scb));
static int get_tty_state PARAMS ((serial_t scb, struct hardwire_ttystate *state));
static int set_tty_state PARAMS ((serial_t scb, struct hardwire_ttystate *state));
static serial_ttystate hardwire_get_tty_state PARAMS ((serial_t scb));
static int hardwire_set_tty_state PARAMS ((serial_t scb, serial_ttystate state));
static int hardwire_noflush_set_tty_state PARAMS ((serial_t, serial_ttystate,
						   serial_ttystate));
static void hardwire_print_tty_state PARAMS ((serial_t, serial_ttystate));
static int hardwire_drain_output PARAMS ((serial_t));
static int hardwire_flush_output PARAMS ((serial_t));
static int hardwire_flush_input PARAMS ((serial_t));
static int hardwire_send_break PARAMS ((serial_t));
static int hardwire_setstopbits PARAMS ((serial_t, int));
d94 1
a94 1
void _initialize_ser_hardwire PARAMS ((void));
d96 1
a96 3
#ifdef __CYGWIN32__
extern void (*ui_loop_hook) PARAMS ((int));
#endif
d101 1
a101 3
hardwire_open(scb, name)
     serial_t scb;
     const char *name;
d111 1
a111 3
get_tty_state (scb, state)
     serial_t scb;
     struct hardwire_ttystate *state;
d114 1
a114 1
  if (tcgetattr(scb->fd, &state->termios) < 0)
d141 1
a141 3
set_tty_state(scb, state)
     serial_t scb;
     struct hardwire_ttystate *state;
d144 1
a144 1
  if (tcsetattr(scb->fd, TCSANOW, &state->termios) < 0)
d171 1
a171 2
hardwire_get_tty_state(scb)
     serial_t scb;
d175 1
a175 1
  state = (struct hardwire_ttystate *)xmalloc(sizeof *state);
d177 1
a177 1
  if (get_tty_state(scb, state))
d180 1
a180 1
  return (serial_ttystate)state;
d184 1
a184 3
hardwire_set_tty_state(scb, ttystate)
     serial_t scb;
     serial_ttystate ttystate;
d188 1
a188 1
  state = (struct hardwire_ttystate *)ttystate;
d190 1
a190 1
  return set_tty_state(scb, state);
d194 3
a196 4
hardwire_noflush_set_tty_state (scb, new_ttystate, old_ttystate)
     serial_t scb;
     serial_ttystate new_ttystate;
     serial_ttystate old_ttystate;
d203 1
a203 1
  new_state = *(struct hardwire_ttystate *)new_ttystate;
d227 3
a229 3
hardwire_print_tty_state (scb, ttystate)
     serial_t scb;
     serial_ttystate ttystate;
d235 6
a240 4
  printf_filtered ("c_iflag = 0x%x, c_oflag = 0x%x,\n",
		   state->termios.c_iflag, state->termios.c_oflag);
  printf_filtered ("c_cflag = 0x%x, c_lflag = 0x%x\n",
		   state->termios.c_cflag, state->termios.c_lflag);
d244 1
a244 1
  printf_filtered ("c_line = 0x%x.\n", state->termios.c_line);
d246 1
a246 1
  printf_filtered ("c_cc: ");
d248 2
a249 2
    printf_filtered ("0x%x ", state->termios.c_cc[i]);
  printf_filtered ("\n");
d253 6
a258 6
  printf_filtered ("c_iflag = 0x%x, c_oflag = 0x%x,\n",
		   state->termio.c_iflag, state->termio.c_oflag);
  printf_filtered ("c_cflag = 0x%x, c_lflag = 0x%x, c_line = 0x%x.\n",
		   state->termio.c_cflag, state->termio.c_lflag,
		   state->termio.c_line);
  printf_filtered ("c_cc: ");
d260 2
a261 2
    printf_filtered ("0x%x ", state->termio.c_cc[i]);
  printf_filtered ("\n");
d265 2
a266 6
  printf_filtered ("sgttyb.sg_flags = 0x%x.\n", state->sgttyb.sg_flags);

  printf_filtered ("tchars: ");
  for (i = 0; i < (int)sizeof (struct tchars); i++)
    printf_filtered ("0x%x ", ((unsigned char *)&state->tc)[i]);
  printf_filtered ("\n");
d268 9
a276 4
  printf_filtered ("ltchars: ");
  for (i = 0; i < (int)sizeof (struct ltchars); i++)
    printf_filtered ("0x%x ", ((unsigned char *)&state->ltc)[i]);
  printf_filtered ("\n");
d278 1
a278 1
  printf_filtered ("lmode:  0x%x\n", state->lmode);
d285 1
a285 2
hardwire_drain_output (scb)
     serial_t scb;
d310 1
a310 1
#endif  
d314 1
a314 2
hardwire_flush_output (scb)
     serial_t scb;
d327 1
a327 1
#endif  
d331 1
a331 2
hardwire_flush_input (scb)
     serial_t scb;
d333 1
a333 2
  scb->bufcnt = 0;
  scb->bufp = scb->buf;
d346 1
a346 1
#endif  
d350 1
a350 2
hardwire_send_break (scb)
     serial_t scb;
d376 1
a376 1
#endif  
d380 1
a380 2
hardwire_raw(scb)
     serial_t scb;
d384 2
a385 2
  if (get_tty_state(scb, &state))
    fprintf_unfiltered(gdb_stderr, "get_tty_state failed: %s\n", safe_strerror(errno));
d391 1
a391 1
  state.termios.c_cflag &= ~(CSIZE|PARENB);
d401 1
a401 1
  state.termio.c_cflag &= ~(CSIZE|PARENB);
d415 1
a415 1
    fprintf_unfiltered(gdb_stderr, "set_tty_state failed: %s\n", safe_strerror(errno));
d425 9
d435 1
a435 3
wait_for(scb, timeout)
     serial_t scb;
     int timeout;
a436 4
#ifndef __CYGWIN32__
  scb->timeout_remaining = 0;
#endif

d447 1
a447 1
    FD_SET(scb->fd, &readfds);
d454 1
a454 1
	  numfds = select(scb->fd+1, &readfds, 0, 0, &tv);
d456 1
a456 1
	  numfds = select(scb->fd+1, &readfds, 0, 0, 0);
d469 1
a469 1
#endif	/* HAVE_SGTTY */
d480 2
a481 2
    if (get_tty_state(scb, &state))
      fprintf_unfiltered(gdb_stderr, "get_tty_state failed: %s\n", safe_strerror(errno));
d533 1
a533 1
      fprintf_unfiltered(gdb_stderr, "set_tty_state failed: %s\n", safe_strerror(errno));
d537 1
a537 1
#endif	/* HAVE_TERMIO || HAVE_TERMIOS */
d544 11
d556 1
a556 3
hardwire_readchar (scb, timeout)
     serial_t scb;
     int timeout;
d558 2
a559 7
  int status;
#ifdef __CYGWIN32__
  int t;
#endif

  if (scb->bufcnt-- > 0)
    return *scb->bufp++;
a560 1
#ifdef __CYGWIN32__
a562 1
#endif
d564 7
a572 4
#ifdef __CYGWIN32__
      t = timeout == 0 ? 0 : 1;
      scb->timeout_remaining = timeout < 0 ? timeout : timeout - t;
      status = wait_for (scb, t);
d574 6
a579 1
      /* -2 means disable timer */
d581 8
a588 4
        ui_loop_hook (-2);
#else
      status = wait_for (scb, timeout);
#endif
d592 1
a592 1
      scb->bufcnt = read (scb->fd, scb->buf, BUFSIZ);
d594 1
a594 1
      if (scb->bufcnt <= 0)
d596 1
a596 1
	  if (scb->bufcnt == 0)
d599 1
a599 1
		 we don't (yet at least) distinguish).  */
d605 2
a606 4
#ifdef __CYGWIN32__
          else if (scb->timeout_remaining < 0)
            continue;
#endif
d616 1
d623 7
d648 60
a707 15
  {50, B50},
  {75, B75},
  {110, B110},
  {134, B134},
  {150, B150},
  {200, B200},
  {300, B300},
  {600, B600},
  {1200, B1200},
  {1800, B1800},
  {2400, B2400},
  {4800, B4800},
  {9600, B9600},
  {19200, B19200},
  {38400, B38400},
d709 4
a712 1
  {57600, B57600},
d715 4
a718 1
  {115200, B115200},
d721 4
a724 1
  {230400, B230400},
d727 4
a730 1
  {460800, B460800},
d732 4
a735 1
  {-1, -1},
d738 2
a739 3
static int 
rate_to_code(rate)
     int rate;
d744 1
a744 1
    if (rate == baudtab[i].rate)  
d751 1
a751 3
hardwire_setbaudrate(scb, rate)
     serial_t scb;
     int rate;
d755 1
a755 1
  if (get_tty_state(scb, &state))
d781 1
a781 1
hardwire_setstopbits(scb, num)
d788 1
a788 1
  if (get_tty_state(scb, &state))
d808 1
a808 1
    state.termios.c_cflag |= CSTOPB; /* two bits */
d815 1
a815 1
    state.termio.c_cflag |= CSTOPB; /* two bits */
d825 167
d993 74
a1066 4
hardwire_write(scb, str, len)
     serial_t scb;
     const char *str;
     int len;
d1072 1
a1072 1
      cc = write(scb->fd, str, len);
d1082 62
d1145 66
a1210 2
hardwire_close(scb)
     serial_t scb;
d1212 38
a1249 2
  if (scb->fd < 0)
    return;
d1251 8
a1258 2
  close(scb->fd);
  scb->fd = -1;
d1261 5
a1265 1
static struct serial_ops hardwire_ops =
d1267 28
a1294 18
  "hardwire",
  0,
  hardwire_open,
  hardwire_close,
  hardwire_readchar,
  hardwire_write,
  hardwire_flush_output,
  hardwire_flush_input,
  hardwire_send_break,
  hardwire_raw,
  hardwire_get_tty_state,
  hardwire_set_tty_state,
  hardwire_print_tty_state,
  hardwire_noflush_set_tty_state,
  hardwire_setbaudrate,
  hardwire_setstopbits,
  hardwire_drain_output,	/* wait for output to drain */
};
d1297 1
a1297 1
_initialize_ser_hardwire ()
d1299 24
a1322 1
  serial_add_interface (&hardwire_ops);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d88 3
a90 1
extern int (*ui_loop_hook) PARAMS ((int));
d437 4
d553 4
a556 2
  int status, delta;
  int detach = 0;
d561 1
d564 1
a565 7
  /* We have to be able to keep the GUI alive here, so we break the original
     timeout into steps of 1 second, running the "keep the GUI alive" hook 
     each time through the loop.
     Also, timeout = 0 means to poll, so we just set the delta to 0, so we
     will only go through the loop once. */
   
  delta = (timeout == 0 ? 0 : 1);
d568 4
d573 1
a573 6
      /* N.B. The UI may destroy our world (for instance by calling
         remote_stop,) in which case we want to get out of here as
         quickly as possible.  It is not safe to touch scb, since
         someone else might have freed it.  The ui_loop_hook signals that 
         we should exit by returning 1. */

d575 4
a578 8
        detach = ui_loop_hook (0);

      if (detach)
	return SERIAL_TIMEOUT;

      scb->timeout_remaining = (timeout < 0 ? timeout : timeout - delta);
      status = wait_for (scb, delta);

d595 1
d598 1
@


1.1.1.3
log
@import gdb-1999-07-05 snapshot
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1998, 1999 Free Software Foundation, Inc.
a26 4
#endif

#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
@


1.1.1.4
log
@import gdb-1999-07-07 pre reformat
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1998 Free Software Foundation, Inc.
d27 4
@


1.1.1.5
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d32 3
a34 3
  {
    struct termios termios;
  };
d45 3
a47 3
  {
    struct termio termio;
  };
d56 7
a62 7
  {
    struct sgttyb sgttyb;
    struct tchars tc;
    struct ltchars ltc;
    /* Line discipline flags.  */
    int lmode;
  };
d73 2
a74 2
static int get_tty_state PARAMS ((serial_t scb, struct hardwire_ttystate * state));
static int set_tty_state PARAMS ((serial_t scb, struct hardwire_ttystate * state));
d93 1
a93 1
hardwire_open (scb, name)
d110 1
a110 1
  if (tcgetattr (scb->fd, &state->termios) < 0)
d137 1
a137 1
set_tty_state (scb, state)
d142 1
a142 1
  if (tcsetattr (scb->fd, TCSANOW, &state->termios) < 0)
d169 1
a169 1
hardwire_get_tty_state (scb)
d174 1
a174 1
  state = (struct hardwire_ttystate *) xmalloc (sizeof *state);
d176 1
a176 1
  if (get_tty_state (scb, state))
d179 1
a179 1
  return (serial_ttystate) state;
d183 1
a183 1
hardwire_set_tty_state (scb, ttystate)
d189 1
a189 1
  state = (struct hardwire_ttystate *) ttystate;
d191 1
a191 1
  return set_tty_state (scb, state);
d205 1
a205 1
  new_state = *(struct hardwire_ttystate *) new_ttystate;
d268 2
a269 2
  for (i = 0; i < (int) sizeof (struct tchars); i++)
    printf_filtered ("0x%x ", ((unsigned char *) &state->tc)[i]);
d273 2
a274 2
  for (i = 0; i < (int) sizeof (struct ltchars); i++)
    printf_filtered ("0x%x ", ((unsigned char *) &state->ltc)[i]);
d310 1
a310 1
#endif
d328 1
a328 1
#endif
d349 1
a349 1
#endif
d380 1
a380 1
#endif
d384 1
a384 1
hardwire_raw (scb)
d389 2
a390 2
  if (get_tty_state (scb, &state))
    fprintf_unfiltered (gdb_stderr, "get_tty_state failed: %s\n", safe_strerror (errno));
d396 1
a396 1
  state.termios.c_cflag &= ~(CSIZE | PARENB);
d406 1
a406 1
  state.termio.c_cflag &= ~(CSIZE | PARENB);
d420 1
a420 1
    fprintf_unfiltered (gdb_stderr, "set_tty_state failed: %s\n", safe_strerror (errno));
d431 1
a431 1
wait_for (scb, timeout)
d445 1
a445 1
    FD_SET (scb->fd, &readfds);
d452 1
a452 1
	  numfds = select (scb->fd + 1, &readfds, 0, 0, &tv);
d454 1
a454 1
	  numfds = select (scb->fd + 1, &readfds, 0, 0, 0);
d467 1
a467 1
#endif /* HAVE_SGTTY */
d478 2
a479 2
    if (get_tty_state (scb, &state))
      fprintf_unfiltered (gdb_stderr, "get_tty_state failed: %s\n", safe_strerror (errno));
d531 1
a531 1
      fprintf_unfiltered (gdb_stderr, "set_tty_state failed: %s\n", safe_strerror (errno));
d535 1
a535 1
#endif /* HAVE_TERMIO || HAVE_TERMIOS */
d561 1
a561 1

d573 1
a573 1
	detach = ui_loop_hook (0);
d591 1
a591 1
	         we don't (yet at least) distinguish).  */
d597 2
a598 2
	      else if (scb->timeout_remaining < 0)
		continue;
d632 15
a646 60
  {
    50, B50
  }
  ,
  {
    75, B75
  }
  ,
  {
    110, B110
  }
  ,
  {
    134, B134
  }
  ,
  {
    150, B150
  }
  ,
  {
    200, B200
  }
  ,
  {
    300, B300
  }
  ,
  {
    600, B600
  }
  ,
  {
    1200, B1200
  }
  ,
  {
    1800, B1800
  }
  ,
  {
    2400, B2400
  }
  ,
  {
    4800, B4800
  }
  ,
  {
    9600, B9600
  }
  ,
  {
    19200, B19200
  }
  ,
  {
    38400, B38400
  }
  ,
d648 1
a648 4
  {
    57600, B57600
  }
  ,
d651 1
a651 4
  {
    115200, B115200
  }
  ,
d654 1
a654 4
  {
    230400, B230400
  }
  ,
d657 1
a657 4
  {
    460800, B460800
  }
  ,
d659 1
a659 4
  {
    -1, -1
  }
  ,
d662 2
a663 2
static int
rate_to_code (rate)
d669 1
a669 1
    if (rate == baudtab[i].rate)
d676 1
a676 1
hardwire_setbaudrate (scb, rate)
d682 1
a682 1
  if (get_tty_state (scb, &state))
d708 1
a708 1
hardwire_setstopbits (scb, num)
d715 1
a715 1
  if (get_tty_state (scb, &state))
d735 1
a735 1
    state.termios.c_cflag |= CSTOPB;	/* two bits */
d742 1
a742 1
    state.termio.c_cflag |= CSTOPB;	/* two bits */
d753 1
a753 1
hardwire_write (scb, str, len)
d762 1
a762 1
      cc = write (scb->fd, str, len);
d773 1
a773 1
hardwire_close (scb)
d779 1
a779 1
  close (scb->fd);
@


1.1.1.6
log
@import gdb-1999-08-30 snapshot
@
text
@d26 3
@


1.1.1.7
log
@import gdb-1999-09-21
@
text
@d2 1
a2 1
   Copyright 1992, 1993, 1994, 1998-1999 Free Software Foundation, Inc.
a22 2
#include "ser-unix.h"

a25 9
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif
#include <sys/socket.h>
#include <sys/time.h>

#include "gdb_string.h"
#include "event-loop.h"

d49 4
d63 20
a82 20
static int hardwire_open (serial_t scb, const char *name);
static void hardwire_raw (serial_t scb);
static int wait_for (serial_t scb, int timeout);
static int hardwire_readchar (serial_t scb, int timeout);
static int rate_to_code (int rate);
static int hardwire_setbaudrate (serial_t scb, int rate);
static int hardwire_write (serial_t scb, const char *str, int len);
static void hardwire_close (serial_t scb);
static int get_tty_state (serial_t scb, struct hardwire_ttystate * state);
static int set_tty_state (serial_t scb, struct hardwire_ttystate * state);
static serial_ttystate hardwire_get_tty_state (serial_t scb);
static int hardwire_set_tty_state (serial_t scb, serial_ttystate state);
static int hardwire_noflush_set_tty_state (serial_t, serial_ttystate,
						   serial_ttystate);
static void hardwire_print_tty_state (serial_t, serial_ttystate, struct gdb_file *);
static int hardwire_drain_output (serial_t);
static int hardwire_flush_output (serial_t);
static int hardwire_flush_input (serial_t);
static int hardwire_send_break (serial_t);
static int hardwire_setstopbits (serial_t, int);
d84 1
a84 1
void _initialize_ser_hardwire (void);
d86 1
a86 1
extern int (*ui_loop_hook) (int);
d91 3
a93 1
hardwire_open (serial_t scb, const char *name)
d103 3
a105 1
get_tty_state (serial_t scb, struct hardwire_ttystate *state)
d135 3
a137 1
set_tty_state (serial_t scb, struct hardwire_ttystate *state)
d167 2
a168 1
hardwire_get_tty_state (serial_t scb)
d181 3
a183 1
hardwire_set_tty_state (serial_t scb, serial_ttystate ttystate)
d193 4
a196 3
hardwire_noflush_set_tty_state (serial_t scb,
				serial_ttystate new_ttystate,
				serial_ttystate old_ttystate)
d227 3
a229 3
hardwire_print_tty_state (serial_t scb,
			  serial_ttystate ttystate,
			  struct gdb_file *stream)
d235 4
a238 4
  fprintf_filtered (stream, "c_iflag = 0x%x, c_oflag = 0x%x,\n",
		    state->termios.c_iflag, state->termios.c_oflag);
  fprintf_filtered (stream, "c_cflag = 0x%x, c_lflag = 0x%x\n",
		    state->termios.c_cflag, state->termios.c_lflag);
d242 1
a242 1
  fprintf_filtered (stream, "c_line = 0x%x.\n", state->termios.c_line);
d244 1
a244 1
  fprintf_filtered (stream, "c_cc: ");
d246 2
a247 2
    fprintf_filtered (stream, "0x%x ", state->termios.c_cc[i]);
  fprintf_filtered (stream, "\n");
d251 6
a256 6
  fprintf_filtered (stream, "c_iflag = 0x%x, c_oflag = 0x%x,\n",
		    state->termio.c_iflag, state->termio.c_oflag);
  fprintf_filtered (stream, "c_cflag = 0x%x, c_lflag = 0x%x, c_line = 0x%x.\n",
		    state->termio.c_cflag, state->termio.c_lflag,
		    state->termio.c_line);
  fprintf_filtered (stream, "c_cc: ");
d258 2
a259 2
    fprintf_filtered (stream, "0x%x ", state->termio.c_cc[i]);
  fprintf_filtered (stream, "\n");
d263 1
a263 2
  fprintf_filtered (stream, "sgttyb.sg_flags = 0x%x.\n",
		    state->sgttyb.sg_flags);
d265 1
a265 1
  fprintf_filtered (stream, "tchars: ");
d267 2
a268 2
    fprintf_filtered (stream, "0x%x ", ((unsigned char *) &state->tc)[i]);
  fprintf_filtered ("\n");
d270 1
a270 1
  fprintf_filtered (stream, "ltchars: ");
d272 2
a273 2
    fprintf_filtered (stream, "0x%x ", ((unsigned char *) &state->ltc)[i]);
  fprintf_filtered (stream, "\n");
d275 1
a275 1
  fprintf_filtered (stream, "lmode:  0x%x\n", state->lmode);
d282 2
a283 1
hardwire_drain_output (serial_t scb)
d312 2
a313 1
hardwire_flush_output (serial_t scb)
d330 2
a331 1
hardwire_flush_input (serial_t scb)
d351 2
a352 1
hardwire_send_break (serial_t scb)
d382 2
a383 1
hardwire_raw (serial_t scb)
a427 4
/* FIXME: Don't replace this with the equivalent ser_unix*() until the
   old TERMIOS/SGTTY/... timer code has been flushed. cagney
   1999-09-16. */

d429 3
a431 1
wait_for (serial_t scb, int timeout)
a539 11

/* FIXME: cagney/1999-09-16: Don't replace this with the equivalent
   ser_unix*() until the old TERMIOS/SGTTY/... timer code has been
   flushed. */

/* NOTE: cagney/1999-09-16: This function is not identical to
   ser_unix_readchar() as part of replacing it with ser_unix*()
   merging will be required - this code handles the case where read()
   times out due to no data while ser_unix_readchar() doesn't expect
   that. */

d541 3
a543 1
hardwire_readchar (serial_t scb, int timeout)
d582 1
a582 5
      /* NOTE: cagney/1999-09-17: See ser_unix_readchar() for reason
         why ASYNC reads are character by character. */

      scb->bufcnt = read (scb->fd, scb->buf,
			  (SERIAL_IS_ASYNC_P (scb) ? 1 : BUFSIZ));
d721 2
a722 1
rate_to_code (int rate)
d734 3
a736 1
hardwire_setbaudrate (serial_t scb, int rate)
a809 4
/* FIXME: Don't replace this with the equivalent ser_unix*() until the
   old TERMIOS/SGTTY/... timer code has been flushed. cagney
   1999-09-16. */

d811 4
a814 1
hardwire_write (serial_t scb, const char *str, int len)
d823 1
a823 1
        return 1;
a829 1

d831 2
a832 1
hardwire_close (serial_t scb)
d841 1
a841 5

/* Generic operations used by all UNIX/FD based serial interfaces. */

serial_ttystate
ser_unix_nop_get_tty_state (serial_t scb)
d843 18
a860 235
  /* allocate a dummy */
  return (serial_ttystate) XMALLOC (int);
}

int
ser_unix_nop_set_tty_state (serial_t scb, serial_ttystate ttystate)
{
  return 0;
}

void
ser_unix_nop_raw (serial_t scb)
{
  return;			/* Always in raw mode */
}

/* Wait for input on scb, with timeout seconds.  Returns 0 on success,
   otherwise SERIAL_TIMEOUT or SERIAL_ERROR. */

int
ser_unix_wait_for (serial_t scb, int timeout)
{
  int numfds;
  struct timeval tv;
  fd_set readfds, exceptfds;

  FD_ZERO (&readfds);
  FD_ZERO (&exceptfds);

  tv.tv_sec = timeout;
  tv.tv_usec = 0;

  FD_SET (scb->fd, &readfds);
  FD_SET (scb->fd, &exceptfds);

  while (1)
    {
      if (timeout >= 0)
	numfds = select (scb->fd + 1, &readfds, 0, &exceptfds, &tv);
      else
	numfds = select (scb->fd + 1, &readfds, 0, &exceptfds, 0);

      if (numfds <= 0)
	{
	  if (numfds == 0)
	    return SERIAL_TIMEOUT;
	  else if (errno == EINTR)
	    continue;
	  else
	    return SERIAL_ERROR;	/* Got an error from select or poll */
	}

      return 0;
    }
}

/* Read a character with user-specified timeout.  TIMEOUT is number of seconds
   to wait, or -1 to wait forever.  Use timeout of 0 to effect a poll.  Returns
   char if successful.  Returns -2 if timeout expired, EOF if line dropped
   dead, or -3 for any other error (see errno in that case). */

int
ser_unix_readchar (serial_t scb, int timeout)
{
  int status;
  int delta;

  if (scb->bufcnt-- > 0)
    return *scb->bufp++;

  /* We have to be able to keep the GUI alive here, so we break the original
     timeout into steps of 1 second, running the "keep the GUI alive" hook 
     each time through the loop.

     Also, timeout = 0 means to poll, so we just set the delta to 0, so we
     will only go through the loop once. */

  delta = (timeout == 0 ? 0 : 1);
  while (1)
    {

      /* N.B. The UI may destroy our world (for instance by calling
         remote_stop,) in which case we want to get out of here as
         quickly as possible.  It is not safe to touch scb, since
         someone else might have freed it.  The ui_loop_hook signals that 
         we should exit by returning 1. */

      if (ui_loop_hook)
	{
	  if (ui_loop_hook (0))
	    return SERIAL_TIMEOUT;
	}

      status = ser_unix_wait_for (scb, delta);
      timeout -= delta;

      /* If we got a character or an error back from wait_for, then we can 
         break from the loop before the timeout is completed. */

      if (status != SERIAL_TIMEOUT)
	{
	  break;
	}

      /* If we have exhausted the original timeout, then generate
         a SERIAL_TIMEOUT, and pass it out of the loop. */

      else if (timeout == 0)
	{
	  status = SERIAL_TIMEOUT;
	  break;
	}
    }

  if (status < 0)
    return status;

  while (1)
    {
      /* FIXME: cagney/1999-09-17: ASYNC: The ASYNC serial code needs
	 to be modified so that it agressivly tries to drain its local
	 input buffer.  Until this is done, the read() below can only
	 take in single characters.  This is to ensure that
	 unprocessed data doesn't end up sitting in the input fifo. */
      scb->bufcnt = read (scb->fd, scb->buf,
			  (SERIAL_IS_ASYNC_P (scb) ? 1 : BUFSIZ));
      if (scb->bufcnt != -1 || errno != EINTR)
	break;
    }

  if (scb->bufcnt <= 0)
    {
      if (scb->bufcnt == 0)
	return SERIAL_TIMEOUT;	/* 0 chars means timeout [may need to
				   distinguish between EOF & timeouts
				   someday] */
      else
	return SERIAL_ERROR;	/* Got an error from read */
    }

  scb->bufcnt--;
  scb->bufp = scb->buf;
  return *scb->bufp++;
}

int
ser_unix_nop_noflush_set_tty_state (serial_t scb,
				    serial_ttystate new_ttystate,
				    serial_ttystate old_ttystate)
{
  return 0;
}

void
ser_unix_nop_print_tty_state (serial_t scb, 
			      serial_ttystate ttystate,
			      struct gdb_file *stream)
{
  /* Nothing to print.  */
  return;
}

int
ser_unix_nop_setbaudrate (serial_t scb, int rate)
{
  return 0;			/* Never fails! */
}

int
ser_unix_nop_setstopbits (serial_t scb, int num)
{
  return 0;			/* Never fails! */
}

int
ser_unix_write (serial_t scb, const char *str, int len)
{
  int cc;

  while (len > 0)
    {
      cc = write (scb->fd, str, len);

      if (cc < 0)
	return 1;
      len -= cc;
      str += cc;
    }
  return 0;
}

int
ser_unix_nop_flush_output (serial_t scb)
{
  return 0;
}

int
ser_unix_nop_flush_input (serial_t scb)
{
  return 0;
}

int
ser_unix_nop_send_break (serial_t scb)
{
  return 0;
}

int
ser_unix_nop_drain_output (serial_t scb)
{
  return 0;
}

static void
ser_unix_event (int error, int fd, gdb_client_data context)
{
  serial_t scb = context;
  scb->async_handler (error, scb->async_context, fd);
}

void
ser_unix_async (serial_t scb,
		int async_p)
{
  if (async_p)
    {
      add_file_handler (scb->fd, ser_unix_event, scb);
    }
  else
    {
      delete_file_handler (scb->fd);
    }
}
d863 1
a863 1
_initialize_ser_hardwire (void)
d865 1
a865 27
  struct serial_ops *ops = XMALLOC (struct serial_ops);
  memset (ops, sizeof (struct serial_ops), 0);
  ops->name = "hardwire";
  ops->next = 0;
  ops->open = hardwire_open;
  ops->close = hardwire_close;
  /* FIXME: Don't replace this with the equivalent ser_unix*() until
     the old TERMIOS/SGTTY/... timer code has been flushed. cagney
     1999-09-16. */
  ops->readchar = hardwire_readchar;
  /* FIXME: Don't replace this with the equivalent ser_unix*() until
     the old TERMIOS/SGTTY/... timer code has been flushed. cagney
     1999-09-16. */
  ops->write = hardwire_write;
  ops->flush_output = hardwire_flush_output;
  ops->flush_input = hardwire_flush_input;
  ops->send_break = hardwire_send_break;
  ops->go_raw = hardwire_raw;
  ops->get_tty_state = hardwire_get_tty_state;
  ops->set_tty_state = hardwire_set_tty_state;
  ops->print_tty_state = hardwire_print_tty_state;
  ops->noflush_set_tty_state = hardwire_noflush_set_tty_state;
  ops->setbaudrate = hardwire_setbaudrate;
  ops->setstopbits = hardwire_setstopbits;
  ops->drain_output = hardwire_drain_output;
  ops->async = ser_unix_async;
  serial_add_interface (ops);
@


1.1.1.8
log
@import gdb-1999-10-04 snapshot
@
text
@d37 1
a73 2
static int do_hardwire_readchar (serial_t scb, int timeout);
static int generic_readchar (serial_t scb, int timeout, int (*do_readchar) (serial_t scb, int timeout));
d76 1
a90 5
static int do_unix_readchar (serial_t scb, int timeout);
static timer_handler_func push_event;
static handler_func fd_event;
static void reschedule (serial_t scb);

d233 1
a233 2
		    (int) state->termios.c_iflag,
		    (int) state->termios.c_oflag);
d235 1
a235 2
		    (int) state->termios.c_cflag,
		    (int) state->termios.c_lflag);
d328 2
a329 1
  ser_unix_flush_input (scb);
d421 3
a423 8
/* FIXME: cagney/1999-09-16: Don't replace this with the equivalent
   ser_unix*() until the old TERMIOS/SGTTY/... timer code has been
   flushed. . */

/* NOTE: cagney/1999-09-30: Much of the code below is dead.  The only
   possible values of the TIMEOUT parameter are ONE and ZERO.
   Consequently all the code that tries to handle the possability of
   an overflowed timer is unnecessary. */
d547 1
a547 1
do_hardwire_readchar (serial_t scb, int timeout)
d552 3
d586 5
a590 1
      status = read (scb->fd, scb->buf, BUFSIZ);
d592 1
a592 1
      if (status <= 0)
d594 1
a594 1
	  if (status == 0)
a613 1
      scb->bufcnt = status;
a619 7
static int
hardwire_readchar (serial_t scb, int timeout)
{
  return generic_readchar (scb, timeout, do_hardwire_readchar);
}


d815 22
d914 2
a915 2
static int
do_unix_readchar (serial_t scb, int timeout)
d920 3
d972 8
a979 2
      status = read (scb->fd, scb->buf, BUFSIZ);
      if (status != -1 || errno != EINTR)
d983 1
a983 1
  if (status <= 0)
d985 1
a985 1
      if (status == 0)
a992 1
  scb->bufcnt = status;
a997 58
/* Perform operations common to both old and new readchar. */

/* Return the next character from the input FIFO.  If the FIFO is
   empty, call the SERIAL specific routine to try and read in more
   characters.

   Initially data from the input FIFO is returned (fd_event()
   pre-reads the input into that FIFO.  Once that has been emptied,
   further data is obtained by polling the input FD using the device
   specific readchar() function.  Note: reschedule() is called after
   every read.  This is because there is no guarentee that the lower
   level fd_event() poll_event() code (which also calls reschedule())
   will be called. */

static int
generic_readchar (serial_t scb, int timeout,
		  int (do_readchar) (serial_t scb, int timeout))
{
  int ch;
  if (scb->bufcnt > 0)
    {
      ch = *scb->bufp;
      scb->bufcnt--;
      scb->bufp++;
    }
  else if (scb->bufcnt < 0)
    {
      /* Some errors/eof are are sticky. */
      ch = scb->bufcnt;
    }
  else
    {
      ch = do_readchar (scb, timeout);
      if (ch < 0)
	{
	  switch ((enum serial_rc) ch)
	    {
	    case SERIAL_EOF:
	    case SERIAL_ERROR:
	      /* Make the error/eof stick. */
	      scb->bufcnt = ch;
	      break;
	    case SERIAL_TIMEOUT:
	      scb->bufcnt = 0;
	      break;
	    }
	}
    }
  reschedule (scb);
  return ch;
}

int
ser_unix_readchar (serial_t scb, int timeout)
{
  return generic_readchar (scb, timeout, do_unix_readchar);
}

d1051 1
a1051 1
ser_unix_flush_input (serial_t scb)
d1053 1
a1053 8
  if (scb->bufcnt >= 0)
    {
      scb->bufcnt = 0;
      scb->bufp = scb->buf;
      return 0;
    }
  else
    return SERIAL_ERROR;
a1067 31


/* Event handling for ASYNC serial code.

   At any time the SERIAL device either: has an empty FIFO and is
   waiting on a FD event; or has a non-empty FIFO/error condition and
   is constantly scheduling timer events.

   ASYNC only stops pestering its client when it is de-async'ed or it
   is told to go away. */

/* Value of scb->async_state: */
enum {
  /* >= 0 (TIMER_SCHEDULED) */
  /* The ID of the currently scheduled timer event. This state is
     rarely encountered.  Timer events are one-off so as soon as the
     event is delivered the state is shanged to NOTHING_SCHEDULED. */
  FD_SCHEDULED = -1,
  /* The fd_event() handler is scheduled.  It is called when ever the
     file descriptor becomes ready. */
  NOTHING_SCHEDULED = -2
  /* Either no task is scheduled (just going into ASYNC mode) or a
     timer event has just gone off and the current state has been
     forced into nothing scheduled. */
};

/* Identify and schedule the next ASYNC task based on scb->async_state
   and scb->buf* (the input FIFO).  A state machine is used to avoid
   the need to make redundant calls into the event-loop - the next
   scheduled task is only changed when needed. */

d1069 1
a1069 108
reschedule (serial_t scb)
{
  if (SERIAL_IS_ASYNC_P (scb))
    {
      int next_state;
      switch (scb->async_state)
	{
	case FD_SCHEDULED:
	  if (scb->bufcnt == 0)
	    next_state = FD_SCHEDULED;
	  else
	    {
	      delete_file_handler (scb->fd);
	      next_state = create_timer (0, push_event, scb);
	    }
	  break;
	case NOTHING_SCHEDULED:
	  if (scb->bufcnt == 0)
	    {
	      add_file_handler (scb->fd, fd_event, scb);
	      next_state = FD_SCHEDULED;
	    }
	  else
	    {
	      next_state = create_timer (0, push_event, scb);
	    }
	  break;
	default: /* TIMER SCHEDULED */
	  if (scb->bufcnt == 0)
	    {
	      delete_timer (scb->async_state);
	      add_file_handler (scb->fd, fd_event, scb);
	      next_state = FD_SCHEDULED;
	    }
	  else
	    next_state = scb->async_state;
	  break;
	}
      if (SERIAL_DEBUG_P (scb))
	{
	  switch (next_state)
	    {
	    case FD_SCHEDULED:
	      if (scb->async_state != FD_SCHEDULED)
		fprintf_unfiltered (gdb_stdlog, "[fd%d->fd-scheduled]\n",
				    scb->fd);
	      break;
	    default: /* TIMER SCHEDULED */
	      if (scb->async_state == FD_SCHEDULED)
		fprintf_unfiltered (gdb_stdlog, "[fd%d->timer-scheduled]\n",
				    scb->fd);
	      break;
	    }
	}
      scb->async_state = next_state;
    }
}

/* FD_EVENT: This is scheduled when the input FIFO is empty (and there
   is no pending error).  As soon as data arrives, it is read into the
   input FIFO and the client notified.  The client should then drain
   the FIFO using readchar().  If the FIFO isn't immediatly emptied,
   push_event() is used to nag the client until it is. */

static void
fd_event (int error, void *context)
{
  serial_t scb = context;
  if (error != 0)
    {
      scb->bufcnt = SERIAL_ERROR;
    }
  else if (scb->bufcnt == 0)
    {
      /* Prime the input FIFO.  The readchar() function is used to
         pull characters out of the buffer.  See also
         generic_readchar(). */
      int nr;
      do
	{
	  nr = read (scb->fd, scb->buf, BUFSIZ);
	}
      while (nr == -1 && errno == EINTR);
      if (nr == 0)
	{
	  scb->bufcnt = SERIAL_EOF;
	}
      else if (nr > 0)
	{
	  scb->bufcnt = nr;
	  scb->bufp = scb->buf;
	}
      else
	{
	  scb->bufcnt = SERIAL_ERROR;
	}
    }
  scb->async_handler (scb, scb->async_context);
  reschedule (scb);
}

/* PUSH_EVENT: The input FIFO is non-empty (or there is a pending
   error).  Nag the client until all the data has been read.  In the
   case of errors, the client will need to close or de-async the
   device before naging stops. */

static void
push_event (void *context)
d1072 1
a1072 4
  scb->async_state = NOTHING_SCHEDULED; /* Timers are one-off */
  scb->async_handler (scb, scb->async_context);
  /* re-schedule */
  reschedule (scb);
a1074 2
/* Put the SERIAL device into/out-of ASYNC mode.  */

d1081 1
a1081 6
      /* Force a re-schedule. */
      scb->async_state = NOTHING_SCHEDULED;
      if (SERIAL_DEBUG_P (scb))
	fprintf_unfiltered (gdb_stdlog, "[fd%d->asynchronous]\n",
			    scb->fd);
      reschedule (scb);
d1085 1
a1085 15
      if (SERIAL_DEBUG_P (scb))
	fprintf_unfiltered (gdb_stdlog, "[fd%d->synchronous]\n",
			    scb->fd);
      /* De-schedule what ever tasks are currently scheduled. */
      switch (scb->async_state)
	{
	case FD_SCHEDULED:
	  delete_file_handler (scb->fd);
	  break;
	NOTHING_SCHEDULED:
	  break;
	default: /* TIMER SCHEDULED */
	  delete_timer (scb->async_state);
	  break;
	}
d1102 4
a1105 1
  ops->write = ser_unix_write;
@


1.1.1.9
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
   Copyright 1992-1994, 1998-2000 Free Software Foundation, Inc.
d84 1
a84 1
static void hardwire_print_tty_state (serial_t, serial_ttystate, struct ui_file *);
d231 1
a231 1
			  struct ui_file *stream)
d1049 1
a1049 1
			      struct ui_file *stream)
@


