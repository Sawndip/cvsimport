head	1.58;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.57
	gdb_7_6-2013-04-26-release:1.57
	gdb_7_6-branch:1.57.0.2
	gdb_7_6-2013-03-12-branchpoint:1.57
	gdb_7_5_1-2012-11-29-release:1.55.2.1
	gdb_7_5-2012-08-17-release:1.55.2.1
	gdb_7_5-branch:1.55.0.2
	gdb_7_5-2012-07-18-branchpoint:1.55
	gdb_7_4_1-2012-04-26-release:1.50.2.1
	gdb_7_4-2012-01-24-release:1.50.2.1
	gdb_7_4-branch:1.50.0.2
	gdb_7_4-2011-12-13-branchpoint:1.50
	gdb_7_3_1-2011-09-04-release:1.47
	gdb_7_3-2011-07-26-release:1.47
	gdb_7_3-branch:1.47.0.2
	gdb_7_3-2011-04-01-branchpoint:1.47
	gdb_7_2-2010-09-02-release:1.43
	gdb_7_2-branch:1.43.0.2
	gdb_7_2-2010-07-07-branchpoint:1.43
	gdb_7_1-2010-03-18-release:1.42
	gdb_7_1-branch:1.42.0.2
	gdb_7_1-2010-02-18-branchpoint:1.42
	gdb_7_0_1-2009-12-22-release:1.41
	gdb_7_0-2009-10-06-release:1.41
	gdb_7_0-branch:1.41.0.4
	gdb_7_0-2009-09-16-branchpoint:1.41
	arc-sim-20090309:1.38
	msnyder-checkpoint-072509-branch:1.41.0.2
	msnyder-checkpoint-072509-branchpoint:1.41
	arc-insight_6_8-branch:1.38.0.16
	arc-insight_6_8-branchpoint:1.38
	insight_6_8-branch:1.38.0.14
	insight_6_8-branchpoint:1.38
	reverse-20081226-branch:1.38.0.12
	reverse-20081226-branchpoint:1.38
	multiprocess-20081120-branch:1.38.0.10
	multiprocess-20081120-branchpoint:1.38
	reverse-20080930-branch:1.38.0.8
	reverse-20080930-branchpoint:1.38
	reverse-20080717-branch:1.38.0.6
	reverse-20080717-branchpoint:1.38
	msnyder-reverse-20080609-branch:1.38.0.4
	msnyder-reverse-20080609-branchpoint:1.38
	drow-reverse-20070409-branch:1.30.0.2
	drow-reverse-20070409-branchpoint:1.30
	gdb_6_8-2008-03-27-release:1.38
	gdb_6_8-branch:1.38.0.2
	gdb_6_8-2008-02-26-branchpoint:1.38
	gdb_6_7_1-2007-10-29-release:1.35
	gdb_6_7-2007-10-10-release:1.35
	gdb_6_7-branch:1.35.0.2
	gdb_6_7-2007-09-07-branchpoint:1.35
	insight_6_6-20070208-release:1.28
	gdb_6_6-2006-12-18-release:1.28
	gdb_6_6-branch:1.28.0.2
	gdb_6_6-2006-11-15-branchpoint:1.28
	insight_6_5-20061003-release:1.26
	gdb-csl-symbian-6_4_50_20060226-12:1.25
	gdb-csl-sourcerygxx-3_4_4-25:1.24
	nickrob-async-20060828-mergepoint:1.28
	gdb-csl-symbian-6_4_50_20060226-11:1.25
	gdb-csl-sourcerygxx-4_1-17:1.25
	gdb-csl-20060226-branch-local-2:1.25
	gdb-csl-sourcerygxx-4_1-14:1.25
	gdb-csl-sourcerygxx-4_1-13:1.25
	gdb-csl-sourcerygxx-4_1-12:1.25
	gdb-csl-sourcerygxx-3_4_4-21:1.25
	gdb_6_5-20060621-release:1.26
	gdb-csl-sourcerygxx-4_1-9:1.25
	gdb-csl-sourcerygxx-4_1-8:1.25
	gdb-csl-sourcerygxx-4_1-7:1.25
	gdb-csl-arm-2006q1-6:1.25
	gdb-csl-sourcerygxx-4_1-6:1.25
	gdb-csl-symbian-6_4_50_20060226-10:1.25
	gdb-csl-symbian-6_4_50_20060226-9:1.25
	gdb-csl-symbian-6_4_50_20060226-8:1.25
	gdb-csl-coldfire-4_1-11:1.25
	gdb-csl-sourcerygxx-3_4_4-19:1.25
	gdb-csl-coldfire-4_1-10:1.25
	gdb_6_5-branch:1.26.0.10
	gdb_6_5-2006-05-14-branchpoint:1.26
	gdb-csl-sourcerygxx-4_1-5:1.25
	nickrob-async-20060513-branch:1.26.0.8
	nickrob-async-20060513-branchpoint:1.26
	gdb-csl-sourcerygxx-4_1-4:1.25
	msnyder-reverse-20060502-branch:1.26.0.6
	msnyder-reverse-20060502-branchpoint:1.26
	gdb-csl-morpho-4_1-4:1.25
	gdb-csl-sourcerygxx-3_4_4-17:1.25
	readline_5_1-import-branch:1.26.0.4
	readline_5_1-import-branchpoint:1.26
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.25
	gdb-csl-symbian-20060226-branch:1.25.0.6
	gdb-csl-symbian-20060226-branchpoint:1.25
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.25
	msnyder-reverse-20060331-branch:1.26.0.2
	msnyder-reverse-20060331-branchpoint:1.26
	gdb-csl-available-20060303-branch:1.25.0.4
	gdb-csl-available-20060303-branchpoint:1.25
	gdb-csl-20060226-branch:1.25.0.2
	gdb-csl-20060226-branchpoint:1.25
	gdb_6_4-20051202-release:1.24
	msnyder-fork-checkpoint-branch:1.24.0.8
	msnyder-fork-checkpoint-branchpoint:1.24
	gdb-csl-gxxpro-6_3-branch:1.24.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.24
	gdb_6_4-branch:1.24.0.4
	gdb_6_4-2005-11-01-branchpoint:1.24
	gdb-csl-arm-20051020-branch:1.24.0.2
	gdb-csl-arm-20051020-branchpoint:1.24
	msnyder-tracepoint-checkpoint-branch:1.23.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.23
	gdb-csl-arm-20050325-2005-q1b:1.22.2.4
	gdb-csl-arm-20050325-2005-q1a:1.22.2.4
	csl-arm-20050325-branch:1.22.0.2
	csl-arm-20050325-branchpoint:1.22
	gdb-post-i18n-errorwarning-20050211:1.22
	gdb-pre-i18n-errorwarning-20050211:1.22
	gdb_6_3-20041109-release:1.21
	gdb_6_3-branch:1.21.0.2
	gdb_6_3-20041019-branchpoint:1.21
	drow_intercu-merge-20040921:1.21
	drow_intercu-merge-20040915:1.21
	jimb-gdb_6_2-e500-branch:1.19.0.76
	jimb-gdb_6_2-e500-branchpoint:1.19
	gdb_6_2-20040730-release:1.19
	gdb_6_2-branch:1.19.0.72
	gdb_6_2-2004-07-10-gmt-branchpoint:1.19
	gdb_6_1_1-20040616-release:1.19
	gdb_6_1-2004-04-05-release:1.19
	drow_intercu-merge-20040402:1.19
	drow_intercu-merge-20040327:1.19
	ezannoni_pie-20040323-branch:1.19.0.70
	ezannoni_pie-20040323-branchpoint:1.19
	cagney_tramp-20040321-mergepoint:1.19
	cagney_tramp-20040309-branch:1.19.0.68
	cagney_tramp-20040309-branchpoint:1.19
	gdb_6_1-branch:1.19.0.66
	gdb_6_1-2004-03-01-gmt-branchpoint:1.19
	drow_intercu-20040221-branch:1.19.0.64
	drow_intercu-20040221-branchpoint:1.19
	cagney_bfdfile-20040213-branch:1.19.0.62
	cagney_bfdfile-20040213-branchpoint:1.19
	drow-cplus-merge-20040208:1.19
	carlton_dictionary-20040126-merge:1.19
	cagney_bigcore-20040122-branch:1.19.0.60
	cagney_bigcore-20040122-branchpoint:1.19
	drow-cplus-merge-20040113:1.19
	drow-cplus-merge-20031224:1.19
	drow-cplus-merge-20031220:1.19
	carlton_dictionary-20031215-merge:1.19
	drow-cplus-merge-20031214:1.19
	carlton-dictionary-20031111-merge:1.19
	gdb_6_0-2003-10-04-release:1.19
	kettenis_sparc-20030918-branch:1.19.0.58
	kettenis_sparc-20030918-branchpoint:1.19
	carlton_dictionary-20030917-merge:1.19
	ezannoni_pie-20030916-branchpoint:1.19
	ezannoni_pie-20030916-branch:1.19.0.56
	cagney_x86i386-20030821-branch:1.19.0.54
	cagney_x86i386-20030821-branchpoint:1.19
	carlton_dictionary-20030805-merge:1.19
	carlton_dictionary-20030627-merge:1.19
	gdb_6_0-branch:1.19.0.52
	gdb_6_0-2003-06-23-branchpoint:1.19
	jimb-ppc64-linux-20030613-branch:1.19.0.50
	jimb-ppc64-linux-20030613-branchpoint:1.19
	cagney_convert-20030606-branch:1.19.0.48
	cagney_convert-20030606-branchpoint:1.19
	cagney_writestrings-20030508-branch:1.19.0.46
	cagney_writestrings-20030508-branchpoint:1.19
	jimb-ppc64-linux-20030528-branch:1.19.0.44
	jimb-ppc64-linux-20030528-branchpoint:1.19
	carlton_dictionary-20030523-merge:1.19
	cagney_fileio-20030521-branch:1.19.0.42
	cagney_fileio-20030521-branchpoint:1.19
	kettenis_i386newframe-20030517-mergepoint:1.19
	jimb-ppc64-linux-20030509-branch:1.19.0.40
	jimb-ppc64-linux-20030509-branchpoint:1.19
	kettenis_i386newframe-20030504-mergepoint:1.19
	carlton_dictionary-20030430-merge:1.19
	kettenis_i386newframe-20030419-branch:1.19.0.38
	kettenis_i386newframe-20030419-branchpoint:1.19
	carlton_dictionary-20030416-merge:1.19
	cagney_frameaddr-20030409-mergepoint:1.19
	kettenis_i386newframe-20030406-branch:1.19.0.36
	kettenis_i386newframe-20030406-branchpoint:1.19
	cagney_frameaddr-20030403-branchpoint:1.19
	cagney_frameaddr-20030403-branch:1.19.0.34
	cagney_framebase-20030330-mergepoint:1.19
	cagney_framebase-20030326-branch:1.19.0.32
	cagney_framebase-20030326-branchpoint:1.19
	cagney_lazyid-20030317-branch:1.19.0.30
	cagney_lazyid-20030317-branchpoint:1.19
	kettenis-i386newframe-20030316-mergepoint:1.19
	offbyone-20030313-branch:1.19.0.28
	offbyone-20030313-branchpoint:1.19
	kettenis-i386newframe-20030308-branch:1.19.0.26
	kettenis-i386newframe-20030308-branchpoint:1.19
	carlton_dictionary-20030305-merge:1.19
	cagney_offbyone-20030303-branch:1.19.0.24
	cagney_offbyone-20030303-branchpoint:1.19
	carlton_dictionary-20030207-merge:1.19
	interps-20030203-mergepoint:1.19
	interps-20030202-branch:1.19.0.22
	interps-20030202-branchpoint:1.19
	cagney-unwind-20030108-branch:1.19.0.20
	cagney-unwind-20030108-branchpoint:1.19
	carlton_dictionary-20021223-merge:1.19
	gdb_5_3-2002-12-12-release:1.19
	carlton_dictionary-20021115-merge:1.19
	kseitz_interps-20021105-merge:1.19
	kseitz_interps-20021103-merge:1.19
	drow-cplus-merge-20021020:1.19
	drow-cplus-merge-20021025:1.19
	carlton_dictionary-20021025-merge:1.19
	carlton_dictionary-20021011-merge:1.19
	drow-cplus-branch:1.19.0.18
	drow-cplus-branchpoint:1.19
	kseitz_interps-20020930-merge:1.19
	carlton_dictionary-20020927-merge:1.19
	carlton_dictionary-branch:1.19.0.16
	carlton_dictionary-20020920-branchpoint:1.19
	gdb_5_3-branch:1.19.0.14
	gdb_5_3-2002-09-04-branchpoint:1.19
	kseitz_interps-20020829-merge:1.19
	cagney_sysregs-20020825-branch:1.19.0.12
	cagney_sysregs-20020825-branchpoint:1.19
	readline_4_3-import-branch:1.19.0.10
	readline_4_3-import-branchpoint:1.19
	gdb_5_2_1-2002-07-23-release:1.19
	kseitz_interps-20020528-branch:1.19.0.8
	kseitz_interps-20020528-branchpoint:1.19
	cagney_regbuf-20020515-branch:1.19.0.6
	cagney_regbuf-20020515-branchpoint:1.19
	jimb-macro-020506-branch:1.19.0.4
	jimb-macro-020506-branchpoint:1.19
	gdb_5_2-2002-04-29-release:1.19
	gdb_5_2-branch:1.19.0.2
	gdb_5_2-2002-03-03-branchpoint:1.19
	gdb_5_1_1-2002-01-24-release:1.11.4.2
	gdb_5_1_0_1-2002-01-03-release:1.11.4.2
	cygnus_cvs_20020108_pre:1.14
	gdb_5_1_0_1-2002-01-03-branchpoint:1.11.4.2
	gdb_5_1_0_1-2002-01-03-branch:1.11.4.2.0.2
	gdb_5_1-2001-11-21-release:1.11.4.2
	gdb_s390-2001-09-26-branch:1.11.0.6
	gdb_s390-2001-09-26-branchpoint:1.11
	gdb_5_1-2001-07-29-branch:1.11.0.4
	gdb_5_1-2001-07-29-branchpoint:1.11
	dberlin-typesystem-branch:1.11.0.2
	dberlin-typesystem-branchpoint:1.11
	gdb-post-ptid_t-2001-05-03:1.10
	gdb-pre-ptid_t-2001-05-03:1.9
	insight-precleanup-2001-01-01:1.7
	gdb-post-protoization-2000-07-29:1.7
	gdb-pre-protoization-2000-07-29:1.7
	gdb-premipsmulti-2000-06-06-branch:1.7.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.7
	gdb-post-params-removal-2000-06-04:1.7
	gdb-pre-params-removal-2000-06-04:1.7
	gdb-post-params-removal-2000-05-28:1.7
	gdb-pre-params-removal-2000-05-28:1.7
	gdb_5_0-2000-05-19-release:1.4.2.2
	gdb_4_18_2-2000-05-18-release:1.4.2.2
	gdb_4_95_1-2000-05-11-snapshot:1.4.2.2
	gdb_4_95_0-2000-04-27-snapshot:1.4.2.2
	gdb_5_0-2000-04-10-branch:1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.4
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.58
date	2013.09.30.11.50.10;	author luisgpm;	state Exp;
branches;
next	1.57;

1.57
date	2013.01.01.06.32.38;	author brobecke;	state Exp;
branches;
next	1.56;

1.56
date	2012.07.30.15.05.43;	author uweigand;	state Exp;
branches;
next	1.55;

1.55
date	2012.07.06.16.49.43;	author jkratoch;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2012.03.21.13.43.54;	author tschwinge;	state Exp;
branches;
next	1.53;

1.53
date	2012.03.08.22.54.30;	author jkratoch;	state Exp;
branches;
next	1.52;

1.52
date	2012.01.04.08.16.56;	author brobecke;	state Exp;
branches;
next	1.51;

1.51
date	2011.12.14.17.20.30;	author palves;	state Exp;
branches;
next	1.50;

1.50
date	2011.10.10.18.47.49;	author uweigand;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2011.10.07.17.15.15;	author palves;	state Exp;
branches;
next	1.48;

1.48
date	2011.06.15.16.39.27;	author uweigand;	state Exp;
branches;
next	1.47;

1.47
date	2011.02.21.15.03.37;	author uweigand;	state Exp;
branches;
next	1.46;

1.46
date	2011.01.30.23.16.33;	author qiyao;	state Exp;
branches;
next	1.45;

1.45
date	2011.01.07.19.36.15;	author msnyder;	state Exp;
branches;
next	1.44;

1.44
date	2011.01.01.15.32.57;	author brobecke;	state Exp;
branches;
next	1.43;

1.43
date	2010.04.12.13.52.43;	author rearnsha;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.01.07.31.29;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2009.04.22.15.14.59;	author kazu;	state Exp;
branches;
next	1.40;

1.40
date	2009.02.23.00.03.48;	author palves;	state Exp;
branches;
next	1.39;

1.39
date	2009.01.03.05.57.50;	author brobecke;	state Exp;
branches;
next	1.38;

1.38
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.37;

1.37
date	2007.10.31.14.15.49;	author uweigand;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.15.19.19.17;	author drow;	state Exp;
branches;
next	1.35;

1.35
date	2007.08.23.18.08.26;	author brobecke;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.09.13.49.20;	author uweigand;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.06.14.34.36;	author uweigand;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.06.14.32.30;	author uweigand;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.25.22.10.08;	author uweigand;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.26.19.20.21;	author drow;	state Exp;
branches;
next	1.29;

1.29
date	2007.01.09.17.58.49;	author drow;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.12.20.46.32;	author drow;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.30.15.57.09;	author drow;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.24.23.08.16;	author drow;	state Exp;
branches
	1.26.8.1;
next	1.25;

1.25
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.24;

1.24
date	2005.09.10.18.11.02;	author drow;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2005.03.29.16.58.23;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.05.15.43.43;	author cagney;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2004.07.24.01.00.19;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.22.01.31.48;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.23.12.36.50;	author rearnsha;	state Exp;
branches
	1.19.64.1;
next	1.18;

1.18
date	2002.02.19.14.28.57;	author rearnsha;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.12.00.58.19;	author rearnsha;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.11.18.34.08;	author rearnsha;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.08.22.14.15;	author msnyder;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.17.20.31.18;	author drow;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.31.15.56.33;	author drow;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.26.15.41.17;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.15.00.03.36;	author kevinb;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.05.04.04.15.24;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.06.19.59.05;	author pb;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.26.23.22.40;	author msnyder;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.20.21.13.19;	author scottb;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.10.21.02.33;	author scottb;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.05.15.38.05;	author scottb;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.02.28.20.51.08;	author scottb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.28.20.17.16;	author scottb;	state Exp;
branches;
next	1.1;

1.1
date	99.12.22.21.45.03;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.55.2.1
date	2012.08.01.12.57.06;	author uweigand;	state Exp;
branches;
next	;

1.50.2.1
date	2012.01.06.04.43.04;	author brobecke;	state Exp;
branches;
next	;

1.26.8.1
date	2006.08.28.07.48.50;	author nickrob;	state Exp;
branches;
next	;

1.24.2.1
date	2005.10.20.03.34.52;	author pbrook;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2005.10.20.03.36.27;	author pbrook;	state Exp;
branches;
next	;

1.22.2.1
date	2005.03.25.21.46.10;	author drow;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2005.03.25.22.20.48;	author drow;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2005.03.29.02.52.04;	author pbrook;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2005.03.30.14.59.29;	author drow;	state Exp;
branches;
next	;

1.19.64.1
date	2004.09.16.17.00.53;	author drow;	state Exp;
branches;
next	;

1.11.4.1
date	2001.10.26.15.44.00;	author drow;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2001.10.31.15.56.28;	author drow;	state Exp;
branches;
next	;

1.4.2.1
date	2000.04.10.21.07.38;	author scottb;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2000.04.20.21.12.11;	author scottb;	state Exp;
branches;
next	;

1.1.1.1
date	99.12.22.21.45.03;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.58
log
@	* aarch64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* aix-thread.c (BUILD_THREAD, BUILD_LWP): Remove.
	Replace BUILD_THREAD with ptid_build.
	Replace BUILD_LWP with ptid_build.
	Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* alphabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* amd64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* amd64bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* arm-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* armnbsd-nat.c: Replace PIDGET with ptid_get_pid.
	* auxv.c: Likewise.
	* breakpoint.c: Likewise.
	* common/ptid.c (ptid_is_pid): Condense check for
	null_ptid and minus_one_ptid.
	(ptid_lwp_p): New function.
	(ptid_tid_p): New function.
	* common/ptid.h: Update comments for accessors.
	(ptid_lwp_p): New prototype.
	(ptid_tid_p): New prototype.
	* defs.h (PIDGET, TIDGET, MERGEPID): Do not define.
	* gcore.c: Replace PIDGET with ptid_get_pid.
	* gdbthread.h: Likewise.
	* gnu-nat.c: Likewise.
	* hppa-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* hppabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* hppanbsd-nat.c: Likewise.
	* i386-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* i386bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* ia64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	* infcmd.c: Likewise.
	* inferior.h: Likewise.
	* inflow.c: Likewise.
	* infrun.c: Likewise.
	* linux-fork.c: Likewise.
	* linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace GET_PID with ptid_get_pid.
	Replace is_lwp with ptid_lwp_p.
	Replace GET_LWP with ptid_get_lwp.
	Replace BUILD_LWP with ptid_build.
@
text
@/* GNU/Linux on ARM native support.
   Copyright (C) 1999-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "inferior.h"
#include "gdbcore.h"
#include "gdb_string.h"
#include "regcache.h"
#include "target.h"
#include "linux-nat.h"
#include "target-descriptions.h"
#include "auxv.h"
#include "observer.h"
#include "gdbthread.h"

#include "arm-tdep.h"
#include "arm-linux-tdep.h"

#include <elf/common.h>
#include <sys/user.h>
#include <sys/ptrace.h>
#include <sys/utsname.h>
#include <sys/procfs.h>

/* Prototypes for supply_gregset etc.  */
#include "gregset.h"

/* Defines ps_err_e, struct ps_prochandle.  */
#include "gdb_proc_service.h"

#ifndef PTRACE_GET_THREAD_AREA
#define PTRACE_GET_THREAD_AREA 22
#endif

#ifndef PTRACE_GETWMMXREGS
#define PTRACE_GETWMMXREGS 18
#define PTRACE_SETWMMXREGS 19
#endif

#ifndef PTRACE_GETVFPREGS
#define PTRACE_GETVFPREGS 27
#define PTRACE_SETVFPREGS 28
#endif

#ifndef PTRACE_GETHBPREGS
#define PTRACE_GETHBPREGS 29
#define PTRACE_SETHBPREGS 30
#endif

/* A flag for whether the WMMX registers are available.  */
static int arm_linux_has_wmmx_registers;

/* The number of 64-bit VFP registers we have (expect this to be 0,
   16, or 32).  */
static int arm_linux_vfp_register_count;

extern int arm_apcs_32;

/* On GNU/Linux, threads are implemented as pseudo-processes, in which
   case we may be tracing more than one process at a time.  In that
   case, inferior_ptid will contain the main process ID and the
   individual thread (process) ID.  get_thread_id () is used to get
   the thread id if it's available, and the process id otherwise.  */

static int
get_thread_id (ptid_t ptid)
{
  int tid = ptid_get_lwp (ptid);
  if (0 == tid)
    tid = ptid_get_pid (ptid);
  return tid;
}

#define GET_THREAD_ID(PTID)	get_thread_id (PTID)

/* Get the value of a particular register from the floating point
   state of the process and store it into regcache.  */

static void
fetch_fpregister (struct regcache *regcache, int regno)
{
  int ret, tid;
  gdb_byte fp[ARM_LINUX_SIZEOF_NWFPE];
  
  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_ptid);

  /* Read the floating point state.  */
  ret = ptrace (PT_GETFPREGS, tid, 0, fp);
  if (ret < 0)
    {
      warning (_("Unable to fetch floating point register."));
      return;
    }

  /* Fetch fpsr.  */
  if (ARM_FPS_REGNUM == regno)
    regcache_raw_supply (regcache, ARM_FPS_REGNUM,
			 fp + NWFPE_FPSR_OFFSET);

  /* Fetch the floating point register.  */
  if (regno >= ARM_F0_REGNUM && regno <= ARM_F7_REGNUM)
    supply_nwfpe_register (regcache, regno, fp);
}

/* Get the whole floating point state of the process and store it
   into regcache.  */

static void
fetch_fpregs (struct regcache *regcache)
{
  int ret, regno, tid;
  gdb_byte fp[ARM_LINUX_SIZEOF_NWFPE];

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_ptid);
  
  /* Read the floating point state.  */
  ret = ptrace (PT_GETFPREGS, tid, 0, fp);
  if (ret < 0)
    {
      warning (_("Unable to fetch the floating point registers."));
      return;
    }

  /* Fetch fpsr.  */
  regcache_raw_supply (regcache, ARM_FPS_REGNUM,
		       fp + NWFPE_FPSR_OFFSET);

  /* Fetch the floating point registers.  */
  for (regno = ARM_F0_REGNUM; regno <= ARM_F7_REGNUM; regno++)
    supply_nwfpe_register (regcache, regno, fp);
}

/* Save a particular register into the floating point state of the
   process using the contents from regcache.  */

static void
store_fpregister (const struct regcache *regcache, int regno)
{
  int ret, tid;
  gdb_byte fp[ARM_LINUX_SIZEOF_NWFPE];

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_ptid);
  
  /* Read the floating point state.  */
  ret = ptrace (PT_GETFPREGS, tid, 0, fp);
  if (ret < 0)
    {
      warning (_("Unable to fetch the floating point registers."));
      return;
    }

  /* Store fpsr.  */
  if (ARM_FPS_REGNUM == regno
      && REG_VALID == regcache_register_status (regcache, ARM_FPS_REGNUM))
    regcache_raw_collect (regcache, ARM_FPS_REGNUM, fp + NWFPE_FPSR_OFFSET);

  /* Store the floating point register.  */
  if (regno >= ARM_F0_REGNUM && regno <= ARM_F7_REGNUM)
    collect_nwfpe_register (regcache, regno, fp);

  ret = ptrace (PTRACE_SETFPREGS, tid, 0, fp);
  if (ret < 0)
    {
      warning (_("Unable to store floating point register."));
      return;
    }
}

/* Save the whole floating point state of the process using
   the contents from regcache.  */

static void
store_fpregs (const struct regcache *regcache)
{
  int ret, regno, tid;
  gdb_byte fp[ARM_LINUX_SIZEOF_NWFPE];

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_ptid);
  
  /* Read the floating point state.  */
  ret = ptrace (PT_GETFPREGS, tid, 0, fp);
  if (ret < 0)
    {
      warning (_("Unable to fetch the floating point registers."));
      return;
    }

  /* Store fpsr.  */
  if (REG_VALID == regcache_register_status (regcache, ARM_FPS_REGNUM))
    regcache_raw_collect (regcache, ARM_FPS_REGNUM, fp + NWFPE_FPSR_OFFSET);

  /* Store the floating point registers.  */
  for (regno = ARM_F0_REGNUM; regno <= ARM_F7_REGNUM; regno++)
    if (REG_VALID == regcache_register_status (regcache, regno))
      collect_nwfpe_register (regcache, regno, fp);

  ret = ptrace (PTRACE_SETFPREGS, tid, 0, fp);
  if (ret < 0)
    {
      warning (_("Unable to store floating point registers."));
      return;
    }
}

/* Fetch a general register of the process and store into
   regcache.  */

static void
fetch_register (struct regcache *regcache, int regno)
{
  int ret, tid;
  elf_gregset_t regs;

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_ptid);
  
  ret = ptrace (PTRACE_GETREGS, tid, 0, &regs);
  if (ret < 0)
    {
      warning (_("Unable to fetch general register."));
      return;
    }

  if (regno >= ARM_A1_REGNUM && regno < ARM_PC_REGNUM)
    regcache_raw_supply (regcache, regno, (char *) &regs[regno]);

  if (ARM_PS_REGNUM == regno)
    {
      if (arm_apcs_32)
        regcache_raw_supply (regcache, ARM_PS_REGNUM,
			     (char *) &regs[ARM_CPSR_GREGNUM]);
      else
        regcache_raw_supply (regcache, ARM_PS_REGNUM,
			     (char *) &regs[ARM_PC_REGNUM]);
    }
    
  if (ARM_PC_REGNUM == regno)
    { 
      regs[ARM_PC_REGNUM] = gdbarch_addr_bits_remove
			      (get_regcache_arch (regcache),
			       regs[ARM_PC_REGNUM]);
      regcache_raw_supply (regcache, ARM_PC_REGNUM,
			   (char *) &regs[ARM_PC_REGNUM]);
    }
}

/* Fetch all general registers of the process and store into
   regcache.  */

static void
fetch_regs (struct regcache *regcache)
{
  int ret, regno, tid;
  elf_gregset_t regs;

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_ptid);
  
  ret = ptrace (PTRACE_GETREGS, tid, 0, &regs);
  if (ret < 0)
    {
      warning (_("Unable to fetch general registers."));
      return;
    }

  for (regno = ARM_A1_REGNUM; regno < ARM_PC_REGNUM; regno++)
    regcache_raw_supply (regcache, regno, (char *) &regs[regno]);

  if (arm_apcs_32)
    regcache_raw_supply (regcache, ARM_PS_REGNUM,
			 (char *) &regs[ARM_CPSR_GREGNUM]);
  else
    regcache_raw_supply (regcache, ARM_PS_REGNUM,
			 (char *) &regs[ARM_PC_REGNUM]);

  regs[ARM_PC_REGNUM] = gdbarch_addr_bits_remove
			  (get_regcache_arch (regcache), regs[ARM_PC_REGNUM]);
  regcache_raw_supply (regcache, ARM_PC_REGNUM,
		       (char *) &regs[ARM_PC_REGNUM]);
}

/* Store all general registers of the process from the values in
   regcache.  */

static void
store_register (const struct regcache *regcache, int regno)
{
  int ret, tid;
  elf_gregset_t regs;
  
  if (REG_VALID != regcache_register_status (regcache, regno))
    return;

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_ptid);
  
  /* Get the general registers from the process.  */
  ret = ptrace (PTRACE_GETREGS, tid, 0, &regs);
  if (ret < 0)
    {
      warning (_("Unable to fetch general registers."));
      return;
    }

  if (regno >= ARM_A1_REGNUM && regno <= ARM_PC_REGNUM)
    regcache_raw_collect (regcache, regno, (char *) &regs[regno]);
  else if (arm_apcs_32 && regno == ARM_PS_REGNUM)
    regcache_raw_collect (regcache, regno,
			 (char *) &regs[ARM_CPSR_GREGNUM]);
  else if (!arm_apcs_32 && regno == ARM_PS_REGNUM)
    regcache_raw_collect (regcache, ARM_PC_REGNUM,
			 (char *) &regs[ARM_PC_REGNUM]);

  ret = ptrace (PTRACE_SETREGS, tid, 0, &regs);
  if (ret < 0)
    {
      warning (_("Unable to store general register."));
      return;
    }
}

static void
store_regs (const struct regcache *regcache)
{
  int ret, regno, tid;
  elf_gregset_t regs;

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_ptid);
  
  /* Fetch the general registers.  */
  ret = ptrace (PTRACE_GETREGS, tid, 0, &regs);
  if (ret < 0)
    {
      warning (_("Unable to fetch general registers."));
      return;
    }

  for (regno = ARM_A1_REGNUM; regno <= ARM_PC_REGNUM; regno++)
    {
      if (REG_VALID == regcache_register_status (regcache, regno))
	regcache_raw_collect (regcache, regno, (char *) &regs[regno]);
    }

  if (arm_apcs_32 && REG_VALID == regcache_register_status (regcache, ARM_PS_REGNUM))
    regcache_raw_collect (regcache, ARM_PS_REGNUM,
			 (char *) &regs[ARM_CPSR_GREGNUM]);

  ret = ptrace (PTRACE_SETREGS, tid, 0, &regs);

  if (ret < 0)
    {
      warning (_("Unable to store general registers."));
      return;
    }
}

/* Fetch all WMMX registers of the process and store into
   regcache.  */

#define IWMMXT_REGS_SIZE (16 * 8 + 6 * 4)

static void
fetch_wmmx_regs (struct regcache *regcache)
{
  char regbuf[IWMMXT_REGS_SIZE];
  int ret, regno, tid;

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_ptid);

  ret = ptrace (PTRACE_GETWMMXREGS, tid, 0, regbuf);
  if (ret < 0)
    {
      warning (_("Unable to fetch WMMX registers."));
      return;
    }

  for (regno = 0; regno < 16; regno++)
    regcache_raw_supply (regcache, regno + ARM_WR0_REGNUM,
			 &regbuf[regno * 8]);

  for (regno = 0; regno < 2; regno++)
    regcache_raw_supply (regcache, regno + ARM_WCSSF_REGNUM,
			 &regbuf[16 * 8 + regno * 4]);

  for (regno = 0; regno < 4; regno++)
    regcache_raw_supply (regcache, regno + ARM_WCGR0_REGNUM,
			 &regbuf[16 * 8 + 2 * 4 + regno * 4]);
}

static void
store_wmmx_regs (const struct regcache *regcache)
{
  char regbuf[IWMMXT_REGS_SIZE];
  int ret, regno, tid;

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_ptid);

  ret = ptrace (PTRACE_GETWMMXREGS, tid, 0, regbuf);
  if (ret < 0)
    {
      warning (_("Unable to fetch WMMX registers."));
      return;
    }

  for (regno = 0; regno < 16; regno++)
    if (REG_VALID == regcache_register_status (regcache,
					       regno + ARM_WR0_REGNUM))
      regcache_raw_collect (regcache, regno + ARM_WR0_REGNUM,
			    &regbuf[regno * 8]);

  for (regno = 0; regno < 2; regno++)
    if (REG_VALID == regcache_register_status (regcache,
					       regno + ARM_WCSSF_REGNUM))
      regcache_raw_collect (regcache, regno + ARM_WCSSF_REGNUM,
			    &regbuf[16 * 8 + regno * 4]);

  for (regno = 0; regno < 4; regno++)
    if (REG_VALID == regcache_register_status (regcache,
					       regno + ARM_WCGR0_REGNUM))
      regcache_raw_collect (regcache, regno + ARM_WCGR0_REGNUM,
			    &regbuf[16 * 8 + 2 * 4 + regno * 4]);

  ret = ptrace (PTRACE_SETWMMXREGS, tid, 0, regbuf);

  if (ret < 0)
    {
      warning (_("Unable to store WMMX registers."));
      return;
    }
}

/* Fetch and store VFP Registers.  The kernel object has space for 32
   64-bit registers, and the FPSCR.  This is even when on a VFPv2 or
   VFPv3D16 target.  */
#define VFP_REGS_SIZE (32 * 8 + 4)

static void
fetch_vfp_regs (struct regcache *regcache)
{
  char regbuf[VFP_REGS_SIZE];
  int ret, regno, tid;

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_ptid);

  ret = ptrace (PTRACE_GETVFPREGS, tid, 0, regbuf);
  if (ret < 0)
    {
      warning (_("Unable to fetch VFP registers."));
      return;
    }

  for (regno = 0; regno < arm_linux_vfp_register_count; regno++)
    regcache_raw_supply (regcache, regno + ARM_D0_REGNUM,
			 (char *) regbuf + regno * 8);

  regcache_raw_supply (regcache, ARM_FPSCR_REGNUM,
		       (char *) regbuf + 32 * 8);
}

static void
store_vfp_regs (const struct regcache *regcache)
{
  char regbuf[VFP_REGS_SIZE];
  int ret, regno, tid;

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_ptid);

  ret = ptrace (PTRACE_GETVFPREGS, tid, 0, regbuf);
  if (ret < 0)
    {
      warning (_("Unable to fetch VFP registers (for update)."));
      return;
    }

  for (regno = 0; regno < arm_linux_vfp_register_count; regno++)
    regcache_raw_collect (regcache, regno + ARM_D0_REGNUM,
			  (char *) regbuf + regno * 8);

  regcache_raw_collect (regcache, ARM_FPSCR_REGNUM,
			(char *) regbuf + 32 * 8);

  ret = ptrace (PTRACE_SETVFPREGS, tid, 0, regbuf);

  if (ret < 0)
    {
      warning (_("Unable to store VFP registers."));
      return;
    }
}

/* Fetch registers from the child process.  Fetch all registers if
   regno == -1, otherwise fetch all general registers or all floating
   point registers depending upon the value of regno.  */

static void
arm_linux_fetch_inferior_registers (struct target_ops *ops,
				    struct regcache *regcache, int regno)
{
  if (-1 == regno)
    {
      fetch_regs (regcache);
      fetch_fpregs (regcache);
      if (arm_linux_has_wmmx_registers)
	fetch_wmmx_regs (regcache);
      if (arm_linux_vfp_register_count > 0)
	fetch_vfp_regs (regcache);
    }
  else 
    {
      if (regno < ARM_F0_REGNUM || regno == ARM_PS_REGNUM)
        fetch_register (regcache, regno);
      else if (regno >= ARM_F0_REGNUM && regno <= ARM_FPS_REGNUM)
        fetch_fpregister (regcache, regno);
      else if (arm_linux_has_wmmx_registers
	       && regno >= ARM_WR0_REGNUM && regno <= ARM_WCGR7_REGNUM)
	fetch_wmmx_regs (regcache);
      else if (arm_linux_vfp_register_count > 0
	       && regno >= ARM_D0_REGNUM
	       && regno <= ARM_D0_REGNUM + arm_linux_vfp_register_count)
	fetch_vfp_regs (regcache);
    }
}

/* Store registers back into the inferior.  Store all registers if
   regno == -1, otherwise store all general registers or all floating
   point registers depending upon the value of regno.  */

static void
arm_linux_store_inferior_registers (struct target_ops *ops,
				    struct regcache *regcache, int regno)
{
  if (-1 == regno)
    {
      store_regs (regcache);
      store_fpregs (regcache);
      if (arm_linux_has_wmmx_registers)
	store_wmmx_regs (regcache);
      if (arm_linux_vfp_register_count > 0)
	store_vfp_regs (regcache);
    }
  else
    {
      if (regno < ARM_F0_REGNUM || regno == ARM_PS_REGNUM)
        store_register (regcache, regno);
      else if ((regno >= ARM_F0_REGNUM) && (regno <= ARM_FPS_REGNUM))
        store_fpregister (regcache, regno);
      else if (arm_linux_has_wmmx_registers
	       && regno >= ARM_WR0_REGNUM && regno <= ARM_WCGR7_REGNUM)
	store_wmmx_regs (regcache);
      else if (arm_linux_vfp_register_count > 0
	       && regno >= ARM_D0_REGNUM
	       && regno <= ARM_D0_REGNUM + arm_linux_vfp_register_count)
	store_vfp_regs (regcache);
    }
}

/* Wrapper functions for the standard regset handling, used by
   thread debugging.  */

void
fill_gregset (const struct regcache *regcache,	
	      gdb_gregset_t *gregsetp, int regno)
{
  arm_linux_collect_gregset (NULL, regcache, regno, gregsetp, 0);
}

void
supply_gregset (struct regcache *regcache, const gdb_gregset_t *gregsetp)
{
  arm_linux_supply_gregset (NULL, regcache, -1, gregsetp, 0);
}

void
fill_fpregset (const struct regcache *regcache,
	       gdb_fpregset_t *fpregsetp, int regno)
{
  arm_linux_collect_nwfpe (NULL, regcache, regno, fpregsetp, 0);
}

/* Fill GDB's register array with the floating-point register values
   in *fpregsetp.  */

void
supply_fpregset (struct regcache *regcache, const gdb_fpregset_t *fpregsetp)
{
  arm_linux_supply_nwfpe (NULL, regcache, -1, fpregsetp, 0);
}

/* Fetch the thread-local storage pointer for libthread_db.  */

ps_err_e
ps_get_thread_area (const struct ps_prochandle *ph,
                    lwpid_t lwpid, int idx, void **base)
{
  if (ptrace (PTRACE_GET_THREAD_AREA, lwpid, NULL, base) != 0)
    return PS_ERR;

  /* IDX is the bias from the thread pointer to the beginning of the
     thread descriptor.  It has to be subtracted due to implementation
     quirks in libthread_db.  */
  *base = (void *) ((char *)*base - idx);

  return PS_OK;
}

static const struct target_desc *
arm_linux_read_description (struct target_ops *ops)
{
  CORE_ADDR arm_hwcap = 0;
  arm_linux_has_wmmx_registers = 0;
  arm_linux_vfp_register_count = 0;

  if (target_auxv_search (ops, AT_HWCAP, &arm_hwcap) != 1)
    {
      return NULL;
    }

  if (arm_hwcap & HWCAP_IWMMXT)
    {
      arm_linux_has_wmmx_registers = 1;
      return tdesc_arm_with_iwmmxt;
    }

  if (arm_hwcap & HWCAP_VFP)
    {
      int pid;
      char *buf;
      const struct target_desc * result = NULL;

      /* NEON implies VFPv3-D32 or no-VFP unit.  Say that we only support
	 Neon with VFPv3-D32.  */
      if (arm_hwcap & HWCAP_NEON)
	{
	  arm_linux_vfp_register_count = 32;
	  result = tdesc_arm_with_neon;
	}
      else if ((arm_hwcap & (HWCAP_VFPv3 | HWCAP_VFPv3D16)) == HWCAP_VFPv3)
	{
	  arm_linux_vfp_register_count = 32;
	  result = tdesc_arm_with_vfpv3;
	}
      else
	{
	  arm_linux_vfp_register_count = 16;
	  result = tdesc_arm_with_vfpv2;
	}

      /* Now make sure that the kernel supports reading these
	 registers.  Support was added in 2.6.30.  */
      pid = ptid_get_lwp (inferior_ptid);
      errno = 0;
      buf = alloca (VFP_REGS_SIZE);
      if (ptrace (PTRACE_GETVFPREGS, pid, 0, buf) < 0
	  && errno == EIO)
	result = NULL;

      return result;
    }

  return NULL;
}

/* Information describing the hardware breakpoint capabilities.  */
struct arm_linux_hwbp_cap
{
  gdb_byte arch;
  gdb_byte max_wp_length;
  gdb_byte wp_count;
  gdb_byte bp_count;
};

/* Get hold of the Hardware Breakpoint information for the target we are
   attached to.  Returns NULL if the kernel doesn't support Hardware 
   breakpoints at all, or a pointer to the information structure.  */
static const struct arm_linux_hwbp_cap *
arm_linux_get_hwbp_cap (void)
{
  /* The info structure we return.  */
  static struct arm_linux_hwbp_cap info;

  /* Is INFO in a good state?  -1 means that no attempt has been made to
     initialize INFO; 0 means an attempt has been made, but it failed; 1
     means INFO is in an initialized state.  */
  static int available = -1;

  if (available == -1)
    {
      int tid;
      unsigned int val;

      tid = GET_THREAD_ID (inferior_ptid);
      if (ptrace (PTRACE_GETHBPREGS, tid, 0, &val) < 0)
	available = 0;
      else
	{
	  info.arch = (gdb_byte)((val >> 24) & 0xff);
	  info.max_wp_length = (gdb_byte)((val >> 16) & 0xff);
	  info.wp_count = (gdb_byte)((val >> 8) & 0xff);
	  info.bp_count = (gdb_byte)(val & 0xff);
	  available = (info.arch != 0);
	}
    }

  return available == 1 ? &info : NULL;
}

/* How many hardware breakpoints are available?  */
static int
arm_linux_get_hw_breakpoint_count (void)
{
  const struct arm_linux_hwbp_cap *cap = arm_linux_get_hwbp_cap ();
  return cap != NULL ? cap->bp_count : 0;
}

/* How many hardware watchpoints are available?  */
static int
arm_linux_get_hw_watchpoint_count (void)
{
  const struct arm_linux_hwbp_cap *cap = arm_linux_get_hwbp_cap ();
  return cap != NULL ? cap->wp_count : 0;
}

/* Have we got a free break-/watch-point available for use?  Returns -1 if
   there is not an appropriate resource available, otherwise returns 1.  */
static int
arm_linux_can_use_hw_breakpoint (int type, int cnt, int ot)
{
  if (type == bp_hardware_watchpoint || type == bp_read_watchpoint
      || type == bp_access_watchpoint || type == bp_watchpoint)
    {
      if (cnt + ot > arm_linux_get_hw_watchpoint_count ())
	return -1;
    }
  else if (type == bp_hardware_breakpoint)
    {
      if (cnt > arm_linux_get_hw_breakpoint_count ())
	return -1;
    }
  else
    gdb_assert (FALSE);

  return 1;
}

/* Enum describing the different types of ARM hardware break-/watch-points.  */
typedef enum
{
  arm_hwbp_break = 0,
  arm_hwbp_load = 1,
  arm_hwbp_store = 2,
  arm_hwbp_access = 3
} arm_hwbp_type;

/* Type describing an ARM Hardware Breakpoint Control register value.  */
typedef unsigned int arm_hwbp_control_t;

/* Structure used to keep track of hardware break-/watch-points.  */
struct arm_linux_hw_breakpoint
{
  /* Address to break on, or being watched.  */
  unsigned int address;
  /* Control register for break-/watch- point.  */
  arm_hwbp_control_t control;
};

/* Structure containing arrays of the break and watch points which are have
   active in each thread.

   The Linux ptrace interface to hardware break-/watch-points presents the 
   values in a vector centred around 0 (which is used fo generic information).
   Positive indicies refer to breakpoint addresses/control registers, negative
   indices to watchpoint addresses/control registers.

   The Linux vector is indexed as follows:
      -((i << 1) + 2): Control register for watchpoint i.
      -((i << 1) + 1): Address register for watchpoint i.
                    0: Information register.
       ((i << 1) + 1): Address register for breakpoint i.
       ((i << 1) + 2): Control register for breakpoint i.

   This structure is used as a per-thread cache of the state stored by the 
   kernel, so that we don't need to keep calling into the kernel to find a 
   free breakpoint.

   We treat break-/watch-points with their enable bit clear as being deleted.
   */
typedef struct arm_linux_thread_points
{
  /* Thread ID.  */
  int tid;
  /* Breakpoints for thread.  */
  struct arm_linux_hw_breakpoint *bpts;
  /* Watchpoint for threads.  */
  struct arm_linux_hw_breakpoint *wpts;
} *arm_linux_thread_points_p;
DEF_VEC_P (arm_linux_thread_points_p);

/* Vector of hardware breakpoints for each thread.  */
VEC(arm_linux_thread_points_p) *arm_threads = NULL;

/* Find the list of hardware break-/watch-points for a thread with id TID.
   If no list exists for TID we return NULL if ALLOC_NEW is 0, otherwise we
   create a new list and return that.  */
static struct arm_linux_thread_points *
arm_linux_find_breakpoints_by_tid (int tid, int alloc_new)
{
  int i;
  struct arm_linux_thread_points *t;

  for (i = 0; VEC_iterate (arm_linux_thread_points_p, arm_threads, i, t); ++i)
    {
      if (t->tid == tid)
	return t;
    }

  t = NULL;

  if (alloc_new)
    {
      t = xmalloc (sizeof (struct arm_linux_thread_points));
      t->tid = tid;
      t->bpts = xzalloc (arm_linux_get_hw_breakpoint_count ()
			 * sizeof (struct arm_linux_hw_breakpoint));
      t->wpts = xzalloc (arm_linux_get_hw_watchpoint_count ()
			 * sizeof (struct arm_linux_hw_breakpoint));
      VEC_safe_push (arm_linux_thread_points_p, arm_threads, t);
    }

  return t;
}

/* Initialize an ARM hardware break-/watch-point control register value.
   BYTE_ADDRESS_SELECT is the mask of bytes to trigger on; HWBP_TYPE is the 
   type of break-/watch-point; ENABLE indicates whether the point is enabled.
   */
static arm_hwbp_control_t 
arm_hwbp_control_initialize (unsigned byte_address_select,
			     arm_hwbp_type hwbp_type,
			     int enable)
{
  gdb_assert ((byte_address_select & ~0xffU) == 0);
  gdb_assert (hwbp_type != arm_hwbp_break 
	      || ((byte_address_select & 0xfU) != 0));

  return (byte_address_select << 5) | (hwbp_type << 3) | (3 << 1) | enable;
}

/* Does the breakpoint control value CONTROL have the enable bit set?  */
static int
arm_hwbp_control_is_enabled (arm_hwbp_control_t control)
{
  return control & 0x1;
}

/* Change a breakpoint control word so that it is in the disabled state.  */
static arm_hwbp_control_t
arm_hwbp_control_disable (arm_hwbp_control_t control)
{
  return control & ~0x1;
}

/* Initialise the hardware breakpoint structure P.  The breakpoint will be
   enabled, and will point to the placed address of BP_TGT.  */
static void
arm_linux_hw_breakpoint_initialize (struct gdbarch *gdbarch,
				    struct bp_target_info *bp_tgt,
				    struct arm_linux_hw_breakpoint *p)
{
  unsigned mask;
  CORE_ADDR address = bp_tgt->placed_address;

  /* We have to create a mask for the control register which says which bits
     of the word pointed to by address to break on.  */
  if (arm_pc_is_thumb (gdbarch, address))
    {
      mask = 0x3;
      address &= ~1;
    }
  else
    {
      mask = 0xf;
      address &= ~3;
    }

  p->address = (unsigned int) address;
  p->control = arm_hwbp_control_initialize (mask, arm_hwbp_break, 1);
}

/* Get the ARM hardware breakpoint type from the RW value we're given when
   asked to set a watchpoint.  */
static arm_hwbp_type 
arm_linux_get_hwbp_type (int rw)
{
  if (rw == hw_read)
    return arm_hwbp_load;
  else if (rw == hw_write)
    return arm_hwbp_store;
  else
    return arm_hwbp_access;
}

/* Initialize the hardware breakpoint structure P for a watchpoint at ADDR
   to LEN.  The type of watchpoint is given in RW.  */
static void
arm_linux_hw_watchpoint_initialize (CORE_ADDR addr, int len, int rw,
				    struct arm_linux_hw_breakpoint *p)
{
  const struct arm_linux_hwbp_cap *cap = arm_linux_get_hwbp_cap ();
  unsigned mask;

  gdb_assert (cap != NULL);
  gdb_assert (cap->max_wp_length != 0);

  mask = (1 << len) - 1;

  p->address = (unsigned int) addr;
  p->control = arm_hwbp_control_initialize (mask, 
					    arm_linux_get_hwbp_type (rw), 1);
}

/* Are two break-/watch-points equal?  */
static int
arm_linux_hw_breakpoint_equal (const struct arm_linux_hw_breakpoint *p1,
			       const struct arm_linux_hw_breakpoint *p2)
{
  return p1->address == p2->address && p1->control == p2->control;
}

/* Insert the hardware breakpoint (WATCHPOINT = 0) or watchpoint (WATCHPOINT
   =1) BPT for thread TID.  */
static void
arm_linux_insert_hw_breakpoint1 (const struct arm_linux_hw_breakpoint* bpt, 
				int tid, int watchpoint)
{
  struct arm_linux_thread_points *t = arm_linux_find_breakpoints_by_tid (tid, 1);
  gdb_byte count, i;
  struct arm_linux_hw_breakpoint* bpts;
  int dir;

  gdb_assert (t != NULL);

  if (watchpoint)
    {
      count = arm_linux_get_hw_watchpoint_count ();
      bpts = t->wpts;
      dir = -1;
    }
  else
    {
      count = arm_linux_get_hw_breakpoint_count ();
      bpts = t->bpts;
      dir = 1;
    }

  for (i = 0; i < count; ++i)
    if (!arm_hwbp_control_is_enabled (bpts[i].control))
      {
	errno = 0;
	if (ptrace (PTRACE_SETHBPREGS, tid, dir * ((i << 1) + 1), 
		    &bpt->address) < 0)
	  perror_with_name (_("Unexpected error setting breakpoint address"));
	if (ptrace (PTRACE_SETHBPREGS, tid, dir * ((i << 1) + 2), 
		    &bpt->control) < 0)
	  perror_with_name (_("Unexpected error setting breakpoint"));

	memcpy (bpts + i, bpt, sizeof (struct arm_linux_hw_breakpoint));
	break;
      }

  gdb_assert (i != count);
}

/* Remove the hardware breakpoint (WATCHPOINT = 0) or watchpoint
   (WATCHPOINT = 1) BPT for thread TID.  */
static void
arm_linux_remove_hw_breakpoint1 (const struct arm_linux_hw_breakpoint *bpt, 
				 int tid, int watchpoint)
{
  struct arm_linux_thread_points *t = arm_linux_find_breakpoints_by_tid (tid, 0);
  gdb_byte count, i;
  struct arm_linux_hw_breakpoint *bpts;
  int dir;

  gdb_assert (t != NULL);

  if (watchpoint)
    {
      count = arm_linux_get_hw_watchpoint_count ();
      bpts = t->wpts;
      dir = -1;
    }
  else
    {
      count = arm_linux_get_hw_breakpoint_count ();
      bpts = t->bpts;
      dir = 1;
    }

  for (i = 0; i < count; ++i)
    if (arm_linux_hw_breakpoint_equal (bpt, bpts + i))
      {
	errno = 0;
	bpts[i].control = arm_hwbp_control_disable (bpts[i].control);
	if (ptrace (PTRACE_SETHBPREGS, tid, dir * ((i << 1) + 2), 
		    &bpts[i].control) < 0)
	  perror_with_name (_("Unexpected error clearing breakpoint"));
	break;
      }

  gdb_assert (i != count);
}

/* Insert a Hardware breakpoint.  */
static int
arm_linux_insert_hw_breakpoint (struct gdbarch *gdbarch, 
				struct bp_target_info *bp_tgt)
{
  struct lwp_info *lp;
  struct arm_linux_hw_breakpoint p;

  if (arm_linux_get_hw_breakpoint_count () == 0)
    return -1;

  arm_linux_hw_breakpoint_initialize (gdbarch, bp_tgt, &p);
  ALL_LWPS (lp)
    arm_linux_insert_hw_breakpoint1 (&p, ptid_get_lwp (lp->ptid), 0);

  return 0;
}

/* Remove a hardware breakpoint.  */
static int
arm_linux_remove_hw_breakpoint (struct gdbarch *gdbarch, 
				struct bp_target_info *bp_tgt)
{
  struct lwp_info *lp;
  struct arm_linux_hw_breakpoint p;

  if (arm_linux_get_hw_breakpoint_count () == 0)
    return -1;

  arm_linux_hw_breakpoint_initialize (gdbarch, bp_tgt, &p);
  ALL_LWPS (lp)
    arm_linux_remove_hw_breakpoint1 (&p, ptid_get_lwp (lp->ptid), 0);

  return 0;
}

/* Are we able to use a hardware watchpoint for the LEN bytes starting at 
   ADDR?  */
static int
arm_linux_region_ok_for_hw_watchpoint (CORE_ADDR addr, int len)
{
  const struct arm_linux_hwbp_cap *cap = arm_linux_get_hwbp_cap ();
  CORE_ADDR max_wp_length, aligned_addr;

  /* Can not set watchpoints for zero or negative lengths.  */
  if (len <= 0)
    return 0;

  /* Need to be able to use the ptrace interface.  */
  if (cap == NULL || cap->wp_count == 0)
    return 0;

  /* Test that the range [ADDR, ADDR + LEN) fits into the largest address
     range covered by a watchpoint.  */
  max_wp_length = (CORE_ADDR)cap->max_wp_length;
  aligned_addr = addr & ~(max_wp_length - 1);

  if (aligned_addr + max_wp_length < addr + len)
    return 0;

  /* The current ptrace interface can only handle watchpoints that are a
     power of 2.  */
  if ((len & (len - 1)) != 0)
    return 0;

  /* All tests passed so we must be able to set a watchpoint.  */
  return 1;
}

/* Insert a Hardware breakpoint.  */
static int
arm_linux_insert_watchpoint (CORE_ADDR addr, int len, int rw,
			     struct expression *cond)
{
  struct lwp_info *lp;
  struct arm_linux_hw_breakpoint p;

  if (arm_linux_get_hw_watchpoint_count () == 0)
    return -1;

  arm_linux_hw_watchpoint_initialize (addr, len, rw, &p);
  ALL_LWPS (lp)
    arm_linux_insert_hw_breakpoint1 (&p, ptid_get_lwp (lp->ptid), 1);

  return 0;
}

/* Remove a hardware breakpoint.  */
static int
arm_linux_remove_watchpoint (CORE_ADDR addr, int len, int rw,
			     struct expression *cond)
{
  struct lwp_info *lp;
  struct arm_linux_hw_breakpoint p;

  if (arm_linux_get_hw_watchpoint_count () == 0)
    return -1;

  arm_linux_hw_watchpoint_initialize (addr, len, rw, &p);
  ALL_LWPS (lp)
    arm_linux_remove_hw_breakpoint1 (&p, ptid_get_lwp (lp->ptid), 1);

  return 0;
}

/* What was the data address the target was stopped on accessing.  */
static int
arm_linux_stopped_data_address (struct target_ops *target, CORE_ADDR *addr_p)
{
  siginfo_t siginfo;
  int slot;

  if (!linux_nat_get_siginfo (inferior_ptid, &siginfo))
    return 0;

  /* This must be a hardware breakpoint.  */
  if (siginfo.si_signo != SIGTRAP
      || (siginfo.si_code & 0xffff) != 0x0004 /* TRAP_HWBKPT */)
    return 0;

  /* We must be able to set hardware watchpoints.  */
  if (arm_linux_get_hw_watchpoint_count () == 0)
    return 0;

  slot = siginfo.si_errno;

  /* If we are in a positive slot then we're looking at a breakpoint and not
     a watchpoint.  */
  if (slot >= 0)
    return 0;

  *addr_p = (CORE_ADDR) (uintptr_t) siginfo.si_addr;
  return 1;
}

/* Has the target been stopped by hitting a watchpoint?  */
static int
arm_linux_stopped_by_watchpoint (void)
{
  CORE_ADDR addr;
  return arm_linux_stopped_data_address (&current_target, &addr);
}

static int
arm_linux_watchpoint_addr_within_range (struct target_ops *target,
					CORE_ADDR addr,
					CORE_ADDR start, int length)
{
  return start <= addr && start + length - 1 >= addr;
}

/* Handle thread creation.  We need to copy the breakpoints and watchpoints
   in the parent thread to the child thread.  */
static void
arm_linux_new_thread (struct lwp_info *lp)
{
  int tid = ptid_get_lwp (lp->ptid);
  const struct arm_linux_hwbp_cap *info = arm_linux_get_hwbp_cap ();

  if (info != NULL)
    {
      int i;
      struct arm_linux_thread_points *p;
      struct arm_linux_hw_breakpoint *bpts;

      if (VEC_empty (arm_linux_thread_points_p, arm_threads))
	return;

      /* Get a list of breakpoints from any thread. */
      p = VEC_last (arm_linux_thread_points_p, arm_threads);

      /* Copy that thread's breakpoints and watchpoints to the new thread. */
      for (i = 0; i < info->bp_count; i++)
	if (arm_hwbp_control_is_enabled (p->bpts[i].control))
	  arm_linux_insert_hw_breakpoint1 (p->bpts + i, tid, 0);
      for (i = 0; i < info->wp_count; i++)
	if (arm_hwbp_control_is_enabled (p->wpts[i].control))
	  arm_linux_insert_hw_breakpoint1 (p->wpts + i, tid, 1);
    }
}

/* Handle thread exit.  Tidy up the memory that has been allocated for the
   thread.  */
static void
arm_linux_thread_exit (struct thread_info *tp, int silent)
{
  const struct arm_linux_hwbp_cap *info = arm_linux_get_hwbp_cap ();

  if (info != NULL)
    {
      int i;
      int tid = ptid_get_lwp (tp->ptid);
      struct arm_linux_thread_points *t = NULL, *p;

      for (i = 0; 
	   VEC_iterate (arm_linux_thread_points_p, arm_threads, i, p); i++)
	{
	  if (p->tid == tid)
	    {
	      t = p;
	      break;
	    }
	}

      if (t == NULL)
	return;

      VEC_unordered_remove (arm_linux_thread_points_p, arm_threads, i);

      xfree (t->bpts);
      xfree (t->wpts);
      xfree (t);
    }
}

void _initialize_arm_linux_nat (void);

void
_initialize_arm_linux_nat (void)
{
  struct target_ops *t;

  /* Fill in the generic GNU/Linux methods.  */
  t = linux_target ();

  /* Add our register access methods.  */
  t->to_fetch_registers = arm_linux_fetch_inferior_registers;
  t->to_store_registers = arm_linux_store_inferior_registers;

  /* Add our hardware breakpoint and watchpoint implementation.  */
  t->to_can_use_hw_breakpoint = arm_linux_can_use_hw_breakpoint;
  t->to_insert_hw_breakpoint = arm_linux_insert_hw_breakpoint;
  t->to_remove_hw_breakpoint = arm_linux_remove_hw_breakpoint;
  t->to_region_ok_for_hw_watchpoint = arm_linux_region_ok_for_hw_watchpoint;
  t->to_insert_watchpoint = arm_linux_insert_watchpoint;
  t->to_remove_watchpoint = arm_linux_remove_watchpoint;
  t->to_stopped_by_watchpoint = arm_linux_stopped_by_watchpoint;
  t->to_stopped_data_address = arm_linux_stopped_data_address;
  t->to_watchpoint_addr_within_range = arm_linux_watchpoint_addr_within_range;

  t->to_read_description = arm_linux_read_description;

  /* Register the target.  */
  linux_nat_add_target (t);

  /* Handle thread creation and exit */
  observer_attach_thread_exit (arm_linux_thread_exit);
  linux_nat_set_new_thread (t, arm_linux_new_thread);
}
@


1.57
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d83 1
a83 1
  int tid = TIDGET (ptid);
d85 1
a85 1
    tid = PIDGET (ptid);
d674 1
a674 1
      pid = GET_LWP (inferior_ptid);
d1050 1
a1050 1
    arm_linux_insert_hw_breakpoint1 (&p, TIDGET (lp->ptid), 0);
d1068 1
a1068 1
    arm_linux_remove_hw_breakpoint1 (&p, TIDGET (lp->ptid), 0);
d1119 1
a1119 1
    arm_linux_insert_hw_breakpoint1 (&p, TIDGET (lp->ptid), 1);
d1137 1
a1137 1
    arm_linux_remove_hw_breakpoint1 (&p, TIDGET (lp->ptid), 1);
d1193 1
a1193 1
  int tid = TIDGET (lp->ptid);
d1228 1
a1228 1
      int tid = TIDGET (tp->ptid);
@


1.56
log
@ChangeLog:

	* arm-linux-nat.c (arm_linux_hw_breakpoint_initialize): Do not
	attempt to 4-byte-align HW breakpoint addresses for Thumb.

gdbserver/ChangeLog:

	* linux-arm-low.c (arm_linux_hw_point_initialize): Do not attempt
	to 4-byte-align HW breakpoint addresses for Thumb.
@
text
@d2 1
a2 1
   Copyright (C) 1999-2002, 2004-2012 Free Software Foundation, Inc.
@


1.55
log
@gdb/
	Code cleanup for the next patch.
	* arm-linux-nat.c (arm_linux_stopped_data_address): Change variable
	siginfo_p to siginfo, update its users incl. the linux_nat_get_siginfo
	call for it.
	* ia64-linux-nat.c (ia64_linux_stopped_data_address): Likewise.
	(ia64_linux_stopped_data_address):
	* linux-nat.c (linux_nat_get_siginfo): Add parameter siginfo, change
	the return value.
	* linux-nat.h (linux_nat_get_siginfo): Likewise.
	* ppc-linux-nat.c (ppc_linux_stopped_data_address): Change variable
	siginfo_p to siginfo, update its users incl. the linux_nat_get_siginfo
	call for it.
@
text
@d899 4
a902 1
    mask = 0x3 << (address & 2);
d904 4
a907 1
    mask = 0xf;
d909 1
a909 1
  p->address = (unsigned int) (address & ~3);
@


1.55.2.1
log
@ChangeLog:

	* arm-linux-nat.c (arm_linux_hw_breakpoint_initialize): Do not
	attempt to 4-byte-align HW breakpoint addresses for Thumb.

gdbserver/ChangeLog:

	* linux-arm-low.c (arm_linux_hw_point_initialize): Do not attempt
	to 4-byte-align HW breakpoint addresses for Thumb.
@
text
@d899 1
a899 4
    {
      mask = 0x3;
      address &= ~1;
    }
d901 1
a901 4
    {
      mask = 0xf;
      address &= ~3;
    }
d903 1
a903 1
  p->address = (unsigned int) address;
@


1.54
log
@struct siginfo vs. siginfo_t

gdb/
	* amd64-linux-nat.c (amd64_linux_siginfo_fixup): Use siginfo_t instead
	of struct siginfo.
	* arm-linux-nat.c (arm_linux_stopped_data_address): Likewise.
	* ia64-linux-nat.c (ia64_linux_stopped_data_address): Likewise.
	* linux-nat.c (linux_nat_siginfo_fixup, siginfo_fixup)
	(linux_xfer_siginfo, linux_nat_set_siginfo_fixup)
	(linux_nat_get_siginfo): Likewise.
	* linux-nat.h (struct lwp_info, linux_nat_set_siginfo_fixup)
	(linux_nat_get_siginfo): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* ppc-linux-nat.c (ppc_linux_stopped_data_address): Likewise.
	* procfs.c (gdb_siginfo_t): Likewise.

gdbserver/
	* linux-arm-low.c (arm_stopped_by_watchpoint): Use siginfo_t instead of
	struct siginfo.
	* linux-low.c (siginfo_fixup, linux_xfer_siginfo): Likewise.
	* linux-x86-low.c (x86_siginfo_fixup): Likewise.
	* linux-low.h: Include <signal.h>.
	(struct siginfo): Remove forward declaration.
	(struct linux_target_ops) <siginfo_fixup>: Use siginfo_t instead of
	struct siginfo.
@
text
@d1140 5
a1144 2
  siginfo_t *siginfo_p = linux_nat_get_siginfo (inferior_ptid);
  int slot = siginfo_p->si_errno;
d1147 2
a1148 2
  if (siginfo_p->si_signo != SIGTRAP
      || (siginfo_p->si_code & 0xffff) != 0x0004 /* TRAP_HWBKPT */)
d1155 2
d1162 1
a1162 1
  *addr_p = (CORE_ADDR) (uintptr_t) siginfo_p->si_addr;
@


1.53
log
@gdb/
	Fix -Wmissing-prototypes build.
	* arm-linux-nat.c (get_thread_id): Make it static.
	* xtensa-linux-nat.c (get_thread_id): Likewise.
@
text
@d1140 1
a1140 1
  struct siginfo *siginfo_p = linux_nat_get_siginfo (inferior_ptid);
@


1.52
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d80 1
a80 1
int
@


1.51
log
@gdb/
2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	PR threads/10729

	* linux-nat.c (linux_nat_new_thread): Change parameter to an lwp
	pointer.
	(linux_nat_prepare_to_resume): New global.
	(lwp_free): New.
	(purge_lwp_list): Use it.
	(add_lwp): Call linux_nat_new_thread even on the first LWP.
	Adjust to interface change.
	(delete_lwp): Call lwp_free instead of xfree.
	(detach_callback, linux_nat_detach, resume_lwp, linux_nat_resume)
	(linux_handle_syscall_trap, linux_handle_extended_wait)
	(linux_nat_filter_event, resume_stopped_resumed_lwps): Call
	linux_nat_prepare_to_resume before resuming.
	(linux_stop_lwp): New.
	(linux_nat_set_new_thread): Adjust.
	(linux_nat_set_prepare_to_resume): New.
	* linux-nat.h (struct arch_lwp_info): Forward declare.
	(struct lwp_info) <arch_private>: New field.
	(linux_stop_lwp): Declare.
	(linux_nat_set_new_thread): Adjust.
	(linux_nat_set_prepare_to_resume): New.

	* i386-nat.c (DR_NADDR, DR_STATUS, DR_CONTROL)
	(struct i386_debug_reg_state): Move to i386-nat.h.
	(dr_mirror): Comment.
	(i386_debug_reg_state): New.
	(i386_update_inferior_debug_regs): Simplify.
	(i386_stopped_data_address): Use the debug register state from the
	inferior, not from the local cache.
	* i386-nat.h (struct i386_dr_low_type): Delete reset_addr and
	unset_status fields.  New get_addr and get_control fields.
	(DR_FIRSTADDR, DR_LASTADDR, DR_CONTROL): Moved from i386-nat.c.
	(DR_NADDR, DR_STATUS): New.
	(struct i386_debug_reg_state): Moved from i386-nat.c.

	* amd64-linux-nat.c (struct arch_lwp_info): New.
	(amd64_linux_dr): Delete global.
	(amd64_linux_dr_get_addr): New.
	(amd64_linux_dr_get_control): New.
	(amd64_linux_dr_unset_status): Delete.
	(amd64_linux_dr_set_addr): Reimplement.
	(amd64_linux_dr_reset_addr): Delete.
	(update_debug_registers_callback): New.
	(amd64_linux_dr_set_control): Reimplement.
	(amd64_linux_dr_set_addr): Reimplement.
	(amd64_linux_prepare_to_resume): New.
	(amd64_linux_new_thread): Change parameter to an lwp pointer.
	Reimplement.
	(_initialize_amd64_linux_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	amd64_linux_dr_get_control as i386_dr_low.get_control.  Install
	amd64_linux_dr_get_addr as i386_dr_low.get_addr.  Install
	amd64_linux_prepare_to_resume.
	* i386-linux-nat.c (DR_FIRSTADDR, DR_LASTADDR, DR_STATUS)
	(DR_CONTROL): Delete.
	(struct arch_lwp_info): New.
	(i386_linux_dr): Delete global.
	(i386_linux_dr_set_control): Reimplement.
	(i386_linux_dr_get_addr): New.
	(i386_linux_dr_set_addr): Reimplement.
	(i386_linux_dr_get_control): New.
	(update_debug_registers_callback): New.
	(i386_linux_dr_unset_status): Delete.
	(i386_linux_dr_set_addr): Reimplement.
	(i386_linux_prepare_to_resume): New.
	(i386_linux_new_thread): Change parameter to an lwp pointer.
	Reimplement.
	(_initialize_i386_linux_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	i386_linux_dr_get_control as i386_dr_low.get_control.  Install
	i386_linux_dr_get_addr as i386_dr_low.get_addr.  Install
	i386_linux_prepare_to_resume.

	* arm-linux-nat.c (arm_linux_new_thread): Change parameter to an
	lwp pointer.  Adjust.
	* ia64-linux-nat.c (ia64_linux_new_thread): Likewise.
	* mips-linux-nat.c (mips_linux_new_thread): Likewise.
	* ppc-linux-nat.c (ppc_linux_new_thread): Likewise.
	* s390-nat.c (s390_fix_watch_points): Likewise.

	* i386-darwin-nat.c (DR_FIRSTADDR, DR_LASTADDR, DR_STATUS)
	(DR_CONTROL): Delete.
	(i386_darwin_dr_reset_addr): Delete.
	(i386_darwin_dr_get_addr): New.
	(i386_darwin_dr_get_control): New.
	* go32-nat.c
	(go32_get_dr7, go32_get_dr): New.
	(init_go32_ops): No longer install i386_dr_low.reset_addr.
	Install go32_get_dr7 as i386_dr_low.get_control.  Install
	go32_get_dr as i386_dr_low.get_addr.
	* i386bsd-nat.c (i386bsd_dr_get): New.
	(i386bsd_dr_reset_addr): Delete.
	(i386bsd_dr_get_addr): New.
	(i386bsd_dr_get_status): Use i386bsd_dr_get.
	(i386bsd_dr_get_control): New.
	* i386bsd-nat.h (i386bsd_dr_reset_addr): Delete.
	(i386bsd_dr_get_addr): New.
	(i386bsd_dr_get_control): New.
	* i386fbsd-nat.c (_initialize_i386fbsd_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	i386bsd_dr_get_control as i386_dr_low.get_control.  Install
	i386bsd_dr_get_addr as i386_dr_low.get_addr.
	* windows-nat.c (init_windows_ops): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	cygwin_get_dr7 as i386_dr_low.get_control.  Install cygwin_get_dr
	as i386_dr_low.get_addr.
	(cygwin_get_dr): New.
	(cygwin_get_dr7): New.

gdb/testsuite/
2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	PR threads/10729

	* gdb.mi/watch-nonstop.c: New file.
 	* gdb.mi/mi-watch-nonstop.exp: New file.
@
text
@d2 1
a2 2
   Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2011 Free Software Foundation, Inc.
@


1.50
log
@	PR gdb/13218
	* arm-linux-nat.c (os_version, os_major, os_minor, os_release):
	Remove unused variables.
	(get_linux_version): Remove function.
	(_initialize_arm_linux_nat): Do not call it.
@
text
@d1181 1
a1181 1
arm_linux_new_thread (ptid_t ptid)
d1183 1
a1183 1
  int tid = TIDGET (ptid);
@


1.50.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright (C) 1999-2002, 2004-2012 Free Software Foundation, Inc.
@


1.49
log
@2011-10-07  Pedro Alves  <pedro@@codesourcery.com>

	* linux-nat.h (ALL_LWPS): Remove the ptid parameter.
	* amd64-linux-nat.c (amd64_linux_dr_set_control)
	(amd64_linux_dr_set_addr, amd64_linux_dr_unset_status): Adjust.
	* arm-linux-nat.c (arm_linux_insert_hw_breakpoint)
	(arm_linux_remove_hw_breakpoint, arm_linux_insert_watchpoint)
	(arm_linux_remove_watchpoint): Adjust.
	* i386-linux-nat.c (i386_linux_dr_set_control)
	(i386_linux_dr_set_addr, i386_linux_dr_unset_status): Adjust.
	* ia64-linux-nat.c (ia64_linux_insert_watchpoint)
	(ia64_linux_remove_watchpoint): Adjust.
	* mips-linux-nat.c (write_watchpoint_regs): Adjust.
	* ppc-linux-nat.c (ppc_linux_insert_hw_breakpoint)
	(ppc_linux_insert_hw_breakpoint, ppc_linux_remove_hw_breakpoint)
	(ppc_linux_insert_mask_watchpoint)
	(ppc_linux_remove_mask_watchpoint, ppc_linux_insert_watchpoint)
	(ppc_linux_remove_watchpoint): Adjust.
	* s390-nat.c (s390_insert_watchpoint, s390_remove_watchpoint):
	Adjust.
@
text
@a74 16
/* The following variables are used to determine the version of the
   underlying GNU/Linux operating system.  Examples:

   GNU/Linux 2.0.35             GNU/Linux 2.2.12
   os_version = 0x00020023      os_version = 0x0002020c
   os_major = 2                 os_major = 2
   os_minor = 0                 os_minor = 2
   os_release = 35              os_release = 12

   Note: os_version = (os_major << 16) | (os_minor << 8) | os_release

   These are initialized using get_linux_version() from
   _initialize_arm_linux_nat().  */

static unsigned int os_version, os_major, os_minor, os_release;

a630 25
static unsigned int
get_linux_version (unsigned int *vmajor,
		   unsigned int *vminor,
		   unsigned int *vrelease)
{
  struct utsname info;
  char *pmajor, *pminor, *prelease, *tail;

  if (-1 == uname (&info))
    {
      warning (_("Unable to determine GNU/Linux version."));
      return -1;
    }

  pmajor = strtok (info.release, ".");
  pminor = strtok (NULL, ".");
  prelease = strtok (NULL, ".");

  *vmajor = (unsigned int) strtoul (pmajor, &tail, 0);
  *vminor = (unsigned int) strtoul (pminor, &tail, 0);
  *vrelease = (unsigned int) strtoul (prelease, &tail, 0);

  return ((*vmajor << 16) | (*vminor << 8) | *vrelease);
}

a1248 2
  os_version = get_linux_version (&os_major, &os_minor, &os_release);

@


1.48
log
@	* arm-linux-tdep.c: Include "auxv.h".
	(AT_HWCAP): Define.
	(ARM_LINUX_SIZEOF_VFP): Define.
	(arm_linux_supply_vfp): New function.
	(arm_linux_collect_vfp): Likewise.
	(arm_linux_regset_from_core_section): Handle .reg-arm-vfp sections.
	(arm_linux_fpa_regset_sections): New variable.
	(arm_linux_vfp_regset_sections): Likewise.
	(arm_linux_core_read_description): New function.
	(arm_linux_init_abi): Install arm_linux_core_read_description and
	arm_linux_fpa_regset_sections or arm_linux_vfp_regset_sections as
	appropriate for the architecture.
	* arm-tdep.h (struct gdbarch_tdep): Add member "vfpregset".
	(tdesc_arm_with_m): Declare.
	(tdesc_arm_with_iwmmxt): Likewise.
	(tdesc_arm_with_vfpv2): Likewise.
	(tdesc_arm_with_vfpv3): Likewise.
	(tdesc_arm_with_neon): Likewise.
	* arm-linux-nat.c: Move features/*.c includes ...
	* arm-tdep.c: ... here.
	* arm-linux-nat.c (arm_linux_read_description): Move initializing
	target description data structures ...
	* arm-tdep.c (_initialize_arm_tdep): ... here.
	* arm-linux-nat.c (HWCAP_VFP, HWCAP_IWMMXT, HWCAP_NEON, HWCAP_VFPv3,
	HWCAP_VFPv3D16): Move definitions ...
	* arm-linux-tdep.h: ... here.
@
text
@a1077 1
  ptid_t ptid;
d1085 2
a1086 2
  ALL_LWPS (lp, ptid)
    arm_linux_insert_hw_breakpoint1 (&p, TIDGET (ptid), 0);
a1095 1
  ptid_t ptid;
d1103 2
a1104 2
  ALL_LWPS (lp, ptid)
    arm_linux_remove_hw_breakpoint1 (&p, TIDGET (ptid), 0);
a1146 1
  ptid_t ptid;
d1154 2
a1155 2
  ALL_LWPS (lp, ptid)
    arm_linux_insert_hw_breakpoint1 (&p, TIDGET (ptid), 1);
a1164 1
  ptid_t ptid;
d1172 2
a1173 2
  ALL_LWPS (lp, ptid)
    arm_linux_remove_hw_breakpoint1 (&p, TIDGET (ptid), 1);
@


1.47
log
@ChangeLog:

	* arm-linux-nat.c: Include "observer.h" and "gdbthread.h".
	(PTRACE_GETHBPREGS, PTRACE_SETHBPREGS): Define.
	(struct arm_linux_hwbp_cap): New type.
	(arm_linux_get_hwbp_cap): New function.
	(arm_linux_get_hw_breakpoint_count): Likewise.
	(arm_linux_get_hw_watchpoint_count): Likewise.
	(arm_linux_can_use_hw_breakpoint): Likewise.
	(arm_hwbp_type): New type.
	(arm_hwbp_control_t): Likewise.
	(struct arm_linux_hw_breakpoint): Likewise.
	(struct arm_linux_thread_points): Likewise.
	(arm_threads): New global variable.
	(arm_linux_find_breakpoints_by_tid): New function.
	(arm_hwbp_control_initialize): Likewise.
	(arm_hwbp_control_is_enabled): Likewise.
	(arm_hwbp_control_disable): Likewise.
	(arm_linux_hw_breakpoint_initialize): Likewise.
	(arm_linux_get_hwbp_type): Likewise.
	(arm_linux_hw_watchpoint_initialize): Likewise.
	(arm_linux_hw_breakpoint_equal): Likewise.
	(arm_linux_insert_hw_breakpoint1): Likewise.
	(arm_linux_remove_hw_breakpoint1): Likewise.
	(arm_linux_insert_hw_breakpoint): Likewise.
	(arm_linux_remove_hw_breakpoint): Likewise.
	(arm_linux_region_ok_for_hw_watchpoint): Likewise.
	(arm_linux_insert_watchpoint): Likewise.
	(arm_linux_remove_watchpoint): Likewise.
	(arm_linux_stopped_data_address): Likewise.
	(arm_linux_stopped_by_watchpoint): Likewise.
	(arm_linux_watchpoint_addr_within_range): Likewise.
	(arm_linux_new_thread): Likewise.
	(arm_linux_thread_exit): Likewise.
	(_initialize_arm_linux_nat): Install hardware breakpoint/watchpoint
	related target callbacks.  Register arm_linux_new_thread and
	arm_linux_thread_exit.
	* arm-tdep.h (arm_pc_is_thumb): Add prototype.
	* arm-tdep.c (arm_pc_is_thumb): Make global.
	(arm_gdbarch_init): Call set_gdbarch_have_nonsteppable_watchpoint.

testsuite/ChangeLog:

	* lib/gdb.exp (skip_hw_breakpoint_tests): Add arm*-*-* target.
	(skip_hw_watchpoint_tests): Likewise.
	(skip_hw_watchpoint_multi_tests): Likewise.
@
text
@a46 5
#include "features/arm-with-iwmmxt.c"
#include "features/arm-with-vfpv2.c"
#include "features/arm-with-vfpv3.c"
#include "features/arm-with-neon.c"

a65 7
/* These are in <asm/elf.h> in current kernels.  */
#define HWCAP_VFP       64
#define HWCAP_IWMMXT    512
#define HWCAP_NEON      4096
#define HWCAP_VFPv3     8192
#define HWCAP_VFPv3D16  16384

a686 2
      if (tdesc_arm_with_iwmmxt == NULL)
	initialize_tdesc_arm_with_iwmmxt ();
a700 2
	  if (tdesc_arm_with_neon == NULL)
	    initialize_tdesc_arm_with_neon ();
a705 2
	  if (tdesc_arm_with_vfpv3 == NULL)
	    initialize_tdesc_arm_with_vfpv3 ();
a710 2
	  if (tdesc_arm_with_vfpv2 == NULL)
	    initialize_tdesc_arm_with_vfpv2 ();
@


1.46
log
@2011-01-31  Yao Qi  <yao@@codesourcery.com>

	* arm-linux-nat.c: Update calls to regcache_register_status
	instead of regcache_valid_p.
	* aix-thread.c: Likewise.
	* i386gnu-nat.c: Likewise.
@
text
@d29 2
d66 5
d749 558
d1323 11
d1338 4
@


1.45
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d193 2
a194 1
  if (ARM_FPS_REGNUM == regno && regcache_valid_p (regcache, ARM_FPS_REGNUM))
d230 1
a230 1
  if (regcache_valid_p (regcache, ARM_FPS_REGNUM))
d235 1
a235 1
    if (regcache_valid_p (regcache, regno))
d332 1
a332 1
  if (!regcache_valid_p (regcache, regno))
d382 1
a382 1
      if (regcache_valid_p (regcache, regno))
d386 1
a386 1
  if (arm_apcs_32 && regcache_valid_p (regcache, ARM_PS_REGNUM))
d450 2
a451 1
    if (regcache_valid_p (regcache, regno + ARM_WR0_REGNUM))
d456 2
a457 1
    if (regcache_valid_p (regcache, regno + ARM_WCSSF_REGNUM))
d462 2
a463 1
    if (regcache_valid_p (regcache, regno + ARM_WCGR0_REGNUM))
@


1.44
log
@run copyright.sh for 2011.
@
text
@d39 1
a39 1
/* Prototypes for supply_gregset etc. */
d75 1
a75 1
   16, or 32). */
@


1.43
log
@2010-04-12  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>

	* arm-tdep.h (gdb_regnum): Add ARM_FPSCR_REGNUM
	* arm-linux-nat.c (arm_linux_vfp_register_count): New
	variable.
	(fetch_vfp_registers): New function to fetch VFP registers.
	(store_vfp_registers): New function to store VFP registers.
	(arm_linux_fetch_inferior_registers): Add support for VFP
	registers.
	(arm_linux_store_inferior_registers): Likewise.
	(arm_linux_read_description): Likewise.
	(_initialize_arm_linux_nat): Delay initialising iWMMX tdesc
	until we need it.
@
text
@d3 1
a3 1
   2010 Free Software Foundation, Inc.
@


1.42
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d28 1
d33 1
d46 3
d59 12
d74 4
d110 1
d472 61
d547 2
d559 4
d580 2
d592 4
d676 55
a730 2
  int ret;
  char regbuf[IWMMXT_REGS_SIZE];
d732 2
a733 6
  ret = ptrace (PTRACE_GETWMMXREGS, GET_THREAD_ID (inferior_ptid),
		0, regbuf);
  if (ret < 0)
    arm_linux_has_wmmx_registers = 0;
  else
    arm_linux_has_wmmx_registers = 1;
d735 1
a735 4
  if (arm_linux_has_wmmx_registers)
    return tdesc_arm_with_iwmmxt;
  else
    return NULL;
a757 3

  /* Initialize the standard target descriptions.  */
  initialize_tdesc_arm_with_iwmmxt ();
@


1.41
log
@	* arm-linux-nat.c (fetch_register, store_register): Use
	ARM_CPSR_GREGNUM instead of ARM_CPSR_REGNUM.
	* arm-linux-tdep.c (arm_linux_supply_gregset,
	arm_linux_collect_gregset): Likewise.
	* arm-linux-tdep.h (ARM_CPSR_GREGNUM): New.
	* arm-tdep.h (ARM_CPSR_REGNUM): Remove.
@
text
@d2 2
a3 2
   Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
@


1.40
log
@	* corelow.c (get_core_registers): Adjust.
	(core_file_thread_alive): Rename to...
	(core_thread_alive): ... this.
	(core_pid_to_str): Try gdbarch_core_pid_to_str first.
	(init_core_ops): Adjust.
	(coreops_suppress_target): Delete.
	(_initialize_corelow): Unconditionally add core_ops.
	* procfs.c: Include "inf-child.h".
	(procfs_ops): Delete.
	(init_procfs_ops): Delete.  Reimplement as...
	(procfs_target): ... this, inheriting from inf-child.
	(procfs_attach, procfs_detach, procfs_fetch_registers): Adjust.
	(procfs_prepare_to_store): Delete.
	(procfs_store_registers, procfs_resume): Adjust.
	(procfs_open): Delete.
	(procfs_suppress_run): Delete.
	(procfs_can_run): Delete.
	(procfs_mourn_inferior): Adjust.
	(procfs_init_inferior): Add target_ops parameter.  Adjust.
	(procfs_create_inferior): Don't pass procfs_init_inferior to
	fork_inferior.  Instead call it after fork_inferior returns.
	(procfs_find_new_threads): Adjust.
	(_initialize_procfs): Adjust to use procfs_target instead of
	init_procfs_ops.
	* sol-thread.c (orig_core_ops, sol_core_ops): Delete.
	(lwp_to_thread): Use target_thread_alive.
	(sol_thread_open): Delete.
	(sol_thread_attach): Delete.
	(sol_thread_detach, sol_thread_resume, sol_thread_wait)
	(sol_thread_fetch_registers, sol_thread_store_registers): Adjust
	to use find_target_beneath.
	(sol_thread_prepare_to_store, sol_thread_xfer_memory): Delete.
	(sol_thread_xfer_partial): Adjust to use find_target_beneath.
	(sol_thread_files_info, sol_thread_kill_inferior): Delete.
	(check_for_thread_db): New.
	(sol_thread_notice_signals, sol_thread_create_inferior): Delete.
	(sol_thread_new_objfile): Call check_for_thread_db.
	(sol_thread_mourn_inferior): Adjust to use find_target_beneath.
	(sol_thread_can_run): Delete.
	(sol_thread_alive): Adjust to use find_target_beneath.
	(sol_thread_stop): Delete.
	(rw_common): Use target_write_memory or target_read_memory.
	(ps_lgetregs, ps_lgetfpregs): Use target_fetch_registers.
	(ps_lsetregs, ps_lsetfpregs): Use target_store_registers.
	(solaris_pid_to_str): Remove check for libthread_db initialization
	failing.
	(sol_find_new_threads): Remove check for libthread_db
	initialization failing, or for an invalid inferior_ptid.  Adjust
	to use find_target_beneath.
	(sol_core_open, sol_core_close, sol_core_detach,
	sol_core_files_info, sol_find_memory_regions,
	sol_make_note_section, ignore): Delete.
	(init_sol_thread_ops): Make it a thread_stratum target.  Remove
	unneeded callback settings.
	(init_sol_core_ops): Delete.
	(_initialize_sol_thread): No longer call init_sol_core_ops, set
	procfs_suppress_run, or hack with core_ops.

	* target.h (struct target_ops): Add a target_ops * parameter to
	to_resume, to_fetch_registers, to_store_registers, to_thread_alive
	and to_find_new_threads.
	(target_fetch_registers, target_store_registers)
	(target_thread_alive, target_find_new_threads): Redeclare as
	function.

	* target.c (update_current_target): Do not inherit or de_fault
	to_resume, to_fetch_registers, to_store_registers,
	to_thread_alive, to_find_new_threads.
	(target_resume): Adjust.
	(target_thread_alive, target_find_new_threads): New.
	(debug_to_resume, debug_to_fetch_registers): Delete.
	(target_fetch_registers): New.
	(debug_to_store_registers): Delete.
	(target_store_registers): New.
	(debug_to_thread_alive, debug_to_find_new_threads): Delete.
	(setup_target_debug): Adjust.

	* gdbcore.h (core_ops): Delete declaration.

	* inf-ptrace.c, linux-nat.c, remote.c, amd64-linux-nat.c,
	inf-child.c, linux-thread-db.c, bsd-uthread.c, inf-ttrace.c,
	i386-sol2-tdep.c, darwin-nat.c, gnu-nat.c, go32-nat.c,
	hpux-thread.c, i386-linux-nat.c, i386fbsd-nat.c, monitor.c,
	nto-procfs.c, remote-m32r-sdi.c, remote-mips.c, windows-nat.c,
	alphabsd-nat.c, amd64bsd-nat.c, arm-linux-nat.c, armnbsd-nat.c,
	bsd-kvm.c, hppa-hpux-nat.c, hppa-linux-nat.c, hppabsd-nat.c,
	hppanbsd-nat.c, i386-darwin-nat.c, i386bsd-nat.c,
	ia64-linux-nat.c, m32r-linux-nat.c, m68kbsd-nat.c,
	m68klinux-nat.c, m88kbsd-nat.c, mips-linux-nat.c,
	mips64obsd-nat.c, mipsnbsd-nat.c, ppc-linux-nat.c, ppcnbsd-nat.c,
	ppcobsd-nat.c, remote-sim.c, rs6000-nat.c, s390-nat.c,
	shnbsd-nat.c, sparc-nat.c, sparc-nat.h, spu-linux-nat.c,
	vaxbsd-nat.c, xtensa-linux-nat.c: Adjust to target_ops changes.

	* gdbarch.sh (core_pid_to_str): New gdbarch callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* sol2-tdep.c: Include "inferior.h".
	(sol2_core_pid_to_str): New.
	* sol2-tdep.h (sol2_core_pid_to_str): Declare.

	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Set it.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Set it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Set it.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Set it.
@
text
@d249 1
a249 1
			     (char *) &regs[ARM_CPSR_REGNUM]);
d289 1
a289 1
			 (char *) &regs[ARM_CPSR_REGNUM]);
d327 1
a327 1
			 (char *) &regs[ARM_CPSR_REGNUM]);
d365 1
a365 1
			 (char *) &regs[ARM_CPSR_REGNUM]);
@


1.39
log
@        Updated copyright notices for most files.
@
text
@d455 2
a456 1
arm_linux_fetch_inferior_registers (struct regcache *regcache, int regno)
d482 2
a483 1
arm_linux_store_inferior_registers (struct regcache *regcache, int regno)
@


1.38
log
@	Updated copyright notices for most files.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008
@


1.37
log
@2007-10-31  Markus Deuling  <deuling@@de.ibm.com>

	* arm-linux-nat.c (fetch_register, fetch_regs): Use get_regcache_arch
	to get at the current architecture by regcache.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007
@


1.36
log
@	* target-descriptions.c (tdesc_predefined_types): New.
	(tdesc_named_type): Use it.
	(tdesc_type_id, maint_print_c_tdesc_cmd): New functions.
	(_intialize_target_descriptions): Register "maint print c-tdesc".
	* features/Makefile (XMLTOC, CFILES, GDB): New macros.
	(cfiles, %.c): New rules.
	* features/arm-with-iwmmxt.c, features/mips-linux.c,
	features/mips64-linux.c: New generated files.

	* arm-linux-nat.c: Include preparsed description instead of
	"xml-support.h".
	(super_xfer_partial, arm_linux_xfer_partial): Remove.
	(arm_linux_read_description): New function.
	(_initialize_arm_linux_nat): Set to_read_description instead of
	to_xfer_partial.  Initialize preparsed description.
	* config/arm/linux.mh (TDEP_XML): Delete.
	* mips-linux-nat.c: Include preparsed descriptions instead of
	"xml-support.h".
	(super_xfer_partial, mips_linux_xfer_partial): Remove.
	(mips_linux_read_description): New function.
	(_initialize_mips_linux_nat): Set to_read_description instead of
	to_xfer_partial.  Initialize preparsed description.
	* config/mips/linux.mh (TDEP_XML): Delete.
	* Makefile.in (XMLFILES): Remove $(TDEP_XML).
	(features_headers, arm_with_iwmmxt_c, mips_linux_c)
	(mips64_linux_c): New macros.
	(arm-linux-nat.o, mips-linux-nat.o): Update.

	* gdb.texinfo (Maintenance Commands): Document "maint print c-tdesc".
@
text
@d258 2
a259 1
			      (current_gdbarch, regs[ARM_PC_REGNUM]);
d295 1
a295 1
			  (current_gdbarch, regs[ARM_PC_REGNUM]);
@


1.35
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@a27 1
#include "xml-support.h"
d43 2
d575 5
a579 30
static LONGEST (*super_xfer_partial) (struct target_ops *, enum target_object,
				      const char *, gdb_byte *, const gdb_byte *,
				      ULONGEST, LONGEST);

static LONGEST
arm_linux_xfer_partial (struct target_ops *ops,
			 enum target_object object,
			 const char *annex,
			 gdb_byte *readbuf, const gdb_byte *writebuf,
			 ULONGEST offset, LONGEST len)
{
  if (object == TARGET_OBJECT_AVAILABLE_FEATURES)
    {
      if (annex != NULL && strcmp (annex, "target.xml") == 0)
	{
	  int ret;
	  char regbuf[IWMMXT_REGS_SIZE];

	  ret = ptrace (PTRACE_GETWMMXREGS, GET_THREAD_ID (inferior_ptid),
			0, regbuf);
	  if (ret < 0)
	    arm_linux_has_wmmx_registers = 0;
	  else
	    arm_linux_has_wmmx_registers = 1;

	  if (arm_linux_has_wmmx_registers)
	    annex = "arm-with-iwmmxt.xml";
	  else
	    return -1;
	}
d581 6
a586 2
      return xml_builtin_xfer_partial (annex, readbuf, writebuf, offset, len);
    }
d588 4
a591 2
  return super_xfer_partial (ops, object, annex, readbuf, writebuf,
			     offset, len);
d610 1
a610 3
  /* Override the default to_xfer_partial.  */
  super_xfer_partial = t->to_xfer_partial;
  t->to_xfer_partial = arm_linux_xfer_partial;
d614 3
@


1.34
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (ADDR_BITS_REMOVE): Replace by gdbarch_addr_bits_remove.
	* value.c (value_as_address): Likewise (comment).
	* remote-mips.c (common_breakpoint): Likewise.
	* regcache.c (read_pc_pid): Likewise.
	* printcmd.c (do_one_display): Likewise.
	* monitor.c (monitor_write_memory, monitor_read_memory)
	(monitor_insert_breakpoint): Likewise.
	* mips-tdep.c (heuristic_proc_start): Likewise.
	* infrun.c (insert_step_resume_breakpoint_at_frame)
	(insert_step_resume_breakpoint_at_caller): Likewise.
	* buildsym.c (record_line): Likewise.
	* arm-tdep.c (arm_scan_prologue, thumb_get_next_pc)
	(arm_get_next_pc): Likewise.
	* armnbsd-nat.c (arm_supply_gregset, fetch_register, store_register)
	(store_regs): Likewise.
	* arm-linux-tdep.c (arm_linux_supply_gregset): Likewise.
	* arm-linux-nat.c (fetch_register, fetch_regs): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.33
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@d258 2
a259 1
      regs[ARM_PC_REGNUM] = ADDR_BITS_REMOVE (regs[ARM_PC_REGNUM]);
d294 2
a295 1
  regs[ARM_PC_REGNUM] = ADDR_BITS_REMOVE (regs[ARM_PC_REGNUM]);
@


1.32
log
@	* gregset.h (struct regcache): Add forward declaration.
	(supply_gregset): Add REGCACHE parameter, make GREGS const.
	(supply_fpregset): Add REGCACHE parameter, make FPREGS const.
	(supply_fpxregset): Add REGCACHE parameter, make FPXREGS const.
	(fill_gregset): Add REGCACHE parameter.
	(fill_fpregset): Likewise.
	(fill_fpxregset): Likewise.

	Update all definitions accordingly:
	* alphabsd-nat.c, alpha-linux-nat.c, alpha-nat.c, amd64-linux-nat.c,
	arm-linux-nat.c, hppa-linux-nat.c, i386gnu-nat.c, i386-linux-nat.c,
	i386-sol2-nat.c, i386v4-nat.c, ia64-linux-nat.c, irix5-nat.c,
	m32r-linux-nat.c, m68klinux-nat.c, mips-linux-nat.c, ppc-linux-nat.c,
	s390-nat.c, sparc64-linux-nat.c, sparc-linux-nat.c, sparc-sol2-nat.c
	(supply_gregset): Add REGCACHE parameter, use it instead of
	current_regcache.  Make GREGSETP parameter const, adapt casts.
	(supply_fpregset): Add REGCACHE parameter, use it instead of
	current_regcache.  Make FPREGSETP parameter const, adapt casts.
	(fill_gregset): Add REGCACHE parameter, use it instead of
	current_regcache.
	(fill_fpregset): Likewise.

	Update all callers to pass in current_regcache as the new argument:
	* core-regset.c: Include "regcache.h".
	(fetch_core_registers): Update supply_gregset,and supply_fpregset calls.
	* procfs.c: Include "regcache.h".
	(procfs_fetch_registers): Update supply_gregset, supply_fpregset calls.
	(procfs_store_registers): Update fill_gregset, fill_fpregset calls.
	(procfs_do_thread_registers): Likewise.
	(procfs_make_note_section): Likewise.
	* proc-service.c: Include "regcache.h".
	(ps_lgetregs): Update fill_gregset call.
	(ps_lsetregs): Update supply_gregset call.
	(ps_lgetfpregs): Update fill_fpregset call.
	(ps_lsetfpregs): Update supply_fpregset call.
	* sol-thread.c (sol_thread_fetch_registers): Update supply_gregset,
	supply_fpregset calls.
	(sol_thread_store_registers): Update fill_gregset, fill_fpregset calls.
	(ps_lgetregs): Update fill_gregset call.
	(ps_lsetregs): Update supply_gregset call.
	(ps_lgetfpregs): Update fill_fpregset call.
	(ps_lsetfpregs): Update supply_fpregset call.

	* linux-nat.c (linux_nat_do_thread_registers): Update fill_gregset,
	fill_fpregset, and fill_fpxregset calls.
	* i386-linux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.
	(fetch_fpxregs): Update supply_fpxregset call.
	(store_fpxregs): Update fill_fpxregset call.
	* m32r-linux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	* m68klinux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.
	(fetch_core_registers): Update supply_gregset, supply_fpregset calls.
	* s390-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.

	* Makefile.in (core-regset.o, procfs.o, proc-service.o): Update
	dependencies.
@
text
@d96 1
a96 1
fetch_fpregister (int regno)
d114 1
a114 1
    regcache_raw_supply (current_regcache, ARM_FPS_REGNUM,
d119 1
a119 1
    supply_nwfpe_register (current_regcache, regno, fp);
d126 1
a126 1
fetch_fpregs (void)
d143 1
a143 1
  regcache_raw_supply (current_regcache, ARM_FPS_REGNUM,
d148 1
a148 1
    supply_nwfpe_register (current_regcache, regno, fp);
d155 1
a155 1
store_fpregister (int regno)
d172 2
a173 3
  if (ARM_FPS_REGNUM == regno && register_cached (ARM_FPS_REGNUM))
    regcache_raw_collect (current_regcache, ARM_FPS_REGNUM,
			  fp + NWFPE_FPSR_OFFSET);
d177 1
a177 1
    collect_nwfpe_register (current_regcache, regno, fp);
d191 1
a191 1
store_fpregs (void)
d208 2
a209 3
  if (register_cached (ARM_FPS_REGNUM))
    regcache_raw_collect (current_regcache, ARM_FPS_REGNUM,
			  fp + NWFPE_FPSR_OFFSET);
d213 2
a214 2
    if (register_cached (regno))
      collect_nwfpe_register (current_regcache, regno, fp);
d228 1
a228 1
fetch_register (int regno)
d244 1
a244 1
    regcache_raw_supply (current_regcache, regno, (char *) &regs[regno]);
d249 1
a249 1
        regcache_raw_supply (current_regcache, ARM_PS_REGNUM,
d252 1
a252 1
        regcache_raw_supply (current_regcache, ARM_PS_REGNUM,
d259 1
a259 1
      regcache_raw_supply (current_regcache, ARM_PC_REGNUM,
d268 1
a268 1
fetch_regs (void)
d284 1
a284 1
    regcache_raw_supply (current_regcache, regno, (char *) &regs[regno]);
d287 1
a287 1
    regcache_raw_supply (current_regcache, ARM_PS_REGNUM,
d290 1
a290 1
    regcache_raw_supply (current_regcache, ARM_PS_REGNUM,
d294 1
a294 1
  regcache_raw_supply (current_regcache, ARM_PC_REGNUM,
d302 1
a302 1
store_register (int regno)
d307 1
a307 1
  if (!register_cached (regno))
d322 1
a322 1
    regcache_raw_collect (current_regcache, regno, (char *) &regs[regno]);
d324 1
a324 1
    regcache_raw_collect (current_regcache, regno,
d327 1
a327 1
    regcache_raw_collect (current_regcache, ARM_PC_REGNUM,
d339 1
a339 1
store_regs (void)
d357 2
a358 2
      if (register_cached (regno))
	regcache_raw_collect (current_regcache, regno, (char *) &regs[regno]);
d361 2
a362 2
  if (arm_apcs_32 && register_cached (ARM_PS_REGNUM))
    regcache_raw_collect (current_regcache, ARM_PS_REGNUM,
d380 1
a380 1
fetch_wmmx_regs (void)
d396 1
a396 1
    regcache_raw_supply (current_regcache, regno + ARM_WR0_REGNUM,
d400 1
a400 1
    regcache_raw_supply (current_regcache, regno + ARM_WCSSF_REGNUM,
d404 1
a404 1
    regcache_raw_supply (current_regcache, regno + ARM_WCGR0_REGNUM,
d409 1
a409 1
store_wmmx_regs (void)
d425 2
a426 2
    if (register_cached (regno + ARM_WR0_REGNUM))
      regcache_raw_collect (current_regcache, regno + ARM_WR0_REGNUM,
d430 2
a431 2
    if (register_cached (regno + ARM_WCSSF_REGNUM))
      regcache_raw_collect (current_regcache, regno + ARM_WCSSF_REGNUM,
d435 2
a436 2
    if (register_cached (regno + ARM_WCGR0_REGNUM))
      regcache_raw_collect (current_regcache, regno + ARM_WCGR0_REGNUM,
d453 1
a453 1
arm_linux_fetch_inferior_registers (int regno)
d457 2
a458 2
      fetch_regs ();
      fetch_fpregs ();
d460 1
a460 1
	fetch_wmmx_regs ();
d465 1
a465 1
        fetch_register (regno);
d467 1
a467 1
        fetch_fpregister (regno);
d470 1
a470 1
	fetch_wmmx_regs ();
d479 1
a479 1
arm_linux_store_inferior_registers (int regno)
d483 2
a484 2
      store_regs ();
      store_fpregs ();
d486 1
a486 1
	store_wmmx_regs ();
d491 1
a491 1
        store_register (regno);
d493 1
a493 1
        store_fpregister (regno);
d496 1
a496 1
	store_wmmx_regs ();
@


1.31
log
@	* core-aout.c: Delete file.
	* Makefile.in (ALLDEPFILES): Remove core-aout.c.
	(core-aout.o): Delete rule.
	* gdbcore.h (kernel_u_addr, KERNEL_U_ADDR): Remove.

        * config/alpha/nm-linux.h (U_REGS_OFFSET): Remove.

        * arm-linux-nat.c (arm_linux_kernel_u_size): Remove.
        * config/arm/nm-linux.h (U_REGS_OFFSET, KERNEL_U_SIZE,
        KERNEL_U_ADDR): Remove.

        * i386-linux-nat.c (register_u_addr, kernel_u_size): Remove.
        (cannot_fetch_register, cannot_store_register): Remove.
        (fetch_register): Inline cannot_fetch_register and register_addr.
        (store_register): Inline cannot_store_register and register_addr.
        * config/i386/linux.mh (NATDEPFILES): Remove core-aout.o.
        * config/i386/nm-linux.h (KERNEL_U_SIZE, KERNEL_U_ADDR,
        REGISTER_U_ADDR, CANNOT_FETCH_REGISTER, CANNOT_STORE_REGISTER):
        Remove.

        * m68klinux-nat.c (m68k_linux_register_u_addr, kernel_u_size): Remove.
        (fetch_register): Inline register_addr.
        (store_register): Inline register_addr.
        * config/m68k/linux.mh (NATDEPFILES): Remove core-aout.o.
        * config/m68k/nm-linux.h (KERNEL_U_SIZE, KERNEL_U_ADDR,
        U_REGS_OFFSET, REGISTER_U_ADDR): Remove.

        * config/mips/nm-irix5.h (REGISTER_U_ADDR): Remove.
        * config/mips/nm-linux.h (KERNEL_U_SIZE, U_REGS_OFFSET,
        REGISTER_U_ADDR): Remove.

        * hppa-linux-nat.c (register_addr): Rename to ...
        (hppa_linux_register_addr): ... this.  Make static.
        (fetch_register, store_register): Adapt callers.
        * config/pa/nm-linux.h (U_REGS_OFFSET): Remove.

        * ppc-linux-nat.c (kernel_u_size): Remove.
        * config/powerpc/nm-linux.h (KERNEL_U_SIZE, KERNEL_U_ADDR): Remove.

	* vax-nat.c (vax_kernel_u_addr, vax_register_u_addr): Make static.
	* config/vax/vax.mh (NATDEPFILES): Remove core-aout.o.
	(NAT_FILE): Remove.
	* config/vax/nm-vax.h: Delete file.
@
text
@d506 2
a507 1
fill_gregset (gdb_gregset_t *gregsetp, int regno)
d509 1
a509 1
  arm_linux_collect_gregset (NULL, current_regcache, regno, gregsetp, 0);
d513 1
a513 1
supply_gregset (gdb_gregset_t *gregsetp)
d515 1
a515 1
  arm_linux_supply_gregset (NULL, current_regcache, -1, gregsetp, 0);
d519 2
a520 1
fill_fpregset (gdb_fpregset_t *fpregsetp, int regno)
d522 1
a522 1
  arm_linux_collect_nwfpe (NULL, current_regcache, regno, fpregsetp, 0);
d529 1
a529 1
supply_fpregset (gdb_fpregset_t *fpregsetp)
d531 1
a531 1
  arm_linux_supply_nwfpe (NULL, current_regcache, -1, fpregsetp, 0);
@


1.30
log
@	* Makefile.in (XMLFILES): Include $(TDEP_XML).
	(filenames_h): New variable.
	(clean): Clean up xml-builtin.c and stamp-xml.
	(arm-linux-nat.o): Update.
	* config/arm/linux.mh (TDEP_XML): Define.
	* arm-linux-nat.c (PTRACE_GETWMMXREGS, PTRACE_SETWMMXREGS): Define.
	(arm_linux_has_wmmx_registers): New.
	(GET_THREAD_ID): Fix typo.
	(IWMMXT_REGS_SIZE): Define.
	(fetch_wmmx_regs, store_wmmx_regs): New.
	(arm_linux_fetch_inferior_registers): Use fetch_wmmx_regs.
	(arm_linux_store_inferior_registers): Use store_wmmx_regs.
	(super_xfer_partial, arm_linux_xfer_partial): New.
	(_initialize_arm_linux_nat): Use them.
	* xml-support.c (fetch_xml_builtin): Move outside HAVE_LIBEXPAT.
	(xml_builtin_xfer_partial): New function.
	* xml-support.h (xml_builtin_xfer_partial): New prototype.
	* NEWS: Update mention of iWMMXt support.
@
text
@a531 6
int
arm_linux_kernel_u_size (void)
{
  return (sizeof (struct user));
}

@


1.29
log
@Copyright updates for 2007.
@
text
@d29 2
d50 8
d90 1
a90 1
#define GET_THREAD_ID(PTID)	get_thread_id ((PTID));
d376 74
d461 2
d466 1
a466 1
      if (regno < ARM_F0_REGNUM || regno > ARM_FPS_REGNUM)
d468 1
a468 2

      if (regno >= ARM_F0_REGNUM && regno <= ARM_FPS_REGNUM)
d470 3
d487 2
d492 1
a492 1
      if ((regno < ARM_F0_REGNUM) || (regno > ARM_FPS_REGNUM))
d494 1
a494 2

      if ((regno >= ARM_F0_REGNUM) && (regno <= ARM_FPS_REGNUM))
d496 3
d580 38
d634 4
@


1.28
log
@	* Makefile.in (arm_linux_tdep_h): New variable.
	(arm-linux-nat.o, arm-linux-tdep.o): Update.
	* arm-linux-nat.c: Include "arm-linux-tdep.h".
	(typeNone, typeSingle, typeDouble, typeExtended)
	(FPWORDS, ARM_CPSR_REGNUM, FPREG, FPA11)
	(fetch_nwfpe_single, fetch_nwfpe_double, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_nwfpe_register, store_nwfpe_single)
	(store_nwfpe_double, store_nwfpe_extended, store_nwfpe_register):
	Delete.
	(fetch_fpregister, fetch_fpregs, store_fpregister, store_fpregs):
	Use gdb_byte buffers, NWFPE_FPSR_OFFSET, supply_nwfpe_register,
	and collect_nwfpe_register.
	(fill_gregset, supply_gregset, fill_fpregset, supply_fpregset): Use
	new regset functions.
	* arm-linux-tdep.c: Include "regset.h" and "arm-linux-tdep.h".
	(arm_apcs_32): New declaration.
	(ARM_LINUX_SIZEOF_GREGSET, arm_linux_supply_gregset)
	(arm_linux_collect_gregset, typeNone, typeSingle, typeDouble)
	(typeExtended, supply_nwfpe_register, collect_nwfpe_register)
	(arm_linux_supply_nwfpe, arm_linux_collect_nwfpe)
	(arm_linux_regset_from_core_section): New.
	(arm_linux_init_abi): Register arm_linux_regset_from_core_section.
	* arm-linux-tdep.h: New file.
	* arm-tdep.h (struct regset): Declare.
	(struct gdbarch_tdep): Add gregset, fpregset members.
	* config/arm/linux.mh (NATDEPFILES): Remove corelow.o and
	core-regset.o.
	* config/arm/linux.mt (TDEPFILES): Add corelow.o.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005, 2006
@


1.27
log
@gdb/
	* Makefile.in (arm-linux-nat.o): Update dependencies.
	* arm-linux-nat.c: Include "gdb_proc_service.h".
	(PTRACE_GET_THREAD_AREA): Define.
	(ps_get_thread_area): New function.
gdb/gdbserver/
	* Makefile.in (linux-arm-low.o): Update dependencies.
	* linux-arm-low.c: Include "../gdb_proc_service.h".
	(PTRACE_GET_THREAD_AREA): Define.
	(ps_get_thread_area): New function.
@
text
@d31 1
a49 26
#define		typeNone		0x00
#define		typeSingle		0x01
#define		typeDouble		0x02
#define		typeExtended		0x03
#define 	FPWORDS			28
#define		ARM_CPSR_REGNUM		16

typedef union tagFPREG
  {
    unsigned int fSingle;
    unsigned int fDouble[2];
    unsigned int fExtended[3];
  }
FPREG;

typedef struct tagFPA11
  {
    FPREG fpreg[8];		/* 8 floating point registers */
    unsigned int fpsr;		/* floating point status register */
    unsigned int fpcr;		/* floating point control register */
    unsigned char fType[8];	/* type of floating point value held in
				   floating point registers.  */
    int initflag;		/* NWFPE initialization flag.  */
  }
FPA11;

a81 126
static void
fetch_nwfpe_single (unsigned int fn, FPA11 * fpa11)
{
  unsigned int mem[3];

  mem[0] = fpa11->fpreg[fn].fSingle;
  mem[1] = 0;
  mem[2] = 0;
  regcache_raw_supply (current_regcache, ARM_F0_REGNUM + fn, (char *) &mem[0]);
}

static void
fetch_nwfpe_double (unsigned int fn, FPA11 * fpa11)
{
  unsigned int mem[3];

  mem[0] = fpa11->fpreg[fn].fDouble[1];
  mem[1] = fpa11->fpreg[fn].fDouble[0];
  mem[2] = 0;
  regcache_raw_supply (current_regcache, ARM_F0_REGNUM + fn, (char *) &mem[0]);
}

static void
fetch_nwfpe_none (unsigned int fn)
{
  unsigned int mem[3] =
  {0, 0, 0};

  regcache_raw_supply (current_regcache, ARM_F0_REGNUM + fn, (char *) &mem[0]);
}

static void
fetch_nwfpe_extended (unsigned int fn, FPA11 * fpa11)
{
  unsigned int mem[3];

  mem[0] = fpa11->fpreg[fn].fExtended[0];	/* sign & exponent */
  mem[1] = fpa11->fpreg[fn].fExtended[2];	/* ls bits */
  mem[2] = fpa11->fpreg[fn].fExtended[1];	/* ms bits */
  regcache_raw_supply (current_regcache, ARM_F0_REGNUM + fn, (char *) &mem[0]);
}

static void
fetch_nwfpe_register (int regno, FPA11 * fpa11)
{
   int fn = regno - ARM_F0_REGNUM;

   switch (fpa11->fType[fn])
     {
     case typeSingle:
       fetch_nwfpe_single (fn, fpa11);
       break;

     case typeDouble:
       fetch_nwfpe_double (fn, fpa11);
       break;

     case typeExtended:
       fetch_nwfpe_extended (fn, fpa11);
       break;

     default:
       fetch_nwfpe_none (fn);
     }
}

static void
store_nwfpe_single (unsigned int fn, FPA11 *fpa11)
{
  unsigned int mem[3];

  regcache_raw_collect (current_regcache, ARM_F0_REGNUM + fn,
			(char *) &mem[0]);
  fpa11->fpreg[fn].fSingle = mem[0];
  fpa11->fType[fn] = typeSingle;
}

static void
store_nwfpe_double (unsigned int fn, FPA11 *fpa11)
{
  unsigned int mem[3];

  regcache_raw_collect (current_regcache, ARM_F0_REGNUM + fn,
			(char *) &mem[0]);
  fpa11->fpreg[fn].fDouble[1] = mem[0];
  fpa11->fpreg[fn].fDouble[0] = mem[1];
  fpa11->fType[fn] = typeDouble;
}

void
store_nwfpe_extended (unsigned int fn, FPA11 *fpa11)
{
  unsigned int mem[3];

  regcache_raw_collect (current_regcache, ARM_F0_REGNUM + fn,
			(char *) &mem[0]);
  fpa11->fpreg[fn].fExtended[0] = mem[0];	/* sign & exponent */
  fpa11->fpreg[fn].fExtended[2] = mem[1];	/* ls bits */
  fpa11->fpreg[fn].fExtended[1] = mem[2];	/* ms bits */
  fpa11->fType[fn] = typeDouble;
}

void
store_nwfpe_register (int regno, FPA11 * fpa11)
{
  if (register_cached (regno))
    {
       unsigned int fn = regno - ARM_F0_REGNUM;
       switch (fpa11->fType[fn])
         {
	 case typeSingle:
	   store_nwfpe_single (fn, fpa11);
	   break;

	 case typeDouble:
	   store_nwfpe_double (fn, fpa11);
	   break;

	 case typeExtended:
	   store_nwfpe_extended (fn, fpa11);
	   break;
	 }
    }
}


d89 1
a89 1
  FPA11 fp;
d95 1
a95 1
  ret = ptrace (PT_GETFPREGS, tid, 0, &fp);
d104 2
a105 1
    regcache_raw_supply (current_regcache, ARM_FPS_REGNUM, (char *) &fp.fpsr);
d109 1
a109 21
    {
      int fn = regno - ARM_F0_REGNUM;

      switch (fp.fType[fn])
	{
	case typeSingle:
	  fetch_nwfpe_single (fn, &fp);
	  break;

	case typeDouble:
	    fetch_nwfpe_double (fn, &fp);
	  break;

	case typeExtended:
	    fetch_nwfpe_extended (fn, &fp);
	  break;

	default:
	    fetch_nwfpe_none (fn);
	}
    }
d119 1
a119 1
  FPA11 fp;
d125 1
a125 1
  ret = ptrace (PT_GETFPREGS, tid, 0, &fp);
d133 2
a134 1
  regcache_raw_supply (current_regcache, ARM_FPS_REGNUM, (char *) &fp.fpsr);
d138 1
a138 21
    {
      int fn = regno - ARM_F0_REGNUM;

      switch (fp.fType[fn])
	{
	case typeSingle:
	  fetch_nwfpe_single (fn, &fp);
	  break;

	case typeDouble:
	  fetch_nwfpe_double (fn, &fp);
	  break;

	case typeExtended:
	  fetch_nwfpe_extended (fn, &fp);
	  break;

	default:
	  fetch_nwfpe_none (fn);
	}
    }
d148 1
a148 1
  FPA11 fp;
d154 1
a154 1
  ret = ptrace (PT_GETFPREGS, tid, 0, &fp);
d163 2
a164 1
    regcache_raw_collect (current_regcache, ARM_FPS_REGNUM, (char *) &fp.fpsr);
d168 1
a168 3
    {
      store_nwfpe_register (regno, &fp);
    }
d170 1
a170 1
  ret = ptrace (PTRACE_SETFPREGS, tid, 0, &fp);
d185 1
a185 1
  FPA11 fp;
d191 1
a191 1
  ret = ptrace (PT_GETFPREGS, tid, 0, &fp);
d200 2
a201 1
    regcache_raw_collect (current_regcache, ARM_FPS_REGNUM, (char *) &fp.fpsr);
d205 2
a206 3
    {
      fetch_nwfpe_register (regno, &fp);
    }
d208 1
a208 1
  ret = ptrace (PTRACE_SETFPREGS, tid, 0, &fp);
d410 2
a411 3
/* Fill register regno (if it is a general-purpose register) in
   *gregsetp with the appropriate value from GDB's register array.
   If regno is -1, do this for all registers.  */
d416 1
a416 20
  if (-1 == regno)
    {
      int regnum;
      for (regnum = ARM_A1_REGNUM; regnum <= ARM_PC_REGNUM; regnum++) 
	regcache_raw_collect (current_regcache, regnum,
			      (char *) &(*gregsetp)[regnum]);
    }
  else if (regno >= ARM_A1_REGNUM && regno <= ARM_PC_REGNUM)
    regcache_raw_collect (current_regcache, regno,
			  (char *) &(*gregsetp)[regno]);

  if (ARM_PS_REGNUM == regno || -1 == regno)
    {
      if (arm_apcs_32)
	regcache_raw_collect (current_regcache, ARM_PS_REGNUM,
			      (char *) &(*gregsetp)[ARM_CPSR_REGNUM]);
      else
	regcache_raw_collect (current_regcache, ARM_PC_REGNUM,
			      (char *) &(*gregsetp)[ARM_PC_REGNUM]);
    }
a418 3
/* Fill GDB's register array with the general-purpose register values
   in *gregsetp.  */

d422 1
a422 15
  int regno, reg_pc;

  for (regno = ARM_A1_REGNUM; regno < ARM_PC_REGNUM; regno++)
    regcache_raw_supply (current_regcache, regno,
			 (char *) &(*gregsetp)[regno]);

  if (arm_apcs_32)
    regcache_raw_supply (current_regcache, ARM_PS_REGNUM,
			 (char *) &(*gregsetp)[ARM_CPSR_REGNUM]);
  else
    regcache_raw_supply (current_regcache, ARM_PS_REGNUM,
			 (char *) &(*gregsetp)[ARM_PC_REGNUM]);

  reg_pc = ADDR_BITS_REMOVE ((CORE_ADDR)(*gregsetp)[ARM_PC_REGNUM]);
  regcache_raw_supply (current_regcache, ARM_PC_REGNUM, (char *) &reg_pc);
a424 4
/* Fill register regno (if it is a floating-point register) in
   *fpregsetp with the appropriate value from GDB's register array.
   If regno is -1, do this for all registers.  */

d428 1
a428 18
  FPA11 *fp = (FPA11 *) fpregsetp;
  
  if (-1 == regno)
    {
       int regnum;
       for (regnum = ARM_F0_REGNUM; regnum <= ARM_F7_REGNUM; regnum++)
         store_nwfpe_register (regnum, fp);
    }
  else if (regno >= ARM_F0_REGNUM && regno <= ARM_F7_REGNUM)
    {
      store_nwfpe_register (regno, fp);
      return;
    }

  /* Store fpsr.  */
  if (ARM_FPS_REGNUM == regno || -1 == regno)
    regcache_raw_collect (current_regcache, ARM_FPS_REGNUM,
			  (char *) &fp->fpsr);
d437 1
a437 11
  int regno;
  FPA11 *fp = (FPA11 *) fpregsetp;

  /* Fetch fpsr.  */
  regcache_raw_supply (current_regcache, ARM_FPS_REGNUM, (char *) &fp->fpsr);

  /* Fetch the floating point registers.  */
  for (regno = ARM_F0_REGNUM; regno <= ARM_F7_REGNUM; regno++)
    {
      fetch_nwfpe_register (regno, fp);
    }
@


1.26
log
@	* linux-nat.c (linux_ops_saved): New.
	(super_mourn_inferior, kill_inferior, threaded, linux_nat_ops)
	(child_mourn_inferior, child_wait, linux_nat_create_inferior)
	(linux_nat_fetch_registers, linux_nat_store_registers)
	(linux_nat_child_post_startup_inferior, init_linux_nat_ops): Delete.
	(init_lwp_list): Don't set threaded.
	(add_lwp): Don't modify threaded.
	(delete_lwp): Don't mention non-threaded mode.
	(linux_nat_switch_fork): New.
	(linux_nat_attach): Update inferior_ptid.
	(linux_nat_wait): Handle num_lwps == 0 at entry.  Don't check
	threaded flag.
	(linux_nat_kill): Handle pending forks and saved forks.
	(linux_nat_mourn_inferior): Handle saved forks.
	(linux_nat_pid_to_str): Don't use the LWP form when there is
	only one thread.
	(linux_target): Don't set to_wait, to_kill, or to_mourn_inferior.
	(linux_nat_add_target): New.
	(_initialize_linux_nat): Don't initialize the linux native target
	here.
	* linux-nat.h (linux_nat_add_target, linux_nat_switch_fork): New
	prototypes.
	* linux-fork.c: Include "linux-nat.h".
	(add_fork): Update initial PID.
	(fork_load_infrun_state): Call linux_nat_switch_fork.
	* Makefile.in (linux-fork.o): Update.

	* alpha-linux-nat.c (_initialize_alpha_linux_nat): Use
	linux_nat_add_target instead of add_target.
	* amd64-linux-nat.c (_initialize_amd64_linux_nat): Likewise.
	* arm-linux-nat.c (_initialize_arm_linux_nat): Likewise.
	* hppa-linux-nat.c (_initialize_hppa_linux_nat): Likewise.
	* ia64-linux-nat.c (_initialize_ia64_linux_nat): Likewise.
	* i386-linux-nat.c (_initialize_i386_linux_nat): Likewise.
	* m32r-linux-nat.c (_initialize_m32r_linux_nat): Likewise.
	* m68klinux-nat.c (_initialize_m68k_linux_nat): Likewise.
	* mips-linux-nat.c (_initialize_mips_linux_nat): Likewise.
	* ppc-linux-nat.c (_initialize_ppc_linux_nat): Likewise.
	* s390-nat.c (_initialize_s390_nat): Likewise.
	* sparc-linux-nat.c (_initialize_sparc_linux_nat): Likewise.
	* sparc64-linux-nat.c (_initialize_sparc64_linux_nat): Likewise.
@
text
@d40 7
d704 17
@


1.26.8.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a30 1
#include "arm-linux-tdep.h"
d40 1
a40 6
/* Defines ps_err_e, struct ps_prochandle.  */
#include "gdb_proc_service.h"

#ifndef PTRACE_GET_THREAD_AREA
#define PTRACE_GET_THREAD_AREA 22
#endif
d42 25
a66 1
extern int arm_apcs_32;
d100 126
d233 1
a233 1
  gdb_byte fp[ARM_LINUX_SIZEOF_NWFPE];
d239 1
a239 1
  ret = ptrace (PT_GETFPREGS, tid, 0, fp);
d248 1
a248 2
    regcache_raw_supply (current_regcache, ARM_FPS_REGNUM,
			 fp + NWFPE_FPSR_OFFSET);
d252 21
a272 1
    supply_nwfpe_register (current_regcache, regno, fp);
d282 1
a282 1
  gdb_byte fp[ARM_LINUX_SIZEOF_NWFPE];
d288 1
a288 1
  ret = ptrace (PT_GETFPREGS, tid, 0, fp);
d296 1
a296 2
  regcache_raw_supply (current_regcache, ARM_FPS_REGNUM,
		       fp + NWFPE_FPSR_OFFSET);
d300 21
a320 1
    supply_nwfpe_register (current_regcache, regno, fp);
d330 1
a330 1
  gdb_byte fp[ARM_LINUX_SIZEOF_NWFPE];
d336 1
a336 1
  ret = ptrace (PT_GETFPREGS, tid, 0, fp);
d345 1
a345 2
    regcache_raw_collect (current_regcache, ARM_FPS_REGNUM,
			  fp + NWFPE_FPSR_OFFSET);
d349 3
a351 1
    collect_nwfpe_register (current_regcache, regno, fp);
d353 1
a353 1
  ret = ptrace (PTRACE_SETFPREGS, tid, 0, fp);
d368 1
a368 1
  gdb_byte fp[ARM_LINUX_SIZEOF_NWFPE];
d374 1
a374 1
  ret = ptrace (PT_GETFPREGS, tid, 0, fp);
d383 1
a383 2
    regcache_raw_collect (current_regcache, ARM_FPS_REGNUM,
			  fp + NWFPE_FPSR_OFFSET);
d387 3
a389 2
    if (register_cached (regno))
      collect_nwfpe_register (current_regcache, regno, fp);
d391 1
a391 1
  ret = ptrace (PTRACE_SETFPREGS, tid, 0, fp);
d593 3
a595 2
/* Wrapper functions for the standard regset handling, used by
   thread debugging.  */
d600 20
a619 1
  arm_linux_collect_gregset (NULL, current_regcache, regno, gregsetp, 0);
d622 3
d628 15
a642 1
  arm_linux_supply_gregset (NULL, current_regcache, -1, gregsetp, 0);
d645 4
d652 18
a669 1
  arm_linux_collect_nwfpe (NULL, current_regcache, regno, fpregsetp, 0);
d678 11
a688 1
  arm_linux_supply_nwfpe (NULL, current_regcache, -1, fpregsetp, 0);
a696 17
/* Fetch the thread-local storage pointer for libthread_db.  */

ps_err_e
ps_get_thread_area (const struct ps_prochandle *ph,
                    lwpid_t lwpid, int idx, void **base)
{
  if (ptrace (PTRACE_GET_THREAD_AREA, lwpid, NULL, base) != 0)
    return PS_ERR;

  /* IDX is the bias from the thread pointer to the beginning of the
     thread descriptor.  It has to be subtracted due to implementation
     quirks in libthread_db.  */
  *base = (void *) ((char *)*base - idx);

  return PS_OK;
}

@


1.25
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005
d739 1
a739 1
  add_target (t);
@


1.24
log
@	* Makefile.in (ALLDEPFILES): Update.
	(alpha-linux-nat.o, sparc-linux-nat.o): New rules.
	(amd64-linux-nat.o, arm-linux-nat.o, hppa-linux-nat.o)
	(i386-linux-nat.o, ia64-linux-nat.o, linux-nat.o, m32r-linux-nat.o)
	(m68klinux-nat.o, mips-linux-nat.o, ppc-linux-nat.o, s390-nat.o)
	(sparc64-linux-nat.o): Update dependencies.
	* alpha-linux-nat.c, sparc-linux-nat.c: New files.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(amd64_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(amd64_linux_child_post_start_inferior): Renamed from
	child_post_startup_inferior and made static.  Call
	super_post_startup_inferior.
	(super_post_startup_inferior): New.
	(_initialize_amd64_linux_nat): Set it.  Call linux_target and
	add_target.
	* arm-linux-nat.c (arm_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(arm_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_arm_linux_nat): Add a prototype.  Use linux_target and
	add_target.
	* hppa-linux-nat.c (hppa_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(hppa_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_hppa_linux_nat): New function.
	* i386-linux-nat.c (i386_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(i386_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(i386_linux_resume): Renamed from child_resume and made static.
	(i386_linux_child_post_start_inferior): Renamed from
	child_post_startup_inferior and made static.  Call
	super_post_startup_inferior.
	(super_post_startup_inferior): New.
	(_initialize_i386_linux_nat): New function.
	* i386-nat.c: Remove LINUX_CHILD_POST_STARTUP_INFERIOR #ifndef.
	* ia64-linux-nat.c (ia64_linux_xfer_unwind_table): Remove.
	(super_xfer_partial): New.
	(ia64_linux_xfer_partial): New function.  Use it.
	(_initialize_ia64_linux_nat): New function.
	* ia64-tdep.c (getunwind_table): Revert 2005-06-08 change; use
	target_read_partial and document the problem.
	* inf-ptrace.c (inf_ptrace_fetch_register): Use
	CANNOT_FETCH_REGISTER.  Fix some comments.
	(inf_ptrace_store_register): Use CANNOT_STORE_REGISTER.  Fix some
	comments.
	* linux-nat.c: Include "inf-ptrace.h" and "auxv.h".
	(linux_ops, super_xfer_partial): New variables.
	(linux_child_post_startup_inferior): Make static.
	(child_post_startup_inferior): Delete.
	(linux_nat_attach, linux_nat_detach, resume_callback)
	(linux_nat_resume, linux_nat_wait, linux_nat_create_inferior)
	(linux_nat_mourn_inferior): Use linux_ops instead of
	deprecated_child_ops.
	(child_wait): Do not depend on CHILD_WAIT.
	(linux_nat_xfer_memory): Remove, replace by ...
	(linux_nat_xfer_partial): ... this.  Use linux_ops->to_xfer_partial
	instead of linux_proc_xfer_memory and child_xfer_memory.
	(linux_nat_fetch_registers, linux_nat_store_registers)
	(linux_nat_child_post_startup_inferior): New functions.
	(init_linux_nat_ops): Use the new functions.
	(linux_proc_xfer_memory): Remove, replace by ...
	(linux_proc_xfer_partial): ... this.  Make static.
	(linux_xfer_partial, linux_register_u_offset, linux_target): New
	functions.
	(_initialize_linux_nat): Do not modify deprecated_child_ops.
	* linux-nat.h (linux_proc_xfer_memory): Remove prototype.
	(struct mem_attrib, struct target_ops): Remove forward declarations.
	(linux_child_post_startup_inferior): Remove prototype.
	(linux_target): Add prototype.
	* linux-thread-db.c (thread_db_xfer_memory): Remove, replace by ...
	(thread_db_xfer_partial): ... this.
	(init_thread_db_ops): Set to_xfer_partial instead of
	deprecated_xfer_memory.
	* m32r-linux-nat.c (m32r_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(m32r_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_m32r_linux_nat): New function.
	* m68klinux-nat.c (m68k_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(m68k_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(old_fetch_inferior_registers, old_store_inferior_registers): Made
	static.
	(_initialize_m68k_linux_nat): Use linux_target and add_target.
	* mips-linux-nat.c (_initialize_mips_linux_nat): New function.
	* ppc-linux-nat.c (ppc_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(ppc_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_ppc_linux_nat): New function.
	* s390-nat.c (s390_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(s390_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_s390_nat): New function.
	* sparc64-linux-nat.c (_initialize_sparc64_linux_nat): Use
	linux_target and add_target.
	* config/nm-linux.h: Don't include "auxv.h".
	(struct target_waitstatus, child_wait, CHILD_WAIT)
	(CHILD_PID_TO_EXEC_FILE, CHILD_INSERT_FORK_CATCHPOINT)
	(CHILD_INSERT_VFORK_CATCHPOINT, CHILD_INSERT_EXEC_CATCHPOINT)
	(CHILD_POST_STARTUP_INFERIOR, CHILD_POST_ATTACH, CHILD_FOLLOW_FORK)
	(DEPRECATED_KILL_INFERIOR, NATIVE_XFER_AUXV): Delete.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Replace infptrace.o
	and inftarg.o with inf-ptrace.o and alpha-linux-nat.o.
	* config/sparc/linux.mh (NATDEPFILES): Replace infptrace.o and
	inftarg.o with sparc-linux-nat.o.
	* config/sparc/linux64.mh (NATDEPFILES): Remove infptrace.o and
	inftarg.o.
	* config/arm/linux.mh (NATDEPFILES): Replace infptrace.o and
	inftarg.o with inf-ptrace.o.
	* config/i386/linux.mh (NATDEPFILES): Likewise.
	* config/i386/linux64.mh (NATDEPFILES): Likewise.
	* config/ia64/linux.mh (NATDEPFILES): Likewise.
	* config/m32r/linux.mh (NATDEPFILES): Likewise.
	* config/m68k/linux.mh (NATDEPFILES): Likewise.
	* config/mips/linux.mh (NATDEPFILES): Likewise.
	* config/pa/linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Likewise.
	* config/s390/s390.mh (NATDEPFILES): Likewise.
	* config/i386/nm-linux.h (DEPRECATED_CHILD_RESUME): Don't define.
	(LINUX_CHILD_POST_STARTUP_INFERIOR): Don't define.
	* config/i386/nm-linux64.h (LINUX_CHILD_POST_STARTUP_INFERIOR):
	Don't define.
	* config/ia64/nm-linux.h: Don't include "target.h".
	(NATIVE_XFER_UNWIND_TABLE, ia64_linux_xfer_unwind_table): Remove.
	* config/djgpp/fnchange.lst: Add alpha-linux-tdep.c,
	alpha-linux-nat.c, sparc-linux-tdep.c, and sparc-linux-nat.c.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2004, 2005
d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.24.2.1
log
@2005-03-25  Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in (arm-linux-nat.o): Update dependencies.
	* gdb/arm-linux-nat.c: Include "gdb_proc_service.h".
	(PTRACE_GET_THREAD_AREA): Define.
	(ps_get_thread_area): New function.

	* gdb/gdbserver/Makefile.in (linux-arm-low.o): Update dependencies.
	* gdb/gdbserver/linux-arm-low.c: Include "../gdb_proc_service.h".
	(PTRACE_GET_THREAD_AREA): Define.
	(ps_get_thread_area): New function.
@
text
@a39 7
/* Defines ps_err_e, struct ps_prochandle.  */
#include "gdb_proc_service.h"

#ifndef PTRACE_GET_THREAD_AREA
#define PTRACE_GET_THREAD_AREA 22
#endif

d98 1
a98 1
#define GET_THREAD_ID(PTID)	get_thread_id (PTID)
a696 17
/* Fetch the thread-local storage pointer for libthread_db.  */

ps_err_e
ps_get_thread_area (const struct ps_prochandle *ph,
                    lwpid_t lwpid, int idx, void **base)
{
  if (ptrace (PTRACE_GET_THREAD_AREA, lwpid, NULL, base) != 0)
    return PS_ERR;

  /* IDX is the bias from the thread pointer to the beginning of the
     thread descriptor.  It has to be subtracted due to implementation
     quirks in libthread_db.  */
  *base = (void *) ((char *)*base - idx);

  return PS_OK;
}

@


1.24.2.2
log
@2005-03-30  Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in (arm-linux-nat.o): Update dependencies.
	* gdb/arm-linux-nat.c: Include "gdb_assert.h".
	(PTRACE_GETWMMXREGS, PTRACE_SETWMMXREGS): Define.
	(arm_linux_has_wmmx_registers): New flag.
	(GET_THREAD_ID): Remove stray punctuation.
	(IWMMXT_REGS_SIZE): Define.
	(fetch_wmmx_regs, store_wmmx_regs): New functions.
	(fetch_inferior_registers, store_inferior_registers): Call them.
	(arm_linux_available_registers): New function.
	* gdb/inftarg.c (child_xfer_partial): Handle
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/config/arm/nm-linux.h (arm_linux_available_registers): Add
	prototype.
	(NATIVE_XFER_AVAILABLE_REGISTERS): Define.

	* gdb/gdbserver/linux-arm-low.c (arm_fill_wmmxregset)
	(arm_store_wmmxregset): Remove stray text.
	(arm_available_registers): Remove debugging output.  Use hex.
	* gdb/gdbserver/regcache.c (num_registers): Make global.
	* gdb/gdbserver/server.c (handle_p_packet, handle_P_packet): Check
	the value of regnum.

2005-03-28  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in: arm-tdep.o depends on $(observer_h).
	* gdb/arm-linux-nat.c (fetch_fpregister, fetch_fpregs,
	store_fpregister, store_fpregs): Rename...
	(fetch_fpa_register, fetch_fpa_regs, store_fpa_register,
	store_fpa_regs): ... to this.
	* gdb/arm-linux-tdep.c (arm_linux_init_abi): Provide ABI specific
	overrides.
	* gdb/arm-tdep.c: Include opserver.h.
	(struct gdbarch_tdep_info): Add.
	(arm_push_dummy_call): Handle doubleword alignment.
	(arm_register_type): Handle iWMMXt and VFP regs.
	(arm_register_byte): Ditto.
	(arm_pseudo_register_read): New function.
	(arm_pseudo_register_write): New function.
	(arm_dwarf_reg_to_regnum): New function.
	(arm_register_sim_regno): Handle iWMMXT regs.
	(arm_register_remote_regno): New function.
	(arm_extract_return_value): Use new macro names.
	(arm_register_name): Handle iWMMXt and VFP registers.
	(arm_sim_available_registers): New function.
	(arm_update_architecture): New function.
	(arm_gdbarch_init): Handle optional register sets.  Register new
	hooks.  Fix misleading error message.
	(_initialize_arm_tdep): Call observer_attach_inferior_created.
	* gdb/arm-tdep.h (ARM_NUM_FP_ARG_REGS, ARM_LAST_FP_ARG_REGNUM,
	FP_REGISTER_SIZE, NUM_FREGS): Rename ...
	(ARM_NUM_FPA_ARG_REGS, ARM_LAST_FPA_ARG_REGNUM, FPA_REGISTER_SIZE,
	NUM_FPA_REGS): ... to this.
	(NUM_IWMMXT_COP0REGS, NUM_IWMMXT_COP1REGS, NUM_IWMMXT_REGS,
	IWMMXT_COP0_REGSIZE, IWMMXT_COP1_REGSIZE, NUM_VFP_XREGS,
	VFP_XREG_SIZE, NUM_VFP_SREGS, VFP_SREG_SIZE, NUM_VFP_PSEUDOS): Define.
	(struct gdbarch_tdep): Add target_has_iwmmxt_regs,
	target_has_vfp_regs, first_iwmmxt_regnum, target_iwmmxt_regnum,
	first_vfp_regnum, first_vfp_pseudo and target_vfp_regnum.
	* gdb/gdbarch.c (struct gdbarch): Add remote_num_g_packet_regs,
	sim_available_registers and register_remote_regno.
	(startup_gdbarch, verify_gdbarch): Ditto.
	(gdbarch_dump): Dump new fields.
	(gdbarch_remote_num_g_packet_regs_p, gdbarch_remote_num_g_packet_regs,
	set_gdbarch_remote_num_g_packet_regs,
	gdbarch_sim_available_registers_p, gdbarch_sim_available_registers,
	set_gdbarch_sim_available_registers, gdbarch_register_remote_regno_p,
	gdbarch_register_remote_regno, set_gdbarch_register_remote_regno):
	New functions.
	* gdb/gdbarch.h: Add prototypes.
	* gdb/gdbarch.sh: Add new fields.
	(deprecated_current_gdbarch_select_hack): Call flush_cached_frames.
	* gdb/remote-sim.h (gdbsim_create_inferior): Call
	observer_notify_inferior_created.
	(gdbsim_xfer_partial): New function.
	(init_gdbsim_ops): Use it.
	* gdb/remote.c (struct remote_state): Add num_g_regs.
	(init_remote_state): Only consider hard regs.  Allow target to provide
	register mapping.
	(packet_reg_from_regnum): Don't check pseudo regs.
	(packet_reg_from_pnum): Ditto.
	(remote_protocol_qPart_availableRegisters): Add.
	(set_remote_protocol_qPart_availableRegisters_packet_cmd,
	show_remote_protocol_qPart_availableRegisters_packet_cmd): New
	functions.
	(fetch_register_using_p, store_register_using_P): Handle arbitrary
	register mappings.
	(fetch_registers_using_g): New function.
	(remote_fetch_registers): Use it.
	(store_registers_using_G): New function.
	(remote_store_registers): Use it.
	(remote_xfer_partial): Handle TARGET_OBJECT_AVAILABLE_REGISTERS.
	(show_remote_cmd): Display availableRegisters.
	(_initialize_remote): Register qPart_availableRegisters.
	* gdb/target.h (enum target_object): Add
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/gdbserver/configure.srv (arm*-*-linux*): set
	srv_linux_regsets=yes.
	* gdb/gdbserver/linux-arm-low.c (PTRACE_GETWMMXREGS,
	PTRACE_SETWMMXREGS): Define.
	(arm_fill_gregset, arm_store_gregset, arm_fill_wmmxregset,
	arm_store_wmmxregset, arm_available_registers): New functions.
	(target_regsets): Add.
	(the_low_target): Use arm_available_registers.
	* gdb/gdbserver/linux-low.c (linux_available_registers): New function.
	(linux_target_op): Use it.
	* gdb/gdbserver/linux-low.h (gdbserver/linux-low.h): Add
	available_registers.
	(use_regsets_p): Declare.
	* gdb/gdbserver/regcache.c (g_register_bytes): Add.
	(regcache_invalidate, registers_to_string, registers_from_string):
	Use it.
	(set_register_cache): Set g_register_bytes.
	(supply_register_as_string): New function.
	* gdb/gdbserver/regcache.h (supply_register_as_string): Add prototype.
	* gdb/gdbserver/server.c (handle_query): Handle
	qPart:availableRegisters.
	(handle_p_packet, handle_P_packet): New functions.
	(main): Handle 'p' and 'P' packets.
	* gdb/gdbserver/target.h (struct target_ops): Add available_registers.
	* gdb/regformats/reg-arm.dat: Add last_g_reg and iWMMXT regs.
	* gdb/regformats/regdat.sh: Handle last_g_reg.
	* gdb/regformats/regdef.h (set_register_cache): Update prototype.
@
text
@a28 1
#include "gdb_assert.h"
a46 7
#ifndef PTRACE_GETWMMXREGS
#define PTRACE_GETWMMXREGS 18
#define PTRACE_SETWMMXREGS 19
#endif

static int arm_linux_has_wmmx_registers = 1;

d237 1
a237 1
fetch_fpa_register (int regno)
d286 1
a286 1
fetch_fpa_regs (void)
d334 1
a334 1
store_fpa_register (int regno)
d372 1
a372 1
store_fpa_regs (void)
a555 91
/* Fetch all WMMX registers of the process and store into
   regcache.  */

#define IWMMXT_REGS_SIZE (16 * 8 + 6 * 4)

static void
fetch_wmmx_regs (void)
{
  char regbuf[IWMMXT_REGS_SIZE];
  int ret, regno, tid, first;

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_ptid);
  
  ret = ptrace (PTRACE_GETWMMXREGS, tid, 0, regbuf);
  if (ret < 0)
    {
      warning (_("Unable to fetch WMMX registers."));
      return;
    }

  first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;

  for (regno = 0; regno < NUM_IWMMXT_COP0REGS; regno++)
    regcache_raw_supply (current_regcache, first + regno,
			 &regbuf[regno * 8]);

  first += NUM_IWMMXT_COP0REGS;

  for (regno = 0; regno < 2; regno++)
    regcache_raw_supply (current_regcache, first + regno, NULL);

  for (regno = 2; regno < 4; regno++)
    regcache_raw_supply (current_regcache, first + regno,
			 &regbuf[16 * 8 + (regno - 2) * 4]);

  for (regno = 4; regno < 8; regno++)
    regcache_raw_supply (current_regcache, first + regno, NULL);

  for (regno = 8; regno < 12; regno++)
    regcache_raw_supply (current_regcache, first + regno,
			 &regbuf[16 * 8 + 2 * 4 + (regno - 8) * 4]);

  for (regno = 12; regno < 16; regno++)
    regcache_raw_supply (current_regcache, first + regno, NULL);
}

static void
store_wmmx_regs (void)
{
  char regbuf[IWMMXT_REGS_SIZE];
  int ret, regno, tid, first;

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_ptid);
  
  ret = ptrace (PTRACE_GETWMMXREGS, tid, 0, regbuf);
  if (ret < 0)
    {
      warning (_("Unable to fetch WMMX registers."));
      return;
    }

  first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;

  for (regno = 0; regno < NUM_IWMMXT_COP0REGS; regno++)
    if (register_cached (first + regno))
      regcache_raw_collect (current_regcache, first + regno,
			    &regbuf[regno * 8]);

  first += 18;
  for (regno = 0; regno < 2; regno++)
    if (register_cached (first + regno))
      regcache_raw_collect (current_regcache, first + regno,
			    &regbuf[16 * 8 + regno * 4]);

  first += 6;
  for (regno = 0; regno < 4; regno++)
    if (register_cached (first + regno))
      regcache_raw_collect (current_regcache, first + regno,
			    &regbuf[16 * 8 + 2 * 4 + regno * 4]);

  ret = ptrace (PTRACE_SETWMMXREGS, tid, 0, regbuf);

  if (ret < 0)
    {
      warning (_("Unable to store WMMX registers."));
      return;
    }
}

d566 1
a566 3
      fetch_fpa_regs ();
      if (arm_linux_has_wmmx_registers)
	fetch_wmmx_regs ();
d570 1
a570 1
      if (regno < ARM_F0_REGNUM || regno == ARM_PS_REGNUM)
d572 3
a574 8
      else if (regno >= ARM_F0_REGNUM && regno <= ARM_FPS_REGNUM)
        fetch_fpa_register (regno);
      else if (arm_linux_has_wmmx_registers)
	{
	  int first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;
	  if (regno >= first && regno < first + NUM_IWMMXT_REGS)
	    fetch_wmmx_regs ();
	}
d588 1
a588 3
      store_fpa_regs ();
      if (arm_linux_has_wmmx_registers)
	store_wmmx_regs ();
d592 1
a592 1
      if (regno < ARM_F0_REGNUM || regno == ARM_PS_REGNUM)
d594 3
a596 8
      else if ((regno >= ARM_F0_REGNUM) && (regno <= ARM_FPS_REGNUM))
        store_fpa_register (regno); 
      else if (arm_linux_has_wmmx_registers)
	{
	  int first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;
	  if (regno >= first && regno < first + NUM_IWMMXT_REGS)
	    store_wmmx_regs ();
	}
a747 44
LONGEST
arm_linux_available_registers (struct target_ops *ops,
			       int /* enum target_object */ object,
			       const char *annex,
			       void *readbuf,
			       const void *writebuf,
			       ULONGEST offset,
			       LONGEST len)
{
  char *result = NULL;
  int total_len;

  gdb_assert (object == TARGET_OBJECT_AVAILABLE_REGISTERS);
  gdb_assert (readbuf && !writebuf);

  if (arm_linux_has_wmmx_registers)
    {
      int ret;
      char regbuf[IWMMXT_REGS_SIZE];

      ret = ptrace (PTRACE_GETWMMXREGS, GET_THREAD_ID (inferior_ptid), 0,
		    regbuf);
      if (ret < 0)
	/* Should we be checking the error code?  */
	arm_linux_has_wmmx_registers = 0;
    }

  if (arm_linux_has_wmmx_registers)
    result = "iwmmxt";

  if (result == NULL)
    return 0;

  total_len = strlen (result);
  if (total_len > offset)
    {
      int bytes_read = min (total_len - offset, len);
      memcpy (readbuf, result + offset, bytes_read);
      return bytes_read;
    }

  return 0;
}

@


1.23
log
@	* arm-linux-nat.c (store_register, store_regs): Handle
	ARM_PS_REGNUM.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d27 2
d553 2
a554 2
void
fetch_inferior_registers (int regno)
d575 2
a576 2
void
store_inferior_registers (int regno)
d722 2
d727 2
d730 10
@


1.22
log
@2005-01-05  Baurjan Ismagulov  <ibr@@ata.cs.hun.edu.tr>

	Committed by Andrew Cagney.
	* ada-valprint.c, aix-thread.c, alpha-nat.c: I18n markup.
	* alphabsd-nat.c, alphanbsd-tdep.c, amd64-linux-nat.c: I18n markup.
	* amd64-tdep.c,	amd64bsd-nat.c, amd64fbsd-nat.c: I18n markup.
	* arch-utils.c, arm-linux-nat.c, arm-tdep.c: I18n markup.
	* armnbsd-nat.c, armnbsd-tdep.c, auxv.c, avr-tdep.c: I18n markup.
	* aix-thread.c (_initialize_aix_thread): Get rid of the
	deprecated_add_show_from_set call.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* command.h (add_setshow_enum_cmd): Add arguments for returning
	new list elements.
	* cli/cli-decode.c (add_setshow_enum_cmd): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Modify calls to
	add_setshow_enum_cmd.
@
text
@d495 6
d533 4
@


1.22.2.1
log
@	* gdb/arm-linux-nat.c (store_register, store_regs): Handle
	ARM_PS_REGNUM.
@
text
@a494 6
  else if (arm_apcs_32 && regno == ARM_PS_REGNUM)
    regcache_raw_collect (current_regcache, regno,
			 (char *) &regs[ARM_CPSR_REGNUM]);
  else if (!arm_apcs_32 && regno == ARM_PS_REGNUM)
    regcache_raw_collect (current_regcache, ARM_PC_REGNUM,
			 (char *) &regs[ARM_PC_REGNUM]);
a526 4
  if (arm_apcs_32 && register_cached (ARM_PS_REGNUM))
    regcache_raw_collect (current_regcache, ARM_PS_REGNUM,
			 (char *) &regs[ARM_CPSR_REGNUM]);

@


1.22.2.2
log
@	* gdb/Makefile.in (arm-linux-nat.o): Update dependencies.
	* gdb/arm-linux-nat.c: Include "gdb_proc_service.h".
	(PTRACE_GET_THREAD_AREA): Define.
	(ps_get_thread_area): New function.

	* gdb/gdbserver/Makefile.in (linux-arm-low.o): Update dependencies.
	* gdb/gdbserver/linux-arm-low.c: Include "../gdb_proc_service.h".
	(PTRACE_GET_THREAD_AREA): Define.
	(ps_get_thread_area): New function.
@
text
@a36 7
/* Defines ps_err_e, struct ps_prochandle.  */
#include "gdb_proc_service.h"

#ifndef PTRACE_GET_THREAD_AREA
#define PTRACE_GET_THREAD_AREA 22
#endif

a693 17
/* Fetch the thread-local storage pointer for libthread_db.  */

ps_err_e
ps_get_thread_area (const struct ps_prochandle *ph,
                    lwpid_t lwpid, int idx, void **base)
{
  if (ptrace (PTRACE_GET_THREAD_AREA, lwpid, NULL, base) != 0)
    return PS_ERR;

  /* IDX is the bias from the thread pointer to the beginning of the
     thread descriptor.  It has to be subtracted due to implementation
     quirks in libthread_db.  */
  *base = (void *) ((char *)*base - idx);

  return PS_OK;
}

@


1.22.2.3
log
@2005-03-28  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in: arm-tdep.o depends on $(observer_h).
	* gdb/arm-linux-nat.c (fetch_fpregister, fetch_fpregs,
	store_fpregister, store_fpregs): Rename...
	(fetch_fpa_register, fetch_fpa_regs, store_fpa_register,
	store_fpa_regs): ... to this.
	* gdb/arm-linux-tdep.c (arm_linux_init_abi): Provide ABI specific
	overrides.
	* gdb/arm-tdep.c: Include opserver.h.
	(struct gdbarch_tdep_info): Add.
	(arm_push_dummy_call): Handle doubleword alignment.
	(arm_register_type): Handle iWMMXt and VFP regs.
	(arm_register_byte): Ditto.
	(arm_pseudo_register_read): New function.
	(arm_pseudo_register_write): New function.
	(arm_dwarf_reg_to_regnum): New function.
	(arm_register_sim_regno): Handle iWMMXT regs.
	(arm_register_remote_regno): New function.
	(arm_extract_return_value): Use new macro names.
	(arm_register_name): Handle iWMMXt and VFP registers.
	(arm_sim_available_registers): New function.
	(arm_update_architecture): New function.
	(arm_gdbarch_init): Handle optional register sets.  Register new
	hooks.  Fix misleading error message.
	(_initialize_arm_tdep): Call observer_attach_inferior_created.
	* gdb/arm-tdep.h (ARM_NUM_FP_ARG_REGS, ARM_LAST_FP_ARG_REGNUM,
	FP_REGISTER_SIZE, NUM_FREGS): Rename ...
	(ARM_NUM_FPA_ARG_REGS, ARM_LAST_FPA_ARG_REGNUM, FPA_REGISTER_SIZE,
	NUM_FPA_REGS): ... to this.
	(NUM_IWMMXT_COP0REGS, NUM_IWMMXT_COP1REGS, NUM_IWMMXT_REGS,
	IWMMXT_COP0_REGSIZE, IWMMXT_COP1_REGSIZE, NUM_VFP_XREGS,
	VFP_XREG_SIZE, NUM_VFP_SREGS, VFP_SREG_SIZE, NUM_VFP_PSEUDOS): Define.
	(struct gdbarch_tdep): Add target_has_iwmmxt_regs,
	target_has_vfp_regs, first_iwmmxt_regnum, target_iwmmxt_regnum,
	first_vfp_regnum, first_vfp_pseudo and target_vfp_regnum.
	* gdb/gdbarch.c (struct gdbarch): Add remote_num_g_packet_regs,
	sim_available_registers and register_remote_regno.
	(startup_gdbarch, verify_gdbarch): Ditto.
	(gdbarch_dump): Dump new fields.
	(gdbarch_remote_num_g_packet_regs_p, gdbarch_remote_num_g_packet_regs,
	set_gdbarch_remote_num_g_packet_regs,
	gdbarch_sim_available_registers_p, gdbarch_sim_available_registers,
	set_gdbarch_sim_available_registers, gdbarch_register_remote_regno_p,
	gdbarch_register_remote_regno, set_gdbarch_register_remote_regno):
	New functions.
	* gdb/gdbarch.h: Add prototypes.
	* gdb/gdbarch.sh: Add new fields.
	(deprecated_current_gdbarch_select_hack): Call flush_cached_frames.
	* gdb/remote-sim.h (gdbsim_create_inferior): Call
	observer_notify_inferior_created.
	(gdbsim_xfer_partial): New function.
	(init_gdbsim_ops): Use it.
	* gdb/remote.c (struct remote_state): Add num_g_regs.
	(init_remote_state): Only consider hard regs.  Allow target to provide
	register mapping.
	(packet_reg_from_regnum): Don't check pseudo regs.
	(packet_reg_from_pnum): Ditto.
	(remote_protocol_qPart_availableRegisters): Add.
	(set_remote_protocol_qPart_availableRegisters_packet_cmd,
	show_remote_protocol_qPart_availableRegisters_packet_cmd): New
	functions.
	(fetch_register_using_p, store_register_using_P): Handle arbitrary
	register mappings.
	(fetch_registers_using_g): New function.
	(remote_fetch_registers): Use it.
	(store_registers_using_G): New function.
	(remote_store_registers): Use it.
	(remote_xfer_partial): Handle TARGET_OBJECT_AVAILABLE_REGISTERS.
	(show_remote_cmd): Display availableRegisters.
	(_initialize_remote): Register qPart_availableRegisters.
	* gdb/target.h (enum target_object): Add
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/gdbserver/configure.srv (arm*-*-linux*): set
	srv_linux_regsets=yes.
	* gdb/gdbserver/linux-arm-low.c (PTRACE_GETWMMXREGS,
	PTRACE_SETWMMXREGS): Define.
	(arm_fill_gregset, arm_store_gregset, arm_fill_wmmxregset,
	arm_store_wmmxregset, arm_available_registers): New functions.
	(target_regsets): Add.
	(the_low_target): Use arm_available_registers.
	* gdb/gdbserver/linux-low.c (linux_available_registers): New function.
	(linux_target_op): Use it.
	* gdb/gdbserver/linux-low.h (gdbserver/linux-low.h): Add
	available_registers.
	(use_regsets_p): Declare.
	* gdb/gdbserver/regcache.c (g_register_bytes): Add.
	(regcache_invalidate, registers_to_string, registers_from_string):
	Use it.
	(set_register_cache): Set g_register_bytes.
	(supply_register_as_string): New function.
	* gdb/gdbserver/regcache.h (supply_register_as_string): Add prototype.
	* gdb/gdbserver/server.c (handle_query): Handle
	qPart:availableRegisters.
	(handle_p_packet, handle_P_packet): New functions.
	(main): Handle 'p' and 'P' packets.
	* gdb/gdbserver/target.h (struct target_ops): Add available_registers.
	* gdb/regformats/reg-arm.dat: Add last_g_reg and iWMMXT regs.
	* gdb/regformats/regdat.sh: Handle last_g_reg.
	* gdb/regformats/regdef.h (set_register_cache): Update prototype.
@
text
@d234 1
a234 1
fetch_fpa_register (int regno)
d283 1
a283 1
fetch_fpa_regs (void)
d331 1
a331 1
store_fpa_register (int regno)
d369 1
a369 1
store_fpa_regs (void)
d563 1
a563 1
      fetch_fpa_regs ();
d571 1
a571 1
        fetch_fpa_register (regno);
d585 1
a585 1
      store_fpa_regs ();
d593 1
a593 1
        store_fpa_register (regno);
@


1.22.2.4
log
@	* gdb/Makefile.in (arm-linux-nat.o): Update dependencies.
	* gdb/arm-linux-nat.c: Include "gdb_assert.h".
	(PTRACE_GETWMMXREGS, PTRACE_SETWMMXREGS): Define.
	(arm_linux_has_wmmx_registers): New flag.
	(GET_THREAD_ID): Remove stray punctuation.
	(IWMMXT_REGS_SIZE): Define.
	(fetch_wmmx_regs, store_wmmx_regs): New functions.
	(fetch_inferior_registers, store_inferior_registers): Call them.
	(arm_linux_available_registers): New function.
	* gdb/inftarg.c (child_xfer_partial): Handle
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/config/arm/nm-linux.h (arm_linux_available_registers): Add
	prototype.
	(NATIVE_XFER_AVAILABLE_REGISTERS): Define.

	* gdb/gdbserver/linux-arm-low.c (arm_fill_wmmxregset)
	(arm_store_wmmxregset): Remove stray text.
	(arm_available_registers): Remove debugging output.  Use hex.
	* gdb/gdbserver/regcache.c (num_registers): Make global.
	* gdb/gdbserver/server.c (handle_p_packet, handle_P_packet): Check
	the value of regnum.
@
text
@a25 1
#include "gdb_assert.h"
a43 7
#ifndef PTRACE_GETWMMXREGS
#define PTRACE_GETWMMXREGS 18
#define PTRACE_SETWMMXREGS 19
#endif

static int arm_linux_has_wmmx_registers = 1;

d102 1
a102 1
#define GET_THREAD_ID(PTID)	get_thread_id (PTID)
a552 91
/* Fetch all WMMX registers of the process and store into
   regcache.  */

#define IWMMXT_REGS_SIZE (16 * 8 + 6 * 4)

static void
fetch_wmmx_regs (void)
{
  char regbuf[IWMMXT_REGS_SIZE];
  int ret, regno, tid, first;

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_ptid);
  
  ret = ptrace (PTRACE_GETWMMXREGS, tid, 0, regbuf);
  if (ret < 0)
    {
      warning (_("Unable to fetch WMMX registers."));
      return;
    }

  first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;

  for (regno = 0; regno < NUM_IWMMXT_COP0REGS; regno++)
    regcache_raw_supply (current_regcache, first + regno,
			 &regbuf[regno * 8]);

  first += NUM_IWMMXT_COP0REGS;

  for (regno = 0; regno < 2; regno++)
    regcache_raw_supply (current_regcache, first + regno, NULL);

  for (regno = 2; regno < 4; regno++)
    regcache_raw_supply (current_regcache, first + regno,
			 &regbuf[16 * 8 + (regno - 2) * 4]);

  for (regno = 4; regno < 8; regno++)
    regcache_raw_supply (current_regcache, first + regno, NULL);

  for (regno = 8; regno < 12; regno++)
    regcache_raw_supply (current_regcache, first + regno,
			 &regbuf[16 * 8 + 2 * 4 + (regno - 8) * 4]);

  for (regno = 12; regno < 16; regno++)
    regcache_raw_supply (current_regcache, first + regno, NULL);
}

static void
store_wmmx_regs (void)
{
  char regbuf[IWMMXT_REGS_SIZE];
  int ret, regno, tid, first;

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_ptid);
  
  ret = ptrace (PTRACE_GETWMMXREGS, tid, 0, regbuf);
  if (ret < 0)
    {
      warning (_("Unable to fetch WMMX registers."));
      return;
    }

  first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;

  for (regno = 0; regno < NUM_IWMMXT_COP0REGS; regno++)
    if (register_cached (first + regno))
      regcache_raw_collect (current_regcache, first + regno,
			    &regbuf[regno * 8]);

  first += 18;
  for (regno = 0; regno < 2; regno++)
    if (register_cached (first + regno))
      regcache_raw_collect (current_regcache, first + regno,
			    &regbuf[16 * 8 + regno * 4]);

  first += 6;
  for (regno = 0; regno < 4; regno++)
    if (register_cached (first + regno))
      regcache_raw_collect (current_regcache, first + regno,
			    &regbuf[16 * 8 + 2 * 4 + regno * 4]);

  ret = ptrace (PTRACE_SETWMMXREGS, tid, 0, regbuf);

  if (ret < 0)
    {
      warning (_("Unable to store WMMX registers."));
      return;
    }
}

a563 2
      if (arm_linux_has_wmmx_registers)
	fetch_wmmx_regs ();
d567 1
a567 1
      if (regno < ARM_F0_REGNUM || regno == ARM_PS_REGNUM)
d569 2
a570 1
      else if (regno >= ARM_F0_REGNUM && regno <= ARM_FPS_REGNUM)
a571 6
      else if (arm_linux_has_wmmx_registers)
	{
	  int first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;
	  if (regno >= first && regno < first + NUM_IWMMXT_REGS)
	    fetch_wmmx_regs ();
	}
a585 2
      if (arm_linux_has_wmmx_registers)
	store_wmmx_regs ();
d589 1
a589 1
      if (regno < ARM_F0_REGNUM || regno == ARM_PS_REGNUM)
d591 3
a593 8
      else if ((regno >= ARM_F0_REGNUM) && (regno <= ARM_FPS_REGNUM))
        store_fpa_register (regno); 
      else if (arm_linux_has_wmmx_registers)
	{
	  int first = gdbarch_tdep (current_gdbarch)->first_iwmmxt_regnum;
	  if (regno >= first && regno < first + NUM_IWMMXT_REGS)
	    store_wmmx_regs ();
	}
a742 44
LONGEST
arm_linux_available_registers (struct target_ops *ops,
			       int /* enum target_object */ object,
			       const char *annex,
			       void *readbuf,
			       const void *writebuf,
			       ULONGEST offset,
			       LONGEST len)
{
  char *result = NULL;
  int total_len;

  gdb_assert (object == TARGET_OBJECT_AVAILABLE_REGISTERS);
  gdb_assert (readbuf && !writebuf);

  if (arm_linux_has_wmmx_registers)
    {
      int ret;
      char regbuf[IWMMXT_REGS_SIZE];

      ret = ptrace (PTRACE_GETWMMXREGS, GET_THREAD_ID (inferior_ptid), 0,
		    regbuf);
      if (ret < 0)
	/* Should we be checking the error code?  */
	arm_linux_has_wmmx_registers = 0;
    }

  if (arm_linux_has_wmmx_registers)
    result = "iwmmxt";

  if (result == NULL)
    return 0;

  total_len = strlen (result);
  if (total_len > offset)
    {
      int bytes_read = min (total_len - offset, len);
      memcpy (readbuf, result + offset, bytes_read);
      return bytes_read;
    }

  return 0;
}

@


1.21
log
@2004-07-23  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_collect instead of regcache_collect.
	* regcache.h (regcache_collect): Delete declaration.
	* regcache.c (regcache_colect): Delete function.
	* win32-nat.c (do_child_store_inferior_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_fill_reg): Update.
	* rs6000-nat.c (store_register): Update.
	* remote.c (store_register_using_P, remote_store_registers): Update.
	* ppcnbsd-tdep.c (ppcnbsd_fill_reg): Update.
	* ppc-linux-nat.c (store_altivec_register, store_spe_register)
	(fill_vrregset, store_spe_registers, fill_gregset)
	(fill_gregset): Update.
	* nto-procfs.c (procfs_store_registers): Update.
	* mipsnbsd-tdep.c (mipsnbsd_fill_reg): Update.
	* mips-linux-tdep.c (fill_gregset, mips64_fill_gregset): Update.
	* m68klinux-nat.c (store_register, fill_gregset): Update.
	* m68k-tdep.c (fill_gregset): Update.
	* infptrace.c (store_register): Update.
	* i386-nto-tdep.c (i386nto_regset_fill): Update.
	* i386-linux-nat.c (store_register, fill_gregset): Update.
	* hppa-linux-nat.c (fill_gregset): Update.
	* go32-nat.c (store_register): Update.
	* armnbsd-nat.c (store_register, store_regs, store_fp_register)
	(store_fp_regs): Update.
	* arm-linux-nat.c (store_nwfpe_single, store_nwfpe_double)
	(store_nwfpe_extended, store_fpregister, store_fpregs)
	(store_register, store_regs, fill_gregset, fill_fpregset): Update.
	* alpha-tdep.c (alpha_fill_int_regs, alpha_fill_fp_regs): Update.
	* aix-thread.c (fill_gprs64, fill_fprs, fill_sprs64, fill_sprs32)
	(store_regs_user_thread, store_regs_kernel_thread): Update.
@
text
@d239 1
a239 1
      warning ("Unable to fetch floating point register.");
d288 1
a288 1
      warning ("Unable to fetch the floating point registers.");
d336 1
a336 1
      warning ("Unable to fetch the floating point registers.");
d353 1
a353 1
      warning ("Unable to store floating point register.");
d374 1
a374 1
      warning ("Unable to fetch the floating point registers.");
d391 1
a391 1
      warning ("Unable to store floating point registers.");
d411 1
a411 1
      warning ("Unable to fetch general register.");
d451 1
a451 1
      warning ("Unable to fetch general registers.");
d489 1
a489 1
      warning ("Unable to fetch general registers.");
d499 1
a499 1
      warning ("Unable to store general register.");
d517 1
a517 1
      warning ("Unable to fetch general registers.");
d531 1
a531 1
      warning ("Unable to store general registers.");
d694 1
a694 1
      warning ("Unable to determine GNU/Linux version.");
@


1.20
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d168 2
a169 1
  regcache_collect (ARM_F0_REGNUM + fn, (char *) &mem[0]);
d179 2
a180 1
  regcache_collect (ARM_F0_REGNUM + fn, (char *) &mem[0]);
d191 2
a192 1
  regcache_collect (ARM_F0_REGNUM + fn, (char *) &mem[0]);
d342 1
a342 1
    regcache_collect (ARM_FPS_REGNUM, (char *) &fp.fpsr);
d380 1
a380 1
    regcache_collect (ARM_FPS_REGNUM, (char *) &fp.fpsr);
d494 1
a494 1
    regcache_collect (regno, (char *) &regs[regno]);
d524 1
a524 1
	regcache_collect (regno, (char *) &regs[regno]);
d591 2
a592 1
	regcache_collect (regnum, (char *) &(*gregsetp)[regnum]);
d595 2
a596 1
    regcache_collect (regno, (char *) &(*gregsetp)[regno]);
d601 2
a602 2
	regcache_collect (ARM_PS_REGNUM,
			  (char *) &(*gregsetp)[ARM_CPSR_REGNUM]);
d604 2
a605 2
	regcache_collect (ARM_PC_REGNUM,
			  (char *) &(*gregsetp)[ARM_PC_REGNUM]);
d655 2
a656 1
    regcache_collect (ARM_FPS_REGNUM, (char *) &fp->fpsr);
@


1.19
log
@* arm-linux-nat.c (store_newfpe_single): Use regcache_collect.
(store_newfpe_double, store_newfpe_extended, store_fpregister)
(store_register, store_regs, fill_gregset, fill_fpregset): Likewise.
@
text
@d105 1
a105 1
  supply_register (ARM_F0_REGNUM + fn, (char *) &mem[0]);
d116 1
a116 1
  supply_register (ARM_F0_REGNUM + fn, (char *) &mem[0]);
d125 1
a125 1
  supply_register (ARM_F0_REGNUM + fn, (char *) &mem[0]);
d136 1
a136 1
  supply_register (ARM_F0_REGNUM + fn, (char *) &mem[0]);
d242 1
a242 1
    supply_register (ARM_FPS_REGNUM, (char *) &fp.fpsr);
d290 1
a290 1
  supply_register (ARM_FPS_REGNUM, (char *) &fp.fpsr);
d413 1
a413 1
    supply_register (regno, (char *) &regs[regno]);
d418 2
a419 1
        supply_register (ARM_PS_REGNUM, (char *) &regs[ARM_CPSR_REGNUM]);
d421 2
a422 1
        supply_register (ARM_PS_REGNUM, (char *) &regs[ARM_PC_REGNUM]);
d428 2
a429 1
      supply_register (ARM_PC_REGNUM, (char *) &regs[ARM_PC_REGNUM]);
d453 1
a453 1
    supply_register (regno, (char *) &regs[regno]);
d456 2
a457 1
    supply_register (ARM_PS_REGNUM, (char *) &regs[ARM_CPSR_REGNUM]);
d459 2
a460 1
    supply_register (ARM_PS_REGNUM, (char *) &regs[ARM_PC_REGNUM]);
d463 2
a464 1
  supply_register (ARM_PC_REGNUM, (char *) &regs[ARM_PC_REGNUM]);
d613 2
a614 1
    supply_register (regno, (char *) &(*gregsetp)[regno]);
d617 2
a618 1
    supply_register (ARM_PS_REGNUM, (char *) &(*gregsetp)[ARM_CPSR_REGNUM]);
d620 2
a621 1
    supply_register (ARM_PS_REGNUM, (char *) &(*gregsetp)[ARM_PC_REGNUM]);
d624 1
a624 1
  supply_register (ARM_PC_REGNUM, (char *) &reg_pc);
d663 1
a663 1
  supply_register (ARM_FPS_REGNUM, (char *) &fp->fpsr);
@


1.19.64.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d105 1
a105 1
  regcache_raw_supply (current_regcache, ARM_F0_REGNUM + fn, (char *) &mem[0]);
d116 1
a116 1
  regcache_raw_supply (current_regcache, ARM_F0_REGNUM + fn, (char *) &mem[0]);
d125 1
a125 1
  regcache_raw_supply (current_regcache, ARM_F0_REGNUM + fn, (char *) &mem[0]);
d136 1
a136 1
  regcache_raw_supply (current_regcache, ARM_F0_REGNUM + fn, (char *) &mem[0]);
d168 1
a168 2
  regcache_raw_collect (current_regcache, ARM_F0_REGNUM + fn,
			(char *) &mem[0]);
d178 1
a178 2
  regcache_raw_collect (current_regcache, ARM_F0_REGNUM + fn,
			(char *) &mem[0]);
d189 1
a189 2
  regcache_raw_collect (current_regcache, ARM_F0_REGNUM + fn,
			(char *) &mem[0]);
d242 1
a242 1
    regcache_raw_supply (current_regcache, ARM_FPS_REGNUM, (char *) &fp.fpsr);
d290 1
a290 1
  regcache_raw_supply (current_regcache, ARM_FPS_REGNUM, (char *) &fp.fpsr);
d339 1
a339 1
    regcache_raw_collect (current_regcache, ARM_FPS_REGNUM, (char *) &fp.fpsr);
d377 1
a377 1
    regcache_raw_collect (current_regcache, ARM_FPS_REGNUM, (char *) &fp.fpsr);
d413 1
a413 1
    regcache_raw_supply (current_regcache, regno, (char *) &regs[regno]);
d418 1
a418 2
        regcache_raw_supply (current_regcache, ARM_PS_REGNUM,
			     (char *) &regs[ARM_CPSR_REGNUM]);
d420 1
a420 2
        regcache_raw_supply (current_regcache, ARM_PS_REGNUM,
			     (char *) &regs[ARM_PC_REGNUM]);
d426 1
a426 2
      regcache_raw_supply (current_regcache, ARM_PC_REGNUM,
			   (char *) &regs[ARM_PC_REGNUM]);
d450 1
a450 1
    regcache_raw_supply (current_regcache, regno, (char *) &regs[regno]);
d453 1
a453 2
    regcache_raw_supply (current_regcache, ARM_PS_REGNUM,
			 (char *) &regs[ARM_CPSR_REGNUM]);
d455 1
a455 2
    regcache_raw_supply (current_regcache, ARM_PS_REGNUM,
			 (char *) &regs[ARM_PC_REGNUM]);
d458 1
a458 2
  regcache_raw_supply (current_regcache, ARM_PC_REGNUM,
		       (char *) &regs[ARM_PC_REGNUM]);
d485 1
a485 1
    regcache_raw_collect (current_regcache, regno, (char *) &regs[regno]);
d515 1
a515 1
	regcache_raw_collect (current_regcache, regno, (char *) &regs[regno]);
d582 1
a582 2
	regcache_raw_collect (current_regcache, regnum,
			      (char *) &(*gregsetp)[regnum]);
d585 1
a585 2
    regcache_raw_collect (current_regcache, regno,
			  (char *) &(*gregsetp)[regno]);
d590 2
a591 2
	regcache_raw_collect (current_regcache, ARM_PS_REGNUM,
			      (char *) &(*gregsetp)[ARM_CPSR_REGNUM]);
d593 2
a594 2
	regcache_raw_collect (current_regcache, ARM_PC_REGNUM,
			      (char *) &(*gregsetp)[ARM_PC_REGNUM]);
d607 1
a607 2
    regcache_raw_supply (current_regcache, regno,
			 (char *) &(*gregsetp)[regno]);
d610 1
a610 2
    regcache_raw_supply (current_regcache, ARM_PS_REGNUM,
			 (char *) &(*gregsetp)[ARM_CPSR_REGNUM]);
d612 1
a612 2
    regcache_raw_supply (current_regcache, ARM_PS_REGNUM,
			 (char *) &(*gregsetp)[ARM_PC_REGNUM]);
d615 1
a615 1
  regcache_raw_supply (current_regcache, ARM_PC_REGNUM, (char *) &reg_pc);
d641 1
a641 2
    regcache_raw_collect (current_regcache, ARM_FPS_REGNUM,
			  (char *) &fp->fpsr);
d654 1
a654 1
  regcache_raw_supply (current_regcache, ARM_FPS_REGNUM, (char *) &fp->fpsr);
@


1.18
log
@* arm-linux-nat.c: Linux -> GNU/Linux when not talking about the
kernel.
* arm-linux-tdep.c: Likewise.
* config/arm/tm-linux.h: Likewise.
@
text
@d164 1
a164 1
store_nwfpe_single (unsigned int fn, FPA11 * fpa11)
d168 1
a168 1
  read_register_gen (ARM_F0_REGNUM + fn, (char *) &mem[0]);
d174 1
a174 1
store_nwfpe_double (unsigned int fn, FPA11 * fpa11)
d178 1
a178 1
  read_register_gen (ARM_F0_REGNUM + fn, (char *) &mem[0]);
d185 1
a185 1
store_nwfpe_extended (unsigned int fn, FPA11 * fpa11)
d189 1
a189 1
  read_register_gen (ARM_F0_REGNUM + fn, (char *) &mem[0]);
d339 1
a339 1
    read_register_gen (ARM_FPS_REGNUM, (char *) &fp.fpsr);
d377 1
a377 1
    read_register_gen (ARM_FPS_REGNUM, (char *) &fp.fpsr);
d485 1
a485 1
    read_register_gen (regno, (char *) &regs[regno]);
d515 1
a515 1
	read_register_gen (regno, (char *) &regs[regno]);
d582 1
a582 1
	read_register_gen (regnum, (char *) &(*gregsetp)[regnum]);
d585 1
a585 1
    read_register_gen (regno, (char *) &(*gregsetp)[regno]);
d590 2
a591 2
	read_register_gen (ARM_PS_REGNUM,
			   (char *) &(*gregsetp)[ARM_CPSR_REGNUM]);
d593 2
a594 2
	read_register_gen (ARM_PC_REGNUM,
			   (char *) &(*gregsetp)[ARM_PC_REGNUM]);
d641 1
a641 1
    read_register_gen (ARM_FPS_REGNUM, (char *) &fp->fpsr);
@


1.17
log
@* arm-linux-nat.c: Really include arm-tdep.h.
* config/arm/tm-linux.h (struct type, struct value): Declare.
@
text
@d66 1
a66 1
   underlying Linux operating system.  Examples:
d68 1
a68 1
   Linux 2.0.35                 Linux 2.2.12
d81 1
a81 1
/* On Linux, threads are implemented as pseudo-processes, in which
d84 2
a85 2
   individual thread (process) ID.  get_thread_id () is used to
   get the thread id if it's available, and the process id otherwise. */
d679 1
a679 1
      warning ("Unable to determine Linux version.");
@


1.16
log
@* arm-tdep.h: New file.
* arm-tdep.c: Include arm-tdep.h.
(arm_addr_bits_remove, arm_smash_text_address, arm_saved_pc_after_call)
(arm_skip_prologue, arm_call_dummy_words, arm_fix_call_dummy)
(arm_print_float_info, arm_register_type, convert_to_extended)
(arm_elf_make_msymbols_special, arm_coff_make_msymbol_special)
(arm_extract_return_value, arm_register_name): Make static.
(arm_software_single_step): Similarly.  Fix types in declaration.
(arm_register_byte, arm_register_raw_size, arm_register_virtual_size)
(arm_store_return_value, arm_store_struct_return): New functions.
(arm_gdbarch_init): Register the above functions.  Also register
call_dummy_start_offset, sizeof_call_dummy_words,
function_start_offset, inner_than, decr_pc_after_break, fp_regnum,
sp_regnum, pc_regnum, register_bytes, num_regs, max_register_raw_size,
max_register_virtual_size, register_size.  Set up
prologue_cache.saved_regs here, rather than ...
(_initialize_arm_tdep): ... here.
* config/arm/tm-arm.h (struct type, struct value): Delete forward
declarations.
(arm_addr_bits_remove, arm_smash_text_address, arm_saved_pc_after_call)
(arm_skip_prologue, arm_call_dummy_words, arm_fix_call_dummy)
(arm_print_float_info, arm_register_type, convert_to_extended)
(arm_elf_make_msymbols_special, arm_coff_make_msymbol_special)
(arm_extract_return_value, arm_register_name): Delete declarations.
(SMASH_TEXT_ADDRESS, ADDR_BITS_REMOVE, FUNCTION_START_OFFSET)
(SKIP_PROLOGUE, SAVED_PC_AFTER_CALL, INNER_THAN, BREAKPOINT_FROM_PC)
(DECR_PC_AFTER_BREAK, PRINT_FLOAT_INFO, REGISTER_SIZE, NUM_REGS)
(REGISTER_NAME, REGISTER_BYTES, REGISTER_BYTE, REGISTER_RAW_SIZE)
(REGISTER_VIRTUAL_SIZE, MAX_REGISTER_RAW_SIZE)
(MAX_REGISTER_VIRTUAL_SIZE, REGISTER_VIRTUAL_TYPE, STORE_STRUCT_RETURN)
(EXTRACT_RETURN_VALUE, STORE_RETURN_VALUE, CALL_DUMMY_WORDS)
(SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_START_OFFSET, FIX_CALL_DUMMY)
(SOFTWARE_SINGLE_STEP_P, SOFTWARE_SINGLE_STEP)
(ELF_MAKE_MSYMBOL_SPECIAL, COFF_MAKE_MSYMBOL_SPECIAL) Delete.
(arm_pc_is_thumb, arm_pc_is_thumb_dummy, thumb_get_next_pc)
(arm_get_next_pc): No-longer static -- these are needed by the RDI
interface.
* arm-linux-nat.c arm-linux-tdep.c armnbsd-nat.c: Include arm-tdep.h.
* remote-rdi.c remote-rdp.c: Likewise.
* Makefile.in (arm-linux-nat.o, arm-linux-tdep.o arm-tdep.o)
(armnbsd-nat.o, remote-rdi.o, remote_rdp.o): Update dependencies.
* config/arm/tm-nbsd.h (SOFTWARE_SINGLE_STEP_P): Delete bogus
definition.

* arm-tdep.h (ARM_A1_REGNUM, ARM_A4_REGNUM, ARM_AP_REGNUM)
(ARM_SP_REGNUM, ARM_LR_REGNUM, ARM_PC_REGNUM, ARM_F0_REGNUM)
(ARM_F3_REGNUM, ARM_F7_REGNUM, ARM_FPS_REGNUM, ARM_PS_REGNUM): Renamed
from non-ARM_ prefixed definitions.
* arm-tdep.c armnbsd-nat.c arm-linux-nat.c arm-linux-tdep.c: Update
all uses of above.
* remote-rdi.c remote-rdp.c: Likewise.
* arm-linux-nat.c (ARM_CPSR_REGNUM): Renamed from CPSR_REGNUM.
@
text
@d27 2
@


1.15
log
@2002-01-07  Michael Snyder  <msnyder@@redhat.com>

        * arm-linux-nat.c: Remove references to regcache.c internal data
	(registers[] and register_valid[]).
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d42 1
a42 1
#define		CPSR_REGNUM		16
d103 1
a103 1
  supply_register (F0_REGNUM + fn, (char *) &mem[0]);
d114 1
a114 1
  supply_register (F0_REGNUM + fn, (char *) &mem[0]);
d123 1
a123 1
  supply_register (F0_REGNUM + fn, (char *) &mem[0]);
d134 1
a134 1
  supply_register (F0_REGNUM + fn, (char *) &mem[0]);
d140 1
a140 1
   int fn = regno - F0_REGNUM;
d166 1
a166 1
  read_register_gen (F0_REGNUM + fn, (char *) &mem[0]);
d176 1
a176 1
  read_register_gen (F0_REGNUM + fn, (char *) &mem[0]);
d187 1
a187 1
  read_register_gen (F0_REGNUM + fn, (char *) &mem[0]);
d199 1
a199 1
       unsigned int fn = regno - F0_REGNUM;
d239 2
a240 2
  if (FPS_REGNUM == regno)
    supply_register (FPS_REGNUM, (char *) &fp.fpsr);
d243 1
a243 1
  if (regno >= F0_REGNUM && regno <= F7_REGNUM)
d245 1
a245 1
      int fn = regno - F0_REGNUM;
d288 1
a288 1
  supply_register (FPS_REGNUM, (char *) &fp.fpsr);
d291 1
a291 1
  for (regno = F0_REGNUM; regno <= F7_REGNUM; regno++)
d293 1
a293 1
      int fn = regno - F0_REGNUM;
d336 2
a337 2
  if (FPS_REGNUM == regno && register_cached (FPS_REGNUM))
    read_register_gen (FPS_REGNUM, (char *) &fp.fpsr);
d340 1
a340 1
  if (regno >= F0_REGNUM && regno <= F7_REGNUM)
d374 2
a375 2
  if (register_cached (FPS_REGNUM))
    read_register_gen (FPS_REGNUM, (char *) &fp.fpsr);
d378 1
a378 1
  for (regno = F0_REGNUM; regno <= F7_REGNUM; regno++)
d410 1
a410 1
  if (regno >= A1_REGNUM && regno < PC_REGNUM)
d413 1
a413 1
  if (PS_REGNUM == regno)
d416 1
a416 1
        supply_register (PS_REGNUM, (char *) &regs[CPSR_REGNUM]);
d418 1
a418 1
        supply_register (PS_REGNUM, (char *) &regs[PC_REGNUM]);
d421 1
a421 1
  if (PC_REGNUM == regno)
d423 2
a424 2
      regs[PC_REGNUM] = ADDR_BITS_REMOVE (regs[PC_REGNUM]);
      supply_register (PC_REGNUM, (char *) &regs[PC_REGNUM]);
d447 1
a447 1
  for (regno = A1_REGNUM; regno < PC_REGNUM; regno++)
d451 1
a451 1
    supply_register (PS_REGNUM, (char *) &regs[CPSR_REGNUM]);
d453 1
a453 1
    supply_register (PS_REGNUM, (char *) &regs[PC_REGNUM]);
d455 2
a456 2
  regs[PC_REGNUM] = ADDR_BITS_REMOVE (regs[PC_REGNUM]);
  supply_register (PC_REGNUM, (char *) &regs[PC_REGNUM]);
d482 1
a482 1
  if (regno >= A1_REGNUM && regno <= PC_REGNUM)
d510 1
a510 1
  for (regno = A1_REGNUM; regno <= PC_REGNUM; regno++)
d539 1
a539 1
      if (regno < F0_REGNUM || regno > FPS_REGNUM)
d542 1
a542 1
      if (regno >= F0_REGNUM && regno <= FPS_REGNUM)
d561 1
a561 1
      if ((regno < F0_REGNUM) || (regno > FPS_REGNUM))
d564 1
a564 1
      if ((regno >= F0_REGNUM) && (regno <= FPS_REGNUM))
d579 1
a579 1
      for (regnum = A1_REGNUM; regnum <= PC_REGNUM; regnum++) 
d582 1
a582 1
  else if (regno >= A1_REGNUM && regno <= PC_REGNUM)
d585 1
a585 1
  if (PS_REGNUM == regno || -1 == regno)
d588 2
a589 1
	read_register_gen (PS_REGNUM, (char *) &(*gregsetp)[CPSR_REGNUM]);
d591 2
a592 1
	read_register_gen (PC_REGNUM, (char *) &(*gregsetp)[PC_REGNUM]);
d604 1
a604 1
  for (regno = A1_REGNUM; regno < PC_REGNUM; regno++)
d608 1
a608 1
    supply_register (PS_REGNUM, (char *) &(*gregsetp)[CPSR_REGNUM]);
d610 1
a610 1
    supply_register (PS_REGNUM, (char *) &(*gregsetp)[PC_REGNUM]);
d612 2
a613 2
  reg_pc = ADDR_BITS_REMOVE ((CORE_ADDR)(*gregsetp)[PC_REGNUM]);
  supply_register (PC_REGNUM, (char *) &reg_pc);
d628 1
a628 1
       for (regnum = F0_REGNUM; regnum <= F7_REGNUM; regnum++)
d631 1
a631 1
  else if (regno >= F0_REGNUM && regno <= F7_REGNUM)
d638 2
a639 2
  if (FPS_REGNUM == regno || -1 == regno)
    read_register_gen (FPS_REGNUM, (char *) &fp->fpsr);
d652 1
a652 1
  supply_register (FPS_REGNUM, (char *) &fp->fpsr);
d655 1
a655 1
  for (regno = F0_REGNUM; regno <= F7_REGNUM; regno++)
@


1.14
log
@        * arm-linux-nat.c: Don't include <asm/ptrace.h>.
        (fetch_register): Use elf_gregset_t instead of struct pt_regs.
        (fetch_regs): Likewise.
        (store_register): Likewise.
        (store_regs): Likewise.
@
text
@d197 1
a197 1
  if (register_valid[regno])
d219 1
a219 1
   state of the process and store it into registers[].  */
d268 1
a268 1
   into registers[].  */
d316 1
a316 1
   process using the contents from registers[].  */
d336 1
a336 1
  if (FPS_REGNUM == regno && register_valid[FPS_REGNUM])
d354 1
a354 1
   the contents from registers[].  */
d374 1
a374 1
  if (register_valid[FPS_REGNUM])
d392 1
a392 1
   registers[].  */
d429 1
a429 1
   registers[].  */
d460 1
a460 1
   registers[].  */
d468 1
a468 1
  if (!register_valid[regno])
d512 1
a512 1
      if (register_valid[regno])
@


1.13
log
@	* arm-linux-nat.c: Include <asm/ptrace.h> explicitly.
@
text
@a31 2
#include <asm/ptrace.h>

d398 1
a398 1
  struct pt_regs regs;
d411 1
a411 1
    supply_register (regno, (char *) &regs.uregs[regno]);
d416 1
a416 1
        supply_register (PS_REGNUM, (char *) &regs.uregs[CPSR_REGNUM]);
d418 1
a418 1
        supply_register (PS_REGNUM, (char *) &regs.uregs[PC_REGNUM]);
d423 2
a424 2
      regs.uregs[PC_REGNUM] = ADDR_BITS_REMOVE (regs.uregs[PC_REGNUM]);
      supply_register (PC_REGNUM, (char *) &regs.uregs[PC_REGNUM]);
d435 1
a435 1
  struct pt_regs regs;
d448 1
a448 1
    supply_register (regno, (char *) &regs.uregs[regno]);
d451 1
a451 1
    supply_register (PS_REGNUM, (char *) &regs.uregs[CPSR_REGNUM]);
d453 1
a453 1
    supply_register (PS_REGNUM, (char *) &regs.uregs[PC_REGNUM]);
d455 2
a456 2
  regs.uregs[PC_REGNUM] = ADDR_BITS_REMOVE (regs.uregs[PC_REGNUM]);
  supply_register (PC_REGNUM, (char *) &regs.uregs[PC_REGNUM]);
d466 1
a466 1
  struct pt_regs regs;
d483 1
a483 1
    read_register_gen (regno, (char *) &regs.uregs[regno]);
d497 1
a497 1
  struct pt_regs regs;
d513 1
a513 1
	read_register_gen (regno, (char *) &regs.uregs[regno]);
@


1.12
log
@        * arm-linux-nat.c (fill_gregset): Do not check register_valid[].
        (fill_fpregset): Likewise.
@
text
@d32 2
@


1.11
log
@Redefine ptid_t to be a struct rather than an int.
@
text
@d580 1
a580 2
        if (register_valid[regnum])
	  read_register_gen (regnum, (char *) &(*gregsetp)[regnum]);
d583 1
a583 4
    {
      if (register_valid[regno])
	read_register_gen (regno, (char *) &(*gregsetp)[regno]);
    }
d587 4
a590 7
      if (register_valid[regno] || -1 == regno)
        {
          if (arm_apcs_32)
	    read_register_gen (PS_REGNUM, (char *) &(*gregsetp)[CPSR_REGNUM]);
	  else
	    read_register_gen (PC_REGNUM, (char *) &(*gregsetp)[PC_REGNUM]);
	}
a591 1
        
d636 2
a637 3
  if (register_valid[FPS_REGNUM])
    if (FPS_REGNUM == regno || -1 == regno)
      read_register_gen (FPS_REGNUM, (char *) &fp->fpsr);
@


1.11.4.1
log
@        * arm-linux-nat.c (fill_gregset): Do not check register_valid[].
        (fill_fpregset): Likewise.
@
text
@d580 2
a581 1
	read_register_gen (regnum, (char *) &(*gregsetp)[regnum]);
d584 4
a587 1
    read_register_gen (regno, (char *) &(*gregsetp)[regno]);
d591 7
a597 4
      if (arm_apcs_32)
	read_register_gen (PS_REGNUM, (char *) &(*gregsetp)[CPSR_REGNUM]);
      else
	read_register_gen (PC_REGNUM, (char *) &(*gregsetp)[PC_REGNUM]);
d599 1
d644 3
a646 2
  if (FPS_REGNUM == regno || -1 == regno)
    read_register_gen (FPS_REGNUM, (char *) &fp->fpsr);
@


1.11.4.2
log
@	* arm-linux-nat.c: Include <asm/ptrace.h> explicitly.
@
text
@a31 2
#include <asm/ptrace.h>

@


1.10
log
@Phase 1 of the ptid_t changes.
@
text
@d82 2
a83 8
   individual thread (process) ID mashed together.  These macros are
   used to separate them out.  These definitions should be overridden
   if thread support is included.  */

#if !defined (PIDGET)	/* Default definition for PIDGET/TIDGET.  */
#define PIDGET(PID)	PID
#define TIDGET(PID)	0
#endif
@


1.9
log
@Create new file regcache.h.  Update all uses.
@
text
@d81 1
a81 1
   case, inferior_pid will contain the main process ID and the
d92 1
a92 1
get_thread_id (int inferior_pid)
d94 3
a96 2
  int tid = TIDGET (inferior_pid);
  if (0 == tid) tid = inferior_pid;
d99 1
a99 1
#define GET_THREAD_ID(PID)	get_thread_id ((PID));
d234 1
a234 1
  tid = GET_THREAD_ID (inferior_pid);
d283 1
a283 1
  tid = GET_THREAD_ID (inferior_pid);
d331 1
a331 1
  tid = GET_THREAD_ID (inferior_pid);
d369 1
a369 1
  tid = GET_THREAD_ID (inferior_pid);
d407 1
a407 1
  tid = GET_THREAD_ID (inferior_pid);
d444 1
a444 1
  tid = GET_THREAD_ID (inferior_pid);
d478 1
a478 1
  tid = GET_THREAD_ID (inferior_pid);
d506 1
a506 1
  tid = GET_THREAD_ID (inferior_pid);
@


1.8
log
@2001-02-04  Philip Blundell  <philb@@gnu.org>

	* config/arm/linux.mh (NATDEPFILES): Add proc-service.o,
	thread-db.o, lin-lwp.o; remove lin-thread.o, linux-thread.o.
	* config/arm/nm-linux.h (PREPARE_TO_PROCEED, ATTACH_LWP,
	GET_THREAD_SIGNALS): Define.
	* arm-linux-nat.c (fill_gregset): Correct type of argument.
	(supply_gregset): Likewise.
	(fill_fpregset): Likewise.
	(supply_fpregset): Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
d25 1
@


1.7
log
@2000-05-26  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * gregset.h: New file.  Typedefs for gdb_gregset_t and
        gdb_fpregset_t, prototypes for supply_gregset and friends.
        * procfs.c: Include gregset.h.  Delete local prototypes for
        supply_gregset etc., and local typedef gdb_gregset_t etc.
        * sol-thread.c: Include gregset.h, delete local prototypes,
        add appropriate casts to gdb_gregset_t.
        * uw-thread.c, lin-thread.c, core-sol2.c, core-regset.c,
        sparc-tdep.c, ptx4-nat.c, ppc-linux-nat.c, mipsv4-nat.c,
        m88k-nat.c, m68klinux-nat.c, m68k-tdep.c, irix5-nat.c,
        irix4-nat.c, ia64-linux-nat.c, i386v4-nat.c, cxux-nat.c,
        arm-linux-nat.c, alpha-nat.c: Include gregset.h.
        * config/nm-linux.h: Define GDB_GREGSET_T, GDB_FPREGET_T.
        * config/sparc/tm-sun4sol2.h: Ditto.
@
text
@d578 1
a578 1
fill_gregset (gregset_t *gregsetp, int regno)
d610 1
a610 1
supply_gregset (gregset_t *gregsetp)
d631 1
a631 1
fill_fpregset (fpregset_t *fpregsetp, int regno)
d657 1
a657 1
supply_fpregset (fpregset_t *fpregsetp)
@


1.6
log
@Changes to support core files and linux threads.

2000-04-20  Scott Bambrough <scottb@@netwinder.org>

	* arm-linux-nat.c (PIDGET, TIDGET): New.
	(get_thread_id, GET_THREAD_ID): New.
	(fetch_nwfpe_register, store_nwfpe_register): New.
	(fetch_register, store_register): New.
	(fetch_fpregister, store_fpregister): New.
	(fill_gregset, supply_gregset): New.
	(fill_fpregset, supply_fpregset): New.
	(fetch_fpregs): Modified to use thread id's.
	(store_fpregs): Modified to use thread id's and
	fetch_nwfpe_register.
	(fetch_regs): Modified to use thread id's.
	(store_regs): Modified to use thread id's.
	(fetch_inferior_registers): Modified to handle single register
	fetches.
	(store_inferior_registers): Modified to handle single register
	stores.
	(arm_linux_register_u_addr): Removed.

	* configure.tgt: Added gdbserver to configdirs for arm*-*-linux*.

	* config/arm/linux.mh
	(NATDEPFILES): Removed core-aout.o.  Added core-regset.o.
	(LOADLIBES): Define.

	* config/arm/nm-linux.h: Include config/nm-linux.h.
	(ATTACH_DETACH): Removed.  Defined in config/nm-linux.h.
	(REGISTER_U_ADDR): Removed.
	(SVR4_SHARED_LIBS): Removed.  Defined in config/nm-linux.h.
	(#include "solib.h"): Removed.  Included via config/nm-linux.h.
@
text
@d31 3
@


1.5
log
@Move arm_skip_solib_resolver from arm-linux-nat.c to arm-linux-tdep.c.

2000-04-10  Philip Blundell <philb@@gnu.org>

	* arm-linux-nat.c (arm_skip_solib_resolver): Remove and move to
	arm-linux-tdep.c.
	* arm-linux-tdep.c (arm_skip_solib_resolver): New.
@
text
@d29 1
d75 21
d139 24
d195 75
a269 2
/* Get the whole floating point state of the process and store the
   floating point stack into registers[].  */
d274 1
a274 1
  int ret, regno;
d277 3
d281 1
a281 1
  ret = ptrace (PT_GETFPREGS, inferior_pid, 0, &fp);
d284 1
a284 1
      warning ("Unable to fetch the floating point state.");
d316 38
d360 1
a360 1
  int ret, regno;
d363 11
d381 1
a381 18
      if (register_valid[regno])
	{
	  unsigned int fn = regno - F0_REGNUM;
	  switch (fp.fType[fn])
	    {
	    case typeSingle:
	      store_nwfpe_single (fn, &fp);
	      break;

	    case typeDouble:
	      store_nwfpe_double (fn, &fp);
	      break;

	    case typeExtended:
	      store_nwfpe_extended (fn, &fp);
	      break;
	    }
	}
d384 1
a384 1
  ret = ptrace (PTRACE_SETFPREGS, inferior_pid, 0, &fp);
d387 1
a387 1
      warning ("Unable to store floating point state.");
d392 37
d435 1
a435 1
  int ret, regno;
d438 4
a441 1
  ret = ptrace (PTRACE_GETREGS, inferior_pid, 0, &regs);
d464 31
d497 1
a497 1
  int ret, regno;
d500 5
a504 1
  ret = ptrace (PTRACE_GETREGS, inferior_pid, 0, &regs);
d517 1
a517 1
  ret = ptrace (PTRACE_SETREGS, inferior_pid, 0, &regs);
d533 9
a541 2
  if ((regno < F0_REGNUM) || (regno > FPS_REGNUM))
    fetch_regs ();
d543 3
a545 2
  if (((regno >= F0_REGNUM) && (regno <= FPS_REGNUM)) || (regno == -1))
    fetch_fpregs ();
d555 58
a612 2
  if ((regno < F0_REGNUM) || (regno > FPS_REGNUM))
    store_regs ();
d614 7
a620 2
  if (((regno >= F0_REGNUM) && (regno <= FPS_REGNUM)) || (regno == -1))
    store_fpregs ();
d623 32
a654 2
int
arm_linux_register_u_addr (int blockend, int regnum)
d656 11
a666 1
  return blockend + REGISTER_BYTE (regnum);
@


1.4
log
@Unable to build x86 hosted debugger for ARM Linux, due to missing target
dependencies.  Created ARM Linux specific arm-linux-tdep.c file and moved
missing code into it from arm-linux-nat.c.

2000-04-05  Scott Bambrough <scottb@@netwinder.org>

	* arm-linux-tdep.c: New file.
	* arm-linux-nat.c (fetch_fpregs): Remove unused code.
	  (arm_get_longjmp_target): Moved it and all defines
	  it uses to arm-linux-tdep.c.
	  (arm_linux_extract_return_value): Moved to
	  arm-linux-tdep.c.
	* config/arm/linux.mt: Add arm-linux-tdep.c to TDEPFILES.
@
text
@a324 126
/*
   Dynamic Linking on ARM Linux
   ----------------------------

   Note: PLT = procedure linkage table
   GOT = global offset table

   As much as possible, ELF dynamic linking defers the resolution of
   jump/call addresses until the last minute. The technique used is
   inspired by the i386 ELF design, and is based on the following
   constraints.

   1) The calling technique should not force a change in the assembly
   code produced for apps; it MAY cause changes in the way assembly
   code is produced for position independent code (i.e. shared
   libraries).

   2) The technique must be such that all executable areas must not be
   modified; and any modified areas must not be executed.

   To do this, there are three steps involved in a typical jump:

   1) in the code
   2) through the PLT
   3) using a pointer from the GOT

   When the executable or library is first loaded, each GOT entry is
   initialized to point to the code which implements dynamic name
   resolution and code finding.  This is normally a function in the
   program interpreter (on ARM Linux this is usually ld-linux.so.2,
   but it does not have to be).  On the first invocation, the function
   is located and the GOT entry is replaced with the real function
   address.  Subsequent calls go through steps 1, 2 and 3 and end up
   calling the real code.

   1) In the code: 

   b    function_call
   bl   function_call

   This is typical ARM code using the 26 bit relative branch or branch
   and link instructions.  The target of the instruction
   (function_call is usually the address of the function to be called.
   In position independent code, the target of the instruction is
   actually an entry in the PLT when calling functions in a shared
   library.  Note that this call is identical to a normal function
   call, only the target differs.

   2) In the PLT:

   The PLT is a synthetic area, created by the linker. It exists in
   both executables and libraries. It is an array of stubs, one per
   imported function call. It looks like this:

   PLT[0]:
   str     lr, [sp, #-4]!       @@push the return address (lr)
   ldr     lr, [pc, #16]   @@load from 6 words ahead
   add     lr, pc, lr      @@form an address for GOT[0]
   ldr     pc, [lr, #8]!   @@jump to the contents of that addr

   The return address (lr) is pushed on the stack and used for
   calculations.  The load on the second line loads the lr with
   &GOT[3] - . - 20.  The addition on the third leaves:

   lr = (&GOT[3] - . - 20) + (. + 8)
   lr = (&GOT[3] - 12)
   lr = &GOT[0]

   On the fourth line, the pc and lr are both updated, so that:

   pc = GOT[2]
   lr = &GOT[0] + 8
   = &GOT[2]

   NOTE: PLT[0] borrows an offset .word from PLT[1]. This is a little
   "tight", but allows us to keep all the PLT entries the same size.

   PLT[n+1]:
   ldr     ip, [pc, #4]    @@load offset from gotoff
   add     ip, pc, ip      @@add the offset to the pc
   ldr     pc, [ip]        @@jump to that address
   gotoff: .word   GOT[n+3] - .

   The load on the first line, gets an offset from the fourth word of
   the PLT entry.  The add on the second line makes ip = &GOT[n+3],
   which contains either a pointer to PLT[0] (the fixup trampoline) or
   a pointer to the actual code.

   3) In the GOT:

   The GOT contains helper pointers for both code (PLT) fixups and
   data fixups.  The first 3 entries of the GOT are special. The next
   M entries (where M is the number of entries in the PLT) belong to
   the PLT fixups. The next D (all remaining) entries belong to
   various data fixups. The actual size of the GOT is 3 + M + D.

   The GOT is also a synthetic area, created by the linker. It exists
   in both executables and libraries.  When the GOT is first
   initialized , all the GOT entries relating to PLT fixups are
   pointing to code back at PLT[0].

   The special entries in the GOT are:

   GOT[0] = linked list pointer used by the dynamic loader
   GOT[1] = pointer to the reloc table for this module
   GOT[2] = pointer to the fixup/resolver code

   The first invocation of function call comes through and uses the
   fixup/resolver code.  On the entry to the fixup/resolver code:

   ip = &GOT[n+3]
   lr = &GOT[2]
   stack[0] = return address (lr) of the function call
   [r0, r1, r2, r3] are still the arguments to the function call

   This is enough information for the fixup/resolver code to work
   with.  Before the fixup/resolver code returns, it actually calls
   the requested function and repairs &GOT[n+3].  */

CORE_ADDR
arm_skip_solib_resolver (CORE_ADDR pc)
{
  /* FIXME */
  return 0;
}

@


1.4.2.1
log
@Move arm_skip_solib_resolver from arm-linux-nat.c to arm-linux-tdep.c.

2000-04-10  Philip Blundell <philb@@gnu.org>

 	* arm-linux-nat.c (arm_skip_solib_resolver): Remove and move to
 	arm-linux-tdep.c.
 	* arm-linux-tdep.c (arm_skip_solib_resolver): New.
@
text
@d325 126
@


1.4.2.2
log
@Changes to support core files and linux threads.

2000-04-20  Scott Bambrough <scottb@@netwinder.org>

	* arm-linux-nat.c (PIDGET, TIDGET): New.
	(get_thread_id, GET_THREAD_ID): New.
	(fetch_nwfpe_register, store_nwfpe_register): New.
	(fetch_register, store_register): New.
	(fetch_fpregister, store_fpregister): New.
	(fill_gregset, supply_gregset): New.
	(fill_fpregset, supply_fpregset): New.
	(fetch_fpregs): Modified to use thread id's.
	(store_fpregs): Modified to use thread id's and
	fetch_nwfpe_register.
	(fetch_regs): Modified to use thread id's.
	(store_regs): Modified to use thread id's.
	(fetch_inferior_registers): Modified to handle single register
	fetches.
	(store_inferior_registers): Modified to handle single register
	stores.
	(arm_linux_register_u_addr): Removed.

	* configure.tgt: Added gdbserver to configdirs for arm*-*-linux*.

	* config/arm/linux.mh
	(NATDEPFILES): Removed core-aout.o.  Added core-regset.o.
	(LOADLIBES): Define.

	* config/arm/nm-linux.h: Include config/nm-linux.h.
	(ATTACH_DETACH): Removed.  Defined in config/nm-linux.h.
	(REGISTER_U_ADDR): Removed.
	(SVR4_SHARED_LIBS): Removed.  Defined in config/nm-linux.h.
	(#include "solib.h"): Removed.  Included via config/nm-linux.h.
@
text
@a28 1
#include <sys/procfs.h>
a73 21
/* On Linux, threads are implemented as pseudo-processes, in which
   case we may be tracing more than one process at a time.  In that
   case, inferior_pid will contain the main process ID and the
   individual thread (process) ID mashed together.  These macros are
   used to separate them out.  These definitions should be overridden
   if thread support is included.  */

#if !defined (PIDGET)	/* Default definition for PIDGET/TIDGET.  */
#define PIDGET(PID)	PID
#define TIDGET(PID)	0
#endif

int
get_thread_id (int inferior_pid)
{
  int tid = TIDGET (inferior_pid);
  if (0 == tid) tid = inferior_pid;
  return tid;
}
#define GET_THREAD_ID(PID)	get_thread_id ((PID));

a116 24
fetch_nwfpe_register (int regno, FPA11 * fpa11)
{
   int fn = regno - F0_REGNUM;

   switch (fpa11->fType[fn])
     {
     case typeSingle:
       fetch_nwfpe_single (fn, fpa11);
       break;

     case typeDouble:
       fetch_nwfpe_double (fn, fpa11);
       break;

     case typeExtended:
       fetch_nwfpe_extended (fn, fpa11);
       break;

     default:
       fetch_nwfpe_none (fn);
     }
}

static void
d149 2
a150 75
void
store_nwfpe_register (int regno, FPA11 * fpa11)
{
  if (register_valid[regno])
    {
       unsigned int fn = regno - F0_REGNUM;
       switch (fpa11->fType[fn])
         {
	 case typeSingle:
	   store_nwfpe_single (fn, fpa11);
	   break;

	 case typeDouble:
	   store_nwfpe_double (fn, fpa11);
	   break;

	 case typeExtended:
	   store_nwfpe_extended (fn, fpa11);
	   break;
	 }
    }
}


/* Get the value of a particular register from the floating point
   state of the process and store it into registers[].  */

static void
fetch_fpregister (int regno)
{
  int ret, tid;
  FPA11 fp;
  
  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_pid);

  /* Read the floating point state.  */
  ret = ptrace (PT_GETFPREGS, tid, 0, &fp);
  if (ret < 0)
    {
      warning ("Unable to fetch floating point register.");
      return;
    }

  /* Fetch fpsr.  */
  if (FPS_REGNUM == regno)
    supply_register (FPS_REGNUM, (char *) &fp.fpsr);

  /* Fetch the floating point register.  */
  if (regno >= F0_REGNUM && regno <= F7_REGNUM)
    {
      int fn = regno - F0_REGNUM;

      switch (fp.fType[fn])
	{
	case typeSingle:
	  fetch_nwfpe_single (fn, &fp);
	  break;

	case typeDouble:
	    fetch_nwfpe_double (fn, &fp);
	  break;

	case typeExtended:
	    fetch_nwfpe_extended (fn, &fp);
	  break;

	default:
	    fetch_nwfpe_none (fn);
	}
    }
}

/* Get the whole floating point state of the process and store it
   into registers[].  */
d155 1
a155 1
  int ret, regno, tid;
a157 3
  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_pid);
  
d159 1
a159 1
  ret = ptrace (PT_GETFPREGS, tid, 0, &fp);
d162 1
a162 1
      warning ("Unable to fetch the floating point registers.");
a193 38
/* Save a particular register into the floating point state of the
   process using the contents from registers[].  */

static void
store_fpregister (int regno)
{
  int ret, tid;
  FPA11 fp;

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_pid);
  
  /* Read the floating point state.  */
  ret = ptrace (PT_GETFPREGS, tid, 0, &fp);
  if (ret < 0)
    {
      warning ("Unable to fetch the floating point registers.");
      return;
    }

  /* Store fpsr.  */
  if (FPS_REGNUM == regno && register_valid[FPS_REGNUM])
    read_register_gen (FPS_REGNUM, (char *) &fp.fpsr);

  /* Store the floating point register.  */
  if (regno >= F0_REGNUM && regno <= F7_REGNUM)
    {
      store_nwfpe_register (regno, &fp);
    }

  ret = ptrace (PTRACE_SETFPREGS, tid, 0, &fp);
  if (ret < 0)
    {
      warning ("Unable to store floating point register.");
      return;
    }
}

d200 1
a200 1
  int ret, regno, tid;
a202 11
  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_pid);
  
  /* Read the floating point state.  */
  ret = ptrace (PT_GETFPREGS, tid, 0, &fp);
  if (ret < 0)
    {
      warning ("Unable to fetch the floating point registers.");
      return;
    }

d210 18
a227 1
      fetch_nwfpe_register (regno, &fp);
d230 1
a230 1
  ret = ptrace (PTRACE_SETFPREGS, tid, 0, &fp);
d233 1
a233 1
      warning ("Unable to store floating point registers.");
a237 37
/* Fetch a general register of the process and store into
   registers[].  */

static void
fetch_register (int regno)
{
  int ret, tid;
  struct pt_regs regs;

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_pid);
  
  ret = ptrace (PTRACE_GETREGS, tid, 0, &regs);
  if (ret < 0)
    {
      warning ("Unable to fetch general register.");
      return;
    }

  if (regno >= A1_REGNUM && regno < PC_REGNUM)
    supply_register (regno, (char *) &regs.uregs[regno]);

  if (PS_REGNUM == regno)
    {
      if (arm_apcs_32)
        supply_register (PS_REGNUM, (char *) &regs.uregs[CPSR_REGNUM]);
      else
        supply_register (PS_REGNUM, (char *) &regs.uregs[PC_REGNUM]);
    }
    
  if (PC_REGNUM == regno)
    { 
      regs.uregs[PC_REGNUM] = ADDR_BITS_REMOVE (regs.uregs[PC_REGNUM]);
      supply_register (PC_REGNUM, (char *) &regs.uregs[PC_REGNUM]);
    }
}

d244 1
a244 1
  int ret, regno, tid;
d247 1
a247 4
  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_pid);
  
  ret = ptrace (PTRACE_GETREGS, tid, 0, &regs);
a269 31
store_register (int regno)
{
  int ret, tid;
  struct pt_regs regs;
  
  if (!register_valid[regno])
    return;

  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_pid);
  
  /* Get the general registers from the process.  */
  ret = ptrace (PTRACE_GETREGS, tid, 0, &regs);
  if (ret < 0)
    {
      warning ("Unable to fetch general registers.");
      return;
    }

  if (regno >= A1_REGNUM && regno <= PC_REGNUM)
    read_register_gen (regno, (char *) &regs.uregs[regno]);

  ret = ptrace (PTRACE_SETREGS, tid, 0, &regs);
  if (ret < 0)
    {
      warning ("Unable to store general register.");
      return;
    }
}

static void
d272 1
a272 1
  int ret, regno, tid;
d275 1
a275 5
  /* Get the thread id for the ptrace call.  */
  tid = GET_THREAD_ID (inferior_pid);
  
  /* Fetch the general registers.  */
  ret = ptrace (PTRACE_GETREGS, tid, 0, &regs);
d288 1
a288 1
  ret = ptrace (PTRACE_SETREGS, tid, 0, &regs);
d304 2
a305 9
  if (-1 == regno)
    {
      fetch_regs ();
      fetch_fpregs ();
    }
  else 
    {
      if (regno < F0_REGNUM || regno > FPS_REGNUM)
        fetch_register (regno);
d307 2
a308 3
      if (regno >= F0_REGNUM && regno <= FPS_REGNUM)
        fetch_fpregister (regno);
    }
d318 2
a319 9
  if (-1 == regno)
    {
      store_regs ();
      store_fpregs ();
    }
  else
    {
      if ((regno < F0_REGNUM) || (regno > FPS_REGNUM))
        store_register (regno);
d321 2
a322 3
      if ((regno >= F0_REGNUM) && (regno <= FPS_REGNUM))
        store_fpregister (regno);
    }
d325 2
a326 38
/* Fill register regno (if it is a general-purpose register) in
   *gregsetp with the appropriate value from GDB's register array.
   If regno is -1, do this for all registers.  */

void
fill_gregset (gregset_t *gregsetp, int regno)
{
  if (-1 == regno)
    {
      int regnum;
      for (regnum = A1_REGNUM; regnum <= PC_REGNUM; regnum++) 
        if (register_valid[regnum])
	  read_register_gen (regnum, (char *) &(*gregsetp)[regnum]);
    }
  else if (regno >= A1_REGNUM && regno <= PC_REGNUM)
    {
      if (register_valid[regno])
	read_register_gen (regno, (char *) &(*gregsetp)[regno]);
    }

  if (PS_REGNUM == regno || -1 == regno)
    {
      if (register_valid[regno] || -1 == regno)
        {
          if (arm_apcs_32)
	    read_register_gen (PS_REGNUM, (char *) &(*gregsetp)[CPSR_REGNUM]);
	  else
	    read_register_gen (PC_REGNUM, (char *) &(*gregsetp)[PC_REGNUM]);
	}
    }
        
}

/* Fill GDB's register array with the general-purpose register values
   in *gregsetp.  */

void
supply_gregset (gregset_t *gregsetp)
d328 1
a328 58
  int regno, reg_pc;

  for (regno = A1_REGNUM; regno < PC_REGNUM; regno++)
    supply_register (regno, (char *) &(*gregsetp)[regno]);

  if (arm_apcs_32)
    supply_register (PS_REGNUM, (char *) &(*gregsetp)[CPSR_REGNUM]);
  else
    supply_register (PS_REGNUM, (char *) &(*gregsetp)[PC_REGNUM]);

  reg_pc = ADDR_BITS_REMOVE ((CORE_ADDR)(*gregsetp)[PC_REGNUM]);
  supply_register (PC_REGNUM, (char *) &reg_pc);
}

/* Fill register regno (if it is a floating-point register) in
   *fpregsetp with the appropriate value from GDB's register array.
   If regno is -1, do this for all registers.  */

void
fill_fpregset (fpregset_t *fpregsetp, int regno)
{
  FPA11 *fp = (FPA11 *) fpregsetp;
  
  if (-1 == regno)
    {
       int regnum;
       for (regnum = F0_REGNUM; regnum <= F7_REGNUM; regnum++)
         store_nwfpe_register (regnum, fp);
    }
  else if (regno >= F0_REGNUM && regno <= F7_REGNUM)
    {
      store_nwfpe_register (regno, fp);
      return;
    }

  /* Store fpsr.  */
  if (register_valid[FPS_REGNUM])
    if (FPS_REGNUM == regno || -1 == regno)
      read_register_gen (FPS_REGNUM, (char *) &fp->fpsr);
}

/* Fill GDB's register array with the floating-point register values
   in *fpregsetp.  */

void
supply_fpregset (fpregset_t *fpregsetp)
{
  int regno;
  FPA11 *fp = (FPA11 *) fpregsetp;

  /* Fetch fpsr.  */
  supply_register (FPS_REGNUM, (char *) &fp->fpsr);

  /* Fetch the floating point registers.  */
  for (regno = F0_REGNUM; regno <= F7_REGNUM; regno++)
    {
      fetch_nwfpe_register (regno, fp);
    }
@


1.3
log
@Update copyright date in file.
@
text
@a172 1
      unsigned int *p = (unsigned int *) &registers[REGISTER_BYTE (regno)];
a324 34
#ifdef GET_LONGJMP_TARGET

/* Figure out where the longjmp will land.  We expect that we have
   just entered longjmp and haven't yet altered r0, r1, so the
   arguments are still in the registers.  (A1_REGNUM) points at the
   jmp_buf structure from which we extract the pc (JB_PC) that we will
   land at.  The pc is copied into ADDR.  This routine returns true on
   success. */

#define LONGJMP_TARGET_SIZE 	sizeof(int)
#define JB_ELEMENT_SIZE		sizeof(int)
#define JB_SL			18
#define JB_FP			19
#define JB_SP			20
#define JB_PC			21

int
arm_get_longjmp_target (CORE_ADDR * pc)
{
  CORE_ADDR jb_addr;
  char buf[LONGJMP_TARGET_SIZE];

  jb_addr = read_register (A1_REGNUM);

  if (target_read_memory (jb_addr + JB_PC * JB_ELEMENT_SIZE, buf,
			  LONGJMP_TARGET_SIZE))
    return 0;

  *pc = extract_address (buf, LONGJMP_TARGET_SIZE);
  return 1;
}

#endif /* GET_LONGJMP_TARGET */

a460 19
}

/* Extract from an array REGBUF containing the (raw) register state
   a function return value of type TYPE, and copy that, in virtual format,
   into VALBUF.  */

void
arm_linux_extract_return_value (struct type *type,
				char regbuf[REGISTER_BYTES],
				char *valbuf)
{
  /* ScottB: This needs to be looked at to handle the different
     floating point emulators on ARM Linux.  Right now the code
     assumes that fetch inferior registers does the right thing for
     GDB.  I suspect this won't handle NWFPE registers correctly, nor
     will the default ARM version (arm_extract_return_value()).  */

  int regnum = (TYPE_CODE_FLT == TYPE_CODE (type)) ? F0_REGNUM : A1_REGNUM;
  memcpy (valbuf, &regbuf[REGISTER_BYTE (regnum)], TYPE_LENGTH (type));
@


1.2
log
@2000-02-28  Scott Bambrough <scottb@@netwinder.org>

	* arm-linux-nat.c (fetch_nw_fpe_*):
 	Renamed to fetch_nwfpe_* to use the same naming convention
	as in the Linux kernel.  Modified prototype to get rid of
	unused parameters.
	(store_nw_fpe_*): Renamed to store_nwfpe_* to use the same
	naming convention as in the Linux kernel.  Fixed calls to
	fetch_nwfpe_*.
	(store_fpregs): Fixed calls to store_nwfpe_*.  Removed
	unused variable.
@
text
@d2 1
a2 1
   Copyright 1999 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d75 1
a75 1
fetch_nw_fpe_single (unsigned int fn, FPA11 * fpa11, unsigned int *pmem)
d86 1
a86 1
fetch_nw_fpe_double (unsigned int fn, FPA11 * fpa11, unsigned int *pmem)
d97 1
a97 1
fetch_nw_fpe_none (unsigned int fn, FPA11 * fpa11, unsigned int *pmem)
d106 1
a106 1
fetch_nw_fpe_extended (unsigned int fn, FPA11 * fpa11, unsigned int *pmem)
d117 1
a117 1
store_nw_fpe_single (unsigned int fn, FPA11 * fpa11)
d127 1
a127 1
store_nw_fpe_double (unsigned int fn, FPA11 * fpa11)
d138 1
a138 1
store_nw_fpe_extended (unsigned int fn, FPA11 * fpa11)
d178 1
a178 1
	  fetch_nw_fpe_single (fn, &fp, p);
d182 1
a182 1
	  fetch_nw_fpe_double (fn, &fp, p);
d186 1
a186 1
	  fetch_nw_fpe_extended (fn, &fp, p);
d190 1
a190 1
	  fetch_nw_fpe_none (fn, &fp, p);
a201 1
  unsigned int mem[3];
d217 1
a217 1
	      store_nw_fpe_single (fn, &fp);
d221 1
a221 1
	      store_nw_fpe_double (fn, &fp);
d225 1
a225 1
	      store_nw_fpe_extended (fn, &fp);
@


1.1.1.1
log
@import gdb-1999-12-21 snapshot
@
text
@@
