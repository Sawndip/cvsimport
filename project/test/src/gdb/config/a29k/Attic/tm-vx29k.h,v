head	1.9;
access;
symbols
	gdb_5_2_1-2002-07-23-release:1.8
	gdb_5_2-2002-04-29-release:1.8
	gdb_5_2-branch:1.8.0.2
	gdb_5_2-2002-03-03-branchpoint:1.8
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.8
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.6
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.4
	gdb_5_1-2001-07-29-branchpoint:1.4
	dberlin-typesystem-branch:1.4.0.2
	dberlin-typesystem-branchpoint:1.4
	gdb-post-ptid_t-2001-05-03:1.4
	gdb-pre-ptid_t-2001-05-03:1.4
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.9
date	2002.05.04.15.52.39;	author cagney;	state dead;
branches;
next	1.8;

1.8
date	2002.01.06.15.02.01;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.05.04.30.23;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.02.02.57.13;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.21.17.19.38;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.14.23.23.08;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.06.08.21.20;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.33;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.14;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.14;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.06.07.19.18.03;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.11.49;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.9
log
@* MAINTAINERS: Mark a29k as deleted.
* NEWS: Mention that a29k was removed.  Add OBSOLETE section.
Move new configurations to the top.
* configure.tgt: Remove a29k.
* config/a29k/tm-vx29k.h: Delete.
* config/a29k/vx29k.mt: Delete.
* config/a29k/tm-a29k.h: Delete.
* config/a29k/a29k-udi.mt: Delete.
* config/a29k/a29k.mt: Delete.
* a29k-tdep.c: Delete.
* remote-udi.c: Delete.
* remote-mm.c: Delete.
* remote-eb.c: Delete.
* remote-adapt.c: Delete.
* Makefile.in: Remove obsolete code.
* gdbserver/Makefile.in: Ditto.
* config/s390/s390x.mt: Ditto.
* config/s390/s390.mt: Ditto.
* config/sparc/sparclynx.mh: Ditto.
* config/sparc/linux.mh: Ditto.
* config/pa/hppaosf.mh: Ditto.
* config/pa/hppabsd.mh: Ditto.
* config/ns32k/nbsd.mt: Ditto.
* config/mips/vr5000.mt: Ditto.
* config/m68k/sun3os4.mh: Ditto.
* config/m68k/nbsd.mt: Ditto.
* config/m68k/m68klynx.mh: Ditto.
* config/m32r/m32r.mt: Ditto.
* config/i386/x86-64linux.mt: Ditto.
* config/i386/nbsdelf.mt: Ditto.
* config/i386/nbsd.mt: Ditto.
* config/i386/i386lynx.mh: Ditto.
@
text
@/* OBSOLETE /* Target machine description for VxWorks on the 29k, for GDB, the GNU debugger. */
/* OBSOLETE    Copyright 1994, 1995, 1998, 1999, 2000 Free Software Foundation, Inc. */
/* OBSOLETE    Contributed by Cygnus Support. */
/* OBSOLETE  */
/* OBSOLETE    This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE    This program is free software; you can redistribute it and/or modify */
/* OBSOLETE    it under the terms of the GNU General Public License as published by */
/* OBSOLETE    the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE    (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE    This program is distributed in the hope that it will be useful, */
/* OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE    GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE    You should have received a copy of the GNU General Public License */
/* OBSOLETE    along with this program; if not, write to the Free Software */
/* OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE    Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE #include "regcache.h" */
/* OBSOLETE #include "value.h" */
/* OBSOLETE #include "a29k/tm-a29k.h" */
/* OBSOLETE #include "tm-vxworks.h" */
/* OBSOLETE  */
/* OBSOLETE /* Number of registers in a ptrace_getregs call. */ */
/* OBSOLETE  */
/* OBSOLETE #define VX_NUM_REGS (NUM_REGS) */
/* OBSOLETE  */
/* OBSOLETE /* Number of registers in a ptrace_getfpregs call. */ */
/* OBSOLETE  */
/* OBSOLETE /* #define VX_SIZE_FPREGS */ */
/* OBSOLETE  */
/* OBSOLETE /* This is almost certainly the wrong place for this: */ */
/* OBSOLETE #define LR2_REGNUM 34 */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Vxworks has its own CALL_DUMMY since it manages breakpoints in the kernel */ */
/* OBSOLETE  */
/* OBSOLETE #undef CALL_DUMMY */
/* OBSOLETE  */
/* OBSOLETE /* Replace the breakpoint instruction in the CALL_DUMMY with a nop. */
/* OBSOLETE    For Vxworks, the breakpoint is set and deleted by calls to */
/* OBSOLETE    CALL_DUMMY_BREAK_SET and CALL_DUMMY_BREAK_DELETE.  */ */
/* OBSOLETE  */
/* OBSOLETE #error "This file is broken.  GDB does not define HOST_BYTE_ORDER." */
/* OBSOLETE #if TARGET_BYTE_ORDER == HOST_BYTE_ORDER */
/* OBSOLETE #define CALL_DUMMY {0x0400870f,\ */
/* OBSOLETE 		0x36008200|(MSP_HW_REGNUM), \ */
/* OBSOLETE 		0x15000040|(MSP_HW_REGNUM<<8)|(MSP_HW_REGNUM<<16), \ */
/* OBSOLETE 		0x03ff80ff, 0x02ff80ff, 0xc8008080, 0x70400101, 0x70400101} */
/* OBSOLETE #else /* Byte order differs.  */ */
/* OBSOLETE #define CALL_DUMMY {0x0f870004,\ */
/* OBSOLETE 		0x00820036|(MSP_HW_REGNUM << 24), \ */
/* OBSOLETE 		0x40000015|(MSP_HW_REGNUM<<8)|(MSP_HW_REGNUM<<16), \ */
/* OBSOLETE 		0xff80ff03, 0xff80ff02, 0x808000c8, 0x01014070, 0x01014070} */
/* OBSOLETE #endif /* Byte order differs.  */ */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* For the basic CALL_DUMMY definitions, see "tm-29k.h."  We use the */
/* OBSOLETE    same CALL_DUMMY code, but define FIX_CALL_DUMMY (and related macros) */
/* OBSOLETE    locally to handle remote debugging of VxWorks targets.  The difference */
/* OBSOLETE    is in the setting and clearing of the breakpoint at the end of the */
/* OBSOLETE    CALL_DUMMY code fragment; under VxWorks, we can't simply insert a */
/* OBSOLETE    breakpoint instruction into the code, since that would interfere with */
/* OBSOLETE    the breakpoint management mechanism on the target. */
/* OBSOLETE    Note that CALL_DUMMY is a piece of code that is used to call any C function */
/* OBSOLETE    thru VxGDB */ */
/* OBSOLETE  */
/* OBSOLETE /* The offset of the instruction within the CALL_DUMMY code where we */
/* OBSOLETE    want the inferior to stop after the function call has completed. */
/* OBSOLETE    call_function_by_hand () sets a breakpoint here (via CALL_DUMMY_BREAK_SET), */
/* OBSOLETE    which POP_FRAME later deletes (via CALL_DUMMY_BREAK_DELETE).  */ */
/* OBSOLETE  */
/* OBSOLETE #define CALL_DUMMY_STOP_OFFSET (7 * 4) */
/* OBSOLETE  */
/* OBSOLETE /* The offset of the first instruction of the CALL_DUMMY code fragment */
/* OBSOLETE    relative to the frame pointer for a dummy frame.  This is equal to */
/* OBSOLETE    the size of the CALL_DUMMY plus the arg_slop area size (see the diagram */
/* OBSOLETE    in "tm-29k.h").  */ */
/* OBSOLETE /* PAD : the arg_slop area size doesn't appear to me to be useful since, the */
/* OBSOLETE    call dummy code no longer modify the msp. See below. This must be checked. */ */
/* OBSOLETE  */
/* OBSOLETE #define CALL_DUMMY_OFFSET_IN_FRAME (CALL_DUMMY_LENGTH + 16 * 4) */
/* OBSOLETE  */
/* OBSOLETE /* Insert the specified number of args and function address */
/* OBSOLETE    into a CALL_DUMMY sequence stored at DUMMYNAME, replace the third */
/* OBSOLETE    instruction (add msp, msp, 16*4) with a nop, and leave the final nop. */
/* OBSOLETE    We can't keep using a CALL_DUMMY that modify the msp since, for VxWorks, */
/* OBSOLETE    CALL_DUMMY is stored in the Memory Stack. Adding 16 words to the msp */
/* OBSOLETE    would then make possible for the inferior to overwrite the CALL_DUMMY code, */
/* OBSOLETE    thus creating a lot of trouble when exiting the inferior to come back in */
/* OBSOLETE    a CALL_DUMMY code that no longer exists... Furthermore, ESF are also stored */
/* OBSOLETE    from the msp in the memory stack. If msp is set higher than the dummy code, */
/* OBSOLETE    an ESF may clobber this code. */ */
/* OBSOLETE  */
/* OBSOLETE #if TARGET_BYTE_ORDER == BFD_ENDIAN_BIG */
/* OBSOLETE #define NOP_INSTR  0x70400101 */
/* OBSOLETE #else /* Target is little endian */ */
/* OBSOLETE #define NOP_INSTR  0x01014070 */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE #undef FIX_CALL_DUMMY */
/* OBSOLETE #define FIX_CALL_DUMMY(dummyname, pc, fun, nargs, args, type, gcc_p)  \ */
/* OBSOLETE   {                                                                   \ */
/* OBSOLETE     *(int *)((char *)dummyname + 8) = NOP_INSTR;                      \ */
/* OBSOLETE     STUFF_I16((char *)dummyname + CONST_INSN, fun);                   \ */
/* OBSOLETE     STUFF_I16((char *)dummyname + CONST_INSN + 4, fun >> 16);         \ */
/* OBSOLETE   } */
/* OBSOLETE  */
/* OBSOLETE /* For VxWorks, CALL_DUMMY must be stored in the stack of the task that is */
/* OBSOLETE    being debugged and executed "in the context of" this task */ */
/* OBSOLETE  */
/* OBSOLETE #undef CALL_DUMMY_LOCATION */
/* OBSOLETE #define CALL_DUMMY_LOCATION     ON_STACK */
/* OBSOLETE  */
/* OBSOLETE /* Set or delete a breakpoint at the location within a CALL_DUMMY code */
/* OBSOLETE    fragment where we want the target program to stop after the function */
/* OBSOLETE    call is complete.  CALL_DUMMY_ADDR is the address of the first */
/* OBSOLETE    instruction in the CALL_DUMMY.  DUMMY_FRAME_ADDR is the value of the */
/* OBSOLETE    frame pointer in the dummy frame. */
/* OBSOLETE  */
/* OBSOLETE    NOTE: in the both of the following definitions, we take advantage of */
/* OBSOLETE    knowledge of the implementation of the target breakpoint operation, */
/* OBSOLETE    in that we pass a null pointer as the second argument.  It seems */
/* OBSOLETE    reasonable to assume that any target requiring the use of  */
/* OBSOLETE    CALL_DUMMY_BREAK_{SET,DELETE} will not store the breakpoint */
/* OBSOLETE    shadow contents in GDB; in any case, this assumption is vaild */
/* OBSOLETE    for all VxWorks-related targets.  */ */
/* OBSOLETE  */
/* OBSOLETE #define CALL_DUMMY_BREAK_SET(call_dummy_addr) \ */
/* OBSOLETE   target_insert_breakpoint ((call_dummy_addr) + CALL_DUMMY_STOP_OFFSET, \ */
/* OBSOLETE 			    (char *) 0) */
/* OBSOLETE  */
/* OBSOLETE #define CALL_DUMMY_BREAK_DELETE(dummy_frame_addr) \ */
/* OBSOLETE   target_remove_breakpoint ((dummy_frame_addr) - (CALL_DUMMY_OFFSET_IN_FRAME \ */
/* OBSOLETE 				                  - CALL_DUMMY_STOP_OFFSET), \ */
/* OBSOLETE 			    (char *) 0) */
/* OBSOLETE  */
/* OBSOLETE /* Return nonzero if the pc is executing within a CALL_DUMMY frame.  */ */
/* OBSOLETE  */
/* OBSOLETE #define PC_IN_CALL_DUMMY(pc, sp, frame_address) \ */
/* OBSOLETE   ((pc) >= (sp) \ */
/* OBSOLETE     && (pc) <= (sp) + CALL_DUMMY_OFFSET_IN_FRAME + CALL_DUMMY_LENGTH) */
/* OBSOLETE  */
/* OBSOLETE /* Defining this prevents us from trying to pass a structure-valued argument */
/* OBSOLETE    to a function called via the CALL_DUMMY mechanism.  This is not handled */
/* OBSOLETE    properly in call_function_by_hand (), and the fix might require re-writing */
/* OBSOLETE    the CALL_DUMMY handling for all targets (at least, a clean solution */
/* OBSOLETE    would probably require this).  Arguably, this should go in "tm-29k.h" */
/* OBSOLETE    rather than here.  */ */
/* OBSOLETE  */
/* OBSOLETE #define STRUCT_VAL_ARGS_UNSUPPORTED */
/* OBSOLETE  */
/* OBSOLETE #define BKPT_OFFSET	(7 * 4) */
/* OBSOLETE #define BKPT_INSTR	0x72500101 */
/* OBSOLETE  */
/* OBSOLETE #undef FIX_CALL_DUMMY */
/* OBSOLETE #define FIX_CALL_DUMMY(dummyname, pc, fun, nargs, args, type, gcc_p)   \ */
/* OBSOLETE   {\ */
/* OBSOLETE     STUFF_I16((char *)dummyname + CONST_INSN, fun);\ */
/* OBSOLETE     STUFF_I16((char *)dummyname + CONST_INSN + 4, fun >> 16);\ */
/* OBSOLETE     *(int *)((char *)dummyname + BKPT_OFFSET) = BKPT_INSTR;\ */
/* OBSOLETE   } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Offsets into jmp_buf.  They are derived from VxWorks' REG_SET struct */
/* OBSOLETE    (see VxWorks' setjmp.h). Note that Sun2, Sun3 and SunOS4 and VxWorks have */
/* OBSOLETE    different REG_SET structs, hence different layouts for the jmp_buf struct. */
/* OBSOLETE    Only JB_PC is needed for getting the saved PC value.  */ */
/* OBSOLETE  */
/* OBSOLETE #define JB_ELEMENT_SIZE 4	/* size of each element in jmp_buf */ */
/* OBSOLETE #define JB_PC		3	/* offset of pc (pc1) in jmp_buf */ */
/* OBSOLETE  */
/* OBSOLETE /* Figure out where the longjmp will land.  We expect that we have just entered */
/* OBSOLETE    longjmp and haven't yet setup the stack frame, so the args are still in the */
/* OBSOLETE    output regs.  lr2 (LR2_REGNUM) points at the jmp_buf structure from which we */
/* OBSOLETE    extract the pc (JB_PC) that we will land at.  The pc is copied into ADDR. */
/* OBSOLETE    This routine returns true on success */ */
/* OBSOLETE  */
/* OBSOLETE #define GET_LONGJMP_TARGET(ADDR) get_longjmp_target(ADDR) */
/* OBSOLETE extern int get_longjmp_target (CORE_ADDR *); */
/* OBSOLETE  */
/* OBSOLETE /* VxWorks adjusts the PC after a breakpoint has been hit.  */ */
/* OBSOLETE  */
/* OBSOLETE #undef DECR_PC_AFTER_BREAK */
/* OBSOLETE #define DECR_PC_AFTER_BREAK 0 */
/* OBSOLETE  */
/* OBSOLETE /* Do whatever promotions are appropriate on a value being returned */
/* OBSOLETE    from a function.  VAL is the user-supplied value, and FUNC_TYPE */
/* OBSOLETE    is the return type of the function if known, else 0. */
/* OBSOLETE  */
/* OBSOLETE    For the Am29k, as far as I understand, if the function return type is known, */
/* OBSOLETE    cast the value to that type; otherwise, ensure that integer return values */
/* OBSOLETE    fill all of gr96. */
/* OBSOLETE  */
/* OBSOLETE    This definition really belongs in "tm-29k.h", since it applies */
/* OBSOLETE    to most Am29K-based systems; but once moved into that file, it might */
/* OBSOLETE    need to be redefined for all Am29K-based targets that also redefine */
/* OBSOLETE    STORE_RETURN_VALUE.  For now, to be safe, we define it here.  */ */
/* OBSOLETE  */
/* OBSOLETE #define PROMOTE_RETURN_VALUE(val, func_type) \ */
/* OBSOLETE   do {                                                                  \ */
/* OBSOLETE       if (func_type)                                                    \ */
/* OBSOLETE         val = value_cast (func_type, val);                              \ */
/* OBSOLETE       if ((TYPE_CODE (VALUE_TYPE (val)) == TYPE_CODE_INT                \ */
/* OBSOLETE            || TYPE_CODE (VALUE_TYPE (val)) == TYPE_CODE_ENUM)           \ */
/* OBSOLETE           && TYPE_LENGTH (VALUE_TYPE (val)) < REGISTER_RAW_SIZE (0))    \ */
/* OBSOLETE         val = value_cast (builtin_type_int, val);                       \ */
/* OBSOLETE   } while (0) */
/* OBSOLETE  */
/* OBSOLETE extern int vx29k_frame_chain_valid (CORE_ADDR, struct frame_info *); */
/* OBSOLETE #define FRAME_CHAIN_VALID(chain, thisframe) vx29k_frame_chain_valid (chain, thisframe) */
/* OBSOLETE  */
/* OBSOLETE extern CORE_ADDR frame_saved_call_site (); */
/* OBSOLETE  */
/* OBSOLETE #undef PREPARE_TO_INIT_FRAME_INFO */
/* OBSOLETE #define PREPARE_TO_INIT_FRAME_INFO(fci)	do {				      \ */
/* OBSOLETE   long current_msp = read_register (MSP_REGNUM);			      \ */
/* OBSOLETE   if (PC_IN_CALL_DUMMY (fci->pc, current_msp, 0))			      \ */
/* OBSOLETE     {									      \ */
/* OBSOLETE       fci->rsize = DUMMY_FRAME_RSIZE;					      \ */
/* OBSOLETE       fci->msize = 0;							      \ */
/* OBSOLETE       fci->saved_msp =	 						      \ */
/* OBSOLETE 	read_register_stack_integer (fci->frame + DUMMY_FRAME_RSIZE - 4, 4);  \ */
/* OBSOLETE       fci->flags |= (TRANSPARENT|MFP_USED);				      \ */
/* OBSOLETE       return;								      \ */
/* OBSOLETE     }									      \ */
/* OBSOLETE   } while (0) */
@


1.8
log
@* MAINTAINERS: Mark a29k target as obsolete.
* Makefile.in (a29k-tdep.o, remote-adapt.o, remote-eb.o)
(remote-mm.o, remote-udi.o): Obsolete.  Remove references in
comments.
* NEWS: Note that a29k targets are obsolete.
* a29k-tdep.c: Mark as obsolete.
* configure.tgt: Mark a29k-*-aout*, a29k-*-coff*, a29k-*-elf*,
a29k-*-ebmon*, a29k-*-kern*, a29k-*-none*, a29k-*-udi* and
a29k-*-vxworks* targets as obsolete.
* remote-adapt.c: Obsolete.
* remote-eb.c: Obsolete.
* remote-mm.c: Obsolete.
* remote-udi.c: Obsolete.
* config/a29k/a29k-udi.mt: Obsolete.
* config/a29k/a29k.mt: Obsolete.
* config/a29k/tm-a29k.h: Obsolete.
* config/a29k/tm-vx29k.h: Obsolete.
* config/a29k/vx29k.mt: Obsolete.
@
text
@@


1.7
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@d1 230
a230 230
/* Target machine description for VxWorks on the 29k, for GDB, the GNU debugger.
   Copyright 1994, 1995, 1998, 1999, 2000 Free Software Foundation, Inc.
   Contributed by Cygnus Support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "regcache.h"
#include "value.h"
#include "a29k/tm-a29k.h"
#include "tm-vxworks.h"

/* Number of registers in a ptrace_getregs call. */

#define VX_NUM_REGS (NUM_REGS)

/* Number of registers in a ptrace_getfpregs call. */

/* #define VX_SIZE_FPREGS */

/* This is almost certainly the wrong place for this: */
#define LR2_REGNUM 34


/* Vxworks has its own CALL_DUMMY since it manages breakpoints in the kernel */

#undef CALL_DUMMY

/* Replace the breakpoint instruction in the CALL_DUMMY with a nop.
   For Vxworks, the breakpoint is set and deleted by calls to
   CALL_DUMMY_BREAK_SET and CALL_DUMMY_BREAK_DELETE.  */

#error "This file is broken.  GDB does not define HOST_BYTE_ORDER."
#if TARGET_BYTE_ORDER == HOST_BYTE_ORDER
#define CALL_DUMMY {0x0400870f,\
		0x36008200|(MSP_HW_REGNUM), \
		0x15000040|(MSP_HW_REGNUM<<8)|(MSP_HW_REGNUM<<16), \
		0x03ff80ff, 0x02ff80ff, 0xc8008080, 0x70400101, 0x70400101}
#else /* Byte order differs.  */
#define CALL_DUMMY {0x0f870004,\
		0x00820036|(MSP_HW_REGNUM << 24), \
		0x40000015|(MSP_HW_REGNUM<<8)|(MSP_HW_REGNUM<<16), \
		0xff80ff03, 0xff80ff02, 0x808000c8, 0x01014070, 0x01014070}
#endif /* Byte order differs.  */


/* For the basic CALL_DUMMY definitions, see "tm-29k.h."  We use the
   same CALL_DUMMY code, but define FIX_CALL_DUMMY (and related macros)
   locally to handle remote debugging of VxWorks targets.  The difference
   is in the setting and clearing of the breakpoint at the end of the
   CALL_DUMMY code fragment; under VxWorks, we can't simply insert a
   breakpoint instruction into the code, since that would interfere with
   the breakpoint management mechanism on the target.
   Note that CALL_DUMMY is a piece of code that is used to call any C function
   thru VxGDB */

/* The offset of the instruction within the CALL_DUMMY code where we
   want the inferior to stop after the function call has completed.
   call_function_by_hand () sets a breakpoint here (via CALL_DUMMY_BREAK_SET),
   which POP_FRAME later deletes (via CALL_DUMMY_BREAK_DELETE).  */

#define CALL_DUMMY_STOP_OFFSET (7 * 4)

/* The offset of the first instruction of the CALL_DUMMY code fragment
   relative to the frame pointer for a dummy frame.  This is equal to
   the size of the CALL_DUMMY plus the arg_slop area size (see the diagram
   in "tm-29k.h").  */
/* PAD : the arg_slop area size doesn't appear to me to be useful since, the
   call dummy code no longer modify the msp. See below. This must be checked. */

#define CALL_DUMMY_OFFSET_IN_FRAME (CALL_DUMMY_LENGTH + 16 * 4)

/* Insert the specified number of args and function address
   into a CALL_DUMMY sequence stored at DUMMYNAME, replace the third
   instruction (add msp, msp, 16*4) with a nop, and leave the final nop.
   We can't keep using a CALL_DUMMY that modify the msp since, for VxWorks,
   CALL_DUMMY is stored in the Memory Stack. Adding 16 words to the msp
   would then make possible for the inferior to overwrite the CALL_DUMMY code,
   thus creating a lot of trouble when exiting the inferior to come back in
   a CALL_DUMMY code that no longer exists... Furthermore, ESF are also stored
   from the msp in the memory stack. If msp is set higher than the dummy code,
   an ESF may clobber this code. */

#if TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
#define NOP_INSTR  0x70400101
#else /* Target is little endian */
#define NOP_INSTR  0x01014070
#endif

#undef FIX_CALL_DUMMY
#define FIX_CALL_DUMMY(dummyname, pc, fun, nargs, args, type, gcc_p)  \
  {                                                                   \
    *(int *)((char *)dummyname + 8) = NOP_INSTR;                      \
    STUFF_I16((char *)dummyname + CONST_INSN, fun);                   \
    STUFF_I16((char *)dummyname + CONST_INSN + 4, fun >> 16);         \
  }

/* For VxWorks, CALL_DUMMY must be stored in the stack of the task that is
   being debugged and executed "in the context of" this task */

#undef CALL_DUMMY_LOCATION
#define CALL_DUMMY_LOCATION     ON_STACK

/* Set or delete a breakpoint at the location within a CALL_DUMMY code
   fragment where we want the target program to stop after the function
   call is complete.  CALL_DUMMY_ADDR is the address of the first
   instruction in the CALL_DUMMY.  DUMMY_FRAME_ADDR is the value of the
   frame pointer in the dummy frame.

   NOTE: in the both of the following definitions, we take advantage of
   knowledge of the implementation of the target breakpoint operation,
   in that we pass a null pointer as the second argument.  It seems
   reasonable to assume that any target requiring the use of 
   CALL_DUMMY_BREAK_{SET,DELETE} will not store the breakpoint
   shadow contents in GDB; in any case, this assumption is vaild
   for all VxWorks-related targets.  */

#define CALL_DUMMY_BREAK_SET(call_dummy_addr) \
  target_insert_breakpoint ((call_dummy_addr) + CALL_DUMMY_STOP_OFFSET, \
			    (char *) 0)

#define CALL_DUMMY_BREAK_DELETE(dummy_frame_addr) \
  target_remove_breakpoint ((dummy_frame_addr) - (CALL_DUMMY_OFFSET_IN_FRAME \
				                  - CALL_DUMMY_STOP_OFFSET), \
			    (char *) 0)

/* Return nonzero if the pc is executing within a CALL_DUMMY frame.  */

#define PC_IN_CALL_DUMMY(pc, sp, frame_address) \
  ((pc) >= (sp) \
    && (pc) <= (sp) + CALL_DUMMY_OFFSET_IN_FRAME + CALL_DUMMY_LENGTH)

/* Defining this prevents us from trying to pass a structure-valued argument
   to a function called via the CALL_DUMMY mechanism.  This is not handled
   properly in call_function_by_hand (), and the fix might require re-writing
   the CALL_DUMMY handling for all targets (at least, a clean solution
   would probably require this).  Arguably, this should go in "tm-29k.h"
   rather than here.  */

#define STRUCT_VAL_ARGS_UNSUPPORTED

#define BKPT_OFFSET	(7 * 4)
#define BKPT_INSTR	0x72500101

#undef FIX_CALL_DUMMY
#define FIX_CALL_DUMMY(dummyname, pc, fun, nargs, args, type, gcc_p)   \
  {\
    STUFF_I16((char *)dummyname + CONST_INSN, fun);\
    STUFF_I16((char *)dummyname + CONST_INSN + 4, fun >> 16);\
    *(int *)((char *)dummyname + BKPT_OFFSET) = BKPT_INSTR;\
  }


/* Offsets into jmp_buf.  They are derived from VxWorks' REG_SET struct
   (see VxWorks' setjmp.h). Note that Sun2, Sun3 and SunOS4 and VxWorks have
   different REG_SET structs, hence different layouts for the jmp_buf struct.
   Only JB_PC is needed for getting the saved PC value.  */

#define JB_ELEMENT_SIZE 4	/* size of each element in jmp_buf */
#define JB_PC		3	/* offset of pc (pc1) in jmp_buf */

/* Figure out where the longjmp will land.  We expect that we have just entered
   longjmp and haven't yet setup the stack frame, so the args are still in the
   output regs.  lr2 (LR2_REGNUM) points at the jmp_buf structure from which we
   extract the pc (JB_PC) that we will land at.  The pc is copied into ADDR.
   This routine returns true on success */

#define GET_LONGJMP_TARGET(ADDR) get_longjmp_target(ADDR)
extern int get_longjmp_target (CORE_ADDR *);

/* VxWorks adjusts the PC after a breakpoint has been hit.  */

#undef DECR_PC_AFTER_BREAK
#define DECR_PC_AFTER_BREAK 0

/* Do whatever promotions are appropriate on a value being returned
   from a function.  VAL is the user-supplied value, and FUNC_TYPE
   is the return type of the function if known, else 0.

   For the Am29k, as far as I understand, if the function return type is known,
   cast the value to that type; otherwise, ensure that integer return values
   fill all of gr96.

   This definition really belongs in "tm-29k.h", since it applies
   to most Am29K-based systems; but once moved into that file, it might
   need to be redefined for all Am29K-based targets that also redefine
   STORE_RETURN_VALUE.  For now, to be safe, we define it here.  */

#define PROMOTE_RETURN_VALUE(val, func_type) \
  do {                                                                  \
      if (func_type)                                                    \
        val = value_cast (func_type, val);                              \
      if ((TYPE_CODE (VALUE_TYPE (val)) == TYPE_CODE_INT                \
           || TYPE_CODE (VALUE_TYPE (val)) == TYPE_CODE_ENUM)           \
          && TYPE_LENGTH (VALUE_TYPE (val)) < REGISTER_RAW_SIZE (0))    \
        val = value_cast (builtin_type_int, val);                       \
  } while (0)

extern int vx29k_frame_chain_valid (CORE_ADDR, struct frame_info *);
#define FRAME_CHAIN_VALID(chain, thisframe) vx29k_frame_chain_valid (chain, thisframe)

extern CORE_ADDR frame_saved_call_site ();

#undef PREPARE_TO_INIT_FRAME_INFO
#define PREPARE_TO_INIT_FRAME_INFO(fci)	do {				      \
  long current_msp = read_register (MSP_REGNUM);			      \
  if (PC_IN_CALL_DUMMY (fci->pc, current_msp, 0))			      \
    {									      \
      fci->rsize = DUMMY_FRAME_RSIZE;					      \
      fci->msize = 0;							      \
      fci->saved_msp =	 						      \
	read_register_stack_integer (fci->frame + DUMMY_FRAME_RSIZE - 4, 4);  \
      fci->flags |= (TRANSPARENT|MFP_USED);				      \
      return;								      \
    }									      \
  } while (0)
@


1.6
log
@Delete HOST_BYTE_ORDER.
@
text
@d98 1
a98 1
#if TARGET_BYTE_ORDER == BIG_ENDIAN
@


1.5
log
@Add explicit #include of "value.h".
@
text
@d47 1
@


1.4
log
@Include regcache.h
@
text
@d23 1
@


1.3
log
@Update/correct copyright notices.
@
text
@d22 1
@


1.2
log
@PARAMS removal.
@
text
@d2 1
a2 1
   Copyright 1994, 1999 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1994 Free Software Foundation, Inc.
d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d23 1
a23 4

#define	GDBINIT_FILENAME	".vxgdbinit"

#define	DEFAULT_PROMPT		"(vxgdb) "
d72 1
a72 1
 
d74 1
a74 1
 
d122 6
a127 6
	 knowledge of the implementation of the target breakpoint operation,
	 in that we pass a null pointer as the second argument.  It seems
	 reasonable to assume that any target requiring the use of 
	 CALL_DUMMY_BREAK_{SET,DELETE} will not store the breakpoint
	 shadow contents in GDB; in any case, this assumption is vaild
	 for all VxWorks-related targets.  */
d150 1
a150 1
   
d163 1
a164 1

d170 1
a170 1
#define JB_ELEMENT_SIZE 4       /* size of each element in jmp_buf */
d172 1
a172 1
 
d180 1
a180 1
extern int get_longjmp_target PARAMS ((CORE_ADDR *));
d183 1
a183 1
 
d190 1
a190 1
 
d199 1
a199 1
 
d210 1
a210 1
extern int vx29k_frame_chain_valid PARAMS ((CORE_ADDR, struct frame_info *));
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-06-07 snapshot
@
text
@d2 1
a2 1
   Copyright 1994, 1999 Free Software Foundation, Inc.
d22 4
a25 1
#include "tm-vxworks.h"
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d71 1
a71 1

d73 1
a73 1

d121 6
a126 6
   knowledge of the implementation of the target breakpoint operation,
   in that we pass a null pointer as the second argument.  It seems
   reasonable to assume that any target requiring the use of 
   CALL_DUMMY_BREAK_{SET,DELETE} will not store the breakpoint
   shadow contents in GDB; in any case, this assumption is vaild
   for all VxWorks-related targets.  */
d149 1
a149 1

d162 1
a163 1

d169 1
a169 1
#define JB_ELEMENT_SIZE 4	/* size of each element in jmp_buf */
d171 1
a171 1

d182 1
a182 1

d189 1
a189 1

d198 1
a198 1

@

