head	1.5;
access;
symbols
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.8
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.6
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.4
	gdb_5_1-2001-07-29-branchpoint:1.4
	dberlin-typesystem-branch:1.4.0.2
	dberlin-typesystem-branchpoint:1.4
	gdb-post-ptid_t-2001-05-03:1.4
	gdb-pre-ptid_t-2001-05-03:1.4
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.4
	gdb-1999-10-25:1.1.1.4
	gdb-1999-10-18:1.1.1.4
	gdb-1999-10-11:1.1.1.4
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.4
	gdb-1999-09-21:1.1.1.4
	gdb-1999-09-13:1.1.1.4
	gdb-1999-09-08:1.1.1.4
	gdb-1999-08-30:1.1.1.4
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2001.12.01.23.06.47;	author cagney;	state dead;
branches;
next	1.4;

1.4
date	2001.04.17.21.20.49;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.06.08.21.30;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.28.01.12.36;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.22;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.22;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.05.05.14.43.33;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.25.18.04.55;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.14.21;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Zap sony news (m68k) and ISI (m68k) targets.
@
text
@/* OBSOLETE /* Definitions to target GDB on an ISI Optimum V (3.05) under 4.3bsd. */
/* OBSOLETE    Copyright 1987, 1989, 1991, 1993, 1999, 2000 */
/* OBSOLETE    Free Software Foundation, Inc. */
/* OBSOLETE  */
/* OBSOLETE    This file is part of GDB. */
/* OBSOLETE  */
/* OBSOLETE    This program is free software; you can redistribute it and/or modify */
/* OBSOLETE    it under the terms of the GNU General Public License as published by */
/* OBSOLETE    the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE    (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE    This program is distributed in the hope that it will be useful, */
/* OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE    GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE    You should have received a copy of the GNU General Public License */
/* OBSOLETE    along with this program; if not, write to the Free Software */
/* OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330, */
/* OBSOLETE    Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE /* This has not been tested on ISI's running BSD 4.2, but it will probably */
/* OBSOLETE    work.  */ */
/* OBSOLETE  */
/* OBSOLETE /* Data segment starts at etext rounded up to DATAROUND in {N,Z}MAGIC files */ */
/* OBSOLETE  */
/* OBSOLETE #define DATAROUND	0x20000 */
/* OBSOLETE #define N_DATADDR(hdr)	(hdr.a_magic != OMAGIC ? \ */
/* OBSOLETE 	(hdr.a_text + DATAROUND) & ~(DATAROUND-1) : hdr.a_text) */
/* OBSOLETE  */
/* OBSOLETE /* Text segment starts at sizeof (struct exec) in {N,Z}MAGIC files */ */
/* OBSOLETE  */
/* OBSOLETE #define N_TXTADDR(hdr)	(hdr.a_magic != OMAGIC ? sizeof (struct exec) : 0) */
/* OBSOLETE  */
/* OBSOLETE /* Amount PC must be decremented by after a breakpoint. */
/* OBSOLETE    This is often the number of bytes in BREAKPOINT */
/* OBSOLETE    but not always. */
/* OBSOLETE    On the ISI, the kernel resets the pc to the trap instr */ */
/* OBSOLETE  */
/* OBSOLETE #define DECR_PC_AFTER_BREAK 0 */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Return number of args passed to a frame. */
/* OBSOLETE    Can return -1, meaning no way to tell.  */ */
/* OBSOLETE  */
/* OBSOLETE extern int isi_frame_num_args (struct frame_info *fi); */
/* OBSOLETE #define FRAME_NUM_ARGS(fi) (isi_frame_num_args ((fi))) */
/* OBSOLETE  */
/* OBSOLETE /* Put here the code to store, into a struct frame_saved_regs, */
/* OBSOLETE    the addresses of the saved registers of frame described by FRAME_INFO. */
/* OBSOLETE    This includes special registers such as pc and fp saved in special */
/* OBSOLETE    ways in the stack frame.  sp is even more special: */
/* OBSOLETE    the address we return for it IS the sp for the next frame.  */ */
/* OBSOLETE  */
/* OBSOLETE #define FRAME_FIND_SAVED_REGS(frame_info, frame_saved_regs)		\ */
/* OBSOLETE { register int regnum;							\ */
/* OBSOLETE   register int regmask;							\ */
/* OBSOLETE   register CORE_ADDR next_addr;						\ */
/* OBSOLETE   register CORE_ADDR pc;						\ */
/* OBSOLETE   register int insn;							\ */
/* OBSOLETE   register int offset;							\ */
/* OBSOLETE   memset (&frame_saved_regs, '\0', sizeof frame_saved_regs);			\ */
/* OBSOLETE   if ((frame_info)->pc >= (frame_info)->frame - CALL_DUMMY_LENGTH - FP_REGNUM*4 - 8*12 - 4 \ */
/* OBSOLETE       && (frame_info)->pc <= (frame_info)->frame)				\ */
/* OBSOLETE     { next_addr = (frame_info)->frame;					\ */
/* OBSOLETE       pc = (frame_info)->frame - CALL_DUMMY_LENGTH - FP_REGNUM * 4 - 8*12 - 4; }\ */
/* OBSOLETE   else   								\ */
/* OBSOLETE     { pc = get_pc_function_start ((frame_info)->pc); 			\ */
/* OBSOLETE       /* Verify we have a link a6 instruction next,			\ */
/* OBSOLETE 	 or a branch followed by a link a6 instruction;			\ */
/* OBSOLETE 	 if not we lose.  If we win, find the address above the saved   \ */
/* OBSOLETE 	 regs using the amount of storage from the link instruction.  */\ */
/* OBSOLETE retry:									\ */
/* OBSOLETE       insn = read_memory_integer (pc, 2);				\ */
/* OBSOLETE       if (insn == 044016)						\ */
/* OBSOLETE 	next_addr = (frame_info)->frame - read_memory_integer (pc += 2, 4), pc+=4; \ */
/* OBSOLETE       else if (insn == 047126)						\ */
/* OBSOLETE 	next_addr = (frame_info)->frame - read_memory_integer (pc += 2, 2), pc+=2; \ */
/* OBSOLETE       else if ((insn & 0177400) == 060000)	/* bra insn */		\ */
/* OBSOLETE 	{ offset = insn & 0377;						\ */
/* OBSOLETE           pc += 2;				/* advance past bra */	\ */
/* OBSOLETE 	  if (offset == 0)			/* bra #word */		\ */
/* OBSOLETE 	    offset = read_memory_integer (pc, 2), pc += 2;		\ */
/* OBSOLETE 	  else if (offset == 0377)		/* bra #long */		\ */
/* OBSOLETE 	    offset = read_memory_integer (pc, 4), pc += 4;		\ */
/* OBSOLETE 	  pc += offset;							\ */
/* OBSOLETE 	  goto retry;							\ */
/* OBSOLETE       } else goto lose;							\ */
/* OBSOLETE       /* If have an addal #-n, sp next, adjust next_addr.  */		\ */
/* OBSOLETE       if ((0177777 & read_memory_integer (pc, 2)) == 0157774)		\ */
/* OBSOLETE 	next_addr += read_memory_integer (pc += 2, 4), pc += 4;		\ */
/* OBSOLETE     }									\ */
/* OBSOLETE   /* next should be a moveml to (sp) or -(sp) or a movl r,-(sp) */	\ */
/* OBSOLETE   insn = read_memory_integer (pc, 2), pc += 2;				\ */
/* OBSOLETE   regmask = read_memory_integer (pc, 2);				\ */
/* OBSOLETE   if ((insn & 0177760) == 022700)	/* movl rn, (sp) */		\ */
/* OBSOLETE     (frame_saved_regs).regs[(insn&7) + ((insn&010)?8:0)] = next_addr;	\ */
/* OBSOLETE   else if ((insn & 0177760) == 024700)	/* movl rn, -(sp) */		\ */
/* OBSOLETE     (frame_saved_regs).regs[(insn&7) + ((insn&010)?8:0)] = next_addr-=4; \ */
/* OBSOLETE   else if (insn == 0044327)		/* moveml mask, (sp) */		\ */
/* OBSOLETE     { pc += 2;								\ */
/* OBSOLETE       /* Regmask's low bit is for register 0, the first written */	\ */
/* OBSOLETE       next_addr -= 4;							\ */
/* OBSOLETE       for (regnum = 0; regnum < 16; regnum++, regmask >>= 1)		\ */
/* OBSOLETE 	if (regmask & 1)						\ */
/* OBSOLETE           (frame_saved_regs).regs[regnum] = (next_addr += 4);		\ */
/* OBSOLETE   } else if (insn == 0044347)		/* moveml mask, -(sp) */	\ */
/* OBSOLETE     { pc += 2;								\ */
/* OBSOLETE       /* Regmask's low bit is for register 15, the first pushed */	\ */
/* OBSOLETE       for (regnum = 15; regnum >= 0; regnum--, regmask >>= 1)		\ */
/* OBSOLETE 	if (regmask & 1)						\ */
/* OBSOLETE           (frame_saved_regs).regs[regnum] = (next_addr -= 4); }		\ */
/* OBSOLETE   /* clrw -(sp); movw ccr,-(sp) may follow.  */				\ */
/* OBSOLETE   if (read_memory_integer (pc, 2) == 041147 				\ */
/* OBSOLETE       && read_memory_integer (pc+2, 2) == 042347)			\ */
/* OBSOLETE     (frame_saved_regs).regs[PS_REGNUM] = (next_addr -= 4);		\ */
/* OBSOLETE   lose: ;								\ */
/* OBSOLETE   (frame_saved_regs).regs[SP_REGNUM] = (frame_info)->frame + 8;		\ */
/* OBSOLETE   (frame_saved_regs).regs[FP_REGNUM] = (frame_info)->frame;		\ */
/* OBSOLETE   (frame_saved_regs).regs[PC_REGNUM] = (frame_info)->frame + 4;		\ */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* The only reason this is here is the tm-isi.h reference below.  It */
/* OBSOLETE    was moved back here from tm-m68k.h.  FIXME? */ */
/* OBSOLETE  */
/* OBSOLETE extern CORE_ADDR isi_skip_prologue (CORE_ADDR); */
/* OBSOLETE #define SKIP_PROLOGUE(pc) (isi_skip_prologue (pc)) */
/* OBSOLETE  */
/* OBSOLETE #include "m68k/tm-m68k.h" */
@


1.4
log
@Obsolete NEWS and ISI systems (along with a few redundant m68k targets).
@
text
@@


1.3
log
@Update/correct copyright notices.
@
text
@d1 129
a129 129
/* Definitions to target GDB on an ISI Optimum V (3.05) under 4.3bsd.
   Copyright 1987, 1989, 1991, 1993, 1999, 2000
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* This has not been tested on ISI's running BSD 4.2, but it will probably
   work.  */

/* Data segment starts at etext rounded up to DATAROUND in {N,Z}MAGIC files */

#define DATAROUND	0x20000
#define N_DATADDR(hdr)	(hdr.a_magic != OMAGIC ? \
	(hdr.a_text + DATAROUND) & ~(DATAROUND-1) : hdr.a_text)

/* Text segment starts at sizeof (struct exec) in {N,Z}MAGIC files */

#define N_TXTADDR(hdr)	(hdr.a_magic != OMAGIC ? sizeof (struct exec) : 0)

/* Amount PC must be decremented by after a breakpoint.
   This is often the number of bytes in BREAKPOINT
   but not always.
   On the ISI, the kernel resets the pc to the trap instr */

#define DECR_PC_AFTER_BREAK 0


/* Return number of args passed to a frame.
   Can return -1, meaning no way to tell.  */

extern int isi_frame_num_args (struct frame_info *fi);
#define FRAME_NUM_ARGS(fi) (isi_frame_num_args ((fi)))

/* Put here the code to store, into a struct frame_saved_regs,
   the addresses of the saved registers of frame described by FRAME_INFO.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special:
   the address we return for it IS the sp for the next frame.  */

#define FRAME_FIND_SAVED_REGS(frame_info, frame_saved_regs)		\
{ register int regnum;							\
  register int regmask;							\
  register CORE_ADDR next_addr;						\
  register CORE_ADDR pc;						\
  register int insn;							\
  register int offset;							\
  memset (&frame_saved_regs, '\0', sizeof frame_saved_regs);			\
  if ((frame_info)->pc >= (frame_info)->frame - CALL_DUMMY_LENGTH - FP_REGNUM*4 - 8*12 - 4 \
      && (frame_info)->pc <= (frame_info)->frame)				\
    { next_addr = (frame_info)->frame;					\
      pc = (frame_info)->frame - CALL_DUMMY_LENGTH - FP_REGNUM * 4 - 8*12 - 4; }\
  else   								\
    { pc = get_pc_function_start ((frame_info)->pc); 			\
      /* Verify we have a link a6 instruction next,			\
	 or a branch followed by a link a6 instruction;			\
	 if not we lose.  If we win, find the address above the saved   \
	 regs using the amount of storage from the link instruction.  */\
retry:									\
      insn = read_memory_integer (pc, 2);				\
      if (insn == 044016)						\
	next_addr = (frame_info)->frame - read_memory_integer (pc += 2, 4), pc+=4; \
      else if (insn == 047126)						\
	next_addr = (frame_info)->frame - read_memory_integer (pc += 2, 2), pc+=2; \
      else if ((insn & 0177400) == 060000)	/* bra insn */		\
	{ offset = insn & 0377;						\
          pc += 2;				/* advance past bra */	\
	  if (offset == 0)			/* bra #word */		\
	    offset = read_memory_integer (pc, 2), pc += 2;		\
	  else if (offset == 0377)		/* bra #long */		\
	    offset = read_memory_integer (pc, 4), pc += 4;		\
	  pc += offset;							\
	  goto retry;							\
      } else goto lose;							\
      /* If have an addal #-n, sp next, adjust next_addr.  */		\
      if ((0177777 & read_memory_integer (pc, 2)) == 0157774)		\
	next_addr += read_memory_integer (pc += 2, 4), pc += 4;		\
    }									\
  /* next should be a moveml to (sp) or -(sp) or a movl r,-(sp) */	\
  insn = read_memory_integer (pc, 2), pc += 2;				\
  regmask = read_memory_integer (pc, 2);				\
  if ((insn & 0177760) == 022700)	/* movl rn, (sp) */		\
    (frame_saved_regs).regs[(insn&7) + ((insn&010)?8:0)] = next_addr;	\
  else if ((insn & 0177760) == 024700)	/* movl rn, -(sp) */		\
    (frame_saved_regs).regs[(insn&7) + ((insn&010)?8:0)] = next_addr-=4; \
  else if (insn == 0044327)		/* moveml mask, (sp) */		\
    { pc += 2;								\
      /* Regmask's low bit is for register 0, the first written */	\
      next_addr -= 4;							\
      for (regnum = 0; regnum < 16; regnum++, regmask >>= 1)		\
	if (regmask & 1)						\
          (frame_saved_regs).regs[regnum] = (next_addr += 4);		\
  } else if (insn == 0044347)		/* moveml mask, -(sp) */	\
    { pc += 2;								\
      /* Regmask's low bit is for register 15, the first pushed */	\
      for (regnum = 15; regnum >= 0; regnum--, regmask >>= 1)		\
	if (regmask & 1)						\
          (frame_saved_regs).regs[regnum] = (next_addr -= 4); }		\
  /* clrw -(sp); movw ccr,-(sp) may follow.  */				\
  if (read_memory_integer (pc, 2) == 041147 				\
      && read_memory_integer (pc+2, 2) == 042347)			\
    (frame_saved_regs).regs[PS_REGNUM] = (next_addr -= 4);		\
  lose: ;								\
  (frame_saved_regs).regs[SP_REGNUM] = (frame_info)->frame + 8;		\
  (frame_saved_regs).regs[FP_REGNUM] = (frame_info)->frame;		\
  (frame_saved_regs).regs[PC_REGNUM] = (frame_info)->frame + 4;		\
}

/* The only reason this is here is the tm-isi.h reference below.  It
   was moved back here from tm-m68k.h.  FIXME? */

extern CORE_ADDR isi_skip_prologue (CORE_ADDR);
#define SKIP_PROLOGUE(pc) (isi_skip_prologue (pc))

#include "m68k/tm-m68k.h"
@


1.2
log
@PARAMS removal.
@
text
@d2 2
a3 1
   Copyright (C) 1987, 1989, 1991, 1993 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d40 1
a41 1

d45 2
a46 12
#define FRAME_NUM_ARGS(val, fi)  \
{ register CORE_ADDR pc = FRAME_SAVED_PC (fi);			\
  register int insn = 0177777 & read_memory_integer (pc, 2);	\
  val = 0;							\
  if (insn == 0047757 || insn == 0157374)  /* lea W(sp),sp or addaw #W,sp */ \
    val = read_memory_integer (pc + 2, 2);			\
  else if ((insn & 0170777) == 0050217 /* addql #N, sp */	\
	   || (insn & 0170777) == 0050117)  /* addqw */		\
    { val = (insn >> 9) & 7; if (val == 0) val = 8; }		\
  else if (insn == 0157774) /* addal #WW, sp */			\
    val = read_memory_integer (pc + 2, 4);			\
  val >>= 2; }
d125 2
a126 15
#define SKIP_PROLOGUE(pc)   \
{ register int op = read_memory_integer (pc, 2);	\
  if (op == 0047126)					\
    pc += 4;   /* Skip link #word */			\
  else if (op == 0044016)				\
    pc += 6;   /* Skip link #long */			\
  /* Not sure why branches are here.  */		\
  /* From tm-isi.h, tm-altos.h */			\
  else if (op == 0060000)				\
    pc += 4;   /* Skip bra #word */			\
  else if (op == 00600377)				\
    pc += 6;   /* skip bra #long */			\
  else if ((op & 0177400) == 0060000)			\
    pc += 2;   /* skip bra #char */			\
}
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990504 snapshot
@
text
@d134 15
a148 2
extern CORE_ADDR isi_skip_prologue PARAMS ((CORE_ADDR));
#define SKIP_PROLOGUE(pc) (isi_skip_prologue (pc))
@


1.1.1.3
log
@import gdb-1999-05-25 snapshot
@
text
@d44 12
a55 2
extern int isi_frame_num_args PARAMS ((struct frame_info *fi));
#define FRAME_NUM_ARGS(fi) (isi_frame_num_args ((fi)))
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d39 1
a40 1

d44 1
a44 1
extern int isi_frame_num_args PARAMS ((struct frame_info * fi));
@

