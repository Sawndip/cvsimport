head	1.12;
access;
symbols
	gdb_5_3-2002-12-12-release:1.11
	carlton_dictionary-20021115-merge:1.11
	kseitz_interps-20021105-merge:1.11
	kseitz_interps-20021103-merge:1.11
	drow-cplus-merge-20021020:1.11
	drow-cplus-merge-20021025:1.11
	carlton_dictionary-20021025-merge:1.11
	carlton_dictionary-20021011-merge:1.11
	drow-cplus-branch:1.11.0.10
	drow-cplus-branchpoint:1.11
	kseitz_interps-20020930-merge:1.11
	carlton_dictionary-20020927-merge:1.11
	carlton_dictionary-branch:1.11.0.8
	carlton_dictionary-20020920-branchpoint:1.11
	gdb_5_3-branch:1.11.0.6
	gdb_5_3-2002-09-04-branchpoint:1.11
	kseitz_interps-20020829-merge:1.11
	cagney_sysregs-20020825-branch:1.11.0.4
	cagney_sysregs-20020825-branchpoint:1.11
	readline_4_3-import-branch:1.11.0.2
	readline_4_3-import-branchpoint:1.11
	gdb_5_2_1-2002-07-23-release:1.9
	kseitz_interps-20020528-branch:1.9.0.8
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.6
	cagney_regbuf-20020515-branchpoint:1.9
	jimb-macro-020506-branch:1.9.0.4
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	gdb_5_2-branch:1.9.0.2
	gdb_5_2-2002-03-03-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.6
	gdb_5_1_0_1-2002-01-03-release:1.6
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.6.0.8
	gdb_5_1-2001-11-21-release:1.6
	gdb_s390-2001-09-26-branch:1.6.0.6
	gdb_s390-2001-09-26-branchpoint:1.6
	gdb_5_1-2001-07-29-branch:1.6.0.4
	gdb_5_1-2001-07-29-branchpoint:1.6
	dberlin-typesystem-branch:1.6.0.2
	dberlin-typesystem-branchpoint:1.6
	gdb-post-ptid_t-2001-05-03:1.6
	gdb-pre-ptid_t-2001-05-03:1.6
	insight-precleanup-2001-01-01:1.4
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb-post-params-removal-2000-06-04:1.4
	gdb-pre-params-removal-2000-06-04:1.4
	gdb-post-params-removal-2000-05-28:1.4
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.7
	insight-2000-02-04:1.1.1.7
	gdb-2000-02-04:1.1.1.7
	gdb-2000-02-02:1.1.1.7
	gdb-2000-02-01:1.1.1.7
	gdb-2000-01-31:1.1.1.7
	gdb-2000-01-26:1.1.1.7
	gdb-2000-01-24:1.1.1.7
	gdb-2000-01-17:1.1.1.7
	gdb-2000-01-10:1.1.1.7
	gdb-2000-01-05:1.1.1.7
	gdb-1999-12-21:1.1.1.7
	gdb-1999-12-13:1.1.1.7
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.6
	gdb-1999-11-16:1.1.1.6
	gdb-1999-11-08:1.1.1.6
	gdb-1999-11-01:1.1.1.6
	gdb-1999-10-25:1.1.1.6
	gdb-1999-10-18:1.1.1.6
	gdb-1999-10-11:1.1.1.6
	gdb-1999-10-04:1.1.1.6
	gdb-1999-09-28:1.1.1.6
	gdb-1999-09-21:1.1.1.6
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.6
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.5
	gdb-1999-08-09:1.1.1.5
	gdb-1999-08-02:1.1.1.5
	gdb-1999-07-26:1.1.1.5
	gdb-1999-07-19:1.1.1.5
	gdb-1999-07-12:1.1.1.5
	gdb-post-reformat-19990707:1.1.1.5
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.5
	gdb-pre-reformat-19990707:1.1.1.4
	gdb-1999-07-07:1.1.1.4
	gdb-1999-07-05:1.1.1.4
	gdb-1999-06-28:1.1.1.4
	gdb-1999-06-21:1.1.1.4
	gdb-1999-06-14:1.1.1.4
	gdb-1999-06-07:1.1.1.4
	gdb-1999-06-01:1.1.1.4
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.4
	gdb-1999-05-19:1.1.1.3
	gdb-1999-05-10:1.1.1.3
	gdb-19990504:1.1.1.3
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.12
date	2002.12.16.20.39.14;	author cagney;	state dead;
branches;
next	1.11;

1.11
date	2002.07.16.14.30.12;	author cagney;	state Exp;
branches
	1.11.8.1
	1.11.10.1;
next	1.10;

1.10
date	2002.06.14.22.55.42;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.29.04.42.35;	author cagney;	state Exp;
branches
	1.9.6.1
	1.9.8.1;
next	1.8;

1.8
date	2002.01.20.18.05.52;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.05.04.30.28;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.14.23.23.10;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.06.08.21.26;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.28.01.12.35;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.14.19.12.54;	author jimb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.22.19.17.47;	author jimb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.16;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.16;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.26.14;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.05.14.43.22;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.05.25.18.04.20;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.07.20.12.17;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.08.31.01.06.54;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.12.14.01.05.40;	author jsm;	state Exp;
branches;
next	;

1.9.6.1
date	2002.06.15.16.42.58;	author cagney;	state Exp;
branches;
next	;

1.9.8.1
date	2002.06.20.01.34.14;	author kseitz;	state Exp;
branches;
next	1.9.8.2;

1.9.8.2
date	2002.07.22.21.47.06;	author kseitz;	state Exp;
branches;
next	;

1.11.8.1
date	2002.12.23.19.38.54;	author carlton;	state dead;
branches;
next	;

1.11.10.1
date	2003.12.14.20.27.36;	author drow;	state dead;
branches;
next	;


desc
@@


1.12
log
@2002-12-16  Andrew Cagney  <ac131313@@redhat.com>

	* config/arc/arc.mt, config/arc/tm-arc.h: Delete.
	* config/d30v/d30v.mt, config/d30v/tm-d30v.h: Delete.
	* config/fr30/fr30.mt, config/fr30/tm-fr30.h: Delete.
	* config/i386/i386aix.mh, config/i386/i386aix.mt: Delete.
	* config/i386/i386m3.mh, config/i386/i386m3.mt: Delete.
	* config/i386/i386mach.mh, config/i386/i386os9k.mt: Delete.
	* config/i386/nm-i386aix.h, config/i386/nm-i386mach.h: Delete.
	* config/i386/nm-m3.h, config/i386/tm-i386aix.h: Delete.
	* config/i386/tm-i386m3.h, config/i386/tm-i386mk.h: Delete.
	* config/i386/xm-i386aix.h, config/i386/xm-i386m3.h: Delete.
	* config/i386/xm-i386mach.h, config/i386/xm-i386mk.h: Delete.
	* config/i960/mon960.mt, config/i960/nindy960.mt: Delete.
	* config/i960/tm-i960.h, config/i960/tm-mon960.h: Delete.
	* config/i960/tm-nindy960.h, config/i960/tm-vx960.h: Delete.
	* config/i960/vxworks960.mt, config/m68k/apollo68b.mh: Delete.
	* config/m68k/apollo68b.mt, config/m68k/apollo68v.mh: Delete.
	* config/m68k/hp300bsd.mh, config/m68k/hp300bsd.mt: Delete.
	* config/m68k/hp300hpux.mh, config/m68k/hp300hpux.mt: Delete.
	* config/m88k/delta88.mh, config/m88k/delta88.mt: Delete.
	* config/m88k/delta88v4.mh, config/m88k/delta88v4.mt: Delete.
	* config/m88k/m88k.mh, config/m88k/m88k.mt: Delete.
	* config/m88k/nm-delta88v4.h, config/m88k/nm-m88k.h: Delete.
	* config/m88k/tm-delta88.h, config/m88k/tm-delta88v4.h: Delete.
	* config/m88k/tm-m88k.h, config/m88k/xm-delta88.h: Delete.
	* config/m88k/xm-dgux.h: Delete.
	* fr30-tdep.c, i386aix-nat.c, i386m3-nat.c: Delete.
	* i386mach-nat.c, i960-tdep.c, m88k-nat.c: Delete.
	* os9kread.c, remote-bug.c, remote-nindy.c: Delete.
	* remote-nrom.c, remote-os9k.c, remote-vx960.c: Delete.
	* d30v-tdep.c, arc-tdep.c, cxux-nat.c, dst.h, dstread.c: Delete.
	* ch-exp.c, ch-lang.c, ch-lang.h, ch-typeprint.c: Delete.
	* ch-valprint.c: Delete.
@
text
@// OBSOLETE /* Parameters for execution on a Fujitsu FR30 processor.
// OBSOLETE    Copyright 1999, 2000 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #define FR30_GENREGS		16
// OBSOLETE #define FR30_DEDICATEDREGS	8
// OBSOLETE #define FR30_REGSIZE		4	/* bytes */
// OBSOLETE 
// OBSOLETE #define NUM_REGS (FR30_GENREGS + FR30_DEDICATEDREGS)
// OBSOLETE #define REGISTER_BYTES ((FR30_GENREGS + FR30_DEDICATEDREGS)*FR30_REGSIZE)
// OBSOLETE 
// OBSOLETE /* Index within `registers' of the first byte of the space for
// OBSOLETE    register N.  */
// OBSOLETE #define REGISTER_BYTE(N) ((N) * FR30_REGSIZE)
// OBSOLETE 
// OBSOLETE /* Initializer for an array of names of registers.
// OBSOLETE    There should be NUM_REGS strings in this initializer.  */
// OBSOLETE #define REGISTER_NAMES \
// OBSOLETE { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", \
// OBSOLETE   "r9", "r10", "r11", "r12", "r13", "r14", "r15", \
// OBSOLETE   "pc", "ps", "tbr", "rp", "ssp", "usp", "mdh", "mdl" }
// OBSOLETE 
// OBSOLETE /* Offset from address of function to start of its code.
// OBSOLETE    Zero on most machines.  */
// OBSOLETE #define FUNCTION_START_OFFSET 0
// OBSOLETE 
// OBSOLETE /* Amount PC must be decremented by after a breakpoint.
// OBSOLETE    This is often the number of bytes in BREAKPOINT
// OBSOLETE    but not always.  */
// OBSOLETE 
// OBSOLETE #define DECR_PC_AFTER_BREAK 0
// OBSOLETE 
// OBSOLETE /* Stack grows downward.  */
// OBSOLETE 
// OBSOLETE #define INNER_THAN(lhs,rhs) ((lhs) < (rhs))
// OBSOLETE 
// OBSOLETE #define R0_REGNUM  0
// OBSOLETE #define R1_REGNUM  1
// OBSOLETE #define R2_REGNUM  2
// OBSOLETE #define R3_REGNUM  3
// OBSOLETE #define R4_REGNUM  4
// OBSOLETE #define R5_REGNUM  5
// OBSOLETE #define R6_REGNUM  6
// OBSOLETE #define R7_REGNUM  7
// OBSOLETE #define R8_REGNUM  8
// OBSOLETE #define R9_REGNUM  9
// OBSOLETE #define R10_REGNUM  10
// OBSOLETE #define R11_REGNUM  11
// OBSOLETE #define R12_REGNUM  12
// OBSOLETE #define R13_REGNUM  13
// OBSOLETE #define FP_REGNUM 14		/* Frame pointer */
// OBSOLETE #define SP_REGNUM 15		/* Stack pointer */
// OBSOLETE #define PC_REGNUM 16		/* Program counter */
// OBSOLETE #define RP_REGNUM 19		/* Return pointer */
// OBSOLETE 
// OBSOLETE #define FIRST_ARGREG	R4_REGNUM	/* first arg (or struct ret val addr) */
// OBSOLETE #define LAST_ARGREG	R7_REGNUM	/* fourth (or third arg) */
// OBSOLETE #define RETVAL_REG	R4_REGNUM	/* return vaue */
// OBSOLETE 
// OBSOLETE /* Say how long (ordinary) registers are.  This is a piece of bogosity
// OBSOLETE    used in push_word and a few other places; REGISTER_RAW_SIZE is the
// OBSOLETE    real way to know how big a register is.  */
// OBSOLETE #define REGISTER_SIZE FR30_REGSIZE
// OBSOLETE 
// OBSOLETE /* Number of bytes of storage in the actual machine representation
// OBSOLETE    for register N.  */
// OBSOLETE #define REGISTER_RAW_SIZE(N) FR30_REGSIZE
// OBSOLETE 
// OBSOLETE /* Largest value REGISTER_RAW_SIZE can have.  */
// OBSOLETE #define MAX_REGISTER_RAW_SIZE FR30_REGSIZE
// OBSOLETE 
// OBSOLETE /* Number of bytes of storage in the program's representation
// OBSOLETE    for register N.  */
// OBSOLETE #define REGISTER_VIRTUAL_SIZE(N) REGISTER_RAW_SIZE(N)
// OBSOLETE 
// OBSOLETE /* Largest value REGISTER_VIRTUAL_SIZE can have.  */
// OBSOLETE #define MAX_REGISTER_VIRTUAL_SIZE FR30_REGSIZE
// OBSOLETE 
// OBSOLETE extern void fr30_pop_frame (void);
// OBSOLETE #define POP_FRAME fr30_pop_frame()
// OBSOLETE 
// OBSOLETE #define USE_GENERIC_DUMMY_FRAMES 1
// OBSOLETE #define CALL_DUMMY                   {0}
// OBSOLETE #define CALL_DUMMY_START_OFFSET      (0)
// OBSOLETE #define CALL_DUMMY_BREAKPOINT_OFFSET (0)
// OBSOLETE #define CALL_DUMMY_LOCATION          AT_ENTRY_POINT
// OBSOLETE #define FIX_CALL_DUMMY(DUMMY, START, FUNADDR, NARGS, ARGS, TYPE, GCCP)
// OBSOLETE #define CALL_DUMMY_ADDRESS()         entry_point_address ()
// OBSOLETE #define PUSH_RETURN_ADDRESS(PC, SP)  (write_register(RP_REGNUM, CALL_DUMMY_ADDRESS()), SP)
// OBSOLETE #define PUSH_DUMMY_FRAME	generic_push_dummy_frame ()
// OBSOLETE 
// OBSOLETE /* Number of bytes at start of arglist that are not really args.  */
// OBSOLETE #define FRAME_ARGS_SKIP 0
// OBSOLETE 
// OBSOLETE /* Return the GDB type object for the "standard" data type
// OBSOLETE    of data in register N.  */
// OBSOLETE #define REGISTER_VIRTUAL_TYPE(REG) builtin_type_int
// OBSOLETE 
// OBSOLETE /* Extract from an array REGBUF containing the (raw) register state
// OBSOLETE    a function return value of type TYPE, and copy that, in virtual format,
// OBSOLETE    into VALBUF.  */
// OBSOLETE #define DEPRECATED_EXTRACT_RETURN_VALUE(TYPE,REGBUF,VALBUF) \
// OBSOLETE     memcpy (VALBUF, REGBUF + REGISTER_BYTE(RETVAL_REG) +  \
// OBSOLETE 	(TYPE_LENGTH(TYPE) < 4 ? 4 - TYPE_LENGTH(TYPE) : 0), TYPE_LENGTH (TYPE))
// OBSOLETE 
// OBSOLETE /* Extract from an array REGBUF containing the (raw) register state
// OBSOLETE    the address in which a function should return its structure value,
// OBSOLETE    as a CORE_ADDR (or an expression that can be used as one).  */
// OBSOLETE #define DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS(REGBUF) \
// OBSOLETE   extract_address (REGBUF + REGISTER_BYTE (RETVAL_REG), \
// OBSOLETE 		   REGISTER_RAW_SIZE (RETVAL_REG))
// OBSOLETE 
// OBSOLETE #define STORE_STRUCT_RETURN(ADDR, SP) \
// OBSOLETE   { write_register (RETVAL_REG, (ADDR)); }
// OBSOLETE 
// OBSOLETE #define FRAME_ARGS_ADDRESS(fi) ((fi)->frame)
// OBSOLETE #define FRAME_LOCALS_ADDRESS(fi) ((fi)->frame)
// OBSOLETE 
// OBSOLETE /* Return number of args passed to a frame.
// OBSOLETE    Can return -1, meaning no way to tell.  */
// OBSOLETE #define FRAME_NUM_ARGS(fi) (-1)
// OBSOLETE 
// OBSOLETE /* Forward decls for prototypes */
// OBSOLETE struct frame_info;
// OBSOLETE struct frame_saved_regs;
// OBSOLETE struct type;
// OBSOLETE struct value;
// OBSOLETE 
// OBSOLETE #define EXTRA_FRAME_INFO \
// OBSOLETE   struct frame_saved_regs fsr;  \
// OBSOLETE   int framesize;		\
// OBSOLETE   int frameoffset;		\
// OBSOLETE   int framereg;
// OBSOLETE 
// OBSOLETE extern CORE_ADDR fr30_frame_chain (struct frame_info *fi);
// OBSOLETE #define FRAME_CHAIN(fi) fr30_frame_chain (fi)
// OBSOLETE 
// OBSOLETE extern CORE_ADDR fr30_frame_saved_pc (struct frame_info *);
// OBSOLETE #define FRAME_SAVED_PC(fi) (fr30_frame_saved_pc (fi))
// OBSOLETE 
// OBSOLETE #define SAVED_PC_AFTER_CALL(fi) read_register (RP_REGNUM)
// OBSOLETE 
// OBSOLETE extern CORE_ADDR fr30_skip_prologue (CORE_ADDR pc);
// OBSOLETE #define SKIP_PROLOGUE(pc) (fr30_skip_prologue (pc))
// OBSOLETE 
// OBSOLETE /* Write into appropriate registers a function return value of type
// OBSOLETE    TYPE, given in virtual format.  VALBUF is in the target byte order;
// OBSOLETE    it's typically the VALUE_CONTENTS of some struct value, and those
// OBSOLETE    are in the target's byte order.  */
// OBSOLETE extern void fr30_store_return_value (struct type *type, char *valbuf);
// OBSOLETE 
// OBSOLETE #define STORE_RETURN_VALUE(TYPE,VALBUF) \
// OBSOLETE   (fr30_store_return_value ((TYPE), (VALBUF)))
// OBSOLETE 
// OBSOLETE /* Put here the code to store, into a struct frame_saved_regs,
// OBSOLETE    the addresses of the saved registers of frame described by FRAME_INFO.
// OBSOLETE    This includes special registers such as pc and fp saved in special
// OBSOLETE    ways in the stack frame.  sp is even more special:
// OBSOLETE    the address we return for it IS the sp for the next frame.  */
// OBSOLETE #define FRAME_FIND_SAVED_REGS(fi, regaddr) regaddr = fi->fsr
// OBSOLETE 
// OBSOLETE /* Use INT #BREAKPOINT_INTNUM instruction for breakpoint */
// OBSOLETE #define FR30_BREAKOP	0x1f	/* opcode, type D instruction */
// OBSOLETE #define BREAKPOINT_INTNUM 9	/* one of the reserved traps */
// OBSOLETE #define BREAKPOINT {FR30_BREAKOP, BREAKPOINT_INTNUM}
// OBSOLETE 
// OBSOLETE /* Define this for Wingdb */
// OBSOLETE #define TARGET_FR30
// OBSOLETE 
// OBSOLETE /* Define other aspects of the stack frame.  */
// OBSOLETE 
// OBSOLETE /* An expression that tells us whether the function invocation represented
// OBSOLETE    by FI does not have a frame on the stack associated with it.  */
// OBSOLETE extern int fr30_frameless_function_invocation (struct frame_info *frame);
// OBSOLETE #define FRAMELESS_FUNCTION_INVOCATION(FI) (fr30_frameless_function_invocation (FI));
// OBSOLETE 
// OBSOLETE extern void fr30_init_extra_frame_info (struct frame_info *fi);
// OBSOLETE #define INIT_EXTRA_FRAME_INFO(fromleaf, fi) fr30_init_extra_frame_info (fi)
// OBSOLETE 
// OBSOLETE #define FRAME_CHAIN_VALID(FP, FI)	generic_file_frame_chain_valid (FP, FI)
// OBSOLETE 
// OBSOLETE extern CORE_ADDR
// OBSOLETE fr30_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
// OBSOLETE 		     int struct_return, CORE_ADDR struct_addr);
// OBSOLETE #define PUSH_ARGUMENTS(NARGS, ARGS, SP, STRUCT_RETURN, STRUCT_ADDR) \
// OBSOLETE   (fr30_push_arguments (NARGS, ARGS, SP, STRUCT_RETURN, STRUCT_ADDR))
// OBSOLETE 
// OBSOLETE #define PC_IN_CALL_DUMMY(PC, SP, FP) generic_pc_in_call_dummy (PC, SP, FP)
// OBSOLETE 
// OBSOLETE /* Fujitsu's ABI requires all structs to be passed using a pointer.
// OBSOLETE    That is obviously not very efficient, so I am leaving the definitions
// OBSOLETE    to make gdb work with GCC style struct passing, in case we decide
// OBSOLETE    to go for better performance, rather than for compatibility with
// OBSOLETE    Fujitsu (just change STRUCT_ALWAYS_BY_ADDR to 0) */
// OBSOLETE 
// OBSOLETE #define STRUCT_ALWAYS_BY_ADDR	1
// OBSOLETE 
// OBSOLETE #if(STRUCT_ALWAYS_BY_ADDR)
// OBSOLETE #define REG_STRUCT_HAS_ADDR(gcc_p,type)		1
// OBSOLETE #else
// OBSOLETE /* more standard GCC (optimized) */
// OBSOLETE #define REG_STRUCT_HAS_ADDR(gcc_p,type)		\
// OBSOLETE 		((TYPE_LENGTH(type) > 4) && (TYPE_LENGTH(type) & 0x3))
// OBSOLETE #endif
// OBSOLETE /* alway return struct by value by input pointer */
// OBSOLETE #define USE_STRUCT_CONVENTION(GCC_P, TYPE)	1
// OBSOLETE 
// OBSOLETE /* The stack should always be aligned on a four-word boundary.  */
// OBSOLETE #define STACK_ALIGN(len) (((len) + 3) & ~3)
// OBSOLETE 
// OBSOLETE /* I think the comment about this in value_arg_coerce is wrong; this
// OBSOLETE    should be true on any system where you can rely on the prototyping
// OBSOLETE    information.  When this is true, value_arg_coerce will promote
// OBSOLETE    floats to doubles iff the function is not prototyped.  */
// OBSOLETE #define COERCE_FLOAT_TO_DOUBLE(formal, actual) (1)
@


1.11
log
@Obsolete fr30.
@
text
@@


1.11.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.11.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.10
log
@+	* gdbarch.sh (DEPRECATED_EXTRACT_RETURN_VALUE): Rename
+	EXTRACT_RETURN_VALUE.
+	(DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS): Rename
+	EXTRACT_STRUCT_VALUE_ADDRESS.
+	* gdbarch.h, gdbarch.c: Regenerate.
+
+	* values.c (value_being_returned): Handle
+	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
+	(EXTRACT_RETURN_VALUE): Define as DEPRECATED_EXTRACT_RETURN_VALUE.
+
+	* arm-linux-tdep.c (arm_linux_init_abi): Update.
+	* arm-tdep.c (arm_gdbarch_init): Update.
+	* avr-tdep.c (avr_gdbarch_init): Update.
+	* cris-tdep.c (cris_gdbarch_init): Update.
+	* d10v-tdep.c (d10v_gdbarch_init): Update.
+	* ia64-tdep.c (ia64_gdbarch_init): Update.
+	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
+	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sh-tdep.c (sh_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sparc-tdep.c (sparc_gdbarch_init): Update.
+	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
+	* v850-tdep.c (v850_gdbarch_init): Update.
+	* vax-tdep.c (vax_gdbarch_init): Update.
+	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
+	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
+
+	* config/arc/tm-arc.h: Update.
+	* config/d30v/tm-d30v.h: Update.
+	* config/fr30/tm-fr30.h: Update.
+	* config/h8300/tm-h8300.h: Update.
* config/h8500/tm-h8500.h: Update.
* config/i386/tm-i386.h: Update.
* config/i386/tm-ptx.h: Update.
* config/i386/tm-symmetry.h: Update.
* config/i960/tm-i960.h: Update.
* config/m32r/tm-m32r.h: Update.
* config/m68k/tm-delta68.h: Update.
* config/m68k/tm-linux.h: Update.
* config/m68k/tm-m68k.h: Update.
* config/m88k/tm-m88k.h: Update.
* config/mcore/tm-mcore.h: Update.
* config/mips/tm-mips.h: Update.
* config/mn10200/tm-mn10200.h: Update.
* config/pa/tm-hppa.h: Update.
* config/pa/tm-hppa64.h: Update.
* config/sparc/tm-sp64.h: Update.
* config/sparc/tm-sparc.h: Update.
* config/sparc/tm-sparclet.h: Update.
* config/z8k/tm-z8k.h: Update.
@
text
@d1 233
a233 233
/* Parameters for execution on a Fujitsu FR30 processor.
   Copyright 1999, 2000 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "regcache.h"

#define FR30_GENREGS		16
#define FR30_DEDICATEDREGS	8
#define FR30_REGSIZE		4	/* bytes */

#define NUM_REGS (FR30_GENREGS + FR30_DEDICATEDREGS)
#define REGISTER_BYTES ((FR30_GENREGS + FR30_DEDICATEDREGS)*FR30_REGSIZE)

/* Index within `registers' of the first byte of the space for
   register N.  */
#define REGISTER_BYTE(N) ((N) * FR30_REGSIZE)

/* Initializer for an array of names of registers.
   There should be NUM_REGS strings in this initializer.  */
#define REGISTER_NAMES \
{ "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", \
  "r9", "r10", "r11", "r12", "r13", "r14", "r15", \
  "pc", "ps", "tbr", "rp", "ssp", "usp", "mdh", "mdl" }

/* Offset from address of function to start of its code.
   Zero on most machines.  */
#define FUNCTION_START_OFFSET 0

/* Amount PC must be decremented by after a breakpoint.
   This is often the number of bytes in BREAKPOINT
   but not always.  */

#define DECR_PC_AFTER_BREAK 0

/* Stack grows downward.  */

#define INNER_THAN(lhs,rhs) ((lhs) < (rhs))

#define R0_REGNUM  0
#define R1_REGNUM  1
#define R2_REGNUM  2
#define R3_REGNUM  3
#define R4_REGNUM  4
#define R5_REGNUM  5
#define R6_REGNUM  6
#define R7_REGNUM  7
#define R8_REGNUM  8
#define R9_REGNUM  9
#define R10_REGNUM  10
#define R11_REGNUM  11
#define R12_REGNUM  12
#define R13_REGNUM  13
#define FP_REGNUM 14		/* Frame pointer */
#define SP_REGNUM 15		/* Stack pointer */
#define PC_REGNUM 16		/* Program counter */
#define RP_REGNUM 19		/* Return pointer */

#define FIRST_ARGREG	R4_REGNUM	/* first arg (or struct ret val addr) */
#define LAST_ARGREG	R7_REGNUM	/* fourth (or third arg) */
#define RETVAL_REG	R4_REGNUM	/* return vaue */

/* Say how long (ordinary) registers are.  This is a piece of bogosity
   used in push_word and a few other places; REGISTER_RAW_SIZE is the
   real way to know how big a register is.  */
#define REGISTER_SIZE FR30_REGSIZE

/* Number of bytes of storage in the actual machine representation
   for register N.  */
#define REGISTER_RAW_SIZE(N) FR30_REGSIZE

/* Largest value REGISTER_RAW_SIZE can have.  */
#define MAX_REGISTER_RAW_SIZE FR30_REGSIZE

/* Number of bytes of storage in the program's representation
   for register N.  */
#define REGISTER_VIRTUAL_SIZE(N) REGISTER_RAW_SIZE(N)

/* Largest value REGISTER_VIRTUAL_SIZE can have.  */
#define MAX_REGISTER_VIRTUAL_SIZE FR30_REGSIZE

extern void fr30_pop_frame (void);
#define POP_FRAME fr30_pop_frame()

#define USE_GENERIC_DUMMY_FRAMES 1
#define CALL_DUMMY                   {0}
#define CALL_DUMMY_START_OFFSET      (0)
#define CALL_DUMMY_BREAKPOINT_OFFSET (0)
#define CALL_DUMMY_LOCATION          AT_ENTRY_POINT
#define FIX_CALL_DUMMY(DUMMY, START, FUNADDR, NARGS, ARGS, TYPE, GCCP)
#define CALL_DUMMY_ADDRESS()         entry_point_address ()
#define PUSH_RETURN_ADDRESS(PC, SP)  (write_register(RP_REGNUM, CALL_DUMMY_ADDRESS()), SP)
#define PUSH_DUMMY_FRAME	generic_push_dummy_frame ()

/* Number of bytes at start of arglist that are not really args.  */
#define FRAME_ARGS_SKIP 0

/* Return the GDB type object for the "standard" data type
   of data in register N.  */
#define REGISTER_VIRTUAL_TYPE(REG) builtin_type_int

/* Extract from an array REGBUF containing the (raw) register state
   a function return value of type TYPE, and copy that, in virtual format,
   into VALBUF.  */
#define DEPRECATED_EXTRACT_RETURN_VALUE(TYPE,REGBUF,VALBUF) \
    memcpy (VALBUF, REGBUF + REGISTER_BYTE(RETVAL_REG) +  \
	(TYPE_LENGTH(TYPE) < 4 ? 4 - TYPE_LENGTH(TYPE) : 0), TYPE_LENGTH (TYPE))

/* Extract from an array REGBUF containing the (raw) register state
   the address in which a function should return its structure value,
   as a CORE_ADDR (or an expression that can be used as one).  */
#define DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS(REGBUF) \
  extract_address (REGBUF + REGISTER_BYTE (RETVAL_REG), \
		   REGISTER_RAW_SIZE (RETVAL_REG))

#define STORE_STRUCT_RETURN(ADDR, SP) \
  { write_register (RETVAL_REG, (ADDR)); }

#define FRAME_ARGS_ADDRESS(fi) ((fi)->frame)
#define FRAME_LOCALS_ADDRESS(fi) ((fi)->frame)

/* Return number of args passed to a frame.
   Can return -1, meaning no way to tell.  */
#define FRAME_NUM_ARGS(fi) (-1)

/* Forward decls for prototypes */
struct frame_info;
struct frame_saved_regs;
struct type;
struct value;

#define EXTRA_FRAME_INFO \
  struct frame_saved_regs fsr;  \
  int framesize;		\
  int frameoffset;		\
  int framereg;

extern CORE_ADDR fr30_frame_chain (struct frame_info *fi);
#define FRAME_CHAIN(fi) fr30_frame_chain (fi)

extern CORE_ADDR fr30_frame_saved_pc (struct frame_info *);
#define FRAME_SAVED_PC(fi) (fr30_frame_saved_pc (fi))

#define SAVED_PC_AFTER_CALL(fi) read_register (RP_REGNUM)

extern CORE_ADDR fr30_skip_prologue (CORE_ADDR pc);
#define SKIP_PROLOGUE(pc) (fr30_skip_prologue (pc))

/* Write into appropriate registers a function return value of type
   TYPE, given in virtual format.  VALBUF is in the target byte order;
   it's typically the VALUE_CONTENTS of some struct value, and those
   are in the target's byte order.  */
extern void fr30_store_return_value (struct type *type, char *valbuf);

#define STORE_RETURN_VALUE(TYPE,VALBUF) \
  (fr30_store_return_value ((TYPE), (VALBUF)))

/* Put here the code to store, into a struct frame_saved_regs,
   the addresses of the saved registers of frame described by FRAME_INFO.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special:
   the address we return for it IS the sp for the next frame.  */
#define FRAME_FIND_SAVED_REGS(fi, regaddr) regaddr = fi->fsr

/* Use INT #BREAKPOINT_INTNUM instruction for breakpoint */
#define FR30_BREAKOP	0x1f	/* opcode, type D instruction */
#define BREAKPOINT_INTNUM 9	/* one of the reserved traps */
#define BREAKPOINT {FR30_BREAKOP, BREAKPOINT_INTNUM}

/* Define this for Wingdb */
#define TARGET_FR30

/* Define other aspects of the stack frame.  */

/* An expression that tells us whether the function invocation represented
   by FI does not have a frame on the stack associated with it.  */
extern int fr30_frameless_function_invocation (struct frame_info *frame);
#define FRAMELESS_FUNCTION_INVOCATION(FI) (fr30_frameless_function_invocation (FI));

extern void fr30_init_extra_frame_info (struct frame_info *fi);
#define INIT_EXTRA_FRAME_INFO(fromleaf, fi) fr30_init_extra_frame_info (fi)

#define FRAME_CHAIN_VALID(FP, FI)	generic_file_frame_chain_valid (FP, FI)

extern CORE_ADDR
fr30_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		     int struct_return, CORE_ADDR struct_addr);
#define PUSH_ARGUMENTS(NARGS, ARGS, SP, STRUCT_RETURN, STRUCT_ADDR) \
  (fr30_push_arguments (NARGS, ARGS, SP, STRUCT_RETURN, STRUCT_ADDR))

#define PC_IN_CALL_DUMMY(PC, SP, FP) generic_pc_in_call_dummy (PC, SP, FP)

/* Fujitsu's ABI requires all structs to be passed using a pointer.
   That is obviously not very efficient, so I am leaving the definitions
   to make gdb work with GCC style struct passing, in case we decide
   to go for better performance, rather than for compatibility with
   Fujitsu (just change STRUCT_ALWAYS_BY_ADDR to 0) */

#define STRUCT_ALWAYS_BY_ADDR	1

#if(STRUCT_ALWAYS_BY_ADDR)
#define REG_STRUCT_HAS_ADDR(gcc_p,type)		1
#else
/* more standard GCC (optimized) */
#define REG_STRUCT_HAS_ADDR(gcc_p,type)		\
		((TYPE_LENGTH(type) > 4) && (TYPE_LENGTH(type) & 0x3))
#endif
/* alway return struct by value by input pointer */
#define USE_STRUCT_CONVENTION(GCC_P, TYPE)	1

/* The stack should always be aligned on a four-word boundary.  */
#define STACK_ALIGN(len) (((len) + 3) & ~3)

/* I think the comment about this in value_arg_coerce is wrong; this
   should be true on any system where you can rely on the prototyping
   information.  When this is true, value_arg_coerce will promote
   floats to doubles iff the function is not prototyped.  */
#define COERCE_FLOAT_TO_DOUBLE(formal, actual) (1)
@


1.9
log
@Eliminate TARGET_BYTE_ORDER.
@
text
@d120 1
a120 1
#define EXTRACT_RETURN_VALUE(TYPE,REGBUF,VALBUF) \
d127 1
a127 1
#define EXTRACT_STRUCT_VALUE_ADDRESS(REGBUF) \
@


1.9.8.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d120 1
a120 1
#define DEPRECATED_EXTRACT_RETURN_VALUE(TYPE,REGBUF,VALBUF) \
d127 1
a127 1
#define DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS(REGBUF) \
@


1.9.8.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1 233
a233 233
// OBSOLETE /* Parameters for execution on a Fujitsu FR30 processor.
// OBSOLETE    Copyright 1999, 2000 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE #define FR30_GENREGS		16
// OBSOLETE #define FR30_DEDICATEDREGS	8
// OBSOLETE #define FR30_REGSIZE		4	/* bytes */
// OBSOLETE 
// OBSOLETE #define NUM_REGS (FR30_GENREGS + FR30_DEDICATEDREGS)
// OBSOLETE #define REGISTER_BYTES ((FR30_GENREGS + FR30_DEDICATEDREGS)*FR30_REGSIZE)
// OBSOLETE 
// OBSOLETE /* Index within `registers' of the first byte of the space for
// OBSOLETE    register N.  */
// OBSOLETE #define REGISTER_BYTE(N) ((N) * FR30_REGSIZE)
// OBSOLETE 
// OBSOLETE /* Initializer for an array of names of registers.
// OBSOLETE    There should be NUM_REGS strings in this initializer.  */
// OBSOLETE #define REGISTER_NAMES \
// OBSOLETE { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", \
// OBSOLETE   "r9", "r10", "r11", "r12", "r13", "r14", "r15", \
// OBSOLETE   "pc", "ps", "tbr", "rp", "ssp", "usp", "mdh", "mdl" }
// OBSOLETE 
// OBSOLETE /* Offset from address of function to start of its code.
// OBSOLETE    Zero on most machines.  */
// OBSOLETE #define FUNCTION_START_OFFSET 0
// OBSOLETE 
// OBSOLETE /* Amount PC must be decremented by after a breakpoint.
// OBSOLETE    This is often the number of bytes in BREAKPOINT
// OBSOLETE    but not always.  */
// OBSOLETE 
// OBSOLETE #define DECR_PC_AFTER_BREAK 0
// OBSOLETE 
// OBSOLETE /* Stack grows downward.  */
// OBSOLETE 
// OBSOLETE #define INNER_THAN(lhs,rhs) ((lhs) < (rhs))
// OBSOLETE 
// OBSOLETE #define R0_REGNUM  0
// OBSOLETE #define R1_REGNUM  1
// OBSOLETE #define R2_REGNUM  2
// OBSOLETE #define R3_REGNUM  3
// OBSOLETE #define R4_REGNUM  4
// OBSOLETE #define R5_REGNUM  5
// OBSOLETE #define R6_REGNUM  6
// OBSOLETE #define R7_REGNUM  7
// OBSOLETE #define R8_REGNUM  8
// OBSOLETE #define R9_REGNUM  9
// OBSOLETE #define R10_REGNUM  10
// OBSOLETE #define R11_REGNUM  11
// OBSOLETE #define R12_REGNUM  12
// OBSOLETE #define R13_REGNUM  13
// OBSOLETE #define FP_REGNUM 14		/* Frame pointer */
// OBSOLETE #define SP_REGNUM 15		/* Stack pointer */
// OBSOLETE #define PC_REGNUM 16		/* Program counter */
// OBSOLETE #define RP_REGNUM 19		/* Return pointer */
// OBSOLETE 
// OBSOLETE #define FIRST_ARGREG	R4_REGNUM	/* first arg (or struct ret val addr) */
// OBSOLETE #define LAST_ARGREG	R7_REGNUM	/* fourth (or third arg) */
// OBSOLETE #define RETVAL_REG	R4_REGNUM	/* return vaue */
// OBSOLETE 
// OBSOLETE /* Say how long (ordinary) registers are.  This is a piece of bogosity
// OBSOLETE    used in push_word and a few other places; REGISTER_RAW_SIZE is the
// OBSOLETE    real way to know how big a register is.  */
// OBSOLETE #define REGISTER_SIZE FR30_REGSIZE
// OBSOLETE 
// OBSOLETE /* Number of bytes of storage in the actual machine representation
// OBSOLETE    for register N.  */
// OBSOLETE #define REGISTER_RAW_SIZE(N) FR30_REGSIZE
// OBSOLETE 
// OBSOLETE /* Largest value REGISTER_RAW_SIZE can have.  */
// OBSOLETE #define MAX_REGISTER_RAW_SIZE FR30_REGSIZE
// OBSOLETE 
// OBSOLETE /* Number of bytes of storage in the program's representation
// OBSOLETE    for register N.  */
// OBSOLETE #define REGISTER_VIRTUAL_SIZE(N) REGISTER_RAW_SIZE(N)
// OBSOLETE 
// OBSOLETE /* Largest value REGISTER_VIRTUAL_SIZE can have.  */
// OBSOLETE #define MAX_REGISTER_VIRTUAL_SIZE FR30_REGSIZE
// OBSOLETE 
// OBSOLETE extern void fr30_pop_frame (void);
// OBSOLETE #define POP_FRAME fr30_pop_frame()
// OBSOLETE 
// OBSOLETE #define USE_GENERIC_DUMMY_FRAMES 1
// OBSOLETE #define CALL_DUMMY                   {0}
// OBSOLETE #define CALL_DUMMY_START_OFFSET      (0)
// OBSOLETE #define CALL_DUMMY_BREAKPOINT_OFFSET (0)
// OBSOLETE #define CALL_DUMMY_LOCATION          AT_ENTRY_POINT
// OBSOLETE #define FIX_CALL_DUMMY(DUMMY, START, FUNADDR, NARGS, ARGS, TYPE, GCCP)
// OBSOLETE #define CALL_DUMMY_ADDRESS()         entry_point_address ()
// OBSOLETE #define PUSH_RETURN_ADDRESS(PC, SP)  (write_register(RP_REGNUM, CALL_DUMMY_ADDRESS()), SP)
// OBSOLETE #define PUSH_DUMMY_FRAME	generic_push_dummy_frame ()
// OBSOLETE 
// OBSOLETE /* Number of bytes at start of arglist that are not really args.  */
// OBSOLETE #define FRAME_ARGS_SKIP 0
// OBSOLETE 
// OBSOLETE /* Return the GDB type object for the "standard" data type
// OBSOLETE    of data in register N.  */
// OBSOLETE #define REGISTER_VIRTUAL_TYPE(REG) builtin_type_int
// OBSOLETE 
// OBSOLETE /* Extract from an array REGBUF containing the (raw) register state
// OBSOLETE    a function return value of type TYPE, and copy that, in virtual format,
// OBSOLETE    into VALBUF.  */
// OBSOLETE #define DEPRECATED_EXTRACT_RETURN_VALUE(TYPE,REGBUF,VALBUF) \
// OBSOLETE     memcpy (VALBUF, REGBUF + REGISTER_BYTE(RETVAL_REG) +  \
// OBSOLETE 	(TYPE_LENGTH(TYPE) < 4 ? 4 - TYPE_LENGTH(TYPE) : 0), TYPE_LENGTH (TYPE))
// OBSOLETE 
// OBSOLETE /* Extract from an array REGBUF containing the (raw) register state
// OBSOLETE    the address in which a function should return its structure value,
// OBSOLETE    as a CORE_ADDR (or an expression that can be used as one).  */
// OBSOLETE #define DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS(REGBUF) \
// OBSOLETE   extract_address (REGBUF + REGISTER_BYTE (RETVAL_REG), \
// OBSOLETE 		   REGISTER_RAW_SIZE (RETVAL_REG))
// OBSOLETE 
// OBSOLETE #define STORE_STRUCT_RETURN(ADDR, SP) \
// OBSOLETE   { write_register (RETVAL_REG, (ADDR)); }
// OBSOLETE 
// OBSOLETE #define FRAME_ARGS_ADDRESS(fi) ((fi)->frame)
// OBSOLETE #define FRAME_LOCALS_ADDRESS(fi) ((fi)->frame)
// OBSOLETE 
// OBSOLETE /* Return number of args passed to a frame.
// OBSOLETE    Can return -1, meaning no way to tell.  */
// OBSOLETE #define FRAME_NUM_ARGS(fi) (-1)
// OBSOLETE 
// OBSOLETE /* Forward decls for prototypes */
// OBSOLETE struct frame_info;
// OBSOLETE struct frame_saved_regs;
// OBSOLETE struct type;
// OBSOLETE struct value;
// OBSOLETE 
// OBSOLETE #define EXTRA_FRAME_INFO \
// OBSOLETE   struct frame_saved_regs fsr;  \
// OBSOLETE   int framesize;		\
// OBSOLETE   int frameoffset;		\
// OBSOLETE   int framereg;
// OBSOLETE 
// OBSOLETE extern CORE_ADDR fr30_frame_chain (struct frame_info *fi);
// OBSOLETE #define FRAME_CHAIN(fi) fr30_frame_chain (fi)
// OBSOLETE 
// OBSOLETE extern CORE_ADDR fr30_frame_saved_pc (struct frame_info *);
// OBSOLETE #define FRAME_SAVED_PC(fi) (fr30_frame_saved_pc (fi))
// OBSOLETE 
// OBSOLETE #define SAVED_PC_AFTER_CALL(fi) read_register (RP_REGNUM)
// OBSOLETE 
// OBSOLETE extern CORE_ADDR fr30_skip_prologue (CORE_ADDR pc);
// OBSOLETE #define SKIP_PROLOGUE(pc) (fr30_skip_prologue (pc))
// OBSOLETE 
// OBSOLETE /* Write into appropriate registers a function return value of type
// OBSOLETE    TYPE, given in virtual format.  VALBUF is in the target byte order;
// OBSOLETE    it's typically the VALUE_CONTENTS of some struct value, and those
// OBSOLETE    are in the target's byte order.  */
// OBSOLETE extern void fr30_store_return_value (struct type *type, char *valbuf);
// OBSOLETE 
// OBSOLETE #define STORE_RETURN_VALUE(TYPE,VALBUF) \
// OBSOLETE   (fr30_store_return_value ((TYPE), (VALBUF)))
// OBSOLETE 
// OBSOLETE /* Put here the code to store, into a struct frame_saved_regs,
// OBSOLETE    the addresses of the saved registers of frame described by FRAME_INFO.
// OBSOLETE    This includes special registers such as pc and fp saved in special
// OBSOLETE    ways in the stack frame.  sp is even more special:
// OBSOLETE    the address we return for it IS the sp for the next frame.  */
// OBSOLETE #define FRAME_FIND_SAVED_REGS(fi, regaddr) regaddr = fi->fsr
// OBSOLETE 
// OBSOLETE /* Use INT #BREAKPOINT_INTNUM instruction for breakpoint */
// OBSOLETE #define FR30_BREAKOP	0x1f	/* opcode, type D instruction */
// OBSOLETE #define BREAKPOINT_INTNUM 9	/* one of the reserved traps */
// OBSOLETE #define BREAKPOINT {FR30_BREAKOP, BREAKPOINT_INTNUM}
// OBSOLETE 
// OBSOLETE /* Define this for Wingdb */
// OBSOLETE #define TARGET_FR30
// OBSOLETE 
// OBSOLETE /* Define other aspects of the stack frame.  */
// OBSOLETE 
// OBSOLETE /* An expression that tells us whether the function invocation represented
// OBSOLETE    by FI does not have a frame on the stack associated with it.  */
// OBSOLETE extern int fr30_frameless_function_invocation (struct frame_info *frame);
// OBSOLETE #define FRAMELESS_FUNCTION_INVOCATION(FI) (fr30_frameless_function_invocation (FI));
// OBSOLETE 
// OBSOLETE extern void fr30_init_extra_frame_info (struct frame_info *fi);
// OBSOLETE #define INIT_EXTRA_FRAME_INFO(fromleaf, fi) fr30_init_extra_frame_info (fi)
// OBSOLETE 
// OBSOLETE #define FRAME_CHAIN_VALID(FP, FI)	generic_file_frame_chain_valid (FP, FI)
// OBSOLETE 
// OBSOLETE extern CORE_ADDR
// OBSOLETE fr30_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
// OBSOLETE 		     int struct_return, CORE_ADDR struct_addr);
// OBSOLETE #define PUSH_ARGUMENTS(NARGS, ARGS, SP, STRUCT_RETURN, STRUCT_ADDR) \
// OBSOLETE   (fr30_push_arguments (NARGS, ARGS, SP, STRUCT_RETURN, STRUCT_ADDR))
// OBSOLETE 
// OBSOLETE #define PC_IN_CALL_DUMMY(PC, SP, FP) generic_pc_in_call_dummy (PC, SP, FP)
// OBSOLETE 
// OBSOLETE /* Fujitsu's ABI requires all structs to be passed using a pointer.
// OBSOLETE    That is obviously not very efficient, so I am leaving the definitions
// OBSOLETE    to make gdb work with GCC style struct passing, in case we decide
// OBSOLETE    to go for better performance, rather than for compatibility with
// OBSOLETE    Fujitsu (just change STRUCT_ALWAYS_BY_ADDR to 0) */
// OBSOLETE 
// OBSOLETE #define STRUCT_ALWAYS_BY_ADDR	1
// OBSOLETE 
// OBSOLETE #if(STRUCT_ALWAYS_BY_ADDR)
// OBSOLETE #define REG_STRUCT_HAS_ADDR(gcc_p,type)		1
// OBSOLETE #else
// OBSOLETE /* more standard GCC (optimized) */
// OBSOLETE #define REG_STRUCT_HAS_ADDR(gcc_p,type)		\
// OBSOLETE 		((TYPE_LENGTH(type) > 4) && (TYPE_LENGTH(type) & 0x3))
// OBSOLETE #endif
// OBSOLETE /* alway return struct by value by input pointer */
// OBSOLETE #define USE_STRUCT_CONVENTION(GCC_P, TYPE)	1
// OBSOLETE 
// OBSOLETE /* The stack should always be aligned on a four-word boundary.  */
// OBSOLETE #define STACK_ALIGN(len) (((len) + 3) & ~3)
// OBSOLETE 
// OBSOLETE /* I think the comment about this in value_arg_coerce is wrong; this
// OBSOLETE    should be true on any system where you can rely on the prototyping
// OBSOLETE    information.  When this is true, value_arg_coerce will promote
// OBSOLETE    floats to doubles iff the function is not prototyped.  */
// OBSOLETE #define COERCE_FLOAT_TO_DOUBLE(formal, actual) (1)
@


1.9.6.1
log
@merge from trunk
@
text
@d120 1
a120 1
#define DEPRECATED_EXTRACT_RETURN_VALUE(TYPE,REGBUF,VALBUF) \
d127 1
a127 1
#define DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS(REGBUF) \
@


1.8
log
@Eliminate IEEE_FLOAT.
@
text
@a54 2
#define TARGET_BYTE_ORDER BFD_ENDIAN_BIG

@


1.7
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@a189 3
/* IEEE format floating point */
#define IEEE_FLOAT (1)

@


1.6
log
@Include regcache.h
@
text
@d55 1
a55 1
#define TARGET_BYTE_ORDER BIG_ENDIAN
@


1.5
log
@Update/correct copyright notices.
@
text
@d21 2
@


1.4
log
@PARAMS removal.
@
text
@d2 1
a2 1
   Copyright 1999, Free Software Foundation, Inc.
@


1.3
log
@Bring IEEE_FLOAT under gdbarch's control.
* gdbarch.sh (IEEE_FLOAT): New entry.
* gdbarch.c, gdbarch.h: Regenerated.
* valprint.c (IEEE_FLOAT): Provide a default #definition for this.
(print_floating): Use IEEE_FLOAT as if it were an expression; use
the code specific to IEEE-format numbers whenever the value of
IEEE_FLOAT is non-zero.
* config/a29k/tm-a29k.h, config/alpha/tm-alpha.h,
config/arc/tm-arc.h, config/arm/tm-arm.h, config/fr30/tm-fr30.h,
config/h8300/tm-h8300.h, config/i386/tm-i386.h,
config/i960/tm-i960.h, config/m88k/tm-m88k.h,
config/mips/tm-mips.h, config/pa/tm-hppa.h,
config/sparc/tm-sparc.h, config/delta/tm-delta.h,
config/frv/tm-frv.h (IEEE_FLOAT): For all ports that #define
IEEE_FLOAT, make sure they give it the value (1).
@
text
@d97 1
a97 1
extern void fr30_pop_frame PARAMS ((void));
d153 1
a153 1
extern CORE_ADDR fr30_frame_chain PARAMS ((struct frame_info * fi));
d156 1
a156 1
extern CORE_ADDR fr30_frame_saved_pc PARAMS ((struct frame_info *));
d161 1
a161 1
extern CORE_ADDR fr30_skip_prologue PARAMS ((CORE_ADDR pc));
d168 1
a168 1
extern void fr30_store_return_value PARAMS ((struct type * type, char *valbuf));
d195 1
a195 1
extern int fr30_frameless_function_invocation PARAMS ((struct frame_info * frame));
d198 1
a198 1
extern void fr30_init_extra_frame_info PARAMS ((struct frame_info * fi));
d204 2
a205 3
  fr30_push_arguments PARAMS ((int nargs, struct value ** args, CORE_ADDR sp,
			       int struct_return,
			       CORE_ADDR struct_addr));
@


1.2
log
@Bring COERCE_FLOAT_TO_DOUBLE under gdbarch's control.
* valops.c (COERCE_FLOAT_TO_DOUBLE): Rework definition to be
more function-like.
(default_coerce_float_to_double, standard_coerce_float_to_double):
New functions.
(value_arg_coerce): Adjust for new definition.
* value.h (default_coerce_float_to_double,
standard_coerce_float_to_double): New declarations for the above.
* gdbarch.sh (coerce_float_to_double): New entry, replacing macro.
* gdbarch.c, gdbarch.h: Regenerated.
* tm-alpha.h, tm-fr30.h, tm-m32r.h, tm-mips.h, tm-hppa.h,
tm-rs6000.h, tm-sh.h, tm-sparc.h (COERCE_FLOAT_TO_DOUBLE): Change
definitions.
* mips-tdep.c (mips_coerce_float_to_double): Supply our own custom
function here.
(mips_gdbarch_init): Install that as our coerce_float_to_double
function.
@
text
@d189 1
a189 1
#define IEEE_FLOAT
@


1.1
log
@Initial revision
@
text
@d2 1
d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d88 1
a88 1
#define MAX_REGISTER_RAW_SIZE FR30_REGSIZE 
d100 1
a100 1
#define USE_GENERIC_DUMMY_FRAMES
d134 1
a134 1
#define FRAME_ARGS_ADDRESS(fi) (fi->frame)
d139 1
a139 1
#define FRAME_NUM_ARGS(numargs, fi) (numargs = -1)
d141 1
a141 1
#ifdef __STDC__		/* Forward decls for prototypes */
a145 1
#endif
d153 1
a153 1
extern CORE_ADDR fr30_frame_chain PARAMS ((struct frame_info *fi));
d156 1
a156 1
extern CORE_ADDR fr30_frame_saved_pc   PARAMS ((struct frame_info *));
d162 1
a162 1
#define SKIP_PROLOGUE(pc) pc = fr30_skip_prologue (pc)
d164 5
a168 2
/* Write into appropriate registers a function return value
   of type TYPE, given in virtual format.  */
d171 1
a171 1
    write_register_bytes (0, VALBUF, TYPE_LENGTH (TYPE))
d193 4
a196 12
/* A macro that tells us whether the function invocation represented
   by FI does not have a frame on the stack associated with it.  If it
   does not, FRAMELESS is set to 1, else 0.  */
#define FRAMELESS_FUNCTION_INVOCATION(FI, FRAMELESS) \
{							\
  CORE_ADDR func_start, after_prologue;			\
  func_start = (get_pc_function_start ((FI)->pc) +	\
		FUNCTION_START_OFFSET);			\
  after_prologue = func_start;				\
  SKIP_PROLOGUE (after_prologue);			\
  (FRAMELESS) = (after_prologue == func_start);		\
}
d198 1
a198 1
extern void fr30_init_extra_frame_info PARAMS ((struct frame_info *fi));
d201 1
a201 1
#define FRAME_CHAIN_VALID(FP, FI)	generic_frame_chain_valid (FP, FI)
d204 3
a206 3
fr30_push_arguments PARAMS ((int nargs, struct value **args, CORE_ADDR sp,
			     int struct_return,
			     CORE_ADDR struct_addr));
d208 1
a208 1
  (SP) = fr30_push_arguments (NARGS, ARGS, SP, STRUCT_RETURN, STRUCT_ADDR)
d210 1
a210 1
#define PC_IN_CALL_DUMMY(PC, SP, FP) generic_pc_in_call_dummy (PC, SP)
d229 9
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a1 1
   Copyright 1999, Free Software Foundation, Inc.
d98 1
a98 1
#define USE_GENERIC_DUMMY_FRAMES 1
d132 1
a132 1
#define FRAME_ARGS_ADDRESS(fi) ((fi)->frame)
d163 2
a164 5
/* Write into appropriate registers a function return value of type
   TYPE, given in virtual format.  VALBUF is in the target byte order;
   it's typically the VALUE_CONTENTS of some struct value, and those
   are in the target's byte order.  */
extern void fr30_store_return_value PARAMS ((struct type *type, char *valbuf));
d167 1
a167 1
  (fr30_store_return_value ((TYPE), (VALBUF)))
d214 1
a214 1
#define PC_IN_CALL_DUMMY(PC, SP, FP) generic_pc_in_call_dummy (PC, SP, FP)
a232 9

/* The stack should always be aligned on a four-word boundary.  */
#define STACK_ALIGN(len) (((len) + 3) & ~3)

/* I think the comment about this in value_arg_coerce is wrong; this
   should be true on any system where you can rely on the prototyping
   information.  When this is true, value_arg_coerce will promote
   floats to doubles iff the function is not prototyped.  */
#define COERCE_FLOAT_TO_DOUBLE 1
@


1.1.1.3
log
@import gdb-19990504 snapshot
@
text
@d162 1
a162 1
#define SKIP_PROLOGUE(pc) (fr30_skip_prologue (pc))
d202 1
a202 1
  after_prologue = SKIP_PROLOGUE (after_prologue);	\
@


1.1.1.4
log
@import gdb-1999-05-25 snapshot
@
text
@d138 1
a138 1
#define FRAME_NUM_ARGS(fi) (-1)
d193 12
a204 4
/* An expression that tells us whether the function invocation represented
   by FI does not have a frame on the stack associated with it.  */
extern int fr30_frameless_function_invocation PARAMS ((struct frame_info *frame));
#define FRAMELESS_FUNCTION_INVOCATION(FI) (fr30_frameless_function_invocation (FI));
d216 1
a216 1
  (fr30_push_arguments (NARGS, ARGS, SP, STRUCT_RETURN, STRUCT_ADDR))
@


1.1.1.5
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d87 1
a87 1
#define MAX_REGISTER_RAW_SIZE FR30_REGSIZE
d140 1
a140 1
#ifdef __STDC__			/* Forward decls for prototypes */
d153 1
a153 1
extern CORE_ADDR fr30_frame_chain PARAMS ((struct frame_info * fi));
d156 1
a156 1
extern CORE_ADDR fr30_frame_saved_pc PARAMS ((struct frame_info *));
d168 1
a168 1
extern void fr30_store_return_value PARAMS ((struct type * type, char *valbuf));
d195 1
a195 1
extern int fr30_frameless_function_invocation PARAMS ((struct frame_info * frame));
d198 1
a198 1
extern void fr30_init_extra_frame_info PARAMS ((struct frame_info * fi));
d204 3
a206 3
  fr30_push_arguments PARAMS ((int nargs, struct value ** args, CORE_ADDR sp,
			       int struct_return,
			       CORE_ADDR struct_addr));
@


1.1.1.6
log
@import gdb-1999-08-30 snapshot
@
text
@d141 1
a141 1
/* Forward decls for prototypes */
d146 1
@


1.1.1.7
log
@import gdb-1999-12-13 snapshot
@
text
@d201 1
a201 1
#define FRAME_CHAIN_VALID(FP, FI)	generic_file_frame_chain_valid (FP, FI)
@


