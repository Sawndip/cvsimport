head	1.216;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.210
	gdb_7_6-2013-04-26-release:1.210
	gdb_7_6-branch:1.210.0.2
	gdb_7_6-2013-03-12-branchpoint:1.210
	gdb_7_5_1-2012-11-29-release:1.206
	gdb_7_5-2012-08-17-release:1.206
	gdb_7_5-branch:1.206.0.2
	gdb_7_5-2012-07-18-branchpoint:1.206
	gdb_7_4_1-2012-04-26-release:1.201.2.2
	gdb_7_4-2012-01-24-release:1.201.2.2
	gdb_7_4-branch:1.201.0.2
	gdb_7_4-2011-12-13-branchpoint:1.201
	gdb_7_3_1-2011-09-04-release:1.194
	gdb_7_3-2011-07-26-release:1.194
	gdb_7_3-branch:1.194.0.2
	gdb_7_3-2011-04-01-branchpoint:1.194
	gdb_7_2-2010-09-02-release:1.189
	gdb_7_2-branch:1.189.0.2
	gdb_7_2-2010-07-07-branchpoint:1.189
	gdb_7_1-2010-03-18-release:1.188
	gdb_7_1-branch:1.188.0.2
	gdb_7_1-2010-02-18-branchpoint:1.188
	gdb_7_0_1-2009-12-22-release:1.184.4.2
	gdb_7_0-2009-10-06-release:1.184.4.2
	gdb_7_0-branch:1.184.0.4
	gdb_7_0-2009-09-16-branchpoint:1.184
	arc-sim-20090309:1.170
	msnyder-checkpoint-072509-branch:1.184.0.2
	msnyder-checkpoint-072509-branchpoint:1.184
	arc-insight_6_8-branch:1.170.0.6
	arc-insight_6_8-branchpoint:1.170
	insight_6_8-branch:1.170.0.4
	insight_6_8-branchpoint:1.170
	reverse-20081226-branch:1.178.0.6
	reverse-20081226-branchpoint:1.178
	multiprocess-20081120-branch:1.178.0.4
	multiprocess-20081120-branchpoint:1.178
	reverse-20080930-branch:1.178.0.2
	reverse-20080930-branchpoint:1.178
	reverse-20080717-branch:1.175.0.4
	reverse-20080717-branchpoint:1.175
	msnyder-reverse-20080609-branch:1.175.0.2
	msnyder-reverse-20080609-branchpoint:1.175
	drow-reverse-20070409-branch:1.159.0.2
	drow-reverse-20070409-branchpoint:1.159
	gdb_6_8-2008-03-27-release:1.170
	gdb_6_8-branch:1.170.0.2
	gdb_6_8-2008-02-26-branchpoint:1.170
	gdb_6_7_1-2007-10-29-release:1.162.2.1
	gdb_6_7-2007-10-10-release:1.162.2.1
	gdb_6_7-branch:1.162.0.2
	gdb_6_7-2007-09-07-branchpoint:1.162
	insight_6_6-20070208-release:1.155
	gdb_6_6-2006-12-18-release:1.155
	gdb_6_6-branch:1.155.0.2
	gdb_6_6-2006-11-15-branchpoint:1.155
	insight_6_5-20061003-release:1.154
	gdb-csl-symbian-6_4_50_20060226-12:1.150
	gdb-csl-sourcerygxx-3_4_4-25:1.147
	nickrob-async-20060828-mergepoint:1.155
	gdb-csl-symbian-6_4_50_20060226-11:1.150
	gdb-csl-sourcerygxx-4_1-17:1.150
	gdb-csl-20060226-branch-local-2:1.150
	gdb-csl-sourcerygxx-4_1-14:1.150
	gdb-csl-sourcerygxx-4_1-13:1.150
	gdb-csl-sourcerygxx-4_1-12:1.150
	gdb-csl-sourcerygxx-3_4_4-21:1.150
	gdb_6_5-20060621-release:1.154
	gdb-csl-sourcerygxx-4_1-9:1.150
	gdb-csl-sourcerygxx-4_1-8:1.150
	gdb-csl-sourcerygxx-4_1-7:1.150
	gdb-csl-arm-2006q1-6:1.150
	gdb-csl-sourcerygxx-4_1-6:1.150
	gdb-csl-symbian-6_4_50_20060226-10:1.150
	gdb-csl-symbian-6_4_50_20060226-9:1.150
	gdb-csl-symbian-6_4_50_20060226-8:1.150
	gdb-csl-coldfire-4_1-11:1.150
	gdb-csl-sourcerygxx-3_4_4-19:1.150
	gdb-csl-coldfire-4_1-10:1.150
	gdb_6_5-branch:1.154.0.4
	gdb_6_5-2006-05-14-branchpoint:1.154
	gdb-csl-sourcerygxx-4_1-5:1.150
	nickrob-async-20060513-branch:1.154.0.2
	nickrob-async-20060513-branchpoint:1.154
	gdb-csl-sourcerygxx-4_1-4:1.150
	msnyder-reverse-20060502-branch:1.153.0.4
	msnyder-reverse-20060502-branchpoint:1.153
	gdb-csl-morpho-4_1-4:1.150
	gdb-csl-sourcerygxx-3_4_4-17:1.150
	readline_5_1-import-branch:1.153.0.2
	readline_5_1-import-branchpoint:1.153
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.150
	gdb-csl-symbian-20060226-branch:1.150.0.8
	gdb-csl-symbian-20060226-branchpoint:1.150
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.150
	msnyder-reverse-20060331-branch:1.150.0.6
	msnyder-reverse-20060331-branchpoint:1.150
	gdb-csl-available-20060303-branch:1.150.0.4
	gdb-csl-available-20060303-branchpoint:1.150
	gdb-csl-20060226-branch:1.150.0.2
	gdb-csl-20060226-branchpoint:1.150
	gdb_6_4-20051202-release:1.147
	msnyder-fork-checkpoint-branch:1.147.0.8
	msnyder-fork-checkpoint-branchpoint:1.147
	gdb-csl-gxxpro-6_3-branch:1.147.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.147
	gdb_6_4-branch:1.147.0.4
	gdb_6_4-2005-11-01-branchpoint:1.147
	gdb-csl-arm-20051020-branch:1.147.0.2
	gdb-csl-arm-20051020-branchpoint:1.147
	msnyder-tracepoint-checkpoint-branch:1.146.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.146
	gdb-csl-arm-20050325-2005-q1b:1.142
	gdb-csl-arm-20050325-2005-q1a:1.142
	csl-arm-20050325-branch:1.142.0.2
	csl-arm-20050325-branchpoint:1.142
	gdb-post-i18n-errorwarning-20050211:1.140
	gdb-pre-i18n-errorwarning-20050211:1.139
	gdb_6_3-20041109-release:1.135.2.1
	gdb_6_3-branch:1.135.0.2
	gdb_6_3-20041019-branchpoint:1.135
	drow_intercu-merge-20040921:1.135
	drow_intercu-merge-20040915:1.135
	jimb-gdb_6_2-e500-branch:1.133.0.6
	jimb-gdb_6_2-e500-branchpoint:1.133
	gdb_6_2-20040730-release:1.133
	gdb_6_2-branch:1.133.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.133
	gdb_6_1_1-20040616-release:1.129.2.1
	gdb_6_1-2004-04-05-release:1.129.2.1
	drow_intercu-merge-20040402:1.130
	drow_intercu-merge-20040327:1.130
	ezannoni_pie-20040323-branch:1.130.0.2
	ezannoni_pie-20040323-branchpoint:1.130
	cagney_tramp-20040321-mergepoint:1.129
	cagney_tramp-20040309-branch:1.129.0.4
	cagney_tramp-20040309-branchpoint:1.129
	gdb_6_1-branch:1.129.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.129
	drow_intercu-20040221-branch:1.128.0.2
	drow_intercu-20040221-branchpoint:1.128
	cagney_bfdfile-20040213-branch:1.122.0.2
	cagney_bfdfile-20040213-branchpoint:1.122
	drow-cplus-merge-20040208:1.120
	carlton_dictionary-20040126-merge:1.119
	cagney_bigcore-20040122-branch:1.119.0.2
	cagney_bigcore-20040122-branchpoint:1.119
	drow-cplus-merge-20040113:1.118
	drow-cplus-merge-20031224:1.118
	drow-cplus-merge-20031220:1.118
	carlton_dictionary-20031215-merge:1.118
	drow-cplus-merge-20031214:1.118
	carlton-dictionary-20031111-merge:1.118
	gdb_6_0-2003-10-04-release:1.105.2.3
	kettenis_sparc-20030918-branch:1.113.0.2
	kettenis_sparc-20030918-branchpoint:1.113
	carlton_dictionary-20030917-merge:1.113
	ezannoni_pie-20030916-branchpoint:1.112
	ezannoni_pie-20030916-branch:1.112.0.2
	cagney_x86i386-20030821-branch:1.108.0.2
	cagney_x86i386-20030821-branchpoint:1.108
	carlton_dictionary-20030805-merge:1.108
	carlton_dictionary-20030627-merge:1.105
	gdb_6_0-branch:1.105.0.2
	gdb_6_0-2003-06-23-branchpoint:1.105
	jimb-ppc64-linux-20030613-branch:1.103.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.103
	cagney_convert-20030606-branch:1.98.0.6
	cagney_convert-20030606-branchpoint:1.98
	cagney_writestrings-20030508-branch:1.96.0.4
	cagney_writestrings-20030508-branchpoint:1.96
	jimb-ppc64-linux-20030528-branch:1.98.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.98
	carlton_dictionary-20030523-merge:1.98
	cagney_fileio-20030521-branch:1.98.0.2
	cagney_fileio-20030521-branchpoint:1.98
	kettenis_i386newframe-20030517-mergepoint:1.98
	jimb-ppc64-linux-20030509-branch:1.96.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.96
	kettenis_i386newframe-20030504-mergepoint:1.95
	carlton_dictionary-20030430-merge:1.95
	kettenis_i386newframe-20030419-branch:1.92.0.2
	kettenis_i386newframe-20030419-branchpoint:1.92
	carlton_dictionary-20030416-merge:1.91
	cagney_frameaddr-20030409-mergepoint:1.89
	kettenis_i386newframe-20030406-branch:1.89.0.2
	kettenis_i386newframe-20030406-branchpoint:1.89
	cagney_frameaddr-20030403-branchpoint:1.88
	cagney_frameaddr-20030403-branch:1.88.0.2
	cagney_framebase-20030330-mergepoint:1.83
	cagney_framebase-20030326-branch:1.80.0.2
	cagney_framebase-20030326-branchpoint:1.80
	cagney_lazyid-20030317-branch:1.77.0.2
	cagney_lazyid-20030317-branchpoint:1.77
	kettenis-i386newframe-20030316-mergepoint:1.77
	offbyone-20030313-branch:1.76.0.2
	offbyone-20030313-branchpoint:1.76
	kettenis-i386newframe-20030308-branch:1.75.0.4
	kettenis-i386newframe-20030308-branchpoint:1.75
	carlton_dictionary-20030305-merge:1.75
	cagney_offbyone-20030303-branch:1.75.0.2
	cagney_offbyone-20030303-branchpoint:1.75
	carlton_dictionary-20030207-merge:1.71
	interps-20030203-mergepoint:1.71
	interps-20030202-branch:1.70.0.4
	interps-20030202-branchpoint:1.70
	cagney-unwind-20030108-branch:1.70.0.2
	cagney-unwind-20030108-branchpoint:1.70
	carlton_dictionary-20021223-merge:1.62
	gdb_5_3-2002-12-12-release:1.51
	carlton_dictionary-20021115-merge:1.54
	kseitz_interps-20021105-merge:1.53
	kseitz_interps-20021103-merge:1.53
	drow-cplus-merge-20021020:1.52
	drow-cplus-merge-20021025:1.52
	carlton_dictionary-20021025-merge:1.52
	carlton_dictionary-20021011-merge:1.52
	drow-cplus-branch:1.52.0.4
	drow-cplus-branchpoint:1.52
	kseitz_interps-20020930-merge:1.52
	carlton_dictionary-20020927-merge:1.52
	carlton_dictionary-branch:1.52.0.2
	carlton_dictionary-20020920-branchpoint:1.52
	gdb_5_3-branch:1.51.0.6
	gdb_5_3-2002-09-04-branchpoint:1.51
	kseitz_interps-20020829-merge:1.51
	cagney_sysregs-20020825-branch:1.51.0.4
	cagney_sysregs-20020825-branchpoint:1.51
	readline_4_3-import-branch:1.51.0.2
	readline_4_3-import-branchpoint:1.51
	gdb_5_2_1-2002-07-23-release:1.42
	kseitz_interps-20020528-branch:1.45.0.6
	kseitz_interps-20020528-branchpoint:1.45
	cagney_regbuf-20020515-branch:1.45.0.4
	cagney_regbuf-20020515-branchpoint:1.45
	jimb-macro-020506-branch:1.45.0.2
	jimb-macro-020506-branchpoint:1.45
	gdb_5_2-2002-04-29-release:1.42
	gdb_5_2-branch:1.42.0.2
	gdb_5_2-2002-03-03-branchpoint:1.42
	gdb_5_1_1-2002-01-24-release:1.1.4.3
	gdb_5_1_0_1-2002-01-03-release:1.1.4.3
	cygnus_cvs_20020108_pre:1.39
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.4.3
	gdb_5_1_0_1-2002-01-03-branch:1.1.4.3.0.2
	gdb_5_1-2001-11-21-release:1.1.4.3
	gdb_5_1-2001-07-29-branch:1.1.0.4
	gdb_s390-2001-09-26-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.216
date	2013.09.16.11.28.53;	author muller;	state Exp;
branches;
next	1.215;

1.215
date	2013.09.13.14.17.29;	author uweigand;	state Exp;
branches;
next	1.214;

1.214
date	2013.09.13.14.11.15;	author uweigand;	state Exp;
branches;
next	1.213;

1.213
date	2013.07.17.05.28.04;	author devans;	state Exp;
branches;
next	1.212;

1.212
date	2013.06.24.22.18.31;	author macro;	state Exp;
branches;
next	1.211;

1.211
date	2013.04.19.15.22.47;	author palves;	state Exp;
branches;
next	1.210;

1.210
date	2013.01.01.06.32.50;	author brobecke;	state Exp;
branches;
next	1.209;

1.209
date	2012.11.02.18.53.54;	author tromey;	state Exp;
branches;
next	1.208;

1.208
date	2012.09.25.12.48.53;	author siddhesh;	state Exp;
branches;
next	1.207;

1.207
date	2012.09.17.08.52.18;	author siddhesh;	state Exp;
branches;
next	1.206;

1.206
date	2012.05.18.21.02.50;	author sergiodj;	state Exp;
branches;
next	1.205;

1.205
date	2012.05.16.14.35.07;	author macro;	state Exp;
branches;
next	1.204;

1.204
date	2012.04.27.20.47.55;	author sergiodj;	state Exp;
branches;
next	1.203;

1.203
date	2012.01.04.08.17.10;	author brobecke;	state Exp;
branches;
next	1.202;

1.202
date	2011.12.19.21.44.57;	author uweigand;	state Exp;
branches;
next	1.201;

1.201
date	2011.12.07.13.31.05;	author uweigand;	state Exp;
branches
	1.201.2.1;
next	1.200;

1.200
date	2011.12.06.14.14.48;	author uweigand;	state Exp;
branches;
next	1.199;

1.199
date	2011.11.30.16.06.54;	author uweigand;	state Exp;
branches;
next	1.198;

1.198
date	2011.11.30.08.26.46;	author uweigand;	state Exp;
branches;
next	1.197;

1.197
date	2011.11.30.08.26.06;	author uweigand;	state Exp;
branches;
next	1.196;

1.196
date	2011.09.21.17.00.31;	author uweigand;	state Exp;
branches;
next	1.195;

1.195
date	2011.07.05.04.34.56;	author bauermann;	state Exp;
branches;
next	1.194;

1.194
date	2011.03.18.18.52.31;	author palves;	state Exp;
branches;
next	1.193;

1.193
date	2011.03.18.18.38.43;	author palves;	state Exp;
branches;
next	1.192;

1.192
date	2011.01.11.21.53.23;	author msnyder;	state Exp;
branches;
next	1.191;

1.191
date	2011.01.01.15.33.14;	author brobecke;	state Exp;
branches;
next	1.190;

1.190
date	2010.08.04.20.40.57;	author palves;	state Exp;
branches;
next	1.189;

1.189
date	2010.06.25.17.47.29;	author uweigand;	state Exp;
branches;
next	1.188;

1.188
date	2010.01.04.15.02.59;	author uweigand;	state Exp;
branches;
next	1.187;

1.187
date	2010.01.01.07.31.41;	author brobecke;	state Exp;
branches;
next	1.186;

1.186
date	2009.09.29.12.51.34;	author uweigand;	state Exp;
branches;
next	1.185;

1.185
date	2009.09.27.20.47.42;	author uweigand;	state Exp;
branches;
next	1.184;

1.184
date	2009.07.02.17.25.58;	author uweigand;	state Exp;
branches
	1.184.4.1;
next	1.183;

1.183
date	2009.06.28.00.20.22;	author drow;	state Exp;
branches;
next	1.182;

1.182
date	2009.06.17.18.39.13;	author uweigand;	state Exp;
branches;
next	1.181;

1.181
date	2009.05.22.23.49.13;	author palves;	state Exp;
branches;
next	1.180;

1.180
date	2009.02.22.01.02.19;	author palves;	state Exp;
branches;
next	1.179;

1.179
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.178;

1.178
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.177;

1.177
date	2008.09.05.11.42.32;	author uweigand;	state Exp;
branches;
next	1.176;

1.176
date	2008.08.24.20.33.33;	author tromey;	state Exp;
branches;
next	1.175;

1.175
date	2008.05.16.00.27.23;	author drow;	state Exp;
branches;
next	1.174;

1.174
date	2008.05.01.00.18.27;	author uweigand;	state Exp;
branches;
next	1.173;

1.173
date	2008.04.30.21.18.28;	author drow;	state Exp;
branches;
next	1.172;

1.172
date	2008.04.22.11.03.42;	author corinna;	state Exp;
branches;
next	1.171;

1.171
date	2008.03.13.12.22.13;	author drow;	state Exp;
branches;
next	1.170;

1.170
date	2008.01.31.15.43.32;	author uweigand;	state Exp;
branches;
next	1.169;

1.169
date	2008.01.17.16.05.41;	author uweigand;	state Exp;
branches;
next	1.168;

1.168
date	2008.01.11.13.20.02;	author deuling;	state Exp;
branches;
next	1.167;

1.167
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.166;

1.166
date	2007.12.06.16.33.00;	author deuling;	state Exp;
branches;
next	1.165;

1.165
date	2007.11.07.06.33.01;	author deuling;	state Exp;
branches;
next	1.164;

1.164
date	2007.11.02.14.27.14;	author uweigand;	state Exp;
branches;
next	1.163;

1.163
date	2007.10.02.19.25.52;	author uweigand;	state Exp;
branches;
next	1.162;

1.162
date	2007.08.23.18.08.37;	author brobecke;	state Exp;
branches
	1.162.2.1;
next	1.161;

1.161
date	2007.06.16.17.24.18;	author uweigand;	state Exp;
branches;
next	1.160;

1.160
date	2007.06.13.17.38.43;	author uweigand;	state Exp;
branches;
next	1.159;

1.159
date	2007.02.27.20.17.19;	author drow;	state Exp;
branches;
next	1.158;

1.158
date	2007.01.09.17.58.58;	author drow;	state Exp;
branches;
next	1.157;

1.157
date	2007.01.08.20.03.49;	author uweigand;	state Exp;
branches;
next	1.156;

1.156
date	2006.11.28.21.41.02;	author uweigand;	state Exp;
branches;
next	1.155;

1.155
date	2006.08.08.21.32.38;	author brobecke;	state Exp;
branches;
next	1.154;

1.154
date	2006.05.06.01.12.11;	author uweigand;	state Exp;
branches
	1.154.2.1;
next	1.153;

1.153
date	2006.04.09.01.21.15;	author uweigand;	state Exp;
branches;
next	1.152;

1.152
date	2006.04.09.00.26.08;	author uweigand;	state Exp;
branches;
next	1.151;

1.151
date	2006.04.05.20.01.19;	author davem;	state Exp;
branches;
next	1.150;

1.150
date	2006.01.15.18.28.58;	author kettenis;	state Exp;
branches;
next	1.149;

1.149
date	2006.01.15.13.45.24;	author kettenis;	state Exp;
branches;
next	1.148;

1.148
date	2005.12.17.22.34.02;	author eliz;	state Exp;
branches;
next	1.147;

1.147
date	2005.08.15.17.36.48;	author uweigand;	state Exp;
branches;
next	1.146;

1.146
date	2005.05.24.16.12.58;	author uweigand;	state Exp;
branches;
next	1.145;

1.145
date	2005.05.16.12.38.09;	author uweigand;	state Exp;
branches;
next	1.144;

1.144
date	2005.05.16.10.55.03;	author uweigand;	state Exp;
branches;
next	1.143;

1.143
date	2005.03.31.19.58.26;	author kevinb;	state Exp;
branches;
next	1.142;

1.142
date	2005.03.17.17.44.14;	author pbrook;	state Exp;
branches;
next	1.141;

1.141
date	2005.02.11.18.13.52;	author cagney;	state Exp;
branches;
next	1.140;

1.140
date	2005.02.11.04.06.04;	author cagney;	state Exp;
branches;
next	1.139;

1.139
date	2005.02.07.00.09.55;	author cagney;	state Exp;
branches;
next	1.138;

1.138
date	2004.11.13.02.15.33;	author cagney;	state Exp;
branches;
next	1.137;

1.137
date	2004.10.31.19.52.46;	author cagney;	state Exp;
branches;
next	1.136;

1.136
date	2004.10.23.16.31.23;	author uweigand;	state Exp;
branches;
next	1.135;

1.135
date	2004.07.31.21.53.17;	author cagney;	state Exp;
branches
	1.135.2.1;
next	1.134;

1.134
date	2004.07.20.19.45.07;	author cagney;	state Exp;
branches;
next	1.133;

1.133
date	2004.06.07.02.02.54;	author tausq;	state Exp;
branches;
next	1.132;

1.132
date	2004.05.04.18.50.26;	author cagney;	state Exp;
branches;
next	1.131;

1.131
date	2004.05.01.19.35.22;	author cagney;	state Exp;
branches;
next	1.130;

1.130
date	2004.03.22.22.33.33;	author cagney;	state Exp;
branches;
next	1.129;

1.129
date	2004.02.26.23.48.01;	author cagney;	state Exp;
branches
	1.129.2.1;
next	1.128;

1.128
date	2004.02.18.04.17.35;	author jimb;	state Exp;
branches
	1.128.2.1;
next	1.127;

1.127
date	2004.02.18.04.07.48;	author jimb;	state Exp;
branches;
next	1.126;

1.126
date	2004.02.18.03.54.11;	author jimb;	state Exp;
branches;
next	1.125;

1.125
date	2004.02.18.03.42.50;	author jimb;	state Exp;
branches;
next	1.124;

1.124
date	2004.02.16.21.49.22;	author cagney;	state Exp;
branches;
next	1.123;

1.123
date	2004.02.14.15.46.33;	author ezannoni;	state Exp;
branches;
next	1.122;

1.122
date	2004.02.12.18.43.09;	author cagney;	state Exp;
branches;
next	1.121;

1.121
date	2004.02.11.15.40.28;	author cagney;	state Exp;
branches;
next	1.120;

1.120
date	2004.01.26.20.52.11;	author cagney;	state Exp;
branches;
next	1.119;

1.119
date	2004.01.13.21.38.47;	author cagney;	state Exp;
branches;
next	1.118;

1.118
date	2003.10.31.22.19.12;	author cagney;	state Exp;
branches;
next	1.117;

1.117
date	2003.10.02.20.28.30;	author cagney;	state Exp;
branches;
next	1.116;

1.116
date	2003.09.27.15.51.02;	author cagney;	state Exp;
branches;
next	1.115;

1.115
date	2003.09.25.20.44.01;	author cagney;	state Exp;
branches;
next	1.114;

1.114
date	2003.09.19.16.22.39;	author cagney;	state Exp;
branches;
next	1.113;

1.113
date	2003.09.17.14.24.30;	author cagney;	state Exp;
branches;
next	1.112;

1.112
date	2003.09.09.04.41.32;	author cagney;	state Exp;
branches;
next	1.111;

1.111
date	2003.09.09.03.58.18;	author cagney;	state Exp;
branches;
next	1.110;

1.110
date	2003.08.28.03.39.20;	author cagney;	state Exp;
branches;
next	1.109;

1.109
date	2003.08.28.03.03.44;	author cagney;	state Exp;
branches;
next	1.108;

1.108
date	2003.07.02.19.20.55;	author jimb;	state Exp;
branches;
next	1.107;

1.107
date	2003.07.02.19.05.56;	author jimb;	state Exp;
branches;
next	1.106;

1.106
date	2003.07.01.00.05.37;	author jimb;	state Exp;
branches;
next	1.105;

1.105
date	2003.06.20.13.57.28;	author drow;	state Exp;
branches
	1.105.2.1;
next	1.104;

1.104
date	2003.06.16.16.47.42;	author cagney;	state Exp;
branches;
next	1.103;

1.103
date	2003.06.13.04.40.33;	author cagney;	state Exp;
branches;
next	1.102;

1.102
date	2003.06.11.13.16.29;	author cagney;	state Exp;
branches;
next	1.101;

1.101
date	2003.06.09.20.08.56;	author cagney;	state Exp;
branches;
next	1.100;

1.100
date	2003.06.09.17.35.58;	author cagney;	state Exp;
branches;
next	1.99;

1.99
date	2003.06.07.22.38.56;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2003.05.17.05.59.58;	author cagney;	state Exp;
branches;
next	1.97;

1.97
date	2003.05.15.22.58.38;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2003.05.05.17.56.55;	author cagney;	state Exp;
branches;
next	1.95;

1.95
date	2003.04.30.22.01.37;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2003.04.29.01.49.47;	author cagney;	state Exp;
branches;
next	1.93;

1.93
date	2003.04.28.16.17.28;	author cagney;	state Exp;
branches;
next	1.92;

1.92
date	2003.04.18.20.20.21;	author jimb;	state Exp;
branches
	1.92.2.1;
next	1.91;

1.91
date	2003.04.11.18.15.39;	author cagney;	state Exp;
branches;
next	1.90;

1.90
date	2003.04.10.22.40.38;	author jimb;	state Exp;
branches;
next	1.89;

1.89
date	2003.04.05.18.54.38;	author cagney;	state Exp;
branches;
next	1.88;

1.88
date	2003.04.01.17.17.29;	author cagney;	state Exp;
branches
	1.88.2.1;
next	1.87;

1.87
date	2003.04.01.14.38.50;	author cagney;	state Exp;
branches;
next	1.86;

1.86
date	2003.03.31.23.52.38;	author cagney;	state Exp;
branches;
next	1.85;

1.85
date	2003.03.31.21.58.22;	author cagney;	state Exp;
branches;
next	1.84;

1.84
date	2003.03.31.19.01.20;	author cagney;	state Exp;
branches;
next	1.83;

1.83
date	2003.03.30.14.59.01;	author cagney;	state Exp;
branches;
next	1.82;

1.82
date	2003.03.30.14.32.09;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2003.03.26.22.39.52;	author cagney;	state Exp;
branches;
next	1.80;

1.80
date	2003.03.25.20.38.46;	author cagney;	state Exp;
branches
	1.80.2.1;
next	1.79;

1.79
date	2003.03.25.18.54.15;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2003.03.24.03.54.48;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2003.03.13.21.45.41;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2003.03.12.16.50.45;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2003.03.03.20.50.19;	author cagney;	state Exp;
branches
	1.75.4.1;
next	1.74;

1.74
date	2003.03.02.04.02.24;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2003.03.02.00.11.43;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2003.02.27.17.48.47;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2003.02.03.20.35.44;	author kevinb;	state Exp;
branches;
next	1.70;

1.70
date	2003.01.08.17.21.29;	author cagney;	state Exp;
branches
	1.70.4.1;
next	1.69;

1.69
date	2003.01.08.15.56.37;	author cagney;	state Exp;
branches;
next	1.68;

1.68
date	2003.01.08.01.53.37;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2003.01.07.14.51.10;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2003.01.05.01.39.55;	author drow;	state Exp;
branches;
next	1.65;

1.65
date	2003.01.04.22.37.47;	author drow;	state Exp;
branches;
next	1.64;

1.64
date	2003.01.03.23.53.48;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2003.01.02.22.20.46;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2002.12.11.02.26.36;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2002.12.09.02.04.16;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2002.12.06.19.26.04;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2002.12.01.19.07.15;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2002.11.28.18.15.59;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2002.11.26.19.01.29;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2002.11.18.22.19.30;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2002.11.16.01.00.06;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2002.11.14.00.25.03;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2002.09.17.20.42.01;	author cagney;	state Exp;
branches
	1.52.2.1
	1.52.4.1;
next	1.51;

1.51
date	2002.08.24.00.21.35;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2002.08.05.17.12.56;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2002.07.11.13.50.49;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.26.15.28.46;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.17.23.32.33;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.14.22.55.40;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2002.04.20.03.09.28;	author cagney;	state Exp;
branches
	1.45.4.1
	1.45.6.1;
next	1.44;

1.44
date	2002.04.18.18.09.06;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2002.04.06.00.02.50;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2002.02.24.22.31.19;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.23.20.00.13;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2002.01.20.18.05.51;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2001.12.20.08.55.31;	author jimb;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.20.08.54.02;	author jimb;	state Exp;
branches;
next	1.37;

1.37
date	2001.12.20.08.52.37;	author jimb;	state Exp;
branches;
next	1.36;

1.36
date	2001.12.20.08.50.46;	author jimb;	state Exp;
branches;
next	1.35;

1.35
date	2001.12.20.03.26.08;	author jimb;	state Exp;
branches;
next	1.34;

1.34
date	2001.12.19.23.07.53;	author jimb;	state Exp;
branches;
next	1.33;

1.33
date	2001.12.19.22.32.35;	author jimb;	state Exp;
branches;
next	1.32;

1.32
date	2001.12.19.22.24.49;	author jimb;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.07.22.49.25;	author jimb;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.05.22.20.00;	author jimb;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.05.00.20.37;	author jimb;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.05.00.07.50;	author jimb;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.04.23.51.55;	author jimb;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.03.18.48.54;	author jimb;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.29.22.24.42;	author jimb;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.29.05.02.37;	author jimb;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.28.03.40.50;	author jimb;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.28.03.34.06;	author jimb;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.27.22.48.26;	author jimb;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.27.22.19.55;	author jimb;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.16.21.40.36;	author jimb;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.16.02.48.30;	author jimb;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.14.22.34.38;	author jimb;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.14.22.29.39;	author jimb;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.14.22.14.11;	author jimb;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.13.17.47.19;	author jimb;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.13.17.38.49;	author jimb;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.13.17.26.46;	author jimb;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.09.19.13.59;	author jimb;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.09.18.58.13;	author jimb;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.08.23.28.36;	author jimb;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.08.19.16.10;	author jimb;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.08.19.06.04;	author jimb;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.08.19.03.54;	author jimb;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.01.01.21.35;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.31.22.57.46;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.21.17.19.37;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.13.22.13.35;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.27.00.13.29;	author cagney;	state dead;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.201.2.1
date	2011.12.19.21.45.42;	author uweigand;	state Exp;
branches;
next	1.201.2.2;

1.201.2.2
date	2012.01.06.04.43.29;	author brobecke;	state Exp;
branches;
next	;

1.184.4.1
date	2009.09.29.00.40.24;	author uweigand;	state Exp;
branches;
next	1.184.4.2;

1.184.4.2
date	2009.09.29.12.52.26;	author uweigand;	state Exp;
branches;
next	;

1.162.2.1
date	2007.10.02.19.26.42;	author uweigand;	state Exp;
branches;
next	;

1.154.2.1
date	2006.08.28.07.48.47;	author nickrob;	state Exp;
branches;
next	;

1.135.2.1
date	2004.10.23.16.32.24;	author uweigand;	state Exp;
branches;
next	;

1.129.2.1
date	2004.03.22.22.36.54;	author cagney;	state Exp;
branches;
next	;

1.128.2.1
date	2004.03.27.17.37.51;	author drow;	state Exp;
branches;
next	1.128.2.2;

1.128.2.2
date	2004.09.16.17.01.18;	author drow;	state Exp;
branches;
next	;

1.105.2.1
date	2003.07.01.00.12.49;	author jimb;	state Exp;
branches;
next	1.105.2.2;

1.105.2.2
date	2003.07.02.19.33.12;	author jimb;	state Exp;
branches;
next	1.105.2.3;

1.105.2.3
date	2003.07.02.19.38.46;	author jimb;	state Exp;
branches;
next	;

1.92.2.1
date	2003.05.04.11.37.45;	author kettenis;	state Exp;
branches;
next	1.92.2.2;

1.92.2.2
date	2003.05.18.09.44.20;	author kettenis;	state Exp;
branches;
next	;

1.88.2.1
date	2003.04.10.21.33.49;	author cagney;	state Exp;
branches;
next	;

1.80.2.1
date	2003.03.30.16.35.22;	author cagney;	state Exp;
branches;
next	;

1.75.4.1
date	2003.03.16.14.01.51;	author kettenis;	state Exp;
branches;
next	;

1.70.4.1
date	2003.02.03.22.00.56;	author cagney;	state Exp;
branches;
next	;

1.52.2.1
date	2002.11.15.19.18.55;	author carlton;	state Exp;
branches;
next	1.52.2.2;

1.52.2.2
date	2002.12.23.19.38.40;	author carlton;	state Exp;
branches;
next	1.52.2.3;

1.52.2.3
date	2003.02.07.19.17.52;	author carlton;	state Exp;
branches;
next	1.52.2.4;

1.52.2.4
date	2003.03.06.00.56.31;	author carlton;	state Exp;
branches;
next	1.52.2.5;

1.52.2.5
date	2003.04.16.19.56.54;	author carlton;	state Exp;
branches;
next	1.52.2.6;

1.52.2.6
date	2003.05.01.00.46.52;	author carlton;	state Exp;
branches;
next	1.52.2.7;

1.52.2.7
date	2003.05.23.18.40.44;	author carlton;	state Exp;
branches;
next	1.52.2.8;

1.52.2.8
date	2003.06.27.21.50.08;	author carlton;	state Exp;
branches;
next	1.52.2.9;

1.52.2.9
date	2003.08.05.17.13.13;	author carlton;	state Exp;
branches;
next	1.52.2.10;

1.52.2.10
date	2003.09.17.21.28.30;	author carlton;	state Exp;
branches;
next	1.52.2.11;

1.52.2.11
date	2003.11.11.23.50.54;	author carlton;	state Exp;
branches;
next	1.52.2.12;

1.52.2.12
date	2004.01.26.19.11.30;	author carlton;	state Exp;
branches;
next	;

1.52.4.1
date	2003.12.14.20.27.29;	author drow;	state Exp;
branches;
next	1.52.4.2;

1.52.4.2
date	2004.02.09.19.43.47;	author drow;	state Exp;
branches;
next	;

1.45.4.1
date	2002.06.15.16.42.54;	author cagney;	state Exp;
branches;
next	1.45.4.2;

1.45.4.2
date	2002.06.21.16.19.30;	author cagney;	state Exp;
branches;
next	1.45.4.3;

1.45.4.3
date	2002.06.28.23.19.26;	author cagney;	state Exp;
branches;
next	;

1.45.6.1
date	2002.06.20.01.32.59;	author kseitz;	state Exp;
branches;
next	1.45.6.2;

1.45.6.2
date	2002.07.22.21.47.02;	author kseitz;	state Exp;
branches;
next	1.45.6.3;

1.45.6.3
date	2002.08.09.18.34.26;	author kseitz;	state Exp;
branches;
next	1.45.6.4;

1.45.6.4
date	2002.08.30.22.52.45;	author kseitz;	state Exp;
branches;
next	1.45.6.5;

1.45.6.5
date	2002.10.01.00.46.14;	author kseitz;	state Exp;
branches;
next	1.45.6.6;

1.45.6.6
date	2002.11.04.00.17.32;	author ezannoni;	state Exp;
branches;
next	;

1.1.2.1
date	2001.09.27.00.13.29;	author cagney;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.10.13.21.02.07;	author cagney;	state Exp;
branches;
next	;

1.1.4.1
date	2001.10.13.22.13.05;	author cagney;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.10.31.22.50.28;	author cagney;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2001.10.31.22.54.37;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.216
log
@	* arm-linux-tdep.c: Add "elf/common.h" header.
	Remove AT_HWCAP macro definintion as it is provided in
	added include file.
	* s390-tdep.c: Remove system header <elf.h>
	Add "elf/common.h" header for AT_HWCAP definition.
	(s390_core_read_description): Use correct CORE_ADDR
	for hwcap local variable used as third parameter
	of function target_auxv_search.
@
text
@/* Target-dependent code for GDB, the GNU debugger.

   Copyright (C) 2001-2013 Free Software Foundation, Inc.

   Contributed by D.J. Barrow (djbarrow@@de.ibm.com,barrow_dj@@yahoo.com)
   for IBM Deutschland Entwicklung GmbH, IBM Corporation.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "frame.h"
#include "inferior.h"
#include "symtab.h"
#include "target.h"
#include "gdbcore.h"
#include "gdbcmd.h"
#include "objfiles.h"
#include "floatformat.h"
#include "regcache.h"
#include "trad-frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
#include "dwarf2-frame.h"
#include "reggroups.h"
#include "regset.h"
#include "value.h"
#include "gdb_assert.h"
#include "dis-asm.h"
#include "solib-svr4.h"
#include "prologue-value.h"
#include "linux-tdep.h"
#include "s390-tdep.h"
#include "auxv.h"

#include "stap-probe.h"
#include "ax.h"
#include "ax-gdb.h"
#include "user-regs.h"
#include "cli/cli-utils.h"
#include <ctype.h>
#include "elf/common.h"

#include "features/s390-linux32.c"
#include "features/s390-linux32v1.c"
#include "features/s390-linux32v2.c"
#include "features/s390-linux64.c"
#include "features/s390-linux64v1.c"
#include "features/s390-linux64v2.c"
#include "features/s390-te-linux64.c"
#include "features/s390x-linux64.c"
#include "features/s390x-linux64v1.c"
#include "features/s390x-linux64v2.c"
#include "features/s390x-te-linux64.c"

/* The tdep structure.  */

struct gdbarch_tdep
{
  /* ABI version.  */
  enum { ABI_LINUX_S390, ABI_LINUX_ZSERIES } abi;

  /* Pseudo register numbers.  */
  int gpr_full_regnum;
  int pc_regnum;
  int cc_regnum;

  /* Core file register sets.  */
  const struct regset *gregset;
  int sizeof_gregset;

  const struct regset *fpregset;
  int sizeof_fpregset;
};


/* ABI call-saved register information.  */

static int
s390_register_call_saved (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  switch (tdep->abi)
    {
    case ABI_LINUX_S390:
      if ((regnum >= S390_R6_REGNUM && regnum <= S390_R15_REGNUM)
	  || regnum == S390_F4_REGNUM || regnum == S390_F6_REGNUM
	  || regnum == S390_A0_REGNUM)
	return 1;

      break;

    case ABI_LINUX_ZSERIES:
      if ((regnum >= S390_R6_REGNUM && regnum <= S390_R15_REGNUM)
	  || (regnum >= S390_F8_REGNUM && regnum <= S390_F15_REGNUM)
	  || (regnum >= S390_A0_REGNUM && regnum <= S390_A1_REGNUM))
	return 1;

      break;
    }

  return 0;
}

static int
s390_cannot_store_register (struct gdbarch *gdbarch, int regnum)
{
  /* The last-break address is read-only.  */
  return regnum == S390_LAST_BREAK_REGNUM;
}

static void
s390_write_pc (struct regcache *regcache, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  regcache_cooked_write_unsigned (regcache, tdep->pc_regnum, pc);

  /* Set special SYSTEM_CALL register to 0 to prevent the kernel from
     messing with the PC we just installed, if we happen to be within
     an interrupted system call that the kernel wants to restart.

     Note that after we return from the dummy call, the SYSTEM_CALL and
     ORIG_R2 registers will be automatically restored, and the kernel
     continues to restart the system call at this point.  */
  if (register_size (gdbarch, S390_SYSTEM_CALL_REGNUM) > 0)
    regcache_cooked_write_unsigned (regcache, S390_SYSTEM_CALL_REGNUM, 0);
}


/* DWARF Register Mapping.  */

static const short s390_dwarf_regmap[] =
{
  /* General Purpose Registers.  */
  S390_R0_REGNUM, S390_R1_REGNUM, S390_R2_REGNUM, S390_R3_REGNUM,
  S390_R4_REGNUM, S390_R5_REGNUM, S390_R6_REGNUM, S390_R7_REGNUM,
  S390_R8_REGNUM, S390_R9_REGNUM, S390_R10_REGNUM, S390_R11_REGNUM,
  S390_R12_REGNUM, S390_R13_REGNUM, S390_R14_REGNUM, S390_R15_REGNUM,

  /* Floating Point Registers.  */
  S390_F0_REGNUM, S390_F2_REGNUM, S390_F4_REGNUM, S390_F6_REGNUM,
  S390_F1_REGNUM, S390_F3_REGNUM, S390_F5_REGNUM, S390_F7_REGNUM,
  S390_F8_REGNUM, S390_F10_REGNUM, S390_F12_REGNUM, S390_F14_REGNUM,
  S390_F9_REGNUM, S390_F11_REGNUM, S390_F13_REGNUM, S390_F15_REGNUM,

  /* Control Registers (not mapped).  */
  -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, 

  /* Access Registers.  */
  S390_A0_REGNUM, S390_A1_REGNUM, S390_A2_REGNUM, S390_A3_REGNUM,
  S390_A4_REGNUM, S390_A5_REGNUM, S390_A6_REGNUM, S390_A7_REGNUM,
  S390_A8_REGNUM, S390_A9_REGNUM, S390_A10_REGNUM, S390_A11_REGNUM,
  S390_A12_REGNUM, S390_A13_REGNUM, S390_A14_REGNUM, S390_A15_REGNUM,

  /* Program Status Word.  */
  S390_PSWM_REGNUM,
  S390_PSWA_REGNUM,

  /* GPR Lower Half Access.  */
  S390_R0_REGNUM, S390_R1_REGNUM, S390_R2_REGNUM, S390_R3_REGNUM,
  S390_R4_REGNUM, S390_R5_REGNUM, S390_R6_REGNUM, S390_R7_REGNUM,
  S390_R8_REGNUM, S390_R9_REGNUM, S390_R10_REGNUM, S390_R11_REGNUM,
  S390_R12_REGNUM, S390_R13_REGNUM, S390_R14_REGNUM, S390_R15_REGNUM,

  /* GNU/Linux-specific registers (not mapped).  */
  -1, -1, -1,
};

/* Convert DWARF register number REG to the appropriate register
   number used by GDB.  */
static int
s390_dwarf_reg_to_regnum (struct gdbarch *gdbarch, int reg)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* In a 32-on-64 debug scenario, debug info refers to the full 64-bit
     GPRs.  Note that call frame information still refers to the 32-bit
     lower halves, because s390_adjust_frame_regnum uses register numbers
     66 .. 81 to access GPRs.  */
  if (tdep->gpr_full_regnum != -1 && reg >= 0 && reg < 16)
    return tdep->gpr_full_regnum + reg;

  if (reg >= 0 && reg < ARRAY_SIZE (s390_dwarf_regmap))
    return s390_dwarf_regmap[reg];

  warning (_("Unmapped DWARF Register #%d encountered."), reg);
  return -1;
}

/* Translate a .eh_frame register to DWARF register, or adjust a
   .debug_frame register.  */
static int
s390_adjust_frame_regnum (struct gdbarch *gdbarch, int num, int eh_frame_p)
{
  /* See s390_dwarf_reg_to_regnum for comments.  */
  return (num >= 0 && num < 16)? num + 66 : num;
}


/* Pseudo registers.  */

static int
regnum_is_gpr_full (struct gdbarch_tdep *tdep, int regnum)
{
  return (tdep->gpr_full_regnum != -1
	  && regnum >= tdep->gpr_full_regnum
	  && regnum <= tdep->gpr_full_regnum + 15);
}

static const char *
s390_pseudo_register_name (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (regnum == tdep->pc_regnum)
    return "pc";

  if (regnum == tdep->cc_regnum)
    return "cc";

  if (regnum_is_gpr_full (tdep, regnum))
    {
      static const char *full_name[] = {
	"r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
	"r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
      };
      return full_name[regnum - tdep->gpr_full_regnum];
    }

  internal_error (__FILE__, __LINE__, _("invalid regnum"));
}

static struct type *
s390_pseudo_register_type (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (regnum == tdep->pc_regnum)
    return builtin_type (gdbarch)->builtin_func_ptr;

  if (regnum == tdep->cc_regnum)
    return builtin_type (gdbarch)->builtin_int;

  if (regnum_is_gpr_full (tdep, regnum))
    return builtin_type (gdbarch)->builtin_uint64;

  internal_error (__FILE__, __LINE__, _("invalid regnum"));
}

static enum register_status
s390_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int regnum, gdb_byte *buf)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int regsize = register_size (gdbarch, regnum);
  ULONGEST val;

  if (regnum == tdep->pc_regnum)
    {
      enum register_status status;

      status = regcache_raw_read_unsigned (regcache, S390_PSWA_REGNUM, &val);
      if (status == REG_VALID)
	{
	  if (register_size (gdbarch, S390_PSWA_REGNUM) == 4)
	    val &= 0x7fffffff;
	  store_unsigned_integer (buf, regsize, byte_order, val);
	}
      return status;
    }

  if (regnum == tdep->cc_regnum)
    {
      enum register_status status;

      status = regcache_raw_read_unsigned (regcache, S390_PSWM_REGNUM, &val);
      if (status == REG_VALID)
	{
	  if (register_size (gdbarch, S390_PSWA_REGNUM) == 4)
	    val = (val >> 12) & 3;
	  else
	    val = (val >> 44) & 3;
	  store_unsigned_integer (buf, regsize, byte_order, val);
	}
      return status;
    }

  if (regnum_is_gpr_full (tdep, regnum))
    {
      enum register_status status;
      ULONGEST val_upper;

      regnum -= tdep->gpr_full_regnum;

      status = regcache_raw_read_unsigned (regcache, S390_R0_REGNUM + regnum, &val);
      if (status == REG_VALID)
	status = regcache_raw_read_unsigned (regcache, S390_R0_UPPER_REGNUM + regnum,
					     &val_upper);
      if (status == REG_VALID)
	{
	  val |= val_upper << 32;
	  store_unsigned_integer (buf, regsize, byte_order, val);
	}
      return status;
    }

  internal_error (__FILE__, __LINE__, _("invalid regnum"));
}

static void
s390_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int regnum, const gdb_byte *buf)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int regsize = register_size (gdbarch, regnum);
  ULONGEST val, psw;

  if (regnum == tdep->pc_regnum)
    {
      val = extract_unsigned_integer (buf, regsize, byte_order);
      if (register_size (gdbarch, S390_PSWA_REGNUM) == 4)
	{
	  regcache_raw_read_unsigned (regcache, S390_PSWA_REGNUM, &psw);
	  val = (psw & 0x80000000) | (val & 0x7fffffff);
	}
      regcache_raw_write_unsigned (regcache, S390_PSWA_REGNUM, val);
      return;
    }

  if (regnum == tdep->cc_regnum)
    {
      val = extract_unsigned_integer (buf, regsize, byte_order);
      regcache_raw_read_unsigned (regcache, S390_PSWM_REGNUM, &psw);
      if (register_size (gdbarch, S390_PSWA_REGNUM) == 4)
	val = (psw & ~((ULONGEST)3 << 12)) | ((val & 3) << 12);
      else
	val = (psw & ~((ULONGEST)3 << 44)) | ((val & 3) << 44);
      regcache_raw_write_unsigned (regcache, S390_PSWM_REGNUM, val);
      return;
    }

  if (regnum_is_gpr_full (tdep, regnum))
    {
      regnum -= tdep->gpr_full_regnum;
      val = extract_unsigned_integer (buf, regsize, byte_order);
      regcache_raw_write_unsigned (regcache, S390_R0_REGNUM + regnum,
				   val & 0xffffffff);
      regcache_raw_write_unsigned (regcache, S390_R0_UPPER_REGNUM + regnum,
				   val >> 32);
      return;
    }

  internal_error (__FILE__, __LINE__, _("invalid regnum"));
}

/* 'float' values are stored in the upper half of floating-point
   registers, even though we are otherwise a big-endian platform.  */

static struct value *
s390_value_from_register (struct type *type, int regnum,
			  struct frame_info *frame)
{
  struct value *value = default_value_from_register (type, regnum, frame);

  check_typedef (type);

  if (regnum >= S390_F0_REGNUM && regnum <= S390_F15_REGNUM
      && TYPE_LENGTH (type) < 8)
    set_value_offset (value, 0);

  return value;
}

/* Register groups.  */

static int
s390_pseudo_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
				 struct reggroup *group)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* We usually save/restore the whole PSW, which includes PC and CC.
     However, some older gdbservers may not support saving/restoring
     the whole PSW yet, and will return an XML register description
     excluding those from the save/restore register groups.  In those
     cases, we still need to explicitly save/restore PC and CC in order
     to push or pop frames.  Since this doesn't hurt anything if we
     already save/restore the whole PSW (it's just redundant), we add
     PC and CC at this point unconditionally.  */
  if (group == save_reggroup || group == restore_reggroup)
    return regnum == tdep->pc_regnum || regnum == tdep->cc_regnum;

  return default_register_reggroup_p (gdbarch, regnum, group);
}


/* Maps for register sets.  */

const short s390_regmap_gregset[] =
  {
    0x00, S390_PSWM_REGNUM,
    0x04, S390_PSWA_REGNUM,
    0x08, S390_R0_REGNUM,
    0x0c, S390_R1_REGNUM,
    0x10, S390_R2_REGNUM,
    0x14, S390_R3_REGNUM,
    0x18, S390_R4_REGNUM,
    0x1c, S390_R5_REGNUM,
    0x20, S390_R6_REGNUM,
    0x24, S390_R7_REGNUM,
    0x28, S390_R8_REGNUM,
    0x2c, S390_R9_REGNUM,
    0x30, S390_R10_REGNUM,
    0x34, S390_R11_REGNUM,
    0x38, S390_R12_REGNUM,
    0x3c, S390_R13_REGNUM,
    0x40, S390_R14_REGNUM,
    0x44, S390_R15_REGNUM,
    0x48, S390_A0_REGNUM,
    0x4c, S390_A1_REGNUM,
    0x50, S390_A2_REGNUM,
    0x54, S390_A3_REGNUM,
    0x58, S390_A4_REGNUM,
    0x5c, S390_A5_REGNUM,
    0x60, S390_A6_REGNUM,
    0x64, S390_A7_REGNUM,
    0x68, S390_A8_REGNUM,
    0x6c, S390_A9_REGNUM,
    0x70, S390_A10_REGNUM,
    0x74, S390_A11_REGNUM,
    0x78, S390_A12_REGNUM,
    0x7c, S390_A13_REGNUM,
    0x80, S390_A14_REGNUM,
    0x84, S390_A15_REGNUM,
    0x88, S390_ORIG_R2_REGNUM,
    -1, -1
  };

const short s390x_regmap_gregset[] =
  {
    0x00, S390_PSWM_REGNUM,
    0x08, S390_PSWA_REGNUM,
    0x10, S390_R0_REGNUM,
    0x18, S390_R1_REGNUM,
    0x20, S390_R2_REGNUM,
    0x28, S390_R3_REGNUM,
    0x30, S390_R4_REGNUM,
    0x38, S390_R5_REGNUM,
    0x40, S390_R6_REGNUM,
    0x48, S390_R7_REGNUM,
    0x50, S390_R8_REGNUM,
    0x58, S390_R9_REGNUM,
    0x60, S390_R10_REGNUM,
    0x68, S390_R11_REGNUM,
    0x70, S390_R12_REGNUM,
    0x78, S390_R13_REGNUM,
    0x80, S390_R14_REGNUM,
    0x88, S390_R15_REGNUM,
    0x90, S390_A0_REGNUM,
    0x94, S390_A1_REGNUM,
    0x98, S390_A2_REGNUM,
    0x9c, S390_A3_REGNUM,
    0xa0, S390_A4_REGNUM,
    0xa4, S390_A5_REGNUM,
    0xa8, S390_A6_REGNUM,
    0xac, S390_A7_REGNUM,
    0xb0, S390_A8_REGNUM,
    0xb4, S390_A9_REGNUM,
    0xb8, S390_A10_REGNUM,
    0xbc, S390_A11_REGNUM,
    0xc0, S390_A12_REGNUM,
    0xc4, S390_A13_REGNUM,
    0xc8, S390_A14_REGNUM,
    0xcc, S390_A15_REGNUM,
    0x10, S390_R0_UPPER_REGNUM,
    0x18, S390_R1_UPPER_REGNUM,
    0x20, S390_R2_UPPER_REGNUM,
    0x28, S390_R3_UPPER_REGNUM,
    0x30, S390_R4_UPPER_REGNUM,
    0x38, S390_R5_UPPER_REGNUM,
    0x40, S390_R6_UPPER_REGNUM,
    0x48, S390_R7_UPPER_REGNUM,
    0x50, S390_R8_UPPER_REGNUM,
    0x58, S390_R9_UPPER_REGNUM,
    0x60, S390_R10_UPPER_REGNUM,
    0x68, S390_R11_UPPER_REGNUM,
    0x70, S390_R12_UPPER_REGNUM,
    0x78, S390_R13_UPPER_REGNUM,
    0x80, S390_R14_UPPER_REGNUM,
    0x88, S390_R15_UPPER_REGNUM,
    0xd0, S390_ORIG_R2_REGNUM,
    -1, -1
  };

const short s390_regmap_fpregset[] =
  {
    0x00, S390_FPC_REGNUM,
    0x08, S390_F0_REGNUM,
    0x10, S390_F1_REGNUM,
    0x18, S390_F2_REGNUM,
    0x20, S390_F3_REGNUM,
    0x28, S390_F4_REGNUM,
    0x30, S390_F5_REGNUM,
    0x38, S390_F6_REGNUM,
    0x40, S390_F7_REGNUM,
    0x48, S390_F8_REGNUM,
    0x50, S390_F9_REGNUM,
    0x58, S390_F10_REGNUM,
    0x60, S390_F11_REGNUM,
    0x68, S390_F12_REGNUM,
    0x70, S390_F13_REGNUM,
    0x78, S390_F14_REGNUM,
    0x80, S390_F15_REGNUM,
    -1, -1
  };

const short s390_regmap_upper[] =
  {
    0x00, S390_R0_UPPER_REGNUM,
    0x04, S390_R1_UPPER_REGNUM,
    0x08, S390_R2_UPPER_REGNUM,
    0x0c, S390_R3_UPPER_REGNUM,
    0x10, S390_R4_UPPER_REGNUM,
    0x14, S390_R5_UPPER_REGNUM,
    0x18, S390_R6_UPPER_REGNUM,
    0x1c, S390_R7_UPPER_REGNUM,
    0x20, S390_R8_UPPER_REGNUM,
    0x24, S390_R9_UPPER_REGNUM,
    0x28, S390_R10_UPPER_REGNUM,
    0x2c, S390_R11_UPPER_REGNUM,
    0x30, S390_R12_UPPER_REGNUM,
    0x34, S390_R13_UPPER_REGNUM,
    0x38, S390_R14_UPPER_REGNUM,
    0x3c, S390_R15_UPPER_REGNUM,
    -1, -1
  };

const short s390_regmap_last_break[] =
  {
    0x04, S390_LAST_BREAK_REGNUM,
    -1, -1
  };

const short s390x_regmap_last_break[] =
  {
    0x00, S390_LAST_BREAK_REGNUM,
    -1, -1
  };

const short s390_regmap_system_call[] =
  {
    0x00, S390_SYSTEM_CALL_REGNUM,
    -1, -1
  };

const short s390_regmap_tdb[] =
  {
    0x00, S390_TDB_DWORD0_REGNUM,
    0x08, S390_TDB_ABORT_CODE_REGNUM,
    0x10, S390_TDB_CONFLICT_TOKEN_REGNUM,
    0x18, S390_TDB_ATIA_REGNUM,
    0x80, S390_TDB_R0_REGNUM,
    0x88, S390_TDB_R1_REGNUM,
    0x90, S390_TDB_R2_REGNUM,
    0x98, S390_TDB_R3_REGNUM,
    0xa0, S390_TDB_R4_REGNUM,
    0xa8, S390_TDB_R5_REGNUM,
    0xb0, S390_TDB_R6_REGNUM,
    0xb8, S390_TDB_R7_REGNUM,
    0xc0, S390_TDB_R8_REGNUM,
    0xc8, S390_TDB_R9_REGNUM,
    0xd0, S390_TDB_R10_REGNUM,
    0xd8, S390_TDB_R11_REGNUM,
    0xe0, S390_TDB_R12_REGNUM,
    0xe8, S390_TDB_R13_REGNUM,
    0xf0, S390_TDB_R14_REGNUM,
    0xf8, S390_TDB_R15_REGNUM,
    -1, -1
  };


/* Supply register REGNUM from the register set REGSET to register cache 
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */
static void
s390_supply_regset (const struct regset *regset, struct regcache *regcache,
		    int regnum, const void *regs, size_t len)
{
  const short *map;
  for (map = regset->descr; map[0] >= 0; map += 2)
    if (regnum == -1 || regnum == map[1])
      regcache_raw_supply (regcache, map[1],
			   regs ? (const char *)regs + map[0] : NULL);
}

/* Supply the TDB regset.  Like s390_supply_regset, but invalidate the
   TDB registers unless the TDB format field is valid.  */

static void
s390_supply_tdb_regset (const struct regset *regset, struct regcache *regcache,
		    int regnum, const void *regs, size_t len)
{
  ULONGEST tdw;
  enum register_status ret;
  int i;

  s390_supply_regset (regset, regcache, regnum, regs, len);
  ret = regcache_cooked_read_unsigned (regcache, S390_TDB_DWORD0_REGNUM, &tdw);
  if (ret != REG_VALID || (tdw >> 56) != 1)
    s390_supply_regset (regset, regcache, regnum, NULL, len);
}

/* Collect register REGNUM from the register cache REGCACHE and store
   it in the buffer specified by REGS and LEN as described by the
   general-purpose register set REGSET.  If REGNUM is -1, do this for
   all registers in REGSET.  */
static void
s390_collect_regset (const struct regset *regset,
		     const struct regcache *regcache,
		     int regnum, void *regs, size_t len)
{
  const short *map;
  for (map = regset->descr; map[0] >= 0; map += 2)
    if (regnum == -1 || regnum == map[1])
      regcache_raw_collect (regcache, map[1], (char *)regs + map[0]);
}

static const struct regset s390_gregset = {
  s390_regmap_gregset, 
  s390_supply_regset,
  s390_collect_regset
};

static const struct regset s390x_gregset = {
  s390x_regmap_gregset, 
  s390_supply_regset,
  s390_collect_regset
};

static const struct regset s390_fpregset = {
  s390_regmap_fpregset, 
  s390_supply_regset,
  s390_collect_regset
};

static const struct regset s390_upper_regset = {
  s390_regmap_upper, 
  s390_supply_regset,
  s390_collect_regset
};

static const struct regset s390_last_break_regset = {
  s390_regmap_last_break,
  s390_supply_regset,
  s390_collect_regset
};

static const struct regset s390x_last_break_regset = {
  s390x_regmap_last_break,
  s390_supply_regset,
  s390_collect_regset
};

static const struct regset s390_system_call_regset = {
  s390_regmap_system_call,
  s390_supply_regset,
  s390_collect_regset
};

static const struct regset s390_tdb_regset = {
  s390_regmap_tdb,
  s390_supply_tdb_regset,
  s390_collect_regset
};

static struct core_regset_section s390_linux32_regset_sections[] =
{
  { ".reg", s390_sizeof_gregset, "general-purpose" },
  { ".reg2", s390_sizeof_fpregset, "floating-point" },
  { NULL, 0}
};

static struct core_regset_section s390_linux32v1_regset_sections[] =
{
  { ".reg", s390_sizeof_gregset, "general-purpose" },
  { ".reg2", s390_sizeof_fpregset, "floating-point" },
  { ".reg-s390-last-break", 8, "s390 last-break address" },
  { NULL, 0}
};

static struct core_regset_section s390_linux32v2_regset_sections[] =
{
  { ".reg", s390_sizeof_gregset, "general-purpose" },
  { ".reg2", s390_sizeof_fpregset, "floating-point" },
  { ".reg-s390-last-break", 8, "s390 last-break address" },
  { ".reg-s390-system-call", 4, "s390 system-call" },
  { NULL, 0}
};

static struct core_regset_section s390_linux64_regset_sections[] =
{
  { ".reg", s390_sizeof_gregset, "general-purpose" },
  { ".reg2", s390_sizeof_fpregset, "floating-point" },
  { ".reg-s390-high-gprs", 16*4, "s390 GPR upper halves" },
  { NULL, 0}
};

static struct core_regset_section s390_linux64v1_regset_sections[] =
{
  { ".reg", s390_sizeof_gregset, "general-purpose" },
  { ".reg2", s390_sizeof_fpregset, "floating-point" },
  { ".reg-s390-high-gprs", 16*4, "s390 GPR upper halves" },
  { ".reg-s390-last-break", 8, "s930 last-break address" },
  { NULL, 0}
};

static struct core_regset_section s390_linux64v2_regset_sections[] =
{
  { ".reg", s390_sizeof_gregset, "general-purpose" },
  { ".reg2", s390_sizeof_fpregset, "floating-point" },
  { ".reg-s390-high-gprs", 16*4, "s390 GPR upper halves" },
  { ".reg-s390-last-break", 8, "s930 last-break address" },
  { ".reg-s390-system-call", 4, "s390 system-call" },
  { ".reg-s390-tdb", s390_sizeof_tdbregset, "s390 TDB" },
  { NULL, 0}
};

static struct core_regset_section s390x_linux64_regset_sections[] =
{
  { ".reg", s390x_sizeof_gregset, "general-purpose" },
  { ".reg2", s390_sizeof_fpregset, "floating-point" },
  { NULL, 0}
};

static struct core_regset_section s390x_linux64v1_regset_sections[] =
{
  { ".reg", s390x_sizeof_gregset, "general-purpose" },
  { ".reg2", s390_sizeof_fpregset, "floating-point" },
  { ".reg-s390-last-break", 8, "s930 last-break address" },
  { NULL, 0}
};

static struct core_regset_section s390x_linux64v2_regset_sections[] =
{
  { ".reg", s390x_sizeof_gregset, "general-purpose" },
  { ".reg2", s390_sizeof_fpregset, "floating-point" },
  { ".reg-s390-last-break", 8, "s930 last-break address" },
  { ".reg-s390-system-call", 4, "s390 system-call" },
  { ".reg-s390-tdb", s390_sizeof_tdbregset, "s390 TDB" },
  { NULL, 0}
};


/* Return the appropriate register set for the core section identified
   by SECT_NAME and SECT_SIZE.  */
static const struct regset *
s390_regset_from_core_section (struct gdbarch *gdbarch,
			       const char *sect_name, size_t sect_size)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (strcmp (sect_name, ".reg") == 0 && sect_size >= tdep->sizeof_gregset)
    return tdep->gregset;

  if (strcmp (sect_name, ".reg2") == 0 && sect_size >= tdep->sizeof_fpregset)
    return tdep->fpregset;

  if (strcmp (sect_name, ".reg-s390-high-gprs") == 0 && sect_size >= 16*4)
    return &s390_upper_regset;

  if (strcmp (sect_name, ".reg-s390-last-break") == 0 && sect_size >= 8)
    return (gdbarch_ptr_bit (gdbarch) == 32
	    ?  &s390_last_break_regset : &s390x_last_break_regset);

  if (strcmp (sect_name, ".reg-s390-system-call") == 0 && sect_size >= 4)
    return &s390_system_call_regset;

  if (strcmp (sect_name, ".reg-s390-tdb") == 0 && sect_size >= 256)
    return &s390_tdb_regset;

  return NULL;
}

static const struct target_desc *
s390_core_read_description (struct gdbarch *gdbarch,
			    struct target_ops *target, bfd *abfd)
{
  asection *high_gprs = bfd_get_section_by_name (abfd, ".reg-s390-high-gprs");
  asection *v1 = bfd_get_section_by_name (abfd, ".reg-s390-last-break");
  asection *v2 = bfd_get_section_by_name (abfd, ".reg-s390-system-call");
  asection *section = bfd_get_section_by_name (abfd, ".reg");
  CORE_ADDR hwcap = 0;

  target_auxv_search (target, AT_HWCAP, &hwcap);
  if (!section)
    return NULL;

  switch (bfd_section_size (abfd, section))
    {
    case s390_sizeof_gregset:
      if (high_gprs)
	return ((hwcap & HWCAP_S390_TE) ? tdesc_s390_te_linux64 :
		v2? tdesc_s390_linux64v2 :
		v1? tdesc_s390_linux64v1 : tdesc_s390_linux64);
      else
	return (v2? tdesc_s390_linux32v2 :
		v1? tdesc_s390_linux32v1 : tdesc_s390_linux32);

    case s390x_sizeof_gregset:
      return ((hwcap & HWCAP_S390_TE) ? tdesc_s390x_te_linux64 :
	      v2? tdesc_s390x_linux64v2 :
	      v1? tdesc_s390x_linux64v1 : tdesc_s390x_linux64);

    default:
      return NULL;
    }
}


/* Decoding S/390 instructions.  */

/* Named opcode values for the S/390 instructions we recognize.  Some
   instructions have their opcode split across two fields; those are the
   op1_* and op2_* enums.  */
enum
  {
    op1_lhi  = 0xa7,   op2_lhi  = 0x08,
    op1_lghi = 0xa7,   op2_lghi = 0x09,
    op1_lgfi = 0xc0,   op2_lgfi = 0x01,
    op_lr    = 0x18,
    op_lgr   = 0xb904,
    op_l     = 0x58,
    op1_ly   = 0xe3,   op2_ly   = 0x58,
    op1_lg   = 0xe3,   op2_lg   = 0x04,
    op_lm    = 0x98,
    op1_lmy  = 0xeb,   op2_lmy  = 0x98,
    op1_lmg  = 0xeb,   op2_lmg  = 0x04,
    op_st    = 0x50,
    op1_sty  = 0xe3,   op2_sty  = 0x50,
    op1_stg  = 0xe3,   op2_stg  = 0x24,
    op_std   = 0x60,
    op_stm   = 0x90,
    op1_stmy = 0xeb,   op2_stmy = 0x90,
    op1_stmg = 0xeb,   op2_stmg = 0x24,
    op1_aghi = 0xa7,   op2_aghi = 0x0b,
    op1_ahi  = 0xa7,   op2_ahi  = 0x0a,
    op1_agfi = 0xc2,   op2_agfi = 0x08,
    op1_afi  = 0xc2,   op2_afi  = 0x09,
    op1_algfi= 0xc2,   op2_algfi= 0x0a,
    op1_alfi = 0xc2,   op2_alfi = 0x0b,
    op_ar    = 0x1a,
    op_agr   = 0xb908,
    op_a     = 0x5a,
    op1_ay   = 0xe3,   op2_ay   = 0x5a,
    op1_ag   = 0xe3,   op2_ag   = 0x08,
    op1_slgfi= 0xc2,   op2_slgfi= 0x04,
    op1_slfi = 0xc2,   op2_slfi = 0x05,
    op_sr    = 0x1b,
    op_sgr   = 0xb909,
    op_s     = 0x5b,
    op1_sy   = 0xe3,   op2_sy   = 0x5b,
    op1_sg   = 0xe3,   op2_sg   = 0x09,
    op_nr    = 0x14,
    op_ngr   = 0xb980,
    op_la    = 0x41,
    op1_lay  = 0xe3,   op2_lay  = 0x71,
    op1_larl = 0xc0,   op2_larl = 0x00,
    op_basr  = 0x0d,
    op_bas   = 0x4d,
    op_bcr   = 0x07,
    op_bc    = 0x0d,
    op_bctr  = 0x06,
    op_bctgr = 0xb946,
    op_bct   = 0x46,
    op1_bctg = 0xe3,   op2_bctg = 0x46,
    op_bxh   = 0x86,
    op1_bxhg = 0xeb,   op2_bxhg = 0x44,
    op_bxle  = 0x87,
    op1_bxleg= 0xeb,   op2_bxleg= 0x45,
    op1_bras = 0xa7,   op2_bras = 0x05,
    op1_brasl= 0xc0,   op2_brasl= 0x05,
    op1_brc  = 0xa7,   op2_brc  = 0x04,
    op1_brcl = 0xc0,   op2_brcl = 0x04,
    op1_brct = 0xa7,   op2_brct = 0x06,
    op1_brctg= 0xa7,   op2_brctg= 0x07,
    op_brxh  = 0x84,
    op1_brxhg= 0xec,   op2_brxhg= 0x44,
    op_brxle = 0x85,
    op1_brxlg= 0xec,   op2_brxlg= 0x45,
  };


/* Read a single instruction from address AT.  */

#define S390_MAX_INSTR_SIZE 6
static int
s390_readinstruction (bfd_byte instr[], CORE_ADDR at)
{
  static int s390_instrlen[] = { 2, 4, 4, 6 };
  int instrlen;

  if (target_read_memory (at, &instr[0], 2))
    return -1;
  instrlen = s390_instrlen[instr[0] >> 6];
  if (instrlen > 2)
    {
      if (target_read_memory (at + 2, &instr[2], instrlen - 2))
        return -1;
    }
  return instrlen;
}


/* The functions below are for recognizing and decoding S/390
   instructions of various formats.  Each of them checks whether INSN
   is an instruction of the given format, with the specified opcodes.
   If it is, it sets the remaining arguments to the values of the
   instruction's fields, and returns a non-zero value; otherwise, it
   returns zero.

   These functions' arguments appear in the order they appear in the
   instruction, not in the machine-language form.  So, opcodes always
   come first, even though they're sometimes scattered around the
   instructions.  And displacements appear before base and extension
   registers, as they do in the assembly syntax, not at the end, as
   they do in the machine language.  */
static int
is_ri (bfd_byte *insn, int op1, int op2, unsigned int *r1, int *i2)
{
  if (insn[0] == op1 && (insn[1] & 0xf) == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      /* i2 is a 16-bit signed quantity.  */
      *i2 = (((insn[2] << 8) | insn[3]) ^ 0x8000) - 0x8000;
      return 1;
    }
  else
    return 0;
}


static int
is_ril (bfd_byte *insn, int op1, int op2,
        unsigned int *r1, int *i2)
{
  if (insn[0] == op1 && (insn[1] & 0xf) == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      /* i2 is a signed quantity.  If the host 'int' is 32 bits long,
         no sign extension is necessary, but we don't want to assume
         that.  */
      *i2 = (((insn[2] << 24)
              | (insn[3] << 16)
              | (insn[4] << 8)
              | (insn[5])) ^ 0x80000000) - 0x80000000;
      return 1;
    }
  else
    return 0;
}


static int
is_rr (bfd_byte *insn, int op, unsigned int *r1, unsigned int *r2)
{
  if (insn[0] == op)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *r2 = insn[1] & 0xf;
      return 1;
    }
  else
    return 0;
}


static int
is_rre (bfd_byte *insn, int op, unsigned int *r1, unsigned int *r2)
{
  if (((insn[0] << 8) | insn[1]) == op)
    {
      /* Yes, insn[3].  insn[2] is unused in RRE format.  */
      *r1 = (insn[3] >> 4) & 0xf;
      *r2 = insn[3] & 0xf;
      return 1;
    }
  else
    return 0;
}


static int
is_rs (bfd_byte *insn, int op,
       unsigned int *r1, unsigned int *r3, int *d2, unsigned int *b2)
{
  if (insn[0] == op)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *r3 = insn[1] & 0xf;
      *b2 = (insn[2] >> 4) & 0xf;
      *d2 = ((insn[2] & 0xf) << 8) | insn[3];
      return 1;
    }
  else
    return 0;
}


static int
is_rsy (bfd_byte *insn, int op1, int op2,
        unsigned int *r1, unsigned int *r3, int *d2, unsigned int *b2)
{
  if (insn[0] == op1
      && insn[5] == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *r3 = insn[1] & 0xf;
      *b2 = (insn[2] >> 4) & 0xf;
      /* The 'long displacement' is a 20-bit signed integer.  */
      *d2 = ((((insn[2] & 0xf) << 8) | insn[3] | (insn[4] << 12)) 
		^ 0x80000) - 0x80000;
      return 1;
    }
  else
    return 0;
}


static int
is_rsi (bfd_byte *insn, int op,
        unsigned int *r1, unsigned int *r3, int *i2)
{
  if (insn[0] == op)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *r3 = insn[1] & 0xf;
      /* i2 is a 16-bit signed quantity.  */
      *i2 = (((insn[2] << 8) | insn[3]) ^ 0x8000) - 0x8000;
      return 1;
    }
  else
    return 0;
}


static int
is_rie (bfd_byte *insn, int op1, int op2,
        unsigned int *r1, unsigned int *r3, int *i2)
{
  if (insn[0] == op1
      && insn[5] == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *r3 = insn[1] & 0xf;
      /* i2 is a 16-bit signed quantity.  */
      *i2 = (((insn[2] << 8) | insn[3]) ^ 0x8000) - 0x8000;
      return 1;
    }
  else
    return 0;
}


static int
is_rx (bfd_byte *insn, int op,
       unsigned int *r1, int *d2, unsigned int *x2, unsigned int *b2)
{
  if (insn[0] == op)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *x2 = insn[1] & 0xf;
      *b2 = (insn[2] >> 4) & 0xf;
      *d2 = ((insn[2] & 0xf) << 8) | insn[3];
      return 1;
    }
  else
    return 0;
}


static int
is_rxy (bfd_byte *insn, int op1, int op2,
        unsigned int *r1, int *d2, unsigned int *x2, unsigned int *b2)
{
  if (insn[0] == op1
      && insn[5] == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *x2 = insn[1] & 0xf;
      *b2 = (insn[2] >> 4) & 0xf;
      /* The 'long displacement' is a 20-bit signed integer.  */
      *d2 = ((((insn[2] & 0xf) << 8) | insn[3] | (insn[4] << 12)) 
		^ 0x80000) - 0x80000;
      return 1;
    }
  else
    return 0;
}


/* Prologue analysis.  */

#define S390_NUM_GPRS 16
#define S390_NUM_FPRS 16

struct s390_prologue_data {

  /* The stack.  */
  struct pv_area *stack;

  /* The size and byte-order of a GPR or FPR.  */
  int gpr_size;
  int fpr_size;
  enum bfd_endian byte_order;

  /* The general-purpose registers.  */
  pv_t gpr[S390_NUM_GPRS];

  /* The floating-point registers.  */
  pv_t fpr[S390_NUM_FPRS];

  /* The offset relative to the CFA where the incoming GPR N was saved
     by the function prologue.  0 if not saved or unknown.  */
  int gpr_slot[S390_NUM_GPRS];

  /* Likewise for FPRs.  */
  int fpr_slot[S390_NUM_FPRS];

  /* Nonzero if the backchain was saved.  This is assumed to be the
     case when the incoming SP is saved at the current SP location.  */
  int back_chain_saved_p;
};

/* Return the effective address for an X-style instruction, like:

        L R1, D2(X2, B2)

   Here, X2 and B2 are registers, and D2 is a signed 20-bit
   constant; the effective address is the sum of all three.  If either
   X2 or B2 are zero, then it doesn't contribute to the sum --- this
   means that r0 can't be used as either X2 or B2.  */
static pv_t
s390_addr (struct s390_prologue_data *data,
	   int d2, unsigned int x2, unsigned int b2)
{
  pv_t result;

  result = pv_constant (d2);
  if (x2)
    result = pv_add (result, data->gpr[x2]);
  if (b2)
    result = pv_add (result, data->gpr[b2]);

  return result;
}

/* Do a SIZE-byte store of VALUE to D2(X2,B2).  */
static void
s390_store (struct s390_prologue_data *data,
	    int d2, unsigned int x2, unsigned int b2, CORE_ADDR size,
	    pv_t value)
{
  pv_t addr = s390_addr (data, d2, x2, b2);
  pv_t offset;

  /* Check whether we are storing the backchain.  */
  offset = pv_subtract (data->gpr[S390_SP_REGNUM - S390_R0_REGNUM], addr);

  if (pv_is_constant (offset) && offset.k == 0)
    if (size == data->gpr_size
	&& pv_is_register_k (value, S390_SP_REGNUM, 0))
      {
	data->back_chain_saved_p = 1;
	return;
      }


  /* Check whether we are storing a register into the stack.  */
  if (!pv_area_store_would_trash (data->stack, addr))
    pv_area_store (data->stack, addr, size, value);


  /* Note: If this is some store we cannot identify, you might think we
     should forget our cached values, as any of those might have been hit.

     However, we make the assumption that the register save areas are only
     ever stored to once in any given function, and we do recognize these
     stores.  Thus every store we cannot recognize does not hit our data.  */
}

/* Do a SIZE-byte load from D2(X2,B2).  */
static pv_t
s390_load (struct s390_prologue_data *data,
	   int d2, unsigned int x2, unsigned int b2, CORE_ADDR size)
	   
{
  pv_t addr = s390_addr (data, d2, x2, b2);

  /* If it's a load from an in-line constant pool, then we can
     simulate that, under the assumption that the code isn't
     going to change between the time the processor actually
     executed it creating the current frame, and the time when
     we're analyzing the code to unwind past that frame.  */
  if (pv_is_constant (addr))
    {
      struct target_section *secp;
      secp = target_section_by_addr (&current_target, addr.k);
      if (secp != NULL
          && (bfd_get_section_flags (secp->the_bfd_section->owner,
				     secp->the_bfd_section)
              & SEC_READONLY))
        return pv_constant (read_memory_integer (addr.k, size,
						 data->byte_order));
    }

  /* Check whether we are accessing one of our save slots.  */
  return pv_area_fetch (data->stack, addr, size);
}

/* Function for finding saved registers in a 'struct pv_area'; we pass
   this to pv_area_scan.

   If VALUE is a saved register, ADDR says it was saved at a constant
   offset from the frame base, and SIZE indicates that the whole
   register was saved, record its offset in the reg_offset table in
   PROLOGUE_UNTYPED.  */
static void
s390_check_for_saved (void *data_untyped, pv_t addr,
		      CORE_ADDR size, pv_t value)
{
  struct s390_prologue_data *data = data_untyped;
  int i, offset;

  if (!pv_is_register (addr, S390_SP_REGNUM))
    return;

  offset = 16 * data->gpr_size + 32 - addr.k;

  /* If we are storing the original value of a register, we want to
     record the CFA offset.  If the same register is stored multiple
     times, the stack slot with the highest address counts.  */
 
  for (i = 0; i < S390_NUM_GPRS; i++)
    if (size == data->gpr_size
	&& pv_is_register_k (value, S390_R0_REGNUM + i, 0))
      if (data->gpr_slot[i] == 0
	  || data->gpr_slot[i] > offset)
	{
	  data->gpr_slot[i] = offset;
	  return;
	}

  for (i = 0; i < S390_NUM_FPRS; i++)
    if (size == data->fpr_size
	&& pv_is_register_k (value, S390_F0_REGNUM + i, 0))
      if (data->fpr_slot[i] == 0
	  || data->fpr_slot[i] > offset)
	{
	  data->fpr_slot[i] = offset;
	  return;
	}
}

/* Analyze the prologue of the function starting at START_PC,
   continuing at most until CURRENT_PC.  Initialize DATA to
   hold all information we find out about the state of the registers
   and stack slots.  Return the address of the instruction after
   the last one that changed the SP, FP, or back chain; or zero
   on error.  */
static CORE_ADDR
s390_analyze_prologue (struct gdbarch *gdbarch,
		       CORE_ADDR start_pc,
		       CORE_ADDR current_pc,
		       struct s390_prologue_data *data)
{
  int word_size = gdbarch_ptr_bit (gdbarch) / 8;

  /* Our return value:
     The address of the instruction after the last one that changed
     the SP, FP, or back chain;  zero if we got an error trying to 
     read memory.  */
  CORE_ADDR result = start_pc;

  /* The current PC for our abstract interpretation.  */
  CORE_ADDR pc;

  /* The address of the next instruction after that.  */
  CORE_ADDR next_pc;
  
  /* Set up everything's initial value.  */
  {
    int i;

    data->stack = make_pv_area (S390_SP_REGNUM, gdbarch_addr_bit (gdbarch));

    /* For the purpose of prologue tracking, we consider the GPR size to
       be equal to the ABI word size, even if it is actually larger
       (i.e. when running a 32-bit binary under a 64-bit kernel).  */
    data->gpr_size = word_size;
    data->fpr_size = 8;
    data->byte_order = gdbarch_byte_order (gdbarch);

    for (i = 0; i < S390_NUM_GPRS; i++)
      data->gpr[i] = pv_register (S390_R0_REGNUM + i, 0);

    for (i = 0; i < S390_NUM_FPRS; i++)
      data->fpr[i] = pv_register (S390_F0_REGNUM + i, 0);

    for (i = 0; i < S390_NUM_GPRS; i++)
      data->gpr_slot[i]  = 0;

    for (i = 0; i < S390_NUM_FPRS; i++)
      data->fpr_slot[i]  = 0;

    data->back_chain_saved_p = 0;
  }

  /* Start interpreting instructions, until we hit the frame's
     current PC or the first branch instruction.  */
  for (pc = start_pc; pc > 0 && pc < current_pc; pc = next_pc)
    {
      bfd_byte insn[S390_MAX_INSTR_SIZE];
      int insn_len = s390_readinstruction (insn, pc);

      bfd_byte dummy[S390_MAX_INSTR_SIZE] = { 0 };
      bfd_byte *insn32 = word_size == 4 ? insn : dummy;
      bfd_byte *insn64 = word_size == 8 ? insn : dummy;

      /* Fields for various kinds of instructions.  */
      unsigned int b2, r1, r2, x2, r3;
      int i2, d2;

      /* The values of SP and FP before this instruction,
         for detecting instructions that change them.  */
      pv_t pre_insn_sp, pre_insn_fp;
      /* Likewise for the flag whether the back chain was saved.  */
      int pre_insn_back_chain_saved_p;

      /* If we got an error trying to read the instruction, report it.  */
      if (insn_len < 0)
        {
          result = 0;
          break;
        }

      next_pc = pc + insn_len;

      pre_insn_sp = data->gpr[S390_SP_REGNUM - S390_R0_REGNUM];
      pre_insn_fp = data->gpr[S390_FRAME_REGNUM - S390_R0_REGNUM];
      pre_insn_back_chain_saved_p = data->back_chain_saved_p;


      /* LHI r1, i2 --- load halfword immediate.  */
      /* LGHI r1, i2 --- load halfword immediate (64-bit version).  */
      /* LGFI r1, i2 --- load fullword immediate.  */
      if (is_ri (insn32, op1_lhi, op2_lhi, &r1, &i2)
          || is_ri (insn64, op1_lghi, op2_lghi, &r1, &i2)
          || is_ril (insn, op1_lgfi, op2_lgfi, &r1, &i2))
	data->gpr[r1] = pv_constant (i2);

      /* LR r1, r2 --- load from register.  */
      /* LGR r1, r2 --- load from register (64-bit version).  */
      else if (is_rr (insn32, op_lr, &r1, &r2)
	       || is_rre (insn64, op_lgr, &r1, &r2))
	data->gpr[r1] = data->gpr[r2];

      /* L r1, d2(x2, b2) --- load.  */
      /* LY r1, d2(x2, b2) --- load (long-displacement version).  */
      /* LG r1, d2(x2, b2) --- load (64-bit version).  */
      else if (is_rx (insn32, op_l, &r1, &d2, &x2, &b2)
	       || is_rxy (insn32, op1_ly, op2_ly, &r1, &d2, &x2, &b2)
	       || is_rxy (insn64, op1_lg, op2_lg, &r1, &d2, &x2, &b2))
	data->gpr[r1] = s390_load (data, d2, x2, b2, data->gpr_size);

      /* ST r1, d2(x2, b2) --- store.  */
      /* STY r1, d2(x2, b2) --- store (long-displacement version).  */
      /* STG r1, d2(x2, b2) --- store (64-bit version).  */
      else if (is_rx (insn32, op_st, &r1, &d2, &x2, &b2)
	       || is_rxy (insn32, op1_sty, op2_sty, &r1, &d2, &x2, &b2)
	       || is_rxy (insn64, op1_stg, op2_stg, &r1, &d2, &x2, &b2))
	s390_store (data, d2, x2, b2, data->gpr_size, data->gpr[r1]);

      /* STD r1, d2(x2,b2) --- store floating-point register.  */
      else if (is_rx (insn, op_std, &r1, &d2, &x2, &b2))
	s390_store (data, d2, x2, b2, data->fpr_size, data->fpr[r1]);

      /* STM r1, r3, d2(b2) --- store multiple.  */
      /* STMY r1, r3, d2(b2) --- store multiple (long-displacement
	 version).  */
      /* STMG r1, r3, d2(b2) --- store multiple (64-bit version).  */
      else if (is_rs (insn32, op_stm, &r1, &r3, &d2, &b2)
	       || is_rsy (insn32, op1_stmy, op2_stmy, &r1, &r3, &d2, &b2)
	       || is_rsy (insn64, op1_stmg, op2_stmg, &r1, &r3, &d2, &b2))
        {
          for (; r1 <= r3; r1++, d2 += data->gpr_size)
	    s390_store (data, d2, 0, b2, data->gpr_size, data->gpr[r1]);
        }

      /* AHI r1, i2 --- add halfword immediate.  */
      /* AGHI r1, i2 --- add halfword immediate (64-bit version).  */
      /* AFI r1, i2 --- add fullword immediate.  */
      /* AGFI r1, i2 --- add fullword immediate (64-bit version).  */
      else if (is_ri (insn32, op1_ahi, op2_ahi, &r1, &i2)
	       || is_ri (insn64, op1_aghi, op2_aghi, &r1, &i2)
	       || is_ril (insn32, op1_afi, op2_afi, &r1, &i2)
	       || is_ril (insn64, op1_agfi, op2_agfi, &r1, &i2))
	data->gpr[r1] = pv_add_constant (data->gpr[r1], i2);

      /* ALFI r1, i2 --- add logical immediate.  */
      /* ALGFI r1, i2 --- add logical immediate (64-bit version).  */
      else if (is_ril (insn32, op1_alfi, op2_alfi, &r1, &i2)
	       || is_ril (insn64, op1_algfi, op2_algfi, &r1, &i2))
	data->gpr[r1] = pv_add_constant (data->gpr[r1],
					 (CORE_ADDR)i2 & 0xffffffff);

      /* AR r1, r2 -- add register.  */
      /* AGR r1, r2 -- add register (64-bit version).  */
      else if (is_rr (insn32, op_ar, &r1, &r2)
	       || is_rre (insn64, op_agr, &r1, &r2))
	data->gpr[r1] = pv_add (data->gpr[r1], data->gpr[r2]);

      /* A r1, d2(x2, b2) -- add.  */
      /* AY r1, d2(x2, b2) -- add (long-displacement version).  */
      /* AG r1, d2(x2, b2) -- add (64-bit version).  */
      else if (is_rx (insn32, op_a, &r1, &d2, &x2, &b2)
	       || is_rxy (insn32, op1_ay, op2_ay, &r1, &d2, &x2, &b2)
	       || is_rxy (insn64, op1_ag, op2_ag, &r1, &d2, &x2, &b2))
	data->gpr[r1] = pv_add (data->gpr[r1],
				s390_load (data, d2, x2, b2, data->gpr_size));

      /* SLFI r1, i2 --- subtract logical immediate.  */
      /* SLGFI r1, i2 --- subtract logical immediate (64-bit version).  */
      else if (is_ril (insn32, op1_slfi, op2_slfi, &r1, &i2)
	       || is_ril (insn64, op1_slgfi, op2_slgfi, &r1, &i2))
	data->gpr[r1] = pv_add_constant (data->gpr[r1],
					 -((CORE_ADDR)i2 & 0xffffffff));

      /* SR r1, r2 -- subtract register.  */
      /* SGR r1, r2 -- subtract register (64-bit version).  */
      else if (is_rr (insn32, op_sr, &r1, &r2)
	       || is_rre (insn64, op_sgr, &r1, &r2))
	data->gpr[r1] = pv_subtract (data->gpr[r1], data->gpr[r2]);

      /* S r1, d2(x2, b2) -- subtract.  */
      /* SY r1, d2(x2, b2) -- subtract (long-displacement version).  */
      /* SG r1, d2(x2, b2) -- subtract (64-bit version).  */
      else if (is_rx (insn32, op_s, &r1, &d2, &x2, &b2)
	       || is_rxy (insn32, op1_sy, op2_sy, &r1, &d2, &x2, &b2)
	       || is_rxy (insn64, op1_sg, op2_sg, &r1, &d2, &x2, &b2))
	data->gpr[r1] = pv_subtract (data->gpr[r1],
				s390_load (data, d2, x2, b2, data->gpr_size));

      /* LA r1, d2(x2, b2) --- load address.  */
      /* LAY r1, d2(x2, b2) --- load address (long-displacement version).  */
      else if (is_rx (insn, op_la, &r1, &d2, &x2, &b2)
               || is_rxy (insn, op1_lay, op2_lay, &r1, &d2, &x2, &b2))
	data->gpr[r1] = s390_addr (data, d2, x2, b2);

      /* LARL r1, i2 --- load address relative long.  */
      else if (is_ril (insn, op1_larl, op2_larl, &r1, &i2))
	data->gpr[r1] = pv_constant (pc + i2 * 2);

      /* BASR r1, 0 --- branch and save.
         Since r2 is zero, this saves the PC in r1, but doesn't branch.  */
      else if (is_rr (insn, op_basr, &r1, &r2)
               && r2 == 0)
	data->gpr[r1] = pv_constant (next_pc);

      /* BRAS r1, i2 --- branch relative and save.  */
      else if (is_ri (insn, op1_bras, op2_bras, &r1, &i2))
        {
          data->gpr[r1] = pv_constant (next_pc);
          next_pc = pc + i2 * 2;

          /* We'd better not interpret any backward branches.  We'll
             never terminate.  */
          if (next_pc <= pc)
            break;
        }

      /* Terminate search when hitting any other branch instruction.  */
      else if (is_rr (insn, op_basr, &r1, &r2)
	       || is_rx (insn, op_bas, &r1, &d2, &x2, &b2)
	       || is_rr (insn, op_bcr, &r1, &r2)
	       || is_rx (insn, op_bc, &r1, &d2, &x2, &b2)
	       || is_ri (insn, op1_brc, op2_brc, &r1, &i2)
	       || is_ril (insn, op1_brcl, op2_brcl, &r1, &i2)
	       || is_ril (insn, op1_brasl, op2_brasl, &r2, &i2))
	break;

      else
	{
	  /* An instruction we don't know how to simulate.  The only
	     safe thing to do would be to set every value we're tracking
	     to 'unknown'.  Instead, we'll be optimistic: we assume that
	     we *can* interpret every instruction that the compiler uses
	     to manipulate any of the data we're interested in here --
	     then we can just ignore anything else.  */
	}

      /* Record the address after the last instruction that changed
         the FP, SP, or backlink.  Ignore instructions that changed
         them back to their original values --- those are probably
         restore instructions.  (The back chain is never restored,
         just popped.)  */
      {
        pv_t sp = data->gpr[S390_SP_REGNUM - S390_R0_REGNUM];
        pv_t fp = data->gpr[S390_FRAME_REGNUM - S390_R0_REGNUM];
        
        if ((! pv_is_identical (pre_insn_sp, sp)
             && ! pv_is_register_k (sp, S390_SP_REGNUM, 0)
	     && sp.kind != pvk_unknown)
            || (! pv_is_identical (pre_insn_fp, fp)
                && ! pv_is_register_k (fp, S390_FRAME_REGNUM, 0)
		&& fp.kind != pvk_unknown)
            || pre_insn_back_chain_saved_p != data->back_chain_saved_p)
          result = next_pc;
      }
    }

  /* Record where all the registers were saved.  */
  pv_area_scan (data->stack, s390_check_for_saved, data);

  free_pv_area (data->stack);
  data->stack = NULL;

  return result;
}

/* Advance PC across any function entry prologue instructions to reach 
   some "real" code.  */
static CORE_ADDR
s390_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  struct s390_prologue_data data;
  CORE_ADDR skip_pc;
  skip_pc = s390_analyze_prologue (gdbarch, pc, (CORE_ADDR)-1, &data);
  return skip_pc ? skip_pc : pc;
}

/* Return true if we are in the functin's epilogue, i.e. after the
   instruction that destroyed the function's stack frame.  */
static int
s390_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  int word_size = gdbarch_ptr_bit (gdbarch) / 8;

  /* In frameless functions, there's not frame to destroy and thus
     we don't care about the epilogue.

     In functions with frame, the epilogue sequence is a pair of
     a LM-type instruction that restores (amongst others) the
     return register %r14 and the stack pointer %r15, followed
     by a branch 'br %r14' --or equivalent-- that effects the
     actual return.

     In that situation, this function needs to return 'true' in
     exactly one case: when pc points to that branch instruction.

     Thus we try to disassemble the one instructions immediately
     preceding pc and check whether it is an LM-type instruction
     modifying the stack pointer.

     Note that disassembling backwards is not reliable, so there
     is a slight chance of false positives here ...  */

  bfd_byte insn[6];
  unsigned int r1, r3, b2;
  int d2;

  if (word_size == 4
      && !target_read_memory (pc - 4, insn, 4)
      && is_rs (insn, op_lm, &r1, &r3, &d2, &b2)
      && r3 == S390_SP_REGNUM - S390_R0_REGNUM)
    return 1;

  if (word_size == 4
      && !target_read_memory (pc - 6, insn, 6)
      && is_rsy (insn, op1_lmy, op2_lmy, &r1, &r3, &d2, &b2)
      && r3 == S390_SP_REGNUM - S390_R0_REGNUM)
    return 1;

  if (word_size == 8
      && !target_read_memory (pc - 6, insn, 6)
      && is_rsy (insn, op1_lmg, op2_lmg, &r1, &r3, &d2, &b2)
      && r3 == S390_SP_REGNUM - S390_R0_REGNUM)
    return 1;

  return 0;
}

/* Displaced stepping.  */

/* Fix up the state of registers and memory after having single-stepped
   a displaced instruction.  */
static void
s390_displaced_step_fixup (struct gdbarch *gdbarch,
			   struct displaced_step_closure *closure,
			   CORE_ADDR from, CORE_ADDR to,
			   struct regcache *regs)
{
  /* Since we use simple_displaced_step_copy_insn, our closure is a
     copy of the instruction.  */
  gdb_byte *insn = (gdb_byte *) closure;
  static int s390_instrlen[] = { 2, 4, 4, 6 };
  int insnlen = s390_instrlen[insn[0] >> 6];

  /* Fields for various kinds of instructions.  */
  unsigned int b2, r1, r2, x2, r3;
  int i2, d2;

  /* Get current PC and addressing mode bit.  */
  CORE_ADDR pc = regcache_read_pc (regs);
  ULONGEST amode = 0;

  if (register_size (gdbarch, S390_PSWA_REGNUM) == 4)
    {
      regcache_cooked_read_unsigned (regs, S390_PSWA_REGNUM, &amode);
      amode &= 0x80000000;
    }

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog,
			"displaced: (s390) fixup (%s, %s) pc %s len %d amode 0x%x\n",
			paddress (gdbarch, from), paddress (gdbarch, to),
			paddress (gdbarch, pc), insnlen, (int) amode);

  /* Handle absolute branch and save instructions.  */
  if (is_rr (insn, op_basr, &r1, &r2)
      || is_rx (insn, op_bas, &r1, &d2, &x2, &b2))
    {
      /* Recompute saved return address in R1.  */
      regcache_cooked_write_unsigned (regs, S390_R0_REGNUM + r1,
				      amode | (from + insnlen));
    }

  /* Handle absolute branch instructions.  */
  else if (is_rr (insn, op_bcr, &r1, &r2)
	   || is_rx (insn, op_bc, &r1, &d2, &x2, &b2)
	   || is_rr (insn, op_bctr, &r1, &r2)
	   || is_rre (insn, op_bctgr, &r1, &r2)
	   || is_rx (insn, op_bct, &r1, &d2, &x2, &b2)
	   || is_rxy (insn, op1_bctg, op2_brctg, &r1, &d2, &x2, &b2)
	   || is_rs (insn, op_bxh, &r1, &r3, &d2, &b2)
	   || is_rsy (insn, op1_bxhg, op2_bxhg, &r1, &r3, &d2, &b2)
	   || is_rs (insn, op_bxle, &r1, &r3, &d2, &b2)
	   || is_rsy (insn, op1_bxleg, op2_bxleg, &r1, &r3, &d2, &b2))
    {
      /* Update PC iff branch was *not* taken.  */
      if (pc == to + insnlen)
	regcache_write_pc (regs, from + insnlen);
    }

  /* Handle PC-relative branch and save instructions.  */
  else if (is_ri (insn, op1_bras, op2_bras, &r1, &i2)
           || is_ril (insn, op1_brasl, op2_brasl, &r1, &i2))
    {
      /* Update PC.  */
      regcache_write_pc (regs, pc - to + from);
      /* Recompute saved return address in R1.  */
      regcache_cooked_write_unsigned (regs, S390_R0_REGNUM + r1,
				      amode | (from + insnlen));
    }

  /* Handle PC-relative branch instructions.  */
  else if (is_ri (insn, op1_brc, op2_brc, &r1, &i2)
	   || is_ril (insn, op1_brcl, op2_brcl, &r1, &i2)
	   || is_ri (insn, op1_brct, op2_brct, &r1, &i2)
	   || is_ri (insn, op1_brctg, op2_brctg, &r1, &i2)
	   || is_rsi (insn, op_brxh, &r1, &r3, &i2)
	   || is_rie (insn, op1_brxhg, op2_brxhg, &r1, &r3, &i2)
	   || is_rsi (insn, op_brxle, &r1, &r3, &i2)
	   || is_rie (insn, op1_brxlg, op2_brxlg, &r1, &r3, &i2))
    {
      /* Update PC.  */
      regcache_write_pc (regs, pc - to + from);
    }

  /* Handle LOAD ADDRESS RELATIVE LONG.  */
  else if (is_ril (insn, op1_larl, op2_larl, &r1, &i2))
    {
      /* Update PC.  */
      regcache_write_pc (regs, from + insnlen);
      /* Recompute output address in R1.  */ 
      regcache_cooked_write_unsigned (regs, S390_R0_REGNUM + r1,
				      amode | (from + i2 * 2));
    }

  /* If we executed a breakpoint instruction, point PC right back at it.  */
  else if (insn[0] == 0x0 && insn[1] == 0x1)
    regcache_write_pc (regs, from);

  /* For any other insn, PC points right after the original instruction.  */
  else
    regcache_write_pc (regs, from + insnlen);

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog,
			"displaced: (s390) pc is now %s\n",
			paddress (gdbarch, regcache_read_pc (regs)));
}


/* Helper routine to unwind pseudo registers.  */

static struct value *
s390_unwind_pseudo_register (struct frame_info *this_frame, int regnum)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  struct type *type = register_type (gdbarch, regnum);

  /* Unwind PC via PSW address.  */
  if (regnum == tdep->pc_regnum)
    {
      struct value *val;

      val = frame_unwind_register_value (this_frame, S390_PSWA_REGNUM);
      if (!value_optimized_out (val))
	{
	  LONGEST pswa = value_as_long (val);

	  if (TYPE_LENGTH (type) == 4)
	    return value_from_pointer (type, pswa & 0x7fffffff);
	  else
	    return value_from_pointer (type, pswa);
	}
    }

  /* Unwind CC via PSW mask.  */
  if (regnum == tdep->cc_regnum)
    {
      struct value *val;

      val = frame_unwind_register_value (this_frame, S390_PSWM_REGNUM);
      if (!value_optimized_out (val))
	{
	  LONGEST pswm = value_as_long (val);

	  if (TYPE_LENGTH (type) == 4)
	    return value_from_longest (type, (pswm >> 12) & 3);
	  else
	    return value_from_longest (type, (pswm >> 44) & 3);
	}
    }

  /* Unwind full GPRs to show at least the lower halves (as the
     upper halves are undefined).  */
  if (regnum_is_gpr_full (tdep, regnum))
    {
      int reg = regnum - tdep->gpr_full_regnum;
      struct value *val;

      val = frame_unwind_register_value (this_frame, S390_R0_REGNUM + reg);
      if (!value_optimized_out (val))
	return value_cast (type, val);
    }

  return allocate_optimized_out_value (type);
}

static struct value *
s390_trad_frame_prev_register (struct frame_info *this_frame,
			       struct trad_frame_saved_reg saved_regs[],
			       int regnum)
{
  if (regnum < S390_NUM_REGS)
    return trad_frame_get_prev_register (this_frame, saved_regs, regnum);
  else
    return s390_unwind_pseudo_register (this_frame, regnum);
}


/* Normal stack frames.  */

struct s390_unwind_cache {

  CORE_ADDR func;
  CORE_ADDR frame_base;
  CORE_ADDR local_base;

  struct trad_frame_saved_reg *saved_regs;
};

static int
s390_prologue_frame_unwind_cache (struct frame_info *this_frame,
				  struct s390_unwind_cache *info)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  int word_size = gdbarch_ptr_bit (gdbarch) / 8;
  struct s390_prologue_data data;
  pv_t *fp = &data.gpr[S390_FRAME_REGNUM - S390_R0_REGNUM];
  pv_t *sp = &data.gpr[S390_SP_REGNUM - S390_R0_REGNUM];
  int i;
  CORE_ADDR cfa;
  CORE_ADDR func;
  CORE_ADDR result;
  ULONGEST reg;
  CORE_ADDR prev_sp;
  int frame_pointer;
  int size;
  struct frame_info *next_frame;

  /* Try to find the function start address.  If we can't find it, we don't
     bother searching for it -- with modern compilers this would be mostly
     pointless anyway.  Trust that we'll either have valid DWARF-2 CFI data
     or else a valid backchain ...  */
  func = get_frame_func (this_frame);
  if (!func)
    return 0;

  /* Try to analyze the prologue.  */
  result = s390_analyze_prologue (gdbarch, func,
				  get_frame_pc (this_frame), &data);
  if (!result)
    return 0;

  /* If this was successful, we should have found the instruction that
     sets the stack pointer register to the previous value of the stack 
     pointer minus the frame size.  */
  if (!pv_is_register (*sp, S390_SP_REGNUM))
    return 0;

  /* A frame size of zero at this point can mean either a real 
     frameless function, or else a failure to find the prologue.
     Perform some sanity checks to verify we really have a 
     frameless function.  */
  if (sp->k == 0)
    {
      /* If the next frame is a NORMAL_FRAME, this frame *cannot* have frame 
	 size zero.  This is only possible if the next frame is a sentinel 
	 frame, a dummy frame, or a signal trampoline frame.  */
      /* FIXME: cagney/2004-05-01: This sanity check shouldn't be
	 needed, instead the code should simpliy rely on its
	 analysis.  */
      next_frame = get_next_frame (this_frame);
      while (next_frame && get_frame_type (next_frame) == INLINE_FRAME)
	next_frame = get_next_frame (next_frame);
      if (next_frame
	  && get_frame_type (get_next_frame (this_frame)) == NORMAL_FRAME)
	return 0;

      /* If we really have a frameless function, %r14 must be valid
	 -- in particular, it must point to a different function.  */
      reg = get_frame_register_unsigned (this_frame, S390_RETADDR_REGNUM);
      reg = gdbarch_addr_bits_remove (gdbarch, reg) - 1;
      if (get_pc_function_start (reg) == func)
	{
	  /* However, there is one case where it *is* valid for %r14
	     to point to the same function -- if this is a recursive
	     call, and we have stopped in the prologue *before* the
	     stack frame was allocated.

	     Recognize this case by looking ahead a bit ...  */

	  struct s390_prologue_data data2;
	  pv_t *sp = &data2.gpr[S390_SP_REGNUM - S390_R0_REGNUM];

	  if (!(s390_analyze_prologue (gdbarch, func, (CORE_ADDR)-1, &data2)
	        && pv_is_register (*sp, S390_SP_REGNUM)
	        && sp->k != 0))
	    return 0;
	}
    }


  /* OK, we've found valid prologue data.  */
  size = -sp->k;

  /* If the frame pointer originally also holds the same value
     as the stack pointer, we're probably using it.  If it holds
     some other value -- even a constant offset -- it is most
     likely used as temp register.  */
  if (pv_is_identical (*sp, *fp))
    frame_pointer = S390_FRAME_REGNUM;
  else
    frame_pointer = S390_SP_REGNUM;

  /* If we've detected a function with stack frame, we'll still have to 
     treat it as frameless if we're currently within the function epilog 
     code at a point where the frame pointer has already been restored.
     This can only happen in an innermost frame.  */
  /* FIXME: cagney/2004-05-01: This sanity check shouldn't be needed,
     instead the code should simpliy rely on its analysis.  */
  next_frame = get_next_frame (this_frame);
  while (next_frame && get_frame_type (next_frame) == INLINE_FRAME)
    next_frame = get_next_frame (next_frame);
  if (size > 0
      && (next_frame == NULL
	  || get_frame_type (get_next_frame (this_frame)) != NORMAL_FRAME))
    {
      /* See the comment in s390_in_function_epilogue_p on why this is
	 not completely reliable ...  */
      if (s390_in_function_epilogue_p (gdbarch, get_frame_pc (this_frame)))
	{
	  memset (&data, 0, sizeof (data));
	  size = 0;
	  frame_pointer = S390_SP_REGNUM;
	}
    }

  /* Once we know the frame register and the frame size, we can unwind
     the current value of the frame register from the next frame, and
     add back the frame size to arrive that the previous frame's 
     stack pointer value.  */
  prev_sp = get_frame_register_unsigned (this_frame, frame_pointer) + size;
  cfa = prev_sp + 16*word_size + 32;

  /* Set up ABI call-saved/call-clobbered registers.  */
  for (i = 0; i < S390_NUM_REGS; i++)
    if (!s390_register_call_saved (gdbarch, i))
      trad_frame_set_unknown (info->saved_regs, i);

  /* CC is always call-clobbered.  */
  trad_frame_set_unknown (info->saved_regs, S390_PSWM_REGNUM);

  /* Record the addresses of all register spill slots the prologue parser
     has recognized.  Consider only registers defined as call-saved by the
     ABI; for call-clobbered registers the parser may have recognized
     spurious stores.  */

  for (i = 0; i < 16; i++)
    if (s390_register_call_saved (gdbarch, S390_R0_REGNUM + i)
	&& data.gpr_slot[i] != 0)
      info->saved_regs[S390_R0_REGNUM + i].addr = cfa - data.gpr_slot[i];

  for (i = 0; i < 16; i++)
    if (s390_register_call_saved (gdbarch, S390_F0_REGNUM + i)
	&& data.fpr_slot[i] != 0)
      info->saved_regs[S390_F0_REGNUM + i].addr = cfa - data.fpr_slot[i];

  /* Function return will set PC to %r14.  */
  info->saved_regs[S390_PSWA_REGNUM] = info->saved_regs[S390_RETADDR_REGNUM];

  /* In frameless functions, we unwind simply by moving the return
     address to the PC.  However, if we actually stored to the
     save area, use that -- we might only think the function frameless
     because we're in the middle of the prologue ...  */
  if (size == 0
      && !trad_frame_addr_p (info->saved_regs, S390_PSWA_REGNUM))
    {
      info->saved_regs[S390_PSWA_REGNUM].realreg = S390_RETADDR_REGNUM;
    }

  /* Another sanity check: unless this is a frameless function,
     we should have found spill slots for SP and PC.
     If not, we cannot unwind further -- this happens e.g. in
     libc's thread_start routine.  */
  if (size > 0)
    {
      if (!trad_frame_addr_p (info->saved_regs, S390_SP_REGNUM)
	  || !trad_frame_addr_p (info->saved_regs, S390_PSWA_REGNUM))
	prev_sp = -1;
    }

  /* We use the current value of the frame register as local_base,
     and the top of the register save area as frame_base.  */
  if (prev_sp != -1)
    {
      info->frame_base = prev_sp + 16*word_size + 32;
      info->local_base = prev_sp - size;
    }

  info->func = func;
  return 1;
}

static void
s390_backchain_frame_unwind_cache (struct frame_info *this_frame,
				   struct s390_unwind_cache *info)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  int word_size = gdbarch_ptr_bit (gdbarch) / 8;
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR backchain;
  ULONGEST reg;
  LONGEST sp;
  int i;

  /* Set up ABI call-saved/call-clobbered registers.  */
  for (i = 0; i < S390_NUM_REGS; i++)
    if (!s390_register_call_saved (gdbarch, i))
      trad_frame_set_unknown (info->saved_regs, i);

  /* CC is always call-clobbered.  */
  trad_frame_set_unknown (info->saved_regs, S390_PSWM_REGNUM);

  /* Get the backchain.  */
  reg = get_frame_register_unsigned (this_frame, S390_SP_REGNUM);
  backchain = read_memory_unsigned_integer (reg, word_size, byte_order);

  /* A zero backchain terminates the frame chain.  As additional
     sanity check, let's verify that the spill slot for SP in the
     save area pointed to by the backchain in fact links back to
     the save area.  */
  if (backchain != 0
      && safe_read_memory_integer (backchain + 15*word_size,
				   word_size, byte_order, &sp)
      && (CORE_ADDR)sp == backchain)
    {
      /* We don't know which registers were saved, but it will have
         to be at least %r14 and %r15.  This will allow us to continue
         unwinding, but other prev-frame registers may be incorrect ...  */
      info->saved_regs[S390_SP_REGNUM].addr = backchain + 15*word_size;
      info->saved_regs[S390_RETADDR_REGNUM].addr = backchain + 14*word_size;

      /* Function return will set PC to %r14.  */
      info->saved_regs[S390_PSWA_REGNUM]
	= info->saved_regs[S390_RETADDR_REGNUM];

      /* We use the current value of the frame register as local_base,
         and the top of the register save area as frame_base.  */
      info->frame_base = backchain + 16*word_size + 32;
      info->local_base = reg;
    }

  info->func = get_frame_pc (this_frame);
}

static struct s390_unwind_cache *
s390_frame_unwind_cache (struct frame_info *this_frame,
			 void **this_prologue_cache)
{
  struct s390_unwind_cache *info;
  if (*this_prologue_cache)
    return *this_prologue_cache;

  info = FRAME_OBSTACK_ZALLOC (struct s390_unwind_cache);
  *this_prologue_cache = info;
  info->saved_regs = trad_frame_alloc_saved_regs (this_frame);
  info->func = -1;
  info->frame_base = -1;
  info->local_base = -1;

  /* Try to use prologue analysis to fill the unwind cache.
     If this fails, fall back to reading the stack backchain.  */
  if (!s390_prologue_frame_unwind_cache (this_frame, info))
    s390_backchain_frame_unwind_cache (this_frame, info);

  return info;
}

static void
s390_frame_this_id (struct frame_info *this_frame,
		    void **this_prologue_cache,
		    struct frame_id *this_id)
{
  struct s390_unwind_cache *info
    = s390_frame_unwind_cache (this_frame, this_prologue_cache);

  if (info->frame_base == -1)
    return;

  *this_id = frame_id_build (info->frame_base, info->func);
}

static struct value *
s390_frame_prev_register (struct frame_info *this_frame,
			  void **this_prologue_cache, int regnum)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct s390_unwind_cache *info
    = s390_frame_unwind_cache (this_frame, this_prologue_cache);

  return s390_trad_frame_prev_register (this_frame, info->saved_regs, regnum);
}

static const struct frame_unwind s390_frame_unwind = {
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  s390_frame_this_id,
  s390_frame_prev_register,
  NULL,
  default_frame_sniffer
};


/* Code stubs and their stack frames.  For things like PLTs and NULL
   function calls (where there is no true frame and the return address
   is in the RETADDR register).  */

struct s390_stub_unwind_cache
{
  CORE_ADDR frame_base;
  struct trad_frame_saved_reg *saved_regs;
};

static struct s390_stub_unwind_cache *
s390_stub_frame_unwind_cache (struct frame_info *this_frame,
			      void **this_prologue_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  int word_size = gdbarch_ptr_bit (gdbarch) / 8;
  struct s390_stub_unwind_cache *info;
  ULONGEST reg;

  if (*this_prologue_cache)
    return *this_prologue_cache;

  info = FRAME_OBSTACK_ZALLOC (struct s390_stub_unwind_cache);
  *this_prologue_cache = info;
  info->saved_regs = trad_frame_alloc_saved_regs (this_frame);

  /* The return address is in register %r14.  */
  info->saved_regs[S390_PSWA_REGNUM].realreg = S390_RETADDR_REGNUM;

  /* Retrieve stack pointer and determine our frame base.  */
  reg = get_frame_register_unsigned (this_frame, S390_SP_REGNUM);
  info->frame_base = reg + 16*word_size + 32;

  return info;
}

static void
s390_stub_frame_this_id (struct frame_info *this_frame,
			 void **this_prologue_cache,
			 struct frame_id *this_id)
{
  struct s390_stub_unwind_cache *info
    = s390_stub_frame_unwind_cache (this_frame, this_prologue_cache);
  *this_id = frame_id_build (info->frame_base, get_frame_pc (this_frame));
}

static struct value *
s390_stub_frame_prev_register (struct frame_info *this_frame,
			       void **this_prologue_cache, int regnum)
{
  struct s390_stub_unwind_cache *info
    = s390_stub_frame_unwind_cache (this_frame, this_prologue_cache);
  return s390_trad_frame_prev_register (this_frame, info->saved_regs, regnum);
}

static int
s390_stub_frame_sniffer (const struct frame_unwind *self,
			 struct frame_info *this_frame,
			 void **this_prologue_cache)
{
  CORE_ADDR addr_in_block;
  bfd_byte insn[S390_MAX_INSTR_SIZE];

  /* If the current PC points to non-readable memory, we assume we
     have trapped due to an invalid function pointer call.  We handle
     the non-existing current function like a PLT stub.  */
  addr_in_block = get_frame_address_in_block (this_frame);
  if (in_plt_section (addr_in_block)
      || s390_readinstruction (insn, get_frame_pc (this_frame)) < 0)
    return 1;
  return 0;
}

static const struct frame_unwind s390_stub_frame_unwind = {
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  s390_stub_frame_this_id,
  s390_stub_frame_prev_register,
  NULL,
  s390_stub_frame_sniffer
};


/* Signal trampoline stack frames.  */

struct s390_sigtramp_unwind_cache {
  CORE_ADDR frame_base;
  struct trad_frame_saved_reg *saved_regs;
};

static struct s390_sigtramp_unwind_cache *
s390_sigtramp_frame_unwind_cache (struct frame_info *this_frame,
				  void **this_prologue_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int word_size = gdbarch_ptr_bit (gdbarch) / 8;
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct s390_sigtramp_unwind_cache *info;
  ULONGEST this_sp, prev_sp;
  CORE_ADDR next_ra, next_cfa, sigreg_ptr, sigreg_high_off;
  int i;

  if (*this_prologue_cache)
    return *this_prologue_cache;

  info = FRAME_OBSTACK_ZALLOC (struct s390_sigtramp_unwind_cache);
  *this_prologue_cache = info;
  info->saved_regs = trad_frame_alloc_saved_regs (this_frame);

  this_sp = get_frame_register_unsigned (this_frame, S390_SP_REGNUM);
  next_ra = get_frame_pc (this_frame);
  next_cfa = this_sp + 16*word_size + 32;

  /* New-style RT frame:
	retcode + alignment (8 bytes)
	siginfo (128 bytes)
	ucontext (contains sigregs at offset 5 words).  */
  if (next_ra == next_cfa)
    {
      sigreg_ptr = next_cfa + 8 + 128 + align_up (5*word_size, 8);
      /* sigregs are followed by uc_sigmask (8 bytes), then by the
	 upper GPR halves if present.  */
      sigreg_high_off = 8;
    }

  /* Old-style RT frame and all non-RT frames:
	old signal mask (8 bytes)
	pointer to sigregs.  */
  else
    {
      sigreg_ptr = read_memory_unsigned_integer (next_cfa + 8,
						 word_size, byte_order);
      /* sigregs are followed by signo (4 bytes), then by the
	 upper GPR halves if present.  */
      sigreg_high_off = 4;
    }

  /* The sigregs structure looks like this:
            long   psw_mask;
            long   psw_addr;
            long   gprs[16];
            int    acrs[16];
            int    fpc;
            int    __pad;
            double fprs[16];  */

  /* PSW mask and address.  */
  info->saved_regs[S390_PSWM_REGNUM].addr = sigreg_ptr;
  sigreg_ptr += word_size;
  info->saved_regs[S390_PSWA_REGNUM].addr = sigreg_ptr;
  sigreg_ptr += word_size;

  /* Then the GPRs.  */
  for (i = 0; i < 16; i++)
    {
      info->saved_regs[S390_R0_REGNUM + i].addr = sigreg_ptr;
      sigreg_ptr += word_size;
    }

  /* Then the ACRs.  */
  for (i = 0; i < 16; i++)
    {
      info->saved_regs[S390_A0_REGNUM + i].addr = sigreg_ptr;
      sigreg_ptr += 4;
    }

  /* The floating-point control word.  */
  info->saved_regs[S390_FPC_REGNUM].addr = sigreg_ptr;
  sigreg_ptr += 8;

  /* And finally the FPRs.  */
  for (i = 0; i < 16; i++)
    {
      info->saved_regs[S390_F0_REGNUM + i].addr = sigreg_ptr;
      sigreg_ptr += 8;
    }

  /* If we have them, the GPR upper halves are appended at the end.  */
  sigreg_ptr += sigreg_high_off;
  if (tdep->gpr_full_regnum != -1)
    for (i = 0; i < 16; i++)
      {
        info->saved_regs[S390_R0_UPPER_REGNUM + i].addr = sigreg_ptr;
	sigreg_ptr += 4;
      }

  /* Restore the previous frame's SP.  */
  prev_sp = read_memory_unsigned_integer (
			info->saved_regs[S390_SP_REGNUM].addr,
			word_size, byte_order);

  /* Determine our frame base.  */
  info->frame_base = prev_sp + 16*word_size + 32;

  return info;
}

static void
s390_sigtramp_frame_this_id (struct frame_info *this_frame,
			     void **this_prologue_cache,
			     struct frame_id *this_id)
{
  struct s390_sigtramp_unwind_cache *info
    = s390_sigtramp_frame_unwind_cache (this_frame, this_prologue_cache);
  *this_id = frame_id_build (info->frame_base, get_frame_pc (this_frame));
}

static struct value *
s390_sigtramp_frame_prev_register (struct frame_info *this_frame,
				   void **this_prologue_cache, int regnum)
{
  struct s390_sigtramp_unwind_cache *info
    = s390_sigtramp_frame_unwind_cache (this_frame, this_prologue_cache);
  return s390_trad_frame_prev_register (this_frame, info->saved_regs, regnum);
}

static int
s390_sigtramp_frame_sniffer (const struct frame_unwind *self,
			     struct frame_info *this_frame,
			     void **this_prologue_cache)
{
  CORE_ADDR pc = get_frame_pc (this_frame);
  bfd_byte sigreturn[2];

  if (target_read_memory (pc, sigreturn, 2))
    return 0;

  if (sigreturn[0] != 0x0a /* svc */)
    return 0;

  if (sigreturn[1] != 119 /* sigreturn */
      && sigreturn[1] != 173 /* rt_sigreturn */)
    return 0;
  
  return 1;
}

static const struct frame_unwind s390_sigtramp_frame_unwind = {
  SIGTRAMP_FRAME,
  default_frame_unwind_stop_reason,
  s390_sigtramp_frame_this_id,
  s390_sigtramp_frame_prev_register,
  NULL,
  s390_sigtramp_frame_sniffer
};


/* Frame base handling.  */

static CORE_ADDR
s390_frame_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct s390_unwind_cache *info
    = s390_frame_unwind_cache (this_frame, this_cache);
  return info->frame_base;
}

static CORE_ADDR
s390_local_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct s390_unwind_cache *info
    = s390_frame_unwind_cache (this_frame, this_cache);
  return info->local_base;
}

static const struct frame_base s390_frame_base = {
  &s390_frame_unwind,
  s390_frame_base_address,
  s390_local_base_address,
  s390_local_base_address
};

static CORE_ADDR
s390_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  ULONGEST pc;
  pc = frame_unwind_register_unsigned (next_frame, tdep->pc_regnum);
  return gdbarch_addr_bits_remove (gdbarch, pc);
}

static CORE_ADDR
s390_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  ULONGEST sp;
  sp = frame_unwind_register_unsigned (next_frame, S390_SP_REGNUM);
  return gdbarch_addr_bits_remove (gdbarch, sp);
}


/* DWARF-2 frame support.  */

static struct value *
s390_dwarf2_prev_register (struct frame_info *this_frame, void **this_cache,
			   int regnum)
{
  return s390_unwind_pseudo_register (this_frame, regnum);
}

static void
s390_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,
                            struct dwarf2_frame_state_reg *reg,
			    struct frame_info *this_frame)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* The condition code (and thus PSW mask) is call-clobbered.  */
  if (regnum == S390_PSWM_REGNUM)
    reg->how = DWARF2_FRAME_REG_UNDEFINED;

  /* The PSW address unwinds to the return address.  */
  else if (regnum == S390_PSWA_REGNUM)
    reg->how = DWARF2_FRAME_REG_RA;

  /* Fixed registers are call-saved or call-clobbered
     depending on the ABI in use.  */
  else if (regnum < S390_NUM_REGS)
    {
      if (s390_register_call_saved (gdbarch, regnum))
	reg->how = DWARF2_FRAME_REG_SAME_VALUE;
      else
	reg->how = DWARF2_FRAME_REG_UNDEFINED;
    }

  /* We install a special function to unwind pseudos.  */
  else
    {
      reg->how = DWARF2_FRAME_REG_FN;
      reg->loc.fn = s390_dwarf2_prev_register;
    }
}


/* Dummy function calls.  */

/* Return non-zero if TYPE is an integer-like type, zero otherwise.
   "Integer-like" types are those that should be passed the way
   integers are: integers, enums, ranges, characters, and booleans.  */
static int
is_integer_like (struct type *type)
{
  enum type_code code = TYPE_CODE (type);

  return (code == TYPE_CODE_INT
          || code == TYPE_CODE_ENUM
          || code == TYPE_CODE_RANGE
          || code == TYPE_CODE_CHAR
          || code == TYPE_CODE_BOOL);
}

/* Return non-zero if TYPE is a pointer-like type, zero otherwise.
   "Pointer-like" types are those that should be passed the way
   pointers are: pointers and references.  */
static int
is_pointer_like (struct type *type)
{
  enum type_code code = TYPE_CODE (type);

  return (code == TYPE_CODE_PTR
          || code == TYPE_CODE_REF);
}


/* Return non-zero if TYPE is a `float singleton' or `double
   singleton', zero otherwise.

   A `T singleton' is a struct type with one member, whose type is
   either T or a `T singleton'.  So, the following are all float
   singletons:

   struct { float x };
   struct { struct { float x; } x; };
   struct { struct { struct { float x; } x; } x; };

   ... and so on.

   All such structures are passed as if they were floats or doubles,
   as the (revised) ABI says.  */
static int
is_float_singleton (struct type *type)
{
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT && TYPE_NFIELDS (type) == 1)
    {
      struct type *singleton_type = TYPE_FIELD_TYPE (type, 0);
      CHECK_TYPEDEF (singleton_type);

      return (TYPE_CODE (singleton_type) == TYPE_CODE_FLT
	      || TYPE_CODE (singleton_type) == TYPE_CODE_DECFLOAT
	      || is_float_singleton (singleton_type));
    }

  return 0;
}


/* Return non-zero if TYPE is a struct-like type, zero otherwise.
   "Struct-like" types are those that should be passed as structs are:
   structs and unions.

   As an odd quirk, not mentioned in the ABI, GCC passes float and
   double singletons as if they were a plain float, double, etc.  (The
   corresponding union types are handled normally.)  So we exclude
   those types here.  *shrug* */
static int
is_struct_like (struct type *type)
{
  enum type_code code = TYPE_CODE (type);

  return (code == TYPE_CODE_UNION
          || (code == TYPE_CODE_STRUCT && ! is_float_singleton (type)));
}


/* Return non-zero if TYPE is a float-like type, zero otherwise.
   "Float-like" types are those that should be passed as
   floating-point values are.

   You'd think this would just be floats, doubles, long doubles, etc.
   But as an odd quirk, not mentioned in the ABI, GCC passes float and
   double singletons as if they were a plain float, double, etc.  (The
   corresponding union types are handled normally.)  So we include
   those types here.  *shrug* */
static int
is_float_like (struct type *type)
{
  return (TYPE_CODE (type) == TYPE_CODE_FLT
	  || TYPE_CODE (type) == TYPE_CODE_DECFLOAT
          || is_float_singleton (type));
}


static int
is_power_of_two (unsigned int n)
{
  return ((n & (n - 1)) == 0);
}

/* Return non-zero if TYPE should be passed as a pointer to a copy,
   zero otherwise.  */
static int
s390_function_arg_pass_by_reference (struct type *type)
{
  if (TYPE_LENGTH (type) > 8)
    return 1;

  return (is_struct_like (type) && !is_power_of_two (TYPE_LENGTH (type)))
	  || TYPE_CODE (type) == TYPE_CODE_COMPLEX
	  || (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type));
}

/* Return non-zero if TYPE should be passed in a float register
   if possible.  */
static int
s390_function_arg_float (struct type *type)
{
  if (TYPE_LENGTH (type) > 8)
    return 0;

  return is_float_like (type);
}

/* Return non-zero if TYPE should be passed in an integer register
   (or a pair of integer registers) if possible.  */
static int
s390_function_arg_integer (struct type *type)
{
  if (TYPE_LENGTH (type) > 8)
    return 0;

   return is_integer_like (type)
	  || is_pointer_like (type)
	  || (is_struct_like (type) && is_power_of_two (TYPE_LENGTH (type)));
}

/* Return ARG, a `SIMPLE_ARG', sign-extended or zero-extended to a full
   word as required for the ABI.  */
static LONGEST
extend_simple_arg (struct gdbarch *gdbarch, struct value *arg)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct type *type = check_typedef (value_type (arg));

  /* Even structs get passed in the least significant bits of the
     register / memory word.  It's not really right to extract them as
     an integer, but it does take care of the extension.  */
  if (TYPE_UNSIGNED (type))
    return extract_unsigned_integer (value_contents (arg),
                                     TYPE_LENGTH (type), byte_order);
  else
    return extract_signed_integer (value_contents (arg),
                                   TYPE_LENGTH (type), byte_order);
}


/* Return the alignment required by TYPE.  */
static int
alignment_of (struct type *type)
{
  int alignment;

  if (is_integer_like (type)
      || is_pointer_like (type)
      || TYPE_CODE (type) == TYPE_CODE_FLT
      || TYPE_CODE (type) == TYPE_CODE_DECFLOAT)
    alignment = TYPE_LENGTH (type);
  else if (TYPE_CODE (type) == TYPE_CODE_STRUCT
           || TYPE_CODE (type) == TYPE_CODE_UNION)
    {
      int i;

      alignment = 1;
      for (i = 0; i < TYPE_NFIELDS (type); i++)
        {
          int field_alignment
	    = alignment_of (check_typedef (TYPE_FIELD_TYPE (type, i)));

          if (field_alignment > alignment)
            alignment = field_alignment;
        }
    }
  else
    alignment = 1;

  /* Check that everything we ever return is a power of two.  Lots of
     code doesn't want to deal with aligning things to arbitrary
     boundaries.  */
  gdb_assert ((alignment & (alignment - 1)) == 0);

  return alignment;
}


/* Put the actual parameter values pointed to by ARGS[0..NARGS-1] in
   place to be passed to a function, as specified by the "GNU/Linux
   for S/390 ELF Application Binary Interface Supplement".

   SP is the current stack pointer.  We must put arguments, links,
   padding, etc. whereever they belong, and return the new stack
   pointer value.
   
   If STRUCT_RETURN is non-zero, then the function we're calling is
   going to return a structure by value; STRUCT_ADDR is the address of
   a block we've allocated for it on the stack.

   Our caller has taken care of any type promotions needed to satisfy
   prototypes or the old K&R argument-passing rules.  */
static CORE_ADDR
s390_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
		      struct regcache *regcache, CORE_ADDR bp_addr,
		      int nargs, struct value **args, CORE_ADDR sp,
		      int struct_return, CORE_ADDR struct_addr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int word_size = gdbarch_ptr_bit (gdbarch) / 8;
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int i;

  /* If the i'th argument is passed as a reference to a copy, then
     copy_addr[i] is the address of the copy we made.  */
  CORE_ADDR *copy_addr = alloca (nargs * sizeof (CORE_ADDR));

  /* Reserve space for the reference-to-copy area.  */
  for (i = 0; i < nargs; i++)
    {
      struct value *arg = args[i];
      struct type *type = check_typedef (value_type (arg));

      if (s390_function_arg_pass_by_reference (type))
        {
          sp -= TYPE_LENGTH (type);
          sp = align_down (sp, alignment_of (type));
          copy_addr[i] = sp;
        }
    }

  /* Reserve space for the parameter area.  As a conservative
     simplification, we assume that everything will be passed on the
     stack.  Since every argument larger than 8 bytes will be 
     passed by reference, we use this simple upper bound.  */
  sp -= nargs * 8;

  /* After all that, make sure it's still aligned on an eight-byte
     boundary.  */
  sp = align_down (sp, 8);

  /* Allocate the standard frame areas: the register save area, the
     word reserved for the compiler (which seems kind of meaningless),
     and the back chain pointer.  */
  sp -= 16*word_size + 32;

  /* Now we have the final SP value.  Make sure we didn't underflow;
     on 31-bit, this would result in addresses with the high bit set,
     which causes confusion elsewhere.  Note that if we error out
     here, stack and registers remain untouched.  */
  if (gdbarch_addr_bits_remove (gdbarch, sp) != sp)
    error (_("Stack overflow"));


  /* Finally, place the actual parameters, working from SP towards
     higher addresses.  The code above is supposed to reserve enough
     space for this.  */
  {
    int fr = 0;
    int gr = 2;
    CORE_ADDR starg = sp + 16*word_size + 32;

    /* A struct is returned using general register 2.  */
    if (struct_return)
      {
	regcache_cooked_write_unsigned (regcache, S390_R0_REGNUM + gr,
				        struct_addr);
	gr++;
      }

    for (i = 0; i < nargs; i++)
      {
        struct value *arg = args[i];
        struct type *type = check_typedef (value_type (arg));
        unsigned length = TYPE_LENGTH (type);

	if (s390_function_arg_pass_by_reference (type))
	  {
	    /* Actually copy the argument contents to the stack slot
	       that was reserved above.  */
	    write_memory (copy_addr[i], value_contents (arg), length);

	    if (gr <= 6)
	      {
		regcache_cooked_write_unsigned (regcache, S390_R0_REGNUM + gr,
					        copy_addr[i]);
		gr++;
	      }
	    else
	      {
		write_memory_unsigned_integer (starg, word_size, byte_order,
					       copy_addr[i]);
		starg += word_size;
	      }
	  }
	else if (s390_function_arg_float (type))
	  {
	    /* The GNU/Linux for S/390 ABI uses FPRs 0 and 2 to pass arguments,
	       the GNU/Linux for zSeries ABI uses 0, 2, 4, and 6.  */
	    if (fr <= (tdep->abi == ABI_LINUX_S390 ? 2 : 6))
	      {
		/* When we store a single-precision value in an FP register,
		   it occupies the leftmost bits.  */
		regcache_cooked_write_part (regcache, S390_F0_REGNUM + fr,
					    0, length, value_contents (arg));
		fr += 2;
	      }
	    else
	      {
		/* When we store a single-precision value in a stack slot,
		   it occupies the rightmost bits.  */
		starg = align_up (starg + length, word_size);
                write_memory (starg - length, value_contents (arg), length);
	      }
	  }
	else if (s390_function_arg_integer (type) && length <= word_size)
	  {
	    if (gr <= 6)
	      {
		/* Integer arguments are always extended to word size.  */
		regcache_cooked_write_signed (regcache, S390_R0_REGNUM + gr,
					      extend_simple_arg (gdbarch,
								 arg));
		gr++;
	      }
	    else
	      {
		/* Integer arguments are always extended to word size.  */
		write_memory_signed_integer (starg, word_size, byte_order,
                                             extend_simple_arg (gdbarch, arg));
                starg += word_size;
	      }
	  }
	else if (s390_function_arg_integer (type) && length == 2*word_size)
	  {
	    if (gr <= 5)
	      {
		regcache_cooked_write (regcache, S390_R0_REGNUM + gr,
				       value_contents (arg));
		regcache_cooked_write (regcache, S390_R0_REGNUM + gr + 1,
				       value_contents (arg) + word_size);
		gr += 2;
	      }
	    else
	      {
		/* If we skipped r6 because we couldn't fit a DOUBLE_ARG
		   in it, then don't go back and use it again later.  */
		gr = 7;

		write_memory (starg, value_contents (arg), length);
		starg += length;
	      }
	  }
	else
	  internal_error (__FILE__, __LINE__, _("unknown argument type"));
      }
  }

  /* Store return PSWA.  In 31-bit mode, keep addressing mode bit.  */
  if (word_size == 4)
    {
      ULONGEST pswa;
      regcache_cooked_read_unsigned (regcache, S390_PSWA_REGNUM, &pswa);
      bp_addr = (bp_addr & 0x7fffffff) | (pswa & 0x80000000);
    }
  regcache_cooked_write_unsigned (regcache, S390_RETADDR_REGNUM, bp_addr);

  /* Store updated stack pointer.  */
  regcache_cooked_write_unsigned (regcache, S390_SP_REGNUM, sp);

  /* We need to return the 'stack part' of the frame ID,
     which is actually the top of the register save area.  */
  return sp + 16*word_size + 32;
}

/* Assuming THIS_FRAME is a dummy, return the frame ID of that
   dummy frame.  The frame ID's base needs to match the TOS value
   returned by push_dummy_call, and the PC match the dummy frame's
   breakpoint.  */
static struct frame_id
s390_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  int word_size = gdbarch_ptr_bit (gdbarch) / 8;
  CORE_ADDR sp = get_frame_register_unsigned (this_frame, S390_SP_REGNUM);
  sp = gdbarch_addr_bits_remove (gdbarch, sp);

  return frame_id_build (sp + 16*word_size + 32,
                         get_frame_pc (this_frame));
}

static CORE_ADDR
s390_frame_align (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  /* Both the 32- and 64-bit ABI's say that the stack pointer should
     always be aligned on an eight-byte boundary.  */
  return (addr & -8);
}


/* Function return value access.  */

static enum return_value_convention
s390_return_value_convention (struct gdbarch *gdbarch, struct type *type)
{
  if (TYPE_LENGTH (type) > 8)
    return RETURN_VALUE_STRUCT_CONVENTION;

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
    case TYPE_CODE_ARRAY:
    case TYPE_CODE_COMPLEX:
      return RETURN_VALUE_STRUCT_CONVENTION;

    default:
      return RETURN_VALUE_REGISTER_CONVENTION;
    }
}

static enum return_value_convention
s390_return_value (struct gdbarch *gdbarch, struct value *function,
		   struct type *type, struct regcache *regcache,
		   gdb_byte *out, const gdb_byte *in)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int word_size = gdbarch_ptr_bit (gdbarch) / 8;
  enum return_value_convention rvc;
  int length;

  type = check_typedef (type);
  rvc = s390_return_value_convention (gdbarch, type);
  length = TYPE_LENGTH (type);

  if (in)
    {
      switch (rvc)
	{
	case RETURN_VALUE_REGISTER_CONVENTION:
	  if (TYPE_CODE (type) == TYPE_CODE_FLT
	      || TYPE_CODE (type) == TYPE_CODE_DECFLOAT)
	    {
	      /* When we store a single-precision value in an FP register,
		 it occupies the leftmost bits.  */
	      regcache_cooked_write_part (regcache, S390_F0_REGNUM, 
					  0, length, in);
	    }
	  else if (length <= word_size)
	    {
	      /* Integer arguments are always extended to word size.  */
	      if (TYPE_UNSIGNED (type))
		regcache_cooked_write_unsigned (regcache, S390_R2_REGNUM,
			extract_unsigned_integer (in, length, byte_order));
	      else
		regcache_cooked_write_signed (regcache, S390_R2_REGNUM,
			extract_signed_integer (in, length, byte_order));
	    }
	  else if (length == 2*word_size)
	    {
	      regcache_cooked_write (regcache, S390_R2_REGNUM, in);
	      regcache_cooked_write (regcache, S390_R3_REGNUM, in + word_size);
	    }
	  else
	    internal_error (__FILE__, __LINE__, _("invalid return type"));
	  break;

	case RETURN_VALUE_STRUCT_CONVENTION:
	  error (_("Cannot set function return value."));
	  break;
	}
    }
  else if (out)
    {
      switch (rvc)
	{
	case RETURN_VALUE_REGISTER_CONVENTION:
	  if (TYPE_CODE (type) == TYPE_CODE_FLT
	      || TYPE_CODE (type) == TYPE_CODE_DECFLOAT)
	    {
	      /* When we store a single-precision value in an FP register,
		 it occupies the leftmost bits.  */
	      regcache_cooked_read_part (regcache, S390_F0_REGNUM, 
					 0, length, out);
	    }
	  else if (length <= word_size)
	    {
	      /* Integer arguments occupy the rightmost bits.  */
	      regcache_cooked_read_part (regcache, S390_R2_REGNUM, 
					 word_size - length, length, out);
	    }
	  else if (length == 2*word_size)
	    {
	      regcache_cooked_read (regcache, S390_R2_REGNUM, out);
	      regcache_cooked_read (regcache, S390_R3_REGNUM, out + word_size);
	    }
	  else
	    internal_error (__FILE__, __LINE__, _("invalid return type"));
	  break;

	case RETURN_VALUE_STRUCT_CONVENTION:
	  error (_("Function return value unknown."));
	  break;
	}
    }

  return rvc;
}


/* Breakpoints.  */

static const gdb_byte *
s390_breakpoint_from_pc (struct gdbarch *gdbarch,
			 CORE_ADDR *pcptr, int *lenptr)
{
  static const gdb_byte breakpoint[] = { 0x0, 0x1 };

  *lenptr = sizeof (breakpoint);
  return breakpoint;
}


/* Address handling.  */

static CORE_ADDR
s390_addr_bits_remove (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  return addr & 0x7fffffff;
}

static int
s390_address_class_type_flags (int byte_size, int dwarf2_addr_class)
{
  if (byte_size == 4)
    return TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1;
  else
    return 0;
}

static const char *
s390_address_class_type_flags_to_name (struct gdbarch *gdbarch, int type_flags)
{
  if (type_flags & TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1)
    return "mode32";
  else
    return NULL;
}

static int
s390_address_class_name_to_type_flags (struct gdbarch *gdbarch,
				       const char *name,
				       int *type_flags_ptr)
{
  if (strcmp (name, "mode32") == 0)
    {
      *type_flags_ptr = TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1;
      return 1;
    }
  else
    return 0;
}

/* Implementation of `gdbarch_stap_is_single_operand', as defined in
   gdbarch.h.  */

static int
s390_stap_is_single_operand (struct gdbarch *gdbarch, const char *s)
{
  return ((isdigit (*s) && s[1] == '(' && s[2] == '%') /* Displacement
							  or indirection.  */
	  || *s == '%' /* Register access.  */
	  || isdigit (*s)); /* Literal number.  */
}

/* Set up gdbarch struct.  */

static struct gdbarch *
s390_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  const struct target_desc *tdesc = info.target_desc;
  struct tdesc_arch_data *tdesc_data = NULL;
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;
  int tdep_abi;
  int have_upper = 0;
  int have_linux_v1 = 0;
  int have_linux_v2 = 0;
  int first_pseudo_reg, last_pseudo_reg;

  /* Default ABI and register size.  */
  switch (info.bfd_arch_info->mach)
    {
    case bfd_mach_s390_31:
      tdep_abi = ABI_LINUX_S390;
      break;

    case bfd_mach_s390_64:
      tdep_abi = ABI_LINUX_ZSERIES;
      break;

    default:
      return NULL;
    }

  /* Use default target description if none provided by the target.  */
  if (!tdesc_has_registers (tdesc))
    {
      if (tdep_abi == ABI_LINUX_S390)
	tdesc = tdesc_s390_linux32;
      else
	tdesc = tdesc_s390x_linux64;
    }

  /* Check any target description for validity.  */
  if (tdesc_has_registers (tdesc))
    {
      static const char *const gprs[] = {
	"r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
	"r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
      };
      static const char *const fprs[] = {
	"f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
	"f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15"
      };
      static const char *const acrs[] = {
	"acr0", "acr1", "acr2", "acr3", "acr4", "acr5", "acr6", "acr7",
	"acr8", "acr9", "acr10", "acr11", "acr12", "acr13", "acr14", "acr15"
      };
      static const char *const gprs_lower[] = {
	"r0l", "r1l", "r2l", "r3l", "r4l", "r5l", "r6l", "r7l",
	"r8l", "r9l", "r10l", "r11l", "r12l", "r13l", "r14l", "r15l"
      };
      static const char *const gprs_upper[] = {
	"r0h", "r1h", "r2h", "r3h", "r4h", "r5h", "r6h", "r7h",
	"r8h", "r9h", "r10h", "r11h", "r12h", "r13h", "r14h", "r15h"
      };
      static const char *const tdb_regs[] = {
	"tdb0", "tac", "tct", "atia",
	"tr0", "tr1", "tr2", "tr3", "tr4", "tr5", "tr6", "tr7",
	"tr8", "tr9", "tr10", "tr11", "tr12", "tr13", "tr14", "tr15"
      };
      const struct tdesc_feature *feature;
      int i, valid_p = 1;

      feature = tdesc_find_feature (tdesc, "org.gnu.gdb.s390.core");
      if (feature == NULL)
	return NULL;

      tdesc_data = tdesc_data_alloc ();

      valid_p &= tdesc_numbered_register (feature, tdesc_data,
					  S390_PSWM_REGNUM, "pswm");
      valid_p &= tdesc_numbered_register (feature, tdesc_data,
					  S390_PSWA_REGNUM, "pswa");

      if (tdesc_unnumbered_register (feature, "r0"))
	{
	  for (i = 0; i < 16; i++)
	    valid_p &= tdesc_numbered_register (feature, tdesc_data,
						S390_R0_REGNUM + i, gprs[i]);
	}
      else
	{
	  have_upper = 1;

	  for (i = 0; i < 16; i++)
	    valid_p &= tdesc_numbered_register (feature, tdesc_data,
						S390_R0_REGNUM + i,
						gprs_lower[i]);
	  for (i = 0; i < 16; i++)
	    valid_p &= tdesc_numbered_register (feature, tdesc_data,
						S390_R0_UPPER_REGNUM + i,
						gprs_upper[i]);
	}

      feature = tdesc_find_feature (tdesc, "org.gnu.gdb.s390.fpr");
      if (feature == NULL)
	{
	  tdesc_data_cleanup (tdesc_data);
	  return NULL;
	}

      valid_p &= tdesc_numbered_register (feature, tdesc_data,
					  S390_FPC_REGNUM, "fpc");
      for (i = 0; i < 16; i++)
	valid_p &= tdesc_numbered_register (feature, tdesc_data,
					    S390_F0_REGNUM + i, fprs[i]);

      feature = tdesc_find_feature (tdesc, "org.gnu.gdb.s390.acr");
      if (feature == NULL)
	{
	  tdesc_data_cleanup (tdesc_data);
	  return NULL;
	}

      for (i = 0; i < 16; i++)
	valid_p &= tdesc_numbered_register (feature, tdesc_data,
					    S390_A0_REGNUM + i, acrs[i]);

      /* Optional GNU/Linux-specific "registers".  */
      feature = tdesc_find_feature (tdesc, "org.gnu.gdb.s390.linux");
      if (feature)
	{
	  tdesc_numbered_register (feature, tdesc_data,
				   S390_ORIG_R2_REGNUM, "orig_r2");

	  if (tdesc_numbered_register (feature, tdesc_data,
				       S390_LAST_BREAK_REGNUM, "last_break"))
	    have_linux_v1 = 1;

	  if (tdesc_numbered_register (feature, tdesc_data,
				       S390_SYSTEM_CALL_REGNUM, "system_call"))
	    have_linux_v2 = 1;

	  if (have_linux_v2 > have_linux_v1)
	    valid_p = 0;
	}

      /* Transaction diagnostic block.  */
      feature = tdesc_find_feature (tdesc, "org.gnu.gdb.s390.tdb");
      if (feature)
	{
	  for (i = 0; i < ARRAY_SIZE (tdb_regs); i++)
	    valid_p &= tdesc_numbered_register (feature, tdesc_data,
						S390_TDB_DWORD0_REGNUM + i,
						tdb_regs[i]);
	}

      if (!valid_p)
	{
	  tdesc_data_cleanup (tdesc_data);
	  return NULL;
	}
    }

  /* Find a candidate among extant architectures.  */
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      tdep = gdbarch_tdep (arches->gdbarch);
      if (!tdep)
	continue;
      if (tdep->abi != tdep_abi)
	continue;
      if ((tdep->gpr_full_regnum != -1) != have_upper)
	continue;
      if (tdesc_data != NULL)
	tdesc_data_cleanup (tdesc_data);
      return arches->gdbarch;
    }

  /* Otherwise create a new gdbarch for the specified machine type.  */
  tdep = XCALLOC (1, struct gdbarch_tdep);
  tdep->abi = tdep_abi;
  gdbarch = gdbarch_alloc (&info, tdep);

  set_gdbarch_believe_pcc_promotion (gdbarch, 0);
  set_gdbarch_char_signed (gdbarch, 0);

  /* S/390 GNU/Linux uses either 64-bit or 128-bit long doubles.
     We can safely let them default to 128-bit, since the debug info
     will give the size of type actually used in each case.  */
  set_gdbarch_long_double_bit (gdbarch, 128);
  set_gdbarch_long_double_format (gdbarch, floatformats_ia64_quad);

  /* Amount PC must be decremented by after a breakpoint.  This is
     often the number of bytes returned by gdbarch_breakpoint_from_pc but not
     always.  */
  set_gdbarch_decr_pc_after_break (gdbarch, 2);
  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_breakpoint_from_pc (gdbarch, s390_breakpoint_from_pc);
  set_gdbarch_skip_prologue (gdbarch, s390_skip_prologue);
  set_gdbarch_in_function_epilogue_p (gdbarch, s390_in_function_epilogue_p);

  set_gdbarch_num_regs (gdbarch, S390_NUM_REGS);
  set_gdbarch_sp_regnum (gdbarch, S390_SP_REGNUM);
  set_gdbarch_fp0_regnum (gdbarch, S390_F0_REGNUM);
  set_gdbarch_stab_reg_to_regnum (gdbarch, s390_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, s390_dwarf_reg_to_regnum);
  set_gdbarch_value_from_register (gdbarch, s390_value_from_register);
  set_gdbarch_regset_from_core_section (gdbarch,
                                        s390_regset_from_core_section);
  set_gdbarch_core_read_description (gdbarch, s390_core_read_description);
  set_gdbarch_cannot_store_register (gdbarch, s390_cannot_store_register);
  set_gdbarch_write_pc (gdbarch, s390_write_pc);
  set_gdbarch_pseudo_register_read (gdbarch, s390_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, s390_pseudo_register_write);
  set_tdesc_pseudo_register_name (gdbarch, s390_pseudo_register_name);
  set_tdesc_pseudo_register_type (gdbarch, s390_pseudo_register_type);
  set_tdesc_pseudo_register_reggroup_p (gdbarch,
                                        s390_pseudo_register_reggroup_p);
  tdesc_use_registers (gdbarch, tdesc, tdesc_data);

  /* Assign pseudo register numbers.  */
  first_pseudo_reg = gdbarch_num_regs (gdbarch);
  last_pseudo_reg = first_pseudo_reg;
  tdep->gpr_full_regnum = -1;
  if (have_upper)
    {
      tdep->gpr_full_regnum = last_pseudo_reg;
      last_pseudo_reg += 16;
    }
  tdep->pc_regnum = last_pseudo_reg++;
  tdep->cc_regnum = last_pseudo_reg++;
  set_gdbarch_pc_regnum (gdbarch, tdep->pc_regnum);
  set_gdbarch_num_pseudo_regs (gdbarch, last_pseudo_reg - first_pseudo_reg);

  /* Inferior function calls.  */
  set_gdbarch_push_dummy_call (gdbarch, s390_push_dummy_call);
  set_gdbarch_dummy_id (gdbarch, s390_dummy_id);
  set_gdbarch_frame_align (gdbarch, s390_frame_align);
  set_gdbarch_return_value (gdbarch, s390_return_value);

  /* Frame handling.  */
  dwarf2_frame_set_init_reg (gdbarch, s390_dwarf2_frame_init_reg);
  dwarf2_frame_set_adjust_regnum (gdbarch, s390_adjust_frame_regnum);
  dwarf2_append_unwinders (gdbarch);
  frame_base_append_sniffer (gdbarch, dwarf2_frame_base_sniffer);
  frame_unwind_append_unwinder (gdbarch, &s390_stub_frame_unwind);
  frame_unwind_append_unwinder (gdbarch, &s390_sigtramp_frame_unwind);
  frame_unwind_append_unwinder (gdbarch, &s390_frame_unwind);
  frame_base_set_default (gdbarch, &s390_frame_base);
  set_gdbarch_unwind_pc (gdbarch, s390_unwind_pc);
  set_gdbarch_unwind_sp (gdbarch, s390_unwind_sp);

  /* Displaced stepping.  */
  set_gdbarch_displaced_step_copy_insn (gdbarch,
                                        simple_displaced_step_copy_insn);
  set_gdbarch_displaced_step_fixup (gdbarch, s390_displaced_step_fixup);
  set_gdbarch_displaced_step_free_closure (gdbarch,
                                           simple_displaced_step_free_closure);
  set_gdbarch_displaced_step_location (gdbarch,
                                       displaced_step_at_entry_point);
  set_gdbarch_max_insn_length (gdbarch, S390_MAX_INSTR_SIZE);

  /* Note that GNU/Linux is the only OS supported on this
     platform.  */
  linux_init_abi (info, gdbarch);

  switch (tdep->abi)
    {
    case ABI_LINUX_S390:
      tdep->gregset = &s390_gregset;
      tdep->sizeof_gregset = s390_sizeof_gregset;
      tdep->fpregset = &s390_fpregset;
      tdep->sizeof_fpregset = s390_sizeof_fpregset;

      set_gdbarch_addr_bits_remove (gdbarch, s390_addr_bits_remove);
      set_solib_svr4_fetch_link_map_offsets
	(gdbarch, svr4_ilp32_fetch_link_map_offsets);

      if (have_upper)
	{
	  if (have_linux_v2)
	    set_gdbarch_core_regset_sections (gdbarch,
					      s390_linux64v2_regset_sections);
	  else if (have_linux_v1)
	    set_gdbarch_core_regset_sections (gdbarch,
					      s390_linux64v1_regset_sections);
	  else
	    set_gdbarch_core_regset_sections (gdbarch,
					      s390_linux64_regset_sections);
	}
      else
	{
	  if (have_linux_v2)
	    set_gdbarch_core_regset_sections (gdbarch,
					      s390_linux32v2_regset_sections);
	  else if (have_linux_v1)
	    set_gdbarch_core_regset_sections (gdbarch,
					      s390_linux32v1_regset_sections);
	  else
	    set_gdbarch_core_regset_sections (gdbarch,
					      s390_linux32_regset_sections);
	}
      break;

    case ABI_LINUX_ZSERIES:
      tdep->gregset = &s390x_gregset;
      tdep->sizeof_gregset = s390x_sizeof_gregset;
      tdep->fpregset = &s390_fpregset;
      tdep->sizeof_fpregset = s390_sizeof_fpregset;

      set_gdbarch_long_bit (gdbarch, 64);
      set_gdbarch_long_long_bit (gdbarch, 64);
      set_gdbarch_ptr_bit (gdbarch, 64);
      set_solib_svr4_fetch_link_map_offsets
	(gdbarch, svr4_lp64_fetch_link_map_offsets);
      set_gdbarch_address_class_type_flags (gdbarch,
                                            s390_address_class_type_flags);
      set_gdbarch_address_class_type_flags_to_name (gdbarch,
                                                    s390_address_class_type_flags_to_name);
      set_gdbarch_address_class_name_to_type_flags (gdbarch,
                                                    s390_address_class_name_to_type_flags);

      if (have_linux_v2)
	set_gdbarch_core_regset_sections (gdbarch,
					  s390x_linux64v2_regset_sections);
      else if (have_linux_v1)
	set_gdbarch_core_regset_sections (gdbarch,
					  s390x_linux64v1_regset_sections);
      else
	set_gdbarch_core_regset_sections (gdbarch,
					  s390x_linux64_regset_sections);
      break;
    }

  set_gdbarch_print_insn (gdbarch, print_insn_s390);

  set_gdbarch_skip_trampoline_code (gdbarch, find_solib_trampoline_target);

  /* Enable TLS support.  */
  set_gdbarch_fetch_tls_load_module_address (gdbarch,
                                             svr4_fetch_objfile_link_map);

  set_gdbarch_get_siginfo_type (gdbarch, linux_get_siginfo_type);

  /* SystemTap functions.  */
  set_gdbarch_stap_register_prefix (gdbarch, "%");
  set_gdbarch_stap_register_indirection_prefix (gdbarch, "(");
  set_gdbarch_stap_register_indirection_suffix (gdbarch, ")");
  set_gdbarch_stap_is_single_operand (gdbarch, s390_stap_is_single_operand);

  return gdbarch;
}


extern initialize_file_ftype _initialize_s390_tdep; /* -Wmissing-prototypes */

void
_initialize_s390_tdep (void)
{
  /* Hook us into the gdbarch mechanism.  */
  register_gdbarch_init (bfd_arch_s390, s390_gdbarch_init);

  /* Initialize the GNU/Linux target descriptions.  */
  initialize_tdesc_s390_linux32 ();
  initialize_tdesc_s390_linux32v1 ();
  initialize_tdesc_s390_linux32v2 ();
  initialize_tdesc_s390_linux64 ();
  initialize_tdesc_s390_linux64v1 ();
  initialize_tdesc_s390_linux64v2 ();
  initialize_tdesc_s390_te_linux64 ();
  initialize_tdesc_s390x_linux64 ();
  initialize_tdesc_s390x_linux64v1 ();
  initialize_tdesc_s390x_linux64v2 ();
  initialize_tdesc_s390x_te_linux64 ();
}
@


1.215
log
@gdb/ChangeLog:
2013-09-13  Andreas Arnez  <arnez@@linux.vnet.ibm.com>

	* NEWS: Mention TDB support.
	* features/s390-tdb.xml: New file.
	* features/s390-te-linux64.xml: New file.
	* features/s390x-te-linux64.xml: New file.
	* features/Makefile (WHICH): Add new tdescs above.
	(s390-te-linux64-expedite): Set.
	(s390x-te-linux64-expedite): Set.
	* features/s390-te-linux64.c: New file (generated).
	* features/s390x-te-linux64.c: New file (generated).
	* regformats/s390-te-linux64.dat: New file (generated).
	* regformats/s390x-te-linux64.dat: New file (generated).
	* s390-tdep.h (HWCAP_S390_HIGH_GPRS): Define.
	(HWCAP_S390_TE): Likewise.
	(S390_TDB_DWORD0_REGNUM): Likewise.
	(S390_TDB_DWORD0_REGNUM): Likewise.
	(S390_TDB_ABORT_CODE_REGNUM): Likewise.
	(S390_TDB_CONFLICT_TOKEN_REGNUM): Likewise.
	(S390_TDB_ATIA_REGNUM): Likewise.
	(S390_TDB_R0_REGNUM): Likewise.
	(S390_TDB_R1_REGNUM): Likewise.
	(S390_TDB_R2_REGNUM): Likewise.
	(S390_TDB_R3_REGNUM): Likewise.
	(S390_TDB_R4_REGNUM): Likewise.
	(S390_TDB_R5_REGNUM): Likewise.
	(S390_TDB_R6_REGNUM): Likewise.
	(S390_TDB_R7_REGNUM): Likewise.
	(S390_TDB_R8_REGNUM): Likewise.
	(S390_TDB_R9_REGNUM): Likewise.
	(S390_TDB_R10_REGNUM): Likewise.
	(S390_TDB_R11_REGNUM): Likewise.
	(S390_TDB_R12_REGNUM): Likewise.
	(S390_TDB_R13_REGNUM): Likewise.
	(S390_TDB_R14_REGNUM): Likewise.
	(S390_TDB_R15_REGNUM): Likewise.
	(S390_NUM_REGS): Increase.
	(S390_IS_TDBREGSET_REGNUM): New macro.
	(s390_regmap_tdb): Declare.
	(s390_sizeof_tdbregset): Define.
	(tdesc_s390_te_linux64): Declare.
	(tdesc_s390x_te_linux64): Likewise.
	* s390-tdep.c: Add includes for "auxv.h", <elf.h>,
	"features/s390-te-linux64.c", and "features/s390x-te-linux64.c".
	(s390_regmap_tdb): New regmap.
	(s390_supply_tdb_regset): New function.
	(s390_tdb_regset): New regset.
	(s390_linux64v2_regset_sections): Add TDB regset to list.
	(s390x_linux64v2_regset_sections): Likewise.
	(s390_regset_from_core_section): Recognize TDB core note section.
	(s390_core_read_description): If HWCAP indicates TE support,
	select tdesc_s390_te_linux64 or tdesc_s390_s390x_te_linux64.
	(s390_gdbarch_init): Handle TDB regset.
	(_initialize_s390_tdep): Initialize new tdescs.
	* s390-nat.c (HWCAP_S390_HIGH_GPRS): Remove define.
	(have_regset_tdb): New variable.
	(s390_native_supply): Support register invalidation.
	(fetch_regset): Invalidate registers if ptrace yields ENODATA.
	(check_regset): Treat ENODATA as "regset exists".
	(s390_linux_fetch_inferior_registers): Add TDB.
	(s390_read_description): Check for TDB existence and select
	appropriate tdesc.
	* gdbserver/Makefile.in (clean): Add removal of new makefile
	targets.
	(s390-te-linux64.c): New makefile target.
	(s390x-te-linux64.c): Likewise.
	* gdbserver/configure.srv (srv_regobj): Append new objects
	s390-te-linux64.o and s390x-te-linux64.o.
	(srv_xmlfiles): Append new files s390-te-linux64.xml,
	s390x-te-linux64.xml, and s390-tdb.xml.
	* gdbserver/linux-s390-low.c (init_registers_s390_te_linux64): New
	declaration.
	(tdesc_s390_te_linux64): Likewise.
	(init_registers_s390x_te_linux64): Likewise.
	(tdesc_s390x_te_linux64): Likewise.
	(s390_check_regset): Treat ENODATA as "regset exists".
	(s390_arch_setup): Add TDB regset support.
	(initialize_low_arch): Initialize registers for new tdescs.

gdb/doc/ChangeLog:
2013-09-13  Andreas Arnez  <arnez@@linux.vnet.ibm.com>

	* gdb.texinfo (Decimal Floating Point format): Mention S/390.
	(Standard Target Features): Add new node to menu.
	(S/390 and System z Features): New node.

gdb/testsuite/ChangeLog:
2013-09-13  Andreas Arnez  <arnez@@linux.vnet.ibm.com>

	* gdb.arch/s390-tdbregs.c: New file.
	* gdb.arch/s390-tdbregs.exp: New file.
@
text
@d55 1
a55 1
#include <elf.h>
d810 1
a810 1
  unsigned long hwcap = 0;
@


1.214
log
@2013-09-13  Andreas Arnez  <arnez@@linux.vnet.ibm.com>

	* s390-tdep.h (S390_IS_GREGSET_REGNUM): New macro.
	(S390_IS_FPREGSET_REGNUM): New macro.
	* s390-tdep.c (s390_dwarf_regmap): Make const.
	(regnum_is_gpr_full): New function for replacing repeated code.
	(s390_pseudo_register_name): Use it.
	(s390_pseudo_register_type): Likewise.
	(s390_pseudo_register_read): Likewise.
	(s390_pseudo_register_write): Likewise.
	(s390_unwind_pseudo_register): Likewise.
	(s390_regmap_gregset): New format for regmap.
	(s390x_regmap_gregset): Likewise.
	(s390_regmap_fpregset): Likewise.
	(s390_regmap_upper): Likewise.
	(s390_regmap_last_break): Likewise.
	(s390_regmap_system_call): Likewise.
	(s390_supply_regset): Adjust to new regmap format.
	(s390_collect_regset): Likewise.
	* s390-nat.c (s390_native_supply): Adjust to new regmap format.
	(s390_native_collect): Likewise.
	(supply_gregset): Likewise.
	(fill_gregset): Likewise.
	(supply_fpregset): Likewise.
	(fill_fpregset): Likewise.
	(fetch_regset): Likewise.
	(store_regset): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
@
text
@d47 1
d55 1
d63 1
d67 1
d575 24
d610 19
a628 1
      regcache_raw_supply (regcache, map[1], (const char *)regs + map[0]);
d688 6
d742 1
d767 1
d796 3
d810 3
d820 2
a821 1
	return (v2? tdesc_s390_linux64v2 :
d828 2
a829 1
      return (v2? tdesc_s390x_linux64v2 :
d3077 5
d3159 10
d3385 1
d3389 1
@


1.213
log
@	* nto-tdep.c (nto_relocate_section_addresses): Update,
	target_section.bfd deleted.
	* ppc64-tdep.c (ppc64_convert_from_func_ptr_addr): Ditto.
	* s390-tdep.c (s390_load): Ditto.
	* solib-aix.c (solib_aix_relocate_section_addresses): Ditto.
@
text
@d144 1
a144 1
static int s390_dwarf_regmap[] =
d215 8
d234 1
a234 3
  if (tdep->gpr_full_regnum != -1
      && regnum >= tdep->gpr_full_regnum
      && regnum < tdep->gpr_full_regnum + 16)
d257 1
a257 3
  if (tdep->gpr_full_regnum != -1
      && regnum >= tdep->gpr_full_regnum
      && regnum < tdep->gpr_full_regnum + 16)
d302 1
a302 3
  if (tdep->gpr_full_regnum != -1
      && regnum >= tdep->gpr_full_regnum
      && regnum < tdep->gpr_full_regnum + 16)
d357 1
a357 3
  if (tdep->gpr_full_regnum != -1
      && regnum >= tdep->gpr_full_regnum
      && regnum < tdep->gpr_full_regnum + 16)
d412 97
a508 1
/* Core file register sets.  */
d510 21
a530 25
int s390_regmap_gregset[S390_NUM_REGS] =
{
  /* Program Status Word.  */
  0x00, 0x04,
  /* General Purpose Registers.  */
  0x08, 0x0c, 0x10, 0x14,
  0x18, 0x1c, 0x20, 0x24,
  0x28, 0x2c, 0x30, 0x34,
  0x38, 0x3c, 0x40, 0x44,
  /* Access Registers.  */
  0x48, 0x4c, 0x50, 0x54,
  0x58, 0x5c, 0x60, 0x64,
  0x68, 0x6c, 0x70, 0x74,
  0x78, 0x7c, 0x80, 0x84,
  /* Floating Point Control Word.  */
  -1,
  /* Floating Point Registers.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* GPR Uppper Halves.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* GNU/Linux-specific optional "registers".  */
  0x88, -1, -1,
};
d532 20
a551 27
int s390x_regmap_gregset[S390_NUM_REGS] =
{
  /* Program Status Word.  */
  0x00, 0x08,
  /* General Purpose Registers.  */
  0x10, 0x18, 0x20, 0x28,
  0x30, 0x38, 0x40, 0x48,
  0x50, 0x58, 0x60, 0x68,
  0x70, 0x78, 0x80, 0x88,
  /* Access Registers.  */
  0x90, 0x94, 0x98, 0x9c,
  0xa0, 0xa4, 0xa8, 0xac,
  0xb0, 0xb4, 0xb8, 0xbc,
  0xc0, 0xc4, 0xc8, 0xcc,
  /* Floating Point Control Word.  */
  -1,
  /* Floating Point Registers.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* GPR Uppper Halves.  */
  0x10, 0x18, 0x20, 0x28,
  0x30, 0x38, 0x40, 0x48,
  0x50, 0x58, 0x60, 0x68,
  0x70, 0x78, 0x80, 0x88,
  /* GNU/Linux-specific optional "registers".  */
  0xd0, -1, -1,
};
d553 5
a557 23
int s390_regmap_fpregset[S390_NUM_REGS] =
{
  /* Program Status Word.  */
  -1, -1,
  /* General Purpose Registers.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* Access Registers.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* Floating Point Control Word.  */
  0x00,
  /* Floating Point Registers.  */
  0x08, 0x10, 0x18, 0x20,
  0x28, 0x30, 0x38, 0x40,
  0x48, 0x50, 0x58, 0x60,
  0x68, 0x70, 0x78, 0x80,
  /* GPR Uppper Halves.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* GNU/Linux-specific optional "registers".  */
  -1, -1, -1,
};
d559 5
a563 23
int s390_regmap_upper[S390_NUM_REGS] =
{
  /* Program Status Word.  */
  -1, -1,
  /* General Purpose Registers.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* Access Registers.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* Floating Point Control Word.  */
  -1,
  /* Floating Point Registers.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* GPR Uppper Halves.  */
  0x00, 0x04, 0x08, 0x0c,
  0x10, 0x14, 0x18, 0x1c,
  0x20, 0x24, 0x28, 0x2c,
  0x30, 0x34, 0x38, 0x3c,
  /* GNU/Linux-specific optional "registers".  */
  -1, -1, -1,
};
d565 5
a569 21
int s390_regmap_last_break[S390_NUM_REGS] =
{
  /* Program Status Word.  */
  -1, -1,
  /* General Purpose Registers.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* Access Registers.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* Floating Point Control Word.  */
  -1,
  /* Floating Point Registers.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* GPR Uppper Halves.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* GNU/Linux-specific optional "registers".  */
  -1, 4, -1,
};
a570 21
int s390x_regmap_last_break[S390_NUM_REGS] =
{
  /* Program Status Word.  */
  -1, -1,
  /* General Purpose Registers.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* Access Registers.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* Floating Point Control Word.  */
  -1,
  /* Floating Point Registers.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* GPR Uppper Halves.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* GNU/Linux-specific optional "registers".  */
  -1, 0, -1,
};
a571 21
int s390_regmap_system_call[S390_NUM_REGS] =
{
  /* Program Status Word.  */
  -1, -1,
  /* General Purpose Registers.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* Access Registers.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* Floating Point Control Word.  */
  -1,
  /* Floating Point Registers.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* GPR Uppper Halves.  */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* GNU/Linux-specific optional "registers".  */
  -1, -1, 0,
};
d579 4
a582 8
  const int *offset = regset->descr;
  int i;

  for (i = 0; i < S390_NUM_REGS; i++)
    {
      if ((regnum == i || regnum == -1) && offset[i] != -1)
	regcache_raw_supply (regcache, i, (const char *)regs + offset[i]);
    }
d594 4
a597 8
  const int *offset = regset->descr;
  int i;

  for (i = 0; i < S390_NUM_REGS; i++)
    {
      if ((regnum == i || regnum == -1) && offset[i] != -1)
	regcache_raw_collect (regcache, i, (char *)regs + offset[i]);
    }
d1705 1
a1705 3
  if (tdep->gpr_full_regnum != -1
      && regnum >= tdep->gpr_full_regnum
      && regnum < tdep->gpr_full_regnum + 16)
@


1.212
log
@	* objfiles.h (pc_in_section): New prototype.
	(in_plt_section): Remove name argument, replace prototype with
	static inline function.
	* mips-tdep.h: Include "objfiles.h".
	(in_mips_stubs_section): New function.
	* hppa-tdep.h (gdbarch_tdep): Remove name argument of
	in_solib_call_trampoline member.
	(hppa_in_solib_call_trampoline): Remove name argument.
	* objfiles.c (pc_in_section): New function.
	(in_plt_section): Remove function.
	* mips-linux-tdep.c: Include "objfiles.h".
	(mips_linux_in_dynsym_stub): Call in_mips_stubs_section.  Remove
	name argument.  Return 1 rather than the low 16-bit halfword of
	any instruction examined.
	(mips_linux_in_dynsym_resolve_code): Update
	mips_linux_in_dynsym_stub call accordingly.
	* mips-tdep.c (mips_stub_frame_sniffer): Use in_mips_stubs_section
	rather than an equivalent hand-coded sequence.
	* hppa-hpux-tdep.c (in_opd_section): Remove function.
	(hppa32_hpux_in_solib_call_trampoline): Remove name argument.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.
	(hppa64_hpux_find_global_pointer): Use pc_in_section rather than
	in_opd_section.
	* hppa-tdep.c (hppa_stub_unwind_sniffer): Remove name argument
	on call to tdep->in_solib_call_trampoline.
	(hppa_in_solib_call_trampoline): Remove name argument, update
	according to in_plt_section change.
	(hppa_skip_trampoline_code): Update according to in_plt_section
	change.
	* aarch64-tdep.c (aarch64_stub_unwind_sniffer): Likewise.
	* arm-symbian-tdep.c (arm_symbian_skip_trampoline_code):
	Likewise.
	* arm-tdep.c (arm_stub_unwind_sniffer): Likewise.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): Likewise.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Likewise.
	* nios2-tdep.c (nios2_stub_frame_sniffer): Likewise.
	* nto-tdep.c (nto_relocate_section_addresses): Likewise.
	* s390-tdep.c (s390_stub_frame_sniffer): Likewise.
	* sh-tdep.c (sh_stub_unwind_sniffer): Likewise.
	* solib-dsbt.c (dsbt_in_dynsym_resolve_code): Likewise.
	* solib-frv.c (frv_in_dynsym_resolve_code): Likewise.
	* solib-svr4.c (svr4_in_dynsym_resolve_code): Likewise.
	* solib-target.c (solib_target_in_dynsym_resolve_code): Likewise.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise.
	* tic6x-tdep.c (tic6x_stub_unwind_sniffer): Likewise.
@
text
@d1182 2
a1183 1
          && (bfd_get_section_flags (secp->bfd, secp->the_bfd_section)
@


1.211
log
@-Wpointer-sign: s390-tdep.c.

-Wpointer-sign reveals a bunch of:

../../src/gdb/s390-tdep.c:1342:7: error: pointer targets in passing argument 4 of ‘is_rx’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/s390-tdep.c:1038:1: note: expected ‘unsigned int *’ but argument is of type ‘int *’
../../src/gdb/s390-tdep.c:1343:9: error: pointer targets in passing argument 5 of ‘is_rxy’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/s390-tdep.c:1055:1: note: expected ‘unsigned int *’ but argument is of type ‘int *’
../../src/gdb/s390-tdep.c:1344:9: error: pointer targets in passing argument 5 of ‘is_rxy’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/s390-tdep.c:1055:1: note: expected ‘unsigned int *’ but argument is of type ‘int *’
...
../../src/gdb/s390-tdep.c:1363:7: error: pointer targets in passing argument 5 of ‘is_rs’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/s390-tdep.c:966:1: note: expected ‘unsigned int *’ but argument is of type ‘int *’
../../src/gdb/s390-tdep.c:1364:9: error: pointer targets in passing argument 6 of ‘is_rsy’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/s390-tdep.c:983:1: note: expected ‘unsigned int *’ but argument is of type ‘int *’
../../src/gdb/s390-tdep.c:1365:9: error: pointer targets in passing argument 6 of ‘is_rsy’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/s390-tdep.c:983:1: note: expected ‘unsigned int *’ but argument is of type ‘int *’
...

I don't know much about s390, but from reading the code I believe the
right fix is to treat d2 as signed.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* s390-tdep.c (is_rs, is_rsy, is_rx, is_rxy): Change type of 'd2'
	parameter to int *.
@
text
@d2119 1
a2119 1
  if (in_plt_section (addr_in_block, NULL)
@


1.210
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d967 1
a967 1
       unsigned int *r1, unsigned int *r3, unsigned int *d2, unsigned int *b2)
d984 1
a984 1
        unsigned int *r1, unsigned int *r3, unsigned int *d2, unsigned int *b2)
d1039 1
a1039 1
       unsigned int *r1, unsigned int *d2, unsigned int *x2, unsigned int *b2)
d1056 1
a1056 1
        unsigned int *r1, unsigned int *d2, unsigned int *x2, unsigned int *b2)
@


1.209
log
@	* configure: Rebuild.
	* configure.ac (build_warnings): Add -Wempty-body.
	* m68k-tdep.c (m68k_gdbarch_init): Remove empty 'if'.
	* remote.c (handle_notification): Use braces for empty 'else' body.
	* s390-tdep.c (s390_analyze_prologue): Use braces for empty
	'else' body.
	* sh64-tdep.c (sh64_push_dummy_call): Use braces for empty
	'else' body.
	* solib-som.c (som_relocate_section_addresses): Use braces
	for empty 'else' body.
	* ui-file.c (stdio_file_write): Use braces for empty 'if' body.
	(stdio_file_write_async_safe, stdio_file_fputs): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2001-2012 Free Software Foundation, Inc.
@


1.208
log
@	* ada-valprint.c (ada_val_print_1): Eliminate single-use
	variable LEN.
	* alpha-tdep.c (alpha_extract_return_value): Use TYPE_LENGTH
	directly.
	(alpha_store_return_value): Likewise.
	* amd64-tdep.c (amd64_classify_aggregate): Likewise.
	(amd64_push_arguments): Likewise.
	* ax-gdb.c (gen_trace_static_fields): Likewise.
	(gen_traced_pop): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* breakpoint.c (update_watchpoint): Likewise.
	* findcmd.c (parse_find_args): Use local variable for type
	instead of length.
	* findvar.c (default_read_var_value): Use TYPE_LENGTH directly.
	* h8300-tdep.c (h8300h_extract_return_value): Likewise.
	(h8300_store_return_value): Likewise.
	* i386-darwin-tdep.c (i386_darwin_push_dummy_call): Likewise.
	Use i386_darwin_arg_type_alignment directly.
	* infcall.c (call_function_by_hand): Use TYPE_LENGTH directly.
	* lm32-tdep.c (lm32_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	(m68hc11_extract_return_value): Likewise.
	* mep-tdep.c (mep_push_dummy_call): Likewise.
	* printcmd.c (float_type_from_length): Likewise.
	* s390-tdep.c (s390_value_from_register): Likewise.
	* stack.c (read_frame_arg): Likewise.
	* tracepoint.c (encode_actions_1): Likewise.
	* valops.c (value_fetch_lazy): Use local variable for type
	instead of length.  Use TYPE_LENGTH directly.
	* value.c (value_contents_equal): Use TYPE_LENGTH directly.
@
text
@d1464 8
a1471 7
        /* An instruction we don't know how to simulate.  The only
           safe thing to do would be to set every value we're tracking
           to 'unknown'.  Instead, we'll be optimistic: we assume that
	   we *can* interpret every instruction that the compiler uses
	   to manipulate any of the data we're interested in here --
	   then we can just ignore anything else.  */
        ;
@


1.207
log
@	* m2-valprint.c (m2_print_array_contents): Eliminate variable
	ELTLEN and use TYPE_LENGTH directly.
	(m2_val_print): Likewise.
	* m68k-tdep.c (m68k_svr4_extract_return_value): Eliminate
	variable LEN and use TYPE_LENGTH directly.
	(m68k_svr4_store_return_value): Likewise.
	* mips-tdep.c (mips_o32_push_dummy_call): Eliminate variable
	ARGLEN and use TYPE_LENGTH directly.
	(mips_o64_push_dummy_call): Likewise.
	* s390-tdep (s390_function_arg_pass_by_reference): Eliminate
	variable LENGTH and use TYPE_LENGTH directly.
	(s390_function_arg_float): Likewise.
	(s390_function_arg_integer): Likewise.
	(s390_push_dummy_call): Likewise.
	(s390_return_value_convention): Likewise.
	* spu-tdep.c (spu_push_dummy_call): Eliminate LEN and use
	TYPE_LENGTH directly.
@
text
@a378 1
  int len = TYPE_LENGTH (check_typedef (type));
d380 4
a383 1
  if (regnum >= S390_F0_REGNUM && regnum <= S390_F15_REGNUM && len < 8)
@


1.206
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d2492 1
a2492 2
  unsigned length = TYPE_LENGTH (type);
  if (length > 8)
d2505 1
a2505 2
  unsigned length = TYPE_LENGTH (type);
  if (length > 8)
d2516 1
a2516 2
  unsigned length = TYPE_LENGTH (type);
  if (length > 8)
d2521 1
a2521 1
	  || (is_struct_like (type) && is_power_of_two (length));
a2615 1
      unsigned length = TYPE_LENGTH (type);
d2619 1
a2619 1
          sp -= length;
d2798 1
a2798 2
  int length = TYPE_LENGTH (type);
  if (length > 8)
@


1.205
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@a1168 1
  pv_t offset;
@


1.204
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* Makefile.in (SFILES): Add `probe' and `stap-probe'.
	(COMMON_OBS): Likewise.
	(HFILES_NO_SRCDIR): Add `probe'.
	* NEWS: Mention support for static and SystemTap probes.
	* amd64-tdep.c (amd64_init_abi): Initializing proper fields used by
	SystemTap probes' arguments parser.
	* arm-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(arm_stap_is_single_operand): New function.
	(arm_stap_parse_special_token): Likewise.
	(arm_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* ax-gdb.c (require_rvalue): Removing static declaration.
	(gen_expr): Likewise.
	* ax-gdb.h (gen_expr): Declaring function.
	(require_rvalue): Likewise.
	* breakpoint.c: Include `gdb_regex.h' and `probe.h'.
	(bkpt_probe_breakpoint_ops): New variable.
	(momentary_breakpoint_from_master): Set the `probe' value.
	(add_location_to_breakpoint): Likewise.
	(break_command_1): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(bkpt_probe_insert_location): New function.
	(bkpt_probe_remove_location): Likewise.
	(bkpt_probe_create_sals_from_address): Likewise.
	(bkpt_probe_decode_linespec): Likewise.
	(tracepoint_probe_create_sals_from_address): Likewise.
	(tracepoint_probe_decode_linespec): Likewise.
	(tracepoint_probe_breakpoint_ops): New variable.
	(trace_command): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(initialize_breakpoint_ops): Initializing breakpoint_ops for
	static probes on breakpoints and tracepoints.
	* breakpoint.h (struct bp_location) <probe>: New field.
	* cli-utils.c (skip_spaces_const): New function.
	(extract_arg): Likewise.
	* cli-utils.h (skip_spaces_const): Likewise.
	(extract_arg): Likewise.
	* coffread.c (coff_sym_fns): Add `sym_probe_fns' value.
	* configure.ac: Append `stap-probe.o' to be generated when ELF
	support is present.
	* configure: Regenerate.
	* dbxread.c (aout_sym_fns): Add `sym_probe_fns' value.
	* elfread.c: Include `probe.h' and `arch-utils.h'.
	(probe_key): New variable.
	(elf_get_probes): New function.
	(elf_get_probe_argument_count): Likewise.
	(elf_evaluate_probe_argument): Likewise.
	(elf_compile_to_ax): Likewise.
	(elf_symfile_relocate_probe): Likewise.
	(stap_probe_key_free): Likewise.
	(elf_probe_fns): New variable.
	(elf_sym_fns): Add `sym_probe_fns' value.
	(elf_sym_fns_lazy_psyms): Likewise.
	(elf_sym_fns_gdb_index): Likewise.
	(_initialize_elfread): Initialize objfile cache for static
	probes.
	* gdb_vecs.h (struct probe): New forward declaration.
	(probe_p): New VEC declaration.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (stap_integer_prefix): New variable.
	(stap_integer_suffix): Likewise.
	(stap_register_prefix): Likewise.
	(stap_register_suffix): Likewise.
	(stap_register_indirection_prefix): Likewise.
	(stap_register_indirection_suffix): Likewise.
	(stap_gdb_register_prefix): Likewise.
	(stap_gdb_register_suffix): Likewise.
	(stap_is_single_operand): New function.
	(stap_parse_special_token): Likewise.
	(struct stap_parse_info): Forward declaration.
	* i386-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	(i386_elf_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* i386-tdep.h (i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	* machoread.c (macho_sym_fns): Add `sym_probe_fns' value.
	* mipsread.c (ecoff_sym_fns): Likewise.
	* objfiles.c (objfile_relocate1): Support relocation for static
	probes.
	* parse.c (prefixify_expression): Remove static declaration.
	(initialize_expout): Likewise.
	(reallocate_expout): Likewise.
	* parser-defs.h (initialize_expout): Declare function.
	(reallocate_expout): Likewise.
	(prefixify_expression): Likewise.
	* ppc-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(ppc_stap_is_single_operand): New function.
	(ppc_stap_parse_special_token): Likewise.
	(ppc_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* probe.c: New file, for generic statically defined probe support.
	* probe.h: Likewise.
	* s390-tdep.c: Including headers needed to perform the parsing of
	SystemTap probes' arguments.
	(s390_stap_is_single_operand): New function.
	(s390_gdbarch_init): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* somread.c (som_sym_fns): Add `sym_probe_fns' value.
	* stap-probe.c: New file, for SystemTap probe support.
	* stap-probe.h: Likewise.
	* symfile.h: Include `gdb_vecs.h'.
	(struct sym_probe_fns): New struct.
	(struct sym_fns) <sym_probe_fns>: New field.
	* symtab.c (init_sal): Initialize `probe' field.
	* symtab.h (struct probe): Forward declaration.
	(struct symtab_and_line) <probe>: New field.
	* tracepoint.c (start_tracing): Adjust semaphore on breakpoints
	locations.
	(stop_tracing): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add `sym_probe_fns' value.
@
text
@d2821 1
a2821 1
s390_return_value (struct gdbarch *gdbarch, struct type *func_type,
@


1.203
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d48 7
a64 1

d2962 12
d3304 6
@


1.202
log
@	* s390-tdep.c (s390_push_dummy_call): Set addressing mode bit
	in return PSWA.
@
text
@d3 1
a3 2
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
   2011 Free Software Foundation, Inc.
@


1.201
log
@	* s390-tdep.c: Replace "Linux" by "GNU/Linux" in comments
	where appropriate.
	* s390-tdep.h: Likewise.
@
text
@d2752 7
a2758 1
  /* Store return address.  */
d2760 1
a2760 1
  
@


1.201.2.1
log
@	* s390-tdep.c (s390_push_dummy_call): Set addressing mode bit
	in return PSWA.
@
text
@d2752 1
a2752 7
  /* Store return PSWA.  In 31-bit mode, keep addressing mode bit.  */
  if (word_size == 4)
    {
      ULONGEST pswa;
      regcache_cooked_read_unsigned (regcache, S390_PSWA_REGNUM, &pswa);
      bp_addr = (bp_addr & 0x7fffffff) | (pswa & 0x80000000);
    }
d2754 1
a2754 1

@


1.201.2.2
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2001-2012 Free Software Foundation, Inc.
@


1.200
log
@ChangeLog:

	* s390-tdep.h (S390_ORIG_R2_REGNUM): Define.
	(S390_LAST_BREAK_REGNUM): Likewise.
	(S390_SYSTEM_CALL_REGNUM): Likewise.
	(S390_NUM_REGS): Update.

	(s390_regmap_last_break): Add declaration.
	(s390x_regmap_last_break): Likewise.
	(s390_regmap_system_call): Likewise.

	(tdesc_s390_linux32v1): Add declaration.
	(tdesc_s390_linux32v2): Likewise.
	(tdesc_s390_linux64v1): Likewise.
	(tdesc_s390_linux64v2): Likewise.
	(tdesc_s390x_linux64v1): Likewise.
	(tdesc_s390x_linux64v2): Likewise.

	* s390-tdep.c: Include new target description files
	"features/s390-linux32v1.c", "features/s390-linux32v2.c",
	"features/s390-linux64v1.c", "features/s390-linux64v2.c",
	"features/s390x-linux64v1.c", and "features/s390x-linux64v2.c".
	(s390_cannot_store_register): New function.
	(s390_write_pc): Likewise.
	(s390_dwarf_regmap): Add fields for new registers.
	(s390_regmap_gregset): Likewise.
	(s390x_regmap_gregset): Likewise.
	(s390_regmap_fpregset): Likewise.
	(s390_regmap_upper): Likewise.
	(s390_regmap_last_break): New variable.
	(s390x_regmap_last_break): Likewise.
	(s390_regmap_system_call): Likewise.
	(s390_last_break_regset): Likewise.
	(s390x_last_break_regset): Likewise.
	(s390_system_call_regset): Likewise.
	(s390_upper_regset_sections): Rename to ...
	(s390_linux64_regset_sections): ... this.
	(s390_linux32_regset_sections): New variable.
	(s390x_linux64_regset_sections): Likewise.
	(s390_linux32v1_regset_sections): Likewise.
	(s390_linux32v2_regset_sections): Likewise.
	(s390_linux64v1_regset_sections): Likewise.
	(s390_linux64v2_regset_sections): Likewise.
	(s390x_linux64v1_regset_sections): Likewise.
	(s390x_linux64v2_regset_sections): Likewise.
	(s390_regset_from_core_section): Handle .reg-s390-last-break and
	.reg-s390-system-call core file sections.
	(s390_core_read_description): Check for presence of
	.reg-s390-last-break and .reg-s390-system-call core file
	sections and return appropriate target description.
	(s390_gdbarch_init): Detect Linux-specific registers "orig_r2",
	"last_break" and "system_call" in target description.  Install
	appropriate gdbarch_core_regset_sections array.
	Call set_gdbarch_cannot_store_register and set_gdbarch_write_pc.
	(_initialize_s390_tdep): Initialize additional target descriptions.

	* s390-nat.c: Include "elf/common.h".
	(PTRACE_GETREGSET, PTRACE_SETREGSET): Define if undefined.
	(have_regset_last_break): New static variable.
	(have_regset_system_call): Likewise.
	(s390_native_supply): Handle S390_ORIG_R2_REGNUM.
	(s390_native_collect): Likewise.
	(fetch_regset, store_regset, check_regset): New functions.
	(s390_linux_fetch_inferior_registers): Handle S390_LAST_BREAK_REGNUM
	and S390_SYSTEM_CALL_REGNUM.
	(s390_linux_store_inferior_registers): Likewise.
	(s390_read_description): Check for presence of NT_S390_LAST_BREAK
	and NT_S390_SYSTEM_CALL regsets and use appropriate description.

	* features/Makefile (WHICH): Add s390-linux32v1, s390-linux64v1,
	s390x-linux64v1, s390-linux32v2, s390-linux64v2, and s390x-linux64v2.
	(s390-linux32v1-expedite): Define.
	(s390-linux32v2-expedite): Likewise.
	(s390-linux64v1-expedite): Likewise.
	(s390-linux64v2-expedite): Likewise.
	(s390x-linux64v1-expedite): Likewise.
	(s390x-linux64v2-expedite): Likewise.

	* features/s390-linux32.xml: Add orig_r2 register.
	* features/s390-linux64.xml: Likewise.
	* features/s390x-linux64.xml: Likewise.
	* features/s390-linux32v1.xml: New file.
	* features/s390-linux32v2.xml: Likewise.
	* features/s390-linux64v1.xml: Likewise.
	* features/s390-linux64v2.xml: Likewise.
	* features/s390x-linux64v1.xml: Likewise.
	* features/s390x-linux64v2.xml: Likewise.

	* features/s390-linux32.c: Regenerate.
	* features/s390-linux64.c: Likewise.
	* features/s390x-linux64.c: Likewise.
	* features/s390-linux32v1.c: New generated file.
	* features/s390-linux32v2.c: Likewise.
	* features/s390-linux64v1.c: Likewise.
	* features/s390-linux64v2.c: Likewise.
	* features/s390x-linux64v1.c: Likewise.
	* features/s390x-linux64v2.c: Likewise.

	* regformats/s390-linux32.dat: Regenerate.
	* regformats/s390-linux64.dat: Regenerate.
	* regformats/s390x-linux64.dat: Regenerate.
	* regformats/s390-linux32v1.dat: New generated file.
	* regformats/s390-linux32v2.dat: Likewise.
	* regformats/s390-linux64v1.dat: Likewise.
	* regformats/s390-linux64v2.dat: Likewise.
	* regformats/s390x-linux64v1.dat: Likewise.
	* regformats/s390x-linux64v2.dat: Likewise.

gdbserver/ChangeLog:

	* Makefile.in (s390-linux32v1.o, s390-linux32v1.c): New rules.
	(s390-linux32v2.o, s390-linux32v2.c): Likewise.
	(s390-linux64v1.o, s390-linux64v1.c): Likewise.
	(s390-linux64v2.o, s390-linux64v2.c): Likewise.
	(s390x-linux64v1.o, s390x-linux64v1.c): Likewise.
	(s390x-linux64v2.o, s390x-linux64v2.c): Likewise.
	* configure.srv [s390*-*-linux*] (srv_regobj): Add new objects.
	(srv_xmlfiles): Add new XML files.

	* linux-s390-low.c: Include "elf/common.h", <sys/ptrace.h>,
	and <sys/uio.h>.
	(PTRACE_GETREGSET, PTRACE_SETREGSET): Define if undefined.
	(init_registers_s390_linux32v1): Add prototype.
	(init_registers_s390_linux32v2): Likewise.
	(init_registers_s390_linux64v1): Likewise.
	(init_registers_s390_linux64v2): Likewise.
	(init_registers_s390x_linux64v1): Likewise.
	(init_registers_s390x_linux64v2): Likewise.
	(s390_num_regs): Increment to 52.
	(s390_regmap): Add orig_r2 register.
	(s390_num_regs_3264): Increment to 68.
	(s390_regmap_3264): Add orig_r2 register.
	(s390_collect_ptrace_register): Handle orig_r2 register.
	(s390_supply_ptrace_register): Likewise.
	(s390_fill_last_break): New function.
	(s390_store_last_break): Likewise.
	(s390_fill_system_call): New function.
	(s390_store_system_call): Likewise.
	(target_regsets): Handle NT_S390_LAST_BREAK and NT_S390_SYSTEM_CALL
	register sets.
	(s390_check_regset): New function.
	(s390_arch_setup): Check for presence of NT_S390_LAST_BREAK and
	NT_S390_SYSTEM_CALL regsets and use appropriate description.
	Update target_regsets for available register sets.

testsuite/ChangeLog:

	* gdb.base/callfuncs.exp (fetch_all_registers): Filter out read-only
	last_break register on s390*-*-* targets.
@
text
@d173 1
a173 1
  /* Linux-specific registers (not mapped).  */
d429 1
a429 1
  /* Linux-specific optional "registers".  */
d457 1
a457 1
  /* Linux-specific optional "registers".  */
d481 1
a481 1
  /* Linux-specific optional "registers".  */
d505 1
a505 1
  /* Linux-specific optional "registers".  */
d527 1
a527 1
  /* Linux-specific optional "registers".  */
d549 1
a549 1
  /* Linux-specific optional "registers".  */
d571 1
a571 1
  /* Linux-specific optional "registers".  */
d3071 1
a3071 1
      /* Optional Linux-specific "registers".  */
d3293 1
a3293 1
  /* Initialize the Linux target descriptions.  */
@


1.199
log
@ChangeLog:

	* s390-nat.c (SUBOFF): Remove.
	(s390_native_supply, s390_native_collect): New functions.
	(supply_gregset, supply_fpregset): Use s390_native_supply.
	(fill_gregset, fill_fpregset): Use s390_native_collect.

	* s390-tdep.c (s390_pseudo_register_reggroup_p): Update comment.
	(s390_unwind_pseudo_register): New function.
	(s390_prologue_frame_unwind_cache): Unwind PSW address and mask
	registers instead of PC and CC.
	(s390_backchain_frame_unwind_cache): Likewise.
	(s390_sigtramp_frame_unwind_cache): Do not unwind PC, CC, or
	full GPR pseudos.
	(s390_trad_frame_prev_register): New function.
	(s390_frame_prev_register): Use it.
	(s390_sigtramp_frame_prev_register): Likewise.
	(s390_dwarf2_prev_register): Use s390_unwind_pseudo_register.
	(s390_dwarf2_frame_init_reg): Unwind PSW address and mask.  Use
	special callback to unwind any pseudo.

	* features/s390-core32.xml: Add pswm/pswa to save/restore group.
	* features/s390-core64.xml: Likewise.
	* features/s390x-core64.xml: Likewise.
	* features/s390-linux32.c: Regenerate.
	* features/s390-linux64.c: Likewise.
	* features/s390x-linux64.c: Likewise.

gdbserver/ChangeLog:

	* linux-s390-low.c (s390_collect_ptrace_register): Fully convert
	PSW address/mask between 8-byte and 16-byte formats.
	(s390_supply_ptrace_register): Likewise.
	(s390_get_pc, s390_set_pc): 4-byte PSW address always includes
	basic addressing mode bit.
@
text
@d50 2
d53 2
d56 2
d110 26
d172 3
d429 2
d457 2
d481 2
d505 68
d634 60
a693 1
static struct core_regset_section s390_upper_regset_sections[] =
d698 9
d710 18
d745 7
d760 2
d769 6
a774 1
      return high_gprs? tdesc_s390_linux64 : tdesc_s390_linux32;
d777 2
a778 1
      return tdesc_s390x_linux64;
d2962 2
d3071 19
d3147 2
a3148 2
  if (have_upper)
    set_gdbarch_core_regset_sections (gdbarch, s390_upper_regset_sections);
d3214 25
d3258 10
d3295 2
d3298 2
d3301 2
@


1.198
log
@	* s390-tdep.c (s390_gdbarch_init): Call set_gdbarch_get_siginfo_type.
@
text
@d355 8
a362 2
  /* PC and CC pseudo registers need to be saved/restored in order to
     push or pop frames.  */
d1458 73
a1546 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1672 1
a1672 1
  trad_frame_set_unknown (info->saved_regs, tdep->cc_regnum);
d1690 1
a1690 1
  info->saved_regs[tdep->pc_regnum] = info->saved_regs[S390_RETADDR_REGNUM];
d1697 1
a1697 1
      && !trad_frame_addr_p (info->saved_regs, tdep->pc_regnum))
d1699 1
a1699 1
      info->saved_regs[tdep->pc_regnum].realreg = S390_RETADDR_REGNUM;
d1709 1
a1709 1
	  || !trad_frame_addr_p (info->saved_regs, tdep->pc_regnum))
a1729 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1743 1
a1743 1
  trad_frame_set_unknown (info->saved_regs, tdep->cc_regnum);
d1765 1
a1765 1
      info->saved_regs[tdep->pc_regnum]
a1818 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1822 1
a1822 18
  /* Unwind full GPRs to show at least the lower halves (as the
     upper halves are undefined).  */
  if (tdep->gpr_full_regnum != -1
      && regnum >= tdep->gpr_full_regnum
      && regnum < tdep->gpr_full_regnum + 16)
    {
      int reg = regnum - tdep->gpr_full_regnum + S390_R0_REGNUM;
      struct value *val, *newval;

      val = trad_frame_get_prev_register (this_frame, info->saved_regs, reg);
      newval = value_cast (register_type (gdbarch, regnum), val);
      if (value_optimized_out (val))
	set_value_optimized_out (newval, 1);

      return newval;
    }

  return trad_frame_get_prev_register (this_frame, info->saved_regs, regnum);
a1849 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1862 1
a1862 1
  info->saved_regs[tdep->pc_regnum].realreg = S390_RETADDR_REGNUM;
d1887 1
a1887 1
  return trad_frame_get_prev_register (this_frame, info->saved_regs, regnum);
a1935 1
  ULONGEST pswm;
a1987 10
  /* Point PC to PSWA as well.  */
  info->saved_regs[tdep->pc_regnum] = info->saved_regs[S390_PSWA_REGNUM];

  /* Extract CC from PSWM.  */
  pswm = read_memory_unsigned_integer (
			info->saved_regs[S390_PSWM_REGNUM].addr,
			word_size, byte_order);
  trad_frame_set_value (info->saved_regs, tdep->cc_regnum,
			(pswm >> (8 * word_size - 20)) & 3);

a2021 16
  /* Provide read-only copies of the full registers.  */
  if (tdep->gpr_full_regnum != -1)
    for (i = 0; i < 16; i++)
      {
	ULONGEST low, high;
	low = read_memory_unsigned_integer (
			info->saved_regs[S390_R0_REGNUM + i].addr,
			4, byte_order);
	high = read_memory_unsigned_integer (
			info->saved_regs[S390_R0_UPPER_REGNUM + i].addr,
			4, byte_order);
	
	trad_frame_set_value (info->saved_regs, tdep->gpr_full_regnum + i,
			      (high << 32) | low);
      }

d2049 1
a2049 1
  return trad_frame_get_prev_register (this_frame, info->saved_regs, regnum);
d2132 1
a2132 11
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int reg = regnum - tdep->gpr_full_regnum;
  struct value *val, *newval;

  val = frame_unwind_register_value (this_frame, S390_R0_REGNUM + reg);
  newval = value_cast (register_type (gdbarch, regnum), val);
  if (value_optimized_out (val))
    set_value_optimized_out (newval, 1);

  return newval;
d2142 8
d2152 1
a2152 1
  if (regnum >= 0 && regnum < S390_NUM_REGS)
d2160 2
a2161 13
  /* The CC pseudo register is call-clobbered.  */
  else if (regnum == tdep->cc_regnum)
    reg->how = DWARF2_FRAME_REG_UNDEFINED;

  /* The PC register unwinds to the return address.  */
  else if (regnum == tdep->pc_regnum)
    reg->how = DWARF2_FRAME_REG_RA;

  /* We install a special function to unwind full GPRs to show at
     least the lower halves (as the upper halves are undefined).  */
  else if (tdep->gpr_full_regnum != -1
	   && regnum >= tdep->gpr_full_regnum
	   && regnum < tdep->gpr_full_regnum + 16)
@


1.197
log
@	* s390-tdep.c (s390_displaced_step_fixup): Fix processing of LARL
	instruction.  Add more diagnostic output.
@
text
@d2995 2
@


1.196
log
@	* s390-tdep.c (s390_function_arg_pass_by_reference): Handle
	complex and vector types.
	(s390_return_value_convention): Likewise.

	(s390_value_from_register): Call check_typedef.
	(extend_simple_arg): Likewise.
	(alignment_of): Likewise.
	(s390_push_dummy_call): Likewise.
	(s390_return_value): Likewise.
@
text
@d1373 1
a1373 1
			"displaced: (s390) fixup (%s, %s) pc %s amode 0x%x\n",
d1375 1
a1375 1
			paddress (gdbarch, pc), (int) amode);
d1431 2
d1435 1
a1435 1
				      amode | (from + insnlen + i2*2));
d1445 5
@


1.195
log
@gdb/
	* ada-lang.c: Fix typos.
	* amd64-tdep.c: Likewise.
	* breakpoint.c: Likewise.
	* cli/cli-decode.c: Likewise.
	* findcmd.c: Likewise.
	* inline-frame.c: Likewise.
	* mi/mi-main.c: Likewise.
	* minsyms.c: Likewise.
	* monitor.c: Likewise.
	* monitor.h: Likewise.
	* prologue-value.c: Likewise.
	* reverse.c: Likewise.
	* s390-tdep.c: Likewise.

gdb/testsuite/
	* gdb.base/call-sc.c: Likewise.
	* gdb.base/ifelse.exp: Likewise.
	* gdb.base/structs.c: Likewise.

gdb/doc/
	* gdb.texinfo: Likewise.
@
text
@d339 1
a339 1
  int len = TYPE_LENGTH (type);
d2257 3
a2259 2
  /* FIXME: All complex and vector types are also returned by reference.  */
  return is_struct_like (type) && !is_power_of_two (length);
d2294 1
a2294 1
  struct type *type = value_type (arg);
d2327 2
a2328 1
          int field_alignment = alignment_of (TYPE_FIELD_TYPE (type, i));
d2379 1
a2379 1
      struct type *type = value_type (arg);
d2432 1
a2432 1
        struct type *type = value_type (arg);
d2566 1
d2581 7
a2587 3
  int length = TYPE_LENGTH (type);
  enum return_value_convention rvc = 
			s390_return_value_convention (gdbarch, type);
@


1.194
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d1310 1
a1310 1
     preceeding pc and check whether it is an LM-type instruction
@


1.193
log
@	gdb/
	* regcache.h (regcache_raw_read, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_part)
	(regcache_cooked_read, regcache_cooked_read_signed)
	(regcache_cooked_read_unsigned, regcache_cooked_read_part)
	(regcache_cooked_read_ftype): Change return to enum
	register_status.
	* regcache.c: Include exceptions.h
	(regcache_save): Adjust to handle REG_UNAVAILABLE registers.
	(do_cooked_read): Change return to enum register_status.  Always
	forward to regcache_cooked_read.
	(regcache_raw_read): Change return to enum register_status.  If
	the register is not REG_VALID, memset the buffer.  Return the
	register's status.
	(regcache_raw_read_signed): Handle non-REG_VALID registers and
	return the register's status.
	(regcache_raw_read_unsigned): Ditto.
	(regcache_cooked_read): Change return to enum register_status.
	Assert that with read-only regcaches, the register's status must
	be known.  If the regcache is read-only, and the register is not
	REG_VALID, memset the buffer.  Return the register's status.
	(regcache_cooked_read_signed): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_cooked_read_unsigned): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_xfer_part, regcache_raw_read_part)
	(regcache_cooked_read_part): Change return to enum
	register_status.  Return the register's status.
	(regcache_read_pc): Throw NOT_AVAILABLE_ERROR if the register is
	unavailable.
	(regcache_dump): Handle unavailable cooked registers.
	* frame.c (do_frame_register_read): Adjust interface to match
	regcache_cooked_read_ftype.
	* gdbarch.sh (pseudo_register_read): Change return to enum
	register_status.
	* gdbarch.h, gdbarch.c: Regenerate.

	* i386-tdep.h (i386_pseudo_register_read): Change return to enum
	register_status.
	* i386-tdep.c (i386_pseudo_register_read): Change return to enum
	register_status.  If reading a raw register indicates the raw
	register is not valid, return the raw register's status,
	otherwise, return REG_VALID.
	* amd64-tdep.c (amd64_pseudo_register_read): Change return to enum
	register_status.  Handle non-REG_VALID raw registers and return
	the register's status.
	* arm-tdep.c (arm_neon_quad_read)
	(arm_pseudo_read): Change return to enum register_status.  Handle
	non-REG_VALID raw registers and return the register's status.
	* avr-tdep.c (avr_pseudo_register_read): Ditto.
	* frv-tdep.c (frv_pseudo_register_read): Ditto.
	* h8300-tdep.c (h8300_pseudo_register_read): Ditto.
	* hppa-tdep.c (hppa_pseudo_register_read): Ditto.
	* m32c-tdep.c (m32c_move_reg_t): Change return to enum
	register_status.
	(m32c_raw_read, m32c_raw_write, m32c_banked_read)
	(m32c_banked_write, m32c_sb_read, m32c_sb_write, m32c_part_read)
	(m32c_part_write, m32c_cat_read, m32c_cat_write)
	(m32c_r3r2r1r0_read, m32c_r3r2r1r0_write)
	(m32c_pseudo_register_read): Change return to enum
	register_status.  Adjust.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* mep-tdep.c (mep_pseudo_cr32_read): Change return to enum
	register_status.  Return the register's status.
	(mep_pseudo_cr64_read, mep_pseudo_register_read): Ditto.
	* mips-tdep.c (mips_pseudo_register_read): Ditto.
	* mt-tdep.c (mt_pseudo_register_read): Ditto.
	* rs6000-tdep.c (move_ev_register_func): New typedef.
	(e500_move_ev_register): Use it.  Change return to enum
	register_status.  Return the register's status.
	(do_regcache_raw_read): New function.
	(do_regcache_raw_write): New function.
	(e500_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.  Use
	do_regcache_raw_read.
	(e500_pseudo_register_write): Adjust.  Use do_regcache_raw_write.
	(dfp_pseudo_register_read): Change return to enum register_status.
	Return the register's status.
	(vsx_pseudo_register_read): Ditto.
	(efpr_pseudo_register_read): Ditto.
	(rs6000_pseudo_register_read): Ditto.
	* s390-tdep.c (s390_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh64-tdep.c (pseudo_register_read_portions): New function.
	(sh64_pseudo_register_read): Change return to enum
	register_status.  Use pseudo_register_read_portions.  Return the
	register's status.
	* ia64-tdep.c (ia64_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh-tdep.c (pseudo_register_read_portions): New function.
	(sh_pseudo_register_read): Change return to enum register_status.
	Use pseudo_register_read_portions.  Return the register's status.
	* sparc-tdep.c (sparc32_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* sparc64-tdep.c (sparc64_pseudo_register_read): Ditto.
	* spu-tdep.c (spu_pseudo_register_read_spu)
	(spu_pseudo_register_read): Ditto.
	* xtensa-tdep.c (xtensa_register_read_masked)
	(xtensa_pseudo_register_read): Ditto.
	* bfin-tdep.c (bfin_pseudo_register_read): Ditto.
@
text
@d1761 1
d1845 1
d2037 1
@


1.192
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d219 1
a219 1
static void
d230 10
a239 5
      regcache_raw_read_unsigned (regcache, S390_PSWA_REGNUM, &val);
      if (register_size (gdbarch, S390_PSWA_REGNUM) == 4)
	val &= 0x7fffffff;
      store_unsigned_integer (buf, regsize, byte_order, val);
      return;
d244 12
a255 7
      regcache_raw_read_unsigned (regcache, S390_PSWM_REGNUM, &val);
      if (register_size (gdbarch, S390_PSWA_REGNUM) == 4)
	val = (val >> 12) & 3;
      else
	val = (val >> 44) & 3;
      store_unsigned_integer (buf, regsize, byte_order, val);
      return;
d262 1
d264 1
d267 10
a276 6
      regcache_raw_read_unsigned (regcache, S390_R0_REGNUM + regnum, &val);
      regcache_raw_read_unsigned (regcache, S390_R0_UPPER_REGNUM + regnum,
				  &val_upper);
      val |= val_upper << 32;
      store_unsigned_integer (buf, regsize, byte_order, val);
      return;
@


1.191
log
@run copyright.sh for 2011.
@
text
@d962 2
a963 1
s390_check_for_saved (void *data_untyped, pv_t addr, CORE_ADDR size, pv_t value)
d1122 2
a1123 1
      /* STMY r1, r3, d2(b2) --- store multiple (long-displacement version).  */
d1537 1
a1537 1
     code at a point where the frame pointer has already been restored.  
d1870 1
a1870 1
	ucontext (contains sigregs at offset 5 words)  */
d1881 1
a1881 1
	pointer to sigregs  */
d2459 2
a2460 1
					      extend_simple_arg (gdbarch, arg));
d2640 2
a2641 1
s390_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr)
d2677 2
a2678 1
s390_address_class_name_to_type_flags (struct gdbarch *gdbarch, const char *name,
@


1.190
log
@	* s390-tdep.c: Include linux-tdep.h.
	(s390_gdbarch_init): Call linux_init_abi.
@
text
@d3 2
a4 2
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
@


1.189
log
@	* s390-tdep.c (s390_push_dummy_call): Error on stack overflow
	during inferior call stack frame setup.
@
text
@d46 1
a46 1

d2912 4
@


1.188
log
@        * features/Makefile (WHICH): Add s390-linux32, s390-linux64,
	and s390x-linux64.
	(s390-linux32-expedite): Define.
	(s390-linux64-expedite): Define.
	(s390x-linux64-expedite): Define.
	* features/s390-acr.xml: New file.
	* features/s390-fpr.xml: New file.
	* features/s390-core32.xml: New file.
	* features/s390-core64.xml: New file.
	* features/s390x-core64.xml: New file.
	* features/s390-linux32.xml: New file.
	* features/s390-linux64.xml: New file.
	* features/s390x-linux64.xml: New file.
	* features/s390-linux32.c: New generated file.
	* features/s390-linux64.c: New generated file.
	* features/s390x-linux64.c: New generated file.

	* regformats/s390-linux32.dat: New generated file.
	* regformats/s390-linux64.dat: New generated file.
	* regformats/s390x-linux64.dat: New generated file.
	* regformats/reg-s390.dat: Remove.
	* regformats/reg-s390x.dat: Remove.

	* s390-nat.c: Include "auxv.h" and <elf.h>.
	(HWCAP_S390_HIGH_GPRS): Define if undefined.
	(s390_target_wordsize): New function.
	(s390_auxv_parse): Likewise.
	(s390_get_hwcap): Likewise.
	(s390_read_description): Likewise.
	(_initialize_s390_nat): Install s390_auxv_parse and
	s390_read_description.

	* s390-tdep.c: Include "features/s390-linux32.c",
	"features/s390-linux64.c", and "features/s390x-linux64.c".
	(struct gdbarch_tdep): Add gpr_full_regnum, pc_regnum, and cc_regnum.
	(s390_register_call_saved): New function.
	(s390_register_name): Remove.
	(s390_register_type): Remove.
	(s390_dwarf_regmap): Add lower half GPR pseudo DWARF CFI regnums.
	(s390_dwarf_reg_to_regnum): Remap GPR regnums to full GPRs.
	(s390_adjust_frame_regnum): Remap GPR regnums to lower halves for CFI.
	(s390_pseudo_register_name): New function.
	(s390_pseudo_register_type): New function.
	(s390_pseudo_register_read): Handle both 32-bit and 64-bit cases.
	Handle full GPR pesudos and varying pseudo register numbers.
	(s390_pseudo_register_write): Likewise
	(s390x_pseudo_register_read): Remove.
	(s390x_pseudo_register_write): Likewise.
	(s390_register_group): Remove.
	(s390_pseudo_register_group): New function.
	(s390_regmap_gregset): Add GPR upper halves.
	(s390x_regmap_gregset): Likewise.
	(s390_regmap_fpregset): Likewise.
	(s390_regmap_upper): New global variable.
	(s390_upper_regset): New global variable.
	(s390_upper_regset_sections): New global variable.
	(s390_regset_from_core_section): Handle GPR upper halves.
	(s390_core_read_description): New function.
	(s390_prologue_frame_unwind_cache): Set up ABI call-saved/clobbered
	register information.  Handle varying pseudo register numbers.
	(s390_backchain_frame_unwind_cache): Likewise.
	(s390_frame_prev_register): Unwind full GPRs to show lower halves.
	(s390_stub_frame_unwind_cache): Handle varying pseudo register numbers.
	(s390_sigtramp_frame_unwind_cache): Unwind PSWM and PSWA as well as
	PC and CC pseudos.  Unwind upper halves and full GPRs as appropriate.
	Handle varying pseudo register numbers.
	(s390_unwind_pc): Handle varying pseudo register numbers.
	(s390_dwarf2_prev_register): New function.
	(s390_dwarf2_frame_init_reg): Set up ABI call-saved/clobbered
	register information.  Handle varying pseudo register numbers.
	Install s390_dwarf2_prev_register to unwind full GPRs.
	(s390_gdbarch_init): Handle target descriptions.  Assign varying
	pseudo register numbers.  Install s390_adjust_frame_regnum.
	(_initialize_s390_tdep): Initialize target descriptions.

	* s390-tdep.h (S390_R0_UPPER_REGNUM .. S390_R15_UPPER_REGNUM): Define.
	(S390_NUM_REGS): Redefine to include upper half registers.
	(S390_PC_REGNUM, S390_CC_REGNUM): Remove.
	(S390_NUM_PSEUDO_REGS, S390_NUM_TOTAL_REGS): Likewise.
	(tdesc_s390_linux32): Add declaration.
	(tdesc_s390_linux64): Likewise.
	(tdesc_s390x_linux64): Likewise.

gdb/testsuite/
	* gdb.xml/tdesc-regs.exp: Support s390*-*-* targets.

gdbserver/
	* Makefile.in (clean): Remove new generated files.
	(reg-s390.o, reg-s390.c): Remove rules.
	(reg-s390x.o, reg-s390x.c): Likewise.
	(s390-linux32.o, s390-linux32.c): Add rules.
	(s390-linux64.o, s390-linux64.c): Likewise.
	(s390x-linux64.o, s390x-linux64.c): Likewise.
	* configure.srv (s390*-*-linux*): Update srv_regobj and srv_xmlfiles.
	* linux-s390-low.c: Include <elf.h>.
	(HWCAP_S390_HIGH_GPRS): Define if undefined.
	(init_registers_s390): Remove prototype.
	(init_registers_s390x): Likewise.
	(init_registers_s390_linux32): Add prototype.
	(init_registers_s390_linux64): Likewise.
	(init_registers_s390x_linux64): Likewise.
	(s390_num_regs_3264): New define.
	(s390_regmap_3264): New global variable.
	(s390_cannot_fetch_register): Remove obsolete check.
	(s390_cannot_store_register): Likewise.
	(s390_collect_ptrace_register): Handle upper/lower register halves.
	(s390_supply_ptrace_register): Likewise.
	(s390_fill_gregset): Update to register number changes.
	(s390_get_hwcap): New routine.
	(s390_arch_setup): Detect 32-bit process running on 64-bit system.
	Install appropriate regmap and register set.
@
text
@a2345 1
  ULONGEST orig_sp;
d2352 1
a2352 1
  /* Build the reference-to-copy area.  */
a2362 1
          write_memory (sp, value_contents (arg), length);
d2377 13
d2396 1
a2396 1
    CORE_ADDR starg = sp;
d2414 4
a2492 5
  /* Allocate the standard frame areas: the register save area, the
     word reserved for the compiler (which seems kind of meaningless),
     and the back chain pointer.  */
  sp -= 16*word_size + 32;

@


1.187
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d49 4
d61 5
d75 4
a78 3
/* Return the name of register REGNUM.  */
static const char *
s390_register_name (struct gdbarch *gdbarch, int regnum)
d80 3
a82 1
  static const char *register_names[S390_NUM_TOTAL_REGS] =
d84 7
a90 16
      /* Program Status Word.  */
      "pswm", "pswa",
      /* General Purpose Registers.  */
      "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
      "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
      /* Access Registers.  */
      "acr0", "acr1", "acr2", "acr3", "acr4", "acr5", "acr6", "acr7",
      "acr8", "acr9", "acr10", "acr11", "acr12", "acr13", "acr14", "acr15",
      /* Floating Point Control Word.  */
      "fpc",
      /* Floating Point Registers.  */
      "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
      "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15",
      /* Pseudo registers.  */
      "pc", "cc",
    };
d92 5
a96 3
  gdb_assert (regnum >= 0 && regnum < S390_NUM_TOTAL_REGS);
  return register_names[regnum];
}
d98 2
a99 19
/* Return the GDB type object for the "standard" data type of data in
   register REGNUM.  */
static struct type *
s390_register_type (struct gdbarch *gdbarch, int regnum)
{
  if (regnum == S390_PSWM_REGNUM || regnum == S390_PSWA_REGNUM)
    return builtin_type (gdbarch)->builtin_long;
  if (regnum >= S390_R0_REGNUM && regnum <= S390_R15_REGNUM)
    return builtin_type (gdbarch)->builtin_long;
  if (regnum >= S390_A0_REGNUM && regnum <= S390_A15_REGNUM)
    return builtin_type (gdbarch)->builtin_int;
  if (regnum == S390_FPC_REGNUM)
    return builtin_type (gdbarch)->builtin_int;
  if (regnum >= S390_F0_REGNUM && regnum <= S390_F15_REGNUM)
    return builtin_type (gdbarch)->builtin_double;
  if (regnum == S390_PC_REGNUM)
    return builtin_type (gdbarch)->builtin_func_ptr;
  if (regnum == S390_CC_REGNUM)
    return builtin_type (gdbarch)->builtin_int;
d101 1
a101 1
  internal_error (__FILE__, __LINE__, _("invalid regnum"));
d104 1
d133 7
a139 1
  S390_PSWA_REGNUM
d147 8
a154 1
  int regnum = -1;
d157 1
a157 1
    regnum = s390_dwarf_regmap[reg];
d159 3
a161 2
  if (regnum == -1)
    warning (_("Unmapped DWARF Register #%d encountered."), reg);
d163 7
a169 1
  return regnum;
a171 1
/* Pseudo registers - PC and condition code.  */
d173 4
a176 3
static void
s390_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int regnum, gdb_byte *buf)
d178 1
a178 2
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  ULONGEST val;
d180 2
a181 6
  switch (regnum)
    {
    case S390_PC_REGNUM:
      regcache_raw_read_unsigned (regcache, S390_PSWA_REGNUM, &val);
      store_unsigned_integer (buf, 4, byte_order, val & 0x7fffffff);
      break;
d183 2
a184 4
    case S390_CC_REGNUM:
      regcache_raw_read_unsigned (regcache, S390_PSWM_REGNUM, &val);
      store_unsigned_integer (buf, 4, byte_order, (val >> 12) & 3);
      break;
d186 9
a194 2
    default:
      internal_error (__FILE__, __LINE__, _("invalid regnum"));
d196 2
d200 2
a201 3
static void
s390_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int regnum, const gdb_byte *buf)
d203 4
a206 2
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  ULONGEST val, psw;
d208 2
a209 8
  switch (regnum)
    {
    case S390_PC_REGNUM:
      val = extract_unsigned_integer (buf, 4, byte_order);
      regcache_raw_read_unsigned (regcache, S390_PSWA_REGNUM, &psw);
      psw = (psw & 0x80000000) | (val & 0x7fffffff);
      regcache_raw_write_unsigned (regcache, S390_PSWA_REGNUM, psw);
      break;
d211 4
a214 6
    case S390_CC_REGNUM:
      val = extract_unsigned_integer (buf, 4, byte_order);
      regcache_raw_read_unsigned (regcache, S390_PSWM_REGNUM, &psw);
      psw = (psw & ~((ULONGEST)3 << 12)) | ((val & 3) << 12);
      regcache_raw_write_unsigned (regcache, S390_PSWM_REGNUM, psw);
      break;
d216 1
a216 3
    default:
      internal_error (__FILE__, __LINE__, _("invalid regnum"));
    }
d220 2
a221 2
s390x_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			    int regnum, gdb_byte *buf)
d223 1
d225 1
d228 1
a228 1
  switch (regnum)
d230 6
a235 3
    case S390_PC_REGNUM:
      regcache_raw_read (regcache, S390_PSWA_REGNUM, buf);
      break;
d237 2
a238 1
    case S390_CC_REGNUM:
d240 22
a261 2
      store_unsigned_integer (buf, 4, byte_order, (val >> 44) & 3);
      break;
d263 1
a263 3
    default:
      internal_error (__FILE__, __LINE__, _("invalid regnum"));
    }
d267 2
a268 2
s390x_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			     int regnum, const gdb_byte *buf)
d270 1
d272 1
d275 1
a275 1
  switch (regnum)
d277 9
a285 3
    case S390_PC_REGNUM:
      regcache_raw_write (regcache, S390_PSWA_REGNUM, buf);
      break;
d287 3
a289 2
    case S390_CC_REGNUM:
      val = extract_unsigned_integer (buf, 4, byte_order);
d291 20
a310 3
      psw = (psw & ~((ULONGEST)3 << 44)) | ((val & 3) << 44);
      regcache_raw_write_unsigned (regcache, S390_PSWM_REGNUM, psw);
      break;
d312 1
a312 3
    default:
      internal_error (__FILE__, __LINE__, _("invalid regnum"));
    }
d334 2
a335 2
s390_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			  struct reggroup *group)
d339 1
a339 12
  /* Registers displayed via 'info regs'.  */
  if (group == general_reggroup)
    return (regnum >= S390_R0_REGNUM && regnum <= S390_R15_REGNUM)
	   || regnum == S390_PC_REGNUM
	   || regnum == S390_CC_REGNUM;

  /* Registers displayed via 'info float'.  */
  if (group == float_reggroup)
    return (regnum >= S390_F0_REGNUM && regnum <= S390_F15_REGNUM)
	   || regnum == S390_FPC_REGNUM;

  /* Registers that need to be saved/restored in order to
d342 1
a342 1
    return regnum != S390_PSWM_REGNUM && regnum != S390_PSWA_REGNUM;
d369 3
d376 1
d393 5
d417 25
d497 14
d525 3
d531 22
d1563 8
d1576 3
a1578 2
  for (i = 6; i <= 15; i++)
    if (data.gpr_slot[i] != 0)
d1581 4
a1584 15
  switch (tdep->abi)
    {
    case ABI_LINUX_S390:
      if (data.fpr_slot[4] != 0)
        info->saved_regs[S390_F4_REGNUM].addr = cfa - data.fpr_slot[4];
      if (data.fpr_slot[6] != 0)
        info->saved_regs[S390_F6_REGNUM].addr = cfa - data.fpr_slot[6];
      break;

    case ABI_LINUX_ZSERIES:
      for (i = 8; i <= 15; i++)
	if (data.fpr_slot[i] != 0)
	  info->saved_regs[S390_F0_REGNUM + i].addr = cfa - data.fpr_slot[i];
      break;
    }
d1587 1
a1587 1
  info->saved_regs[S390_PC_REGNUM] = info->saved_regs[S390_RETADDR_REGNUM];
d1594 1
a1594 1
      && !trad_frame_addr_p (info->saved_regs, S390_PC_REGNUM))
d1596 1
a1596 1
      info->saved_regs[S390_PC_REGNUM].realreg = S390_RETADDR_REGNUM;
d1606 1
a1606 1
	  || !trad_frame_addr_p (info->saved_regs, S390_PC_REGNUM))
d1627 1
d1633 9
d1663 2
a1664 1
      info->saved_regs[S390_PC_REGNUM] = info->saved_regs[S390_RETADDR_REGNUM];
d1716 2
d1720 18
d1765 1
d1778 1
a1778 1
  info->saved_regs[S390_PC_REGNUM].realreg = S390_RETADDR_REGNUM;
d1845 1
d1850 2
a1851 1
  CORE_ADDR next_ra, next_cfa, sigreg_ptr;
d1872 3
d1884 3
d1898 2
a1899 1
  /* Let's ignore the PSW mask, it will not be restored anyway.  */
d1901 5
d1907 6
a1912 3
  /* Next comes the PSW address.  */
  info->saved_regs[S390_PC_REGNUM].addr = sigreg_ptr;
  sigreg_ptr += word_size;
d1939 25
d2052 1
d2054 1
a2054 1
  pc = frame_unwind_register_unsigned (next_frame, S390_PC_REGNUM);
d2069 17
d2093 3
a2095 1
  switch (tdep->abi)
d2097 1
a2097 5
    case ABI_LINUX_S390:
      /* Call-saved registers.  */
      if ((regnum >= S390_R6_REGNUM && regnum <= S390_R15_REGNUM)
	  || regnum == S390_F4_REGNUM
	  || regnum == S390_F6_REGNUM)
d2099 1
a2099 5

      /* Call-clobbered registers.  */
      else if ((regnum >= S390_R0_REGNUM && regnum <= S390_R5_REGNUM)
	       || (regnum >= S390_F0_REGNUM && regnum <= S390_F15_REGNUM
		   && regnum != S390_F4_REGNUM && regnum != S390_F6_REGNUM))
d2101 1
d2103 16
a2118 20
      /* The return address column.  */
      else if (regnum == S390_PC_REGNUM)
	reg->how = DWARF2_FRAME_REG_RA;
      break;

    case ABI_LINUX_ZSERIES:
      /* Call-saved registers.  */
      if ((regnum >= S390_R6_REGNUM && regnum <= S390_R15_REGNUM)
	  || (regnum >= S390_F8_REGNUM && regnum <= S390_F15_REGNUM))
	reg->how = DWARF2_FRAME_REG_SAME_VALUE;

      /* Call-clobbered registers.  */
      else if ((regnum >= S390_R0_REGNUM && regnum <= S390_R5_REGNUM)
	       || (regnum >= S390_F0_REGNUM && regnum <= S390_F7_REGNUM))
	reg->how = DWARF2_FRAME_REG_UNDEFINED;

      /* The return address column.  */
      else if (regnum == S390_PC_REGNUM)
	reg->how = DWARF2_FRAME_REG_RA;
      break;
d2680 2
d2684 91
d2776 23
a2798 8
  /* First see if there is already a gdbarch that can satisfy the request.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* None found: is the request for a s390 architecture? */
  if (info.bfd_arch_info->arch != bfd_arch_s390)
    return NULL;		/* No; then it's not for us.  */
d2800 18
a2817 1
  /* Yes: create a new gdbarch for the specified machine type.  */
d2819 1
d2841 1
a2841 1
  set_gdbarch_pc_regnum (gdbarch, S390_PC_REGNUM);
a2843 4
  set_gdbarch_num_regs (gdbarch, S390_NUM_REGS);
  set_gdbarch_num_pseudo_regs (gdbarch, S390_NUM_PSEUDO_REGS);
  set_gdbarch_register_name (gdbarch, s390_register_name);
  set_gdbarch_register_type (gdbarch, s390_register_type);
a2846 1
  set_gdbarch_register_reggroup_p (gdbarch, s390_register_reggroup_p);
d2849 24
d2882 1
d2902 1
a2902 1
  switch (info.bfd_arch_info->mach)
d2904 1
a2904 3
    case bfd_mach_s390_31:
      tdep->abi = ABI_LINUX_S390;

a2910 2
      set_gdbarch_pseudo_register_read (gdbarch, s390_pseudo_register_read);
      set_gdbarch_pseudo_register_write (gdbarch, s390_pseudo_register_write);
a2912 1

a2913 2
    case bfd_mach_s390_64:
      tdep->abi = ABI_LINUX_ZSERIES;
d2915 1
a2923 2
      set_gdbarch_pseudo_register_read (gdbarch, s390x_pseudo_register_read);
      set_gdbarch_pseudo_register_write (gdbarch, s390x_pseudo_register_write);
a2946 1

a2951 1

d2954 5
@


1.186
log
@	* s390-tdep.c (s390_displaced_step_fixup): Use type ULONGEST
	instead of CORE_ADDR for "amode".
@
text
@d3 1
a3 1
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
@


1.185
log
@	* s390-tdep.c (op_bctr, op_bctgr, op_bct, op1_bctg, op2_bctg,
	op_bxh, op1_bxhg, op2_bxhg, op_bxle, op1_bxleg, op2_bxleg,
	op1_brct, op2_brct, op1_brctg, op2_brctg, op_brxh, op1_brxhg,
	op2_brxhg, op_brxle, op1_brxlg, op2_brxlg): New enum values.
	(is_rsi, is_rie): New insn format decoder routines.
	(s390_displaced_step_fixup): New function.
	(s390_gdbarch_init): Install displaced stepping routines.
@
text
@d1233 1
a1233 1
  CORE_ADDR amode = 0;
@


1.184
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d494 8
d506 6
d652 35
d1211 103
d2553 10
@


1.184.4.1
log
@	* s390-tdep.c (op_bctr, op_bctgr, op_bct, op1_bctg, op2_bctg,
	op_bxh, op1_bxhg, op2_bxhg, op_bxle, op1_bxleg, op2_bxleg,
	op1_brct, op2_brct, op1_brctg, op2_brctg, op_brxh, op1_brxhg,
	op2_brxhg, op_brxle, op1_brxlg, op2_brxlg): New enum values.
	(is_rsi, is_rie): New insn format decoder routines.
	(s390_displaced_step_fixup): New function.
	(s390_gdbarch_init): Install displaced stepping routines.
@
text
@a493 8
    op_bctr  = 0x06,
    op_bctgr = 0xb946,
    op_bct   = 0x46,
    op1_bctg = 0xe3,   op2_bctg = 0x46,
    op_bxh   = 0x86,
    op1_bxhg = 0xeb,   op2_bxhg = 0x44,
    op_bxle  = 0x87,
    op1_bxleg= 0xeb,   op2_bxleg= 0x45,
a497 6
    op1_brct = 0xa7,   op2_brct = 0x06,
    op1_brctg= 0xa7,   op2_brctg= 0x07,
    op_brxh  = 0x84,
    op1_brxhg= 0xec,   op2_brxhg= 0x44,
    op_brxle = 0x85,
    op1_brxlg= 0xec,   op2_brxlg= 0x45,
a637 35
is_rsi (bfd_byte *insn, int op,
        unsigned int *r1, unsigned int *r3, int *i2)
{
  if (insn[0] == op)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *r3 = insn[1] & 0xf;
      /* i2 is a 16-bit signed quantity.  */
      *i2 = (((insn[2] << 8) | insn[3]) ^ 0x8000) - 0x8000;
      return 1;
    }
  else
    return 0;
}


static int
is_rie (bfd_byte *insn, int op1, int op2,
        unsigned int *r1, unsigned int *r3, int *i2)
{
  if (insn[0] == op1
      && insn[5] == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *r3 = insn[1] & 0xf;
      /* i2 is a 16-bit signed quantity.  */
      *i2 = (((insn[2] << 8) | insn[3]) ^ 0x8000) - 0x8000;
      return 1;
    }
  else
    return 0;
}


static int
a1161 103
/* Displaced stepping.  */

/* Fix up the state of registers and memory after having single-stepped
   a displaced instruction.  */
static void
s390_displaced_step_fixup (struct gdbarch *gdbarch,
			   struct displaced_step_closure *closure,
			   CORE_ADDR from, CORE_ADDR to,
			   struct regcache *regs)
{
  /* Since we use simple_displaced_step_copy_insn, our closure is a
     copy of the instruction.  */
  gdb_byte *insn = (gdb_byte *) closure;
  static int s390_instrlen[] = { 2, 4, 4, 6 };
  int insnlen = s390_instrlen[insn[0] >> 6];

  /* Fields for various kinds of instructions.  */
  unsigned int b2, r1, r2, x2, r3;
  int i2, d2;

  /* Get current PC and addressing mode bit.  */
  CORE_ADDR pc = regcache_read_pc (regs);
  CORE_ADDR amode = 0;

  if (register_size (gdbarch, S390_PSWA_REGNUM) == 4)
    {
      regcache_cooked_read_unsigned (regs, S390_PSWA_REGNUM, &amode);
      amode &= 0x80000000;
    }

  if (debug_displaced)
    fprintf_unfiltered (gdb_stdlog,
			"displaced: (s390) fixup (%s, %s) pc %s amode 0x%x\n",
			paddress (gdbarch, from), paddress (gdbarch, to),
			paddress (gdbarch, pc), (int) amode);

  /* Handle absolute branch and save instructions.  */
  if (is_rr (insn, op_basr, &r1, &r2)
      || is_rx (insn, op_bas, &r1, &d2, &x2, &b2))
    {
      /* Recompute saved return address in R1.  */
      regcache_cooked_write_unsigned (regs, S390_R0_REGNUM + r1,
				      amode | (from + insnlen));
    }

  /* Handle absolute branch instructions.  */
  else if (is_rr (insn, op_bcr, &r1, &r2)
	   || is_rx (insn, op_bc, &r1, &d2, &x2, &b2)
	   || is_rr (insn, op_bctr, &r1, &r2)
	   || is_rre (insn, op_bctgr, &r1, &r2)
	   || is_rx (insn, op_bct, &r1, &d2, &x2, &b2)
	   || is_rxy (insn, op1_bctg, op2_brctg, &r1, &d2, &x2, &b2)
	   || is_rs (insn, op_bxh, &r1, &r3, &d2, &b2)
	   || is_rsy (insn, op1_bxhg, op2_bxhg, &r1, &r3, &d2, &b2)
	   || is_rs (insn, op_bxle, &r1, &r3, &d2, &b2)
	   || is_rsy (insn, op1_bxleg, op2_bxleg, &r1, &r3, &d2, &b2))
    {
      /* Update PC iff branch was *not* taken.  */
      if (pc == to + insnlen)
	regcache_write_pc (regs, from + insnlen);
    }

  /* Handle PC-relative branch and save instructions.  */
  else if (is_ri (insn, op1_bras, op2_bras, &r1, &i2)
           || is_ril (insn, op1_brasl, op2_brasl, &r1, &i2))
    {
      /* Update PC.  */
      regcache_write_pc (regs, pc - to + from);
      /* Recompute saved return address in R1.  */
      regcache_cooked_write_unsigned (regs, S390_R0_REGNUM + r1,
				      amode | (from + insnlen));
    }

  /* Handle PC-relative branch instructions.  */
  else if (is_ri (insn, op1_brc, op2_brc, &r1, &i2)
	   || is_ril (insn, op1_brcl, op2_brcl, &r1, &i2)
	   || is_ri (insn, op1_brct, op2_brct, &r1, &i2)
	   || is_ri (insn, op1_brctg, op2_brctg, &r1, &i2)
	   || is_rsi (insn, op_brxh, &r1, &r3, &i2)
	   || is_rie (insn, op1_brxhg, op2_brxhg, &r1, &r3, &i2)
	   || is_rsi (insn, op_brxle, &r1, &r3, &i2)
	   || is_rie (insn, op1_brxlg, op2_brxlg, &r1, &r3, &i2))
    {
      /* Update PC.  */
      regcache_write_pc (regs, pc - to + from);
    }

  /* Handle LOAD ADDRESS RELATIVE LONG.  */
  else if (is_ril (insn, op1_larl, op2_larl, &r1, &i2))
    {
      /* Recompute output address in R1.  */ 
      regcache_cooked_write_unsigned (regs, S390_R0_REGNUM + r1,
				      amode | (from + insnlen + i2*2));
    }

  /* If we executed a breakpoint instruction, point PC right back at it.  */
  else if (insn[0] == 0x0 && insn[1] == 0x1)
    regcache_write_pc (regs, from);

  /* For any other insn, PC points right after the original instruction.  */
  else
    regcache_write_pc (regs, from + insnlen);
}
a2400 10
  /* Displaced stepping.  */
  set_gdbarch_displaced_step_copy_insn (gdbarch,
                                        simple_displaced_step_copy_insn);
  set_gdbarch_displaced_step_fixup (gdbarch, s390_displaced_step_fixup);
  set_gdbarch_displaced_step_free_closure (gdbarch,
                                           simple_displaced_step_free_closure);
  set_gdbarch_displaced_step_location (gdbarch,
                                       displaced_step_at_entry_point);
  set_gdbarch_max_insn_length (gdbarch, S390_MAX_INSTR_SIZE);

@


1.184.4.2
log
@	* s390-tdep.c (s390_displaced_step_fixup): Use type ULONGEST
	instead of CORE_ADDR for "amode".
@
text
@d1233 1
a1233 1
  ULONGEST amode = 0;
@


1.183
log
@	gdb/
	* NEWS: Document inlined function support.
	* Makefile.in (SFILES): Add inline-frame.c.
	(COMMON_OBS): Add inline-frame.o.
	* block.c (contained_in): Rewrite to use lexical nesting.
	(block_linkage_function): Skip inlined function blocks.
	(block_inlined_p): New.
	* block.h (struct block): Update comment.
	(block_inlined_p): New prototype.
	* blockframe.c (get_frame_block): Handle inlined functions.
	(get_frame_function): Do not use block_linkage_function.
	(block_innermost_frame): Use get_frame_block and contained_in.
	* breakpoint.c (watchpoint_check): Remove extra reinit_frame_cache.
	Skip over inlined functions.  Simplify epilogue check.
	(bpstat_check_breakpoint_conditions): Use get_stack_frame_id.
	Update comments.
	(set_momentary_breakpoint): Only accept non-inlined frames.
	(watch_command_1): Use frame_unwind_caller_pc and
	frame_unwind_caller_id instead of get_prev_frame.
	(until_break_command): Likewise.  Use get_stack_frame_id.
	* buildsym.c (end_symtab): Set SYMBOL_SYMTAB for block functions.
	* dwarf2loc.c (dwarf_expr_frame_base): Use block_linkage_function.
	* dwarf2read.c (process_die): Handle DW_TAG_inlined_subroutine.
	(read_func_scope, new_symbol): Likewise.  Handle arguments specially
	for inlined functions without call site information.
	(inherit_abstract_dies): Allow tag mismatch for inlined subroutines.
	(die_specification): Treat DW_AT_abstract_origin as a specification.
	(read_type_die): Handle DW_TAG_inlined_subroutine.
	* frame-unwind.c (frame_unwind_init): Add inline_frame_unwind.
	* frame.c (fprint_frame_id): Print inline depth.
	(fprint_frame_type): Handle INLINE_FRAME and SENTINEL_FRAME.
	(skip_inlined_frames, get_stack_frame_id): New.
	(frame_unwind_caller_id): Use skip_inlined_frames.
	(frame_id_inlined_p): New.
	(frame_id_eq): Make the logic match the comments.  Add inline_depth
	check.
	(frame_id_inner): Handle inlined functions.
	(frame_unwind_pc): New function, copied from frame_unwind_caller_pc.
	(frame_unwind_caller_pc): Use skip_inlined_frames and frame_unwind_pc.
	(get_prev_frame_1): Check for inline frames.  Split out frame
	allocation to get_prev_frame_raw.
	(get_prev_frame_raw): New function.
	(get_prev_frame): Handle inline frames.
	(get_frame_pc): Use frame_unwind_pc.
	(get_frame_address_in_block): Skip inlined frames on both sides.
	(pc_notcurrent): Delete.
	(find_frame_sal): Rewrite to handle inline call sites.  Use
	get_frame_address_in_block.
	(deprecated_update_frame_pc_hack): Make static.
	* frame.h: Update comments.
	(struct frame_id): Add inline_depth.
	(enum frame_type): Add INLINE_FRAME.
	(frame_id_inlined_p, get_stack_frame_id): New prototypes.
	* gdbthread.h (struct thread_info): Add step_stack_frame_id field.
	* infcmd.c (set_step_frame): New function.
	(step_once): Use set_step_frame.  Handle inlined functions.
	(until_next_command): Use set_step_frame.
	(finish_backward), finish_forward): Use get_stack_frame_id.
	(finish_command): Support inlined functions.
	* inferior.h (set_step_info): New prototype.
	* infrun.c (RESUME_ALL): Use minus_one_ptid.
	(clear_proceed_status): Clear step_stack_frame_id.
	(init_wait_for_inferior): Call clear_inline_frame_state.
	(init_execution_control_state): Make static.
	(set_step_info): New function.
	(init_thread_stepping_state): Do not set the symtab or line here.
	(stepped_in_from): New function.
	(handle_inferior_event): Handle inlined functions.  Use set_step_info.
	(insert_step_resume_breakpoint_at_frame): Use get_stack_frame_id.
	(struct inferior_status): Add step_stack_frame_id.
	(save_inferior_status, restore_inferior_status): Save and restore
	step_stack_frame_id.
	* inline-frame.c, inline-frame.h: New files.
	* minsyms.c (prim_record_minimal_symbol_and_info): Use XCALLOC.
	* regcache.c (regcache_write_pc): Call reinit_frame_cache.
	* s390-tdep.c (s390_prologue_frame_unwind_cache): Handle INLINE_FRAME.
	* stack.c (frame_show_address): New.
	(print_frame_info, print_frame): Use it.
	(find_frame_funname): Use get_frame_function.  Handle inlined blocks.
	(frame_info): Mark inlined functions.
	(backtrace_command_1): Use get_current_user_frame.
	(print_frame_local_vars, print_frame_label_vars): Update comments.
	(return_command): Refuse inlined functions.
	* symtab.c (lookup_symbol_aux_local): Stop at inlined function
	boundaries.
	(find_function_start_sal): Avoid inlined functions.
	(completion_list_add_fields): New function.
	(default_make_symbol_completion_list): Use it.  Use block_static_block
	and block_global_block.  Check for inlined functions.
	(skip_prologue_using_sal): Avoid line number comparison across
	inlining.
	* symtab.h (struct symbol): Add is_inlined.
	(SYMBOL_INLINED): New.
	* target.c (target_resume): Call clear_inline_frame_state.
	* valops.c (value_of_variable): Check block_inlined_p.

	gdb/doc/
	* gdb.texinfo (Debugging Optimized Code): New chapter.
	(Compiling for Debugging): Reference it.  Move some
	text to the new section.

	gdb/testsuite/
	* gdb.base/break.exp: Add an XFAIL for gcc/36748.
	* gdb.cp/annota2.exp: Accept frames-invalid in more places.
	* gdb.opt/Makefile.in (EXECUTABLES): Update.
	* gdb.opt/clobbered-registers-O2.exp: Update to GPL v3.
	* gdb.opt/inline-bt.c, gdb.opt/inline-bt.exp,
	gdb.opt/inline-cmds.c, gdb.opt/inline-cmds.exp,
	gdb.opt/inline-locals.c, gdb.opt/inline-locals.exp,
	gdb.opt/inline-markers.c: New files.
	* lib/gdb.exp (skip_inline_frame_tests): New function.
	(skip_inline_var_tests): New function.
@
text
@d169 1
d176 1
a176 1
      store_unsigned_integer (buf, 4, val & 0x7fffffff);
d181 1
a181 1
      store_unsigned_integer (buf, 4, (val >> 12) & 3);
d193 1
d199 1
a199 1
      val = extract_unsigned_integer (buf, 4);
d206 1
a206 1
      val = extract_unsigned_integer (buf, 4);
d221 1
d232 1
a232 1
      store_unsigned_integer (buf, 4, (val >> 44) & 3);
d244 1
d254 1
a254 1
      val = extract_unsigned_integer (buf, 4);
d684 1
a684 1
  /* The size of a GPR or FPR.  */
d687 1
d785 2
a786 1
        return pv_constant (read_memory_integer (addr.k, size));
d873 1
d1366 1
d1373 1
a1373 1
  backchain = read_memory_unsigned_integer (reg, word_size);
d1380 2
a1381 1
      && safe_read_memory_integer (backchain + 15*word_size, word_size, &sp)
d1552 1
d1583 2
a1584 1
      sigreg_ptr = read_memory_unsigned_integer (next_cfa + 8, word_size);
d1631 1
a1631 1
			word_size);
d1924 1
a1924 1
extend_simple_arg (struct value *arg)
d1926 1
d1934 1
a1934 1
                                     TYPE_LENGTH (type));
d1937 1
a1937 1
                                   TYPE_LENGTH (type));
d2000 1
d2066 2
a2067 1
		write_memory_unsigned_integer (starg, word_size, copy_addr[i]);
d2097 1
a2097 1
					      extend_simple_arg (arg));
d2103 2
a2104 2
		write_memory_signed_integer (starg, word_size,
                                             extend_simple_arg (arg));
d2199 1
d2222 1
a2222 1
			extract_unsigned_integer (in, length));
d2225 1
a2225 1
			extract_signed_integer (in, length));
@


1.182
log
@	* prologue-value.c (make_pv_area): Add ADDR_BIT argument.
	Use it instead of address bits of current_gdbarch.
	* prologue-value.c (make_pv_area): Add ADDR_BIT argument.
	* arm-tdep.c (thumb_analyze_prologue): Pass address bits to
	make_pv_area.
	(arm_scan_prologue): Likewise.
	* m32c-tdep.c (m32c_analyze_prologue): Likewise.
	* mep-tdep.c (mep_analyze_prologue): Likewise.
	* mn10300-tdep.c (mn10300_analyze_prologue): Likewise.
	* s390-tdep.c (s390_analyze_prologue): Likewise.
@
text
@d1185 1
d1219 4
a1222 1
      if (get_next_frame (this_frame)
d1268 3
d1272 1
a1272 1
      && (!get_next_frame (this_frame)
@


1.181
log
@	* target.h (struct section_table): Rename to ...
	(struct target_section): ... this.
	* exec.c: Adjust all references.
	* exec.h: Adjust all references.
	* nto-tdep.c: Adjust all references.
	* nto-tdep.h: Adjust all references.
	* ppc-linux-tdep.c: Adjust all references.
	* rs6000-nat.c: Adjust all references.
	* s390-tdep.c: Adjust all references.
	* solib-darwin.c: Adjust all references.
	* solib-frv.c: Adjust all references.
	* solib-irix.c: Adjust all references.
	* solib-null.c: Adjust all references.
	* solib-osf.c: Adjust all references.
	* solib-pa64.c: Adjust all references.
	* solib-som.c: Adjust all references.
	* solib-sunos.c: Adjust all references.
	* solib-svr4.c: Adjust all references.
	* solib-target.c: Adjust all references.
	* solib.c: Adjust all references.
	* solist.h: Adjust all references.
	* symfile.c: Adjust all references.
	* symfile.h: Adjust all references.
	* target.c: Adjust all references.
@
text
@d860 1
a860 1
    data->stack = make_pv_area (S390_SP_REGNUM);
@


1.180
log
@	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
        * alpha-linux-tdep.c (alpha_linux_regset_from_core_section): Make
	it static.
        * alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Declare.
        * amd64fbsd-tdep.c (amd64fbsd_init_abi): Make it static.
        * amd64nbsd-tdep.c (_initialize_amd64nbsd_ndep): Rename to ...
	(_initialize_amd64nbsd_tdep): ... this.
	* arm-linux-tdep.c (arm_linux_software_single_step): Make it static.
	(_initialize_arm_linux_tdep): Declare.
	* armbsd-tdep.c (armbsd_fpreg_offset): Make it static.
	* armnbsd-tdep.c (_initialize_arm_netbsd_tdep): Declare.
	* armobsd-tdep.c (_initialize_armobsd_tdep): Declare.
	* avr-tdep.c (avr_return_value): Make it static.
	(avr_frame_unwind_cache): Ditto.
	* bsd-uthread.c (bsd_uthread_inferior_created): Ditto.
	(bsd_uthread_solib_loaded): Ditto.
	(bsd_uthread_solib_unloaded): Ditto.
	(bsd_uthread_target): Ditto.
	(_initialize_bsd_uthread): Declare.
	* cris-tdep.c (crisv32_single_step_through_delay): Make it static.
	(cris_frame_unwind_cache): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_use_struct_convention): Ditto.
	(h8300h_use_struct_convention): Ditto.
	* hppa-tdep.c (hppa_sign_extend, hppa_low_hppa_sign_extend):
	Ditto.
	* hppa-tdep.h (hppa_low_sign_extend, hppa_sign_extend): Delete
	declarations.
	* hppabsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_find_global_pointer): Make it static.
	* hppabsd-tdep.h: New.
	* hppanbsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Remove declaration.
	(_initialize_hppabsd_tdep): Remove declaration.
	(_initialize_hppanbsd_tdep): Declare.
	* hppaobsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Delete declaration.
	(hppaobsd_init_abi): Make it static.
	* i386-nto-tdep.c (_initialize_i386nto_tdep): Declare.
	* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Declare.
	* ia64-linux-tdep.c (_initialize_ia64_linux_tdep): Declare.
	* ia64-tdep.c (ia64_register_reggroup_p): Make it static.
	* iq2000-tdep.c (_initialize_iq2000_tdep): Declare.
	* m32c-tdep.c (m32c_register_reggroup_p): Make it static.
	(m32c_analyze_prologue, m32c_virtual_frame_pointer): Ditto.
	(_initialize_m32c_tdep): Declare.
	* m32r-rom.c (_initialize_m32r_rom): Declare.
	* m32r-tdep.c (m32r_skip_prologue): Make it static.
	(m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Make it static.
	(m68hc11_return_value): Ditto.
	* m68klinux-tdep.c (_initialize_m68k_linux_tdep): Declare.
	* m88k-tdep.c (m88k_frame_cache): Make it static.
	* mep-tdep.c (mep_gdb_print_insn): Ditto.
	(mep_return_value): Ditto.
	(_initialize_mep_tdep): Declare.
	* mips-irix-tdep.c (_initialize_mips_irix_tdep): Declare.
	* mips-linux-tdep.c (supply_64bit_reg): Make it static.
	(mips_linux_syscall_next_pc): Ditto.
	(_initialize_mips_linux_tdep): Declare.
	* mips-tdep.c (mips_single_step_through_delay): Make it static.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Declare.
	* mn10300-linux-tdep.c (_initialize_mn10300_linux_tdep): Declare.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Declare.
	* mt-tdep.c (_initialize_mt_tdep): Declare.
	* nbsd-tdep.c: Include nbsd-tdep.h.
	* nto-tdep.c (find_load_phdr): Make it static.
	(_initialize_nto_tdep): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Make it
	static.
	(_initialize_ppc_linux_tdep): Declare.
	* remote-m32r-sdi.c (m32r_can_use_hw_watchpoint)
	(m32r_insert_watchpoint, m32r_remove_watchpoint)
	(m32r_stopped_data_address, m32r_stopped_by_watchpoint): Make
	static.
	* rs6000-aix-tdep.c (_initialize_rs6000_aix_tdep): Declare.
	* rs6000-nat.c: Include xcoffread.h.
	(find_toc_address): Don't extern declare get_toc_offset.  Adjust
	to call xcoff_get_to_offset.
	* rs6000-tdep.c (ppc_vsx_support_p, ppc_displaced_step_fixup)
	(rs6000_skip_main_prologue, rs6000_in_solib_return_trampoline)
	(rs6000_skip_trampoline_code): Make static.
	* s390-tdep.c (s390_regset_from_core_section): Ditto.
	* sh-tdep.c (sh_register_reggroup_p): Ditto.
	* shnbsd-tdep.c (shnbsd_regset_from_core_section): Ditto.
	(_initialize_shnbsd_tdep): Declare.
	* solib-frv.c (displacement_from_map): Make static.
	(_initialize_frv_solib): Declare.
	* solib-irix.c (fetch_lm_info): Make static.
	(_initialize_irix_solib): Declare.
	* solib-som.c: Include solib-som.h.
	(som_solib_select): Line break.
	* sparc-tdep.c (sparc_regset_from_core_section): Make static.
	* sparcnbsd-tdep.c (_initialize_sparnbsd_tdep): Rename to ...
	(_initialize_sparcnbsd_tdep): ... this.
	* spu-tdep.c (spu_software_single_step): Make it static.
	(_initialize_spu_tdep): Declare.
	* vax-tdep.c (vax_frame_cache): Make it static.
	* xcoffread.c: Include xcoffread.h.
	(get_toc_offset): Rename to ...
	(xcoff_get_toc_offset): ... this.
	(_initialize_xcoffread): Declare.
	* xcoffread.h: New.
	* xtensa-linux-tdep.c (_initialize_xtensa_linux_tdep): Declare.
	* xtensa-tdep.c (xtensa_skip_prologue, xtensa_derive_tdep): Make
	static.
	(_initialize_xtensa_tdep): Declare.
@
text
@d775 1
a775 1
      struct section_table *secp;
@


1.179
log
@        Updated copyright notices for most files.
@
text
@d422 1
a422 1
const struct regset *
@


1.178
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.177
log
@	* gdbarch.sh (addr_bits_remove): Change type to 'm'.
	(smash_text_address): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.

	* arch-utils.c (core_addr_identity): Add gdbarch parameter.
	* arch-utils.h (core_addr_identity): Likewise.
	* arm-tdep.c (arm_addr_bits_remove): Likewise.
	(arm_smash_text_address): Likewise.
	* hppa-tdep.c (hppa_smash_text_address): Likewise.
	* m88k-tdep.c (m88k_addr_bits_remove): Likewise.
	* s390-tdep.c (s390_addr_bits_remove): Likewise.

	* mips-tdep.c (mips_addr_bits_remove): Add gdbarch parameter.
	Use it instead of current_gdbarch.

	* arm-tdep.c (arm_prologue_prev_register, arm_unwind_pc,
	arm_dwarf2_prev_register): Update calls.
	* m88k-tdep.c (m88k_unwind_pc): Update call.
@
text
@d99 1
a99 1
    return builtin_type_long;
d101 1
a101 1
    return builtin_type_long;
d103 1
a103 1
    return builtin_type_int;
d105 1
a105 1
    return builtin_type_int;
d107 1
a107 1
    return builtin_type_double;
d109 1
a109 1
    return builtin_type_void_func_ptr;
d111 1
a111 1
    return builtin_type_int;
@


1.176
log
@	* s390-tdep.c (s390_address_class_type_flags): Use
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1.
	(s390_address_class_type_flags_to_name): Likewise.
	(s390_address_class_name_to_type_flags): Likewise.
@
text
@d2272 1
a2272 1
s390_addr_bits_remove (CORE_ADDR addr)
@


1.175
log
@	* gdbarch.sh: Delete dwarf_reg_to_regnum.
	* gdbarch.c, gdbarch.h: Regenerated.
	* amd64-tdep.c, arm-tdep.c, h8300-tdep.c, hppa-linux-tdep.c,
	hppa-tdep.c, i386-tdep.c, m32c-tdep.c, m68k-tdep.c, mips-tdep.c,
	s390-tdep.c, xtensa-tdep.c: Do not set dwarf_reg_to_regnum.

	* gdbint.texinfo (Target Conditionals): Delete entry for
	gdbarch_dwarf_reg_to_regnum.
@
text
@d2281 1
a2281 1
    return TYPE_FLAG_ADDRESS_CLASS_1;
d2289 1
a2289 1
  if (type_flags & TYPE_FLAG_ADDRESS_CLASS_1)
d2301 1
a2301 1
      *type_flags_ptr = TYPE_FLAG_ADDRESS_CLASS_1;
@


1.174
log
@	* s390-tdep.c: Update for unwinder changes.
@
text
@a2355 1
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, s390_dwarf_reg_to_regnum);
@


1.173
log
@	* dwarf2-frame.c (read_reg): Expect this_frame in the baton.
	(execute_stack_op): Put this_frame in the baton.
	(execute_cfa_program): Take this_frame.
	(struct dwarf2_frame_ops): Update comment for signal_frame_p.
	(dwarf2_frame_default_init_reg, dwarf2_frame_init_reg)
	(dwarf2_frame_signal_frame_p, dwarf2_frame_cache)
	(dwarf2_frame_this_id): Adjust to work on this_frame.
	(dwarf2_signal_frame_this_id): Delete.
	(dwarf2_frame_prev_register): Update signature.  Use new frame
	unwind methods.
	(dwarf2_frame_sniffer): Update signature.  Expect this_frame.
	(dwarf2_frame_unwind, dwarf2_signal_frame_unwind): Add
	dwarf2_frame_sniffer.
	(dwarf2_append_unwinders): New.
	(dwarf2_frame_base_address, dwarf2_frame_base_sniffer): Expect
	this_frame.
	* sparc-tdep.c (sparc32_dwarf2_struct_return_p)
	(sparc32_dwarf2_frame_init_reg): Expect this_frame.
	* cris-tdep.c (cris_dwarf2_frame_init_reg): Likewise.
	* rs6000-tdep.c (ppc_dwarf2_frame_init_reg): Likewise.
	* s390-tdep.c (s390_dwarf2_frame_init_reg): Likewise.
	* sh-tdep.c (sh_dwarf2_frame_init_reg): Likewise.
	* sparc64-tdep.c (sparc64_dwarf2_frame_init_reg): Likewise.
	* dwarf2-frame.h (dwarf2_frame_sniffer): Delete declaration.
	(dwarf2_append_unwinders): Declare.
	(dwarf2_frame_base_sniffer): Update declaration.
	* i386-linux-tdep.c (i386_linux_dwarf_signal_frame_p): Expect
	this_frame.
@
text
@d1168 1
a1168 1
s390_prologue_frame_unwind_cache (struct frame_info *next_frame,
d1171 1
a1171 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d1190 1
a1190 1
  func = frame_func_unwind (next_frame, NORMAL_FRAME);
d1196 1
a1196 1
				  frame_pc_unwind (next_frame), &data);
d1218 2
a1219 1
      if (get_frame_type (next_frame) == NORMAL_FRAME)
d1224 1
a1224 1
      reg = frame_unwind_register_unsigned (next_frame, S390_RETADDR_REGNUM);
d1264 3
a1266 1
  if (size > 0 && get_frame_type (next_frame) != NORMAL_FRAME)
d1270 1
a1270 1
      if (s390_in_function_epilogue_p (gdbarch, frame_pc_unwind (next_frame)))
d1282 1
a1282 1
  prev_sp = frame_unwind_register_unsigned (next_frame, frame_pointer) + size;
d1347 1
a1347 1
s390_backchain_frame_unwind_cache (struct frame_info *next_frame,
d1350 1
a1350 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d1357 1
a1357 1
  reg = frame_unwind_register_unsigned (next_frame, S390_SP_REGNUM);
d1383 1
a1383 1
  info->func = frame_pc_unwind (next_frame);
d1387 1
a1387 1
s390_frame_unwind_cache (struct frame_info *next_frame,
d1396 1
a1396 1
  info->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d1403 2
a1404 2
  if (!s390_prologue_frame_unwind_cache (next_frame, info))
    s390_backchain_frame_unwind_cache (next_frame, info);
d1410 1
a1410 1
s390_frame_this_id (struct frame_info *next_frame,
d1415 1
a1415 1
    = s390_frame_unwind_cache (next_frame, this_prologue_cache);
d1423 3
a1425 6
static void
s390_frame_prev_register (struct frame_info *next_frame,
			  void **this_prologue_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, gdb_byte *bufferp)
d1428 2
a1429 3
    = s390_frame_unwind_cache (next_frame, this_prologue_cache);
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, bufferp);
d1435 3
a1437 1
  s390_frame_prev_register
a1439 6
static const struct frame_unwind *
s390_frame_sniffer (struct frame_info *next_frame)
{
  return &s390_frame_unwind;
}

d1452 1
a1452 1
s390_stub_frame_unwind_cache (struct frame_info *next_frame,
d1455 1
a1455 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d1465 1
a1465 1
  info->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d1471 1
a1471 1
  reg = frame_unwind_register_unsigned (next_frame, S390_SP_REGNUM);
d1478 1
a1478 1
s390_stub_frame_this_id (struct frame_info *next_frame,
d1483 2
a1484 2
    = s390_stub_frame_unwind_cache (next_frame, this_prologue_cache);
  *this_id = frame_id_build (info->frame_base, frame_pc_unwind (next_frame));
d1487 3
a1489 6
static void
s390_stub_frame_prev_register (struct frame_info *next_frame,
			       void **this_prologue_cache,
			       int regnum, int *optimizedp,
			       enum lval_type *lvalp, CORE_ADDR *addrp,
			       int *realnump, gdb_byte *bufferp)
d1492 2
a1493 3
    = s390_stub_frame_unwind_cache (next_frame, this_prologue_cache);
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, bufferp);
d1496 4
a1499 8
static const struct frame_unwind s390_stub_frame_unwind = {
  NORMAL_FRAME,
  s390_stub_frame_this_id,
  s390_stub_frame_prev_register
};

static const struct frame_unwind *
s390_stub_frame_sniffer (struct frame_info *next_frame)
d1507 1
a1507 1
  addr_in_block = frame_unwind_address_in_block (next_frame, NORMAL_FRAME);
d1509 3
a1511 3
      || s390_readinstruction (insn, frame_pc_unwind (next_frame)) < 0)
    return &s390_stub_frame_unwind;
  return NULL;
d1514 8
d1531 1
a1531 1
s390_sigtramp_frame_unwind_cache (struct frame_info *next_frame,
d1534 1
a1534 1
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d1546 1
a1546 1
  info->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d1548 2
a1549 2
  this_sp = frame_unwind_register_unsigned (next_frame, S390_SP_REGNUM);
  next_ra = frame_pc_unwind (next_frame);
d1622 1
a1622 1
s390_sigtramp_frame_this_id (struct frame_info *next_frame,
d1627 2
a1628 2
    = s390_sigtramp_frame_unwind_cache (next_frame, this_prologue_cache);
  *this_id = frame_id_build (info->frame_base, frame_pc_unwind (next_frame));
d1631 3
a1633 6
static void
s390_sigtramp_frame_prev_register (struct frame_info *next_frame,
				   void **this_prologue_cache,
				   int regnum, int *optimizedp,
				   enum lval_type *lvalp, CORE_ADDR *addrp,
				   int *realnump, gdb_byte *bufferp)
d1636 2
a1637 3
    = s390_sigtramp_frame_unwind_cache (next_frame, this_prologue_cache);
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, bufferp);
d1640 4
a1643 8
static const struct frame_unwind s390_sigtramp_frame_unwind = {
  SIGTRAMP_FRAME,
  s390_sigtramp_frame_this_id,
  s390_sigtramp_frame_prev_register
};

static const struct frame_unwind *
s390_sigtramp_frame_sniffer (struct frame_info *next_frame)
d1645 1
a1645 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
d1649 1
a1649 1
    return NULL;
d1652 1
a1652 1
    return NULL;
d1656 1
a1656 1
    return NULL;
d1658 1
a1658 1
  return &s390_sigtramp_frame_unwind;
d1661 8
d1673 1
a1673 1
s390_frame_base_address (struct frame_info *next_frame, void **this_cache)
d1676 1
a1676 1
    = s390_frame_unwind_cache (next_frame, this_cache);
d1681 1
a1681 1
s390_local_base_address (struct frame_info *next_frame, void **this_cache)
d1684 1
a1684 1
    = s390_frame_unwind_cache (next_frame, this_cache);
d2128 1
a2128 1
/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that
d2133 1
a2133 1
s390_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d2136 2
a2137 1
  CORE_ADDR sp = s390_unwind_sp (gdbarch, next_frame);
d2140 1
a2140 1
                         frame_pc_unwind (next_frame));
d2365 1
a2365 1
  set_gdbarch_unwind_dummy_id (gdbarch, s390_unwind_dummy_id);
d2371 1
a2371 1
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
d2373 3
a2375 3
  frame_unwind_append_sniffer (gdbarch, s390_stub_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, s390_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, s390_frame_sniffer);
@


1.172
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d1722 1
a1722 1
			    struct frame_info *next_frame)
@


1.171
log
@	* breakpoint.h (breakpoint_restore_shadows): New
	declaration.
	* breakpoint.c (breakpoint_restore_shadows): New.
	(read_memory_nobpt): Delete.
	* gdbcore.h (read_memory_nobpt): Delete declaration.
	* target.c (memory_xfer_partial): Call
	breakpoint_restore_shadows.
	(restore_show_memory_breakpoints)
	(make_show_memory_beakpoints_cleanup): New.
	(show_memory_breakpoints): New.
	* target.h (make_show_memory_beakpoints_cleanup): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint):
	Make sure we see memory breakpoints when checking if
	breakpoint is still there.
	* alpha-tdep.c, alphanbsd-tdep.c, frame.c, frv-tdep.c,
	hppa-linux-tdep.c, hppa-tdep.c, i386-linux-nat.c, i386-tdep.c,
	m68klinux-tdep.c, mips-tdep.c, mn10300-tdep.c, s390-tdep.c,
	sparc-tdep.c: Use target_read_memory instead of read_memory_nobpt.
@
text
@d2178 3
a2180 3
s390_return_value (struct gdbarch *gdbarch, struct type *type, 
		   struct regcache *regcache, gdb_byte *out,
		   const gdb_byte *in)
@


1.170
log
@2008-01-31  Andreas Krebbel  <krebbel1@@de.ibm.com>

	* s390-tdep.c (is_float_singleton, is_float_like,
	alignment_of, s390_return_value): Make checks for
	TYPE_CODE_FLT to match TYPE_CODE_DECFLOAT as well.
@
text
@d506 1
a506 1
  if (read_memory_nobpt (at, &instr[0], 2))
d511 1
a511 1
      if (read_memory_nobpt (at + 2, &instr[2], instrlen - 2))
d1135 1
a1135 1
      && !read_memory_nobpt (pc - 4, insn, 4)
d1141 1
a1141 1
      && !read_memory_nobpt (pc - 6, insn, 6)
d1147 1
a1147 1
      && !read_memory_nobpt (pc - 6, insn, 6)
d1661 1
a1661 1
  if (read_memory_nobpt (pc, sigreturn, 2))
@


1.169
log
@	* s390-tdep.c (s390_gdbarch_init): Set default long double
	type to 128-bit IEEE quad.
@
text
@d1819 1
d1858 1
d1935 2
a1936 1
      || TYPE_CODE (type) == TYPE_CODE_FLT)
d2191 2
a2192 1
	  if (TYPE_CODE (type) == TYPE_CODE_FLT)
d2228 2
a2229 1
	  if (TYPE_CODE (type) == TYPE_CODE_FLT)
@


1.168
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d2331 6
@


1.167
log
@	Updated copyright notices for most files.
@
text
@d1096 1
a1096 1
s390_skip_prologue (CORE_ADDR pc)
d1100 1
a1100 1
  skip_pc = s390_analyze_prologue (current_gdbarch, pc, (CORE_ADDR)-1, &data);
@


1.166
log
@	* gdbarch.sh (stab_reg_to_regnum, dwarf_reg_to_regnum)
	( dwarf2_reg_to_regnum, sdb_reg_to_regnum, ecoff_reg_to_regnum): Add
	gdbarch as parameter.
	* gdbarch.{c,h}: Regenerate.

	* xtensa-tdep.c (xtensa_reg_to_regnum): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* s390-tdep.c (s390_dwarf_reg_to_regnum): Likewise.
	* rs6000-tdep.c (rs6000_stab_reg_to_regnum)
	(rs6000_dwarf2_reg_to_regnum): Likewise.
	* mips-tdep.c (mips_stab_reg_to_regnum)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum): Likewise.
	* mep-tdep.c (mep_debug_reg_to_regnum): Likewise.
	* m32c-tdep.c (m32c_debug_info_reg_to_regnum): Likewise.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise
	* h8300-tdep.c (h8300s_dbg_reg_to_regnum)
	(h8300_dbg_reg_to_regnum): Likewise.
	* amd64-tdep.c (amd64_dwarf_reg_to_regnum): Likewise.
	* arch-utils.c (no_op_reg_to_regnum): Likewise.
	* arch-utils.h (no_op_reg_to_regnum): Likewise.
	* arm-tdep.c (arm_dwarf_reg_to_regnum): Likewise.
	* cris-tdep.c (cris_dwarf2_reg_to_regnum): Likewise.
	* hppa-tdep.c (hppa64_dwarf_reg_to_regnum): Likewise.
	* ia64-tdep.c (ia64_dwarf_reg_to_regnum): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.165
log
@*** empty log message ***
@
text
@d150 1
a150 1
s390_dwarf_reg_to_regnum (int reg)
@


1.164
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d2259 1
a2259 1
s390_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
@


1.163
log
@	* s390-tdep.c (s390_regset_from_core_section): Allow excess section
	size to enable bi-arch generate-core-file support.
@
text
@d68 1
a68 1
s390_register_name (int regnum)
@


1.162
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d428 1
a428 1
  if (strcmp (sect_name, ".reg") == 0 && sect_size == tdep->sizeof_gregset)
d431 1
a431 1
  if (strcmp (sect_name, ".reg2") == 0 && sect_size == tdep->sizeof_fpregset)
@


1.162.2.1
log
@	* s390-tdep.c (s390_regset_from_core_section): Allow excess section
	size to enable bi-arch generate-core-file support.
@
text
@d428 1
a428 1
  if (strcmp (sect_name, ".reg") == 0 && sect_size >= tdep->sizeof_gregset)
d431 1
a431 1
  if (strcmp (sect_name, ".reg2") == 0 && sect_size >= tdep->sizeof_fpregset)
@


1.161
log
@	* amd64-tdep.c (struct amd64_register_info): Remove.
	(amd64_register_info): Remove.
	(amd64_register_names): New static variable.
	(AMD64_NUM_REGS): Use amd64_register_names instead of
	amd64_register_info.
	(amd64_register_name): Likewise.
	(amd64_register_type): Do not refer to amd64_register_info.

	* s390-tdep.c (struct s390_register_info): Remove.
	(s390_register_info): Remove.
	(s390_register_name): Do not refer to s390_register_info.
	(s390_register_type): Likewise.

	* sparc64-tdep.c (struct sparc64_register_info): Remove.
	(sparc64_register_info, sparc64_pseudo_register_info): Remove.
	(sparc64_register_names, sparc64_pseudo_register_names): New.
	(SPARC64_NUM_REGS, SPARC64_NUM_PSEUDO_REGS): Use
	sparc64_register_names and sparc64_pseudo_register_names instead of
	sparc64_register_info and sparc64_pseudo_register_info.
	(sparc64_register_name): Likewise.
	(sparc64_register_type): Do not refer to sparc64_register_info
	and sparc64_pseudo_register_info.
@
text
@d13 1
a13 1
   the Free Software Foundation; either version 2 of the License, or
d22 1
a22 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.160
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (BREAKPOINT_FROM_PC): Replace by
	gdbarch_breakpoint_from_pc.
	* s390-tdep.c (s390_gdbarch_init): Likewise (comment).
	* remote.c (remote_insert_breakpoint)
	(remote_insert_hw_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* mips-tdep.c (mips_breakpoint_from_pc): Likewise (comment).
	* breakpoint.h (bp_target_info): Likewise (comment).
	* breakpoint.c (read_memory_nobpt): Likewise.
	* mem-break.c (default_memory_insert_breakpoint): Likewise.
	(symtab.h, breakpoint.h): Remove include. Remove unnecessary comment.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@a67 76
/* Register information.  */

struct s390_register_info
{
  char *name;
  struct type **type;
};

static struct s390_register_info s390_register_info[S390_NUM_TOTAL_REGS] = 
{
  /* Program Status Word.  */
  { "pswm", &builtin_type_long },
  { "pswa", &builtin_type_long },

  /* General Purpose Registers.  */
  { "r0", &builtin_type_long },
  { "r1", &builtin_type_long },
  { "r2", &builtin_type_long },
  { "r3", &builtin_type_long },
  { "r4", &builtin_type_long },
  { "r5", &builtin_type_long },
  { "r6", &builtin_type_long },
  { "r7", &builtin_type_long },
  { "r8", &builtin_type_long },
  { "r9", &builtin_type_long },
  { "r10", &builtin_type_long },
  { "r11", &builtin_type_long },
  { "r12", &builtin_type_long },
  { "r13", &builtin_type_long },
  { "r14", &builtin_type_long },
  { "r15", &builtin_type_long },

  /* Access Registers.  */
  { "acr0", &builtin_type_int },
  { "acr1", &builtin_type_int },
  { "acr2", &builtin_type_int },
  { "acr3", &builtin_type_int },
  { "acr4", &builtin_type_int },
  { "acr5", &builtin_type_int },
  { "acr6", &builtin_type_int },
  { "acr7", &builtin_type_int },
  { "acr8", &builtin_type_int },
  { "acr9", &builtin_type_int },
  { "acr10", &builtin_type_int },
  { "acr11", &builtin_type_int },
  { "acr12", &builtin_type_int },
  { "acr13", &builtin_type_int },
  { "acr14", &builtin_type_int },
  { "acr15", &builtin_type_int },

  /* Floating Point Control Word.  */
  { "fpc", &builtin_type_int },

  /* Floating Point Registers.  */
  { "f0", &builtin_type_double },
  { "f1", &builtin_type_double },
  { "f2", &builtin_type_double },
  { "f3", &builtin_type_double },
  { "f4", &builtin_type_double },
  { "f5", &builtin_type_double },
  { "f6", &builtin_type_double },
  { "f7", &builtin_type_double },
  { "f8", &builtin_type_double },
  { "f9", &builtin_type_double },
  { "f10", &builtin_type_double },
  { "f11", &builtin_type_double },
  { "f12", &builtin_type_double },
  { "f13", &builtin_type_double },
  { "f14", &builtin_type_double },
  { "f15", &builtin_type_double },

  /* Pseudo registers.  */
  { "pc", &builtin_type_void_func_ptr },
  { "cc", &builtin_type_int },
};

d72 19
d92 1
a92 1
  return s390_register_info[regnum].name;
d96 1
a96 1
   register REGNUM. */
d100 16
a115 2
  gdb_assert (regnum >= 0 && regnum < S390_NUM_TOTAL_REGS);
  return *s390_register_info[regnum].type;
@


1.159
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@d2377 1
a2377 1
     often the number of bytes returned by BREAKPOINT_FROM_PC but not
@


1.158
log
@Copyright updates for 2007.
@
text
@d1235 1
a1235 1
  func = frame_func_unwind (next_frame);
d1559 1
a1559 1
  CORE_ADDR pc = frame_pc_unwind (next_frame);
d1565 3
a1567 2
  if (in_plt_section (pc, NULL)
      || s390_readinstruction (insn, pc) < 0)
@


1.157
log
@	* gdbarch.sh (value_from_register): New gdbarch function.
	* gdbarch.c, gdbarch.h: Regenerate.
	* findvar.c (default_value_from_register): New function.
	(value_from_register): Use gdbarch_value_from_register.
	* value.h (default_value_from_register): Declare.
	* spu-tdep.c (spu_convert_register_p, spu_register_to_value,
	spu_value_to_register): Remove.
	(spu_value_from_register): New function.
	(spu_gdbarch_init): Do not call set_gdbarch_convert_register_p,
	set_gdbarch_register_to_value, set_gdbarch_value_to_register.
	Call set_gdbarch_value_from_register.
	* s390-tdep.c (s390_convert_register_p, s390_register_to_value,
	s390_value_to_register): Remove.
	(s390_value_from_register): New function.
	(s390_gdbarch_init): Do not call set_gdbarch_convert_register_p,
	set_gdbarch_register_to_value, set_gdbarch_value_to_register.
	Call set_gdbarch_value_from_register.
@
text
@d3 1
a3 1
   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006
@


1.156
log
@	* config/tm-linux.h: Delete file.
	* config/alpha/alpha-linux.mt (DEPRECATED_TM_FILE): Set to tm-alpha.h.
	* config/alpha/tm-alphalinux.h: Delete file.
	* config/arm/linux.mt (DEPRECATED_TM_FILE): Set to tm-arm.h
	* config/arm/tm-linux.h: Delete file.
	* config/i386/tm-linux.h: Do not include "config/tm-linux.h".
	* config/ia64/tm-linux.h: Do not include "config/tm-linux.h".
	* config/m32r/linux.mt (DEPRECATED_TM_FILE): Remove.
	* config/mips/tm-linux.h:  Do not include "config/tm-linux.h".
	* config/pa/linux.mt (DEPRECATED_TM_FILE): Set to tm-hppa.h.
	* config/pa/tm-linux.h: Delete file.
	* config/powerpc/tm-linux.h: Do not include "config/tm-linux.h".
	* config/s390/linux.mt (DEPRECATED_TM_FILE): Remove.
	* config/sh/linux.mt (DEPRECATED_TM_FILE): Set to tm-sh.h.
	* config/sh/tm-linux.h: Delete file.
	* alpha-linux-tdep.c: Include "symtab.h".
	(alpha_linux_init_abi): Call set_gdbarch_skip_trampoline_code.
	* i386-linux-tdep.c: Include "symtab.h".
	(i386_linux_init_abi): Call set_gdbarch_skip_trampoline_code.
	* ia64-linux-tdep.c: Include "symtab.h".
	(ia64_linux_init_abi): Call set_gdbarch_skip_trampoline_code.
	* m32r-linux-tdep.c: Include "symtab.h".
	(m32r_linux_init_abi): Call set_gdbarch_skip_trampoline_code.
	* mips-linux-tdep.c: Include "symtab.h".
	(mips_linux_init_abi): Call set_gdbarch_skip_trampoline_code.
	* sh-linux-tdep.c: Include "symtab.h".
	(sh_linux_init_abi): Call set_gdbarch_skip_trampoline_code.
	* s390-tdep.c (s390_gdbarch_init): Call
	set_gdbarch_skip_trampoline_code.
	* s390-nat.c: Do not include "tm.h".
	* Makefile.in (alpha-linux-tdep.o): Add dependency on $(symtab_h).
	(i386-linux-tdep.o): Likewise.
	(ia64-linux-tdep.o): Likewise.
	(m32r-linux-tdep.o): Likewise.
	(mips-linux-tdep.o): Likewise.
	(sh-linux-tdep.o): Likewise.
	(s390-nat.o): Remove dependency on $(tm_h).
@
text
@d309 3
a311 10
static int
s390_convert_register_p (int regno, struct type *type)
{
  return (regno >= S390_F0_REGNUM && regno <= S390_F15_REGNUM)
	 && TYPE_LENGTH (type) < 8;
}

static void
s390_register_to_value (struct frame_info *frame, int regnum,
                        struct type *valtype, gdb_byte *out)
d313 2
a314 3
  gdb_byte in[8];
  int len = TYPE_LENGTH (valtype);
  gdb_assert (len < 8);
d316 2
a317 3
  get_frame_register (frame, regnum, in);
  memcpy (out, in, len);
}
d319 1
a319 11
static void
s390_value_to_register (struct frame_info *frame, int regnum,
                        struct type *valtype, const gdb_byte *in)
{
  gdb_byte out[8];
  int len = TYPE_LENGTH (valtype);
  gdb_assert (len < 8);

  memset (out, 0, 8);
  memcpy (out, in, len);
  put_frame_register (frame, regnum, out);
d2395 1
a2395 3
  set_gdbarch_convert_register_p (gdbarch, s390_convert_register_p);
  set_gdbarch_register_to_value (gdbarch, s390_register_to_value);
  set_gdbarch_value_to_register (gdbarch, s390_value_to_register);
@


1.155
log
@        * gdbcore.h (read_memory_nobpt): New function name instead of
        deprecated_read_memory_nobpt.
        * breakpoint.c (read_memory_nobpt): New function name instead
        of deprecated_read_memory_nobpt.
        Adjust calls to old deprecated_read_memory_nobpt accordingly.
        * alpha-tdep.c: Adjust calls to deprecated_read_memory_nobpt
        accordingly.
        * alphanbsd-tdep.c: Likewise.
        * frame.c: Likewise.
        * frv-tdep.c: Likewise.
        * hppa-linux-tdep.c: Likewise.
        * hppa-tdep.c: Likewise.
        * i386-linux-nat.c: Likewise.
        * m68klinux-tdep.c: Likewise.
        * mips-tdep.c: Likewise.
        * s390-tdep.c: Likewise.
@
text
@d2481 2
@


1.154
log
@	* s390-tdep.c (s390_collect_regset): New function.
	(s390_gregset, s390x_gregset, s390_fpregset): Add it.
@
text
@d570 1
a570 1
  if (deprecated_read_memory_nobpt (at, &instr[0], 2))
d575 1
a575 1
      if (deprecated_read_memory_nobpt (at + 2, &instr[2], instrlen - 2))
d1199 1
a1199 1
      && !deprecated_read_memory_nobpt (pc - 4, insn, 4)
d1205 1
a1205 1
      && !deprecated_read_memory_nobpt (pc - 6, insn, 6)
d1211 1
a1211 1
      && !deprecated_read_memory_nobpt (pc - 6, insn, 6)
d1724 1
a1724 1
  if (deprecated_read_memory_nobpt (pc, sigreturn, 2))
@


1.154.2.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d570 1
a570 1
  if (read_memory_nobpt (at, &instr[0], 2))
d575 1
a575 1
      if (read_memory_nobpt (at + 2, &instr[2], instrlen - 2))
d1199 1
a1199 1
      && !read_memory_nobpt (pc - 4, insn, 4)
d1205 1
a1205 1
      && !read_memory_nobpt (pc - 6, insn, 6)
d1211 1
a1211 1
      && !read_memory_nobpt (pc - 6, insn, 6)
d1724 1
a1724 1
  if (read_memory_nobpt (pc, sigreturn, 2))
@


1.153
log
@	* s390-tdep.c (struct s390_prologue_data): New field 'stack'.
	(s390_store): Call pv_area_store to track stack slots.
	(s390_load): Call pv_area_fetch to track stack slots.
	(s390_check_for_saved): New function.
	(s390_analyze_prologue): Call pv_area_scan.  Allocate and free stack.
@
text
@d447 19
d468 2
a469 1
  s390_supply_regset
d474 2
a475 1
  s390_supply_regset
d480 2
a481 1
  s390_supply_regset
@


1.152
log
@	* Makefile.in (s390-tdep.o): Add dependency on $(prologue_value_h).
	* s390-tdep.c: Include "prologue-value.h".
	(struct prologue_value): Remove.
	(pv_set_to_unknown, pv_set_to_constant, pv_set_to_register,
	pv_constant_last, pv_add, pv_add_constant, pv_subtract,
	pv_logical_and, pv_is_identical, pv_is_register): Remove.
	(compute_x_addr): Remove, replace by ...
	(s390_addr): ... this new function.
	(struct s390_prologue_data): Use pv_t instead of prologue_value.
	(s390_store, s390_load): Likewise.
	(s390_prologue_frame_unwind_cache): Likewise.
	(s390_analyze_prologue): Likewise.  Also, simplify and combine
	several conditional statements.
@
text
@d719 3
d774 1
a774 2
  pv_t cfa, offset;
  int i;
d789 2
a790 31
  cfa = pv_register (S390_SP_REGNUM, 16 * data->gpr_size + 32);
  offset = pv_subtract (cfa, addr);

  if (pv_is_constant (offset)
      && offset.k < INT_MAX && offset.k > 0
      && offset.k % data->gpr_size == 0)
    {
      /* If we are storing the original value of a register, we want to
	 record the CFA offset.  If the same register is stored multiple
	 times, the stack slot with the highest address counts.  */
      
      for (i = 0; i < S390_NUM_GPRS; i++)
	if (size == data->gpr_size
	    && pv_is_register_k (value, S390_R0_REGNUM + i, 0))
	  if (data->gpr_slot[i] == 0
	      || data->gpr_slot[i] > offset.k)
	    {
	      data->gpr_slot[i] = offset.k;
	      return;
	    }

      for (i = 0; i < S390_NUM_FPRS; i++)
	if (size == data->fpr_size
	    && pv_is_register_k (value, S390_F0_REGNUM + i, 0))
	  if (data->fpr_slot[i] == 0
	      || data->fpr_slot[i] > offset.k)
	    {
	      data->fpr_slot[i] = offset.k;
	      return;
	    }
    }
d808 1
a808 2
  pv_t cfa, offset;
  int i;
d826 2
a827 2
  cfa = pv_register (S390_SP_REGNUM, 16 * data->gpr_size + 32);
  offset = pv_subtract (cfa, addr);
d829 17
a845 6
  if (pv_is_constant (offset)
      && offset.k < INT_MAX && offset.k > 0)
    {
      for (i = 0; i < S390_NUM_GPRS; i++)
	if (offset.k == data->gpr_slot[i])
	  return pv_register (S390_R0_REGNUM + i, 0);
d847 13
a859 4
      for (i = 0; i < S390_NUM_FPRS; i++)
	if (offset.k == data->fpr_slot[i])
	  return pv_register (S390_F0_REGNUM + i, 0);
    }
d861 9
a869 2
  /* Otherwise, we don't know the value.  */
  return pv_unknown ();
a870 1
            
d902 2
d1126 6
@


1.151
log
@	* dwarf2-frame.c (dwarf2_frame_ops init_reg): Add "next_frame"
	argument.
	(dwarf2_frame_default_init_reg): Likewise.
	(dwarf2_frame_set_init_reg): Update init_reg arg.
	(dwarf2_frame_init_reg): Take "next_frame" and pass it to
	ops->init_reg().
	(dwarf2_frame_cache): Pass next_frame to dwarf2_frame_init_reg.
	* dwarf2-frame.h (dwarf2-frame_set_init_reg): Update declaration.
	* cris-tdep.c (cris_dwarf2_frame_init_reg): Add next_frame arg.
	* s390-tdep.c (s390_dwarf2_frame_init_reg): Likewise.
	* sh-tdep.c (sh_dwarf2_frame_init_reg): Likewise.
	* sparc64-tdep.c (sparc64_dwarf2_frame_init_reg): Likewise.
	* sparc-tdep.c (sparc32_struct_return_from_sym): New function.
	(sparc32_frame_cache): Call it.
	(sparc32_dwarf2_struct_return_p): New function.
	(sparc_dwarf2_frame_init_reg): Use it to determine if the function
	returns a structure and thus we have to indicate the return PC and
	NPC are 4 bytes later than usual.
@
text
@d47 1
a479 324
/* Prologue analysis.  */

/* When we analyze a prologue, we're really doing 'abstract
   interpretation' or 'pseudo-evaluation': running the function's code
   in simulation, but using conservative approximations of the values
   it would have when it actually runs.  For example, if our function
   starts with the instruction:

      ahi r1, 42     # add halfword immediate 42 to r1

   we don't know exactly what value will be in r1 after executing this
   instruction, but we do know it'll be 42 greater than its original
   value.

   If we then see an instruction like:

      ahi r1, 22     # add halfword immediate 22 to r1

   we still don't know what r1's value is, but again, we can say it is
   now 64 greater than its original value.

   If the next instruction were:

      lr r2, r1      # set r2 to r1's value

   then we can say that r2's value is now the original value of r1
   plus 64.  And so on.

   Of course, this can only go so far before it gets unreasonable.  If
   we wanted to be able to say anything about the value of r1 after
   the instruction:

      xr r1, r3      # exclusive-or r1 and r3, place result in r1

   then things would get pretty complex.  But remember, we're just
   doing a conservative approximation; if exclusive-or instructions
   aren't relevant to prologues, we can just say r1's value is now
   'unknown'.  We can ignore things that are too complex, if that loss
   of information is acceptable for our application.

   Once you've reached an instruction that you don't know how to
   simulate, you stop.  Now you examine the state of the registers and
   stack slots you've kept track of.  For example:

   - To see how large your stack frame is, just check the value of sp;
     if it's the original value of sp minus a constant, then that
     constant is the stack frame's size.  If the sp's value has been
     marked as 'unknown', then that means the prologue has done
     something too complex for us to track, and we don't know the
     frame size.

   - To see whether we've saved the SP in the current frame's back
     chain slot, we just check whether the current value of the back
     chain stack slot is the original value of the sp.

   Sure, this takes some work.  But prologue analyzers aren't
   quick-and-simple pattern patching to recognize a few fixed prologue
   forms any more; they're big, hairy functions.  Along with inferior
   function calls, prologue analysis accounts for a substantial
   portion of the time needed to stabilize a GDB port.  So I think
   it's worthwhile to look for an approach that will be easier to
   understand and maintain.  In the approach used here:

   - It's easier to see that the analyzer is correct: you just see
     whether the analyzer properly (albiet conservatively) simulates
     the effect of each instruction.

   - It's easier to extend the analyzer: you can add support for new
     instructions, and know that you haven't broken anything that
     wasn't already broken before.

   - It's orthogonal: to gather new information, you don't need to
     complicate the code for each instruction.  As long as your domain
     of conservative values is already detailed enough to tell you
     what you need, then all the existing instruction simulations are
     already gathering the right data for you.

   A 'struct prologue_value' is a conservative approximation of the
   real value the register or stack slot will have.  */

struct prologue_value {

  /* What sort of value is this?  This determines the interpretation
     of subsequent fields.  */
  enum {

    /* We don't know anything about the value.  This is also used for
       values we could have kept track of, when doing so would have
       been too complex and we don't want to bother.  The bottom of
       our lattice.  */
    pv_unknown,

    /* A known constant.  K is its value.  */
    pv_constant,

    /* The value that register REG originally had *UPON ENTRY TO THE
       FUNCTION*, plus K.  If K is zero, this means, obviously, just
       the value REG had upon entry to the function.  REG is a GDB
       register number.  Before we start interpreting, we initialize
       every register R to { pv_register, R, 0 }.  */
    pv_register,

  } kind;

  /* The meanings of the following fields depend on 'kind'; see the
     comments for the specific 'kind' values.  */
  int reg;
  CORE_ADDR k;
};


/* Set V to be unknown.  */
static void
pv_set_to_unknown (struct prologue_value *v)
{
  v->kind = pv_unknown;
}


/* Set V to the constant K.  */
static void
pv_set_to_constant (struct prologue_value *v, CORE_ADDR k)
{
  v->kind = pv_constant;
  v->k = k;
}


/* Set V to the original value of register REG, plus K.  */
static void
pv_set_to_register (struct prologue_value *v, int reg, CORE_ADDR k)
{
  v->kind = pv_register;
  v->reg = reg;
  v->k = k;
}


/* If one of *A and *B is a constant, and the other isn't, swap the
   pointers as necessary to ensure that *B points to the constant.
   This can reduce the number of cases we need to analyze in the
   functions below.  */
static void
pv_constant_last (struct prologue_value **a,
                  struct prologue_value **b)
{
  if ((*a)->kind == pv_constant
      && (*b)->kind != pv_constant)
    {
      struct prologue_value *temp = *a;
      *a = *b;
      *b = temp;
    }
}


/* Set SUM to the sum of A and B.  SUM, A, and B may point to the same
   'struct prologue_value' object.  */
static void
pv_add (struct prologue_value *sum,
        struct prologue_value *a,
        struct prologue_value *b)
{
  pv_constant_last (&a, &b);

  /* We can handle adding constants to registers, and other constants.  */
  if (b->kind == pv_constant
      && (a->kind == pv_register
          || a->kind == pv_constant))
    {
      sum->kind = a->kind;
      sum->reg = a->reg;    /* not meaningful if a is pv_constant, but
                               harmless */
      sum->k = a->k + b->k;
    }

  /* Anything else we don't know how to add.  We don't have a
     representation for, say, the sum of two registers, or a multiple
     of a register's value (adding a register to itself).  */
  else
    sum->kind = pv_unknown;
}


/* Add the constant K to V.  */
static void
pv_add_constant (struct prologue_value *v, CORE_ADDR k)
{
  struct prologue_value pv_k;

  /* Rather than thinking of all the cases we can and can't handle,
     we'll just let pv_add take care of that for us.  */
  pv_set_to_constant (&pv_k, k);
  pv_add (v, v, &pv_k);
}


/* Subtract B from A, and put the result in DIFF.

   This isn't quite the same as negating B and adding it to A, since
   we don't have a representation for the negation of anything but a
   constant.  For example, we can't negate { pv_register, R1, 10 },
   but we do know that { pv_register, R1, 10 } minus { pv_register,
   R1, 5 } is { pv_constant, <ignored>, 5 }.

   This means, for example, that we can subtract two stack addresses;
   they're both relative to the original SP.  Since the frame pointer
   is set based on the SP, its value will be the original SP plus some
   constant (probably zero), so we can use its value just fine.  */
static void
pv_subtract (struct prologue_value *diff,
             struct prologue_value *a,
             struct prologue_value *b)
{
  pv_constant_last (&a, &b);

  /* We can subtract a constant from another constant, or from a
     register.  */
  if (b->kind == pv_constant
      && (a->kind == pv_register
          || a->kind == pv_constant))
    {
      diff->kind = a->kind;
      diff->reg = a->reg;    /* not always meaningful, but harmless */
      diff->k = a->k - b->k;
    }

  /* We can subtract a register from itself, yielding a constant.  */
  else if (a->kind == pv_register
           && b->kind == pv_register
           && a->reg == b->reg)
    {
      diff->kind = pv_constant;
      diff->k = a->k - b->k;
    }

  /* We don't know how to subtract anything else.  */
  else
    diff->kind = pv_unknown;
}


/* Set AND to the logical and of A and B.  */
static void
pv_logical_and (struct prologue_value *and,
                struct prologue_value *a,
                struct prologue_value *b)
{
  pv_constant_last (&a, &b);

  /* We can 'and' two constants.  */
  if (a->kind == pv_constant
      && b->kind == pv_constant)
    {
      and->kind = pv_constant;
      and->k = a->k & b->k;
    }

  /* We can 'and' anything with the constant zero.  */
  else if (b->kind == pv_constant
           && b->k == 0)
    {
      and->kind = pv_constant;
      and->k = 0;
    }
  
  /* We can 'and' anything with ~0.  */
  else if (b->kind == pv_constant
           && b->k == ~ (CORE_ADDR) 0)
    *and = *a;

  /* We can 'and' a register with itself.  */
  else if (a->kind == pv_register
           && b->kind == pv_register
           && a->reg == b->reg
           && a->k == b->k)
    *and = *a;

  /* Otherwise, we don't know.  */
  else
    pv_set_to_unknown (and);
}


/* Return non-zero iff A and B are identical expressions.

   This is not the same as asking if the two values are equal; the
   result of such a comparison would have to be a pv_boolean, and
   asking whether two 'unknown' values were equal would give you
   pv_maybe.  Same for comparing, say, { pv_register, R1, 0 } and {
   pv_register, R2, 0}.  Instead, this is asking whether the two
   representations are the same.  */
static int
pv_is_identical (struct prologue_value *a,
                 struct prologue_value *b)
{
  if (a->kind != b->kind)
    return 0;

  switch (a->kind)
    {
    case pv_unknown:
      return 1;
    case pv_constant:
      return (a->k == b->k);
    case pv_register:
      return (a->reg == b->reg && a->k == b->k);
    default:
      gdb_assert (0);
    }
}


/* Return non-zero if A is the original value of register number R
   plus K, zero otherwise.  */
static int
pv_is_register (struct prologue_value *a, int r, CORE_ADDR k)
{
  return (a->kind == pv_register
          && a->reg == r
          && a->k == k);
}


d712 1
a712 29
/* Set ADDR to the effective address for an X-style instruction, like:

        L R1, D2(X2, B2)

   Here, X2 and B2 are registers, and D2 is a signed 20-bit
   constant; the effective address is the sum of all three.  If either
   X2 or B2 are zero, then it doesn't contribute to the sum --- this
   means that r0 can't be used as either X2 or B2.

   GPR is an array of general register values, indexed by GPR number,
   not GDB register number.  */
static void
compute_x_addr (struct prologue_value *addr, 
                struct prologue_value *gpr,
                int d2, unsigned int x2, unsigned int b2)
{
  /* We can't just add stuff directly in addr; it might alias some of
     the registers we need to read.  */
  struct prologue_value result;

  pv_set_to_constant (&result, d2);
  if (x2)
    pv_add (&result, &result, &gpr[x2]);
  if (b2)
    pv_add (&result, &result, &gpr[b2]);

  *addr = result;
}

d724 1
a724 1
  struct prologue_value gpr[S390_NUM_GPRS];
d727 1
a727 1
  struct prologue_value fpr[S390_NUM_FPRS];
d741 24
a764 1
/* Do a SIZE-byte store of VALUE to ADDR.  */
d766 3
a768 4
s390_store (struct prologue_value *addr,
            CORE_ADDR size,
            struct prologue_value *value,
	    struct s390_prologue_data *data)
d770 2
a771 1
  struct prologue_value cfa, offset;
d775 1
a775 1
  pv_subtract (&offset, &data->gpr[S390_SP_REGNUM - S390_R0_REGNUM], addr);
d777 1
a777 1
  if (offset.kind == pv_constant && offset.k == 0)
d779 1
a779 1
	&& pv_is_register (value, S390_SP_REGNUM, 0))
d787 2
a788 2
  pv_set_to_register (&cfa, S390_SP_REGNUM, 16 * data->gpr_size + 32);
  pv_subtract (&offset, &cfa, addr);
d790 1
a790 1
  if (offset.kind == pv_constant
d800 1
a800 1
	    && pv_is_register (value, S390_R0_REGNUM + i, 0))
d810 1
a810 1
	    && pv_is_register (value, S390_F0_REGNUM + i, 0))
d828 5
a832 6
/* Do a SIZE-byte load from ADDR into VALUE.  */
static void
s390_load (struct prologue_value *addr,
	   CORE_ADDR size,
	   struct prologue_value *value,
	   struct s390_prologue_data *data)
d834 2
a835 1
  struct prologue_value cfa, offset;
d843 1
a843 1
  if (addr->kind == pv_constant)
d846 1
a846 1
      secp = target_section_by_addr (&current_target, addr->k);
d850 1
a850 4
	{
          pv_set_to_constant (value, read_memory_integer (addr->k, size));
	  return;
	}
d854 2
a855 2
  pv_set_to_register (&cfa, S390_SP_REGNUM, 16 * data->gpr_size + 32);
  pv_subtract (&offset, &cfa, addr);
d857 1
a857 1
  if (offset.kind == pv_constant
d862 1
a862 4
	  {
	    pv_set_to_register (value, S390_R0_REGNUM + i, 0);
	    return;
	  }
d866 1
a866 4
	  {
	    pv_set_to_register (value, S390_F0_REGNUM + i, 0);
	    return;
	  }
d870 1
a870 1
  pv_set_to_unknown (value);
d911 1
a911 1
      pv_set_to_register (&data->gpr[i], S390_R0_REGNUM + i, 0);
d914 1
a914 1
      pv_set_to_register (&data->fpr[i], S390_F0_REGNUM + i, 0);
d932 4
d942 1
a942 1
      struct prologue_value pre_insn_sp, pre_insn_fp;
a958 69
      /* LHI r1, i2 --- load halfword immediate */
      if (word_size == 4
	  && is_ri (insn, op1_lhi, op2_lhi, &r1, &i2))
        pv_set_to_constant (&data->gpr[r1], i2);

      /* LGHI r1, i2 --- load halfword immediate (64-bit version) */
      else if (word_size == 8
	       && is_ri (insn, op1_lghi, op2_lghi, &r1, &i2))
        pv_set_to_constant (&data->gpr[r1], i2);

      /* LGFI r1, i2 --- load fullword immediate */
      else if (is_ril (insn, op1_lgfi, op2_lgfi, &r1, &i2))
        pv_set_to_constant (&data->gpr[r1], i2);

      /* LR r1, r2 --- load from register */
      else if (word_size == 4
	       && is_rr (insn, op_lr, &r1, &r2))
        data->gpr[r1] = data->gpr[r2];

      /* LGR r1, r2 --- load from register (64-bit version) */
      else if (word_size == 8
               && is_rre (insn, op_lgr, &r1, &r2))
        data->gpr[r1] = data->gpr[r2];

      /* L r1, d2(x2, b2) --- load */
      else if (word_size == 4
	       && is_rx (insn, op_l, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;

          compute_x_addr (&addr, data->gpr, d2, x2, b2);
	  s390_load (&addr, 4, &data->gpr[r1], data);
        }

      /* LY r1, d2(x2, b2) --- load (long-displacement version) */
      else if (word_size == 4
	       && is_rxy (insn, op1_ly, op2_ly, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;

          compute_x_addr (&addr, data->gpr, d2, x2, b2);
	  s390_load (&addr, 4, &data->gpr[r1], data);
        }

      /* LG r1, d2(x2, b2) --- load (64-bit version) */
      else if (word_size == 8
	       && is_rxy (insn, op1_lg, op2_lg, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;

          compute_x_addr (&addr, data->gpr, d2, x2, b2);
	  s390_load (&addr, 8, &data->gpr[r1], data);
        }

      /* ST r1, d2(x2, b2) --- store */
      else if (word_size == 4
	       && is_rx (insn, op_st, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;

          compute_x_addr (&addr, data->gpr, d2, x2, b2);
	  s390_store (&addr, 4, &data->gpr[r1], data);
        }

      /* STY r1, d2(x2, b2) --- store (long-displacement version) */
      else if (word_size == 4
	       && is_rxy (insn, op1_sty, op2_sty, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;
d960 29
a988 13
          compute_x_addr (&addr, data->gpr, d2, x2, b2);
	  s390_store (&addr, 4, &data->gpr[r1], data);
        }

      /* STG r1, d2(x2, b2) --- store (64-bit version) */
      else if (word_size == 8
	       && is_rxy (insn, op1_stg, op2_stg, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;

          compute_x_addr (&addr, data->gpr, d2, x2, b2);
	  s390_store (&addr, 8, &data->gpr[r1], data);
        }
d990 1
a990 1
      /* STD r1, d2(x2,b2) --- store floating-point register  */
d992 1
a992 23
        {
          struct prologue_value addr;

          compute_x_addr (&addr, data->gpr, d2, x2, b2);
          s390_store (&addr, 8, &data->fpr[r1], data);
        }

      /* STM r1, r3, d2(b2) --- store multiple */
      else if (word_size == 4
	       && is_rs (insn, op_stm, &r1, &r3, &d2, &b2))
        {
          int regnum;
          int offset;
          struct prologue_value addr;

          for (regnum = r1, offset = 0;
               regnum <= r3;
               regnum++, offset += 4)
            {
              compute_x_addr (&addr, data->gpr, d2 + offset, 0, b2);
              s390_store (&addr, 4, &data->gpr[regnum], data);
            }
        }
d994 6
a999 3
      /* STMY r1, r3, d2(b2) --- store multiple (long-displacement version) */
      else if (word_size == 4
	       && is_rsy (insn, op1_stmy, op2_stmy, &r1, &r3, &d2, &b2))
d1001 2
a1002 11
          int regnum;
          int offset;
          struct prologue_value addr;

          for (regnum = r1, offset = 0;
               regnum <= r3;
               regnum++, offset += 4)
            {
              compute_x_addr (&addr, data->gpr, d2 + offset, 0, b2);
              s390_store (&addr, 4, &data->gpr[regnum], data);
            }
d1005 59
a1063 172
      /* STMG r1, r3, d2(b2) --- store multiple (64-bit version) */
      else if (word_size == 8
	       && is_rsy (insn, op1_stmg, op2_stmg, &r1, &r3, &d2, &b2))
        {
          int regnum;
          int offset;
          struct prologue_value addr;

          for (regnum = r1, offset = 0;
               regnum <= r3;
               regnum++, offset += 8)
            {
              compute_x_addr (&addr, data->gpr, d2 + offset, 0, b2);
              s390_store (&addr, 8, &data->gpr[regnum], data);
            }
        }

      /* AHI r1, i2 --- add halfword immediate */
      else if (word_size == 4
	       && is_ri (insn, op1_ahi, op2_ahi, &r1, &i2))
        pv_add_constant (&data->gpr[r1], i2);

      /* AGHI r1, i2 --- add halfword immediate (64-bit version) */
      else if (word_size == 8
               && is_ri (insn, op1_aghi, op2_aghi, &r1, &i2))
        pv_add_constant (&data->gpr[r1], i2);

      /* AFI r1, i2 --- add fullword immediate */
      else if (word_size == 4
	       && is_ril (insn, op1_afi, op2_afi, &r1, &i2))
        pv_add_constant (&data->gpr[r1], i2);

      /* AGFI r1, i2 --- add fullword immediate (64-bit version) */
      else if (word_size == 8
               && is_ril (insn, op1_agfi, op2_agfi, &r1, &i2))
        pv_add_constant (&data->gpr[r1], i2);

      /* ALFI r1, i2 --- add logical immediate */
      else if (word_size == 4
	       && is_ril (insn, op1_alfi, op2_alfi, &r1, &i2))
        pv_add_constant (&data->gpr[r1], (CORE_ADDR)i2 & 0xffffffff);

      /* ALGFI r1, i2 --- add logical immediate (64-bit version) */
      else if (word_size == 8
               && is_ril (insn, op1_algfi, op2_algfi, &r1, &i2))
        pv_add_constant (&data->gpr[r1], (CORE_ADDR)i2 & 0xffffffff);

      /* AR r1, r2 -- add register */
      else if (word_size == 4
	       && is_rr (insn, op_ar, &r1, &r2))
        pv_add (&data->gpr[r1], &data->gpr[r1], &data->gpr[r2]);

      /* AGR r1, r2 -- add register (64-bit version) */
      else if (word_size == 8
	       && is_rre (insn, op_agr, &r1, &r2))
        pv_add (&data->gpr[r1], &data->gpr[r1], &data->gpr[r2]);

      /* A r1, d2(x2, b2) -- add */
      else if (word_size == 4
	       && is_rx (insn, op_a, &r1, &d2, &x2, &b2))
	{
          struct prologue_value addr;
          struct prologue_value value;

          compute_x_addr (&addr, data->gpr, d2, x2, b2);
	  s390_load (&addr, 4, &value, data);
	
	  pv_add (&data->gpr[r1], &data->gpr[r1], &value);
	}

      /* AY r1, d2(x2, b2) -- add (long-displacement version) */
      else if (word_size == 4
	       && is_rxy (insn, op1_ay, op2_ay, &r1, &d2, &x2, &b2))
	{
          struct prologue_value addr;
          struct prologue_value value;

          compute_x_addr (&addr, data->gpr, d2, x2, b2);
	  s390_load (&addr, 4, &value, data);
	
	  pv_add (&data->gpr[r1], &data->gpr[r1], &value);
	}

      /* AG r1, d2(x2, b2) -- add (64-bit version) */
      else if (word_size == 8
	       && is_rxy (insn, op1_ag, op2_ag, &r1, &d2, &x2, &b2))
	{
          struct prologue_value addr;
          struct prologue_value value;

          compute_x_addr (&addr, data->gpr, d2, x2, b2);
	  s390_load (&addr, 8, &value, data);
	
	  pv_add (&data->gpr[r1], &data->gpr[r1], &value);
	}

      /* SLFI r1, i2 --- subtract logical immediate */
      else if (word_size == 4
	       && is_ril (insn, op1_slfi, op2_slfi, &r1, &i2))
        pv_add_constant (&data->gpr[r1], -((CORE_ADDR)i2 & 0xffffffff));

      /* SLGFI r1, i2 --- subtract logical immediate (64-bit version) */
      else if (word_size == 8
               && is_ril (insn, op1_slgfi, op2_slgfi, &r1, &i2))
        pv_add_constant (&data->gpr[r1], -((CORE_ADDR)i2 & 0xffffffff));

      /* SR r1, r2 -- subtract register */
      else if (word_size == 4
	       && is_rr (insn, op_sr, &r1, &r2))
        pv_subtract (&data->gpr[r1], &data->gpr[r1], &data->gpr[r2]);

      /* SGR r1, r2 -- subtract register (64-bit version) */
      else if (word_size == 8
	       && is_rre (insn, op_sgr, &r1, &r2))
        pv_subtract (&data->gpr[r1], &data->gpr[r1], &data->gpr[r2]);

      /* S r1, d2(x2, b2) -- subtract */
      else if (word_size == 4
	       && is_rx (insn, op_s, &r1, &d2, &x2, &b2))
	{
          struct prologue_value addr;
          struct prologue_value value;

          compute_x_addr (&addr, data->gpr, d2, x2, b2);
	  s390_load (&addr, 4, &value, data);
	
	  pv_subtract (&data->gpr[r1], &data->gpr[r1], &value);
	}

      /* SY r1, d2(x2, b2) -- subtract (long-displacement version) */
      else if (word_size == 4
	       && is_rxy (insn, op1_sy, op2_sy, &r1, &d2, &x2, &b2))
	{
          struct prologue_value addr;
          struct prologue_value value;

          compute_x_addr (&addr, data->gpr, d2, x2, b2);
	  s390_load (&addr, 4, &value, data);
	
	  pv_subtract (&data->gpr[r1], &data->gpr[r1], &value);
	}

      /* SG r1, d2(x2, b2) -- subtract (64-bit version) */
      else if (word_size == 8
	       && is_rxy (insn, op1_sg, op2_sg, &r1, &d2, &x2, &b2))
	{
          struct prologue_value addr;
          struct prologue_value value;

          compute_x_addr (&addr, data->gpr, d2, x2, b2);
	  s390_load (&addr, 8, &value, data);
	
	  pv_subtract (&data->gpr[r1], &data->gpr[r1], &value);
	}

      /* NR r1, r2 --- logical and */
      else if (word_size == 4
	       && is_rr (insn, op_nr, &r1, &r2))
        pv_logical_and (&data->gpr[r1], &data->gpr[r1], &data->gpr[r2]);

      /* NGR r1, r2 >--- logical and (64-bit version) */
      else if (word_size == 8
               && is_rre (insn, op_ngr, &r1, &r2))
        pv_logical_and (&data->gpr[r1], &data->gpr[r1], &data->gpr[r2]);

      /* LA r1, d2(x2, b2) --- load address */
      else if (is_rx (insn, op_la, &r1, &d2, &x2, &b2))
        compute_x_addr (&data->gpr[r1], data->gpr, d2, x2, b2);

      /* LAY r1, d2(x2, b2) --- load address (long-displacement version) */
      else if (is_rxy (insn, op1_lay, op2_lay, &r1, &d2, &x2, &b2))
        compute_x_addr (&data->gpr[r1], data->gpr, d2, x2, b2);
d1065 1
a1065 1
      /* LARL r1, i2 --- load address relative long */
d1067 1
a1067 1
        pv_set_to_constant (&data->gpr[r1], pc + i2 * 2);
d1069 1
a1069 1
      /* BASR r1, 0 --- branch and save
d1073 1
a1073 1
        pv_set_to_constant (&data->gpr[r1], next_pc);
d1075 1
a1075 1
      /* BRAS r1, i2 --- branch relative and save */
d1078 1
a1078 1
          pv_set_to_constant (&data->gpr[r1], next_pc);
d1112 2
a1113 2
        struct prologue_value *sp = &data->gpr[S390_SP_REGNUM - S390_R0_REGNUM];
        struct prologue_value *fp = &data->gpr[S390_FRAME_REGNUM - S390_R0_REGNUM];
d1115 6
a1120 4
        if ((! pv_is_identical (&pre_insn_sp, sp)
             && ! pv_is_register (sp, S390_SP_REGNUM, 0))
            || (! pv_is_identical (&pre_insn_fp, fp)
                && ! pv_is_register (fp, S390_FRAME_REGNUM, 0))
d1211 2
a1212 2
  struct prologue_value *fp = &data.gpr[S390_FRAME_REGNUM - S390_R0_REGNUM];
  struct prologue_value *sp = &data.gpr[S390_SP_REGNUM - S390_R0_REGNUM];
d1239 1
a1239 1
  if (sp->kind != pv_register || sp->reg != S390_SP_REGNUM)
d1271 1
a1271 1
	  struct prologue_value *sp = &data2.gpr[S390_SP_REGNUM - S390_R0_REGNUM];
d1274 1
a1274 2
	        && sp->kind == pv_register
	        && sp->reg == S390_SP_REGNUM
d1288 1
a1288 1
  if (pv_is_identical (sp, fp))
@


1.150
log
@* arm-linux-tdep.c (arm_linux_svr4_fetch_link_map_offsets):
Remove.
(arm_linux_init_abi): Set solib_svr4_fetch_link_map_offsets to
svr4_ilp32_fetch_link_map_offsets.
* cris-tdep.c (cris_linux_svr4_fetch_link_map_offsets): Remove
function.
(cris_gdbarch_init): Set solib_svr4_fetch_link_map_offsets to
svr4_ilp32_fetch_link_map_offsets.
* mips-linux-tdep.c (mips_linux_svr4_fetch_link_map_offsets)
(mips64_linux_svr4_fetch_link_map_offsets): Remove functions.
(mips_linux_init_abi): Set solib_svr4_fetch_link_map_offsets to
svr4_ilp32_fetch_link_map_offsets or svr4_lp64_fetch_link_map_offsets
where appropriate.
* nbsd-tdep.c (nbsd_ilp32_solib_svr4_fetch_link_map_offsets):
Simply call svr4_ilp32_fetch_link_map_offsets.
(nbsd_lp64_solib_svr4_fetch_link_map_offsets): Simply call
svr4_lp64_fetch_link_map_offsets.
* ppc-linux-tdep.c (ppc_linux_svr4_fetch_link_map_offsets): Remove
function.
(ppc_linux_init_abi): Set solib_svr4_fetch_link_map_offsets to
svr4_ilp32_fetch_link_map_offsets.
* s390-tdep.c (s390_svr4_fetch_link_map_offsets)
(s390x_svr4_fetch_link_map_offsets): Remove functions.
(s390_gdbarch_init): Set solib_svr4_fetch_link_map_offsets to
svr4_ilp32_fetch_link_map_offsets or svr4_lp64_fetch_link_map_offsets
where appropriate.
@
text
@d2282 2
a2283 1
                            struct dwarf2_frame_state_reg *reg)
@


1.149
log
@* s390-tdep.c: Do not include "tm.h" and "../bfd/bfd.h".
* Makefile.in (s390-tdep.o): Update dependencies.
@
text
@d46 1
a46 1
#include "solib-svr4.h"         /* For struct link_map_offsets.  */
a2866 70

/* Link map offsets.  */

static struct link_map_offsets *
s390_svr4_fetch_link_map_offsets (void)
{
  static struct link_map_offsets lmo;
  static struct link_map_offsets *lmp = NULL;

  if (lmp == NULL)
    {
      lmp = &lmo;

      lmo.r_debug_size = 8;

      lmo.r_map_offset = 4;
      lmo.r_map_size   = 4;

      lmo.link_map_size = 20;

      lmo.l_addr_offset = 0;
      lmo.l_addr_size   = 4;

      lmo.l_name_offset = 4;
      lmo.l_name_size   = 4;

      lmo.l_next_offset = 12;
      lmo.l_next_size   = 4;

      lmo.l_prev_offset = 16;
      lmo.l_prev_size   = 4;
    }

  return lmp;
}

static struct link_map_offsets *
s390x_svr4_fetch_link_map_offsets (void)
{
  static struct link_map_offsets lmo;
  static struct link_map_offsets *lmp = NULL;

  if (lmp == NULL)
    {
      lmp = &lmo;

      lmo.r_debug_size = 16;   /* All we need.  */

      lmo.r_map_offset = 8;
      lmo.r_map_size   = 8;

      lmo.link_map_size = 40;   /* All we need.  */

      lmo.l_addr_offset = 0;
      lmo.l_addr_size   = 8;

      lmo.l_name_offset = 8;
      lmo.l_name_size   = 8;

      lmo.l_next_offset = 24;
      lmo.l_next_size   = 8;

      lmo.l_prev_offset = 32;
      lmo.l_prev_size   = 8;
    }

  return lmp;
}


d2948 2
a2949 2
      set_solib_svr4_fetch_link_map_offsets (gdbarch,
					     s390_svr4_fetch_link_map_offsets);
d2965 2
a2966 2
      set_solib_svr4_fetch_link_map_offsets (gdbarch,
					     s390x_svr4_fetch_link_map_offsets);
@


1.148
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 2
a4 2
   Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation,
   Inc.
a34 2
#include "tm.h"
#include "../bfd/bfd.h"
@


1.147
log
@	* s390-tdep.c (op1_lgfi, op2_lgfi, op1_agfi, op2_agfi,
	op1_afi, op2_afi, op1_algfi, op2_algfi, op1_alfi, op2_alfi,
	op1_slgfi, op2_slgfi, op1_slfi, op2_slfi): New opcode enums.
	(s390_analyze_prologue): Recognize new z9-109 instructions.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation,
d23 2
a24 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.146
log
@	* s390-tdep.c (s390_frame_prev_register): Change type of last
	argument to 'gdb_byte *'.
	(s390_stub_frame_prev_register): Likewise.
	(s390_sigtramp_frame_prev_register): Likewise.
@
text
@d814 1
d832 4
d841 2
d1304 4
d1448 20
d1517 10
@


1.145
log
@	* s390-tdep.c (s390_return_value): Remove unnecessary casts.
	(s390_breakpoint_from_pc): Change type of return value and
	'breakpoint' to const gdb_byte *.
@
text
@d1948 1
a1948 1
			  int *realnump, void *bufferp)
d2020 1
a2020 1
			       int *realnump, void *bufferp)
d2163 1
a2163 1
				   int *realnump, void *bufferp)
@


1.144
log
@	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write):
	Change type of 'buf' argument to gdb_byte *.
	(s390x_pseudo_register_read, s390x_pseudo_register_write): Likewise.
	(s390_register_to_value): Change type of 'out' to gdb_byte *, change
	type of 'in' to gdb_byte [].
	(s390_value_to_register): Change type of 'in' to gdb_byte *, change
	type of 'out' to gdb_byte [].
	(s390_return_value): Change type of 'out' and 'in' to gdb_byte *.
@
text
@d2729 1
a2729 2
	      regcache_cooked_write (regcache, S390_R3_REGNUM,
				     (const char *)in + word_size);
d2761 1
a2761 2
	      regcache_cooked_read (regcache, S390_R3_REGNUM,
				    (char *)out + word_size);
d2779 1
a2779 1
static const unsigned char *
d2782 1
a2782 1
  static unsigned char breakpoint[] = { 0x0, 0x1 };
@


1.143
log
@	* gdbarch.sh (fetch_tls_load_module_address): New architecture method.
	* gdbarch.c, gdbarch.h: Regenerate.
	* dwarf2loc.c (dwarf_expr_tls_address): Fetch TLS load module
	address and pass this address, instead of the objfile address, to
	target_get_thread_local_address().
	* linux-thread-db.c (thread_db_get_thread_local_address): Change
	second parameter from type ``struct objfile *'' to CORE_ADDR.  Do
	not call svr4_fetch_objfile_link_map() to fetch the load module
	address.
	* target.h (struct target_ops): Change second parameter of
	``to_get_thread_local_address'' from ``struct objfile *'' to
	``CORE_ADDR''.
	* alpha-linux-tdep.c (solib-svr4.h): Include.
	(alpha_linux_init_abi): Register TLS load module fetcher.
	* amd64-linux-tdep.c (amd64_linux_init_abi): Likewise.
	* hppa-linux-tdep.c (hppa_linux_init_abi): Likewise.
	* i386-linux-tdep.c (i386_linux_init_abi): Likewise.
	* ia64-linux-tdep.c (solib-svr4.h): Include.
	(ia64_linux_init_abi): Register TLS load module fetcher.
	* m32r-linux-tdep.c (m32r_linux_init_abi): Likewise.
	* m68klinux-tdep.c (m68k_linux_init_abi): Likewise.
	* mips-linux-tdep.c (mips_linux_init_abi): Likewise.
	* s390-tdep.c (s390_gdbarch_init): Likewise.
	* sparc-linux-tdep.c (sparc32_linux_init_abi): Likewise.
	* sparc64-linux-tdep.c (solib-svr4.h): Include.
	(sparc64_linux_init_abi): Register TLS load module fetcher.
	* Makefile.in (alpha-linux-tdep.o, ia64-linux-tdep.o)
	(sparc-linux-tdep.o): Update dependencies.
@
text
@d213 1
a213 1
			   int regnum, void *buf)
d236 1
a236 1
			    int regnum, const void *buf)
d263 1
a263 1
			    int regnum, void *buf)
d285 1
a285 1
			     int regnum, const void *buf)
d319 1
a319 1
                        struct type *valtype, void *out)
d321 1
a321 1
  char in[8];
d331 1
a331 1
                        struct type *valtype, const void *in)
d333 1
a333 1
  char out[8];
d2697 2
a2698 1
		   struct regcache *regcache, void *out, const void *in)
@


1.142
log
@2005-03-17  Paul Brook  <paul@@codesourcery.com>

	* amd64-tdep.c (amd64_dwarf_reg_to_regnum): Fix broken logic.
	* s390-tdep.c (s390_dwarf_reg_to_regnum): Ditto.
@
text
@d3010 4
@


1.141
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d200 1
a200 1
  if (reg >= 0 || reg < ARRAY_SIZE (s390_dwarf_regmap))
@


1.140
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d230 1
a230 1
      internal_error (__FILE__, __LINE__, "invalid regnum");
d257 1
a257 1
      internal_error (__FILE__, __LINE__, "invalid regnum");
d279 1
a279 1
      internal_error (__FILE__, __LINE__, "invalid regnum");
d303 1
a303 1
      internal_error (__FILE__, __LINE__, "invalid regnum");
d2631 1
a2631 1
	  internal_error (__FILE__, __LINE__, "unknown argument type");
d2732 1
a2732 1
	    internal_error (__FILE__, __LINE__, "invalid return type");
d2765 1
a2765 1
	    internal_error (__FILE__, __LINE__, "invalid return type");
@


1.139
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d204 1
a204 1
    warning ("Unmapped DWARF Register #%d encountered\n", reg);
d2736 1
a2736 1
	  error ("Cannot set function return value.");
d2769 1
a2769 1
	  error ("Function return value unknown.");
@


1.138
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* sparc-tdep.c: Replace VALUE_TYPE with value_type.
	* v850-tdep.c, sparc64-tdep.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, s390-tdep.c, mcore-tdep.c: Ditto.
	* h8300-tdep.c, arm-linux-tdep.c, amd64-tdep.c: Ditto.
	* hppa-tdep.c, mips-tdep.c, m88k-tdep.c: Ditto.
	* m68hc11-tdep.c, m32r-tdep.c, ia64-tdep.c: Ditto.
	* frv-tdep.c, cris-tdep.c, avr-tdep.c, alpha-tdep.c: Ditto.
@
text
@d3 2
a4 1
   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d2438 1
a2438 1
    return extract_unsigned_integer (VALUE_CONTENTS (arg),
d2441 1
a2441 1
    return extract_signed_integer (VALUE_CONTENTS (arg),
d2522 1
a2522 1
          write_memory (sp, VALUE_CONTENTS (arg), length);
d2582 1
a2582 1
					    0, length, VALUE_CONTENTS (arg));
d2590 1
a2590 1
                write_memory (starg - length, VALUE_CONTENTS (arg), length);
d2615 1
a2615 1
				       VALUE_CONTENTS (arg));
d2617 1
a2617 1
				       VALUE_CONTENTS (arg) + word_size);
d2626 1
a2626 1
		write_memory (starg, VALUE_CONTENTS (arg), length);
@


1.137
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Do not set
	in_solib_call_trampoline to in_plt_entry, IN_SOLIB_CALL_TRAMPOLINE
	isn't used by this architecture.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_init_abi): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Ditto.
	* m68klinux-tdep.c (m68k_linux_init_abi): Ditto.
	* i386-tdep.c (i386_svr4_init_abi): Ditto.
	* i386-nto-tdep.c (i386nto_init_abi): Ditto.
	* arm-linux-tdep.c (arm_linux_init_abi): Ditto.
	* amd64-tdep.c (amd64_init_abi): Ditto.
@
text
@d2431 1
a2431 1
  struct type *type = VALUE_TYPE (arg);
d2514 1
a2514 1
      struct type *type = VALUE_TYPE (arg);
d2555 1
a2555 1
        struct type *type = VALUE_TYPE (arg);
@


1.136
log
@	* s390-tdep.c (enum pv_boolean): Remove.
	(pv_is_array_ref): Remove.
	(s390_on_stack): Remove.
	(S390_NUM_SPILL_SLOTS): Remove.
	(struct s390_prologue_data): Remove members 'spill' and 'back_chain',
	add members 'gpr_slot', 'fpr_slot', and 'back_chain_saved_p'.
	(s390_store): Track all stores of orginal incoming registers to the
	stack constant offsets relative to the CFA, instead of only tracking
	stores into specific spill slots.
	(s390_load): Likewise.
	(s390_analyze_prologue): Adapt to struct s390_prologue_data changes.
	(s390_prologue_frame_unwind_cache): Likewise.  Only track registers
	defined as call-saved by the ABI.
	(s390_push_dummy_call): Use bottom of dummy call argument save area
	as return value, not the top.  Do not store to the called function's
	register save area.
	(s390_unwind_dummy_id): Adapt accordingly.
@
text
@a2955 1
  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
@


1.135
log
@2004-07-31  Andrew Cagney  <cagney@@gnu.org>

	* trad-frame.c (trad_frame_get_prev_register): Rename
	trad_frame_get_prev_register.
	* vax-tdep.c (vax_frame_prev_register): Update.
	* trad-frame.h: Update.
	* trad-frame.c (trad_frame_get_register): Update.
	* sparcobsd-tdep.c (sparc32obsd_frame_prev_register): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64obsd-tdep.c (sparc64obsd_frame_prev_register): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_prev_register):
	Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-linux-tdep.c (sparc32_linux_sigtramp_frame_prev_register):
	Update.
	* s390-tdep.c (s390_frame_prev_register)
	(s390_stub_frame_prev_register)
	(s390_sigtramp_frame_prev_register): Update.
	* rs6000-tdep.c (rs6000_frame_prev_register): Update.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_prev_register): Update.
	* mips-tdep.c (mips_mdebug_frame_prev_register): Update.
	* m88k-tdep.c (m88k_frame_prev_register)
	* m68hc11-tdep.c (m68hc11_frame_prev_register)
	* m32r-tdep.c (m32r_frame_prev_register): Update.
	* hppa-tdep.c (hppa_frame_prev_register_helper)
	* frv-tdep.c (frv_frame_prev_register): Update.
	* d10v-tdep.c (d10v_frame_prev_register): Update.
	* cris-tdep.c (cris_frame_prev_register): Update.
	* avr-tdep.c (avr_frame_prev_register): Update.
	* arm-tdep.c (arm_prologue_prev_register)
	(arm_sigtramp_prev_register): Update.
@
text
@a803 60
/* A prologue-value-esque boolean type, including "maybe", when we
   can't figure out whether something is true or not.  */
enum pv_boolean {
  pv_maybe,
  pv_definite_yes,
  pv_definite_no,
};


/* Decide whether a reference to SIZE bytes at ADDR refers exactly to
   an element of an array.  The array starts at ARRAY_ADDR, and has
   ARRAY_LEN values of ELT_SIZE bytes each.  If ADDR definitely does
   refer to an array element, set *I to the index of the referenced
   element in the array, and return pv_definite_yes.  If it definitely
   doesn't, return pv_definite_no.  If we can't tell, return pv_maybe.

   If the reference does touch the array, but doesn't fall exactly on
   an element boundary, or doesn't refer to the whole element, return
   pv_maybe.  */
static enum pv_boolean
pv_is_array_ref (struct prologue_value *addr,
                 CORE_ADDR size,
                 struct prologue_value *array_addr,
                 CORE_ADDR array_len, 
                 CORE_ADDR elt_size,
                 int *i)
{
  struct prologue_value offset;

  /* Note that, since ->k is a CORE_ADDR, and CORE_ADDR is unsigned,
     if addr is *before* the start of the array, then this isn't going
     to be negative...  */
  pv_subtract (&offset, addr, array_addr);

  if (offset.kind == pv_constant)
    {
      /* This is a rather odd test.  We want to know if the SIZE bytes
         at ADDR don't overlap the array at all, so you'd expect it to
         be an || expression: "if we're completely before || we're
         completely after".  But with unsigned arithmetic, things are
         different: since it's a number circle, not a number line, the
         right values for offset.k are actually one contiguous range.  */
      if (offset.k <= -size
          && offset.k >= array_len * elt_size)
        return pv_definite_no;
      else if (offset.k % elt_size != 0
               || size != elt_size)
        return pv_maybe;
      else
        {
          *i = offset.k / elt_size;
          return pv_definite_yes;
        }
    }
  else
    return pv_maybe;
}



a1058 4
/* The number of GPR and FPR spill slots in an S/390 stack frame.  We
   track general-purpose registers r2 -- r15, and floating-point
   registers f0, f2, f4, and f6.  */
#define S390_NUM_SPILL_SLOTS (14 + 4)
d1074 10
a1083 10
  /* The register spill stack slots in the caller's frame ---
     general-purpose registers r2 through r15, and floating-point
     registers.  spill[i] is where gpr i+2 gets spilled;
     spill[(14, 15, 16, 17)] is where (f0, f2, f4, f6) get spilled.  */
  struct prologue_value spill[S390_NUM_SPILL_SLOTS];

  /* The value of the back chain slot.  This is only valid if the stack
     pointer is known to be less than its original value --- that is,
     if we have indeed allocated space on the stack.  */
  struct prologue_value back_chain;
a1085 66

/* If the SIZE bytes at ADDR are a stack slot we're actually tracking,
   return pv_definite_yes and set *STACK to point to the slot.  If
   we're sure that they are not any of our stack slots, then return
   pv_definite_no.  Otherwise, return pv_maybe.

   DATA describes our current state (registers and stack slots).  */
static enum pv_boolean
s390_on_stack (struct prologue_value *addr,
               CORE_ADDR size,
	       struct s390_prologue_data *data,
               struct prologue_value **stack)
{
  struct prologue_value gpr_spill_addr;
  struct prologue_value fpr_spill_addr;
  struct prologue_value back_chain_addr;  
  int i;
  enum pv_boolean b;

  /* Construct the addresses of the spill arrays and the back chain.  */
  pv_set_to_register (&gpr_spill_addr, S390_SP_REGNUM, 2 * data->gpr_size);
  pv_set_to_register (&fpr_spill_addr, S390_SP_REGNUM, 16 * data->gpr_size);
  back_chain_addr = data->gpr[S390_SP_REGNUM - S390_R0_REGNUM];

  /* We have to check for GPR and FPR references using two separate
     calls to pv_is_array_ref, since the GPR and FPR spill slots are
     different sizes.  (SPILL is an array, but the thing it tracks
     isn't really an array.)  */

  /* Was it a reference to the GPR spill array?  */
  b = pv_is_array_ref (addr, size, &gpr_spill_addr, 14, data->gpr_size, &i);
  if (b == pv_definite_yes)
    {
      *stack = &data->spill[i];
      return pv_definite_yes;
    }
  if (b == pv_maybe)
    return pv_maybe;

  /* Was it a reference to the FPR spill array?  */
  b = pv_is_array_ref (addr, size, &fpr_spill_addr, 4, data->fpr_size, &i);
  if (b == pv_definite_yes)
    {
      *stack = &data->spill[14 + i];
      return pv_definite_yes;
    }
  if (b == pv_maybe)
    return pv_maybe;

  /* Was it a reference to the back chain?
     This isn't quite right.  We ought to check whether we have
     actually allocated any new frame at all.  */
  b = pv_is_array_ref (addr, size, &back_chain_addr, 1, data->gpr_size, &i);
  if (b == pv_definite_yes)
    {
      *stack = &data->back_chain;
      return pv_definite_yes;
    }
  if (b == pv_maybe)
    return pv_maybe;

  /* All the above queries returned definite 'no's.  */
  return pv_definite_no;
}


d1093 36
a1128 1
  struct prologue_value *stack;
d1130 9
a1138 5
  /* We can do it if it's definitely a reference to something on the stack.  */
  if (s390_on_stack (addr, size, data, &stack) == pv_definite_yes)
    {
      *stack = *value;
      return;
a1140 2
  /* Note: If s390_on_stack returns pv_maybe, you might think we should
     forget our cached values, as any of those might have been hit.
d1142 6
a1147 4
     However, we make the assumption that --since the fields we track
     are save areas private to compiler, and never directly exposed to 
     the user-- every access to our data is explicit.  Hence, every 
     memory access we cannot follow can't hit our data.  */
d1157 2
a1158 1
  struct prologue_value *stack;
d1178 6
a1183 3
  /* If it's definitely a reference to something on the stack, 
     we can do that.  */
  if (s390_on_stack (addr, size, data, &stack) == pv_definite_yes)
d1185 13
a1197 2
      *value = *stack;
      return;
d1247 5
a1251 2
    for (i = 0; i < S390_NUM_SPILL_SLOTS; i++)
      pv_set_to_unknown (&data->spill[i]);
d1253 1
a1253 1
    pv_set_to_unknown (&data->back_chain);
d1267 1
a1267 1
      /* The values of SP, FP, and back chain before this instruction,
d1269 3
a1271 1
      struct prologue_value pre_insn_sp, pre_insn_fp, pre_insn_back_chain;
d1284 1
a1284 1
      pre_insn_back_chain = data->back_chain;
d1606 1
a1606 1
            || ! pv_is_identical (&pre_insn_back_chain, &data->back_chain))
d1693 1
d1698 2
a1699 2
  int slot_num;
  CORE_ADDR slot_addr;
d1802 1
d1804 8
a1811 3
  /* Scan the spill array; if a spill slot says it holds the
     original value of some register, then record that slot's
     address as the place that register was saved.  */
d1813 1
a1813 4
  /* Slots for %r2 .. %r15.  */
  for (slot_num = 0, slot_addr = prev_sp + 2 * data.gpr_size;
       slot_num < 14;
       slot_num++, slot_addr += data.gpr_size)
d1815 6
a1820 1
      struct prologue_value *slot = &data.spill[slot_num];
d1822 5
a1826 15
      if (slot->kind == pv_register
          && slot->k == 0)
        info->saved_regs[slot->reg].addr = slot_addr;
    }

  /* Slots for %f0 .. %f6.  */
  for (slot_num = 14, slot_addr = prev_sp + 16 * data.gpr_size;
       slot_num < S390_NUM_SPILL_SLOTS;
       slot_num++, slot_addr += data.fpr_size)
    {
      struct prologue_value *slot = &data.spill[slot_num];

      if (slot->kind == pv_register
          && slot->k == 0)
        info->saved_regs[slot->reg].addr = slot_addr;
a2638 5
  /* Write the back chain pointer into the first word of the stack
     frame.  This is needed to unwind across a dummy frame.  */
  regcache_cooked_read_unsigned (regcache, S390_SP_REGNUM, &orig_sp);
  write_memory_unsigned_integer (sp, word_size, orig_sp);

d2646 2
a2647 3
     which is actually the top of the register save area
     allocated on the original stack.  */
  return orig_sp + 16*word_size + 32;
d2658 1
a2658 2
  CORE_ADDR this_sp = s390_unwind_sp (gdbarch, next_frame);
  CORE_ADDR prev_sp = read_memory_unsigned_integer (this_sp, word_size);
d2660 1
a2660 1
  return frame_id_build (prev_sp + 16*word_size + 32,
@


1.135.2.1
log
@	* s390-tdep.c (enum pv_boolean): Remove.
	(pv_is_array_ref): Remove.
	(s390_on_stack): Remove.
	(S390_NUM_SPILL_SLOTS): Remove.
	(struct s390_prologue_data): Remove members 'spill' and 'back_chain',
	add members 'gpr_slot', 'fpr_slot', and 'back_chain_saved_p'.
	(s390_store): Track all stores of orginal incoming registers to the
	stack constant offsets relative to the CFA, instead of only tracking
	stores into specific spill slots.
	(s390_load): Likewise.
	(s390_analyze_prologue): Adapt to struct s390_prologue_data changes.
	(s390_prologue_frame_unwind_cache): Likewise.  Only track registers
	defined as call-saved by the ABI.
	(s390_push_dummy_call): Use bottom of dummy call argument save area
	as return value, not the top.  Do not store to the called function's
	register save area.
	(s390_unwind_dummy_id): Adapt accordingly.
@
text
@d804 60
d1119 4
d1138 10
a1147 10
  /* The offset relative to the CFA where the incoming GPR N was saved
     by the function prologue.  0 if not saved or unknown.  */
  int gpr_slot[S390_NUM_GPRS];

  /* Likewise for FPRs.  */
  int fpr_slot[S390_NUM_FPRS];

  /* Nonzero if the backchain was saved.  This is assumed to be the
     case when the incoming SP is saved at the current SP location.  */
  int back_chain_saved_p;
d1150 66
d1223 1
a1223 2
  struct prologue_value cfa, offset;
  int i;
d1225 5
a1229 43
  /* Check whether we are storing the backchain.  */
  pv_subtract (&offset, &data->gpr[S390_SP_REGNUM - S390_R0_REGNUM], addr);

  if (offset.kind == pv_constant && offset.k == 0)
    if (size == data->gpr_size
	&& pv_is_register (value, S390_SP_REGNUM, 0))
      {
	data->back_chain_saved_p = 1;
	return;
      }


  /* Check whether we are storing a register into the stack.  */
  pv_set_to_register (&cfa, S390_SP_REGNUM, 16 * data->gpr_size + 32);
  pv_subtract (&offset, &cfa, addr);

  if (offset.kind == pv_constant
      && offset.k < INT_MAX && offset.k > 0
      && offset.k % data->gpr_size == 0)
    {
      /* If we are storing the original value of a register, we want to
	 record the CFA offset.  If the same register is stored multiple
	 times, the stack slot with the highest address counts.  */
      
      for (i = 0; i < S390_NUM_GPRS; i++)
	if (size == data->gpr_size
	    && pv_is_register (value, S390_R0_REGNUM + i, 0))
	  if (data->gpr_slot[i] == 0
	      || data->gpr_slot[i] > offset.k)
	    {
	      data->gpr_slot[i] = offset.k;
	      return;
	    }

      for (i = 0; i < S390_NUM_FPRS; i++)
	if (size == data->fpr_size
	    && pv_is_register (value, S390_F0_REGNUM + i, 0))
	  if (data->fpr_slot[i] == 0
	      || data->fpr_slot[i] > offset.k)
	    {
	      data->fpr_slot[i] = offset.k;
	      return;
	    }
d1232 2
d1235 4
a1238 6
  /* Note: If this is some store we cannot identify, you might think we
     should forget our cached values, as any of those might have been hit.

     However, we make the assumption that the register save areas are only
     ever stored to once in any given function, and we do recognize these
     stores.  Thus every store we cannot recognize does not hit our data.  */
d1248 1
a1248 2
  struct prologue_value cfa, offset;
  int i;
d1268 3
a1270 6
  /* Check whether we are accessing one of our save slots.  */
  pv_set_to_register (&cfa, S390_SP_REGNUM, 16 * data->gpr_size + 32);
  pv_subtract (&offset, &cfa, addr);

  if (offset.kind == pv_constant
      && offset.k < INT_MAX && offset.k > 0)
d1272 2
a1273 13
      for (i = 0; i < S390_NUM_GPRS; i++)
	if (offset.k == data->gpr_slot[i])
	  {
	    pv_set_to_register (value, S390_R0_REGNUM + i, 0);
	    return;
	  }

      for (i = 0; i < S390_NUM_FPRS; i++)
	if (offset.k == data->fpr_slot[i])
	  {
	    pv_set_to_register (value, S390_F0_REGNUM + i, 0);
	    return;
	  }
d1323 2
a1324 5
    for (i = 0; i < S390_NUM_GPRS; i++)
      data->gpr_slot[i]  = 0;

    for (i = 0; i < S390_NUM_FPRS; i++)
      data->fpr_slot[i]  = 0;
d1326 1
a1326 1
    data->back_chain_saved_p = 0;
d1340 1
a1340 1
      /* The values of SP and FP before this instruction,
d1342 1
a1342 3
      struct prologue_value pre_insn_sp, pre_insn_fp;
      /* Likewise for the flag whether the back chain was saved.  */
      int pre_insn_back_chain_saved_p;
d1355 1
a1355 1
      pre_insn_back_chain_saved_p = data->back_chain_saved_p;
d1677 1
a1677 1
            || pre_insn_back_chain_saved_p != data->back_chain_saved_p)
a1763 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d1768 2
a1769 2
  int i;
  CORE_ADDR cfa;
a1871 1
  cfa = prev_sp + 16*word_size + 32;
d1873 15
a1887 8
  /* Record the addresses of all register spill slots the prologue parser
     has recognized.  Consider only registers defined as call-saved by the
     ABI; for call-clobbered registers the parser may have recognized
     spurious stores.  */

  for (i = 6; i <= 15; i++)
    if (data.gpr_slot[i] != 0)
      info->saved_regs[S390_R0_REGNUM + i].addr = cfa - data.gpr_slot[i];
d1889 4
a1892 1
  switch (tdep->abi)
d1894 1
a1894 6
    case ABI_LINUX_S390:
      if (data.fpr_slot[4] != 0)
        info->saved_regs[S390_F4_REGNUM].addr = cfa - data.fpr_slot[4];
      if (data.fpr_slot[6] != 0)
        info->saved_regs[S390_F6_REGNUM].addr = cfa - data.fpr_slot[6];
      break;
d1896 3
a1898 5
    case ABI_LINUX_ZSERIES:
      for (i = 8; i <= 15; i++)
	if (data.fpr_slot[i] != 0)
	  info->saved_regs[S390_F0_REGNUM + i].addr = cfa - data.fpr_slot[i];
      break;
d2711 5
d2723 3
a2725 2
     which is actually the top of the register save area.  */
  return sp + 16*word_size + 32;
d2736 2
a2737 1
  CORE_ADDR sp = s390_unwind_sp (gdbarch, next_frame);
d2739 1
a2739 1
  return frame_id_build (sp + 16*word_size + 32,
@


1.134
log
@2004-07-20  Andrew Cagney  <cagney@@gnu.org>

	* breakpoint.c (deprecated_read_memory_nobpt): Rename
	read_memory_nobpt.
	* sparc-linux-tdep.c (sparc_linux_sigtramp_start): Update.
	* s390-tdep.c (s390_readinstruction, s390_in_function_epilogue_p)
	(s390_sigtramp_frame_sniffer): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue): Update.
	* mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset): Update.
	* mips-tdep.c (mips_fetch_instruction, mips16_fetch_instruction)
	(mips32_fetch_instruction): Update.
	* mcore-tdep.c (get_insn): Update.
	* m68klinux-tdep.c (m68k_linux_pc_in_sigtramp): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_offset): Update.
	* i386ly-tdep.c (i386lynx_saved_pc_after_call): Update.
	* i386-linux-tdep.c (i386_linux_sigtramp_start)
	(i386_linux_rt_sigtramp_start): Update.
	* i386-linux-nat.c (child_resume): Update.
	* hppa-tdep.c (skip_prologue_hard_way, hppa_frame_cache): Update.
	* hppa-linux-tdep.c (insns_match_pattern): Update.
	* gdbcore.h: Update.
	* frv-tdep.c (frv_gdbarch_adjust_breakpoint_address): Update.
	* frame.c (safe_frame_unwind_memory): Update.
	* amd64-linux-tdep.c (amd64_linux_sigtramp_start): Update.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Update.
	* alpha-tdep.c (alpha_read_insn): Update.
@
text
@d2023 2
a2024 2
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
                            optimizedp, lvalp, addrp, realnump, bufferp);
d2095 2
a2096 2
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
                            optimizedp, lvalp, addrp, realnump, bufferp);
d2238 2
a2239 2
  trad_frame_prev_register (next_frame, info->saved_regs, regnum,
                            optimizedp, lvalp, addrp, realnump, bufferp);
@


1.133
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (PUSH_DUMMY_CALL): Change CORE_ADDR func_addr argument
	to struct value *function.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.
	* infcall.c (call_function_by_hand): Pass entire function value
	to push_dummy_call.

	* Makefile.in (alpha-tdep.o, frv-tdep.o, ia64-tdep.o, mips-tdep.o)
	(ppc-sysv-tdep.o, rs6000-tdep.o): Update dependencies.
	* alpha-tdep.c (alpha_push_dummy_call): Update call signature.
	* amd64-tdep.c (amd64_push_dummy_call): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* avr-tdep.c (avr_push_dummy_call): Likewise.
	* cris-tdep.c (cris_push_dummy_call): Likewise.
	* d10v-tdep.c (d10v_push_dummy_call): Likewise.
	* frv-tdep.c (frv_push_dummy_call): Likewise.
	* h8300-tdep.c (h8300_push_dummy_call): Likewise.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_push_dummy_call): Likewise.
	* i386-tdep.c (i386_push_dummy_call): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	* m68k-tdep.c (m68k_push_dummy_call): Likewise.
	* m88k-tdep.c (m88k_push_dummy_call): Likewise.
	* mips-tdep.c (mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
	* s390-tdep.c (s390_push_dummy_call): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu)
	(sh_push_dummy_call_nofpu): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_call): Likewise.
	* sparc64-tdep.c (sparc64_push_dummy_call): Likewise.
	* vax-tdep.c (vax_push_dummy_call): Likewise.
@
text
@d925 1
a925 1
  if (read_memory_nobpt (at, &instr[0], 2))
d930 1
a930 1
      if (read_memory_nobpt (at + 2, &instr[2], instrlen - 2))
d1727 1
a1727 1
      && !read_memory_nobpt (pc - 4, insn, 4)
d1733 1
a1733 1
      && !read_memory_nobpt (pc - 6, insn, 6)
d1739 1
a1739 1
      && !read_memory_nobpt (pc - 6, insn, 6)
d2254 1
a2254 1
  if (read_memory_nobpt (pc, sigreturn, 2))
@


1.132
log
@2004-05-04  Ulrich Weigand <Ulrich.Weigand@@de.ibm.com>

	Committed by Andrew Cagney.
	* s390-tdep.c (s390_sigtramp_frame_unwind_cache): Account for
	alignment padding when accessing ucontext struct members.
@
text
@d2568 1
a2568 1
s390_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
@


1.131
log
@2004-05-01  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (create_sentinel_frame): Set type to SENTINEL_FRAME.
	* dummy-frame.c (dummy_frame_this_id): Use get_frame_type, instead
	of frame_relative_level.
	* sentinel-frame.c (sentinel_frame_unwinder): Set unwinder's type
	to SENTINEL_FRAME.
	* frame.h (enum frame_type): Add SENTINEL_FRAME.
	* s390-tdep.c (s390_prologue_frame_unwind_cache): Delete calls to
	frame_relative_level.
@
text
@d2156 1
a2156 1
      sigreg_ptr = next_cfa + 8 + 128 + 5*word_size;
@


1.130
log
@2004-03-22  Andrew Cagney  <cagney@@redhat.com>

	* s390-tdep.c (struct s390_stub_unwind_cache): Rename
	s390_pltstub_unwind_cache.
	(s390_stub_frame_unwind_cache): Rename
	s390_pltstub_frame_unwind_cache.
	(s390_stub_frame_this_id): Rename s390_pltstub_frame_this_id.
	(s390_stub_frame_prev_register): Rename
	s390_pltstub_frame_prev_register.
	(s390_stub_frame_unwind): Rename s390_pltstub_frame_unwind.
	(s390_stub_frame_sniffer): Rename s390_stub_frame_sniffer.

	From Ulrich Weigand:
	* s390-tdep.c (s390_pltstub_frame_sniffer): Handle invalid function
	pointer calls like PLT calls.
@
text
@d1806 4
a1809 4
      if (get_frame_type (next_frame) == NORMAL_FRAME
	  /* For some reason, sentinel frames are NORMAL_FRAMEs
	     -- but they have negative frame level.  */
	  && frame_relative_level (next_frame) >= 0)
d1853 3
a1855 3
  if (size > 0
      && (get_frame_type (next_frame) != NORMAL_FRAME
	  || frame_relative_level (next_frame) < 0))
@


1.129
log
@Index: ChangeLog
2004-02-26  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in: Update dependencies.
	Changes from Ulrich Weigand,
	* s390-tdep.c: Include "dwarf2-frame.h".
	(s390_dwarf2_frame_init_reg): New function.
	(s390_gdbarch_init): Install dwarf2_frame_sniffer and
	dwarf2_frame_base_sniffer.  Call dwarf2_frame_set_init_reg.
@
text
@d2040 3
a2042 3
/* PLT stub stack frames.  */

struct s390_pltstub_unwind_cache {
d2044 2
d2050 3
a2052 3
static struct s390_pltstub_unwind_cache *
s390_pltstub_frame_unwind_cache (struct frame_info *next_frame,
				 void **this_prologue_cache)
d2056 1
a2056 1
  struct s390_pltstub_unwind_cache *info;
d2062 1
a2062 1
  info = FRAME_OBSTACK_ZALLOC (struct s390_pltstub_unwind_cache);
d2077 3
a2079 3
s390_pltstub_frame_this_id (struct frame_info *next_frame,
			    void **this_prologue_cache,
			    struct frame_id *this_id)
d2081 2
a2082 2
  struct s390_pltstub_unwind_cache *info
    = s390_pltstub_frame_unwind_cache (next_frame, this_prologue_cache);
d2087 5
a2091 5
s390_pltstub_frame_prev_register (struct frame_info *next_frame,
				  void **this_prologue_cache,
				  int regnum, int *optimizedp,
				  enum lval_type *lvalp, CORE_ADDR *addrp,
				  int *realnump, void *bufferp)
d2093 2
a2094 2
  struct s390_pltstub_unwind_cache *info
    = s390_pltstub_frame_unwind_cache (next_frame, this_prologue_cache);
d2099 1
a2099 1
static const struct frame_unwind s390_pltstub_frame_unwind = {
d2101 2
a2102 2
  s390_pltstub_frame_this_id,
  s390_pltstub_frame_prev_register
d2106 1
a2106 1
s390_pltstub_frame_sniffer (struct frame_info *next_frame)
d2108 2
a2109 2
  if (!in_plt_section (frame_pc_unwind (next_frame), NULL))
    return NULL;
d2111 7
a2117 1
  return &s390_pltstub_frame_unwind;
d3039 1
a3039 1
  frame_unwind_append_sniffer (gdbarch, s390_pltstub_frame_sniffer);
@


1.129.2.1
log
@2004-03-22  Andrew Cagney  <cagney@@redhat.com>

	* s390-tdep.c (struct s390_stub_unwind_cache): Rename
	s390_pltstub_unwind_cache.
	(s390_stub_frame_unwind_cache): Rename
	s390_pltstub_frame_unwind_cache.
	(s390_stub_frame_this_id): Rename s390_pltstub_frame_this_id.
	(s390_stub_frame_prev_register): Rename
	s390_pltstub_frame_prev_register.
	(s390_stub_frame_unwind): Rename s390_pltstub_frame_unwind.
	(s390_stub_frame_sniffer): Rename s390_stub_frame_sniffer.

	From Ulrich Weigand:
	* s390-tdep.c (s390_pltstub_frame_sniffer): Handle invalid function
	pointer calls like PLT calls.
@
text
@d2040 3
a2042 3
/* Code stubs and their stack frames.  For things like PLTs and NULL
   function calls (where there is no true frame and the return address
   is in the RETADDR register).  */
a2043 2
struct s390_stub_unwind_cache
{
d2048 3
a2050 3
static struct s390_stub_unwind_cache *
s390_stub_frame_unwind_cache (struct frame_info *next_frame,
			      void **this_prologue_cache)
d2054 1
a2054 1
  struct s390_stub_unwind_cache *info;
d2060 1
a2060 1
  info = FRAME_OBSTACK_ZALLOC (struct s390_stub_unwind_cache);
d2075 3
a2077 3
s390_stub_frame_this_id (struct frame_info *next_frame,
			 void **this_prologue_cache,
			 struct frame_id *this_id)
d2079 2
a2080 2
  struct s390_stub_unwind_cache *info
    = s390_stub_frame_unwind_cache (next_frame, this_prologue_cache);
d2085 5
a2089 5
s390_stub_frame_prev_register (struct frame_info *next_frame,
			       void **this_prologue_cache,
			       int regnum, int *optimizedp,
			       enum lval_type *lvalp, CORE_ADDR *addrp,
			       int *realnump, void *bufferp)
d2091 2
a2092 2
  struct s390_stub_unwind_cache *info
    = s390_stub_frame_unwind_cache (next_frame, this_prologue_cache);
d2097 1
a2097 1
static const struct frame_unwind s390_stub_frame_unwind = {
d2099 2
a2100 2
  s390_stub_frame_this_id,
  s390_stub_frame_prev_register
d2104 1
a2104 1
s390_stub_frame_sniffer (struct frame_info *next_frame)
d2106 2
a2107 2
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  bfd_byte insn[S390_MAX_INSTR_SIZE];
d2109 1
a2109 7
  /* If the current PC points to non-readable memory, we assume we
     have trapped due to an invalid function pointer call.  We handle
     the non-existing current function like a PLT stub.  */
  if (in_plt_section (pc, NULL)
      || s390_readinstruction (insn, pc) < 0)
    return &s390_stub_frame_unwind;
  return NULL;
d3031 1
a3031 1
  frame_unwind_append_sniffer (gdbarch, s390_stub_frame_sniffer);
@


1.128
log
@2004-02-17  Ulrich Weigand <Ulrich.Weigand@@de.ibm.com>

	Committed by Jim Blandy  <jimb@@redhat.com>.

	* s390-nat.c (SUBOFF): New macro.
	(supply_gregset, fill_gregset): Use it to handle debugging
	of 32-bit exectuables running under a 64-bit kernel.
	* s390-tdep.c: Include "solib-svr4.h".
	(s390_svr4_fetch_link_map_offset): New function.
	(s390x_svr_fetch_link_map_offset): Likewise.
	(s390_gdbarch_init): Call set_solib_svr4_fetch_link_map_offsets.
	* Makefile.in (s390-tdep.o): Update dependencies.
@
text
@d41 1
d2302 47
d3028 3
@


1.128.2.1
log
@Merge mainline to intercu branch.
@
text
@a40 1
#include "dwarf2-frame.h"
d2039 3
a2041 3
/* Code stubs and their stack frames.  For things like PLTs and NULL
   function calls (where there is no true frame and the return address
   is in the RETADDR register).  */
a2042 2
struct s390_stub_unwind_cache
{
d2047 3
a2049 3
static struct s390_stub_unwind_cache *
s390_stub_frame_unwind_cache (struct frame_info *next_frame,
			      void **this_prologue_cache)
d2053 1
a2053 1
  struct s390_stub_unwind_cache *info;
d2059 1
a2059 1
  info = FRAME_OBSTACK_ZALLOC (struct s390_stub_unwind_cache);
d2074 3
a2076 3
s390_stub_frame_this_id (struct frame_info *next_frame,
			 void **this_prologue_cache,
			 struct frame_id *this_id)
d2078 2
a2079 2
  struct s390_stub_unwind_cache *info
    = s390_stub_frame_unwind_cache (next_frame, this_prologue_cache);
d2084 5
a2088 5
s390_stub_frame_prev_register (struct frame_info *next_frame,
			       void **this_prologue_cache,
			       int regnum, int *optimizedp,
			       enum lval_type *lvalp, CORE_ADDR *addrp,
			       int *realnump, void *bufferp)
d2090 2
a2091 2
  struct s390_stub_unwind_cache *info
    = s390_stub_frame_unwind_cache (next_frame, this_prologue_cache);
d2096 1
a2096 1
static const struct frame_unwind s390_stub_frame_unwind = {
d2098 2
a2099 2
  s390_stub_frame_this_id,
  s390_stub_frame_prev_register
d2103 1
a2103 1
s390_stub_frame_sniffer (struct frame_info *next_frame)
d2105 2
a2106 2
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  bfd_byte insn[S390_MAX_INSTR_SIZE];
d2108 1
a2108 7
  /* If the current PC points to non-readable memory, we assume we
     have trapped due to an invalid function pointer call.  We handle
     the non-existing current function like a PLT stub.  */
  if (in_plt_section (pc, NULL)
      || s390_readinstruction (insn, pc) < 0)
    return &s390_stub_frame_unwind;
  return NULL;
a2300 47
/* DWARF-2 frame support.  */

static void
s390_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,
                            struct dwarf2_frame_state_reg *reg)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  switch (tdep->abi)
    {
    case ABI_LINUX_S390:
      /* Call-saved registers.  */
      if ((regnum >= S390_R6_REGNUM && regnum <= S390_R15_REGNUM)
	  || regnum == S390_F4_REGNUM
	  || regnum == S390_F6_REGNUM)
	reg->how = DWARF2_FRAME_REG_SAME_VALUE;

      /* Call-clobbered registers.  */
      else if ((regnum >= S390_R0_REGNUM && regnum <= S390_R5_REGNUM)
	       || (regnum >= S390_F0_REGNUM && regnum <= S390_F15_REGNUM
		   && regnum != S390_F4_REGNUM && regnum != S390_F6_REGNUM))
	reg->how = DWARF2_FRAME_REG_UNDEFINED;

      /* The return address column.  */
      else if (regnum == S390_PC_REGNUM)
	reg->how = DWARF2_FRAME_REG_RA;
      break;

    case ABI_LINUX_ZSERIES:
      /* Call-saved registers.  */
      if ((regnum >= S390_R6_REGNUM && regnum <= S390_R15_REGNUM)
	  || (regnum >= S390_F8_REGNUM && regnum <= S390_F15_REGNUM))
	reg->how = DWARF2_FRAME_REG_SAME_VALUE;

      /* Call-clobbered registers.  */
      else if ((regnum >= S390_R0_REGNUM && regnum <= S390_R5_REGNUM)
	       || (regnum >= S390_F0_REGNUM && regnum <= S390_F7_REGNUM))
	reg->how = DWARF2_FRAME_REG_UNDEFINED;

      /* The return address column.  */
      else if (regnum == S390_PC_REGNUM)
	reg->how = DWARF2_FRAME_REG_RA;
      break;
    }
}


d2980 1
a2980 4
  dwarf2_frame_set_init_reg (gdbarch, s390_dwarf2_frame_init_reg);
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
  frame_base_append_sniffer (gdbarch, dwarf2_frame_base_sniffer);
  frame_unwind_append_sniffer (gdbarch, s390_stub_frame_sniffer);
@


1.128.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d925 1
a925 1
  if (deprecated_read_memory_nobpt (at, &instr[0], 2))
d930 1
a930 1
      if (deprecated_read_memory_nobpt (at + 2, &instr[2], instrlen - 2))
d1727 1
a1727 1
      && !deprecated_read_memory_nobpt (pc - 4, insn, 4)
d1733 1
a1733 1
      && !deprecated_read_memory_nobpt (pc - 6, insn, 6)
d1739 1
a1739 1
      && !deprecated_read_memory_nobpt (pc - 6, insn, 6)
d1806 4
a1809 4
      /* FIXME: cagney/2004-05-01: This sanity check shouldn't be
	 needed, instead the code should simpliy rely on its
	 analysis.  */
      if (get_frame_type (next_frame) == NORMAL_FRAME)
d1853 3
a1855 3
  /* FIXME: cagney/2004-05-01: This sanity check shouldn't be needed,
     instead the code should simpliy rely on its analysis.  */
  if (size > 0 && get_frame_type (next_frame) != NORMAL_FRAME)
d2023 2
a2024 2
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, bufferp);
d2095 2
a2096 2
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, bufferp);
d2156 1
a2156 1
      sigreg_ptr = next_cfa + 8 + 128 + align_up (5*word_size, 8);
d2238 2
a2239 2
  trad_frame_get_prev_register (next_frame, info->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, bufferp);
d2254 1
a2254 1
  if (deprecated_read_memory_nobpt (pc, sigreturn, 2))
d2568 1
a2568 1
s390_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
@


1.127
log
@2004-02-17  Ulrich Weigand <Ulrich.Weigand@@de.ibm.com>

	Committed by Jim Blandy  <jimb@@redhat.com>.

	* s390-tdep.c: Include "trad-frame.h", "frame-base.h", and
	"frame-unwind.h".
	(s390_readinstruction): Reformat.  Use read_memory_nobpt.
	(GDB_TARGET_IS_ESAME, S390_GPR_SIZE, S390_FPR_SIZE): Remove.
	(S390_SYSCALL_OPCODE, S390_SYSCALL_SIZE): Remove.
	(S390_SIGCONTEXT_SREGS_OFFSET, S390X_SIGCONTEXT_SREGS_OFFSET,
	S390_SIGREGS_FP0_OFFSET, S390X_SIGREGS_FP0_OFFSET,
	S390_UC_MCONTEXT_OFFSET, S390X_UC_MCONTEXT_OFFSET,
	S390_SIGNAL_FRAMESIZE,
	s390_NR_sigreturn, s390_NR_rt_sigreturn): Remove.
	(struct frame_extra_info): Remove.
	(s390_memset_extra_info): Remove.
	(op_*, op1_*, op2_* enums): Add several new opcodes.
	(is_rse): Renamed to ...
	(is_rsy): ... this.  Support long displacements.
	(is_rxe): Renamed to ...
	(is_rxy): ... this.  Support long displacements.
	(compute_x_addr): Support long displacements.
	(struct s390_prologue_data): New data type.
	(s390_on_stack): Change API to use struct s390_prologue_data.
	(s390_store): Reimplement.
	(s390_load): New function.
	(s390_get_signal_frame_info): Remove.
	(s390_get_frame_info): Remove, replace by ...
	(s390_analyze_prolog): ... this new function.
	(s390_check_function_end): Remove.
	(s390_function_start): Remove.
	(s390_frameless_function_invokation): Remove.
	(s390_is_sigreturn): Remove.
	(s390_init_frame_pc_first): Remove.
	(s390_init_frame_extra_info): Remove.
	(s390_frame_init_saved_regs): Remove.
	(s390_frame_saved_pc_nofix): Remove.
	(s390_frame_saved_pc): Remove.
	(s390_frame_chain): Remove.
	(s390_fp_regnum, s390_read_fp): Remove.
	(s390_pop_frame_regular, s390_pop_frame): Remove.
	(s390_saved_pc_after_call): Remove.
	(s390_skip_prologue): Reimplement.
	(s390_in_function_epilogue_p): Support long displacements.
	(struct s390_unwind_cache): New data structure.
	(s390_frame_unwind_cache): New function.
	(s390_prologue_frame_unwind_cache): Likewise.
	(s390_backchain_frame_unwind_cache): Likewise.
	(s390_frame_this_id, s390_frame_prev_register): Likewise.
	(s390_frame_unwind): Define.
	(s390_frame_sniffer): New function.
	(struct s390_pltstub_unwind_cache): New data structure.
	(s390_pltstub_frame_unwind_cache): New function.
	(s390_pltstub_frame_this_id): Likewise.
	(s390_pltstub_frame_prev_register): Likewise.
	(s390_pltstub_frame_unwind): Define.
	(s390_pltstub_frame_sniffer): New function.
	(struct s390_sigtramp_unwind_cache): New data structure.
	(s390_sigtramp_frame_unwind_cache): New function.
	(s390_sigtramp_frame_this_id): Likewise.
	(s390_sigtramp_frame_prev_register): Likewise.
	(s390_sigtramp_frame_unwind): Define.
	(s390_sigtramp_frame_sniffer): New function.
	(s390_frame_base_address, s390_local_base_address): New functions.
	(s390_frame_base): Define.
	(s390_unwind_pc, s390_unwind_sp): New function.
	(s390_push_dummy_call): Use new frame base location.
	(s390_unwind_dummy_id): Likewise.
	(s390_gdbarch_init): Remove calls to:
	set_gdbarch_frameless_function_invocation,
	set_gdbarch_deprecated_init_frame_pc,
	set_gdbarch_deprecated_frame_chain,
	set_gdbarch_deprecated_frame_init_saved_regs,
	set_gdbarch_deprecated_pop_frame,
	set_gdbarch_deprecated_init_extra_frame_info,
	set_gdbarch_deprecated_init_frame_pc_first,
	set_gdbarch_deprecated_target_read_fp,
	set_gdbarch_deprecated_frame_saved_pc,
	set_gdbarch_deprecated_saved_pc_after_call,
	set_gdbarch_deprecated_fp_regnum.
	Add calls to:
	set_gdbarch_in_solib_call_trampoline,
	frame_unwind_append_sniffer,
	frame_base_set_default,
	set_gdbarch_unwind_pc,
	set_gdbarch_unwind_sp.
	* Makefile.in (s390-tdep.o): Update dependencies.
@
text
@d46 1
d2852 69
d3000 3
d3017 2
@


1.126
log
@2004-02-17  Ulrich Weigand <Ulrich.Weigand@@de.ibm.com>

	Committed by Jim Blandy  <jimb@@redhat.com>.

	* s390-tdep.c (struct gdbarch_tdep): Add 'abi' member.
	(S390_STACK_FRAME_OVERHEAD): Remove.
	(S390_STACK_PARAMETER_ALIGNMENT): Remove.
	(S390_NUM_FP_PARAMETER_REGISTERS): Remove.
	(s390_promote_integer_argument): Remove.
	(s390_cannot_extract_struct_value_address): Remove.
	(s390_use_struct_convention, s390_store_struct_return): Remove.
	(s390_extract_return_value, s390_store_return_value): Remove.
	(s390_return_value_convention, s390_return_value): New functions.
	(is_float_singleton): Handle typedefs.
	(is_double_or_float, is_double_arg, is_simple_arg, pass_by_copy_ref):
	Remove, replace by ...
	(s390_function_arg_pass_by_reference, s390_function_arg_float,
	s390_function_arg_integer): ... these new functions.
	(s390_push_arguments, s390_push_return_address): Remove, replace by ...
	(s390_push_dummy_call, s390_unwind_dummy_id): ... these new functions.
	(s390_gdbarch_init): Remove s390_call_dummy_words and elf_flags.
	Fill in tdep->abi.
	Remove calls to:
	set_gdbarch_deprecated_store_struct_return,
	set_gdbarch_deprecated_extract_return_value,
	set_gdbarch_deprecated_store_return_value,
	set_gdbarch_use_struct_convention,
	set_gdbarch_extract_struct_value_address,
	set_gdbarch_deprecated_pc_in_call_dummy,
	set_gdbarch_deprecated_push_arguments,
	set_gdbarch_deprecated_save_dummy_frame_tos,
	set_gdbarch_deprecated_push_return_address,
	set_gdbarch_deprecated_sizeof_call_dummy_words,
	set_gdbarch_deprecated_call_dummy_words,
	set_gdbarch_deprecated_dummy_write_sp.
	Add calls to:
	set_gdbarch_push_dummy_call,
	set_gdbarch_unwind_dummy_id,
	set_gdbarch_return_value.
@
text
@d38 3
a477 66
#define GDB_TARGET_IS_ESAME (TARGET_ARCHITECTURE->mach == bfd_mach_s390_64)
#define S390_GPR_SIZE      (GDB_TARGET_IS_ESAME ? 8 : 4)
#define S390_FPR_SIZE      (8)
#define S390_MAX_INSTR_SIZE (6)
#define S390_SYSCALL_OPCODE (0x0a)
#define S390_SYSCALL_SIZE   (2)
#define S390_SIGCONTEXT_SREGS_OFFSET (8)
#define S390X_SIGCONTEXT_SREGS_OFFSET (8)
#define S390_SIGREGS_FP0_OFFSET       (144)
#define S390X_SIGREGS_FP0_OFFSET      (216)
#define S390_UC_MCONTEXT_OFFSET    (256)
#define S390X_UC_MCONTEXT_OFFSET   (344)
#define S390_SIGNAL_FRAMESIZE  (GDB_TARGET_IS_ESAME ? 160:96)
#define s390_NR_sigreturn          119
#define s390_NR_rt_sigreturn       173



struct frame_extra_info
{
  int initialised;
  int good_prologue;
  CORE_ADDR function_start;
  CORE_ADDR skip_prologue_function_start;
  CORE_ADDR saved_pc_valid;
  CORE_ADDR saved_pc;
  CORE_ADDR sig_fixed_saved_pc_valid;
  CORE_ADDR sig_fixed_saved_pc;
  CORE_ADDR frame_pointer_saved_pc;	/* frame pointer needed for alloca */
  CORE_ADDR stack_bought_valid;
  CORE_ADDR stack_bought;	/* amount we decrement the stack pointer by */
  CORE_ADDR sigcontext;
};


static CORE_ADDR s390_frame_saved_pc_nofix (struct frame_info *fi);

static int
s390_readinstruction (bfd_byte instr[], CORE_ADDR at)
{
  int instrlen;

  static int s390_instrlen[] = {
    2,
    4,
    4,
    6
  };
  if (target_read_memory (at, &instr[0], 2))
    return -1;
  instrlen = s390_instrlen[instr[0] >> 6];
  if (instrlen > 2)
    {
      if (target_read_memory (at + 2, &instr[2], instrlen - 2))
        return -1;
    }
  return instrlen;
}

static void
s390_memset_extra_info (struct frame_extra_info *fextra_info)
{
  memset (fextra_info, 0, sizeof (struct frame_extra_info));
}


d869 4
a872 5
    op1_aghi = 0xa7,   op2_aghi = 0xb,
    op1_ahi  = 0xa7,   op2_ahi  = 0xa,
    op_ar    = 0x1a,
    op_basr  = 0x0d,
    op1_bras = 0xa7,   op2_bras = 0x5,
d874 5
a878 9
    op_la    = 0x41,
    op1_larl = 0xc0,   op2_larl = 0x0,
    op_lgr   = 0xb904,
    op1_lghi = 0xa7,   op2_lghi = 0x9,
    op1_lhi  = 0xa7,   op2_lhi  = 0x8,
    op_lr    = 0x18,
    op_nr    = 0x14,
    op_ngr   = 0xb980,
    op_s     = 0x5b,
d880 2
a882 1
    op1_stg  = 0xe3,   op2_stg  = 0x24,
d884 1
d886 25
a910 3
    op_lm    = 0x98,
    op1_lmg  = 0xeb,   op2_lmg  = 0x04,
    op_svc   = 0x0a,
d914 21
d1031 1
a1031 1
is_rse (bfd_byte *insn, int op1, int op2,
a1034 1
      /* Yes, insn[5].  insn[4] is unused.  */
d1040 3
a1042 1
      *d2 = ((insn[2] & 0xf) << 8) | insn[3];
d1068 1
a1068 1
is_rxe (bfd_byte *insn, int op1, int op2,
a1071 1
      /* Yes, insn[5].  insn[4] is unused.  */
d1077 3
a1079 1
      *d2 = ((insn[2] & 0xf) << 8) | insn[3];
d1091 1
a1091 1
   Here, X2 and B2 are registers, and D2 is an unsigned 12-bit
d1101 1
a1101 1
                unsigned int d2, unsigned int x2, unsigned int b2)
d1124 24
d1153 2
a1154 10
   - GPR is an array indexed by GPR number giving the current values
     of the general-purpose registers.
   - SPILL is an array tracking the spill area of the caller's frame;
     SPILL[i] is the i'th spill slot.  The spill slots are designated
     for r2 -- r15, and then f0, f2, f4, and f6.
   - BACK_CHAIN is the value of the back chain slot; it's only valid
     when the current frame actually has some space for a back chain
     slot --- that is, when the current value of the stack pointer
     (according to GPR) is at least S390_STACK_FRAME_OVERHEAD bytes
     less than its original value.  */
d1158 1
a1158 3
               struct prologue_value *gpr,
               struct prologue_value *spill, 
               struct prologue_value *back_chain,
d1168 3
a1170 3
  pv_set_to_register (&gpr_spill_addr, S390_SP_REGNUM, 2 * S390_GPR_SIZE);
  pv_set_to_register (&fpr_spill_addr, S390_SP_REGNUM, 16 * S390_GPR_SIZE);
  back_chain_addr = gpr[S390_SP_REGNUM - S390_R0_REGNUM];
d1178 1
a1178 1
  b = pv_is_array_ref (addr, size, &gpr_spill_addr, 14, S390_GPR_SIZE, &i);
d1181 1
a1181 1
      *stack = &spill[i];
d1188 1
a1188 1
  b = pv_is_array_ref (addr, size, &fpr_spill_addr, 4, S390_FPR_SIZE, &i);
d1191 1
a1191 1
      *stack = &spill[14 + i];
d1200 1
a1200 1
  b = pv_is_array_ref (addr, size, &back_chain_addr, 1, S390_GPR_SIZE, &i);
d1203 1
a1203 1
      *stack = back_chain;
d1214 2
a1215 5
/* Do a SIZE-byte store of VALUE to ADDR.  GPR, SPILL, and BACK_CHAIN,
   and the return value are as described for s390_on_stack, above.
   Note that, when this returns pv_maybe, we have to assume that all
   of our memory now contains unknown values.  */
static enum pv_boolean
d1219 1
a1219 3
            struct prologue_value *gpr,
            struct prologue_value *spill, 
            struct prologue_value *back_chain)
a1221 2
  enum pv_boolean on_stack
    = s390_on_stack (addr, size, gpr, spill, back_chain, &stack);
d1223 9
a1231 2
  if (on_stack == pv_definite_yes)
    *stack = *value;
d1233 4
a1236 1
  return on_stack;
a1237 1
            
d1239 8
a1246 18
/* The current frame looks like a signal delivery frame: the first
   instruction is an 'svc' opcode.  If the next frame is a signal
   handler's frame, set FI's saved register map to point into the
   signal context structure.  */
static void
s390_get_signal_frame_info (struct frame_info *fi)
{
  struct frame_info *next_frame = get_next_frame (fi);

  if (next_frame
      && get_frame_extra_info (next_frame)
      && get_frame_extra_info (next_frame)->sigcontext)
    {
      /* We're definitely backtracing from a signal handler.  */
      CORE_ADDR *saved_regs = deprecated_get_frame_saved_regs (fi);
      CORE_ADDR save_reg_addr = (get_frame_extra_info (next_frame)->sigcontext
                                 + DEPRECATED_REGISTER_BYTE (S390_R0_REGNUM));
      int reg;
d1248 17
a1264 5
      for (reg = 0; reg < S390_NUM_GPRS; reg++)
        {
          saved_regs[S390_R0_REGNUM + reg] = save_reg_addr;
          save_reg_addr += S390_GPR_SIZE;
        }
d1266 6
a1271 8
      save_reg_addr = (get_frame_extra_info (next_frame)->sigcontext
                       + (GDB_TARGET_IS_ESAME ? S390X_SIGREGS_FP0_OFFSET :
                          S390_SIGREGS_FP0_OFFSET));
      for (reg = 0; reg < S390_NUM_FPRS; reg++)
        {
          saved_regs[S390_F0_REGNUM + reg] = save_reg_addr;
          save_reg_addr += S390_FPR_SIZE;
        }
d1273 3
d1277 1
d1279 13
a1292 6
static int
s390_get_frame_info (CORE_ADDR start_pc,
                     struct frame_extra_info *fextra_info,
                     struct frame_info *fi,
                     int init_extra_info)
{
d1294 4
a1297 3
     zero if we were able to read all the instructions we wanted, or
     -1 if we got an error trying to read memory.  */
  int result = 0;
a1304 21
  /* The general-purpose registers.  */
  struct prologue_value gpr[S390_NUM_GPRS];

  /* The floating-point registers.  */
  struct prologue_value fpr[S390_NUM_FPRS];

  /* The register spill stack slots in the caller's frame ---
     general-purpose registers r2 through r15, and floating-point
     registers.  spill[i] is where gpr i+2 gets spilled;
     spill[(14, 15, 16, 17)] is where (f0, f2, f4, f6) get spilled.  */
  struct prologue_value spill[S390_NUM_SPILL_SLOTS];

  /* The value of the back chain slot.  This is only valid if the stack
     pointer is known to be less than its original value --- that is,
     if we have indeed allocated space on the stack.  */
  struct prologue_value back_chain;

  /* The address of the instruction after the last one that changed
     the SP, FP, or back chain.  */
  CORE_ADDR after_last_frame_setup_insn = start_pc;

d1309 6
d1316 1
a1316 1
      pv_set_to_register (&gpr[i], S390_R0_REGNUM + i, 0);
d1319 1
a1319 1
      pv_set_to_register (&fpr[i], S390_F0_REGNUM + i, 0);
d1322 1
a1322 1
      pv_set_to_unknown (&spill[i]);
d1324 1
a1324 1
    pv_set_to_unknown (&back_chain);
d1327 3
a1329 5
  /* Start interpreting instructions, until we hit something we don't
     know how to interpret.  (Ideally, we should stop at the frame's
     real current PC, but at the moment, our callers don't give us
     that info.)  */
  for (pc = start_pc; ; pc = next_pc)
d1335 2
a1336 2
      unsigned int b2, r1, r2, d2, x2, r3;
      int i2;
d1345 1
a1345 1
          result = -1;
d1351 3
a1353 18
      pre_insn_sp = gpr[S390_SP_REGNUM - S390_R0_REGNUM];
      pre_insn_fp = gpr[S390_FRAME_REGNUM - S390_R0_REGNUM];
      pre_insn_back_chain = back_chain;

      /* A special case, first --- only recognized as the very first
         instruction of the function, for signal delivery frames:
         SVC i --- system call  */
      if (pc == start_pc
          && is_rr (insn, op_svc, &r1, &r2))
        {
          if (fi)
            s390_get_signal_frame_info (fi);
          break;
        }
        
      /* AHI r1, i2 --- add halfword immediate */
      else if (is_ri (insn, op1_ahi, op2_ahi, &r1, &i2))
        pv_add_constant (&gpr[r1], i2);
d1355 9
d1365 4
a1368 4
      /* AGHI r1, i2 --- add halfword immediate (64-bit version) */
      else if (GDB_TARGET_IS_ESAME
               && is_ri (insn, op1_aghi, op2_aghi, &r1, &i2))
        pv_add_constant (&gpr[r1], i2);
d1370 4
a1373 3
      /* AR r1, r2 -- add register */
      else if (is_rr (insn, op_ar, &r1, &r2))
        pv_add (&gpr[r1], &gpr[r1], &gpr[r2]);
d1375 3
a1377 8
      /* BASR r1, 0 --- branch and save
         Since r2 is zero, this saves the PC in r1, but doesn't branch.  */
      else if (is_rr (insn, op_basr, &r1, &r2)
               && r2 == 0)
        pv_set_to_constant (&gpr[r1], next_pc);

      /* BRAS r1, i2 --- branch relative and save */
      else if (is_ri (insn, op1_bras, op2_bras, &r1, &i2))
d1379 1
a1379 2
          pv_set_to_constant (&gpr[r1], next_pc);
          next_pc = pc + i2 * 2;
d1381 2
a1382 4
          /* We'd better not interpret any backward branches.  We'll
             never terminate.  */
          if (next_pc <= pc)
            break;
d1385 3
a1387 2
      /* L r1, d2(x2, b2) --- load */
      else if (is_rx (insn, op_l, &r1, &d2, &x2, &b2))
a1389 3
          struct prologue_value *stack;

          compute_x_addr (&addr, gpr, d2, x2, b2);
d1391 2
a1392 20
          /* If it's a load from an in-line constant pool, then we can
             simulate that, under the assumption that the code isn't
             going to change between the time the processor actually
             executed it creating the current frame, and the time when
             we're analyzing the code to unwind past that frame.  */
          if (addr.kind == pv_constant
              && start_pc <= addr.k 
              && addr.k < next_pc)
            pv_set_to_constant (&gpr[r1], 
                                read_memory_integer (addr.k, 4));

          /* If it's definitely a reference to something on the stack, 
             we can do that.  */
          else if (s390_on_stack (&addr, 4, gpr, spill, &back_chain, &stack)
                   == pv_definite_yes)
            gpr[r1] = *stack;

          /* Otherwise, we don't know the value.  */
          else
            pv_set_to_unknown (&gpr[r1]);
d1395 5
a1399 3
      /* LA r1, d2(x2, b2) --- load address */
      else if (is_rx (insn, op_la, &r1, &d2, &x2, &b2))
        compute_x_addr (&gpr[r1], gpr, d2, x2, b2);
d1401 3
a1403 4
      /* LARL r1, i2 --- load address relative long */
      else if (GDB_TARGET_IS_ESAME 
               && is_ril (insn, op1_larl, op2_larl, &r1, &i2))
        pv_set_to_constant (&gpr[r1], pc + i2 * 2);
d1405 5
a1409 4
      /* LGR r1, r2 --- load from register */
      else if (GDB_TARGET_IS_ESAME
               && is_rre (insn, op_lgr, &r1, &r2))
        gpr[r1] = gpr[r2];
d1411 3
a1413 16
      /* LHI r1, i2 --- load halfword immediate */
      else if (is_ri (insn, op1_lhi, op2_lhi, &r1, &i2))
        pv_set_to_constant (&gpr[r1], i2);

      /* LGHI r1, i2 --- load halfword immediate --- 64-bit version */
      else if (is_ri (insn, op1_lghi, op2_lghi, &r1, &i2))
        pv_set_to_constant (&gpr[r1], i2);

      /* LR r1, r2 --- load from register */
      else if (is_rr (insn, op_lr, &r1, &r2))
        gpr[r1] = gpr[r2];

      /* NGR r1, r2 --- logical and --- 64-bit version */
      else if (GDB_TARGET_IS_ESAME
               && is_rre (insn, op_ngr, &r1, &r2))
        pv_logical_and (&gpr[r1], &gpr[r1], &gpr[r2]);
d1415 3
a1417 15
      /* NR r1, r2 --- logical and */
      else if (is_rr (insn, op_nr, &r1, &r2))
        pv_logical_and (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* NGR r1, r2 --- logical and --- 64-bit version */
      else if (GDB_TARGET_IS_ESAME
               && is_rre (insn, op_ngr, &r1, &r2))
        pv_logical_and (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* NR r1, r2 --- logical and */
      else if (is_rr (insn, op_nr, &r1, &r2))
        pv_logical_and (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* S r1, d2(x2, b2) --- subtract from memory */
      else if (is_rx (insn, op_s, &r1, &d2, &x2, &b2))
a1419 4
          struct prologue_value value;
          struct prologue_value *stack;

          compute_x_addr (&addr, gpr, d2, x2, b2);
d1421 2
a1422 20
          /* If it's a load from an in-line constant pool, then we can
             simulate that, under the assumption that the code isn't
             going to change between the time the processor actually
             executed it and the time when we're analyzing it.  */
          if (addr.kind == pv_constant
              && start_pc <= addr.k 
              && addr.k < pc)
            pv_set_to_constant (&value, read_memory_integer (addr.k, 4));

          /* If it's definitely a reference to something on the stack,
             we could do that.  */
          else if (s390_on_stack (&addr, 4, gpr, spill, &back_chain, &stack)
                   == pv_definite_yes)
            value = *stack;

          /* Otherwise, we don't know the value.  */
          else
            pv_set_to_unknown (&value);

          pv_subtract (&gpr[r1], &gpr[r1], &value);
d1425 3
a1427 2
      /* ST r1, d2(x2, b2) --- store  */
      else if (is_rx (insn, op_st, &r1, &d2, &x2, &b2))
d1431 2
a1432 13
          compute_x_addr (&addr, gpr, d2, x2, b2);

          /* The below really should be '4', not 'S390_GPR_SIZE'; this
             instruction always stores 32 bits, regardless of the full
             size of the GPR.  */
          if (s390_store (&addr, 4, &gpr[r1], gpr, spill, &back_chain)
              == pv_maybe)
            /* If we can't be sure that it's *not* a store to
               something we're tracing, then we would have to mark all
               our memory as unknown --- after all, it *could* be a
               store to any of them --- so we might as well just stop
               interpreting.  */
            break;
d1440 2
a1441 10
          compute_x_addr (&addr, gpr, d2, x2, b2);

          if (s390_store (&addr, 8, &fpr[r1], gpr, spill, &back_chain)
              == pv_maybe)
            /* If we can't be sure that it's *not* a store to
               something we're tracing, then we would have to mark all
               our memory as unknown --- after all, it *could* be a
               store to any of them --- so we might as well just stop
               interpreting.  */
            break;
d1444 3
a1446 3
      /* STG r1, d2(x2, b2) --- 64-bit store */
      else if (GDB_TARGET_IS_ESAME
               && is_rxe (insn, op1_stg, op2_stg, &r1, &d2, &x2, &b2))
d1448 2
d1452 7
a1458 13
          compute_x_addr (&addr, gpr, d2, x2, b2);

          /* The below really should be '8', not 'S390_GPR_SIZE'; this
             instruction always stores 64 bits, regardless of the full
             size of the GPR.  */
          if (s390_store (&addr, 8, &gpr[r1], gpr, spill, &back_chain)
              == pv_maybe)
            /* If we can't be sure that it's *not* a store to
               something we're tracing, then we would have to mark all
               our memory as unknown --- after all, it *could* be a
               store to any of them --- so we might as well just stop
               interpreting.  */
            break;
d1461 3
a1463 2
      /* STM r1, r3, d2(b2) --- store multiple */
      else if (is_rs (insn, op_stm, &r1, &r3, &d2, &b2))
d1473 2
a1474 10
              compute_x_addr (&addr, gpr, d2 + offset, 0, b2);
              
              if (s390_store (&addr, 4, &gpr[regnum], gpr, spill, &back_chain)
                  == pv_maybe)
                /* If we can't be sure that it's *not* a store to
                   something we're tracing, then we would have to mark all
                   our memory as unknown --- after all, it *could* be a
                   store to any of them --- so we might as well just stop
                   interpreting.  */
                break;
a1475 5

          /* If we left the loop early, we should stop interpreting
             altogether.  */
          if (regnum <= r3)
            break;
d1478 3
a1480 3
      /* STMG r1, r3, d2(b2) --- store multiple, 64-bit */
      else if (GDB_TARGET_IS_ESAME
               && is_rse (insn, op1_stmg, op2_stmg, &r1, &r3, &d2, &b2))
d1490 2
a1491 10
              compute_x_addr (&addr, gpr, d2 + offset, 0, b2);
              
              if (s390_store (&addr, 8, &gpr[regnum], gpr, spill, &back_chain)
                  == pv_maybe)
                /* If we can't be sure that it's *not* a store to
                   something we're tracing, then we would have to mark all
                   our memory as unknown --- after all, it *could* be a
                   store to any of them --- so we might as well just stop
                   interpreting.  */
                break;
d1493 34
d1528 112
a1639 3
          /* If we left the loop early, we should stop interpreting
             altogether.  */
          if (regnum <= r3)
d1643 10
d1656 5
a1660 4
           to 'unknown'.  Instead, we'll be optimistic: we just stop
           interpreting, and assume that the machine state we've got
           now is good enough for unwinding the stack.  */
        break;
d1668 2
a1669 2
        struct prologue_value *sp = &gpr[S390_SP_REGNUM - S390_R0_REGNUM];
        struct prologue_value *fp = &gpr[S390_FRAME_REGNUM - S390_R0_REGNUM];
d1675 2
a1676 2
            || ! pv_is_identical (&pre_insn_back_chain, &back_chain))
          after_last_frame_setup_insn = next_pc;
d1680 2
a1681 7
  /* Okay, now gpr[], fpr[], spill[], and back_chain reflect the state
     of the machine as of the first instruction we couldn't interpret
     (hopefully the first non-prologue instruction).  */
  {
    /* The size of the frame, or (CORE_ADDR) -1 if we couldn't figure
       that out.  */
    CORE_ADDR frame_size = -1;
d1683 9
a1691 167
    /* The value the SP had upon entry to the function, or
       (CORE_ADDR) -1 if we can't figure that out.  */
    CORE_ADDR original_sp = -1;

    /* Are we using S390_FRAME_REGNUM as a frame pointer register?  */
    int using_frame_pointer = 0;

    /* If S390_FRAME_REGNUM is some constant offset from the SP, then
       that strongly suggests that we're going to use that as our
       frame pointer register, not the SP.  */
    {
      struct prologue_value *fp = &gpr[S390_FRAME_REGNUM - S390_R0_REGNUM];

      if (fp->kind == pv_register
          && fp->reg == S390_SP_REGNUM)
        using_frame_pointer = 1;
    }

    /* If we were given a frame_info structure, we may be able to use
       the frame's base address to figure out the actual value of the
       original SP.  */
    if (fi && get_frame_base (fi))
      {
        int frame_base_regno;
        struct prologue_value *frame_base;

        /* The meaning of the frame base depends on whether the
           function uses a frame pointer register other than the SP or
           not (see s390_read_fp):
           - If the function does use a frame pointer register other
             than the SP, then the frame base is that register's
             value.
           - If the function doesn't use a frame pointer, then the
             frame base is the SP itself.
           We're duplicating some of the logic of s390_fp_regnum here,
           but we don't want to call that, because it would just do
           exactly the same analysis we've already done above.  */
        if (using_frame_pointer)
          frame_base_regno = S390_FRAME_REGNUM;
        else
          frame_base_regno = S390_SP_REGNUM;

        frame_base = &gpr[frame_base_regno - S390_R0_REGNUM];

        /* We know the frame base address; if the value of whatever
           register it came from is a constant offset from the
           original SP, then we can reconstruct the original SP just
           by subtracting off that constant.  */
        if (frame_base->kind == pv_register
            && frame_base->reg == S390_SP_REGNUM)
          original_sp = get_frame_base (fi) - frame_base->k;
      }

    /* If the analysis said that the current SP value is the original
       value less some constant, then that constant is the frame size.  */
    {
      struct prologue_value *sp = &gpr[S390_SP_REGNUM - S390_R0_REGNUM];

      if (sp->kind == pv_register
          && sp->reg == S390_SP_REGNUM)
        frame_size = -sp->k;
    }

    /* If we knew other registers' current values, we could check if
       the analysis said any of those were related to the original SP
       value, too.  But for now, we'll just punt.  */

    /* If the caller passed in an 'extra info' structure, fill in the
       parts we can.  */
    if (fextra_info)
      {
        if (init_extra_info || ! fextra_info->initialised)
          {
            s390_memset_extra_info (fextra_info);
            fextra_info->function_start = start_pc;
            fextra_info->initialised = 1;
          }

        if (frame_size != -1)
          {
            fextra_info->stack_bought_valid = 1;
            fextra_info->stack_bought = frame_size;
          }

        /* Assume everything was okay, and indicate otherwise when we
           find something amiss.  */
        fextra_info->good_prologue = 1;

        if (using_frame_pointer)
          /* Actually, nobody cares about the exact PC, so any
             non-zero value will do here.  */
          fextra_info->frame_pointer_saved_pc = 1;

        /* If we weren't able to find the size of the frame, or find
           the original sp based on actual current register values,
           then we're not going to be able to unwind this frame.

           (If we're just doing prologue analysis to set a breakpoint,
           then frame_size might be known, but original_sp unknown; if
           we're analyzing a real frame which uses alloca, then
           original_sp might be known (from the frame pointer
           register), but the frame size might be unknown.)  */
        if (original_sp == -1 && frame_size == -1)
          fextra_info->good_prologue = 0;
        
        if (fextra_info->good_prologue)
          fextra_info->skip_prologue_function_start
            = after_last_frame_setup_insn;
        else 
          /* If the prologue was too complex for us to make sense of,
             then perhaps it's better to just not skip anything at
             all.  */
          fextra_info->skip_prologue_function_start = start_pc;
      }

    /* Indicate where registers were saved on the stack, if:
       - the caller seems to want to know,
       - the caller provided an actual SP, and
       - the analysis gave us enough information to actually figure it
         out.  */
    if (fi
        && deprecated_get_frame_saved_regs (fi)
        && original_sp != -1)
      {
        int slot_num;
        CORE_ADDR slot_addr;
        CORE_ADDR *saved_regs = deprecated_get_frame_saved_regs (fi);

        /* Scan the spill array; if a spill slot says it holds the
           original value of some register, then record that slot's
           address as the place that register was saved.

           Just for kicks, note that, even if registers aren't saved
           in their officially-sanctioned slots, this will still work
           --- we know what really got put where.  */

        /* First, the slots for r2 -- r15.  */
        for (slot_num = 0, slot_addr = original_sp + 2 * S390_GPR_SIZE;
             slot_num < 14;
             slot_num++, slot_addr += S390_GPR_SIZE)
          {
            struct prologue_value *slot = &spill[slot_num];

            if (slot->kind == pv_register
                && slot->k == 0)
              saved_regs[slot->reg] = slot_addr;
          }

        /* Then, the slots for f0, f2, f4, and f6.  They're a
           different size.  */
        for (slot_num = 14, slot_addr = original_sp + 16 * S390_GPR_SIZE;
             slot_num < S390_NUM_SPILL_SLOTS;
             slot_num++, slot_addr += S390_FPR_SIZE)
          {
            struct prologue_value *slot = &spill[slot_num];
            
            if (slot->kind == pv_register
                && slot->k == 0)
              saved_regs[slot->reg] = slot_addr;
          }

        /* The stack pointer's element of saved_regs[] is special.  */
        saved_regs[S390_SP_REGNUM] = original_sp;
      }
  }

  return result;
d1730 6
d1738 1
a1738 1
      && is_rse (insn, op1_lmg, op2_lmg, &r1, &r3, &d2, &b2)
d1745 12
d1758 2
a1759 1
s390_check_function_end (CORE_ADDR pc)
d1761 27
a1787 2
  bfd_byte instr[S390_MAX_INSTR_SIZE];
  int regidx, instrlen;
d1789 4
a1792 5
  instrlen = s390_readinstruction (instr, pc);
  if (instrlen < 0)
    return -1;
  /* check for BR */
  if (instrlen != 2 || instr[0] != 07 || (instr[1] >> 4) != 0xf)
d1794 97
a1890 7
  regidx = instr[1] & 0xf;
  /* Check for LMG or LG */
  instrlen =
    s390_readinstruction (instr, pc - (GDB_TARGET_IS_ESAME ? 6 : 4));
  if (instrlen < 0)
    return -1;
  if (GDB_TARGET_IS_ESAME)
d1892 1
d1894 3
a1896 2
      if (instrlen != 6 || instr[0] != 0xeb || instr[5] != 0x4)
	return 0;
d1898 10
a1907 1
  else if (instrlen != 4 || instr[0] != 0x98)
d1909 1
a1909 1
      return 0;
d1911 6
a1916 8
  if ((instr[2] >> 4) != 0xf)
    return 0;
  if (regidx == 14)
    return 1;
  instrlen = s390_readinstruction (instr, pc - (GDB_TARGET_IS_ESAME ? 12 : 8));
  if (instrlen < 0)
    return -1;
  if (GDB_TARGET_IS_ESAME)
d1918 3
a1920 3
      /* Check for LG */
      if (instrlen != 6 || instr[0] != 0xe3 || instr[5] != 0x4)
	return 0;
d1922 4
a1925 1
  else
d1927 2
a1928 3
      /* Check for L */
      if (instrlen != 4 || instr[0] != 0x58)
	return 0;
d1930 2
a1931 4
  if (instr[2] >> 4 != 0xf)
    return 0;
  if (instr[1] >> 4 != regidx)
    return 0;
d1935 3
a1937 2
static CORE_ADDR
s390_sniff_pc_function_start (CORE_ADDR pc, struct frame_info *fi)
d1939 26
a1964 13
  CORE_ADDR function_start, test_function_start;
  int loop_cnt, err, function_end;
  struct frame_extra_info fextra_info;
  function_start = get_pc_function_start (pc);

  if (function_start == 0)
    {
      test_function_start = pc;
      if (test_function_start & 1)
	return 0;		/* This has to be bogus */
      loop_cnt = 0;
      do
	{
d1966 4
a1969 12
	  err =
	    s390_get_frame_info (test_function_start, &fextra_info, fi, 1);
	  loop_cnt++;
	  test_function_start -= 2;
	  function_end = s390_check_function_end (test_function_start);
	}
      while (!(function_end == 1 || err || loop_cnt >= 4096 ||
	       (fextra_info.good_prologue)));
      if (fextra_info.good_prologue)
	function_start = fextra_info.function_start;
      else if (function_end == 1)
	function_start = test_function_start;
d1971 2
a1972 1
  return function_start;
d1975 7
d1983 19
a2001 2
static int
s390_frameless_function_invocation (struct frame_info *fi)
d2003 2
a2004 2
  struct frame_extra_info fextra_info, *fextra_info_ptr;
  int frameless = 0;
d2006 2
a2007 14
  if (get_next_frame (fi) == NULL)		/* no may be frameless */
    {
      if (get_frame_extra_info (fi))
	fextra_info_ptr = get_frame_extra_info (fi);
      else
	{
	  fextra_info_ptr = &fextra_info;
	  s390_get_frame_info (s390_sniff_pc_function_start (get_frame_pc (fi), fi),
			       fextra_info_ptr, fi, 1);
	}
      frameless = (fextra_info_ptr->stack_bought_valid
                   && fextra_info_ptr->stack_bought == 0);
    }
  return frameless;
d2009 1
d2012 12
d2025 8
a2032 3
static int
s390_is_sigreturn (CORE_ADDR pc, struct frame_info *sighandler_fi,
		   CORE_ADDR *sregs, CORE_ADDR *sigcaller_pc)
d2034 1
a2034 62
  bfd_byte instr[S390_MAX_INSTR_SIZE];
  int instrlen;
  CORE_ADDR scontext;
  int retval = 0;
  CORE_ADDR orig_sp;
  CORE_ADDR temp_sregs;

  scontext = temp_sregs = 0;

  instrlen = s390_readinstruction (instr, pc);
  if (sigcaller_pc)
    *sigcaller_pc = 0;
  if (((instrlen == S390_SYSCALL_SIZE) &&
       (instr[0] == S390_SYSCALL_OPCODE)) &&
      ((instr[1] == s390_NR_sigreturn) || (instr[1] == s390_NR_rt_sigreturn)))
    {
      if (sighandler_fi)
	{
	  if (s390_frameless_function_invocation (sighandler_fi))
	    orig_sp = get_frame_base (sighandler_fi);
	  else
	    orig_sp = ADDR_BITS_REMOVE ((CORE_ADDR)
					read_memory_integer (get_frame_base (sighandler_fi),
							     S390_GPR_SIZE));
	  if (orig_sp && sigcaller_pc)
	    {
	      scontext = orig_sp + S390_SIGNAL_FRAMESIZE;
	      if (pc == scontext && instr[1] == s390_NR_rt_sigreturn)
		{
		  /* We got a new style rt_signal */
		  /* get address of read ucontext->uc_mcontext */
		  temp_sregs = orig_sp + (GDB_TARGET_IS_ESAME ?
					  S390X_UC_MCONTEXT_OFFSET :
					  S390_UC_MCONTEXT_OFFSET);
		}
	      else
		{
		  /* read sigcontext->sregs */
		  temp_sregs = ADDR_BITS_REMOVE ((CORE_ADDR)
						 read_memory_integer (scontext
								      +
								      (GDB_TARGET_IS_ESAME
								       ?
								       S390X_SIGCONTEXT_SREGS_OFFSET
								       :
								       S390_SIGCONTEXT_SREGS_OFFSET),
								      S390_GPR_SIZE));

		}
	      /* read sigregs->psw.addr */
	      *sigcaller_pc =
		ADDR_BITS_REMOVE ((CORE_ADDR)
				  read_memory_integer (temp_sregs +
						       DEPRECATED_REGISTER_BYTE (S390_PSWA_REGNUM),
						       S390_GPR_SIZE));
	    }
	}
      retval = 1;
    }
  if (sregs)
    *sregs = temp_sregs;
  return retval;
d2037 12
a2048 7
/*
  We need to do something better here but this will keep us out of trouble
  for the moment.
  For some reason the blockframe.c calls us with fi->next->fromleaf
  so this seems of little use to us. */
static CORE_ADDR
s390_init_frame_pc_first (int next_fromleaf, struct frame_info *fi)
d2050 20
a2069 15
  CORE_ADDR sigcaller_pc;
  CORE_ADDR pc = 0;
  if (next_fromleaf)
    {
      pc = ADDR_BITS_REMOVE (read_register (S390_RETADDR_REGNUM));
      /* fix signal handlers */
    }
  else if (get_next_frame (fi) && get_frame_pc (get_next_frame (fi)))
    pc = s390_frame_saved_pc_nofix (get_next_frame (fi));
  if (pc && get_next_frame (fi) && get_frame_base (get_next_frame (fi))
      && s390_is_sigreturn (pc, get_next_frame (fi), NULL, &sigcaller_pc))
    {
      pc = sigcaller_pc;
    }
  return pc;
d2073 3
a2075 1
s390_init_extra_frame_info (int fromleaf, struct frame_info *fi)
d2077 3
a2079 6
  frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));
  if (get_frame_pc (fi))
    s390_get_frame_info (s390_sniff_pc_function_start (get_frame_pc (fi), fi),
			 get_frame_extra_info (fi), fi, 1);
  else
    s390_memset_extra_info (get_frame_extra_info (fi));
a2081 4
/* If saved registers of frame FI are not known yet, read and cache them.
   &FEXTRA_INFOP contains struct frame_extra_info; TDATAP can be NULL,
   in which case the framedata are read.  */

d2083 5
a2087 1
s390_frame_init_saved_regs (struct frame_info *fi)
d2089 5
d2095 5
a2099 1
  int quick;
d2101 7
a2107 15
  if (deprecated_get_frame_saved_regs (fi) == NULL)
    {
      /* zalloc memsets the saved regs */
      frame_saved_regs_zalloc (fi);
      if (get_frame_pc (fi))
	{
	  quick = (get_frame_extra_info (fi)
		   && get_frame_extra_info (fi)->initialised
		   && get_frame_extra_info (fi)->good_prologue);
	  s390_get_frame_info (quick
			       ? get_frame_extra_info (fi)->function_start
			       : s390_sniff_pc_function_start (get_frame_pc (fi), fi),
			       get_frame_extra_info (fi), fi, !quick);
	}
    }
d2111 6
d2118 3
a2120 2
static CORE_ADDR
s390_frame_saved_pc_nofix (struct frame_info *fi)
d2122 6
a2127 2
  if (get_frame_extra_info (fi) && get_frame_extra_info (fi)->saved_pc_valid)
    return get_frame_extra_info (fi)->saved_pc;
d2129 2
a2130 22
  if (deprecated_generic_find_dummy_frame (get_frame_pc (fi),
					   get_frame_base (fi)))
    return deprecated_read_register_dummy (get_frame_pc (fi),
					   get_frame_base (fi), S390_PC_REGNUM);

  s390_frame_init_saved_regs (fi);
  if (get_frame_extra_info (fi))
    {
      get_frame_extra_info (fi)->saved_pc_valid = 1;
      if (get_frame_extra_info (fi)->good_prologue
          && deprecated_get_frame_saved_regs (fi)[S390_RETADDR_REGNUM])
        get_frame_extra_info (fi)->saved_pc
          = ADDR_BITS_REMOVE (read_memory_integer
                              (deprecated_get_frame_saved_regs (fi)[S390_RETADDR_REGNUM],
                               S390_GPR_SIZE));
      else
        get_frame_extra_info (fi)->saved_pc
          = ADDR_BITS_REMOVE (read_register (S390_RETADDR_REGNUM));
      return get_frame_extra_info (fi)->saved_pc;
    }
  return 0;
}
d2132 3
a2134 4
static CORE_ADDR
s390_frame_saved_pc (struct frame_info *fi)
{
  CORE_ADDR saved_pc = 0, sig_pc;
d2136 3
a2138 4
  if (get_frame_extra_info (fi)
      && get_frame_extra_info (fi)->sig_fixed_saved_pc_valid)
    return get_frame_extra_info (fi)->sig_fixed_saved_pc;
  saved_pc = s390_frame_saved_pc_nofix (fi);
d2140 5
a2144 1
  if (get_frame_extra_info (fi))
d2146 1
a2146 7
      get_frame_extra_info (fi)->sig_fixed_saved_pc_valid = 1;
      if (saved_pc)
	{
	  if (s390_is_sigreturn (saved_pc, fi, NULL, &sig_pc))
	    saved_pc = sig_pc;
	}
      get_frame_extra_info (fi)->sig_fixed_saved_pc = saved_pc;
a2147 2
  return saved_pc;
}
d2149 7
d2157 8
d2166 2
d2169 3
a2171 2
/* We want backtraces out of signal handlers so we don't set
   (get_frame_type (thisframe) == SIGTRAMP_FRAME) to 1 */
d2173 6
a2178 4
static CORE_ADDR
s390_frame_chain (struct frame_info *thisframe)
{
  CORE_ADDR prev_fp = 0;
d2180 2
a2181 6
  if (deprecated_generic_find_dummy_frame (get_frame_pc (thisframe),
					   get_frame_base (thisframe)))
    return deprecated_read_register_dummy (get_frame_pc (thisframe),
					   get_frame_base (thisframe),
					   S390_SP_REGNUM);
  else
d2183 3
a2185 3
      int sigreturn = 0;
      CORE_ADDR sregs = 0;
      struct frame_extra_info prev_fextra_info;
d2187 3
a2189 4
      memset (&prev_fextra_info, 0, sizeof (prev_fextra_info));
      if (get_frame_pc (thisframe))
	{
	  CORE_ADDR saved_pc, sig_pc;
d2191 5
a2195 46
	  saved_pc = s390_frame_saved_pc_nofix (thisframe);
	  if (saved_pc)
	    {
	      if ((sigreturn =
		   s390_is_sigreturn (saved_pc, thisframe, &sregs, &sig_pc)))
		saved_pc = sig_pc;
	      s390_get_frame_info (s390_sniff_pc_function_start
				   (saved_pc, NULL), &prev_fextra_info, NULL,
				   1);
	    }
	}
      if (sigreturn)
	{
	  /* read sigregs,regs.gprs[11 or 15] */
	  prev_fp = read_memory_integer (sregs +
					 DEPRECATED_REGISTER_BYTE (S390_R0_REGNUM +
							(prev_fextra_info.
							 frame_pointer_saved_pc
							 ? 11 : 15)),
					 S390_GPR_SIZE);
	  get_frame_extra_info (thisframe)->sigcontext = sregs;
	}
      else
	{
	  if (deprecated_get_frame_saved_regs (thisframe))
	    {
	      int regno;

              if (prev_fextra_info.frame_pointer_saved_pc
                  && deprecated_get_frame_saved_regs (thisframe)[S390_FRAME_REGNUM])
                regno = S390_FRAME_REGNUM;
              else
                regno = S390_SP_REGNUM;

	      if (deprecated_get_frame_saved_regs (thisframe)[regno])
                {
                  /* The SP's entry of `saved_regs' is special.  */
                  if (regno == S390_SP_REGNUM)
                    prev_fp = deprecated_get_frame_saved_regs (thisframe)[regno];
                  else
                    prev_fp =
                      read_memory_integer (deprecated_get_frame_saved_regs (thisframe)[regno],
                                           S390_GPR_SIZE);
                }
	    }
	}
a2196 2
  return ADDR_BITS_REMOVE (prev_fp);
}
d2198 4
a2201 4
/*
  Whether struct frame_extra_info is actually needed I'll have to figure
  out as our frames are similar to rs6000 there is a possibility
  i386 dosen't need it. */
d2203 2
a2204 6
/* Not the most efficent code in the world */
static int
s390_fp_regnum (void)
{
  int regno = S390_SP_REGNUM;
  struct frame_extra_info fextra_info;
d2206 2
a2207 1
  CORE_ADDR pc = ADDR_BITS_REMOVE (read_register (S390_PC_REGNUM));
d2209 8
a2216 5
  s390_get_frame_info (s390_sniff_pc_function_start (pc, NULL), &fextra_info,
		       NULL, 1);
  if (fextra_info.frame_pointer_saved_pc)
    regno = S390_FRAME_REGNUM;
  return regno;
d2219 6
a2224 2
static CORE_ADDR
s390_read_fp (void)
d2226 4
a2229 1
  return read_register (s390_fp_regnum ());
d2232 5
d2238 2
a2239 2
static void
s390_pop_frame_regular (struct frame_info *frame)
d2241 5
a2245 1
  int regnum;
d2247 2
a2248 1
  write_register (S390_PC_REGNUM, DEPRECATED_FRAME_SAVED_PC (frame));
d2250 9
a2258 12
  /* Restore any saved registers.  */
  if (deprecated_get_frame_saved_regs (frame))
    {
      for (regnum = 0; regnum < NUM_REGS; regnum++)
        if (deprecated_get_frame_saved_regs (frame)[regnum] != 0)
          {
            ULONGEST value;
            
            value = read_memory_unsigned_integer (deprecated_get_frame_saved_regs (frame)[regnum],
                                                  DEPRECATED_REGISTER_RAW_SIZE (regnum));
            write_register (regnum, value);
          }
d2260 7
a2266 5
      /* Actually cut back the stack.  Remember that the SP's element of
         saved_regs is the old SP itself, not the address at which it is
         saved.  */
      write_register (S390_SP_REGNUM, deprecated_get_frame_saved_regs (frame)[S390_SP_REGNUM]);
    }
d2268 6
a2273 2
  /* Throw away any cached frame information.  */
  flush_cached_frames ();
d2276 14
d2291 2
a2292 6
/* Destroy the innermost (Top-Of-Stack) stack frame, restoring the 
   machine state that was in effect before the frame was created. 
   Used in the contexts of the "return" command, and of 
   target function calls from the debugger.  */
static void
s390_pop_frame (void)
d2294 3
a2296 3
  /* This function checks for and handles generic dummy frames, and
     calls back to our function for ordinary frames.  */
  generic_pop_current_frame (s390_pop_frame_regular);
d2665 4
a2668 2
  /* Return stack pointer.  */ 
  return sp;
d2678 6
a2683 3
  ULONGEST sp;
  frame_unwind_unsigned_register (next_frame, S390_SP_REGNUM, &sp);
  return frame_id_build (sp, frame_pc_unwind (next_frame));
d2799 2
a2809 6
/* Advance PC across any function entry prologue instructions to reach some
   "real" code.  */
static CORE_ADDR
s390_skip_prologue (CORE_ADDR pc)
{
  struct frame_extra_info fextra_info;
d2811 1
a2811 13
  s390_get_frame_info (pc, &fextra_info, NULL, 1);
  return fextra_info.skip_prologue_function_start;
}

/* Immediately after a function call, return the saved pc.
   Can't go through the frames for this because on some machines
   the new frame is not set up until the new function executes
   some instructions.  */
static CORE_ADDR
s390_saved_pc_after_call (struct frame_info *frame)
{
  return ADDR_BITS_REMOVE (read_register (S390_RETADDR_REGNUM));
}
d2816 1
a2816 1
  return (addr) & 0x7fffffff;
d2850 3
a2871 4
  /* NOTE: cagney/2002-12-06: This can be deleted when this arch is
     ready to unwind the PC first (see frame.c:get_prev_frame()).  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, deprecated_init_frame_pc_default);

a2874 2
  set_gdbarch_deprecated_frame_chain (gdbarch, s390_frame_chain);
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, s390_frame_init_saved_regs);
a2878 1
  set_gdbarch_deprecated_pop_frame (gdbarch, s390_pop_frame);
a2882 3
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, s390_init_extra_frame_info);
  set_gdbarch_deprecated_init_frame_pc_first (gdbarch, s390_init_frame_pc_first);
  set_gdbarch_deprecated_target_read_fp (gdbarch, s390_read_fp);
d2884 1
a2884 10
  /* This function that tells us whether the function invocation represented
     by FI does not have a frame on the stack associated with it.  If it
     does not, FRAMELESS is set to 1, else 0.  */
  set_gdbarch_deprecated_frameless_function_invocation (gdbarch, s390_frameless_function_invocation);
  /* Return saved PC from a frame */
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, s390_frame_saved_pc);
  /* DEPRECATED_FRAME_CHAIN takes a frame's nominal address and
     produces the frame's chain-pointer. */
  set_gdbarch_deprecated_frame_chain (gdbarch, s390_frame_chain);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, s390_saved_pc_after_call);
a2886 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, S390_SP_REGNUM);
d2907 9
@


1.125
log
@2004-02-17  Ulrich Weigand <Ulrich.Weigand@@de.ibm.com>

	Committed by Jim Blandy  <jimb@@redhat.com>.
	* config/s390/nm-linux.h: Update comments.  Do not include "solib.h".
	(KERNEL_U_ADDR, REGISTER_U_ADDR, U_REGS_OFFSET): Remove.
	(FETCH_INFERIOR_REGISTERS): Define.
	* config/s390/s390.mh (NATDEPFILES): Remove core-aout.o and
	core-regset.o.
	* config/s390/s390x.mt: Remove.
	* config/s390/tm-s390.h: Remove.
	* config/s390/tm-linux.h: Do not include "s390/tm-s390.h".
	(TARGET_ELF64): Remove.
	(SKIP_TRAMPOLINE_CODE): Do not undefine.
	* configure.tgt [s390-*-*, s390x-*-*]: Merge into single
	s390*-*-* case; always set gdb_target to s390.
	* regformats/reg-s390.dat: Remove control registers.
	* regformats/reg-s390x.dat: Likewise.
	* s390-tdep.h: New file.
	* s390-nat.c: Do not include <asm/processor.h> or <value.h>.
	Include "inferior.h" and "s390-tdep.h".
	Remove private definition of offsetof.
	(s390_register_u_addr): Remove.
	(regmap_gregset, regmap_fpregset): Define.
	(supply_gregset, fill_gregset): Reimplement.
	(supply_fpregset, fill_fpregset): Likewise.
	(s390_inferior_tid): New function.
	(fetch_regs, store_regs, fetch_fpregs, store_fpregs): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* s390-tdep.c: Do not define S390_TDEP.  Include "defs.h" instead
	of <defs.h>.  Include "reggroups.h", "regset.h", and "s390-tdep.h".
	Global replace of S390_GP0_REGNUM by S390_R0_REGNUM.
	Global replace of S390_FP0_REGNUM by S390_F0_REGNUM.
	(struct gdbarch_tdep): Define.
	(struct s390_register_info): Define.
	(s390_register_info): New variable.
	(s390_register_name): Reimplement.
	(s390_register_type): New function.
	(s390_register_raw_size, s390x_register_raw_size): Remove.
	(s390_cannot_fetch_register): Remove.
	(s390_register_byte): Remove.
	(s390_register_virtual_type, s390x_register_virtual_type): Remove.
	(s390_dwarf_regmap): New variable.
	(s390_dwarf_reg_to_regnum): New function.
	(s390_stab_reg_to_regnum): Remove.
	(s390_pseudo_register_read, s390_pseudo_register_write): New functions.
	(s390x_pseudo_register_read, s390x_pseudo_register_write): Likewise.
	(s390_convert_register_p): Likewise.
	(s390_register_to_value, s390_value_to_register): Likewise.
	(s390_register_reggroup_p): Likewise.
	(s390_regmap_gregset, s390x_regmap_gregset, s390_regmap_fpregset,
	s390_gregset, s390x_gregset, s390_fpregset): New variables.
	(s390_supply_regset, s390_regset_from_core_section): New functions.
	(GDB_TARGET_IS_ESAME): Move here from tm-s390.h.
	(S390_FPR_SIZE): Likewise.
	(S390_GPR_SIZE): Likewise.  Redefine in terms of GDB_TARGET_IS_ESAME.
	Global replace of DEPRECATED_REGISTER_SIZE by S390_GPR_SIZE.
	(S390_NUM_GPRS): Move here from tm-s390.h.
	(S390_NUM_FPRS): Likewise.
	(s390_in_function_epilogue_p): New function.
	(s390_is_sigreturn): Replace S390_PSW_ADDR_SIZE by S390_GPR_SIZE.
	Replace S390_PC_REGNUM by S390_PSWA_REGNUM.
	(s390_gdbarch_init): Allocate and set up gdbarch_tdep structure.
	Replace s390_stab_reg_to_regnum by s390_dwarf_reg_to_regnum.
	Replace S390_FP_REGNUM by S390_SP_REGNUM.
	Remove calls to:
	set_gdbarch_deprecated_max_register_raw_size,
	set_gdbarch_deprecated_max_register_virtual_size,
	set_gdbarch_deprecated_register_byte,
	set_gdbarch_cannot_fetch_register,
	set_gdbarch_cannot_store_register,
	set_gdbarch_deprecated_register_size,
	set_gdbarch_deprecated_register_raw_size,
	set_gdbarch_deprecated_register_virtual_size,
	set_gdbarch_deprecated_register_virtual_type,
	set_gdbarch_deprecated_register_bytes.
	Add calls to:
	set_gdbarch_num_pseudo_regs,
	set_gdbarch_register_type,
	set_gdbarch_convert_register_p,
	set_gdbarch_register_to_value,
	set_gdbarch_value_to_register,
	set_gdbarch_register_reggroup_p,
	set_gdbarch_regset_from_core_section,
	set_gdbarch_pseudo_register_read,
	set_gdbarch_pseudo_register_write,
	set_gdbarch_in_function_epilogue_p.
	* Makefile.in (s390-nat.o, s390-tdep.o): Update dependencies.
	(s390_tdep_h): New variable.
@
text
@d51 3
a486 3
#define S390_STACK_FRAME_OVERHEAD  16*S390_GPR_SIZE+32
#define S390_STACK_PARAMETER_ALIGNMENT  S390_GPR_SIZE
#define S390_NUM_FP_PARAMETER_REGISTERS (GDB_TARGET_IS_ESAME ? 4:2)
a2256 98


/* NOTE: cagney/2003-10-31: "return_value" makes
   "extract_struct_value_address", "extract_return_value", and
   "use_struct_convention" redundant.  */
static CORE_ADDR
s390_cannot_extract_struct_value_address (struct regcache *regcache)
{
  return 0;
}

/* a given return value in `regbuf' with a type `valtype', extract and copy its
   value into `valbuf' */
static void
s390_extract_return_value (struct type *valtype, char *regbuf, char *valbuf)
{
  /* floats and doubles are returned in fpr0. fpr's have a size of 8 bytes.
     We need to truncate the return value into float size (4 byte) if
     necessary. */
  int len = TYPE_LENGTH (valtype);

  if (TYPE_CODE (valtype) == TYPE_CODE_FLT)
    memcpy (valbuf, &regbuf[DEPRECATED_REGISTER_BYTE (S390_F0_REGNUM)], len);
  else
    {
      int offset = 0;
      /* return value is copied starting from r2. */
      if (TYPE_LENGTH (valtype) < S390_GPR_SIZE)
	offset = S390_GPR_SIZE - TYPE_LENGTH (valtype);
      memcpy (valbuf,
	      regbuf + DEPRECATED_REGISTER_BYTE (S390_R0_REGNUM + 2) + offset,
	      TYPE_LENGTH (valtype));
    }
}


static char *
s390_promote_integer_argument (struct type *valtype, char *valbuf,
			       char *reg_buff, int *arglen)
{
  char *value = valbuf;
  int len = TYPE_LENGTH (valtype);

  if (len < S390_GPR_SIZE)
    {
      /* We need to upgrade this value to a register to pass it correctly */
      int idx, diff = S390_GPR_SIZE - len, negative =
	(!TYPE_UNSIGNED (valtype) && value[0] & 0x80);
      for (idx = 0; idx < S390_GPR_SIZE; idx++)
	{
	  reg_buff[idx] = (idx < diff ? (negative ? 0xff : 0x0) :
			   value[idx - diff]);
	}
      value = reg_buff;
      *arglen = S390_GPR_SIZE;
    }
  else
    {
      if (len & (S390_GPR_SIZE - 1))
	{
	  fprintf_unfiltered (gdb_stderr,
			      "s390_promote_integer_argument detected an argument not "
			      "a multiple of S390_GPR_SIZE & greater than S390_GPR_SIZE "
			      "we might not deal with this correctly.\n");
	}
      *arglen = len;
    }

  return (value);
}

static void
s390_store_return_value (struct type *valtype, char *valbuf)
{
  int arglen;
  char *reg_buff = alloca (max (S390_FPR_SIZE, S390_GPR_SIZE)), *value;

  if (TYPE_CODE (valtype) == TYPE_CODE_FLT)
    {
      if (TYPE_LENGTH (valtype) == 4
          || TYPE_LENGTH (valtype) == 8)
        deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (S390_F0_REGNUM),
					 valbuf, TYPE_LENGTH (valtype));
      else
        error ("GDB is unable to return `long double' values "
               "on this architecture.");
    }
  else
    {
      value =
	s390_promote_integer_argument (valtype, valbuf, reg_buff, &arglen);
      /* Everything else is returned in GPR2 and up. */
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (S390_R0_REGNUM + 2),
				       value, arglen);
    }
}


d2324 2
a2340 1

d2367 2
a2368 4
   WHY THE HECK DO WE CARE ABOUT THIS???  Well, it turns out that GCC
   passes all float singletons and double singletons as if they were
   simply floats or doubles.  This is *not* what the ABI says it
   should do.  */
d2372 10
a2381 4
  return (TYPE_CODE (type) == TYPE_CODE_STRUCT
          && TYPE_NFIELDS (type) == 1
          && (TYPE_CODE (TYPE_FIELD_TYPE (type, 0)) == TYPE_CODE_FLT
              || is_float_singleton (TYPE_FIELD_TYPE (type, 0))));
a2419 4
/* Return non-zero if TYPE is considered a `DOUBLE_OR_FLOAT', as
   defined by the parameter passing conventions described in the
   "GNU/Linux for S/390 ELF Application Binary Interface Supplement".
   Otherwise, return zero.  */
d2421 1
a2421 1
is_double_or_float (struct type *type)
d2423 1
a2423 3
  return (is_float_like (type)
          && (TYPE_LENGTH (type) == 4
              || TYPE_LENGTH (type) == 8));
d2426 2
a2427 5

/* Return non-zero if TYPE is a `DOUBLE_ARG', as defined by the
   parameter passing conventions described in the "GNU/Linux for S/390
   ELF Application Binary Interface Supplement".  Return zero
   otherwise.  */
d2429 1
a2429 1
is_double_arg (struct type *type)
d2432 2
d2435 2
a2436 7
  /* The s390x ABI doesn't handle DOUBLE_ARGS specially.  */
  if (GDB_TARGET_IS_ESAME)
    return 0;

  return ((is_integer_like (type)
           || is_struct_like (type))
          && length == 8);
d2439 2
a2440 5

/* Return non-zero if TYPE is considered a `SIMPLE_ARG', as defined by
   the parameter passing conventions described in the "GNU/Linux for
   S/390 ELF Application Binary Interface Supplement".  Return zero
   otherwise.  */
d2442 1
a2442 1
is_simple_arg (struct type *type)
d2445 2
d2448 1
a2448 12
  /* This is almost a direct translation of the ABI's language, except
     that we have to exclude 8-byte structs; those are DOUBLE_ARGs.  */
  return ((is_integer_like (type) && length <= S390_GPR_SIZE)
          || is_pointer_like (type)
          || (is_struct_like (type) && !is_double_arg (type)));
}


static int
is_power_of_two (unsigned int n)
{
  return ((n & (n - 1)) == 0);
d2451 2
a2452 3
/* Return non-zero if TYPE should be passed as a pointer to a copy,
   zero otherwise.  TYPE must be a SIMPLE_ARG, as recognized by
   `is_simple_arg'.  */
d2454 1
a2454 1
pass_by_copy_ref (struct type *type)
d2457 2
d2460 3
a2462 2
  return (is_struct_like (type)
          && !(is_power_of_two (length) && length <= S390_GPR_SIZE));
a2464 1

d2535 4
a2538 2
s390_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		     int struct_return, CORE_ADDR struct_addr)
d2540 3
a2543 4
  int pointer_size = (TARGET_PTR_BIT / TARGET_CHAR_BIT);

  /* The number of arguments passed by reference-to-copy.  */
  int num_copies;
a2549 1
  num_copies = 0;
d2556 1
a2556 2
      if (is_simple_arg (type)
          && pass_by_copy_ref (type))
a2561 1
          num_copies++;
d2567 3
a2569 11
     stack.  */
  {
    int i;

    for (i = 0; i < nargs; i++)
      {
        struct value *arg = args[i];
        struct type *type = VALUE_TYPE (arg);
        int length = TYPE_LENGTH (type);
        
        sp = align_down (sp, alignment_of (type));
a2570 11
        /* SIMPLE_ARG values get extended to S390_GPR_SIZE bytes. 
           Assume every argument is.  */
        if (length < S390_GPR_SIZE) length = S390_GPR_SIZE;
        sp -= length;
      }
  }

  /* Include space for any reference-to-copy pointers.  */
  sp = align_down (sp, pointer_size);
  sp -= num_copies * pointer_size;
    
d2583 1
a2583 1
    /* A struct is returned using general register 2 */
d2585 5
a2589 1
      gr++;
d2595 1
a2595 20
        
        if (is_double_or_float (type)
            && fr <= S390_NUM_FP_PARAMETER_REGISTERS * 2 - 2)
          {
            /* When we store a single-precision value in an FP register,
               it occupies the leftmost bits.  */
            deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (S390_F0_REGNUM + fr),
					     VALUE_CONTENTS (arg),
					     TYPE_LENGTH (type));
            fr += 2;
          }
        else if (is_simple_arg (type)
                 && gr <= 6)
          {
            /* Do we need to pass a pointer to our copy of this
               argument?  */
            if (pass_by_copy_ref (type))
              write_register (S390_R0_REGNUM + gr, copy_addr[i]);
            else
              write_register (S390_R0_REGNUM + gr, extend_simple_arg (arg));
d2597 73
a2669 51
            gr++;
          }
        else if (is_double_arg (type)
                 && gr <= 5)
          {
            deprecated_write_register_gen (S390_R0_REGNUM + gr,
					   VALUE_CONTENTS (arg));
            deprecated_write_register_gen (S390_R0_REGNUM + gr + 1,
					   VALUE_CONTENTS (arg) + S390_GPR_SIZE);
            gr += 2;
          }
        else
          {
            /* The `OTHER' case.  */
            enum type_code code = TYPE_CODE (type);
            unsigned length = TYPE_LENGTH (type);
            
            /* If we skipped r6 because we couldn't fit a DOUBLE_ARG
               in it, then don't go back and use it again later.  */
            if (is_double_arg (type) && gr == 6)
              gr = 7;

            if (is_simple_arg (type))
              {
                /* Simple args are always extended to 
                   S390_GPR_SIZE bytes.  */
                starg = align_up (starg, S390_GPR_SIZE);

                /* Do we need to pass a pointer to our copy of this
                   argument?  */
                if (pass_by_copy_ref (type))
                  write_memory_signed_integer (starg, pointer_size,
                                               copy_addr[i]);
                else
                  /* Simple args are always extended to 
                     S390_GPR_SIZE bytes. */
                  write_memory_signed_integer (starg, S390_GPR_SIZE,
                                               extend_simple_arg (arg));
                starg += S390_GPR_SIZE;
              }
            else
              {
                /* You'd think we should say:
                   starg = align_up (starg, alignment_of (type));
                   Unfortunately, GCC seems to simply align the stack on
                   a four/eight-byte boundary, even when passing doubles. */
                starg = align_up (starg, S390_STACK_PARAMETER_ALIGNMENT);
                write_memory (starg, VALUE_CONTENTS (arg), length);
                starg += length;
              }
          }
d2676 1
a2676 1
  sp -= S390_STACK_FRAME_OVERHEAD;
d2679 9
a2687 4
     frame.  This will help us get backtraces from within functions
     called from GDB.  */
  write_memory_unsigned_integer (sp, (TARGET_PTR_BIT / TARGET_CHAR_BIT),
                                 deprecated_read_fp ());
d2689 1
d2693 11
d2714 4
a2717 2
static int
s390_use_struct_convention (int gcc_p, struct type *value_type)
d2719 10
a2728 1
  enum type_code code = TYPE_CODE (value_type);
d2730 3
a2732 2
  return (code == TYPE_CODE_STRUCT
          || code == TYPE_CODE_UNION);
d2735 3
a2737 2
static void
s390_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
d2739 76
a2814 1
  write_register (S390_R0_REGNUM + 2, addr);
a2817 1

a2853 8

static CORE_ADDR
s390_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
{
  write_register (S390_RETADDR_REGNUM, entry_point_address ());
  return sp;
}

a2887 1
  static LONGEST s390_call_dummy_words[] = { 0 };
a2889 1
  int elf_flags;
a2912 3
  set_gdbarch_deprecated_store_struct_return (gdbarch, s390_store_struct_return);
  set_gdbarch_deprecated_extract_return_value (gdbarch, s390_extract_return_value);
  set_gdbarch_deprecated_store_return_value (gdbarch, s390_store_return_value);
a2941 1
  set_gdbarch_use_struct_convention (gdbarch, s390_use_struct_convention);
a2952 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, s390_cannot_extract_struct_value_address);
d2954 3
a2956 2
  /* Parameters for inferior function calls.  */
  set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_at_entry_point);
d2958 1
a2958 6
  set_gdbarch_deprecated_push_arguments (gdbarch, s390_push_arguments);
  set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
  set_gdbarch_deprecated_push_return_address (gdbarch,
                                              s390_push_return_address);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (s390_call_dummy_words));
  set_gdbarch_deprecated_call_dummy_words (gdbarch, s390_call_dummy_words);
d2963 2
d2975 2
a2994 3

  /* Should be using push_dummy_call.  */
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);
@


1.124
log
@2004-02-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAMELESS_FUNCTION_INVOCATION): Predicate
	and function replacing FRAMELESS_FUNCTION_INVOCATION.
	* blockframe.c (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* frame.h (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	(delta68_frame_args_address): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	(frv_frameless_function_invocation): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	(cris_frameless_function_invocation): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* stack.c (frame_info): Update, call predicate.
	* rs6000-tdep.c (rs6000_frame_chain): Update, call predicate..
	* frame.c (legacy_get_prev_frame): Update, call predicate..
	* arch-utils.c (generic_frameless_function_invocation_not): Delete.
	* arch-utils.h (generic_frameless_function_invocation_not): Delete.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set frameless function
	invocation.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
@
text
@d25 1
a25 2
#define S390_TDEP		/* for special macros in tm-s390.h */
#include <defs.h>
d38 2
d44 1
d47 139
a185 2
/* Number of bytes of storage in the actual machine representation
   for register N.  */
d187 90
a276 1
s390_register_raw_size (int reg_nr)
d278 18
a295 5
  if (S390_FP0_REGNUM <= reg_nr
      && reg_nr < S390_FP0_REGNUM + S390_NUM_FPRS)
    return S390_FPR_SIZE;
  else
    return 4;
d298 3
d302 21
a322 1
s390x_register_raw_size (int reg_nr)
d324 7
a330 2
  return (reg_nr == S390_FPC_REGNUM)
    || (reg_nr >= S390_FIRST_ACR && reg_nr <= S390_LAST_ACR) ? 4 : 8;
d333 2
d336 92
a427 1
s390_cannot_fetch_register (int regno)
d429 8
a436 2
  return (regno >= S390_FIRST_CR && regno < (S390_FIRST_CR + 9)) ||
    (regno >= (S390_FIRST_CR + 12) && regno <= S390_LAST_CR);
d439 20
a458 2
static int
s390_register_byte (int reg_nr)
d460 9
a468 10
  if (reg_nr <= S390_GP_LAST_REGNUM)
    return reg_nr * S390_GPR_SIZE;
  if (reg_nr <= S390_LAST_ACR)
    return S390_ACR0_OFFSET + (((reg_nr) - S390_FIRST_ACR) * S390_ACR_SIZE);
  if (reg_nr <= S390_LAST_CR)
    return S390_CR0_OFFSET + (((reg_nr) - S390_FIRST_CR) * S390_CR_SIZE);
  if (reg_nr == S390_FPC_REGNUM)
    return S390_FPC_OFFSET;
  else
    return S390_FP0_OFFSET + (((reg_nr) - S390_FP0_REGNUM) * S390_FPR_SIZE);
d471 4
d484 2
a485 2
#define S390_STACK_FRAME_OVERHEAD  16*DEPRECATED_REGISTER_SIZE+32
#define S390_STACK_PARAMETER_ALIGNMENT  DEPRECATED_REGISTER_SIZE
a540 38

static const char *
s390_register_name (int reg_nr)
{
  static char *register_names[] = {
    "pswm", "pswa",
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "acr0", "acr1", "acr2", "acr3", "acr4", "acr5", "acr6", "acr7",
    "acr8", "acr9", "acr10", "acr11", "acr12", "acr13", "acr14", "acr15",
    "cr0", "cr1", "cr2", "cr3", "cr4", "cr5", "cr6", "cr7",
    "cr8", "cr9", "cr10", "cr11", "cr12", "cr13", "cr14", "cr15",
    "fpc",
    "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
    "f8", "f9", "f10", "f11", "f12", "f13", "f14", "f15"
  };

  if (reg_nr <= S390_LAST_REGNUM)
    return register_names[reg_nr];
  else
    return NULL;
}




static int
s390_stab_reg_to_regnum (int regno)
{
  return regno >= 64 ? S390_PSWM_REGNUM - 64 :
    regno >= 48 ? S390_FIRST_ACR - 48 :
    regno >= 32 ? S390_FIRST_CR - 32 :
    regno <= 15 ? (regno + 2) :
    S390_FP0_REGNUM + ((regno - 16) & 8) + (((regno - 16) & 3) << 1) +
    (((regno - 16) & 4) >> 2);
}


d952 2
d1142 2
d1177 1
a1177 1
  back_chain_addr = gpr[S390_SP_REGNUM - S390_GP0_REGNUM];
d1260 1
a1260 1
                                 + DEPRECATED_REGISTER_BYTE (S390_GP0_REGNUM));
d1265 1
a1265 1
          saved_regs[S390_GP0_REGNUM + reg] = save_reg_addr;
d1274 1
a1274 1
          saved_regs[S390_FP0_REGNUM + reg] = save_reg_addr;
d1324 1
a1324 1
      pv_set_to_register (&gpr[i], S390_GP0_REGNUM + i, 0);
d1327 1
a1327 1
      pv_set_to_register (&fpr[i], S390_FP0_REGNUM + i, 0);
d1361 2
a1362 2
      pre_insn_sp = gpr[S390_SP_REGNUM - S390_GP0_REGNUM];
      pre_insn_fp = gpr[S390_FRAME_REGNUM - S390_GP0_REGNUM];
d1644 2
a1645 2
        struct prologue_value *sp = &gpr[S390_SP_REGNUM - S390_GP0_REGNUM];
        struct prologue_value *fp = &gpr[S390_FRAME_REGNUM - S390_GP0_REGNUM];
d1675 1
a1675 1
      struct prologue_value *fp = &gpr[S390_FRAME_REGNUM - S390_GP0_REGNUM];
d1706 1
a1706 1
        frame_base = &gpr[frame_base_regno - S390_GP0_REGNUM];
d1720 1
a1720 1
      struct prologue_value *sp = &gpr[S390_SP_REGNUM - S390_GP0_REGNUM];
d1833 44
d2047 2
a2048 2
						       DEPRECATED_REGISTER_BYTE (S390_PC_REGNUM),
						       S390_PSW_ADDR_SIZE));
d2217 1
a2217 1
					 DEPRECATED_REGISTER_BYTE (S390_GP0_REGNUM +
d2279 1
a2279 1
    memcpy (valbuf, &regbuf[DEPRECATED_REGISTER_BYTE (S390_FP0_REGNUM)], len);
d2287 1
a2287 1
	      regbuf + DEPRECATED_REGISTER_BYTE (S390_GP0_REGNUM + 2) + offset,
d2332 1
a2332 1
  char *reg_buff = alloca (max (S390_FPR_SIZE, DEPRECATED_REGISTER_SIZE)), *value;
d2338 1
a2338 1
        deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (S390_FP0_REGNUM),
d2349 1
a2349 1
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (S390_GP0_REGNUM + 2),
d2556 1
a2556 1
  return ((is_integer_like (type) && length <= DEPRECATED_REGISTER_SIZE)
d2577 1
a2577 1
          && !(is_power_of_two (length) && length <= DEPRECATED_REGISTER_SIZE));
d2697 1
a2697 1
        /* SIMPLE_ARG values get extended to DEPRECATED_REGISTER_SIZE bytes. 
d2699 1
a2699 1
        if (length < DEPRECATED_REGISTER_SIZE) length = DEPRECATED_REGISTER_SIZE;
d2734 1
a2734 1
            deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (S390_FP0_REGNUM + fr),
d2745 1
a2745 1
              write_register (S390_GP0_REGNUM + gr, copy_addr[i]);
d2747 1
a2747 1
              write_register (S390_GP0_REGNUM + gr, extend_simple_arg (arg));
d2754 1
a2754 1
            deprecated_write_register_gen (S390_GP0_REGNUM + gr,
d2756 2
a2757 2
            deprecated_write_register_gen (S390_GP0_REGNUM + gr + 1,
					   VALUE_CONTENTS (arg) + DEPRECATED_REGISTER_SIZE);
d2774 2
a2775 2
                   DEPRECATED_REGISTER_SIZE bytes.  */
                starg = align_up (starg, DEPRECATED_REGISTER_SIZE);
d2784 2
a2785 2
                     DEPRECATED_REGISTER_SIZE bytes. */
                  write_memory_signed_integer (starg, DEPRECATED_REGISTER_SIZE,
d2787 1
a2787 1
                starg += DEPRECATED_REGISTER_SIZE;
a2835 23

/* Return the GDB type object for the "standard" data type
   of data in register N.  */
static struct type *
s390_register_virtual_type (int regno)
{
  if (S390_FP0_REGNUM <= regno && regno < S390_FP0_REGNUM + S390_NUM_FPRS)
    return builtin_type_double;
  else
    return builtin_type_int;
}


static struct type *
s390x_register_virtual_type (int regno)
{
  return (regno == S390_FPC_REGNUM) ||
    (regno >= S390_FIRST_ACR && regno <= S390_LAST_ACR) ? builtin_type_int :
    (regno >= S390_FP0_REGNUM) ? builtin_type_double : builtin_type_long;
}



d2839 1
a2839 1
  write_register (S390_GP0_REGNUM + 2, addr);
d2937 2
a2938 1
  gdbarch = gdbarch_alloc (&info, NULL);
a2958 2
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 8);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 8);
d2964 1
a2974 1
  set_gdbarch_deprecated_register_byte (gdbarch, s390_register_byte);
d2977 2
a2978 2
  set_gdbarch_deprecated_fp_regnum (gdbarch, S390_FP_REGNUM);
  set_gdbarch_fp0_regnum (gdbarch, S390_FP0_REGNUM);
d2980 1
a2980 2
  set_gdbarch_cannot_fetch_register (gdbarch, s390_cannot_fetch_register);
  set_gdbarch_cannot_store_register (gdbarch, s390_cannot_fetch_register);
d2983 10
a2992 3
  set_gdbarch_stab_reg_to_regnum (gdbarch, s390_stab_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, s390_stab_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, s390_stab_reg_to_regnum);
d3008 4
a3011 4
      set_gdbarch_deprecated_register_size (gdbarch, 4);
      set_gdbarch_deprecated_register_raw_size (gdbarch, s390_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, s390_register_raw_size);
      set_gdbarch_deprecated_register_virtual_type (gdbarch, s390_register_virtual_type);
d3014 2
a3015 1
      set_gdbarch_deprecated_register_bytes (gdbarch, S390_REGISTER_BYTES);
d3018 4
a3021 4
      set_gdbarch_deprecated_register_size (gdbarch, 8);
      set_gdbarch_deprecated_register_raw_size (gdbarch, s390x_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, s390x_register_raw_size);
      set_gdbarch_deprecated_register_virtual_type (gdbarch, s390x_register_virtual_type);
d3026 2
a3027 1
      set_gdbarch_deprecated_register_bytes (gdbarch, S390X_REGISTER_BYTES);
@


1.123
log
@2004-02-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symfile.c (init_entry_point_info, entry_point_address): Move
	from here...
	* objfiles.c (init_entry_point_info, entry_point_address):..to
	here.
	* symfile.h (init_entry_point_info, entry_point_address): Remove
	prototypes.
	* objfiles.h (init_entry_point_info, entry_point_address):Add
	prototypes.
	* cris-tdep.c: Remove include of symfile.h. Add include of
	objfiles.h.
	* infcall.c: Ditto.
	* mcore-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
 	* v850-tdep.c: Ditto.
	* arm-tdep.c: Remove include of symfile.h.
	* blockframe.c: Ditto.
	* coffread.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* frv-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* mipsread.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* s390-tdep.c: Ditto.
	* sh-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* gdbarch.sh: Remove include of symfile.h.
	* gdbarch.c: Regenerate.
	* solib-irix.c (enable_break): Use entry_point_address().
	Add comment about include file.
	* xcoffread.c: Add comment about include file.
	* Makefile.in (arm-tdep.o, blockframe.o, coffread.o, cris-tdep.o)
	(dbxread.o, dwarf2read.o, dwarfread.o, frv-tdep.o, gdbarch.o)
	(ia64-tdep.o, infcall.o, mcore-tdep.o, mdebugread.o, mipsread.o)
	(mn10300-tdep.o, rs6000-nat.o, s390-tdep.o, sh64-tdep.o)
	(sh-tdep.o, v850-tdep.o, xstormy16-tdep.o): Update dependencies.
@
text
@d2592 1
a2592 2
  set_gdbarch_frameless_function_invocation (gdbarch,
					     s390_frameless_function_invocation);
@


1.122
log
@2004-02-12  Andrew Cagney  <cagney@@redhat.com>

	* remote-rdi.c (arm_rdi_start_remote): Delete unused function.
	(arm_rdi_interrupt, arm_rdi_interrupt_twice): Ditto.
	(interrupt_query): Ditto.
	(ofunc): Delete unused variable.
	* cris-tdep.c (cris_abi): Delete unused function.
	(reg_pop_op, move_reg_to_mem_index_inc_op): Ditto.
	(cris_get_wide_opcode, cris_get_short_size): Ditto.
	(cris_get_asr_quick_shift_steps): Ditto.
	(cris_skip_prologue_frameless_p): Ditto.
	* arm-tdep.c (arm_push_return_address): Delete unused function.
	(arm_push_dummy_frame, arm_fix_call_dummy): Ditto.
	* rs6000-tdep.c (rs6000_pc_in_call_dummy): Delete unused function.
	* s390-tdep.c (s390_function_start): Delete unused function.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
a33 1
#include "symfile.h"
@


1.121
log
@2004-02-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_SKIP): Default to 0.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@a1567 16

static CORE_ADDR
s390_function_start (struct frame_info *fi)
{
  CORE_ADDR function_start = 0;

  if (get_frame_extra_info (fi) && get_frame_extra_info (fi)->initialised)
    function_start = get_frame_extra_info (fi)->function_start;
  else if (get_frame_pc (fi))
    function_start = get_frame_func (fi);
  return function_start;
}




@


1.120
log
@2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (EXTRACT_STRUCT_VALUE_ADDRESS): Deprecate.  Add
	comments mentioning extract_returned_value_address.
	* infcmd.c (print_return_value): Update.  Add comments on
	extract_returned_value_address.
	* stack.c (return_command): Add comments on
	extract_returned_value_address.
	* values.c: Update comment.
	* m32r-tdep.c: Update comment.
	* sparc-tdep.c: Update comment.
	* ia64-tdep.c (ia64_use_struct_convention): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	EXTRACT_STRUCT_VALUE_ADDRESS to
	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
@
text
@a2586 1
  set_gdbarch_frame_args_skip (gdbarch, 0);
@


1.119
log
@2004-01-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FUNCTION_START_OFFSET): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	FUNCTION_START_OFFSET.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d2631 1
a2631 1
  set_gdbarch_extract_struct_value_address (gdbarch, s390_cannot_extract_struct_value_address);
@


1.118
log
@2003-10-31  Andrew Cagney  <cagney@@redhat.com>

	* s390-tdep.c (s390_cannot_extract_struct_value_address): New
	function.
	(s390_gdbarch_init): Set extract_struct_value_address.
	* arch-utils.c (generic_cannot_extract_struct_value_address):
	Delete function.
	* arch-utils.h (generic_cannot_extract_struct_value_address):
	Delete definition.
@
text
@a2599 3
  /* Offset from address of function to start of its code.
     Zero on most machines.  */
  set_gdbarch_function_start_offset (gdbarch, 0);
@


1.117
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d1877 9
d2634 1
a2634 2
  set_gdbarch_deprecated_extract_struct_value_address
    (gdbarch, generic_cannot_extract_struct_value_address);
@


1.116
log
@2003-09-27  Andrew Cagney  <cagney@@redhat.com>

	* arch-utils.c (deprecated_init_frame_pc_default): Rename
	"init_frame_pc_default".
	* arch-utils.h (deprecated_init_frame_pc_default): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/pa/tm-hppa.h (DEPRECATED_INIT_FRAME_PC): Update.
@
text
@d2003 1
a2003 1
                                                  REGISTER_RAW_SIZE (regnum));
@


1.115
log
@2003-09-25  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_frame_saved_regs): Rename
	get_frame_saved_regs.
	* cris-tdep.c, frame.c, h8300-tdep.c, hppa-tdep.c: Update.
	* mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, ppc-linux-tdep.c, rs6000-tdep.c: Update.
	* s390-tdep.c, sh64-tdep.c, stack.c: Update.
	* v850-tdep.c, vax-tdep.c, xstormy16-tdep.c: Update.
@
text
@d2573 1
a2573 1
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_default);
@


1.114
log
@2003-09-19  Andrew Cagney  <cagney@@redhat.com>

	* utils.c (align_up, align_down): New functions.
	* defs.h (align_up, align_down): Declare.
	* ppc-sysv-tdep.c (align_up, align_down): Delete functions.
	* s390-tdep.c: Replace "round_up" and "round_down" with "align_up"
	and "align_down".
	(round_up, round_down): Delete functions.
	* mips-tdep.c: Replace ROUND_UP and ROUND_DOWN with "align_up" and
	"align_down".
	(ROUND_DOWN, ROUND_UP): Delete macros.
	(mips_dump_tdep): Do not print "ROUND_UP" or "ROUND_DOWN".
	* h8300-tdep.c: Replace "round_up" and "round_down" with
	"align_up" and "align_down".
	(round_up, round_down): Delete macros.
	* frv-tdep.c: Replace ROUND_UP and ROUND_DOWN with "align_up" and
	"align_down".
	(ROUND_UP, ROUND_DOWN): Delete macros.
@
text
@d904 1
a904 1
      CORE_ADDR *saved_regs = get_frame_saved_regs (fi);
d1431 1
a1431 1
        && get_frame_saved_regs (fi)
d1436 1
a1436 1
        CORE_ADDR *saved_regs = get_frame_saved_regs (fi);
d1722 1
a1722 1
  if (get_frame_saved_regs (fi) == NULL)
d1757 1
a1757 1
          && get_frame_saved_regs (fi)[S390_RETADDR_REGNUM])
d1760 1
a1760 1
                              (get_frame_saved_regs (fi)[S390_RETADDR_REGNUM],
d1844 1
a1844 1
	  if (get_frame_saved_regs (thisframe))
d1849 1
a1849 1
                  && get_frame_saved_regs (thisframe)[S390_FRAME_REGNUM])
d1854 1
a1854 1
	      if (get_frame_saved_regs (thisframe)[regno])
d1858 1
a1858 1
                    prev_fp = get_frame_saved_regs (thisframe)[regno];
d1861 1
a1861 1
                      read_memory_integer (get_frame_saved_regs (thisframe)[regno],
d1995 1
a1995 1
  if (get_frame_saved_regs (frame))
d1998 1
a1998 1
        if (get_frame_saved_regs (frame)[regnum] != 0)
d2002 1
a2002 1
            value = read_memory_unsigned_integer (get_frame_saved_regs (frame)[regnum],
d2010 1
a2010 1
      write_register (S390_SP_REGNUM, get_frame_saved_regs (frame)[S390_SP_REGNUM]);
@


1.113
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTE): Rename REGISTER_BYTE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-linux-tdep.c, core-sol2.c, cris-tdep.c: Update.
	* d10v-tdep.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, irix5-nat.c, lynx-nat.c, m68knbsd-nat.c: Update.
	* mcore-tdep.c, mips-linux-tdep.c, mips-tdep.c: Update.
	* mipsv4-nat.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* ns32knbsd-nat.c, ppc-bdm.c, regcache.c, remote-sds.c: Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh64-tdep.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, v850-tdep.c: Update.
	* v850ice.c, vax-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-cisco.h, config/m68k/tm-delta68.h: Update.
	* config/pa/nm-hppah.h: Update.

2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* mi/mi-main.c: Rename REGISTER_BYTE to DEPRECATED_REGISTER_BYTE.
@
text
@a2208 22
/* Round ADDR up to the next N-byte boundary.  N must be a power of
   two.  */
static CORE_ADDR
round_up (CORE_ADDR addr, int n)
{
  /* Check that N is really a power of two.  */
  gdb_assert (n && (n & (n-1)) == 0);
  return ((addr + n - 1) & -n);
}


/* Round ADDR down to the next N-byte boundary.  N must be a power of
   two.  */
static CORE_ADDR
round_down (CORE_ADDR addr, int n)
{
  /* Check that N is really a power of two.  */
  gdb_assert (n && (n & (n-1)) == 0);
  return (addr & -n);
}


d2285 1
a2285 1
          sp = round_down (sp, alignment_of (type));
d2304 1
a2304 1
        sp = round_down (sp, alignment_of (type));
d2314 1
a2314 1
  sp = round_down (sp, pointer_size);
d2319 1
a2319 1
  sp = round_down (sp, 8);
d2384 1
a2384 1
                starg = round_up (starg, DEPRECATED_REGISTER_SIZE);
d2401 1
a2401 1
                   starg = round_up (starg, alignment_of (type));
d2404 1
a2404 1
                starg = round_up (starg, S390_STACK_PARAMETER_ALIGNMENT);
@


1.112
log
@2003-09-04  Andrew Cagney  <cagney@@redhat.com>

	* avr-tdep.c: Include "dis-asm.h".
	* cris-tdep.c: Include "dis-asm.h".
	(cris_delayed_get_disassembler): Use "struct disassemble_info"
	instead of corresponding typedef.
	* h8300-tdep.c: Include "dis-asm.h".
	* ia64-tdep.c: Include "dis-asm.h".
	* i386-tdep.c: Include "dis-asm.h".
	(i386_print_insn): Use "struct disassemble_info" instead of
	corresponding typedef.
	* m68k-tdep.c: Include "dis-asm.h".
	* mcore-tdep.c: Include "dis-asm.h".
	* mips-tdep.c: Include "dis-asm.h".
	(gdb_print_insn_mips): Make static, use "struct disassemble_info"
	instead of corresponding typedef.
	* ns32k-tdep.c: Include "dis-asm.h".
	* s390-tdep.c: Include "dis-asm.h".
	* sparc-tdep.c: Include "dis-asm.h".
	* vax-tdep.c: Include "dis-asm.h".
	* v850-tdep.c: Include "dis-asm.h".
	* mn10300-tdep.c: Include "dis-asm.h".
	* rs6000-tdep.c: Include "dis-asm.h".
	* xstormy16-tdep.c: Include "dis-asm.h".
	(_initialize_xstormy16_tdep): Delete "extern" declaration of
	print_insn_xstormy16.
	* Makefile.in (v850-tdep.o): Update dependencies.
	(vax-tdep.o, sparc-tdep.o, s390-tdep.o): Ditto.
	(ns32k-tdep.o, mips-tdep.o, mcore-tdep.o): Ditto.
	(m68k-tdep.o, ia64-tdep.o, i386-tdep.o): Ditto.
	(h8300-tdep.o, cris-tdep.o, avr-tdep.o): Ditto.
	(mn10300-tdep.o, xstormy16-tdep.o, disasm.o): Ditto.
	(gdbarch_h): Remove $(dis_asm_h).
	* disasm.c: Include "dis-asm.h".
	(dis_asm_read_memory): Use "struct disassemble_info" instead of
	corresponding typedef.
	(dis_asm_memory_error, dump_insns, do_assembly_only): Ditto.
	(gdb_disassemble_info, gdb_disassembly, gdb_print_insn): Ditto.
	* gdbarch.sh: Do not include "dis-asm.h".
	(struct disassemble_info): Declare opaque.
	(TARGET_PRINT_INSN): Update declaration.
	* gdbarch.h, gdbarch.c: Re-generate.
@
text
@d906 1
a906 1
                                 + REGISTER_BYTE (S390_GP0_REGNUM));
d1665 1
a1665 2
						       REGISTER_BYTE
						       (S390_PC_REGNUM),
d1835 1
a1835 1
					 REGISTER_BYTE (S390_GP0_REGNUM +
d1888 1
a1888 1
    memcpy (valbuf, &regbuf[REGISTER_BYTE (S390_FP0_REGNUM)], len);
d1896 1
a1896 1
	      regbuf + REGISTER_BYTE (S390_GP0_REGNUM + 2) + offset,
d1947 1
a1947 1
        deprecated_write_register_bytes (REGISTER_BYTE (S390_FP0_REGNUM),
d1958 1
a1958 1
      deprecated_write_register_bytes (REGISTER_BYTE (S390_GP0_REGNUM + 2),
d2365 1
a2365 1
            deprecated_write_register_bytes (REGISTER_BYTE (S390_FP0_REGNUM + fr),
@


1.111
log
@2003-09-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_CALL_DUMMY_ADDRESS): Rename
	CALL_DUMMY_ADDRESS, change to a predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* blockframe.c (deprecated_pc_in_call_dummy_at_entry_point):
	Use either DEPRECATED_CALL_DUMMY_ADDRESS or entry_point_address.
	* infcall.c (call_function_by_hand): Ditto.
	* sparc-tdep.c (sparc_push_return_address): Ditto.
	(sparc_gdbarch_init): Set deprecated_call_dummy_address.
	* xstormy16-tdep.c (xstormy16_push_return_address): Replace
	CALL_DUMMY_ADDRESS with entry_point_address.
	* v850-tdep.c (v850_push_return_address): Ditto.
	* s390-tdep.c (s390_push_return_address): Ditto.
	* rs6000-tdep.c (ppc_push_return_address): Ditto.
	* mn10300-tdep.c (mn10300_push_return_address): Ditto.
	* mcore-tdep.c (mcore_push_return_address): Ditto.
	* cris-tdep.c (cris_push_return_address): Ditto.
	* arm-tdep.c (arm_push_return_address): Ditto.
@
text
@d42 1
a42 1

@


1.110
log
@2003-08-27  Andrew Cagney  <cagney@@redhat.com>

	* s390-tdep.c (s390_readinstruction): Delete "info" parameter.
	Use target_read_memory.
	(s390_get_frame_info): Update.  Do not reference
	deprecated_tm_print_insn_info.
	(s390_check_function_end, s390_is_sigreturn): Ditto.
@
text
@d2539 1
a2539 1
  write_register (S390_RETADDR_REGNUM, CALL_DUMMY_ADDRESS ());
@


1.109
log
@2003-08-27  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (cris-tdep.o): Update dependencies.
	* cris-tdep.c: Include "gdb_assert.h".
	(cris_gdbarch_init): Set print_insn.
	(_initialize_cris_tdep): Do not set deprecated_tm_print_insn.
	(cris_delayed_get_disassembler): Simplify, directly call the
	disassembler returned by cris_get_disassembler.
	* hppa-tdep.c (hppa_gdbarch_init): Set print_insn.
	(_initialize_hppa_tdep): Do not set deprecated_tm_print_insn.
	* ns32k-tdep.c (ns32k_gdbarch_init): Set print_insn.
	(_initialize_ns32k_tdep): Do not set deprecated_tm_print_insn.
	* mn10300-tdep.c (mn10300_gdbarch_init): Set print_insn.
	(_initialize_mn10300_tdep): Do not set deprecated_tm_print_insn.
	* mcore-tdep.c (mcore_gdbarch_init): Set print_insn.
	(_initialize_mcore_tdep): Do not set deprecated_tm_print_insn.
	* frv-tdep.c (frv_gdbarch_init): Set print_insn.
	(_initialize_frv_tdep): Do not set deprecated_tm_print_insn.
	* sparc-tdep.c (sparc_gdbarch_init): Set print_insn.
	(gdb_print_insn_sparc): Delete function.
	(_initialize_sparc_tdep): Do not set deprecated_tm_print_insn or
	deprecated_tm_print_insn_info.
	* v850-tdep.c (v850_gdbarch_init): Set print_insn.
	(_initialize_v850_tdep): Do not set deprecated_tm_print_insn.
	(v850_gdbarch_init): Do not set deprecated_tm_print_insn_info.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set print_insn.
	(_initialize_xstormy16_tdep): Do not set deprecated_tm_print_insn.
	* s390-tdep.c (gdb_print_insn_s390): Delete function.
	(_initialize_s390_tdep): Do not set deprecated_tm_print_insn.
	(s390_gdbarch_init): Set print_insn.
@
text
@d125 1
a125 2
s390_readinstruction (bfd_byte instr[], CORE_ADDR at,
		      struct disassemble_info *info)
d135 1
a135 1
  if ((*info->read_memory_func) (at, &instr[0], 2, info))
d140 1
a140 1
      if ((*info->read_memory_func) (at + 2, &instr[2], instrlen - 2, info))
a937 3
  /* We just use this for reading instructions.  */
  disassemble_info info;

a964 2
  info.read_memory_func = deprecated_tm_print_insn_info.read_memory_func;

d988 1
a988 1
      int insn_len = s390_readinstruction (insn, pc, &info);
a1483 1
  disassemble_info info;
d1486 1
a1486 2
  info.read_memory_func = deprecated_tm_print_insn_info.read_memory_func;
  instrlen = s390_readinstruction (instr, pc, &info);
d1495 1
a1495 1
    s390_readinstruction (instr, pc - (GDB_TARGET_IS_ESAME ? 6 : 4), &info);
d1512 1
a1512 2
  instrlen = s390_readinstruction (instr, pc - (GDB_TARGET_IS_ESAME ? 12 : 8),
				   &info);
a1612 1
  disassemble_info info;
d1621 1
a1621 2
  info.read_memory_func = deprecated_tm_print_insn_info.read_memory_func;
  instrlen = s390_readinstruction (instr, pc, &info);
@


1.108
log
@* s390-tdep.c (struct frame_extra_info): new member:
'stack_bought_valid'.
(s390_get_frame_info): Set fextra_info->stack_bought_valid if we
initialize fextra_info->stack_bought.
(s390_frameless_function_invocation): Don't trust the value of
fextra_info_ptr->stack_bought unless
fextra_info->stack_bought_valid is set.
@
text
@a1973 20
static int
gdb_print_insn_s390 (bfd_vma memaddr, disassemble_info * info)
{
  bfd_byte instrbuff[S390_MAX_INSTR_SIZE];
  int instrlen, cnt;

  instrlen = s390_readinstruction (instrbuff, (CORE_ADDR) memaddr, info);
  if (instrlen < 0)
    {
      (*info->memory_error_func) (instrlen, memaddr, info);
      return -1;
    }
  for (cnt = 0; cnt < instrlen; cnt++)
    info->fprintf_func (info->stream, "%02X ", instrbuff[cnt]);
  for (cnt = instrlen; cnt < S390_MAX_INSTR_SIZE; cnt++)
    info->fprintf_func (info->stream, "   ");
  instrlen = print_insn_s390 (memaddr, info);
  return instrlen;
}

d2705 2
a2719 2
  if (!deprecated_tm_print_insn)	/* Someone may have already set it */
    deprecated_tm_print_insn = gdb_print_insn_s390;
@


1.107
log
@New S390 prologue analyzer.
* s390-tdep.c (struct prologue_value, enum pv_boolean): New types.
(pv_set_to_unknown, pv_set_to_constant, pv_set_to_register,
pv_constant_last, pv_add, pv_add_constant, pv_subtract,
pv_logical_and, pv_is_identical, pv_is_register, pv_is_array_ref,
compute_x_addr, s390_on_stack, s390_store,
s390_get_signal_frame_info): New functions.
(S390_NUM_SPILL_SLOTS): New macro.
(s390_get_frame_info): Rewritten.
(is_arg_reg): Deleted.

Break out the decoding of S/390 instructions into separate
functions, to make it more legible, and easier to check
against the spec.
* s390-tdep.c (is_ri, is_ril, is_rr, is_rre, is_rs, is_rse,
is_rx, is_rxe): New functions.
(op1_aghi, op2_aghi, op1_ahi, op2_ahi, op_ar, op_basr, op1_bras,
op2_bras, op_l, op_la, op1_larl, op2_larl, op_lgr, op1_lghi,
op2_lghi, op1_lhi, op2_lhi, op_lr, op_nr, op_ngr, op_s, op_st,
op_std, op1_stg, op2_stg, op_stm, op1_stmg, op2_stmg, op_svc): New
enums for opcode values.  (Is this an improvement?)
@
text
@d116 1
d1396 1
d1609 2
a1610 1
      frameless = ((fextra_info_ptr->stack_bought == 0));
@


1.106
log
@Patch from IBM (authors unspecified, probably Ulrich Weigand and
Gerhard Tonn) for argument passing on the S/390 and S/390x:
* s390-tdep.c (S390_STACK_FRAME_OVERHEAD): This is always space
for 16 registers, and then 32 more bytes.
(S390_STACK_PARAMETER_ALIGNMENT, S390_NUM_FP_PARAMETER_REGISTERS):
New macros.
(is_double_arg): The s390x doesn't handle DOUBLE_ARGS specially.
Move up in the file, since it's now used by is_simple_arg.
(is_simple_arg): Don't assume registers are four bytes long.
Exclude all double arguments.  Extended floats are not simple
args.
(is_power_of_two): New function.
(pass_by_copy_ref): Call is_power_of_two, and check that the
length fits in a register, rather than listing all the acceptable
sizes.  Extended floats are not passed by reference.
(s390_push_arguments): Don't assume registers are four bytes long.
Reserve an argument register to point to the buffer for structures
returned by value.  Use S390_NUM_FP_PARAMETER_REGISTERS and
S390_STACK_FRAME_OVERHEAD.
@
text
@d191 443
a633 2
/* Return true if REGIDX is the number of a register used to pass
     arguments, false otherwise.  */
d635 2
a636 1
is_arg_reg (int regidx)
d638 14
a651 1
  return 2 <= regidx && regidx <= 6;
d655 284
a938 32
/* s390_get_frame_info based on Hartmuts
   prologue definition in
   gcc-2.8.1/config/l390/linux.c 

   It reads one instruction at a time & based on whether
   it looks like prologue code or not it makes a decision on
   whether the prologue is over, there are various state machines
   in the code to determine if the prologue code is possilby valid.
   
   This is done to hopefully allow the code survive minor revs of
   calling conventions.

 */

static int
s390_get_frame_info (CORE_ADDR pc, struct frame_extra_info *fextra_info,
		     struct frame_info *fi, int init_extra_info)
{
#define CONST_POOL_REGIDX 13
#define GOT_REGIDX        12
  bfd_byte instr[S390_MAX_INSTR_SIZE];
  CORE_ADDR test_pc = pc, test_pc2;
  CORE_ADDR orig_sp = 0, save_reg_addr = 0, *saved_regs = NULL;
  int valid_prologue, good_prologue = 0;
  int gprs_saved[S390_NUM_GPRS];
  int fprs_saved[S390_NUM_FPRS];
  int regidx, instrlen;
  int const_pool_state;
  int varargs_state;
  int loop_cnt, gdb_gpr_store, gdb_fpr_store;
  int offset, expected_offset;
  int err = 0;
d941 2
a942 45
  /* Have we seen an instruction initializing the frame pointer yet?
     If we've seen an `lr %r11, %r15', then frame_pointer_found is
     non-zero, and frame_pointer_regidx == 11.  Otherwise,
     frame_pointer_found is zero and frame_pointer_regidx is 15,
     indicating that we're using the stack pointer as our frame
     pointer.  */
  int frame_pointer_found = 0;
  int frame_pointer_regidx = 0xf;

  /* What we've seen so far regarding saving the back chain link:
     0 -- nothing yet; sp still has the same value it had at the entry
          point.  Since not all functions allocate frames, this is a
          valid state for the prologue to finish in.
     1 -- We've saved the original sp in some register other than the
          frame pointer (hard-coded to be %r11, yuck).
          save_link_regidx is the register we saved it in.
     2 -- We've seen the initial `bras' instruction of the sequence for
          reserving more than 32k of stack:
                bras %rX, .+8
                .long N
                s %r15, 0(%rX)
          where %rX is not the constant pool register.
          subtract_sp_regidx is %rX, and fextra_info->stack_bought is N.
     3 -- We've reserved space for a new stack frame.  This means we
          either saw a simple `ahi %r15,-N' in state 1, or the final
          `s %r15, ...' in state 2.
     4 -- The frame and link are now fully initialized.  We've
          reserved space for the new stack frame, and stored the old
          stack pointer captured in the back chain pointer field.  */
  int save_link_state = 0;
  int save_link_regidx, subtract_sp_regidx;

  /* What we've seen so far regarding r12 --- the GOT (Global Offset
     Table) pointer.  We expect to see `l %r12, N(%r13)', which loads
     r12 with the offset from the constant pool to the GOT, and then
     an `ar %r12, %r13', which adds the constant pool address,
     yielding the GOT's address.  Here's what got_state means:
     0 -- seen nothing
     1 -- seen `l %r12, N(%r13)', but no `ar'
     2 -- seen load and add, so GOT pointer is totally initialized
     When got_state is 1, then got_load_addr is the address of the
     load instruction, and got_load_len is the length of that
     instruction.  */
  int got_state= 0;
  CORE_ADDR got_load_addr = 0, got_load_len = 0;
d944 23
a966 1
  const_pool_state = varargs_state = 0;
a967 2
  memset (gprs_saved, 0, sizeof (gprs_saved));
  memset (fprs_saved, 0, sizeof (fprs_saved));
d970 21
a990 2
  save_link_regidx = subtract_sp_regidx = 0;
  if (fextra_info)
d992 262
a1253 367
      if (fi && get_frame_base (fi))
	{
          orig_sp = get_frame_base (fi);
          if (! init_extra_info && fextra_info->initialised)
            orig_sp += fextra_info->stack_bought;
	  saved_regs = get_frame_saved_regs (fi);
	}
      if (init_extra_info || !fextra_info->initialised)
	{
	  s390_memset_extra_info (fextra_info);
	  fextra_info->function_start = pc;
	  fextra_info->initialised = 1;
	}
    }
  instrlen = 0;
  do
    {
      valid_prologue = 0;
      test_pc += instrlen;
      /* add the previous instruction len */
      instrlen = s390_readinstruction (instr, test_pc, &info);
      if (instrlen < 0)
	{
	  good_prologue = 0;
	  err = -1;
	  break;
	}
      /* We probably are in a glibc syscall */
      if (instr[0] == S390_SYSCALL_OPCODE && test_pc == pc)
	{
	  good_prologue = 1;
	  if (saved_regs && fextra_info && get_next_frame (fi)
	      && get_frame_extra_info (get_next_frame (fi))
	      && get_frame_extra_info (get_next_frame (fi))->sigcontext)
	    {
	      /* We are backtracing from a signal handler */
	      save_reg_addr = get_frame_extra_info (get_next_frame (fi))->sigcontext +
		REGISTER_BYTE (S390_GP0_REGNUM);
	      for (regidx = 0; regidx < S390_NUM_GPRS; regidx++)
		{
		  saved_regs[S390_GP0_REGNUM + regidx] = save_reg_addr;
		  save_reg_addr += S390_GPR_SIZE;
		}
	      save_reg_addr = get_frame_extra_info (get_next_frame (fi))->sigcontext +
		(GDB_TARGET_IS_ESAME ? S390X_SIGREGS_FP0_OFFSET :
		 S390_SIGREGS_FP0_OFFSET);
	      for (regidx = 0; regidx < S390_NUM_FPRS; regidx++)
		{
		  saved_regs[S390_FP0_REGNUM + regidx] = save_reg_addr;
		  save_reg_addr += S390_FPR_SIZE;
		}
	    }
	  break;
	}
      if (save_link_state == 0)
	{
	  /* check for a stack relative STMG or STM */
	  if (((GDB_TARGET_IS_ESAME &&
		((instr[0] == 0xeb) && (instr[5] == 0x24))) ||
	       (instr[0] == 0x90)) && ((instr[2] >> 4) == 0xf))
	    {
	      regidx = (instr[1] >> 4);
	      if (regidx < 6)
		varargs_state = 1;
	      offset = ((instr[2] & 0xf) << 8) + instr[3];
	      expected_offset =
		S390_GPR6_STACK_OFFSET + (S390_GPR_SIZE * (regidx - 6));
	      if (offset != expected_offset)
		{
		  good_prologue = 0;
		  break;
		}
	      if (saved_regs)
		save_reg_addr = orig_sp + offset;
	      for (; regidx <= (instr[1] & 0xf); regidx++)
		{
		  if (gprs_saved[regidx])
		    {
		      good_prologue = 0;
		      break;
		    }
		  good_prologue = 1;
		  gprs_saved[regidx] = 1;
		  if (saved_regs)
		    {
		      saved_regs[S390_GP0_REGNUM + regidx] = save_reg_addr;
		      save_reg_addr += S390_GPR_SIZE;
		    }
		}
	      valid_prologue = 1;
	      continue;
	    }
	}
      /* check for a stack relative STG or ST */
      if ((save_link_state == 0 || save_link_state == 3) &&
	  ((GDB_TARGET_IS_ESAME &&
	    ((instr[0] == 0xe3) && (instr[5] == 0x24))) ||
	   (instr[0] == 0x50)) && ((instr[2] >> 4) == 0xf))
	{
	  regidx = instr[1] >> 4;
	  offset = ((instr[2] & 0xf) << 8) + instr[3];
	  if (offset == 0)
	    {
	      if (save_link_state == 3 && regidx == save_link_regidx)
		{
		  save_link_state = 4;
		  valid_prologue = 1;
		  continue;
		}
	      else
		break;
	    }
	  if (regidx < 6)
	    varargs_state = 1;
	  expected_offset =
	    S390_GPR6_STACK_OFFSET + (S390_GPR_SIZE * (regidx - 6));
	  if (offset != expected_offset)
	    {
	      good_prologue = 0;
	      break;
	    }
	  if (gprs_saved[regidx])
	    {
	      good_prologue = 0;
	      break;
	    }
	  good_prologue = 1;
	  gprs_saved[regidx] = 1;
	  if (saved_regs)
	    {
	      save_reg_addr = orig_sp + offset;
	      saved_regs[S390_GP0_REGNUM + regidx] = save_reg_addr;
	    }
	  valid_prologue = 1;
	  continue;
	}

      /* Check for an fp-relative STG, ST, or STM.  This is probably
          spilling an argument from a register out into a stack slot.
          This could be a user instruction, but if we haven't included
          any other suspicious instructions in the prologue, this
          could only be an initializing store, which isn't too bad to
          skip.  The consequences of not including arg-to-stack spills
          are more serious, though --- you don't see the proper values
          of the arguments.  */
      if ((save_link_state == 3 || save_link_state == 4)
          && ((instr[0] == 0x50      /* st %rA, D(%rX,%rB) */
               && (instr[1] & 0xf) == 0 /* %rX is zero, no index reg */
               && is_arg_reg ((instr[1] >> 4) & 0xf)
               && ((instr[2] >> 4) & 0xf) == frame_pointer_regidx)
              || (instr[0] == 0x90 /* stm %rA, %rB, D(%rC) */
                  && is_arg_reg ((instr[1] >> 4) & 0xf)
                  && is_arg_reg (instr[1] & 0xf)
                  && ((instr[2] >> 4) & 0xf) == frame_pointer_regidx)))
        {
          valid_prologue = 1;
          continue;
        }

      /* check for STD */
      if (instr[0] == 0x60 && (instr[2] >> 4) == 0xf)
	{
	  regidx = instr[1] >> 4;
	  if (regidx == 0 || regidx == 2)
	    varargs_state = 1;
	  if (fprs_saved[regidx])
	    {
	      good_prologue = 0;
	      break;
	    }
	  fprs_saved[regidx] = 1;
	  if (saved_regs)
	    {
	      save_reg_addr = orig_sp + (((instr[2] & 0xf) << 8) + instr[3]);
	      saved_regs[S390_FP0_REGNUM + regidx] = save_reg_addr;
	    }
	  valid_prologue = 1;
	  continue;
	}


      if (const_pool_state == 0)
	{

	  if (GDB_TARGET_IS_ESAME)
	    {
	      /* Check for larl CONST_POOL_REGIDX,offset on ESAME */
	      if ((instr[0] == 0xc0)
		  && (instr[1] == (CONST_POOL_REGIDX << 4)))
		{
		  const_pool_state = 2;
		  valid_prologue = 1;
		  continue;
		}
	    }
	  else
	    {
	      /* Check for BASR gpr13,gpr0 used to load constant pool pointer to r13 in old compiler */
	      if (instr[0] == 0xd && (instr[1] & 0xf) == 0
		  && ((instr[1] >> 4) == CONST_POOL_REGIDX))
		{
		  const_pool_state = 1;
		  valid_prologue = 1;
		  continue;
		}
	    }
	  /* Check for new fangled bras %r13,newpc to load new constant pool */
	  /* embedded in code, older pre abi compilers also emitted this stuff.  */
	  if ((instr[0] == 0xa7) && ((instr[1] & 0xf) == 0x5) &&
	      ((instr[1] >> 4) == CONST_POOL_REGIDX)
	      && ((instr[2] & 0x80) == 0))
	    {
	      const_pool_state = 2;
	      test_pc +=
		(((((instr[2] & 0xf) << 8) + instr[3]) << 1) - instrlen);
	      valid_prologue = 1;
	      continue;
	    }
	}
      /* Check for AGHI or AHI CONST_POOL_REGIDX,val */
      if (const_pool_state == 1 && (instr[0] == 0xa7) &&
	  ((GDB_TARGET_IS_ESAME &&
	    (instr[1] == ((CONST_POOL_REGIDX << 4) | 0xb))) ||
	   (instr[1] == ((CONST_POOL_REGIDX << 4) | 0xa))))
	{
	  const_pool_state = 2;
	  valid_prologue = 1;
	  continue;
	}
      /* Check for LGR or LR gprx,15 */
      if ((GDB_TARGET_IS_ESAME &&
	   instr[0] == 0xb9 && instr[1] == 0x04 && (instr[3] & 0xf) == 0xf) ||
	  (instr[0] == 0x18 && (instr[1] & 0xf) == 0xf))
	{
	  if (GDB_TARGET_IS_ESAME)
	    regidx = instr[3] >> 4;
	  else
	    regidx = instr[1] >> 4;
	  if (save_link_state == 0 && regidx != 0xb)
	    {
	      /* Almost defintely code for
	         decrementing the stack pointer 
	         ( i.e. a non leaf function 
	         or else leaf with locals ) */
	      save_link_regidx = regidx;
	      save_link_state = 1;
	      valid_prologue = 1;
	      continue;
	    }
	  /* We use this frame pointer for alloca
	     unfortunately we need to assume its gpr11
	     otherwise we would need a smarter prologue
	     walker. */
	  if (!frame_pointer_found && regidx == 0xb)
	    {
	      frame_pointer_regidx = 0xb;
	      frame_pointer_found = 1;
	      if (fextra_info)
		fextra_info->frame_pointer_saved_pc = test_pc;
	      valid_prologue = 1;
	      continue;
	    }
	}
      /* Check for AHI or AGHI gpr15,val */
      if (save_link_state == 1 && (instr[0] == 0xa7) &&
	  ((GDB_TARGET_IS_ESAME && (instr[1] == 0xfb)) || (instr[1] == 0xfa)))
	{
	  if (fextra_info)
	    fextra_info->stack_bought =
	      -extract_signed_integer (&instr[2], 2);
	  save_link_state = 3;
	  valid_prologue = 1;
	  continue;
	}
      /* Alternatively check for the complex construction for
         buying more than 32k of stack
         BRAS gprx,.+8
         long val
         s    %r15,0(%gprx)  gprx currently r1 */
      if ((save_link_state == 1) && (instr[0] == 0xa7)
	  && ((instr[1] & 0xf) == 0x5) && (instr[2] == 0)
	  && (instr[3] == 0x4) && ((instr[1] >> 4) != CONST_POOL_REGIDX))
	{
	  subtract_sp_regidx = instr[1] >> 4;
	  save_link_state = 2;
	  if (fextra_info)
	    target_read_memory (test_pc + instrlen,
				(char *) &fextra_info->stack_bought,
				sizeof (fextra_info->stack_bought));
	  test_pc += 4;
	  valid_prologue = 1;
	  continue;
	}
      if (save_link_state == 2 && instr[0] == 0x5b
	  && instr[1] == 0xf0 &&
	  instr[2] == (subtract_sp_regidx << 4) && instr[3] == 0)
	{
	  save_link_state = 3;
	  valid_prologue = 1;
	  continue;
	}
      /* check for LA gprx,offset(15) used for varargs */
      if ((instr[0] == 0x41) && ((instr[2] >> 4) == 0xf) &&
	  ((instr[1] & 0xf) == 0))
	{
	  /* some code uses gpr7 to point to outgoing args */
	  if (((instr[1] >> 4) == 7) && (save_link_state == 0) &&
	      ((instr[2] & 0xf) == 0)
	      && (instr[3] == S390_STACK_FRAME_OVERHEAD))
	    {
	      valid_prologue = 1;
	      continue;
	    }
	  if (varargs_state == 1)
	    {
	      varargs_state = 2;
	      valid_prologue = 1;
	      continue;
	    }
	}
      /* Check for a GOT load */

      if (GDB_TARGET_IS_ESAME)
	{
	  /* Check for larl  GOT_REGIDX, on ESAME */
	  if ((got_state == 0) && (instr[0] == 0xc0)
	      && (instr[1] == (GOT_REGIDX << 4)))
	    {
	      got_state = 2;
	      valid_prologue = 1;
	      continue;
	    }
	}
      else
	{
	  /* check for l GOT_REGIDX,x(CONST_POOL_REGIDX) */
	  if (got_state == 0 && const_pool_state == 2 && instr[0] == 0x58
	      && (instr[2] == (CONST_POOL_REGIDX << 4))
	      && ((instr[1] >> 4) == GOT_REGIDX))
	    {
	      got_state = 1;
              got_load_addr = test_pc;
              got_load_len = instrlen;
	      valid_prologue = 1;
	      continue;
	    }
	  /* Check for subsequent ar got_regidx,basr_regidx */
	  if (got_state == 1 && instr[0] == 0x1a &&
	      instr[1] == ((GOT_REGIDX << 4) | CONST_POOL_REGIDX))
	    {
	      got_state = 2;
	      valid_prologue = 1;
	      continue;
	    }
	}
    }
  while (valid_prologue && good_prologue);
  if (good_prologue)
    {
      /* If this function doesn't reference the global offset table,
         then the compiler may use r12 for other things.  If the last
         instruction we saw was a load of r12 from the constant pool,
         with no subsequent add to make the address PC-relative, then
         the load was probably a genuine body instruction; don't treat
         it as part of the prologue.  */
      if (got_state == 1
          && got_load_addr + got_load_len == test_pc)
d1255 24
a1278 2
          test_pc = got_load_addr;
          instrlen = got_load_len;
d1280 17
d1298 183
a1480 15
      good_prologue = (((const_pool_state == 0) || (const_pool_state == 2)) &&
		       ((save_link_state == 0) || (save_link_state == 4)) &&
		       ((varargs_state == 0) || (varargs_state == 2)));
    }
  if (fextra_info)
    {
      fextra_info->good_prologue = good_prologue;
      fextra_info->skip_prologue_function_start =
	(good_prologue ? test_pc : pc);
    }
  if (saved_regs)
    /* The SP's element of the saved_regs array holds the old SP,
       not the address at which it is saved.  */
    saved_regs[S390_SP_REGNUM] = orig_sp;
  return err;
@


1.105
log
@	* config/arm/linux.mt: Remove code protected by GDBSERVER define.
	* config/arm/nm-linux.h: Likewise.
	* config/arm/tm-linux.h: Likewise.
	* config/ia64/nm-linux.h: Likewise.
	* config/ia64/tm-ia64.h: Likewise.
	* config/s390/tm-linux.h: Likewise.
	* config/s390/tm-s390.h: Likewise.
	* s390-nat.c: Likewise.
	* s390-tdep.c: Likewise.

	* config/i386/linux.mt: Don't set GDBSERVER_DEPFILES.
	* config/ia64/linux.mt: Likewise.
	* config/m68k/linux.mh: Likewise.
	* config/mips/linux.mt: Likewise.
	* config/powerpc/linux.mh: Likewise.
	* config/sh/linux.mt: Likewise.
@
text
@d96 3
a98 1
#define S390_STACK_FRAME_OVERHEAD  (GDB_TARGET_IS_ESAME ? 160:96)
d1336 1
a1336 1
   corresponding union types are handled normally.)  So we exclude
d1359 19
d1389 1
a1389 1
  return ((is_integer_like (type) && length <= 4)
d1391 1
a1391 2
          || (is_struct_like (type) && length != 8)
          || (is_float_like (type) && length == 16));
d1395 6
d1409 2
a1410 2
  return ((is_struct_like (type) && length != 1 && length != 2 && length != 4)
          || (is_float_like (type) && length == 16));
a1432 15
/* Return non-zero if TYPE is a `DOUBLE_ARG', as defined by the
   parameter passing conventions described in the "GNU/Linux for S/390
   ELF Application Binary Interface Supplement".  Return zero
   otherwise.  */
static int
is_double_arg (struct type *type)
{
  unsigned length = TYPE_LENGTH (type);

  return ((is_integer_like (type)
           || is_struct_like (type))
          && length == 8);
}


d1552 3
a1554 3
        /* SIMPLE_ARG values get extended to 32 bits.  Assume every
           argument is.  */
        if (length < 4) length = 4;
d1575 4
d1585 1
a1585 1
            && fr <= 2)
d1612 1
a1612 1
					   VALUE_CONTENTS (arg) + 4);
d1628 3
a1630 3
                /* Simple args are always either extended to 32 bits,
                   or pointers.  */
                starg = round_up (starg, 4);
d1638 3
a1640 2
                  /* Simple args are always extended to 32 bits.  */
                  write_memory_signed_integer (starg, 4,
d1642 1
a1642 1
                starg += 4;
d1649 2
a1650 2
                   a four-byte boundary, even when passing doubles.  */
                starg = round_up (starg, 4);
d1661 1
a1661 1
  sp -= 96;
@


1.105.2.1
log
@Patch from IBM (authors unspecified, probably Ulrich Weigand and
Gerhard Tonn) for argument passing on the S/390 and S/390x:
* s390-tdep.c (S390_STACK_FRAME_OVERHEAD): This is always space
for 16 registers, and then 32 more bytes.
(S390_STACK_PARAMETER_ALIGNMENT, S390_NUM_FP_PARAMETER_REGISTERS):
New macros.
(is_double_arg): The s390x doesn't handle DOUBLE_ARGS specially.
Move up in the file, since it's now used by is_simple_arg.
(is_simple_arg): Don't assume registers are four bytes long.
Exclude all double arguments.  Extended floats are not simple
args.
(is_power_of_two): New function.
(pass_by_copy_ref): Call is_power_of_two, and check that the
length fits in a register, rather than listing all the acceptable
sizes.  Extended floats are not passed by reference.
(s390_push_arguments): Don't assume registers are four bytes long.
Reserve an argument register to point to the buffer for structures
returned by value.  Use S390_NUM_FP_PARAMETER_REGISTERS and
S390_STACK_FRAME_OVERHEAD.
@
text
@d96 1
a96 3
#define S390_STACK_FRAME_OVERHEAD  16*DEPRECATED_REGISTER_SIZE+32
#define S390_STACK_PARAMETER_ALIGNMENT  DEPRECATED_REGISTER_SIZE
#define S390_NUM_FP_PARAMETER_REGISTERS (GDB_TARGET_IS_ESAME ? 4:2)
d1334 1
a1334 1
   corresponding union types are handled normally.)  So we include
a1356 19
/* Return non-zero if TYPE is a `DOUBLE_ARG', as defined by the
   parameter passing conventions described in the "GNU/Linux for S/390
   ELF Application Binary Interface Supplement".  Return zero
   otherwise.  */
static int
is_double_arg (struct type *type)
{
  unsigned length = TYPE_LENGTH (type);

  /* The s390x ABI doesn't handle DOUBLE_ARGS specially.  */
  if (GDB_TARGET_IS_ESAME)
    return 0;

  return ((is_integer_like (type)
           || is_struct_like (type))
          && length == 8);
}


d1368 1
a1368 1
  return ((is_integer_like (type) && length <= DEPRECATED_REGISTER_SIZE)
d1370 2
a1371 1
          || (is_struct_like (type) && !is_double_arg (type)));
a1374 6
static int
is_power_of_two (unsigned int n)
{
  return ((n & (n - 1)) == 0);
}

d1383 2
a1384 2
  return (is_struct_like (type)
          && !(is_power_of_two (length) && length <= DEPRECATED_REGISTER_SIZE));
d1407 15
d1541 3
a1543 3
        /* SIMPLE_ARG values get extended to DEPRECATED_REGISTER_SIZE bytes. 
           Assume every argument is.  */
        if (length < DEPRECATED_REGISTER_SIZE) length = DEPRECATED_REGISTER_SIZE;
a1563 4
    /* A struct is returned using general register 2 */
    if (struct_return)
      gr++;

d1570 1
a1570 1
            && fr <= S390_NUM_FP_PARAMETER_REGISTERS * 2 - 2)
d1597 1
a1597 1
					   VALUE_CONTENTS (arg) + DEPRECATED_REGISTER_SIZE);
d1613 3
a1615 3
                /* Simple args are always extended to 
                   DEPRECATED_REGISTER_SIZE bytes.  */
                starg = round_up (starg, DEPRECATED_REGISTER_SIZE);
d1623 2
a1624 3
                  /* Simple args are always extended to 
                     DEPRECATED_REGISTER_SIZE bytes. */
                  write_memory_signed_integer (starg, DEPRECATED_REGISTER_SIZE,
d1626 1
a1626 1
                starg += DEPRECATED_REGISTER_SIZE;
d1633 2
a1634 2
                   a four/eight-byte boundary, even when passing doubles. */
                starg = round_up (starg, S390_STACK_PARAMETER_ALIGNMENT);
d1645 1
a1645 1
  sp -= S390_STACK_FRAME_OVERHEAD;
@


1.105.2.2
log
@New S390 prologue analyzer.
* s390-tdep.c (struct prologue_value, enum pv_boolean): New types.
(pv_set_to_unknown, pv_set_to_constant, pv_set_to_register,
pv_constant_last, pv_add, pv_add_constant, pv_subtract,
pv_logical_and, pv_is_identical, pv_is_register, pv_is_array_ref,
compute_x_addr, s390_on_stack, s390_store,
s390_get_signal_frame_info): New functions.
(S390_NUM_SPILL_SLOTS): New macro.
(s390_get_frame_info): Rewritten.
(is_arg_reg): Deleted.

Break out the decoding of S/390 instructions into separate
functions, to make it more legible, and easier to check
against the spec.
* s390-tdep.c (is_ri, is_ril, is_rr, is_rre, is_rs, is_rse,
is_rx, is_rxe): New functions.
(op1_aghi, op2_aghi, op1_ahi, op2_ahi, op_ar, op_basr, op1_bras,
op2_bras, op_l, op_la, op1_larl, op2_larl, op_lgr, op1_lghi,
op2_lghi, op1_lhi, op2_lhi, op_lr, op_nr, op_ngr, op_s, op_st,
op_std, op1_stg, op2_stg, op_stm, op1_stmg, op2_stmg, op_svc): New
enums for opcode values.  (Is this an improvement?)
@
text
@d191 2
a192 443
/* Prologue analysis.  */

/* When we analyze a prologue, we're really doing 'abstract
   interpretation' or 'pseudo-evaluation': running the function's code
   in simulation, but using conservative approximations of the values
   it would have when it actually runs.  For example, if our function
   starts with the instruction:

      ahi r1, 42     # add halfword immediate 42 to r1

   we don't know exactly what value will be in r1 after executing this
   instruction, but we do know it'll be 42 greater than its original
   value.

   If we then see an instruction like:

      ahi r1, 22     # add halfword immediate 22 to r1

   we still don't know what r1's value is, but again, we can say it is
   now 64 greater than its original value.

   If the next instruction were:

      lr r2, r1      # set r2 to r1's value

   then we can say that r2's value is now the original value of r1
   plus 64.  And so on.

   Of course, this can only go so far before it gets unreasonable.  If
   we wanted to be able to say anything about the value of r1 after
   the instruction:

      xr r1, r3      # exclusive-or r1 and r3, place result in r1

   then things would get pretty complex.  But remember, we're just
   doing a conservative approximation; if exclusive-or instructions
   aren't relevant to prologues, we can just say r1's value is now
   'unknown'.  We can ignore things that are too complex, if that loss
   of information is acceptable for our application.

   Once you've reached an instruction that you don't know how to
   simulate, you stop.  Now you examine the state of the registers and
   stack slots you've kept track of.  For example:

   - To see how large your stack frame is, just check the value of sp;
     if it's the original value of sp minus a constant, then that
     constant is the stack frame's size.  If the sp's value has been
     marked as 'unknown', then that means the prologue has done
     something too complex for us to track, and we don't know the
     frame size.

   - To see whether we've saved the SP in the current frame's back
     chain slot, we just check whether the current value of the back
     chain stack slot is the original value of the sp.

   Sure, this takes some work.  But prologue analyzers aren't
   quick-and-simple pattern patching to recognize a few fixed prologue
   forms any more; they're big, hairy functions.  Along with inferior
   function calls, prologue analysis accounts for a substantial
   portion of the time needed to stabilize a GDB port.  So I think
   it's worthwhile to look for an approach that will be easier to
   understand and maintain.  In the approach used here:

   - It's easier to see that the analyzer is correct: you just see
     whether the analyzer properly (albiet conservatively) simulates
     the effect of each instruction.

   - It's easier to extend the analyzer: you can add support for new
     instructions, and know that you haven't broken anything that
     wasn't already broken before.

   - It's orthogonal: to gather new information, you don't need to
     complicate the code for each instruction.  As long as your domain
     of conservative values is already detailed enough to tell you
     what you need, then all the existing instruction simulations are
     already gathering the right data for you.

   A 'struct prologue_value' is a conservative approximation of the
   real value the register or stack slot will have.  */

struct prologue_value {

  /* What sort of value is this?  This determines the interpretation
     of subsequent fields.  */
  enum {

    /* We don't know anything about the value.  This is also used for
       values we could have kept track of, when doing so would have
       been too complex and we don't want to bother.  The bottom of
       our lattice.  */
    pv_unknown,

    /* A known constant.  K is its value.  */
    pv_constant,

    /* The value that register REG originally had *UPON ENTRY TO THE
       FUNCTION*, plus K.  If K is zero, this means, obviously, just
       the value REG had upon entry to the function.  REG is a GDB
       register number.  Before we start interpreting, we initialize
       every register R to { pv_register, R, 0 }.  */
    pv_register,

  } kind;

  /* The meanings of the following fields depend on 'kind'; see the
     comments for the specific 'kind' values.  */
  int reg;
  CORE_ADDR k;
};


/* Set V to be unknown.  */
static void
pv_set_to_unknown (struct prologue_value *v)
{
  v->kind = pv_unknown;
}


/* Set V to the constant K.  */
static void
pv_set_to_constant (struct prologue_value *v, CORE_ADDR k)
{
  v->kind = pv_constant;
  v->k = k;
}


/* Set V to the original value of register REG, plus K.  */
static void
pv_set_to_register (struct prologue_value *v, int reg, CORE_ADDR k)
{
  v->kind = pv_register;
  v->reg = reg;
  v->k = k;
}


/* If one of *A and *B is a constant, and the other isn't, swap the
   pointers as necessary to ensure that *B points to the constant.
   This can reduce the number of cases we need to analyze in the
   functions below.  */
static void
pv_constant_last (struct prologue_value **a,
                  struct prologue_value **b)
{
  if ((*a)->kind == pv_constant
      && (*b)->kind != pv_constant)
    {
      struct prologue_value *temp = *a;
      *a = *b;
      *b = temp;
    }
}


/* Set SUM to the sum of A and B.  SUM, A, and B may point to the same
   'struct prologue_value' object.  */
static void
pv_add (struct prologue_value *sum,
        struct prologue_value *a,
        struct prologue_value *b)
{
  pv_constant_last (&a, &b);

  /* We can handle adding constants to registers, and other constants.  */
  if (b->kind == pv_constant
      && (a->kind == pv_register
          || a->kind == pv_constant))
    {
      sum->kind = a->kind;
      sum->reg = a->reg;    /* not meaningful if a is pv_constant, but
                               harmless */
      sum->k = a->k + b->k;
    }

  /* Anything else we don't know how to add.  We don't have a
     representation for, say, the sum of two registers, or a multiple
     of a register's value (adding a register to itself).  */
  else
    sum->kind = pv_unknown;
}


/* Add the constant K to V.  */
static void
pv_add_constant (struct prologue_value *v, CORE_ADDR k)
{
  struct prologue_value pv_k;

  /* Rather than thinking of all the cases we can and can't handle,
     we'll just let pv_add take care of that for us.  */
  pv_set_to_constant (&pv_k, k);
  pv_add (v, v, &pv_k);
}


/* Subtract B from A, and put the result in DIFF.

   This isn't quite the same as negating B and adding it to A, since
   we don't have a representation for the negation of anything but a
   constant.  For example, we can't negate { pv_register, R1, 10 },
   but we do know that { pv_register, R1, 10 } minus { pv_register,
   R1, 5 } is { pv_constant, <ignored>, 5 }.

   This means, for example, that we can subtract two stack addresses;
   they're both relative to the original SP.  Since the frame pointer
   is set based on the SP, its value will be the original SP plus some
   constant (probably zero), so we can use its value just fine.  */
static void
pv_subtract (struct prologue_value *diff,
             struct prologue_value *a,
             struct prologue_value *b)
{
  pv_constant_last (&a, &b);

  /* We can subtract a constant from another constant, or from a
     register.  */
  if (b->kind == pv_constant
      && (a->kind == pv_register
          || a->kind == pv_constant))
    {
      diff->kind = a->kind;
      diff->reg = a->reg;    /* not always meaningful, but harmless */
      diff->k = a->k - b->k;
    }

  /* We can subtract a register from itself, yielding a constant.  */
  else if (a->kind == pv_register
           && b->kind == pv_register
           && a->reg == b->reg)
    {
      diff->kind = pv_constant;
      diff->k = a->k - b->k;
    }

  /* We don't know how to subtract anything else.  */
  else
    diff->kind = pv_unknown;
}


/* Set AND to the logical and of A and B.  */
static void
pv_logical_and (struct prologue_value *and,
                struct prologue_value *a,
                struct prologue_value *b)
{
  pv_constant_last (&a, &b);

  /* We can 'and' two constants.  */
  if (a->kind == pv_constant
      && b->kind == pv_constant)
    {
      and->kind = pv_constant;
      and->k = a->k & b->k;
    }

  /* We can 'and' anything with the constant zero.  */
  else if (b->kind == pv_constant
           && b->k == 0)
    {
      and->kind = pv_constant;
      and->k = 0;
    }
  
  /* We can 'and' anything with ~0.  */
  else if (b->kind == pv_constant
           && b->k == ~ (CORE_ADDR) 0)
    *and = *a;

  /* We can 'and' a register with itself.  */
  else if (a->kind == pv_register
           && b->kind == pv_register
           && a->reg == b->reg
           && a->k == b->k)
    *and = *a;

  /* Otherwise, we don't know.  */
  else
    pv_set_to_unknown (and);
}


/* Return non-zero iff A and B are identical expressions.

   This is not the same as asking if the two values are equal; the
   result of such a comparison would have to be a pv_boolean, and
   asking whether two 'unknown' values were equal would give you
   pv_maybe.  Same for comparing, say, { pv_register, R1, 0 } and {
   pv_register, R2, 0}.  Instead, this is asking whether the two
   representations are the same.  */
static int
pv_is_identical (struct prologue_value *a,
                 struct prologue_value *b)
{
  if (a->kind != b->kind)
    return 0;

  switch (a->kind)
    {
    case pv_unknown:
      return 1;
    case pv_constant:
      return (a->k == b->k);
    case pv_register:
      return (a->reg == b->reg && a->k == b->k);
    default:
      gdb_assert (0);
    }
}


/* Return non-zero if A is the original value of register number R
   plus K, zero otherwise.  */
static int
pv_is_register (struct prologue_value *a, int r, CORE_ADDR k)
{
  return (a->kind == pv_register
          && a->reg == r
          && a->k == k);
}


/* A prologue-value-esque boolean type, including "maybe", when we
   can't figure out whether something is true or not.  */
enum pv_boolean {
  pv_maybe,
  pv_definite_yes,
  pv_definite_no,
};


/* Decide whether a reference to SIZE bytes at ADDR refers exactly to
   an element of an array.  The array starts at ARRAY_ADDR, and has
   ARRAY_LEN values of ELT_SIZE bytes each.  If ADDR definitely does
   refer to an array element, set *I to the index of the referenced
   element in the array, and return pv_definite_yes.  If it definitely
   doesn't, return pv_definite_no.  If we can't tell, return pv_maybe.

   If the reference does touch the array, but doesn't fall exactly on
   an element boundary, or doesn't refer to the whole element, return
   pv_maybe.  */
static enum pv_boolean
pv_is_array_ref (struct prologue_value *addr,
                 CORE_ADDR size,
                 struct prologue_value *array_addr,
                 CORE_ADDR array_len, 
                 CORE_ADDR elt_size,
                 int *i)
{
  struct prologue_value offset;

  /* Note that, since ->k is a CORE_ADDR, and CORE_ADDR is unsigned,
     if addr is *before* the start of the array, then this isn't going
     to be negative...  */
  pv_subtract (&offset, addr, array_addr);

  if (offset.kind == pv_constant)
    {
      /* This is a rather odd test.  We want to know if the SIZE bytes
         at ADDR don't overlap the array at all, so you'd expect it to
         be an || expression: "if we're completely before || we're
         completely after".  But with unsigned arithmetic, things are
         different: since it's a number circle, not a number line, the
         right values for offset.k are actually one contiguous range.  */
      if (offset.k <= -size
          && offset.k >= array_len * elt_size)
        return pv_definite_no;
      else if (offset.k % elt_size != 0
               || size != elt_size)
        return pv_maybe;
      else
        {
          *i = offset.k / elt_size;
          return pv_definite_yes;
        }
    }
  else
    return pv_maybe;
}



/* Decoding S/390 instructions.  */

/* Named opcode values for the S/390 instructions we recognize.  Some
   instructions have their opcode split across two fields; those are the
   op1_* and op2_* enums.  */
enum
  {
    op1_aghi = 0xa7,   op2_aghi = 0xb,
    op1_ahi  = 0xa7,   op2_ahi  = 0xa,
    op_ar    = 0x1a,
    op_basr  = 0x0d,
    op1_bras = 0xa7,   op2_bras = 0x5,
    op_l     = 0x58,
    op_la    = 0x41,
    op1_larl = 0xc0,   op2_larl = 0x0,
    op_lgr   = 0xb904,
    op1_lghi = 0xa7,   op2_lghi = 0x9,
    op1_lhi  = 0xa7,   op2_lhi  = 0x8,
    op_lr    = 0x18,
    op_nr    = 0x14,
    op_ngr   = 0xb980,
    op_s     = 0x5b,
    op_st    = 0x50,
    op_std   = 0x60,
    op1_stg  = 0xe3,   op2_stg  = 0x24,
    op_stm   = 0x90,
    op1_stmg = 0xeb,   op2_stmg = 0x24,
    op_svc   = 0x0a,
  };


/* The functions below are for recognizing and decoding S/390
   instructions of various formats.  Each of them checks whether INSN
   is an instruction of the given format, with the specified opcodes.
   If it is, it sets the remaining arguments to the values of the
   instruction's fields, and returns a non-zero value; otherwise, it
   returns zero.

   These functions' arguments appear in the order they appear in the
   instruction, not in the machine-language form.  So, opcodes always
   come first, even though they're sometimes scattered around the
   instructions.  And displacements appear before base and extension
   registers, as they do in the assembly syntax, not at the end, as
   they do in the machine language.  */
static int
is_ri (bfd_byte *insn, int op1, int op2, unsigned int *r1, int *i2)
{
  if (insn[0] == op1 && (insn[1] & 0xf) == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      /* i2 is a 16-bit signed quantity.  */
      *i2 = (((insn[2] << 8) | insn[3]) ^ 0x8000) - 0x8000;
      return 1;
    }
  else
    return 0;
}


d194 1
a194 2
is_ril (bfd_byte *insn, int op1, int op2,
        unsigned int *r1, int *i2)
d196 1
a196 14
  if (insn[0] == op1 && (insn[1] & 0xf) == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      /* i2 is a signed quantity.  If the host 'int' is 32 bits long,
         no sign extension is necessary, but we don't want to assume
         that.  */
      *i2 = (((insn[2] << 24)
              | (insn[3] << 16)
              | (insn[4] << 8)
              | (insn[5])) ^ 0x80000000) - 0x80000000;
      return 1;
    }
  else
    return 0;
d200 32
a231 284
static int
is_rr (bfd_byte *insn, int op, unsigned int *r1, unsigned int *r2)
{
  if (insn[0] == op)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *r2 = insn[1] & 0xf;
      return 1;
    }
  else
    return 0;
}


static int
is_rre (bfd_byte *insn, int op, unsigned int *r1, unsigned int *r2)
{
  if (((insn[0] << 8) | insn[1]) == op)
    {
      /* Yes, insn[3].  insn[2] is unused in RRE format.  */
      *r1 = (insn[3] >> 4) & 0xf;
      *r2 = insn[3] & 0xf;
      return 1;
    }
  else
    return 0;
}


static int
is_rs (bfd_byte *insn, int op,
       unsigned int *r1, unsigned int *r3, unsigned int *d2, unsigned int *b2)
{
  if (insn[0] == op)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *r3 = insn[1] & 0xf;
      *b2 = (insn[2] >> 4) & 0xf;
      *d2 = ((insn[2] & 0xf) << 8) | insn[3];
      return 1;
    }
  else
    return 0;
}


static int
is_rse (bfd_byte *insn, int op1, int op2,
        unsigned int *r1, unsigned int *r3, unsigned int *d2, unsigned int *b2)
{
  if (insn[0] == op1
      /* Yes, insn[5].  insn[4] is unused.  */
      && insn[5] == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *r3 = insn[1] & 0xf;
      *b2 = (insn[2] >> 4) & 0xf;
      *d2 = ((insn[2] & 0xf) << 8) | insn[3];
      return 1;
    }
  else
    return 0;
}


static int
is_rx (bfd_byte *insn, int op,
       unsigned int *r1, unsigned int *d2, unsigned int *x2, unsigned int *b2)
{
  if (insn[0] == op)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *x2 = insn[1] & 0xf;
      *b2 = (insn[2] >> 4) & 0xf;
      *d2 = ((insn[2] & 0xf) << 8) | insn[3];
      return 1;
    }
  else
    return 0;
}


static int
is_rxe (bfd_byte *insn, int op1, int op2,
        unsigned int *r1, unsigned int *d2, unsigned int *x2, unsigned int *b2)
{
  if (insn[0] == op1
      /* Yes, insn[5].  insn[4] is unused.  */
      && insn[5] == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *x2 = insn[1] & 0xf;
      *b2 = (insn[2] >> 4) & 0xf;
      *d2 = ((insn[2] & 0xf) << 8) | insn[3];
      return 1;
    }
  else
    return 0;
}


/* Set ADDR to the effective address for an X-style instruction, like:

        L R1, D2(X2, B2)

   Here, X2 and B2 are registers, and D2 is an unsigned 12-bit
   constant; the effective address is the sum of all three.  If either
   X2 or B2 are zero, then it doesn't contribute to the sum --- this
   means that r0 can't be used as either X2 or B2.

   GPR is an array of general register values, indexed by GPR number,
   not GDB register number.  */
static void
compute_x_addr (struct prologue_value *addr, 
                struct prologue_value *gpr,
                unsigned int d2, unsigned int x2, unsigned int b2)
{
  /* We can't just add stuff directly in addr; it might alias some of
     the registers we need to read.  */
  struct prologue_value result;

  pv_set_to_constant (&result, d2);
  if (x2)
    pv_add (&result, &result, &gpr[x2]);
  if (b2)
    pv_add (&result, &result, &gpr[b2]);

  *addr = result;
}


/* The number of GPR and FPR spill slots in an S/390 stack frame.  We
   track general-purpose registers r2 -- r15, and floating-point
   registers f0, f2, f4, and f6.  */
#define S390_NUM_SPILL_SLOTS (14 + 4)


/* If the SIZE bytes at ADDR are a stack slot we're actually tracking,
   return pv_definite_yes and set *STACK to point to the slot.  If
   we're sure that they are not any of our stack slots, then return
   pv_definite_no.  Otherwise, return pv_maybe.
   - GPR is an array indexed by GPR number giving the current values
     of the general-purpose registers.
   - SPILL is an array tracking the spill area of the caller's frame;
     SPILL[i] is the i'th spill slot.  The spill slots are designated
     for r2 -- r15, and then f0, f2, f4, and f6.
   - BACK_CHAIN is the value of the back chain slot; it's only valid
     when the current frame actually has some space for a back chain
     slot --- that is, when the current value of the stack pointer
     (according to GPR) is at least S390_STACK_FRAME_OVERHEAD bytes
     less than its original value.  */
static enum pv_boolean
s390_on_stack (struct prologue_value *addr,
               CORE_ADDR size,
               struct prologue_value *gpr,
               struct prologue_value *spill, 
               struct prologue_value *back_chain,
               struct prologue_value **stack)
{
  struct prologue_value gpr_spill_addr;
  struct prologue_value fpr_spill_addr;
  struct prologue_value back_chain_addr;  
  int i;
  enum pv_boolean b;

  /* Construct the addresses of the spill arrays and the back chain.  */
  pv_set_to_register (&gpr_spill_addr, S390_SP_REGNUM, 2 * S390_GPR_SIZE);
  pv_set_to_register (&fpr_spill_addr, S390_SP_REGNUM, 16 * S390_GPR_SIZE);
  back_chain_addr = gpr[S390_SP_REGNUM - S390_GP0_REGNUM];

  /* We have to check for GPR and FPR references using two separate
     calls to pv_is_array_ref, since the GPR and FPR spill slots are
     different sizes.  (SPILL is an array, but the thing it tracks
     isn't really an array.)  */

  /* Was it a reference to the GPR spill array?  */
  b = pv_is_array_ref (addr, size, &gpr_spill_addr, 14, S390_GPR_SIZE, &i);
  if (b == pv_definite_yes)
    {
      *stack = &spill[i];
      return pv_definite_yes;
    }
  if (b == pv_maybe)
    return pv_maybe;

  /* Was it a reference to the FPR spill array?  */
  b = pv_is_array_ref (addr, size, &fpr_spill_addr, 4, S390_FPR_SIZE, &i);
  if (b == pv_definite_yes)
    {
      *stack = &spill[14 + i];
      return pv_definite_yes;
    }
  if (b == pv_maybe)
    return pv_maybe;

  /* Was it a reference to the back chain?
     This isn't quite right.  We ought to check whether we have
     actually allocated any new frame at all.  */
  b = pv_is_array_ref (addr, size, &back_chain_addr, 1, S390_GPR_SIZE, &i);
  if (b == pv_definite_yes)
    {
      *stack = back_chain;
      return pv_definite_yes;
    }
  if (b == pv_maybe)
    return pv_maybe;

  /* All the above queries returned definite 'no's.  */
  return pv_definite_no;
}


/* Do a SIZE-byte store of VALUE to ADDR.  GPR, SPILL, and BACK_CHAIN,
   and the return value are as described for s390_on_stack, above.
   Note that, when this returns pv_maybe, we have to assume that all
   of our memory now contains unknown values.  */
static enum pv_boolean
s390_store (struct prologue_value *addr,
            CORE_ADDR size,
            struct prologue_value *value,
            struct prologue_value *gpr,
            struct prologue_value *spill, 
            struct prologue_value *back_chain)
{
  struct prologue_value *stack;
  enum pv_boolean on_stack
    = s390_on_stack (addr, size, gpr, spill, back_chain, &stack);

  if (on_stack == pv_definite_yes)
    *stack = *value;

  return on_stack;
}
            

/* The current frame looks like a signal delivery frame: the first
   instruction is an 'svc' opcode.  If the next frame is a signal
   handler's frame, set FI's saved register map to point into the
   signal context structure.  */
static void
s390_get_signal_frame_info (struct frame_info *fi)
{
  struct frame_info *next_frame = get_next_frame (fi);

  if (next_frame
      && get_frame_extra_info (next_frame)
      && get_frame_extra_info (next_frame)->sigcontext)
    {
      /* We're definitely backtracing from a signal handler.  */
      CORE_ADDR *saved_regs = get_frame_saved_regs (fi);
      CORE_ADDR save_reg_addr = (get_frame_extra_info (next_frame)->sigcontext
                                 + REGISTER_BYTE (S390_GP0_REGNUM));
      int reg;

      for (reg = 0; reg < S390_NUM_GPRS; reg++)
        {
          saved_regs[S390_GP0_REGNUM + reg] = save_reg_addr;
          save_reg_addr += S390_GPR_SIZE;
        }

      save_reg_addr = (get_frame_extra_info (next_frame)->sigcontext
                       + (GDB_TARGET_IS_ESAME ? S390X_SIGREGS_FP0_OFFSET :
                          S390_SIGREGS_FP0_OFFSET));
      for (reg = 0; reg < S390_NUM_FPRS; reg++)
        {
          saved_regs[S390_FP0_REGNUM + reg] = save_reg_addr;
          save_reg_addr += S390_FPR_SIZE;
        }
    }
}


static int
s390_get_frame_info (CORE_ADDR start_pc,
                     struct frame_extra_info *fextra_info,
                     struct frame_info *fi,
                     int init_extra_info)
{
  /* Our return value:
     zero if we were able to read all the instructions we wanted, or
     -1 if we got an error trying to read memory.  */
  int result = 0;

  /* We just use this for reading instructions.  */
d234 45
a278 2
  /* The current PC for our abstract interpretation.  */
  CORE_ADDR pc;
d280 1
a280 23
  /* The address of the next instruction after that.  */
  CORE_ADDR next_pc;
  
  /* The general-purpose registers.  */
  struct prologue_value gpr[S390_NUM_GPRS];

  /* The floating-point registers.  */
  struct prologue_value fpr[S390_NUM_FPRS];

  /* The register spill stack slots in the caller's frame ---
     general-purpose registers r2 through r15, and floating-point
     registers.  spill[i] is where gpr i+2 gets spilled;
     spill[(14, 15, 16, 17)] is where (f0, f2, f4, f6) get spilled.  */
  struct prologue_value spill[S390_NUM_SPILL_SLOTS];

  /* The value of the back chain slot.  This is only valid if the stack
     pointer is known to be less than its original value --- that is,
     if we have indeed allocated space on the stack.  */
  struct prologue_value back_chain;

  /* The address of the instruction after the last one that changed
     the SP, FP, or back chain.  */
  CORE_ADDR after_last_frame_setup_insn = start_pc;
d282 2
d286 2
a287 21
  /* Set up everything's initial value.  */
  {
    int i;

    for (i = 0; i < S390_NUM_GPRS; i++)
      pv_set_to_register (&gpr[i], S390_GP0_REGNUM + i, 0);

    for (i = 0; i < S390_NUM_FPRS; i++)
      pv_set_to_register (&fpr[i], S390_FP0_REGNUM + i, 0);

    for (i = 0; i < S390_NUM_SPILL_SLOTS; i++)
      pv_set_to_unknown (&spill[i]);

    pv_set_to_unknown (&back_chain);
  }

  /* Start interpreting instructions, until we hit something we don't
     know how to interpret.  (Ideally, we should stop at the frame's
     real current PC, but at the moment, our callers don't give us
     that info.)  */
  for (pc = start_pc; ; pc = next_pc)
d289 367
a655 69
      bfd_byte insn[S390_MAX_INSTR_SIZE];
      int insn_len = s390_readinstruction (insn, pc, &info);

      /* Fields for various kinds of instructions.  */
      unsigned int b2, r1, r2, d2, x2, r3;
      int i2;

      /* The values of SP, FP, and back chain before this instruction,
         for detecting instructions that change them.  */
      struct prologue_value pre_insn_sp, pre_insn_fp, pre_insn_back_chain;

      /* If we got an error trying to read the instruction, report it.  */
      if (insn_len < 0)
        {
          result = -1;
          break;
        }

      next_pc = pc + insn_len;

      pre_insn_sp = gpr[S390_SP_REGNUM - S390_GP0_REGNUM];
      pre_insn_fp = gpr[S390_FRAME_REGNUM - S390_GP0_REGNUM];
      pre_insn_back_chain = back_chain;

      /* A special case, first --- only recognized as the very first
         instruction of the function, for signal delivery frames:
         SVC i --- system call  */
      if (pc == start_pc
          && is_rr (insn, op_svc, &r1, &r2))
        {
          if (fi)
            s390_get_signal_frame_info (fi);
          break;
        }
        
      /* AHI r1, i2 --- add halfword immediate */
      else if (is_ri (insn, op1_ahi, op2_ahi, &r1, &i2))
        pv_add_constant (&gpr[r1], i2);


      /* AGHI r1, i2 --- add halfword immediate (64-bit version) */
      else if (GDB_TARGET_IS_ESAME
               && is_ri (insn, op1_aghi, op2_aghi, &r1, &i2))
        pv_add_constant (&gpr[r1], i2);

      /* AR r1, r2 -- add register */
      else if (is_rr (insn, op_ar, &r1, &r2))
        pv_add (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* BASR r1, 0 --- branch and save
         Since r2 is zero, this saves the PC in r1, but doesn't branch.  */
      else if (is_rr (insn, op_basr, &r1, &r2)
               && r2 == 0)
        pv_set_to_constant (&gpr[r1], next_pc);

      /* BRAS r1, i2 --- branch relative and save */
      else if (is_ri (insn, op1_bras, op2_bras, &r1, &i2))
        {
          pv_set_to_constant (&gpr[r1], next_pc);
          next_pc = pc + i2 * 2;

          /* We'd better not interpret any backward branches.  We'll
             never terminate.  */
          if (next_pc <= pc)
            break;
        }

      /* L r1, d2(x2, b2) --- load */
      else if (is_rx (insn, op_l, &r1, &d2, &x2, &b2))
d657 2
a658 217
          struct prologue_value addr;
          struct prologue_value *stack;

          compute_x_addr (&addr, gpr, d2, x2, b2);

          /* If it's a load from an in-line constant pool, then we can
             simulate that, under the assumption that the code isn't
             going to change between the time the processor actually
             executed it creating the current frame, and the time when
             we're analyzing the code to unwind past that frame.  */
          if (addr.kind == pv_constant
              && start_pc <= addr.k 
              && addr.k < next_pc)
            pv_set_to_constant (&gpr[r1], 
                                read_memory_integer (addr.k, 4));

          /* If it's definitely a reference to something on the stack, 
             we can do that.  */
          else if (s390_on_stack (&addr, 4, gpr, spill, &back_chain, &stack)
                   == pv_definite_yes)
            gpr[r1] = *stack;

          /* Otherwise, we don't know the value.  */
          else
            pv_set_to_unknown (&gpr[r1]);
        }

      /* LA r1, d2(x2, b2) --- load address */
      else if (is_rx (insn, op_la, &r1, &d2, &x2, &b2))
        compute_x_addr (&gpr[r1], gpr, d2, x2, b2);

      /* LARL r1, i2 --- load address relative long */
      else if (GDB_TARGET_IS_ESAME 
               && is_ril (insn, op1_larl, op2_larl, &r1, &i2))
        pv_set_to_constant (&gpr[r1], pc + i2 * 2);

      /* LGR r1, r2 --- load from register */
      else if (GDB_TARGET_IS_ESAME
               && is_rre (insn, op_lgr, &r1, &r2))
        gpr[r1] = gpr[r2];

      /* LHI r1, i2 --- load halfword immediate */
      else if (is_ri (insn, op1_lhi, op2_lhi, &r1, &i2))
        pv_set_to_constant (&gpr[r1], i2);

      /* LGHI r1, i2 --- load halfword immediate --- 64-bit version */
      else if (is_ri (insn, op1_lghi, op2_lghi, &r1, &i2))
        pv_set_to_constant (&gpr[r1], i2);

      /* LR r1, r2 --- load from register */
      else if (is_rr (insn, op_lr, &r1, &r2))
        gpr[r1] = gpr[r2];

      /* NGR r1, r2 --- logical and --- 64-bit version */
      else if (GDB_TARGET_IS_ESAME
               && is_rre (insn, op_ngr, &r1, &r2))
        pv_logical_and (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* NR r1, r2 --- logical and */
      else if (is_rr (insn, op_nr, &r1, &r2))
        pv_logical_and (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* NGR r1, r2 --- logical and --- 64-bit version */
      else if (GDB_TARGET_IS_ESAME
               && is_rre (insn, op_ngr, &r1, &r2))
        pv_logical_and (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* NR r1, r2 --- logical and */
      else if (is_rr (insn, op_nr, &r1, &r2))
        pv_logical_and (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* S r1, d2(x2, b2) --- subtract from memory */
      else if (is_rx (insn, op_s, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;
          struct prologue_value value;
          struct prologue_value *stack;

          compute_x_addr (&addr, gpr, d2, x2, b2);

          /* If it's a load from an in-line constant pool, then we can
             simulate that, under the assumption that the code isn't
             going to change between the time the processor actually
             executed it and the time when we're analyzing it.  */
          if (addr.kind == pv_constant
              && start_pc <= addr.k 
              && addr.k < pc)
            pv_set_to_constant (&value, read_memory_integer (addr.k, 4));

          /* If it's definitely a reference to something on the stack,
             we could do that.  */
          else if (s390_on_stack (&addr, 4, gpr, spill, &back_chain, &stack)
                   == pv_definite_yes)
            value = *stack;

          /* Otherwise, we don't know the value.  */
          else
            pv_set_to_unknown (&value);

          pv_subtract (&gpr[r1], &gpr[r1], &value);
        }

      /* ST r1, d2(x2, b2) --- store  */
      else if (is_rx (insn, op_st, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;

          compute_x_addr (&addr, gpr, d2, x2, b2);

          /* The below really should be '4', not 'S390_GPR_SIZE'; this
             instruction always stores 32 bits, regardless of the full
             size of the GPR.  */
          if (s390_store (&addr, 4, &gpr[r1], gpr, spill, &back_chain)
              == pv_maybe)
            /* If we can't be sure that it's *not* a store to
               something we're tracing, then we would have to mark all
               our memory as unknown --- after all, it *could* be a
               store to any of them --- so we might as well just stop
               interpreting.  */
            break;
        }

      /* STD r1, d2(x2,b2) --- store floating-point register  */
      else if (is_rx (insn, op_std, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;

          compute_x_addr (&addr, gpr, d2, x2, b2);

          if (s390_store (&addr, 8, &fpr[r1], gpr, spill, &back_chain)
              == pv_maybe)
            /* If we can't be sure that it's *not* a store to
               something we're tracing, then we would have to mark all
               our memory as unknown --- after all, it *could* be a
               store to any of them --- so we might as well just stop
               interpreting.  */
            break;
        }

      /* STG r1, d2(x2, b2) --- 64-bit store */
      else if (GDB_TARGET_IS_ESAME
               && is_rxe (insn, op1_stg, op2_stg, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;

          compute_x_addr (&addr, gpr, d2, x2, b2);

          /* The below really should be '8', not 'S390_GPR_SIZE'; this
             instruction always stores 64 bits, regardless of the full
             size of the GPR.  */
          if (s390_store (&addr, 8, &gpr[r1], gpr, spill, &back_chain)
              == pv_maybe)
            /* If we can't be sure that it's *not* a store to
               something we're tracing, then we would have to mark all
               our memory as unknown --- after all, it *could* be a
               store to any of them --- so we might as well just stop
               interpreting.  */
            break;
        }

      /* STM r1, r3, d2(b2) --- store multiple */
      else if (is_rs (insn, op_stm, &r1, &r3, &d2, &b2))
        {
          int regnum;
          int offset;
          struct prologue_value addr;

          for (regnum = r1, offset = 0;
               regnum <= r3;
               regnum++, offset += 4)
            {
              compute_x_addr (&addr, gpr, d2 + offset, 0, b2);
              
              if (s390_store (&addr, 4, &gpr[regnum], gpr, spill, &back_chain)
                  == pv_maybe)
                /* If we can't be sure that it's *not* a store to
                   something we're tracing, then we would have to mark all
                   our memory as unknown --- after all, it *could* be a
                   store to any of them --- so we might as well just stop
                   interpreting.  */
                break;
            }

          /* If we left the loop early, we should stop interpreting
             altogether.  */
          if (regnum <= r3)
            break;
        }

      /* STMG r1, r3, d2(b2) --- store multiple, 64-bit */
      else if (GDB_TARGET_IS_ESAME
               && is_rse (insn, op1_stmg, op2_stmg, &r1, &r3, &d2, &b2))
        {
          int regnum;
          int offset;
          struct prologue_value addr;

          for (regnum = r1, offset = 0;
               regnum <= r3;
               regnum++, offset += 8)
            {
              compute_x_addr (&addr, gpr, d2 + offset, 0, b2);
              
              if (s390_store (&addr, 8, &gpr[regnum], gpr, spill, &back_chain)
                  == pv_maybe)
                /* If we can't be sure that it's *not* a store to
                   something we're tracing, then we would have to mark all
                   our memory as unknown --- after all, it *could* be a
                   store to any of them --- so we might as well just stop
                   interpreting.  */
                break;
            }

          /* If we left the loop early, we should stop interpreting
             altogether.  */
          if (regnum <= r3)
            break;
a659 17

      else
        /* An instruction we don't know how to simulate.  The only
           safe thing to do would be to set every value we're tracking
           to 'unknown'.  Instead, we'll be optimistic: we just stop
           interpreting, and assume that the machine state we've got
           now is good enough for unwinding the stack.  */
        break;

      /* Record the address after the last instruction that changed
         the FP, SP, or backlink.  Ignore instructions that changed
         them back to their original values --- those are probably
         restore instructions.  (The back chain is never restored,
         just popped.)  */
      {
        struct prologue_value *sp = &gpr[S390_SP_REGNUM - S390_GP0_REGNUM];
        struct prologue_value *fp = &gpr[S390_FRAME_REGNUM - S390_GP0_REGNUM];
d661 15
a675 183
        if ((! pv_is_identical (&pre_insn_sp, sp)
             && ! pv_is_register (sp, S390_SP_REGNUM, 0))
            || (! pv_is_identical (&pre_insn_fp, fp)
                && ! pv_is_register (fp, S390_FRAME_REGNUM, 0))
            || ! pv_is_identical (&pre_insn_back_chain, &back_chain))
          after_last_frame_setup_insn = next_pc;
      }
    }

  /* Okay, now gpr[], fpr[], spill[], and back_chain reflect the state
     of the machine as of the first instruction we couldn't interpret
     (hopefully the first non-prologue instruction).  */
  {
    /* The size of the frame, or (CORE_ADDR) -1 if we couldn't figure
       that out.  */
    CORE_ADDR frame_size = -1;

    /* The value the SP had upon entry to the function, or
       (CORE_ADDR) -1 if we can't figure that out.  */
    CORE_ADDR original_sp = -1;

    /* Are we using S390_FRAME_REGNUM as a frame pointer register?  */
    int using_frame_pointer = 0;

    /* If S390_FRAME_REGNUM is some constant offset from the SP, then
       that strongly suggests that we're going to use that as our
       frame pointer register, not the SP.  */
    {
      struct prologue_value *fp = &gpr[S390_FRAME_REGNUM - S390_GP0_REGNUM];

      if (fp->kind == pv_register
          && fp->reg == S390_SP_REGNUM)
        using_frame_pointer = 1;
    }

    /* If we were given a frame_info structure, we may be able to use
       the frame's base address to figure out the actual value of the
       original SP.  */
    if (fi && get_frame_base (fi))
      {
        int frame_base_regno;
        struct prologue_value *frame_base;

        /* The meaning of the frame base depends on whether the
           function uses a frame pointer register other than the SP or
           not (see s390_read_fp):
           - If the function does use a frame pointer register other
             than the SP, then the frame base is that register's
             value.
           - If the function doesn't use a frame pointer, then the
             frame base is the SP itself.
           We're duplicating some of the logic of s390_fp_regnum here,
           but we don't want to call that, because it would just do
           exactly the same analysis we've already done above.  */
        if (using_frame_pointer)
          frame_base_regno = S390_FRAME_REGNUM;
        else
          frame_base_regno = S390_SP_REGNUM;

        frame_base = &gpr[frame_base_regno - S390_GP0_REGNUM];

        /* We know the frame base address; if the value of whatever
           register it came from is a constant offset from the
           original SP, then we can reconstruct the original SP just
           by subtracting off that constant.  */
        if (frame_base->kind == pv_register
            && frame_base->reg == S390_SP_REGNUM)
          original_sp = get_frame_base (fi) - frame_base->k;
      }

    /* If the analysis said that the current SP value is the original
       value less some constant, then that constant is the frame size.  */
    {
      struct prologue_value *sp = &gpr[S390_SP_REGNUM - S390_GP0_REGNUM];

      if (sp->kind == pv_register
          && sp->reg == S390_SP_REGNUM)
        frame_size = -sp->k;
    }

    /* If we knew other registers' current values, we could check if
       the analysis said any of those were related to the original SP
       value, too.  But for now, we'll just punt.  */

    /* If the caller passed in an 'extra info' structure, fill in the
       parts we can.  */
    if (fextra_info)
      {
        if (init_extra_info || ! fextra_info->initialised)
          {
            s390_memset_extra_info (fextra_info);
            fextra_info->function_start = start_pc;
            fextra_info->initialised = 1;
          }

        if (frame_size != -1)
          {
            fextra_info->stack_bought = frame_size;
          }

        /* Assume everything was okay, and indicate otherwise when we
           find something amiss.  */
        fextra_info->good_prologue = 1;

        if (using_frame_pointer)
          /* Actually, nobody cares about the exact PC, so any
             non-zero value will do here.  */
          fextra_info->frame_pointer_saved_pc = 1;

        /* If we weren't able to find the size of the frame, or find
           the original sp based on actual current register values,
           then we're not going to be able to unwind this frame.

           (If we're just doing prologue analysis to set a breakpoint,
           then frame_size might be known, but original_sp unknown; if
           we're analyzing a real frame which uses alloca, then
           original_sp might be known (from the frame pointer
           register), but the frame size might be unknown.)  */
        if (original_sp == -1 && frame_size == -1)
          fextra_info->good_prologue = 0;
        
        if (fextra_info->good_prologue)
          fextra_info->skip_prologue_function_start
            = after_last_frame_setup_insn;
        else 
          /* If the prologue was too complex for us to make sense of,
             then perhaps it's better to just not skip anything at
             all.  */
          fextra_info->skip_prologue_function_start = start_pc;
      }

    /* Indicate where registers were saved on the stack, if:
       - the caller seems to want to know,
       - the caller provided an actual SP, and
       - the analysis gave us enough information to actually figure it
         out.  */
    if (fi
        && get_frame_saved_regs (fi)
        && original_sp != -1)
      {
        int slot_num;
        CORE_ADDR slot_addr;
        CORE_ADDR *saved_regs = get_frame_saved_regs (fi);

        /* Scan the spill array; if a spill slot says it holds the
           original value of some register, then record that slot's
           address as the place that register was saved.

           Just for kicks, note that, even if registers aren't saved
           in their officially-sanctioned slots, this will still work
           --- we know what really got put where.  */

        /* First, the slots for r2 -- r15.  */
        for (slot_num = 0, slot_addr = original_sp + 2 * S390_GPR_SIZE;
             slot_num < 14;
             slot_num++, slot_addr += S390_GPR_SIZE)
          {
            struct prologue_value *slot = &spill[slot_num];

            if (slot->kind == pv_register
                && slot->k == 0)
              saved_regs[slot->reg] = slot_addr;
          }

        /* Then, the slots for f0, f2, f4, and f6.  They're a
           different size.  */
        for (slot_num = 14, slot_addr = original_sp + 16 * S390_GPR_SIZE;
             slot_num < S390_NUM_SPILL_SLOTS;
             slot_num++, slot_addr += S390_FPR_SIZE)
          {
            struct prologue_value *slot = &spill[slot_num];
            
            if (slot->kind == pv_register
                && slot->k == 0)
              saved_regs[slot->reg] = slot_addr;
          }

        /* The stack pointer's element of saved_regs[] is special.  */
        saved_regs[S390_SP_REGNUM] = original_sp;
      }
  }

  return result;
@


1.105.2.3
log
@* s390-tdep.c (struct frame_extra_info): new member:
'stack_bought_valid'.
(s390_get_frame_info): Set fextra_info->stack_bought_valid if we
initialize fextra_info->stack_bought.
(s390_frameless_function_invocation): Don't trust the value of
fextra_info_ptr->stack_bought unless
fextra_info->stack_bought_valid is set.
@
text
@a115 1
  CORE_ADDR stack_bought_valid;
a1394 1
            fextra_info->stack_bought_valid = 1;
d1607 1
a1607 2
      frameless = (fextra_info_ptr->stack_bought_valid
                   && fextra_info_ptr->stack_bought == 0);
@


1.104
log
@2003-06-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (SAVE_DUMMY_FRAME_TOS): Deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* infcall.c (call_function_by_hand): Update.
	* ia64-tdep.c (ia64_push_arguments): Update comment.
	* frame.c (legacy_get_prev_frame): Do not assume
	SAVE_DUMMY_FRAME_TOS_P.
	* dummy-frame.c (find_dummy_frame): Update comment.
@
text
@a86 1
#ifndef GDBSERVER
a1916 2

#endif /* GDBSERVER */
@


1.103
log
@2003-06-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Update comments on registers, re-order.
	(deprecated_register_byte): Rename register_byte.
	(deprecated_register_raw_size): Rename register_raw_size.
	(deprecated_register_virtual_size): Rename register_virtual_size.
	(deprecated_register_virtual_type): Rename register_virtual_type.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c: Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
@
text
@d1863 1
a1863 1
  set_gdbarch_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
@


1.102
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_push_return_address): Make static.
	(xstormy16_save_dummy_frame_tos): Make static.
	(_initialize_xstormy16_tdep): Add declaration.
	* vax-tdep.c (_initialize_vax_tdep): Add declaration.
	* v850-tdep.c: Make local functions static.
	(_initialize_v850_tdep): Add declaration.
	* sparc-tdep.c: Make local functions static.
	(_initialize_sparc_tdep): Add declaration.
	* sh-tdep.c: Make local functions static.
	(_initialize_sh_tdep): Add declaration.
	* sh3-rom.c (_initialize_sh3_rom): Add declaration.
	* s390-tdep.c: Make local functions static.
	(_initialize_s390_tdep): Add declaration.
	* dbxread.c (find_stab_function_addr): Make static.
	* ppc-bdm.c (_initialize_bdm_ppc): Add declaration.
	* ocd.c (_initialize_remote_ocd): Add declaration.
	* dink32-rom.c (_initialize_dink32_rom): Add declaration.
	* ppcbug-rom.c (_initialize_ppcbug_rom): Add declaration.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Add declaration.
	* ns32knbsd-tdep.c (_initialize_ns32knbsd_tdep): Add declaration.
	* mips-tdep.c (_initialize_mips_tdep): Add declaration.
	* remote-array.c (_initialize_array): Add declaration.
	(_initialize_remote_monitors): Add declaration.
	* remote-mips.c: Make local functions static.
	(_initialize_remote_mips): Add declaration.
	* mcore-tdep.c: Make all local functions static.
	(_initialize_mcore_tdep): Add declaration.
	* dbug-rom.c (_initialize_dbug_rom): Add declaration.
	* abug-rom.c (_initialize_abug_rom): Add declaration.
	* rom68k-rom.c (_initialize_rom68k): Add declaration.
	* cpu32bug-rom.c (_initialize_cpu32bug_rom): Add declaration.
	* m68k-tdep.c (_initialize_m68k_tdep): Add declaration.
	* remote-est.c (_initialize_est): Add declaration.
	* m68hc11-tdep.c (_initialize_m68hc11_tdep): Add declaration.
	(m68hc11_call_dummy_address): Make static.
	* ia64-tdep.c: Make local functions static.
	(_initialize_ia64_tdep): Add declaration.
	* solib-legacy.c (_initialize_svr4_lm): Add declaration.
	* monitor.c (monitor_wait_filter): Make static.
	(_initialize_remote_monitors): Add declaration.
	* remote-hms.c (_initialize_remote_hms): Add declaration.
	* remote-e7000.c (fetch_regs_from_dump): Make static.
	(expect_n): Make static.
	(_initialize_remote_e7000): Add declaration.
	* ser-e7kpc.c: Always include "defs.h".
	(_initialize_ser_e7000pc): Add declaration.
	* h8300-tdep.c (_initialize_h8300_tdep): Add declaration.
	* cris-tdep.c: Make all but one function static.
	(_initialize_cris_tdep): Add declaration.
	* solib-svr4.c (_initialize_svr4_solib): Add declaration.
	* solib.c (update_solib_list): Make static.
	(_initialize_solib): Add declaration.
	* avr-tdep.c (avr_breakpoint_from_pc): Make static.
	(_initialize_avr_tdep): Add declaration.
	* remote-rdi.c (voiddummy): Make static.
	(_initialize_remote_rdi): Add declaration.
	* arm-tdep.c (_initialize_arm_tdep): Add declaration.
	* remote-rdp.c (send_rdp): Make static.
	(_initialize_remote_rdp): Add declaration.
	* alpha-tdep.c (_initialize_alpha_tdep): Add declaration.
@
text
@d1843 1
a1843 1
  set_gdbarch_register_byte (gdbarch, s390_register_byte);
d1873 3
a1875 3
      set_gdbarch_register_raw_size (gdbarch, s390_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, s390_register_raw_size);
      set_gdbarch_register_virtual_type (gdbarch, s390_register_virtual_type);
d1882 3
a1884 4
      set_gdbarch_register_raw_size (gdbarch, s390x_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, s390x_register_raw_size);
      set_gdbarch_register_virtual_type (gdbarch,
					 s390x_register_virtual_type);
@


1.101
log
@2003-06-09  Andrew Cagney  <cagney@@redhat.com>

	* vax-tdep.c (vax_frame_locals_address): Delete function.
	(vax_gdbarch_init): Do not set frame_locals_address.
	* m68hc11-tdep.c (m68hc11_frame_locals_address): Delete function.
	(m68hc11_gdbarch_init): Do not set frame_locals_address.
	* s390-tdep.c (s390_frame_args_address): Delete function.
	(s390_gdbarch_init): Do not set frame_args_address or
	frame_locals_address.
	* ns32k-tdep.c (ns32k_frame_locals_address): Delete.
	(ns32k_gdbarch_init): Do not set frame_locals_address.
	* hppa-tdep.c (hppa_frame_args_address): Delete function.
	(hppa_frame_locals_address): Delete function.
	(hppa_gdbarch_init): Do not set frame_args_address, or
	frame_locals_address.
	* arm-tdep.c (arm_frame_args_address): Delete.
	(arm_frame_locals_address): Delete.
	(arm_gdbarch_init): Do not set frame_args_address, or
	frame_locals_address.
@
text
@d48 1
a48 1
int
d58 1
a58 1
int
d65 1
a65 1
int
d72 1
a72 1
int
d122 1
a122 1
int
d153 1
a153 1
const char *
d178 1
a178 1
int
d213 1
a213 1
int
d678 1
a678 1
int
d770 1
a770 1
CORE_ADDR
d785 1
a785 1
int
d884 1
a884 1
CORE_ADDR
d904 1
a904 1
void
d919 1
a919 1
void
d973 1
a973 1
CORE_ADDR
d1002 1
a1002 1
CORE_ADDR
d1082 1
a1082 1
void
d1140 1
a1140 1
void
d1188 1
a1188 1
int
d1203 1
a1203 1
CORE_ADDR
d1245 1
a1245 1
void
d1495 1
a1495 1
CORE_ADDR
d1679 1
a1679 1
struct type *
d1689 1
a1689 1
struct type *
d1699 1
a1699 1
void
d1707 1
a1707 1
const static unsigned char *
d1718 1
a1718 1
CORE_ADDR
d1731 1
a1731 1
CORE_ADDR
d1769 1
a1769 1
int
d1782 1
a1782 1
struct gdbarch *
d1907 2
@


1.100
log
@2003-06-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_NUM_ARGS): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (frame_num_args_unknown): Delete both declarations.
	* arch-utils.c (frame_num_args_unknown): Delete function.
	* stack.c (print_args_stub): Use FRAME_NUM_ARGS_P.
	(frame_info): Use FRAME_NUM_ARGS_P.
	* arm-tdep.c (arm_frame_num_args): Delete function.
	(arm_gdbarch_init): Do not set frame_num_args.
	* config/pa/tm-hppa64.h (FRAME_NUM_ARGS): Delete.
	* hppa-tdep.c (hppa_frame_num_args): Delete function.
	(hppa_gdbarch_init): Do not set frame_num_args.
	* config/sparc/tm-sparc.h (FRAME_NUM_ARGS): Delete.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	frame_num_args to default frame_num_args_unknown.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@a943 9
CORE_ADDR
s390_frame_args_address (struct frame_info *fi)
{

  /* Apparently gdb already knows gdb_args_offset itself */
  return get_frame_base (fi);
}


a1809 1
  set_gdbarch_frame_args_address (gdbarch, s390_frame_args_address);
a1811 1
  set_gdbarch_frame_locals_address (gdbarch, s390_frame_args_address);
@


1.99
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* inferior.h (deprecated_write_sp): Replace
	generic_target_write_sp.
	* regcache.c (deprecated_write_sp): Replace
	generic_target_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Update.
@
text
@a1822 2
  /* We can't do this */
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
@


1.98
log
@2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTES): Rename REGISTER_BYTES.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_extract_return_value): Delete reference.
	* TODO (REGISTER_BYTES): Delete reference.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	(ns32k_gdbarch_init_32382): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* sparc-tdep.c (sparc_pop_frame): Update.
	* rs6000-tdep.c (rs6000_pop_frame): Update.
	* remote.c (init_remote_state): Update.
	(remote_prepare_to_store): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	(sds_prepare_to_store): Update.
	* remote-array.c: Update.
	* regcache.c (init_legacy_regcache_descr): Update.
	(init_regcache_descr): Update.
	* mips-tdep.c (mips_eabi_extract_return_value): Update.
	(mips_o64_extract_return_value): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* irix4-nat.c (fetch_core_registers): Update.
	* i386-tdep.h: Update.
	* hppa-tdep.c (pa_do_registers_info): Update.
	(pa_do_strcat_registers_info): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/sparc/nm-sun4sol2.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-sun4os4.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-nbsd.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/s390/tm-s390.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-mips.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix6.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix5.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/m68k/tm-sun3.h (DEPRECATED_REGISTER_BYTES): Update.
	(REGISTER_BYTES_OK): Update.
	* config/m68k/nm-sun3.h (CHILD_PREPARE_TO_STORE): Update.
	* config/ia64/tm-ia64.h (DEPRECATED_REGISTER_BYTES): Update.

Index: doc/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	REGISTER_BYTES with DEPRECATED_REGISTER_BYTES.  Fix typo,
	DEPRECATED_REGISTER_SIZE instead of REGISTER_BYTE.

Index: mi/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_setup_architecture_data):
@
text
@d1914 1
a1914 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
@


1.97
log
@2003-05-15  Andrew Cagney  <cagney@@redhat.com>

	* arch-utils.h (legacy_breakpoint_from_pc): Delete declaration.
	* target.h (memory_breakpoint_from_pc): Delete declaration.
	* mem-break.c (memory_breakpoint_from_pc): Delete function.
	* arch-utils.c (legacy_breakpoint_from_pc): Delete function.
	* monitor.c (monitor_insert_breakpoint): Use
	gdbarch_breakpoint_from_pc instead of memory_breakpoint_from_pc.
	* gdbarch.sh (BREAKPOINT_FROM_PC): Do not provide a default.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sparc-tdep.c (sparc_breakpoint_from_pc): New function.
	(sparc_gdbarch_init): Set breakpoint_from_pc to
	sparc_breakpoint_from_pc.
	* config/sparc/tm-sparc.h (BREAKPOINT): Delete macro.
	(BREAKPOINT_FROM_PC): Define.
	(sparc_breakpoint_from_pc): Declare.
	* hppa-tdep.c (hppa_breakpoint_from_pc): New function.
	* config/pa/tm-hppa.h (hppa_breakpoint_from_pc): Declare.
	(BREAKPOINT_FROM_PC): Define.
	(BREAKPOINT): Delete macro.
	* target.h: Update comment.
	* s390-tdep.c (s390_gdbarch_init): Update comments.
	* remote.c: Update comments.
	* remote-mips.c: Update comments.
	* proc-api.c (write_with_trace): Do not check for a breakpoint.
	* mem-break.c: Update comment.
	* ia64-tdep.c (IA64_BREAKPOINT): Rename BREAKPOINT.
	(ia64_memory_insert_breakpoint): Update.
	* config/sparc/tm-sparc.h: Update comment.
	* config/pa/tm-hppa64.h: Update comment.
	* rs6000-tdep.c (BIG_BREAKPOINT, LITTLE_BREAKPOINT): Delete macro.
	(rs6000_breakpoint_from_pc): Update.
	* mips-tdep.c (BIG_BREAKPOINT, LITTLE_BREAKPOINT): Delete macro.
	(PMON_BIG_BREAKPOINT, PMON_LITTLE_BREAKPOINT): Delete macro.
	(IDT_LITTLE_BREAKPOINT, IDT_LITTLE_BREAKPOINT): Delete macro.
	(MIPS16_LITTLE_BREAKPOINT, MIPS16_BIG_BREAKPOINT): Delete macro.
	(mips_breakpoint_from_pc): Update.
	(mips_dump_tdep): Update.
@
text
@d1891 1
a1891 1
      set_gdbarch_register_bytes (gdbarch, S390_REGISTER_BYTES);
d1903 1
a1903 1
      set_gdbarch_register_bytes (gdbarch, S390X_REGISTER_BYTES);
@


1.96
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_SIZE): Rename REGISTER_SIZE.
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Rename
	SIZEOF_CALL_DUMMY_WORDS.
	(DEPRECATED_CALL_DUMMY_WORDS): Rename CALL_DUMMY_WORDS.
	(DEPRECATED_FIX_CALL_DUMMY): Rename FIX_CALL_DUMMY.
	(DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET): Rename
	CALL_DUMMY_BREAKPOINT_OFFSET.
	(DEPRECATED_CALL_DUMMY_START_OFFSET): Rename
	CALL_DUMMY_START_OFFSET.
	(DEPRECATED_CALL_DUMMY_LENGTH): Rename CALL_DUMMY_LENGTH.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-tdep.c, alphafbsd-tdep.c, arm-linux-tdep.c: Update.
	* arm-tdep.c, avr-tdep.c, breakpoint.c, cris-tdep.c: Update.
	* dummy-frame.c, dummy-frame.h, frv-tdep.c, gdbarch.c: Update.
	* gdbarch.h, gdbarch.sh, h8300-tdep.c, hppa-tdep.c: Update.
	* i386-tdep.c, ia64-tdep.c, infcall.c, inferior.h: Update.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Update.
	* mips-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* rs6000-tdep.c, s390-tdep.c, sh-tdep.c, sol-thread.c: Update.
	* sparc-tdep.c, target.c, v850-tdep.c, valops.c: Update.
	* vax-tdep.c, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/ia64/tm-ia64.h, config/m68k/tm-vx68.h: Update.
	* config/mips/tm-mips.h, config/pa/nm-hppah.h: Update.
	* config/pa/tm-hppa.h, config/pa/tm-hppa64.h: Update.
	* config/s390/tm-s390.h, config/sparc/tm-sp64.h: Update.
	* config/sparc/tm-sparc.h: Update.

Index: doc/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Make
	CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_LENGTH,
	FIX_CALL_DUMMY, CALL_DUMMY_BREAKPOINT_OFFSET and
	CALL_DUMMY_BREAKPOINT_OFFSET deprecated.

Index: mi/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Replace
	REGISTER_SIZE with DEPRECATED_REGISTER_SIZE.

Index: testsuite/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/watchpoint.exp: Rename CALL_DUMMY_BREAKPOINT_OFFSET to
	DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET in comments.
@
text
@d1828 3
a1830 3
  /* Amount PC must be decremented by after a breakpoint.
     This is often the number of bytes in BREAKPOINT
     but not always.  */
@


1.95
log
@2003-04-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (deprecated_tm_print_insn_info): Rename
	"tm_print_insn_info".
	(TARGET_PRINT_INSN_INFO): Delete macro.
	(dis_asm_read_memory): Delete function declaration.
	(dis_asm_memory_error, dis_asm_print_address): Ditto.
	(tm_print_insn_info): Delete variable definition.
	(_initialize_gdbarch): Do not initialize "tm_print_insn_info".
	* gdbarch.h, gdbarch.c: Re-generate.
	* d10v-tdep.c (display_trace): Replace "tm_print_insn_info" with
	"deprecated_tm_print_insn_info".
	* mcore-tdep.c (mcore_dump_insn): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* sparc-tdep.c (_initialize_sparc_tdep): Ditto.
	* v850-tdep.c (v850_scan_prologue, v850_gdbarch_init): Ditto.
	* ia64-tdep.c (_initialize_ia64_tdep): Ditto.
	* printcmd.c (print_insn): Use "deprecated_tm_print_insn_info"
	instead of TARGET_PRINT_INSN_INFO, add comment.
	* s390-tdep.c (s390_get_frame_info): Instead of
	"dis_asm_read_memory", use "deprecated_tm_print_insn_info".
	(s390_check_function_end, s390_is_sigreturn): Ditto.
	* corefile.c (dis_asm_read_memory): Move to "disasm.c".
	(dis_asm_memory_error, dis_asm_print_address): Ditto.
	* disasm.c: Include "gdbcore.h".
	(_initialize_disasm): New function, initialize
	"deprecated_tm_print_insn_info".
	(deprecated_tm_print_insn_info): New variable.
	(dis_asm_read_memory): Moved from "corefile.c", made static.
	(dis_asm_print_address, dis_asm_memory_error): Ditto.
	* Makefile.in (disasm.o): Update dependencies.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d1153 1
a1153 1
  char *reg_buff = alloca (max (S390_FPR_SIZE, REGISTER_SIZE)), *value;
d1879 2
a1880 3
  set_gdbarch_sizeof_call_dummy_words (gdbarch,
                                       sizeof (s390_call_dummy_words));
  set_gdbarch_call_dummy_words (gdbarch, s390_call_dummy_words);
d1885 1
a1885 1
      set_gdbarch_register_size (gdbarch, 4);
d1894 1
a1894 1
      set_gdbarch_register_size (gdbarch, 8);
@


1.94
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d283 1
a283 1
  info.read_memory_func = dis_asm_read_memory;
d685 1
a685 1
  info.read_memory_func = dis_asm_read_memory;
d822 1
a822 1
  info.read_memory_func = dis_asm_read_memory;
@


1.93
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (deprecated_tm_print_insn): Rename tm_print_insn.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (_initialize_xstormy16_tdep): Update.
	* vax-tdep.c (_initialize_vax_tdep): Update.
	* v850-tdep.c (_initialize_v850_tdep): Update.
	* sparc-tdep.c (_initialize_sparc_tdep): Update.
	* s390-tdep.c (_initialize_s390_tdep): Update.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Update.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* m68k-tdep.c (_initialize_m68k_tdep): Update.
	* ia64-tdep.c (_initialize_ia64_tdep): Update.
	* hppa-tdep.c (_initialize_hppa_tdep): Update.
	* h8300-tdep.c (_initialize_h8300_tdep): Update.
	* frv-tdep.c (_initialize_frv_tdep): Update.
	* cris-tdep.c (cris_delayed_get_disassembler): Update.
	(_initialize_cris_tdep): Update.
	* arch-utils.c (legacy_print_insn): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	"tm_print_insn" to "deprecated_tm_print_insn".
@
text
@d1661 1
a1661 1
                                 read_fp ());
d1844 1
a1844 1
  set_gdbarch_read_fp (gdbarch, s390_read_fp);
d1859 1
a1859 1
  set_gdbarch_fp_regnum (gdbarch, S390_FP_REGNUM);
@


1.92
log
@* s390-tdep.c (s390_frame_align): New function.
(s390_gdbarch_init): Register it with the gdbarch object.
@
text
@d1928 2
a1929 2
  if (!tm_print_insn)		/* Someone may have already set it */
    tm_print_insn = gdb_print_insn_s390;
@


1.92.2.1
log
@Merge from mainline.
@
text
@d283 1
a283 1
  info.read_memory_func = deprecated_tm_print_insn_info.read_memory_func;
d685 1
a685 1
  info.read_memory_func = deprecated_tm_print_insn_info.read_memory_func;
d822 1
a822 1
  info.read_memory_func = deprecated_tm_print_insn_info.read_memory_func;
d1661 1
a1661 1
                                 deprecated_read_fp ());
d1844 1
a1844 1
  set_gdbarch_deprecated_target_read_fp (gdbarch, s390_read_fp);
d1859 1
a1859 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, S390_FP_REGNUM);
d1928 2
a1929 2
  if (!deprecated_tm_print_insn)	/* Someone may have already set it */
    deprecated_tm_print_insn = gdb_print_insn_s390;
@


1.92.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1153 1
a1153 1
  char *reg_buff = alloca (max (S390_FPR_SIZE, DEPRECATED_REGISTER_SIZE)), *value;
d1828 3
a1830 3
  /* Amount PC must be decremented by after a breakpoint.  This is
     often the number of bytes returned by BREAKPOINT_FROM_PC but not
     always.  */
d1879 3
a1881 2
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (s390_call_dummy_words));
  set_gdbarch_deprecated_call_dummy_words (gdbarch, s390_call_dummy_words);
d1886 1
a1886 1
      set_gdbarch_deprecated_register_size (gdbarch, 4);
d1892 1
a1892 1
      set_gdbarch_deprecated_register_bytes (gdbarch, S390_REGISTER_BYTES);
d1895 1
a1895 1
      set_gdbarch_deprecated_register_size (gdbarch, 8);
d1904 1
a1904 1
      set_gdbarch_deprecated_register_bytes (gdbarch, S390X_REGISTER_BYTES);
@


1.91
log
@2003-04-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_SAVED_PC_AFTER_CALL): Deprecate
	SAVED_PC_AFTER_CALL.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_saved_pc_after_call): Update declaration.
	* i386ly-tdep.c (i386lynx_init_abi): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	* infrun.c (step_over_function): Update.
	* i386-linux-tdep.c (skip_hurd_resolver): Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	* arm-linux-tdep.c (skip_hurd_resolver): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	* x86-64-tdep.h (x86_64_linux_saved_pc_after_call): Update
	declaration.
@
text
@d1667 9
d1874 1
@


1.90
log
@* s390-tdep.c (s390_gdbarch_init): Put back accidentally deleted
call to set_gdbarch_deprecated_push_arguments.
@
text
@d1846 1
a1846 1
  set_gdbarch_saved_pc_after_call (gdbarch, s390_saved_pc_after_call);
@


1.89
log
@2003-04-05  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_func_unwind, get_frame_func): New functions.
	* frame.h (get_frame_func, frame_func_unwind): Declare.
	(struct frame_info): Add field "prev_func" for caching the
	previous frame's function address.
	* arm-tdep.c (arm_frameless_function_invocation): Combine
	get_pc_function_start and get_frame_pc into get_frame_func.
	* sh-tdep.c (sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	* s390-tdep.c (s390_function_start): Ditto.
	* rs6000-tdep.c (rs6000_pop_frame): Ditto.
	(rs6000_frameless_function_invocation): Ditto.
	(rs6000_frame_saved_pc): Ditto.
	* m68k-tdep.c (m68k_frame_init_saved_regs): Ditto.
	* ia64-tdep.c (ia64_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frameless_signal_p): Ditto.
	(i386_frame_init_saved_regs): Ditto.
	* hppa-tdep.c (hppa_frame_find_saved_regs): Ditto.
	* d10v-tdep.c (d10v_frame_unwind_cache): Combine
	get_pc_function_start and frame_pc_unwind into frame_func_unwind.
	* cris-tdep.c (cris_frame_init_saved_regs): Ditto.
	* blockframe.c (frameless_look_for_prologue): Ditto.
@
text
@d1867 2
@


1.88
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_START_OFFSET): Default to zero.
	CALL_DUMMY_LENGTH): Ditto.
	* gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_START_OFFSET): Delete macro.
	(CALL_DUMMY_LENGTH): Delete macro.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set above when zero.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@d778 1
a778 1
    function_start = get_pc_function_start (get_frame_pc (fi));
@


1.88.2.1
log
@Merge with mainline.
@
text
@d778 1
a778 1
    function_start = get_frame_func (fi);
@


1.87
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_BREAKPOINT_OFFSET): Default to zero.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sp64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* config/pa/tm-hppa64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* inferior.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET): Delete.
	* infcmd.c (run_stack_dummy): Simplify assuming
	CALL_DUMMY_BREAKPOINT_OFFSET_P.
	* infrun.c (handle_inferior_event): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set
	call_dummy_breakpoint_offset or call_dummy_breakpoint_offset_p.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@a1863 2
  set_gdbarch_call_dummy_length (gdbarch, 0);
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
a1866 1
  set_gdbarch_deprecated_push_return_address (gdbarch, s390_push_return_address);
@


1.86
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FIX_CALL_DUMMY): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Regenerate.
	* inferior.h (FIX_CALL_DUMMY): Delete macro.
	* valops.c (hand_function_call): Only call FIX_CALL_DUMMY when
	available.
	* frame.h (generic_fix_call_dummy): Delete declaration.
	* dummy-frame.h: Update comment.
	* dummy-frame.c (generic_fix_call_dummy): Delete function.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	fix_call_dummy.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@a1868 2
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);
@


1.85
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Include "symfile.h".
	(CALL_DUMMY_ADDRESS): Default to entry_point_address.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_ADDRESS): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_address, the default is at entry_point_address.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@a1870 1
  set_gdbarch_fix_call_dummy (gdbarch, generic_fix_call_dummy);
@


1.84
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_P): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* dummy-frame.c (dummy_frame_this_id): Update comments.
	* rs6000-tdep.c (rs6000_extract_struct_value_address): Ditto.
	* frame.c (legacy_get_prev_frame): Ditto.
	* valops.c (call_function_by_hand): Delete function.
	(hand_function_call): Rename to call_function_by_hand

2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to CALL_DUMMY_P.
@
text
@a1864 1
  set_gdbarch_call_dummy_address (gdbarch, entry_point_address);
@


1.83
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_DUMMY_WRITE_SP): Replace TARGET_WRITE_SP.
	* gdbarch.h, gdbarch.c: Regenerate.
	* v850-tdep.c (v850_gdbarch_init): Set deprecated_dummy_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_push_dummy_frame, sparc_pop_frame): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_DUMMY_WRITE_SP): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Define.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* valops.c (hand_function_call): Replace TARGET_WRITE_SP with
	DEPRECATED_DUMMY_WRITE_SP.  Call when the method is available,
	instead of when push_dummy_call is not available.

2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Remove
	reference to TARGET_WRITE_SP.
@
text
@a1863 1
  set_gdbarch_call_dummy_p (gdbarch, 1);
@


1.82
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_RETURN_ADDRESS): Replace
	PUSH_RETURN_ADDRESS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* valops.c (hand_function_call): Update.
@
text
@d1910 3
@


1.81
log
@2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_ARGUMENTS): Rename PUSH_ARGUMENTS.
	(push_dummy_call): New pure multi-arch replacement with gdbarch,
	regcache and dummy_addr parameters.
	* gdbarch.h, gdbarch.c: Re-generate.
	* valops.c (hand_function_call): Use gdbarch_push_dummy_call when
	available; assume it will handle stack alignment and return
	address issues.  Fall back to DEPRECATED_PUSH_ARGUMENTS and
	legacy_push_arguments.
	(legacy_push_arguments): Rename default_push_arguments.
	* value.h (legacy_push_arguments): Rename default_push_arguments.
	* i386-tdep.c (i386_push_arguments): Call legacy_push_arguments.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/i386/tm-symmetry.h: Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* arm-linux-tdep.c (arm_linux_init_abi): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	PUSH_ARGUMENTS with push_dummy_call, add gdbarch, regcache and
	dummy_addr parameters.
@
text
@d1874 1
a1874 1
  set_gdbarch_push_return_address (gdbarch, s390_push_return_address);
@


1.80
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_STORE_STRUCT_RETURN): Replace
	STORE_STRUCT_RETURN.
	* gdbarch.h, gdbarch.c: Regenerate.
	* d10v-tdep.c (d10v_store_struct_return): Delete function.
	(d10v_push_arguments): Set the struct return register.
	(d10v_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d1869 1
a1869 1
  set_gdbarch_push_arguments (gdbarch, s390_push_arguments);
@


1.80.2.1
log
@Merge with mainline.
@
text
@d1869 1
a1869 1
  set_gdbarch_deprecated_push_arguments (gdbarch, s390_push_arguments);
d1874 1
a1874 1
  set_gdbarch_deprecated_push_return_address (gdbarch, s390_push_return_address);
a1908 3

  /* Should be using push_dummy_call.  */
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
@


1.79
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_STACK_ADJUST_P): Delete.
	(DEPRECATED_CALL_DUMMY_STACK_ADJUST): Replace
	CALL_DUMMY_STACK_ADJUST with a predicate variable.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_stack_adjust_p.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sparc.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.  Do not set
	call_dummy_stack_adjust_p.
	* inferior.h (CALL_DUMMY_STACK_ADJUST_P): Delete macro.
	(CALL_DUMMY_STACK_ADJUST): Delete macro.
	* sparc-tdep.c (sparc32_push_arguments): Update.
	* valops.c (hand_function_call): Update.

2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	reference to CALL_DUMMY_STACK_ADJUST_P.  Rename
	CALL_DUMMY_STACK_ADJUST to DEPRECATED_CALL_DUMMY_STACK_ADJUST.
	Add reference to PUSH_ARGUMENTS.
@
text
@d1816 1
a1816 1
  set_gdbarch_store_struct_return (gdbarch, s390_store_struct_return);
@


1.78
log
@Index: ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_CHAIN): Replace FRAME_CHAIN.
	(DEPRECATED_FRAME_CHAIN_VALID): Replace FRAME_CHAIN_VALID.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update.
	* objfiles.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* frame.c (legacy_saved_regs_this_id): Update.
	(legacy_get_prev_frame, get_prev_frame, legacy_frame_p): Update.
	* dummy-frame.h: Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* config/m68k/tm-vx68.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-os68k.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-sun3.h: Update.
	* blockframe.c (inside_main_func, frame_chain_valid): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_frame_chain, sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	(rs6000_gdbarch_init, rs6000_frame_saved_pc): Update.
	(frame_get_saved_regs): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_frame_num_args, i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	(i386_interix_back_one_frame): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	(hppa_init_extra_frame_info): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Algorithms, Target Architecture Definition):
	Deprecate FRAME_CHAIN and FRAME_CHAIN_VALID.
@
text
@a1872 1
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
@


1.77
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_POP_FRAME): Replace POP_FRAME.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update comment.
	* stack.c (return_command): Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_POP_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_POP_FRAME): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	POP_FRAME with DEPRECATED_POP_FRAME.  Update description.
@
text
@d1811 1
a1811 1
  set_gdbarch_frame_chain (gdbarch, s390_frame_chain);
d1843 3
a1845 3
  /* FRAME_CHAIN takes a frame's nominal address
     and produces the frame's chain-pointer. */
  set_gdbarch_frame_chain (gdbarch, s390_frame_chain);
@


1.76
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_SAVED_PC): Replace FRAME_SAVED_PC.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.h: Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* sh-tdep.c (sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Update.
	* xstormy16-tdep.c (xstormy16_pop_frame): Update.
	(xstormy16_frame_chain_valid): Update.
	* vax-tdep.c (vax_saved_pc_after_call): Update.
	* v850-tdep.c (v850_frame_chain): Update.
	(v850_pop_frame): Update.
	(v850_init_extra_frame_info): Update.
	* sparc-tdep.c (setup_arbitrary_frame): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* s390-tdep.c (s390_pop_frame_regular): Update.
	* mn10300-tdep.c (mn10300_frame_chain): Update.
	(mn10300_pop_frame_regular): Update.
	(mn10300_init_extra_frame_info): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	(mips_frame_chain): Update.
	(mips_pop_frame): Update.
	* mcore-tdep.c (mcore_frame_chain): Update.
	(mcore_pop_frame): Update.
	(mcore_init_extra_frame_info): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* m68k-tdep.c (isi_frame_num_args): Update.
	(delta68_frame_num_args): Update.
	(news_frame_num_args): Update.
	* ia64-tdep.c (ia64_pop_frame_regular): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	(alpha_frame_chain): Update.
	(alpha_pop_frame): Update.
	* hppa-tdep.c (hppa_saved_pc_after_call): Update.
	(hppa_init_extra_frame_info): Update.
	(hppa_frame_chain): Update.
	(hppa_frame_chain_valid): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_init_extra_frame_info): Update.
	* arm-tdep.c (arm_frame_chain_valid): Update.
	(arm_init_extra_frame_info): Update.
	(arm_pop_frame): Update.
	* frame.c (frame_pc_unwind): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_SAVED_PC): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-linux.h (DEPRECATED_FRAME_SAVED_PC): Update.

2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_SAVED_PC to DEPRECATED_FRAME_SAVED_PC.
@
text
@d1823 1
a1823 1
  set_gdbarch_pop_frame (gdbarch, s390_pop_frame);
@


1.75
log
@2003-03-03  Andrew Cagney  <cagney@@redhat.com>

	Make MAX_REGISTER_RAW_SIZE and MAX_REGISTER_VIRTUAL_SIZE optional.
	* gdbarch.sh (DEPRECATED_MAX_REGISTER_RAW_SIZE): Variable with
	predicate.  Replace MAX_REGISTER_RAW_SIZE.
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto for
	MAX_REGISTER_VIRTUAL_SIZE.
	* regcache.c (legacy_max_register_raw_size): New function.
	(legacy_max_register_virtual_size): New function.
	* defs.h (MAX_REGISTER_VIRTUAL_SIZE): Define.
	(MAX_REGISTER_RAW_SIZE): Define.
	(legacy_max_register_raw_size): Declare.
	(legacy_max_register_virtual_size): Declare.
	* config/sparc/tm-sparc.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/i386/tm-ptx.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Do not set
	max_register_raw_size or max_register_virtual_size.
@
text
@d1224 1
a1224 1
  write_register (S390_PC_REGNUM, FRAME_SAVED_PC (frame));
d1842 1
a1842 1
  set_gdbarch_frame_saved_pc (gdbarch, s390_frame_saved_pc);
@


1.75.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d1224 1
a1224 1
  write_register (S390_PC_REGNUM, DEPRECATED_FRAME_SAVED_PC (frame));
d1823 1
a1823 1
  set_gdbarch_deprecated_pop_frame (gdbarch, s390_pop_frame);
d1842 1
a1842 1
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, s390_frame_saved_pc);
@


1.74
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_INIT_SAVED_REGS): Rename
	FRAME_INIT_SAVED_REGS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* stack.c (frame_info): Update.
	* sh-tdep.c (sh_find_callers_reg, sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info, sh64_init_extra_frame_info): Update.
	(sh64_get_saved_register, sh_pop_frame, sh64_pop_frame): Update.
	* ns32k-tdep.c (ns32k_pop_frame): Update.
	* mips-tdep.c (mips_pop_frame): Update.
	* m68hc11-tdep.c (m68hc11_pop_frame): Update.
	* ia64-tdep.c (ia64_frame_chain): Update.
	(ia64_frame_saved_pc, ia64_get_saved_register): Update.
	(ia64_frameless_function_invocation): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_pop_frame_regular): Update.
	* frame.h (struct frame_info): Update comment.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Rename macro.
	* frame.c (frame_saved_regs_register_unwind): Update.
	(frame_saved_regs_register_unwind): Update.
	(deprecated_generic_get_saved_register): Update.
	* cris-tdep.c: Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_INIT_SAVED_REGS):
	Rename macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_INIT_SAVED_REGS to DEPRECATED_FRAME_INIT_SAVED_REGS.
@
text
@d1829 2
a1830 2
  set_gdbarch_max_register_raw_size (gdbarch, 8);
  set_gdbarch_max_register_virtual_size (gdbarch, 8);
@


1.73
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename
	INIT_EXTRA_FRAME_INFO.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-tdep.c: Update comments.
	* sh-tdep.c, mcore-tdep.c, m68hc11-tdep.c: Ditto.
	* i386-interix-tdep.c, hppa-tdep.c, h8300-tdep.c: Ditto.
	* frame.h, avr-tdep.c: Ditto.
	* frame.c (get_prev_frame): DEPRECATED_INIT_EXTRA_FRAME_INFO.
	(create_new_frame, legacy_get_prev_frame): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* config/pa/tm-hppa.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Initialize
	deprecated_init_extra_frame_info instead of init_extra_frame_info.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.

Index: doc/ChangeLog
2003-02-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo: Rename INIT_EXTRA_FRAME_INFO to
	DEPRECATED_INIT_EXTRA_FRAME_INFO.
@
text
@d1812 1
a1812 1
  set_gdbarch_frame_init_saved_regs (gdbarch, s390_frame_init_saved_regs);
@


1.72
log
@2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_DUMMY_FRAME): Procedure with
	predicate.  Replaces PUSH_DUMMY_FRAME.
	* gdbarch.h, gdbarch.c: Regnerate.
	* valops.c (hand_function_call): Update.  Call
	generic_push_dummy_frame directly.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* inferior.h (PUSH_DUMMY_FRAME): Delete definition.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Don't set
	push_dummy_frame to generic_push_dummy_frame.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@d1833 1
a1833 1
  set_gdbarch_init_extra_frame_info (gdbarch, s390_init_extra_frame_info);
@


1.71
log
@	* s390-tdep.c (s390_address_class_type_flags)
	(s390_address_class_type_flags_to_name)
	(s390_address_class_name_to_type_flags): New functions.
	(s390_gdbarch_init): Define ADDRESS_CLASS_TYPE_FLAGS_TO_NAME,
	ADDRESS_CLASS_NAME_TO_TYPE_FLAGS, and ADDRESS_CLASS_TYPE_FLAGS.
@
text
@a1868 1
  set_gdbarch_push_dummy_frame (gdbarch, generic_push_dummy_frame);
@


1.70
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_extra_info.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, ia64-tdep.c, m68hc11-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10300-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, xstormy16-tdep.c: Ditto.
@
text
@d1751 31
d1903 6
@


1.70.4.1
log
@Merge with interps-20030203-mergepoint.
@
text
@a1750 31
static int
s390_address_class_type_flags (int byte_size, int dwarf2_addr_class)
{
  if (byte_size == 4)
    return TYPE_FLAG_ADDRESS_CLASS_1;
  else
    return 0;
}

static const char *
s390_address_class_type_flags_to_name (struct gdbarch *gdbarch, int type_flags)
{
  if (type_flags & TYPE_FLAG_ADDRESS_CLASS_1)
    return "mode32";
  else
    return NULL;
}

int
s390_address_class_name_to_type_flags (struct gdbarch *gdbarch, const char *name,
				       int *type_flags_ptr)
{
  if (strcmp (name, "mode32") == 0)
    {
      *type_flags_ptr = TYPE_FLAG_ADDRESS_CLASS_1;
      return 1;
    }
  else
    return 0;
}

a1871 6
      set_gdbarch_address_class_type_flags (gdbarch,
                                            s390_address_class_type_flags);
      set_gdbarch_address_class_type_flags_to_name (gdbarch,
                                                    s390_address_class_type_flags_to_name);
      set_gdbarch_address_class_name_to_type_flags (gdbarch,
                                                    s390_address_class_name_to_type_flags);
@


1.69
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_next_frame.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10200-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, sparc-tdep.c: Ditto.
	* v850-tdep.c, vax-tdep.c, x86-64-linux-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
@
text
@d320 2
a321 2
	      && get_next_frame (fi)->extra_info
	      && get_next_frame (fi)->extra_info->sigcontext)
d324 1
a324 1
	      save_reg_addr = get_next_frame (fi)->extra_info->sigcontext +
d331 1
a331 1
	      save_reg_addr = get_next_frame (fi)->extra_info->sigcontext +
d775 2
a776 2
  if (fi->extra_info && fi->extra_info->initialised)
    function_start = fi->extra_info->function_start;
d793 2
a794 2
      if (fi->extra_info)
	fextra_info_ptr = fi->extra_info;
d910 1
a910 1
			 fi->extra_info, fi, 1);
d912 1
a912 1
    s390_memset_extra_info (fi->extra_info);
d931 7
a937 5
	  quick = (fi->extra_info && fi->extra_info->initialised
		   && fi->extra_info->good_prologue);
	  s390_get_frame_info (quick ? fi->extra_info->function_start :
			       s390_sniff_pc_function_start (get_frame_pc (fi), fi),
			       fi->extra_info, fi, !quick);
d956 2
a957 2
  if (fi->extra_info && fi->extra_info->saved_pc_valid)
    return fi->extra_info->saved_pc;
d965 1
a965 1
  if (fi->extra_info)
d967 2
a968 2
      fi->extra_info->saved_pc_valid = 1;
      if (fi->extra_info->good_prologue
d970 1
a970 1
        fi->extra_info->saved_pc
d975 1
a975 1
        fi->extra_info->saved_pc
d977 1
a977 1
      return fi->extra_info->saved_pc;
d987 3
a989 2
  if (fi->extra_info && fi->extra_info->sig_fixed_saved_pc_valid)
    return fi->extra_info->sig_fixed_saved_pc;
d992 1
a992 1
  if (fi->extra_info)
d994 1
a994 1
      fi->extra_info->sig_fixed_saved_pc_valid = 1;
d1000 1
a1000 1
      fi->extra_info->sig_fixed_saved_pc = saved_pc;
d1052 1
a1052 1
	  thisframe->extra_info->sigcontext = sregs;
@


1.68
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_base.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10200-tdep.c: Ditto.
	* mn10300-tdep.c, ns32k-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c: Ditto.
	* x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* config/h8500/tm-h8500.h, config/mn10200/tm-mn10200.h: Ditto.
	* config/sparc/tm-sparc.h: Ditto.
@
text
@d319 3
a321 2
	  if (saved_regs && fextra_info && fi->next && fi->next->extra_info
	      && fi->next->extra_info->sigcontext)
d324 1
a324 1
	      save_reg_addr = fi->next->extra_info->sigcontext +
d331 1
a331 1
	      save_reg_addr = fi->next->extra_info->sigcontext +
d791 1
a791 1
  if (fi->next == NULL)		/* no may be frameless */
@


1.67
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_init_extra_frame_info): Allocate
	extra_info using frame_extra_info_zalloc.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	* sh-tdep.c (sh_init_extra_frame_info): Ditto.
	(sh64_init_extra_frame_info): Ditto.
	* mn10300-tdep.c (mn10300_init_extra_frame_info): Ditto.
	* s390-tdep.c (s390_init_extra_frame_info): Ditto.
	* mips-tdep.c (mips_init_extra_frame_info): Ditto.
	* mcore-tdep.c (mcore_init_extra_frame_info): Ditto.
	* frv-tdep.c (frv_init_extra_frame_info): Ditto.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Ditto.
	* ia64-tdep.c (ia64_init_extra_frame_info): Ditto.
	* h8300-tdep.c (h8300_init_extra_frame_info): Ditto.
	* d10v-tdep.c (d10v_init_extra_frame_info): Ditto.
	* cris-tdep.c (cris_init_extra_frame_info): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.
	* alpha-tdep.c (alpha_init_extra_frame_info): Ditto.

	* mn10300-tdep.c (analyze_dummy_frame): Use
	deprecated_set_frame_extra_info_hack.
	* mcore-tdep.c (analyze_dummy_frame): Ditto.
@
text
@d288 1
a288 1
      if (fi && fi->frame)
d290 1
a290 1
          orig_sp = fi->frame;
d832 1
a832 1
	    orig_sp = sighandler_fi->frame;
d835 1
a835 2
					read_memory_integer (sighandler_fi->
							     frame,
d946 1
a946 1
  return fi->frame;
d956 4
a959 2
  if (deprecated_generic_find_dummy_frame (get_frame_pc (fi), fi->frame))
    return deprecated_read_register_dummy (get_frame_pc (fi), fi->frame, S390_PC_REGNUM);
d1012 4
a1015 2
  if (deprecated_generic_find_dummy_frame (get_frame_pc (thisframe), thisframe->frame))
    return deprecated_read_register_dummy (get_frame_pc (thisframe), thisframe->frame,
@


1.66
log
@	* arm-tdep.c (arm_frame_chain_valid):  Remove unnecessary test.
	* d10v-tdep.c (d10v_frame_chain_valid): Remove unnecessary tests.
	* hppa-tdep.c (hppa_frame_chain_valid): Remove unnecessary test.

	* blockframe.c: Include "gdbcmd.h" and "command.h".
	(backtrace_below_main): New variable.
	(file_frame_chain_valid, func_frame_chain_valid)
	(nonnull_frame_chain_valid, generic_file_frame_chain_valid)
	(generic_func_frame_chain_valid): Remove functions.
	(frame_chain_valid, do_flush_frames_sfunc): New functions.
	(_initialize_blockframe): New function.
	* Makefile.in (blockframe.o): Update dependencies.
	* frame.c (frame_saved_regs_id_unwind, get_prev_frame): Remove FIXME
	comment.  Call frame_chain_valid ().
	* frame.h: Remove old prototypes.  Add prototype for
	frame_chain_valid and update comments to match.
	* gdbarch.sh: Change FRAME_CHAIN_VALID into a predicated function.
	Remove old comment.
	* gdbarch.h: Regenerated.
	* gdbarch.c: Regenerated.

Plus updates to all other targets not to provide a FRAME_CHAIN_VALID.
@
text
@d907 1
a907 1
  fi->extra_info = frame_obstack_alloc (sizeof (struct frame_extra_info));
@


1.65
log
@gdb/
	* buildsym.h (processing_hp_compilation): Remove obsolete variable.
	* gdbarch.sh Remove include of "value.h" in gdbarch.h.
	(COERCE_FLOAT_TO_DOUBLE): Remove.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* Makefile.in: Remove value_h from gdbarch_h.
	* valops.c (coerce_float_to_double): New variable.
	(default_coerce_float_to_double): Remove.
	(standard_coerce_float_to_double): Remove.
	(value_arg_coerce): Use coerce_float_to_double.
	(_initialize_valops): Add "set coerce-float-to-double".
	* value.h (default_coerce_float_to_double): Remove prototype.
	(standard_coerce_float_to_double): Remove prototype.

	* hpread.c (hpread_process_one_debug_symbol): Mark C++ functions as
	prototyped.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Mark all functions as prototyped.

	* hppa-tdep.c (hppa_coerce_float_to_double): Remove.
	* alpha-tdep.c (alpha_gdbarch_init): Remove call to
	set_gdbarch_coerce_float_to_double.
	* arm-tdep.c (arm_gdbarch_init): Likewise.
	* frv-tdep.c (frv_gdbarch_init): Likewise.
	* h8300-tdep.c (h8300_gdbarch_init): Likewise (commented out).
	* i386-sol2-tdep.c (i386_sol2_init_abi): Likewise.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	(mips_coerce_float_to_double): Remove.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	(rs6000_coerce_float_to_double): Remove.
	* s390-tdep.c (s390_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	(sh_coerce_float_to_double): Remove.
	* sparc-tdep.c (sparc_gdbarch_init): Likewise.
	(sparc_coerce_float_to_double): Remove.
	* v850-tdep.c (v850_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.
	* config/m32r/tm-m32r.h (COERCE_FLOAT_TO_DOUBLE): Remove.
	* config/pa/tm-hppa.h: (COERCE_FLOAT_TO_DOUBLE): Remove.
	(hppa_coerce_float_to_double): Remove prototype.
	* config/sparc/tm-sparc.h (COERCE_FLOAT_TO_DOUBLE): Remove.
doc/
	* gdb.texinfo (Controlling GDB): Add ABI section.  Document
	"set coerce-float-to-double".
	* gdbint.texinfo (COERCE_FLOAT_TO_DOUBLE): Remove documentation.
testsuite/
	* gdb.base/callfuncs.exp: Don't XFAIL unprototyped functions for
	stabs.
	* gdb.base/completion.exp: Allow marker1(void) as well as marker1().
	* gdb.base/whatis.exp: Always allow (void) after function names.
@
text
@a1817 1
  set_gdbarch_frame_chain_valid (gdbarch, func_frame_chain_valid);
@


1.64
log
@2003-01-03  Andrew Cagney  <ac131313@@redhat.com>

	* alpha-tdep.c: Use get_frame_saved_regs.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, xstormy16-tdep.c: Ditto.
@
text
@d3 1
a3 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
a1842 2
  set_gdbarch_coerce_float_to_double (gdbarch,
                                      standard_coerce_float_to_double);
@


1.63
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c: Use get_frame_pc and deprecated_update_frame_pc_hack
	frame accessor methods.
	* alpha-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Ditto.
	* s390-tdep.c, sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* z8k-tdep.c: Ditto.
@
text
@d293 1
a293 1
	  saved_regs = fi->saved_regs;
d925 1
a925 1
  if (fi->saved_regs == NULL)
d965 1
a965 1
          && fi->saved_regs[S390_RETADDR_REGNUM])
d968 1
a968 1
                              (fi->saved_regs[S390_RETADDR_REGNUM],
d1049 1
a1049 1
	  if (thisframe->saved_regs)
d1054 1
a1054 1
                  && thisframe->saved_regs[S390_FRAME_REGNUM])
d1059 1
a1059 1
	      if (thisframe->saved_regs[regno])
d1063 1
a1063 1
                    prev_fp = thisframe->saved_regs[regno];
d1066 1
a1066 1
                      read_memory_integer (thisframe->saved_regs[regno],
d1220 1
a1220 1
  if (frame->saved_regs)
d1223 1
a1223 1
        if (frame->saved_regs[regnum] != 0)
d1227 1
a1227 1
            value = read_memory_unsigned_integer (frame->saved_regs[regnum],
d1235 1
a1235 1
      write_register (S390_SP_REGNUM, frame->saved_regs[S390_SP_REGNUM]);
@


1.62
log
@2002-12-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
	Change to a function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Update.  Test
	DEPRECATED_INIT_FRAME_PC_P.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/mn10200/tm-mn10200.h (DEPRECATED_INIT_FRAME_PC): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* arm-tdep.c: Update comments.
	* h8300-tdep.c (h8300_gdbarch_init): Explicitly set init_frame_pc.
	* config/m32r/tm-m32r.h (DEPRECATED_INIT_FRAME_PC): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC_FIRST): Delete macro.
	(DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
@
text
@d776 2
a777 2
  else if (fi->pc)
    function_start = get_pc_function_start (fi->pc);
d797 1
a797 1
	  s390_get_frame_info (s390_sniff_pc_function_start (fi->pc, fi),
d908 2
a909 2
  if (fi->pc)
    s390_get_frame_info (s390_sniff_pc_function_start (fi->pc, fi),
d929 1
a929 1
      if (fi->pc)
d934 1
a934 1
			       s390_sniff_pc_function_start (fi->pc, fi),
d957 2
a958 2
  if (deprecated_generic_find_dummy_frame (fi->pc, fi->frame))
    return deprecated_read_register_dummy (fi->pc, fi->frame, S390_PC_REGNUM);
d1011 2
a1012 2
  if (deprecated_generic_find_dummy_frame (thisframe->pc, thisframe->frame))
    return deprecated_read_register_dummy (thisframe->pc, thisframe->frame,
d1021 1
a1021 1
      if (thisframe->pc)
@


1.61
log
@2002-12-08  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (INIT_FRAME_PC_FIRST, INIT_FRAME_PC_DEFAULT): Convert
	to pure functions.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Explictly assign prev's pc with value
	returned by INIT_FRAME_PC_FIRST and INIT_EXTRA_FRAME_INFO.

	* arch-utils.h (init_frame_pc_default, init_frame_pc_noop): Change
	declaration to a function returning a CORE_ADDR.
	* x86-64-tdep.h (x86_64_init_frame_pc): Ditto.
	* arch-utils.c (init_frame_pc_noop): Return the PC value.
	(init_frame_pc_default): Ditto.
	* x86-64-linux-tdep.c (x86_64_init_frame_pc): Ditto.
	* s390-tdep.c (s390_init_frame_pc_first): Ditto.
	* mips-tdep.c (mips_init_frame_pc_first): Ditto.
	* dwarf2cfi.h (cfi_init_frame_pc): Ditto.
	* dwarf2cfi.c (cfi_init_frame_pc): Ditto.
	* alpha-tdep.c (alpha_init_frame_pc_first): Ditto.

	* i386-interix-tdep.c (i386_interix_init_abi): Set init_frame_pc
	to init_frame_pc_noop.
	(i386_interix_init_frame_pc): Delete function.
	* z8k-tdep.c (init_frame_pc): Delete function.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC): Define as init_frame_pc_noop.
	(INIT_FRAME_PC_FIRST): Ditto.
	* config/mn10200/tm-mn10200.h (INIT_FRAME_PC): Ditto.
	(INIT_FRAME_PC_FIRST): Ditto.
	* config/sparc/tm-sparc.h (INIT_FRAME_PC): Ditto.
	* config/rs6000/tm-rs6000.h (INIT_FRAME_PC): Redefine as
	init_frame_pc_noop.
	(INIT_FRAME_PC_FIRST): Convert to an expression.
	* config/sparc/tm-sparc.h (INIT_FRAME_PC_FIRST): Ditto.
@
text
@d1764 4
@


1.60
log
@2002-12-06  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC_FIRST): Rename
	INIT_FRAME_PC_FIRST.  Change to a function with predicate.  Do not
	provide a default value.
	* gdbarch.h, gdbarch.c: Regenerate.
	* frame.c (get_prev_frame): Update.  Check
	DEPRECATED_INIT_FRAME_PC_FIRST_P.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d884 1
a884 1
void
d888 1
a888 2

  fi->pc = 0;
d891 1
a891 1
      fi->pc = ADDR_BITS_REMOVE (read_register (S390_RETADDR_REGNUM));
d894 4
a897 4
  else if (fi->next && fi->next->pc)
    fi->pc = s390_frame_saved_pc_nofix (fi->next);
  if (fi->pc && fi->next && fi->next->frame &&
      s390_is_sigreturn (fi->pc, fi->next, NULL, &sigcaller_pc))
d899 1
a899 1
      fi->pc = sigcaller_pc;
d901 1
a901 1

@


1.59
log
@2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Rename
	PC_IN_CALL_DUMMY.  Change to predicate.  Always allow call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h, config/sparc/tm-sp64.h: Update.
	* config/mn10200/tm-mn10200.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, frame.h: Update.
	* x86-64-tdep.c, vax-tdep.c, sparc-tdep.c: Update.
	* s390-tdep.c, ns32k-tdep.c, mn10300-tdep.c: Update.
	* m68k-tdep.c, i386-tdep.c, frv-tdep.c: Update.
	* cris-tdep.c, alpha-tdep.c: Update.
	* frame.c (set_unwind_by_pc, create_new_frame): Use either
	DEPRECATED_PC_IN_CALL_DUMMY or pc_in_dummy_frame.
	(get_prev_frame): Ditto.

Index: doc/ChangeLog
2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	PC_IN_CALL_DUMMY.
@
text
@d1793 1
a1793 1
  set_gdbarch_init_frame_pc_first (gdbarch, s390_init_frame_pc_first);
@


1.58
log
@2002-11-27  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_LOCATION): Default to AT_ENTRY_POINT.
	(USE_GENERIC_DUMMY_FRAMES): Default to true.
	(PC_IN_CALL_DUMMY): Default to generic_pc_in_call_dummy.
	* gdbarch.c, gdbarch.h: Re-generate.
	* inferior.h (USE_GENERIC_DUMMY_FRAMES): Delete macro definition.
	(CALL_DUMMY_LOCATION): Delete macro definition.
	(PC_IN_CALL_DUMMY): Delete macro definitions.

	* arm-tdep.c (arm_gdbarch_init): Do not set pc_in_call_dummy,
	default is already generic_pc_in_call_dummy.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* arm-tdep.c (arm_gdbarch_init): Do not set
	use_generic_dummy_frames, default is already 1.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_location, default is already AT_ENTRY_POINT.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d1828 1
a1828 1
  set_gdbarch_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_at_entry_point);
@


1.57
log
@2002-11-26  Andrew Cagney  <ac131313@@redhat.com>

	* inferior.h (deprecated_pc_in_call_dummy_before_text_end): Rename
	pc_in_call_dummy_before_text_end
	(deprecated_pc_in_call_dummy_after_text_end): Rename
	pc_in_call_dummy_after_text_end.
	(deprecated_pc_in_call_dummy_on_stack): Rename
	pc_in_call_dummy_on_stack.
	(deprecated_pc_in_call_dummy_at_entry_point): Rename
	pc_in_call_dummy_at_entry_point.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (PC_IN_CALL_DUMMY): Update.
	* blockframe.c (deprecated_pc_in_call_dummy_before_text_end)
	(deprecated_pc_in_call_dummy_after_text_end)
	(deprecated_pc_in_call_dummy_on_stack)
	(deprecated_pc_in_call_dummy_at_entry_point): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@a1824 1
  set_gdbarch_use_generic_dummy_frames (gdbarch, 1);
a1825 1
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
@


1.56
log
@2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (enum frame_type): Define.
	(get_frame_type): Declare.
	(struct frame_info): Add field `type'.  Delete field
	signal_handler_caller.
	(deprecated_set_frame_signal_handler_caller): Declare.
	* frame.c (get_frame_type): New function.
	(deprecated_set_frame_type): New function.
	(create_new_frame): Set the frame's type.
	(get_prev_frame): Similar.
	* sparc-tdep.c: Use get_frame_type instead of signal_handler_caller.
	* s390-tdep.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* x86-64-linux-tdep.c: Ditto.
	* vax-tdep.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* i386-interix-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* m68k-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* cris-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* i386-tdep.c: Ditto.
	* stack.c: Ditto.
	* ada-lang.c: Ditto.
	* blockframe.c: Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Use
	deprecated_set_frame_type instead of signal_handler_caller.
	* ppc-linux-tdep.c (ppc_linux_init_extra_frame_info): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	* breakpoint.h: Delete FIXME suggesting get_frame_type.

Index: tui/ChangeLog
2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	signal_handler_caller.
@
text
@d1830 1
a1830 1
  set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_at_entry_point);
@


1.55
log
@2002-11-15  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (generic_unwind_get_saved_register): Make static.
	* frame.h (generic_unwind_get_saved_register): Delete declaration.
	* avr-tdep.c (avr_gdbarch_init): Do not set get_saved_register,
	defaults to generic_unwind_get_saved_register.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* config/mn10200/tm-mn10200.h (GET_SAVED_REGISTER): Delete macro.
@
text
@d1004 2
a1005 2
/* We want backtraces out of signal handlers so we don't
   set thisframe->signal_handler_caller to 1 */
@


1.54
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_bytes): Rename
	read_register_bytes.
	(deprecated_write_register_bytes): Rename write_register_bytes.
	* alpha-tdep.c, arm-tdep.c, cris-tdep.c, d10v-tdep.c: Update.
	* dwarf2cfi.c, frv-tdep.c, hppa-tdep.c, ia64-tdep.c: Update.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, regcache.c, remote-sds.c, remote-vx.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh-tdep.c: Update.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c, x86-64-tdep.c: Update.
	* xstormy16-tdep.c, z8k-tdep.c, config/nm-gnu.h: Update.
	* config/nm-m3.h, config/h8500/tm-h8500.h: Update.
	* config/i386/nm-ptx4.h, config/i386/nm-symmetry.h: Update.
	* config/m32r/tm-m32r.h, config/m68k/nm-sun3.h: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-linux.h: Update.
	* config/mn10200/tm-mn10200.h, config/pa/tm-hppa64.h: Update.
	* config/sparc/nm-nbsd.h, config/sparc/nm-sun4os4.h: Update.
	* config/sparc/nm-sun4sol2.h, config/sparc/tm-sparclet.h: Update.

2002-11-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Use
	deprecated_write_register_bytes instead of write_register_bytes.
@
text
@a1813 1
  set_gdbarch_get_saved_register (gdbarch, generic_unwind_get_saved_register);
@


1.53
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@d1153 2
a1154 2
        write_register_bytes (REGISTER_BYTE (S390_FP0_REGNUM), valbuf,
                              TYPE_LENGTH (valtype));
d1164 2
a1165 2
      write_register_bytes (REGISTER_BYTE (S390_GP0_REGNUM + 2), value,
			    arglen);
d1578 3
a1580 3
            write_register_bytes (REGISTER_BYTE (S390_FP0_REGNUM + fr),
                                  VALUE_CONTENTS (arg),
                                  TYPE_LENGTH (type));
@


1.52
log
@2002-09-17  Andrew Cagney  <cagney@@redhat.com>

	* h8300-tdep.c (h8300_frame_chain):
	(h8300_frame_saved_pc):

	* blockframe.c (deprecated_read_register_dummy): Rename
	generic_read_register_dummy.
	* frame.c (frame_unwind_signed_register): New function.
	(frame_unwind_unsigned_register): New function.
	* frame.h (frame_unwind_signed_register): Declare.
	(frame_unwind_unsigned_register): Declare.
	(deprecated_read_register_dummy): Rename
	generic_read_register_dummy.

	* xstormy16-tdep.c (xstormy16_frame_saved_pc): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	* s390-tdep.c (s390_frame_saved_pc_nofix): Update.
	(s390_frame_chain): Update.
	* v850-tdep.c (v850_find_callers_reg): Update.
	(v850_frame_saved_pc): Update.
	* m32r-tdep.c (m32r_init_extra_frame_info): Update.
	(m32r_find_callers_reg): Update.
	(m32r_frame_saved_pc): Update.
	* sh-tdep.c (sh_find_callers_reg): Update.
	(sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info): Update.
	(sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* mcore-tdep.c (mcore_find_callers_reg): Update.
	(mcore_frame_saved_pc): Update.
	(mcore_init_extra_frame_info): Update.
	* i386-tdep.c (i386_frame_saved_pc): Update.
	* ia64-tdep.c (ia64_frame_saved_pc): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_init_extra_frame_info): Update.
	* d10v-tdep.c (d10v_frame_saved_pc): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_frame_chain): Update.
	(avr_init_extra_frame_info): Update.
	(avr_frame_saved_pc): Update.
	* arm-tdep.c (arm_find_callers_reg): Update.
	(arm_init_extra_frame_info): Update.
	(arm_frame_saved_pc): Update.
@
text
@d1598 4
a1601 4
            write_register_gen (S390_GP0_REGNUM + gr,
                                VALUE_CONTENTS (arg));
            write_register_gen (S390_GP0_REGNUM + gr + 1,
                                VALUE_CONTENTS (arg) + 4);
@


1.52.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d42 1
a42 1
#include "dis-asm.h"
d48 1
a48 1
static int
d58 1
a58 1
static int
d65 1
a65 1
static int
d72 1
a72 1
static int
d87 1
d97 1
a97 3
#define S390_STACK_FRAME_OVERHEAD  16*DEPRECATED_REGISTER_SIZE+32
#define S390_STACK_PARAMETER_ALIGNMENT  DEPRECATED_REGISTER_SIZE
#define S390_NUM_FP_PARAMETER_REGISTERS (GDB_TARGET_IS_ESAME ? 4:2)
a114 1
  CORE_ADDR stack_bought_valid;
d122 3
a124 2
static int
s390_readinstruction (bfd_byte instr[], CORE_ADDR at)
d134 1
a134 1
  if (target_read_memory (at, &instr[0], 2))
d139 1
a139 1
      if (target_read_memory (at + 2, &instr[2], instrlen - 2))
d153 1
a153 1
static const char *
d178 1
a178 1
static int
d190 4
a193 114
/* Prologue analysis.  */

/* When we analyze a prologue, we're really doing 'abstract
   interpretation' or 'pseudo-evaluation': running the function's code
   in simulation, but using conservative approximations of the values
   it would have when it actually runs.  For example, if our function
   starts with the instruction:

      ahi r1, 42     # add halfword immediate 42 to r1

   we don't know exactly what value will be in r1 after executing this
   instruction, but we do know it'll be 42 greater than its original
   value.

   If we then see an instruction like:

      ahi r1, 22     # add halfword immediate 22 to r1

   we still don't know what r1's value is, but again, we can say it is
   now 64 greater than its original value.

   If the next instruction were:

      lr r2, r1      # set r2 to r1's value

   then we can say that r2's value is now the original value of r1
   plus 64.  And so on.

   Of course, this can only go so far before it gets unreasonable.  If
   we wanted to be able to say anything about the value of r1 after
   the instruction:

      xr r1, r3      # exclusive-or r1 and r3, place result in r1

   then things would get pretty complex.  But remember, we're just
   doing a conservative approximation; if exclusive-or instructions
   aren't relevant to prologues, we can just say r1's value is now
   'unknown'.  We can ignore things that are too complex, if that loss
   of information is acceptable for our application.

   Once you've reached an instruction that you don't know how to
   simulate, you stop.  Now you examine the state of the registers and
   stack slots you've kept track of.  For example:

   - To see how large your stack frame is, just check the value of sp;
     if it's the original value of sp minus a constant, then that
     constant is the stack frame's size.  If the sp's value has been
     marked as 'unknown', then that means the prologue has done
     something too complex for us to track, and we don't know the
     frame size.

   - To see whether we've saved the SP in the current frame's back
     chain slot, we just check whether the current value of the back
     chain stack slot is the original value of the sp.

   Sure, this takes some work.  But prologue analyzers aren't
   quick-and-simple pattern patching to recognize a few fixed prologue
   forms any more; they're big, hairy functions.  Along with inferior
   function calls, prologue analysis accounts for a substantial
   portion of the time needed to stabilize a GDB port.  So I think
   it's worthwhile to look for an approach that will be easier to
   understand and maintain.  In the approach used here:

   - It's easier to see that the analyzer is correct: you just see
     whether the analyzer properly (albiet conservatively) simulates
     the effect of each instruction.

   - It's easier to extend the analyzer: you can add support for new
     instructions, and know that you haven't broken anything that
     wasn't already broken before.

   - It's orthogonal: to gather new information, you don't need to
     complicate the code for each instruction.  As long as your domain
     of conservative values is already detailed enough to tell you
     what you need, then all the existing instruction simulations are
     already gathering the right data for you.

   A 'struct prologue_value' is a conservative approximation of the
   real value the register or stack slot will have.  */

struct prologue_value {

  /* What sort of value is this?  This determines the interpretation
     of subsequent fields.  */
  enum {

    /* We don't know anything about the value.  This is also used for
       values we could have kept track of, when doing so would have
       been too complex and we don't want to bother.  The bottom of
       our lattice.  */
    pv_unknown,

    /* A known constant.  K is its value.  */
    pv_constant,

    /* The value that register REG originally had *UPON ENTRY TO THE
       FUNCTION*, plus K.  If K is zero, this means, obviously, just
       the value REG had upon entry to the function.  REG is a GDB
       register number.  Before we start interpreting, we initialize
       every register R to { pv_register, R, 0 }.  */
    pv_register,

  } kind;

  /* The meanings of the following fields depend on 'kind'; see the
     comments for the specific 'kind' values.  */
  int reg;
  CORE_ADDR k;
};


/* Set V to be unknown.  */
static void
pv_set_to_unknown (struct prologue_value *v)
d195 1
a195 1
  v->kind = pv_unknown;
d199 3
a201 8
/* Set V to the constant K.  */
static void
pv_set_to_constant (struct prologue_value *v, CORE_ADDR k)
{
  v->kind = pv_constant;
  v->k = k;
}

d203 7
a209 8
/* Set V to the original value of register REG, plus K.  */
static void
pv_set_to_register (struct prologue_value *v, int reg, CORE_ADDR k)
{
  v->kind = pv_register;
  v->reg = reg;
  v->k = k;
}
d211 1
d213 3
a215 7
/* If one of *A and *B is a constant, and the other isn't, swap the
   pointers as necessary to ensure that *B points to the constant.
   This can reduce the number of cases we need to analyze in the
   functions below.  */
static void
pv_constant_last (struct prologue_value **a,
                  struct prologue_value **b)
d217 67
a283 36
  if ((*a)->kind == pv_constant
      && (*b)->kind != pv_constant)
    {
      struct prologue_value *temp = *a;
      *a = *b;
      *b = temp;
    }
}


/* Set SUM to the sum of A and B.  SUM, A, and B may point to the same
   'struct prologue_value' object.  */
static void
pv_add (struct prologue_value *sum,
        struct prologue_value *a,
        struct prologue_value *b)
{
  pv_constant_last (&a, &b);

  /* We can handle adding constants to registers, and other constants.  */
  if (b->kind == pv_constant
      && (a->kind == pv_register
          || a->kind == pv_constant))
    {
      sum->kind = a->kind;
      sum->reg = a->reg;    /* not meaningful if a is pv_constant, but
                               harmless */
      sum->k = a->k + b->k;
    }

  /* Anything else we don't know how to add.  We don't have a
     representation for, say, the sum of two registers, or a multiple
     of a register's value (adding a register to itself).  */
  else
    sum->kind = pv_unknown;
}
d285 2
a286 38

/* Add the constant K to V.  */
static void
pv_add_constant (struct prologue_value *v, CORE_ADDR k)
{
  struct prologue_value pv_k;

  /* Rather than thinking of all the cases we can and can't handle,
     we'll just let pv_add take care of that for us.  */
  pv_set_to_constant (&pv_k, k);
  pv_add (v, v, &pv_k);
}


/* Subtract B from A, and put the result in DIFF.

   This isn't quite the same as negating B and adding it to A, since
   we don't have a representation for the negation of anything but a
   constant.  For example, we can't negate { pv_register, R1, 10 },
   but we do know that { pv_register, R1, 10 } minus { pv_register,
   R1, 5 } is { pv_constant, <ignored>, 5 }.

   This means, for example, that we can subtract two stack addresses;
   they're both relative to the original SP.  Since the frame pointer
   is set based on the SP, its value will be the original SP plus some
   constant (probably zero), so we can use its value just fine.  */
static void
pv_subtract (struct prologue_value *diff,
             struct prologue_value *a,
             struct prologue_value *b)
{
  pv_constant_last (&a, &b);

  /* We can subtract a constant from another constant, or from a
     register.  */
  if (b->kind == pv_constant
      && (a->kind == pv_register
          || a->kind == pv_constant))
d288 13
a300 3
      diff->kind = a->kind;
      diff->reg = a->reg;    /* not always meaningful, but harmless */
      diff->k = a->k - b->k;
d302 2
a303 5

  /* We can subtract a register from itself, yielding a constant.  */
  else if (a->kind == pv_register
           && b->kind == pv_register
           && a->reg == b->reg)
d305 118
a422 17
      diff->kind = pv_constant;
      diff->k = a->k - b->k;
    }

  /* We don't know how to subtract anything else.  */
  else
    diff->kind = pv_unknown;
}


/* Set AND to the logical and of A and B.  */
static void
pv_logical_and (struct prologue_value *and,
                struct prologue_value *a,
                struct prologue_value *b)
{
  pv_constant_last (&a, &b);
d424 17
a440 123
  /* We can 'and' two constants.  */
  if (a->kind == pv_constant
      && b->kind == pv_constant)
    {
      and->kind = pv_constant;
      and->k = a->k & b->k;
    }

  /* We can 'and' anything with the constant zero.  */
  else if (b->kind == pv_constant
           && b->k == 0)
    {
      and->kind = pv_constant;
      and->k = 0;
    }
  
  /* We can 'and' anything with ~0.  */
  else if (b->kind == pv_constant
           && b->k == ~ (CORE_ADDR) 0)
    *and = *a;

  /* We can 'and' a register with itself.  */
  else if (a->kind == pv_register
           && b->kind == pv_register
           && a->reg == b->reg
           && a->k == b->k)
    *and = *a;

  /* Otherwise, we don't know.  */
  else
    pv_set_to_unknown (and);
}


/* Return non-zero iff A and B are identical expressions.

   This is not the same as asking if the two values are equal; the
   result of such a comparison would have to be a pv_boolean, and
   asking whether two 'unknown' values were equal would give you
   pv_maybe.  Same for comparing, say, { pv_register, R1, 0 } and {
   pv_register, R2, 0}.  Instead, this is asking whether the two
   representations are the same.  */
static int
pv_is_identical (struct prologue_value *a,
                 struct prologue_value *b)
{
  if (a->kind != b->kind)
    return 0;

  switch (a->kind)
    {
    case pv_unknown:
      return 1;
    case pv_constant:
      return (a->k == b->k);
    case pv_register:
      return (a->reg == b->reg && a->k == b->k);
    default:
      gdb_assert (0);
    }
}


/* Return non-zero if A is the original value of register number R
   plus K, zero otherwise.  */
static int
pv_is_register (struct prologue_value *a, int r, CORE_ADDR k)
{
  return (a->kind == pv_register
          && a->reg == r
          && a->k == k);
}


/* A prologue-value-esque boolean type, including "maybe", when we
   can't figure out whether something is true or not.  */
enum pv_boolean {
  pv_maybe,
  pv_definite_yes,
  pv_definite_no,
};


/* Decide whether a reference to SIZE bytes at ADDR refers exactly to
   an element of an array.  The array starts at ARRAY_ADDR, and has
   ARRAY_LEN values of ELT_SIZE bytes each.  If ADDR definitely does
   refer to an array element, set *I to the index of the referenced
   element in the array, and return pv_definite_yes.  If it definitely
   doesn't, return pv_definite_no.  If we can't tell, return pv_maybe.

   If the reference does touch the array, but doesn't fall exactly on
   an element boundary, or doesn't refer to the whole element, return
   pv_maybe.  */
static enum pv_boolean
pv_is_array_ref (struct prologue_value *addr,
                 CORE_ADDR size,
                 struct prologue_value *array_addr,
                 CORE_ADDR array_len, 
                 CORE_ADDR elt_size,
                 int *i)
{
  struct prologue_value offset;

  /* Note that, since ->k is a CORE_ADDR, and CORE_ADDR is unsigned,
     if addr is *before* the start of the array, then this isn't going
     to be negative...  */
  pv_subtract (&offset, addr, array_addr);

  if (offset.kind == pv_constant)
    {
      /* This is a rather odd test.  We want to know if the SIZE bytes
         at ADDR don't overlap the array at all, so you'd expect it to
         be an || expression: "if we're completely before || we're
         completely after".  But with unsigned arithmetic, things are
         different: since it's a number circle, not a number line, the
         right values for offset.k are actually one contiguous range.  */
      if (offset.k <= -size
          && offset.k >= array_len * elt_size)
        return pv_definite_no;
      else if (offset.k % elt_size != 0
               || size != elt_size)
        return pv_maybe;
      else
d442 2
a443 2
          *i = offset.k / elt_size;
          return pv_definite_yes;
a444 4
    }
  else
    return pv_maybe;
}
d446 20
d468 2
a469 1
/* Decoding S/390 instructions.  */
d471 137
a607 27
/* Named opcode values for the S/390 instructions we recognize.  Some
   instructions have their opcode split across two fields; those are the
   op1_* and op2_* enums.  */
enum
  {
    op1_aghi = 0xa7,   op2_aghi = 0xb,
    op1_ahi  = 0xa7,   op2_ahi  = 0xa,
    op_ar    = 0x1a,
    op_basr  = 0x0d,
    op1_bras = 0xa7,   op2_bras = 0x5,
    op_l     = 0x58,
    op_la    = 0x41,
    op1_larl = 0xc0,   op2_larl = 0x0,
    op_lgr   = 0xb904,
    op1_lghi = 0xa7,   op2_lghi = 0x9,
    op1_lhi  = 0xa7,   op2_lhi  = 0x8,
    op_lr    = 0x18,
    op_nr    = 0x14,
    op_ngr   = 0xb980,
    op_s     = 0x5b,
    op_st    = 0x50,
    op_std   = 0x60,
    op1_stg  = 0xe3,   op2_stg  = 0x24,
    op_stm   = 0x90,
    op1_stmg = 0xeb,   op2_stmg = 0x24,
    op_svc   = 0x0a,
  };
d609 33
a641 73

/* The functions below are for recognizing and decoding S/390
   instructions of various formats.  Each of them checks whether INSN
   is an instruction of the given format, with the specified opcodes.
   If it is, it sets the remaining arguments to the values of the
   instruction's fields, and returns a non-zero value; otherwise, it
   returns zero.

   These functions' arguments appear in the order they appear in the
   instruction, not in the machine-language form.  So, opcodes always
   come first, even though they're sometimes scattered around the
   instructions.  And displacements appear before base and extension
   registers, as they do in the assembly syntax, not at the end, as
   they do in the machine language.  */
static int
is_ri (bfd_byte *insn, int op1, int op2, unsigned int *r1, int *i2)
{
  if (insn[0] == op1 && (insn[1] & 0xf) == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      /* i2 is a 16-bit signed quantity.  */
      *i2 = (((insn[2] << 8) | insn[3]) ^ 0x8000) - 0x8000;
      return 1;
    }
  else
    return 0;
}


static int
is_ril (bfd_byte *insn, int op1, int op2,
        unsigned int *r1, int *i2)
{
  if (insn[0] == op1 && (insn[1] & 0xf) == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      /* i2 is a signed quantity.  If the host 'int' is 32 bits long,
         no sign extension is necessary, but we don't want to assume
         that.  */
      *i2 = (((insn[2] << 24)
              | (insn[3] << 16)
              | (insn[4] << 8)
              | (insn[5])) ^ 0x80000000) - 0x80000000;
      return 1;
    }
  else
    return 0;
}


static int
is_rr (bfd_byte *insn, int op, unsigned int *r1, unsigned int *r2)
{
  if (insn[0] == op)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *r2 = insn[1] & 0xf;
      return 1;
    }
  else
    return 0;
}


static int
is_rre (bfd_byte *insn, int op, unsigned int *r1, unsigned int *r2)
{
  if (((insn[0] << 8) | insn[1]) == op)
    {
      /* Yes, insn[3].  insn[2] is unused in RRE format.  */
      *r1 = (insn[3] >> 4) & 0xf;
      *r2 = insn[3] & 0xf;
      return 1;
d643 2
a644 10
  else
    return 0;
}


static int
is_rs (bfd_byte *insn, int op,
       unsigned int *r1, unsigned int *r3, unsigned int *d2, unsigned int *b2)
{
  if (insn[0] == op)
d646 8
a653 559
      *r1 = (insn[1] >> 4) & 0xf;
      *r3 = insn[1] & 0xf;
      *b2 = (insn[2] >> 4) & 0xf;
      *d2 = ((insn[2] & 0xf) << 8) | insn[3];
      return 1;
    }
  else
    return 0;
}


static int
is_rse (bfd_byte *insn, int op1, int op2,
        unsigned int *r1, unsigned int *r3, unsigned int *d2, unsigned int *b2)
{
  if (insn[0] == op1
      /* Yes, insn[5].  insn[4] is unused.  */
      && insn[5] == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *r3 = insn[1] & 0xf;
      *b2 = (insn[2] >> 4) & 0xf;
      *d2 = ((insn[2] & 0xf) << 8) | insn[3];
      return 1;
    }
  else
    return 0;
}


static int
is_rx (bfd_byte *insn, int op,
       unsigned int *r1, unsigned int *d2, unsigned int *x2, unsigned int *b2)
{
  if (insn[0] == op)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *x2 = insn[1] & 0xf;
      *b2 = (insn[2] >> 4) & 0xf;
      *d2 = ((insn[2] & 0xf) << 8) | insn[3];
      return 1;
    }
  else
    return 0;
}


static int
is_rxe (bfd_byte *insn, int op1, int op2,
        unsigned int *r1, unsigned int *d2, unsigned int *x2, unsigned int *b2)
{
  if (insn[0] == op1
      /* Yes, insn[5].  insn[4] is unused.  */
      && insn[5] == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *x2 = insn[1] & 0xf;
      *b2 = (insn[2] >> 4) & 0xf;
      *d2 = ((insn[2] & 0xf) << 8) | insn[3];
      return 1;
    }
  else
    return 0;
}


/* Set ADDR to the effective address for an X-style instruction, like:

        L R1, D2(X2, B2)

   Here, X2 and B2 are registers, and D2 is an unsigned 12-bit
   constant; the effective address is the sum of all three.  If either
   X2 or B2 are zero, then it doesn't contribute to the sum --- this
   means that r0 can't be used as either X2 or B2.

   GPR is an array of general register values, indexed by GPR number,
   not GDB register number.  */
static void
compute_x_addr (struct prologue_value *addr, 
                struct prologue_value *gpr,
                unsigned int d2, unsigned int x2, unsigned int b2)
{
  /* We can't just add stuff directly in addr; it might alias some of
     the registers we need to read.  */
  struct prologue_value result;

  pv_set_to_constant (&result, d2);
  if (x2)
    pv_add (&result, &result, &gpr[x2]);
  if (b2)
    pv_add (&result, &result, &gpr[b2]);

  *addr = result;
}


/* The number of GPR and FPR spill slots in an S/390 stack frame.  We
   track general-purpose registers r2 -- r15, and floating-point
   registers f0, f2, f4, and f6.  */
#define S390_NUM_SPILL_SLOTS (14 + 4)


/* If the SIZE bytes at ADDR are a stack slot we're actually tracking,
   return pv_definite_yes and set *STACK to point to the slot.  If
   we're sure that they are not any of our stack slots, then return
   pv_definite_no.  Otherwise, return pv_maybe.
   - GPR is an array indexed by GPR number giving the current values
     of the general-purpose registers.
   - SPILL is an array tracking the spill area of the caller's frame;
     SPILL[i] is the i'th spill slot.  The spill slots are designated
     for r2 -- r15, and then f0, f2, f4, and f6.
   - BACK_CHAIN is the value of the back chain slot; it's only valid
     when the current frame actually has some space for a back chain
     slot --- that is, when the current value of the stack pointer
     (according to GPR) is at least S390_STACK_FRAME_OVERHEAD bytes
     less than its original value.  */
static enum pv_boolean
s390_on_stack (struct prologue_value *addr,
               CORE_ADDR size,
               struct prologue_value *gpr,
               struct prologue_value *spill, 
               struct prologue_value *back_chain,
               struct prologue_value **stack)
{
  struct prologue_value gpr_spill_addr;
  struct prologue_value fpr_spill_addr;
  struct prologue_value back_chain_addr;  
  int i;
  enum pv_boolean b;

  /* Construct the addresses of the spill arrays and the back chain.  */
  pv_set_to_register (&gpr_spill_addr, S390_SP_REGNUM, 2 * S390_GPR_SIZE);
  pv_set_to_register (&fpr_spill_addr, S390_SP_REGNUM, 16 * S390_GPR_SIZE);
  back_chain_addr = gpr[S390_SP_REGNUM - S390_GP0_REGNUM];

  /* We have to check for GPR and FPR references using two separate
     calls to pv_is_array_ref, since the GPR and FPR spill slots are
     different sizes.  (SPILL is an array, but the thing it tracks
     isn't really an array.)  */

  /* Was it a reference to the GPR spill array?  */
  b = pv_is_array_ref (addr, size, &gpr_spill_addr, 14, S390_GPR_SIZE, &i);
  if (b == pv_definite_yes)
    {
      *stack = &spill[i];
      return pv_definite_yes;
    }
  if (b == pv_maybe)
    return pv_maybe;

  /* Was it a reference to the FPR spill array?  */
  b = pv_is_array_ref (addr, size, &fpr_spill_addr, 4, S390_FPR_SIZE, &i);
  if (b == pv_definite_yes)
    {
      *stack = &spill[14 + i];
      return pv_definite_yes;
    }
  if (b == pv_maybe)
    return pv_maybe;

  /* Was it a reference to the back chain?
     This isn't quite right.  We ought to check whether we have
     actually allocated any new frame at all.  */
  b = pv_is_array_ref (addr, size, &back_chain_addr, 1, S390_GPR_SIZE, &i);
  if (b == pv_definite_yes)
    {
      *stack = back_chain;
      return pv_definite_yes;
    }
  if (b == pv_maybe)
    return pv_maybe;

  /* All the above queries returned definite 'no's.  */
  return pv_definite_no;
}


/* Do a SIZE-byte store of VALUE to ADDR.  GPR, SPILL, and BACK_CHAIN,
   and the return value are as described for s390_on_stack, above.
   Note that, when this returns pv_maybe, we have to assume that all
   of our memory now contains unknown values.  */
static enum pv_boolean
s390_store (struct prologue_value *addr,
            CORE_ADDR size,
            struct prologue_value *value,
            struct prologue_value *gpr,
            struct prologue_value *spill, 
            struct prologue_value *back_chain)
{
  struct prologue_value *stack;
  enum pv_boolean on_stack
    = s390_on_stack (addr, size, gpr, spill, back_chain, &stack);

  if (on_stack == pv_definite_yes)
    *stack = *value;

  return on_stack;
}
            

/* The current frame looks like a signal delivery frame: the first
   instruction is an 'svc' opcode.  If the next frame is a signal
   handler's frame, set FI's saved register map to point into the
   signal context structure.  */
static void
s390_get_signal_frame_info (struct frame_info *fi)
{
  struct frame_info *next_frame = get_next_frame (fi);

  if (next_frame
      && get_frame_extra_info (next_frame)
      && get_frame_extra_info (next_frame)->sigcontext)
    {
      /* We're definitely backtracing from a signal handler.  */
      CORE_ADDR *saved_regs = deprecated_get_frame_saved_regs (fi);
      CORE_ADDR save_reg_addr = (get_frame_extra_info (next_frame)->sigcontext
                                 + DEPRECATED_REGISTER_BYTE (S390_GP0_REGNUM));
      int reg;

      for (reg = 0; reg < S390_NUM_GPRS; reg++)
        {
          saved_regs[S390_GP0_REGNUM + reg] = save_reg_addr;
          save_reg_addr += S390_GPR_SIZE;
        }

      save_reg_addr = (get_frame_extra_info (next_frame)->sigcontext
                       + (GDB_TARGET_IS_ESAME ? S390X_SIGREGS_FP0_OFFSET :
                          S390_SIGREGS_FP0_OFFSET));
      for (reg = 0; reg < S390_NUM_FPRS; reg++)
        {
          saved_regs[S390_FP0_REGNUM + reg] = save_reg_addr;
          save_reg_addr += S390_FPR_SIZE;
        }
    }
}


static int
s390_get_frame_info (CORE_ADDR start_pc,
                     struct frame_extra_info *fextra_info,
                     struct frame_info *fi,
                     int init_extra_info)
{
  /* Our return value:
     zero if we were able to read all the instructions we wanted, or
     -1 if we got an error trying to read memory.  */
  int result = 0;

  /* The current PC for our abstract interpretation.  */
  CORE_ADDR pc;

  /* The address of the next instruction after that.  */
  CORE_ADDR next_pc;
  
  /* The general-purpose registers.  */
  struct prologue_value gpr[S390_NUM_GPRS];

  /* The floating-point registers.  */
  struct prologue_value fpr[S390_NUM_FPRS];

  /* The register spill stack slots in the caller's frame ---
     general-purpose registers r2 through r15, and floating-point
     registers.  spill[i] is where gpr i+2 gets spilled;
     spill[(14, 15, 16, 17)] is where (f0, f2, f4, f6) get spilled.  */
  struct prologue_value spill[S390_NUM_SPILL_SLOTS];

  /* The value of the back chain slot.  This is only valid if the stack
     pointer is known to be less than its original value --- that is,
     if we have indeed allocated space on the stack.  */
  struct prologue_value back_chain;

  /* The address of the instruction after the last one that changed
     the SP, FP, or back chain.  */
  CORE_ADDR after_last_frame_setup_insn = start_pc;

  /* Set up everything's initial value.  */
  {
    int i;

    for (i = 0; i < S390_NUM_GPRS; i++)
      pv_set_to_register (&gpr[i], S390_GP0_REGNUM + i, 0);

    for (i = 0; i < S390_NUM_FPRS; i++)
      pv_set_to_register (&fpr[i], S390_FP0_REGNUM + i, 0);

    for (i = 0; i < S390_NUM_SPILL_SLOTS; i++)
      pv_set_to_unknown (&spill[i]);

    pv_set_to_unknown (&back_chain);
  }

  /* Start interpreting instructions, until we hit something we don't
     know how to interpret.  (Ideally, we should stop at the frame's
     real current PC, but at the moment, our callers don't give us
     that info.)  */
  for (pc = start_pc; ; pc = next_pc)
    {
      bfd_byte insn[S390_MAX_INSTR_SIZE];
      int insn_len = s390_readinstruction (insn, pc);

      /* Fields for various kinds of instructions.  */
      unsigned int b2, r1, r2, d2, x2, r3;
      int i2;

      /* The values of SP, FP, and back chain before this instruction,
         for detecting instructions that change them.  */
      struct prologue_value pre_insn_sp, pre_insn_fp, pre_insn_back_chain;

      /* If we got an error trying to read the instruction, report it.  */
      if (insn_len < 0)
        {
          result = -1;
          break;
        }

      next_pc = pc + insn_len;

      pre_insn_sp = gpr[S390_SP_REGNUM - S390_GP0_REGNUM];
      pre_insn_fp = gpr[S390_FRAME_REGNUM - S390_GP0_REGNUM];
      pre_insn_back_chain = back_chain;

      /* A special case, first --- only recognized as the very first
         instruction of the function, for signal delivery frames:
         SVC i --- system call  */
      if (pc == start_pc
          && is_rr (insn, op_svc, &r1, &r2))
        {
          if (fi)
            s390_get_signal_frame_info (fi);
          break;
        }
        
      /* AHI r1, i2 --- add halfword immediate */
      else if (is_ri (insn, op1_ahi, op2_ahi, &r1, &i2))
        pv_add_constant (&gpr[r1], i2);


      /* AGHI r1, i2 --- add halfword immediate (64-bit version) */
      else if (GDB_TARGET_IS_ESAME
               && is_ri (insn, op1_aghi, op2_aghi, &r1, &i2))
        pv_add_constant (&gpr[r1], i2);

      /* AR r1, r2 -- add register */
      else if (is_rr (insn, op_ar, &r1, &r2))
        pv_add (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* BASR r1, 0 --- branch and save
         Since r2 is zero, this saves the PC in r1, but doesn't branch.  */
      else if (is_rr (insn, op_basr, &r1, &r2)
               && r2 == 0)
        pv_set_to_constant (&gpr[r1], next_pc);

      /* BRAS r1, i2 --- branch relative and save */
      else if (is_ri (insn, op1_bras, op2_bras, &r1, &i2))
        {
          pv_set_to_constant (&gpr[r1], next_pc);
          next_pc = pc + i2 * 2;

          /* We'd better not interpret any backward branches.  We'll
             never terminate.  */
          if (next_pc <= pc)
            break;
        }

      /* L r1, d2(x2, b2) --- load */
      else if (is_rx (insn, op_l, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;
          struct prologue_value *stack;

          compute_x_addr (&addr, gpr, d2, x2, b2);

          /* If it's a load from an in-line constant pool, then we can
             simulate that, under the assumption that the code isn't
             going to change between the time the processor actually
             executed it creating the current frame, and the time when
             we're analyzing the code to unwind past that frame.  */
          if (addr.kind == pv_constant
              && start_pc <= addr.k 
              && addr.k < next_pc)
            pv_set_to_constant (&gpr[r1], 
                                read_memory_integer (addr.k, 4));

          /* If it's definitely a reference to something on the stack, 
             we can do that.  */
          else if (s390_on_stack (&addr, 4, gpr, spill, &back_chain, &stack)
                   == pv_definite_yes)
            gpr[r1] = *stack;

          /* Otherwise, we don't know the value.  */
          else
            pv_set_to_unknown (&gpr[r1]);
        }

      /* LA r1, d2(x2, b2) --- load address */
      else if (is_rx (insn, op_la, &r1, &d2, &x2, &b2))
        compute_x_addr (&gpr[r1], gpr, d2, x2, b2);

      /* LARL r1, i2 --- load address relative long */
      else if (GDB_TARGET_IS_ESAME 
               && is_ril (insn, op1_larl, op2_larl, &r1, &i2))
        pv_set_to_constant (&gpr[r1], pc + i2 * 2);

      /* LGR r1, r2 --- load from register */
      else if (GDB_TARGET_IS_ESAME
               && is_rre (insn, op_lgr, &r1, &r2))
        gpr[r1] = gpr[r2];

      /* LHI r1, i2 --- load halfword immediate */
      else if (is_ri (insn, op1_lhi, op2_lhi, &r1, &i2))
        pv_set_to_constant (&gpr[r1], i2);

      /* LGHI r1, i2 --- load halfword immediate --- 64-bit version */
      else if (is_ri (insn, op1_lghi, op2_lghi, &r1, &i2))
        pv_set_to_constant (&gpr[r1], i2);

      /* LR r1, r2 --- load from register */
      else if (is_rr (insn, op_lr, &r1, &r2))
        gpr[r1] = gpr[r2];

      /* NGR r1, r2 --- logical and --- 64-bit version */
      else if (GDB_TARGET_IS_ESAME
               && is_rre (insn, op_ngr, &r1, &r2))
        pv_logical_and (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* NR r1, r2 --- logical and */
      else if (is_rr (insn, op_nr, &r1, &r2))
        pv_logical_and (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* NGR r1, r2 --- logical and --- 64-bit version */
      else if (GDB_TARGET_IS_ESAME
               && is_rre (insn, op_ngr, &r1, &r2))
        pv_logical_and (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* NR r1, r2 --- logical and */
      else if (is_rr (insn, op_nr, &r1, &r2))
        pv_logical_and (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* S r1, d2(x2, b2) --- subtract from memory */
      else if (is_rx (insn, op_s, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;
          struct prologue_value value;
          struct prologue_value *stack;

          compute_x_addr (&addr, gpr, d2, x2, b2);

          /* If it's a load from an in-line constant pool, then we can
             simulate that, under the assumption that the code isn't
             going to change between the time the processor actually
             executed it and the time when we're analyzing it.  */
          if (addr.kind == pv_constant
              && start_pc <= addr.k 
              && addr.k < pc)
            pv_set_to_constant (&value, read_memory_integer (addr.k, 4));

          /* If it's definitely a reference to something on the stack,
             we could do that.  */
          else if (s390_on_stack (&addr, 4, gpr, spill, &back_chain, &stack)
                   == pv_definite_yes)
            value = *stack;

          /* Otherwise, we don't know the value.  */
          else
            pv_set_to_unknown (&value);

          pv_subtract (&gpr[r1], &gpr[r1], &value);
        }

      /* ST r1, d2(x2, b2) --- store  */
      else if (is_rx (insn, op_st, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;

          compute_x_addr (&addr, gpr, d2, x2, b2);

          /* The below really should be '4', not 'S390_GPR_SIZE'; this
             instruction always stores 32 bits, regardless of the full
             size of the GPR.  */
          if (s390_store (&addr, 4, &gpr[r1], gpr, spill, &back_chain)
              == pv_maybe)
            /* If we can't be sure that it's *not* a store to
               something we're tracing, then we would have to mark all
               our memory as unknown --- after all, it *could* be a
               store to any of them --- so we might as well just stop
               interpreting.  */
            break;
        }

      /* STD r1, d2(x2,b2) --- store floating-point register  */
      else if (is_rx (insn, op_std, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;

          compute_x_addr (&addr, gpr, d2, x2, b2);

          if (s390_store (&addr, 8, &fpr[r1], gpr, spill, &back_chain)
              == pv_maybe)
            /* If we can't be sure that it's *not* a store to
               something we're tracing, then we would have to mark all
               our memory as unknown --- after all, it *could* be a
               store to any of them --- so we might as well just stop
               interpreting.  */
            break;
        }

      /* STG r1, d2(x2, b2) --- 64-bit store */
      else if (GDB_TARGET_IS_ESAME
               && is_rxe (insn, op1_stg, op2_stg, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;

          compute_x_addr (&addr, gpr, d2, x2, b2);

          /* The below really should be '8', not 'S390_GPR_SIZE'; this
             instruction always stores 64 bits, regardless of the full
             size of the GPR.  */
          if (s390_store (&addr, 8, &gpr[r1], gpr, spill, &back_chain)
              == pv_maybe)
            /* If we can't be sure that it's *not* a store to
               something we're tracing, then we would have to mark all
               our memory as unknown --- after all, it *could* be a
               store to any of them --- so we might as well just stop
               interpreting.  */
            break;
        }

      /* STM r1, r3, d2(b2) --- store multiple */
      else if (is_rs (insn, op_stm, &r1, &r3, &d2, &b2))
        {
          int regnum;
          int offset;
          struct prologue_value addr;

          for (regnum = r1, offset = 0;
               regnum <= r3;
               regnum++, offset += 4)
            {
              compute_x_addr (&addr, gpr, d2 + offset, 0, b2);
              
              if (s390_store (&addr, 4, &gpr[regnum], gpr, spill, &back_chain)
                  == pv_maybe)
                /* If we can't be sure that it's *not* a store to
                   something we're tracing, then we would have to mark all
                   our memory as unknown --- after all, it *could* be a
                   store to any of them --- so we might as well just stop
                   interpreting.  */
                break;
            }

          /* If we left the loop early, we should stop interpreting
             altogether.  */
          if (regnum <= r3)
            break;
        }

      /* STMG r1, r3, d2(b2) --- store multiple, 64-bit */
      else if (GDB_TARGET_IS_ESAME
               && is_rse (insn, op1_stmg, op2_stmg, &r1, &r3, &d2, &b2))
d655 2
a656 24
          int regnum;
          int offset;
          struct prologue_value addr;

          for (regnum = r1, offset = 0;
               regnum <= r3;
               regnum++, offset += 8)
            {
              compute_x_addr (&addr, gpr, d2 + offset, 0, b2);
              
              if (s390_store (&addr, 8, &gpr[regnum], gpr, spill, &back_chain)
                  == pv_maybe)
                /* If we can't be sure that it's *not* a store to
                   something we're tracing, then we would have to mark all
                   our memory as unknown --- after all, it *could* be a
                   store to any of them --- so we might as well just stop
                   interpreting.  */
                break;
            }

          /* If we left the loop early, we should stop interpreting
             altogether.  */
          if (regnum <= r3)
            break;
a657 17

      else
        /* An instruction we don't know how to simulate.  The only
           safe thing to do would be to set every value we're tracking
           to 'unknown'.  Instead, we'll be optimistic: we just stop
           interpreting, and assume that the machine state we've got
           now is good enough for unwinding the stack.  */
        break;

      /* Record the address after the last instruction that changed
         the FP, SP, or backlink.  Ignore instructions that changed
         them back to their original values --- those are probably
         restore instructions.  (The back chain is never restored,
         just popped.)  */
      {
        struct prologue_value *sp = &gpr[S390_SP_REGNUM - S390_GP0_REGNUM];
        struct prologue_value *fp = &gpr[S390_FRAME_REGNUM - S390_GP0_REGNUM];
d659 3
a661 7
        if ((! pv_is_identical (&pre_insn_sp, sp)
             && ! pv_is_register (sp, S390_SP_REGNUM, 0))
            || (! pv_is_identical (&pre_insn_fp, fp)
                && ! pv_is_register (fp, S390_FRAME_REGNUM, 0))
            || ! pv_is_identical (&pre_insn_back_chain, &back_chain))
          after_last_frame_setup_insn = next_pc;
      }
d663 1
a663 19

  /* Okay, now gpr[], fpr[], spill[], and back_chain reflect the state
     of the machine as of the first instruction we couldn't interpret
     (hopefully the first non-prologue instruction).  */
  {
    /* The size of the frame, or (CORE_ADDR) -1 if we couldn't figure
       that out.  */
    CORE_ADDR frame_size = -1;

    /* The value the SP had upon entry to the function, or
       (CORE_ADDR) -1 if we can't figure that out.  */
    CORE_ADDR original_sp = -1;

    /* Are we using S390_FRAME_REGNUM as a frame pointer register?  */
    int using_frame_pointer = 0;

    /* If S390_FRAME_REGNUM is some constant offset from the SP, then
       that strongly suggests that we're going to use that as our
       frame pointer register, not the SP.  */
d665 3
a667 5
      struct prologue_value *fp = &gpr[S390_FRAME_REGNUM - S390_GP0_REGNUM];

      if (fp->kind == pv_register
          && fp->reg == S390_SP_REGNUM)
        using_frame_pointer = 1;
d669 5
a673 150

    /* If we were given a frame_info structure, we may be able to use
       the frame's base address to figure out the actual value of the
       original SP.  */
    if (fi && get_frame_base (fi))
      {
        int frame_base_regno;
        struct prologue_value *frame_base;

        /* The meaning of the frame base depends on whether the
           function uses a frame pointer register other than the SP or
           not (see s390_read_fp):
           - If the function does use a frame pointer register other
             than the SP, then the frame base is that register's
             value.
           - If the function doesn't use a frame pointer, then the
             frame base is the SP itself.
           We're duplicating some of the logic of s390_fp_regnum here,
           but we don't want to call that, because it would just do
           exactly the same analysis we've already done above.  */
        if (using_frame_pointer)
          frame_base_regno = S390_FRAME_REGNUM;
        else
          frame_base_regno = S390_SP_REGNUM;

        frame_base = &gpr[frame_base_regno - S390_GP0_REGNUM];

        /* We know the frame base address; if the value of whatever
           register it came from is a constant offset from the
           original SP, then we can reconstruct the original SP just
           by subtracting off that constant.  */
        if (frame_base->kind == pv_register
            && frame_base->reg == S390_SP_REGNUM)
          original_sp = get_frame_base (fi) - frame_base->k;
      }

    /* If the analysis said that the current SP value is the original
       value less some constant, then that constant is the frame size.  */
    {
      struct prologue_value *sp = &gpr[S390_SP_REGNUM - S390_GP0_REGNUM];

      if (sp->kind == pv_register
          && sp->reg == S390_SP_REGNUM)
        frame_size = -sp->k;
    }

    /* If we knew other registers' current values, we could check if
       the analysis said any of those were related to the original SP
       value, too.  But for now, we'll just punt.  */

    /* If the caller passed in an 'extra info' structure, fill in the
       parts we can.  */
    if (fextra_info)
      {
        if (init_extra_info || ! fextra_info->initialised)
          {
            s390_memset_extra_info (fextra_info);
            fextra_info->function_start = start_pc;
            fextra_info->initialised = 1;
          }

        if (frame_size != -1)
          {
            fextra_info->stack_bought_valid = 1;
            fextra_info->stack_bought = frame_size;
          }

        /* Assume everything was okay, and indicate otherwise when we
           find something amiss.  */
        fextra_info->good_prologue = 1;

        if (using_frame_pointer)
          /* Actually, nobody cares about the exact PC, so any
             non-zero value will do here.  */
          fextra_info->frame_pointer_saved_pc = 1;

        /* If we weren't able to find the size of the frame, or find
           the original sp based on actual current register values,
           then we're not going to be able to unwind this frame.

           (If we're just doing prologue analysis to set a breakpoint,
           then frame_size might be known, but original_sp unknown; if
           we're analyzing a real frame which uses alloca, then
           original_sp might be known (from the frame pointer
           register), but the frame size might be unknown.)  */
        if (original_sp == -1 && frame_size == -1)
          fextra_info->good_prologue = 0;
        
        if (fextra_info->good_prologue)
          fextra_info->skip_prologue_function_start
            = after_last_frame_setup_insn;
        else 
          /* If the prologue was too complex for us to make sense of,
             then perhaps it's better to just not skip anything at
             all.  */
          fextra_info->skip_prologue_function_start = start_pc;
      }

    /* Indicate where registers were saved on the stack, if:
       - the caller seems to want to know,
       - the caller provided an actual SP, and
       - the analysis gave us enough information to actually figure it
         out.  */
    if (fi
        && deprecated_get_frame_saved_regs (fi)
        && original_sp != -1)
      {
        int slot_num;
        CORE_ADDR slot_addr;
        CORE_ADDR *saved_regs = deprecated_get_frame_saved_regs (fi);

        /* Scan the spill array; if a spill slot says it holds the
           original value of some register, then record that slot's
           address as the place that register was saved.

           Just for kicks, note that, even if registers aren't saved
           in their officially-sanctioned slots, this will still work
           --- we know what really got put where.  */

        /* First, the slots for r2 -- r15.  */
        for (slot_num = 0, slot_addr = original_sp + 2 * S390_GPR_SIZE;
             slot_num < 14;
             slot_num++, slot_addr += S390_GPR_SIZE)
          {
            struct prologue_value *slot = &spill[slot_num];

            if (slot->kind == pv_register
                && slot->k == 0)
              saved_regs[slot->reg] = slot_addr;
          }

        /* Then, the slots for f0, f2, f4, and f6.  They're a
           different size.  */
        for (slot_num = 14, slot_addr = original_sp + 16 * S390_GPR_SIZE;
             slot_num < S390_NUM_SPILL_SLOTS;
             slot_num++, slot_addr += S390_FPR_SIZE)
          {
            struct prologue_value *slot = &spill[slot_num];
            
            if (slot->kind == pv_register
                && slot->k == 0)
              saved_regs[slot->reg] = slot_addr;
          }

        /* The stack pointer's element of saved_regs[] is special.  */
        saved_regs[S390_SP_REGNUM] = original_sp;
      }
  }

  return result;
d677 1
a677 1
static int
d681 1
d684 2
a685 1
  instrlen = s390_readinstruction (instr, pc);
d694 1
a694 1
    s390_readinstruction (instr, pc - (GDB_TARGET_IS_ESAME ? 6 : 4));
d711 2
a712 1
  instrlen = s390_readinstruction (instr, pc - (GDB_TARGET_IS_ESAME ? 12 : 8));
d769 1
a769 1
static CORE_ADDR
d774 4
a777 4
  if (get_frame_extra_info (fi) && get_frame_extra_info (fi)->initialised)
    function_start = get_frame_extra_info (fi)->function_start;
  else if (get_frame_pc (fi))
    function_start = get_frame_func (fi);
d784 1
a784 1
static int
d790 1
a790 1
  if (get_next_frame (fi) == NULL)		/* no may be frameless */
d792 2
a793 2
      if (get_frame_extra_info (fi))
	fextra_info_ptr = get_frame_extra_info (fi);
d797 1
a797 1
	  s390_get_frame_info (s390_sniff_pc_function_start (get_frame_pc (fi), fi),
d800 1
a800 2
      frameless = (fextra_info_ptr->stack_bought_valid
                   && fextra_info_ptr->stack_bought == 0);
d812 1
d821 2
a822 1
  instrlen = s390_readinstruction (instr, pc);
d832 1
a832 1
	    orig_sp = get_frame_base (sighandler_fi);
d835 2
a836 1
					read_memory_integer (get_frame_base (sighandler_fi),
d867 2
a868 1
						       DEPRECATED_REGISTER_BYTE (S390_PC_REGNUM),
d884 1
a884 1
static CORE_ADDR
d888 2
a889 1
  CORE_ADDR pc = 0;
d892 1
a892 1
      pc = ADDR_BITS_REMOVE (read_register (S390_RETADDR_REGNUM));
d895 4
a898 4
  else if (get_next_frame (fi) && get_frame_pc (get_next_frame (fi)))
    pc = s390_frame_saved_pc_nofix (get_next_frame (fi));
  if (pc && get_next_frame (fi) && get_frame_base (get_next_frame (fi))
      && s390_is_sigreturn (pc, get_next_frame (fi), NULL, &sigcaller_pc))
d900 1
a900 1
      pc = sigcaller_pc;
d902 1
a902 1
  return pc;
d905 1
a905 1
static void
d908 4
a911 4
  frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));
  if (get_frame_pc (fi))
    s390_get_frame_info (s390_sniff_pc_function_start (get_frame_pc (fi), fi),
			 get_frame_extra_info (fi), fi, 1);
d913 1
a913 1
    s390_memset_extra_info (get_frame_extra_info (fi));
d920 1
a920 1
static void
d926 1
a926 1
  if (deprecated_get_frame_saved_regs (fi) == NULL)
d930 1
a930 1
      if (get_frame_pc (fi))
d932 5
a936 7
	  quick = (get_frame_extra_info (fi)
		   && get_frame_extra_info (fi)->initialised
		   && get_frame_extra_info (fi)->good_prologue);
	  s390_get_frame_info (quick
			       ? get_frame_extra_info (fi)->function_start
			       : s390_sniff_pc_function_start (get_frame_pc (fi), fi),
			       get_frame_extra_info (fi), fi, !quick);
d943 9
d955 2
a956 2
  if (get_frame_extra_info (fi) && get_frame_extra_info (fi)->saved_pc_valid)
    return get_frame_extra_info (fi)->saved_pc;
d958 2
a959 4
  if (deprecated_generic_find_dummy_frame (get_frame_pc (fi),
					   get_frame_base (fi)))
    return deprecated_read_register_dummy (get_frame_pc (fi),
					   get_frame_base (fi), S390_PC_REGNUM);
d962 1
a962 1
  if (get_frame_extra_info (fi))
d964 4
a967 4
      get_frame_extra_info (fi)->saved_pc_valid = 1;
      if (get_frame_extra_info (fi)->good_prologue
          && deprecated_get_frame_saved_regs (fi)[S390_RETADDR_REGNUM])
        get_frame_extra_info (fi)->saved_pc
d969 1
a969 1
                              (deprecated_get_frame_saved_regs (fi)[S390_RETADDR_REGNUM],
d972 1
a972 1
        get_frame_extra_info (fi)->saved_pc
d974 1
a974 1
      return get_frame_extra_info (fi)->saved_pc;
d979 1
a979 1
static CORE_ADDR
d984 2
a985 3
  if (get_frame_extra_info (fi)
      && get_frame_extra_info (fi)->sig_fixed_saved_pc_valid)
    return get_frame_extra_info (fi)->sig_fixed_saved_pc;
d988 1
a988 1
  if (get_frame_extra_info (fi))
d990 1
a990 1
      get_frame_extra_info (fi)->sig_fixed_saved_pc_valid = 1;
d996 1
a996 1
      get_frame_extra_info (fi)->sig_fixed_saved_pc = saved_pc;
d1004 2
a1005 2
/* We want backtraces out of signal handlers so we don't set
   (get_frame_type (thisframe) == SIGTRAMP_FRAME) to 1 */
d1007 1
a1007 1
static CORE_ADDR
d1012 2
a1013 4
  if (deprecated_generic_find_dummy_frame (get_frame_pc (thisframe),
					   get_frame_base (thisframe)))
    return deprecated_read_register_dummy (get_frame_pc (thisframe),
					   get_frame_base (thisframe),
d1022 1
a1022 1
      if (get_frame_pc (thisframe))
d1041 1
a1041 1
					 DEPRECATED_REGISTER_BYTE (S390_GP0_REGNUM +
d1046 1
a1046 1
	  get_frame_extra_info (thisframe)->sigcontext = sregs;
d1050 1
a1050 1
	  if (deprecated_get_frame_saved_regs (thisframe))
d1055 1
a1055 1
                  && deprecated_get_frame_saved_regs (thisframe)[S390_FRAME_REGNUM])
d1060 1
a1060 1
	      if (deprecated_get_frame_saved_regs (thisframe)[regno])
d1064 1
a1064 1
                    prev_fp = deprecated_get_frame_saved_regs (thisframe)[regno];
d1067 1
a1067 1
                      read_memory_integer (deprecated_get_frame_saved_regs (thisframe)[regno],
a1082 9
/* NOTE: cagney/2003-10-31: "return_value" makes
   "extract_struct_value_address", "extract_return_value", and
   "use_struct_convention" redundant.  */
static CORE_ADDR
s390_cannot_extract_struct_value_address (struct regcache *regcache)
{
  return 0;
}

d1085 1
a1085 1
static void
d1094 1
a1094 1
    memcpy (valbuf, &regbuf[DEPRECATED_REGISTER_BYTE (S390_FP0_REGNUM)], len);
d1102 1
a1102 1
	      regbuf + DEPRECATED_REGISTER_BYTE (S390_GP0_REGNUM + 2) + offset,
d1143 1
a1143 1
static void
d1147 1
a1147 1
  char *reg_buff = alloca (max (S390_FPR_SIZE, DEPRECATED_REGISTER_SIZE)), *value;
d1153 2
a1154 2
        deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (S390_FP0_REGNUM),
					 valbuf, TYPE_LENGTH (valtype));
d1164 2
a1165 2
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (S390_GP0_REGNUM + 2),
				       value, arglen);
d1168 20
d1191 1
a1191 1
static int
d1206 1
a1206 1
static CORE_ADDR
d1218 1
a1218 1
  write_register (S390_PC_REGNUM, DEPRECATED_FRAME_SAVED_PC (frame));
d1221 1
a1221 1
  if (deprecated_get_frame_saved_regs (frame))
d1224 1
a1224 1
        if (deprecated_get_frame_saved_regs (frame)[regnum] != 0)
d1228 2
a1229 2
            value = read_memory_unsigned_integer (deprecated_get_frame_saved_regs (frame)[regnum],
                                                  DEPRECATED_REGISTER_RAW_SIZE (regnum));
d1236 1
a1236 1
      write_register (S390_SP_REGNUM, deprecated_get_frame_saved_regs (frame)[S390_SP_REGNUM]);
d1248 1
a1248 1
static void
d1338 1
a1338 1
   corresponding union types are handled normally.)  So we include
a1360 19
/* Return non-zero if TYPE is a `DOUBLE_ARG', as defined by the
   parameter passing conventions described in the "GNU/Linux for S/390
   ELF Application Binary Interface Supplement".  Return zero
   otherwise.  */
static int
is_double_arg (struct type *type)
{
  unsigned length = TYPE_LENGTH (type);

  /* The s390x ABI doesn't handle DOUBLE_ARGS specially.  */
  if (GDB_TARGET_IS_ESAME)
    return 0;

  return ((is_integer_like (type)
           || is_struct_like (type))
          && length == 8);
}


d1372 1
a1372 1
  return ((is_integer_like (type) && length <= DEPRECATED_REGISTER_SIZE)
d1374 2
a1375 1
          || (is_struct_like (type) && !is_double_arg (type)));
a1378 6
static int
is_power_of_two (unsigned int n)
{
  return ((n & (n - 1)) == 0);
}

d1387 2
a1388 2
  return (is_struct_like (type)
          && !(is_power_of_two (length) && length <= DEPRECATED_REGISTER_SIZE));
d1411 37
d1498 1
a1498 1
static CORE_ADDR
d1524 1
a1524 1
          sp = align_down (sp, alignment_of (type));
d1543 1
a1543 1
        sp = align_down (sp, alignment_of (type));
d1545 3
a1547 3
        /* SIMPLE_ARG values get extended to DEPRECATED_REGISTER_SIZE bytes. 
           Assume every argument is.  */
        if (length < DEPRECATED_REGISTER_SIZE) length = DEPRECATED_REGISTER_SIZE;
d1553 1
a1553 1
  sp = align_down (sp, pointer_size);
d1558 1
a1558 1
  sp = align_down (sp, 8);
a1567 4
    /* A struct is returned using general register 2 */
    if (struct_return)
      gr++;

d1574 1
a1574 1
            && fr <= S390_NUM_FP_PARAMETER_REGISTERS * 2 - 2)
d1578 3
a1580 3
            deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (S390_FP0_REGNUM + fr),
					     VALUE_CONTENTS (arg),
					     TYPE_LENGTH (type));
d1598 4
a1601 4
            deprecated_write_register_gen (S390_GP0_REGNUM + gr,
					   VALUE_CONTENTS (arg));
            deprecated_write_register_gen (S390_GP0_REGNUM + gr + 1,
					   VALUE_CONTENTS (arg) + DEPRECATED_REGISTER_SIZE);
d1617 3
a1619 3
                /* Simple args are always extended to 
                   DEPRECATED_REGISTER_SIZE bytes.  */
                starg = align_up (starg, DEPRECATED_REGISTER_SIZE);
d1627 2
a1628 3
                  /* Simple args are always extended to 
                     DEPRECATED_REGISTER_SIZE bytes. */
                  write_memory_signed_integer (starg, DEPRECATED_REGISTER_SIZE,
d1630 1
a1630 1
                starg += DEPRECATED_REGISTER_SIZE;
d1635 1
a1635 1
                   starg = align_up (starg, alignment_of (type));
d1637 2
a1638 2
                   a four/eight-byte boundary, even when passing doubles. */
                starg = align_up (starg, S390_STACK_PARAMETER_ALIGNMENT);
d1649 1
a1649 1
  sp -= S390_STACK_FRAME_OVERHEAD;
d1655 1
a1655 1
                                 deprecated_read_fp ());
a1660 9
static CORE_ADDR
s390_frame_align (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  /* Both the 32- and 64-bit ABI's say that the stack pointer should
     always be aligned on an eight-byte boundary.  */
  return (addr & -8);
}


d1673 1
a1673 1
static struct type *
d1683 1
a1683 1
static struct type *
d1693 1
a1693 1
static void
d1701 1
a1701 1
static const unsigned char *
d1712 1
a1712 1
static CORE_ADDR
d1725 1
a1725 1
static CORE_ADDR
d1741 1
a1741 1
  write_register (S390_RETADDR_REGNUM, entry_point_address ());
d1745 1
a1745 32
static int
s390_address_class_type_flags (int byte_size, int dwarf2_addr_class)
{
  if (byte_size == 4)
    return TYPE_FLAG_ADDRESS_CLASS_1;
  else
    return 0;
}

static const char *
s390_address_class_type_flags_to_name (struct gdbarch *gdbarch, int type_flags)
{
  if (type_flags & TYPE_FLAG_ADDRESS_CLASS_1)
    return "mode32";
  else
    return NULL;
}

static int
s390_address_class_name_to_type_flags (struct gdbarch *gdbarch, const char *name,
				       int *type_flags_ptr)
{
  if (strcmp (name, "mode32") == 0)
    {
      *type_flags_ptr = TYPE_FLAG_ADDRESS_CLASS_1;
      return 1;
    }
  else
    return 0;
}

static struct gdbarch *
a1764 4
  /* NOTE: cagney/2002-12-06: This can be deleted when this arch is
     ready to unwind the PC first (see frame.c:get_prev_frame()).  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, deprecated_init_frame_pc_default);

d1769 7
a1775 3
  set_gdbarch_deprecated_frame_chain (gdbarch, s390_frame_chain);
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, s390_frame_init_saved_regs);
  set_gdbarch_deprecated_store_struct_return (gdbarch, s390_store_struct_return);
d1778 3
a1780 3
  /* Amount PC must be decremented by after a breakpoint.  This is
     often the number of bytes returned by BREAKPOINT_FROM_PC but not
     always.  */
d1782 1
a1782 1
  set_gdbarch_deprecated_pop_frame (gdbarch, s390_pop_frame);
d1788 2
a1789 2
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 8);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 8);
d1792 3
a1794 3
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, s390_init_extra_frame_info);
  set_gdbarch_deprecated_init_frame_pc_first (gdbarch, s390_init_frame_pc_first);
  set_gdbarch_deprecated_target_read_fp (gdbarch, s390_read_fp);
d1801 6
a1806 6
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, s390_frame_saved_pc);
  /* DEPRECATED_FRAME_CHAIN takes a frame's nominal address and
     produces the frame's chain-pointer. */
  set_gdbarch_deprecated_frame_chain (gdbarch, s390_frame_chain);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, s390_saved_pc_after_call);
  set_gdbarch_deprecated_register_byte (gdbarch, s390_register_byte);
d1809 1
a1809 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, S390_FP_REGNUM);
d1814 1
d1816 1
d1821 2
a1822 1
  set_gdbarch_extract_struct_value_address (gdbarch, s390_cannot_extract_struct_value_address);
d1825 20
a1844 8
  set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_at_entry_point);
  set_gdbarch_frame_align (gdbarch, s390_frame_align);
  set_gdbarch_deprecated_push_arguments (gdbarch, s390_push_arguments);
  set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
  set_gdbarch_deprecated_push_return_address (gdbarch,
                                              s390_push_return_address);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (s390_call_dummy_words));
  set_gdbarch_deprecated_call_dummy_words (gdbarch, s390_call_dummy_words);
d1849 4
a1852 4
      set_gdbarch_deprecated_register_size (gdbarch, 4);
      set_gdbarch_deprecated_register_raw_size (gdbarch, s390_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, s390_register_raw_size);
      set_gdbarch_deprecated_register_virtual_type (gdbarch, s390_register_virtual_type);
d1855 1
a1855 1
      set_gdbarch_deprecated_register_bytes (gdbarch, S390_REGISTER_BYTES);
d1858 5
a1862 4
      set_gdbarch_deprecated_register_size (gdbarch, 8);
      set_gdbarch_deprecated_register_raw_size (gdbarch, s390x_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, s390x_register_raw_size);
      set_gdbarch_deprecated_register_virtual_type (gdbarch, s390x_register_virtual_type);
d1867 1
a1867 7
      set_gdbarch_deprecated_register_bytes (gdbarch, S390X_REGISTER_BYTES);
      set_gdbarch_address_class_type_flags (gdbarch,
                                            s390_address_class_type_flags);
      set_gdbarch_address_class_type_flags_to_name (gdbarch,
                                                    s390_address_class_type_flags_to_name);
      set_gdbarch_address_class_name_to_type_flags (gdbarch,
                                                    s390_address_class_name_to_type_flags);
a1870 5
  /* Should be using push_dummy_call.  */
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);

  set_gdbarch_print_insn (gdbarch, print_insn_s390);

a1875 2
extern initialize_file_ftype _initialize_s390_tdep; /* -Wmissing-prototypes */

d1882 2
d1885 2
@


1.52.4.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d2600 3
d2634 1
a2634 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, s390_cannot_extract_struct_value_address);
@


1.52.2.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d1153 2
a1154 2
        deprecated_write_register_bytes (REGISTER_BYTE (S390_FP0_REGNUM),
					 valbuf, TYPE_LENGTH (valtype));
d1164 2
a1165 2
      deprecated_write_register_bytes (REGISTER_BYTE (S390_GP0_REGNUM + 2),
				       value, arglen);
d1578 3
a1580 3
            deprecated_write_register_bytes (REGISTER_BYTE (S390_FP0_REGNUM + fr),
					     VALUE_CONTENTS (arg),
					     TYPE_LENGTH (type));
d1598 4
a1601 4
            deprecated_write_register_gen (S390_GP0_REGNUM + gr,
					   VALUE_CONTENTS (arg));
            deprecated_write_register_gen (S390_GP0_REGNUM + gr + 1,
					   VALUE_CONTENTS (arg) + 4);
@


1.52.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d884 1
a884 1
CORE_ADDR
d888 2
a889 1
  CORE_ADDR pc = 0;
d892 1
a892 1
      pc = ADDR_BITS_REMOVE (read_register (S390_RETADDR_REGNUM));
d895 4
a898 4
  else if (get_next_frame (fi) && get_frame_pc (get_next_frame (fi)))
    pc = s390_frame_saved_pc_nofix (get_next_frame (fi));
  if (pc && get_next_frame (fi) && get_frame_base (get_next_frame (fi))
      && s390_is_sigreturn (pc, get_next_frame (fi), NULL, &sigcaller_pc))
d900 1
a900 1
      pc = sigcaller_pc;
d902 1
a902 1
  return pc;
d1004 2
a1005 2
/* We want backtraces out of signal handlers so we don't set
   (get_frame_type (thisframe) == SIGTRAMP_FRAME) to 1 */
a1764 4
  /* NOTE: cagney/2002-12-06: This can be deleted when this arch is
     ready to unwind the PC first (see frame.c:get_prev_frame()).  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_default);

d1793 1
a1793 1
  set_gdbarch_deprecated_init_frame_pc_first (gdbarch, s390_init_frame_pc_first);
d1814 1
d1826 1
d1828 1
d1831 1
a1831 1
  set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_at_entry_point);
@


1.52.2.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d288 1
a288 1
      if (fi && get_frame_base (fi))
d290 1
a290 1
          orig_sp = get_frame_base (fi);
d293 1
a293 1
	  saved_regs = get_frame_saved_regs (fi);
d319 2
a320 3
	  if (saved_regs && fextra_info && get_next_frame (fi)
	      && get_frame_extra_info (get_next_frame (fi))
	      && get_frame_extra_info (get_next_frame (fi))->sigcontext)
d323 1
a323 1
	      save_reg_addr = get_frame_extra_info (get_next_frame (fi))->sigcontext +
d330 1
a330 1
	      save_reg_addr = get_frame_extra_info (get_next_frame (fi))->sigcontext +
d774 4
a777 4
  if (get_frame_extra_info (fi) && get_frame_extra_info (fi)->initialised)
    function_start = get_frame_extra_info (fi)->function_start;
  else if (get_frame_pc (fi))
    function_start = get_pc_function_start (get_frame_pc (fi));
d790 1
a790 1
  if (get_next_frame (fi) == NULL)		/* no may be frameless */
d792 2
a793 2
      if (get_frame_extra_info (fi))
	fextra_info_ptr = get_frame_extra_info (fi);
d797 1
a797 1
	  s390_get_frame_info (s390_sniff_pc_function_start (get_frame_pc (fi), fi),
d832 1
a832 1
	    orig_sp = get_frame_base (sighandler_fi);
d835 2
a836 1
					read_memory_integer (get_frame_base (sighandler_fi),
d907 4
a910 4
  frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));
  if (get_frame_pc (fi))
    s390_get_frame_info (s390_sniff_pc_function_start (get_frame_pc (fi), fi),
			 get_frame_extra_info (fi), fi, 1);
d912 1
a912 1
    s390_memset_extra_info (get_frame_extra_info (fi));
d925 1
a925 1
  if (get_frame_saved_regs (fi) == NULL)
d929 1
a929 1
      if (get_frame_pc (fi))
d931 5
a935 7
	  quick = (get_frame_extra_info (fi)
		   && get_frame_extra_info (fi)->initialised
		   && get_frame_extra_info (fi)->good_prologue);
	  s390_get_frame_info (quick
			       ? get_frame_extra_info (fi)->function_start
			       : s390_sniff_pc_function_start (get_frame_pc (fi), fi),
			       get_frame_extra_info (fi), fi, !quick);
d947 1
a947 1
  return get_frame_base (fi);
d954 2
a955 2
  if (get_frame_extra_info (fi) && get_frame_extra_info (fi)->saved_pc_valid)
    return get_frame_extra_info (fi)->saved_pc;
d957 2
a958 4
  if (deprecated_generic_find_dummy_frame (get_frame_pc (fi),
					   get_frame_base (fi)))
    return deprecated_read_register_dummy (get_frame_pc (fi),
					   get_frame_base (fi), S390_PC_REGNUM);
d961 1
a961 1
  if (get_frame_extra_info (fi))
d963 4
a966 4
      get_frame_extra_info (fi)->saved_pc_valid = 1;
      if (get_frame_extra_info (fi)->good_prologue
          && get_frame_saved_regs (fi)[S390_RETADDR_REGNUM])
        get_frame_extra_info (fi)->saved_pc
d968 1
a968 1
                              (get_frame_saved_regs (fi)[S390_RETADDR_REGNUM],
d971 1
a971 1
        get_frame_extra_info (fi)->saved_pc
d973 1
a973 1
      return get_frame_extra_info (fi)->saved_pc;
d983 2
a984 3
  if (get_frame_extra_info (fi)
      && get_frame_extra_info (fi)->sig_fixed_saved_pc_valid)
    return get_frame_extra_info (fi)->sig_fixed_saved_pc;
d987 1
a987 1
  if (get_frame_extra_info (fi))
d989 1
a989 1
      get_frame_extra_info (fi)->sig_fixed_saved_pc_valid = 1;
d995 1
a995 1
      get_frame_extra_info (fi)->sig_fixed_saved_pc = saved_pc;
d1011 2
a1012 4
  if (deprecated_generic_find_dummy_frame (get_frame_pc (thisframe),
					   get_frame_base (thisframe)))
    return deprecated_read_register_dummy (get_frame_pc (thisframe),
					   get_frame_base (thisframe),
d1021 1
a1021 1
      if (get_frame_pc (thisframe))
d1045 1
a1045 1
	  get_frame_extra_info (thisframe)->sigcontext = sregs;
d1049 1
a1049 1
	  if (get_frame_saved_regs (thisframe))
d1054 1
a1054 1
                  && get_frame_saved_regs (thisframe)[S390_FRAME_REGNUM])
d1059 1
a1059 1
	      if (get_frame_saved_regs (thisframe)[regno])
d1063 1
a1063 1
                    prev_fp = get_frame_saved_regs (thisframe)[regno];
d1066 1
a1066 1
                      read_memory_integer (get_frame_saved_regs (thisframe)[regno],
d1220 1
a1220 1
  if (get_frame_saved_regs (frame))
d1223 1
a1223 1
        if (get_frame_saved_regs (frame)[regnum] != 0)
d1227 1
a1227 1
            value = read_memory_unsigned_integer (get_frame_saved_regs (frame)[regnum],
d1235 1
a1235 1
      write_register (S390_SP_REGNUM, get_frame_saved_regs (frame)[S390_SP_REGNUM]);
a1743 31
static int
s390_address_class_type_flags (int byte_size, int dwarf2_addr_class)
{
  if (byte_size == 4)
    return TYPE_FLAG_ADDRESS_CLASS_1;
  else
    return 0;
}

static const char *
s390_address_class_type_flags_to_name (struct gdbarch *gdbarch, int type_flags)
{
  if (type_flags & TYPE_FLAG_ADDRESS_CLASS_1)
    return "mode32";
  else
    return NULL;
}

int
s390_address_class_name_to_type_flags (struct gdbarch *gdbarch, const char *name,
				       int *type_flags_ptr)
{
  if (strcmp (name, "mode32") == 0)
    {
      *type_flags_ptr = TYPE_FLAG_ADDRESS_CLASS_1;
      return 1;
    }
  else
    return 0;
}

d1818 1
d1843 2
a1867 6
      set_gdbarch_address_class_type_flags (gdbarch,
                                            s390_address_class_type_flags);
      set_gdbarch_address_class_type_flags_to_name (gdbarch,
                                                    s390_address_class_type_flags_to_name);
      set_gdbarch_address_class_name_to_type_flags (gdbarch,
                                                    s390_address_class_name_to_type_flags);
@


1.52.2.4
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d1812 1
a1812 1
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, s390_frame_init_saved_regs);
d1829 2
a1830 2
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 8);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 8);
d1833 1
a1833 1
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, s390_init_extra_frame_info);
d1869 1
@


1.52.2.5
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d778 1
a778 1
    function_start = get_frame_func (fi);
d1224 1
a1224 1
  write_register (S390_PC_REGNUM, DEPRECATED_FRAME_SAVED_PC (frame));
d1811 1
a1811 1
  set_gdbarch_deprecated_frame_chain (gdbarch, s390_frame_chain);
d1816 1
a1816 1
  set_gdbarch_deprecated_store_struct_return (gdbarch, s390_store_struct_return);
d1823 1
a1823 1
  set_gdbarch_deprecated_pop_frame (gdbarch, s390_pop_frame);
d1842 5
a1846 5
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, s390_frame_saved_pc);
  /* DEPRECATED_FRAME_CHAIN takes a frame's nominal address and
     produces the frame's chain-pointer. */
  set_gdbarch_deprecated_frame_chain (gdbarch, s390_frame_chain);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, s390_saved_pc_after_call);
d1864 4
d1869 1
a1869 1
  set_gdbarch_deprecated_push_arguments (gdbarch, s390_push_arguments);
d1871 5
a1875 2
  set_gdbarch_deprecated_push_return_address (gdbarch,
                                              s390_push_return_address);
a1909 3

  /* Should be using push_dummy_call.  */
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
@


1.52.2.6
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d283 1
a283 1
  info.read_memory_func = deprecated_tm_print_insn_info.read_memory_func;
d685 1
a685 1
  info.read_memory_func = deprecated_tm_print_insn_info.read_memory_func;
d822 1
a822 1
  info.read_memory_func = deprecated_tm_print_insn_info.read_memory_func;
d1661 1
a1661 1
                                 deprecated_read_fp ());
a1666 9
static CORE_ADDR
s390_frame_align (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  /* Both the 32- and 64-bit ABI's say that the stack pointer should
     always be aligned on an eight-byte boundary.  */
  return (addr & -8);
}


d1835 1
a1835 1
  set_gdbarch_deprecated_target_read_fp (gdbarch, s390_read_fp);
d1850 1
a1850 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, S390_FP_REGNUM);
a1864 1
  set_gdbarch_frame_align (gdbarch, s390_frame_align);
d1918 2
a1919 2
  if (!deprecated_tm_print_insn)	/* Someone may have already set it */
    deprecated_tm_print_insn = gdb_print_insn_s390;
@


1.52.2.7
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d1153 1
a1153 1
  char *reg_buff = alloca (max (S390_FPR_SIZE, DEPRECATED_REGISTER_SIZE)), *value;
d1828 3
a1830 3
  /* Amount PC must be decremented by after a breakpoint.  This is
     often the number of bytes returned by BREAKPOINT_FROM_PC but not
     always.  */
d1879 3
a1881 2
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (s390_call_dummy_words));
  set_gdbarch_deprecated_call_dummy_words (gdbarch, s390_call_dummy_words);
d1886 1
a1886 1
      set_gdbarch_deprecated_register_size (gdbarch, 4);
d1892 1
a1892 1
      set_gdbarch_deprecated_register_bytes (gdbarch, S390_REGISTER_BYTES);
d1895 1
a1895 1
      set_gdbarch_deprecated_register_size (gdbarch, 8);
d1904 1
a1904 1
      set_gdbarch_deprecated_register_bytes (gdbarch, S390X_REGISTER_BYTES);
@


1.52.2.8
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d48 1
a48 1
static int
d58 1
a58 1
static int
d65 1
a65 1
static int
d72 1
a72 1
static int
d87 1
d122 1
a122 1
static int
d153 1
a153 1
static const char *
d178 1
a178 1
static int
d213 1
a213 1
static int
d678 1
a678 1
static int
d770 1
a770 1
static CORE_ADDR
d785 1
a785 1
static int
d884 1
a884 1
static CORE_ADDR
d904 1
a904 1
static void
d919 1
a919 1
static void
d944 9
d982 1
a982 1
static CORE_ADDR
d1011 1
a1011 1
static CORE_ADDR
d1091 1
a1091 1
static void
d1149 1
a1149 1
static void
d1197 1
a1197 1
static int
d1212 1
a1212 1
static CORE_ADDR
d1254 1
a1254 1
static void
d1504 1
a1504 1
static CORE_ADDR
d1688 1
a1688 1
static struct type *
d1698 1
a1698 1
static struct type *
d1708 1
a1708 1
static void
d1716 1
a1716 1
static const unsigned char *
d1727 1
a1727 1
static CORE_ADDR
d1740 1
a1740 1
static CORE_ADDR
d1778 1
a1778 1
static int
d1791 1
a1791 1
static struct gdbarch *
d1819 1
d1822 3
d1856 1
a1856 1
  set_gdbarch_deprecated_register_byte (gdbarch, s390_register_byte);
d1876 1
a1876 1
  set_gdbarch_deprecated_save_dummy_frame_tos (gdbarch, generic_save_dummy_frame_tos);
d1886 3
a1888 3
      set_gdbarch_deprecated_register_raw_size (gdbarch, s390_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, s390_register_raw_size);
      set_gdbarch_deprecated_register_virtual_type (gdbarch, s390_register_virtual_type);
d1895 4
a1898 3
      set_gdbarch_deprecated_register_raw_size (gdbarch, s390x_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, s390x_register_raw_size);
      set_gdbarch_deprecated_register_virtual_type (gdbarch, s390x_register_virtual_type);
d1914 1
a1914 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);
a1920 2
extern initialize_file_ftype _initialize_s390_tdep; /* -Wmissing-prototypes */

d1930 2
@


1.52.2.9
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d96 1
a96 3
#define S390_STACK_FRAME_OVERHEAD  16*DEPRECATED_REGISTER_SIZE+32
#define S390_STACK_PARAMETER_ALIGNMENT  DEPRECATED_REGISTER_SIZE
#define S390_NUM_FP_PARAMETER_REGISTERS (GDB_TARGET_IS_ESAME ? 4:2)
a113 1
  CORE_ADDR stack_bought_valid;
d189 2
a190 292
/* Prologue analysis.  */

/* When we analyze a prologue, we're really doing 'abstract
   interpretation' or 'pseudo-evaluation': running the function's code
   in simulation, but using conservative approximations of the values
   it would have when it actually runs.  For example, if our function
   starts with the instruction:

      ahi r1, 42     # add halfword immediate 42 to r1

   we don't know exactly what value will be in r1 after executing this
   instruction, but we do know it'll be 42 greater than its original
   value.

   If we then see an instruction like:

      ahi r1, 22     # add halfword immediate 22 to r1

   we still don't know what r1's value is, but again, we can say it is
   now 64 greater than its original value.

   If the next instruction were:

      lr r2, r1      # set r2 to r1's value

   then we can say that r2's value is now the original value of r1
   plus 64.  And so on.

   Of course, this can only go so far before it gets unreasonable.  If
   we wanted to be able to say anything about the value of r1 after
   the instruction:

      xr r1, r3      # exclusive-or r1 and r3, place result in r1

   then things would get pretty complex.  But remember, we're just
   doing a conservative approximation; if exclusive-or instructions
   aren't relevant to prologues, we can just say r1's value is now
   'unknown'.  We can ignore things that are too complex, if that loss
   of information is acceptable for our application.

   Once you've reached an instruction that you don't know how to
   simulate, you stop.  Now you examine the state of the registers and
   stack slots you've kept track of.  For example:

   - To see how large your stack frame is, just check the value of sp;
     if it's the original value of sp minus a constant, then that
     constant is the stack frame's size.  If the sp's value has been
     marked as 'unknown', then that means the prologue has done
     something too complex for us to track, and we don't know the
     frame size.

   - To see whether we've saved the SP in the current frame's back
     chain slot, we just check whether the current value of the back
     chain stack slot is the original value of the sp.

   Sure, this takes some work.  But prologue analyzers aren't
   quick-and-simple pattern patching to recognize a few fixed prologue
   forms any more; they're big, hairy functions.  Along with inferior
   function calls, prologue analysis accounts for a substantial
   portion of the time needed to stabilize a GDB port.  So I think
   it's worthwhile to look for an approach that will be easier to
   understand and maintain.  In the approach used here:

   - It's easier to see that the analyzer is correct: you just see
     whether the analyzer properly (albiet conservatively) simulates
     the effect of each instruction.

   - It's easier to extend the analyzer: you can add support for new
     instructions, and know that you haven't broken anything that
     wasn't already broken before.

   - It's orthogonal: to gather new information, you don't need to
     complicate the code for each instruction.  As long as your domain
     of conservative values is already detailed enough to tell you
     what you need, then all the existing instruction simulations are
     already gathering the right data for you.

   A 'struct prologue_value' is a conservative approximation of the
   real value the register or stack slot will have.  */

struct prologue_value {

  /* What sort of value is this?  This determines the interpretation
     of subsequent fields.  */
  enum {

    /* We don't know anything about the value.  This is also used for
       values we could have kept track of, when doing so would have
       been too complex and we don't want to bother.  The bottom of
       our lattice.  */
    pv_unknown,

    /* A known constant.  K is its value.  */
    pv_constant,

    /* The value that register REG originally had *UPON ENTRY TO THE
       FUNCTION*, plus K.  If K is zero, this means, obviously, just
       the value REG had upon entry to the function.  REG is a GDB
       register number.  Before we start interpreting, we initialize
       every register R to { pv_register, R, 0 }.  */
    pv_register,

  } kind;

  /* The meanings of the following fields depend on 'kind'; see the
     comments for the specific 'kind' values.  */
  int reg;
  CORE_ADDR k;
};


/* Set V to be unknown.  */
static void
pv_set_to_unknown (struct prologue_value *v)
{
  v->kind = pv_unknown;
}


/* Set V to the constant K.  */
static void
pv_set_to_constant (struct prologue_value *v, CORE_ADDR k)
{
  v->kind = pv_constant;
  v->k = k;
}


/* Set V to the original value of register REG, plus K.  */
static void
pv_set_to_register (struct prologue_value *v, int reg, CORE_ADDR k)
{
  v->kind = pv_register;
  v->reg = reg;
  v->k = k;
}


/* If one of *A and *B is a constant, and the other isn't, swap the
   pointers as necessary to ensure that *B points to the constant.
   This can reduce the number of cases we need to analyze in the
   functions below.  */
static void
pv_constant_last (struct prologue_value **a,
                  struct prologue_value **b)
{
  if ((*a)->kind == pv_constant
      && (*b)->kind != pv_constant)
    {
      struct prologue_value *temp = *a;
      *a = *b;
      *b = temp;
    }
}


/* Set SUM to the sum of A and B.  SUM, A, and B may point to the same
   'struct prologue_value' object.  */
static void
pv_add (struct prologue_value *sum,
        struct prologue_value *a,
        struct prologue_value *b)
{
  pv_constant_last (&a, &b);

  /* We can handle adding constants to registers, and other constants.  */
  if (b->kind == pv_constant
      && (a->kind == pv_register
          || a->kind == pv_constant))
    {
      sum->kind = a->kind;
      sum->reg = a->reg;    /* not meaningful if a is pv_constant, but
                               harmless */
      sum->k = a->k + b->k;
    }

  /* Anything else we don't know how to add.  We don't have a
     representation for, say, the sum of two registers, or a multiple
     of a register's value (adding a register to itself).  */
  else
    sum->kind = pv_unknown;
}


/* Add the constant K to V.  */
static void
pv_add_constant (struct prologue_value *v, CORE_ADDR k)
{
  struct prologue_value pv_k;

  /* Rather than thinking of all the cases we can and can't handle,
     we'll just let pv_add take care of that for us.  */
  pv_set_to_constant (&pv_k, k);
  pv_add (v, v, &pv_k);
}


/* Subtract B from A, and put the result in DIFF.

   This isn't quite the same as negating B and adding it to A, since
   we don't have a representation for the negation of anything but a
   constant.  For example, we can't negate { pv_register, R1, 10 },
   but we do know that { pv_register, R1, 10 } minus { pv_register,
   R1, 5 } is { pv_constant, <ignored>, 5 }.

   This means, for example, that we can subtract two stack addresses;
   they're both relative to the original SP.  Since the frame pointer
   is set based on the SP, its value will be the original SP plus some
   constant (probably zero), so we can use its value just fine.  */
static void
pv_subtract (struct prologue_value *diff,
             struct prologue_value *a,
             struct prologue_value *b)
{
  pv_constant_last (&a, &b);

  /* We can subtract a constant from another constant, or from a
     register.  */
  if (b->kind == pv_constant
      && (a->kind == pv_register
          || a->kind == pv_constant))
    {
      diff->kind = a->kind;
      diff->reg = a->reg;    /* not always meaningful, but harmless */
      diff->k = a->k - b->k;
    }

  /* We can subtract a register from itself, yielding a constant.  */
  else if (a->kind == pv_register
           && b->kind == pv_register
           && a->reg == b->reg)
    {
      diff->kind = pv_constant;
      diff->k = a->k - b->k;
    }

  /* We don't know how to subtract anything else.  */
  else
    diff->kind = pv_unknown;
}


/* Set AND to the logical and of A and B.  */
static void
pv_logical_and (struct prologue_value *and,
                struct prologue_value *a,
                struct prologue_value *b)
{
  pv_constant_last (&a, &b);

  /* We can 'and' two constants.  */
  if (a->kind == pv_constant
      && b->kind == pv_constant)
    {
      and->kind = pv_constant;
      and->k = a->k & b->k;
    }

  /* We can 'and' anything with the constant zero.  */
  else if (b->kind == pv_constant
           && b->k == 0)
    {
      and->kind = pv_constant;
      and->k = 0;
    }
  
  /* We can 'and' anything with ~0.  */
  else if (b->kind == pv_constant
           && b->k == ~ (CORE_ADDR) 0)
    *and = *a;

  /* We can 'and' a register with itself.  */
  else if (a->kind == pv_register
           && b->kind == pv_register
           && a->reg == b->reg
           && a->k == b->k)
    *and = *a;

  /* Otherwise, we don't know.  */
  else
    pv_set_to_unknown (and);
}


/* Return non-zero iff A and B are identical expressions.

   This is not the same as asking if the two values are equal; the
   result of such a comparison would have to be a pv_boolean, and
   asking whether two 'unknown' values were equal would give you
   pv_maybe.  Same for comparing, say, { pv_register, R1, 0 } and {
   pv_register, R2, 0}.  Instead, this is asking whether the two
   representations are the same.  */
d192 1
a192 2
pv_is_identical (struct prologue_value *a,
                 struct prologue_value *b)
d194 1
a194 14
  if (a->kind != b->kind)
    return 0;

  switch (a->kind)
    {
    case pv_unknown:
      return 1;
    case pv_constant:
      return (a->k == b->k);
    case pv_register:
      return (a->reg == b->reg && a->k == b->k);
    default:
      gdb_assert (0);
    }
d198 3
a200 9
/* Return non-zero if A is the original value of register number R
   plus K, zero otherwise.  */
static int
pv_is_register (struct prologue_value *a, int r, CORE_ADDR k)
{
  return (a->kind == pv_register
          && a->reg == r
          && a->k == k);
}
d202 7
d210 1
a210 8
/* A prologue-value-esque boolean type, including "maybe", when we
   can't figure out whether something is true or not.  */
enum pv_boolean {
  pv_maybe,
  pv_definite_yes,
  pv_definite_no,
};

a211 95
/* Decide whether a reference to SIZE bytes at ADDR refers exactly to
   an element of an array.  The array starts at ARRAY_ADDR, and has
   ARRAY_LEN values of ELT_SIZE bytes each.  If ADDR definitely does
   refer to an array element, set *I to the index of the referenced
   element in the array, and return pv_definite_yes.  If it definitely
   doesn't, return pv_definite_no.  If we can't tell, return pv_maybe.

   If the reference does touch the array, but doesn't fall exactly on
   an element boundary, or doesn't refer to the whole element, return
   pv_maybe.  */
static enum pv_boolean
pv_is_array_ref (struct prologue_value *addr,
                 CORE_ADDR size,
                 struct prologue_value *array_addr,
                 CORE_ADDR array_len, 
                 CORE_ADDR elt_size,
                 int *i)
{
  struct prologue_value offset;

  /* Note that, since ->k is a CORE_ADDR, and CORE_ADDR is unsigned,
     if addr is *before* the start of the array, then this isn't going
     to be negative...  */
  pv_subtract (&offset, addr, array_addr);

  if (offset.kind == pv_constant)
    {
      /* This is a rather odd test.  We want to know if the SIZE bytes
         at ADDR don't overlap the array at all, so you'd expect it to
         be an || expression: "if we're completely before || we're
         completely after".  But with unsigned arithmetic, things are
         different: since it's a number circle, not a number line, the
         right values for offset.k are actually one contiguous range.  */
      if (offset.k <= -size
          && offset.k >= array_len * elt_size)
        return pv_definite_no;
      else if (offset.k % elt_size != 0
               || size != elt_size)
        return pv_maybe;
      else
        {
          *i = offset.k / elt_size;
          return pv_definite_yes;
        }
    }
  else
    return pv_maybe;
}



/* Decoding S/390 instructions.  */

/* Named opcode values for the S/390 instructions we recognize.  Some
   instructions have their opcode split across two fields; those are the
   op1_* and op2_* enums.  */
enum
  {
    op1_aghi = 0xa7,   op2_aghi = 0xb,
    op1_ahi  = 0xa7,   op2_ahi  = 0xa,
    op_ar    = 0x1a,
    op_basr  = 0x0d,
    op1_bras = 0xa7,   op2_bras = 0x5,
    op_l     = 0x58,
    op_la    = 0x41,
    op1_larl = 0xc0,   op2_larl = 0x0,
    op_lgr   = 0xb904,
    op1_lghi = 0xa7,   op2_lghi = 0x9,
    op1_lhi  = 0xa7,   op2_lhi  = 0x8,
    op_lr    = 0x18,
    op_nr    = 0x14,
    op_ngr   = 0xb980,
    op_s     = 0x5b,
    op_st    = 0x50,
    op_std   = 0x60,
    op1_stg  = 0xe3,   op2_stg  = 0x24,
    op_stm   = 0x90,
    op1_stmg = 0xeb,   op2_stmg = 0x24,
    op_svc   = 0x0a,
  };


/* The functions below are for recognizing and decoding S/390
   instructions of various formats.  Each of them checks whether INSN
   is an instruction of the given format, with the specified opcodes.
   If it is, it sets the remaining arguments to the values of the
   instruction's fields, and returns a non-zero value; otherwise, it
   returns zero.

   These functions' arguments appear in the order they appear in the
   instruction, not in the machine-language form.  So, opcodes always
   come first, even though they're sometimes scattered around the
   instructions.  And displacements appear before base and extension
   registers, as they do in the assembly syntax, not at the end, as
   they do in the machine language.  */
d213 2
a214 1
is_ri (bfd_byte *insn, int op1, int op2, unsigned int *r1, int *i2)
d216 15
a230 10
  if (insn[0] == op1 && (insn[1] & 0xf) == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      /* i2 is a 16-bit signed quantity.  */
      *i2 = (((insn[2] << 8) | insn[3]) ^ 0x8000) - 0x8000;
      return 1;
    }
  else
    return 0;
}
d232 45
d278 1
a278 19
static int
is_ril (bfd_byte *insn, int op1, int op2,
        unsigned int *r1, int *i2)
{
  if (insn[0] == op1 && (insn[1] & 0xf) == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      /* i2 is a signed quantity.  If the host 'int' is 32 bits long,
         no sign extension is necessary, but we don't want to assume
         that.  */
      *i2 = (((insn[2] << 24)
              | (insn[3] << 16)
              | (insn[4] << 8)
              | (insn[5])) ^ 0x80000000) - 0x80000000;
      return 1;
    }
  else
    return 0;
}
d280 3
d284 2
a285 4
static int
is_rr (bfd_byte *insn, int op, unsigned int *r1, unsigned int *r2)
{
  if (insn[0] == op)
d287 13
a299 3
      *r1 = (insn[1] >> 4) & 0xf;
      *r2 = insn[1] & 0xf;
      return 1;
d301 2
a302 9
  else
    return 0;
}


static int
is_rre (bfd_byte *insn, int op, unsigned int *r1, unsigned int *r2)
{
  if (((insn[0] << 8) | insn[1]) == op)
d304 119
a422 9
      /* Yes, insn[3].  insn[2] is unused in RRE format.  */
      *r1 = (insn[3] >> 4) & 0xf;
      *r2 = insn[3] & 0xf;
      return 1;
    }
  else
    return 0;
}

d424 17
a440 226
static int
is_rs (bfd_byte *insn, int op,
       unsigned int *r1, unsigned int *r3, unsigned int *d2, unsigned int *b2)
{
  if (insn[0] == op)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *r3 = insn[1] & 0xf;
      *b2 = (insn[2] >> 4) & 0xf;
      *d2 = ((insn[2] & 0xf) << 8) | insn[3];
      return 1;
    }
  else
    return 0;
}


static int
is_rse (bfd_byte *insn, int op1, int op2,
        unsigned int *r1, unsigned int *r3, unsigned int *d2, unsigned int *b2)
{
  if (insn[0] == op1
      /* Yes, insn[5].  insn[4] is unused.  */
      && insn[5] == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *r3 = insn[1] & 0xf;
      *b2 = (insn[2] >> 4) & 0xf;
      *d2 = ((insn[2] & 0xf) << 8) | insn[3];
      return 1;
    }
  else
    return 0;
}


static int
is_rx (bfd_byte *insn, int op,
       unsigned int *r1, unsigned int *d2, unsigned int *x2, unsigned int *b2)
{
  if (insn[0] == op)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *x2 = insn[1] & 0xf;
      *b2 = (insn[2] >> 4) & 0xf;
      *d2 = ((insn[2] & 0xf) << 8) | insn[3];
      return 1;
    }
  else
    return 0;
}


static int
is_rxe (bfd_byte *insn, int op1, int op2,
        unsigned int *r1, unsigned int *d2, unsigned int *x2, unsigned int *b2)
{
  if (insn[0] == op1
      /* Yes, insn[5].  insn[4] is unused.  */
      && insn[5] == op2)
    {
      *r1 = (insn[1] >> 4) & 0xf;
      *x2 = insn[1] & 0xf;
      *b2 = (insn[2] >> 4) & 0xf;
      *d2 = ((insn[2] & 0xf) << 8) | insn[3];
      return 1;
    }
  else
    return 0;
}


/* Set ADDR to the effective address for an X-style instruction, like:

        L R1, D2(X2, B2)

   Here, X2 and B2 are registers, and D2 is an unsigned 12-bit
   constant; the effective address is the sum of all three.  If either
   X2 or B2 are zero, then it doesn't contribute to the sum --- this
   means that r0 can't be used as either X2 or B2.

   GPR is an array of general register values, indexed by GPR number,
   not GDB register number.  */
static void
compute_x_addr (struct prologue_value *addr, 
                struct prologue_value *gpr,
                unsigned int d2, unsigned int x2, unsigned int b2)
{
  /* We can't just add stuff directly in addr; it might alias some of
     the registers we need to read.  */
  struct prologue_value result;

  pv_set_to_constant (&result, d2);
  if (x2)
    pv_add (&result, &result, &gpr[x2]);
  if (b2)
    pv_add (&result, &result, &gpr[b2]);

  *addr = result;
}


/* The number of GPR and FPR spill slots in an S/390 stack frame.  We
   track general-purpose registers r2 -- r15, and floating-point
   registers f0, f2, f4, and f6.  */
#define S390_NUM_SPILL_SLOTS (14 + 4)


/* If the SIZE bytes at ADDR are a stack slot we're actually tracking,
   return pv_definite_yes and set *STACK to point to the slot.  If
   we're sure that they are not any of our stack slots, then return
   pv_definite_no.  Otherwise, return pv_maybe.
   - GPR is an array indexed by GPR number giving the current values
     of the general-purpose registers.
   - SPILL is an array tracking the spill area of the caller's frame;
     SPILL[i] is the i'th spill slot.  The spill slots are designated
     for r2 -- r15, and then f0, f2, f4, and f6.
   - BACK_CHAIN is the value of the back chain slot; it's only valid
     when the current frame actually has some space for a back chain
     slot --- that is, when the current value of the stack pointer
     (according to GPR) is at least S390_STACK_FRAME_OVERHEAD bytes
     less than its original value.  */
static enum pv_boolean
s390_on_stack (struct prologue_value *addr,
               CORE_ADDR size,
               struct prologue_value *gpr,
               struct prologue_value *spill, 
               struct prologue_value *back_chain,
               struct prologue_value **stack)
{
  struct prologue_value gpr_spill_addr;
  struct prologue_value fpr_spill_addr;
  struct prologue_value back_chain_addr;  
  int i;
  enum pv_boolean b;

  /* Construct the addresses of the spill arrays and the back chain.  */
  pv_set_to_register (&gpr_spill_addr, S390_SP_REGNUM, 2 * S390_GPR_SIZE);
  pv_set_to_register (&fpr_spill_addr, S390_SP_REGNUM, 16 * S390_GPR_SIZE);
  back_chain_addr = gpr[S390_SP_REGNUM - S390_GP0_REGNUM];

  /* We have to check for GPR and FPR references using two separate
     calls to pv_is_array_ref, since the GPR and FPR spill slots are
     different sizes.  (SPILL is an array, but the thing it tracks
     isn't really an array.)  */

  /* Was it a reference to the GPR spill array?  */
  b = pv_is_array_ref (addr, size, &gpr_spill_addr, 14, S390_GPR_SIZE, &i);
  if (b == pv_definite_yes)
    {
      *stack = &spill[i];
      return pv_definite_yes;
    }
  if (b == pv_maybe)
    return pv_maybe;

  /* Was it a reference to the FPR spill array?  */
  b = pv_is_array_ref (addr, size, &fpr_spill_addr, 4, S390_FPR_SIZE, &i);
  if (b == pv_definite_yes)
    {
      *stack = &spill[14 + i];
      return pv_definite_yes;
    }
  if (b == pv_maybe)
    return pv_maybe;

  /* Was it a reference to the back chain?
     This isn't quite right.  We ought to check whether we have
     actually allocated any new frame at all.  */
  b = pv_is_array_ref (addr, size, &back_chain_addr, 1, S390_GPR_SIZE, &i);
  if (b == pv_definite_yes)
    {
      *stack = back_chain;
      return pv_definite_yes;
    }
  if (b == pv_maybe)
    return pv_maybe;

  /* All the above queries returned definite 'no's.  */
  return pv_definite_no;
}


/* Do a SIZE-byte store of VALUE to ADDR.  GPR, SPILL, and BACK_CHAIN,
   and the return value are as described for s390_on_stack, above.
   Note that, when this returns pv_maybe, we have to assume that all
   of our memory now contains unknown values.  */
static enum pv_boolean
s390_store (struct prologue_value *addr,
            CORE_ADDR size,
            struct prologue_value *value,
            struct prologue_value *gpr,
            struct prologue_value *spill, 
            struct prologue_value *back_chain)
{
  struct prologue_value *stack;
  enum pv_boolean on_stack
    = s390_on_stack (addr, size, gpr, spill, back_chain, &stack);

  if (on_stack == pv_definite_yes)
    *stack = *value;

  return on_stack;
}
            

/* The current frame looks like a signal delivery frame: the first
   instruction is an 'svc' opcode.  If the next frame is a signal
   handler's frame, set FI's saved register map to point into the
   signal context structure.  */
static void
s390_get_signal_frame_info (struct frame_info *fi)
{
  struct frame_info *next_frame = get_next_frame (fi);

  if (next_frame
      && get_frame_extra_info (next_frame)
      && get_frame_extra_info (next_frame)->sigcontext)
    {
      /* We're definitely backtracing from a signal handler.  */
      CORE_ADDR *saved_regs = get_frame_saved_regs (fi);
      CORE_ADDR save_reg_addr = (get_frame_extra_info (next_frame)->sigcontext
                                 + REGISTER_BYTE (S390_GP0_REGNUM));
      int reg;

      for (reg = 0; reg < S390_NUM_GPRS; reg++)
d442 2
a443 2
          saved_regs[S390_GP0_REGNUM + reg] = save_reg_addr;
          save_reg_addr += S390_GPR_SIZE;
d446 20
a465 10
      save_reg_addr = (get_frame_extra_info (next_frame)->sigcontext
                       + (GDB_TARGET_IS_ESAME ? S390X_SIGREGS_FP0_OFFSET :
                          S390_SIGREGS_FP0_OFFSET));
      for (reg = 0; reg < S390_NUM_FPRS; reg++)
        {
          saved_regs[S390_FP0_REGNUM + reg] = save_reg_addr;
          save_reg_addr += S390_FPR_SIZE;
        }
    }
}
d468 2
a469 10
static int
s390_get_frame_info (CORE_ADDR start_pc,
                     struct frame_extra_info *fextra_info,
                     struct frame_info *fi,
                     int init_extra_info)
{
  /* Our return value:
     zero if we were able to read all the instructions we wanted, or
     -1 if we got an error trying to read memory.  */
  int result = 0;
d471 137
a607 342
  /* We just use this for reading instructions.  */
  disassemble_info info;

  /* The current PC for our abstract interpretation.  */
  CORE_ADDR pc;

  /* The address of the next instruction after that.  */
  CORE_ADDR next_pc;
  
  /* The general-purpose registers.  */
  struct prologue_value gpr[S390_NUM_GPRS];

  /* The floating-point registers.  */
  struct prologue_value fpr[S390_NUM_FPRS];

  /* The register spill stack slots in the caller's frame ---
     general-purpose registers r2 through r15, and floating-point
     registers.  spill[i] is where gpr i+2 gets spilled;
     spill[(14, 15, 16, 17)] is where (f0, f2, f4, f6) get spilled.  */
  struct prologue_value spill[S390_NUM_SPILL_SLOTS];

  /* The value of the back chain slot.  This is only valid if the stack
     pointer is known to be less than its original value --- that is,
     if we have indeed allocated space on the stack.  */
  struct prologue_value back_chain;

  /* The address of the instruction after the last one that changed
     the SP, FP, or back chain.  */
  CORE_ADDR after_last_frame_setup_insn = start_pc;

  info.read_memory_func = deprecated_tm_print_insn_info.read_memory_func;

  /* Set up everything's initial value.  */
  {
    int i;

    for (i = 0; i < S390_NUM_GPRS; i++)
      pv_set_to_register (&gpr[i], S390_GP0_REGNUM + i, 0);

    for (i = 0; i < S390_NUM_FPRS; i++)
      pv_set_to_register (&fpr[i], S390_FP0_REGNUM + i, 0);

    for (i = 0; i < S390_NUM_SPILL_SLOTS; i++)
      pv_set_to_unknown (&spill[i]);

    pv_set_to_unknown (&back_chain);
  }

  /* Start interpreting instructions, until we hit something we don't
     know how to interpret.  (Ideally, we should stop at the frame's
     real current PC, but at the moment, our callers don't give us
     that info.)  */
  for (pc = start_pc; ; pc = next_pc)
    {
      bfd_byte insn[S390_MAX_INSTR_SIZE];
      int insn_len = s390_readinstruction (insn, pc, &info);

      /* Fields for various kinds of instructions.  */
      unsigned int b2, r1, r2, d2, x2, r3;
      int i2;

      /* The values of SP, FP, and back chain before this instruction,
         for detecting instructions that change them.  */
      struct prologue_value pre_insn_sp, pre_insn_fp, pre_insn_back_chain;

      /* If we got an error trying to read the instruction, report it.  */
      if (insn_len < 0)
        {
          result = -1;
          break;
        }

      next_pc = pc + insn_len;

      pre_insn_sp = gpr[S390_SP_REGNUM - S390_GP0_REGNUM];
      pre_insn_fp = gpr[S390_FRAME_REGNUM - S390_GP0_REGNUM];
      pre_insn_back_chain = back_chain;

      /* A special case, first --- only recognized as the very first
         instruction of the function, for signal delivery frames:
         SVC i --- system call  */
      if (pc == start_pc
          && is_rr (insn, op_svc, &r1, &r2))
        {
          if (fi)
            s390_get_signal_frame_info (fi);
          break;
        }
        
      /* AHI r1, i2 --- add halfword immediate */
      else if (is_ri (insn, op1_ahi, op2_ahi, &r1, &i2))
        pv_add_constant (&gpr[r1], i2);


      /* AGHI r1, i2 --- add halfword immediate (64-bit version) */
      else if (GDB_TARGET_IS_ESAME
               && is_ri (insn, op1_aghi, op2_aghi, &r1, &i2))
        pv_add_constant (&gpr[r1], i2);

      /* AR r1, r2 -- add register */
      else if (is_rr (insn, op_ar, &r1, &r2))
        pv_add (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* BASR r1, 0 --- branch and save
         Since r2 is zero, this saves the PC in r1, but doesn't branch.  */
      else if (is_rr (insn, op_basr, &r1, &r2)
               && r2 == 0)
        pv_set_to_constant (&gpr[r1], next_pc);

      /* BRAS r1, i2 --- branch relative and save */
      else if (is_ri (insn, op1_bras, op2_bras, &r1, &i2))
        {
          pv_set_to_constant (&gpr[r1], next_pc);
          next_pc = pc + i2 * 2;

          /* We'd better not interpret any backward branches.  We'll
             never terminate.  */
          if (next_pc <= pc)
            break;
        }

      /* L r1, d2(x2, b2) --- load */
      else if (is_rx (insn, op_l, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;
          struct prologue_value *stack;

          compute_x_addr (&addr, gpr, d2, x2, b2);

          /* If it's a load from an in-line constant pool, then we can
             simulate that, under the assumption that the code isn't
             going to change between the time the processor actually
             executed it creating the current frame, and the time when
             we're analyzing the code to unwind past that frame.  */
          if (addr.kind == pv_constant
              && start_pc <= addr.k 
              && addr.k < next_pc)
            pv_set_to_constant (&gpr[r1], 
                                read_memory_integer (addr.k, 4));

          /* If it's definitely a reference to something on the stack, 
             we can do that.  */
          else if (s390_on_stack (&addr, 4, gpr, spill, &back_chain, &stack)
                   == pv_definite_yes)
            gpr[r1] = *stack;

          /* Otherwise, we don't know the value.  */
          else
            pv_set_to_unknown (&gpr[r1]);
        }

      /* LA r1, d2(x2, b2) --- load address */
      else if (is_rx (insn, op_la, &r1, &d2, &x2, &b2))
        compute_x_addr (&gpr[r1], gpr, d2, x2, b2);

      /* LARL r1, i2 --- load address relative long */
      else if (GDB_TARGET_IS_ESAME 
               && is_ril (insn, op1_larl, op2_larl, &r1, &i2))
        pv_set_to_constant (&gpr[r1], pc + i2 * 2);

      /* LGR r1, r2 --- load from register */
      else if (GDB_TARGET_IS_ESAME
               && is_rre (insn, op_lgr, &r1, &r2))
        gpr[r1] = gpr[r2];

      /* LHI r1, i2 --- load halfword immediate */
      else if (is_ri (insn, op1_lhi, op2_lhi, &r1, &i2))
        pv_set_to_constant (&gpr[r1], i2);

      /* LGHI r1, i2 --- load halfword immediate --- 64-bit version */
      else if (is_ri (insn, op1_lghi, op2_lghi, &r1, &i2))
        pv_set_to_constant (&gpr[r1], i2);

      /* LR r1, r2 --- load from register */
      else if (is_rr (insn, op_lr, &r1, &r2))
        gpr[r1] = gpr[r2];

      /* NGR r1, r2 --- logical and --- 64-bit version */
      else if (GDB_TARGET_IS_ESAME
               && is_rre (insn, op_ngr, &r1, &r2))
        pv_logical_and (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* NR r1, r2 --- logical and */
      else if (is_rr (insn, op_nr, &r1, &r2))
        pv_logical_and (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* NGR r1, r2 --- logical and --- 64-bit version */
      else if (GDB_TARGET_IS_ESAME
               && is_rre (insn, op_ngr, &r1, &r2))
        pv_logical_and (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* NR r1, r2 --- logical and */
      else if (is_rr (insn, op_nr, &r1, &r2))
        pv_logical_and (&gpr[r1], &gpr[r1], &gpr[r2]);

      /* S r1, d2(x2, b2) --- subtract from memory */
      else if (is_rx (insn, op_s, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;
          struct prologue_value value;
          struct prologue_value *stack;

          compute_x_addr (&addr, gpr, d2, x2, b2);

          /* If it's a load from an in-line constant pool, then we can
             simulate that, under the assumption that the code isn't
             going to change between the time the processor actually
             executed it and the time when we're analyzing it.  */
          if (addr.kind == pv_constant
              && start_pc <= addr.k 
              && addr.k < pc)
            pv_set_to_constant (&value, read_memory_integer (addr.k, 4));

          /* If it's definitely a reference to something on the stack,
             we could do that.  */
          else if (s390_on_stack (&addr, 4, gpr, spill, &back_chain, &stack)
                   == pv_definite_yes)
            value = *stack;

          /* Otherwise, we don't know the value.  */
          else
            pv_set_to_unknown (&value);

          pv_subtract (&gpr[r1], &gpr[r1], &value);
        }

      /* ST r1, d2(x2, b2) --- store  */
      else if (is_rx (insn, op_st, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;

          compute_x_addr (&addr, gpr, d2, x2, b2);

          /* The below really should be '4', not 'S390_GPR_SIZE'; this
             instruction always stores 32 bits, regardless of the full
             size of the GPR.  */
          if (s390_store (&addr, 4, &gpr[r1], gpr, spill, &back_chain)
              == pv_maybe)
            /* If we can't be sure that it's *not* a store to
               something we're tracing, then we would have to mark all
               our memory as unknown --- after all, it *could* be a
               store to any of them --- so we might as well just stop
               interpreting.  */
            break;
        }

      /* STD r1, d2(x2,b2) --- store floating-point register  */
      else if (is_rx (insn, op_std, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;

          compute_x_addr (&addr, gpr, d2, x2, b2);

          if (s390_store (&addr, 8, &fpr[r1], gpr, spill, &back_chain)
              == pv_maybe)
            /* If we can't be sure that it's *not* a store to
               something we're tracing, then we would have to mark all
               our memory as unknown --- after all, it *could* be a
               store to any of them --- so we might as well just stop
               interpreting.  */
            break;
        }

      /* STG r1, d2(x2, b2) --- 64-bit store */
      else if (GDB_TARGET_IS_ESAME
               && is_rxe (insn, op1_stg, op2_stg, &r1, &d2, &x2, &b2))
        {
          struct prologue_value addr;

          compute_x_addr (&addr, gpr, d2, x2, b2);

          /* The below really should be '8', not 'S390_GPR_SIZE'; this
             instruction always stores 64 bits, regardless of the full
             size of the GPR.  */
          if (s390_store (&addr, 8, &gpr[r1], gpr, spill, &back_chain)
              == pv_maybe)
            /* If we can't be sure that it's *not* a store to
               something we're tracing, then we would have to mark all
               our memory as unknown --- after all, it *could* be a
               store to any of them --- so we might as well just stop
               interpreting.  */
            break;
        }

      /* STM r1, r3, d2(b2) --- store multiple */
      else if (is_rs (insn, op_stm, &r1, &r3, &d2, &b2))
        {
          int regnum;
          int offset;
          struct prologue_value addr;

          for (regnum = r1, offset = 0;
               regnum <= r3;
               regnum++, offset += 4)
            {
              compute_x_addr (&addr, gpr, d2 + offset, 0, b2);
              
              if (s390_store (&addr, 4, &gpr[regnum], gpr, spill, &back_chain)
                  == pv_maybe)
                /* If we can't be sure that it's *not* a store to
                   something we're tracing, then we would have to mark all
                   our memory as unknown --- after all, it *could* be a
                   store to any of them --- so we might as well just stop
                   interpreting.  */
                break;
            }

          /* If we left the loop early, we should stop interpreting
             altogether.  */
          if (regnum <= r3)
            break;
        }

      /* STMG r1, r3, d2(b2) --- store multiple, 64-bit */
      else if (GDB_TARGET_IS_ESAME
               && is_rse (insn, op1_stmg, op2_stmg, &r1, &r3, &d2, &b2))
        {
          int regnum;
          int offset;
          struct prologue_value addr;

          for (regnum = r1, offset = 0;
               regnum <= r3;
               regnum++, offset += 8)
            {
              compute_x_addr (&addr, gpr, d2 + offset, 0, b2);
              
              if (s390_store (&addr, 8, &gpr[regnum], gpr, spill, &back_chain)
                  == pv_maybe)
                /* If we can't be sure that it's *not* a store to
                   something we're tracing, then we would have to mark all
                   our memory as unknown --- after all, it *could* be a
                   store to any of them --- so we might as well just stop
                   interpreting.  */
                break;
            }

          /* If we left the loop early, we should stop interpreting
             altogether.  */
          if (regnum <= r3)
            break;
        }
d609 11
d621 21
a641 23
        /* An instruction we don't know how to simulate.  The only
           safe thing to do would be to set every value we're tracking
           to 'unknown'.  Instead, we'll be optimistic: we just stop
           interpreting, and assume that the machine state we've got
           now is good enough for unwinding the stack.  */
        break;

      /* Record the address after the last instruction that changed
         the FP, SP, or backlink.  Ignore instructions that changed
         them back to their original values --- those are probably
         restore instructions.  (The back chain is never restored,
         just popped.)  */
      {
        struct prologue_value *sp = &gpr[S390_SP_REGNUM - S390_GP0_REGNUM];
        struct prologue_value *fp = &gpr[S390_FRAME_REGNUM - S390_GP0_REGNUM];
        
        if ((! pv_is_identical (&pre_insn_sp, sp)
             && ! pv_is_register (sp, S390_SP_REGNUM, 0))
            || (! pv_is_identical (&pre_insn_fp, fp)
                && ! pv_is_register (fp, S390_FRAME_REGNUM, 0))
            || ! pv_is_identical (&pre_insn_back_chain, &back_chain))
          after_last_frame_setup_insn = next_pc;
      }
d643 2
a644 19

  /* Okay, now gpr[], fpr[], spill[], and back_chain reflect the state
     of the machine as of the first instruction we couldn't interpret
     (hopefully the first non-prologue instruction).  */
  {
    /* The size of the frame, or (CORE_ADDR) -1 if we couldn't figure
       that out.  */
    CORE_ADDR frame_size = -1;

    /* The value the SP had upon entry to the function, or
       (CORE_ADDR) -1 if we can't figure that out.  */
    CORE_ADDR original_sp = -1;

    /* Are we using S390_FRAME_REGNUM as a frame pointer register?  */
    int using_frame_pointer = 0;

    /* If S390_FRAME_REGNUM is some constant offset from the SP, then
       that strongly suggests that we're going to use that as our
       frame pointer register, not the SP.  */
d646 12
a657 93
      struct prologue_value *fp = &gpr[S390_FRAME_REGNUM - S390_GP0_REGNUM];

      if (fp->kind == pv_register
          && fp->reg == S390_SP_REGNUM)
        using_frame_pointer = 1;
    }

    /* If we were given a frame_info structure, we may be able to use
       the frame's base address to figure out the actual value of the
       original SP.  */
    if (fi && get_frame_base (fi))
      {
        int frame_base_regno;
        struct prologue_value *frame_base;

        /* The meaning of the frame base depends on whether the
           function uses a frame pointer register other than the SP or
           not (see s390_read_fp):
           - If the function does use a frame pointer register other
             than the SP, then the frame base is that register's
             value.
           - If the function doesn't use a frame pointer, then the
             frame base is the SP itself.
           We're duplicating some of the logic of s390_fp_regnum here,
           but we don't want to call that, because it would just do
           exactly the same analysis we've already done above.  */
        if (using_frame_pointer)
          frame_base_regno = S390_FRAME_REGNUM;
        else
          frame_base_regno = S390_SP_REGNUM;

        frame_base = &gpr[frame_base_regno - S390_GP0_REGNUM];

        /* We know the frame base address; if the value of whatever
           register it came from is a constant offset from the
           original SP, then we can reconstruct the original SP just
           by subtracting off that constant.  */
        if (frame_base->kind == pv_register
            && frame_base->reg == S390_SP_REGNUM)
          original_sp = get_frame_base (fi) - frame_base->k;
      }

    /* If the analysis said that the current SP value is the original
       value less some constant, then that constant is the frame size.  */
    {
      struct prologue_value *sp = &gpr[S390_SP_REGNUM - S390_GP0_REGNUM];

      if (sp->kind == pv_register
          && sp->reg == S390_SP_REGNUM)
        frame_size = -sp->k;
    }

    /* If we knew other registers' current values, we could check if
       the analysis said any of those were related to the original SP
       value, too.  But for now, we'll just punt.  */

    /* If the caller passed in an 'extra info' structure, fill in the
       parts we can.  */
    if (fextra_info)
      {
        if (init_extra_info || ! fextra_info->initialised)
          {
            s390_memset_extra_info (fextra_info);
            fextra_info->function_start = start_pc;
            fextra_info->initialised = 1;
          }

        if (frame_size != -1)
          {
            fextra_info->stack_bought_valid = 1;
            fextra_info->stack_bought = frame_size;
          }

        /* Assume everything was okay, and indicate otherwise when we
           find something amiss.  */
        fextra_info->good_prologue = 1;

        if (using_frame_pointer)
          /* Actually, nobody cares about the exact PC, so any
             non-zero value will do here.  */
          fextra_info->frame_pointer_saved_pc = 1;

        /* If we weren't able to find the size of the frame, or find
           the original sp based on actual current register values,
           then we're not going to be able to unwind this frame.

           (If we're just doing prologue analysis to set a breakpoint,
           then frame_size might be known, but original_sp unknown; if
           we're analyzing a real frame which uses alloca, then
           original_sp might be known (from the frame pointer
           register), but the frame size might be unknown.)  */
        if (original_sp == -1 && frame_size == -1)
          fextra_info->good_prologue = 0;
d659 15
a673 62
        if (fextra_info->good_prologue)
          fextra_info->skip_prologue_function_start
            = after_last_frame_setup_insn;
        else 
          /* If the prologue was too complex for us to make sense of,
             then perhaps it's better to just not skip anything at
             all.  */
          fextra_info->skip_prologue_function_start = start_pc;
      }

    /* Indicate where registers were saved on the stack, if:
       - the caller seems to want to know,
       - the caller provided an actual SP, and
       - the analysis gave us enough information to actually figure it
         out.  */
    if (fi
        && get_frame_saved_regs (fi)
        && original_sp != -1)
      {
        int slot_num;
        CORE_ADDR slot_addr;
        CORE_ADDR *saved_regs = get_frame_saved_regs (fi);

        /* Scan the spill array; if a spill slot says it holds the
           original value of some register, then record that slot's
           address as the place that register was saved.

           Just for kicks, note that, even if registers aren't saved
           in their officially-sanctioned slots, this will still work
           --- we know what really got put where.  */

        /* First, the slots for r2 -- r15.  */
        for (slot_num = 0, slot_addr = original_sp + 2 * S390_GPR_SIZE;
             slot_num < 14;
             slot_num++, slot_addr += S390_GPR_SIZE)
          {
            struct prologue_value *slot = &spill[slot_num];

            if (slot->kind == pv_register
                && slot->k == 0)
              saved_regs[slot->reg] = slot_addr;
          }

        /* Then, the slots for f0, f2, f4, and f6.  They're a
           different size.  */
        for (slot_num = 14, slot_addr = original_sp + 16 * S390_GPR_SIZE;
             slot_num < S390_NUM_SPILL_SLOTS;
             slot_num++, slot_addr += S390_FPR_SIZE)
          {
            struct prologue_value *slot = &spill[slot_num];
            
            if (slot->kind == pv_register
                && slot->k == 0)
              saved_regs[slot->reg] = slot_addr;
          }

        /* The stack pointer's element of saved_regs[] is special.  */
        saved_regs[S390_SP_REGNUM] = original_sp;
      }
  }

  return result;
d800 1
a800 2
      frameless = (fextra_info_ptr->stack_bought_valid
                   && fextra_info_ptr->stack_bought == 0);
d1334 1
a1334 1
   corresponding union types are handled normally.)  So we include
a1356 19
/* Return non-zero if TYPE is a `DOUBLE_ARG', as defined by the
   parameter passing conventions described in the "GNU/Linux for S/390
   ELF Application Binary Interface Supplement".  Return zero
   otherwise.  */
static int
is_double_arg (struct type *type)
{
  unsigned length = TYPE_LENGTH (type);

  /* The s390x ABI doesn't handle DOUBLE_ARGS specially.  */
  if (GDB_TARGET_IS_ESAME)
    return 0;

  return ((is_integer_like (type)
           || is_struct_like (type))
          && length == 8);
}


d1368 1
a1368 1
  return ((is_integer_like (type) && length <= DEPRECATED_REGISTER_SIZE)
d1370 2
a1371 1
          || (is_struct_like (type) && !is_double_arg (type)));
a1374 6
static int
is_power_of_two (unsigned int n)
{
  return ((n & (n - 1)) == 0);
}

d1383 2
a1384 2
  return (is_struct_like (type)
          && !(is_power_of_two (length) && length <= DEPRECATED_REGISTER_SIZE));
d1407 15
d1541 3
a1543 3
        /* SIMPLE_ARG values get extended to DEPRECATED_REGISTER_SIZE bytes. 
           Assume every argument is.  */
        if (length < DEPRECATED_REGISTER_SIZE) length = DEPRECATED_REGISTER_SIZE;
a1563 4
    /* A struct is returned using general register 2 */
    if (struct_return)
      gr++;

d1570 1
a1570 1
            && fr <= S390_NUM_FP_PARAMETER_REGISTERS * 2 - 2)
d1597 1
a1597 1
					   VALUE_CONTENTS (arg) + DEPRECATED_REGISTER_SIZE);
d1613 3
a1615 3
                /* Simple args are always extended to 
                   DEPRECATED_REGISTER_SIZE bytes.  */
                starg = round_up (starg, DEPRECATED_REGISTER_SIZE);
d1623 2
a1624 3
                  /* Simple args are always extended to 
                     DEPRECATED_REGISTER_SIZE bytes. */
                  write_memory_signed_integer (starg, DEPRECATED_REGISTER_SIZE,
d1626 1
a1626 1
                starg += DEPRECATED_REGISTER_SIZE;
d1633 2
a1634 2
                   a four/eight-byte boundary, even when passing doubles. */
                starg = round_up (starg, S390_STACK_PARAMETER_ALIGNMENT);
d1645 1
a1645 1
  sp -= S390_STACK_FRAME_OVERHEAD;
@


1.52.2.10
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d42 1
a42 1
#include "dis-asm.h"
d125 2
a126 1
s390_readinstruction (bfd_byte instr[], CORE_ADDR at)
d136 1
a136 1
  if (target_read_memory (at, &instr[0], 2))
d141 1
a141 1
      if (target_read_memory (at + 2, &instr[2], instrlen - 2))
d907 1
a907 1
                                 + DEPRECATED_REGISTER_BYTE (S390_GP0_REGNUM));
d939 3
d969 2
d994 1
a994 1
      int insn_len = s390_readinstruction (insn, pc);
d1490 1
d1493 2
a1494 1
  instrlen = s390_readinstruction (instr, pc);
d1503 1
a1503 1
    s390_readinstruction (instr, pc - (GDB_TARGET_IS_ESAME ? 6 : 4));
d1520 2
a1521 1
  instrlen = s390_readinstruction (instr, pc - (GDB_TARGET_IS_ESAME ? 12 : 8));
d1622 1
d1631 2
a1632 1
  instrlen = s390_readinstruction (instr, pc);
d1676 2
a1677 1
						       DEPRECATED_REGISTER_BYTE (S390_PC_REGNUM),
d1847 1
a1847 1
					 DEPRECATED_REGISTER_BYTE (S390_GP0_REGNUM +
d1900 1
a1900 1
    memcpy (valbuf, &regbuf[DEPRECATED_REGISTER_BYTE (S390_FP0_REGNUM)], len);
d1908 1
a1908 1
	      regbuf + DEPRECATED_REGISTER_BYTE (S390_GP0_REGNUM + 2) + offset,
d1959 1
a1959 1
        deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (S390_FP0_REGNUM),
d1970 1
a1970 1
      deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (S390_GP0_REGNUM + 2),
d1974 20
d2397 1
a2397 1
            deprecated_write_register_bytes (DEPRECATED_REGISTER_BYTE (S390_FP0_REGNUM + fr),
d2570 1
a2570 1
  write_register (S390_RETADDR_REGNUM, entry_point_address ());
a2724 2
  set_gdbarch_print_insn (gdbarch, print_insn_s390);

d2738 2
@


1.52.2.11
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d904 1
a904 1
      CORE_ADDR *saved_regs = deprecated_get_frame_saved_regs (fi);
d1431 1
a1431 1
        && deprecated_get_frame_saved_regs (fi)
d1436 1
a1436 1
        CORE_ADDR *saved_regs = deprecated_get_frame_saved_regs (fi);
d1722 1
a1722 1
  if (deprecated_get_frame_saved_regs (fi) == NULL)
d1757 1
a1757 1
          && deprecated_get_frame_saved_regs (fi)[S390_RETADDR_REGNUM])
d1760 1
a1760 1
                              (deprecated_get_frame_saved_regs (fi)[S390_RETADDR_REGNUM],
d1844 1
a1844 1
	  if (deprecated_get_frame_saved_regs (thisframe))
d1849 1
a1849 1
                  && deprecated_get_frame_saved_regs (thisframe)[S390_FRAME_REGNUM])
d1854 1
a1854 1
	      if (deprecated_get_frame_saved_regs (thisframe)[regno])
d1858 1
a1858 1
                    prev_fp = deprecated_get_frame_saved_regs (thisframe)[regno];
d1861 1
a1861 1
                      read_memory_integer (deprecated_get_frame_saved_regs (thisframe)[regno],
a1876 9
/* NOTE: cagney/2003-10-31: "return_value" makes
   "extract_struct_value_address", "extract_return_value", and
   "use_struct_convention" redundant.  */
static CORE_ADDR
s390_cannot_extract_struct_value_address (struct regcache *regcache)
{
  return 0;
}

d1995 1
a1995 1
  if (deprecated_get_frame_saved_regs (frame))
d1998 1
a1998 1
        if (deprecated_get_frame_saved_regs (frame)[regnum] != 0)
d2002 2
a2003 2
            value = read_memory_unsigned_integer (deprecated_get_frame_saved_regs (frame)[regnum],
                                                  DEPRECATED_REGISTER_RAW_SIZE (regnum));
d2010 1
a2010 1
      write_register (S390_SP_REGNUM, deprecated_get_frame_saved_regs (frame)[S390_SP_REGNUM]);
d2209 22
d2307 1
a2307 1
          sp = align_down (sp, alignment_of (type));
d2326 1
a2326 1
        sp = align_down (sp, alignment_of (type));
d2336 1
a2336 1
  sp = align_down (sp, pointer_size);
d2341 1
a2341 1
  sp = align_down (sp, 8);
d2406 1
a2406 1
                starg = align_up (starg, DEPRECATED_REGISTER_SIZE);
d2423 1
a2423 1
                   starg = align_up (starg, alignment_of (type));
d2426 1
a2426 1
                starg = align_up (starg, S390_STACK_PARAMETER_ALIGNMENT);
d2595 1
a2595 1
  set_gdbarch_deprecated_init_frame_pc (gdbarch, deprecated_init_frame_pc_default);
d2647 2
a2648 1
  set_gdbarch_extract_struct_value_address (gdbarch, s390_cannot_extract_struct_value_address);
@


1.52.2.12
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2600 3
@


1.51
log
@Index: ChangeLog
===================================================================
RCS file: /cvs/src/src/gdb/ChangeLog,v
retrieving revision 1.3144
diff -u -r1.3144 ChangeLog
--- ChangeLog	23 Aug 2002 23:05:38 -0000	1.3144
+++ ChangeLog	23 Aug 2002 23:14:45 -0000
@@@@ -1,3 +1,53 @@@@
2002-08-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (STORE_RETURN_VALUE): Add regcache parameter.
	(DEPRECATED_STORE_RETURN_VALUE): New method.
	(EXTRACT_RETURN_VALUE): Make buffer parameter a void pointer.
	* gdbarch.h, gdbarch.c: Re-generate.

	* values.c (set_return_value): Pass current_regcache to
	STORE_RETURN_VALUE.
	* arch-utils.h (legacy_store_return_value): Declare.
	* arch-utils.c (legacy_store_return_value): New function.
	(legacy_extract_return_value): Update parameters.

	* config/pa/tm-hppa.h (DEPRECATED_STORE_RETURN_VALUE): Rename
	STORE_RETURN_VALUE.
	* config/pa/tm-hppa64.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/z8k/tm-z8k.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparclet.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/mn10200/tm-mn10200.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-linux.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m32r/tm-m32r.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8500/tm-h8500.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8300/tm-h8300.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.

	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* i386-tdep.c (i386_extract_return_value): Update.
	* arch-utils.c (legacy_extract_return_value): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.

Index: doc/ChangeLog
2002-08-21  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Update
	STORE_RETURN_VALUE, mention regcache.
@
text
@d959 1
a959 1
    return generic_read_register_dummy (fi->pc, fi->frame, S390_PC_REGNUM);
d1013 2
a1014 2
    return generic_read_register_dummy (thisframe->pc, thisframe->frame,
                                        S390_SP_REGNUM);
@


1.50
log
@2002-08-05  Andrew Cagney  <ac131313@@redhat.com>
* mcore-tdep.c (mcore_gdbarch_init): Use
generic_unwind_get_saved_register instead of
generic_get_saved_register.
* v850-tdep.c (v850_gdbarch_init): Ditto.
* frv-tdep.c (frv_gdbarch_init): Ditto.
* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
* s390-tdep.c (s390_gdbarch_init): Ditto.
* d10v-tdep.c (d10v_gdbarch_init): Ditto.
* config/mn10200/tm-mn10200.h (GET_SAVED_REGISTER): Ditto.
* config/h8300/tm-h8300.h (GET_SAVED_REGISTER): Ditto.
@
text
@d1777 1
a1777 1
  set_gdbarch_store_return_value (gdbarch, s390_store_return_value);
@


1.49
log
@Fix some K&R isms.
@
text
@d1814 1
a1814 1
  set_gdbarch_get_saved_register (gdbarch, generic_get_saved_register);
@


1.48
log
@* frame.h (deprecated_generic_find_dummy_frame): Rename
generic_find_dummy_frame.
* blockframe.c (generic_find_dummy_frame): Make static.
(deprecated_generic_find_dummy_frame): New function.
* sh-tdep.c (sh_nofp_frame_init_saved_regs): Replace
generic_find_dummy_frame with deprecated_find_dummy_frame.
(sh64_nofp_frame_init_saved_regs): Ditto.
(sh_fp_frame_init_saved_regs): Ditto.
* s390-tdep.c (s390_frame_saved_pc_nofix): Ditto.
(s390_frame_chain): Ditto.
* cris-tdep.c (cris_frame_init_saved_regs): Ditto.
@
text
@d1192 1
a1192 1
s390_fp_regnum ()
d1207 1
a1207 1
s390_read_fp ()
d1249 1
a1249 1
s390_pop_frame ()
d1877 1
a1877 1
_initialize_s390_tdep ()
@


1.47
log
@* gdbarch.sh (REGISTER_NAME): Change return type a constant string
pointer.
* gdbarch.h, gdbarch.c: Regenerate.
* config/mips/tm-mips.h (mips_register_name): Update.
* i386-tdep.h (i386_register_name): Update.
* mips-tdep.c (mips_register_name): Update
* alpha-tdep.c (alpha_register_name): Update.
* arch-utils.c (legacy_register_name): Update.
* arch-utils.h (legacy_register_name): Update.
* avr-tdep.c (avr_register_name): Update.
* ia64-tdep.c (ia64_register_name): Update.
* i386-tdep.c (i386_register_name): Update.
* sparc-tdep.c (sparc32_register_name): Update.
(sparc64_register_name): Update.
(sparclite_register_name): Update.
(sparclet_register_name):
* sh-tdep.c (sh_generic_register_name): Update.
(sh_sh_register_name): Update.
(sh_sh3_register_name): Update.
(sh_sh3e_register_name): Update.
(sh_sh_dsp_register_name): Update.
(sh_sh3_dsp_register_name): Update.
(sh_sh4_register_name): Update.
(sh_sh64_register_name): Update.
* s390-tdep.c (s390_register_name): Update.
* rs6000-tdep.c (rs6000_register_name): Update.
* ns32k-tdep.c (ns32k_register_name_32082): Update.
(ns32k_register_name_32382): Update.
* d10v-tdep.c (d10v_ts2_register_name): Update.
(d10v_ts3_register_name): Update.
* xstormy16-tdep.c (xstormy16_register_name): Update.
* vax-tdep.c (vax_register_name): Update.
* v850-tdep.c (v850_register_name): Update.
* m68hc11-tdep.c (m68hc11_register_name): Update.
* mn10300-tdep.c (mn10300_generic_register_name): Update.
(am33_register_name): Update.
@
text
@d958 1
a958 1
  if (generic_find_dummy_frame (fi->pc, fi->frame))
d1012 1
a1012 1
  if (generic_find_dummy_frame (thisframe->pc, thisframe->frame))
@


1.46
log
@+	* gdbarch.sh (DEPRECATED_EXTRACT_RETURN_VALUE): Rename
+	EXTRACT_RETURN_VALUE.
+	(DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS): Rename
+	EXTRACT_STRUCT_VALUE_ADDRESS.
+	* gdbarch.h, gdbarch.c: Regenerate.
+
+	* values.c (value_being_returned): Handle
+	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
+	(EXTRACT_RETURN_VALUE): Define as DEPRECATED_EXTRACT_RETURN_VALUE.
+
+	* arm-linux-tdep.c (arm_linux_init_abi): Update.
+	* arm-tdep.c (arm_gdbarch_init): Update.
+	* avr-tdep.c (avr_gdbarch_init): Update.
+	* cris-tdep.c (cris_gdbarch_init): Update.
+	* d10v-tdep.c (d10v_gdbarch_init): Update.
+	* ia64-tdep.c (ia64_gdbarch_init): Update.
+	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
+	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sh-tdep.c (sh_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sparc-tdep.c (sparc_gdbarch_init): Update.
+	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
+	* v850-tdep.c (v850_gdbarch_init): Update.
+	* vax-tdep.c (vax_gdbarch_init): Update.
+	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
+	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
+
+	* config/arc/tm-arc.h: Update.
+	* config/d30v/tm-d30v.h: Update.
+	* config/fr30/tm-fr30.h: Update.
+	* config/h8300/tm-h8300.h: Update.
* config/h8500/tm-h8500.h: Update.
* config/i386/tm-i386.h: Update.
* config/i386/tm-ptx.h: Update.
* config/i386/tm-symmetry.h: Update.
* config/i960/tm-i960.h: Update.
* config/m32r/tm-m32r.h: Update.
* config/m68k/tm-delta68.h: Update.
* config/m68k/tm-linux.h: Update.
* config/m68k/tm-m68k.h: Update.
* config/m88k/tm-m88k.h: Update.
* config/mcore/tm-mcore.h: Update.
* config/mips/tm-mips.h: Update.
* config/mn10200/tm-mn10200.h: Update.
* config/pa/tm-hppa.h: Update.
* config/pa/tm-hppa64.h: Update.
* config/sparc/tm-sp64.h: Update.
* config/sparc/tm-sparc.h: Update.
* config/sparc/tm-sparclet.h: Update.
* config/z8k/tm-z8k.h: Update.
@
text
@d153 1
a153 1
char *
@


1.45
log
@* sparc-tdep.c (sparc_get_saved_register): Use get_prev_frame
instead of ->prev.
* z8k-tdep.c (z8k_frame_chain): Do not use ->prev.
* s390-tdep.c (s390_frame_chain): Do not use ->prev.
* rs6000-tdep.c (frame_get_saved_regs): Use rs6000_frame_chain()
instead of ->prev.
@
text
@d1776 1
a1776 1
  set_gdbarch_extract_return_value (gdbarch, s390_extract_return_value);
d1821 1
a1821 1
  set_gdbarch_extract_struct_value_address
@


1.45.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d153 1
a153 1
const char *
d1776 1
a1776 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, s390_extract_return_value);
d1821 1
a1821 1
  set_gdbarch_deprecated_extract_struct_value_address
@


1.45.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d958 1
a958 1
  if (deprecated_generic_find_dummy_frame (fi->pc, fi->frame))
d1012 1
a1012 1
  if (deprecated_generic_find_dummy_frame (thisframe->pc, thisframe->frame))
d1192 1
a1192 1
s390_fp_regnum (void)
d1207 1
a1207 1
s390_read_fp (void)
d1249 1
a1249 1
s390_pop_frame (void)
d1877 1
a1877 1
_initialize_s390_tdep (void)
@


1.45.6.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d1814 1
a1814 1
  set_gdbarch_get_saved_register (gdbarch, generic_unwind_get_saved_register);
@


1.45.6.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d1777 1
a1777 1
  set_gdbarch_deprecated_store_return_value (gdbarch, s390_store_return_value);
@


1.45.6.5
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d959 1
a959 1
    return deprecated_read_register_dummy (fi->pc, fi->frame, S390_PC_REGNUM);
d1013 2
a1014 2
    return deprecated_read_register_dummy (thisframe->pc, thisframe->frame,
					   S390_SP_REGNUM);
@


1.45.6.6
log
@merge from mainline
@
text
@d1598 4
a1601 4
            deprecated_write_register_gen (S390_GP0_REGNUM + gr,
					   VALUE_CONTENTS (arg));
            deprecated_write_register_gen (S390_GP0_REGNUM + gr + 1,
					   VALUE_CONTENTS (arg) + 4);
@


1.45.4.1
log
@merge from trunk
@
text
@d1776 1
a1776 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, s390_extract_return_value);
d1821 1
a1821 1
  set_gdbarch_deprecated_extract_struct_value_address
@


1.45.4.2
log
@Merge with trunk.
@
text
@d153 1
a153 1
const char *
@


1.45.4.3
log
@merge with trunk
@
text
@d958 1
a958 1
  if (deprecated_generic_find_dummy_frame (fi->pc, fi->frame))
d1012 1
a1012 1
  if (deprecated_generic_find_dummy_frame (thisframe->pc, thisframe->frame))
@


1.44
log
@* gdbarch.sh (BREAKPOINT_FROM_PC): Return a const buffer.
* gdbarch.h, gdbarch.c: Regenerate.

* defs.h (breakpoint_from_pc_fn): Delete type definition.
* target.h (memory_breakpoint_from_pc): Update declaration.
* config/mcore/tm-mcore.h (mcore_breakpoint_from_p): Ditto.

* arch-utils.c (legacy_breakpoint_from_pc): Update return type.
* mcore-tdep.c (mcore_breakpoint_from_pc): Ditto.
* mem-break.c (memory_breakpoint_from_pc): Ditto.
* rs6000-tdep.c (rs6000_breakpoint_from_pc): Ditto.
* s390-tdep.c (s390_breakpoint_from_pc): Ditto
* xstormy16-tdep.c (xstormy16_breakpoint_from_pc): Ditto.
* mn10300-tdep.c (mn10300_breakpoint_from_pc): Ditto.
* mips-tdep.c (mips_breakpoint_from_pc): Ditto.
* m68hc11-tdep.c (m68hc11_breakpoint_from_pc): Ditto.
* ia64-tdep.c (ia64_breakpoint_from_pc): Ditto.
* d10v-tdep.c (d10v_breakpoint_from_pc): Ditto.
* arch-utils.c (legacy_breakpoint_from_pc): Ditto..

* mem-break.c (default_memory_insert_breakpoint): Make `bp' a
const pointer.
* monitor.c (monitor_insert_breakpoint): Ditto.
* rs6000-tdep.c (rs6000_software_single_step): Ditto for `breakp'.

* config/mcore/tm-mcore.h: Update copyright.
* mem-break.c: Ditto.
* xstormy16-tdep.c: Ditto.
@
text
@d1012 1
a1012 3
  if (thisframe->prev && thisframe->prev->frame)
    prev_fp = thisframe->prev->frame;
  else if (generic_find_dummy_frame (thisframe->pc, thisframe->frame))
@


1.43
log
@* h8500-tdep.c (h8500_write_fp): Delete function.
* dwarf2cfi.c (cfi_write_fp): Document as not used.
* mips-tdep.c (mips_gdbarch_init): Do not set write_fp.
* ia64-tdep.c (ia64_gdbarch_init): Do not set write_fp.
* m68hc11-tdep.c (m68hc11_gdbarch_init): Do not set write_fp.
* rs6000-tdep.c (rs6000_gdbarch_init): Do not set write_fp.
* s390-tdep.c (s390_gdbarch_init): Do not set write_fp.
(s390_write_fp):
* sh-tdep.c (sh_gdbarch_init): Do not set write_fp.
* x86-64-tdep.c (i386_gdbarch_init): Do not set write_fp.
* d10v-tdep.c (d10v_gdbarch_init): Do not set write_fp.
(d10v_write_fp): Delete function.
* inferior.h (write_fp, generic_target_write_fp): Delete
declarations.
* regcache.c (generic_target_write_fp): Delete function.
(write_fp): Delete function.
* gdbarch.sh (TARGET_WRITE_FP): Delete.
* gdbarch.h, gdbarch.c: Regenerate.
* config/v850/tm-v850.h (TARGET_WRITE_FP): Delete macro.
* config/sparc/tm-sp64.h (TARGET_WRITE_FP): Delete macro.
(sparc64_write_fp): Delete declaration.
* config/h8500/tm-h8500.h (TARGET_WRITE_FP): Delete macro.
(h8500_write_fp): Delete declaration.
@
text
@d1703 1
a1703 1
static unsigned char *
@


1.42
log
@s/Linux/.../
Fix PR gdb/378.
@
text
@a1214 7
void
s390_write_fp (CORE_ADDR val)
{
  write_register (s390_fp_regnum (), val);
}


a1796 1
  set_gdbarch_write_fp (gdbarch, s390_write_fp);
@


1.41
log
@From 2002-02-20 Martin Schwidefsky <schwidefsky@@de.ibm.com>:
* config/s390/tm-s390.h (GDB_TARGET_IS_ESAME): Use renamed
architecture defines.
* s390-tdep.c (s390_gdbarch_init): Likewise.
@
text
@d2 3
a4 1
   Copyright 2001 Free Software Foundation, Inc.
d1359 1
a1359 1
   "Linux for S/390 ELF Application Binary Interface Supplement".
d1371 3
a1373 2
   the parameter passing conventions described in the "Linux for S/390
   ELF Application Binary Interface Supplement".  Return zero otherwise.  */
d1421 3
a1423 2
   parameter passing conventions described in the "Linux for S/390 ELF
   Application Binary Interface Supplement".  Return zero otherwise.  */
d1494 2
a1495 2
   place to be passed to a function, as specified by the "Linux for
   S/390 ELF Application Binary Interface Supplement".
@


1.40
log
@Eliminate IEEE_FLOAT.
@
text
@d1854 1
a1854 1
    case bfd_mach_s390_esa:
d1863 1
a1863 1
    case bfd_mach_s390_esame:
@


1.39
log
@* s390-tdep.c (s390_pop_frame_regular): Make sure the saved_regs
array is actually set before we try to use it.
@
text
@a1787 1
  set_gdbarch_ieee_float (gdbarch, 1);
@


1.38
log
@* s390-tdep.c (s390_frame_saved_pc_nofix): If we get the saved PC
out of the return address register, cache that in the frame's
extra info, just as if we'd gotten it from the saved regs array;
that way, it's not a lie to set the saved_pc_valid flag.
@
text
@d1228 11
a1238 4
  for (regnum = 0; regnum < NUM_REGS; regnum++)
    if (frame->saved_regs[regnum] != 0)
      {
        ULONGEST value;
d1240 5
a1244 9
        value = read_memory_unsigned_integer (frame->saved_regs[regnum],
                                              REGISTER_RAW_SIZE (regnum));
        write_register (regnum, value);
      }

  /* Actually cut back the stack.  Remember that the SP's element of
     saved_regs is the old SP itself, not the address at which it is
     saved.  */
  write_register (S390_SP_REGNUM, frame->saved_regs[S390_SP_REGNUM]);
@


1.37
log
@* s390-tdep.c (s390_get_frame_info): Give orig_sp a reasonable
value, even when fextra_info->stack_bought can't be trusted,
@
text
@d963 10
a972 12
      if (fi->extra_info->good_prologue)
	{
	  if (fi->saved_regs[S390_RETADDR_REGNUM])
	    {
	      return (fi->extra_info->saved_pc =
		      ADDR_BITS_REMOVE (read_memory_integer
					(fi->saved_regs[S390_RETADDR_REGNUM],
					 S390_GPR_SIZE)));
	    }
          else
            return read_register (S390_RETADDR_REGNUM);
	}
@


1.36
log
@* s390-tdep.c (s390_readinstruction): Don't call
info->read_memory_func to read zero bytes.  Some targets'
xfer_memory functions can't cope with that.
@
text
@d288 1
d290 1
a290 1
            orig_sp = fi->frame + fextra_info->stack_bought;
@


1.35
log
@* gdbarch.sh (TARGET_CHAR_SIGNED): New macro.
* gdbarch.c, gdbarch.h: Regenerated.
* gdbtypes.c (build_gdbtypes): If TARGET_CHAR_SIGNED is zero,
set the TYPE_FLAG_UNSIGNED bit on the type.
* s390-tdep.c (s390_gdbarch_init): On the S/390, characters
are unsigned by default.
* rs6000-tdep.c (rs6000_gdbarch_init): Same for PowerPC and
RS6000.
@
text
@d135 5
a139 2
  if ((*info->read_memory_func) (at + 2, &instr[2], instrlen - 2, info))
    return -1;
@


1.34
log
@* s390-tdep.c (s390_register_name): S390_LAST_REGNUM is, in fact,
the last register number, not one greater than the last register
number.

* s390-tdep.c (s390_register_virtual_type): Replace clever but
incorrect range comparison with correct, legible equivalent.
@
text
@d1766 1
@


1.33
log
@* s390-tdep.c (s390_gdbarch_init): Revert accidentally committed
change.
@
text
@d164 3
a166 1
  if (reg_nr >= S390_LAST_REGNUM)
a167 1
  return register_names[reg_nr];
d1676 4
a1679 2
  return ((unsigned) regno - S390_FPC_REGNUM) <
    S390_NUM_FPRS ? builtin_type_double : builtin_type_int;
@


1.32
log
@* s390-tdep.c (s390_register_raw_size): Replace unnecessarily
obscure range comparison with legible equivalent.
@
text
@a1762 1
  set_gdbarch_char_signed (gdbarch, 0);
@


1.31
log
@* s390-tdep.c (s390_store_return_value): Don't convert float
values to double format when returning them; just return them in
the first half of the FP register, as the ABI specifies.
@
text
@d45 1
a45 3
   for register N. 
   Note that the unsigned cast here forces the result of the
   subtraction to very high positive values if N < S390_FP0_REGNUM */
d49 5
a53 2
  return ((unsigned) reg_nr - S390_FP0_REGNUM) <
    S390_NUM_FPRS ? S390_FPR_SIZE : 4;
d1763 1
@


1.30
log
@* s390-tdep.c (s390_get_frame_info): Recognize argument register
spills that use the `stm' instruction.
(is_arg_reg): New function.
@
text
@d1147 7
a1153 6
      DOUBLEST tempfloat = extract_floating (valbuf, TYPE_LENGTH (valtype));

      floatformat_from_doublest (&floatformat_ieee_double_big, &tempfloat,
				 reg_buff);
      write_register_bytes (REGISTER_BYTE (S390_FP0_REGNUM), reg_buff,
			    S390_FPR_SIZE);
@


1.29
log
@* s390-tdep.c (s390_get_frame_info): Recognize spills of reg
arguments into their stack slots.
@
text
@d183 8
d416 1
a416 1
      /* Check for an fp-relative STG or ST.  This is probably
d425 8
a432 3
          && instr[0] == 0x50      /* st %rA, D(%rX,%rB) */
          && (instr[1] & 0xf) == 0 /* %rX is zero, no index reg */
          && ((instr[2] >> 4) & 0xf) == frame_pointer_regidx)
@


1.28
log
@* s390-tdep.c (s390_get_frame_info): More doc fixes.
@
text
@d408 17
@


1.27
log
@* s390-tdep.c (s390_get_frame_info): Doc fixes.
@
text
@d212 1
a212 1
  int frame_pointer_found, varargs_state;
a213 1
  int frame_pointer_regidx = 0xf;
d218 9
d247 1
a247 1
  int save_link_state;
d261 1
a261 1
  int got_state;
d264 2
a265 2
  const_pool_state = save_link_state = got_state = varargs_state = 0;
  frame_pointer_found = 0;
@


1.26
log
@* s390-tdep.c (s390_get_frame_info): Don't used fextra_info to set
orig_sp if it's not initialized.
@
text
@d211 1
a211 2
  int save_link_regidx, subtract_sp_regidx;
  int const_pool_state, save_link_state;
d219 23
d518 2
a519 1
         long vals    %r15,0(%gprx)  gprx currently r1 */
@


1.25
log
@Tighten up GDB's support for returning structs by value.
* s390-tdep.c (s390_use_struct_convention): New function.
(s390_gdbarch_init): Register it as the S/390's
USE_STRUCT_CONVENTION method.  Register
generic_cannot_extract_struct_value_address as our
EXTRACT_STRUCT_VALUE_ADDRESS method.
* arch-utils.c (generic_cannot_extract_struct_value_address): New
function.
* arch-utils.h: Add corresponding prototype.
@
text
@d245 2
a246 1
	  orig_sp = fi->frame + fextra_info->stack_bought;
@


1.24
log
@* s390-tdep.c (s390_frame_saved_pc_nofix): If the prologue didn't
save the return address register, assume that the return address
is still in there.
@
text
@d1595 11
d1749 1
a1749 1
  set_gdbarch_use_struct_convention (gdbarch, generic_use_struct_convention);
d1755 2
a1771 1
  set_gdbarch_extract_struct_value_address (gdbarch, 0);
@


1.23
log
@* s390-tdep.c: Get frame chains and saved pc values properly from
dummy frames.
(s390_frame_saved_pc_nofix): if `*fi' is a dummy frame, get the
saved PC from the dummy frame's registers.
(s390_frame_chain): Same for the saved SP.
(s390_gdbarch_init): Register `generic_save_dummy_frame_tos' as
the `SAVE_DUMMY_FRAME_TOS' method, so the dummy frame's `top' gets
set correctly.
@
text
@d904 2
@


1.22
log
@* s390-tdep.c (s390_frame_chain): Remember that the SP's element
of the frame's saved_regs array is special.
@
text
@d887 4
d944 3
d1753 1
@


1.21
log
@* s390-tdep.c (s390_push_dummy_frame): Delete function; it's no
longer used.
@
text
@d977 1
d979 5
a983 1
	      int regno;
a984 5
	      regno =
		((prev_fextra_info.frame_pointer_saved_pc
		  && thisframe->
		  saved_regs[S390_FRAME_REGNUM]) ? S390_FRAME_REGNUM :
		 S390_SP_REGNUM);
d986 9
a994 3
		prev_fp =
		  read_memory_integer (thisframe->saved_regs[regno],
				       S390_GPR_SIZE);
@


1.20
log
@* s390-tdep.c (register_names): Call the general-purpose registers
`r0' -- `r15', and the floating-point registers `f0' -- `f15', to
match the assembly language.
@
text
@a1137 16
void
s390_push_dummy_frame ()
{
  CORE_ADDR orig_sp = read_register (S390_SP_REGNUM), new_sp;
  void *saved_regs = alloca (REGISTER_BYTES);

  new_sp = (orig_sp - (REGISTER_BYTES + S390_GPR_SIZE));
  read_register_bytes (0, (char *) saved_regs, REGISTER_BYTES);
  /* Use saved copy instead of orig_sp as this will have the correct endianness */
  write_memory (new_sp, (char *) saved_regs + REGISTER_BYTE (S390_SP_REGNUM),
		S390_GPR_SIZE);
  write_memory (new_sp + S390_GPR_SIZE, (char *) &saved_regs, REGISTER_BYTES);
  write_register (S390_SP_REGNUM, new_sp);
}


@


1.19
log
@* s390-tdep.c: Tweak argument-passing to match GCC bugs.
(is_float_singleton, is_struct_like, is_float_like): New
functions, that isolate the weirdness.
(is_double_or_float, is_simple_arg, pass_by_copy_ref,
is_double_arg): Use is_struct_like and is_float_like, rather than
testing the type codes ourselves.
(s390_push_arguments): When passing args on the stack, align each
on to a four-byte boundary, regardless of what the type itself
needs.
@
text
@d152 2
a153 2
    "gpr0", "gpr1", "gpr2", "gpr3", "gpr4", "gpr5", "gpr6", "gpr7",
    "gpr8", "gpr9", "gpr10", "gpr11", "gpr12", "gpr13", "gpr14", "gpr15",
d159 2
a160 2
    "fpr0", "fpr1", "fpr2", "fpr3", "fpr4", "fpr5", "fpr6", "fpr7",
    "fpr8", "fpr9", "fpr10", "fpr11", "fpr12", "fpr13", "fpr14", "fpr15"
@


1.18
log
@* s390-tdep.c (is_simple_arg): Structs and unions exactly eight
bytes long should be handled as DOUBLE_ARGs; don't recognize them
as SIMPLE_ARGs.
@
text
@d1224 62
d1293 1
a1293 1
  return (TYPE_CODE (type) == TYPE_CODE_FLT
a1304 1
  enum type_code code = TYPE_CODE (type);
d1311 2
a1312 4
          || ((code == TYPE_CODE_STRUCT
               || code == TYPE_CODE_UNION)
              && length != 8)
          || (code == TYPE_CODE_FLT && length == 16));
a1321 1
  enum type_code code = TYPE_CODE (type);
d1324 2
a1325 3
  return (((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION)
           && length != 1 && length != 2 && length != 4)
          || (code == TYPE_CODE_FLT && length == 16));
a1353 1
  enum type_code code = TYPE_CODE (type);
d1357 1
a1357 2
           || code == TYPE_CODE_STRUCT
           || code == TYPE_CODE_UNION)
d1570 5
a1574 1
                starg = round_up (starg, alignment_of (type));
@


1.17
log
@* s390-tdep.c (s390_pop_frame_regular): On the S/390, the frame
pointer and the SP are often the same, so we can't pop the frame
by setting the SP to the FP; we need to get the old SP from
saved_regs.
@
text
@d1246 2
d1250 3
a1252 2
          || code == TYPE_CODE_STRUCT
          || code == TYPE_CODE_UNION
@


1.16
log
@* s390-tdep.c (s390_extract_return_value): Returned `float' values
can simply be copied bitwise from the registers into the value
object's buffer.
@
text
@d1172 4
a1175 2
  /* Actually cut back the stack.  */
  write_register (S390_SP_REGNUM, FRAME_FP (frame));
@


1.15
log
@* s390-tdep.c (s390_get_frame_info): Initialize SP's element of
the frame's saved_regs array correctly.
@
text
@d1013 1
a1013 14
    {
      if (len > (TARGET_FLOAT_BIT >> 3))
	memcpy (valbuf, &regbuf[REGISTER_BYTE (S390_FP0_REGNUM)], len);
      else
	{
	  /* float */
	  DOUBLEST val;

	  floatformat_to_doublest (&floatformat_ieee_double_big,
				   &regbuf[REGISTER_BYTE (S390_FP0_REGNUM)],
				   &val);
	  store_floating (valbuf, len, val);
	}
    }
@


1.14
log
@* s390-tdep.c: Rewrite inferior function call code.  This may
break zSeries support; that should be fixed soon.
#include "gdb_assert.h".
(is_integer_like, is_pointer_like, is_simple_arg,
pass_by_copy_ref, extend_simple_arg, is_double_arg, round_up,
round_down, alignment_of): New functions.
(s390_push_arguments): Rewritten to handle passing large arguments
by value, and to make more readable.
@
text
@d599 4
@


1.13
log
@* s390-tdep.c (s390_pop_frame): Call generic_pop_current_frame, to
interact correctly with generic dummy frames.
(s390_pop_frame_regular): Move the guts of the frame-popping code
to here, to be called by generic_pop_current_frame.  Use the
frame's saved_regs array; this works for `return' as well as
inferior function calls.
@
text
@d39 1
a39 1

d1202 27
a1228 8
/* used by call function by hand
  struct_return indicates that this function returns a structure &
  therefore gpr2 stores a pointer to the structure to be returned as
  opposed to the first argument.
  Currently I haven't seen a TYPE_CODE_INT whose size wasn't 2^n or less
  than S390_GPR_SIZE this is good because I don't seem to have to worry
  about sign extending pushed arguments (i.e. a signed char currently
  comes into this code with a size of 4 ). */
d1230 153
d1387 34
a1420 8
  int num_float_args, num_gpr_args, orig_num_gpr_args, argno;
  int second_pass, len, arglen, gprs_required;
  CORE_ADDR outgoing_args_ptr, outgoing_args_space;
  struct value *arg;
  struct type *type;
  int max_num_gpr_args = 5 - (struct_return ? 1 : 0);
  int arg0_regnum = S390_GP0_REGNUM + 2 + (struct_return ? 1 : 0);
  char *reg_buff = alloca (max (S390_FPR_SIZE, REGISTER_SIZE)), *value;
d1422 7
a1428 17
  for (second_pass = 0; second_pass <= 1; second_pass++)
    {
      if (second_pass)
	outgoing_args_ptr = sp + S390_STACK_FRAME_OVERHEAD;
      else
	outgoing_args_ptr = 0;
      num_float_args = 0;
      num_gpr_args = 0;
      for (argno = 0; argno < nargs; argno++)
	{
	  arg = args[argno];
	  type = check_typedef (VALUE_TYPE (arg));
	  len = TYPE_LENGTH (type);
	  if (TYPE_CODE (type) == TYPE_CODE_FLT)
	    {
	      int all_float_registers_used =
		num_float_args > (GDB_TARGET_IS_ESAME ? 3 : 1);
d1430 6
a1435 4
	      if (second_pass)
		{
		  DOUBLEST tempfloat =
		    extract_floating (VALUE_CONTENTS (arg), len);
d1437 15
d1453 73
a1525 21
		  floatformat_from_doublest (all_float_registers_used &&
					     len == (TARGET_FLOAT_BIT >> 3)
					     ? &floatformat_ieee_single_big
					     : &floatformat_ieee_double_big,
					     &tempfloat, reg_buff);
		  if (all_float_registers_used)
		    write_memory (outgoing_args_ptr, reg_buff, len);
		  else
		    write_register_bytes (REGISTER_BYTE ((S390_FP0_REGNUM)
							 +
							 (2 *
							  num_float_args)),
					  reg_buff, S390_FPR_SIZE);
		}
	      if (all_float_registers_used)
		outgoing_args_ptr += len;
	      num_float_args++;
	    }
	  else
	    {
	      gprs_required = ((len + (S390_GPR_SIZE - 1)) / S390_GPR_SIZE);
d1527 10
a1536 38
	      value =
		s390_promote_integer_argument (type, VALUE_CONTENTS (arg),
					       reg_buff, &arglen);

	      orig_num_gpr_args = num_gpr_args;
	      num_gpr_args += gprs_required;
	      if (num_gpr_args > max_num_gpr_args)
		{
		  if (second_pass)
		    write_memory (outgoing_args_ptr, value, arglen);
		  outgoing_args_ptr += arglen;
		}
	      else
		{
		  if (second_pass)
		    write_register_bytes (REGISTER_BYTE (arg0_regnum)
					  +
					  (orig_num_gpr_args * S390_GPR_SIZE),
					  value, arglen);
		}
	    }
	}
      if (second_pass)
        {
          /* Write the back chain pointer into the first word of the
             stack frame.  This will help us get backtraces from
             within functions called from GDB.  */
          write_memory_unsigned_integer (sp, 
                                         (TARGET_PTR_BIT / TARGET_CHAR_BIT),
                                         read_fp ());
        }
      else
	{
	  outgoing_args_space = outgoing_args_ptr;
	  /* Align to 16 bytes because because I like alignment & 
	     some of the kernel code requires 8 byte stack alignment at least. */
	  sp = (sp - (S390_STACK_FRAME_OVERHEAD + outgoing_args_ptr)) & (-16);
	}
a1537 1
    }
a1538 1

@


1.12
log
@* s390-tdep.c (s390_gdbarch_init): Register the function
`standard_coerce_float_to_double', since GCC for the S/390 follows
the standard rules for passing floats.
@
text
@d1162 31
a1192 3
/* pop the innermost frame, go back to the caller.
    Used in `call_function_by_hand' to remove an artificial stack
     frame.  */
d1196 4
a1199 3
  CORE_ADDR new_sp = read_register (S390_SP_REGNUM), orig_sp;
  void *saved_regs = alloca (REGISTER_BYTES);

a1200 3
  read_memory (new_sp + S390_GPR_SIZE, (char *) saved_regs, REGISTER_BYTES);
  write_register_bytes (0, (char *) &saved_regs, REGISTER_BYTES);
}
@


1.11
log
@* s390-tdep.c: Don't use a call dummy.
(s390_fix_call_dummy, s390_pc_in_call_dummy): Delete.
(s390_push_return_address): Put the address of the inferior call
breakpoint in r14.
(s390_gdbarch_init):
- Provide trivial definition of s390_call_dummy_words; register it
  with the gdbarch appropriately.
- Delete S390x_call_dummy_words.
- Gather inferior-call-related settings into a group.
- Use generic dummy frames.
- Put the inferior call breakpoint at the entry point.
- Use generic gdbarch methods: pc_in_call_dummy_at_entry_point,
  generic_push_dummy_frame, generic_fix_call_dummy.
- There is a call dummy breakpoint offset; it's zero.
@
text
@d1457 2
@


1.10
log
@* s390-nat.c: (s390_push_arguments): Write a back chain pointer
into the dummy frame, to help us get backtraces.
@
text
@a1287 9
void
s390_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs,
		     struct value **args, struct type *value_type,
		     int using_gcc)
{
  store_unsigned_integer (dummy + 4, REGISTER_SIZE, fun);
}


a1335 7
/* pc_in_call_dummy_on stack may work for us must test this */
int
s390_pc_in_call_dummy (CORE_ADDR pc, CORE_ADDR sp, CORE_ADDR frame_address)
{
  return pc > sp && pc < (sp + 4096);
}

d1356 1
d1363 1
a1363 20

  /* instruction sequence for s390 call dummy is as follows
     bras %r1,.+8      ; 0xA7150004   
     long basraddr     ; 0x00000000
     l    %r1,0(%r1)   ; 0x58101000
     basr %r14,%r1     ; 0x0DE1
     breakpoint        ; 0x0001 */
  static LONGEST s390_call_dummy_words[] = { 0xA7150004, 0x00000000,
    0x58101000, 0x0DE10001
  };
  /* instruction sequence for esame call dummy is as follows
     bras %r1,.+12     ; 0xA7150006   
     long basraddr     ; 0x0000000000000000
     lg   %r1,0(%r1)   ; 0xE31010000004
     basr %r14,%r1     ; 0x0DE1
     breakpoint        ; 0x0001 */
  static LONGEST s390x_call_dummy_words[] = { 0xA715000600000000,
    0x00000000E3101000,
    0x00040DE100010000
  };
a1381 7
  /* We don't define set_gdbarch_call_dummy_breakpoint_offset 
     as we already have a breakpoint inserted. */
  set_gdbarch_use_generic_dummy_frames (gdbarch, 0);

  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
  set_gdbarch_pc_in_call_dummy (gdbarch, s390_pc_in_call_dummy);
a1396 2
  set_gdbarch_push_dummy_frame (gdbarch, s390_push_dummy_frame);
  set_gdbarch_push_arguments (gdbarch, s390_push_arguments);
d1438 1
a1438 3
  /* Stuff below here wouldn't be required if gdbarch.sh was a little */
  /* more intelligent */
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 0);
d1440 10
d1452 1
a1452 1
  set_gdbarch_fix_call_dummy (gdbarch, s390_fix_call_dummy);
d1454 3
a1461 1
      set_gdbarch_call_dummy_length (gdbarch, 16);
a1466 4

      set_gdbarch_sizeof_call_dummy_words (gdbarch,
					   sizeof (s390_call_dummy_words));
      set_gdbarch_call_dummy_words (gdbarch, s390_call_dummy_words);
a1470 1
      set_gdbarch_call_dummy_length (gdbarch, 22);
a1478 3
      set_gdbarch_sizeof_call_dummy_words (gdbarch,
					   sizeof (s390x_call_dummy_words));
      set_gdbarch_call_dummy_words (gdbarch, s390x_call_dummy_words);
@


1.9
log
@* s390-tdep.c (s390_get_frame_info): Initialize got_load_addr and
got_load_len, to placate compiler.
@
text
@d1266 10
a1275 1
      if (!second_pass)
@


1.8
log
@* s390-tdep.c (s390_gdbarch_init): Use func_frame_chain_valid, not
file_frame_chain_valid.
@
text
@d232 1
a232 1
  CORE_ADDR got_load_addr, got_load_len;
@


1.7
log
@* s390-tdep.c (s390_get_frame_info): If the prologue loads r12
from the constant pool, but doesn't add in the constant pool's
address to it, then this function probably isn't using r12 as a
GOT pointer, and that load probably wasn't part of the prologue.
@
text
@d1466 1
a1466 1
  set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
@


1.6
log
@* s390-tdep.c (s390_gdbarch_init): Use the default
prepare_to_proceed function established by config/nm-linux.h;
don't try to set it to linuxthreads_prepare_to_proceed.
@
text
@d212 1
a212 1
  int const_pool_state, save_link_state, got_state;
d219 15
d557 3
a559 1
	      got_state == 1;
d576 14
a589 2
      good_prologue = (((got_state == 0) || (got_state == 2)) &&
		       ((const_pool_state == 0) || (const_pool_state == 2)) &&
@


1.5
log
@s/value_ptr/struct value */
@
text
@a1449 3
#ifdef GDB_NM_FILE
  set_gdbarch_prepare_to_proceed (gdbarch, linuxthreads_prepare_to_proceed);
#endif
@


1.4
log
@From DJ Barrow.
* s390-tdep.c: (s390_gdbarch_init): Don't initialize
find_solib_trampoline_target.
@
text
@d1157 1
a1157 1
s390_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
d1163 1
a1163 1
  value_ptr arg;
@


1.3
log
@Add explicit #include of "value.h".
@
text
@d43 1
a1441 1
  set_gdbarch_skip_trampoline_code (gdbarch, find_solib_trampoline_target);
@


1.2
log
@S/390 31 & 64 bit target and GNU/Linux native support.
Contributed by D.J. Barrow <djbarrow@@de.ibm.com> of IBM.
* s390-nat.c, s390-tdep.c: New file.
* config/s390/nm-linux.h, config/s390/s390.mh: New file.
* config/s390/s390.mt, config/s390/s390x.mt: New file.
* config/s390/tm-linux.h, config/s390/tm-s390.h: New file.
* config/s390/xm-linux.h: New file.
* NEWS: Update.
* MAINTAINERS: Update.
@
text
@d38 1
a38 1

@


1.1
log
@file s390-tdep.c was initially added on branch gdb_s390-2001-09-26-branch.
@
text
@d1 1504
@


1.1.4.1
log
@S/390 31 & 64 bit target and GNU/Linux native support.
Contributed by D.J. Barrow <djbarrow@@de.ibm.com> of IBM.
* s390-nat.c, s390-tdep.c: New file.
* config/s390/nm-linux.h, config/s390/s390.mh: New file.
* config/s390/s390.mt, config/s390/s390x.mt: New file.
* config/s390/tm-linux.h, config/s390/tm-s390.h: New file.
* config/s390/xm-linux.h: New file.
* NEWS: Update.
* MAINTAINERS: Update.
@
text
@a0 1504
/* Target-dependent code for GDB, the GNU debugger.
   Copyright 2001 Free Software Foundation, Inc.
   Contributed by D.J. Barrow (djbarrow@@de.ibm.com,barrow_dj@@yahoo.com)
   for IBM Deutschland Entwicklung GmbH, IBM Corporation.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#define S390_TDEP		/* for special macros in tm-s390.h */
#include <defs.h>
#include "arch-utils.h"
#include "frame.h"
#include "inferior.h"
#include "symtab.h"
#include "target.h"
#include "gdbcore.h"
#include "gdbcmd.h"
#include "symfile.h"
#include "objfiles.h"
#include "tm.h"
#include "../bfd/bfd.h"
#include "floatformat.h"
#include "regcache.h"





/* Number of bytes of storage in the actual machine representation
   for register N. 
   Note that the unsigned cast here forces the result of the
   subtraction to very high positive values if N < S390_FP0_REGNUM */
int
s390_register_raw_size (int reg_nr)
{
  return ((unsigned) reg_nr - S390_FP0_REGNUM) <
    S390_NUM_FPRS ? S390_FPR_SIZE : 4;
}

int
s390x_register_raw_size (int reg_nr)
{
  return (reg_nr == S390_FPC_REGNUM)
    || (reg_nr >= S390_FIRST_ACR && reg_nr <= S390_LAST_ACR) ? 4 : 8;
}

int
s390_cannot_fetch_register (int regno)
{
  return (regno >= S390_FIRST_CR && regno < (S390_FIRST_CR + 9)) ||
    (regno >= (S390_FIRST_CR + 12) && regno <= S390_LAST_CR);
}

int
s390_register_byte (int reg_nr)
{
  if (reg_nr <= S390_GP_LAST_REGNUM)
    return reg_nr * S390_GPR_SIZE;
  if (reg_nr <= S390_LAST_ACR)
    return S390_ACR0_OFFSET + (((reg_nr) - S390_FIRST_ACR) * S390_ACR_SIZE);
  if (reg_nr <= S390_LAST_CR)
    return S390_CR0_OFFSET + (((reg_nr) - S390_FIRST_CR) * S390_CR_SIZE);
  if (reg_nr == S390_FPC_REGNUM)
    return S390_FPC_OFFSET;
  else
    return S390_FP0_OFFSET + (((reg_nr) - S390_FP0_REGNUM) * S390_FPR_SIZE);
}

#ifndef GDBSERVER
#define S390_MAX_INSTR_SIZE (6)
#define S390_SYSCALL_OPCODE (0x0a)
#define S390_SYSCALL_SIZE   (2)
#define S390_SIGCONTEXT_SREGS_OFFSET (8)
#define S390X_SIGCONTEXT_SREGS_OFFSET (8)
#define S390_SIGREGS_FP0_OFFSET       (144)
#define S390X_SIGREGS_FP0_OFFSET      (216)
#define S390_UC_MCONTEXT_OFFSET    (256)
#define S390X_UC_MCONTEXT_OFFSET   (344)
#define S390_STACK_FRAME_OVERHEAD  (GDB_TARGET_IS_ESAME ? 160:96)
#define S390_SIGNAL_FRAMESIZE  (GDB_TARGET_IS_ESAME ? 160:96)
#define s390_NR_sigreturn          119
#define s390_NR_rt_sigreturn       173



struct frame_extra_info
{
  int initialised;
  int good_prologue;
  CORE_ADDR function_start;
  CORE_ADDR skip_prologue_function_start;
  CORE_ADDR saved_pc_valid;
  CORE_ADDR saved_pc;
  CORE_ADDR sig_fixed_saved_pc_valid;
  CORE_ADDR sig_fixed_saved_pc;
  CORE_ADDR frame_pointer_saved_pc;	/* frame pointer needed for alloca */
  CORE_ADDR stack_bought;	/* amount we decrement the stack pointer by */
  CORE_ADDR sigcontext;
};


static CORE_ADDR s390_frame_saved_pc_nofix (struct frame_info *fi);

int
s390_readinstruction (bfd_byte instr[], CORE_ADDR at,
		      struct disassemble_info *info)
{
  int instrlen;

  static int s390_instrlen[] = {
    2,
    4,
    4,
    6
  };
  if ((*info->read_memory_func) (at, &instr[0], 2, info))
    return -1;
  instrlen = s390_instrlen[instr[0] >> 6];
  if ((*info->read_memory_func) (at + 2, &instr[2], instrlen - 2, info))
    return -1;
  return instrlen;
}

static void
s390_memset_extra_info (struct frame_extra_info *fextra_info)
{
  memset (fextra_info, 0, sizeof (struct frame_extra_info));
}



char *
s390_register_name (int reg_nr)
{
  static char *register_names[] = {
    "pswm", "pswa",
    "gpr0", "gpr1", "gpr2", "gpr3", "gpr4", "gpr5", "gpr6", "gpr7",
    "gpr8", "gpr9", "gpr10", "gpr11", "gpr12", "gpr13", "gpr14", "gpr15",
    "acr0", "acr1", "acr2", "acr3", "acr4", "acr5", "acr6", "acr7",
    "acr8", "acr9", "acr10", "acr11", "acr12", "acr13", "acr14", "acr15",
    "cr0", "cr1", "cr2", "cr3", "cr4", "cr5", "cr6", "cr7",
    "cr8", "cr9", "cr10", "cr11", "cr12", "cr13", "cr14", "cr15",
    "fpc",
    "fpr0", "fpr1", "fpr2", "fpr3", "fpr4", "fpr5", "fpr6", "fpr7",
    "fpr8", "fpr9", "fpr10", "fpr11", "fpr12", "fpr13", "fpr14", "fpr15"
  };

  if (reg_nr >= S390_LAST_REGNUM)
    return NULL;
  return register_names[reg_nr];
}




int
s390_stab_reg_to_regnum (int regno)
{
  return regno >= 64 ? S390_PSWM_REGNUM - 64 :
    regno >= 48 ? S390_FIRST_ACR - 48 :
    regno >= 32 ? S390_FIRST_CR - 32 :
    regno <= 15 ? (regno + 2) :
    S390_FP0_REGNUM + ((regno - 16) & 8) + (((regno - 16) & 3) << 1) +
    (((regno - 16) & 4) >> 2);
}



/* s390_get_frame_info based on Hartmuts
   prologue definition in
   gcc-2.8.1/config/l390/linux.c 

   It reads one instruction at a time & based on whether
   it looks like prologue code or not it makes a decision on
   whether the prologue is over, there are various state machines
   in the code to determine if the prologue code is possilby valid.
   
   This is done to hopefully allow the code survive minor revs of
   calling conventions.

 */

int
s390_get_frame_info (CORE_ADDR pc, struct frame_extra_info *fextra_info,
		     struct frame_info *fi, int init_extra_info)
{
#define CONST_POOL_REGIDX 13
#define GOT_REGIDX        12
  bfd_byte instr[S390_MAX_INSTR_SIZE];
  CORE_ADDR test_pc = pc, test_pc2;
  CORE_ADDR orig_sp = 0, save_reg_addr = 0, *saved_regs = NULL;
  int valid_prologue, good_prologue = 0;
  int gprs_saved[S390_NUM_GPRS];
  int fprs_saved[S390_NUM_FPRS];
  int regidx, instrlen;
  int save_link_regidx, subtract_sp_regidx;
  int const_pool_state, save_link_state, got_state;
  int frame_pointer_found, varargs_state;
  int loop_cnt, gdb_gpr_store, gdb_fpr_store;
  int frame_pointer_regidx = 0xf;
  int offset, expected_offset;
  int err = 0;
  disassemble_info info;
  const_pool_state = save_link_state = got_state = varargs_state = 0;
  frame_pointer_found = 0;
  memset (gprs_saved, 0, sizeof (gprs_saved));
  memset (fprs_saved, 0, sizeof (fprs_saved));
  info.read_memory_func = dis_asm_read_memory;

  save_link_regidx = subtract_sp_regidx = 0;
  if (fextra_info)
    {
      if (fi && fi->frame)
	{
	  orig_sp = fi->frame + fextra_info->stack_bought;
	  saved_regs = fi->saved_regs;
	}
      if (init_extra_info || !fextra_info->initialised)
	{
	  s390_memset_extra_info (fextra_info);
	  fextra_info->function_start = pc;
	  fextra_info->initialised = 1;
	}
    }
  instrlen = 0;
  do
    {
      valid_prologue = 0;
      test_pc += instrlen;
      /* add the previous instruction len */
      instrlen = s390_readinstruction (instr, test_pc, &info);
      if (instrlen < 0)
	{
	  good_prologue = 0;
	  err = -1;
	  break;
	}
      /* We probably are in a glibc syscall */
      if (instr[0] == S390_SYSCALL_OPCODE && test_pc == pc)
	{
	  good_prologue = 1;
	  if (saved_regs && fextra_info && fi->next && fi->next->extra_info
	      && fi->next->extra_info->sigcontext)
	    {
	      /* We are backtracing from a signal handler */
	      save_reg_addr = fi->next->extra_info->sigcontext +
		REGISTER_BYTE (S390_GP0_REGNUM);
	      for (regidx = 0; regidx < S390_NUM_GPRS; regidx++)
		{
		  saved_regs[S390_GP0_REGNUM + regidx] = save_reg_addr;
		  save_reg_addr += S390_GPR_SIZE;
		}
	      save_reg_addr = fi->next->extra_info->sigcontext +
		(GDB_TARGET_IS_ESAME ? S390X_SIGREGS_FP0_OFFSET :
		 S390_SIGREGS_FP0_OFFSET);
	      for (regidx = 0; regidx < S390_NUM_FPRS; regidx++)
		{
		  saved_regs[S390_FP0_REGNUM + regidx] = save_reg_addr;
		  save_reg_addr += S390_FPR_SIZE;
		}
	    }
	  break;
	}
      if (save_link_state == 0)
	{
	  /* check for a stack relative STMG or STM */
	  if (((GDB_TARGET_IS_ESAME &&
		((instr[0] == 0xeb) && (instr[5] == 0x24))) ||
	       (instr[0] == 0x90)) && ((instr[2] >> 4) == 0xf))
	    {
	      regidx = (instr[1] >> 4);
	      if (regidx < 6)
		varargs_state = 1;
	      offset = ((instr[2] & 0xf) << 8) + instr[3];
	      expected_offset =
		S390_GPR6_STACK_OFFSET + (S390_GPR_SIZE * (regidx - 6));
	      if (offset != expected_offset)
		{
		  good_prologue = 0;
		  break;
		}
	      if (saved_regs)
		save_reg_addr = orig_sp + offset;
	      for (; regidx <= (instr[1] & 0xf); regidx++)
		{
		  if (gprs_saved[regidx])
		    {
		      good_prologue = 0;
		      break;
		    }
		  good_prologue = 1;
		  gprs_saved[regidx] = 1;
		  if (saved_regs)
		    {
		      saved_regs[S390_GP0_REGNUM + regidx] = save_reg_addr;
		      save_reg_addr += S390_GPR_SIZE;
		    }
		}
	      valid_prologue = 1;
	      continue;
	    }
	}
      /* check for a stack relative STG or ST */
      if ((save_link_state == 0 || save_link_state == 3) &&
	  ((GDB_TARGET_IS_ESAME &&
	    ((instr[0] == 0xe3) && (instr[5] == 0x24))) ||
	   (instr[0] == 0x50)) && ((instr[2] >> 4) == 0xf))
	{
	  regidx = instr[1] >> 4;
	  offset = ((instr[2] & 0xf) << 8) + instr[3];
	  if (offset == 0)
	    {
	      if (save_link_state == 3 && regidx == save_link_regidx)
		{
		  save_link_state = 4;
		  valid_prologue = 1;
		  continue;
		}
	      else
		break;
	    }
	  if (regidx < 6)
	    varargs_state = 1;
	  expected_offset =
	    S390_GPR6_STACK_OFFSET + (S390_GPR_SIZE * (regidx - 6));
	  if (offset != expected_offset)
	    {
	      good_prologue = 0;
	      break;
	    }
	  if (gprs_saved[regidx])
	    {
	      good_prologue = 0;
	      break;
	    }
	  good_prologue = 1;
	  gprs_saved[regidx] = 1;
	  if (saved_regs)
	    {
	      save_reg_addr = orig_sp + offset;
	      saved_regs[S390_GP0_REGNUM + regidx] = save_reg_addr;
	    }
	  valid_prologue = 1;
	  continue;
	}

      /* check for STD */
      if (instr[0] == 0x60 && (instr[2] >> 4) == 0xf)
	{
	  regidx = instr[1] >> 4;
	  if (regidx == 0 || regidx == 2)
	    varargs_state = 1;
	  if (fprs_saved[regidx])
	    {
	      good_prologue = 0;
	      break;
	    }
	  fprs_saved[regidx] = 1;
	  if (saved_regs)
	    {
	      save_reg_addr = orig_sp + (((instr[2] & 0xf) << 8) + instr[3]);
	      saved_regs[S390_FP0_REGNUM + regidx] = save_reg_addr;
	    }
	  valid_prologue = 1;
	  continue;
	}


      if (const_pool_state == 0)
	{

	  if (GDB_TARGET_IS_ESAME)
	    {
	      /* Check for larl CONST_POOL_REGIDX,offset on ESAME */
	      if ((instr[0] == 0xc0)
		  && (instr[1] == (CONST_POOL_REGIDX << 4)))
		{
		  const_pool_state = 2;
		  valid_prologue = 1;
		  continue;
		}
	    }
	  else
	    {
	      /* Check for BASR gpr13,gpr0 used to load constant pool pointer to r13 in old compiler */
	      if (instr[0] == 0xd && (instr[1] & 0xf) == 0
		  && ((instr[1] >> 4) == CONST_POOL_REGIDX))
		{
		  const_pool_state = 1;
		  valid_prologue = 1;
		  continue;
		}
	    }
	  /* Check for new fangled bras %r13,newpc to load new constant pool */
	  /* embedded in code, older pre abi compilers also emitted this stuff.  */
	  if ((instr[0] == 0xa7) && ((instr[1] & 0xf) == 0x5) &&
	      ((instr[1] >> 4) == CONST_POOL_REGIDX)
	      && ((instr[2] & 0x80) == 0))
	    {
	      const_pool_state = 2;
	      test_pc +=
		(((((instr[2] & 0xf) << 8) + instr[3]) << 1) - instrlen);
	      valid_prologue = 1;
	      continue;
	    }
	}
      /* Check for AGHI or AHI CONST_POOL_REGIDX,val */
      if (const_pool_state == 1 && (instr[0] == 0xa7) &&
	  ((GDB_TARGET_IS_ESAME &&
	    (instr[1] == ((CONST_POOL_REGIDX << 4) | 0xb))) ||
	   (instr[1] == ((CONST_POOL_REGIDX << 4) | 0xa))))
	{
	  const_pool_state = 2;
	  valid_prologue = 1;
	  continue;
	}
      /* Check for LGR or LR gprx,15 */
      if ((GDB_TARGET_IS_ESAME &&
	   instr[0] == 0xb9 && instr[1] == 0x04 && (instr[3] & 0xf) == 0xf) ||
	  (instr[0] == 0x18 && (instr[1] & 0xf) == 0xf))
	{
	  if (GDB_TARGET_IS_ESAME)
	    regidx = instr[3] >> 4;
	  else
	    regidx = instr[1] >> 4;
	  if (save_link_state == 0 && regidx != 0xb)
	    {
	      /* Almost defintely code for
	         decrementing the stack pointer 
	         ( i.e. a non leaf function 
	         or else leaf with locals ) */
	      save_link_regidx = regidx;
	      save_link_state = 1;
	      valid_prologue = 1;
	      continue;
	    }
	  /* We use this frame pointer for alloca
	     unfortunately we need to assume its gpr11
	     otherwise we would need a smarter prologue
	     walker. */
	  if (!frame_pointer_found && regidx == 0xb)
	    {
	      frame_pointer_regidx = 0xb;
	      frame_pointer_found = 1;
	      if (fextra_info)
		fextra_info->frame_pointer_saved_pc = test_pc;
	      valid_prologue = 1;
	      continue;
	    }
	}
      /* Check for AHI or AGHI gpr15,val */
      if (save_link_state == 1 && (instr[0] == 0xa7) &&
	  ((GDB_TARGET_IS_ESAME && (instr[1] == 0xfb)) || (instr[1] == 0xfa)))
	{
	  if (fextra_info)
	    fextra_info->stack_bought =
	      -extract_signed_integer (&instr[2], 2);
	  save_link_state = 3;
	  valid_prologue = 1;
	  continue;
	}
      /* Alternatively check for the complex construction for
         buying more than 32k of stack
         BRAS gprx,.+8
         long vals    %r15,0(%gprx)  gprx currently r1 */
      if ((save_link_state == 1) && (instr[0] == 0xa7)
	  && ((instr[1] & 0xf) == 0x5) && (instr[2] == 0)
	  && (instr[3] == 0x4) && ((instr[1] >> 4) != CONST_POOL_REGIDX))
	{
	  subtract_sp_regidx = instr[1] >> 4;
	  save_link_state = 2;
	  if (fextra_info)
	    target_read_memory (test_pc + instrlen,
				(char *) &fextra_info->stack_bought,
				sizeof (fextra_info->stack_bought));
	  test_pc += 4;
	  valid_prologue = 1;
	  continue;
	}
      if (save_link_state == 2 && instr[0] == 0x5b
	  && instr[1] == 0xf0 &&
	  instr[2] == (subtract_sp_regidx << 4) && instr[3] == 0)
	{
	  save_link_state = 3;
	  valid_prologue = 1;
	  continue;
	}
      /* check for LA gprx,offset(15) used for varargs */
      if ((instr[0] == 0x41) && ((instr[2] >> 4) == 0xf) &&
	  ((instr[1] & 0xf) == 0))
	{
	  /* some code uses gpr7 to point to outgoing args */
	  if (((instr[1] >> 4) == 7) && (save_link_state == 0) &&
	      ((instr[2] & 0xf) == 0)
	      && (instr[3] == S390_STACK_FRAME_OVERHEAD))
	    {
	      valid_prologue = 1;
	      continue;
	    }
	  if (varargs_state == 1)
	    {
	      varargs_state = 2;
	      valid_prologue = 1;
	      continue;
	    }
	}
      /* Check for a GOT load */

      if (GDB_TARGET_IS_ESAME)
	{
	  /* Check for larl  GOT_REGIDX, on ESAME */
	  if ((got_state == 0) && (instr[0] == 0xc0)
	      && (instr[1] == (GOT_REGIDX << 4)))
	    {
	      got_state = 2;
	      valid_prologue = 1;
	      continue;
	    }
	}
      else
	{
	  /* check for l GOT_REGIDX,x(CONST_POOL_REGIDX) */
	  if (got_state == 0 && const_pool_state == 2 && instr[0] == 0x58
	      && (instr[2] == (CONST_POOL_REGIDX << 4))
	      && ((instr[1] >> 4) == GOT_REGIDX))
	    {
	      got_state == 1;
	      valid_prologue = 1;
	      continue;
	    }
	  /* Check for subsequent ar got_regidx,basr_regidx */
	  if (got_state == 1 && instr[0] == 0x1a &&
	      instr[1] == ((GOT_REGIDX << 4) | CONST_POOL_REGIDX))
	    {
	      got_state = 2;
	      valid_prologue = 1;
	      continue;
	    }
	}
    }
  while (valid_prologue && good_prologue);
  if (good_prologue)
    {
      good_prologue = (((got_state == 0) || (got_state == 2)) &&
		       ((const_pool_state == 0) || (const_pool_state == 2)) &&
		       ((save_link_state == 0) || (save_link_state == 4)) &&
		       ((varargs_state == 0) || (varargs_state == 2)));
    }
  if (fextra_info)
    {
      fextra_info->good_prologue = good_prologue;
      fextra_info->skip_prologue_function_start =
	(good_prologue ? test_pc : pc);
    }
  return err;
}


int
s390_check_function_end (CORE_ADDR pc)
{
  bfd_byte instr[S390_MAX_INSTR_SIZE];
  disassemble_info info;
  int regidx, instrlen;

  info.read_memory_func = dis_asm_read_memory;
  instrlen = s390_readinstruction (instr, pc, &info);
  if (instrlen < 0)
    return -1;
  /* check for BR */
  if (instrlen != 2 || instr[0] != 07 || (instr[1] >> 4) != 0xf)
    return 0;
  regidx = instr[1] & 0xf;
  /* Check for LMG or LG */
  instrlen =
    s390_readinstruction (instr, pc - (GDB_TARGET_IS_ESAME ? 6 : 4), &info);
  if (instrlen < 0)
    return -1;
  if (GDB_TARGET_IS_ESAME)
    {

      if (instrlen != 6 || instr[0] != 0xeb || instr[5] != 0x4)
	return 0;
    }
  else if (instrlen != 4 || instr[0] != 0x98)
    {
      return 0;
    }
  if ((instr[2] >> 4) != 0xf)
    return 0;
  if (regidx == 14)
    return 1;
  instrlen = s390_readinstruction (instr, pc - (GDB_TARGET_IS_ESAME ? 12 : 8),
				   &info);
  if (instrlen < 0)
    return -1;
  if (GDB_TARGET_IS_ESAME)
    {
      /* Check for LG */
      if (instrlen != 6 || instr[0] != 0xe3 || instr[5] != 0x4)
	return 0;
    }
  else
    {
      /* Check for L */
      if (instrlen != 4 || instr[0] != 0x58)
	return 0;
    }
  if (instr[2] >> 4 != 0xf)
    return 0;
  if (instr[1] >> 4 != regidx)
    return 0;
  return 1;
}

static CORE_ADDR
s390_sniff_pc_function_start (CORE_ADDR pc, struct frame_info *fi)
{
  CORE_ADDR function_start, test_function_start;
  int loop_cnt, err, function_end;
  struct frame_extra_info fextra_info;
  function_start = get_pc_function_start (pc);

  if (function_start == 0)
    {
      test_function_start = pc;
      if (test_function_start & 1)
	return 0;		/* This has to be bogus */
      loop_cnt = 0;
      do
	{

	  err =
	    s390_get_frame_info (test_function_start, &fextra_info, fi, 1);
	  loop_cnt++;
	  test_function_start -= 2;
	  function_end = s390_check_function_end (test_function_start);
	}
      while (!(function_end == 1 || err || loop_cnt >= 4096 ||
	       (fextra_info.good_prologue)));
      if (fextra_info.good_prologue)
	function_start = fextra_info.function_start;
      else if (function_end == 1)
	function_start = test_function_start;
    }
  return function_start;
}



CORE_ADDR
s390_function_start (struct frame_info *fi)
{
  CORE_ADDR function_start = 0;

  if (fi->extra_info && fi->extra_info->initialised)
    function_start = fi->extra_info->function_start;
  else if (fi->pc)
    function_start = get_pc_function_start (fi->pc);
  return function_start;
}




int
s390_frameless_function_invocation (struct frame_info *fi)
{
  struct frame_extra_info fextra_info, *fextra_info_ptr;
  int frameless = 0;

  if (fi->next == NULL)		/* no may be frameless */
    {
      if (fi->extra_info)
	fextra_info_ptr = fi->extra_info;
      else
	{
	  fextra_info_ptr = &fextra_info;
	  s390_get_frame_info (s390_sniff_pc_function_start (fi->pc, fi),
			       fextra_info_ptr, fi, 1);
	}
      frameless = ((fextra_info_ptr->stack_bought == 0));
    }
  return frameless;

}


static int
s390_is_sigreturn (CORE_ADDR pc, struct frame_info *sighandler_fi,
		   CORE_ADDR *sregs, CORE_ADDR *sigcaller_pc)
{
  bfd_byte instr[S390_MAX_INSTR_SIZE];
  disassemble_info info;
  int instrlen;
  CORE_ADDR scontext;
  int retval = 0;
  CORE_ADDR orig_sp;
  CORE_ADDR temp_sregs;

  scontext = temp_sregs = 0;

  info.read_memory_func = dis_asm_read_memory;
  instrlen = s390_readinstruction (instr, pc, &info);
  if (sigcaller_pc)
    *sigcaller_pc = 0;
  if (((instrlen == S390_SYSCALL_SIZE) &&
       (instr[0] == S390_SYSCALL_OPCODE)) &&
      ((instr[1] == s390_NR_sigreturn) || (instr[1] == s390_NR_rt_sigreturn)))
    {
      if (sighandler_fi)
	{
	  if (s390_frameless_function_invocation (sighandler_fi))
	    orig_sp = sighandler_fi->frame;
	  else
	    orig_sp = ADDR_BITS_REMOVE ((CORE_ADDR)
					read_memory_integer (sighandler_fi->
							     frame,
							     S390_GPR_SIZE));
	  if (orig_sp && sigcaller_pc)
	    {
	      scontext = orig_sp + S390_SIGNAL_FRAMESIZE;
	      if (pc == scontext && instr[1] == s390_NR_rt_sigreturn)
		{
		  /* We got a new style rt_signal */
		  /* get address of read ucontext->uc_mcontext */
		  temp_sregs = orig_sp + (GDB_TARGET_IS_ESAME ?
					  S390X_UC_MCONTEXT_OFFSET :
					  S390_UC_MCONTEXT_OFFSET);
		}
	      else
		{
		  /* read sigcontext->sregs */
		  temp_sregs = ADDR_BITS_REMOVE ((CORE_ADDR)
						 read_memory_integer (scontext
								      +
								      (GDB_TARGET_IS_ESAME
								       ?
								       S390X_SIGCONTEXT_SREGS_OFFSET
								       :
								       S390_SIGCONTEXT_SREGS_OFFSET),
								      S390_GPR_SIZE));

		}
	      /* read sigregs->psw.addr */
	      *sigcaller_pc =
		ADDR_BITS_REMOVE ((CORE_ADDR)
				  read_memory_integer (temp_sregs +
						       REGISTER_BYTE
						       (S390_PC_REGNUM),
						       S390_PSW_ADDR_SIZE));
	    }
	}
      retval = 1;
    }
  if (sregs)
    *sregs = temp_sregs;
  return retval;
}

/*
  We need to do something better here but this will keep us out of trouble
  for the moment.
  For some reason the blockframe.c calls us with fi->next->fromleaf
  so this seems of little use to us. */
void
s390_init_frame_pc_first (int next_fromleaf, struct frame_info *fi)
{
  CORE_ADDR sigcaller_pc;

  fi->pc = 0;
  if (next_fromleaf)
    {
      fi->pc = ADDR_BITS_REMOVE (read_register (S390_RETADDR_REGNUM));
      /* fix signal handlers */
    }
  else if (fi->next && fi->next->pc)
    fi->pc = s390_frame_saved_pc_nofix (fi->next);
  if (fi->pc && fi->next && fi->next->frame &&
      s390_is_sigreturn (fi->pc, fi->next, NULL, &sigcaller_pc))
    {
      fi->pc = sigcaller_pc;
    }

}

void
s390_init_extra_frame_info (int fromleaf, struct frame_info *fi)
{
  fi->extra_info = frame_obstack_alloc (sizeof (struct frame_extra_info));
  if (fi->pc)
    s390_get_frame_info (s390_sniff_pc_function_start (fi->pc, fi),
			 fi->extra_info, fi, 1);
  else
    s390_memset_extra_info (fi->extra_info);
}

/* If saved registers of frame FI are not known yet, read and cache them.
   &FEXTRA_INFOP contains struct frame_extra_info; TDATAP can be NULL,
   in which case the framedata are read.  */

void
s390_frame_init_saved_regs (struct frame_info *fi)
{

  int quick;

  if (fi->saved_regs == NULL)
    {
      /* zalloc memsets the saved regs */
      frame_saved_regs_zalloc (fi);
      if (fi->pc)
	{
	  quick = (fi->extra_info && fi->extra_info->initialised
		   && fi->extra_info->good_prologue);
	  s390_get_frame_info (quick ? fi->extra_info->function_start :
			       s390_sniff_pc_function_start (fi->pc, fi),
			       fi->extra_info, fi, !quick);
	}
    }
}



CORE_ADDR
s390_frame_args_address (struct frame_info *fi)
{

  /* Apparently gdb already knows gdb_args_offset itself */
  return fi->frame;
}


static CORE_ADDR
s390_frame_saved_pc_nofix (struct frame_info *fi)
{
  if (fi->extra_info && fi->extra_info->saved_pc_valid)
    return fi->extra_info->saved_pc;
  s390_frame_init_saved_regs (fi);
  if (fi->extra_info)
    {
      fi->extra_info->saved_pc_valid = 1;
      if (fi->extra_info->good_prologue)
	{
	  if (fi->saved_regs[S390_RETADDR_REGNUM])
	    {
	      return (fi->extra_info->saved_pc =
		      ADDR_BITS_REMOVE (read_memory_integer
					(fi->saved_regs[S390_RETADDR_REGNUM],
					 S390_GPR_SIZE)));
	    }
	}
    }
  return 0;
}

CORE_ADDR
s390_frame_saved_pc (struct frame_info *fi)
{
  CORE_ADDR saved_pc = 0, sig_pc;

  if (fi->extra_info && fi->extra_info->sig_fixed_saved_pc_valid)
    return fi->extra_info->sig_fixed_saved_pc;
  saved_pc = s390_frame_saved_pc_nofix (fi);

  if (fi->extra_info)
    {
      fi->extra_info->sig_fixed_saved_pc_valid = 1;
      if (saved_pc)
	{
	  if (s390_is_sigreturn (saved_pc, fi, NULL, &sig_pc))
	    saved_pc = sig_pc;
	}
      fi->extra_info->sig_fixed_saved_pc = saved_pc;
    }
  return saved_pc;
}




/* We want backtraces out of signal handlers so we don't
   set thisframe->signal_handler_caller to 1 */

CORE_ADDR
s390_frame_chain (struct frame_info *thisframe)
{
  CORE_ADDR prev_fp = 0;

  if (thisframe->prev && thisframe->prev->frame)
    prev_fp = thisframe->prev->frame;
  else
    {
      int sigreturn = 0;
      CORE_ADDR sregs = 0;
      struct frame_extra_info prev_fextra_info;

      memset (&prev_fextra_info, 0, sizeof (prev_fextra_info));
      if (thisframe->pc)
	{
	  CORE_ADDR saved_pc, sig_pc;

	  saved_pc = s390_frame_saved_pc_nofix (thisframe);
	  if (saved_pc)
	    {
	      if ((sigreturn =
		   s390_is_sigreturn (saved_pc, thisframe, &sregs, &sig_pc)))
		saved_pc = sig_pc;
	      s390_get_frame_info (s390_sniff_pc_function_start
				   (saved_pc, NULL), &prev_fextra_info, NULL,
				   1);
	    }
	}
      if (sigreturn)
	{
	  /* read sigregs,regs.gprs[11 or 15] */
	  prev_fp = read_memory_integer (sregs +
					 REGISTER_BYTE (S390_GP0_REGNUM +
							(prev_fextra_info.
							 frame_pointer_saved_pc
							 ? 11 : 15)),
					 S390_GPR_SIZE);
	  thisframe->extra_info->sigcontext = sregs;
	}
      else
	{
	  if (thisframe->saved_regs)
	    {

	      int regno;

	      regno =
		((prev_fextra_info.frame_pointer_saved_pc
		  && thisframe->
		  saved_regs[S390_FRAME_REGNUM]) ? S390_FRAME_REGNUM :
		 S390_SP_REGNUM);
	      if (thisframe->saved_regs[regno])
		prev_fp =
		  read_memory_integer (thisframe->saved_regs[regno],
				       S390_GPR_SIZE);
	    }
	}
    }
  return ADDR_BITS_REMOVE (prev_fp);
}

/*
  Whether struct frame_extra_info is actually needed I'll have to figure
  out as our frames are similar to rs6000 there is a possibility
  i386 dosen't need it. */



/* a given return value in `regbuf' with a type `valtype', extract and copy its
   value into `valbuf' */
void
s390_extract_return_value (struct type *valtype, char *regbuf, char *valbuf)
{
  /* floats and doubles are returned in fpr0. fpr's have a size of 8 bytes.
     We need to truncate the return value into float size (4 byte) if
     necessary. */
  int len = TYPE_LENGTH (valtype);

  if (TYPE_CODE (valtype) == TYPE_CODE_FLT)
    {
      if (len > (TARGET_FLOAT_BIT >> 3))
	memcpy (valbuf, &regbuf[REGISTER_BYTE (S390_FP0_REGNUM)], len);
      else
	{
	  /* float */
	  DOUBLEST val;

	  floatformat_to_doublest (&floatformat_ieee_double_big,
				   &regbuf[REGISTER_BYTE (S390_FP0_REGNUM)],
				   &val);
	  store_floating (valbuf, len, val);
	}
    }
  else
    {
      int offset = 0;
      /* return value is copied starting from r2. */
      if (TYPE_LENGTH (valtype) < S390_GPR_SIZE)
	offset = S390_GPR_SIZE - TYPE_LENGTH (valtype);
      memcpy (valbuf,
	      regbuf + REGISTER_BYTE (S390_GP0_REGNUM + 2) + offset,
	      TYPE_LENGTH (valtype));
    }
}


static char *
s390_promote_integer_argument (struct type *valtype, char *valbuf,
			       char *reg_buff, int *arglen)
{
  char *value = valbuf;
  int len = TYPE_LENGTH (valtype);

  if (len < S390_GPR_SIZE)
    {
      /* We need to upgrade this value to a register to pass it correctly */
      int idx, diff = S390_GPR_SIZE - len, negative =
	(!TYPE_UNSIGNED (valtype) && value[0] & 0x80);
      for (idx = 0; idx < S390_GPR_SIZE; idx++)
	{
	  reg_buff[idx] = (idx < diff ? (negative ? 0xff : 0x0) :
			   value[idx - diff]);
	}
      value = reg_buff;
      *arglen = S390_GPR_SIZE;
    }
  else
    {
      if (len & (S390_GPR_SIZE - 1))
	{
	  fprintf_unfiltered (gdb_stderr,
			      "s390_promote_integer_argument detected an argument not "
			      "a multiple of S390_GPR_SIZE & greater than S390_GPR_SIZE "
			      "we might not deal with this correctly.\n");
	}
      *arglen = len;
    }

  return (value);
}

void
s390_store_return_value (struct type *valtype, char *valbuf)
{
  int arglen;
  char *reg_buff = alloca (max (S390_FPR_SIZE, REGISTER_SIZE)), *value;

  if (TYPE_CODE (valtype) == TYPE_CODE_FLT)
    {
      DOUBLEST tempfloat = extract_floating (valbuf, TYPE_LENGTH (valtype));

      floatformat_from_doublest (&floatformat_ieee_double_big, &tempfloat,
				 reg_buff);
      write_register_bytes (REGISTER_BYTE (S390_FP0_REGNUM), reg_buff,
			    S390_FPR_SIZE);
    }
  else
    {
      value =
	s390_promote_integer_argument (valtype, valbuf, reg_buff, &arglen);
      /* Everything else is returned in GPR2 and up. */
      write_register_bytes (REGISTER_BYTE (S390_GP0_REGNUM + 2), value,
			    arglen);
    }
}
static int
gdb_print_insn_s390 (bfd_vma memaddr, disassemble_info * info)
{
  bfd_byte instrbuff[S390_MAX_INSTR_SIZE];
  int instrlen, cnt;

  instrlen = s390_readinstruction (instrbuff, (CORE_ADDR) memaddr, info);
  if (instrlen < 0)
    {
      (*info->memory_error_func) (instrlen, memaddr, info);
      return -1;
    }
  for (cnt = 0; cnt < instrlen; cnt++)
    info->fprintf_func (info->stream, "%02X ", instrbuff[cnt]);
  for (cnt = instrlen; cnt < S390_MAX_INSTR_SIZE; cnt++)
    info->fprintf_func (info->stream, "   ");
  instrlen = print_insn_s390 (memaddr, info);
  return instrlen;
}



/* Not the most efficent code in the world */
int
s390_fp_regnum ()
{
  int regno = S390_SP_REGNUM;
  struct frame_extra_info fextra_info;

  CORE_ADDR pc = ADDR_BITS_REMOVE (read_register (S390_PC_REGNUM));

  s390_get_frame_info (s390_sniff_pc_function_start (pc, NULL), &fextra_info,
		       NULL, 1);
  if (fextra_info.frame_pointer_saved_pc)
    regno = S390_FRAME_REGNUM;
  return regno;
}

CORE_ADDR
s390_read_fp ()
{
  return read_register (s390_fp_regnum ());
}


void
s390_write_fp (CORE_ADDR val)
{
  write_register (s390_fp_regnum (), val);
}


void
s390_push_dummy_frame ()
{
  CORE_ADDR orig_sp = read_register (S390_SP_REGNUM), new_sp;
  void *saved_regs = alloca (REGISTER_BYTES);

  new_sp = (orig_sp - (REGISTER_BYTES + S390_GPR_SIZE));
  read_register_bytes (0, (char *) saved_regs, REGISTER_BYTES);
  /* Use saved copy instead of orig_sp as this will have the correct endianness */
  write_memory (new_sp, (char *) saved_regs + REGISTER_BYTE (S390_SP_REGNUM),
		S390_GPR_SIZE);
  write_memory (new_sp + S390_GPR_SIZE, (char *) &saved_regs, REGISTER_BYTES);
  write_register (S390_SP_REGNUM, new_sp);
}

/* pop the innermost frame, go back to the caller.
    Used in `call_function_by_hand' to remove an artificial stack
     frame.  */
void
s390_pop_frame ()
{
  CORE_ADDR new_sp = read_register (S390_SP_REGNUM), orig_sp;
  void *saved_regs = alloca (REGISTER_BYTES);


  read_memory (new_sp + S390_GPR_SIZE, (char *) saved_regs, REGISTER_BYTES);
  write_register_bytes (0, (char *) &saved_regs, REGISTER_BYTES);
}

/* used by call function by hand
  struct_return indicates that this function returns a structure &
  therefore gpr2 stores a pointer to the structure to be returned as
  opposed to the first argument.
  Currently I haven't seen a TYPE_CODE_INT whose size wasn't 2^n or less
  than S390_GPR_SIZE this is good because I don't seem to have to worry
  about sign extending pushed arguments (i.e. a signed char currently
  comes into this code with a size of 4 ). */

CORE_ADDR
s390_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
		     int struct_return, CORE_ADDR struct_addr)
{
  int num_float_args, num_gpr_args, orig_num_gpr_args, argno;
  int second_pass, len, arglen, gprs_required;
  CORE_ADDR outgoing_args_ptr, outgoing_args_space;
  value_ptr arg;
  struct type *type;
  int max_num_gpr_args = 5 - (struct_return ? 1 : 0);
  int arg0_regnum = S390_GP0_REGNUM + 2 + (struct_return ? 1 : 0);
  char *reg_buff = alloca (max (S390_FPR_SIZE, REGISTER_SIZE)), *value;

  for (second_pass = 0; second_pass <= 1; second_pass++)
    {
      if (second_pass)
	outgoing_args_ptr = sp + S390_STACK_FRAME_OVERHEAD;
      else
	outgoing_args_ptr = 0;
      num_float_args = 0;
      num_gpr_args = 0;
      for (argno = 0; argno < nargs; argno++)
	{
	  arg = args[argno];
	  type = check_typedef (VALUE_TYPE (arg));
	  len = TYPE_LENGTH (type);
	  if (TYPE_CODE (type) == TYPE_CODE_FLT)
	    {
	      int all_float_registers_used =
		num_float_args > (GDB_TARGET_IS_ESAME ? 3 : 1);

	      if (second_pass)
		{
		  DOUBLEST tempfloat =
		    extract_floating (VALUE_CONTENTS (arg), len);


		  floatformat_from_doublest (all_float_registers_used &&
					     len == (TARGET_FLOAT_BIT >> 3)
					     ? &floatformat_ieee_single_big
					     : &floatformat_ieee_double_big,
					     &tempfloat, reg_buff);
		  if (all_float_registers_used)
		    write_memory (outgoing_args_ptr, reg_buff, len);
		  else
		    write_register_bytes (REGISTER_BYTE ((S390_FP0_REGNUM)
							 +
							 (2 *
							  num_float_args)),
					  reg_buff, S390_FPR_SIZE);
		}
	      if (all_float_registers_used)
		outgoing_args_ptr += len;
	      num_float_args++;
	    }
	  else
	    {
	      gprs_required = ((len + (S390_GPR_SIZE - 1)) / S390_GPR_SIZE);

	      value =
		s390_promote_integer_argument (type, VALUE_CONTENTS (arg),
					       reg_buff, &arglen);

	      orig_num_gpr_args = num_gpr_args;
	      num_gpr_args += gprs_required;
	      if (num_gpr_args > max_num_gpr_args)
		{
		  if (second_pass)
		    write_memory (outgoing_args_ptr, value, arglen);
		  outgoing_args_ptr += arglen;
		}
	      else
		{
		  if (second_pass)
		    write_register_bytes (REGISTER_BYTE (arg0_regnum)
					  +
					  (orig_num_gpr_args * S390_GPR_SIZE),
					  value, arglen);
		}
	    }
	}
      if (!second_pass)
	{
	  outgoing_args_space = outgoing_args_ptr;
	  /* Align to 16 bytes because because I like alignment & 
	     some of the kernel code requires 8 byte stack alignment at least. */
	  sp = (sp - (S390_STACK_FRAME_OVERHEAD + outgoing_args_ptr)) & (-16);
	}

    }
  return sp;

}

void
s390_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs,
		     struct value **args, struct type *value_type,
		     int using_gcc)
{
  store_unsigned_integer (dummy + 4, REGISTER_SIZE, fun);
}


/* Return the GDB type object for the "standard" data type
   of data in register N.  */
struct type *
s390_register_virtual_type (int regno)
{
  return ((unsigned) regno - S390_FPC_REGNUM) <
    S390_NUM_FPRS ? builtin_type_double : builtin_type_int;
}


struct type *
s390x_register_virtual_type (int regno)
{
  return (regno == S390_FPC_REGNUM) ||
    (regno >= S390_FIRST_ACR && regno <= S390_LAST_ACR) ? builtin_type_int :
    (regno >= S390_FP0_REGNUM) ? builtin_type_double : builtin_type_long;
}



void
s390_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  write_register (S390_GP0_REGNUM + 2, addr);
}



static unsigned char *
s390_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
{
  static unsigned char breakpoint[] = { 0x0, 0x1 };

  *lenptr = sizeof (breakpoint);
  return breakpoint;
}

/* Advance PC across any function entry prologue instructions to reach some
   "real" code.  */
CORE_ADDR
s390_skip_prologue (CORE_ADDR pc)
{
  struct frame_extra_info fextra_info;

  s390_get_frame_info (pc, &fextra_info, NULL, 1);
  return fextra_info.skip_prologue_function_start;
}

/* pc_in_call_dummy_on stack may work for us must test this */
int
s390_pc_in_call_dummy (CORE_ADDR pc, CORE_ADDR sp, CORE_ADDR frame_address)
{
  return pc > sp && pc < (sp + 4096);
}

/* Immediately after a function call, return the saved pc.
   Can't go through the frames for this because on some machines
   the new frame is not set up until the new function executes
   some instructions.  */
CORE_ADDR
s390_saved_pc_after_call (struct frame_info *frame)
{
  return ADDR_BITS_REMOVE (read_register (S390_RETADDR_REGNUM));
}

static CORE_ADDR
s390_addr_bits_remove (CORE_ADDR addr)
{
  return (addr) & 0x7fffffff;
}


static CORE_ADDR
s390_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
{
  return sp;
}

struct gdbarch *
s390_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{

  /* instruction sequence for s390 call dummy is as follows
     bras %r1,.+8      ; 0xA7150004   
     long basraddr     ; 0x00000000
     l    %r1,0(%r1)   ; 0x58101000
     basr %r14,%r1     ; 0x0DE1
     breakpoint        ; 0x0001 */
  static LONGEST s390_call_dummy_words[] = { 0xA7150004, 0x00000000,
    0x58101000, 0x0DE10001
  };
  /* instruction sequence for esame call dummy is as follows
     bras %r1,.+12     ; 0xA7150006   
     long basraddr     ; 0x0000000000000000
     lg   %r1,0(%r1)   ; 0xE31010000004
     basr %r14,%r1     ; 0x0DE1
     breakpoint        ; 0x0001 */
  static LONGEST s390x_call_dummy_words[] = { 0xA715000600000000,
    0x00000000E3101000,
    0x00040DE100010000
  };
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;
  int elf_flags;

  /* First see if there is already a gdbarch that can satisfy the request.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* None found: is the request for a s390 architecture? */
  if (info.bfd_arch_info->arch != bfd_arch_s390)
    return NULL;		/* No; then it's not for us.  */

  /* Yes: create a new gdbarch for the specified machine type.  */
  gdbarch = gdbarch_alloc (&info, NULL);

  set_gdbarch_believe_pcc_promotion (gdbarch, 0);

  /* We don't define set_gdbarch_call_dummy_breakpoint_offset 
     as we already have a breakpoint inserted. */
  set_gdbarch_use_generic_dummy_frames (gdbarch, 0);

  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
  set_gdbarch_pc_in_call_dummy (gdbarch, s390_pc_in_call_dummy);
  set_gdbarch_frame_args_skip (gdbarch, 0);
  set_gdbarch_frame_args_address (gdbarch, s390_frame_args_address);
  set_gdbarch_frame_chain (gdbarch, s390_frame_chain);
  set_gdbarch_frame_init_saved_regs (gdbarch, s390_frame_init_saved_regs);
  set_gdbarch_frame_locals_address (gdbarch, s390_frame_args_address);
  /* We can't do this */
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
  set_gdbarch_store_struct_return (gdbarch, s390_store_struct_return);
  set_gdbarch_extract_return_value (gdbarch, s390_extract_return_value);
  set_gdbarch_store_return_value (gdbarch, s390_store_return_value);
  /* Amount PC must be decremented by after a breakpoint.
     This is often the number of bytes in BREAKPOINT
     but not always.  */
  set_gdbarch_decr_pc_after_break (gdbarch, 2);
  set_gdbarch_pop_frame (gdbarch, s390_pop_frame);
  set_gdbarch_push_dummy_frame (gdbarch, s390_push_dummy_frame);
  set_gdbarch_push_arguments (gdbarch, s390_push_arguments);
  set_gdbarch_ieee_float (gdbarch, 1);
  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  /* Offset from address of function to start of its code.
     Zero on most machines.  */
  set_gdbarch_function_start_offset (gdbarch, 0);
  set_gdbarch_max_register_raw_size (gdbarch, 8);
  set_gdbarch_max_register_virtual_size (gdbarch, 8);
  set_gdbarch_breakpoint_from_pc (gdbarch, s390_breakpoint_from_pc);
  set_gdbarch_skip_prologue (gdbarch, s390_skip_prologue);
  set_gdbarch_init_extra_frame_info (gdbarch, s390_init_extra_frame_info);
  set_gdbarch_init_frame_pc_first (gdbarch, s390_init_frame_pc_first);
  set_gdbarch_read_fp (gdbarch, s390_read_fp);
  set_gdbarch_write_fp (gdbarch, s390_write_fp);
  /* This function that tells us whether the function invocation represented
     by FI does not have a frame on the stack associated with it.  If it
     does not, FRAMELESS is set to 1, else 0.  */
  set_gdbarch_frameless_function_invocation (gdbarch,
					     s390_frameless_function_invocation);
  /* Return saved PC from a frame */
  set_gdbarch_frame_saved_pc (gdbarch, s390_frame_saved_pc);
  /* FRAME_CHAIN takes a frame's nominal address
     and produces the frame's chain-pointer. */
  set_gdbarch_frame_chain (gdbarch, s390_frame_chain);
  set_gdbarch_saved_pc_after_call (gdbarch, s390_saved_pc_after_call);
  set_gdbarch_register_byte (gdbarch, s390_register_byte);
  set_gdbarch_pc_regnum (gdbarch, S390_PC_REGNUM);
  set_gdbarch_sp_regnum (gdbarch, S390_SP_REGNUM);
  set_gdbarch_fp_regnum (gdbarch, S390_FP_REGNUM);
  set_gdbarch_fp0_regnum (gdbarch, S390_FP0_REGNUM);
  set_gdbarch_num_regs (gdbarch, S390_NUM_REGS);
  set_gdbarch_cannot_fetch_register (gdbarch, s390_cannot_fetch_register);
  set_gdbarch_cannot_store_register (gdbarch, s390_cannot_fetch_register);
  set_gdbarch_get_saved_register (gdbarch, generic_get_saved_register);
  set_gdbarch_use_struct_convention (gdbarch, generic_use_struct_convention);
  set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
  set_gdbarch_register_name (gdbarch, s390_register_name);
  set_gdbarch_stab_reg_to_regnum (gdbarch, s390_stab_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, s390_stab_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, s390_stab_reg_to_regnum);
  set_gdbarch_skip_trampoline_code (gdbarch, find_solib_trampoline_target);

  /* Stuff below here wouldn't be required if gdbarch.sh was a little */
  /* more intelligent */
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 0);
  set_gdbarch_call_dummy_p (gdbarch, 1);
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
  set_gdbarch_extract_struct_value_address (gdbarch, 0);
  set_gdbarch_fix_call_dummy (gdbarch, s390_fix_call_dummy);
#ifdef GDB_NM_FILE
  set_gdbarch_prepare_to_proceed (gdbarch, linuxthreads_prepare_to_proceed);
#endif
  set_gdbarch_push_return_address (gdbarch, s390_push_return_address);

  switch (info.bfd_arch_info->mach)
    {
    case bfd_mach_s390_esa:
      set_gdbarch_register_size (gdbarch, 4);
      set_gdbarch_call_dummy_length (gdbarch, 16);
      set_gdbarch_register_raw_size (gdbarch, s390_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, s390_register_raw_size);
      set_gdbarch_register_virtual_type (gdbarch, s390_register_virtual_type);

      set_gdbarch_addr_bits_remove (gdbarch, s390_addr_bits_remove);

      set_gdbarch_sizeof_call_dummy_words (gdbarch,
					   sizeof (s390_call_dummy_words));
      set_gdbarch_call_dummy_words (gdbarch, s390_call_dummy_words);
      set_gdbarch_register_bytes (gdbarch, S390_REGISTER_BYTES);
      break;
    case bfd_mach_s390_esame:
      set_gdbarch_register_size (gdbarch, 8);
      set_gdbarch_call_dummy_length (gdbarch, 22);
      set_gdbarch_register_raw_size (gdbarch, s390x_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, s390x_register_raw_size);
      set_gdbarch_register_virtual_type (gdbarch,
					 s390x_register_virtual_type);

      set_gdbarch_long_bit (gdbarch, 64);
      set_gdbarch_long_long_bit (gdbarch, 64);
      set_gdbarch_ptr_bit (gdbarch, 64);
      set_gdbarch_sizeof_call_dummy_words (gdbarch,
					   sizeof (s390x_call_dummy_words));
      set_gdbarch_call_dummy_words (gdbarch, s390x_call_dummy_words);
      set_gdbarch_register_bytes (gdbarch, S390X_REGISTER_BYTES);
      break;
    }

  return gdbarch;
}



void
_initialize_s390_tdep ()
{

  /* Hook us into the gdbarch mechanism.  */
  register_gdbarch_init (bfd_arch_s390, s390_gdbarch_init);
  if (!tm_print_insn)		/* Someone may have already set it */
    tm_print_insn = gdb_print_insn_s390;
}

#endif /* GDBSERVER */
@


1.1.4.2
log
@include "value.h"
@
text
@a37 1
#include "value.h"
@


1.1.4.3
log
@Don't initialize solib-trampoline target.
@
text
@d1442 1
@


1.1.2.1
log
@http://www10.software.ibm.com/developerworks/opensource/linux390/exp_src.html
Patch:    gdb-5.1pre-050901-s390.tar.gz (09/11/2001)
MD5: 886251f3719a754dd65a69df462ceac1
@
text
@a0 1504
/* Target-dependent code for GDB, the GNU debugger.
   Copyright 1999 Free Software Foundation, Inc.
   Contributed by D.J. Barrow (djbarrow@@de.ibm.com,barrow_dj@@yahoo.com)
   for IBM Deutschland Entwicklung GmbH, IBM Corporation.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */

#define S390_TDEP		/* for special macros in tm-s390.h */
#include <defs.h>
#include "arch-utils.h"
#include "frame.h"
#include "inferior.h"
#include "symtab.h"
#include "target.h"
#include "gdbcore.h"
#include "gdbcmd.h"
#include "symfile.h"
#include "objfiles.h"
#include "tm.h"
#include "../bfd/bfd.h"
#include "floatformat.h"
#include "regcache.h"





/* Number of bytes of storage in the actual machine representation
   for register N. 
   Note that the unsigned cast here forces the result of the
   subtraction to very high positive values if N < S390_FP0_REGNUM */
int
s390_register_raw_size (int reg_nr)
{
  return ((unsigned) reg_nr - S390_FP0_REGNUM) <
    S390_NUM_FPRS ? S390_FPR_SIZE : 4;
}

int
s390x_register_raw_size (int reg_nr)
{
  return (reg_nr == S390_FPC_REGNUM)
    || (reg_nr >= S390_FIRST_ACR && reg_nr <= S390_LAST_ACR) ? 4 : 8;
}

int
s390_cannot_fetch_register (int regno)
{
  return (regno >= S390_FIRST_CR && regno < (S390_FIRST_CR + 9)) ||
    (regno >= (S390_FIRST_CR + 12) && regno <= S390_LAST_CR);
}

int
s390_register_byte (int reg_nr)
{
  if (reg_nr <= S390_GP_LAST_REGNUM)
    return reg_nr * S390_GPR_SIZE;
  if (reg_nr <= S390_LAST_ACR)
    return S390_ACR0_OFFSET + (((reg_nr) - S390_FIRST_ACR) * S390_ACR_SIZE);
  if (reg_nr <= S390_LAST_CR)
    return S390_CR0_OFFSET + (((reg_nr) - S390_FIRST_CR) * S390_CR_SIZE);
  if (reg_nr == S390_FPC_REGNUM)
    return S390_FPC_OFFSET;
  else
    return S390_FP0_OFFSET + (((reg_nr) - S390_FP0_REGNUM) * S390_FPR_SIZE);
}

#ifndef GDBSERVER
#define S390_MAX_INSTR_SIZE (6)
#define S390_SYSCALL_OPCODE (0x0a)
#define S390_SYSCALL_SIZE   (2)
#define S390_SIGCONTEXT_SREGS_OFFSET (8)
#define S390X_SIGCONTEXT_SREGS_OFFSET (8)
#define S390_SIGREGS_FP0_OFFSET       (144)
#define S390X_SIGREGS_FP0_OFFSET      (216)
#define S390_UC_MCONTEXT_OFFSET    (256)
#define S390X_UC_MCONTEXT_OFFSET   (344)
#define S390_STACK_FRAME_OVERHEAD  (GDB_TARGET_IS_ESAME ? 160:96)
#define S390_SIGNAL_FRAMESIZE  (GDB_TARGET_IS_ESAME ? 160:96)
#define s390_NR_sigreturn          119
#define s390_NR_rt_sigreturn       173



struct frame_extra_info
{
  int initialised;
  int good_prologue;
  CORE_ADDR function_start;
  CORE_ADDR skip_prologue_function_start;
  CORE_ADDR saved_pc_valid;
  CORE_ADDR saved_pc;
  CORE_ADDR sig_fixed_saved_pc_valid;
  CORE_ADDR sig_fixed_saved_pc;
  CORE_ADDR frame_pointer_saved_pc;	/* frame pointer needed for alloca */
  CORE_ADDR stack_bought;	/* amount we decrement the stack pointer by */
  CORE_ADDR sigcontext;
};


static CORE_ADDR s390_frame_saved_pc_nofix (struct frame_info *fi);

int
s390_readinstruction (bfd_byte instr[], CORE_ADDR at,
		      struct disassemble_info *info)
{
  int instrlen;

  static int s390_instrlen[] = {
    2,
    4,
    4,
    6
  };
  if ((*info->read_memory_func) (at, &instr[0], 2, info))
    return -1;
  instrlen = s390_instrlen[instr[0] >> 6];
  if ((*info->read_memory_func) (at + 2, &instr[2], instrlen - 2, info))
    return -1;
  return instrlen;
}

static void
s390_memset_extra_info (struct frame_extra_info *fextra_info)
{
  memset (fextra_info, 0, sizeof (struct frame_extra_info));
}



char *
s390_register_name (int reg_nr)
{
  static char *register_names[] = {
    "pswm", "pswa",
    "gpr0", "gpr1", "gpr2", "gpr3", "gpr4", "gpr5", "gpr6", "gpr7",
    "gpr8", "gpr9", "gpr10", "gpr11", "gpr12", "gpr13", "gpr14", "gpr15",
    "acr0", "acr1", "acr2", "acr3", "acr4", "acr5", "acr6", "acr7",
    "acr8", "acr9", "acr10", "acr11", "acr12", "acr13", "acr14", "acr15",
    "cr0", "cr1", "cr2", "cr3", "cr4", "cr5", "cr6", "cr7",
    "cr8", "cr9", "cr10", "cr11", "cr12", "cr13", "cr14", "cr15",
    "fpc",
    "fpr0", "fpr1", "fpr2", "fpr3", "fpr4", "fpr5", "fpr6", "fpr7",
    "fpr8", "fpr9", "fpr10", "fpr11", "fpr12", "fpr13", "fpr14", "fpr15"
  };

  if (reg_nr >= S390_LAST_REGNUM)
    return NULL;
  return register_names[reg_nr];
}




int
s390_stab_reg_to_regnum (int regno)
{
  return regno >= 64 ? S390_PSWM_REGNUM - 64 :
    regno >= 48 ? S390_FIRST_ACR - 48 :
    regno >= 32 ? S390_FIRST_CR - 32 :
    regno <= 15 ? (regno + 2) :
    S390_FP0_REGNUM + ((regno - 16) & 8) + (((regno - 16) & 3) << 1) +
    (((regno - 16) & 4) >> 2);
}



/* s390_get_frame_info based on Hartmuts
   prologue definition in
   gcc-2.8.1/config/l390/linux.c 

   It reads one instruction at a time & based on whether
   it looks like prologue code or not it makes a decision on
   whether the prologue is over, there are various state machines
   in the code to determine if the prologue code is possilby valid.
   
   This is done to hopefully allow the code survive minor revs of
   calling conventions.

 */

int
s390_get_frame_info (CORE_ADDR pc, struct frame_extra_info *fextra_info,
		     struct frame_info *fi, int init_extra_info)
{
#define CONST_POOL_REGIDX 13
#define GOT_REGIDX        12
  bfd_byte instr[S390_MAX_INSTR_SIZE];
  CORE_ADDR test_pc = pc, test_pc2;
  CORE_ADDR orig_sp = 0, save_reg_addr = 0, *saved_regs = NULL;
  int valid_prologue, good_prologue = 0;
  int gprs_saved[S390_NUM_GPRS];
  int fprs_saved[S390_NUM_FPRS];
  int regidx, instrlen;
  int save_link_regidx, subtract_sp_regidx;
  int const_pool_state, save_link_state, got_state;
  int frame_pointer_found, varargs_state;
  int loop_cnt, gdb_gpr_store, gdb_fpr_store;
  int frame_pointer_regidx = 0xf;
  int offset, expected_offset;
  int err = 0;
  disassemble_info info;
  const_pool_state = save_link_state = got_state = varargs_state = 0;
  frame_pointer_found = 0;
  memset (gprs_saved, 0, sizeof (gprs_saved));
  memset (fprs_saved, 0, sizeof (fprs_saved));
  info.read_memory_func = dis_asm_read_memory;

  save_link_regidx = subtract_sp_regidx = 0;
  if (fextra_info)
    {
      if (fi && fi->frame)
	{
	  orig_sp = fi->frame + fextra_info->stack_bought;
	  saved_regs = fi->saved_regs;
	}
      if (init_extra_info || !fextra_info->initialised)
	{
	  s390_memset_extra_info (fextra_info);
	  fextra_info->function_start = pc;
	  fextra_info->initialised = 1;
	}
    }
  instrlen = 0;
  do
    {
      valid_prologue = 0;
      test_pc += instrlen;
      /* add the previous instruction len */
      instrlen = s390_readinstruction (instr, test_pc, &info);
      if (instrlen < 0)
	{
	  good_prologue = 0;
	  err = -1;
	  break;
	}
      /* We probably are in a glibc syscall */
      if (instr[0] == S390_SYSCALL_OPCODE && test_pc == pc)
	{
	  good_prologue = 1;
	  if (saved_regs && fextra_info && fi->next && fi->next->extra_info
	      && fi->next->extra_info->sigcontext)
	    {
	      /* We are backtracing from a signal handler */
	      save_reg_addr = fi->next->extra_info->sigcontext +
		REGISTER_BYTE (S390_GP0_REGNUM);
	      for (regidx = 0; regidx < S390_NUM_GPRS; regidx++)
		{
		  saved_regs[S390_GP0_REGNUM + regidx] = save_reg_addr;
		  save_reg_addr += S390_GPR_SIZE;
		}
	      save_reg_addr = fi->next->extra_info->sigcontext +
		(GDB_TARGET_IS_ESAME ? S390X_SIGREGS_FP0_OFFSET :
		 S390_SIGREGS_FP0_OFFSET);
	      for (regidx = 0; regidx < S390_NUM_FPRS; regidx++)
		{
		  saved_regs[S390_FP0_REGNUM + regidx] = save_reg_addr;
		  save_reg_addr += S390_FPR_SIZE;
		}
	    }
	  break;
	}
      if (save_link_state == 0)
	{
	  /* check for a stack relative STMG or STM */
	  if (((GDB_TARGET_IS_ESAME &&
		((instr[0] == 0xeb) && (instr[5] == 0x24))) ||
	       (instr[0] == 0x90)) && ((instr[2] >> 4) == 0xf))
	    {
	      regidx = (instr[1] >> 4);
	      if (regidx < 6)
		varargs_state = 1;
	      offset = ((instr[2] & 0xf) << 8) + instr[3];
	      expected_offset =
		S390_GPR6_STACK_OFFSET + (S390_GPR_SIZE * (regidx - 6));
	      if (offset != expected_offset)
		{
		  good_prologue = 0;
		  break;
		}
	      if (saved_regs)
		save_reg_addr = orig_sp + offset;
	      for (; regidx <= (instr[1] & 0xf); regidx++)
		{
		  if (gprs_saved[regidx])
		    {
		      good_prologue = 0;
		      break;
		    }
		  good_prologue = 1;
		  gprs_saved[regidx] = 1;
		  if (saved_regs)
		    {
		      saved_regs[S390_GP0_REGNUM + regidx] = save_reg_addr;
		      save_reg_addr += S390_GPR_SIZE;
		    }
		}
	      valid_prologue = 1;
	      continue;
	    }
	}
      /* check for a stack relative STG or ST */
      if ((save_link_state == 0 || save_link_state == 3) &&
	  ((GDB_TARGET_IS_ESAME &&
	    ((instr[0] == 0xe3) && (instr[5] == 0x24))) ||
	   (instr[0] == 0x50)) && ((instr[2] >> 4) == 0xf))
	{
	  regidx = instr[1] >> 4;
	  offset = ((instr[2] & 0xf) << 8) + instr[3];
	  if (offset == 0)
	    {
	      if (save_link_state == 3 && regidx == save_link_regidx)
		{
		  save_link_state = 4;
		  valid_prologue = 1;
		  continue;
		}
	      else
		break;
	    }
	  if (regidx < 6)
	    varargs_state = 1;
	  expected_offset =
	    S390_GPR6_STACK_OFFSET + (S390_GPR_SIZE * (regidx - 6));
	  if (offset != expected_offset)
	    {
	      good_prologue = 0;
	      break;
	    }
	  if (gprs_saved[regidx])
	    {
	      good_prologue = 0;
	      break;
	    }
	  good_prologue = 1;
	  gprs_saved[regidx] = 1;
	  if (saved_regs)
	    {
	      save_reg_addr = orig_sp + offset;
	      saved_regs[S390_GP0_REGNUM + regidx] = save_reg_addr;
	    }
	  valid_prologue = 1;
	  continue;
	}

      /* check for STD */
      if (instr[0] == 0x60 && (instr[2] >> 4) == 0xf)
	{
	  regidx = instr[1] >> 4;
	  if (regidx == 0 || regidx == 2)
	    varargs_state = 1;
	  if (fprs_saved[regidx])
	    {
	      good_prologue = 0;
	      break;
	    }
	  fprs_saved[regidx] = 1;
	  if (saved_regs)
	    {
	      save_reg_addr = orig_sp + (((instr[2] & 0xf) << 8) + instr[3]);
	      saved_regs[S390_FP0_REGNUM + regidx] = save_reg_addr;
	    }
	  valid_prologue = 1;
	  continue;
	}


      if (const_pool_state == 0)
	{

	  if (GDB_TARGET_IS_ESAME)
	    {
	      /* Check for larl CONST_POOL_REGIDX,offset on ESAME */
	      if ((instr[0] == 0xc0)
		  && (instr[1] == (CONST_POOL_REGIDX << 4)))
		{
		  const_pool_state = 2;
		  valid_prologue = 1;
		  continue;
		}
	    }
	  else
	    {
	      /* Check for BASR gpr13,gpr0 used to load constant pool pointer to r13 in old compiler */
	      if (instr[0] == 0xd && (instr[1] & 0xf) == 0
		  && ((instr[1] >> 4) == CONST_POOL_REGIDX))
		{
		  const_pool_state = 1;
		  valid_prologue = 1;
		  continue;
		}
	    }
	  /* Check for new fangled bras %r13,newpc to load new constant pool */
	  /* embedded in code, older pre abi compilers also emitted this stuff.  */
	  if ((instr[0] == 0xa7) && ((instr[1] & 0xf) == 0x5) &&
	      ((instr[1] >> 4) == CONST_POOL_REGIDX)
	      && ((instr[2] & 0x80) == 0))
	    {
	      const_pool_state = 2;
	      test_pc +=
		(((((instr[2] & 0xf) << 8) + instr[3]) << 1) - instrlen);
	      valid_prologue = 1;
	      continue;
	    }
	}
      /* Check for AGHI or AHI CONST_POOL_REGIDX,val */
      if (const_pool_state == 1 && (instr[0] == 0xa7) &&
	  ((GDB_TARGET_IS_ESAME &&
	    (instr[1] == ((CONST_POOL_REGIDX << 4) | 0xb))) ||
	   (instr[1] == ((CONST_POOL_REGIDX << 4) | 0xa))))
	{
	  const_pool_state = 2;
	  valid_prologue = 1;
	  continue;
	}
      /* Check for LGR or LR gprx,15 */
      if ((GDB_TARGET_IS_ESAME &&
	   instr[0] == 0xb9 && instr[1] == 0x04 && (instr[3] & 0xf) == 0xf) ||
	  (instr[0] == 0x18 && (instr[1] & 0xf) == 0xf))
	{
	  if (GDB_TARGET_IS_ESAME)
	    regidx = instr[3] >> 4;
	  else
	    regidx = instr[1] >> 4;
	  if (save_link_state == 0 && regidx != 0xb)
	    {
	      /* Almost defintely code for
	         decrementing the stack pointer 
	         ( i.e. a non leaf function 
	         or else leaf with locals ) */
	      save_link_regidx = regidx;
	      save_link_state = 1;
	      valid_prologue = 1;
	      continue;
	    }
	  /* We use this frame pointer for alloca
	     unfortunately we need to assume its gpr11
	     otherwise we would need a smarter prologue
	     walker. */
	  if (!frame_pointer_found && regidx == 0xb)
	    {
	      frame_pointer_regidx = 0xb;
	      frame_pointer_found = 1;
	      if (fextra_info)
		fextra_info->frame_pointer_saved_pc = test_pc;
	      valid_prologue = 1;
	      continue;
	    }
	}
      /* Check for AHI or AGHI gpr15,val */
      if (save_link_state == 1 && (instr[0] == 0xa7) &&
	  ((GDB_TARGET_IS_ESAME && (instr[1] == 0xfb)) || (instr[1] == 0xfa)))
	{
	  if (fextra_info)
	    fextra_info->stack_bought =
	      -extract_signed_integer (&instr[2], 2);
	  save_link_state = 3;
	  valid_prologue = 1;
	  continue;
	}
      /* Alternatively check for the complex construction for
         buying more than 32k of stack
         BRAS gprx,.+8
         long vals    %r15,0(%gprx)  gprx currently r1 */
      if ((save_link_state == 1) && (instr[0] == 0xa7)
	  && ((instr[1] & 0xf) == 0x5) && (instr[2] == 0)
	  && (instr[3] == 0x4) && ((instr[1] >> 4) != CONST_POOL_REGIDX))
	{
	  subtract_sp_regidx = instr[1] >> 4;
	  save_link_state = 2;
	  if (fextra_info)
	    target_read_memory (test_pc + instrlen,
				(char *) &fextra_info->stack_bought,
				sizeof (fextra_info->stack_bought));
	  test_pc += 4;
	  valid_prologue = 1;
	  continue;
	}
      if (save_link_state == 2 && instr[0] == 0x5b
	  && instr[1] == 0xf0 &&
	  instr[2] == (subtract_sp_regidx << 4) && instr[3] == 0)
	{
	  save_link_state = 3;
	  valid_prologue = 1;
	  continue;
	}
      /* check for LA gprx,offset(15) used for varargs */
      if ((instr[0] == 0x41) && ((instr[2] >> 4) == 0xf) &&
	  ((instr[1] & 0xf) == 0))
	{
	  /* some code uses gpr7 to point to outgoing args */
	  if (((instr[1] >> 4) == 7) && (save_link_state == 0) &&
	      ((instr[2] & 0xf) == 0)
	      && (instr[3] == S390_STACK_FRAME_OVERHEAD))
	    {
	      valid_prologue = 1;
	      continue;
	    }
	  if (varargs_state == 1)
	    {
	      varargs_state = 2;
	      valid_prologue = 1;
	      continue;
	    }
	}
      /* Check for a GOT load */

      if (GDB_TARGET_IS_ESAME)
	{
	  /* Check for larl  GOT_REGIDX, on ESAME */
	  if ((got_state == 0) && (instr[0] == 0xc0)
	      && (instr[1] == (GOT_REGIDX << 4)))
	    {
	      got_state = 2;
	      valid_prologue = 1;
	      continue;
	    }
	}
      else
	{
	  /* check for l GOT_REGIDX,x(CONST_POOL_REGIDX) */
	  if (got_state == 0 && const_pool_state == 2 && instr[0] == 0x58
	      && (instr[2] == (CONST_POOL_REGIDX << 4))
	      && ((instr[1] >> 4) == GOT_REGIDX))
	    {
	      got_state == 1;
	      valid_prologue = 1;
	      continue;
	    }
	  /* Check for subsequent ar got_regidx,basr_regidx */
	  if (got_state == 1 && instr[0] == 0x1a &&
	      instr[1] == ((GOT_REGIDX << 4) | CONST_POOL_REGIDX))
	    {
	      got_state = 2;
	      valid_prologue = 1;
	      continue;
	    }
	}
    }
  while (valid_prologue && good_prologue);
  if (good_prologue)
    {
      good_prologue = (((got_state == 0) || (got_state == 2)) &&
		       ((const_pool_state == 0) || (const_pool_state == 2)) &&
		       ((save_link_state == 0) || (save_link_state == 4)) &&
		       ((varargs_state == 0) || (varargs_state == 2)));
    }
  if (fextra_info)
    {
      fextra_info->good_prologue = good_prologue;
      fextra_info->skip_prologue_function_start =
	(good_prologue ? test_pc : pc);
    }
  return err;
}


int
s390_check_function_end (CORE_ADDR pc)
{
  bfd_byte instr[S390_MAX_INSTR_SIZE];
  disassemble_info info;
  int regidx, instrlen;

  info.read_memory_func = dis_asm_read_memory;
  instrlen = s390_readinstruction (instr, pc, &info);
  if (instrlen < 0)
    return -1;
  /* check for BR */
  if (instrlen != 2 || instr[0] != 07 || (instr[1] >> 4) != 0xf)
    return 0;
  regidx = instr[1] & 0xf;
  /* Check for LMG or LG */
  instrlen =
    s390_readinstruction (instr, pc - (GDB_TARGET_IS_ESAME ? 6 : 4), &info);
  if (instrlen < 0)
    return -1;
  if (GDB_TARGET_IS_ESAME)
    {

      if (instrlen != 6 || instr[0] != 0xeb || instr[5] != 0x4)
	return 0;
    }
  else if (instrlen != 4 || instr[0] != 0x98)
    {
      return 0;
    }
  if ((instr[2] >> 4) != 0xf)
    return 0;
  if (regidx == 14)
    return 1;
  instrlen = s390_readinstruction (instr, pc - (GDB_TARGET_IS_ESAME ? 12 : 8),
				   &info);
  if (instrlen < 0)
    return -1;
  if (GDB_TARGET_IS_ESAME)
    {
      /* Check for LG */
      if (instrlen != 6 || instr[0] != 0xe3 || instr[5] != 0x4)
	return 0;
    }
  else
    {
      /* Check for L */
      if (instrlen != 4 || instr[0] != 0x58)
	return 0;
    }
  if (instr[2] >> 4 != 0xf)
    return 0;
  if (instr[1] >> 4 != regidx)
    return 0;
  return 1;
}

static CORE_ADDR
s390_sniff_pc_function_start (CORE_ADDR pc, struct frame_info *fi)
{
  CORE_ADDR function_start, test_function_start;
  int loop_cnt, err, function_end;
  struct frame_extra_info fextra_info;
  function_start = get_pc_function_start (pc);

  if (function_start == 0)
    {
      test_function_start = pc;
      if (test_function_start & 1)
	return 0;		/* This has to be bogus */
      loop_cnt = 0;
      do
	{

	  err =
	    s390_get_frame_info (test_function_start, &fextra_info, fi, 1);
	  loop_cnt++;
	  test_function_start -= 2;
	  function_end = s390_check_function_end (test_function_start);
	}
      while (!(function_end == 1 || err || loop_cnt >= 4096 ||
	       (fextra_info.good_prologue)));
      if (fextra_info.good_prologue)
	function_start = fextra_info.function_start;
      else if (function_end == 1)
	function_start = test_function_start;
    }
  return function_start;
}



CORE_ADDR
s390_function_start (struct frame_info *fi)
{
  CORE_ADDR function_start = 0;

  if (fi->extra_info && fi->extra_info->initialised)
    function_start = fi->extra_info->function_start;
  else if (fi->pc)
    function_start = get_pc_function_start (fi->pc);
  return function_start;
}




int
s390_frameless_function_invocation (struct frame_info *fi)
{
  struct frame_extra_info fextra_info, *fextra_info_ptr;
  int frameless = 0;

  if (fi->next == NULL)		/* no may be frameless */
    {
      if (fi->extra_info)
	fextra_info_ptr = fi->extra_info;
      else
	{
	  fextra_info_ptr = &fextra_info;
	  s390_get_frame_info (s390_sniff_pc_function_start (fi->pc, fi),
			       fextra_info_ptr, fi, 1);
	}
      frameless = ((fextra_info_ptr->stack_bought == 0));
    }
  return frameless;

}


static int
s390_is_sigreturn (CORE_ADDR pc, struct frame_info *sighandler_fi,
		   CORE_ADDR *sregs, CORE_ADDR *sigcaller_pc)
{
  bfd_byte instr[S390_MAX_INSTR_SIZE];
  disassemble_info info;
  int instrlen;
  CORE_ADDR scontext;
  int retval = 0;
  CORE_ADDR orig_sp;
  CORE_ADDR temp_sregs;

  scontext = temp_sregs = 0;

  info.read_memory_func = dis_asm_read_memory;
  instrlen = s390_readinstruction (instr, pc, &info);
  if (sigcaller_pc)
    *sigcaller_pc = 0;
  if (((instrlen == S390_SYSCALL_SIZE) &&
       (instr[0] == S390_SYSCALL_OPCODE)) &&
      ((instr[1] == s390_NR_sigreturn) || (instr[1] == s390_NR_rt_sigreturn)))
    {
      if (sighandler_fi)
	{
	  if (s390_frameless_function_invocation (sighandler_fi))
	    orig_sp = sighandler_fi->frame;
	  else
	    orig_sp = ADDR_BITS_REMOVE ((CORE_ADDR)
					read_memory_integer (sighandler_fi->
							     frame,
							     S390_GPR_SIZE));
	  if (orig_sp && sigcaller_pc)
	    {
	      scontext = orig_sp + S390_SIGNAL_FRAMESIZE;
	      if (pc == scontext && instr[1] == s390_NR_rt_sigreturn)
		{
		  /* We got a new style rt_signal */
		  /* get address of read ucontext->uc_mcontext */
		  temp_sregs = orig_sp + (GDB_TARGET_IS_ESAME ?
					  S390X_UC_MCONTEXT_OFFSET :
					  S390_UC_MCONTEXT_OFFSET);
		}
	      else
		{
		  /* read sigcontext->sregs */
		  temp_sregs = ADDR_BITS_REMOVE ((CORE_ADDR)
						 read_memory_integer (scontext
								      +
								      (GDB_TARGET_IS_ESAME
								       ?
								       S390X_SIGCONTEXT_SREGS_OFFSET
								       :
								       S390_SIGCONTEXT_SREGS_OFFSET),
								      S390_GPR_SIZE));

		}
	      /* read sigregs->psw.addr */
	      *sigcaller_pc =
		ADDR_BITS_REMOVE ((CORE_ADDR)
				  read_memory_integer (temp_sregs +
						       REGISTER_BYTE
						       (S390_PC_REGNUM),
						       S390_PSW_ADDR_SIZE));
	    }
	}
      retval = 1;
    }
  if (sregs)
    *sregs = temp_sregs;
  return retval;
}

/*
  We need to do something better here but this will keep us out of trouble
  for the moment.
  For some reason the blockframe.c calls us with fi->next->fromleaf
  so this seems of little use to us. */
void
s390_init_frame_pc_first (int next_fromleaf, struct frame_info *fi)
{
  CORE_ADDR sigcaller_pc;

  fi->pc = 0;
  if (next_fromleaf)
    {
      fi->pc = ADDR_BITS_REMOVE (read_register (S390_RETADDR_REGNUM));
      /* fix signal handlers */
    }
  else if (fi->next && fi->next->pc)
    fi->pc = s390_frame_saved_pc_nofix (fi->next);
  if (fi->pc && fi->next && fi->next->frame &&
      s390_is_sigreturn (fi->pc, fi->next, NULL, &sigcaller_pc))
    {
      fi->pc = sigcaller_pc;
    }

}

void
s390_init_extra_frame_info (int fromleaf, struct frame_info *fi)
{
  fi->extra_info = frame_obstack_alloc (sizeof (struct frame_extra_info));
  if (fi->pc)
    s390_get_frame_info (s390_sniff_pc_function_start (fi->pc, fi),
			 fi->extra_info, fi, 1);
  else
    s390_memset_extra_info (fi->extra_info);
}

/* If saved registers of frame FI are not known yet, read and cache them.
   &FEXTRA_INFOP contains struct frame_extra_info; TDATAP can be NULL,
   in which case the framedata are read.  */

void
s390_frame_init_saved_regs (struct frame_info *fi)
{

  int quick;

  if (fi->saved_regs == NULL)
    {
      /* zalloc memsets the saved regs */
      frame_saved_regs_zalloc (fi);
      if (fi->pc)
	{
	  quick = (fi->extra_info && fi->extra_info->initialised
		   && fi->extra_info->good_prologue);
	  s390_get_frame_info (quick ? fi->extra_info->function_start :
			       s390_sniff_pc_function_start (fi->pc, fi),
			       fi->extra_info, fi, !quick);
	}
    }
}



CORE_ADDR
s390_frame_args_address (struct frame_info *fi)
{

  /* Apparently gdb already knows gdb_args_offset itself */
  return fi->frame;
}


static CORE_ADDR
s390_frame_saved_pc_nofix (struct frame_info *fi)
{
  if (fi->extra_info && fi->extra_info->saved_pc_valid)
    return fi->extra_info->saved_pc;
  s390_frame_init_saved_regs (fi);
  if (fi->extra_info)
    {
      fi->extra_info->saved_pc_valid = 1;
      if (fi->extra_info->good_prologue)
	{
	  if (fi->saved_regs[S390_RETADDR_REGNUM])
	    {
	      return (fi->extra_info->saved_pc =
		      ADDR_BITS_REMOVE (read_memory_integer
					(fi->saved_regs[S390_RETADDR_REGNUM],
					 S390_GPR_SIZE)));
	    }
	}
    }
  return 0;
}

CORE_ADDR
s390_frame_saved_pc (struct frame_info *fi)
{
  CORE_ADDR saved_pc = 0, sig_pc;

  if (fi->extra_info && fi->extra_info->sig_fixed_saved_pc_valid)
    return fi->extra_info->sig_fixed_saved_pc;
  saved_pc = s390_frame_saved_pc_nofix (fi);

  if (fi->extra_info)
    {
      fi->extra_info->sig_fixed_saved_pc_valid = 1;
      if (saved_pc)
	{
	  if (s390_is_sigreturn (saved_pc, fi, NULL, &sig_pc))
	    saved_pc = sig_pc;
	}
      fi->extra_info->sig_fixed_saved_pc = saved_pc;
    }
  return saved_pc;
}




/* We want backtraces out of signal handlers so we don't
   set thisframe->signal_handler_caller to 1 */

CORE_ADDR
s390_frame_chain (struct frame_info *thisframe)
{
  CORE_ADDR prev_fp = 0;

  if (thisframe->prev && thisframe->prev->frame)
    prev_fp = thisframe->prev->frame;
  else
    {
      int sigreturn = 0;
      CORE_ADDR sregs = 0;
      struct frame_extra_info prev_fextra_info;

      memset (&prev_fextra_info, 0, sizeof (prev_fextra_info));
      if (thisframe->pc)
	{
	  CORE_ADDR saved_pc, sig_pc;

	  saved_pc = s390_frame_saved_pc_nofix (thisframe);
	  if (saved_pc)
	    {
	      if ((sigreturn =
		   s390_is_sigreturn (saved_pc, thisframe, &sregs, &sig_pc)))
		saved_pc = sig_pc;
	      s390_get_frame_info (s390_sniff_pc_function_start
				   (saved_pc, NULL), &prev_fextra_info, NULL,
				   1);
	    }
	}
      if (sigreturn)
	{
	  /* read sigregs,regs.gprs[11 or 15] */
	  prev_fp = read_memory_integer (sregs +
					 REGISTER_BYTE (S390_GP0_REGNUM +
							(prev_fextra_info.
							 frame_pointer_saved_pc
							 ? 11 : 15)),
					 S390_GPR_SIZE);
	  thisframe->extra_info->sigcontext = sregs;
	}
      else
	{
	  if (thisframe->saved_regs)
	    {

	      int regno;

	      regno =
		((prev_fextra_info.frame_pointer_saved_pc
		  && thisframe->
		  saved_regs[S390_FRAME_REGNUM]) ? S390_FRAME_REGNUM :
		 S390_SP_REGNUM);
	      if (thisframe->saved_regs[regno])
		prev_fp =
		  read_memory_integer (thisframe->saved_regs[regno],
				       S390_GPR_SIZE);
	    }
	}
    }
  return ADDR_BITS_REMOVE (prev_fp);
}

/*
  Whether struct frame_extra_info is actually needed I'll have to figure
  out as our frames are similar to rs6000 there is a possibility
  i386 dosen't need it. */



/* a given return value in `regbuf' with a type `valtype', extract and copy its
   value into `valbuf' */
void
s390_extract_return_value (struct type *valtype, char *regbuf, char *valbuf)
{
  /* floats and doubles are returned in fpr0. fpr's have a size of 8 bytes.
     We need to truncate the return value into float size (4 byte) if
     necessary. */
  int len = TYPE_LENGTH (valtype);

  if (TYPE_CODE (valtype) == TYPE_CODE_FLT)
    {
      if (len > (TARGET_FLOAT_BIT >> 3))
	memcpy (valbuf, &regbuf[REGISTER_BYTE (S390_FP0_REGNUM)], len);
      else
	{
	  /* float */
	  DOUBLEST val;

	  floatformat_to_doublest (&floatformat_ieee_double_big,
				   &regbuf[REGISTER_BYTE (S390_FP0_REGNUM)],
				   &val);
	  store_floating (valbuf, len, val);
	}
    }
  else
    {
      int offset = 0;
      /* return value is copied starting from r2. */
      if (TYPE_LENGTH (valtype) < S390_GPR_SIZE)
	offset = S390_GPR_SIZE - TYPE_LENGTH (valtype);
      memcpy (valbuf,
	      regbuf + REGISTER_BYTE (S390_GP0_REGNUM + 2) + offset,
	      TYPE_LENGTH (valtype));
    }
}


static char *
s390_promote_integer_argument (struct type *valtype, char *valbuf,
			       char *reg_buff, int *arglen)
{
  char *value = valbuf;
  int len = TYPE_LENGTH (valtype);

  if (len < S390_GPR_SIZE)
    {
      /* We need to upgrade this value to a register to pass it correctly */
      int idx, diff = S390_GPR_SIZE - len, negative =
	(!TYPE_UNSIGNED (valtype) && value[0] & 0x80);
      for (idx = 0; idx < S390_GPR_SIZE; idx++)
	{
	  reg_buff[idx] = (idx < diff ? (negative ? 0xff : 0x0) :
			   value[idx - diff]);
	}
      value = reg_buff;
      *arglen = S390_GPR_SIZE;
    }
  else
    {
      if (len & (S390_GPR_SIZE - 1))
	{
	  fprintf_unfiltered (gdb_stderr,
			      "s390_promote_integer_argument detected an argument not "
			      "a multiple of S390_GPR_SIZE & greater than S390_GPR_SIZE "
			      "we might not deal with this correctly.\n");
	}
      *arglen = len;
    }

  return (value);
}

void
s390_store_return_value (struct type *valtype, char *valbuf)
{
  int arglen;
  char *reg_buff = alloca (max (S390_FPR_SIZE, REGISTER_SIZE)), *value;

  if (TYPE_CODE (valtype) == TYPE_CODE_FLT)
    {
      DOUBLEST tempfloat = extract_floating (valbuf, TYPE_LENGTH (valtype));

      floatformat_from_doublest (&floatformat_ieee_double_big, &tempfloat,
				 reg_buff);
      write_register_bytes (REGISTER_BYTE (S390_FP0_REGNUM), reg_buff,
			    S390_FPR_SIZE);
    }
  else
    {
      value =
	s390_promote_integer_argument (valtype, valbuf, reg_buff, &arglen);
      /* Everything else is returned in GPR2 and up. */
      write_register_bytes (REGISTER_BYTE (S390_GP0_REGNUM + 2), value,
			    arglen);
    }
}
static int
gdb_print_insn_s390 (bfd_vma memaddr, disassemble_info * info)
{
  bfd_byte instrbuff[S390_MAX_INSTR_SIZE];
  int instrlen, cnt;

  instrlen = s390_readinstruction (instrbuff, (CORE_ADDR) memaddr, info);
  if (instrlen < 0)
    {
      (*info->memory_error_func) (instrlen, memaddr, info);
      return -1;
    }
  for (cnt = 0; cnt < instrlen; cnt++)
    info->fprintf_func (info->stream, "%02X ", instrbuff[cnt]);
  for (cnt = instrlen; cnt < S390_MAX_INSTR_SIZE; cnt++)
    info->fprintf_func (info->stream, "   ");
  instrlen = print_insn_s390 (memaddr, info);
  return instrlen;
}



/* Not the most efficent code in the world */
int
s390_fp_regnum ()
{
  int regno = S390_SP_REGNUM;
  struct frame_extra_info fextra_info;

  CORE_ADDR pc = ADDR_BITS_REMOVE (read_register (S390_PC_REGNUM));

  s390_get_frame_info (s390_sniff_pc_function_start (pc, NULL), &fextra_info,
		       NULL, 1);
  if (fextra_info.frame_pointer_saved_pc)
    regno = S390_FRAME_REGNUM;
  return regno;
}

CORE_ADDR
s390_read_fp ()
{
  return read_register (s390_fp_regnum ());
}


void
s390_write_fp (CORE_ADDR val)
{
  write_register (s390_fp_regnum (), val);
}


void
s390_push_dummy_frame ()
{
  CORE_ADDR orig_sp = read_register (S390_SP_REGNUM), new_sp;
  void *saved_regs = alloca (REGISTER_BYTES);

  new_sp = (orig_sp - (REGISTER_BYTES + S390_GPR_SIZE));
  read_register_bytes (0, (char *) saved_regs, REGISTER_BYTES);
  /* Use saved copy instead of orig_sp as this will have the correct endianness */
  write_memory (new_sp, (char *) saved_regs + REGISTER_BYTE (S390_SP_REGNUM),
		S390_GPR_SIZE);
  write_memory (new_sp + S390_GPR_SIZE, (char *) &saved_regs, REGISTER_BYTES);
  write_register (S390_SP_REGNUM, new_sp);
}

/* pop the innermost frame, go back to the caller.
    Used in `call_function_by_hand' to remove an artificial stack
     frame.  */
void
s390_pop_frame ()
{
  CORE_ADDR new_sp = read_register (S390_SP_REGNUM), orig_sp;
  void *saved_regs = alloca (REGISTER_BYTES);


  read_memory (new_sp + S390_GPR_SIZE, (char *) saved_regs, REGISTER_BYTES);
  write_register_bytes (0, (char *) &saved_regs, REGISTER_BYTES);
}

/* used by call function by hand
  struct_return indicates that this function returns a structure &
  therefore gpr2 stores a pointer to the structure to be returned as
  opposed to the first argument.
  Currently I haven't seen a TYPE_CODE_INT whose size wasn't 2^n or less
  than S390_GPR_SIZE this is good because I don't seem to have to worry
  about sign extending pushed arguments (i.e. a signed char currently
  comes into this code with a size of 4 ). */

CORE_ADDR
s390_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
		     int struct_return, CORE_ADDR struct_addr)
{
  int num_float_args, num_gpr_args, orig_num_gpr_args, argno;
  int second_pass, len, arglen, gprs_required;
  CORE_ADDR outgoing_args_ptr, outgoing_args_space;
  value_ptr arg;
  struct type *type;
  int max_num_gpr_args = 5 - (struct_return ? 1 : 0);
  int arg0_regnum = S390_GP0_REGNUM + 2 + (struct_return ? 1 : 0);
  char *reg_buff = alloca (max (S390_FPR_SIZE, REGISTER_SIZE)), *value;

  for (second_pass = 0; second_pass <= 1; second_pass++)
    {
      if (second_pass)
	outgoing_args_ptr = sp + S390_STACK_FRAME_OVERHEAD;
      else
	outgoing_args_ptr = 0;
      num_float_args = 0;
      num_gpr_args = 0;
      for (argno = 0; argno < nargs; argno++)
	{
	  arg = args[argno];
	  type = check_typedef (VALUE_TYPE (arg));
	  len = TYPE_LENGTH (type);
	  if (TYPE_CODE (type) == TYPE_CODE_FLT)
	    {
	      int all_float_registers_used =
		num_float_args > (GDB_TARGET_IS_ESAME ? 3 : 1);

	      if (second_pass)
		{
		  DOUBLEST tempfloat =
		    extract_floating (VALUE_CONTENTS (arg), len);


		  floatformat_from_doublest (all_float_registers_used &&
					     len == (TARGET_FLOAT_BIT >> 3)
					     ? &floatformat_ieee_single_big
					     : &floatformat_ieee_double_big,
					     &tempfloat, reg_buff);
		  if (all_float_registers_used)
		    write_memory (outgoing_args_ptr, reg_buff, len);
		  else
		    write_register_bytes (REGISTER_BYTE ((S390_FP0_REGNUM)
							 +
							 (2 *
							  num_float_args)),
					  reg_buff, S390_FPR_SIZE);
		}
	      if (all_float_registers_used)
		outgoing_args_ptr += len;
	      num_float_args++;
	    }
	  else
	    {
	      gprs_required = ((len + (S390_GPR_SIZE - 1)) / S390_GPR_SIZE);

	      value =
		s390_promote_integer_argument (type, VALUE_CONTENTS (arg),
					       reg_buff, &arglen);

	      orig_num_gpr_args = num_gpr_args;
	      num_gpr_args += gprs_required;
	      if (num_gpr_args > max_num_gpr_args)
		{
		  if (second_pass)
		    write_memory (outgoing_args_ptr, value, arglen);
		  outgoing_args_ptr += arglen;
		}
	      else
		{
		  if (second_pass)
		    write_register_bytes (REGISTER_BYTE (arg0_regnum)
					  +
					  (orig_num_gpr_args * S390_GPR_SIZE),
					  value, arglen);
		}
	    }
	}
      if (!second_pass)
	{
	  outgoing_args_space = outgoing_args_ptr;
	  /* Align to 16 bytes because because I like alignment & 
	     some of the kernel code requires 8 byte stack alignment at least. */
	  sp = (sp - (S390_STACK_FRAME_OVERHEAD + outgoing_args_ptr)) & (-16);
	}

    }
  return sp;

}

void
s390_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs,
		     struct value **args, struct type *value_type,
		     int using_gcc)
{
  store_unsigned_integer (dummy + 4, REGISTER_SIZE, fun);
}


/* Return the GDB type object for the "standard" data type
   of data in register N.  */
struct type *
s390_register_virtual_type (int regno)
{
  return ((unsigned) regno - S390_FPC_REGNUM) <
    S390_NUM_FPRS ? builtin_type_double : builtin_type_int;
}


struct type *
s390x_register_virtual_type (int regno)
{
  return (regno == S390_FPC_REGNUM) ||
    (regno >= S390_FIRST_ACR && regno <= S390_LAST_ACR) ? builtin_type_int :
    (regno >= S390_FP0_REGNUM) ? builtin_type_double : builtin_type_long;
}



void
s390_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  write_register (S390_GP0_REGNUM + 2, addr);
}



static unsigned char *
s390_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
{
  static unsigned char breakpoint[] = { 0x0, 0x1 };

  *lenptr = sizeof (breakpoint);
  return breakpoint;
}

/* Advance PC across any function entry prologue instructions to reach some
   "real" code.  */
CORE_ADDR
s390_skip_prologue (CORE_ADDR pc)
{
  struct frame_extra_info fextra_info;

  s390_get_frame_info (pc, &fextra_info, NULL, 1);
  return fextra_info.skip_prologue_function_start;
}

/* pc_in_call_dummy_on stack may work for us must test this */
int
s390_pc_in_call_dummy (CORE_ADDR pc, CORE_ADDR sp, CORE_ADDR frame_address)
{
  return pc > sp && pc < (sp + 4096);
}

/* Immediately after a function call, return the saved pc.
   Can't go through the frames for this because on some machines
   the new frame is not set up until the new function executes
   some instructions.  */
CORE_ADDR
s390_saved_pc_after_call (struct frame_info *frame)
{
  return ADDR_BITS_REMOVE (read_register (S390_RETADDR_REGNUM));
}

static CORE_ADDR
s390_addr_bits_remove (CORE_ADDR addr)
{
  return (addr) & 0x7fffffff;
}


static CORE_ADDR
s390_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
{
  return sp;
}

struct gdbarch *
s390_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{

  /* instruction sequence for s390 call dummy is as follows
     bras %r1,.+8      ; 0xA7150004   
     long basraddr     ; 0x00000000
     l    %r1,0(%r1)   ; 0x58101000
     basr %r14,%r1     ; 0x0DE1
     breakpoint        ; 0x0001 */
  static LONGEST s390_call_dummy_words[] = { 0xA7150004, 0x00000000,
    0x58101000, 0x0DE10001
  };
  /* instruction sequence for esame call dummy is as follows
     bras %r1,.+12     ; 0xA7150006   
     long basraddr     ; 0x0000000000000000
     lg   %r1,0(%r1)   ; 0xE31010000004
     basr %r14,%r1     ; 0x0DE1
     breakpoint        ; 0x0001 */
  static LONGEST s390x_call_dummy_words[] = { 0xA715000600000000,
    0x00000000E3101000,
    0x00040DE100010000
  };
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;
  int elf_flags;

  /* First see if there is already a gdbarch that can satisfy the request.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* None found: is the request for a s390 architecture? */
  if (info.bfd_arch_info->arch != bfd_arch_s390)
    return NULL;		/* No; then it's not for us.  */

  /* Yes: create a new gdbarch for the specified machine type.  */
  gdbarch = gdbarch_alloc (&info, NULL);

  set_gdbarch_believe_pcc_promotion (gdbarch, 0);

  /* We don't define set_gdbarch_call_dummy_breakpoint_offset 
     as we already have a breakpoint inserted. */
  set_gdbarch_use_generic_dummy_frames (gdbarch, 0);

  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
  set_gdbarch_pc_in_call_dummy (gdbarch, s390_pc_in_call_dummy);
  set_gdbarch_frame_args_skip (gdbarch, 0);
  set_gdbarch_frame_args_address (gdbarch, s390_frame_args_address);
  set_gdbarch_frame_chain (gdbarch, s390_frame_chain);
  set_gdbarch_frame_init_saved_regs (gdbarch, s390_frame_init_saved_regs);
  set_gdbarch_frame_locals_address (gdbarch, s390_frame_args_address);
  /* We can't do this */
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
  set_gdbarch_store_struct_return (gdbarch, s390_store_struct_return);
  set_gdbarch_extract_return_value (gdbarch, s390_extract_return_value);
  set_gdbarch_store_return_value (gdbarch, s390_store_return_value);
  /* Amount PC must be decremented by after a breakpoint.
     This is often the number of bytes in BREAKPOINT
     but not always.  */
  set_gdbarch_decr_pc_after_break (gdbarch, 2);
  set_gdbarch_pop_frame (gdbarch, s390_pop_frame);
  set_gdbarch_push_dummy_frame (gdbarch, s390_push_dummy_frame);
  set_gdbarch_push_arguments (gdbarch, s390_push_arguments);
  set_gdbarch_ieee_float (gdbarch, 1);
  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  /* Offset from address of function to start of its code.
     Zero on most machines.  */
  set_gdbarch_function_start_offset (gdbarch, 0);
  set_gdbarch_max_register_raw_size (gdbarch, 8);
  set_gdbarch_max_register_virtual_size (gdbarch, 8);
  set_gdbarch_breakpoint_from_pc (gdbarch, s390_breakpoint_from_pc);
  set_gdbarch_skip_prologue (gdbarch, s390_skip_prologue);
  set_gdbarch_init_extra_frame_info (gdbarch, s390_init_extra_frame_info);
  set_gdbarch_init_frame_pc_first (gdbarch, s390_init_frame_pc_first);
  set_gdbarch_read_fp (gdbarch, s390_read_fp);
  set_gdbarch_write_fp (gdbarch, s390_write_fp);
  /* This function that tells us whether the function invocation represented
     by FI does not have a frame on the stack associated with it.  If it
     does not, FRAMELESS is set to 1, else 0.  */
  set_gdbarch_frameless_function_invocation (gdbarch,
					     s390_frameless_function_invocation);
  /* Return saved PC from a frame */
  set_gdbarch_frame_saved_pc (gdbarch, s390_frame_saved_pc);
  /* FRAME_CHAIN takes a frame's nominal address
     and produces the frame's chain-pointer. */
  set_gdbarch_frame_chain (gdbarch, s390_frame_chain);
  set_gdbarch_saved_pc_after_call (gdbarch, s390_saved_pc_after_call);
  set_gdbarch_register_byte (gdbarch, s390_register_byte);
  set_gdbarch_pc_regnum (gdbarch, S390_PC_REGNUM);
  set_gdbarch_sp_regnum (gdbarch, S390_SP_REGNUM);
  set_gdbarch_fp_regnum (gdbarch, S390_FP_REGNUM);
  set_gdbarch_fp0_regnum (gdbarch, S390_FP0_REGNUM);
  set_gdbarch_num_regs (gdbarch, S390_NUM_REGS);
  set_gdbarch_cannot_fetch_register (gdbarch, s390_cannot_fetch_register);
  set_gdbarch_cannot_store_register (gdbarch, s390_cannot_fetch_register);
  set_gdbarch_get_saved_register (gdbarch, generic_get_saved_register);
  set_gdbarch_use_struct_convention (gdbarch, generic_use_struct_convention);
  set_gdbarch_frame_chain_valid (gdbarch, file_frame_chain_valid);
  set_gdbarch_register_name (gdbarch, s390_register_name);
  set_gdbarch_stab_reg_to_regnum (gdbarch, s390_stab_reg_to_regnum);
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, s390_stab_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, s390_stab_reg_to_regnum);
  set_gdbarch_skip_trampoline_code (gdbarch, find_solib_trampoline_target);

  /* Stuff below here wouldn't be required if gdbarch.sh was a little */
  /* more intelligent */
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 0);
  set_gdbarch_call_dummy_p (gdbarch, 1);
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
  set_gdbarch_extract_struct_value_address (gdbarch, 0);
  set_gdbarch_fix_call_dummy (gdbarch, s390_fix_call_dummy);
#ifdef GDB_NM_FILE
  set_gdbarch_prepare_to_proceed (gdbarch, linuxthreads_prepare_to_proceed);
#endif
  set_gdbarch_push_return_address (gdbarch, s390_push_return_address);

  switch (info.bfd_arch_info->mach)
    {
    case bfd_mach_s390_esa:
      set_gdbarch_register_size (gdbarch, 4);
      set_gdbarch_call_dummy_length (gdbarch, 16);
      set_gdbarch_register_raw_size (gdbarch, s390_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, s390_register_raw_size);
      set_gdbarch_register_virtual_type (gdbarch, s390_register_virtual_type);

      set_gdbarch_addr_bits_remove (gdbarch, s390_addr_bits_remove);

      set_gdbarch_sizeof_call_dummy_words (gdbarch,
					   sizeof (s390_call_dummy_words));
      set_gdbarch_call_dummy_words (gdbarch, s390_call_dummy_words);
      set_gdbarch_register_bytes (gdbarch, S390_REGISTER_BYTES);
      break;
    case bfd_mach_s390_esame:
      set_gdbarch_register_size (gdbarch, 8);
      set_gdbarch_call_dummy_length (gdbarch, 22);
      set_gdbarch_register_raw_size (gdbarch, s390x_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, s390x_register_raw_size);
      set_gdbarch_register_virtual_type (gdbarch,
					 s390x_register_virtual_type);

      set_gdbarch_long_bit (gdbarch, 64);
      set_gdbarch_long_long_bit (gdbarch, 64);
      set_gdbarch_ptr_bit (gdbarch, 64);
      set_gdbarch_sizeof_call_dummy_words (gdbarch,
					   sizeof (s390x_call_dummy_words));
      set_gdbarch_call_dummy_words (gdbarch, s390x_call_dummy_words);
      set_gdbarch_register_bytes (gdbarch, S390X_REGISTER_BYTES);
      break;
    }

  return gdbarch;
}



void
_initialize_s390_tdep ()
{

  /* Hook us into the gdbarch mechanism.  */
  register_gdbarch_init (bfd_arch_s390, s390_gdbarch_init);
  if (!tm_print_insn)		/* Someone may have already set it */
    tm_print_insn = gdb_print_insn_s390;
}

#endif /* GDBSERVER */
@


1.1.2.2
log
@* s390-tdep.c, s390-nat.c: Update copyright.
* config/s390/tm-s390.h, config/s390/xm-linux.h: Ditto.
* config/s390/tm-linux.h, config/s390/nm-linux.h: Ditto.
@
text
@d2 1
a2 1
   Copyright 2001 Free Software Foundation, Inc.
@


