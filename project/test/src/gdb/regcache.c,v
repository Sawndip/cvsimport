head	1.202;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.201
	gdb_7_6-2013-04-26-release:1.201
	gdb_7_6-branch:1.201.0.2
	gdb_7_6-2013-03-12-branchpoint:1.201
	gdb_7_5_1-2012-11-29-release:1.196
	gdb_7_5-2012-08-17-release:1.196
	gdb_7_5-branch:1.196.0.2
	gdb_7_5-2012-07-18-branchpoint:1.196
	gdb_7_4_1-2012-04-26-release:1.195.2.1
	gdb_7_4-2012-01-24-release:1.195.2.1
	gdb_7_4-branch:1.195.0.2
	gdb_7_4-2011-12-13-branchpoint:1.195
	gdb_7_3_1-2011-09-04-release:1.188.2.1
	gdb_7_3-2011-07-26-release:1.188.2.1
	gdb_7_3-branch:1.188.0.2
	gdb_7_3-2011-04-01-branchpoint:1.188
	gdb_7_2-2010-09-02-release:1.180
	gdb_7_2-branch:1.180.0.2
	gdb_7_2-2010-07-07-branchpoint:1.180
	gdb_7_1-2010-03-18-release:1.177
	gdb_7_1-branch:1.177.0.2
	gdb_7_1-2010-02-18-branchpoint:1.177
	gdb_7_0_1-2009-12-22-release:1.174
	gdb_7_0-2009-10-06-release:1.174
	gdb_7_0-branch:1.174.0.4
	gdb_7_0-2009-09-16-branchpoint:1.174
	arc-sim-20090309:1.164.2.1
	msnyder-checkpoint-072509-branch:1.174.0.2
	msnyder-checkpoint-072509-branchpoint:1.174
	arc-insight_6_8-branch:1.164.2.1.0.4
	arc-insight_6_8-branchpoint:1.164.2.1
	insight_6_8-branch:1.164.2.1.0.2
	insight_6_8-branchpoint:1.164.2.1
	reverse-20081226-branch:1.168.0.4
	reverse-20081226-branchpoint:1.168
	multiprocess-20081120-branch:1.168.0.2
	multiprocess-20081120-branchpoint:1.168
	reverse-20080930-branch:1.167.0.2
	reverse-20080930-branchpoint:1.167
	reverse-20080717-branch:1.166.0.4
	reverse-20080717-branchpoint:1.166
	msnyder-reverse-20080609-branch:1.166.0.2
	msnyder-reverse-20080609-branchpoint:1.166
	drow-reverse-20070409-branch:1.143.0.2
	drow-reverse-20070409-branchpoint:1.143
	gdb_6_8-2008-03-27-release:1.164.2.1
	gdb_6_8-branch:1.164.0.2
	gdb_6_8-2008-02-26-branchpoint:1.164
	gdb_6_7_1-2007-10-29-release:1.161
	gdb_6_7-2007-10-10-release:1.161
	gdb_6_7-branch:1.161.0.2
	gdb_6_7-2007-09-07-branchpoint:1.161
	insight_6_6-20070208-release:1.139
	gdb_6_6-2006-12-18-release:1.139
	gdb_6_6-branch:1.139.0.2
	gdb_6_6-2006-11-15-branchpoint:1.139
	insight_6_5-20061003-release:1.138
	gdb-csl-symbian-6_4_50_20060226-12:1.138
	gdb-csl-sourcerygxx-3_4_4-25:1.137
	nickrob-async-20060828-mergepoint:1.139
	gdb-csl-symbian-6_4_50_20060226-11:1.138
	gdb-csl-sourcerygxx-4_1-17:1.138
	gdb-csl-20060226-branch-local-2:1.138
	gdb-csl-sourcerygxx-4_1-14:1.138
	gdb-csl-sourcerygxx-4_1-13:1.138
	gdb-csl-sourcerygxx-4_1-12:1.138
	gdb-csl-sourcerygxx-3_4_4-21:1.138
	gdb_6_5-20060621-release:1.138
	gdb-csl-sourcerygxx-4_1-9:1.138
	gdb-csl-sourcerygxx-4_1-8:1.138
	gdb-csl-sourcerygxx-4_1-7:1.138
	gdb-csl-arm-2006q1-6:1.138
	gdb-csl-sourcerygxx-4_1-6:1.138
	gdb-csl-symbian-6_4_50_20060226-10:1.138
	gdb-csl-symbian-6_4_50_20060226-9:1.138
	gdb-csl-symbian-6_4_50_20060226-8:1.138
	gdb-csl-coldfire-4_1-11:1.138
	gdb-csl-sourcerygxx-3_4_4-19:1.138
	gdb-csl-coldfire-4_1-10:1.138
	gdb_6_5-branch:1.138.0.16
	gdb_6_5-2006-05-14-branchpoint:1.138
	gdb-csl-sourcerygxx-4_1-5:1.138
	nickrob-async-20060513-branch:1.138.0.14
	nickrob-async-20060513-branchpoint:1.138
	gdb-csl-sourcerygxx-4_1-4:1.138
	msnyder-reverse-20060502-branch:1.138.0.12
	msnyder-reverse-20060502-branchpoint:1.138
	gdb-csl-morpho-4_1-4:1.138
	gdb-csl-sourcerygxx-3_4_4-17:1.138
	readline_5_1-import-branch:1.138.0.10
	readline_5_1-import-branchpoint:1.138
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.138
	gdb-csl-symbian-20060226-branch:1.138.0.8
	gdb-csl-symbian-20060226-branchpoint:1.138
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.138
	msnyder-reverse-20060331-branch:1.138.0.6
	msnyder-reverse-20060331-branchpoint:1.138
	gdb-csl-available-20060303-branch:1.138.0.4
	gdb-csl-available-20060303-branchpoint:1.138
	gdb-csl-20060226-branch:1.138.0.2
	gdb-csl-20060226-branchpoint:1.138
	gdb_6_4-20051202-release:1.137
	msnyder-fork-checkpoint-branch:1.137.0.8
	msnyder-fork-checkpoint-branchpoint:1.137
	gdb-csl-gxxpro-6_3-branch:1.137.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.137
	gdb_6_4-branch:1.137.0.4
	gdb_6_4-2005-11-01-branchpoint:1.137
	gdb-csl-arm-20051020-branch:1.137.0.2
	gdb-csl-arm-20051020-branchpoint:1.137
	msnyder-tracepoint-checkpoint-branch:1.136.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.136
	gdb-csl-arm-20050325-2005-q1b:1.134
	gdb-csl-arm-20050325-2005-q1a:1.134
	csl-arm-20050325-branch:1.134.0.2
	csl-arm-20050325-branchpoint:1.134
	gdb-post-i18n-errorwarning-20050211:1.129
	gdb-pre-i18n-errorwarning-20050211:1.129
	gdb_6_3-20041109-release:1.128
	gdb_6_3-branch:1.128.0.2
	gdb_6_3-20041019-branchpoint:1.128
	drow_intercu-merge-20040921:1.127
	drow_intercu-merge-20040915:1.127
	jimb-gdb_6_2-e500-branch:1.115.0.6
	jimb-gdb_6_2-e500-branchpoint:1.115
	gdb_6_2-20040730-release:1.115
	gdb_6_2-branch:1.115.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.115
	gdb_6_1_1-20040616-release:1.109
	gdb_6_1-2004-04-05-release:1.109
	drow_intercu-merge-20040402:1.110
	drow_intercu-merge-20040327:1.110
	ezannoni_pie-20040323-branch:1.110.0.2
	ezannoni_pie-20040323-branchpoint:1.110
	cagney_tramp-20040321-mergepoint:1.110
	cagney_tramp-20040309-branch:1.109.0.4
	cagney_tramp-20040309-branchpoint:1.109
	gdb_6_1-branch:1.109.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.109
	drow_intercu-20040221-branch:1.108.0.2
	drow_intercu-20040221-branchpoint:1.108
	cagney_bfdfile-20040213-branch:1.107.0.2
	cagney_bfdfile-20040213-branchpoint:1.107
	drow-cplus-merge-20040208:1.106
	carlton_dictionary-20040126-merge:1.106
	cagney_bigcore-20040122-branch:1.106.0.2
	cagney_bigcore-20040122-branchpoint:1.106
	drow-cplus-merge-20040113:1.105
	drow-cplus-merge-20031224:1.105
	drow-cplus-merge-20031220:1.105
	carlton_dictionary-20031215-merge:1.105
	drow-cplus-merge-20031214:1.105
	carlton-dictionary-20031111-merge:1.105
	gdb_6_0-2003-10-04-release:1.88.2.2
	kettenis_sparc-20030918-branch:1.99.0.2
	kettenis_sparc-20030918-branchpoint:1.99
	carlton_dictionary-20030917-merge:1.99
	ezannoni_pie-20030916-branchpoint:1.97
	ezannoni_pie-20030916-branch:1.97.0.2
	cagney_x86i386-20030821-branch:1.94.0.2
	cagney_x86i386-20030821-branchpoint:1.94
	carlton_dictionary-20030805-merge:1.94
	carlton_dictionary-20030627-merge:1.88
	gdb_6_0-branch:1.88.0.2
	gdb_6_0-2003-06-23-branchpoint:1.88
	jimb-ppc64-linux-20030613-branch:1.87.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.87
	cagney_convert-20030606-branch:1.82.0.6
	cagney_convert-20030606-branchpoint:1.82
	cagney_writestrings-20030508-branch:1.80.0.4
	cagney_writestrings-20030508-branchpoint:1.80
	jimb-ppc64-linux-20030528-branch:1.82.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.82
	carlton_dictionary-20030523-merge:1.82
	cagney_fileio-20030521-branch:1.82.0.2
	cagney_fileio-20030521-branchpoint:1.82
	kettenis_i386newframe-20030517-mergepoint:1.82
	jimb-ppc64-linux-20030509-branch:1.80.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.80
	kettenis_i386newframe-20030504-mergepoint:1.75
	carlton_dictionary-20030430-merge:1.75
	kettenis_i386newframe-20030419-branch:1.74.0.6
	kettenis_i386newframe-20030419-branchpoint:1.74
	carlton_dictionary-20030416-merge:1.74
	cagney_frameaddr-20030409-mergepoint:1.74
	kettenis_i386newframe-20030406-branch:1.74.0.4
	kettenis_i386newframe-20030406-branchpoint:1.74
	cagney_frameaddr-20030403-branchpoint:1.74
	cagney_frameaddr-20030403-branch:1.74.0.2
	cagney_framebase-20030330-mergepoint:1.74
	cagney_framebase-20030326-branch:1.73.0.6
	cagney_framebase-20030326-branchpoint:1.73
	cagney_lazyid-20030317-branch:1.73.0.4
	cagney_lazyid-20030317-branchpoint:1.73
	kettenis-i386newframe-20030316-mergepoint:1.73
	offbyone-20030313-branch:1.73.0.2
	offbyone-20030313-branchpoint:1.73
	kettenis-i386newframe-20030308-branch:1.71.0.4
	kettenis-i386newframe-20030308-branchpoint:1.71
	carlton_dictionary-20030305-merge:1.71
	cagney_offbyone-20030303-branch:1.71.0.2
	cagney_offbyone-20030303-branchpoint:1.71
	carlton_dictionary-20030207-merge:1.68
	interps-20030203-mergepoint:1.68
	interps-20030202-branch:1.68.0.4
	interps-20030202-branchpoint:1.68
	cagney-unwind-20030108-branch:1.68.0.2
	cagney-unwind-20030108-branchpoint:1.68
	carlton_dictionary-20021223-merge:1.68
	gdb_5_3-2002-12-12-release:1.58
	carlton_dictionary-20021115-merge:1.68
	kseitz_interps-20021105-merge:1.60
	kseitz_interps-20021103-merge:1.60
	drow-cplus-merge-20021020:1.58
	drow-cplus-merge-20021025:1.58
	carlton_dictionary-20021025-merge:1.58
	carlton_dictionary-20021011-merge:1.58
	drow-cplus-branch:1.58.0.6
	drow-cplus-branchpoint:1.58
	kseitz_interps-20020930-merge:1.58
	carlton_dictionary-20020927-merge:1.58
	carlton_dictionary-branch:1.58.0.4
	carlton_dictionary-20020920-branchpoint:1.58
	gdb_5_3-branch:1.58.0.2
	gdb_5_3-2002-09-04-branchpoint:1.58
	kseitz_interps-20020829-merge:1.58
	cagney_sysregs-20020825-branch:1.57.0.2
	cagney_sysregs-20020825-branchpoint:1.57
	readline_4_3-import-branch:1.54.0.2
	readline_4_3-import-branchpoint:1.54
	gdb_5_2_1-2002-07-23-release:1.32
	kseitz_interps-20020528-branch:1.36.0.4
	kseitz_interps-20020528-branchpoint:1.36
	cagney_regbuf-20020515-branch:1.36.0.2
	cagney_regbuf-20020515-branchpoint:1.36
	jimb-macro-020506-branch:1.34.0.2
	jimb-macro-020506-branchpoint:1.34
	gdb_5_2-2002-04-29-release:1.32
	gdb_5_2-branch:1.32.0.2
	gdb_5_2-2002-03-03-branchpoint:1.32
	gdb_5_1_1-2002-01-24-release:1.24.4.1
	gdb_5_1_0_1-2002-01-03-release:1.24.4.1
	cygnus_cvs_20020108_pre:1.29
	gdb_5_1_0_1-2002-01-03-branchpoint:1.24.4.1
	gdb_5_1_0_1-2002-01-03-branch:1.24.4.1.0.4
	gdb_5_1-2001-11-21-release:1.24.4.1
	gdb_s390-2001-09-26-branch:1.24.4.1.0.2
	gdb_s390-2001-09-26-branchpoint:1.24.4.1
	gdb_5_1-2001-07-29-branch:1.24.0.4
	gdb_5_1-2001-07-29-branchpoint:1.24
	dberlin-typesystem-branch:1.24.0.2
	dberlin-typesystem-branchpoint:1.24
	gdb-post-ptid_t-2001-05-03:1.23
	gdb-pre-ptid_t-2001-05-03:1.22
	insight-precleanup-2001-01-01:1.12
	gdb-post-protoization-2000-07-29:1.6
	gdb-pre-protoization-2000-07-29:1.6;
locks; strict;
comment	@ * @;


1.202
date	2013.09.23.16.48.43;	author aburgess;	state Exp;
branches;
next	1.201;

1.201
date	2013.03.07.18.59.54;	author palves;	state Exp;
branches;
next	1.200;

1.200
date	2013.03.01.15.38.26;	author palves;	state Exp;
branches;
next	1.199;

1.199
date	2013.01.31.18.37.37;	author aristovski;	state Exp;
branches;
next	1.198;

1.198
date	2013.01.01.06.32.49;	author brobecke;	state Exp;
branches;
next	1.197;

1.197
date	2012.09.28.12.04.28;	author palves;	state Exp;
branches;
next	1.196;

1.196
date	2012.01.04.08.17.09;	author brobecke;	state Exp;
branches;
next	1.195;

1.195
date	2011.10.26.17.32.00;	author uweigand;	state Exp;
branches
	1.195.2.1;
next	1.194;

1.194
date	2011.10.11.18.35.25;	author davem;	state Exp;
branches;
next	1.193;

1.193
date	2011.09.17.13.29.32;	author qiyao;	state Exp;
branches;
next	1.192;

1.192
date	2011.07.22.15.31.51;	author tromey;	state Exp;
branches;
next	1.191;

1.191
date	2011.07.11.17.19.16;	author tromey;	state Exp;
branches;
next	1.190;

1.190
date	2011.04.20.17.54.08;	author palves;	state Exp;
branches;
next	1.189;

1.189
date	2011.04.20.17.01.09;	author palves;	state Exp;
branches;
next	1.188;

1.188
date	2011.03.24.11.22.03;	author palves;	state Exp;
branches
	1.188.2.1;
next	1.187;

1.187
date	2011.03.18.18.38.43;	author palves;	state Exp;
branches;
next	1.186;

1.186
date	2011.02.04.15.46.49;	author palves;	state Exp;
branches;
next	1.185;

1.185
date	2011.01.25.12.47.24;	author palves;	state Exp;
branches;
next	1.184;

1.184
date	2011.01.25.12.13.20;	author palves;	state Exp;
branches;
next	1.183;

1.183
date	2011.01.10.20.38.50;	author msnyder;	state Exp;
branches;
next	1.182;

1.182
date	2011.01.05.22.22.50;	author msnyder;	state Exp;
branches;
next	1.181;

1.181
date	2011.01.01.15.33.13;	author brobecke;	state Exp;
branches;
next	1.180;

1.180
date	2010.05.16.21.11.14;	author msnyder;	state Exp;
branches;
next	1.179;

1.179
date	2010.05.06.18.07.08;	author msnyder;	state Exp;
branches;
next	1.178;

1.178
date	2010.04.29.16.33.15;	author palves;	state Exp;
branches;
next	1.177;

1.177
date	2010.01.28.22.07.58;	author drow;	state Exp;
branches;
next	1.176;

1.176
date	2010.01.01.07.31.39;	author brobecke;	state Exp;
branches;
next	1.175;

1.175
date	2009.10.19.09.51.41;	author palves;	state Exp;
branches;
next	1.174;

1.174
date	2009.07.02.17.25.58;	author uweigand;	state Exp;
branches;
next	1.173;

1.173
date	2009.07.02.17.06.44;	author uweigand;	state Exp;
branches;
next	1.172;

1.172
date	2009.06.28.00.20.22;	author drow;	state Exp;
branches;
next	1.171;

1.171
date	2009.05.05.13.24.49;	author uweigand;	state Exp;
branches;
next	1.170;

1.170
date	2009.02.21.16.14.48;	author palves;	state Exp;
branches;
next	1.169;

1.169
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.168;

1.168
date	2008.10.30.20.35.30;	author tromey;	state Exp;
branches;
next	1.167;

1.167
date	2008.08.18.22.35.17;	author palves;	state Exp;
branches;
next	1.166;

1.166
date	2008.05.04.14.12.34;	author uweigand;	state Exp;
branches
	1.166.4.1;
next	1.165;

1.165
date	2008.02.27.01.07.42;	author drow;	state Exp;
branches;
next	1.164;

1.164
date	2008.02.18.16.37.17;	author deuling;	state Exp;
branches
	1.164.2.1;
next	1.163;

1.163
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.162;

1.162
date	2007.10.08.12.45.17;	author uweigand;	state Exp;
branches;
next	1.161;

1.161
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches;
next	1.160;

1.160
date	2007.06.21.12.10.48;	author schwab;	state Exp;
branches;
next	1.159;

1.159
date	2007.06.20.20.47.34;	author uweigand;	state Exp;
branches;
next	1.158;

1.158
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.157;

1.157
date	2007.06.16.17.16.25;	author uweigand;	state Exp;
branches;
next	1.156;

1.156
date	2007.06.15.22.45.57;	author uweigand;	state Exp;
branches;
next	1.155;

1.155
date	2007.06.15.22.44.56;	author uweigand;	state Exp;
branches;
next	1.154;

1.154
date	2007.06.09.13.49.20;	author uweigand;	state Exp;
branches;
next	1.153;

1.153
date	2007.06.09.13.42.15;	author uweigand;	state Exp;
branches;
next	1.152;

1.152
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.151;

1.151
date	2007.05.31.17.19.32;	author uweigand;	state Exp;
branches;
next	1.150;

1.150
date	2007.05.31.17.00.07;	author uweigand;	state Exp;
branches;
next	1.149;

1.149
date	2007.05.13.12.27.30;	author uweigand;	state Exp;
branches;
next	1.148;

1.148
date	2007.05.06.19.37.30;	author uweigand;	state Exp;
branches;
next	1.147;

1.147
date	2007.05.06.18.55.41;	author uweigand;	state Exp;
branches;
next	1.146;

1.146
date	2007.05.06.14.34.38;	author uweigand;	state Exp;
branches;
next	1.145;

1.145
date	2007.04.29.01.51.50;	author uweigand;	state Exp;
branches;
next	1.144;

1.144
date	2007.04.28.21.52.38;	author uweigand;	state Exp;
branches;
next	1.143;

1.143
date	2007.03.29.18.55.01;	author drow;	state Exp;
branches;
next	1.142;

1.142
date	2007.01.13.23.24.43;	author kettenis;	state Exp;
branches;
next	1.141;

1.141
date	2007.01.13.22.32.13;	author kettenis;	state Exp;
branches;
next	1.140;

1.140
date	2007.01.09.17.58.56;	author drow;	state Exp;
branches;
next	1.139;

1.139
date	2006.07.24.20.10.48;	author fred;	state Exp;
branches;
next	1.138;

1.138
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches
	1.138.14.1;
next	1.137;

1.137
date	2005.06.18.15.22.55;	author kettenis;	state Exp;
branches;
next	1.136;

1.136
date	2005.05.19.16.37.09;	author cagney;	state Exp;
branches;
next	1.135;

1.135
date	2005.05.09.21.20.34;	author cagney;	state Exp;
branches;
next	1.134;

1.134
date	2005.03.10.02.43.23;	author brobecke;	state Exp;
branches;
next	1.133;

1.133
date	2005.02.15.15.49.14;	author cagney;	state Exp;
branches;
next	1.132;

1.132
date	2005.02.14.18.10.09;	author cagney;	state Exp;
branches;
next	1.131;

1.131
date	2005.02.12.00.39.20;	author cagney;	state Exp;
branches;
next	1.130;

1.130
date	2005.02.11.18.13.52;	author cagney;	state Exp;
branches;
next	1.129;

1.129
date	2004.11.14.01.11.07;	author cagney;	state Exp;
branches;
next	1.128;

1.128
date	2004.10.11.16.35.28;	author davea;	state Exp;
branches;
next	1.127;

1.127
date	2004.08.07.16.33.54;	author cagney;	state Exp;
branches;
next	1.126;

1.126
date	2004.08.05.14.12.39;	author cagney;	state Exp;
branches;
next	1.125;

1.125
date	2004.08.04.17.50.55;	author jimb;	state Exp;
branches;
next	1.124;

1.124
date	2004.08.03.03.52.01;	author cagney;	state Exp;
branches;
next	1.123;

1.123
date	2004.08.03.02.02.23;	author cagney;	state Exp;
branches;
next	1.122;

1.122
date	2004.08.03.00.57.26;	author cagney;	state Exp;
branches;
next	1.121;

1.121
date	2004.08.02.21.58.44;	author cagney;	state Exp;
branches;
next	1.120;

1.120
date	2004.08.02.21.39.35;	author cagney;	state Exp;
branches;
next	1.119;

1.119
date	2004.08.02.21.07.17;	author cagney;	state Exp;
branches;
next	1.118;

1.118
date	2004.07.24.01.00.20;	author cagney;	state Exp;
branches;
next	1.117;

1.117
date	2004.07.22.01.31.49;	author cagney;	state Exp;
branches;
next	1.116;

1.116
date	2004.07.10.01.17.52;	author msnyder;	state Exp;
branches;
next	1.115;

1.115
date	2004.06.28.23.59.28;	author cagney;	state Exp;
branches;
next	1.114;

1.114
date	2004.05.14.07.17.45;	author jimb;	state Exp;
branches;
next	1.113;

1.113
date	2004.04.26.09.49.36;	author orjanf;	state Exp;
branches;
next	1.112;

1.112
date	2004.04.21.23.52.20;	author cagney;	state Exp;
branches;
next	1.111;

1.111
date	2004.04.17.17.31.40;	author tausq;	state Exp;
branches;
next	1.110;

1.110
date	2004.03.15.20.38.08;	author cagney;	state Exp;
branches;
next	1.109;

1.109
date	2004.02.29.17.01.38;	author drow;	state Exp;
branches
	1.109.4.1;
next	1.108;

1.108
date	2004.02.15.15.22.06;	author cagney;	state Exp;
branches
	1.108.2.1;
next	1.107;

1.107
date	2004.02.12.00.17.53;	author fnf;	state Exp;
branches;
next	1.106;

1.106
date	2004.01.17.18.24.15;	author cagney;	state Exp;
branches;
next	1.105;

1.105
date	2003.10.24.17.37.03;	author cagney;	state Exp;
branches;
next	1.104;

1.104
date	2003.10.02.20.28.30;	author cagney;	state Exp;
branches;
next	1.103;

1.103
date	2003.09.30.19.12.19;	author cagney;	state Exp;
branches;
next	1.102;

1.102
date	2003.09.30.13.29.43;	author cagney;	state Exp;
branches;
next	1.101;

1.101
date	2003.09.27.19.32.53;	author kettenis;	state Exp;
branches;
next	1.100;

1.100
date	2003.09.21.01.26.45;	author cagney;	state Exp;
branches;
next	1.99;

1.99
date	2003.09.17.15.42.21;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2003.09.17.14.24.30;	author cagney;	state Exp;
branches;
next	1.97;

1.97
date	2003.08.29.13.04.44;	author kettenis;	state Exp;
branches;
next	1.96;

1.96
date	2003.08.29.11.48.04;	author kettenis;	state Exp;
branches;
next	1.95;

1.95
date	2003.08.29.09.59.28;	author kettenis;	state Exp;
branches;
next	1.94;

1.94
date	2003.08.04.22.24.44;	author cagney;	state Exp;
branches;
next	1.93;

1.93
date	2003.08.04.21.12.46;	author cagney;	state Exp;
branches;
next	1.92;

1.92
date	2003.08.04.20.34.10;	author cagney;	state Exp;
branches;
next	1.91;

1.91
date	2003.07.28.15.41.19;	author cagney;	state Exp;
branches;
next	1.90;

1.90
date	2003.07.09.14.35.26;	author cagney;	state Exp;
branches;
next	1.89;

1.89
date	2003.07.03.14.34.29;	author cagney;	state Exp;
branches;
next	1.88;

1.88
date	2003.06.16.13.19.36;	author cagney;	state Exp;
branches
	1.88.2.1;
next	1.87;

1.87
date	2003.06.09.01.02.06;	author cagney;	state Exp;
branches;
next	1.86;

1.86
date	2003.06.08.18.27.14;	author cagney;	state Exp;
branches;
next	1.85;

1.85
date	2003.06.07.22.38.55;	author cagney;	state Exp;
branches;
next	1.84;

1.84
date	2003.06.07.18.08.24;	author cagney;	state Exp;
branches;
next	1.83;

1.83
date	2003.06.07.16.23.12;	author cagney;	state Exp;
branches;
next	1.82;

1.82
date	2003.05.17.05.59.58;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2003.05.15.18.01.50;	author cagney;	state Exp;
branches;
next	1.80;

1.80
date	2003.05.08.22.33.14;	author cagney;	state Exp;
branches
	1.80.4.1;
next	1.79;

1.79
date	2003.05.08.20.52.48;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2003.05.08.20.38.07;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2003.05.08.18.46.48;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2003.05.04.17.34.50;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2003.04.29.01.49.47;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2003.03.27.15.29.44;	author cagney;	state Exp;
branches
	1.74.6.1;
next	1.73;

1.73
date	2003.03.12.20.50.13;	author cagney;	state Exp;
branches
	1.73.6.1;
next	1.72;

1.72
date	2003.03.10.19.08.47;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2003.03.03.20.50.19;	author cagney;	state Exp;
branches
	1.71.2.1
	1.71.4.1;
next	1.70;

1.70
date	2003.03.01.17.59.12;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2003.02.28.17.47.42;	author cagney;	state Exp;
branches;
next	1.68;

1.68
date	2002.11.14.20.37.28;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2002.11.14.00.25.03;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2002.11.13.17.59.40;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2002.11.13.16.57.36;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2002.11.13.16.07.03;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2002.11.07.21.43.23;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2002.11.07.15.31.31;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2002.11.07.02.40.28;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2002.11.02.15.13.34;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2002.08.25.23.44.30;	author kettenis;	state Exp;
branches
	1.58.4.1
	1.58.6.1;
next	1.57;

1.57
date	2002.08.25.18.47.16;	author cagney;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2002.08.25.15.36.11;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2002.08.25.14.44.04;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2002.08.19.00.43.41;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2002.08.13.23.06.40;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2002.08.13.14.32.28;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2002.08.13.13.58.50;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2002.08.10.02.00.16;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2002.08.10.00.36.46;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2002.08.07.16.01.58;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2002.08.02.20.51.21;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2002.08.02.19.06.21;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2002.08.02.18.08.31;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2002.08.02.14.48.19;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2002.07.29.19.54.42;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2002.07.24.19.43.43;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2002.07.24.14.38.55;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2002.07.03.20.36.54;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.27.18.28.23;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2002.06.22.21.18.32;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.20.03.13.51;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.15.01.01.56;	author cagney;	state Exp;
branches
	1.36.2.1
	1.36.4.1;
next	1.35;

1.35
date	2002.05.13.17.20.58;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.06.00.02.50;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.21.02.13.05;	author hunt;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.06.03.16.38;	author msnyder;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.29.20.24.27;	author msnyder;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.15.02.06.46;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.07.15.00.59;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.06.20.49.47;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.15.06.43.10;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.24.05.11.07;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.10.21.52.17;	author msnyder;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.15.23.50.46;	author cagney;	state Exp;
branches
	1.24.4.1;
next	1.23;

1.23
date	2001.05.04.04.15.26;	author kevinb;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.27.20.36.24;	author jtc;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.24.01.26.09;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.13.23.31.14;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.06.08.21.11;	author kevinb;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.20.22.39.03;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.06.20.05.41;	author msnyder;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.09.00.12.48;	author nsd;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.09.00.11.28;	author nsd;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.17.01.30.53;	author msnyder;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.30.21.50.57;	author jtc;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.01.17.59.26;	author msnyder;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.25.21.03.00;	author taylor;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.11.19.09.55;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.11.03.19.22;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.24.14.35.14;	author ezannoni;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.21.22.25.52;	author ezannoni;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.12.22.01.17;	author msnyder;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.11.05.42.25;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.10.06.16.51;	author msnyder;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.10.06.14.40;	author msnyder;	state Exp;
branches;
next	;

1.195.2.1
date	2012.01.06.04.43.26;	author brobecke;	state Exp;
branches;
next	;

1.188.2.1
date	2011.04.20.17.04.32;	author palves;	state Exp;
branches;
next	;

1.166.4.1
date	2008.07.20.14.30.11;	author teawater;	state Exp;
branches;
next	1.166.4.2;

1.166.4.2
date	2008.10.06.17.52.17;	author msnyder;	state Exp;
branches;
next	;

1.164.2.1
date	2008.03.04.20.01.21;	author brobecke;	state Exp;
branches;
next	;

1.138.14.1
date	2006.08.28.07.48.47;	author nickrob;	state Exp;
branches;
next	;

1.109.4.1
date	2004.03.09.22.59.00;	author cagney;	state Exp;
branches;
next	1.109.4.2;

1.109.4.2
date	2004.03.16.16.05.55;	author cagney;	state Exp;
branches;
next	;

1.108.2.1
date	2004.03.27.17.37.50;	author drow;	state Exp;
branches;
next	1.108.2.2;

1.108.2.2
date	2004.09.16.17.01.17;	author drow;	state Exp;
branches;
next	;

1.88.2.1
date	2003.07.03.14.48.58;	author cagney;	state Exp;
branches;
next	1.88.2.2;

1.88.2.2
date	2003.07.31.21.00.34;	author cagney;	state Exp;
branches;
next	;

1.80.4.1
date	2003.06.03.20.54.38;	author cagney;	state Exp;
branches;
next	;

1.74.6.1
date	2003.05.04.11.37.45;	author kettenis;	state Exp;
branches;
next	1.74.6.2;

1.74.6.2
date	2003.05.18.09.44.19;	author kettenis;	state Exp;
branches;
next	;

1.73.6.1
date	2003.03.30.16.35.22;	author cagney;	state Exp;
branches;
next	;

1.71.2.1
date	2003.03.07.14.24.29;	author cagney;	state Exp;
branches;
next	1.71.2.2;

1.71.2.2
date	2003.03.10.21.00.55;	author cagney;	state Exp;
branches;
next	;

1.71.4.1
date	2003.03.16.14.01.50;	author kettenis;	state Exp;
branches;
next	;

1.58.4.1
date	2002.11.15.19.18.52;	author carlton;	state Exp;
branches;
next	1.58.4.2;

1.58.4.2
date	2003.03.06.00.56.31;	author carlton;	state Exp;
branches;
next	1.58.4.3;

1.58.4.3
date	2003.04.16.19.56.54;	author carlton;	state Exp;
branches;
next	1.58.4.4;

1.58.4.4
date	2003.05.01.00.46.52;	author carlton;	state Exp;
branches;
next	1.58.4.5;

1.58.4.5
date	2003.05.23.18.40.43;	author carlton;	state Exp;
branches;
next	1.58.4.6;

1.58.4.6
date	2003.06.27.21.50.07;	author carlton;	state Exp;
branches;
next	1.58.4.7;

1.58.4.7
date	2003.08.05.17.13.12;	author carlton;	state Exp;
branches;
next	1.58.4.8;

1.58.4.8
date	2003.09.17.21.28.28;	author carlton;	state Exp;
branches;
next	1.58.4.9;

1.58.4.9
date	2003.11.11.23.50.52;	author carlton;	state Exp;
branches;
next	1.58.4.10;

1.58.4.10
date	2004.01.26.19.11.29;	author carlton;	state Exp;
branches;
next	;

1.58.6.1
date	2003.12.14.20.27.28;	author drow;	state Exp;
branches;
next	1.58.6.2;

1.58.6.2
date	2004.02.09.19.43.46;	author drow;	state Exp;
branches;
next	;

1.57.2.1
date	2002.08.25.20.26.13;	author cagney;	state Exp;
branches;
next	1.57.2.2;

1.57.2.2
date	2002.08.26.19.57.39;	author cagney;	state Exp;
branches;
next	1.57.2.3;

1.57.2.3
date	2002.09.19.16.49.55;	author cagney;	state Exp;
branches;
next	;

1.36.2.1
date	2002.05.16.00.54.56;	author cagney;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2002.05.16.19.08.01;	author cagney;	state Exp;
branches;
next	1.36.2.3;

1.36.2.3
date	2002.05.17.15.06.31;	author cagney;	state Exp;
branches;
next	1.36.2.4;

1.36.2.4
date	2002.05.17.16.17.30;	author cagney;	state Exp;
branches;
next	1.36.2.5;

1.36.2.5
date	2002.05.23.18.03.25;	author cagney;	state Exp;
branches;
next	1.36.2.6;

1.36.2.6
date	2002.06.15.19.32.43;	author cagney;	state Exp;
branches;
next	1.36.2.7;

1.36.2.7
date	2002.06.21.16.19.28;	author cagney;	state Exp;
branches;
next	1.36.2.8;

1.36.2.8
date	2002.06.21.16.46.52;	author cagney;	state Exp;
branches;
next	1.36.2.9;

1.36.2.9
date	2002.06.25.20.02.41;	author cagney;	state Exp;
branches;
next	1.36.2.10;

1.36.2.10
date	2002.06.28.23.19.26;	author cagney;	state Exp;
branches;
next	;

1.36.4.1
date	2002.07.22.21.47.01;	author kseitz;	state Exp;
branches;
next	1.36.4.2;

1.36.4.2
date	2002.08.09.18.34.26;	author kseitz;	state Exp;
branches;
next	1.36.4.3;

1.36.4.3
date	2002.08.30.22.52.45;	author kseitz;	state Exp;
branches;
next	1.36.4.4;

1.36.4.4
date	2002.11.04.00.17.32;	author ezannoni;	state Exp;
branches;
next	;

1.24.4.1
date	2001.08.27.01.59.34;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.202
log
@In regcache use print_hex_chars.

  https://sourceware.org/ml/gdb-patches/2013-09/msg00815.html

gdb/ChangeLog

        * regcache.c: Add include of valprint.h.
        (dump_endian_bytes): Delete.
        (regcache_dump): Use print_hex_chars not dump_endian_bytes.
@
text
@/* Cache and manage the values of registers for GDB, the GNU debugger.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "inferior.h"
#include "target.h"
#include "gdbarch.h"
#include "gdbcmd.h"
#include "regcache.h"
#include "reggroups.h"
#include "gdb_assert.h"
#include "gdb_string.h"
#include "gdbcmd.h"		/* For maintenanceprintlist.  */
#include "observer.h"
#include "exceptions.h"
#include "remote.h"
#include "valprint.h"

/*
 * DATA STRUCTURE
 *
 * Here is the actual register cache.
 */

/* Per-architecture object describing the layout of a register cache.
   Computed once when the architecture is created.  */

struct gdbarch_data *regcache_descr_handle;

struct regcache_descr
{
  /* The architecture this descriptor belongs to.  */
  struct gdbarch *gdbarch;

  /* The raw register cache.  Each raw (or hard) register is supplied
     by the target interface.  The raw cache should not contain
     redundant information - if the PC is constructed from two
     registers then those registers and not the PC lives in the raw
     cache.  */
  int nr_raw_registers;
  long sizeof_raw_registers;
  long sizeof_raw_register_status;

  /* The cooked register space.  Each cooked register in the range
     [0..NR_RAW_REGISTERS) is direct-mapped onto the corresponding raw
     register.  The remaining [NR_RAW_REGISTERS
     .. NR_COOKED_REGISTERS) (a.k.a. pseudo registers) are mapped onto
     both raw registers and memory by the architecture methods
     gdbarch_pseudo_register_read and gdbarch_pseudo_register_write.  */
  int nr_cooked_registers;
  long sizeof_cooked_registers;
  long sizeof_cooked_register_status;

  /* Offset and size (in 8 bit bytes), of each register in the
     register cache.  All registers (including those in the range
     [NR_RAW_REGISTERS .. NR_COOKED_REGISTERS) are given an
     offset.  */
  long *register_offset;
  long *sizeof_register;

  /* Cached table containing the type of each register.  */
  struct type **register_type;
};

static void *
init_regcache_descr (struct gdbarch *gdbarch)
{
  int i;
  struct regcache_descr *descr;
  gdb_assert (gdbarch != NULL);

  /* Create an initial, zero filled, table.  */
  descr = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct regcache_descr);
  descr->gdbarch = gdbarch;

  /* Total size of the register space.  The raw registers are mapped
     directly onto the raw register cache while the pseudo's are
     either mapped onto raw-registers or memory.  */
  descr->nr_cooked_registers = gdbarch_num_regs (gdbarch)
			       + gdbarch_num_pseudo_regs (gdbarch);
  descr->sizeof_cooked_register_status
    = gdbarch_num_regs (gdbarch) + gdbarch_num_pseudo_regs (gdbarch);

  /* Fill in a table of register types.  */
  descr->register_type
    = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers,
			      struct type *);
  for (i = 0; i < descr->nr_cooked_registers; i++)
    descr->register_type[i] = gdbarch_register_type (gdbarch, i);

  /* Construct a strictly RAW register cache.  Don't allow pseudo's
     into the register cache.  */
  descr->nr_raw_registers = gdbarch_num_regs (gdbarch);
  descr->sizeof_raw_register_status = gdbarch_num_regs (gdbarch);

  /* Lay out the register cache.

     NOTE: cagney/2002-05-22: Only register_type() is used when
     constructing the register cache.  It is assumed that the
     register's raw size, virtual size and type length are all the
     same.  */

  {
    long offset = 0;

    descr->sizeof_register
      = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, long);
    descr->register_offset
      = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, long);
    for (i = 0; i < descr->nr_raw_registers; i++)
      {
	descr->sizeof_register[i] = TYPE_LENGTH (descr->register_type[i]);
	descr->register_offset[i] = offset;
	offset += descr->sizeof_register[i];
	gdb_assert (MAX_REGISTER_SIZE >= descr->sizeof_register[i]);
      }
    /* Set the real size of the raw register cache buffer.  */
    descr->sizeof_raw_registers = offset;

    for (; i < descr->nr_cooked_registers; i++)
      {
	descr->sizeof_register[i] = TYPE_LENGTH (descr->register_type[i]);
	descr->register_offset[i] = offset;
	offset += descr->sizeof_register[i];
	gdb_assert (MAX_REGISTER_SIZE >= descr->sizeof_register[i]);
      }
    /* Set the real size of the readonly register cache buffer.  */
    descr->sizeof_cooked_registers = offset;
  }

  return descr;
}

static struct regcache_descr *
regcache_descr (struct gdbarch *gdbarch)
{
  return gdbarch_data (gdbarch, regcache_descr_handle);
}

/* Utility functions returning useful register attributes stored in
   the regcache descr.  */

struct type *
register_type (struct gdbarch *gdbarch, int regnum)
{
  struct regcache_descr *descr = regcache_descr (gdbarch);

  gdb_assert (regnum >= 0 && regnum < descr->nr_cooked_registers);
  return descr->register_type[regnum];
}

/* Utility functions returning useful register attributes stored in
   the regcache descr.  */

int
register_size (struct gdbarch *gdbarch, int regnum)
{
  struct regcache_descr *descr = regcache_descr (gdbarch);
  int size;

  gdb_assert (regnum >= 0
	      && regnum < (gdbarch_num_regs (gdbarch)
			   + gdbarch_num_pseudo_regs (gdbarch)));
  size = descr->sizeof_register[regnum];
  return size;
}

/* The register cache for storing raw register values.  */

struct regcache
{
  struct regcache_descr *descr;

  /* The address space of this register cache (for registers where it
     makes sense, like PC or SP).  */
  struct address_space *aspace;

  /* The register buffers.  A read-only register cache can hold the
     full [0 .. gdbarch_num_regs + gdbarch_num_pseudo_regs) while a read/write
     register cache can only hold [0 .. gdbarch_num_regs).  */
  gdb_byte *registers;
  /* Register cache status.  */
  signed char *register_status;
  /* Is this a read-only cache?  A read-only cache is used for saving
     the target's register state (e.g, across an inferior function
     call or just before forcing a function return).  A read-only
     cache can only be updated via the methods regcache_dup() and
     regcache_cpy().  The actual contents are determined by the
     reggroup_save and reggroup_restore methods.  */
  int readonly_p;
  /* If this is a read-write cache, which thread's registers is
     it connected to?  */
  ptid_t ptid;
};

static struct regcache *
regcache_xmalloc_1 (struct gdbarch *gdbarch, struct address_space *aspace,
		    int readonly_p)
{
  struct regcache_descr *descr;
  struct regcache *regcache;

  gdb_assert (gdbarch != NULL);
  descr = regcache_descr (gdbarch);
  regcache = XMALLOC (struct regcache);
  regcache->descr = descr;
  regcache->readonly_p = readonly_p;
  if (readonly_p)
    {
      regcache->registers
	= XCALLOC (descr->sizeof_cooked_registers, gdb_byte);
      regcache->register_status
	= XCALLOC (descr->sizeof_cooked_register_status, signed char);
    }
  else
    {
      regcache->registers
	= XCALLOC (descr->sizeof_raw_registers, gdb_byte);
      regcache->register_status
	= XCALLOC (descr->sizeof_raw_register_status, signed char);
    }
  regcache->aspace = aspace;
  regcache->ptid = minus_one_ptid;
  return regcache;
}

struct regcache *
regcache_xmalloc (struct gdbarch *gdbarch, struct address_space *aspace)
{
  return regcache_xmalloc_1 (gdbarch, aspace, 1);
}

void
regcache_xfree (struct regcache *regcache)
{
  if (regcache == NULL)
    return;
  xfree (regcache->registers);
  xfree (regcache->register_status);
  xfree (regcache);
}

static void
do_regcache_xfree (void *data)
{
  regcache_xfree (data);
}

struct cleanup *
make_cleanup_regcache_xfree (struct regcache *regcache)
{
  return make_cleanup (do_regcache_xfree, regcache);
}

/* Return REGCACHE's architecture.  */

struct gdbarch *
get_regcache_arch (const struct regcache *regcache)
{
  return regcache->descr->gdbarch;
}

struct address_space *
get_regcache_aspace (const struct regcache *regcache)
{
  return regcache->aspace;
}

/* Return  a pointer to register REGNUM's buffer cache.  */

static gdb_byte *
register_buffer (const struct regcache *regcache, int regnum)
{
  return regcache->registers + regcache->descr->register_offset[regnum];
}

void
regcache_save (struct regcache *dst, regcache_cooked_read_ftype *cooked_read,
	       void *src)
{
  struct gdbarch *gdbarch = dst->descr->gdbarch;
  gdb_byte buf[MAX_REGISTER_SIZE];
  int regnum;

  /* The DST should be `read-only', if it wasn't then the save would
     end up trying to write the register values back out to the
     target.  */
  gdb_assert (dst->readonly_p);
  /* Clear the dest.  */
  memset (dst->registers, 0, dst->descr->sizeof_cooked_registers);
  memset (dst->register_status, 0,
	  dst->descr->sizeof_cooked_register_status);
  /* Copy over any registers (identified by their membership in the
     save_reggroup) and mark them as valid.  The full [0 .. gdbarch_num_regs +
     gdbarch_num_pseudo_regs) range is checked since some architectures need
     to save/restore `cooked' registers that live in memory.  */
  for (regnum = 0; regnum < dst->descr->nr_cooked_registers; regnum++)
    {
      if (gdbarch_register_reggroup_p (gdbarch, regnum, save_reggroup))
	{
	  enum register_status status = cooked_read (src, regnum, buf);

	  if (status == REG_VALID)
	    memcpy (register_buffer (dst, regnum), buf,
		    register_size (gdbarch, regnum));
	  else
	    {
	      gdb_assert (status != REG_UNKNOWN);

	      memset (register_buffer (dst, regnum), 0,
		      register_size (gdbarch, regnum));
	    }
	  dst->register_status[regnum] = status;
	}
    }
}

static void
regcache_restore (struct regcache *dst,
		  regcache_cooked_read_ftype *cooked_read,
		  void *cooked_read_context)
{
  struct gdbarch *gdbarch = dst->descr->gdbarch;
  gdb_byte buf[MAX_REGISTER_SIZE];
  int regnum;

  /* The dst had better not be read-only.  If it is, the `restore'
     doesn't make much sense.  */
  gdb_assert (!dst->readonly_p);
  /* Copy over any registers, being careful to only restore those that
     were both saved and need to be restored.  The full [0 .. gdbarch_num_regs
     + gdbarch_num_pseudo_regs) range is checked since some architectures need
     to save/restore `cooked' registers that live in memory.  */
  for (regnum = 0; regnum < dst->descr->nr_cooked_registers; regnum++)
    {
      if (gdbarch_register_reggroup_p (gdbarch, regnum, restore_reggroup))
	{
	  enum register_status status;

	  status = cooked_read (cooked_read_context, regnum, buf);
	  if (status == REG_VALID)
	    regcache_cooked_write (dst, regnum, buf);
	}
    }
}

static enum register_status
do_cooked_read (void *src, int regnum, gdb_byte *buf)
{
  struct regcache *regcache = src;

  return regcache_cooked_read (regcache, regnum, buf);
}

void
regcache_cpy (struct regcache *dst, struct regcache *src)
{
  gdb_assert (src != NULL && dst != NULL);
  gdb_assert (src->descr->gdbarch == dst->descr->gdbarch);
  gdb_assert (src != dst);
  gdb_assert (src->readonly_p || dst->readonly_p);

  if (!src->readonly_p)
    regcache_save (dst, do_cooked_read, src);
  else if (!dst->readonly_p)
    regcache_restore (dst, do_cooked_read, src);
  else
    regcache_cpy_no_passthrough (dst, src);
}

void
regcache_cpy_no_passthrough (struct regcache *dst, struct regcache *src)
{
  gdb_assert (src != NULL && dst != NULL);
  gdb_assert (src->descr->gdbarch == dst->descr->gdbarch);
  /* NOTE: cagney/2002-05-17: Don't let the caller do a no-passthrough
     move of data into a thread's regcache.  Doing this would be silly
     - it would mean that regcache->register_status would be
     completely invalid.  */
  gdb_assert (dst->readonly_p && src->readonly_p);

  memcpy (dst->registers, src->registers,
	  dst->descr->sizeof_cooked_registers);
  memcpy (dst->register_status, src->register_status,
	  dst->descr->sizeof_cooked_register_status);
}

struct regcache *
regcache_dup (struct regcache *src)
{
  struct regcache *newbuf;

  newbuf = regcache_xmalloc (src->descr->gdbarch, get_regcache_aspace (src));
  regcache_cpy (newbuf, src);
  return newbuf;
}

enum register_status
regcache_register_status (const struct regcache *regcache, int regnum)
{
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0);
  if (regcache->readonly_p)
    gdb_assert (regnum < regcache->descr->nr_cooked_registers);
  else
    gdb_assert (regnum < regcache->descr->nr_raw_registers);

  return regcache->register_status[regnum];
}

void
regcache_invalidate (struct regcache *regcache, int regnum)
{
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0);
  gdb_assert (!regcache->readonly_p);
  gdb_assert (regnum < regcache->descr->nr_raw_registers);
  regcache->register_status[regnum] = REG_UNKNOWN;
}


/* Global structure containing the current regcache.  */

/* NOTE: this is a write-through cache.  There is no "dirty" bit for
   recording if the register values have been changed (eg. by the
   user).  Therefore all registers must be written back to the
   target when appropriate.  */

struct regcache_list
{
  struct regcache *regcache;
  struct regcache_list *next;
};

static struct regcache_list *current_regcache;

struct regcache *
get_thread_arch_aspace_regcache (ptid_t ptid, struct gdbarch *gdbarch,
				 struct address_space *aspace)
{
  struct regcache_list *list;
  struct regcache *new_regcache;

  for (list = current_regcache; list; list = list->next)
    if (ptid_equal (list->regcache->ptid, ptid)
	&& get_regcache_arch (list->regcache) == gdbarch)
      return list->regcache;

  new_regcache = regcache_xmalloc_1 (gdbarch, aspace, 0);
  new_regcache->ptid = ptid;

  list = xmalloc (sizeof (struct regcache_list));
  list->regcache = new_regcache;
  list->next = current_regcache;
  current_regcache = list;

  return new_regcache;
}

struct regcache *
get_thread_arch_regcache (ptid_t ptid, struct gdbarch *gdbarch)
{
  struct address_space *aspace;

  /* For the benefit of "maint print registers" & co when debugging an
     executable, allow dumping the regcache even when there is no
     thread selected (target_thread_address_space internal-errors if
     no address space is found).  Note that normal user commands will
     fail higher up on the call stack due to no
     target_has_registers.  */
  aspace = (ptid_equal (null_ptid, ptid)
	    ? NULL
	    : target_thread_address_space (ptid));

  return get_thread_arch_aspace_regcache  (ptid, gdbarch, aspace);
}

static ptid_t current_thread_ptid;
static struct gdbarch *current_thread_arch;

struct regcache *
get_thread_regcache (ptid_t ptid)
{
  if (!current_thread_arch || !ptid_equal (current_thread_ptid, ptid))
    {
      current_thread_ptid = ptid;
      current_thread_arch = target_thread_architecture (ptid);
    }

  return get_thread_arch_regcache (ptid, current_thread_arch);
}

struct regcache *
get_current_regcache (void)
{
  return get_thread_regcache (inferior_ptid);
}


/* Observer for the target_changed event.  */

static void
regcache_observer_target_changed (struct target_ops *target)
{
  registers_changed ();
}

/* Update global variables old ptids to hold NEW_PTID if they were
   holding OLD_PTID.  */
static void
regcache_thread_ptid_changed (ptid_t old_ptid, ptid_t new_ptid)
{
  struct regcache_list *list;

  for (list = current_regcache; list; list = list->next)
    if (ptid_equal (list->regcache->ptid, old_ptid))
      list->regcache->ptid = new_ptid;
}

/* Low level examining and depositing of registers.

   The caller is responsible for making sure that the inferior is
   stopped before calling the fetching routines, or it will get
   garbage.  (a change from GDB version 3, in which the caller got the
   value from the last stop).  */

/* REGISTERS_CHANGED ()

   Indicate that registers may have changed, so invalidate the cache.  */

void
registers_changed_ptid (ptid_t ptid)
{
  struct regcache_list *list, **list_link;

  list = current_regcache;
  list_link = &current_regcache;
  while (list)
    {
      if (ptid_match (list->regcache->ptid, ptid))
	{
	  struct regcache_list *dead = list;

	  *list_link = list->next;
	  regcache_xfree (list->regcache);
	  list = *list_link;
	  xfree (dead);
	  continue;
	}

      list_link = &list->next;
      list = *list_link;
    }

  if (ptid_match (current_thread_ptid, ptid))
    {
      current_thread_ptid = null_ptid;
      current_thread_arch = NULL;
    }

  if (ptid_match (inferior_ptid, ptid))
    {
      /* We just deleted the regcache of the current thread.  Need to
	 forget about any frames we have cached, too.  */
      reinit_frame_cache ();
    }
}

void
registers_changed (void)
{
  registers_changed_ptid (minus_one_ptid);

  /* Force cleanup of any alloca areas if using C alloca instead of
     a builtin alloca.  This particular call is used to clean up
     areas allocated by low level target code which may build up
     during lengthy interactions between gdb and the target before
     gdb gives control to the user (ie watchpoints).  */
  alloca (0);
}

enum register_status
regcache_raw_read (struct regcache *regcache, int regnum, gdb_byte *buf)
{
  gdb_assert (regcache != NULL && buf != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  /* Make certain that the register cache is up-to-date with respect
     to the current thread.  This switching shouldn't be necessary
     only there is still only one target side register cache.  Sigh!
     On the bright side, at least there is a regcache object.  */
  if (!regcache->readonly_p
      && regcache_register_status (regcache, regnum) == REG_UNKNOWN)
    {
      struct cleanup *old_chain = save_inferior_ptid ();

      inferior_ptid = regcache->ptid;
      target_fetch_registers (regcache, regnum);
      do_cleanups (old_chain);

      /* A number of targets can't access the whole set of raw
	 registers (because the debug API provides no means to get at
	 them).  */
      if (regcache->register_status[regnum] == REG_UNKNOWN)
	regcache->register_status[regnum] = REG_UNAVAILABLE;
    }

  if (regcache->register_status[regnum] != REG_VALID)
    memset (buf, 0, regcache->descr->sizeof_register[regnum]);
  else
    memcpy (buf, register_buffer (regcache, regnum),
	    regcache->descr->sizeof_register[regnum]);

  return regcache->register_status[regnum];
}

enum register_status
regcache_raw_read_signed (struct regcache *regcache, int regnum, LONGEST *val)
{
  gdb_byte *buf;
  enum register_status status;

  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  status = regcache_raw_read (regcache, regnum, buf);
  if (status == REG_VALID)
    *val = extract_signed_integer
      (buf, regcache->descr->sizeof_register[regnum],
       gdbarch_byte_order (regcache->descr->gdbarch));
  else
    *val = 0;
  return status;
}

enum register_status
regcache_raw_read_unsigned (struct regcache *regcache, int regnum,
			    ULONGEST *val)
{
  gdb_byte *buf;
  enum register_status status;

  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  status = regcache_raw_read (regcache, regnum, buf);
  if (status == REG_VALID)
    *val = extract_unsigned_integer
      (buf, regcache->descr->sizeof_register[regnum],
       gdbarch_byte_order (regcache->descr->gdbarch));
  else
    *val = 0;
  return status;
}

void
regcache_raw_write_signed (struct regcache *regcache, int regnum, LONGEST val)
{
  void *buf;

  gdb_assert (regcache != NULL);
  gdb_assert (regnum >=0 && regnum < regcache->descr->nr_raw_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  store_signed_integer (buf, regcache->descr->sizeof_register[regnum],
			gdbarch_byte_order (regcache->descr->gdbarch), val);
  regcache_raw_write (regcache, regnum, buf);
}

void
regcache_raw_write_unsigned (struct regcache *regcache, int regnum,
			     ULONGEST val)
{
  void *buf;

  gdb_assert (regcache != NULL);
  gdb_assert (regnum >=0 && regnum < regcache->descr->nr_raw_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  store_unsigned_integer (buf, regcache->descr->sizeof_register[regnum],
			  gdbarch_byte_order (regcache->descr->gdbarch), val);
  regcache_raw_write (regcache, regnum, buf);
}

enum register_status
regcache_cooked_read (struct regcache *regcache, int regnum, gdb_byte *buf)
{
  gdb_assert (regnum >= 0);
  gdb_assert (regnum < regcache->descr->nr_cooked_registers);
  if (regnum < regcache->descr->nr_raw_registers)
    return regcache_raw_read (regcache, regnum, buf);
  else if (regcache->readonly_p
	   && regcache->register_status[regnum] != REG_UNKNOWN)
    {
      /* Read-only register cache, perhaps the cooked value was
	 cached?  */
      if (regcache->register_status[regnum] == REG_VALID)
	memcpy (buf, register_buffer (regcache, regnum),
		regcache->descr->sizeof_register[regnum]);
      else
	memset (buf, 0, regcache->descr->sizeof_register[regnum]);

      return regcache->register_status[regnum];
    }
  else if (gdbarch_pseudo_register_read_value_p (regcache->descr->gdbarch))
    {
      struct value *mark, *computed;
      enum register_status result = REG_VALID;

      mark = value_mark ();

      computed = gdbarch_pseudo_register_read_value (regcache->descr->gdbarch,
						     regcache, regnum);
      if (value_entirely_available (computed))
	memcpy (buf, value_contents_raw (computed),
		regcache->descr->sizeof_register[regnum]);
      else
	{
	  memset (buf, 0, regcache->descr->sizeof_register[regnum]);
	  result = REG_UNAVAILABLE;
	}

      value_free_to_mark (mark);

      return result;
    }
  else
    return gdbarch_pseudo_register_read (regcache->descr->gdbarch, regcache,
					 regnum, buf);
}

struct value *
regcache_cooked_read_value (struct regcache *regcache, int regnum)
{
  gdb_assert (regnum >= 0);
  gdb_assert (regnum < regcache->descr->nr_cooked_registers);

  if (regnum < regcache->descr->nr_raw_registers
      || (regcache->readonly_p
	  && regcache->register_status[regnum] != REG_UNKNOWN)
      || !gdbarch_pseudo_register_read_value_p (regcache->descr->gdbarch))
    {
      struct value *result;

      result = allocate_value (register_type (regcache->descr->gdbarch,
					      regnum));
      VALUE_LVAL (result) = lval_register;
      VALUE_REGNUM (result) = regnum;

      /* It is more efficient in general to do this delegation in this
	 direction than in the other one, even though the value-based
	 API is preferred.  */
      if (regcache_cooked_read (regcache, regnum,
				value_contents_raw (result)) == REG_UNAVAILABLE)
	mark_value_bytes_unavailable (result, 0,
				      TYPE_LENGTH (value_type (result)));

      return result;
    }
  else
    return gdbarch_pseudo_register_read_value (regcache->descr->gdbarch,
					       regcache, regnum);
}

enum register_status
regcache_cooked_read_signed (struct regcache *regcache, int regnum,
			     LONGEST *val)
{
  enum register_status status;
  gdb_byte *buf;

  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_cooked_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  status = regcache_cooked_read (regcache, regnum, buf);
  if (status == REG_VALID)
    *val = extract_signed_integer
      (buf, regcache->descr->sizeof_register[regnum],
       gdbarch_byte_order (regcache->descr->gdbarch));
  else
    *val = 0;
  return status;
}

enum register_status
regcache_cooked_read_unsigned (struct regcache *regcache, int regnum,
			       ULONGEST *val)
{
  enum register_status status;
  gdb_byte *buf;

  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_cooked_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  status = regcache_cooked_read (regcache, regnum, buf);
  if (status == REG_VALID)
    *val = extract_unsigned_integer
      (buf, regcache->descr->sizeof_register[regnum],
       gdbarch_byte_order (regcache->descr->gdbarch));
  else
    *val = 0;
  return status;
}

void
regcache_cooked_write_signed (struct regcache *regcache, int regnum,
			      LONGEST val)
{
  void *buf;

  gdb_assert (regcache != NULL);
  gdb_assert (regnum >=0 && regnum < regcache->descr->nr_cooked_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  store_signed_integer (buf, regcache->descr->sizeof_register[regnum],
			gdbarch_byte_order (regcache->descr->gdbarch), val);
  regcache_cooked_write (regcache, regnum, buf);
}

void
regcache_cooked_write_unsigned (struct regcache *regcache, int regnum,
				ULONGEST val)
{
  void *buf;

  gdb_assert (regcache != NULL);
  gdb_assert (regnum >=0 && regnum < regcache->descr->nr_cooked_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  store_unsigned_integer (buf, regcache->descr->sizeof_register[regnum],
			  gdbarch_byte_order (regcache->descr->gdbarch), val);
  regcache_cooked_write (regcache, regnum, buf);
}

void
regcache_raw_write (struct regcache *regcache, int regnum,
		    const gdb_byte *buf)
{
  struct cleanup *old_chain;

  gdb_assert (regcache != NULL && buf != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  gdb_assert (!regcache->readonly_p);

  /* On the sparc, writing %g0 is a no-op, so we don't even want to
     change the registers array if something writes to this register.  */
  if (gdbarch_cannot_store_register (get_regcache_arch (regcache), regnum))
    return;

  /* If we have a valid copy of the register, and new value == old
     value, then don't bother doing the actual store.  */
  if (regcache_register_status (regcache, regnum) == REG_VALID
      && (memcmp (register_buffer (regcache, regnum), buf,
		  regcache->descr->sizeof_register[regnum]) == 0))
    return;

  old_chain = save_inferior_ptid ();
  inferior_ptid = regcache->ptid;

  target_prepare_to_store (regcache);
  memcpy (register_buffer (regcache, regnum), buf,
	  regcache->descr->sizeof_register[regnum]);
  regcache->register_status[regnum] = REG_VALID;
  target_store_registers (regcache, regnum);

  do_cleanups (old_chain);
}

void
regcache_cooked_write (struct regcache *regcache, int regnum,
		       const gdb_byte *buf)
{
  gdb_assert (regnum >= 0);
  gdb_assert (regnum < regcache->descr->nr_cooked_registers);
  if (regnum < regcache->descr->nr_raw_registers)
    regcache_raw_write (regcache, regnum, buf);
  else
    gdbarch_pseudo_register_write (regcache->descr->gdbarch, regcache,
				   regnum, buf);
}

/* Perform a partial register transfer using a read, modify, write
   operation.  */

typedef void (regcache_read_ftype) (struct regcache *regcache, int regnum,
				    void *buf);
typedef void (regcache_write_ftype) (struct regcache *regcache, int regnum,
				     const void *buf);

static enum register_status
regcache_xfer_part (struct regcache *regcache, int regnum,
		    int offset, int len, void *in, const void *out,
		    enum register_status (*read) (struct regcache *regcache,
						  int regnum,
						  gdb_byte *buf),
		    void (*write) (struct regcache *regcache, int regnum,
				   const gdb_byte *buf))
{
  struct regcache_descr *descr = regcache->descr;
  gdb_byte reg[MAX_REGISTER_SIZE];

  gdb_assert (offset >= 0 && offset <= descr->sizeof_register[regnum]);
  gdb_assert (len >= 0 && offset + len <= descr->sizeof_register[regnum]);
  /* Something to do?  */
  if (offset + len == 0)
    return REG_VALID;
  /* Read (when needed) ...  */
  if (in != NULL
      || offset > 0
      || offset + len < descr->sizeof_register[regnum])
    {
      enum register_status status;

      gdb_assert (read != NULL);
      status = read (regcache, regnum, reg);
      if (status != REG_VALID)
	return status;
    }
  /* ... modify ...  */
  if (in != NULL)
    memcpy (in, reg + offset, len);
  if (out != NULL)
    memcpy (reg + offset, out, len);
  /* ... write (when needed).  */
  if (out != NULL)
    {
      gdb_assert (write != NULL);
      write (regcache, regnum, reg);
    }

  return REG_VALID;
}

enum register_status
regcache_raw_read_part (struct regcache *regcache, int regnum,
			int offset, int len, gdb_byte *buf)
{
  struct regcache_descr *descr = regcache->descr;

  gdb_assert (regnum >= 0 && regnum < descr->nr_raw_registers);
  return regcache_xfer_part (regcache, regnum, offset, len, buf, NULL,
			     regcache_raw_read, regcache_raw_write);
}

void
regcache_raw_write_part (struct regcache *regcache, int regnum,
			 int offset, int len, const gdb_byte *buf)
{
  struct regcache_descr *descr = regcache->descr;

  gdb_assert (regnum >= 0 && regnum < descr->nr_raw_registers);
  regcache_xfer_part (regcache, regnum, offset, len, NULL, buf,
		      regcache_raw_read, regcache_raw_write);
}

enum register_status
regcache_cooked_read_part (struct regcache *regcache, int regnum,
			   int offset, int len, gdb_byte *buf)
{
  struct regcache_descr *descr = regcache->descr;

  gdb_assert (regnum >= 0 && regnum < descr->nr_cooked_registers);
  return regcache_xfer_part (regcache, regnum, offset, len, buf, NULL,
			     regcache_cooked_read, regcache_cooked_write);
}

void
regcache_cooked_write_part (struct regcache *regcache, int regnum,
			    int offset, int len, const gdb_byte *buf)
{
  struct regcache_descr *descr = regcache->descr;

  gdb_assert (regnum >= 0 && regnum < descr->nr_cooked_registers);
  regcache_xfer_part (regcache, regnum, offset, len, NULL, buf,
		      regcache_cooked_read, regcache_cooked_write);
}

/* Supply register REGNUM, whose contents are stored in BUF, to REGCACHE.  */

void
regcache_raw_supply (struct regcache *regcache, int regnum, const void *buf)
{
  void *regbuf;
  size_t size;

  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  gdb_assert (!regcache->readonly_p);

  regbuf = register_buffer (regcache, regnum);
  size = regcache->descr->sizeof_register[regnum];

  if (buf)
    {
      memcpy (regbuf, buf, size);
      regcache->register_status[regnum] = REG_VALID;
    }
  else
    {
      /* This memset not strictly necessary, but better than garbage
	 in case the register value manages to escape somewhere (due
	 to a bug, no less).  */
      memset (regbuf, 0, size);
      regcache->register_status[regnum] = REG_UNAVAILABLE;
    }
}

/* Collect register REGNUM from REGCACHE and store its contents in BUF.  */

void
regcache_raw_collect (const struct regcache *regcache, int regnum, void *buf)
{
  const void *regbuf;
  size_t size;

  gdb_assert (regcache != NULL && buf != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);

  regbuf = register_buffer (regcache, regnum);
  size = regcache->descr->sizeof_register[regnum];
  memcpy (buf, regbuf, size);
}


/* Special handling for register PC.  */

CORE_ADDR
regcache_read_pc (struct regcache *regcache)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);

  CORE_ADDR pc_val;

  if (gdbarch_read_pc_p (gdbarch))
    pc_val = gdbarch_read_pc (gdbarch, regcache);
  /* Else use per-frame method on get_current_frame.  */
  else if (gdbarch_pc_regnum (gdbarch) >= 0)
    {
      ULONGEST raw_val;

      if (regcache_cooked_read_unsigned (regcache,
					 gdbarch_pc_regnum (gdbarch),
					 &raw_val) == REG_UNAVAILABLE)
	throw_error (NOT_AVAILABLE_ERROR, _("PC register is not available"));

      pc_val = gdbarch_addr_bits_remove (gdbarch, raw_val);
    }
  else
    internal_error (__FILE__, __LINE__,
		    _("regcache_read_pc: Unable to find PC"));
  return pc_val;
}

void
regcache_write_pc (struct regcache *regcache, CORE_ADDR pc)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);

  if (gdbarch_write_pc_p (gdbarch))
    gdbarch_write_pc (gdbarch, regcache, pc);
  else if (gdbarch_pc_regnum (gdbarch) >= 0)
    regcache_cooked_write_unsigned (regcache,
				    gdbarch_pc_regnum (gdbarch), pc);
  else
    internal_error (__FILE__, __LINE__,
		    _("regcache_write_pc: Unable to update PC"));

  /* Writing the PC (for instance, from "load") invalidates the
     current frame.  */
  reinit_frame_cache ();
}


static void
reg_flush_command (char *command, int from_tty)
{
  /* Force-flush the register cache.  */
  registers_changed ();
  if (from_tty)
    printf_filtered (_("Register cache flushed.\n"));
}

enum regcache_dump_what
{
  regcache_dump_none, regcache_dump_raw,
  regcache_dump_cooked, regcache_dump_groups,
  regcache_dump_remote
};

static void
regcache_dump (struct regcache *regcache, struct ui_file *file,
	       enum regcache_dump_what what_to_dump)
{
  struct cleanup *cleanups = make_cleanup (null_cleanup, NULL);
  struct gdbarch *gdbarch = regcache->descr->gdbarch;
  int regnum;
  int footnote_nr = 0;
  int footnote_register_size = 0;
  int footnote_register_offset = 0;
  int footnote_register_type_name_null = 0;
  long register_offset = 0;
  gdb_byte buf[MAX_REGISTER_SIZE];

#if 0
  fprintf_unfiltered (file, "nr_raw_registers %d\n",
		      regcache->descr->nr_raw_registers);
  fprintf_unfiltered (file, "nr_cooked_registers %d\n",
		      regcache->descr->nr_cooked_registers);
  fprintf_unfiltered (file, "sizeof_raw_registers %ld\n",
		      regcache->descr->sizeof_raw_registers);
  fprintf_unfiltered (file, "sizeof_raw_register_status %ld\n",
		      regcache->descr->sizeof_raw_register_status);
  fprintf_unfiltered (file, "gdbarch_num_regs %d\n", 
		      gdbarch_num_regs (gdbarch));
  fprintf_unfiltered (file, "gdbarch_num_pseudo_regs %d\n",
		      gdbarch_num_pseudo_regs (gdbarch));
#endif

  gdb_assert (regcache->descr->nr_cooked_registers
	      == (gdbarch_num_regs (gdbarch)
		  + gdbarch_num_pseudo_regs (gdbarch)));

  for (regnum = -1; regnum < regcache->descr->nr_cooked_registers; regnum++)
    {
      /* Name.  */
      if (regnum < 0)
	fprintf_unfiltered (file, " %-10s", "Name");
      else
	{
	  const char *p = gdbarch_register_name (gdbarch, regnum);

	  if (p == NULL)
	    p = "";
	  else if (p[0] == '\0')
	    p = "''";
	  fprintf_unfiltered (file, " %-10s", p);
	}

      /* Number.  */
      if (regnum < 0)
	fprintf_unfiltered (file, " %4s", "Nr");
      else
	fprintf_unfiltered (file, " %4d", regnum);

      /* Relative number.  */
      if (regnum < 0)
	fprintf_unfiltered (file, " %4s", "Rel");
      else if (regnum < gdbarch_num_regs (gdbarch))
	fprintf_unfiltered (file, " %4d", regnum);
      else
	fprintf_unfiltered (file, " %4d",
			    (regnum - gdbarch_num_regs (gdbarch)));

      /* Offset.  */
      if (regnum < 0)
	fprintf_unfiltered (file, " %6s  ", "Offset");
      else
	{
	  fprintf_unfiltered (file, " %6ld",
			      regcache->descr->register_offset[regnum]);
	  if (register_offset != regcache->descr->register_offset[regnum]
	      || (regnum > 0
		  && (regcache->descr->register_offset[regnum]
		      != (regcache->descr->register_offset[regnum - 1]
			  + regcache->descr->sizeof_register[regnum - 1])))
	      )
	    {
	      if (!footnote_register_offset)
		footnote_register_offset = ++footnote_nr;
	      fprintf_unfiltered (file, "*%d", footnote_register_offset);
	    }
	  else
	    fprintf_unfiltered (file, "  ");
	  register_offset = (regcache->descr->register_offset[regnum]
			     + regcache->descr->sizeof_register[regnum]);
	}

      /* Size.  */
      if (regnum < 0)
	fprintf_unfiltered (file, " %5s ", "Size");
      else
	fprintf_unfiltered (file, " %5ld",
			    regcache->descr->sizeof_register[regnum]);

      /* Type.  */
      {
	const char *t;

	if (regnum < 0)
	  t = "Type";
	else
	  {
	    static const char blt[] = "builtin_type";

	    t = TYPE_NAME (register_type (regcache->descr->gdbarch, regnum));
	    if (t == NULL)
	      {
		char *n;

		if (!footnote_register_type_name_null)
		  footnote_register_type_name_null = ++footnote_nr;
		n = xstrprintf ("*%d", footnote_register_type_name_null);
		make_cleanup (xfree, n);
		t = n;
	      }
	    /* Chop a leading builtin_type.  */
	    if (strncmp (t, blt, strlen (blt)) == 0)
	      t += strlen (blt);
	  }
	fprintf_unfiltered (file, " %-15s", t);
      }

      /* Leading space always present.  */
      fprintf_unfiltered (file, " ");

      /* Value, raw.  */
      if (what_to_dump == regcache_dump_raw)
	{
	  if (regnum < 0)
	    fprintf_unfiltered (file, "Raw value");
	  else if (regnum >= regcache->descr->nr_raw_registers)
	    fprintf_unfiltered (file, "<cooked>");
	  else if (regcache_register_status (regcache, regnum) == REG_UNKNOWN)
	    fprintf_unfiltered (file, "<invalid>");
	  else if (regcache_register_status (regcache, regnum) == REG_UNAVAILABLE)
	    fprintf_unfiltered (file, "<unavailable>");
	  else
	    {
	      regcache_raw_read (regcache, regnum, buf);
	      print_hex_chars (file, buf,
			       regcache->descr->sizeof_register[regnum],
			       gdbarch_byte_order (gdbarch));
	    }
	}

      /* Value, cooked.  */
      if (what_to_dump == regcache_dump_cooked)
	{
	  if (regnum < 0)
	    fprintf_unfiltered (file, "Cooked value");
	  else
	    {
	      enum register_status status;

	      status = regcache_cooked_read (regcache, regnum, buf);
	      if (status == REG_UNKNOWN)
		fprintf_unfiltered (file, "<invalid>");
	      else if (status == REG_UNAVAILABLE)
		fprintf_unfiltered (file, "<unavailable>");
	      else
		print_hex_chars (file, buf,
				 regcache->descr->sizeof_register[regnum],
				 gdbarch_byte_order (gdbarch));
	    }
	}

      /* Group members.  */
      if (what_to_dump == regcache_dump_groups)
	{
	  if (regnum < 0)
	    fprintf_unfiltered (file, "Groups");
	  else
	    {
	      const char *sep = "";
	      struct reggroup *group;

	      for (group = reggroup_next (gdbarch, NULL);
		   group != NULL;
		   group = reggroup_next (gdbarch, group))
		{
		  if (gdbarch_register_reggroup_p (gdbarch, regnum, group))
		    {
		      fprintf_unfiltered (file,
					  "%s%s", sep, reggroup_name (group));
		      sep = ",";
		    }
		}
	    }
	}

      /* Remote packet configuration.  */
      if (what_to_dump == regcache_dump_remote)
	{
	  if (regnum < 0)
	    {
	      fprintf_unfiltered (file, "Rmt Nr  g/G Offset");
	    }
	  else if (regnum < regcache->descr->nr_raw_registers)
	    {
	      int pnum, poffset;

	      if (remote_register_number_and_offset (get_regcache_arch (regcache), regnum,
						     &pnum, &poffset))
		fprintf_unfiltered (file, "%7d %11d", pnum, poffset);
	    }
	}

      fprintf_unfiltered (file, "\n");
    }

  if (footnote_register_size)
    fprintf_unfiltered (file, "*%d: Inconsistent register sizes.\n",
			footnote_register_size);
  if (footnote_register_offset)
    fprintf_unfiltered (file, "*%d: Inconsistent register offsets.\n",
			footnote_register_offset);
  if (footnote_register_type_name_null)
    fprintf_unfiltered (file, 
			"*%d: Register type's name NULL.\n",
			footnote_register_type_name_null);
  do_cleanups (cleanups);
}

static void
regcache_print (char *args, enum regcache_dump_what what_to_dump)
{
  if (args == NULL)
    regcache_dump (get_current_regcache (), gdb_stdout, what_to_dump);
  else
    {
      struct cleanup *cleanups;
      struct ui_file *file = gdb_fopen (args, "w");

      if (file == NULL)
	perror_with_name (_("maintenance print architecture"));
      cleanups = make_cleanup_ui_file_delete (file);
      regcache_dump (get_current_regcache (), file, what_to_dump);
      do_cleanups (cleanups);
    }
}

static void
maintenance_print_registers (char *args, int from_tty)
{
  regcache_print (args, regcache_dump_none);
}

static void
maintenance_print_raw_registers (char *args, int from_tty)
{
  regcache_print (args, regcache_dump_raw);
}

static void
maintenance_print_cooked_registers (char *args, int from_tty)
{
  regcache_print (args, regcache_dump_cooked);
}

static void
maintenance_print_register_groups (char *args, int from_tty)
{
  regcache_print (args, regcache_dump_groups);
}

static void
maintenance_print_remote_registers (char *args, int from_tty)
{
  regcache_print (args, regcache_dump_remote);
}

extern initialize_file_ftype _initialize_regcache; /* -Wmissing-prototype */

void
_initialize_regcache (void)
{
  regcache_descr_handle
    = gdbarch_data_register_post_init (init_regcache_descr);

  observer_attach_target_changed (regcache_observer_target_changed);
  observer_attach_thread_ptid_changed (regcache_thread_ptid_changed);

  add_com ("flushregs", class_maintenance, reg_flush_command,
	   _("Force gdb to flush its register cache (maintainer command)"));

  add_cmd ("registers", class_maintenance, maintenance_print_registers,
	   _("Print the internal register configuration.\n"
	     "Takes an optional file parameter."), &maintenanceprintlist);
  add_cmd ("raw-registers", class_maintenance,
	   maintenance_print_raw_registers,
	   _("Print the internal register configuration "
	     "including raw values.\n"
	     "Takes an optional file parameter."), &maintenanceprintlist);
  add_cmd ("cooked-registers", class_maintenance,
	   maintenance_print_cooked_registers,
	   _("Print the internal register configuration "
	     "including cooked values.\n"
	     "Takes an optional file parameter."), &maintenanceprintlist);
  add_cmd ("register-groups", class_maintenance,
	   maintenance_print_register_groups,
	   _("Print the internal register configuration "
	     "including each register's group.\n"
	     "Takes an optional file parameter."),
	   &maintenanceprintlist);
  add_cmd ("remote-registers", class_maintenance,
	   maintenance_print_remote_registers, _("\
Print the internal register configuration including each register's\n\
remote register number and buffer offset in the g/G packets.\n\
Takes an optional file parameter."),
	   &maintenanceprintlist);

}
@


1.201
log
@regcache.c: fix -Wpointer-sign

$ make WERROR_CFLAGS="-Wpointer-sign -Werror" regcache.o 2>&1 1>/dev/null
../../src/gdb/regcache.c: In function regcache_xmalloc_1:
../../src/gdb/regcache.c:228:2: error: pointer targets in assignment differ in signedness [-Werror=pointer-sign]
../../src/gdb/regcache.c:235:2: error: pointer targets in assignment differ in signedness [-Werror=pointer-sign]
cc1: all warnings being treated as errors

regcache->register_status is "signed char".

gdb/
2013-03-07  Pedro Alves  <palves@@redhat.com>

	* regcache.c (regcache_xmalloc_1): Call XCALLOC with signed char
	for 'regcache->register_status'.
@
text
@d33 1
a1093 21
static void
dump_endian_bytes (struct ui_file *file, enum bfd_endian endian,
		   const gdb_byte *buf, long len)
{
  int i;

  switch (endian)
    {
    case BFD_ENDIAN_BIG:
      for (i = 0; i < len; i++)
	fprintf_unfiltered (file, "%02x", buf[i]);
      break;
    case BFD_ENDIAN_LITTLE:
      for (i = len - 1; i >= 0; i--)
	fprintf_unfiltered (file, "%02x", buf[i]);
      break;
    default:
      internal_error (__FILE__, __LINE__, _("Bad switch"));
    }
}

d1241 3
a1243 4
	      fprintf_unfiltered (file, "0x");
	      dump_endian_bytes (file,
				 gdbarch_byte_order (gdbarch), buf,
				 regcache->descr->sizeof_register[regnum]);
d1262 3
a1264 6
		{
		  fprintf_unfiltered (file, "0x");
		  dump_endian_bytes (file,
				     gdbarch_byte_order (gdbarch), buf,
				     regcache->descr->sizeof_register[regnum]);
		}
@


1.200
log
@Use gdb_byte for bytes from the program being debugged.

gdb_byte should be used for bytes from the program being debugged.  We
have many places using char or unsigned char instead all over the
existing ports, and more ends up added over time due to copy/paste as
new code is based on old code.

I've greped the tree for "char buf[", and fixed all I found.

Tested by building with --enable-targets=all.

2013-03-01  Pedro Alves  <palves@@redhat.com>

	Use gdb_byte for bytes from the program being debugged.

	* arm-tdep.c (arm_store_return_value, arm_get_longjmp_target):
	Change type of local 'buf' to gdb_byte.
	* avr-tdep.c (avr_frame_prev_register, avr_push_dummy_call): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* cris-tdep.c (cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache): Likewise.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp)
	(frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Likewise.
	* frv-tdep.c (frv_pseudo_register_write, frv_analyze_prologue): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_find_global_pointer)
	(hppa32_hpux_search_dummy_call_sequence)
	(hppa_hpux_supply_save_state): Likewise.
	* hppa-linux-tdep.c (insns_match_pattern)
	(hppa_linux_find_global_pointer): Likewise.
	* hppa-tdep.c (hppa_in_function_epilogue_p)
	(skip_prologue_hard_way, hppa_frame_cache): Likewise.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Likewise.
	* i386fbsd-tdep.c (i386fbsd_supply_uthread)
	(i386fbsd_collect_uthread): Likewise.
	* ia64-hpux-tdep.c (ia64_hpux_push_dummy_code): Likewise.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Likewise.
	* ia64-tdep.c (examine_prologue, ia64_frame_cache)
	(ia64_frame_prev_register, ia64_sigtramp_frame_cache)
	(ia64_sigtramp_frame_prev_register, ia64_access_reg)
	(ia64_access_rse_reg, ia64_libunwind_frame_this_id)
	(ia64_libunwind_frame_prev_register)
	(ia64_libunwind_sigtramp_frame_this_id)
	(ia64_find_global_pointer_from_dynamic_section)
	(find_extant_func_descr, find_func_descr, ia64_dummy_id)
	(ia64_unwind_pc): Likewise.
	* iq2000-tdep.c (iq2000_store_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call)
	(m68hc11_extract_return_value): Likewise.
	* m68klinux-nat.c (fetch_register, store_register): Likewise.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_cr32_write)
	(mep_get_insn, mep_push_dummy_call): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips_linux_in_dynsym_stub): Likewise.
	* mn10300-tdep.c (mep_pseudo_cr32_write): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* regcache.c (dump_endian_bytes): Change type of parameter 'buf'
	to gdb_byte.
	* remote-mips.c (mips_set_register): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* score-tdep.c (score7_fetch_inst): Change type of parameter
	'memblock' and local 'buf' to gdb_byte.
	(score7_malloc_and_get_memblock): Change return type to gdb_byte.
	Change type of local 'buf' to gdb_byte.  Adjust.
	(score7_adjust_memblock_ptr): Change type of parameter 'memblock'
	to gdb_byte**.
	(score7_analyze_prologue): Change type of 'memblock' and
	'memblock_ptr' locals to gdb_byte*.
	* sh64-tdep.c (sh64_extract_return_value)
	(sh64_store_return_value): Change type of local 'buf' to gdb_byte.
	* solib-darwin.c (darwin_current_sos, darwin_read_exec_load_addr):
	* solib-pa64.c (pa64_solib_create_inferior_hook)
	(pa64_open_symbol_file_object): Remove local 'buf'.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start)
	(som_open_symbol_file_object): Likewise.
	* solib-spu.c (spu_current_sos): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	* spu-multiarch.c (parse_spufs_run, spu_fetch_registers)
	(spu_store_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	* tic6x-tdep.c (tic6x_get_longjmp_target): Likewise.
	* xstormy16-tdep.c (xstormy16_store_return_value)
	(xstormy16_push_dummy_call, xstormy16_resolve_jmp_table_entry)
	(xstormy16_find_jmp_table_entry): Likewise.
@
text
@d228 1
a228 1
	= XCALLOC (descr->sizeof_cooked_register_status, gdb_byte);
d235 1
a235 1
	= XCALLOC (descr->sizeof_raw_register_status, gdb_byte);
@


1.199
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

	* charset.c (intermediate_encoding): Remove unused i.
	* completer.c (signal_completer): Remove unused i.
	* continuations.c (discard_my_continuations_1): Remove unused
	continuation_ptr.
	* corelow.c (core_close): Remove unuseD name.
	(get_core_siginfo): Remove unused pid.
	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Remove unused
	i, cps.
	* dwarf2loc.c (dwarf2_compile_expr_to_ax): Remove unused base_offset.
	(loclist_describe_location): Remove unused first.
	* event-top.c (command_line_handler): Remove unused got_eof.
	* exec.c (exec_close_1): Remove unused need_symtab_cleanup.
	(resize_section_table): Remove unused old_value.
	* gdb_bfd.c (gdb_bfd_map_section): Remove unused header.
	* gnu-v3-abi.c (compute_vtable_size): Remove unused addr.
	* i386-tdep.c (i386_process_record): Remove unused rex.
	* infcmd.c (get_return_value): Remove unused uiout.
	* jv-lang.c (type_from_class): Remove unused is_array.
	* jv-valprint.c (java_val_print): Remove unused i.
	* linux-nat.c (linux_nat_stop_lwp): Remove unused ptid.
	* linux-thread-db.c (thread_db_find_new_threads_2): Remove unuseD pid.
	* m2-typeprint.c (m2_print_type): Remove unused code.
	* macroexp.c (get_character_constant): Remove unused body_start.
	(macro_stringify): Remove unused result.
	* objc-lang.c (find_methods): Remove unused gdbarch.
	* objfiles.c (filter_overlapping_sections): Remove unused abfd1, abfd2.
	* regcache.c (regcache_cooked_read): Remove unused gdbarch.
	* stack.c (print_frame_args): Remove unused summary.
	* thread.c (thread_apply_command): Remove unused p.
	* valarith.c (value_x_unop): Remove unused mangle_ptr.
	* valops.c (search_struct_method): Remove unused skip.
	* valprint.c (generic_val_print): Remove unused byte_order.
	* varobj.c (varobj_update): Remove unused changed.
	* cli/cli-cmds.c (complete_command): Remove unused next_item.
	(alias_command): Remove unused c.
	* mi/mi-cmd-catch.c (mi_catch_load_unload): Remove unused c.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Remove unused
	format.
	(mi_cmd_data_write_memory): Remove unused word_format.
	(mi_cmd_data_write_memory_bytes): Remove unused r.
	* python/py-gdb-readline.c (gdbpy_readline_wrapper): Remove unused
	p_start, p_end.
	* python/python.c (_initialize_python): Remove unused cmd_name, cmd.
	* tui/tui-disasm.c (tui_set_disassem_content): Remove unused
	line_width.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00766.html
@
text
@d1095 1
a1095 1
		   const unsigned char *buf, long len)
d1133 1
a1133 1
  unsigned char buf[MAX_REGISTER_SIZE];
@


1.198
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a708 2
      struct gdbarch *gdbarch = regcache->descr->gdbarch;

@


1.197
log
@2012-09-28  selven  <pcthegreat@@gmail.com>

	Make definition match declaration.

	* regcache.c (regcache_register_status): Change return type to
	enum register_status.
@
text
@d3 1
a3 2
   Copyright (C) 1986-1987, 1989, 1991, 1994-1996, 1998, 2000-2002,
   2004, 2007-2012 Free Software Foundation, Inc.
@


1.196
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d414 1
a414 1
int
@


1.195
log
@	* regcache.c (registers_changed_ptid): Invalidate thread architecture
	and frame caches if PTID refers to all threads of a process.
@
text
@d3 2
a4 2
   Copyright (C) 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000, 2001,
   2002, 2004, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.195.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 2
   Copyright (C) 1986-1987, 1989, 1991, 1994-1996, 1998, 2000-2002,
   2004, 2007-2012 Free Software Foundation, Inc.
@


1.194
log
@Fix regcache_restore() handling of unavailable regs.

	* regcache.c (regcache_restore): Do not write unavailable regs, mark
	static.
	* regcache.h (regcache_restore): Remove declaration.
@
text
@a550 1
  int wildcard = ptid_equal (ptid, minus_one_ptid);
d571 1
a571 1
  if (wildcard || ptid_equal (ptid, current_thread_ptid))
d577 1
a577 1
  if (wildcard || ptid_equal (ptid, inferior_ptid))
@


1.193
log
@	gdb/
	* infrun.c (displaced_step_fixup): Move some code ...
	(displaced_step_restore): ... here.  New function.
	(handle_inferior_event): Cleanup displaced stepping state for both
	child and parent when get forked or vforked event.
	* regcache.c (get_thread_arch_aspace_regcache): New function.
	get_thread_arch_regcache (): Call it.
@
text
@d334 1
a334 1
void
d354 1
a354 1
	  int valid = cooked_read (cooked_read_context, regnum, buf);
d356 2
a357 1
	  if (valid)
@


1.192
log
@gdb
	* amd64-tdep.c (amd64_pseudo_register_read_value): Rename
	from amd64_pseudo_register_read.  Change arguments.  Call
	mark_value_bytes_unavailable when needed.
	(amd64_init_abi): Use set_gdbarch_pseudo_register_read_value, not
	set_gdbarch_pseudo_register_read.
	* sentinel-frame.c (sentinel_frame_prev_register): Use
	regcache_cooked_read_value.
	* regcache.h (regcache_cooked_read_value): Declare.
	* regcache.c (regcache_cooked_read_value): New function.
	(regcache_cooked_read): Call
	gdbarch_pseudo_register_read_value if available.
	* i386-tdep.h (i386_pseudo_register_read_value): Declare.
	(i386_pseudo_register_read): Remove.
	* i386-tdep.c (i386_pseudo_register_read_into_value): Rename from
	i386_pseudo_register_read.  Change arguments.  Call
	mark_value_bytes_unavailable when needed.
	(i386_pseudo_register_read_value): New function.
	(i386_gdbarch_init): Call set_gdbarch_pseudo_register_read_value,
	not set_gdbarch_pseudo_register_read.
	* gdbarch.sh (pseudo_register_read_value): New method.
	* gdbarch.c, gdbarch.h: Rebuild.
	* findvar.c (value_from_register): Call get_frame_register_value.
gdb/testsuite
	* gdb.dwarf2/typeddwarf.c: XFAIL 'z' on x86-64.
	* gdb.dwarf2/typeddwarf.exp (xfail-gdb-test): Add arch_pattern
	argument.
	* gdb.dwarf2/typeddwarf-amd64.S: New file.
@
text
@d453 2
a454 1
get_thread_arch_regcache (ptid_t ptid, struct gdbarch *gdbarch)
a457 1
  struct address_space *aspace;
d464 16
d490 1
a490 9
  new_regcache = regcache_xmalloc_1 (gdbarch, aspace, 0);
  new_regcache->ptid = ptid;

  list = xmalloc (sizeof (struct regcache_list));
  list->regcache = new_regcache;
  list->next = current_regcache;
  current_regcache = list;

  return new_regcache;
@


1.191
log
@	* regcache.c (struct regcache_descr): Fix typo.
	* i387-tdep.c (i387_supply_xsave): Fix typo.
@
text
@d712 22
d739 33
@


1.190
log
@2011-04-20  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* regcache.c: Include remote.h.
	(enum regcache_dump_what) <regcache_dump_remote>: New enum value.
	(regcache_dump): Handle regcache_dump_remote.
	(maintenance_print_remote_registers): New function.
	(_initialize_regcache): Install "maint print remote-registers"
	command.
	* remote.c (map_regcache_remote_table): New function, factored out
	from ...
	(init_remote_state): ... here.
	(remote_register_number_and_offset): New.
	* remote.h (remote_register_number_and_offset): Declare.

	gdb/doc/
	* gdb.texinfo (Maintenance Commands): Document `maint print
	remote-registers'.
@
text
@d70 1
a70 1
  /* Offset and size (in 8 bit bytes), of reach register in the
@


1.189
log
@2011-04-20  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* regcache.c (get_thread_arch_regcache): If creating a regcache for
	null_ptid, assume and allow a NULL address space, instead of
	asking the target for the ptid's address space.
	* infrun.c (ptid_is_pid): Remove assertion.

	gdb/testsuite/
	* gdb.base/maint.exp: Test that "maint print registers" works
	without a running program.
@
text
@d33 1
d1057 2
a1058 1
  regcache_dump_cooked, regcache_dump_groups
d1256 17
d1331 6
d1370 6
@


1.188
log
@	* regcache.c (regcache_raw_read): If the target didn't supply a
	given raw register, mark it as unavailable.
@
text
@d456 1
d463 11
a473 2
  new_regcache = regcache_xmalloc_1 (gdbarch,
				     target_thread_address_space (ptid), 0);
a474 1
  gdb_assert (new_regcache->aspace != NULL);
@


1.188.2.1
log
@2011-04-20  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* regcache.c (get_thread_arch_regcache): If creating a regcache for
	null_ptid, assume and allow a NULL address space, instead of
	asking the target for the ptid's address space.
	* infrun.c (ptid_is_pid): Remove assertion.

	gdb/testsuite/
	* gdb.base/maint.exp: Test that "maint print registers" works
	without a running program.
@
text
@a455 1
  struct address_space *aspace;
d462 2
a463 11
  /* For the benefit of "maint print registers" & co when debugging an
     executable, allow dumping the regcache even when there is no
     thread selected (target_thread_address_space internal-errors if
     no address space is found).  Note that normal user commands will
     fail higher up on the call stack due to no
     target_has_registers.  */
  aspace = (ptid_equal (null_ptid, ptid)
	    ? NULL
	    : target_thread_address_space (ptid));

  new_regcache = regcache_xmalloc_1 (gdbarch, aspace, 0);
d465 1
@


1.187
log
@	gdb/
	* regcache.h (regcache_raw_read, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_part)
	(regcache_cooked_read, regcache_cooked_read_signed)
	(regcache_cooked_read_unsigned, regcache_cooked_read_part)
	(regcache_cooked_read_ftype): Change return to enum
	register_status.
	* regcache.c: Include exceptions.h
	(regcache_save): Adjust to handle REG_UNAVAILABLE registers.
	(do_cooked_read): Change return to enum register_status.  Always
	forward to regcache_cooked_read.
	(regcache_raw_read): Change return to enum register_status.  If
	the register is not REG_VALID, memset the buffer.  Return the
	register's status.
	(regcache_raw_read_signed): Handle non-REG_VALID registers and
	return the register's status.
	(regcache_raw_read_unsigned): Ditto.
	(regcache_cooked_read): Change return to enum register_status.
	Assert that with read-only regcaches, the register's status must
	be known.  If the regcache is read-only, and the register is not
	REG_VALID, memset the buffer.  Return the register's status.
	(regcache_cooked_read_signed): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_cooked_read_unsigned): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_xfer_part, regcache_raw_read_part)
	(regcache_cooked_read_part): Change return to enum
	register_status.  Return the register's status.
	(regcache_read_pc): Throw NOT_AVAILABLE_ERROR if the register is
	unavailable.
	(regcache_dump): Handle unavailable cooked registers.
	* frame.c (do_frame_register_read): Adjust interface to match
	regcache_cooked_read_ftype.
	* gdbarch.sh (pseudo_register_read): Change return to enum
	register_status.
	* gdbarch.h, gdbarch.c: Regenerate.

	* i386-tdep.h (i386_pseudo_register_read): Change return to enum
	register_status.
	* i386-tdep.c (i386_pseudo_register_read): Change return to enum
	register_status.  If reading a raw register indicates the raw
	register is not valid, return the raw register's status,
	otherwise, return REG_VALID.
	* amd64-tdep.c (amd64_pseudo_register_read): Change return to enum
	register_status.  Handle non-REG_VALID raw registers and return
	the register's status.
	* arm-tdep.c (arm_neon_quad_read)
	(arm_pseudo_read): Change return to enum register_status.  Handle
	non-REG_VALID raw registers and return the register's status.
	* avr-tdep.c (avr_pseudo_register_read): Ditto.
	* frv-tdep.c (frv_pseudo_register_read): Ditto.
	* h8300-tdep.c (h8300_pseudo_register_read): Ditto.
	* hppa-tdep.c (hppa_pseudo_register_read): Ditto.
	* m32c-tdep.c (m32c_move_reg_t): Change return to enum
	register_status.
	(m32c_raw_read, m32c_raw_write, m32c_banked_read)
	(m32c_banked_write, m32c_sb_read, m32c_sb_write, m32c_part_read)
	(m32c_part_write, m32c_cat_read, m32c_cat_write)
	(m32c_r3r2r1r0_read, m32c_r3r2r1r0_write)
	(m32c_pseudo_register_read): Change return to enum
	register_status.  Adjust.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* mep-tdep.c (mep_pseudo_cr32_read): Change return to enum
	register_status.  Return the register's status.
	(mep_pseudo_cr64_read, mep_pseudo_register_read): Ditto.
	* mips-tdep.c (mips_pseudo_register_read): Ditto.
	* mt-tdep.c (mt_pseudo_register_read): Ditto.
	* rs6000-tdep.c (move_ev_register_func): New typedef.
	(e500_move_ev_register): Use it.  Change return to enum
	register_status.  Return the register's status.
	(do_regcache_raw_read): New function.
	(do_regcache_raw_write): New function.
	(e500_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.  Use
	do_regcache_raw_read.
	(e500_pseudo_register_write): Adjust.  Use do_regcache_raw_write.
	(dfp_pseudo_register_read): Change return to enum register_status.
	Return the register's status.
	(vsx_pseudo_register_read): Ditto.
	(efpr_pseudo_register_read): Ditto.
	(rs6000_pseudo_register_read): Ditto.
	* s390-tdep.c (s390_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh64-tdep.c (pseudo_register_read_portions): New function.
	(sh64_pseudo_register_read): Change return to enum
	register_status.  Use pseudo_register_read_portions.  Return the
	register's status.
	* ia64-tdep.c (ia64_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh-tdep.c (pseudo_register_read_portions): New function.
	(sh_pseudo_register_read): Change return to enum register_status.
	Use pseudo_register_read_portions.  Return the register's status.
	* sparc-tdep.c (sparc32_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* sparc64-tdep.c (sparc64_pseudo_register_read): Ditto.
	* spu-tdep.c (spu_pseudo_register_read_spu)
	(spu_pseudo_register_read): Ditto.
	* xtensa-tdep.c (xtensa_register_read_masked)
	(xtensa_pseudo_register_read): Ditto.
	* bfin-tdep.c (bfin_pseudo_register_read): Ditto.
@
text
@d589 2
a590 1
  if (!regcache->readonly_p)
d592 1
a592 3
      if (regcache_register_status (regcache, regnum) == REG_UNKNOWN)
	{
	  struct cleanup *old_chain = save_inferior_ptid ();
d594 9
a602 13
	  inferior_ptid = regcache->ptid;
	  target_fetch_registers (regcache, regnum);
	  do_cleanups (old_chain);
	}
#if 0
      /* FIXME: cagney/2004-08-07: At present a number of targets
	 forget (or didn't know that they needed) to set this leading to
	 panics.  Also is the problem that targets need to indicate
	 that a register is in one of the possible states: valid,
	 undefined, unknown.  The last of which isn't yet
	 possible.  */
      gdb_assert (regcache_register_status (regcache, regnum) == REG_VALID);
#endif
@


1.186
log
@	* regcache.c (registers_changed_ptid): Don't explictly always
	clear `current_regcache'.  Only clear current_thread_ptid and
	current_thread_arch when PTID matches.  Only reinit the frame
	cache if PTID matches the current inferior_ptid.  Move alloca(0)
	call to ...
	(registers_changed): ... here.
@
text
@d32 1
d316 1
a316 1
	  int valid = cooked_read (src, regnum, buf);
d318 4
a321 1
	  if (valid)
d323 3
a325 1
	      memcpy (register_buffer (dst, regnum), buf,
a326 1
	      dst->register_status[regnum] = REG_VALID;
d328 1
d361 1
a361 1
static int
d366 1
a366 7
  if (regcache->register_status[regnum] == REG_UNKNOWN && regcache->readonly_p)
    /* Don't even think about fetching a register from a read-only
       cache when the register isn't yet valid.  There isn't a target
       from which the register value can be fetched.  */
    return 0;
  regcache_cooked_read (regcache, regnum, buf);
  return 1;
a368 1

d580 1
a580 1
void
d609 8
a616 3
  /* Copy the value directly into the register cache.  */
  memcpy (buf, register_buffer (regcache, regnum),
	  regcache->descr->sizeof_register[regnum]);
d619 1
a619 1
void
d623 1
d628 8
a635 4
  regcache_raw_read (regcache, regnum, buf);
  (*val) = extract_signed_integer
	     (buf, regcache->descr->sizeof_register[regnum],
	      gdbarch_byte_order (regcache->descr->gdbarch));
d638 1
a638 1
void
d643 1
d648 8
a655 4
  regcache_raw_read (regcache, regnum, buf);
  (*val) = extract_unsigned_integer
	     (buf, regcache->descr->sizeof_register[regnum],
	      gdbarch_byte_order (regcache->descr->gdbarch));
d685 1
a685 1
void
d691 1
a691 1
    regcache_raw_read (regcache, regnum, buf);
d693 14
a706 5
	   && regnum < regcache->descr->nr_cooked_registers
	   && regcache->register_status[regnum] == REG_VALID)
    /* Read-only register cache, and the cooked value was cached.  */
    memcpy (buf, register_buffer (regcache, regnum),
	    regcache->descr->sizeof_register[regnum]);
d708 2
a709 2
    gdbarch_pseudo_register_read (regcache->descr->gdbarch, regcache,
				  regnum, buf);
d712 1
a712 1
void
d716 1
d722 8
a729 4
  regcache_cooked_read (regcache, regnum, buf);
  (*val) = extract_signed_integer
	     (buf, regcache->descr->sizeof_register[regnum],
	      gdbarch_byte_order (regcache->descr->gdbarch));
d732 1
a732 1
void
d736 1
d742 8
a749 4
  regcache_cooked_read (regcache, regnum, buf);
  (*val) = extract_unsigned_integer
	     (buf, regcache->descr->sizeof_register[regnum],
	      gdbarch_byte_order (regcache->descr->gdbarch));
d835 1
a835 1
static void
d838 3
a840 2
		    void (*read) (struct regcache *regcache, int regnum,
				  gdb_byte *buf),
d851 1
a851 1
    return;
d857 2
d860 3
a862 1
      read (regcache, regnum, reg);
d875 2
d879 1
a879 1
void
d886 2
a887 2
  regcache_xfer_part (regcache, regnum, offset, len, buf, NULL,
		      regcache_raw_read, regcache_raw_write);
d901 1
a901 1
void
d908 2
a909 2
  regcache_xfer_part (regcache, regnum, offset, len, buf, NULL,
		      regcache_cooked_read, regcache_cooked_write);
d986 5
a990 3
      regcache_cooked_read_unsigned (regcache,
				     gdbarch_pc_regnum (gdbarch),
				     &raw_val);
d1209 14
a1222 7
	      /* FIXME: no way for cooked reads to signal unavailable
		 yet.  */
	      regcache_cooked_read (regcache, regnum, buf);
	      fprintf_unfiltered (file, "0x");
	      dump_endian_bytes (file,
				 gdbarch_byte_order (gdbarch), buf,
				 regcache->descr->sizeof_register[regnum]);
@


1.185
log
@	* regcache.c (struct regcache_descr): Rename
	sizeof_raw_register_valid_p field to sizeof_raw_register_status,
	and sizeof_cooked_register_valid_p to
	sizeof_cooked_register_status.
	(init_regcache_descr): Adjust.
	(struct regcache): Rename register_valid_p field to
	register_status.
	(regcache_xmalloc_1, regcache_xfree, regcache_save)
	(do_cooked_read): Adjust.
	(regcache_valid_p): Rename to ...
	(regcache_register_status): ... this.  Adjust.
	(regcache_invalidate): Adjust.
	(regcache_raw_read, regcache_cooked_read, regcache_raw_write):
	Adjust.
	(regcache_raw_supply): Adjust.  If buf i NULL, mark the register
	as unavailable, not valid.
	(regcache_dump): Adjust.
	* regcache.h (enum register_status): New.
	(regcache_register_status): Declare.
	(regcache_invalidate): Delete declaration.
	* corelow.c (get_core_registers): Adjust.
	* tracepoint.c (tfile_fetch_registers): Adjust.
	* trad-frame.c (REG_VALUE): Rename to ...
	(TF_REG_VALUE): ... this.
	(REG_UNKNOWN): Rename to ...
	(TF_REG_UNKNOWN): ... this.
	(trad_frame_set_value, trad_frame_set_unknown): Adjust.
	* mi/mi-main.c (register_changed_p): Adjust.
@
text
@d533 1
d554 5
a558 1
  current_regcache = NULL;
d560 7
a566 2
  current_thread_ptid = null_ptid;
  current_thread_arch = NULL;
d568 4
a571 2
  /* Need to forget about any frames we have cached, too.  */
  reinit_frame_cache ();
a581 6
registers_changed (void)
{
  registers_changed_ptid (minus_one_ptid);
}

void
@


1.184
log
@	* regcache.c (struct regcache_descr): Remove outdated comment.
	(init_regcache_descr): Remove sizeof_raw_register_valid_p
	overallocate hack.
	(regcache_xmalloc): Rename to ...
	(regcache_xmalloc_1): ... this.  Add `readonly_p' parameter.
	Allocate the regcache type accordingly.
	(regcache_xmalloc): New as wrapper around regcache_xmalloc_1.
	(regcache_xfree): Asser the source is also readonly.  Copy sizeof
	cooked registers, not raw.
	(regcache_dup_no_passthrough): Delete.
	(get_thread_arch_regcache): Use regcache_xmalloc_1.
	* h8300-tdep.c (h8300_push_dummy_call): Tweak comment to not
	mention obsolete write_register_bytes.
	* regcache.h (regcache_dup_no_passthrough): Delete declaration.
@
text
@d56 1
a56 1
  long sizeof_raw_register_valid_p;
d66 1
a66 1
  long sizeof_cooked_register_valid_p;
d95 2
a96 3
  descr->sizeof_cooked_register_valid_p = gdbarch_num_regs (gdbarch)
					  + gdbarch_num_pseudo_regs 
					      (gdbarch);
d108 1
a108 1
  descr->sizeof_raw_register_valid_p = gdbarch_num_regs (gdbarch);
d196 2
a197 5
  /* Register cache status:
     register_valid_p[REG] == 0 if REG value is not in the cache
                            > 0 if REG value is in the cache
                            < 0 if REG value is permanently unavailable */
  signed char *register_valid_p;
d226 2
a227 2
      regcache->register_valid_p
	= XCALLOC (descr->sizeof_cooked_register_valid_p, gdb_byte);
d233 2
a234 2
      regcache->register_valid_p
	= XCALLOC (descr->sizeof_raw_register_valid_p, gdb_byte);
d253 1
a253 1
  xfree (regcache->register_valid_p);
d305 2
a306 2
  memset (dst->register_valid_p, 0,
	  dst->descr->sizeof_cooked_register_valid_p);
d321 1
a321 1
	      dst->register_valid_p[regnum] = 1;
d360 1
a360 1
  if (!regcache->register_valid_p[regnum] && regcache->readonly_p)
d392 3
a394 2
     move of data into the current regcache.  Doing this would be
     silly - it would mean that valid_p would be completely invalid.  */
d399 2
a400 2
  memcpy (dst->register_valid_p, src->register_valid_p,
	  dst->descr->sizeof_cooked_register_valid_p);
d414 1
a414 1
regcache_valid_p (const struct regcache *regcache, int regnum)
d423 1
a423 1
  return regcache->register_valid_p[regnum];
d433 1
a433 1
  regcache->register_valid_p[regnum] = 0;
d586 1
a586 1
      if (!regcache_valid_p (regcache, regnum))
d601 1
a601 1
      gdb_assert (regcache_valid_p (regcache, regnum));
d674 2
a675 2
	   && regcache->register_valid_p[regnum])
    /* Read-only register cache, perhaps the cooked value was cached?  */
d758 1
a758 1
  if (regcache_valid_p (regcache, regnum)
d769 1
a769 1
  regcache->register_valid_p[regnum] = 1;
d893 4
a896 1
    memcpy (regbuf, buf, size);
d898 7
a904 4
    memset (regbuf, 0, size);

  /* Mark the register as cached.  */
  regcache->register_valid_p[regnum] = 1;
d1028 2
a1029 2
  fprintf_unfiltered (file, "sizeof_raw_register_valid_p %ld\n",
		      regcache->descr->sizeof_raw_register_valid_p);
d1140 1
a1140 1
	  else if (!regcache_valid_p (regcache, regnum))
d1142 2
d1161 2
@


1.183
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* nto-procfs.c: Comment cleanup, mostly periods and spaces.
	* nto-tdep.c: Ditto.
	* nto-tdep.h: Ditto.
	* objc-exp.y: Ditto.
	* objc-lang.c: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* observer.c: Ditto.
	* opencl-lang.c: Ditto.
	* osabi.c: Ditto.
	* parse.c: Ditto.
	* parser-defs.h: Ditto.
	* p-exp.y: Ditto.
	* p-lang.c: Ditto.
	* posix-hdep.c: Ditto.
	* ppcbug-rom.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* ppc-linux-tdep.h: Ditto.
	* ppcnbsd-tdep.c: Ditto.
	* ppcobsd-tdep.c: Ditto.
	* ppcobsd-tdep.h: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* ppc-tdep.h: Ditto.
	* printcmd.c: Ditto.
	* proc-abi.c: Ditto.
	* proc-flags.c: Ditto.
	* procfs.c: Ditto.
	* proc-utils.h: Ditto.
	* progspace.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* ravenscar-sparc-thread.c: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote.c: Ditto.
	* remote-fileio.c: Ditto.
	* remote-fileio.h: Ditto.
	* remote.h: Ditto.
	* remote-m32r-sdi.c: Ditto.
	* remote-mips.c: Ditto.
	* remote-sim.c: Ditto.
	* rs6000-aix-tdep.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
@
text
@d70 2
a71 4
     [NR_RAW_REGISTERS .. NR_COOKED_REGISTERS) are given an offset.
     Assigning all registers an offset makes it possible to keep
     legacy code, such as that found in read_register_bytes() and
     write_register_bytes() working.  */
d109 1
a109 6

  /* FIXME: cagney/2002-08-13: Overallocate the register_valid_p
     array.  This pretects GDB from erant code that accesses elements
     of the global register_valid_p[] array in the range 
     [gdbarch_num_regs .. gdbarch_num_regs + gdbarch_num_pseudo_regs).  */
  descr->sizeof_raw_register_valid_p = descr->sizeof_cooked_register_valid_p;
d125 11
a135 1
    for (i = 0; i < descr->nr_cooked_registers; i++)
d142 1
a142 1
    /* Set the real size of the register cache buffer.  */
a145 7
  /* FIXME: cagney/2002-05-22: Should only need to allocate space for
     the raw registers.  Unfortunately some code still accesses the
     register array directly using the global registers[].  Until that
     code has been purged, play safe and over allocating the register
     buffer.  Ulgh!  */
  descr->sizeof_raw_registers = descr->sizeof_cooked_registers;

d214 3
a216 2
struct regcache *
regcache_xmalloc (struct gdbarch *gdbarch, struct address_space *aspace)
d225 15
a239 4
  regcache->registers
    = XCALLOC (descr->sizeof_raw_registers, gdb_byte);
  regcache->register_valid_p
    = XCALLOC (descr->sizeof_raw_register_valid_p, gdb_byte);
a240 1
  regcache->readonly_p = 1;
d245 6
d398 1
a398 1
  gdb_assert (dst->readonly_p);
d400 2
a401 1
  memcpy (dst->registers, src->registers, dst->descr->sizeof_raw_registers);
d403 1
a403 1
	  dst->descr->sizeof_raw_register_valid_p);
a415 10
struct regcache *
regcache_dup_no_passthrough (struct regcache *src)
{
  struct regcache *newbuf;

  newbuf = regcache_xmalloc (src->descr->gdbarch, get_regcache_aspace (src));
  regcache_cpy_no_passthrough (newbuf, src);
  return newbuf;
}

d466 2
a467 3
  new_regcache = regcache_xmalloc (gdbarch,
				   target_thread_address_space (ptid));
  new_regcache->readonly_p = 0;
@


1.182
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d40 1
a40 1
   Computed once when the architecture is created */
d558 1
a558 1
  /* Need to forget about any frames we have cached, too. */
d757 1
a757 1
     value, then don't bother doing the actual store. */
d812 1
a812 1
  /* Read (when needed) ... */
d820 1
a820 1
  /* ... modify ... */
@


1.181
log
@run copyright.sh for 2011.
@
text
@d103 2
a104 1
    = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, struct type *);
d296 2
a297 1
  memset (dst->register_valid_p, 0, dst->descr->sizeof_cooked_register_valid_p);
d997 2
a998 1
  regcache_dump_none, regcache_dump_raw, regcache_dump_cooked, regcache_dump_groups
d1177 2
a1178 1
		      fprintf_unfiltered (file, "%s%s", sep, reggroup_name (group));
d1248 2
a1249 1
  regcache_descr_handle = gdbarch_data_register_post_init (init_regcache_descr);
d1257 3
a1259 3
  add_cmd ("registers", class_maintenance, maintenance_print_registers, _("\
Print the internal register configuration.\n\
Takes an optional file parameter."), &maintenanceprintlist);
d1261 4
a1264 3
	   maintenance_print_raw_registers, _("\
Print the internal register configuration including raw values.\n\
Takes an optional file parameter."), &maintenanceprintlist);
d1266 4
a1269 3
	   maintenance_print_cooked_registers, _("\
Print the internal register configuration including cooked values.\n\
Takes an optional file parameter."), &maintenanceprintlist);
d1271 4
a1274 3
	   maintenance_print_register_groups, _("\
Print the internal register configuration including each register's group.\n\
Takes an optional file parameter."),
@


1.180
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* record.c: White space.
	* regcache.c: White space.
	* reggroups.c: White space.
	* remote-fileio.c: White space.
	* remote-m32r-sdi.c: White space.
	* remote-mips.c: White space.
	* remote-sim.c: White space.
@
text
@d4 1
a4 1
   2002, 2004, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.179
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* auxv.c (target_auxv_search): Delete unused variable.
	* blockframe.c (get_frame_block): Delete unused variable.
	* regcache.c (regcache_cpy): Delete unused variable.
	(regcache_cpy_no_passthrough): Delete unused variable.
	* charset.c (wchar_iterate): Delete unused variable.
	(find_charset_names): Delete unused variable.
	(_initialize_charset): Delete unused variable.
	* disasm.c (do_mixed_source_and_assembly):
	Delete unused variable.
	* source.c (set_default_source_symtab_and_line):
	Delete unused variable.
	(set_substitute_path_command): Delete unused variable.
	* value.c (preserve_values): Delete unused variable.
	(value_from_double): Delete unused variable.
@
text
@d126 1
d165 1
d178 1
d222 1
d288 1
d305 1
d324 1
d337 1
d348 1
d394 1
d404 1
d587 1
d611 1
d626 1
d640 1
d654 1
d686 1
d701 1
d716 1
d730 1
d804 1
d836 1
d847 1
d858 1
d869 1
d931 1
d977 1
d1039 1
d1096 1
d1102 1
d1107 1
d1167 1
d1206 1
@


1.178
log
@	PR gdb/11557

	gdb/
	* regcache.c (registers_changed): Rename to ...
	(registers_changed_ptid): ... this, and only delete register cache
	entries matching the ptid filter argument.
	(registers_changed): Reimplement on top of registers_changed_ptid.
	* regcache.h (registers_changed_ptid): Declare.
	* target.c (target_resume): Flush register caches.

	gdb/testsuite/
	* gdb.mi/mi-ns-stale-regcache.exp, gdb.mi/ns-stale-regcache.c: New
	files.
@
text
@a352 3
  int i;
  gdb_byte *buf;

a368 1
  int i;
@


1.177
log
@	* regcache.c (regcache_xmalloc): Add aspace argument.  Use it
	for the new regcache.  All callers updated.
	(regcache_cpy, regcache_cpy_no_passthrough): Do not set aspace here.
	(get_thread_arch_regcache): Do not set aspace here.
	* regcache.h (regcache_xmalloc): Update declaration.

	* frame.c, infcall.c, ppc-linux-tdep.c: Calls to
	regcache_xmalloc updated.
@
text
@d521 1
a521 1
registers_changed (void)
d523 1
a523 1
  struct regcache_list *list, *next;
d525 3
a527 1
  for (list = current_regcache; list; list = next)
d529 13
a541 3
      next = list->next;
      regcache_xfree (list->regcache);
      xfree (list);
d560 5
@


1.176
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d215 1
a215 1
regcache_xmalloc (struct gdbarch *gdbarch)
d227 1
a227 1
  regcache->aspace = NULL;
a360 2
  dst->aspace = src->aspace;

a379 1
  dst->aspace = src->aspace;
d389 1
a389 1
  newbuf = regcache_xmalloc (src->descr->gdbarch);
d398 1
a398 1
  newbuf = regcache_xmalloc (src->descr->gdbarch);
d453 2
a454 1
  new_regcache = regcache_xmalloc (gdbarch);
a456 1
  new_regcache->aspace = target_thread_address_space (ptid);
@


1.175
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d4 1
a4 1
   2002, 2004, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.174
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d188 5
d227 1
d263 6
d355 1
d360 3
d381 2
d459 2
@


1.173
log
@	* target.h (struct target_ops): New member to_thread_architecture.
	(target_thread_architecture): New macro.
	* target.c (update_current_target): Inherit to_thread_architecture.
	(default_thread_architecture): New function.
	(debug_to_thread_architecture): New function.
	(setup_target_debug): Handle to_thread_architecture.

	* regcache.h (get_thread_arch_regcache): New.
	* regcache.c (struct regcache_list): New data type.
	(current_regcache): Hold regcache list instead of single regcache.
	(current_thread_ptid, current_thread_arch): New static variables.
	(get_thread_arch_regcache): New function.
	(get_thread_regcache): Use it.  Call target_thread_architecture.
	(regcache_thread_ptid_changed): Update to current_regcache changes.
	(registers_changed): Likewise.  Reset current_thread_arch and
	current_thread_ptid.

	* remote.c (remote_wait): Access target registers in target_gdbarch.
	* linux-nat.c (linux_nat_do_thread_registers): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* solib-svr4.c (enable_break): Likewise.
	(svr4_relocate_main_executable): Likewise.
@
text
@d573 3
a575 2
  (*val) = extract_signed_integer (buf,
				   regcache->descr->sizeof_register[regnum]);
d587 3
a589 2
  (*val) = extract_unsigned_integer (buf,
				     regcache->descr->sizeof_register[regnum]);
d599 2
a600 1
  store_signed_integer (buf, regcache->descr->sizeof_register[regnum], val);
d612 2
a613 1
  store_unsigned_integer (buf, regcache->descr->sizeof_register[regnum], val);
d644 3
a646 2
  (*val) = extract_signed_integer (buf,
				   regcache->descr->sizeof_register[regnum]);
d658 3
a660 2
  (*val) = extract_unsigned_integer (buf,
				     regcache->descr->sizeof_register[regnum]);
d671 2
a672 1
  store_signed_integer (buf, regcache->descr->sizeof_register[regnum], val);
d684 2
a685 1
  store_unsigned_integer (buf, regcache->descr->sizeof_register[regnum], val);
@


1.172
log
@	gdb/
	* NEWS: Document inlined function support.
	* Makefile.in (SFILES): Add inline-frame.c.
	(COMMON_OBS): Add inline-frame.o.
	* block.c (contained_in): Rewrite to use lexical nesting.
	(block_linkage_function): Skip inlined function blocks.
	(block_inlined_p): New.
	* block.h (struct block): Update comment.
	(block_inlined_p): New prototype.
	* blockframe.c (get_frame_block): Handle inlined functions.
	(get_frame_function): Do not use block_linkage_function.
	(block_innermost_frame): Use get_frame_block and contained_in.
	* breakpoint.c (watchpoint_check): Remove extra reinit_frame_cache.
	Skip over inlined functions.  Simplify epilogue check.
	(bpstat_check_breakpoint_conditions): Use get_stack_frame_id.
	Update comments.
	(set_momentary_breakpoint): Only accept non-inlined frames.
	(watch_command_1): Use frame_unwind_caller_pc and
	frame_unwind_caller_id instead of get_prev_frame.
	(until_break_command): Likewise.  Use get_stack_frame_id.
	* buildsym.c (end_symtab): Set SYMBOL_SYMTAB for block functions.
	* dwarf2loc.c (dwarf_expr_frame_base): Use block_linkage_function.
	* dwarf2read.c (process_die): Handle DW_TAG_inlined_subroutine.
	(read_func_scope, new_symbol): Likewise.  Handle arguments specially
	for inlined functions without call site information.
	(inherit_abstract_dies): Allow tag mismatch for inlined subroutines.
	(die_specification): Treat DW_AT_abstract_origin as a specification.
	(read_type_die): Handle DW_TAG_inlined_subroutine.
	* frame-unwind.c (frame_unwind_init): Add inline_frame_unwind.
	* frame.c (fprint_frame_id): Print inline depth.
	(fprint_frame_type): Handle INLINE_FRAME and SENTINEL_FRAME.
	(skip_inlined_frames, get_stack_frame_id): New.
	(frame_unwind_caller_id): Use skip_inlined_frames.
	(frame_id_inlined_p): New.
	(frame_id_eq): Make the logic match the comments.  Add inline_depth
	check.
	(frame_id_inner): Handle inlined functions.
	(frame_unwind_pc): New function, copied from frame_unwind_caller_pc.
	(frame_unwind_caller_pc): Use skip_inlined_frames and frame_unwind_pc.
	(get_prev_frame_1): Check for inline frames.  Split out frame
	allocation to get_prev_frame_raw.
	(get_prev_frame_raw): New function.
	(get_prev_frame): Handle inline frames.
	(get_frame_pc): Use frame_unwind_pc.
	(get_frame_address_in_block): Skip inlined frames on both sides.
	(pc_notcurrent): Delete.
	(find_frame_sal): Rewrite to handle inline call sites.  Use
	get_frame_address_in_block.
	(deprecated_update_frame_pc_hack): Make static.
	* frame.h: Update comments.
	(struct frame_id): Add inline_depth.
	(enum frame_type): Add INLINE_FRAME.
	(frame_id_inlined_p, get_stack_frame_id): New prototypes.
	* gdbthread.h (struct thread_info): Add step_stack_frame_id field.
	* infcmd.c (set_step_frame): New function.
	(step_once): Use set_step_frame.  Handle inlined functions.
	(until_next_command): Use set_step_frame.
	(finish_backward), finish_forward): Use get_stack_frame_id.
	(finish_command): Support inlined functions.
	* inferior.h (set_step_info): New prototype.
	* infrun.c (RESUME_ALL): Use minus_one_ptid.
	(clear_proceed_status): Clear step_stack_frame_id.
	(init_wait_for_inferior): Call clear_inline_frame_state.
	(init_execution_control_state): Make static.
	(set_step_info): New function.
	(init_thread_stepping_state): Do not set the symtab or line here.
	(stepped_in_from): New function.
	(handle_inferior_event): Handle inlined functions.  Use set_step_info.
	(insert_step_resume_breakpoint_at_frame): Use get_stack_frame_id.
	(struct inferior_status): Add step_stack_frame_id.
	(save_inferior_status, restore_inferior_status): Save and restore
	step_stack_frame_id.
	* inline-frame.c, inline-frame.h: New files.
	* minsyms.c (prim_record_minimal_symbol_and_info): Use XCALLOC.
	* regcache.c (regcache_write_pc): Call reinit_frame_cache.
	* s390-tdep.c (s390_prologue_frame_unwind_cache): Handle INLINE_FRAME.
	* stack.c (frame_show_address): New.
	(print_frame_info, print_frame): Use it.
	(find_frame_funname): Use get_frame_function.  Handle inlined blocks.
	(frame_info): Mark inlined functions.
	(backtrace_command_1): Use get_current_user_frame.
	(print_frame_local_vars, print_frame_label_vars): Update comments.
	(return_command): Refuse inlined functions.
	* symtab.c (lookup_symbol_aux_local): Stop at inlined function
	boundaries.
	(find_function_start_sal): Avoid inlined functions.
	(completion_list_add_fields): New function.
	(default_make_symbol_completion_list): Use it.  Use block_static_block
	and block_global_block.  Check for inlined functions.
	(skip_prologue_using_sal): Avoid line number comparison across
	inlining.
	* symtab.h (struct symbol): Add is_inlined.
	(SYMBOL_INLINED): New.
	* target.c (target_resume): Call clear_inline_frame_state.
	* valops.c (value_of_variable): Check block_inlined_p.

	gdb/doc/
	* gdb.texinfo (Debugging Optimized Code): New chapter.
	(Compiling for Debugging): Reference it.  Move some
	text to the new section.

	gdb/testsuite/
	* gdb.base/break.exp: Add an XFAIL for gcc/36748.
	* gdb.cp/annota2.exp: Accept frames-invalid in more places.
	* gdb.opt/Makefile.in (EXECUTABLES): Update.
	* gdb.opt/clobbered-registers-O2.exp: Update to GPL v3.
	* gdb.opt/inline-bt.c, gdb.opt/inline-bt.exp,
	gdb.opt/inline-cmds.c, gdb.opt/inline-cmds.exp,
	gdb.opt/inline-locals.c, gdb.opt/inline-locals.exp,
	gdb.opt/inline-markers.c: New files.
	* lib/gdb.exp (skip_inline_frame_tests): New function.
	(skip_inline_var_tests): New function.
@
text
@a412 3
/* FIXME: cagney/2002-05-11: The two global arrays registers[] and
   deprecated_register_valid[] currently point into this structure.  */
static struct regcache *current_regcache;
d419 1
a419 1
struct regcache *get_thread_regcache (ptid_t ptid)
d421 5
a425 3
  /* NOTE: uweigand/2007-05-05:  We need to detect the thread's
     current architecture at this point.  */
  struct gdbarch *thread_gdbarch = current_gdbarch;
d427 5
a431 3
  if (current_regcache && ptid_equal (current_regcache->ptid, ptid)
      && get_regcache_arch (current_regcache) == thread_gdbarch)
    return current_regcache;
d433 4
a436 2
  if (current_regcache)
    regcache_xfree (current_regcache);
d438 3
a440 3
  current_regcache = regcache_xmalloc (thread_gdbarch);
  current_regcache->readonly_p = 0;
  current_regcache->ptid = ptid;
d442 6
a447 1
  return current_regcache;
d450 17
a466 1
struct regcache *get_current_regcache (void)
d485 5
a489 3
  if (current_regcache != NULL
      && ptid_equal (current_regcache->ptid, old_ptid))
    current_regcache->ptid = new_ptid;
d506 8
a513 1
  int i;
a514 1
  regcache_xfree (current_regcache);
d517 3
@


1.171
log
@	* inferior.h (read_pc, write_pc): Remove.
	* regcache.c (read_pc, write_pc): Remove.

	* infrun.c (displaced_step_fixup): Use regcache_read_pc instead
	of read_pc.
	(handle_inferior_event): Use regcache_read_pc instead of read_pc
	when determining value of stop_pc.  Replace subsequent uses of
	read_pc by inspecting already-retrieved stop_pc value.
	(keep_going): Use regcache_read_pc instead of read_pc.

	* breakpoint.c (watchpoint_check): Use current frame architecture
	and PC instead of current_gdbarch and read_pc ().
	* tracepoint.c (set_traceframe_context): Replace PC argument
	with FRAME argument.
	(trace_start_command, finish_tfind_command): Update calls.
	(finish_tfind_command): Compare frame IDs to identify transitions
	between frames.
	(trace_find_pc_command): Use regcache_read_pc instead of read_pc.
	* rs6000-nat.c (exec_one_dummy_insn): Pass in regcache instead
	of gdbarch.  Use regcache_read_pc and regcache_write_pc instead
	of read_pc and write_pc.
	(store_register): Make regcache argument non-const.  Update call
	to exec_one_dummy_insn.

	* thread.c (switch_to_thread): Use regcache_read_pc instead of read_pc.
	* infcmd.c (post_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (enable_break, svr4_relocate_main_executable): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Likewise.
	* record.c (record_wait): Likewise.
	* procfs.c (procfs_wait): Likewise.
	* remote-mips.c (common_open, mips_wait): Likewise.
	* remote-m32r-sdi.c (m32r_resume): Likewise.

	* symfile.c (generic_load): Use regcache_write_pc instead of write_pc.
	* monitor.c (monitor_create_inferior, monitor_load): Likewise.
	* m32r-rom.c (m32r_load, m32r_upload_command): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior, m32r_load): Likewise.
	* remote-mips.c (mips_create_inferior, mips_load): Likewise.

	* solib-darwin.c: Include "regcache.h".
	* solib-pa64.c: Include "regcache.h".
	* solib-svr4.c: Include "regcache.h.".

	* symfile.c: Do not mention read_pc or write_pc in comments.
	* dink32-rom.c: Likewise.
	* m32r-rom.c: Likewise.
	* mips-tdep.c: Likewise.
@
text
@d857 4
@


1.170
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@a843 6
CORE_ADDR
read_pc (void)
{
  return regcache_read_pc (get_current_regcache ());
}

a858 6
void
write_pc (CORE_ADDR pc)
{
  regcache_write_pc (get_current_regcache (), pc);
}

@


1.169
log
@        Updated copyright notices for most files.
@
text
@d450 1
a450 1
void
@


1.168
log
@	* cli/cli-logging.c (handle_redirections): Make a cleanup.
	* reggroups.c (maintenance_print_reggroups): Make a cleanup.
	* regcache.c (regcache_print): Make a cleanup.
	* maint.c (maintenance_print_architecture): Make a cleanup.
	* dummy-frame.c (maintenance_print_dummy_frames): Make a cleanup.
@
text
@d4 1
a4 1
   2002, 2004, 2007, 2008 Free Software Foundation, Inc.
@


1.167
log
@2008-08-18  Pedro Alves  <pedro@@codesourcery.com>

	gdb/doc/
	* observer.texi (thread_ptid_changed): New.

	gdb/
	* gdbthread.h (thread_change_ptid): Declare.
	* infrun.c (infrun_thread_ptid_changed): New.
	(_initialize_infrun): Attach infrun_thread_ptid_changed to the
	thread_ptid_changed observer.
	* regcache.c (regcache_thread_ptid_changed): New.
	(_initialize_regcache): Attach regcache_thread_ptid_changed to the
	thread_ptid_changed observer.
	* thread.c (thread_change_ptid): New.
@
text
@d1107 1
d1111 1
d1113 1
a1113 1
      ui_file_delete (file);
@


1.166
log
@	* inferior.h (read_pc_pid, write_pc_pid): Remove.
	* regcache.h (regcache_read_pc, regcache_write_pc): Add prototypes.

	* regcache.c (read_pc_pid): Remove, replace by ...
	(regcache_read_pc): ... this function.
	(write_pc_pid): Remove, replace by ...
	(regcache_write_pc): ... this function.
	(read_pc, write_pc): Update.

	* infrun.c (displaced_step_prepare): Replace read_pc_pid and
	write_pc_pid by regcache_read_pc and regcache_write_pc.
	(displaced_step_fixup): Likewise.
	(resume): Likewise.  Use regcache arch instead of current_gdbarch.
	(prepare_to_proceed): Likewise.
	(proceed): Likewise.
	(adjust_pc_after_break): Likewise.
	(handle_inferior_event): Likewise.

	* linux-nat.c (cancel_breakpoint): Likewise.
	* linux-thread-db.c (check_event): Likewise.
	* aix-thread.c (aix_thread_wait): Likewise.
	* tracepoint.c (trace_dump_command): Likewise.
@
text
@d456 10
d1147 1
@


1.166.4.1
log
@Add record target to GDB.
@
text
@a31 1
#include "record.h"
a660 1
  record_regcache_raw_write_regnum = regnum;
@


1.166.4.2
log
@2008-10-04  Hui Zhu  <teawater@@gmail.com>

	Change from "to_prepare_to_store" to "to_store_registers".
	* record.c (record_beneath_to_prepare_to_store): Removed.
	(record_beneath_to_store_registers): New function pointer.
	Instead "record_beneath_to_prepare_to_store". Will point
	to the low strata target "to_store_registers" function.
	(record_prepare_to_store): Removed.
	(record_store_registers): New function.
	Instead "record_prepare_to_store". Record the change of
	registers from GDB.
	(init_record_ops): Change record_prepare_to_store to
	record_store_registers.
	* record.h (record_beneath_to_prepare_to_store): Removed.
	(record_beneath_to_store_registers): New extern.
	(record_regcache_raw_write_regnum): Remove.
	* target.c (update_current_target): Change
	record_beneath_to_prepare_to_store to
	record_beneath_to_store_registers.

2008-10-06  Michael Snyder  <msnyder@@promb-2s-dhcp59.eng.vmware.com>

	* regcache.c (regcache_raw_write): Remove global variable.
	No need to include "record.h" now.
	* record.c (record_regcache_raw_write_regnum): Remove.
@
text
@d32 1
d662 1
@


1.165
log
@2008-02-26  Greg Law  <glaw@@undo-software.com>

	* regcache.c (registers_changed): Call reinit_frame_cache.
@
text
@d808 1
a808 11
/* read_pc, write_pc, etc.  Special handling for register PC.  */

/* NOTE: cagney/2001-02-18: The functions read_pc_pid(), read_pc() and
   read_sp(), will eventually be replaced by per-frame methods.
   Instead of relying on the global INFERIOR_PTID, they will use the
   contextual information provided by the FRAME.  These functions do
   not belong in the register cache.  */

/* NOTE: cagney/2003-06-07: The functions generic_target_write_pc(),
   write_pc_pid() and write_pc(), all need to be replaced by something
   that does not rely on global state.  But what?  */
d811 1
a811 1
read_pc_pid (ptid_t ptid)
a812 1
  struct regcache *regcache = get_thread_regcache (ptid);
d829 2
a830 2
    internal_error (__FILE__, __LINE__, _("read_pc_pid: Unable to find PC"));

d837 1
a837 1
  return read_pc_pid (inferior_ptid);
d841 1
a841 1
write_pc_pid (CORE_ADDR pc, ptid_t ptid)
a842 1
  struct regcache *regcache = get_thread_regcache (ptid);
d852 1
a852 1
		    _("write_pc_pid: Unable to update PC"));
d858 1
a858 1
  write_pc_pid (pc, inferior_ptid);
@


1.164
log
@
	* sentinel-frame.c (sentinel_frame_prev_register): Do not call
	register_offset_hack anymore.

	* regcache.{c,h} (register_offset_hack): Remove.
@
text
@d475 3
@


1.164.2.1
log
@        * regcache.c (registers_changed): Call reinit_frame_cache.
@
text
@a474 3
  /* Need to forget about any frames we have cached, too. */
  reinit_frame_cache ();

@


1.163
log
@	Updated copyright notices for most files.
@
text
@a763 12
/* Hack to keep code that view the register buffer as raw bytes
   working.  */

int
register_offset_hack (struct gdbarch *gdbarch, int regnum)
{
  struct regcache_descr *descr = regcache_descr (gdbarch);
  gdb_assert (regnum >= 0 && regnum < descr->nr_cooked_registers);
  return descr->register_offset[regnum];
}


@


1.162
log
@2007-10-08  Markus Deuling  <deuling@@de.ibm.com>

	* regcache.c (init_regcache_descr, register_type, read_pc_pid)
	(write_pc_pid, regcache_dump): Replace current_gdbarch by gdbarch.
	* regcache.c (regcache_raw_write): Use get_regcache_arch or
	get_frame_arch to get at the current architecture by regcache or by
	frame, respectively.
@
text
@d4 1
a4 1
   2002, 2004, 2007 Free Software Foundation, Inc.
@


1.161
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d95 3
a97 3
  descr->nr_cooked_registers = gdbarch_num_regs (current_gdbarch)
			       + gdbarch_num_pseudo_regs (current_gdbarch);
  descr->sizeof_cooked_register_valid_p = gdbarch_num_regs (current_gdbarch)
d99 1
a99 1
					      (current_gdbarch);
d109 1
a109 1
  descr->nr_raw_registers = gdbarch_num_regs (current_gdbarch);
d177 2
a178 2
	      && regnum < (gdbarch_num_regs (current_gdbarch)
			   + gdbarch_num_pseudo_regs (current_gdbarch)));
d645 1
a645 1
  if (gdbarch_cannot_store_register (current_gdbarch, regnum))
d840 1
a840 1
  else if (gdbarch_pc_regnum (current_gdbarch) >= 0)
d844 1
a844 1
				     gdbarch_pc_regnum (current_gdbarch),
d846 1
a846 1
      pc_val = gdbarch_addr_bits_remove (current_gdbarch, raw_val);
d868 1
a868 1
  else if (gdbarch_pc_regnum (current_gdbarch) >= 0)
d870 1
a870 1
				    gdbarch_pc_regnum (current_gdbarch), pc);
d941 1
a941 1
		      gdbarch_num_regs (current_gdbarch));
d943 1
a943 1
		      gdbarch_num_pseudo_regs (current_gdbarch));
d947 2
a948 2
	      == (gdbarch_num_regs (current_gdbarch)
		  + gdbarch_num_pseudo_regs (current_gdbarch)));
d957 1
a957 1
	  const char *p = gdbarch_register_name (current_gdbarch, regnum);
d974 1
a974 1
      else if (regnum < gdbarch_num_regs (current_gdbarch))
d978 1
a978 1
			    (regnum - gdbarch_num_regs (current_gdbarch)));
d1053 1
a1053 1
				 gdbarch_byte_order (current_gdbarch), buf,
d1068 1
a1068 1
				 gdbarch_byte_order (current_gdbarch), buf,
@


1.160
log
@	* regcache.c (write_pc_pid): Restore missing else.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.159
log
@	* regcache.c (regcache_print): Use get_current_regcache ()
	instead of current_regcache.
@
text
@d870 1
a870 1
  if (gdbarch_pc_regnum (current_gdbarch) >= 0)
@


1.158
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1117 1
a1117 1
    regcache_dump (current_regcache, gdb_stdout, what_to_dump);
d1123 1
a1123 1
      regcache_dump (current_regcache, file, what_to_dump);    
@


1.157
log
@	* regcache.c (struct regcache): Add ptid_t member.
	(regcache_xmalloc): Initialize it.
	(regcache_cpy_no_passthrough): Do not refer to current_regcache.
	(regcache_dup): Likewise.
	(regcache_dup_no_passthrough): Likewise.
	(current_regcache): Make static.
	(registers_ptid): Remove variable.
	(get_thread_regcache): New function.
	(get_current_regcache): New function.
	(registers_changed): Implement by freeing current regcache.
	(regcache_raw_read): Do not refer to current_regcache.  Set
	inferior_ptid to regcache->ptid while calling target routines.
	(regcache_raw_write): Likewise.
	(regcache_raw_supply): Do not refer to current_regcache.
	(read_pc_pid): Use thread regcache.  Do not modify inferior_ptid.
	(write_pc_pid): Likewise.
	(build_regcache): Remove.
	(_initialize_regcache): Do not call DEPRECATED_REGISTER_GDBARCH_SWAP
	or deprecated_register_gdbarch_swap.  Do not initialize
	registers_ptid.
	* regcache.h (get_current_regcache): Add prototype.
	(get_thread_regcache): Likewise.
	(current_regcache): Remove declaration.

	* corelow.c (core_open): Replace current_regcache by
	get_current_regcache ().
	* frame.c (frame_pop): Likewise.
	(put_frame_register): Likewise.
	(get_current_frame, create_new_frame): Likewise.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Likewise.
	* stack.c (return_command): Likewise.
	* infcall.c (call_function_by_hand): Likewise.
	* infrun.c (resume): Likewise.
	(save_inferior_status, restore_inferior_status): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	(fork_save_infrun_state): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* i386fbsd-nat.c (i386fbsd_resume): Likewise.
	* monitor.c (monitor_wait): Likewise.
	* remote.c (remote_wait): Likewise.
	* remote-mips.c (mips_wait): Likewise.

	* bsd-kvm.c (bsd_kvm_open): Likewise
	(bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Likewise.
	* fbsd-nat.c (fbsd_make_corefile_notes): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* ia64-linux-nat.c (ia64_linux_insert_watchpoint): Likewise.
	(ia64_linux_stopped_data_address): Likewise.

	* frv-tdep.c (frv_fdpic_loadmap_addresses): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* mep-tdep.c (current_me_module, current_options): Likewise.
	* mips-tdep.c (deprecated_mips_set_processor_regs_hack): Likewise.

	* linux-nat.c (linux_nat_do_thread_registers): Use thread
	regcache instead of current_regcache.  Call target_fetch_registers.
	(linux_nat_corefile_thread_callback): Update call site.
	(linux_nat_do_registers): Likewise.
	* procfs.c (procfs_do_thread_registers): Use thread regcache instead
	of current_regcache.
	(procfs_make_note_section): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
@
text
@d842 1
a842 1
  else if (PC_REGNUM >= 0)
d845 3
a847 1
      regcache_cooked_read_unsigned (regcache, PC_REGNUM, &raw_val);
d870 3
a872 2
  else if (PC_REGNUM >= 0)
    regcache_cooked_write_unsigned (regcache, PC_REGNUM, pc);
@


1.156
log
@	* regcache.c (read_register, read_register_pid): Remove.
	(write_register, write_register_pid): Likewise.
	* regcache.h (read_register, read_register_pid): Remove prototype.
	(write_register, write_register_pid): Likewise.
@
text
@d206 3
d225 1
d364 1
a364 1
     move of data into the current_regcache().  Doing this would be
d366 1
a366 1
  gdb_assert (dst != current_regcache);
a375 1
  gdb_assert (current_regcache != NULL);
a384 1
  gdb_assert (current_regcache != NULL);
d417 1
a417 1
struct regcache *current_regcache;
d424 24
a447 1
/* The thread/process associated with the current set of registers. */
a448 1
static ptid_t registers_ptid;
d474 2
a475 1
  registers_ptid = pid_to_ptid (-1);
a482 3

  for (i = 0; i < current_regcache->descr->nr_raw_registers; i++)
    regcache_invalidate (current_regcache, i);
d497 1
a497 2
      gdb_assert (regcache == current_regcache);
      if (! ptid_equal (registers_ptid, inferior_ptid))
d499 4
a502 2
	  registers_changed ();
	  registers_ptid = inferior_ptid;
a503 2
      if (!regcache_valid_p (regcache, regnum))
	target_fetch_registers (regcache, regnum);
d639 2
a649 8
  /* Make certain that the correct cache is selected.  */
  gdb_assert (regcache == current_regcache);
  if (! ptid_equal (registers_ptid, inferior_ptid))
    {
      registers_changed ();
      registers_ptid = inferior_ptid;
    }

d657 3
d665 2
a789 9
  /* FIXME: kettenis/20030828: It shouldn't be necessary to handle
     CURRENT_REGCACHE specially here.  */
  if (regcache == current_regcache
      && !ptid_equal (registers_ptid, inferior_ptid))
    {
      registers_changed ();
      registers_ptid = inferior_ptid;
    }

d834 1
a834 1
  struct regcache *regcache = current_regcache;
a836 1
  ptid_t saved_inferior_ptid;
a838 4
  /* In case ptid != inferior_ptid. */
  saved_inferior_ptid = inferior_ptid;
  inferior_ptid = ptid;

a850 1
  inferior_ptid = saved_inferior_ptid;
d863 1
a863 1
  struct regcache *regcache = current_regcache;
a865 6
  ptid_t saved_inferior_ptid;

  /* In case ptid != inferior_ptid. */
  saved_inferior_ptid = inferior_ptid;
  inferior_ptid = ptid;

a872 2

  inferior_ptid = saved_inferior_ptid;
a891 7
build_regcache (void)
{
  current_regcache = regcache_xmalloc (current_gdbarch);
  current_regcache->readonly_p = 0;
}

static void
a1154 2
  DEPRECATED_REGISTER_GDBARCH_SWAP (current_regcache);
  deprecated_register_gdbarch_swap (NULL, 0, build_regcache);
a1160 4
   /* Initialize the thread/process associated with the current set of
      registers.  For now, -1 is special, and means `no current process'.  */
  registers_ptid = pid_to_ptid (-1);

@


1.155
log
@	* gdbarch.sh (read_pc): Add REGCACHE argument.  Remove PTID argument.
	(write_pc): Likewise.  Remove default implementation, add predicate.
	* gdbarch.c, gdbarch.h: Regenerate.
	* regcache.c (read_pc_pid): Use current regcache instead of calling
	read_register_pid.
	(write_pc_pid): Check gdbarch_write_pc predicate, implement default
	case inline.
	(generic_target_write_pc): Remove.
	* inferior.h (generic_target_write_pc): Remove.
	* frv-tdep.c (frv_gdbarch_init): Do not install it.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Likewise.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	* sh64-tdep.c (sh64_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.

	* avr-tdep.c (avr_read_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling read_register_pid.
	* hppa-hpux-tdep.c (hppa_hpux_read_pc): Likewise.
	* hppa-tdep.c (hppa_read_pc): Likewise.
	* hppa-tdep.h (hppa_read_pc): Likewise.
	* ia64-tdep.c (ia64_read_pc): Likewise.
	* m32r-tdep.c (m32r_read_pc): Likewise.
	* mep-tdep.c (mep_read_pc): Likewise.
	* mn10300-tdep.c (mn10300_read_pc): Likewise.
	* spu-tdep.c (spu_read_pc): Likewise.

	* arm-tdep.c (arm_write_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling write_register_pid.
	* avr-tdep.c (avr_write_pc): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_write_pc): Likewise.
	* hppa-tdep.c (hppa_write_pc): Likewise.
	* hppa-tdep.h (hppa_write_pc): Likewise.
	* i386-linux-tdep.c (i386_linux_write_pc): Likewise.
	* amd64-linux-tdep.c (amd64_linux_write_pc): Likewise.
	* ia64-linux-tdep.c (ia64_linux_write_pc): Likewise.
	* ia64-tdep.c (ia64_write_pc): Likewise.
	* ia64-tdep.h (ia64_write_pc): Likewise.
	* m32r-tdep.c (m32r_write_pc): Likewise.
	* m88k-tdep.c (m88k_write_pc): Likewise.
	* mep-tdep.c (mep_write_pc): Likewise.
	* mips-tdep.c (mips_write_pc): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.
	* mn10300-tdep.c (mn10300_write_pc): Likewise.
	* sparc-tdep.c (sparc_write_pc): Likewise.
	* spu-tdep.c (spu_write_pc): Likewise.

	* mips-tdep.c (read_signed_register): Remove.
	(read_signed_register_pid): Likewise.
	(mips_read_pc): Add REGCACHE argument.  Remove PTID argument.
	Use REGCACHE instead of calling read_signed_register_pid.
@
text
@a756 67
/* Return the contents of register REGNUM as an unsigned integer.  */

ULONGEST
read_register (int regnum)
{
  gdb_byte *buf = alloca (register_size (current_gdbarch, regnum));
  gdb_assert (current_regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == current_gdbarch);
  regcache_cooked_read (current_regcache, regnum, buf);
  return (extract_unsigned_integer (buf, register_size (current_gdbarch, regnum)));
}

ULONGEST
read_register_pid (int regnum, ptid_t ptid)
{
  ptid_t save_ptid;
  int save_pid;
  CORE_ADDR retval;

  if (ptid_equal (ptid, inferior_ptid))
    return read_register (regnum);

  save_ptid = inferior_ptid;

  inferior_ptid = ptid;

  retval = read_register (regnum);

  inferior_ptid = save_ptid;

  return retval;
}

/* Store VALUE into the raw contents of register number REGNUM.  */

void
write_register (int regnum, LONGEST val)
{
  void *buf;
  int size;
  size = register_size (current_gdbarch, regnum);
  buf = alloca (size);
  store_signed_integer (buf, size, (LONGEST) val);
  gdb_assert (current_regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == current_gdbarch);
  regcache_cooked_write (current_regcache, regnum, buf);
}

void
write_register_pid (int regnum, CORE_ADDR val, ptid_t ptid)
{
  ptid_t save_ptid;

  if (ptid_equal (ptid, inferior_ptid))
    {
      write_register (regnum, val);
      return;
    }

  save_ptid = inferior_ptid;

  inferior_ptid = ptid;

  write_register (regnum, val);

  inferior_ptid = save_ptid;
}
@


1.154
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (ADDR_BITS_REMOVE): Replace by gdbarch_addr_bits_remove.
	* value.c (value_as_address): Likewise (comment).
	* remote-mips.c (common_breakpoint): Likewise.
	* regcache.c (read_pc_pid): Likewise.
	* printcmd.c (do_one_display): Likewise.
	* monitor.c (monitor_write_memory, monitor_read_memory)
	(monitor_insert_breakpoint): Likewise.
	* mips-tdep.c (heuristic_proc_start): Likewise.
	* infrun.c (insert_step_resume_breakpoint_at_frame)
	(insert_step_resume_breakpoint_at_caller): Likewise.
	* buildsym.c (record_line): Likewise.
	* arm-tdep.c (arm_scan_prologue, thumb_get_next_pc)
	(arm_get_next_pc): Likewise.
	* armnbsd-nat.c (arm_supply_gregset, fetch_register, store_register)
	(store_regs): Likewise.
	* arm-linux-tdep.c (arm_linux_supply_gregset): Likewise.
	* arm-linux-nat.c (fetch_register, fetch_regs): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d890 3
d900 2
a901 2
  if (TARGET_READ_PC_P ())
    pc_val = TARGET_READ_PC (ptid);
d905 2
a906 1
      CORE_ADDR raw_val = read_register_pid (PC_REGNUM, ptid);
d923 1
a923 1
generic_target_write_pc (CORE_ADDR pc, ptid_t ptid)
d925 2
a926 6
  if (PC_REGNUM >= 0)
    write_register_pid (PC_REGNUM, pc, ptid);
  else
    internal_error (__FILE__, __LINE__,
		    _("generic_target_write_pc"));
}
a927 3
void
write_pc_pid (CORE_ADDR pc, ptid_t ptid)
{
d934 7
a940 1
  TARGET_WRITE_PC (pc, ptid);
@


1.153
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (REGISTER_NAME): Replace by gdbarch_register_name.
	* tracepoint.c (scope_info): Likewise.
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_register_reggroup_p): Likewise.
	* sh64-tdep.c (sh64_do_fp_register, sh64_do_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_reggroup_p): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* remote.c (packet_reg): Likewise (comment).
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* printcmd.c (address_info): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* mt-dep.c (mt_registers_info): Likewise.
	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Likewise (comment).
	* mips-tdep.c (mips_register_reggroup_p, mips_read_fp_register_single)
	(mips_read_fp_register_double, mips_print_fp_register)
	(mips_print_register, print_gp_register_row, mips_print_registers_info)
	(mips_register_sim_regno): Likewise.
	* m68klinux-nat.c (regmap, fetch_register, store_register): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register)
	(inf_ptrace_store_register): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register)
	(ia64_linux_store_register): Likewise.
	* i386-linux-nat.c (fetch_register, store_register): Likewise.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register)
	(hppa_hpux_store_register): Likewise.
	* findvar.c (locate_var_value): Likewise.
	* dwarf2loc.c (locexpr_describe_location): Likewise.
	* dwarf2-frame.c (execute_cfa_program): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* arch-utils.c (legacy_register_sim_regno): Likewise.
	* alpha-tdep.c (alpha_register_reggroup_p): Likewise.
	* alpha-nat.c (fetch_osf_core_registers): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers, mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d903 1
a903 1
      pc_val = ADDR_BITS_REMOVE (raw_val);
@


1.152
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d1030 1
a1030 1
	  const char *p = REGISTER_NAME (regnum);
@


1.151
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (CANNOT_FETCH_REGISTER): Replace by
	gdbarch_cannot_fetch_register.
	* alpha-nat.c (fetch_osf_core_registers): Likewise.
	* hppa-linux-nat.c (fetch_register): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	* m68klinux-nat.c (fetch_register): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_supply_fpreg):
	Likewise.
	* gdbarch.sh (CANNOT_STORE_REGISTER): Replace by
	gdbarch_cannot_store_register.
	* hppa-linux-nat.c (store_register): Likewise.
	* inf-ptrace.c (inf_ptrace_store_register): Likewise.
	* regcache.c (regcache_raw_write): Likewise.
	* m68klinux-nat.c (store_register): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_fill_reg, mipsnbsd_fill_fpreg): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d97 5
a101 2
  descr->nr_cooked_registers = NUM_REGS + NUM_PSEUDO_REGS;
  descr->sizeof_cooked_register_valid_p = NUM_REGS + NUM_PSEUDO_REGS;
d111 1
a111 1
  descr->nr_raw_registers = NUM_REGS;
d115 2
a116 2
     of the global register_valid_p[] array in the range [NUM_REGS
     .. NUM_REGS + NUM_PSEUDO_REGS).  */
d178 3
a180 1
  gdb_assert (regnum >= 0 && regnum < (NUM_REGS + NUM_PSEUDO_REGS));
d191 2
a192 2
     full [0 .. NUM_REGS + NUM_PSEUDO_REGS) while a read/write
     register cache can only hold [0 .. NUM_REGS).  */
d278 2
a279 2
     save_reggroup) and mark them as valid.  The full [0 .. NUM_REGS +
     NUM_PSEUDO_REGS) range is checked since some architectures need
d308 2
a309 2
     were both saved and need to be restored.  The full [0 .. NUM_REGS
     + NUM_PSEUDO_REGS) range is checked since some architectures need
d1013 4
a1016 2
  fprintf_unfiltered (file, "NUM_REGS %d\n", NUM_REGS);
  fprintf_unfiltered (file, "NUM_PSEUDO_REGS %d\n", NUM_PSEUDO_REGS);
d1020 2
a1021 1
	      == (NUM_REGS + NUM_PSEUDO_REGS));
d1047 1
a1047 1
      else if (regnum < NUM_REGS)
d1050 2
a1051 1
	fprintf_unfiltered (file, " %4d", (regnum - NUM_REGS));
@


1.150
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_BYTE_ORDER): Replace by gdbarch_byte_order.
	* ax-gdb.c (gen_bitfield_ref): Likewise.
	* mi/mi-main.c (get_register): Likewise.
	* findvar.c (default_value_from_register, extract_signed_integer)
	(extract_unsigned_integer, extract_long_unsigned_integer)
	(store_signed_integer, store_unsigned_integer): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* value.c (lookup_internalvar, value_of_internalvar)
	(set_internalvar): Likewise.
	* defs.h: Likewise.
	* valprint.c (print_binary_chars, print_octal_chars)
	(print_decimal_chars, print_hex_chars, print_char_chars): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* arch-utils.c (selected_byte_order, show_endian): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* doublest.c (floatformat_from_length, floatformat_from_type)
	(extract_typed_floating, store_typed_floating): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d619 1
a619 1
  if (CANNOT_STORE_REGISTER (regnum))
@


1.149
log
@	* inferior.h (read_sp): Remove prototype.
	* regcache.c (read_sp): Remove.
	* gcore.c (derive_stack_segment): Use get_frame_sp instead of read_sp.
	* infcall.c (call_function_by_hand): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call): Use regcache instead
	of calling read_sp.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
@
text
@d1116 2
a1117 1
	      dump_endian_bytes (file, TARGET_BYTE_ORDER, buf,
d1131 2
a1132 1
	      dump_endian_bytes (file, TARGET_BYTE_ORDER, buf,
@


1.148
log
@	* regcache.c (regcache_invalidate): New function.
	(register_cached): Remove.
	(set_register_cached): Remove.
	(deprecated_registers_fetched): Remove.
	(registers_changed): Use regcache_invalidate instead
	of set_register_cached.
	(regcache_raw_read): Update comment.

	* regcache.h (regcache_invalidate): Add prototype.
	(register_cached): Remove.
	(set_register_cached): Remove.
	(deprecated_registers_fetched): Remove.

	* findvar.c (value_of_register): Do not call register_cached.
	* frame.c (frame_register): Likewise.
	* tui/tui-regs.c (tui_get_register): Likewise.

	* remote.c (fetch_register_using_p): Do not call set_register_cached.
	(process_g_packet): Likewise.
	(remote_fetch_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* mt-tdep.c (mt_select_coprocessor): Replace set_register_cached call
	by regcache_invalidate.
	(mt_pseudo_register_write): Likewise.
	* sh-tdep.c (sh_pseudo_register_write): Likewise.

	* corelow.c (get_core_registers): Replace deprecated_registers_fetched
	call by loop over regcache_raw_supply (..., NULL).
@
text
@d870 1
a870 2
/* read_pc, write_pc, read_sp, etc.  Special handling for registers
   PC, SP, and FP.  */
a942 15
/* Cope with strage ways of getting to the stack and frame pointers */

CORE_ADDR
read_sp (void)
{
  if (TARGET_READ_SP_P ())
    return TARGET_READ_SP ();
  else if (gdbarch_unwind_sp_p (current_gdbarch))
    return get_frame_sp (get_current_frame ());
  else if (SP_REGNUM >= 0)
    /* Try SP_REGNUM last: this makes all sorts of [wrong] assumptions
       about the architecture so put it at the end.  */
    return read_register (SP_REGNUM);
  internal_error (__FILE__, __LINE__, _("read_sp: Unable to find SP"));
}
@


1.147
log
@	* target.h (struct target_ops): Add REGCACHE parameter to
	to_prepare_to_store.
	(target_prepare_to_store): Likewise.
	* target.c (debug_to_prepare_to_store): Add REGCACHE parameter.
	(update_current_target): Adapt prepare_to_store de_fault rule.

	* regcache.c (regcache_raw_write): Pass regcache to
	target_prepare_to_store.

	* inftarg.c (child_prepare_to_store): Add REGCACHE parameter.
	Do not call CHILD_PREPARE_TO_STORE.
	* gnu-nat.c (gnu_prepare_to_store): Likewise.
	* procfs.c (procfs_prepare_to_store): Likewise.

	* inf-child.c (inf_child_prepare_to_store): Add REGCACHE parameter.
	* go32-nat.c (go32_prepare_to_store): Likewise.
	* monitor.c (monitor_prepare_to_store): Likewise.
	* nto-procfs.c (procfs_prepare_to_store): Likewise.
	* remote-m32r-sdi.c (m32r_prepare_to_store): Likewise.
	* remote-mips.c (mips_prepare_to_store): Likewise.
	* remote-sim.c (gdbsim_prepare_to_store): Likewise.
	* win32-nat.c (win32_prepare_to_store): Likewise.

	* remote.c (remote_prepare_to_store): Add REGCACHE parameter.
	Use it instead of current_regcache.

	* hpux-thread.c (hpux_thread_prepare_to_store): Add REGCACHE
	parameter.  Pass it on to next target.
	* sol-thread.c (sol_thread_prepare_to_store): Likewise.
@
text
@d396 11
a420 27
/*
 * FUNCTIONS:
 */

/* REGISTER_CACHED()

   Returns 0 if the value is not in the cache (needs fetch).
          >0 if the value is in the cache.
	  <0 if the value is permanently unavailable (don't ask again).  */

int
register_cached (int regnum)
{
  return current_regcache->register_valid_p[regnum];
}

/* Record that REGNUM's value is cached if STATE is >0, uncached but
   fetchable if STATE is 0, and uncached and unfetchable if STATE is <0.  */

void
set_register_cached (int regnum, int state)
{
  gdb_assert (regnum >= 0);
  gdb_assert (regnum < current_regcache->descr->nr_raw_registers);
  current_regcache->register_valid_p[regnum] = state;
}

d455 1
a455 1
    set_register_cached (i, 0);
a457 19
/* DEPRECATED_REGISTERS_FETCHED ()

   Indicate that all registers have been fetched, so mark them all valid.  */

/* FIXME: cagney/2001-12-04: This function is DEPRECATED.  The target
   code was blatting the registers[] array and then calling this.
   Since targets should only be using regcache_raw_supply() the need for
   this function/hack is eliminated.  */

void
deprecated_registers_fetched (void)
{
  int i;

  for (i = 0; i < NUM_REGS; i++)
    set_register_cached (i, 1);
  /* Do not assume that the pseudo-regs have also been fetched.
     Fetching all real regs NEVER accounts for pseudo-regs.  */
}
d485 1
a485 1
      gdb_assert (register_cached (regnum));
@


1.146
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@d672 1
a672 1
  target_prepare_to_store ();
@


1.145
log
@	* regcache.c (deprecated_read_register_gen): Remove, inline ...
	(read_register): ... here.
	(deprecated_write_register_gen): Remove, inline ...
	(write_register): ... here.
	* regcache.h (deprecated_read_register_gen): Remove prototype.
	(deprecated_write_register_gen): Likewise.

	* remote-sim.c (gdbsim_store_register): Replace call to
	deprecated_read_register_gen with regcache_cooked_read.
	* target.c (debug_print_register): Replace calls to
	deprecated_read_register_gen and read_register with
	regcache_cooked_read.
@
text
@d511 2
a512 2
      if (!register_cached (regnum))
	target_fetch_registers (regnum);
d676 1
a676 1
  target_store_registers (regnum);
@


1.144
log
@	* gdbarch.sh: Remove deprecated_register_byte.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_register_size, generic_register_byte): Remove.
	* arch-utils.c (generic_register_size, generic_register_byte): Remove.

	* regcache.h (regcache_valid_p): Make REGCACHE parameter const.
	* regcache.c (regcache_valid_p): Allow to query cooked registers in
	read-only register caches.  Make REGCACHE parameter const.
	(regcache_dump): Do not check DEPRECATED_REGISTER_BYTE.

	* mi/mi-main.c (old_regs): Remove.
	(mi_setup_architecture_data, _initialize_mi_main): Remove.
	(register_changed_p): Reimplement to compare two register caches.
	(mi_cmd_data_list_changed_registers): Update caller.
	* mi/mi-main.h (mi_setup_architecture_data): Remove.
	* mi/mi-interp.c (mi_interpreter_init): Do not call
	mi_setup_architecture_data.
@
text
@a576 8
deprecated_read_register_gen (int regnum, gdb_byte *buf)
{
  gdb_assert (current_regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == current_gdbarch);
  regcache_cooked_read (current_regcache, regnum, buf);
}

void
a679 8
deprecated_write_register_gen (int regnum, gdb_byte *buf)
{
  gdb_assert (current_regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == current_gdbarch);
  regcache_cooked_write (current_regcache, regnum, buf);
}

void
d793 3
a795 1
  deprecated_read_register_gen (regnum, buf);
d830 3
a832 1
  deprecated_write_register_gen (regnum, buf);
@


1.143
log
@	* defs.h (deprecated_registers_changed_hook): Delete declaration.
	* interps.c (clear_interpreter_hooks): Do not clear
	deprecated_registers_changed_hook.
	* regcache.c (registers_changed): Do not call it.
	* top.c (deprecated_registers_changed_hook): Do not define it.
	* mi/mi-interp.c (mi_command_loop): Do not clear it.
	* tui/tui-hooks.c (tui_install_hooks): Do not install it.
	(tui_remove_hooks): Do not remove it.
	(tui_selected_frame_level_changed_hook): Check for negative level.
	Use get_selected_frame.
	(tui_registers_changed_hook): Deleted.
@
text
@d384 1
a384 1
regcache_valid_p (struct regcache *regcache, int regnum)
d387 6
a392 1
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
a1114 1
	      || register_offset != DEPRECATED_REGISTER_BYTE (regnum)
@


1.142
log
@	* gdbarch.sh (deprecated_extract_return_value)
	(deprecated_store_return_value): Remove.
	(extract_return_value, store_return_value): Remove default values.
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.c, arch-utils.h (legacy_extract_return_value)
	(legacy_store_return_value): Remove.
	* regcache.c, regcache.h (deprecated_grub_regcache_for_registers):
	Remove.
@
text
@a466 3

  if (deprecated_registers_changed_hook)
    deprecated_registers_changed_hook ();
@


1.141
log
@	* regcache.c, regcache.h (deprecated_register_bytes)
	(deprecated_read_register_bytes)
	(deprecated_write_register_bytes): Remove.
@
text
@a390 6
gdb_byte *
deprecated_grub_regcache_for_registers (struct regcache *regcache)
{
  return regcache->registers;
}

@


1.140
log
@Copyright updates for 2007.
@
text
@a497 78
/* deprecated_read_register_bytes and deprecated_write_register_bytes
   are generally a *BAD* idea.  They are inefficient because they need
   to check for partial updates, which can only be done by scanning
   through all of the registers and seeing if the bytes that are being
   read/written fall inside of an invalid register.  [The main reason
   this is necessary is that register sizes can vary, so a simple
   index won't suffice.]  It is far better to call read_register_gen
   and write_register_gen if you want to get at the raw register
   contents, as it only takes a regnum as an argument, and therefore
   can't do a partial register update.

   Prior to the recent fixes to check for partial updates, both read
   and deprecated_write_register_bytes always checked to see if any
   registers were stale, and then called target_fetch_registers (-1)
   to update the whole set.  This caused really slowed things down for
   remote targets.  */

/* Copy INLEN bytes of consecutive data from registers
   starting with the INREGBYTE'th byte of register data
   into memory at MYADDR.  */

void
deprecated_read_register_bytes (int in_start, gdb_byte *in_buf, int in_len)
{
  int in_end = in_start + in_len;
  int regnum;
  gdb_byte reg_buf[MAX_REGISTER_SIZE];

  /* See if we are trying to read bytes from out-of-date registers.  If so,
     update just those registers.  */

  for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
    {
      int reg_start;
      int reg_end;
      int reg_len;
      int start;
      int end;
      int byte;

      reg_start = DEPRECATED_REGISTER_BYTE (regnum);
      reg_len = register_size (current_gdbarch, regnum);
      reg_end = reg_start + reg_len;

      if (reg_end <= in_start || in_end <= reg_start)
	/* The range the user wants to read doesn't overlap with regnum.  */
	continue;

      if (REGISTER_NAME (regnum) != NULL && *REGISTER_NAME (regnum) != '\0')
	/* Force the cache to fetch the entire register.  */
	deprecated_read_register_gen (regnum, reg_buf);

      /* Legacy note: This function, for some reason, allows a NULL
         input buffer.  If the buffer is NULL, the registers are still
         fetched, just the final transfer is skipped. */
      if (in_buf == NULL)
	continue;

      /* start = max (reg_start, in_start) */
      if (reg_start > in_start)
	start = reg_start;
      else
	start = in_start;

      /* end = min (reg_end, in_end) */
      if (reg_end < in_end)
	end = reg_end;
      else
	end = in_end;

      /* Transfer just the bytes common to both IN_BUF and REG_BUF */
      for (byte = start; byte < end; byte++)
	{
	  in_buf[byte - in_start] = reg_buf[byte - reg_start];
	}
    }
}

a711 49
/* Copy INLEN bytes of consecutive data from memory at MYADDR
   into registers starting with the MYREGSTART'th byte of register data.  */

void
deprecated_write_register_bytes (int myregstart, gdb_byte *myaddr, int inlen)
{
  int myregend = myregstart + inlen;
  int regnum;

  target_prepare_to_store ();

  /* Scan through the registers updating any that are covered by the
     range myregstart<=>myregend using write_register_gen, which does
     nice things like handling threads, and avoiding updates when the
     new and old contents are the same.  */

  for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
    {
      int regstart, regend;

      regstart = DEPRECATED_REGISTER_BYTE (regnum);
      regend = regstart + register_size (current_gdbarch, regnum);

      /* Is this register completely outside the range the user is writing?  */
      if (myregend <= regstart || regend <= myregstart)
	/* do nothing */ ;		

      /* Is this register completely within the range the user is writing?  */
      else if (myregstart <= regstart && regend <= myregend)
	deprecated_write_register_gen (regnum, myaddr + (regstart - myregstart));

      /* The register partially overlaps the range being written.  */
      else
	{
	  gdb_byte regbuf[MAX_REGISTER_SIZE];
	  /* What's the overlap between this register's bytes and
             those the caller wants to write?  */
	  int overlapstart = max (regstart, myregstart);
	  int overlapend   = min (regend,   myregend);

	  /* We may be doing a partial update of an invalid register.
	     Update it from the target before scribbling on it.  */
	  deprecated_read_register_gen (regnum, regbuf);

	  target_store_registers (regnum);
	}
    }
}

a806 8
/* Hack to keep code using register_bytes working.  */

int
deprecated_register_bytes (void)
{
  return current_regcache->descr->sizeof_raw_registers;
}

@


1.139
log
@2006-07-21  Frederic Riss  <frederic.riss@@st.com>

	* regcache.c (struct regcache): Make register_valid_p a signed
char
	array.
@
text
@d3 2
a4 2
   Copyright (C) 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000,
   2001, 2002, 2004 Free Software Foundation, Inc.
@


1.138
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d189 5
a193 1
  gdb_byte *register_valid_p;
@


1.138.14.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d189 1
a189 5
  /* Register cache status:
     register_valid_p[REG] == 0 if REG value is not in the cache
                            > 0 if REG value is in the cache
                            < 0 if REG value is permanently unavailable */
  signed char *register_valid_p;
@


1.137
log
@* regcache.c (regcache_raw_supply, regcache_raw_collect): Change
type of last argument back to `void *'.
* regcache.h (regcache_raw_supply, regcache_raw_collect): Likewise.
@
text
@d3 1
a3 1
   Copyright 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.136
log
@2005-05-19  Andrew Cagney  <cagney@@gnu.org>

	* regcache.h (regcache_raw_read, regcache_raw_write)
	(regcache_raw_read_part, regcache_raw_write_part)
	(regcache_cooked_read_part, regcache_cooked_write_part)
	(regcache_cooked_read, regcache_cooked_write)
	(regcache_raw_supply, regcache_raw_collect)
	(regcache_cooked_read_ftype, regcache_save, regcache_restore)
	(deprecated_read_register_gen, deprecated_write_register_gen)
	(deprecated_read_register_bytes, deprecated_write_register_bytes)
	(deprecated_grub_regcache_for_registers): Use gdb_byte for byte
	buffer parameters.
	* ia64-tdep.c (ia64_extract_return_value): Update.
	* frame.c (do_frame_register_read): Update.
	* regcache.c (deprecated_grub_regcache_for_registers)
	(struct regcache, regcache_save, regcache_restore, regcache_cpy)
	(do_cooked_read, regcache_xmalloc, register_buffer)
	(deprecated_read_register_bytes, regcache_raw_read)
	(regcache_raw_read_signed, regcache_raw_read_unsigned)
	(deprecated_read_register_gen, regcache_cooked_read)
	(regcache_cooked_read_signed, regcache_cooked_read_unsigned)
	(deprecated_write_register_gen, regcache_cooked_write)
	(deprecated_write_register_bytes, regcache_raw_read_part)
	(regcache_raw_write_part, regcache_cooked_read_part)
	(regcache_cooked_write_part, read_register, regcache_raw_supply):
@
text
@d1005 1
a1005 2
regcache_raw_supply (struct regcache *regcache, int regnum,
		     const gdb_byte *buf)
d1038 1
a1038 2
regcache_raw_collect (const struct regcache *regcache, int regnum,
		      gdb_byte *buf)
@


1.135
log
@2005-05-09  Andrew Cagney  <cagney@@gnu.org>

	Use gdb_byte in preference to bfd_byte.
	* gdbarch.sh: Update.
	* gdbarch.h, gdbarch.c: Re-generate.
	* ada-lang.c, ada-lang.h, ada-valprint.c, arch-utils.c: Update.
	* c-lang.c, c-lang.h, c-valprint.c, cp-valprint.c: Update.
	* f-lang.c, f-lang.h, f-valprint.c, gdbcore.h, jv-lang.h: Update.
	* jv-valprint.c, language.c, language.h, m2-lang.c: Update.
	* m2-lang.h, m2-valprint.c, objc-lang.c, p-lang.c: Update.
	* p-lang.h, p-valprint.c, regcache.c, scm-lang.c: Update.
	* scm-lang.h, scm-valprint.c, target.c, target.h: Update.
	* tramp-frame.c, valarith.c, valops.c, valprint.c: Update.
	* valprint.h, value.c, value.h: Update.
@
text
@d188 2
a189 2
  char *registers;
  char *register_valid_p;
d209 1
a209 1
    = XCALLOC (descr->sizeof_raw_registers, char);
d211 1
a211 1
    = XCALLOC (descr->sizeof_raw_register_valid_p, char);
d248 1
a248 1
static char *
d259 1
a259 1
  char buf[MAX_REGISTER_SIZE];
d290 1
a290 1
		  void *src)
d293 1
a293 1
  char buf[MAX_REGISTER_SIZE];
d306 1
a306 1
	  int valid = cooked_read (src, regnum, buf);
d314 1
a314 1
do_cooked_read (void *src, int regnum, void *buf)
d331 1
a331 1
  char *buf;
d387 1
a387 1
char *
d516 1
a516 1
deprecated_read_register_bytes (int in_start, char *in_buf, int in_len)
d520 1
a520 1
  char reg_buf[MAX_REGISTER_SIZE];
d573 1
a573 1
regcache_raw_read (struct regcache *regcache, int regnum, void *buf)
d609 1
a609 1
  char *buf;
d622 1
a622 1
  char *buf;
d655 1
a655 1
deprecated_read_register_gen (int regnum, char *buf)
d663 1
a663 1
regcache_cooked_read (struct regcache *regcache, int regnum, void *buf)
d684 1
a684 1
  char *buf;
d697 1
a697 1
  char *buf;
d731 2
a732 1
regcache_raw_write (struct regcache *regcache, int regnum, const void *buf)
d766 1
a766 1
deprecated_write_register_gen (int regnum, char *buf)
d774 2
a775 1
regcache_cooked_write (struct regcache *regcache, int regnum, const void *buf)
d790 1
a790 1
deprecated_write_register_bytes (int myregstart, char *myaddr, int inlen)
d820 1
a820 1
	  char regbuf[MAX_REGISTER_SIZE];
d846 4
a849 1
		    regcache_read_ftype *read, regcache_write_ftype *write)
d881 1
a881 1
			int offset, int len, void *buf)
d891 1
a891 1
			 int offset, int len, const void *buf)
d901 1
a901 1
			   int offset, int len, void *buf)
d911 1
a911 1
			    int offset, int len, const void *buf)
d943 1
a943 1
  char *buf = alloca (register_size (current_gdbarch, regnum));
d1005 2
a1006 1
regcache_raw_supply (struct regcache *regcache, int regnum, const void *buf)
d1039 2
a1040 1
regcache_raw_collect (const struct regcache *regcache, int regnum, void *buf)
@


1.134
log
@        * regcache.c: Fix typo in comment.
@
text
@d847 1
a847 1
  bfd_byte reg[MAX_REGISTER_SIZE];
@


1.133
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d54 1
a54 1
     registers then those regigisters and not the PC lives in the raw
@


1.132
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d1418 1
a1418 1
	   "Force gdb to flush its register cache (maintainer command)");
@


1.131
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d1424 3
a1426 5
  add_cmd ("registers", class_maintenance,
	   maintenance_print_registers,
	   "Print the internal register configuration.\
Takes an optional file parameter.",
	   &maintenanceprintlist);
d1428 3
a1430 4
	   maintenance_print_raw_registers,
	   "Print the internal register configuration including raw values.\
Takes an optional file parameter.",
	   &maintenanceprintlist);
d1432 3
a1434 4
	   maintenance_print_cooked_registers,
	   "Print the internal register configuration including cooked values.\
Takes an optional file parameter.",
	   &maintenanceprintlist);
d1436 3
a1438 3
	   maintenance_print_register_groups,
	   "Print the internal register configuration including each register's group.\
Takes an optional file parameter.",
@


1.130
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d1143 1
a1143 1
    printf_filtered ("Register cache flushed.\n");
@


1.129
log
@2004-11-13  Andrew Cagney  <cagney@@gnu.org>

	* regcache.h (deprecated_register_valid): Delete.
	(deprecated_registers): Delete.
	* regcache.c (deprecated_register_valid): Delete.
	(deprecated_registers): Delete.
	(deprecated_read_register_byte, _initialize_regcache)
	(deprecated_write_register_bytes, build_regcache): Update.
	* config/powerpc/ppc-sim.mt (TDEPFILES): Remove ppc-bdm.o and
	remote-sds.o.
	* config/powerpc/ppc-eabi.mt (TDEPFILES): Ditto.
	* config/mips/embed.mt (TDEPFILES): Remove remote-mips.o.
@
text
@d1079 1
a1079 1
    internal_error (__FILE__, __LINE__, "read_pc_pid: Unable to find PC");
d1098 1
a1098 1
		    "generic_target_write_pc");
d1134 1
a1134 1
  internal_error (__FILE__, __LINE__, "read_sp: Unable to find SP");
d1169 1
a1169 1
      internal_error (__FILE__, __LINE__, "Bad switch");
d1376 1
a1376 1
	perror_with_name ("maintenance print architecture");
@


1.128
log
@2004-10-11  David Anderson  <davea@@sgi.com>

        * regcache.c (regcache_raw_read): Comment was missing "to".
        Extraneous ' removed.
        * gdb_thread_db.h (struct td_thrinfo): ti_lid field
        comment now describes use.
@
text
@a402 17
/* REGISTERS contains the cached register values (in target byte order). */

char *deprecated_registers;

/* DEPRECATED_REGISTER_VALID is 0 if the register needs to be fetched,
                     1 if it has been fetched, and
		    -1 if the register value was not available.  

   "Not available" indicates that the target is not not able to supply
   the register at this state.  The register may become available at a
   later time (after the next resume).  This often occures when GDB is
   manipulating a target that contains only a snapshot of the entire
   system being debugged - some of the registers in such a system may
   not have been saved.  */

signed char *deprecated_register_valid;

d420 1
a420 1
  return deprecated_register_valid[regnum];
a544 9
      else
	/* Legacy note: even though this register is ``invalid'' we
           still need to return something.  It would appear that some
           code relies on apparent gaps in the register array also
           being returned.  */
	/* FIXME: cagney/2001-08-18: This is just silly.  It defeats
           the entire register read/write flow of control.  Must
           resist temptation to return 0xdeadbeef.  */
	memcpy (reg_buf, &deprecated_registers[reg_start], reg_len);
a827 4
	  memcpy (&deprecated_registers[overlapstart],
		  myaddr + (overlapstart - myregstart),
		  overlapend - overlapstart);

a1150 2
  deprecated_registers = deprecated_grub_regcache_for_registers (current_regcache);
  deprecated_register_valid = current_regcache->register_valid_p;
a1412 2
  DEPRECATED_REGISTER_GDBARCH_SWAP (deprecated_registers);
  DEPRECATED_REGISTER_GDBARCH_SWAP (deprecated_register_valid);
@


1.127
log
@2004-08-07  Andrew Cagney  <cagney@@gnu.org>

	* regcache.c (regcache_raw_read): For the moment, #ifdef assert
	that the register is valid.
@
text
@d619 2
a620 2
	 forget (or didn't know that they needed) set this leading to
	 panics.  Also is the problem that target's need to indicate
@


1.126
log
@2004-08-05  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_frame_saved_pc): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* regcache.c (deprecated_read_fp, deprecated_write_sp): Delete.
	* inferior.h (deprecated_read_fp, deprecated_write_sp): Delete.
	* frame.h: Delete deprecated_read_fp from comments.
	* arch-utils.c (deprecated_init_frame_pc_default): Delete.
	* arch-utils.h (deprecated_init_frame_pc_default): Delete.

Index: doc/ChangeLog
2004-08-05  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Target Architecture Definition): Delete
	reference to deprecated_read_fp.
@
text
@d617 7
d625 1
@


1.125
log
@* regcache.c (regcache_raw_read): Assert that, after calling
target_fetch_registers, the register we're reading is cached.
@
text
@d1069 2
a1070 2
/* read_pc, write_pc, read_sp, deprecated_read_fp, etc.  Special
   handling for registers PC, SP, and FP.  */
d1072 5
a1076 5
/* NOTE: cagney/2001-02-18: The functions read_pc_pid(), read_pc(),
   read_sp(), and deprecated_read_fp(), will eventually be replaced by
   per-frame methods.  Instead of relying on the global INFERIOR_PTID,
   they will use the contextual information provided by the FRAME.
   These functions do not belong in the register cache.  */
d1079 2
a1080 3
   write_pc_pid(), write_pc(), and deprecated_read_fp(), all need to
   be replaced by something that does not rely on global state.  But
   what?  */
a1158 16
void
deprecated_write_sp (CORE_ADDR val)
{
  gdb_assert (SP_REGNUM >= 0);
  write_register (SP_REGNUM, val);
}

CORE_ADDR
deprecated_read_fp (void)
{
  if (DEPRECATED_FP_REGNUM >= 0)
    return read_register (DEPRECATED_FP_REGNUM);
  else
    internal_error (__FILE__, __LINE__, "deprecated_read_fp");
}

@


1.124
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_target_read_fp)
	(deprecated_frame_locals_address, deprecated_frame_args_address)
	(deprecated_frame_chain_valid, deprecated_frame_chain)
	(deprecated_init_extra_frame_info, deprecated_pop_frame)
	(deprecated_frame_init_saved_regs, deprecated_get_saved_register)
	(deprecated_do_registers_info, deprecated_init_frame_pc): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* regcache.c (deprecated_read_fp): Do not call
	DEPRECATED_TARGET_READ_FP_P.
	* infcmd.c (default_print_registers_info): Do not call
	DEPRECATED_DO_REGISTERS_INFO.
	* frame-base.c (default_frame_locals_address): Do not call
	DEPRECATED_FRAME_LOCALS_ADDRESS.
	(default_frame_args_address): Do not call
	DEPRECATED_FRAME_ARGS_ADDRESS.
@
text
@d617 1
@


1.123
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_register_bytes): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* regcache.c (deprecated_register_bytes): New function.
	* regcache.h (deprecated_register_bytes): Declare.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* remote.c (init_remote_state): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers, sds_prepare_to_store): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
@
text
@d1169 1
a1169 3
  if (DEPRECATED_TARGET_READ_FP_P ())
    return DEPRECATED_TARGET_READ_FP ();
  else if (DEPRECATED_FP_REGNUM >= 0)
@


1.122
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@d946 8
@


1.121
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	* regcache.h: Delete DEPRECATED_REGISTER_VIRTUAL_SIZE and
	DEPRECATED_REGISTER_RAW_SIZE from comments.
	* regcache.c (init_regcache_descr, regcache_dump): Do not check or
	use DEPRECATED_REGISTER_VIRTUAL_SIZE and
	DEPRECATED_REGISTER_RAW_SIZE.
	* findvar.c (value_of_register): Simplify by assuming that the
	registers raw and virtual sizes are identical.
	* regcache.h: Delete DEPRECATED_REGISTER_VIRTUAL_TYPE in
	comment.
	* arch-utils.c (generic_register_size): Simplify by assuming
	register_type.
@
text
@d552 1
a552 1
      reg_len = DEPRECATED_REGISTER_RAW_SIZE (regnum);
d822 1
a822 1
      regend = regstart + DEPRECATED_REGISTER_RAW_SIZE (regnum);
d951 1
a951 1
  char *buf = alloca (DEPRECATED_REGISTER_RAW_SIZE (regnum));
d953 1
a953 1
  return (extract_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regnum)));
d984 1
a984 1
  size = DEPRECATED_REGISTER_RAW_SIZE (regnum);
@


1.120
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	* regcache.c (legacy_read_register_gen, real_register)
	(legacy_write_register_gen): Delete, not used.
@
text
@a146 14
  /* Sanity check.  Confirm that there is agreement between the
     regcache and the target's redundant DEPRECATED_REGISTER_BYTE (new
     targets should not even be defining it).  */
  for (i = 0; i < descr->nr_cooked_registers; i++)
    {
      if (DEPRECATED_REGISTER_BYTE_P ())
	gdb_assert (descr->register_offset[i] == DEPRECATED_REGISTER_BYTE (i));
#if 0
      gdb_assert (descr->sizeof_register[i] == DEPRECATED_REGISTER_RAW_SIZE (i));
      gdb_assert (descr->sizeof_register[i] == DEPRECATED_REGISTER_VIRTUAL_SIZE (i));
#endif
    }
  /* gdb_assert (descr->sizeof_raw_registers == DEPRECATED_REGISTER_BYTES (i));  */

d1300 2
a1301 19
	{
	  fprintf_unfiltered (file, " %5ld",
			      regcache->descr->sizeof_register[regnum]);
	  if ((regcache->descr->sizeof_register[regnum]
	       != DEPRECATED_REGISTER_RAW_SIZE (regnum))
	      || (regcache->descr->sizeof_register[regnum]
		  != DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum))
	      || (regcache->descr->sizeof_register[regnum]
		  != TYPE_LENGTH (register_type (regcache->descr->gdbarch,
						 regnum)))
	      )
	    {
	      if (!footnote_register_size)
		footnote_register_size = ++footnote_nr;
	      fprintf_unfiltered (file, "*%d", footnote_register_size);
	    }
	  else
	    fprintf_unfiltered (file, " ");
	}
d1345 1
a1345 1
				 DEPRECATED_REGISTER_RAW_SIZE (regnum));
d1359 1
a1359 1
				 DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
@


1.119
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	* regcache.c (struct regcache_descr): Delete legacy_p.
	(init_legacy_regcache_descr): Delete function.
	(init_regcache_descr): Delete call to init_legacy_regcache_descr.
	Do not use deprecated register functions.
	(regcache_raw_read, deprecated_write_register_gen):
	(deprecated_read_register_gen, regcache_raw_write): Delete code
	predicated on legacy_p.
	(register_size): Delete check against register raw size.
@
text
@a464 8
/* Return whether register REGNUM is a real register.  */

static int
real_register (int regnum)
{
  return regnum >= 0 && regnum < NUM_REGS;
}

a611 22
/* Read register REGNUM into memory at MYADDR, which must be large
   enough for REGISTER_RAW_BYTES (REGNUM).  Target byte-order.  If the
   register is known to be the size of a CORE_ADDR or smaller,
   read_register can be used instead.  */

static void
legacy_read_register_gen (int regnum, char *myaddr)
{
  gdb_assert (regnum >= 0 && regnum < (NUM_REGS + NUM_PSEUDO_REGS));
  if (! ptid_equal (registers_ptid, inferior_ptid))
    {
      registers_changed ();
      registers_ptid = inferior_ptid;
    }

  if (!register_cached (regnum))
    target_fetch_registers (regnum);

  memcpy (myaddr, register_buffer (current_regcache, regnum),
	  DEPRECATED_REGISTER_RAW_SIZE (regnum));
}

a760 40
/* Write register REGNUM at MYADDR to the target.  MYADDR points at
   REGISTER_RAW_BYTES(REGNUM), which must be in target byte-order.  */

static void
legacy_write_register_gen (int regnum, const void *myaddr)
{
  int size;
  gdb_assert (regnum >= 0 && regnum < (NUM_REGS + NUM_PSEUDO_REGS));

  /* On the sparc, writing %g0 is a no-op, so we don't even want to
     change the registers array if something writes to this register.  */
  if (CANNOT_STORE_REGISTER (regnum))
    return;

  if (! ptid_equal (registers_ptid, inferior_ptid))
    {
      registers_changed ();
      registers_ptid = inferior_ptid;
    }

  size = DEPRECATED_REGISTER_RAW_SIZE (regnum);

  if (real_register (regnum))
    {
      /* If we have a valid copy of the register, and new value == old
	 value, then don't bother doing the actual store. */
      if (register_cached (regnum)
	  && (memcmp (register_buffer (current_regcache, regnum), myaddr, size)
	      == 0))
	return;
      else
	target_prepare_to_store ();
    }

  memcpy (register_buffer (current_regcache, regnum), myaddr, size);

  set_register_cached (regnum, 1);
  target_store_registers (regnum);
}

@


1.118
log
@2004-07-23  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_collect instead of regcache_collect.
	* regcache.h (regcache_collect): Delete declaration.
	* regcache.c (regcache_colect): Delete function.
	* win32-nat.c (do_child_store_inferior_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_fill_reg): Update.
	* rs6000-nat.c (store_register): Update.
	* remote.c (store_register_using_P, remote_store_registers): Update.
	* ppcnbsd-tdep.c (ppcnbsd_fill_reg): Update.
	* ppc-linux-nat.c (store_altivec_register, store_spe_register)
	(fill_vrregset, store_spe_registers, fill_gregset)
	(fill_gregset): Update.
	* nto-procfs.c (procfs_store_registers): Update.
	* mipsnbsd-tdep.c (mipsnbsd_fill_reg): Update.
	* mips-linux-tdep.c (fill_gregset, mips64_fill_gregset): Update.
	* m68klinux-nat.c (store_register, fill_gregset): Update.
	* m68k-tdep.c (fill_gregset): Update.
	* infptrace.c (store_register): Update.
	* i386-nto-tdep.c (i386nto_regset_fill): Update.
	* i386-linux-nat.c (store_register, fill_gregset): Update.
	* hppa-linux-nat.c (fill_gregset): Update.
	* go32-nat.c (store_register): Update.
	* armnbsd-nat.c (store_register, store_regs, store_fp_register)
	(store_fp_regs): Update.
	* arm-linux-nat.c (store_nwfpe_single, store_nwfpe_double)
	(store_nwfpe_extended, store_fpregister, store_fpregs)
	(store_register, store_regs, fill_gregset, fill_fpregset): Update.
	* alpha-tdep.c (alpha_fill_int_regs, alpha_fill_fp_regs): Update.
	* aix-thread.c (fill_gprs64, fill_fprs, fill_sprs64, fill_sprs32)
	(store_regs_user_thread, store_regs_kernel_thread): Update.
@
text
@a50 4
  /* Is this a ``legacy'' register cache?  Such caches reserve space
     for raw and pseudo registers and allow access to both.  */
  int legacy_p;

a82 60
static void
init_legacy_regcache_descr (struct gdbarch *gdbarch,
			    struct regcache_descr *descr)
{
  int i;
  /* FIXME: cagney/2002-05-11: gdbarch_data() should take that
     ``gdbarch'' as a parameter.  */
  gdb_assert (gdbarch != NULL);

  /* Compute the offset of each register.  Legacy architectures define
     DEPRECATED_REGISTER_BYTE() so use that.  */
  /* FIXME: cagney/2002-11-07: Instead of using
     DEPRECATED_REGISTER_BYTE() this code should, as is done in
     init_regcache_descr(), compute the offets at runtime.  This
     currently isn't possible as some ISAs define overlapping register
     regions - see the mess in read_register_bytes() and
     write_register_bytes() registers.  */
  descr->sizeof_register
    = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, long);
  descr->register_offset
    = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, long);
  for (i = 0; i < descr->nr_cooked_registers; i++)
    {
      /* FIXME: cagney/2001-12-04: This code shouldn't need to use
         DEPRECATED_REGISTER_BYTE().  Unfortunately, legacy code likes
         to lay the buffer out so that certain registers just happen
         to overlap.  Ulgh!  New targets use gdbarch's register
         read/write and entirely avoid this uglyness.  */
      descr->register_offset[i] = DEPRECATED_REGISTER_BYTE (i);
      descr->sizeof_register[i] = DEPRECATED_REGISTER_RAW_SIZE (i);
      gdb_assert (MAX_REGISTER_SIZE >= DEPRECATED_REGISTER_RAW_SIZE (i));
      gdb_assert (MAX_REGISTER_SIZE >= DEPRECATED_REGISTER_VIRTUAL_SIZE (i));
    }

  /* Compute the real size of the register buffer.  Start out by
     trusting DEPRECATED_REGISTER_BYTES, but then adjust it upwards
     should that be found to not be sufficient.  */
  /* FIXME: cagney/2002-11-05: Instead of using the macro
     DEPRECATED_REGISTER_BYTES, this code should, as is done in
     init_regcache_descr(), compute the total number of register bytes
     using the accumulated offsets.  */
  descr->sizeof_cooked_registers = DEPRECATED_REGISTER_BYTES; /* OK */
  for (i = 0; i < descr->nr_cooked_registers; i++)
    {
      long regend;
      /* Keep extending the buffer so that there is always enough
         space for all registers.  The comparison is necessary since
         legacy code is free to put registers in random places in the
         buffer separated by holes.  Once DEPRECATED_REGISTER_BYTE()
         is killed this can be greatly simplified.  */
      regend = descr->register_offset[i] + descr->sizeof_register[i];
      if (descr->sizeof_cooked_registers < regend)
	descr->sizeof_cooked_registers = regend;
    }
  /* FIXME: cagney/2002-05-11: Shouldn't be including pseudo-registers
     in the register cache.  Unfortunately some architectures still
     rely on this and the pseudo_register_write() method.  */
  descr->sizeof_raw_registers = descr->sizeof_cooked_registers;
}

d104 1
a104 9
    {
      if (gdbarch_register_type_p (gdbarch))
	{
	  gdb_assert (!DEPRECATED_REGISTER_VIRTUAL_TYPE_P ()); /* OK */
	  descr->register_type[i] = gdbarch_register_type (gdbarch, i);
	}
      else
	descr->register_type[i] = DEPRECATED_REGISTER_VIRTUAL_TYPE (i); /* OK */
    }
a115 20
  /* If an old style architecture, fill in the remainder of the
     register cache descriptor using the register macros.  */
  /* NOTE: cagney/2003-06-29: If either of DEPRECATED_REGISTER_BYTE or
     DEPRECATED_REGISTER_RAW_SIZE are still present, things are most likely
     totally screwed.  Ex: an architecture with raw register sizes
     smaller than what DEPRECATED_REGISTER_BYTE indicates; non
     monotonic DEPRECATED_REGISTER_BYTE values.  For GDB 6 check for
     these nasty methods and fall back to legacy code when present.
     Sigh!  */
  if ((!gdbarch_pseudo_register_read_p (gdbarch)
       && !gdbarch_pseudo_register_write_p (gdbarch)
       && !gdbarch_register_type_p (gdbarch))
      || DEPRECATED_REGISTER_BYTE_P ()
      || DEPRECATED_REGISTER_RAW_SIZE_P ())
    {
      descr->legacy_p = 1;
      init_legacy_regcache_descr (gdbarch, descr);
      return descr;
    }

a190 5
  /* NB: The deprecated DEPRECATED_REGISTER_RAW_SIZE, if not provided, defaults
     to the size of the register's type.  */
  gdb_assert (size == DEPRECATED_REGISTER_RAW_SIZE (regnum)); /* OK */
  /* NB: Don't check the register's virtual size.  It, in say the case
     of the MIPS, may not match the raw size!  */
a646 10
  if (regcache->descr->legacy_p
      && !regcache->readonly_p)
    {
      gdb_assert (regcache == current_regcache);
      /* For moment, just use underlying legacy code.  Ulgh!!! This
	 silently and very indirectly updates the regcache's regcache
	 via the global deprecated_register_valid[].  */
      legacy_read_register_gen (regnum, buf);
      return;
    }
a719 5
  if (current_regcache->descr->legacy_p)
    {
      legacy_read_register_gen (regnum, buf);
      return;
    }
a837 10
  if (regcache->descr->legacy_p)
    {
      /* For moment, just use underlying legacy code.  Ulgh!!! This
	 silently and very indirectly updates the regcache's buffers
	 via the globals deprecated_register_valid[] and registers[].  */
      gdb_assert (regcache == current_regcache);
      legacy_write_register_gen (regnum, buf);
      return;
    }

a869 5
  if (current_regcache->descr->legacy_p)
    {
      legacy_write_register_gen (regnum, buf);
      return;
    }
a1310 1
  fprintf_unfiltered (file, "legacy_p %d\n", regcache->descr->legacy_p);
@


1.117
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@a1220 6
void
regcache_collect (int regnum, void *buf)
{
  regcache_raw_collect (current_regcache, regnum, buf);
}

@


1.116
log
@2004-07-10  Michael Snyder  <msnyder@@redhat.com>

        * symfile.c (generic_load): Comment typo.
        * stack.c (get_selected_block): Ditto.
        * regcache.c (regcache_cooked_read): Ditto.
        * monitor.c (monitor_debug): Ditto.
        * mips-tdep.c (mips_read_pc): Ditto.
        * i386-linux-nat.c (ps_get_thread_area): Ditto.
        * gdb_mbuild.sh: Ditto.
        * gdbarch.sh: Ditto.
        * gdbarch.h: Ditto.
@
text
@a613 3
/* NOTE: cagney/2001-12-04: This function does not set valid on the
   pseudo-register range since pseudo registers are always supplied
   using supply_register().  */
d616 1
a616 1
   Since targets should only be using supply_register() the need for
a1220 20
/* FIXME: kettenis/20030828: We should get rid of supply_register and
   regcache_collect in favour of regcache_raw_supply and
   regcache_raw_collect.  */

/* SUPPLY_REGISTER()

   Record that register REGNUM contains VAL.  This is used when the
   value is obtained from the inferior or core dump, so there is no
   need to store the value there.

   If VAL is a NULL pointer, then it's probably an unsupported register.
   We just set its value to all zeros.  We might want to record this
   fact, and report it to the users of read_register and friends.  */

void
supply_register (int regnum, const void *val)
{
  regcache_raw_supply (current_regcache, regnum, val);
}

@


1.115
log
@2004-06-26  Andrew Cagney  <cagney@@gnu.org>

	* xcoffsolib.c (xcoff_solib_address): Replace xasprintf with
	xstrprintf.
	* varobj.c (varobj_gen_name, create_child, c_name_of_child)
	(c_value_of_variable): Ditto.
	* utils.c (internal_vproblem): Ditto.
	* solib-aix5.c (build_so_list_from_mapfile): Ditto.
	* remote.c (add_packet_config_cmd): Ditto.
	* remote-rdp.c (rdp_set_command_line): Ditto.
	* regcache.c (regcache_dump): Ditto.
	* frv-tdep.c (new_variant, new_variant): Ditto.
	* fbsd-proc.c (child_pid_to_exec_file): Ditto.
	(fbsd_find_memory_regions): Ditto.
	* breakpoint.c (create_thread_event_breakpoint)
	(create_breakpoints): Ditto.
	* aix-thread.c (aix_thread_pid_to_str): Ditto.
	* ada-lang.c (is_package_name): Ditto.  Also delete xmalloc call.

Index: doc/ChangeLog
2004-06-26  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Coding): Replace xasprintf with xstrprintf.
@
text
@d848 1
a848 1
    /* Read-only register cache, perhaphs the cooked value was cached?  */
@


1.114
log
@Committed by Jim Blandy <jimb@@redhat.com>:
* regcache.c (struct regcache_descr): fix comment spelling.
@
text
@d1575 1
a1575 1
		xasprintf (&n, "*%d", footnote_register_type_name_null);
@


1.113
log
@2004-04-26  Orjan Friberg <orjanf@@axis.com>

	* frame.c: Include "observer.h".
	(frame_observer_target_changed): New function.
	(_initialize_frame): Attach target_changed observer.
	* regcache.c: Include "observer.h".
	(regcache_observer_target_changed): New function.
	(_initialize_regcache): Attach target_changed observer.
	* valops.c: Include "observer.h".
	(value_assign): Notify target_changed event when modifying register.
	* Makefile.in (frame.o, regcache.o, valops.o): Add $(observer_h).
@
text
@d67 1
a67 1
     .. NR_COOKED_REGISTERS) (a.k.a. pseudo regiters) are mapped onto
d69 1
a69 1
     gdbarch_register_read and gdbarch_register_write.  */
@


1.112
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d33 1
d570 8
d1708 2
@


1.111
log
@2004-04-17  Randolph Chung  <tausq@@debian.org>

	* hppa-tdep.c (hppa_pseudo_register_read): Define.
	(hppa_gdbarch_init): Set pseudo_register_read.
	* config/pa/tm-hppa.h (DEPRECATED_CLEAN_UP_REGISTER_VALUE): Remove.
	* regcache.c (supply_register): Remove check for
	DEPRECATED_CLEAN_UP_REGISTER_VALUE since we've removed the last user.
@
text
@d597 2
a598 2
  if (registers_changed_hook)
    registers_changed_hook ();
@


1.110
log
@2004-03-15  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (gdbarch_data_pre_init_fytpe)
	(gdbarch_data_register_pre_init, gdbarch_data_post_init_fytpe)
	(gdbarch_data_register_post_init): Replace gdbarch_data_init_ftype
	and register_gdbarch_data.
	(deprecated_set_gdbarch_data): Rename set_gdbarch_data.
	(struct gdbarch_data): Replace "init" by "pre_init" and
	"post_init".
	* gdbarch.h, gdbarch.c: Re-generate.
	* dwarf2-frame.c (dwarf2_frame_init): Replace "gdbarch" paramter
	with"obstack", use OBSTACK_ZALLOC.
	(dwarf2_frame_ops): Delete.
	(dwarf2_frame_set_init_reg): Use gdbarch_data.
	(dwarf2_frame_init_reg): Use gdbarch_data.
	(_initialize_dwarf2_frame): Use gdbarch_data_register_pre_init.
	* solib-svr4.c (set_solib_svr4_fetch_link_map_offsets)
	(_initialize_svr4_solib): Update.
	* user-regs.c (_initialize_user_regs): Update.
	* reggroups.c (_initialize_reggroup): Update.
	* regcache.c (_initialize_regcache): Update.
	* mips-linux-tdep.c (_initialize_mips_linux_tdep): Update.
	* libunwind-frame.c (_initialize_libunwind_frame): Update.
	* gnu-v3-abi.c (init_gnuv3_ops): Update.
	* frame-unwind.c (_initialize_frame_unwind): Update.
	* frame-base.c (_initialize_frame_base): Update.
	* user-regs.c (user_reg_add): Update.
	* reggroups.c (reggroup_add): Update.
	* mips-linux-tdep.c (set_mips_linux_register_addr): Update.
	* libunwind-frame.c (libunwind_frame_set_descr): Update.
	* frame-unwind.c (frame_unwind_append_sniffer): Update.
	* frame-base.c (frame_base_table): Update.
	* remote.c (_initialize_remote): Update.
	* gdb_obstack.h (OBSTACK_ZALLOC, OBSTACK_CALLOC): Define.
@
text
@a1232 14

  /* On some architectures, e.g. HPPA, there are a few stray bits in
     some registers, that the rest of the code would like to ignore.  */

  /* NOTE: cagney/2001-03-16: The macro CLEAN_UP_REGISTER_VALUE is
     going to be deprecated.  Instead architectures will leave the raw
     register value as is and instead clean things up as they pass
     through the method gdbarch_pseudo_register_read() clean up the
     values. */

#ifdef DEPRECATED_CLEAN_UP_REGISTER_VALUE
  DEPRECATED_CLEAN_UP_REGISTER_VALUE \
    (regnum, register_buffer (current_regcache, regnum));
#endif
@


1.109
log
@	* regcache.c (read_pc_pid): Restore inferior_ptid after reading
	PC_REGNUM.
@
text
@d1708 1
a1708 1
  regcache_descr_handle = register_gdbarch_data (init_regcache_descr);
@


1.109.4.1
log
@Jumbo patch.  Experiments with tramp-frame.
@
text
@d1708 1
a1708 1
  regcache_descr_handle = register_gdbarch_data (NULL, init_regcache_descr);
@


1.109.4.2
log
@Dump of tramp-frame stuff.
@
text
@d1708 1
a1708 1
  regcache_descr_handle = gdbarch_data_register_post_init (init_regcache_descr);
@


1.108
log
@2004-02-15  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (deprecated_register_gdbarch_swap): Rename
	register_gdbarch_swap.
	(DEPRECATED_REGISTER_GDBARCH_SWAP): Rename REGISTER_GDBARCH_SWAP.
	* f-lang.c (_initialize_f_language): Update, use
	DEPRECATED_REGISTER_GDBARCH_SWAP.
	* remote.c (_initialize_remote): Ditto.
	* regcache.c (_initialize_regcache): Ditto.
	* parse.c (_initialize_parse): Ditto.
	* infrun.c (_initialize_infrun): Ditto.
	* mi/mi-main.c (_initialize_mi_main): Ditto.
	* gdbtypes.c (_initialize_gdbtypes): Ditto.
@
text
@d1335 1
a1335 2
      CORE_ADDR pc_val = ADDR_BITS_REMOVE (raw_val);
      return pc_val;
@


1.108.2.1
log
@Merge mainline to intercu branch.
@
text
@d1335 2
a1336 1
      pc_val = ADDR_BITS_REMOVE (raw_val);
d1709 1
a1709 1
  regcache_descr_handle = gdbarch_data_register_post_init (init_regcache_descr);
@


1.108.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a32 1
#include "observer.h"
d50 4
d66 1
a66 1
     .. NR_COOKED_REGISTERS) (a.k.a. pseudo registers) are mapped onto
d68 1
a68 1
     gdbarch_pseudo_register_read and gdbarch_pseudo_register_write.  */
d86 60
d167 9
a175 1
    descr->register_type[i] = gdbarch_register_type (gdbarch, i);
d187 20
d238 14
d282 5
d561 1
a561 1
/* Observer for the target_changed event.  */
d563 2
a564 2
void
regcache_observer_target_changed (struct target_ops *target)
d566 1
a566 1
  registers_changed ();
d597 2
a598 2
  if (deprecated_registers_changed_hook)
    deprecated_registers_changed_hook ();
d605 3
d610 1
a610 1
   Since targets should only be using regcache_raw_supply() the need for
d665 1
a665 1
      reg_len = register_size (current_gdbarch, regnum);
d711 22
d738 10
a761 9
#if 0
      /* FIXME: cagney/2004-08-07: At present a number of targets
	 forget (or didn't know that they needed) set this leading to
	 panics.  Also is the problem that target's need to indicate
	 that a register is in one of the possible states: valid,
	 undefined, unknown.  The last of which isn't yet
	 possible.  */
      gdb_assert (register_cached (regnum));
#endif
d821 5
d839 1
a839 1
    /* Read-only register cache, perhaps the cooked value was cached?  */
d897 40
d944 10
d986 5
d1027 1
a1027 1
      regend = regstart + register_size (current_gdbarch, regnum);
a1150 8
/* Hack to keep code using register_bytes working.  */

int
deprecated_register_bytes (void)
{
  return current_regcache->descr->sizeof_raw_registers;
}

d1156 1
a1156 1
  char *buf = alloca (register_size (current_gdbarch, regnum));
d1158 1
a1158 1
  return (extract_unsigned_integer (buf, register_size (current_gdbarch, regnum)));
d1189 1
a1189 1
  size = register_size (current_gdbarch, regnum);
d1215 40
d1305 2
a1306 2
/* read_pc, write_pc, read_sp, etc.  Special handling for registers
   PC, SP, and FP.  */
d1308 5
a1312 5
/* NOTE: cagney/2001-02-18: The functions read_pc_pid(), read_pc() and
   read_sp(), will eventually be replaced by per-frame methods.
   Instead of relying on the global INFERIOR_PTID, they will use the
   contextual information provided by the FRAME.  These functions do
   not belong in the register cache.  */
d1315 3
a1317 2
   write_pc_pid() and write_pc(), all need to be replaced by something
   that does not rely on global state.  But what?  */
d1396 18
d1472 1
d1546 19
a1564 2
	fprintf_unfiltered (file, " %5ld",
			    regcache->descr->sizeof_register[regnum]);
d1580 1
a1580 1
		n = xstrprintf ("*%d", footnote_register_type_name_null);
d1608 1
a1608 1
				 regcache->descr->sizeof_register[regnum]);
d1622 1
a1622 1
				 regcache->descr->sizeof_register[regnum]);
a1713 2
  observer_attach_target_changed (regcache_observer_target_changed);

@


1.107
log
@Fix obvious typo (completly -> completely) and update copyrights as needed
@
text
@d1710 4
a1713 4
  REGISTER_GDBARCH_SWAP (current_regcache);
  register_gdbarch_swap (&deprecated_registers, sizeof (deprecated_registers), NULL);
  register_gdbarch_swap (&deprecated_register_valid, sizeof (deprecated_register_valid), NULL);
  register_gdbarch_swap (NULL, 0, build_regcache);
@


1.106
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_NPC_REGNUM): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* procfs.c (procfs_fetch_registers): Delete reference to
	DEPRECATED_NPC_REGNUM.
	(procfs_store_registers): Ditto.
	* regcache.c (generic_target_write_pc): Simplify.
	* lynx-nat.c: Delete #ifdef SPARC code.  Not used.

Index: doc/ChangeLog
2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	documentation on DEPRECATED_NPC_REGNUM.
@
text
@d4 1
a4 1
   2001, 2002 Free Software Foundation, Inc.
d462 1
a462 1
     silly - it would mean that valid_p would be completly invalid.  */
@


1.105
log
@Index: mi/ChangeLog
2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* tui-out.c: Fix "fortunatly"[sic].

Index: doc/ChangeLog
2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* annotate.texinfo: Fix "fortunatly"[sic].

2003-10-24  Andrew Cagney  <cagney@@redhat.com>

	* osabi.c (gdbarch_init_osabi): Fix typos, and "fortunatly"[sic].
	* PROBLEMS, arch-utils.c, cli-out.c, command.h: Ditto.
	* complaints.c, cris-tdep.c, disasm.c, dwarf2-frame.c: Ditto.
	* frame.c, frame.h, infcall.c, infcmd.c, infrun.c: Ditto.
	* kod.c, mips-tdep.c, regcache.c, regcache.h, remote.c: Ditto.
@
text
@a1353 1
#ifdef PC_REGNUM
d1356 3
a1358 6
  if (DEPRECATED_NPC_REGNUM >= 0)
    write_register_pid (DEPRECATED_NPC_REGNUM, pc + 4, ptid);
#else
  internal_error (__FILE__, __LINE__,
		  "generic_target_write_pc");
#endif
@


1.104
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d110 1
a110 1
         DEPRECATED_REGISTER_BYTE().  Unfortunatly, legacy code likes
d141 1
a141 1
     in the register cache.  Unfortunatly some architectures still
d232 1
a232 1
     the raw registers.  Unfortunatly some code still accesses the
@


1.103
log
@2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_VIRTUAL_SIZE to
	DEPRECATED_REGISTER_VIRTUAL_SIZE.

2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_VIRTUAL_SIZE): Rename
	REGISTER_VIRTUAL_SIZE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* vax-tdep.h, sparc-tdep.c, regcache.h: Update.
	* regcache.c, mn10300-tdep.c, mips-tdep.c: Update.
	* infcmd.c, frame.c, findvar.c, cris-tdep.c: Update.

2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_VIRTUAL_SIZE to DEPRECATED_REGISTER_VIRTUAL_SIZE.
	(Target Architecture Definition):
@
text
@d115 2
a116 2
      descr->sizeof_register[i] = REGISTER_RAW_SIZE (i);
      gdb_assert (MAX_REGISTER_SIZE >= REGISTER_RAW_SIZE (i));
d190 1
a190 1
     REGISTER_RAW_SIZE are still present, things are most likely
d199 2
a200 1
      || DEPRECATED_REGISTER_BYTE_P () || REGISTER_RAW_SIZE_P ())
d246 1
a246 1
      gdb_assert (descr->sizeof_register[i] == REGISTER_RAW_SIZE (i));
d282 1
a282 1
  /* NB: The deprecated REGISTER_RAW_SIZE, if not provided, defaults
d284 1
a284 1
  gdb_assert (size == REGISTER_RAW_SIZE (regnum)); /* OK */
d665 1
a665 1
      reg_len = REGISTER_RAW_SIZE (regnum);
d730 1
a730 1
	  REGISTER_RAW_SIZE (regnum));
d917 1
a917 1
  size = REGISTER_RAW_SIZE (regnum);
d1027 1
a1027 1
      regend = regstart + REGISTER_RAW_SIZE (regnum);
d1156 1
a1156 1
  char *buf = alloca (REGISTER_RAW_SIZE (regnum));
d1158 1
a1158 1
  return (extract_unsigned_integer (buf, REGISTER_RAW_SIZE (regnum)));
d1189 1
a1189 1
  size = REGISTER_RAW_SIZE (regnum);
d1555 1
a1555 1
	       != REGISTER_RAW_SIZE (regnum))
d1613 1
a1613 1
				 REGISTER_RAW_SIZE (regnum));
@


1.102
log
@2003-09-29  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_VIRTUAL_TYPE): Rename
	DEPRECATED_REGISTER_VIRTUAL_TYPE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arch-utils.c,	hppa-tdep.c, regcache.c, regcache.h: Update.
	* sh64-tdep.c, sparc-tdep.c: Update.

2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_VIRTUAL_TYPE to DEPRECATED_REGISTER_VIRTUAL_TYPE.
@
text
@d117 1
a117 1
      gdb_assert (MAX_REGISTER_SIZE >= REGISTER_VIRTUAL_SIZE (i));
d246 1
a246 1
      gdb_assert (descr->sizeof_register[i] == REGISTER_VIRTUAL_SIZE (i));
d1556 1
a1556 1
		  != REGISTER_VIRTUAL_SIZE (regnum))
d1626 1
a1626 1
				 REGISTER_VIRTUAL_SIZE (regnum));
@


1.101
log
@* regcache.h (get_regcache_arch): New prototype.
* regcache.c (get_regcache_arch): New function.
@
text
@d170 1
a170 1
	  gdb_assert (!REGISTER_VIRTUAL_TYPE_P ()); /* OK */
d174 1
a174 1
	descr->register_type[i] = REGISTER_VIRTUAL_TYPE (i); /* OK */
@


1.100
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d347 8
@


1.99
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_NPC_REGNUM): Deprecate NPC_REGNUM.
	* gdbarch.h, gdbarch.c: Regenerate.
	* core-sol2.c, hppa-tdep.c, lynx-nat.c, procfs.c: Update.
	* regcache.c, remote-vxsparc.c, sparc-linux-nat.c: Update.
	* sparc-nat.c, sparc-tdep.c, sparc64-tdep.c: Update.
	* sparcnbsd-tdep.c: Update.
@
text
@a1409 1
/* ARGSUSED */
@


1.98
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTE): Rename REGISTER_BYTE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-linux-tdep.c, core-sol2.c, cris-tdep.c: Update.
	* d10v-tdep.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, irix5-nat.c, lynx-nat.c, m68knbsd-nat.c: Update.
	* mcore-tdep.c, mips-linux-tdep.c, mips-tdep.c: Update.
	* mipsv4-nat.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* ns32knbsd-nat.c, ppc-bdm.c, regcache.c, remote-sds.c: Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh64-tdep.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, v850-tdep.c: Update.
	* v850ice.c, vax-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-cisco.h, config/m68k/tm-delta68.h: Update.
	* config/pa/nm-hppah.h: Update.

2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* mi/mi-main.c: Rename REGISTER_BYTE to DEPRECATED_REGISTER_BYTE.
@
text
@d1348 2
a1349 2
  if (NPC_REGNUM >= 0)
    write_register_pid (NPC_REGNUM, pc + 4, ptid);
@


1.97
log
@* regcache.c (regcache_raw_supply): Don't assert that BUF isn't a
null pointer.  Fix typo in comment.
@
text
@d96 7
a102 6
     REGISTER_BYTE() so use that.  */
  /* FIXME: cagney/2002-11-07: Instead of using REGISTER_BYTE() this
     code should, as is done in init_regcache_descr(), compute the
     offets at runtime.  This currently isn't possible as some ISAs
     define overlapping register regions - see the mess in
     read_register_bytes() and write_register_bytes() registers.  */
d110 5
a114 5
         REGISTER_BYTE().  Unfortunatly, legacy code likes to lay the
         buffer out so that certain registers just happen to overlap.
         Ulgh!  New targets use gdbarch's register read/write and
         entirely avoid this uglyness.  */
      descr->register_offset[i] = REGISTER_BYTE (i);
d134 2
a135 2
         buffer separated by holes.  Once REGISTER_BYTE() is killed
         this can be greatly simplified.  */
d189 1
a189 1
  /* NOTE: cagney/2003-06-29: If either of REGISTER_BYTE or
d192 4
a195 3
     smaller than what REGISTER_BYTE indicates; non monotonic
     REGISTER_BYTE values.  For GDB 6 check for these nasty methods
     and fall back to legacy code when present.  Sigh!  */
d199 1
a199 1
      || REGISTER_BYTE_P () || REGISTER_RAW_SIZE_P ())
d238 2
a239 2
     regcache and the target's redundant REGISTER_BYTE (new targets
     should not even be defining it).  */
d242 2
a243 2
      if (REGISTER_BYTE_P ())
	gdb_assert (descr->register_offset[i] == REGISTER_BYTE (i));
d655 1
a655 1
      reg_start = REGISTER_BYTE (regnum);
d1017 1
a1017 1
      regstart = REGISTER_BYTE (regnum);
d1522 1
a1522 1
	      || register_offset != REGISTER_BYTE (regnum)
@


1.96
log
@* regcache.c (supply_register): Reimplement to call
regcache_raw_supply.
(regcache_collect): Reimplement by calling regcache_raw_collect.
@
text
@d1244 1
a1244 1
/* Supply register REGNUM, whose contents are store in BUF, to REGCACHE.  */
d1252 1
a1252 1
  gdb_assert (regcache != NULL && buf != NULL);
@


1.95
log
@* regcache.c (register_buffer): Consitify first argument.
(regcache_raw_supply, regcache_raw_collect): New
functions.
@
text
@d1221 1
a1221 15
#if 1
  if (! ptid_equal (registers_ptid, inferior_ptid))
    {
      registers_changed ();
      registers_ptid = inferior_ptid;
    }
#endif

  set_register_cached (regnum, 1);
  if (val)
    memcpy (register_buffer (current_regcache, regnum), val, 
	    REGISTER_RAW_SIZE (regnum));
  else
    memset (register_buffer (current_regcache, regnum), '\000', 
	    REGISTER_RAW_SIZE (regnum));
d1241 1
a1241 2
  memcpy (buf, register_buffer (current_regcache, regnum),
	  REGISTER_RAW_SIZE (regnum));
@


1.94
log
@2003-08-04  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (gdbarch_data_free_ftype): Delete declaration.
	(register_gdbarch_data): Delete "free" parameter.  Update
	comments.
	* gdbarch.h, gdbarch.c: Re-generate.
	* reggroups.c (_initialize_reggroup): Update.
	* gnu-v3-abi.c (init_gnuv3_ops): Update.
	* frame-base.c (_initialize_frame_base): Update.
	* frame-unwind.c (_initialize_frame_unwind): Update.
	* user-regs.c (_initialize_user_regs): Update.
	* remote.c (_initialize_remote): Update.
	* regcache.c (_initialize_regcache): Update.
@
text
@d348 1
a348 1
register_buffer (struct regcache *regcache, int regnum)
d1204 4
d1257 49
@


1.93
log
@2003-08-04  Andrew Cagney  <cagney@@redhat.com>

	* regcache.c (xfree_regcache_descr): Delete function.
	(_initialize_regcache): Update call to register_gdbarch_data.
	(init_regcache_descr, init_legacy_regcache_descr): Use
	GDBARCH_OBSTACK_XALLOC and GDBARCH_OBSTACK_CALLOC.
@
text
@d1665 1
a1665 1
  regcache_descr_handle = register_gdbarch_data (init_regcache_descr, NULL);
@


1.92
log
@2003-08-04  Andrew Cagney  <cagney@@redhat.com>

	* reggroups.c (struct reggroup_el): Define.
	(struct reggroups): Delete field "nr_group".  Replace array
	"group" with a "first" to "last" linked list.
	(reggroups_init): Update.  Allocate using gdbarch's obstack.
	(reggroups_free): Delete function.
	(add_group): Update.  Add "el" parameter.
	(reggroup_add): Pass gdbarch obstack allocated space to add_group.
	(default_groups): Update.
	(reggroup_next): Replace reggroups.
	(reggroups_dump): Update.
	(_initialize_reggroup): Pass XMALLOC allocated space to add_group.
	* regcache.c (regcache_dump): Use reggroup_next instead of reggroups.
	* infcmd.c (registers_info): Use reggroup_next instead of reggroups.
@
text
@d102 4
a105 2
  descr->sizeof_register = XCALLOC (descr->nr_cooked_registers, long);
  descr->register_offset = XCALLOC (descr->nr_cooked_registers, long);
d153 1
a153 1
  descr = XCALLOC (1, struct regcache_descr);
d163 2
a164 2
  descr->register_type = XCALLOC (descr->nr_cooked_registers,
				  struct type *);
d213 4
a216 2
    descr->sizeof_register = XCALLOC (descr->nr_cooked_registers, long);
    descr->register_offset = XCALLOC (descr->nr_cooked_registers, long);
a257 13
static void
xfree_regcache_descr (struct gdbarch *gdbarch, void *ptr)
{
  struct regcache_descr *descr = ptr;
  if (descr == NULL)
    return;
  xfree (descr->register_offset);
  xfree (descr->sizeof_register);
  descr->register_offset = NULL;
  descr->sizeof_register = NULL;
  xfree (descr);
}

d1665 1
a1665 2
  regcache_descr_handle = register_gdbarch_data (init_regcache_descr,
						 xfree_regcache_descr);
@


1.91
log
@2003-07-28  Andrew Cagney  <cagney@@redhat.com>

	* regcache.c (struct regcache_descr): Update comments on
	nr_raw_registers.
	(init_legacy_regcache_descr): Don't set nr_raw_registers or
	sizeof_raw_register_valid_p.
	(init_regcache_descr): Set nr_raw_registers and
	sizeof_raw_register_valid_p before calling
	init_legacy_regcache_descr.
@
text
@a1428 1
  struct reggroup *const *groups = reggroups (gdbarch);
a1598 1
	      int i;
d1600 4
a1603 1
	      for (i = 0; groups[i] != NULL; i++)
d1605 1
a1605 1
		  if (gdbarch_register_reggroup_p (gdbarch, regnum, groups[i]))
d1607 1
a1607 1
		      fprintf_unfiltered (file, "%s%s", sep, reggroup_name (groups[i]));
@


1.90
log
@2003-07-09  Andrew Cagney  <cagney@@redhat.com>

	* regcache.c (register_size): Only check REGISTER_RAW_SIZE once.
	Add comments about the checks.
@
text
@d54 5
a58 4
  /* The raw register cache.  This should contain just [0
     .. NUM_RAW_REGISTERS).  However, for older targets, it contains
     space for the full [0 .. NUM_RAW_REGISTERS +
     NUM_PSEUDO_REGISTERS).  */
a94 6
  /* FIXME: cagney/2002-05-11: Shouldn't be including pseudo-registers
     in the register cache.  Unfortunatly some architectures still
     rely on this and the pseudo_register_write() method.  */
  descr->nr_raw_registers = descr->nr_cooked_registers;
  descr->sizeof_raw_register_valid_p = descr->sizeof_cooked_register_valid_p;

d174 10
a200 10

  /* Construct a strictly RAW register cache.  Don't allow pseudo's
     into the register cache.  */
  descr->nr_raw_registers = NUM_REGS;

  /* FIXME: cagney/2002-08-13: Overallocate the register_valid_p
     array.  This pretects GDB from erant code that accesses elements
     of the global register_valid_p[] array in the range [NUM_REGS
     .. NUM_REGS + NUM_PSEUDO_REGS).  */
  descr->sizeof_raw_register_valid_p = descr->sizeof_cooked_register_valid_p;
@


1.89
log
@2003-07-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (REGISTER_RAW_SIZE, REGISTER_VIRTUAL_SIZE): Add
	predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* regcache.c (init_regcache_descr): Use legacy code when either
	REGISTER_BYTE or REGISTER_RAW_SIZE is set.
@
text
@d293 2
d296 2
a297 1
  gdb_assert (size == REGISTER_RAW_SIZE (regnum)); /* OK */
@


1.88
log
@2003-06-16  Andrew Cagney  <cagney@@redhat.com>

	* regcache.c (do_cooked_read): Do not use register_valid_p.
@
text
@d181 10
a190 3
  if (!gdbarch_pseudo_register_read_p (gdbarch)
      && !gdbarch_pseudo_register_write_p (gdbarch)
      && !gdbarch_register_type_p (gdbarch))
a191 6
      /* NOTE: cagney/2003-05-02: Don't add a test for REGISTER_BYTE_P
	 to the above.  Doing that would cause all the existing
	 architectures to revert back to the legacy regcache
	 mechanisms, and that is not a good thing.  Instead just,
	 later, check that the register cache's layout is consistent
	 with REGISTER_BYTE.  */
@


1.88.2.1
log
@2003-07-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (REGISTER_RAW_SIZE, REGISTER_VIRTUAL_SIZE): Add
	predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* regcache.c (init_regcache_descr): Use legacy code when either
	REGISTER_BYTE or REGISTER_RAW_SIZE is set.
@
text
@d181 3
a183 10
  /* NOTE: cagney/2003-06-29: If either of REGISTER_BYTE or
     REGISTER_RAW_SIZE are still present, things are most likely
     totally screwed.  Ex: an architecture with raw register sizes
     smaller than what REGISTER_BYTE indicates; non monotonic
     REGISTER_BYTE values.  For GDB 6 check for these nasty methods
     and fall back to legacy code when present.  Sigh!  */
  if ((!gdbarch_pseudo_register_read_p (gdbarch)
       && !gdbarch_pseudo_register_write_p (gdbarch)
       && !gdbarch_register_type_p (gdbarch))
      || REGISTER_BYTE_P () || REGISTER_RAW_SIZE_P ())
d185 6
@


1.88.2.2
log
@2003-07-31  Andrew Cagney  <cagney@@redhat.com>

	* regcache.c (struct regcache_descr): Update comments on
	nr_raw_registers.
	(init_legacy_regcache_descr): Don't set nr_raw_registers or
	sizeof_raw_register_valid_p.
	(init_regcache_descr): Set nr_raw_registers and
	sizeof_raw_register_valid_p before calling
	init_legacy_regcache_descr.
@
text
@d54 4
a57 5
  /* The raw register cache.  Each raw (or hard) register is supplied
     by the target interface.  The raw cache should not contain
     redundant information - if the PC is constructed from two
     registers then those regigisters and not the PC lives in the raw
     cache.  */
d94 6
a178 10
  /* Construct a strictly RAW register cache.  Don't allow pseudo's
     into the register cache.  */
  descr->nr_raw_registers = NUM_REGS;

  /* FIXME: cagney/2002-08-13: Overallocate the register_valid_p
     array.  This pretects GDB from erant code that accesses elements
     of the global register_valid_p[] array in the range [NUM_REGS
     .. NUM_REGS + NUM_PSEUDO_REGS).  */
  descr->sizeof_raw_register_valid_p = descr->sizeof_cooked_register_valid_p;

d196 10
@


1.87
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (UNWIND_SP): Add.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (frame_sp_unwind): New function.
	(get_frame_sp): New function.
	* frame.h (get_frame_sp, frame_sp_unwind): Declare.
	* regcache.c (read_sp): Rewrite, try each of TARGET_READ_SP,
	gdbarch_unwind_sp and SP_REGNUM when looking for the SP register
	value.
	* d10v-tdep.c (d10v_unwind_sp): Replace d10v_read_sp.
	(d10v_gdbarch_init): Set unwind_sp instead of read_sp.

2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Document
	"unwind_sp".  Cross reference "unwind_sp" and TARGET_READ_SP.
@
text
@d426 1
a426 2
  if (!regcache_valid_p (regcache, regnum)
      && regcache->readonly_p)
@


1.86
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* acinclude.m4 (gcc_AC_CHECK_DECL, (gcc_AC_CHECK_DECL): Stolen
	from GCC's acinclude.m4.
	* configure.in: Check for getopt's delcaration.
	* aclocal.m4, config.in, configure: Re-generate.
	* main.c (error_init): Delete declaration.
	* defs.h (error_init): Declare.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Make static.
	(rs6000_convert_from_func_ptr_addr): Make static.
	(_initialize_rs6000_tdep): Add declaration.
	* cli/cli-cmds.c (dont_repeat): Delete declaration.
	(show_commands, set_verbose, show_history): Delete declaration.
	* top.h (set_verbose): Add declaration.
	(show_history, set_history, show_commands): Add declaration.
	(do_restore_instream_cleanup): Add declaration.
	* objc-lang.c (specialcmp): Make static.
	(print_object_command): Make static.
	(find_objc_msgsend): Make static.
	(find_objc_msgcall_submethod_helper): Make static.
	(find_objc_msgcall_submethod): Make static.
	(_initialize_objc_language): Add declaration.
	(find_implementation_from_class): Make static.
	(find_implementation): Make static.
	* objc-exp.y (yylex): Delete lookup_struct_typedef declaration.
	* objc-lang.h (lookup_struct_typedef): Add declaration.
	* cli/cli-interp.c (_initialize_cli_interp): Add declaration.
	* cli/cli-script.c (clear_hook_in_cleanup): Make static.
	(do_restore_user_call_depth): Make static.
	(do_restore_instream_cleanup): Delete declaration.
	(dont_repeat): Delete declaration.
	* cli/cli-decode.c (add_abbrev_cmd): Delete function.
	* cli/cli-dump.c (_initialize_cli_dump): Add declaration.
	* reggroups.c (_initialize_reggroup): Add declaration.
	* cp-support.c (_initialize_cp_support): Add declaration.
	* cp-abi.c (_initialize_cp_abi): Add declaration.
	* hpacc-abi.c (_initialize_hpacc_abi): Add declaration.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Make static.
	(_initialize_gnu_v3_abi): Add declaration.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Make static.
	(_initialize_gnu_v2_abi): Add declaration.
	* frame-base.c (_initialize_frame_base): Add declaration.
	* doublest.c (floatformat_from_length): Make static.
	* frame-unwind.c (_initialize_frame_unwind): Add declaration.
	* frame.c (create_sentinel_frame): Make static.
	(_initialize_frame): Add declaration.
	* top.c (do_catch_errors): Make static.
	(gdb_rl_operate_and_get_next_completion): Make static.
	* typeprint.c: Include "typeprint.h".
	* sentinel-frame.c (sentinel_frame_prev_register): Make static.
	(sentinel_frame_this_id): Make static.
	* p-valprint.c (_initialize_pascal_valprint): Add declaration.
	* ui-out.c (make_cleanup_ui_out_begin_end): Delete function.
	* dwarf2-frame.c (dwarf2_frame_cache): Make static.
	* p-exp.y (push_current_type, pop_current_type): ISO C declaration.
	* dwarf2expr.h (dwarf_expr_context): ISO C declaration.
	* maint.c (maintenance_print_architecture): Make static.
	* signals/signals.c (_initialize_signals): Add declaration.
	* std-regs.c (_initialize_frame_reg): Add declaration.
	* jv-exp.y (push_variable): ISO C definition.
	(push_qualified_expression_name): Ditto.
	* memattr.c (_initialize_mem): Add declaration.
	* remote.c (remote_check_watch_resources): Make static.
	(remote_stopped_by_watchpoint): Make static.
	(remote_stopped_data_address): Make static.
	* d10v-tdep.c (nr_dmap_regs): Make static.
	(a0_regnum): Make static.
	(d10v_frame_unwind_cache): Make static.
	(d10v_frame_p): Make static.
	* osabi.c (show_osabi): Make static.
	(_initialize_gdb_osabi): Add extern declaration.
	* gdbtypes.c (make_qualified_type): Make static.
	(safe_parse_type): Make static.
	* macrocmd.c (_initialize_macrocmd): Add extern declaration.
	* macrotab.c (macro_bcache_free): Make static.
	* interps.c (interp_set_quiet): Make static.
	(interpreter_exec_cmd): Make static.
	* stack.h (select_frame_command): New file.
	* stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete function.
	(select_frame_command): Make global.
	* infcall.c: Include "infcall.h".
	* linespec.c: Include "linespec.h".
	* symfile.c (sections_overlap): Make static.
	* cp-support.h (cp_initialize_namespace): ISO C declaration.
	* charset.c (_initialize_charset): Add missing prototype.
	* regcache.c (init_legacy_regcache_descr): Make static.
	(do_regcache_xfree): Make static.
	(regcache_xfer_part): Make static.
	(_initialize_regcache): Add missing prototype.
	* breakpoint.c (parse_breakpoint_sals): Make static.
	(breakpoint_sals_to_pc): Make static.
	* interps.h (clear_interpreter_hooks): ISO C declaration.
	* Makefile.in (stack_h): Define.
	(stack.o, typeprint.o, mi-main.o): Update dependencies.
	(mi-cmd-stack.o, infcall.o, linespec.o): Update dependencies.

Index: mi/ChangeLog
2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-parse.c (_initialize_mi_parse): Delete function.
	* mi-main.c: Include "mi-main.h".
	* mi-interp.c (_initialize_mi_interp): Add declaration.
	* mi-cmd-stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete extern declaration.
	(mi_cmd_stack_select_frame): Replace select_frame_command_wrapper
	with select_frame_command.
@
text
@d1354 2
a1355 1
  /* Else return SP from get_current_frame.  */
d1357 2
@


1.85
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* inferior.h (deprecated_write_sp): Replace
	generic_target_write_sp.
	* regcache.c (deprecated_write_sp): Replace
	generic_target_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Update.
@
text
@d85 1
a85 1
void
d343 1
a343 1
void
d1067 1
a1067 1
void
d1666 2
@


1.84
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (TARGET_READ_SP): Add predicate, delete default.
	* gdbarch.h, gdbarch.c: Regenerate.
	* mn10300-tdep.c: Include "gdb_assert.h".
	(mn10300_read_fp): New function.
	(mn10300_gdbarch_init): Set deprecated_target_read_fp to
	mn10300_read_fp.  Do not set read_sp to generic_target_read_sp.
	* ia64-tdep.c: Include "gdb_assert.h".
	(ia64_read_fp): New function.
	(ia64_gdbarch_init): Set deprecated_target_read_fp to
	ia64_read_sp.  Do not set read_sp to generic_target_read_sp.
	* regcache.c (generic_target_read_sp): Delete function.
	(read_sp): Try TARGET_READ_SP and SP_REGNUM for the SP register.
	* inferior.h (generic_target_read_sp): Delete declaration.
	* frv-tdep.c (frv_gdbarch_init): Do not set read_sp to
	generic_target_read_sp.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* Makefile.in (mn10300-tdep.o, ia64-tdep.o): Update dependencies.
@
text
@a1275 3
/* NOTE: cagney/2003-06-07: The function generic_target_write_sp()
   should be deleted.  */

d1361 1
a1361 1
generic_target_write_sp (CORE_ADDR val)
d1363 2
a1364 9
#ifdef SP_REGNUM
  if (SP_REGNUM >= 0)
    {
      write_register (SP_REGNUM, val);
      return;
    }
#endif
  internal_error (__FILE__, __LINE__,
		  "generic_target_write_sp");
@


1.83
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (TARGET_READ_PC): Add predicate, remove default.
	* gdbarch.h, gdbarch.c: Re-generate.
	* regcache.c: Update comments on read_pc et.al.
	(generic_target_read_pc): Delete function.
	(read_pc_pid): Try TARGET_READ_PC and PC_REGNUM for a PC register.
	* inferior.h (generic_target_read_pc): Delete declaration.
	* frv-tdep.c (frv_gdbarch_init): Do not set read_pc to
	generic_target_read_pc.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
@
text
@a1275 3
/* NOTE: cagney/2003-06-07: The function generic_target_read_sp()
   should be deleted.  */

d1353 1
a1353 1
generic_target_read_sp (void)
d1355 4
a1358 2
#ifdef SP_REGNUM
  if (SP_REGNUM >= 0)
d1360 1
a1360 9
#endif
  internal_error (__FILE__, __LINE__,
		  "generic_target_read_sp");
}

CORE_ADDR
read_sp (void)
{
  return TARGET_READ_SP ();
@


1.82
log
@2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTES): Rename REGISTER_BYTES.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_extract_return_value): Delete reference.
	* TODO (REGISTER_BYTES): Delete reference.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	(ns32k_gdbarch_init_32382): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* sparc-tdep.c (sparc_pop_frame): Update.
	* rs6000-tdep.c (rs6000_pop_frame): Update.
	* remote.c (init_remote_state): Update.
	(remote_prepare_to_store): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	(sds_prepare_to_store): Update.
	* remote-array.c: Update.
	* regcache.c (init_legacy_regcache_descr): Update.
	(init_regcache_descr): Update.
	* mips-tdep.c (mips_eabi_extract_return_value): Update.
	(mips_o64_extract_return_value): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* irix4-nat.c (fetch_core_registers): Update.
	* i386-tdep.h: Update.
	* hppa-tdep.c (pa_do_registers_info): Update.
	(pa_do_strcat_registers_info): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/sparc/nm-sun4sol2.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-sun4os4.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-nbsd.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/s390/tm-s390.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-mips.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix6.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix5.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/m68k/tm-sun3.h (DEPRECATED_REGISTER_BYTES): Update.
	(REGISTER_BYTES_OK): Update.
	* config/m68k/nm-sun3.h (CHILD_PREPARE_TO_STORE): Update.
	* config/ia64/tm-ia64.h (DEPRECATED_REGISTER_BYTES): Update.

Index: doc/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	REGISTER_BYTES with DEPRECATED_REGISTER_BYTES.  Fix typo,
	DEPRECATED_REGISTER_SIZE instead of REGISTER_BYTE.

Index: mi/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_setup_architecture_data):
@
text
@d1270 16
a1285 35
/* NOTE: cagney/2001-02-18: The functions generic_target_read_pc(),
   read_pc_pid(), read_pc(), generic_target_write_pc(),
   write_pc_pid(), write_pc(), generic_target_read_sp(), read_sp(),
   generic_target_write_sp(), and deprecated_read_fp(), will
   eventually be moved out of the reg-cache into either frame.[hc] or
   to the multi-arch framework.  The are not part of the raw register
   cache.  */

/* This routine is getting awfully cluttered with #if's.  It's probably
   time to turn this into READ_PC and define it in the tm.h file.
   Ditto for write_pc.

   1999-06-08: The following were re-written so that it assumes the
   existence of a TARGET_READ_PC et.al. macro.  A default generic
   version of that macro is made available where needed.

   Since the ``TARGET_READ_PC'' et.al. macro is going to be controlled
   by the multi-arch framework, it will eventually be possible to
   eliminate the intermediate read_pc_pid().  The client would call
   TARGET_READ_PC directly. (cagney). */

CORE_ADDR
generic_target_read_pc (ptid_t ptid)
{
#ifdef PC_REGNUM
  if (PC_REGNUM >= 0)
    {
      CORE_ADDR pc_val = ADDR_BITS_REMOVE ((CORE_ADDR) read_register_pid (PC_REGNUM, ptid));
      return pc_val;
    }
#endif
  internal_error (__FILE__, __LINE__,
		  "generic_target_read_pc");
  return 0;
}
d1297 11
a1307 1
  pc_val = TARGET_READ_PC (ptid);
@


1.81
log
@2003-05-15  Andrew Cagney  <cagney@@redhat.com>

	* regcache.c (build_regcache): Set deprecated_register_valid
	directly.
	(deprecated_grub_regcache_for_register_valid): Delete function.
	* regcache.h (deprecated_grub_regcache_for_register_valid): Delete
	declaration.
@
text
@d123 7
a129 6
     trusting REGISTER_BYTES, but then adjust it upwards should that
     be found to not be sufficient.  */
  /* FIXME: cagney/2002-11-05: Instead of using REGISTER_BYTES, this
     code should, as is done in init_regcache_descr(), compute the
     total number of register bytes using the accumulated offsets.  */
  descr->sizeof_cooked_registers = REGISTER_BYTES; /* OK use.  */
d247 1
a247 1
  /* gdb_assert (descr->sizeof_raw_registers == REGISTER_BYTES (i));  */
@


1.80
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (max_register_size): Delete declaration.
	* regcache.c (max_register_size): Delete function.
	(struct regcache_descr): Delete field "max_register_size".
	(init_regcache_descr, init_legacy_regcache_descr): Assert that all
	registers fit in MAX_REGISTER_SIZE.
	(regcache_save): Replace max_register_size with MAX_REGISTER_SIZE.
	(regcache_restore, regcache_xfer_part, regcache_dump): Ditto.
	* thread-db.c: Replace max_register_size with MAX_REGISTER_SIZE.
	* sh-tdep.c, rom68k-rom.c, remote-sim.c, remote-mips.c: Ditto.
	* remote-e7000.c, monitor.c, mipsv4-nat.c, mips-nat.c: Ditto.
	* m68klinux-nat.c, lynx-nat.c, irix4-nat.c: Ditto.
	* hpux-thread.c, hppah-nat.c, hppab-nat.c, hppa-tdep.c: Ditto.
	* dve3900-rom.c, hppa-tdep.c: Ditto.
@
text
@a501 6
char *
deprecated_grub_regcache_for_register_valid (struct regcache *regcache)
{
  return regcache->register_valid_p;
}

d1421 1
a1421 1
  deprecated_register_valid = deprecated_grub_regcache_for_register_valid (current_regcache);
@


1.80.4.1
log
@Snap const char * mess.
@
text
@d1413 1
a1413 1
reg_flush_command (const char *command, int from_tty)
d1662 1
a1662 1
regcache_print (const char *args, enum regcache_dump_what what_to_dump)
d1677 1
a1677 1
maintenance_print_registers (const char *args, int from_tty)
d1683 1
a1683 1
maintenance_print_raw_registers (const char *args, int from_tty)
d1689 1
a1689 1
maintenance_print_cooked_registers (const char *args, int from_tty)
d1695 1
a1695 1
maintenance_print_register_groups (const char *args, int from_tty)
@


1.79
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@a80 3
  /* Useful constant.  Largest of all the registers.  */
  long max_register_size;

a108 1
  descr->max_register_size = 0;
d118 2
a119 4
      if (descr->max_register_size < REGISTER_RAW_SIZE (i))
	descr->max_register_size = REGISTER_RAW_SIZE (i);
      if (descr->max_register_size < REGISTER_VIRTUAL_SIZE (i))
	descr->max_register_size = REGISTER_VIRTUAL_SIZE (i);
a215 1
    descr->max_register_size = 0;
d221 1
a221 2
	if (descr->max_register_size < descr->sizeof_register[i])
	  descr->max_register_size = descr->sizeof_register[i];
a284 7
max_register_size (struct gdbarch *gdbarch)
{
  struct regcache_descr *descr = regcache_descr (gdbarch);
  return descr->max_register_size;
}

int
d367 1
a367 1
  void *buf = alloca (max_register_size (gdbarch));
d401 1
a401 1
  void *buf = alloca (max_register_size (gdbarch));
d1078 1
a1078 1
  bfd_byte *reg = alloca (descr->max_register_size);
d1468 1
a1468 1
  unsigned char *buf = alloca (regcache->descr->max_register_size);
a1479 2
  fprintf_unfiltered (file, "max_register_size %ld\n",
		      regcache->descr->max_register_size);
@


1.78
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (read_signed_register): New function, moved to here
	from "regcache.c".
	(read_signed_register_pid): Ditto.
	* regcache.c (read_signed_register_pid): Delete function, moved to
	"mips-tdep.c".
	(read_signed_register): Ditto.
	* regcache.h (read_signed_register): Delete declaration.
	(read_signed_register_pid): Delete declaration.
@
text
@a299 9
legacy_max_register_raw_size (void)
{
  if (DEPRECATED_MAX_REGISTER_RAW_SIZE_P ())
    return DEPRECATED_MAX_REGISTER_RAW_SIZE;
  else
    return max_register_size (current_gdbarch);
}

int
d670 1
a670 1
  char *reg_buf = alloca (MAX_REGISTER_RAW_SIZE);
d1060 1
a1060 1
	  char *regbuf = (char*) alloca (MAX_REGISTER_RAW_SIZE);
@


1.77
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Add comments on MAX_REGISTER_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_VIRTUAL_SIZE): Delete macro.
	(legacy_max_register_virtual_size): Delete declaration.
	* infcmd.c (default_print_registers_info): Use MAX_REGISTER_SIZE.
	* d10v-tdep.c (d10v_print_registers_info): Ditto.
	* tracepoint.c (memrange_sortmerge): Ditto.
	* sparc-tdep.c (sparc_print_registers): Ditto.
	* regcache.c (legacy_max_register_virtual_size): Delete function.
@
text
@a1210 30
/* Return the contents of register REGNUM as a signed integer.  */

LONGEST
read_signed_register (int regnum)
{
  void *buf = alloca (REGISTER_RAW_SIZE (regnum));
  deprecated_read_register_gen (regnum, buf);
  return (extract_signed_integer (buf, REGISTER_RAW_SIZE (regnum)));
}

LONGEST
read_signed_register_pid (int regnum, ptid_t ptid)
{
  ptid_t save_ptid;
  LONGEST retval;

  if (ptid_equal (ptid, inferior_ptid))
    return read_signed_register (regnum);

  save_ptid = inferior_ptid;

  inferior_ptid = ptid;

  retval = read_signed_register (regnum);

  inferior_ptid = save_ptid;

  return retval;
}

@


1.76
log
@2003-05-02  Andrew Cagney  <cagney@@redhat.com>

	* sentinel-frame.c (sentinel_frame_prev_register): Replace
	REGISTER_BYTE with register_offset_hack.
	* regcache.c (init_regcache_descr): When REGISTER_BYTE_P, check
	that REGISTER_BYTE is consistent with the regcache.
	* gdbarch.sh (REGISTER_BYTE): Add a predicate.
	* gdbarch.h, gdbarch.c: Regenerate.
@
text
@a308 9
legacy_max_register_virtual_size (void)
{
  if (DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE_P ())
    return DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE;
  else
    return max_register_size (current_gdbarch);
}

int
@


1.75
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d190 6
d242 3
a244 7
#if 0
  /* Sanity check.  Confirm that the assumptions about gdbarch are
     true.  The REGCACHE_DESCR_HANDLE is set before doing the checks
     so that targets using the generic methods supplied by regcache
     don't go into infinite recursion trying to, again, create the
     regcache.  */
  set_gdbarch_data (gdbarch, regcache_descr_handle, descr);
d247 3
d252 1
a252 1
      gdb_assert (descr->register_offset[i] == REGISTER_BYTE (i));
a254 1
#endif
@


1.74
log
@2003-03-27  Andrew Cagney  <cagney@@redhat.com>

	* regcache.c (write_sp): Delete function and references.
	* inferior.h (write_sp): Delete declaration.
	* valops.c (hand_function_call): Replace write_sp with
	TARGET_WRITE_SP.
	* sparc-tdep.c (sparc_push_dummy_frame): Ditto.
	(sparc_pop_frame): Ditto.

Index: doc/ChangeLog
2003-03-27  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Remove
	references to write_sp.
@
text
@d1331 2
a1332 2
/* read_pc, write_pc, read_sp, read_fp, etc.  Special handling for
   registers PC, SP, and FP.  */
d1337 4
a1340 4
   generic_target_write_sp(), generic_target_read_fp() and read_fp(),
   will eventually be moved out of the reg-cache into either
   frame.[hc] or to the multi-arch framework.  The are not part of the
   raw register cache.  */
d1460 1
a1460 1
generic_target_read_fp (void)
d1462 6
a1467 12
#ifdef FP_REGNUM
  if (FP_REGNUM >= 0)
    return read_register (FP_REGNUM);
#endif
  internal_error (__FILE__, __LINE__,
		  "generic_target_read_fp");
}

CORE_ADDR
read_fp (void)
{
  return TARGET_READ_FP ();
@


1.74.6.1
log
@Merge from mainline.
@
text
@d1331 2
a1332 2
/* read_pc, write_pc, read_sp, deprecated_read_fp, etc.  Special
   handling for registers PC, SP, and FP.  */
d1337 4
a1340 4
   generic_target_write_sp(), and deprecated_read_fp(), will
   eventually be moved out of the reg-cache into either frame.[hc] or
   to the multi-arch framework.  The are not part of the raw register
   cache.  */
d1460 1
a1460 1
deprecated_read_fp (void)
d1462 12
a1473 6
  if (DEPRECATED_TARGET_READ_FP_P ())
    return DEPRECATED_TARGET_READ_FP ();
  else if (DEPRECATED_FP_REGNUM >= 0)
    return read_register (DEPRECATED_FP_REGNUM);
  else
    internal_error (__FILE__, __LINE__, "deprecated_read_fp");
@


1.74.6.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d81 3
d112 1
d122 4
a125 2
      gdb_assert (MAX_REGISTER_SIZE >= REGISTER_RAW_SIZE (i));
      gdb_assert (MAX_REGISTER_SIZE >= REGISTER_VIRTUAL_SIZE (i));
d129 6
a134 7
     trusting DEPRECATED_REGISTER_BYTES, but then adjust it upwards
     should that be found to not be sufficient.  */
  /* FIXME: cagney/2002-11-05: Instead of using the macro
     DEPRECATED_REGISTER_BYTES, this code should, as is done in
     init_regcache_descr(), compute the total number of register bytes
     using the accumulated offsets.  */
  descr->sizeof_cooked_registers = DEPRECATED_REGISTER_BYTES; /* OK */
a189 6
      /* NOTE: cagney/2003-05-02: Don't add a test for REGISTER_BYTE_P
	 to the above.  Doing that would cause all the existing
	 architectures to revert back to the legacy regcache
	 mechanisms, and that is not a good thing.  Instead just,
	 later, check that the register cache's layout is consistent
	 with REGISTER_BYTE.  */
d216 1
d222 2
a223 1
	gdb_assert (MAX_REGISTER_SIZE >= descr->sizeof_register[i]);
d236 7
a242 3
  /* Sanity check.  Confirm that there is agreement between the
     regcache and the target's redundant REGISTER_BYTE (new targets
     should not even be defining it).  */
a244 3
      if (REGISTER_BYTE_P ())
	gdb_assert (descr->register_offset[i] == REGISTER_BYTE (i));
#if 0
d247 3
a250 2
    }
  /* gdb_assert (descr->sizeof_raw_registers == DEPRECATED_REGISTER_BYTES (i));  */
d289 25
d396 1
a396 1
  char buf[MAX_REGISTER_SIZE];
d430 1
a430 1
  char buf[MAX_REGISTER_SIZE];
d531 6
d684 1
a684 1
  char reg_buf[MAX_REGISTER_SIZE];
d1074 1
a1074 1
	  char regbuf[MAX_REGISTER_SIZE];
d1107 1
a1107 1
  bfd_byte reg[MAX_REGISTER_SIZE];
d1216 30
d1486 1
a1486 1
  deprecated_register_valid = current_regcache->register_valid_p;
d1527 1
a1527 1
  unsigned char buf[MAX_REGISTER_SIZE];
d1539 2
@


1.73
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* regcache.c (regcache_cooked_write_signed): New function.
	(regcache_cooked_write_unsigned): New function.
	(regcache_cooked_read_unsigned): Fix regnum in range assertion.
	(regcache_cooked_read_signed): Fix regnum in range assertion.
	* regcache.h (regcache_cooked_write_signed): Declare.
	(regcache_cooked_write_unsigned): Declare.
@
text
@d1331 2
a1332 2
/* read_pc, write_pc, read_sp, write_sp, read_fp, etc.  Special
   handling for registers PC, SP, and FP.  */
d1337 4
a1340 4
   generic_target_write_sp(), write_sp(), generic_target_read_fp() and
   read_fp(), will eventually be moved out of the reg-cache into
   either frame.[hc] or to the multi-arch framework.  The are not part
   of the raw register cache.  */
a1456 6
}

void
write_sp (CORE_ADDR val)
{
  TARGET_WRITE_SP (val);
@


1.73.6.1
log
@Merge with mainline.
@
text
@d1331 2
a1332 2
/* read_pc, write_pc, read_sp, read_fp, etc.  Special handling for
   registers PC, SP, and FP.  */
d1337 4
a1340 4
   generic_target_write_sp(), generic_target_read_fp() and read_fp(),
   will eventually be moved out of the reg-cache into either
   frame.[hc] or to the multi-arch framework.  The are not part of the
   raw register cache.  */
d1457 6
@


1.72
log
@2003-03-10  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (regcache_cooked_read_ftype): Define.
	(regcache_save, regcache_restore): Add a cooked_read parameter.
	* regcache.c (regcache_save, regcache_restore): Update.
	(do_cooked_read): New function.
	(regcache_cpy): Pass do_cooked_read to regcache_save and
	regcache_restore.
@
text
@d887 1
a887 1
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
d900 1
a900 1
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
d905 24
@


1.71
log
@2003-03-03  Andrew Cagney  <cagney@@redhat.com>

	Make MAX_REGISTER_RAW_SIZE and MAX_REGISTER_VIRTUAL_SIZE optional.
	* gdbarch.sh (DEPRECATED_MAX_REGISTER_RAW_SIZE): Variable with
	predicate.  Replace MAX_REGISTER_RAW_SIZE.
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto for
	MAX_REGISTER_VIRTUAL_SIZE.
	* regcache.c (legacy_max_register_raw_size): New function.
	(legacy_max_register_virtual_size): New function.
	* defs.h (MAX_REGISTER_VIRTUAL_SIZE): Define.
	(MAX_REGISTER_RAW_SIZE): Define.
	(legacy_max_register_raw_size): Declare.
	(legacy_max_register_virtual_size): Declare.
	* config/sparc/tm-sparc.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/i386/tm-ptx.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Do not set
	max_register_raw_size or max_register_virtual_size.
@
text
@d392 2
a393 1
regcache_save (struct regcache *dst, struct regcache *src)
d396 1
a397 3
  /* The SRC and DST register caches had better belong to the same
     architecture.  */
  gdb_assert (src->descr->gdbarch == dst->descr->gdbarch);
d399 1
a399 1
     end up trying to write the register values out through to the
a400 1
  gdb_assert (!src->readonly_p);
d406 3
a408 4
     save_reggroup) and mark them as valid.  The full [0
     .. NUM_REGS+NUM_PSEUDO_REGS) range is checked since some
     architectures need to save/restore `cooked' registers that live
     in memory.  */
d413 7
a419 2
	  regcache_cooked_read (src, regnum, register_buffer (dst, regnum));
	  dst->register_valid_p[regnum] = 1;
d425 3
a427 1
regcache_restore (struct regcache *dst, struct regcache *src)
d430 1
d432 2
a433 1
  gdb_assert (src->descr->gdbarch == dst->descr->gdbarch);
a434 1
  gdb_assert (src->readonly_p);
d436 4
a439 5
     were both saved and need to be restored.  The full [0
     .. NUM_REGS+NUM_PSEUDO_REGS) range is checked since some
     architectures need to save/restore `cooked' registers that live
     in memory.  */
  for (regnum = 0; regnum < src->descr->nr_cooked_registers; regnum++)
d441 1
a441 2
      if (gdbarch_register_reggroup_p (gdbarch, regnum, restore_reggroup)
	  && src->register_valid_p[regnum])
d443 3
a445 1
	  regcache_cooked_write (dst, regnum, register_buffer (src, regnum));
d450 15
d475 1
a475 1
    regcache_save (dst, src);
d477 1
a477 1
    regcache_restore (dst, src);
@


1.71.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d392 1
a392 2
regcache_save (struct regcache *dst, regcache_cooked_read_ftype *cooked_read,
	       void *src)
a394 1
  void *buf = alloca (max_register_size (gdbarch));
d396 3
d400 1
a400 1
     end up trying to write the register values back out to the
d402 1
d408 4
a411 3
     save_reggroup) and mark them as valid.  The full [0 .. NUM_REGS +
     NUM_PSEUDO_REGS) range is checked since some architectures need
     to save/restore `cooked' registers that live in memory.  */
d416 2
a417 7
	  int valid = cooked_read (src, regnum, buf);
	  if (valid)
	    {
	      memcpy (register_buffer (dst, regnum), buf,
		      register_size (gdbarch, regnum));
	      dst->register_valid_p[regnum] = 1;
	    }
d423 1
a423 3
regcache_restore (struct regcache *dst,
		  regcache_cooked_read_ftype *cooked_read,
		  void *src)
a425 1
  void *buf = alloca (max_register_size (gdbarch));
d427 1
a427 2
  /* The dst had better not be read-only.  If it is, the `restore'
     doesn't make much sense.  */
d429 1
d431 5
a435 4
     were both saved and need to be restored.  The full [0 .. NUM_REGS
     + NUM_PSEUDO_REGS) range is checked since some architectures need
     to save/restore `cooked' registers that live in memory.  */
  for (regnum = 0; regnum < dst->descr->nr_cooked_registers; regnum++)
d437 2
a438 1
      if (gdbarch_register_reggroup_p (gdbarch, regnum, restore_reggroup))
d440 1
a440 3
	  int valid = cooked_read (src, regnum, buf);
	  if (valid)
	    regcache_cooked_write (dst, regnum, buf);
a444 15
static int
do_cooked_read (void *src, int regnum, void *buf)
{
  struct regcache *regcache = src;
  if (!regcache_valid_p (regcache, regnum)
      && regcache->readonly_p)
    /* Don't even think about fetching a register from a read-only
       cache when the register isn't yet valid.  There isn't a target
       from which the register value can be fetched.  */
    return 0;
  regcache_cooked_read (regcache, regnum, buf);
  return 1;
}


d455 1
a455 1
    regcache_save (dst, do_cooked_read, src);
d457 1
a457 1
    regcache_restore (dst, do_cooked_read, src);
d867 1
a867 1
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_cooked_registers);
d880 1
a880 1
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_cooked_registers);
a884 24
}

void
regcache_cooked_write_signed (struct regcache *regcache, int regnum,
			      LONGEST val)
{
  void *buf;
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >=0 && regnum < regcache->descr->nr_cooked_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  store_signed_integer (buf, regcache->descr->sizeof_register[regnum], val);
  regcache_cooked_write (regcache, regnum, buf);
}

void
regcache_cooked_write_unsigned (struct regcache *regcache, int regnum,
				ULONGEST val)
{
  void *buf;
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >=0 && regnum < regcache->descr->nr_cooked_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  store_unsigned_integer (buf, regcache->descr->sizeof_register[regnum], val);
  regcache_cooked_write (regcache, regnum, buf);
@


1.71.2.1
log
@2003-03-06  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_frame_pop): Delete function.
	(d10v_frame_unwind): Update.
	* frame.c: Include "reggroups.h".
	* regcache.c (regcache_raw_write): Allow writes to a readonly
	regcache.
	* frame.c (frame_saved_regs_pop): Delete function.
	(trad_frame_unwinder): Update
	(frame_pop): Rewrite.
	* sentinel-frame.c (sentinel_frame_pop): Delete function.
	(sentinel_frame_unwinder): Update.
	* dummy-frame.c (dummy_frame_pop): Delete function.
	(dummy_frame_unwind): Update.
	* frame-unwind.h (frame_unwind_pop_ftype): Delete definition.
	(struct frame_unwind): Update.
@
text
@d932 1
a932 8

  if (regcache->readonly_p)
    {
      memcpy (register_buffer (regcache, regnum), buf,
	      regcache->descr->sizeof_register[regnum]);
      regcache->register_valid_p[regnum] = 1;
      return;
    }
@


1.71.2.2
log
@2003-03-10  Andrew Cagney  <cagney@@redhat.com>

	* frame.c: Merge in posted frame_pop patch.
	* regcache.h, regcache.c: Merge with mainline.
@
text
@d392 1
a392 2
regcache_save (struct regcache *dst, regcache_cooked_read_ftype *cooked_read,
	       void *src)
a394 1
  void *buf = alloca (max_register_size (gdbarch));
d396 3
d400 1
a400 1
     end up trying to write the register values back out to the
d402 1
d408 4
a411 3
     save_reggroup) and mark them as valid.  The full [0 .. NUM_REGS +
     NUM_PSEUDO_REGS) range is checked since some architectures need
     to save/restore `cooked' registers that live in memory.  */
d416 2
a417 7
	  int valid = cooked_read (src, regnum, buf);
	  if (valid)
	    {
	      memcpy (register_buffer (dst, regnum), buf,
		      register_size (gdbarch, regnum));
	      dst->register_valid_p[regnum] = 1;
	    }
d423 1
a423 3
regcache_restore (struct regcache *dst,
		  regcache_cooked_read_ftype *cooked_read,
		  void *src)
a425 1
  void *buf = alloca (max_register_size (gdbarch));
d427 1
a427 2
  /* The dst had better not be read-only.  If it is, the `restore'
     doesn't make much sense.  */
d429 1
d431 5
a435 4
     were both saved and need to be restored.  The full [0 .. NUM_REGS
     + NUM_PSEUDO_REGS) range is checked since some architectures need
     to save/restore `cooked' registers that live in memory.  */
  for (regnum = 0; regnum < dst->descr->nr_cooked_registers; regnum++)
d437 2
a438 1
      if (gdbarch_register_reggroup_p (gdbarch, regnum, restore_reggroup))
d440 1
a440 3
	  int valid = cooked_read (src, regnum, buf);
	  if (valid)
	    regcache_cooked_write (dst, regnum, buf);
a444 15
static int
do_cooked_read (void *src, int regnum, void *buf)
{
  struct regcache *regcache = src;
  if (!regcache_valid_p (regcache, regnum)
      && regcache->readonly_p)
    /* Don't even think about fetching a register from a read-only
       cache when the register isn't yet valid.  There isn't a target
       from which the register value can be fetched.  */
    return 0;
  regcache_cooked_read (regcache, regnum, buf);
  return 1;
}


d455 1
a455 1
    regcache_save (dst, do_cooked_read, src);
d457 1
a457 1
    regcache_restore (dst, do_cooked_read, src);
d932 8
a939 1
  gdb_assert (!regcache->readonly_p);
@


1.70
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (register_type): New function with predicate.
	(REGISTER_VIRTUAL_TYPE): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.c (generic_register_byte): Use generic_register_size.
	(generic_register_size): When available, use
	gdbarch_register_type.
	* regcache.c (init_regcache_descr): When available, initialize the
	register type array using gdbarch_register_type.  If the
	architecture supplies gdbarch_register_type, do not use the legacy
	regcache layout.
	* d10v-tdep.c (d10v_register_type): Replace
	d10v_register_virtual_type.
	(d10v_gdbarch_init): Set register_type instead of
	register_virtual_type.
@
text
@d296 18
@


1.69
log
@2003-02-28  Andrew Cagney  <cagney@@redhat.com>

	* regcache.c (register_size): New function.
	* regcache.h (register_size): Declare
	* d10v-tdep.c: Use register_size instead of REGISTER_RAW_SIZE, use
	max_register_size instead of MAX_REGISTER_RAW_SIZE.
@
text
@d175 7
a181 1
      descr->register_type[i] = REGISTER_VIRTUAL_TYPE (i);
d187 2
a188 1
      && !gdbarch_pseudo_register_write_p (gdbarch))
@


1.68
log
@2002-11-14  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_registers): Rename registers.
	* a68v-nat.c, alpha-nat.c, arch-utils.c, core-sol2.c: Update.
	* hp300ux-nat.c, hppab-nat.c, hppah-nat.c: Update.
	* hppam3-nat.c, hpux-thread.c, i386gnu-nat.c: Update.
	* ia64-aix-nat.c, ia64-linux-nat.c, ia64-tdep.c: Update.
	* irix4-nat.c, irix5-nat.c, lynx-nat.c, m68k-tdep.c: Update.
	* m68knbsd-nat.c, mips-linux-tdep.c, mipsm3-nat.c: Update.
	* mipsv4-nat.c, ns32knbsd-nat.c, ppc-bdm.c: Update.
	* ppc-sysv-tdep.c, ptx4-nat.c, regcache.c, remote-es.c: Update.
	* remote-sds.c, remote-vx68.c, remote-vxmips.c: Update.
	* remote-vxsparc.c, rs6000-tdep.c, sol-thread.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, symm-nat.c: Update.
	* v850ice.c: Update.
@
text
@d288 12
@


1.67
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_bytes): Rename
	read_register_bytes.
	(deprecated_write_register_bytes): Rename write_register_bytes.
	* alpha-tdep.c, arm-tdep.c, cris-tdep.c, d10v-tdep.c: Update.
	* dwarf2cfi.c, frv-tdep.c, hppa-tdep.c, ia64-tdep.c: Update.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, regcache.c, remote-sds.c, remote-vx.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh-tdep.c: Update.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c, x86-64-tdep.c: Update.
	* xstormy16-tdep.c, z8k-tdep.c, config/nm-gnu.h: Update.
	* config/nm-m3.h, config/h8500/tm-h8500.h: Update.
	* config/i386/nm-ptx4.h, config/i386/nm-symmetry.h: Update.
	* config/m32r/tm-m32r.h, config/m68k/nm-sun3.h: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-linux.h: Update.
	* config/mn10200/tm-mn10200.h, config/pa/tm-hppa64.h: Update.
	* config/sparc/nm-nbsd.h, config/sparc/nm-sun4os4.h: Update.
	* config/sparc/nm-sun4sol2.h, config/sparc/tm-sparclet.h: Update.

2002-11-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Use
	deprecated_write_register_bytes instead of write_register_bytes.
@
text
@d492 1
a492 1
char *registers;
d660 1
a660 1
	memcpy (reg_buf, registers + reg_start, reg_len);
d1003 1
a1003 1
	  memcpy (registers + overlapstart,
d1416 1
a1416 1
  registers = deprecated_grub_regcache_for_registers (current_regcache);
d1698 1
a1698 1
  register_gdbarch_swap (&registers, sizeof (registers), NULL);
@


1.66
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.c (struct regcache): Replace passthough_p with
	readonly_p.
	(regcache_xmalloc): Initialize readonly_p.
	(build_regcache): Initialize readonly_p.
	(regcache_save): New function.
	(regcache_restore): New function.
	(regcache_cpy): Re-implement using regcache_save and
	regcache_restore.
	(regcache_raw_read): Update.
	(regcache_cooked_read): When a read-only cache, checked for cached
	pseudo register values.
	(regcache_raw_write): Assert that the cache is not read-only.
	Remove code handling a non-passthrough cache.
	* regcache.h (regcache_save): Declare.
	(regcache_restore): Declare.
@
text
@d601 10
a610 10
/* read_register_bytes and write_register_bytes are generally a *BAD*
   idea.  They are inefficient because they need to check for partial
   updates, which can only be done by scanning through all of the
   registers and seeing if the bytes that are being read/written fall
   inside of an invalid register.  [The main reason this is necessary
   is that register sizes can vary, so a simple index won't suffice.]
   It is far better to call read_register_gen and write_register_gen
   if you want to get at the raw register contents, as it only takes a
   regnum as an argument, and therefore can't do a partial register
   update.
d613 4
a616 4
   and write_register_bytes always checked to see if any registers
   were stale, and then called target_fetch_registers (-1) to update
   the whole set.  This caused really slowed things down for remote
   targets.  */
d623 1
a623 1
read_register_bytes (int in_start, char *in_buf, int in_len)
d963 1
a963 1
write_register_bytes (int myregstart, char *myaddr, int inlen)
@


1.65
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.c (struct regcache_descr): Add fields
	sizeof_cooked_registers and sizeof_cooked_register_valid_p.
	(init_legacy_regcache_descr): Compute the size of a cooked
	register cache and then assign that to sizeof_raw_registers.  Set
	sizeof_raw_register_valid_p to sizeof_cooked_register_valid_p
	(init_legacy_regcache_descr): Ditto.
@
text
@d298 7
a304 3
  /* If a value isn't in the cache should the corresponding target be
     queried for a value.  */
  int passthrough_p;
d320 1
a320 1
  regcache->passthrough_p = 0;
d355 54
d416 7
a422 27
  /* FIXME: cagney/2002-05-17: To say this bit is bad is being polite.
     It keeps the existing code working where things rely on going
     through to the register cache.  */
  if (src == current_regcache && src->descr->legacy_p)
    {
      /* ULGH!!!!  Old way.  Use REGISTER bytes and let code below
	 untangle fetch.  */
      read_register_bytes (0, dst->registers, REGISTER_BYTES);
      return;
    }
  /* FIXME: cagney/2002-05-17: To say this bit is bad is being polite.
     It keeps the existing code working where things rely on going
     through to the register cache.  */
  if (dst == current_regcache && dst->descr->legacy_p)
    {
      /* ULGH!!!!  Old way.  Use REGISTER bytes and let code below
	 untangle fetch.  */
      write_register_bytes (0, src->registers, REGISTER_BYTES);
      return;
    }
  buf = alloca (src->descr->max_register_size);
  for (i = 0; i < src->descr->nr_raw_registers; i++)
    {
      /* Should we worry about the valid bit here?  */
      regcache_raw_read (src, i, buf);
      regcache_raw_write (dst, i, buf);
    }
d716 1
a716 1
      && regcache->passthrough_p)
d729 1
a729 1
  if (regcache->passthrough_p)
d813 6
d895 1
d897 1
a897 2
  if (regcache->passthrough_p
      && regcache->descr->legacy_p)
a911 10
  /* Handle the simple case first -> not write through so just store
     value in cache.  */
  if (!regcache->passthrough_p)
    {
      memcpy (register_buffer (regcache, regnum), buf,
	      regcache->descr->sizeof_register[regnum]);
      regcache->register_valid_p[regnum] = 1;
      return;
    }

d1415 1
a1415 1
  current_regcache->passthrough_p = 1;
@


1.64
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.c (register_buffer): Move to near start of file, update
	description.
	(regcache_raw_read): Use.
	(regcache_raw_write): Use.
	(struct regcache): Rename raw_registers to registers and
	raw_register_valid_p to register_valid_p.
	(regcache_xmalloc): Update.
	(regcache_xfree): Update.
	(register_buffer): Update.
	(regcache_cpy): Update.
	(regcache_cpy_no_passthrough): Update.
	(regcache_valid_p): Update.
	(deprecated_grub_regcache_for_registers): Update.
	(deprecated_grub_regcache_for_register_valid): Update.
	(set_register_cached): Update.
	(regcache_raw_write): Update.
@
text
@d69 2
d98 2
a99 1
     in the register buffer.  Unfortunatly some architectures do.  */
d101 1
a101 1
  descr->sizeof_raw_register_valid_p = descr->nr_cooked_registers;
d103 7
a109 5
  /* FIXME: cagney/2002-05-11: Instead of using REGISTER_BYTE() this
     code should compute the offets et.al. at runtime.  This currently
     isn't possible because some targets overlap register locations -
     see the mess in read_register_bytes() and write_register_bytes()
     registers.  */
d115 5
d128 7
a134 2
  /* Come up with the real size of the registers buffer.  */
  descr->sizeof_raw_registers = REGISTER_BYTES; /* OK use.  */
a142 5
      /* FIXME: cagney/2001-12-04: This code shouldn't need to use
         REGISTER_BYTE().  Unfortunatly, legacy code likes to lay the
         buffer out so that certain registers just happen to overlap.
         Ulgh!  New targets use gdbarch's register read/write and
         entirely avoid this uglyness.  */
d144 2
a145 2
      if (descr->sizeof_raw_registers < regend)
	descr->sizeof_raw_registers = regend;
d147 4
d168 1
d196 1
a196 1
  descr->sizeof_raw_register_valid_p = NUM_REGS + NUM_PSEUDO_REGS;
d198 1
a198 4
  /* Lay out the register cache.  The pseud-registers are included in
     the layout even though their value isn't stored in the register
     cache.  Some code, via read_register_bytes() access a register
     using an offset/length rather than a register number.
d219 1
a219 7
    /* FIXME: cagney/2002-05-22: Should only need to allocate space
       for the raw registers.  Unfortunatly some code still accesses
       the register array directly using the global registers[].
       Until that code has been purged, play safe and over allocating
       the register buffer.  Ulgh!  */
    descr->sizeof_raw_registers = offset;
    /* = descr->register_offset[descr->nr_raw_registers]; */
d221 7
@


1.63
log
@2002-11-07  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (regcache_cooked_read_using_offset_hack)
	(regcache_cooked_write_using_offset_hack): Delete declarations.
	(register_changed): Delete declaration.
	* regcache.c (regcache_cooked_read_using_offset_hack)
	(regcache_cooked_write_using_offset_hack): Delete functions.
	(cooked_xfer_using_offset_hack): Delete function.
	(register_changed): Delete function.
@
text
@d280 5
a284 2
  char *raw_registers;
  char *raw_register_valid_p;
d299 1
a299 1
  regcache->raw_registers
d301 1
a301 1
  regcache->raw_register_valid_p
d312 2
a313 2
  xfree (regcache->raw_registers);
  xfree (regcache->raw_register_valid_p);
d329 8
d352 1
a352 1
      read_register_bytes (0, dst->raw_registers, REGISTER_BYTES);
d362 1
a362 1
      write_register_bytes (0, src->raw_registers, REGISTER_BYTES);
d384 2
a385 3
  memcpy (dst->raw_registers, src->raw_registers,
	  dst->descr->sizeof_raw_registers);
  memcpy (dst->raw_register_valid_p, src->raw_register_valid_p,
d414 1
a414 1
  return regcache->raw_register_valid_p[regnum];
d420 1
a420 1
  return regcache->raw_registers;
d426 1
a426 1
  return regcache->raw_register_valid_p;
d484 1
a484 10
  current_regcache->raw_register_valid_p[regnum] = state;
}

/* If REGNUM >= 0, return a pointer to register REGNUM's cache buffer area,
   else return a pointer to the start of the cache buffer.  */

static char *
register_buffer (struct regcache *regcache, int regnum)
{
  return regcache->raw_registers + regcache->descr->register_offset[regnum];
d690 1
a690 2
  memcpy (buf, (regcache->raw_registers
		+ regcache->descr->register_offset[regnum]),
d859 1
a859 2
      memcpy ((regcache->raw_registers
	       + regcache->descr->register_offset[regnum]), buf,
d861 1
a861 1
      regcache->raw_register_valid_p[regnum] = 1;
d883 1
a883 1
  regcache->raw_register_valid_p[regnum] = 1;
@


1.62
log
@2002-11-07  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.c (deprecated_registers_fetched): Update.
	* regcache.h (deprecated_registers_fetched): Rename
	registers_fetched.
	* remote-vxsparc.c (vx_read_register): Update.
	* remote-vxmips.c (vx_read_register): Update.
	* remote-vx68.c (vx_read_register): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* mipsm3-nat.c (fetch_inferior_registers): Update.
	* sun3-nat.c (fetch_inferior_registers): Update.
	* symm-nat.c (fetch_inferior_registers): Update.
	* ns32knbsd-nat.c (fetch_inferior_registers): Update.
	(fetch_core_registers): Update.
	(fetch_kcore_registers): Update.
	* mips-nat.c (fetch_inferior_registers): Update.
	* corelow.c (get_core_registers): Update.
	* a68v-nat.c (fetch_inferior_registers): Update.
@
text
@a476 9
/* REGISTER_CHANGED

   invalidate a single register REGNUM in the cache */
void
register_changed (int regnum)
{
  set_register_cached (regnum, 0);
}

a1055 78
}

static void
cooked_xfer_using_offset_hack (struct regcache *regcache,
			       int buf_start, int buf_len, void *in_b,
			       const void *out_b)
{
  struct regcache_descr *descr = regcache->descr;
  struct gdbarch *gdbarch = descr->gdbarch;
  bfd_byte *in_buf = in_b;
  const bfd_byte *out_buf = out_b;
  int buf_end = buf_start + buf_len;
  int regnum;
  char *reg_buf = alloca (descr->max_register_size);

  /* NOTE: cagney/2002-08-17: This code assumes that the register
     offsets are strictly increasing and do not overlap.  If this
     isn't the case then the bug is in the target architecture and NOT
     this code.  */

  /* NOTE: cagney/2002-08-17: This code assumes that only the
     registers covered by BUF_START:BUF_LEN should be transfered.  If,
     for some reason, there is a gap between two registers, then that
     gap isn't transfered.  (The gap shouldn't be there but that is
     another story.)  */

  /* Iterate through all registers looking for those that lie within
     BUF_START:BUF_LEN.  */

  for (regnum = 0; regnum < descr->nr_cooked_registers; regnum++)
    {
      /* The register's location.  */
      int reg_start = descr->register_offset[regnum];
      int reg_len = descr->sizeof_register[regnum];
      int reg_end = reg_start + reg_len;

      /* The START, END and LEN that falls within the current
         register.  */
      int xfer_start;
      int xfer_end;
      int xfer_len;

      /* start = max (reg_start, buf_start) */
      if (reg_start > buf_start)
	xfer_start = reg_start;
      else
	xfer_start = buf_start;
      
      /* end = min (reg_end, buf_end) */
      if (reg_end < buf_end)
	xfer_end = reg_end;
      else
	xfer_end = buf_end;
      
      /* The number of bytes to transfer.  If there isn't anything to
         transfer (the end is before the start) this will be -ve.  */
      xfer_len = xfer_end - xfer_start;

      if (xfer_len > 0)
	regcache_xfer_part (regcache, regnum, xfer_start - reg_start,
			    xfer_len, in_b, out_b, regcache_cooked_read,
			    regcache_cooked_write);
    }
}

void
regcache_cooked_read_using_offset_hack (struct regcache *regcache,
					int buf_start, int buf_len, void *b)
{
  cooked_xfer_using_offset_hack (regcache, buf_start, buf_len, b, NULL);
}

void
regcache_cooked_write_using_offset_hack (struct regcache *regcache,
					 int buf_start, int buf_len,
					 const void *b)
{
  cooked_xfer_using_offset_hack (regcache, buf_start, buf_len, NULL, b);
@


1.61
log
@2002-11-06  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_register_valid): Rename register_valid.
	* regcache.c: Update.
	* ia64-aix-nat.c: Update.
	* i386gnu-nat.c: Update.
	* alpha-nat.c: Update.
	* sparc-nat.c: Update.
	* lynx-nat.c: Update.
	* remote-mips.c: Update.
@
text
@d535 1
a535 1
/* REGISTERS_FETCHED ()
d548 1
a548 1
registers_fetched (void)
@


1.60
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* reggroups.h, reggroups.c: New files.
	* regcache.c: Include "reggroups.h".
	(enum regcache_dump_what): Add `regcache_dump_groups'.
	(regcache_dump): Contract size of the "Type" column.  When
	specified, dump the register's groups.
	(maintenance_print_register_groups): New function.
	(_initialize_regcache): Add command `maint print register-groups'.
	* Makefile.in (COMMON_OBS): Add reggroups.o
	(SFILES): Add reggroups.c.
	(reggroups_h): Define.
	(regcache.o, gdbarch.o): Update dependencies.
	(reggroups.o): Specify dependencies.
	* gdbarch.sh (register_reggroup_p): Add pure multi-arch method.
	Add opaque declaration for `struct reggroup' in generated .h file.
	Include "reggroups.h" in generated .c file.
	gdbarch.h, gdbarch.c: Re-generate.
@
text
@d421 1
a421 1
   register_valid[] currently point into this structure.  */
d433 1
a433 1
/* REGISTER_VALID is 0 if the register needs to be fetched,
d444 1
a444 1
signed char *register_valid;
d463 1
a463 1
  return register_valid[regnum];
d678 1
a678 1
	 via the global register_valid[].  */
d853 1
a853 1
	 via the globals register_valid[] and registers[].  */
d1458 1
a1458 1
  register_valid = deprecated_grub_regcache_for_register_valid (current_regcache);
d1740 1
a1740 1
  register_gdbarch_swap (&register_valid, sizeof (register_valid), NULL);
@


1.59
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@d29 1
d1483 1
a1483 1
  regcache_dump_none, regcache_dump_raw, regcache_dump_cooked
d1491 2
d1599 26
a1624 21
      if (regnum < 0)
	fprintf_unfiltered (file, " %-20s", "Type");
      else
	{
	  static const char blt[] = "builtin_type";
	  const char *t = TYPE_NAME (register_type (regcache->descr->gdbarch,
						    regnum));
	  if (t == NULL)
	    {
	      char *n;
	      if (!footnote_register_type_name_null)
		footnote_register_type_name_null = ++footnote_nr;
	      xasprintf (&n, "*%d", footnote_register_type_name_null);
	      make_cleanup (xfree, n);
	      t = n;
	    }
	  /* Chop a leading builtin_type.  */
	  if (strncmp (t, blt, strlen (blt)) == 0)
	    t += strlen (blt);
	  fprintf_unfiltered (file, " %-20s", t);
	}
d1658 20
d1727 6
d1763 5
@


1.58
log
@* regcache.c (regcache_raw_write_signed,
regcache_raw_write_unsigned): New functions.
* regcache.h (regcache_raw_write_signed,
regcache_raw_write_unsigned): New prototypes.
@
text
@d607 1
a607 1
	read_register_gen (regnum, reg_buf);
d751 1
a751 1
read_register_gen (int regnum, char *buf)
d897 1
a897 1
write_register_gen (int regnum, char *buf)
d950 1
a950 1
	write_register_gen (regnum, myaddr + (regstart - myregstart));
d963 1
a963 1
	  read_register_gen (regnum, regbuf);
d1150 1
a1150 1
  read_register_gen (regnum, buf);
d1181 1
a1181 1
  read_register_gen (regnum, buf);
d1215 1
a1215 1
  write_register_gen (regnum, buf);
@


1.58.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a28 1
#include "reggroups.h"
d53 4
a56 5
  /* The raw register cache.  Each raw (or hard) register is supplied
     by the target interface.  The raw cache should not contain
     redundant information - if the PC is constructed from two
     registers then those regigisters and not the PC lives in the raw
     cache.  */
a67 2
  long sizeof_cooked_registers;
  long sizeof_cooked_register_valid_p;
d78 3
d85 1
a85 1
static void
d94 13
a106 12
  /* Compute the offset of each register.  Legacy architectures define
     DEPRECATED_REGISTER_BYTE() so use that.  */
  /* FIXME: cagney/2002-11-07: Instead of using
     DEPRECATED_REGISTER_BYTE() this code should, as is done in
     init_regcache_descr(), compute the offets at runtime.  This
     currently isn't possible as some ISAs define overlapping register
     regions - see the mess in read_register_bytes() and
     write_register_bytes() registers.  */
  descr->sizeof_register
    = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, long);
  descr->register_offset
    = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, long);
d109 10
a118 19
      /* FIXME: cagney/2001-12-04: This code shouldn't need to use
         DEPRECATED_REGISTER_BYTE().  Unfortunately, legacy code likes
         to lay the buffer out so that certain registers just happen
         to overlap.  Ulgh!  New targets use gdbarch's register
         read/write and entirely avoid this uglyness.  */
      descr->register_offset[i] = DEPRECATED_REGISTER_BYTE (i);
      descr->sizeof_register[i] = DEPRECATED_REGISTER_RAW_SIZE (i);
      gdb_assert (MAX_REGISTER_SIZE >= DEPRECATED_REGISTER_RAW_SIZE (i));
      gdb_assert (MAX_REGISTER_SIZE >= DEPRECATED_REGISTER_VIRTUAL_SIZE (i));
    }

  /* Compute the real size of the register buffer.  Start out by
     trusting DEPRECATED_REGISTER_BYTES, but then adjust it upwards
     should that be found to not be sufficient.  */
  /* FIXME: cagney/2002-11-05: Instead of using the macro
     DEPRECATED_REGISTER_BYTES, this code should, as is done in
     init_regcache_descr(), compute the total number of register bytes
     using the accumulated offsets.  */
  descr->sizeof_cooked_registers = DEPRECATED_REGISTER_BYTES; /* OK */
d125 7
a131 2
         buffer separated by holes.  Once DEPRECATED_REGISTER_BYTE()
         is killed this can be greatly simplified.  */
d133 2
a134 2
      if (descr->sizeof_cooked_registers < regend)
	descr->sizeof_cooked_registers = regend;
a135 4
  /* FIXME: cagney/2002-05-11: Shouldn't be including pseudo-registers
     in the register cache.  Unfortunately some architectures still
     rely on this and the pseudo_register_write() method.  */
  descr->sizeof_raw_registers = descr->sizeof_cooked_registers;
d146 1
a146 1
  descr = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct regcache_descr);
a152 1
  descr->sizeof_cooked_register_valid_p = NUM_REGS + NUM_PSEUDO_REGS;
d155 2
a156 2
  descr->register_type
    = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, struct type *);
d159 11
a169 7
      if (gdbarch_register_type_p (gdbarch))
	{
	  gdb_assert (!DEPRECATED_REGISTER_VIRTUAL_TYPE_P ()); /* OK */
	  descr->register_type[i] = gdbarch_register_type (gdbarch, i);
	}
      else
	descr->register_type[i] = DEPRECATED_REGISTER_VIRTUAL_TYPE (i); /* OK */
d180 1
a180 21
  descr->sizeof_raw_register_valid_p = descr->sizeof_cooked_register_valid_p;

  /* If an old style architecture, fill in the remainder of the
     register cache descriptor using the register macros.  */
  /* NOTE: cagney/2003-06-29: If either of DEPRECATED_REGISTER_BYTE or
     DEPRECATED_REGISTER_RAW_SIZE are still present, things are most likely
     totally screwed.  Ex: an architecture with raw register sizes
     smaller than what DEPRECATED_REGISTER_BYTE indicates; non
     monotonic DEPRECATED_REGISTER_BYTE values.  For GDB 6 check for
     these nasty methods and fall back to legacy code when present.
     Sigh!  */
  if ((!gdbarch_pseudo_register_read_p (gdbarch)
       && !gdbarch_pseudo_register_write_p (gdbarch)
       && !gdbarch_register_type_p (gdbarch))
      || DEPRECATED_REGISTER_BYTE_P ()
      || DEPRECATED_REGISTER_RAW_SIZE_P ())
    {
      descr->legacy_p = 1;
      init_legacy_regcache_descr (gdbarch, descr);
      return descr;
    }
d182 4
a185 1
  /* Lay out the register cache.
d194 3
a196 4
    descr->sizeof_register
      = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, long);
    descr->register_offset
      = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, long);
d202 2
a203 1
	gdb_assert (MAX_REGISTER_SIZE >= descr->sizeof_register[i]);
d206 7
a212 1
    descr->sizeof_cooked_registers = offset;
d215 7
a221 10
  /* FIXME: cagney/2002-05-22: Should only need to allocate space for
     the raw registers.  Unfortunately some code still accesses the
     register array directly using the global registers[].  Until that
     code has been purged, play safe and over allocating the register
     buffer.  Ulgh!  */
  descr->sizeof_raw_registers = descr->sizeof_cooked_registers;

  /* Sanity check.  Confirm that there is agreement between the
     regcache and the target's redundant DEPRECATED_REGISTER_BYTE (new
     targets should not even be defining it).  */
d224 5
a228 5
      if (DEPRECATED_REGISTER_BYTE_P ())
	gdb_assert (descr->register_offset[i] == DEPRECATED_REGISTER_BYTE (i));
#if 0
      gdb_assert (descr->sizeof_register[i] == DEPRECATED_REGISTER_RAW_SIZE (i));
      gdb_assert (descr->sizeof_register[i] == DEPRECATED_REGISTER_VIRTUAL_SIZE (i));
a229 2
    }
  /* gdb_assert (descr->sizeof_raw_registers == DEPRECATED_REGISTER_BYTES (i));  */
d240 13
d268 1
a268 1
register_size (struct gdbarch *gdbarch, int regnum)
d271 1
a271 9
  int size;
  gdb_assert (regnum >= 0 && regnum < (NUM_REGS + NUM_PSEUDO_REGS));
  size = descr->sizeof_register[regnum];
  /* NB: The deprecated DEPRECATED_REGISTER_RAW_SIZE, if not provided, defaults
     to the size of the register's type.  */
  gdb_assert (size == DEPRECATED_REGISTER_RAW_SIZE (regnum)); /* OK */
  /* NB: Don't check the register's virtual size.  It, in say the case
     of the MIPS, may not match the raw size!  */
  return size;
d279 5
a283 12
  /* The register buffers.  A read-only register cache can hold the
     full [0 .. NUM_REGS + NUM_PSEUDO_REGS) while a read/write
     register cache can only hold [0 .. NUM_REGS).  */
  char *registers;
  char *register_valid_p;
  /* Is this a read-only cache?  A read-only cache is used for saving
     the target's register state (e.g, across an inferior function
     call or just before forcing a function return).  A read-only
     cache can only be updated via the methods regcache_dup() and
     regcache_cpy().  The actual contents are determined by the
     reggroup_save and reggroup_restore methods.  */
  int readonly_p;
d295 1
a295 1
  regcache->registers
d297 1
a297 1
  regcache->register_valid_p
d299 1
a299 1
  regcache->readonly_p = 1;
d308 2
a309 2
  xfree (regcache->registers);
  xfree (regcache->register_valid_p);
d313 1
a313 1
static void
a324 89
/* Return REGCACHE's architecture.  */

struct gdbarch *
get_regcache_arch (const struct regcache *regcache)
{
  return regcache->descr->gdbarch;
}

/* Return  a pointer to register REGNUM's buffer cache.  */

static char *
register_buffer (const struct regcache *regcache, int regnum)
{
  return regcache->registers + regcache->descr->register_offset[regnum];
}

void
regcache_save (struct regcache *dst, regcache_cooked_read_ftype *cooked_read,
	       void *src)
{
  struct gdbarch *gdbarch = dst->descr->gdbarch;
  char buf[MAX_REGISTER_SIZE];
  int regnum;
  /* The DST should be `read-only', if it wasn't then the save would
     end up trying to write the register values back out to the
     target.  */
  gdb_assert (dst->readonly_p);
  /* Clear the dest.  */
  memset (dst->registers, 0, dst->descr->sizeof_cooked_registers);
  memset (dst->register_valid_p, 0, dst->descr->sizeof_cooked_register_valid_p);
  /* Copy over any registers (identified by their membership in the
     save_reggroup) and mark them as valid.  The full [0 .. NUM_REGS +
     NUM_PSEUDO_REGS) range is checked since some architectures need
     to save/restore `cooked' registers that live in memory.  */
  for (regnum = 0; regnum < dst->descr->nr_cooked_registers; regnum++)
    {
      if (gdbarch_register_reggroup_p (gdbarch, regnum, save_reggroup))
	{
	  int valid = cooked_read (src, regnum, buf);
	  if (valid)
	    {
	      memcpy (register_buffer (dst, regnum), buf,
		      register_size (gdbarch, regnum));
	      dst->register_valid_p[regnum] = 1;
	    }
	}
    }
}

void
regcache_restore (struct regcache *dst,
		  regcache_cooked_read_ftype *cooked_read,
		  void *src)
{
  struct gdbarch *gdbarch = dst->descr->gdbarch;
  char buf[MAX_REGISTER_SIZE];
  int regnum;
  /* The dst had better not be read-only.  If it is, the `restore'
     doesn't make much sense.  */
  gdb_assert (!dst->readonly_p);
  /* Copy over any registers, being careful to only restore those that
     were both saved and need to be restored.  The full [0 .. NUM_REGS
     + NUM_PSEUDO_REGS) range is checked since some architectures need
     to save/restore `cooked' registers that live in memory.  */
  for (regnum = 0; regnum < dst->descr->nr_cooked_registers; regnum++)
    {
      if (gdbarch_register_reggroup_p (gdbarch, regnum, restore_reggroup))
	{
	  int valid = cooked_read (src, regnum, buf);
	  if (valid)
	    regcache_cooked_write (dst, regnum, buf);
	}
    }
}

static int
do_cooked_read (void *src, int regnum, void *buf)
{
  struct regcache *regcache = src;
  if (!regcache->register_valid_p[regnum] && regcache->readonly_p)
    /* Don't even think about fetching a register from a read-only
       cache when the register isn't yet valid.  There isn't a target
       from which the register value can be fetched.  */
    return 0;
  regcache_cooked_read (regcache, regnum, buf);
  return 1;
}


d333 27
a359 7
  gdb_assert (src->readonly_p || dst->readonly_p);
  if (!src->readonly_p)
    regcache_save (dst, do_cooked_read, src);
  else if (!dst->readonly_p)
    regcache_restore (dst, do_cooked_read, src);
  else
    regcache_cpy_no_passthrough (dst, src);
d372 3
a374 2
  memcpy (dst->registers, src->registers, dst->descr->sizeof_raw_registers);
  memcpy (dst->register_valid_p, src->register_valid_p,
d403 1
a403 1
  return regcache->register_valid_p[regnum];
d409 7
a415 1
  return regcache->registers;
d420 1
a420 1
   deprecated_register_valid[] currently point into this structure.  */
d430 1
a430 1
char *deprecated_registers;
d432 1
a432 1
/* DEPRECATED_REGISTER_VALID is 0 if the register needs to be fetched,
d443 1
a443 1
signed char *deprecated_register_valid;
d462 1
a462 1
  return deprecated_register_valid[regnum];
d473 19
a491 1
  current_regcache->register_valid_p[regnum] = state;
d534 1
a534 1
/* DEPRECATED_REGISTERS_FETCHED ()
d547 1
a547 1
deprecated_registers_fetched (void)
d557 10
a566 10
/* deprecated_read_register_bytes and deprecated_write_register_bytes
   are generally a *BAD* idea.  They are inefficient because they need
   to check for partial updates, which can only be done by scanning
   through all of the registers and seeing if the bytes that are being
   read/written fall inside of an invalid register.  [The main reason
   this is necessary is that register sizes can vary, so a simple
   index won't suffice.]  It is far better to call read_register_gen
   and write_register_gen if you want to get at the raw register
   contents, as it only takes a regnum as an argument, and therefore
   can't do a partial register update.
d569 4
a572 4
   and deprecated_write_register_bytes always checked to see if any
   registers were stale, and then called target_fetch_registers (-1)
   to update the whole set.  This caused really slowed things down for
   remote targets.  */
d579 1
a579 1
deprecated_read_register_bytes (int in_start, char *in_buf, int in_len)
d583 1
a583 1
  char reg_buf[MAX_REGISTER_SIZE];
d597 2
a598 2
      reg_start = DEPRECATED_REGISTER_BYTE (regnum);
      reg_len = DEPRECATED_REGISTER_RAW_SIZE (regnum);
d607 1
a607 1
	deprecated_read_register_gen (regnum, reg_buf);
d616 1
a616 1
	memcpy (reg_buf, &deprecated_registers[reg_start], reg_len);
d663 1
a663 1
	  DEPRECATED_REGISTER_RAW_SIZE (regnum));
d672 1
a672 1
      && !regcache->readonly_p)
d677 1
a677 1
	 via the global deprecated_register_valid[].  */
d685 1
a685 1
  if (!regcache->readonly_p)
d697 2
a698 1
  memcpy (buf, register_buffer (regcache, regnum),
d751 1
a751 1
deprecated_read_register_gen (int regnum, char *buf)
a769 6
  else if (regcache->readonly_p
	   && regnum < regcache->descr->nr_cooked_registers
	   && regcache->register_valid_p[regnum])
    /* Read-only register cache, perhaphs the cooked value was cached?  */
    memcpy (buf, register_buffer (regcache, regnum),
	    regcache->descr->sizeof_register[regnum]);
d781 1
a781 1
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_cooked_registers);
d794 1
a794 1
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_cooked_registers);
a800 24
void
regcache_cooked_write_signed (struct regcache *regcache, int regnum,
			      LONGEST val)
{
  void *buf;
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >=0 && regnum < regcache->descr->nr_cooked_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  store_signed_integer (buf, regcache->descr->sizeof_register[regnum], val);
  regcache_cooked_write (regcache, regnum, buf);
}

void
regcache_cooked_write_unsigned (struct regcache *regcache, int regnum,
				ULONGEST val)
{
  void *buf;
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >=0 && regnum < regcache->descr->nr_cooked_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  store_unsigned_integer (buf, regcache->descr->sizeof_register[regnum], val);
  regcache_cooked_write (regcache, regnum, buf);
}

d821 1
a821 1
  size = DEPRECATED_REGISTER_RAW_SIZE (regnum);
a845 1
  gdb_assert (!regcache->readonly_p);
d847 2
a848 1
  if (regcache->descr->legacy_p)
d852 1
a852 1
	 via the globals deprecated_register_valid[] and registers[].  */
d863 11
d892 1
a892 1
  regcache->register_valid_p[regnum] = 1;
d897 1
a897 1
deprecated_write_register_gen (int regnum, char *buf)
d925 1
a925 1
deprecated_write_register_bytes (int myregstart, char *myaddr, int inlen)
d941 2
a942 2
      regstart = DEPRECATED_REGISTER_BYTE (regnum);
      regend = regstart + DEPRECATED_REGISTER_RAW_SIZE (regnum);
d950 1
a950 1
	deprecated_write_register_gen (regnum, myaddr + (regstart - myregstart));
d955 1
a955 1
	  char regbuf[MAX_REGISTER_SIZE];
d963 1
a963 1
	  deprecated_read_register_gen (regnum, regbuf);
d965 1
a965 1
	  memcpy (&deprecated_registers[overlapstart],
d982 1
a982 1
static void
d988 1
a988 1
  bfd_byte reg[MAX_REGISTER_SIZE];
d1066 78
d1149 3
a1151 3
  char *buf = alloca (DEPRECATED_REGISTER_RAW_SIZE (regnum));
  deprecated_read_register_gen (regnum, buf);
  return (extract_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regnum)));
d1175 30
d1212 1
a1212 1
  size = DEPRECATED_REGISTER_RAW_SIZE (regnum);
d1215 1
a1215 1
  deprecated_write_register_gen (regnum, buf);
a1237 4
/* FIXME: kettenis/20030828: We should get rid of supply_register and
   regcache_collect in favour of regcache_raw_supply and
   regcache_raw_collect.  */

d1251 15
a1265 1
  regcache_raw_supply (current_regcache, regnum, val);
d1285 2
a1286 1
  regcache_raw_collect (current_regcache, regnum, buf);
a1288 1
/* Supply register REGNUM, whose contents are stored in BUF, to REGCACHE.  */
d1290 2
a1291 5
void
regcache_raw_supply (struct regcache *regcache, int regnum, const void *buf)
{
  void *regbuf;
  size_t size;
d1293 20
a1312 3
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  gdb_assert (!regcache->readonly_p);
d1314 5
a1318 4
  /* FIXME: kettenis/20030828: It shouldn't be necessary to handle
     CURRENT_REGCACHE specially here.  */
  if (regcache == current_regcache
      && !ptid_equal (registers_ptid, inferior_ptid))
d1320 2
a1321 2
      registers_changed ();
      registers_ptid = inferior_ptid;
d1323 4
a1326 11

  regbuf = register_buffer (regcache, regnum);
  size = regcache->descr->sizeof_register[regnum];

  if (buf)
    memcpy (regbuf, buf, size);
  else
    memset (regbuf, 0, size);

  /* Mark the register as cached.  */
  regcache->register_valid_p[regnum] = 1;
a1328 31
/* Collect register REGNUM from REGCACHE and store its contents in BUF.  */

void
regcache_raw_collect (const struct regcache *regcache, int regnum, void *buf)
{
  const void *regbuf;
  size_t size;

  gdb_assert (regcache != NULL && buf != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);

  regbuf = register_buffer (regcache, regnum);
  size = regcache->descr->sizeof_register[regnum];
  memcpy (buf, regbuf, size);
}


/* read_pc, write_pc, read_sp, deprecated_read_fp, etc.  Special
   handling for registers PC, SP, and FP.  */

/* NOTE: cagney/2001-02-18: The functions read_pc_pid(), read_pc(),
   read_sp(), and deprecated_read_fp(), will eventually be replaced by
   per-frame methods.  Instead of relying on the global INFERIOR_PTID,
   they will use the contextual information provided by the FRAME.
   These functions do not belong in the register cache.  */

/* NOTE: cagney/2003-06-07: The functions generic_target_write_pc(),
   write_pc_pid(), write_pc(), and deprecated_read_fp(), all need to
   be replaced by something that does not rely on global state.  But
   what?  */

d1339 1
a1339 11
  if (TARGET_READ_PC_P ())
    pc_val = TARGET_READ_PC (ptid);
  /* Else use per-frame method on get_current_frame.  */
  else if (PC_REGNUM >= 0)
    {
      CORE_ADDR raw_val = read_register_pid (PC_REGNUM, ptid);
      CORE_ADDR pc_val = ADDR_BITS_REMOVE (raw_val);
      return pc_val;
    }
  else
    internal_error (__FILE__, __LINE__, "read_pc_pid: Unable to find PC");
d1357 2
a1358 2
  if (DEPRECATED_NPC_REGNUM >= 0)
    write_register_pid (DEPRECATED_NPC_REGNUM, pc + 4, ptid);
d1388 11
d1401 15
a1415 9
  if (TARGET_READ_SP_P ())
    return TARGET_READ_SP ();
  else if (gdbarch_unwind_sp_p (current_gdbarch))
    return get_frame_sp (get_current_frame ());
  else if (SP_REGNUM >= 0)
    /* Try SP_REGNUM last: this makes all sorts of [wrong] assumptions
       about the architecture so put it at the end.  */
    return read_register (SP_REGNUM);
  internal_error (__FILE__, __LINE__, "read_sp: Unable to find SP");
d1419 7
a1425 1
deprecated_write_sp (CORE_ADDR val)
d1427 6
a1432 2
  gdb_assert (SP_REGNUM >= 0);
  write_register (SP_REGNUM, val);
d1436 1
a1436 1
deprecated_read_fp (void)
d1438 1
a1438 6
  if (DEPRECATED_TARGET_READ_FP_P ())
    return DEPRECATED_TARGET_READ_FP ();
  else if (DEPRECATED_FP_REGNUM >= 0)
    return read_register (DEPRECATED_FP_REGNUM);
  else
    internal_error (__FILE__, __LINE__, "deprecated_read_fp");
d1441 1
d1455 3
a1457 3
  current_regcache->readonly_p = 0;
  deprecated_registers = deprecated_grub_regcache_for_registers (current_regcache);
  deprecated_register_valid = current_regcache->register_valid_p;
d1482 1
a1482 1
  regcache_dump_none, regcache_dump_raw, regcache_dump_cooked, regcache_dump_groups
a1489 1
  struct gdbarch *gdbarch = regcache->descr->gdbarch;
d1496 1
a1496 1
  unsigned char buf[MAX_REGISTER_SIZE];
d1508 2
d1554 1
a1554 1
	      || register_offset != DEPRECATED_REGISTER_BYTE (regnum)
d1579 1
a1579 1
	       != DEPRECATED_REGISTER_RAW_SIZE (regnum))
d1581 1
a1581 1
		  != DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum))
d1596 21
a1616 26
      {
	const char *t;
	if (regnum < 0)
	  t = "Type";
	else
	  {
	    static const char blt[] = "builtin_type";
	    t = TYPE_NAME (register_type (regcache->descr->gdbarch, regnum));
	    if (t == NULL)
	      {
		char *n;
		if (!footnote_register_type_name_null)
		  footnote_register_type_name_null = ++footnote_nr;
		xasprintf (&n, "*%d", footnote_register_type_name_null);
		make_cleanup (xfree, n);
		t = n;
	      }
	    /* Chop a leading builtin_type.  */
	    if (strncmp (t, blt, strlen (blt)) == 0)
	      t += strlen (blt);
	  }
	fprintf_unfiltered (file, " %-15s", t);
      }

      /* Leading space always present.  */
      fprintf_unfiltered (file, " ");
d1632 1
a1632 1
				 DEPRECATED_REGISTER_RAW_SIZE (regnum));
d1646 1
a1646 23
				 DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
	    }
	}

      /* Group members.  */
      if (what_to_dump == regcache_dump_groups)
	{
	  if (regnum < 0)
	    fprintf_unfiltered (file, "Groups");
	  else
	    {
	      const char *sep = "";
	      struct reggroup *group;
	      for (group = reggroup_next (gdbarch, NULL);
		   group != NULL;
		   group = reggroup_next (gdbarch, group))
		{
		  if (gdbarch_register_reggroup_p (gdbarch, regnum, group))
		    {
		      fprintf_unfiltered (file, "%s%s", sep, reggroup_name (group));
		      sep = ",";
		    }
		}
a1698 8
static void
maintenance_print_register_groups (char *args, int from_tty)
{
  regcache_print (args, regcache_dump_groups);
}

extern initialize_file_ftype _initialize_regcache; /* -Wmissing-prototype */

d1702 2
a1703 1
  regcache_descr_handle = register_gdbarch_data (init_regcache_descr);
d1705 2
a1706 2
  register_gdbarch_swap (&deprecated_registers, sizeof (deprecated_registers), NULL);
  register_gdbarch_swap (&deprecated_register_valid, sizeof (deprecated_register_valid), NULL);
a1728 5
Takes an optional file parameter.",
	   &maintenanceprintlist);
  add_cmd ("register-groups", class_maintenance,
	   maintenance_print_register_groups,
	   "Print the internal register configuration including each register's group.\
@


1.58.6.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d1354 1
d1357 6
a1362 3
  else
    internal_error (__FILE__, __LINE__,
		    "generic_target_write_pc");
@


1.58.4.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a28 1
#include "reggroups.h"
a67 2
  long sizeof_cooked_registers;
  long sizeof_cooked_register_valid_p;
d95 1
a95 2
     in the register cache.  Unfortunatly some architectures still
     rely on this and the pseudo_register_write() method.  */
d97 1
a97 1
  descr->sizeof_raw_register_valid_p = descr->sizeof_cooked_register_valid_p;
d99 5
a103 7
  /* Compute the offset of each register.  Legacy architectures define
     REGISTER_BYTE() so use that.  */
  /* FIXME: cagney/2002-11-07: Instead of using REGISTER_BYTE() this
     code should, as is done in init_regcache_descr(), compute the
     offets at runtime.  This currently isn't possible as some ISAs
     define overlapping register regions - see the mess in
     read_register_bytes() and write_register_bytes() registers.  */
a108 5
      /* FIXME: cagney/2001-12-04: This code shouldn't need to use
         REGISTER_BYTE().  Unfortunatly, legacy code likes to lay the
         buffer out so that certain registers just happen to overlap.
         Ulgh!  New targets use gdbarch's register read/write and
         entirely avoid this uglyness.  */
d117 2
a118 7
  /* Compute the real size of the register buffer.  Start out by
     trusting REGISTER_BYTES, but then adjust it upwards should that
     be found to not be sufficient.  */
  /* FIXME: cagney/2002-11-05: Instead of using REGISTER_BYTES, this
     code should, as is done in init_regcache_descr(), compute the
     total number of register bytes using the accumulated offsets.  */
  descr->sizeof_cooked_registers = REGISTER_BYTES; /* OK use.  */
d127 5
d133 2
a134 2
      if (descr->sizeof_cooked_registers < regend)
	descr->sizeof_cooked_registers = regend;
a135 4
  /* FIXME: cagney/2002-05-11: Shouldn't be including pseudo-registers
     in the register cache.  Unfortunatly some architectures still
     rely on this and the pseudo_register_write() method.  */
  descr->sizeof_raw_registers = descr->sizeof_cooked_registers;
a152 1
  descr->sizeof_cooked_register_valid_p = NUM_REGS + NUM_PSEUDO_REGS;
d180 1
a180 1
  descr->sizeof_raw_register_valid_p = descr->sizeof_cooked_register_valid_p;
d182 4
a185 1
  /* Lay out the register cache.
d206 7
a212 1
    descr->sizeof_cooked_registers = offset;
a214 7
  /* FIXME: cagney/2002-05-22: Should only need to allocate space for
     the raw registers.  Unfortunatly some code still accesses the
     register array directly using the global registers[].  Until that
     code has been purged, play safe and over allocating the register
     buffer.  Ulgh!  */
  descr->sizeof_raw_registers = descr->sizeof_cooked_registers;

d279 5
a283 12
  /* The register buffers.  A read-only register cache can hold the
     full [0 .. NUM_REGS + NUM_PSEUDO_REGS) while a read/write
     register cache can only hold [0 .. NUM_REGS).  */
  char *registers;
  char *register_valid_p;
  /* Is this a read-only cache?  A read-only cache is used for saving
     the target's register state (e.g, across an inferior function
     call or just before forcing a function return).  A read-only
     cache can only be updated via the methods regcache_dup() and
     regcache_cpy().  The actual contents are determined by the
     reggroup_save and reggroup_restore methods.  */
  int readonly_p;
d295 1
a295 1
  regcache->registers
d297 1
a297 1
  regcache->register_valid_p
d299 1
a299 1
  regcache->readonly_p = 1;
d308 2
a309 2
  xfree (regcache->registers);
  xfree (regcache->register_valid_p);
a324 62
/* Return  a pointer to register REGNUM's buffer cache.  */

static char *
register_buffer (struct regcache *regcache, int regnum)
{
  return regcache->registers + regcache->descr->register_offset[regnum];
}

void
regcache_save (struct regcache *dst, struct regcache *src)
{
  struct gdbarch *gdbarch = dst->descr->gdbarch;
  int regnum;
  /* The SRC and DST register caches had better belong to the same
     architecture.  */
  gdb_assert (src->descr->gdbarch == dst->descr->gdbarch);
  /* The DST should be `read-only', if it wasn't then the save would
     end up trying to write the register values out through to the
     target.  */
  gdb_assert (!src->readonly_p);
  gdb_assert (dst->readonly_p);
  /* Clear the dest.  */
  memset (dst->registers, 0, dst->descr->sizeof_cooked_registers);
  memset (dst->register_valid_p, 0, dst->descr->sizeof_cooked_register_valid_p);
  /* Copy over any registers (identified by their membership in the
     save_reggroup) and mark them as valid.  The full [0
     .. NUM_REGS+NUM_PSEUDO_REGS) range is checked since some
     architectures need to save/restore `cooked' registers that live
     in memory.  */
  for (regnum = 0; regnum < dst->descr->nr_cooked_registers; regnum++)
    {
      if (gdbarch_register_reggroup_p (gdbarch, regnum, save_reggroup))
	{
	  regcache_cooked_read (src, regnum, register_buffer (dst, regnum));
	  dst->register_valid_p[regnum] = 1;
	}
    }
}

void
regcache_restore (struct regcache *dst, struct regcache *src)
{
  struct gdbarch *gdbarch = dst->descr->gdbarch;
  int regnum;
  gdb_assert (src->descr->gdbarch == dst->descr->gdbarch);
  gdb_assert (!dst->readonly_p);
  gdb_assert (src->readonly_p);
  /* Copy over any registers, being careful to only restore those that
     were both saved and need to be restored.  The full [0
     .. NUM_REGS+NUM_PSEUDO_REGS) range is checked since some
     architectures need to save/restore `cooked' registers that live
     in memory.  */
  for (regnum = 0; regnum < src->descr->nr_cooked_registers; regnum++)
    {
      if (gdbarch_register_reggroup_p (gdbarch, regnum, restore_reggroup)
	  && src->register_valid_p[regnum])
	{
	  regcache_cooked_write (dst, regnum, register_buffer (src, regnum));
	}
    }
}

d333 27
a359 7
  gdb_assert (src->readonly_p || dst->readonly_p);
  if (!src->readonly_p)
    regcache_save (dst, src);
  else if (!dst->readonly_p)
    regcache_restore (dst, src);
  else
    regcache_cpy_no_passthrough (dst, src);
d372 3
a374 2
  memcpy (dst->registers, src->registers, dst->descr->sizeof_raw_registers);
  memcpy (dst->register_valid_p, src->register_valid_p,
d403 1
a403 1
  return regcache->register_valid_p[regnum];
d409 1
a409 1
  return regcache->registers;
d415 1
a415 1
  return regcache->register_valid_p;
d420 1
a420 1
   deprecated_register_valid[] currently point into this structure.  */
d430 1
a430 1
char *deprecated_registers;
d432 1
a432 1
/* DEPRECATED_REGISTER_VALID is 0 if the register needs to be fetched,
d443 1
a443 1
signed char *deprecated_register_valid;
d462 1
a462 1
  return deprecated_register_valid[regnum];
d473 19
a491 1
  current_regcache->register_valid_p[regnum] = state;
d534 1
a534 1
/* DEPRECATED_REGISTERS_FETCHED ()
d547 1
a547 1
deprecated_registers_fetched (void)
d557 10
a566 10
/* deprecated_read_register_bytes and deprecated_write_register_bytes
   are generally a *BAD* idea.  They are inefficient because they need
   to check for partial updates, which can only be done by scanning
   through all of the registers and seeing if the bytes that are being
   read/written fall inside of an invalid register.  [The main reason
   this is necessary is that register sizes can vary, so a simple
   index won't suffice.]  It is far better to call read_register_gen
   and write_register_gen if you want to get at the raw register
   contents, as it only takes a regnum as an argument, and therefore
   can't do a partial register update.
d569 4
a572 4
   and deprecated_write_register_bytes always checked to see if any
   registers were stale, and then called target_fetch_registers (-1)
   to update the whole set.  This caused really slowed things down for
   remote targets.  */
d579 1
a579 1
deprecated_read_register_bytes (int in_start, char *in_buf, int in_len)
d607 1
a607 1
	deprecated_read_register_gen (regnum, reg_buf);
d616 1
a616 1
	memcpy (reg_buf, &deprecated_registers[reg_start], reg_len);
d672 1
a672 1
      && !regcache->readonly_p)
d677 1
a677 1
	 via the global deprecated_register_valid[].  */
d685 1
a685 1
  if (!regcache->readonly_p)
d697 2
a698 1
  memcpy (buf, register_buffer (regcache, regnum),
d751 1
a751 1
deprecated_read_register_gen (int regnum, char *buf)
a769 6
  else if (regcache->readonly_p
	   && regnum < regcache->descr->nr_cooked_registers
	   && regcache->register_valid_p[regnum])
    /* Read-only register cache, perhaphs the cooked value was cached?  */
    memcpy (buf, register_buffer (regcache, regnum),
	    regcache->descr->sizeof_register[regnum]);
a845 1
  gdb_assert (!regcache->readonly_p);
d847 2
a848 1
  if (regcache->descr->legacy_p)
d852 1
a852 1
	 via the globals deprecated_register_valid[] and registers[].  */
d863 11
d892 1
a892 1
  regcache->register_valid_p[regnum] = 1;
d897 1
a897 1
deprecated_write_register_gen (int regnum, char *buf)
d925 1
a925 1
deprecated_write_register_bytes (int myregstart, char *myaddr, int inlen)
d950 1
a950 1
	deprecated_write_register_gen (regnum, myaddr + (regstart - myregstart));
d963 1
a963 1
	  deprecated_read_register_gen (regnum, regbuf);
d965 1
a965 1
	  memcpy (&deprecated_registers[overlapstart],
d1066 78
d1150 1
a1150 1
  deprecated_read_register_gen (regnum, buf);
d1181 1
a1181 1
  deprecated_read_register_gen (regnum, buf);
d1215 1
a1215 1
  deprecated_write_register_gen (regnum, buf);
d1455 3
a1457 3
  current_regcache->readonly_p = 0;
  deprecated_registers = deprecated_grub_regcache_for_registers (current_regcache);
  deprecated_register_valid = deprecated_grub_regcache_for_register_valid (current_regcache);
d1482 1
a1482 1
  regcache_dump_none, regcache_dump_raw, regcache_dump_cooked, regcache_dump_groups
a1489 2
  struct gdbarch *gdbarch = regcache->descr->gdbarch;
  struct reggroup *const *groups = reggroups (gdbarch);
d1596 21
a1616 26
      {
	const char *t;
	if (regnum < 0)
	  t = "Type";
	else
	  {
	    static const char blt[] = "builtin_type";
	    t = TYPE_NAME (register_type (regcache->descr->gdbarch, regnum));
	    if (t == NULL)
	      {
		char *n;
		if (!footnote_register_type_name_null)
		  footnote_register_type_name_null = ++footnote_nr;
		xasprintf (&n, "*%d", footnote_register_type_name_null);
		make_cleanup (xfree, n);
		t = n;
	      }
	    /* Chop a leading builtin_type.  */
	    if (strncmp (t, blt, strlen (blt)) == 0)
	      t += strlen (blt);
	  }
	fprintf_unfiltered (file, " %-15s", t);
      }

      /* Leading space always present.  */
      fprintf_unfiltered (file, " ");
a1649 20
      /* Group members.  */
      if (what_to_dump == regcache_dump_groups)
	{
	  if (regnum < 0)
	    fprintf_unfiltered (file, "Groups");
	  else
	    {
	      int i;
	      const char *sep = "";
	      for (i = 0; groups[i] != NULL; i++)
		{
		  if (gdbarch_register_reggroup_p (gdbarch, regnum, groups[i]))
		    {
		      fprintf_unfiltered (file, "%s%s", sep, reggroup_name (groups[i]));
		      sep = ",";
		    }
		}
	    }
	}

a1698 6
static void
maintenance_print_register_groups (char *args, int from_tty)
{
  regcache_print (args, regcache_dump_groups);
}

d1705 2
a1706 2
  register_gdbarch_swap (&deprecated_registers, sizeof (deprecated_registers), NULL);
  register_gdbarch_swap (&deprecated_register_valid, sizeof (deprecated_register_valid), NULL);
a1728 5
Takes an optional file parameter.",
	   &maintenanceprintlist);
  add_cmd ("register-groups", class_maintenance,
	   maintenance_print_register_groups,
	   "Print the internal register configuration including each register's group.\
@


1.58.4.2
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d175 1
a175 7
      if (gdbarch_register_type_p (gdbarch))
	{
	  gdb_assert (!REGISTER_VIRTUAL_TYPE_P ()); /* OK */
	  descr->register_type[i] = gdbarch_register_type (gdbarch, i);
	}
      else
	descr->register_type[i] = REGISTER_VIRTUAL_TYPE (i); /* OK */
d181 1
a181 2
      && !gdbarch_pseudo_register_write_p (gdbarch)
      && !gdbarch_register_type_p (gdbarch))
a285 30
}

int
legacy_max_register_raw_size (void)
{
  if (DEPRECATED_MAX_REGISTER_RAW_SIZE_P ())
    return DEPRECATED_MAX_REGISTER_RAW_SIZE;
  else
    return max_register_size (current_gdbarch);
}

int
legacy_max_register_virtual_size (void)
{
  if (DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE_P ())
    return DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE;
  else
    return max_register_size (current_gdbarch);
}

int
register_size (struct gdbarch *gdbarch, int regnum)
{
  struct regcache_descr *descr = regcache_descr (gdbarch);
  int size;
  gdb_assert (regnum >= 0 && regnum < (NUM_REGS + NUM_PSEUDO_REGS));
  size = descr->sizeof_register[regnum];
  gdb_assert (size == REGISTER_RAW_SIZE (regnum)); /* OK */
  gdb_assert (size == REGISTER_RAW_SIZE (regnum)); /* OK */
  return size;
@


1.58.4.3
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d392 1
a392 2
regcache_save (struct regcache *dst, regcache_cooked_read_ftype *cooked_read,
	       void *src)
a394 1
  void *buf = alloca (max_register_size (gdbarch));
d396 3
d400 1
a400 1
     end up trying to write the register values back out to the
d402 1
d408 4
a411 3
     save_reggroup) and mark them as valid.  The full [0 .. NUM_REGS +
     NUM_PSEUDO_REGS) range is checked since some architectures need
     to save/restore `cooked' registers that live in memory.  */
d416 2
a417 7
	  int valid = cooked_read (src, regnum, buf);
	  if (valid)
	    {
	      memcpy (register_buffer (dst, regnum), buf,
		      register_size (gdbarch, regnum));
	      dst->register_valid_p[regnum] = 1;
	    }
d423 1
a423 3
regcache_restore (struct regcache *dst,
		  regcache_cooked_read_ftype *cooked_read,
		  void *src)
a425 1
  void *buf = alloca (max_register_size (gdbarch));
d427 1
a427 2
  /* The dst had better not be read-only.  If it is, the `restore'
     doesn't make much sense.  */
d429 1
d431 5
a435 4
     were both saved and need to be restored.  The full [0 .. NUM_REGS
     + NUM_PSEUDO_REGS) range is checked since some architectures need
     to save/restore `cooked' registers that live in memory.  */
  for (regnum = 0; regnum < dst->descr->nr_cooked_registers; regnum++)
d437 2
a438 1
      if (gdbarch_register_reggroup_p (gdbarch, regnum, restore_reggroup))
d440 1
a440 3
	  int valid = cooked_read (src, regnum, buf);
	  if (valid)
	    regcache_cooked_write (dst, regnum, buf);
a444 15
static int
do_cooked_read (void *src, int regnum, void *buf)
{
  struct regcache *regcache = src;
  if (!regcache_valid_p (regcache, regnum)
      && regcache->readonly_p)
    /* Don't even think about fetching a register from a read-only
       cache when the register isn't yet valid.  There isn't a target
       from which the register value can be fetched.  */
    return 0;
  regcache_cooked_read (regcache, regnum, buf);
  return 1;
}


d455 1
a455 1
    regcache_save (dst, do_cooked_read, src);
d457 1
a457 1
    regcache_restore (dst, do_cooked_read, src);
d867 1
a867 1
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_cooked_registers);
d880 1
a880 1
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_cooked_registers);
a886 24
void
regcache_cooked_write_signed (struct regcache *regcache, int regnum,
			      LONGEST val)
{
  void *buf;
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >=0 && regnum < regcache->descr->nr_cooked_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  store_signed_integer (buf, regcache->descr->sizeof_register[regnum], val);
  regcache_cooked_write (regcache, regnum, buf);
}

void
regcache_cooked_write_unsigned (struct regcache *regcache, int regnum,
				ULONGEST val)
{
  void *buf;
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >=0 && regnum < regcache->descr->nr_cooked_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  store_unsigned_integer (buf, regcache->descr->sizeof_register[regnum], val);
  regcache_cooked_write (regcache, regnum, buf);
}

d1287 2
a1288 2
/* read_pc, write_pc, read_sp, read_fp, etc.  Special handling for
   registers PC, SP, and FP.  */
d1293 4
a1296 4
   generic_target_write_sp(), generic_target_read_fp() and read_fp(),
   will eventually be moved out of the reg-cache into either
   frame.[hc] or to the multi-arch framework.  The are not part of the
   raw register cache.  */
d1413 6
@


1.58.4.4
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d1331 2
a1332 2
/* read_pc, write_pc, read_sp, deprecated_read_fp, etc.  Special
   handling for registers PC, SP, and FP.  */
d1337 4
a1340 4
   generic_target_write_sp(), and deprecated_read_fp(), will
   eventually be moved out of the reg-cache into either frame.[hc] or
   to the multi-arch framework.  The are not part of the raw register
   cache.  */
d1460 1
a1460 1
deprecated_read_fp (void)
d1462 12
a1473 6
  if (DEPRECATED_TARGET_READ_FP_P ())
    return DEPRECATED_TARGET_READ_FP ();
  else if (DEPRECATED_FP_REGNUM >= 0)
    return read_register (DEPRECATED_FP_REGNUM);
  else
    internal_error (__FILE__, __LINE__, "deprecated_read_fp");
@


1.58.4.5
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d81 3
d112 1
d122 4
a125 2
      gdb_assert (MAX_REGISTER_SIZE >= REGISTER_RAW_SIZE (i));
      gdb_assert (MAX_REGISTER_SIZE >= REGISTER_VIRTUAL_SIZE (i));
d129 6
a134 7
     trusting DEPRECATED_REGISTER_BYTES, but then adjust it upwards
     should that be found to not be sufficient.  */
  /* FIXME: cagney/2002-11-05: Instead of using the macro
     DEPRECATED_REGISTER_BYTES, this code should, as is done in
     init_regcache_descr(), compute the total number of register bytes
     using the accumulated offsets.  */
  descr->sizeof_cooked_registers = DEPRECATED_REGISTER_BYTES; /* OK */
a189 6
      /* NOTE: cagney/2003-05-02: Don't add a test for REGISTER_BYTE_P
	 to the above.  Doing that would cause all the existing
	 architectures to revert back to the legacy regcache
	 mechanisms, and that is not a good thing.  Instead just,
	 later, check that the register cache's layout is consistent
	 with REGISTER_BYTE.  */
d216 1
d222 2
a223 1
	gdb_assert (MAX_REGISTER_SIZE >= descr->sizeof_register[i]);
d236 7
a242 3
  /* Sanity check.  Confirm that there is agreement between the
     regcache and the target's redundant REGISTER_BYTE (new targets
     should not even be defining it).  */
a244 3
      if (REGISTER_BYTE_P ())
	gdb_assert (descr->register_offset[i] == REGISTER_BYTE (i));
#if 0
d247 3
a250 2
    }
  /* gdb_assert (descr->sizeof_raw_registers == DEPRECATED_REGISTER_BYTES (i));  */
d289 25
d396 1
a396 1
  char buf[MAX_REGISTER_SIZE];
d430 1
a430 1
  char buf[MAX_REGISTER_SIZE];
d531 6
d684 1
a684 1
  char reg_buf[MAX_REGISTER_SIZE];
d1074 1
a1074 1
	  char regbuf[MAX_REGISTER_SIZE];
d1107 1
a1107 1
  bfd_byte reg[MAX_REGISTER_SIZE];
d1216 30
d1486 1
a1486 1
  deprecated_register_valid = current_regcache->register_valid_p;
d1527 1
a1527 1
  unsigned char buf[MAX_REGISTER_SIZE];
d1539 2
@


1.58.4.6
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d85 1
a85 1
static void
d343 1
a343 1
static void
d426 2
a427 1
  if (!regcache->register_valid_p[regnum] && regcache->readonly_p)
d1067 1
a1067 1
static void
d1270 35
a1304 10
/* NOTE: cagney/2001-02-18: The functions read_pc_pid(), read_pc(),
   read_sp(), and deprecated_read_fp(), will eventually be replaced by
   per-frame methods.  Instead of relying on the global INFERIOR_PTID,
   they will use the contextual information provided by the FRAME.
   These functions do not belong in the register cache.  */

/* NOTE: cagney/2003-06-07: The functions generic_target_write_pc(),
   write_pc_pid(), write_pc(), and deprecated_read_fp(), all need to
   be replaced by something that does not rely on global state.  But
   what?  */
d1316 1
a1316 11
  if (TARGET_READ_PC_P ())
    pc_val = TARGET_READ_PC (ptid);
  /* Else use per-frame method on get_current_frame.  */
  else if (PC_REGNUM >= 0)
    {
      CORE_ADDR raw_val = read_register_pid (PC_REGNUM, ptid);
      CORE_ADDR pc_val = ADDR_BITS_REMOVE (raw_val);
      return pc_val;
    }
  else
    internal_error (__FILE__, __LINE__, "read_pc_pid: Unable to find PC");
d1365 11
d1378 1
a1378 9
  if (TARGET_READ_SP_P ())
    return TARGET_READ_SP ();
  else if (gdbarch_unwind_sp_p (current_gdbarch))
    return get_frame_sp (get_current_frame ());
  else if (SP_REGNUM >= 0)
    /* Try SP_REGNUM last: this makes all sorts of [wrong] assumptions
       about the architecture so put it at the end.  */
    return read_register (SP_REGNUM);
  internal_error (__FILE__, __LINE__, "read_sp: Unable to find SP");
d1382 1
a1382 1
deprecated_write_sp (CORE_ADDR val)
d1384 9
a1392 2
  gdb_assert (SP_REGNUM >= 0);
  write_register (SP_REGNUM, val);
a1693 2

extern initialize_file_ftype _initialize_regcache; /* -Wmissing-prototype */
@


1.58.4.7
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d54 4
a57 5
  /* The raw register cache.  Each raw (or hard) register is supplied
     by the target interface.  The raw cache should not contain
     redundant information - if the PC is constructed from two
     registers then those regigisters and not the PC lives in the raw
     cache.  */
d94 6
d107 2
a108 4
  descr->sizeof_register
    = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, long);
  descr->register_offset
    = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, long);
d156 1
a156 1
  descr = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct regcache_descr);
d166 2
a167 2
  descr->register_type
    = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, struct type *);
d179 17
a205 18
  /* If an old style architecture, fill in the remainder of the
     register cache descriptor using the register macros.  */
  /* NOTE: cagney/2003-06-29: If either of REGISTER_BYTE or
     REGISTER_RAW_SIZE are still present, things are most likely
     totally screwed.  Ex: an architecture with raw register sizes
     smaller than what REGISTER_BYTE indicates; non monotonic
     REGISTER_BYTE values.  For GDB 6 check for these nasty methods
     and fall back to legacy code when present.  Sigh!  */
  if ((!gdbarch_pseudo_register_read_p (gdbarch)
       && !gdbarch_pseudo_register_write_p (gdbarch)
       && !gdbarch_register_type_p (gdbarch))
      || REGISTER_BYTE_P () || REGISTER_RAW_SIZE_P ())
    {
      descr->legacy_p = 1;
      init_legacy_regcache_descr (gdbarch, descr);
      return descr;
    }

d215 2
a216 4
    descr->sizeof_register
      = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, long);
    descr->register_offset
      = GDBARCH_OBSTACK_CALLOC (gdbarch, descr->nr_cooked_registers, long);
d258 13
a291 2
  /* NB: The deprecated REGISTER_RAW_SIZE, if not provided, defaults
     to the size of the register's type.  */
d293 1
a293 2
  /* NB: Don't check the register's virtual size.  It, in say the case
     of the MIPS, may not match the raw size!  */
d1430 1
d1601 1
d1603 1
a1603 4
	      struct reggroup *group;
	      for (group = reggroup_next (gdbarch, NULL);
		   group != NULL;
		   group = reggroup_next (gdbarch, group))
d1605 1
a1605 1
		  if (gdbarch_register_reggroup_p (gdbarch, regnum, group))
d1607 1
a1607 1
		      fprintf_unfiltered (file, "%s%s", sep, reggroup_name (group));
d1674 2
a1675 1
  regcache_descr_handle = register_gdbarch_data (init_regcache_descr);
@


1.58.4.8
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d96 6
a101 7
     DEPRECATED_REGISTER_BYTE() so use that.  */
  /* FIXME: cagney/2002-11-07: Instead of using
     DEPRECATED_REGISTER_BYTE() this code should, as is done in
     init_regcache_descr(), compute the offets at runtime.  This
     currently isn't possible as some ISAs define overlapping register
     regions - see the mess in read_register_bytes() and
     write_register_bytes() registers.  */
d109 5
a113 5
         DEPRECATED_REGISTER_BYTE().  Unfortunatly, legacy code likes
         to lay the buffer out so that certain registers just happen
         to overlap.  Ulgh!  New targets use gdbarch's register
         read/write and entirely avoid this uglyness.  */
      descr->register_offset[i] = DEPRECATED_REGISTER_BYTE (i);
d133 2
a134 2
         buffer separated by holes.  Once DEPRECATED_REGISTER_BYTE()
         is killed this can be greatly simplified.  */
d188 1
a188 1
  /* NOTE: cagney/2003-06-29: If either of DEPRECATED_REGISTER_BYTE or
d191 3
a193 4
     smaller than what DEPRECATED_REGISTER_BYTE indicates; non
     monotonic DEPRECATED_REGISTER_BYTE values.  For GDB 6 check for
     these nasty methods and fall back to legacy code when present.
     Sigh!  */
d197 1
a197 1
      || DEPRECATED_REGISTER_BYTE_P () || REGISTER_RAW_SIZE_P ())
d236 2
a237 2
     regcache and the target's redundant DEPRECATED_REGISTER_BYTE (new
     targets should not even be defining it).  */
d240 2
a241 2
      if (DEPRECATED_REGISTER_BYTE_P ())
	gdb_assert (descr->register_offset[i] == DEPRECATED_REGISTER_BYTE (i));
d348 1
a348 1
register_buffer (const struct regcache *regcache, int regnum)
d653 1
a653 1
      reg_start = DEPRECATED_REGISTER_BYTE (regnum);
d1015 1
a1015 1
      regstart = DEPRECATED_REGISTER_BYTE (regnum);
a1203 4
/* FIXME: kettenis/20030828: We should get rid of supply_register and
   regcache_collect in favour of regcache_raw_supply and
   regcache_raw_collect.  */

d1217 15
a1231 1
  regcache_raw_supply (current_regcache, regnum, val);
d1251 2
a1252 50
  regcache_raw_collect (current_regcache, regnum, buf);
}

/* Supply register REGNUM, whose contents are stored in BUF, to REGCACHE.  */

void
regcache_raw_supply (struct regcache *regcache, int regnum, const void *buf)
{
  void *regbuf;
  size_t size;

  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  gdb_assert (!regcache->readonly_p);

  /* FIXME: kettenis/20030828: It shouldn't be necessary to handle
     CURRENT_REGCACHE specially here.  */
  if (regcache == current_regcache
      && !ptid_equal (registers_ptid, inferior_ptid))
    {
      registers_changed ();
      registers_ptid = inferior_ptid;
    }

  regbuf = register_buffer (regcache, regnum);
  size = regcache->descr->sizeof_register[regnum];

  if (buf)
    memcpy (regbuf, buf, size);
  else
    memset (regbuf, 0, size);

  /* Mark the register as cached.  */
  regcache->register_valid_p[regnum] = 1;
}

/* Collect register REGNUM from REGCACHE and store its contents in BUF.  */

void
regcache_raw_collect (const struct regcache *regcache, int regnum, void *buf)
{
  const void *regbuf;
  size_t size;

  gdb_assert (regcache != NULL && buf != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);

  regbuf = register_buffer (regcache, regnum);
  size = regcache->descr->sizeof_register[regnum];
  memcpy (buf, regbuf, size);
d1308 2
a1309 2
  if (DEPRECATED_NPC_REGNUM >= 0)
    write_register_pid (DEPRECATED_NPC_REGNUM, pc + 4, ptid);
d1482 1
a1482 1
	      || register_offset != DEPRECATED_REGISTER_BYTE (regnum)
@


1.58.4.9
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d110 1
a110 1
         DEPRECATED_REGISTER_BYTE().  Unfortunately, legacy code likes
d115 3
a117 3
      descr->sizeof_register[i] = DEPRECATED_REGISTER_RAW_SIZE (i);
      gdb_assert (MAX_REGISTER_SIZE >= DEPRECATED_REGISTER_RAW_SIZE (i));
      gdb_assert (MAX_REGISTER_SIZE >= DEPRECATED_REGISTER_VIRTUAL_SIZE (i));
d141 1
a141 1
     in the register cache.  Unfortunately some architectures still
d170 1
a170 1
	  gdb_assert (!DEPRECATED_REGISTER_VIRTUAL_TYPE_P ()); /* OK */
d174 1
a174 1
	descr->register_type[i] = DEPRECATED_REGISTER_VIRTUAL_TYPE (i); /* OK */
d190 1
a190 1
     DEPRECATED_REGISTER_RAW_SIZE are still present, things are most likely
d199 1
a199 2
      || DEPRECATED_REGISTER_BYTE_P ()
      || DEPRECATED_REGISTER_RAW_SIZE_P ())
d231 1
a231 1
     the raw registers.  Unfortunately some code still accesses the
d245 2
a246 2
      gdb_assert (descr->sizeof_register[i] == DEPRECATED_REGISTER_RAW_SIZE (i));
      gdb_assert (descr->sizeof_register[i] == DEPRECATED_REGISTER_VIRTUAL_SIZE (i));
d281 1
a281 1
  /* NB: The deprecated DEPRECATED_REGISTER_RAW_SIZE, if not provided, defaults
d283 1
a283 1
  gdb_assert (size == DEPRECATED_REGISTER_RAW_SIZE (regnum)); /* OK */
a346 8
/* Return REGCACHE's architecture.  */

struct gdbarch *
get_regcache_arch (const struct regcache *regcache)
{
  return regcache->descr->gdbarch;
}

d656 1
a656 1
      reg_len = DEPRECATED_REGISTER_RAW_SIZE (regnum);
d721 1
a721 1
	  DEPRECATED_REGISTER_RAW_SIZE (regnum));
d908 1
a908 1
  size = DEPRECATED_REGISTER_RAW_SIZE (regnum);
d1018 1
a1018 1
      regend = regstart + DEPRECATED_REGISTER_RAW_SIZE (regnum);
d1147 1
a1147 1
  char *buf = alloca (DEPRECATED_REGISTER_RAW_SIZE (regnum));
d1149 1
a1149 1
  return (extract_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regnum)));
d1180 1
a1180 1
  size = DEPRECATED_REGISTER_RAW_SIZE (regnum);
d1410 1
d1547 1
a1547 1
	       != DEPRECATED_REGISTER_RAW_SIZE (regnum))
d1549 1
a1549 1
		  != DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum))
d1605 1
a1605 1
				 DEPRECATED_REGISTER_RAW_SIZE (regnum));
d1619 1
a1619 1
				 DEPRECATED_REGISTER_VIRTUAL_SIZE (regnum));
@


1.58.4.10
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d1354 1
d1357 6
a1362 3
  else
    internal_error (__FILE__, __LINE__,
		    "generic_target_write_pc");
@


1.57
log
@2002-08-25  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (register_offset_hack): Declare.
	(regcache_cooked_read_using_offset_hack): Declare.
	(regcache_cooked_write_using_offset_hack): Declare.

	* regcache.c (register_offset_hack): New function.
	(regcache_cooked_read_using_offset_hack): New function.
	(regcache_cooked_write_using_offset_hack): New function.
	(regcache_dump): Check that the registers, according to their
	offset, are packed hard against each other.
	(cooked_xfer_using_offset_hack): New function.
@
text
@d728 23
@


1.57.2.1
log
@Support for partial save/restore of the registers.
@
text
@d53 1
a53 1
  /* The raw register space.  This should contain just [0
d58 2
a68 5
  /* The cache proper.  A read-only cache can contain cooked values.
     A read/write cache can not.  */
  long sizeof_registers;
  long sizeof_register_valid_p;

d97 1
d118 1
a118 1
  descr->sizeof_registers = REGISTER_BYTES; /* OK use.  */
d133 2
a134 2
      if (descr->sizeof_registers < regend)
	descr->sizeof_registers = regend;
a153 8
  /* NOTE: cagney/2002-08-25: Include space for both raw and cooked
     registers in the register_valid_p table.  A read-only regcache
     can cache pre-computed cooked values (so needs the space).  A
     read/write shouldn't need the extra space, unfortunatly existing
     code is able to access elements of the global register_valid_p[]
     array in the range [NUM_REGS .. NUM_REGS + NUM_PSEUDO_REGS).  */
  descr->sizeof_register_valid_p = NUM_REGS + NUM_PSEUDO_REGS;

d176 6
d211 1
a211 1
    descr->sizeof_registers = offset;
d228 1
a228 1
  /* gdb_assert (descr->sizeof_cache == REGISTER_BYTES (i));  */
d279 5
a283 5
  char *registers;
  char *register_valid_p;
  /* A read-only regcache, can cache cooked values.  It is
     created/updated using the dup/cpy functions.  */
  int readonly_p;
d295 5
a299 3
  regcache->registers = XCALLOC (descr->sizeof_registers, char);
  regcache->register_valid_p = XCALLOC (descr->sizeof_register_valid_p, char);
  regcache->readonly_p = 1;
d308 2
a309 2
  xfree (regcache->registers);
  xfree (regcache->register_valid_p);
a324 42
static void
regcache_save (struct regcache *dst, struct regcache *src)
{
  struct gdbarch *gdbarch = dst->descr->gdbarch;
  int regnum;
  void *buf = alloca (dst->descr->max_register_size);
  gdb_assert (src->descr->gdbarch == dst->descr->gdbarch);
  gdb_assert (dst->readonly_p);
  /* Clear the dest.  */
  memset (dst->registers, 0, dst->descr->sizeof_registers);
  memset (dst->register_valid_p, 0, dst->descr->sizeof_register_valid_p);
  /* Copy over any relevant registers.  */
  for (regnum = gdbarch_next_cooked_register_to_save (gdbarch, -1);
       regnum >= 0;
       regnum = gdbarch_next_cooked_register_to_save (gdbarch, regnum))
    {
      regcache_cooked_read (src, regnum, buf);
      memcpy (dst->registers + dst->descr->register_offset[regnum],
	      buf, dst->descr->sizeof_register[regnum]);
      dst->register_valid_p[regnum] = 1;
    }
}

static void
regcache_restore (struct regcache *dst, struct regcache *src)
{
  struct gdbarch *gdbarch = dst->descr->gdbarch;
  int regnum;
  void *buf = alloca (dst->descr->max_register_size);
  gdb_assert (src->descr->gdbarch == dst->descr->gdbarch);
  gdb_assert (!dst->readonly_p);
  /* Copy over any relevant registers.  */
  for (regnum = gdbarch_next_cooked_register_to_restore (gdbarch, -1);
       regnum >= 0;
       regnum = gdbarch_next_cooked_register_to_restore (gdbarch, regnum))
    {
      memcpy (buf, src->registers + src->descr->register_offset[regnum],
	      src->descr->sizeof_register[regnum]);
      regcache_cooked_write (dst, regnum, buf);
    }
}

d333 27
a359 7
  gdb_assert (src->readonly_p || dst->readonly_p);
  if (!src->readonly_p)
    regcache_save (dst, src);
  else if (!dst->readonly_p)
    regcache_restore (dst, src);
  else
    regcache_cpy_no_passthrough (dst, src);
d372 4
a375 3
  memcpy (dst->registers, src->registers, dst->descr->sizeof_registers);
  memcpy (dst->register_valid_p, src->register_valid_p,
	  dst->descr->sizeof_register_valid_p);
d403 1
a403 1
  return regcache->register_valid_p[regnum];
d409 1
a409 1
  return regcache->registers;
d415 1
a415 1
  return regcache->register_valid_p;
d473 1
a473 1
  current_regcache->register_valid_p[regnum] = state;
d491 1
a491 1
  return regcache->registers + regcache->descr->register_offset[regnum];
d672 1
a672 1
      && !regcache->readonly_p)
d685 1
a685 1
  if (!regcache->readonly_p)
d697 1
a697 1
  memcpy (buf, (regcache->registers
a746 4
  else if (regcache->readonly_p && regcache->register_valid_p[regnum])
    memcpy (buf, (regcache->registers
		  + regcache->descr->register_offset[regnum]),
	    regcache->descr->sizeof_register[regnum]);
a822 1
  gdb_assert (!regcache->readonly_p);
d824 2
a825 1
  if (regcache->descr->legacy_p)
d840 11
d869 1
a869 1
  regcache->register_valid_p[regnum] = 1;
a890 1
  gdb_assert (!regcache->readonly_p);
d1432 1
a1432 1
  current_regcache->readonly_p = 0;
@


1.57.2.2
log
@2002-08-26  Andrew Cagney  <ac131313@@redhat.com>

	* i386-tdep.c: Include "reggroups.h".
	(i386_register_reggroup_p): New function.
	(i386_add_reggroups, i386_init_reggroups): New function.
	(i386_gdbarch_init): Call i386_add_reggroups.  Set
	register_reggroup_p.
	(_initialize_i386_tdep): Call i386_init_reggroups.

	* infcmd.c: Include <ctype.h>.
	(registers_info): Rewrite.  Handle reggroups.
	(default_print_registers_info): Use gdbarch_register_reggroup_p.
	(print_float_info): Use gdbarch_register_reggroup_p.

	* regcache.c: Include "reggroups.h".
	(regcache_dump): Include the register groups in the ``maint print
	registers'' command.

	* infcmd.c: Include "regroup.h".
	(default_print_registers_info): Use gdbarch_register_reggroup_p.
	(print_float_info): Ditto.

	* gdbarch.sh: Include "reggroups.h".
	(register_reggroup_p): New method.
	(struct reggroup): Add opaque declaration.
	* gdbarch.h, gdbarch.c: Regenerate.

	* Makefile.in (SFILES): Add reggroups.c.
	(reggroups_h): Define.
	(COMMON_OBS): Add reggroups.o.
	(reggroups.o): Specify dependencies.
	(gdbarch.o, infcmd.o, i386-tdep.o): Update dependencies.

	* reggroups.c: New file.
	* reggroups.h: New file.
@
text
@a31 1
#include "reggroups.h"
a1640 24
	    }
	}

      /* The registers groups.  */
      if (what_to_dump == regcache_dump_none)
	{
	  if (regnum < 0)
	    fprintf_unfiltered (file, "Groups");
	  else
	    {
	      struct reggroup *const *group;
	      const char *prefix = "";
	      for (group = reggroups (regcache->descr->gdbarch);
		   *group != NULL;
		   group++)
		{
		  if (gdbarch_register_reggroup_p (regcache->descr->gdbarch,
						   regnum, *group))
		    {
		      fprintf_unfiltered (file, "%s%s", prefix,
					  reggroup_name (*group));
		      prefix = ",";
		    }
		}
@


1.57.2.3
log
@2002-09-13  Andrew Cagney  <cagney@@redhat.com>

	* i386-tdep.c (i386_add_reggroups): Add save_reggroup and
	restore_reggroup.
	(i386_register_reggroup_p): Rewrite.  Use
	default_register_reggroup_p.

	* reggroups.h (save_reggroup, restore_reggroup): Declare.
	* reggroups.c (save_reggroup, restore_reggroup): Define.
	(_initialize_reggroup): Add save_reggroup and restore_reggroup to
	default_groups.
	* regcache.c (regcache_restore): Restore the registers in
	restore_reggroup.
	(regcache_save): Save registers in save_reggroup.
@
text
@d340 3
a342 1
  for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
d344 4
a347 7
      if (gdbarch_register_reggroup_p (gdbarch, regnum, save_reggroup))
	{
	  regcache_cooked_read (src, regnum, buf);
	  memcpy (dst->registers + dst->descr->register_offset[regnum],
		  buf, dst->descr->sizeof_register[regnum]);
	  dst->register_valid_p[regnum] = 1;
	}
d360 3
a362 1
  for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
d364 3
a366 6
      if (gdbarch_register_reggroup_p (gdbarch, regnum, restore_reggroup))
	{
	  memcpy (buf, src->registers + src->descr->register_offset[regnum],
		  src->descr->sizeof_register[regnum]);
	  regcache_cooked_write (dst, regnum, buf);
	}
@


1.56
log
@2002-08-25  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.c (struct regcache_descr): Add field register_type.
	(init_legacy_regcache_descr): Pass a pre-allocated regcache_descr
	in as a parameter
	(init_regcache_descr): Initialize register_type.  Pass the descr
	to init_legacy_regcache_descr.  Use register_type instead of
	REGISTER_VIRTUAL_TYPE.
	(register_type): New function.
	(regcache_dump): Replace REGISTER_VIRTUAL_TYPE with register_type.
	* regcache.h (register_type): Declare.
@
text
@d1032 89
d1531 6
a1536 1
	      || register_offset != REGISTER_BYTE (regnum))
@


1.55
log
@2002-08-25  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.c (max_register_size): New function.
	(init_legacy_regcache_descr): Ensure that max_register_size is
	large enough for REGISTER_VIRTUAL_SIZE.
	* regcache.h (max_register_size): Declare.
@
text
@d80 3
d85 3
a87 2
static void *
init_legacy_regcache_descr (struct gdbarch *gdbarch)
a89 1
  struct regcache_descr *descr;
a93 4
  descr = XMALLOC (struct regcache_descr);
  descr->gdbarch = gdbarch;
  descr->legacy_p = 1;

a95 1
  descr->nr_cooked_registers = NUM_REGS + NUM_PSEUDO_REGS;
a135 1
  return descr;
d145 2
a146 7
  /* If an old style architecture, construct the register cache
     description using all the register macros.  */
  if (!gdbarch_pseudo_register_read_p (gdbarch)
      && !gdbarch_pseudo_register_write_p (gdbarch))
    return init_legacy_regcache_descr (gdbarch);

  descr = XMALLOC (struct regcache_descr);
a147 1
  descr->legacy_p = 0;
d154 18
d187 4
a190 4
     NOTE: cagney/2002-05-22: Only REGISTER_VIRTUAL_TYPE() needs to be
     used when constructing the register cache.  It is assumed that
     register raw size, virtual size and type length of the type are
     all the same.  */
d199 1
a199 1
	descr->sizeof_register[i] = TYPE_LENGTH (REGISTER_VIRTUAL_TYPE (i));
d256 11
d1466 2
a1467 1
		  != TYPE_LENGTH (REGISTER_VIRTUAL_TYPE (regnum)))
d1484 2
a1485 1
	  const char *t = TYPE_NAME (REGISTER_VIRTUAL_TYPE (regnum));
@


1.54
log
@2002-08-18  Andrew Cagney  <ac131313@@redhat.com>

* regcache.c (regcache_xfer_part): New function.
(regcache_raw_read_part): New function.
(regcache_raw_write_part): New function.
(regcache_cooked_read_part): New function.
(regcache_cooked_write_part): New function.
* regcache.h (regcache_raw_read_part): Declare.
(regcache_raw_write_part): Declare.
(regcache_cooked_read_part): Declare.
(regcache_cooked_write_part): Declare.
@
text
@d115 2
d242 10
@


1.53
log
@2002-08-13  Andrew Cagney  <cagney@@redhat.com>

* regcache.c (init_regcache_descr): Overallocate the
raw_register_valid_p array including space for NUM_PSEUDO_REGS.
(registers_changed): Replace NUM_REGS+NUM_PSEUDO_REGS with
num_raw_registers.
(set_register_cached): Add range checking assertions.  Use
current_regcache.
@
text
@d919 80
@


1.52
log
@2002-08-13  Andrew Cagney  <cagney@@redhat.com>

* i386-tdep.c (i386_register_name): Handle mmx registers.
(mmx_regnum_p): New function.
(i386_mmx_names): New array.
(mmx_num_regs): New variable.
(i386_pseudo_register_read): New function.
(i386_pseudo_register_write): New function.
(mmx_regnum_to_fp_regnum): New function. Code from Fernando Nasser.

* regcache.c (regcache_raw_read_unsigned): New function.
(regcache_raw_read_signed): New function.
* regcache.h (regcache_raw_read_unsigned): Declare.
(regcache_raw_read_signed): Declare.
@
text
@d164 6
a169 1
  descr->sizeof_raw_register_valid_p = NUM_REGS;
d439 3
a441 1
  register_valid[regnum] = state;
d495 1
a495 1
  for (i = 0; i < NUM_REGS + NUM_PSEUDO_REGS; i++)
@


1.51
log
@2002-08-12  Andrew Cagney  <cagney@@redhat.com>
* regcache.c (regcache_raw_read_as_address): Delete function.
(regcache_cooked_read_signed): New function.
(regcache_cooked_read_unsigned): New function.
* regcache.h (regcache_cooked_read_signed): Declare.
(regcache_cooked_read_unsigned): Declare.
(regcache_raw_read_as_address): Delete declaration.
* blockframe.c (generic_read_register_dummy): Use
regcache_cooked_read_unsigned.
* i386-tdep.c (i386_extract_struct_value_address): Use
regcache_cooked_read_unsigned.
@
text
@d664 25
@


1.50
log
@2002-08-09  Andrew Cagney  <cagney@@redhat.com>

* regcache.c (regcache_dump): Compare the register offset
with REGISTER_BYTE.
* arch-utils.c (generic_register_byte): New function.
* arch-utils.h (generic_register_byte): Declare.
* gdbarch.sh (REGISTER_BYTE): Default to generic_register_byte.
* gdbarch.h, gdbarch.c: Regenerate.
@
text
@a368 11
CORE_ADDR
regcache_raw_read_as_address (struct regcache *regcache, int regnum)
{
  char *buf;
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  regcache_raw_read (regcache, regnum, buf);
  return extract_address (buf, regcache->descr->sizeof_register[regnum]);
}

d686 26
@


1.49
log
@2002-08-09  Andrew Cagney  <cagney@@redhat.com>

* regcache.c: Include "gdbcmd.h"
(_initialize_regcache): Add commands "maintenance print
registers", "maintenance print raw-registers" and "maintenance
print cooked-registers".
(enum regcache_dump_what): Define.
(dump_endian_bytes): New function.
(regcache_dump): New function.
(regcache_print): New function.
(maintenance_print_registers): New function.
(maintenance_print_raw_registers): New function.
(maintenance_print_cooked_registers): New function.
* Makefile.in (regcache.o): Update dependencies.
@
text
@d1282 2
a1283 1
	  if (register_offset != regcache->descr->register_offset[regnum])
@


1.48
log
@2002-08-07  Andrew Cagney  <ac131313@@redhat.com>

* regcache.c (pseudo_register): Delete function.
(fetch_register): Delete function.
(store_register): Delete function.
(regcache_raw_read, legacy_read_register_gen): Use
target_fetch_registers instead of fetch_register.
(legacy_write_register_gen, regcache_raw_write): Use
target_store_register instead of store_register.
(write_register_bytes): Ditto.

* gdbarch.sh (FETCH_PSEUDO_REGISTER): Delete.
(STORE_PSEUDO_REGISTER): Delete.
* gdbarch.h, gdbarch.c: Regenerate.
@
text
@d31 1
d1189 231
d1436 17
@


1.47
log
@Fri Aug  2 15:53:50 2002  Andrew Cagney  <cagney@@redhat.com>

* gdbarch.sh: Include "gdb_string.h".
* gdbarch.c: Regenerate.

* regcache.c: Include "gdb_string.h".
* ax-general.c: Ditto.
* varobj.c: Ditto.
* std-regs.c: Ditto.
* fbsd-proc.c: Ditto.
* thread.c: Ditto.

* Makefile.in (regcache.o): Update dependencies.
(thread.o, gdbarch.o): Ditto.
(ax-general.o, gdbarch.o): Ditto.
(varobj.o, std-regs.o): Ditto.
(fbsd-proc.o): Specify dependencies.
@
text
@a472 40
/* Return whether register REGNUM is a pseudo register.  */

static int
pseudo_register (int regnum)
{
  return regnum >= NUM_REGS && regnum < NUM_REGS + NUM_PSEUDO_REGS;
}

/* Fetch register REGNUM into the cache.  */

static void
fetch_register (int regnum)
{
  /* NOTE: cagney/2001-12-04: Legacy targets were using fetch/store
     pseudo-register as a way of handling registers that needed to be
     constructed from one or more raw registers.  New targets instead
     use gdbarch register read/write.  */
  if (FETCH_PSEUDO_REGISTER_P ()
      && pseudo_register (regnum))
    FETCH_PSEUDO_REGISTER (regnum);
  else
    target_fetch_registers (regnum);
}

/* Write register REGNUM cached value to the target.  */

static void
store_register (int regnum)
{
  /* NOTE: cagney/2001-12-04: Legacy targets were using fetch/store
     pseudo-register as a way of handling registers that needed to be
     constructed from one or more raw registers.  New targets instead
     use gdbarch register read/write.  */
  if (STORE_PSEUDO_REGISTER_P ()
      && pseudo_register (regnum))
    STORE_PSEUDO_REGISTER (regnum);
  else
    target_store_registers (regnum);
}

d631 1
a631 1
    fetch_register (regnum);
d665 1
a665 1
	fetch_register (regnum);
d735 1
a735 1
  store_register (regnum);
d790 1
a790 1
  store_register (regnum);
d866 1
a866 1
	  store_register (regnum);
@


1.46
log
@2002-08-02  Andrew Cagney  <cagney@@redhat.com>
* regcache.c (regcache_cooked_read): Rename rawnum parameter to
regnum.
(regcache_cooked_write): Ditto.
@
text
@d30 1
@


1.45
log
@Add the cooked register interface.
@
text
@d726 1
a726 1
regcache_cooked_read (struct regcache *regcache, int rawnum, void *buf)
d846 1
a846 2
regcache_cooked_write (struct regcache *regcache, int rawnum,
		       const void *buf)
@


1.44
log
@2002-08-02  Andrew Cagney  <cagney@@redhat.com>
* gdbarch.sh (pseudo_register_read, pseudo_register_write):
Replace the architecture methods register_read and register_write.
* gdbarch.h, gdbarch.c: Regenerate.
* regcache.c (init_regcache_descr): Update.
(read_register_gen): Update.
(write_register_gen): Update.
(supply_register): Update comment.
* sh-tdep.c (sh_gdbarch_init): Update.
(sh_pseudo_register_read, sh64_pseudo_register_read): Add
`regcache' and `gdbarch' parameters.  Make `buffer' a void
pointer.  Update code.
(sh_pseudo_register_write, sh64_pseudo_register_write): Add
`regcache' and `gdbarch' parameters.  Make `buffer' a constant
void pointer.  Update code.
(sh64_register_write): Delete.
(sh4_register_read): Delete.
(sh64_register_read): Delete.
(sh4_register_write): Delete.
(sh_sh4_register_convert_to_raw): Make `from' parameter a constant
void pointer, `to' parameter a void pointer.
(sh_sh64_register_convert_to_raw): Ditto.
@
text
@d722 6
d729 3
a731 3
  gdb_assert (regnum < current_regcache->descr->nr_cooked_registers);
  if (regnum < current_regcache->descr->nr_raw_registers)
    regcache_raw_read (current_regcache, regnum, buf);
d733 2
a734 2
    gdbarch_pseudo_register_read (current_gdbarch, current_regcache,
			          regnum, buf);
a736 1

d842 7
d850 3
a852 3
  gdb_assert (regnum < current_regcache->descr->nr_cooked_registers);
  if (regnum < current_regcache->descr->nr_raw_registers)
    regcache_raw_write (current_regcache, regnum, buf);
d854 1
a854 1
    gdbarch_pseudo_register_write (current_gdbarch, current_regcache,
@


1.43
log
@2002-07-25  Andrew Cagney  <cagney@@redhat.com>

* regcache.c (struct regcache_descr): Rename nr_registers to
nr_cooked_registers.  Revise comments describing the structure
member fields.
(init_regcache_descr): Update.
(init_legacy_regcache_descr): Update.
(read_register_gen, write_register_gen): When a cooked register in
the raw register range, directly access the value from the raw
register cache.
@
text
@d146 2
a147 2
  if (!gdbarch_register_read_p (gdbarch)
      && !gdbarch_register_write_p (gdbarch))
d727 2
a728 1
    gdbarch_register_read (current_gdbarch, regnum, buf);
d842 2
a843 1
    gdbarch_register_write (current_gdbarch, regnum, buf);
d1029 1
a1029 1
     through the method gdbarch_register_read() clean up the
@


1.42
log
@2002-07-24  Andrew Cagney  <cagney@@redhat.com>
* regcache.c (regcache_raw_write): Change buf parameter to a
constant void pointer.
(regcache_raw_read): Change buf parameter to a void pointer.
(legacy_write_register_gen): Change myaddr parameter a constant
void pointer.
(supply_register): Change val parameter to a const void pointer.
* regcache.h (regcache_raw_write): Update declaration.
(regcache_raw_read): Update declaration.
(supply_register): Update declaration.
@
text
@d59 14
a72 5
  /* Offset, in bytes, of reach register in the raw register cache.
     Pseudo registers have an offset even though they don't
     (shouldn't) have a correspoinding space in the register cache.
     It is to keep existing code, that relies on
     write/write_register_bytes working.  */
d74 1
d76 1
a76 7
  /* The cooked / frame / virtual register space.  The registers in
     the range [0..NR_RAW_REGISTERS) should be mapped directly onto
     the corresponding raw register.  The next [NR_RAW_REGISTERS
     .. NR_REGISTERS) should have been mapped, via
     gdbarch_register_read/write onto either raw registers or memory.  */
  int nr_registers;
  long *sizeof_register;
a77 1

d95 3
a97 3
  descr->nr_registers = NUM_REGS + NUM_PSEUDO_REGS;
  descr->nr_raw_registers = descr->nr_registers;
  descr->sizeof_raw_register_valid_p = descr->nr_registers;
d104 2
a105 2
  descr->sizeof_register = XCALLOC (descr->nr_registers, long);
  descr->register_offset = XCALLOC (descr->nr_registers, long);
d107 1
a107 1
  for (i = 0; i < descr->nr_registers; i++)
d117 1
a117 1
  for (i = 0; i < descr->nr_registers; i++)
d154 2
a155 2
  /* Total size of the register space.  The raw registers should
     directly map onto the raw register cache while the pseudo's are
d157 1
a157 1
  descr->nr_registers = NUM_REGS + NUM_PSEUDO_REGS;
d176 2
a177 2
    descr->sizeof_register = XCALLOC (descr->nr_registers, long);
    descr->register_offset = XCALLOC (descr->nr_registers, long);
d179 1
a179 1
    for (i = 0; i < descr->nr_registers; i++)
d204 1
a204 1
  for (i = 0; i < descr->nr_registers; i++)
d722 6
a727 1
  gdbarch_register_read (current_gdbarch, regnum, buf);
d836 6
a841 1
  gdbarch_register_write (current_gdbarch, regnum, buf);
@


1.41
log
@2002-07-24  Andrew Cagney  <cagney@@redhat.com>
* regcache.h (regcache_raw_read, regcache_raw_write): Replace
regcache_read and regcache_write.
(regcache_raw_read_as_address): Replace regcache_read_as_address.
* regcache.c: Update.
* sh-tdep.c (sh64_push_arguments): Update comment.
(sh_pseudo_register_read): Update.
(sh_pseudo_register_write): Update.
(sh4_register_read): Update.
(sh4_register_write): Update.
(sh64_pseudo_register_read): Update.
(sh64_pseudo_register_write): Update.
(sh64_register_read): Update.
(sh64_register_write): Update.
* i386-tdep.c (i386_extract_return_value): Update.
(i386_extract_struct_value_address): Update.
(i386_extract_return_value): Update.
* blockframe.c (generic_read_register_dummy): Update.
(generic_call_dummy_register_unwind): Update
* infrun.c (write_inferior_status_register): Update.
@
text
@d674 1
a674 1
regcache_raw_read (struct regcache *regcache, int regnum, char *buf)
d727 1
a727 1
legacy_write_register_gen (int regnum, char *myaddr)
d764 1
a764 1
regcache_raw_write (struct regcache *regcache, int regnum, char *buf)
d990 1
a990 1
supply_register (int regnum, char *val)
@


1.40
log
@* infcmd.c (print_return_value): Remove compatibility code calling
deprecated_grub_regcache_for_registers.

* values.c: Include "regcache.h".
(value_being_returned): Update.  Use
deprecated_grub_regcache_for_registers to extract the register
buffer address.
* value.h (value_being_returned): Change ``retbuf'' parameter to a
``struct regcache''.
* Makefile.in (values.o): Add dependency on $(regcache_h).

* inferior.h (run_stack_dummy): Change type of second parameter to
a ``struct regcache''.
* valops.c (hand_function_call): Change type of retbuf to ``struct
regcache''.  Allocate using regcache_xmalloc, clean using
make_cleanup_regcache_xfree.
* infcmd.c (run_stack_dummy): Update.  Use
regcache_cpu_no_passthrough instead of memcpy to copy the buffer.

* regcache.c (do_regcache_xfree): New function.
(make_cleanup_regcache_xfree): New function.
* regcache.h (make_cleanup_regcache_xfree): Declare.
@
text
@d315 2
a316 2
      regcache_read (src, i, buf);
      regcache_write (dst, i, buf);
d365 1
a365 1
regcache_read_as_address (struct regcache *regcache, int regnum)
d371 1
a371 1
  regcache_read (regcache, regnum, buf);
d674 1
a674 1
regcache_read (struct regcache *regcache, int regnum, char *buf)
d764 1
a764 1
regcache_write (struct regcache *regcache, int regnum, char *buf)
@


1.39
log
@From 2002-06-27 John David Anglin <dave@@hiauly1.hia.nrc.ca>:
* regcache.c (supply_register): Add missing argument to
register_buffer call.
@
text
@d272 12
@


1.38
log
@* regcache.h: Update comments describing the regcache_cpy family
of functions.
(regcache_save, regcache_restore): Delete declaration.
(regcache_save_no_passthrough): Delete declaration.
(regcache_restore_no_passthrough): Delete declaration.
* regcache.c (regcache_save): Delete function.
(regcache_save_no_passthrough): Delete function.
(regcache_restore): Delete function.
(regcache_restore_no_passthrough): Delete function.
@
text
@d1006 2
a1007 1
  DEPRECATED_CLEAN_UP_REGISTER_VALUE (regnum, register_buffer (regnum));
@


1.37
log
@* regcache.h: Update copyright.
(struct regcache, struct gdbarch): Add opaque declarations.
(current_regcache): Declare global variable.
(regcache_read, regcache_write): Add gdbarch parameter.
(regcache_save, regcache_save_no_passthrough)
(regcache_restore, regcache_restore_no_passthrough)
(regcache_dup, regcache_dup_no_passthrough)
(regcache_cpy, regcache_cpy_no_passthrough)
(deprecated_grub_regcache_for_registers)
(deprecated_grub_regcache_for_register_valid)
(regcache_valid_p): Add function declarations.

* regcache.c: Update copyright.
(regcache_descr_handle): New global variable.
(struct regcache_descr): Define.
(init_legacy_regcache_descr, init_regcache_descr): New functions.
(regcache_descr, xfree_regcache_descr): New functions.
(struct regcache): Define.
(regcache_xmalloc, regcache_xfree): New functions.
(regcache_cpy, regcache_cpy_no_passthrough): New functions.
(regcache_dup, regcache_dup_no_passthrough): New functions.
(regcache_valid_p, regcache_read_as_address): New functions.
(deprecated_grub_regcache_for_registers): New function.
(deprecated_grub_regcache_for_register_valid): New function.
(current_regcache): New global variable.
(register_buffer): Add regcache parameter.  Update calls.
(regcache_read, regcache_write): Add regcache parameter.  Rewrite.
(read_register_gen, write_register_gen): Update register_buffer
call.  Test for legacy_p instead of gdbarch_register_read_p or
gdbarch_register_write_p.
(regcache_collect): Update register_buffer call.
(build_regcache): Rewrite.  Use deprecated grub functions.
(regcache_save, regcache_save_no_passthrough): New functions.
(regcache_restore, regcache_restore_no_passthrough): New
functions.
(_initialize_regcache): Create the regcache_data_handle. Swap
current_regcache global variable.

* sh-tdep.c (sh_pseudo_register_read): Add current_regcache
parameter to regcache_read and regcache_write calls.
(sh4_register_read): Ditto.
(sh64_pseudo_register_read): Ditto.
(sh64_register_read): Ditto.
(sh_pseudo_register_write): Ditto.
(sh4_register_write): Ditto.
(sh64_pseudo_register_write): Ditto.
(sh64_register_write): Ditto.

* defs.h (XCALLOC): Define.
@
text
@a1188 35
regcache_save (struct regcache *regcache)
{
  int i;
  gdb_assert (current_regcache != NULL && regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == regcache->descr->gdbarch);
  regcache_cpy (regcache, current_regcache);
}

void
regcache_save_no_passthrough (struct regcache *regcache)
{
  gdb_assert (current_regcache != NULL && regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == regcache->descr->gdbarch);
  regcache_cpy_no_passthrough (regcache, current_regcache);
}

void
regcache_restore (struct regcache *regcache)
{
  int i;
  gdb_assert (current_regcache != NULL && regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == regcache->descr->gdbarch);
  regcache_cpy (current_regcache, regcache);
}

void
regcache_restore_no_passthrough (struct regcache *regcache)
{
  char *regcache_registers;
  gdb_assert (current_regcache != NULL && regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == regcache->descr->gdbarch);
  regcache_cpy_no_passthrough (current_regcache, regcache);
}

void
@


1.36
log
@* regcache.c (register_valid): Revise comments refering to "Not
available" and "unavailable".
* frame.c (frame_register_read): Ditto.
* findvar.c (value_of_register): Ditto.
@
text
@d2 3
a4 2
   Copyright 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000, 2001
   Free Software Foundation, Inc.
d37 343
d444 1
a444 1
register_buffer (int regnum)
d446 1
a446 2
  gdb_assert (regnum >= 0 && regnum < (NUM_REGS + NUM_PSEUDO_REGS));
  return &registers[REGISTER_BYTE (regnum)];
d657 1
a657 1
  memcpy (myaddr, register_buffer (regnum),
d662 1
a662 1
regcache_read (int rawnum, char *buf)
d664 31
a694 3
  gdb_assert (rawnum >= 0 && rawnum < (NUM_REGS + NUM_PSEUDO_REGS));
  /* For moment, just use underlying legacy code. Ulgh!!! */
  legacy_read_register_gen (rawnum, buf);
d700 3
a702 1
  if (! gdbarch_register_read_p (current_gdbarch))
d738 2
a739 1
	  && memcmp (register_buffer (regnum), myaddr, size) == 0)
d745 1
a745 1
  memcpy (register_buffer (regnum), myaddr, size);
d752 1
a752 1
regcache_write (int rawnum, char *buf)
d754 50
a803 3
  gdb_assert (rawnum >= 0 && rawnum < (NUM_REGS + NUM_PSEUDO_REGS));
  /* For moment, just use underlying legacy code. Ulgh!!! */
  legacy_write_register_gen (rawnum, buf);
d809 3
a811 1
  if (! gdbarch_register_write_p (current_gdbarch))
d990 1
a990 1
    memcpy (register_buffer (regnum), val, 
d993 1
a993 1
    memset (register_buffer (regnum), '\000', 
d1013 2
a1014 1
  memcpy (buf, register_buffer (regnum), REGISTER_RAW_SIZE (regnum));
d1182 26
d1209 12
a1220 25
  int sizeof_register_valid;
  /* Come up with the real size of the registers buffer.  */
  int sizeof_registers = REGISTER_BYTES; /* OK use.  */
  for (i = 0; i < NUM_REGS + NUM_PSEUDO_REGS; i++)
    {
      long regend;
      /* Keep extending the buffer so that there is always enough
         space for all registers.  The comparison is necessary since
         legacy code is free to put registers in random places in the
         buffer separated by holes.  Once REGISTER_BYTE() is killed
         this can be greatly simplified.  */
      /* FIXME: cagney/2001-12-04: This code shouldn't need to use
         REGISTER_BYTE().  Unfortunatly, legacy code likes to lay the
         buffer out so that certain registers just happen to overlap.
         Ulgh!  New targets use gdbarch's register read/write and
         entirely avoid this uglyness.  */
      regend = REGISTER_BYTE (i) + REGISTER_RAW_SIZE (i);
      if (sizeof_registers < regend)
	sizeof_registers = regend;
    }
  registers = xmalloc (sizeof_registers);
  sizeof_register_valid = ((NUM_REGS + NUM_PSEUDO_REGS)
			   * sizeof (*register_valid));
  register_valid = xmalloc (sizeof_register_valid);
  memset (register_valid, 0, sizeof_register_valid);
d1226 3
@


1.36.4.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d2 2
a3 3

   Copyright 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000,
   2001, 2002 Free Software Foundation, Inc.
a35 355
/* Per-architecture object describing the layout of a register cache.
   Computed once when the architecture is created */

struct gdbarch_data *regcache_descr_handle;

struct regcache_descr
{
  /* The architecture this descriptor belongs to.  */
  struct gdbarch *gdbarch;

  /* Is this a ``legacy'' register cache?  Such caches reserve space
     for raw and pseudo registers and allow access to both.  */
  int legacy_p;

  /* The raw register cache.  This should contain just [0
     .. NUM_RAW_REGISTERS).  However, for older targets, it contains
     space for the full [0 .. NUM_RAW_REGISTERS +
     NUM_PSEUDO_REGISTERS).  */
  int nr_raw_registers;
  long sizeof_raw_registers;
  long sizeof_raw_register_valid_p;

  /* Offset, in bytes, of reach register in the raw register cache.
     Pseudo registers have an offset even though they don't
     (shouldn't) have a correspoinding space in the register cache.
     It is to keep existing code, that relies on
     write/write_register_bytes working.  */
  long *register_offset;

  /* The cooked / frame / virtual register space.  The registers in
     the range [0..NR_RAW_REGISTERS) should be mapped directly onto
     the corresponding raw register.  The next [NR_RAW_REGISTERS
     .. NR_REGISTERS) should have been mapped, via
     gdbarch_register_read/write onto either raw registers or memory.  */
  int nr_registers;
  long *sizeof_register;
  long max_register_size;

};

static void *
init_legacy_regcache_descr (struct gdbarch *gdbarch)
{
  int i;
  struct regcache_descr *descr;
  /* FIXME: cagney/2002-05-11: gdbarch_data() should take that
     ``gdbarch'' as a parameter.  */
  gdb_assert (gdbarch != NULL);

  descr = XMALLOC (struct regcache_descr);
  descr->gdbarch = gdbarch;
  descr->legacy_p = 1;

  /* FIXME: cagney/2002-05-11: Shouldn't be including pseudo-registers
     in the register buffer.  Unfortunatly some architectures do.  */
  descr->nr_registers = NUM_REGS + NUM_PSEUDO_REGS;
  descr->nr_raw_registers = descr->nr_registers;
  descr->sizeof_raw_register_valid_p = descr->nr_registers;

  /* FIXME: cagney/2002-05-11: Instead of using REGISTER_BYTE() this
     code should compute the offets et.al. at runtime.  This currently
     isn't possible because some targets overlap register locations -
     see the mess in read_register_bytes() and write_register_bytes()
     registers.  */
  descr->sizeof_register = XCALLOC (descr->nr_registers, long);
  descr->register_offset = XCALLOC (descr->nr_registers, long);
  descr->max_register_size = 0;
  for (i = 0; i < descr->nr_registers; i++)
    {
      descr->register_offset[i] = REGISTER_BYTE (i);
      descr->sizeof_register[i] = REGISTER_RAW_SIZE (i);
      if (descr->max_register_size < REGISTER_RAW_SIZE (i))
	descr->max_register_size = REGISTER_RAW_SIZE (i);
    }

  /* Come up with the real size of the registers buffer.  */
  descr->sizeof_raw_registers = REGISTER_BYTES; /* OK use.  */
  for (i = 0; i < descr->nr_registers; i++)
    {
      long regend;
      /* Keep extending the buffer so that there is always enough
         space for all registers.  The comparison is necessary since
         legacy code is free to put registers in random places in the
         buffer separated by holes.  Once REGISTER_BYTE() is killed
         this can be greatly simplified.  */
      /* FIXME: cagney/2001-12-04: This code shouldn't need to use
         REGISTER_BYTE().  Unfortunatly, legacy code likes to lay the
         buffer out so that certain registers just happen to overlap.
         Ulgh!  New targets use gdbarch's register read/write and
         entirely avoid this uglyness.  */
      regend = descr->register_offset[i] + descr->sizeof_register[i];
      if (descr->sizeof_raw_registers < regend)
	descr->sizeof_raw_registers = regend;
    }
  return descr;
}

static void *
init_regcache_descr (struct gdbarch *gdbarch)
{
  int i;
  struct regcache_descr *descr;
  gdb_assert (gdbarch != NULL);

  /* If an old style architecture, construct the register cache
     description using all the register macros.  */
  if (!gdbarch_register_read_p (gdbarch)
      && !gdbarch_register_write_p (gdbarch))
    return init_legacy_regcache_descr (gdbarch);

  descr = XMALLOC (struct regcache_descr);
  descr->gdbarch = gdbarch;
  descr->legacy_p = 0;

  /* Total size of the register space.  The raw registers should
     directly map onto the raw register cache while the pseudo's are
     either mapped onto raw-registers or memory.  */
  descr->nr_registers = NUM_REGS + NUM_PSEUDO_REGS;

  /* Construct a strictly RAW register cache.  Don't allow pseudo's
     into the register cache.  */
  descr->nr_raw_registers = NUM_REGS;
  descr->sizeof_raw_register_valid_p = NUM_REGS;

  /* Lay out the register cache.  The pseud-registers are included in
     the layout even though their value isn't stored in the register
     cache.  Some code, via read_register_bytes() access a register
     using an offset/length rather than a register number.

     NOTE: cagney/2002-05-22: Only REGISTER_VIRTUAL_TYPE() needs to be
     used when constructing the register cache.  It is assumed that
     register raw size, virtual size and type length of the type are
     all the same.  */

  {
    long offset = 0;
    descr->sizeof_register = XCALLOC (descr->nr_registers, long);
    descr->register_offset = XCALLOC (descr->nr_registers, long);
    descr->max_register_size = 0;
    for (i = 0; i < descr->nr_registers; i++)
      {
	descr->sizeof_register[i] = TYPE_LENGTH (REGISTER_VIRTUAL_TYPE (i));
	descr->register_offset[i] = offset;
	offset += descr->sizeof_register[i];
	if (descr->max_register_size < descr->sizeof_register[i])
	  descr->max_register_size = descr->sizeof_register[i];
      }
    /* Set the real size of the register cache buffer.  */
    /* FIXME: cagney/2002-05-22: Should only need to allocate space
       for the raw registers.  Unfortunatly some code still accesses
       the register array directly using the global registers[].
       Until that code has been purged, play safe and over allocating
       the register buffer.  Ulgh!  */
    descr->sizeof_raw_registers = offset;
    /* = descr->register_offset[descr->nr_raw_registers]; */
  }

#if 0
  /* Sanity check.  Confirm that the assumptions about gdbarch are
     true.  The REGCACHE_DESCR_HANDLE is set before doing the checks
     so that targets using the generic methods supplied by regcache
     don't go into infinite recursion trying to, again, create the
     regcache.  */
  set_gdbarch_data (gdbarch, regcache_descr_handle, descr);
  for (i = 0; i < descr->nr_registers; i++)
    {
      gdb_assert (descr->sizeof_register[i] == REGISTER_RAW_SIZE (i));
      gdb_assert (descr->sizeof_register[i] == REGISTER_VIRTUAL_SIZE (i));
      gdb_assert (descr->register_offset[i] == REGISTER_BYTE (i));
    }
  /* gdb_assert (descr->sizeof_raw_registers == REGISTER_BYTES (i));  */
#endif

  return descr;
}

static struct regcache_descr *
regcache_descr (struct gdbarch *gdbarch)
{
  return gdbarch_data (gdbarch, regcache_descr_handle);
}

static void
xfree_regcache_descr (struct gdbarch *gdbarch, void *ptr)
{
  struct regcache_descr *descr = ptr;
  if (descr == NULL)
    return;
  xfree (descr->register_offset);
  xfree (descr->sizeof_register);
  descr->register_offset = NULL;
  descr->sizeof_register = NULL;
  xfree (descr);
}

/* The register cache for storing raw register values.  */

struct regcache
{
  struct regcache_descr *descr;
  char *raw_registers;
  char *raw_register_valid_p;
  /* If a value isn't in the cache should the corresponding target be
     queried for a value.  */
  int passthrough_p;
};

struct regcache *
regcache_xmalloc (struct gdbarch *gdbarch)
{
  struct regcache_descr *descr;
  struct regcache *regcache;
  gdb_assert (gdbarch != NULL);
  descr = regcache_descr (gdbarch);
  regcache = XMALLOC (struct regcache);
  regcache->descr = descr;
  regcache->raw_registers
    = XCALLOC (descr->sizeof_raw_registers, char);
  regcache->raw_register_valid_p
    = XCALLOC (descr->sizeof_raw_register_valid_p, char);
  regcache->passthrough_p = 0;
  return regcache;
}

void
regcache_xfree (struct regcache *regcache)
{
  if (regcache == NULL)
    return;
  xfree (regcache->raw_registers);
  xfree (regcache->raw_register_valid_p);
  xfree (regcache);
}

void
do_regcache_xfree (void *data)
{
  regcache_xfree (data);
}

struct cleanup *
make_cleanup_regcache_xfree (struct regcache *regcache)
{
  return make_cleanup (do_regcache_xfree, regcache);
}

void
regcache_cpy (struct regcache *dst, struct regcache *src)
{
  int i;
  char *buf;
  gdb_assert (src != NULL && dst != NULL);
  gdb_assert (src->descr->gdbarch == dst->descr->gdbarch);
  gdb_assert (src != dst);
  /* FIXME: cagney/2002-05-17: To say this bit is bad is being polite.
     It keeps the existing code working where things rely on going
     through to the register cache.  */
  if (src == current_regcache && src->descr->legacy_p)
    {
      /* ULGH!!!!  Old way.  Use REGISTER bytes and let code below
	 untangle fetch.  */
      read_register_bytes (0, dst->raw_registers, REGISTER_BYTES);
      return;
    }
  /* FIXME: cagney/2002-05-17: To say this bit is bad is being polite.
     It keeps the existing code working where things rely on going
     through to the register cache.  */
  if (dst == current_regcache && dst->descr->legacy_p)
    {
      /* ULGH!!!!  Old way.  Use REGISTER bytes and let code below
	 untangle fetch.  */
      write_register_bytes (0, src->raw_registers, REGISTER_BYTES);
      return;
    }
  buf = alloca (src->descr->max_register_size);
  for (i = 0; i < src->descr->nr_raw_registers; i++)
    {
      /* Should we worry about the valid bit here?  */
      regcache_read (src, i, buf);
      regcache_write (dst, i, buf);
    }
}

void
regcache_cpy_no_passthrough (struct regcache *dst, struct regcache *src)
{
  int i;
  gdb_assert (src != NULL && dst != NULL);
  gdb_assert (src->descr->gdbarch == dst->descr->gdbarch);
  /* NOTE: cagney/2002-05-17: Don't let the caller do a no-passthrough
     move of data into the current_regcache().  Doing this would be
     silly - it would mean that valid_p would be completly invalid.  */
  gdb_assert (dst != current_regcache);
  memcpy (dst->raw_registers, src->raw_registers,
	  dst->descr->sizeof_raw_registers);
  memcpy (dst->raw_register_valid_p, src->raw_register_valid_p,
	  dst->descr->sizeof_raw_register_valid_p);
}

struct regcache *
regcache_dup (struct regcache *src)
{
  struct regcache *newbuf;
  gdb_assert (current_regcache != NULL);
  newbuf = regcache_xmalloc (src->descr->gdbarch);
  regcache_cpy (newbuf, src);
  return newbuf;
}

struct regcache *
regcache_dup_no_passthrough (struct regcache *src)
{
  struct regcache *newbuf;
  gdb_assert (current_regcache != NULL);
  newbuf = regcache_xmalloc (src->descr->gdbarch);
  regcache_cpy_no_passthrough (newbuf, src);
  return newbuf;
}

int
regcache_valid_p (struct regcache *regcache, int regnum)
{
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  return regcache->raw_register_valid_p[regnum];
}

CORE_ADDR
regcache_read_as_address (struct regcache *regcache, int regnum)
{
  char *buf;
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  regcache_read (regcache, regnum, buf);
  return extract_address (buf, regcache->descr->sizeof_register[regnum]);
}

char *
deprecated_grub_regcache_for_registers (struct regcache *regcache)
{
  return regcache->raw_registers;
}

char *
deprecated_grub_regcache_for_register_valid (struct regcache *regcache)
{
  return regcache->raw_register_valid_p;
}

/* Global structure containing the current regcache.  */
/* FIXME: cagney/2002-05-11: The two global arrays registers[] and
   register_valid[] currently point into this structure.  */
struct regcache *current_regcache;

d100 1
a100 1
register_buffer (struct regcache *regcache, int regnum)
d102 2
a103 1
  return regcache->raw_registers + regcache->descr->register_offset[regnum];
d314 1
a314 1
  memcpy (myaddr, register_buffer (current_regcache, regnum),
d319 1
a319 1
regcache_read (struct regcache *regcache, int regnum, char *buf)
d321 3
a323 31
  gdb_assert (regcache != NULL && buf != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  if (regcache->descr->legacy_p
      && regcache->passthrough_p)
    {
      gdb_assert (regcache == current_regcache);
      /* For moment, just use underlying legacy code.  Ulgh!!! This
	 silently and very indirectly updates the regcache's regcache
	 via the global register_valid[].  */
      legacy_read_register_gen (regnum, buf);
      return;
    }
  /* Make certain that the register cache is up-to-date with respect
     to the current thread.  This switching shouldn't be necessary
     only there is still only one target side register cache.  Sigh!
     On the bright side, at least there is a regcache object.  */
  if (regcache->passthrough_p)
    {
      gdb_assert (regcache == current_regcache);
      if (! ptid_equal (registers_ptid, inferior_ptid))
	{
	  registers_changed ();
	  registers_ptid = inferior_ptid;
	}
      if (!register_cached (regnum))
	fetch_register (regnum);
    }
  /* Copy the value directly into the register cache.  */
  memcpy (buf, (regcache->raw_registers
		+ regcache->descr->register_offset[regnum]),
	  regcache->descr->sizeof_register[regnum]);
d329 1
a329 3
  gdb_assert (current_regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == current_gdbarch);
  if (current_regcache->descr->legacy_p)
d365 1
a365 2
	  && (memcmp (register_buffer (current_regcache, regnum), myaddr, size)
	      == 0))
d371 1
a371 1
  memcpy (register_buffer (current_regcache, regnum), myaddr, size);
d378 1
a378 1
regcache_write (struct regcache *regcache, int regnum, char *buf)
d380 3
a382 50
  gdb_assert (regcache != NULL && buf != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);

  if (regcache->passthrough_p
      && regcache->descr->legacy_p)
    {
      /* For moment, just use underlying legacy code.  Ulgh!!! This
	 silently and very indirectly updates the regcache's buffers
	 via the globals register_valid[] and registers[].  */
      gdb_assert (regcache == current_regcache);
      legacy_write_register_gen (regnum, buf);
      return;
    }

  /* On the sparc, writing %g0 is a no-op, so we don't even want to
     change the registers array if something writes to this register.  */
  if (CANNOT_STORE_REGISTER (regnum))
    return;

  /* Handle the simple case first -> not write through so just store
     value in cache.  */
  if (!regcache->passthrough_p)
    {
      memcpy ((regcache->raw_registers
	       + regcache->descr->register_offset[regnum]), buf,
	      regcache->descr->sizeof_register[regnum]);
      regcache->raw_register_valid_p[regnum] = 1;
      return;
    }

  /* Make certain that the correct cache is selected.  */
  gdb_assert (regcache == current_regcache);
  if (! ptid_equal (registers_ptid, inferior_ptid))
    {
      registers_changed ();
      registers_ptid = inferior_ptid;
    }

  /* If we have a valid copy of the register, and new value == old
     value, then don't bother doing the actual store. */
  if (regcache_valid_p (regcache, regnum)
      && (memcmp (register_buffer (regcache, regnum), buf,
		  regcache->descr->sizeof_register[regnum]) == 0))
    return;

  target_prepare_to_store ();
  memcpy (register_buffer (regcache, regnum), buf,
	  regcache->descr->sizeof_register[regnum]);
  regcache->raw_register_valid_p[regnum] = 1;
  store_register (regnum);
d388 1
a388 3
  gdb_assert (current_regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == current_gdbarch);
  if (current_regcache->descr->legacy_p)
d567 1
a567 1
    memcpy (register_buffer (current_regcache, regnum), val, 
d570 1
a570 1
    memset (register_buffer (current_regcache, regnum), '\000', 
d583 1
a583 2
  DEPRECATED_CLEAN_UP_REGISTER_VALUE \
    (regnum, register_buffer (current_regcache, regnum));
d590 1
a590 2
  memcpy (buf, register_buffer (current_regcache, regnum),
	  REGISTER_RAW_SIZE (regnum));
d758 26
a783 4
  current_regcache = regcache_xmalloc (current_gdbarch);
  current_regcache->passthrough_p = 1;
  registers = deprecated_grub_regcache_for_registers (current_regcache);
  register_valid = deprecated_grub_regcache_for_register_valid (current_regcache);
a788 3
  regcache_descr_handle = register_gdbarch_data (init_regcache_descr,
						 xfree_regcache_descr);
  REGISTER_GDBARCH_SWAP (current_regcache);
@


1.36.4.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a29 1
#include "gdb_string.h"
d59 5
a63 14
  /* The cooked register space.  Each cooked register in the range
     [0..NR_RAW_REGISTERS) is direct-mapped onto the corresponding raw
     register.  The remaining [NR_RAW_REGISTERS
     .. NR_COOKED_REGISTERS) (a.k.a. pseudo regiters) are mapped onto
     both raw registers and memory by the architecture methods
     gdbarch_register_read and gdbarch_register_write.  */
  int nr_cooked_registers;

  /* Offset and size (in 8 bit bytes), of reach register in the
     register cache.  All registers (including those in the range
     [NR_RAW_REGISTERS .. NR_COOKED_REGISTERS) are given an offset.
     Assigning all registers an offset makes it possible to keep
     legacy code, such as that found in read_register_bytes() and
     write_register_bytes() working.  */
d65 7
d73 1
a74 2
  /* Useful constant.  Largest of all the registers.  */
  long max_register_size;
d92 3
a94 3
  descr->nr_cooked_registers = NUM_REGS + NUM_PSEUDO_REGS;
  descr->nr_raw_registers = descr->nr_cooked_registers;
  descr->sizeof_raw_register_valid_p = descr->nr_cooked_registers;
d101 2
a102 2
  descr->sizeof_register = XCALLOC (descr->nr_cooked_registers, long);
  descr->register_offset = XCALLOC (descr->nr_cooked_registers, long);
d104 1
a104 1
  for (i = 0; i < descr->nr_cooked_registers; i++)
d114 1
a114 1
  for (i = 0; i < descr->nr_cooked_registers; i++)
d143 2
a144 2
  if (!gdbarch_pseudo_register_read_p (gdbarch)
      && !gdbarch_pseudo_register_write_p (gdbarch))
d151 2
a152 2
  /* Total size of the register space.  The raw registers are mapped
     directly onto the raw register cache while the pseudo's are
d154 1
a154 1
  descr->nr_cooked_registers = NUM_REGS + NUM_PSEUDO_REGS;
d173 2
a174 2
    descr->sizeof_register = XCALLOC (descr->nr_cooked_registers, long);
    descr->register_offset = XCALLOC (descr->nr_cooked_registers, long);
d176 1
a176 1
    for (i = 0; i < descr->nr_cooked_registers; i++)
d201 1
a201 1
  for (i = 0; i < descr->nr_cooked_registers; i++)
d315 2
a316 2
      regcache_raw_read (src, i, buf);
      regcache_raw_write (dst, i, buf);
d365 1
a365 1
regcache_raw_read_as_address (struct regcache *regcache, int regnum)
d371 1
a371 1
  regcache_raw_read (regcache, regnum, buf);
d469 40
d667 1
a667 1
    target_fetch_registers (regnum);
d674 1
a674 1
regcache_raw_read (struct regcache *regcache, int regnum, void *buf)
d701 1
a701 1
	target_fetch_registers (regnum);
d719 1
a719 1
  regcache_cooked_read (current_regcache, regnum, buf);
a721 11
void
regcache_cooked_read (struct regcache *regcache, int regnum, void *buf)
{
  gdb_assert (regnum >= 0);
  gdb_assert (regnum < regcache->descr->nr_cooked_registers);
  if (regnum < regcache->descr->nr_raw_registers)
    regcache_raw_read (regcache, regnum, buf);
  else
    gdbarch_pseudo_register_read (regcache->descr->gdbarch, regcache,
				  regnum, buf);
}
d727 1
a727 1
legacy_write_register_gen (int regnum, const void *myaddr)
d760 1
a760 1
  target_store_registers (regnum);
d764 1
a764 1
regcache_raw_write (struct regcache *regcache, int regnum, const void *buf)
d815 1
a815 1
  target_store_registers (regnum);
d828 1
a828 13
  regcache_cooked_write (current_regcache, regnum, buf);
}

void
regcache_cooked_write (struct regcache *regcache, int regnum, const void *buf)
{
  gdb_assert (regnum >= 0);
  gdb_assert (regnum < regcache->descr->nr_cooked_registers);
  if (regnum < regcache->descr->nr_raw_registers)
    regcache_raw_write (regcache, regnum, buf);
  else
    gdbarch_pseudo_register_write (regcache->descr->gdbarch, regcache,
				   regnum, buf);
d879 1
a879 1
	  target_store_registers (regnum);
d990 1
a990 1
supply_register (int regnum, const void *val)
d1014 1
a1014 1
     through the method gdbarch_pseudo_register_read() clean up the
@


1.36.4.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a30 1
#include "gdbcmd.h"		/* For maintenanceprintlist.  */
a78 3

  /* Cached table containing the type of each register.  */
  struct type **register_type;
d81 2
a82 3
void
init_legacy_regcache_descr (struct gdbarch *gdbarch,
			    struct regcache_descr *descr)
d85 1
d90 4
d96 1
a113 2
      if (descr->max_register_size < REGISTER_VIRTUAL_SIZE (i))
	descr->max_register_size = REGISTER_VIRTUAL_SIZE (i);
d135 1
d145 7
a151 2
  /* Create an initial, zero filled, table.  */
  descr = XCALLOC (1, struct regcache_descr);
d153 1
a159 18
  /* Fill in a table of register types.  */
  descr->register_type = XCALLOC (descr->nr_cooked_registers,
				  struct type *);
  for (i = 0; i < descr->nr_cooked_registers; i++)
    {
      descr->register_type[i] = REGISTER_VIRTUAL_TYPE (i);
    }

  /* If an old style architecture, fill in the remainder of the
     register cache descriptor using the register macros.  */
  if (!gdbarch_pseudo_register_read_p (gdbarch)
      && !gdbarch_pseudo_register_write_p (gdbarch))
    {
      descr->legacy_p = 1;
      init_legacy_regcache_descr (gdbarch, descr);
      return descr;
    }

d163 1
a163 6

  /* FIXME: cagney/2002-08-13: Overallocate the register_valid_p
     array.  This pretects GDB from erant code that accesses elements
     of the global register_valid_p[] array in the range [NUM_REGS
     .. NUM_REGS + NUM_PSEUDO_REGS).  */
  descr->sizeof_raw_register_valid_p = NUM_REGS + NUM_PSEUDO_REGS;
d170 4
a173 4
     NOTE: cagney/2002-05-22: Only register_type() is used when
     constructing the register cache.  It is assumed that the
     register's raw size, virtual size and type length are all the
     same.  */
d182 1
a182 1
	descr->sizeof_register[i] = TYPE_LENGTH (descr->register_type[i]);
a235 21
/* Utility functions returning useful register attributes stored in
   the regcache descr.  */

struct type *
register_type (struct gdbarch *gdbarch, int regnum)
{
  struct regcache_descr *descr = regcache_descr (gdbarch);
  gdb_assert (regnum >= 0 && regnum < descr->nr_cooked_registers);
  return descr->register_type[regnum];
}

/* Utility functions returning useful register attributes stored in
   the regcache descr.  */

int
max_register_size (struct gdbarch *gdbarch)
{
  struct regcache_descr *descr = regcache_descr (gdbarch);
  return descr->max_register_size;
}

d368 11
d444 1
a444 3
  gdb_assert (regnum >= 0);
  gdb_assert (regnum < current_regcache->descr->nr_raw_registers);
  current_regcache->raw_register_valid_p[regnum] = state;
d498 1
a498 1
  for (i = 0; i < current_regcache->descr->nr_raw_registers; i++)
a673 48
regcache_raw_read_signed (struct regcache *regcache, int regnum, LONGEST *val)
{
  char *buf;
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  regcache_raw_read (regcache, regnum, buf);
  (*val) = extract_signed_integer (buf,
				   regcache->descr->sizeof_register[regnum]);
}

void
regcache_raw_read_unsigned (struct regcache *regcache, int regnum,
			    ULONGEST *val)
{
  char *buf;
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  regcache_raw_read (regcache, regnum, buf);
  (*val) = extract_unsigned_integer (buf,
				     regcache->descr->sizeof_register[regnum]);
}

void
regcache_raw_write_signed (struct regcache *regcache, int regnum, LONGEST val)
{
  void *buf;
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >=0 && regnum < regcache->descr->nr_raw_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  store_signed_integer (buf, regcache->descr->sizeof_register[regnum], val);
  regcache_raw_write (regcache, regnum, buf);
}

void
regcache_raw_write_unsigned (struct regcache *regcache, int regnum,
			     ULONGEST val)
{
  void *buf;
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >=0 && regnum < regcache->descr->nr_raw_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  store_unsigned_integer (buf, regcache->descr->sizeof_register[regnum], val);
  regcache_raw_write (regcache, regnum, buf);
}

void
a697 26
void
regcache_cooked_read_signed (struct regcache *regcache, int regnum,
			     LONGEST *val)
{
  char *buf;
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  regcache_cooked_read (regcache, regnum, buf);
  (*val) = extract_signed_integer (buf,
				   regcache->descr->sizeof_register[regnum]);
}

void
regcache_cooked_read_unsigned (struct regcache *regcache, int regnum,
			       ULONGEST *val)
{
  char *buf;
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  regcache_cooked_read (regcache, regnum, buf);
  (*val) = extract_unsigned_integer (buf,
				     regcache->descr->sizeof_register[regnum]);
}

a870 169
/* Perform a partial register transfer using a read, modify, write
   operation.  */

typedef void (regcache_read_ftype) (struct regcache *regcache, int regnum,
				    void *buf);
typedef void (regcache_write_ftype) (struct regcache *regcache, int regnum,
				     const void *buf);

void
regcache_xfer_part (struct regcache *regcache, int regnum,
		    int offset, int len, void *in, const void *out,
		    regcache_read_ftype *read, regcache_write_ftype *write)
{
  struct regcache_descr *descr = regcache->descr;
  bfd_byte *reg = alloca (descr->max_register_size);
  gdb_assert (offset >= 0 && offset <= descr->sizeof_register[regnum]);
  gdb_assert (len >= 0 && offset + len <= descr->sizeof_register[regnum]);
  /* Something to do?  */
  if (offset + len == 0)
    return;
  /* Read (when needed) ... */
  if (in != NULL
      || offset > 0
      || offset + len < descr->sizeof_register[regnum])
    {
      gdb_assert (read != NULL);
      read (regcache, regnum, reg);
    }
  /* ... modify ... */
  if (in != NULL)
    memcpy (in, reg + offset, len);
  if (out != NULL)
    memcpy (reg + offset, out, len);
  /* ... write (when needed).  */
  if (out != NULL)
    {
      gdb_assert (write != NULL);
      write (regcache, regnum, reg);
    }
}

void
regcache_raw_read_part (struct regcache *regcache, int regnum,
			int offset, int len, void *buf)
{
  struct regcache_descr *descr = regcache->descr;
  gdb_assert (regnum >= 0 && regnum < descr->nr_raw_registers);
  regcache_xfer_part (regcache, regnum, offset, len, buf, NULL,
		      regcache_raw_read, regcache_raw_write);
}

void
regcache_raw_write_part (struct regcache *regcache, int regnum,
			 int offset, int len, const void *buf)
{
  struct regcache_descr *descr = regcache->descr;
  gdb_assert (regnum >= 0 && regnum < descr->nr_raw_registers);
  regcache_xfer_part (regcache, regnum, offset, len, NULL, buf,
		      regcache_raw_read, regcache_raw_write);
}

void
regcache_cooked_read_part (struct regcache *regcache, int regnum,
			   int offset, int len, void *buf)
{
  struct regcache_descr *descr = regcache->descr;
  gdb_assert (regnum >= 0 && regnum < descr->nr_cooked_registers);
  regcache_xfer_part (regcache, regnum, offset, len, buf, NULL,
		      regcache_cooked_read, regcache_cooked_write);
}

void
regcache_cooked_write_part (struct regcache *regcache, int regnum,
			    int offset, int len, const void *buf)
{
  struct regcache_descr *descr = regcache->descr;
  gdb_assert (regnum >= 0 && regnum < descr->nr_cooked_registers);
  regcache_xfer_part (regcache, regnum, offset, len, NULL, buf,
		      regcache_cooked_read, regcache_cooked_write);
}

/* Hack to keep code that view the register buffer as raw bytes
   working.  */

int
register_offset_hack (struct gdbarch *gdbarch, int regnum)
{
  struct regcache_descr *descr = regcache_descr (gdbarch);
  gdb_assert (regnum >= 0 && regnum < descr->nr_cooked_registers);
  return descr->register_offset[regnum];
}

static void
cooked_xfer_using_offset_hack (struct regcache *regcache,
			       int buf_start, int buf_len, void *in_b,
			       const void *out_b)
{
  struct regcache_descr *descr = regcache->descr;
  struct gdbarch *gdbarch = descr->gdbarch;
  bfd_byte *in_buf = in_b;
  const bfd_byte *out_buf = out_b;
  int buf_end = buf_start + buf_len;
  int regnum;
  char *reg_buf = alloca (descr->max_register_size);

  /* NOTE: cagney/2002-08-17: This code assumes that the register
     offsets are strictly increasing and do not overlap.  If this
     isn't the case then the bug is in the target architecture and NOT
     this code.  */

  /* NOTE: cagney/2002-08-17: This code assumes that only the
     registers covered by BUF_START:BUF_LEN should be transfered.  If,
     for some reason, there is a gap between two registers, then that
     gap isn't transfered.  (The gap shouldn't be there but that is
     another story.)  */

  /* Iterate through all registers looking for those that lie within
     BUF_START:BUF_LEN.  */

  for (regnum = 0; regnum < descr->nr_cooked_registers; regnum++)
    {
      /* The register's location.  */
      int reg_start = descr->register_offset[regnum];
      int reg_len = descr->sizeof_register[regnum];
      int reg_end = reg_start + reg_len;

      /* The START, END and LEN that falls within the current
         register.  */
      int xfer_start;
      int xfer_end;
      int xfer_len;

      /* start = max (reg_start, buf_start) */
      if (reg_start > buf_start)
	xfer_start = reg_start;
      else
	xfer_start = buf_start;
      
      /* end = min (reg_end, buf_end) */
      if (reg_end < buf_end)
	xfer_end = reg_end;
      else
	xfer_end = buf_end;
      
      /* The number of bytes to transfer.  If there isn't anything to
         transfer (the end is before the start) this will be -ve.  */
      xfer_len = xfer_end - xfer_start;

      if (xfer_len > 0)
	regcache_xfer_part (regcache, regnum, xfer_start - reg_start,
			    xfer_len, in_b, out_b, regcache_cooked_read,
			    regcache_cooked_write);
    }
}

void
regcache_cooked_read_using_offset_hack (struct regcache *regcache,
					int buf_start, int buf_len, void *b)
{
  cooked_xfer_using_offset_hack (regcache, buf_start, buf_len, b, NULL);
}

void
regcache_cooked_write_using_offset_hack (struct regcache *regcache,
					 int buf_start, int buf_len,
					 const void *b)
{
  cooked_xfer_using_offset_hack (regcache, buf_start, buf_len, NULL, b);
}
a1187 239
static void
dump_endian_bytes (struct ui_file *file, enum bfd_endian endian,
		   const unsigned char *buf, long len)
{
  int i;
  switch (endian)
    {
    case BFD_ENDIAN_BIG:
      for (i = 0; i < len; i++)
	fprintf_unfiltered (file, "%02x", buf[i]);
      break;
    case BFD_ENDIAN_LITTLE:
      for (i = len - 1; i >= 0; i--)
	fprintf_unfiltered (file, "%02x", buf[i]);
      break;
    default:
      internal_error (__FILE__, __LINE__, "Bad switch");
    }
}

enum regcache_dump_what
{
  regcache_dump_none, regcache_dump_raw, regcache_dump_cooked
};

static void
regcache_dump (struct regcache *regcache, struct ui_file *file,
	       enum regcache_dump_what what_to_dump)
{
  struct cleanup *cleanups = make_cleanup (null_cleanup, NULL);
  int regnum;
  int footnote_nr = 0;
  int footnote_register_size = 0;
  int footnote_register_offset = 0;
  int footnote_register_type_name_null = 0;
  long register_offset = 0;
  unsigned char *buf = alloca (regcache->descr->max_register_size);

#if 0
  fprintf_unfiltered (file, "legacy_p %d\n", regcache->descr->legacy_p);
  fprintf_unfiltered (file, "nr_raw_registers %d\n",
		      regcache->descr->nr_raw_registers);
  fprintf_unfiltered (file, "nr_cooked_registers %d\n",
		      regcache->descr->nr_cooked_registers);
  fprintf_unfiltered (file, "sizeof_raw_registers %ld\n",
		      regcache->descr->sizeof_raw_registers);
  fprintf_unfiltered (file, "sizeof_raw_register_valid_p %ld\n",
		      regcache->descr->sizeof_raw_register_valid_p);
  fprintf_unfiltered (file, "max_register_size %ld\n",
		      regcache->descr->max_register_size);
  fprintf_unfiltered (file, "NUM_REGS %d\n", NUM_REGS);
  fprintf_unfiltered (file, "NUM_PSEUDO_REGS %d\n", NUM_PSEUDO_REGS);
#endif

  gdb_assert (regcache->descr->nr_cooked_registers
	      == (NUM_REGS + NUM_PSEUDO_REGS));

  for (regnum = -1; regnum < regcache->descr->nr_cooked_registers; regnum++)
    {
      /* Name.  */
      if (regnum < 0)
	fprintf_unfiltered (file, " %-10s", "Name");
      else
	{
	  const char *p = REGISTER_NAME (regnum);
	  if (p == NULL)
	    p = "";
	  else if (p[0] == '\0')
	    p = "''";
	  fprintf_unfiltered (file, " %-10s", p);
	}

      /* Number.  */
      if (regnum < 0)
	fprintf_unfiltered (file, " %4s", "Nr");
      else
	fprintf_unfiltered (file, " %4d", regnum);

      /* Relative number.  */
      if (regnum < 0)
	fprintf_unfiltered (file, " %4s", "Rel");
      else if (regnum < NUM_REGS)
	fprintf_unfiltered (file, " %4d", regnum);
      else
	fprintf_unfiltered (file, " %4d", (regnum - NUM_REGS));

      /* Offset.  */
      if (regnum < 0)
	fprintf_unfiltered (file, " %6s  ", "Offset");
      else
	{
	  fprintf_unfiltered (file, " %6ld",
			      regcache->descr->register_offset[regnum]);
	  if (register_offset != regcache->descr->register_offset[regnum]
	      || register_offset != REGISTER_BYTE (regnum)
	      || (regnum > 0
		  && (regcache->descr->register_offset[regnum]
		      != (regcache->descr->register_offset[regnum - 1]
			  + regcache->descr->sizeof_register[regnum - 1])))
	      )
	    {
	      if (!footnote_register_offset)
		footnote_register_offset = ++footnote_nr;
	      fprintf_unfiltered (file, "*%d", footnote_register_offset);
	    }
	  else
	    fprintf_unfiltered (file, "  ");
	  register_offset = (regcache->descr->register_offset[regnum]
			     + regcache->descr->sizeof_register[regnum]);
	}

      /* Size.  */
      if (regnum < 0)
	fprintf_unfiltered (file, " %5s ", "Size");
      else
	{
	  fprintf_unfiltered (file, " %5ld",
			      regcache->descr->sizeof_register[regnum]);
	  if ((regcache->descr->sizeof_register[regnum]
	       != REGISTER_RAW_SIZE (regnum))
	      || (regcache->descr->sizeof_register[regnum]
		  != REGISTER_VIRTUAL_SIZE (regnum))
	      || (regcache->descr->sizeof_register[regnum]
		  != TYPE_LENGTH (register_type (regcache->descr->gdbarch,
						 regnum)))
	      )
	    {
	      if (!footnote_register_size)
		footnote_register_size = ++footnote_nr;
	      fprintf_unfiltered (file, "*%d", footnote_register_size);
	    }
	  else
	    fprintf_unfiltered (file, " ");
	}

      /* Type.  */
      if (regnum < 0)
	fprintf_unfiltered (file, " %-20s", "Type");
      else
	{
	  static const char blt[] = "builtin_type";
	  const char *t = TYPE_NAME (register_type (regcache->descr->gdbarch,
						    regnum));
	  if (t == NULL)
	    {
	      char *n;
	      if (!footnote_register_type_name_null)
		footnote_register_type_name_null = ++footnote_nr;
	      xasprintf (&n, "*%d", footnote_register_type_name_null);
	      make_cleanup (xfree, n);
	      t = n;
	    }
	  /* Chop a leading builtin_type.  */
	  if (strncmp (t, blt, strlen (blt)) == 0)
	    t += strlen (blt);
	  fprintf_unfiltered (file, " %-20s", t);
	}

      /* Value, raw.  */
      if (what_to_dump == regcache_dump_raw)
	{
	  if (regnum < 0)
	    fprintf_unfiltered (file, "Raw value");
	  else if (regnum >= regcache->descr->nr_raw_registers)
	    fprintf_unfiltered (file, "<cooked>");
	  else if (!regcache_valid_p (regcache, regnum))
	    fprintf_unfiltered (file, "<invalid>");
	  else
	    {
	      regcache_raw_read (regcache, regnum, buf);
	      fprintf_unfiltered (file, "0x");
	      dump_endian_bytes (file, TARGET_BYTE_ORDER, buf,
				 REGISTER_RAW_SIZE (regnum));
	    }
	}

      /* Value, cooked.  */
      if (what_to_dump == regcache_dump_cooked)
	{
	  if (regnum < 0)
	    fprintf_unfiltered (file, "Cooked value");
	  else
	    {
	      regcache_cooked_read (regcache, regnum, buf);
	      fprintf_unfiltered (file, "0x");
	      dump_endian_bytes (file, TARGET_BYTE_ORDER, buf,
				 REGISTER_VIRTUAL_SIZE (regnum));
	    }
	}

      fprintf_unfiltered (file, "\n");
    }

  if (footnote_register_size)
    fprintf_unfiltered (file, "*%d: Inconsistent register sizes.\n",
			footnote_register_size);
  if (footnote_register_offset)
    fprintf_unfiltered (file, "*%d: Inconsistent register offsets.\n",
			footnote_register_offset);
  if (footnote_register_type_name_null)
    fprintf_unfiltered (file, 
			"*%d: Register type's name NULL.\n",
			footnote_register_type_name_null);
  do_cleanups (cleanups);
}

static void
regcache_print (char *args, enum regcache_dump_what what_to_dump)
{
  if (args == NULL)
    regcache_dump (current_regcache, gdb_stdout, what_to_dump);
  else
    {
      struct ui_file *file = gdb_fopen (args, "w");
      if (file == NULL)
	perror_with_name ("maintenance print architecture");
      regcache_dump (current_regcache, file, what_to_dump);    
      ui_file_delete (file);
    }
}

static void
maintenance_print_registers (char *args, int from_tty)
{
  regcache_print (args, regcache_dump_none);
}

static void
maintenance_print_raw_registers (char *args, int from_tty)
{
  regcache_print (args, regcache_dump_raw);
}

static void
maintenance_print_cooked_registers (char *args, int from_tty)
{
  regcache_print (args, regcache_dump_cooked);
}

a1203 17

  add_cmd ("registers", class_maintenance,
	   maintenance_print_registers,
	   "Print the internal register configuration.\
Takes an optional file parameter.",
	   &maintenanceprintlist);
  add_cmd ("raw-registers", class_maintenance,
	   maintenance_print_raw_registers,
	   "Print the internal register configuration including raw values.\
Takes an optional file parameter.",
	   &maintenanceprintlist);
  add_cmd ("cooked-registers", class_maintenance,
	   maintenance_print_cooked_registers,
	   "Print the internal register configuration including cooked values.\
Takes an optional file parameter.",
	   &maintenanceprintlist);

@


1.36.4.4
log
@merge from mainline
@
text
@a28 1
#include "reggroups.h"
d607 1
a607 1
	deprecated_read_register_gen (regnum, reg_buf);
d751 1
a751 1
deprecated_read_register_gen (int regnum, char *buf)
d897 1
a897 1
deprecated_write_register_gen (int regnum, char *buf)
d950 1
a950 1
	deprecated_write_register_gen (regnum, myaddr + (regstart - myregstart));
d963 1
a963 1
	  deprecated_read_register_gen (regnum, regbuf);
d1150 1
a1150 1
  deprecated_read_register_gen (regnum, buf);
d1181 1
a1181 1
  deprecated_read_register_gen (regnum, buf);
d1215 1
a1215 1
  deprecated_write_register_gen (regnum, buf);
d1482 1
a1482 1
  regcache_dump_none, regcache_dump_raw, regcache_dump_cooked, regcache_dump_groups
a1489 2
  struct gdbarch *gdbarch = regcache->descr->gdbarch;
  struct reggroup *const *groups = reggroups (gdbarch);
d1596 21
a1616 26
      {
	const char *t;
	if (regnum < 0)
	  t = "Type";
	else
	  {
	    static const char blt[] = "builtin_type";
	    t = TYPE_NAME (register_type (regcache->descr->gdbarch, regnum));
	    if (t == NULL)
	      {
		char *n;
		if (!footnote_register_type_name_null)
		  footnote_register_type_name_null = ++footnote_nr;
		xasprintf (&n, "*%d", footnote_register_type_name_null);
		make_cleanup (xfree, n);
		t = n;
	      }
	    /* Chop a leading builtin_type.  */
	    if (strncmp (t, blt, strlen (blt)) == 0)
	      t += strlen (blt);
	  }
	fprintf_unfiltered (file, " %-15s", t);
      }

      /* Leading space always present.  */
      fprintf_unfiltered (file, " ");
a1649 20
      /* Group members.  */
      if (what_to_dump == regcache_dump_groups)
	{
	  if (regnum < 0)
	    fprintf_unfiltered (file, "Groups");
	  else
	    {
	      int i;
	      const char *sep = "";
	      for (i = 0; groups[i] != NULL; i++)
		{
		  if (gdbarch_register_reggroup_p (gdbarch, regnum, groups[i]))
		    {
		      fprintf_unfiltered (file, "%s%s", sep, reggroup_name (groups[i]));
		      sep = ",";
		    }
		}
	    }
	}

a1698 6
static void
maintenance_print_register_groups (char *args, int from_tty)
{
  regcache_print (args, regcache_dump_groups);
}

a1728 5
Takes an optional file parameter.",
	   &maintenanceprintlist);
  add_cmd ("register-groups", class_maintenance,
	   maintenance_print_register_groups,
	   "Print the internal register configuration including each register's group.\
@


1.36.2.1
log
@regbuf
@
text
@a28 1
#include "regbuf.h"
a35 6
/* Global structure containing the current regbuf.  */
/* FIXME: cagney/2002-05-11: The two global arrays registers[] and
   register_valid[] currently point into this structure.  */

struct regbuf *regcache_regbuf;

d758 26
a783 28
  regcache_regbuf = regbuf_xmalloc (current_gdbarch);
  registers = grub_around_regbuf_for_registers (regcache_regbuf);
  register_valid = grub_around_regbuf_for_register_valid (regcache_regbuf);
}

void
regcache_save (struct regbuf *regbuf)
{
  /* FIXME: cagney/2002-05-11: This assumes that the current
     architecture and the regbuf architecture are identical.  */
  char *regbuf_registers = grub_around_regbuf_for_registers (regbuf);
  char *regbuf_register_valid = grub_around_regbuf_for_register_valid (regbuf);
  memcpy (regbuf_registers, registers, REGISTER_BYTES);
  memcpy (regbuf_register_valid, register_valid, NUM_REGS + NUM_PSEUDO_REGS);
}

void
regcache_restore (struct regbuf *regbuf)
{
  char *regbuf_registers = grub_around_regbuf_for_registers (regbuf);
  write_register_bytes (0, regbuf_registers, REGISTER_BYTES);
}

void
regcache_restore_no_writethrough (struct regbuf *regbuf)
{
  char *regbuf_registers = grub_around_regbuf_for_registers (regbuf);
  memcpy (registers, regbuf_registers, REGISTER_BYTES);
a788 1
  REGISTER_GDBARCH_SWAP (regcache_regbuf);
@


1.36.2.2
log
@regbuf->regcache
@
text
@d2 2
a3 3

   Copyright 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000,
   2001, 2002 Free Software Foundation, Inc.
d29 1
d37 1
a37 193
/* Per-architecture object describing the layout of a register cache.
   Computed once when the architecture is created */

struct gdbarch_data *regcache_data_handle;

struct regcache_descr
{
  /* The architecture this descriptor belongs to.  */
  struct gdbarch *gdbarch;
  /* Total number of registers in the buffer.  */
  int nr_registers;
  /* Size of the register buffer, over-allocate making room for both
     real and pseudo-registers.  */
  /* FIXME: cagney/2002-05-11: This over-allocation shouldn't be
     necessary.  Unfortunatly, some targets store real values in
     pseudo-registers and we want to be sure those targets don't crash
     GDB.  Once that code has been trashed this can be pruned down to
     just raw registers.  */
  long sizeof_registers;
  /* Offset into the register buffer for each register.  */
  long *register_offset;
  /* Size, in bytes of the register valid array.  */
  long sizeof_register_valid_p;
  /* Size, in ``bytes'', of a register.  */
  long *sizeof_register;
};

static struct regcache_descr *
regcache_descr (struct gdbarch *gdbarch)
{
  int i;
  struct regcache_descr *descr;
  /* FIXME: cagney/2002-05-11: gdbarch_data() should take that
     ``gdbarch'' as a parameter.  */
  gdb_assert (gdbarch != NULL);

  descr = gdbarch_data (gdbarch, regcache_data_handle);
  if (descr != NULL)
    return descr;
  
  descr = XMALLOC (struct regcache_descr);
  descr->gdbarch = gdbarch;

  /* FIXME: cagney/2002-05-11: Shouldn't be including pseudo-registers
     in the register buffer.  Unfortunatly some architectures do.  */
  descr->nr_registers = NUM_REGS + NUM_PSEUDO_REGS;
  descr->sizeof_register_valid_p = NUM_REGS + NUM_PSEUDO_REGS;

  /* FIXME: cagney/2002-05-11: Instead of using REGISTER_BYTE() this
     code should compute the offets et.al. at runtime.  This currently
     isn't possible because some targets overlap register locations -
     see the mess in read_register_bytes() and write_register_bytes()
     registers.  */
  descr->sizeof_register = XCALLOC (descr->nr_registers, long);
  descr->register_offset = XCALLOC (descr->nr_registers, long);
  for (i = 0; i < descr->nr_registers; i++)
    {
      descr->register_offset[i] = REGISTER_BYTE (i);
      descr->sizeof_register[i] = REGISTER_RAW_SIZE (i);
    }

  /* Come up with the real size of the registers buffer.  */
  descr->sizeof_registers = REGISTER_BYTES; /* OK use.  */
  for (i = 0; i < descr->nr_registers; i++)
    {
      long regend;
      /* Keep extending the buffer so that there is always enough
         space for all registers.  The comparison is necessary since
         legacy code is free to put registers in random places in the
         buffer separated by holes.  Once REGISTER_BYTE() is killed
         this can be greatly simplified.  */
      /* FIXME: cagney/2001-12-04: This code shouldn't need to use
         REGISTER_BYTE().  Unfortunatly, legacy code likes to lay the
         buffer out so that certain registers just happen to overlap.
         Ulgh!  New targets use gdbarch's register read/write and
         entirely avoid this uglyness.  */
      regend = descr->register_offset[i] + descr->sizeof_register[i];
      if (descr->sizeof_registers < regend)
	descr->sizeof_registers = regend;
    }
  set_gdbarch_data (gdbarch, regcache_data_handle, descr);
  return descr;
}

static void
xfree_regcache_descr (struct gdbarch *gdbarch, void *ptr)
{
  struct regcache_descr *descr = ptr;
  if (descr == NULL)
    return;
  xfree (descr->register_offset);
  xfree (descr->sizeof_register);
  descr->register_offset = NULL;
  descr->sizeof_register = NULL;
  xfree (descr);
}

/* For moment, ``struct regcache'' is just a character buffer.  */

struct regcache
{
  struct regcache_descr *descr;
  char *registers;
  char *register_valid_p;
  /* If a value isn't in the cache should the corresponding target be
     queried for a value.  */
  int passthrough_p;
};

struct regcache *
regcache_xmalloc (struct gdbarch *gdbarch)
{
  struct regcache_descr *descr;
  struct regcache *regcache;
  gdb_assert (gdbarch != NULL);
  descr = regcache_descr (gdbarch);
  regcache = XMALLOC (struct regcache);
  regcache->descr = descr;
  regcache->registers = XCALLOC (descr->sizeof_registers, char);
  regcache->register_valid_p = XCALLOC (descr->sizeof_register_valid_p, char);
  regcache->passthrough_p = 0;
  return regcache;
}

void
regcache_xfree (struct regcache *regcache)
{
  if (regcache == NULL)
    return;
  xfree (regcache->registers);
  xfree (regcache->register_valid_p);
  xfree (regcache);
}

void
do_regcache_xfree (void *buf)
{
  regcache_xfree (buf);
}

struct regcache *
regcache_xmalloc_with_cleanup (struct gdbarch *gdbarch)
{
  struct regcache *regcache = regcache_xmalloc (gdbarch);
  make_cleanup (do_regcache_xfree, regcache);
  return regcache;
}

struct regcache *
regcache_dup (struct regcache *regcache)
{
  struct regcache *newbuf;
  gdb_assert (current_regcache != NULL);
  newbuf = regcache_xmalloc (regcache->descr->gdbarch);
  memcpy (newbuf->registers, regcache->registers,
	  regcache->descr->sizeof_registers);
  memcpy (newbuf->register_valid_p, regcache->register_valid_p,
	  regcache->descr->sizeof_register_valid_p);
  return newbuf;
}

int
regcache_valid_p (struct regcache *regcache, int regnum)
{
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_registers);
  return regcache->register_valid_p[regnum];
}

CORE_ADDR
regcache_read_as_address (struct regcache *regcache, int regnum)
{
  char *buf;
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  regcache_read (regcache, regnum, buf);
  return extract_address (buf, regcache->descr->sizeof_register[regnum]);
}

char *
grub_around_regcache_for_registers (struct regcache *regcache)
{
  return regcache->registers;
}

char *
grub_around_regcache_for_register_valid (struct regcache *regcache)
{
  return regcache->register_valid_p;
}

/* Global structure containing the current regcache.  */
d40 2
a41 1
struct regcache *current_regcache;
d326 1
a326 1
regcache_read (struct regcache *regcache, int regnum, char *buf)
d328 3
a330 13
  gdb_assert (regcache != NULL && buf != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_registers);
  if (regcache->passthrough_p)
    /* For moment, just use underlying legacy code. Ulgh!!! This
       silently and very indirectly updates the regcache's regcache via
       the global register_valid[].  */
    legacy_read_register_gen (regnum, buf);
  else
    {
      memcpy (buf, (regcache->registers
		    + regcache->descr->register_offset[regnum]),
	      regcache->descr->sizeof_register[regnum]);
    }
d385 1
a385 1
regcache_write (struct regcache *regcache, int regnum, char *buf)
d387 3
a389 13
  gdb_assert (regcache != NULL && buf != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_registers);
  if (regcache->passthrough_p)
    /* For moment, just use underlying legacy code. Ulgh!!! This
       silently and very indirectly updates the regcache's regcache via
       the global register_valid[].  */
    legacy_write_register_gen (regnum, buf);
  else
    {
      memcpy (regcache->registers + regcache->descr->register_offset[regnum], buf,
	      regcache->descr->sizeof_register[regnum]);
      regcache->register_valid_p[regnum] = 1;
    }
d765 3
a767 4
  current_regcache = regcache_xmalloc (current_gdbarch);
  current_regcache->passthrough_p = 1;
  registers = grub_around_regcache_for_registers (current_regcache);
  register_valid = grub_around_regcache_for_register_valid (current_regcache);
d771 1
a771 1
regcache_save (struct regcache *regcache)
d773 6
a778 8
  gdb_assert (current_regcache != NULL && regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == regcache->descr->gdbarch);
  memcpy (grub_around_regcache_for_registers (regcache),
	  grub_around_regcache_for_registers (current_regcache),
	  regcache->descr->sizeof_registers);
  memcpy (grub_around_regcache_for_register_valid (regcache),
	  grub_around_regcache_for_register_valid (current_regcache),
	  regcache->descr->sizeof_register_valid_p);
d782 1
a782 1
regcache_restore (struct regcache *regcache)
d784 2
a785 7
  char *regcache_registers;
  gdb_assert (current_regcache != NULL && regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == regcache->descr->gdbarch);
  regcache_registers = grub_around_regcache_for_registers (regcache);
  /* NOTE: cagney, this should be regcache->sizeof_registers but,
     again, things are screwed as it might copy pseudo registers.  */
  write_register_bytes (0, regcache_registers, REGISTER_BYTES);
d789 1
a789 1
regcache_restore_no_writethrough (struct regcache *regcache)
d791 2
a792 5
  char *regcache_registers;
  gdb_assert (current_regcache != NULL && regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == regcache->descr->gdbarch);
  regcache_registers = grub_around_regcache_for_registers (regcache);
  memcpy (registers, regcache_registers, REGISTER_BYTES);
d798 1
a798 2
  regcache_data_handle = register_gdbarch_data (NULL, xfree_regcache_descr);
  REGISTER_GDBARCH_SWAP (current_regcache);
@


1.36.2.3
log
@introduce regcache_move.
Fix cases where normal vs no_passthroug copies didn't reflect the old code.
@
text
@a184 52
void
regcache_move (struct regcache *dst, struct regcache *src)
{
  int i;
  char *buf = alloca (MAX_REGISTER_RAW_SIZE);
  gdb_assert (src != NULL && dst != NULL);
  gdb_assert (src->descr->gdbarch == dst->descr->gdbarch);
  /* FIXME: cagney/2002-05-17: To say this bit is bad is being polite.
     It keeps the existing code working where things rely on going
     through the register cache.  */
  if (src == current_regcache
      && !gdbarch_register_read_p (src->descr->gdbarch))
    {
      /* ULGH!!!!  Old way.  Use REGISTER bytes and let code below
	 untangle fetch.  */
      read_register_bytes (0, dst->registers, REGISTER_BYTES);
      return;
    }
  for (i = 0; i < current_regcache->descr->nr_registers; i++)
    {
      /* Should we worry about the valid bit here?  */
      regcache_read (src, i, buf);
      regcache_write (dst, i, buf);
    }
}

void
regcache_move_no_passthrough (struct regcache *dst, struct regcache *src)
{
  int i;
  gdb_assert (src != NULL && dst != NULL);
  gdb_assert (src->descr->gdbarch == dst->descr->gdbarch);
  /* NOTE: cagney/2002-05-17: Don't let the caller do a no-passthrough
     move of data into the current_regcache().  Doing this would be
     silly - it would mean that valid_p would be completly invalid.  */
  gdb_assert (dst != current_regcache);
  memcpy (dst->registers, src->registers,
	  dst->descr->sizeof_registers);
  memcpy (dst->register_valid_p, src->register_valid_p,
	  dst->descr->sizeof_register_valid_p);
}

struct regcache *
regcache_dup (struct regcache *src)
{
  struct regcache *newbuf;
  gdb_assert (current_regcache != NULL);
  newbuf = regcache_xmalloc (src->descr->gdbarch);
  regcache_move (newbuf, src);
  return newbuf;
}

d186 1
a186 1
regcache_dup_no_passthrough (struct regcache *src)
d190 5
a194 2
  newbuf = regcache_xmalloc (src->descr->gdbarch);
  regcache_move_no_passthrough (newbuf, src);
a984 2
  int i;
  char *buf = alloca (MAX_REGISTER_RAW_SIZE);
d987 6
a992 9
  regcache_move (regcache, current_regcache);
}

void
regcache_save_no_passthrough (struct regcache *regcache)
{
  gdb_assert (current_regcache != NULL && regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == regcache->descr->gdbarch);
  regcache_move_no_passthrough (regcache, current_regcache);
d998 1
a998 2
  int i;
  char *buf = alloca (MAX_REGISTER_RAW_SIZE);
d1001 4
a1004 1
  regcache_move (current_regcache, regcache);
d1008 1
a1008 1
regcache_restore_no_passthrough (struct regcache *regcache)
d1013 2
a1014 1
  regcache_move_no_passthrough (current_regcache, regcache);
@


1.36.2.4
log
@regcache_move()
@
text
@d186 1
a186 1
regcache_cpy (struct regcache *dst, struct regcache *src)
a191 1
  gdb_assert (src != dst);
a202 11
  /* FIXME: cagney/2002-05-17: To say this bit is bad is being polite.
     It keeps the existing code working where things rely on going
     through the register cache.  */
  if (dst == current_regcache
      && !gdbarch_register_read_p (dst->descr->gdbarch))
    {
      /* ULGH!!!!  Old way.  Use REGISTER bytes and let code below
	 untangle fetch.  */
      write_register_bytes (0, src->registers, REGISTER_BYTES);
      return;
    }
d212 1
a212 1
regcache_cpy_no_passthrough (struct regcache *dst, struct regcache *src)
d233 1
a233 1
  regcache_cpy (newbuf, src);
d243 1
a243 1
  regcache_cpy_no_passthrough (newbuf, src);
d1038 1
a1038 1
  regcache_cpy (regcache, current_regcache);
d1046 1
a1046 1
  regcache_cpy_no_passthrough (regcache, current_regcache);
d1056 1
a1056 1
  regcache_cpy (current_regcache, regcache);
d1065 1
a1065 1
  regcache_cpy_no_passthrough (current_regcache, regcache);
@


1.36.2.5
log
@* regcache.c (register_buffer): Add regcache parameter.  Update
callers.
(struct regcache_descr): Add nr_raw_registers and
max_register_size.  Add legacy_p.  Change registers to
raw_registers, register_valid_p to raw_register_valid_p.  Update
all callers.
(legacy_regcache_descr): New function handle legacy case.
(regcache_descr): Use legacy function.  For non-legacy case,
restrict the register cache to just NUM_REGS.
(regcache_read, regcache_write): When non-legacy case, implement
regcache read and write directly.
(regcache_write): Use regcache_valid_p.

* regcache.h (deprecated_grub_regcache_for_registers): Rename
grub_around_regcache_for_registers
(deprecated_grub_regcache_for_register_valid): Rename
grub_around_regcache_for_register_valid.
* regcache.c (deprecated_grub_around_regcache_for_registers)
(deprecated_grub_regcache_for_register_valid): Rename.
* rs6000-tdep.c (rs6000_extract_return_value): Update.
* regcache.c (build_regcache): Update.
@
text
@d46 11
a56 18

  /* Is this a ``legacy'' register cache?  Such caches reserve space
     for raw and pseudo registers and allow access to both.  */
  int legacy_p;

  /* The raw register cache.  This should contain just [0
     .. NUM_RAW_REGISTERS).  However, for older targets, it contains
     space for the full [0 .. NUM_RAW_REGISTERS +
     NUM_PSEUDO_REGISTERS).  */
  int nr_raw_registers;
  long sizeof_raw_registers;
  long sizeof_raw_register_valid_p;

  /* Offset, in bytes, of reach register in the raw register cache.
     Pseudo registers have an offset even though they don't
     (shouldn't) have a correspoinding space in the register cache.
     It is to keep existing code, that relies on
     write/write_register_bytes working.  */
d58 3
a60 7

  /* The cooked / frame / virtual register space.  The registers in
     the range [0..NR_RAW_REGISTERS) should be mapped directly onto
     the corresponding raw register.  The next [NR_RAW_REGISTERS
     .. NR_REGISTERS) should have been mapped, via
     gdbarch_register_read/write onto either raw registers or memory.  */
  int nr_registers;
a61 2
  long max_register_size;

d65 1
a65 1
legacy_regcache_descr (struct gdbarch *gdbarch)
a78 1
  descr->legacy_p = 1;
d83 1
a83 2
  descr->nr_raw_registers = descr->nr_registers;
  descr->sizeof_raw_register_valid_p = descr->nr_registers;
a91 1
  descr->max_register_size = 0;
a95 2
      if (descr->max_register_size < REGISTER_RAW_SIZE (i))
	descr->max_register_size = REGISTER_RAW_SIZE (i);
d99 1
a99 1
  descr->sizeof_raw_registers = REGISTER_BYTES; /* OK use.  */
d114 2
a115 2
      if (descr->sizeof_raw_registers < regend)
	descr->sizeof_raw_registers = regend;
a120 81
static struct regcache_descr *
regcache_descr (struct gdbarch *gdbarch)
{
  int i;
  struct regcache_descr *descr;
  gdb_assert (gdbarch != NULL);

  /* If the value has previously been computed, just return that.  */
  descr = gdbarch_data (gdbarch, regcache_data_handle);
  if (descr != NULL)
    return descr;
  
  /* If an old style architecture, construct the register cache
     description using all the register macros.  */
  if (!gdbarch_register_read_p (gdbarch)
      && !gdbarch_register_write_p (gdbarch))
    return legacy_regcache_descr (gdbarch);

  descr = XMALLOC (struct regcache_descr);
  descr->gdbarch = gdbarch;
  descr->legacy_p = 0;

  /* Total size of the register space.  The raw registers should
     directly map onto the raw register cache while the pseudo's are
     either mapped onto raw-registers or memory.  */
  descr->nr_registers = NUM_REGS + NUM_PSEUDO_REGS;

  /* Construct a strictly RAW register cache.  Don't allow pseudo's
     into the register cache.  */
  descr->nr_raw_registers = NUM_REGS;
  descr->sizeof_raw_register_valid_p = NUM_REGS;

  /* Lay out the register cache.  The pseud-registers are included in
     the layout even though their value isn't stored in the register
     cache.  Some code, via read_register_bytes() access a register
     using an offset/length rather than a register number.

     NOTE: cagney/2002-05-22: Only REGISTER_VIRTUAL_TYPE() needs to be
     used when constructing the register cache.  It is assumed that
     register raw size, virtual size and type length of the type are
     all the same.  */

  {
    long offset = 0;
    descr->sizeof_register = XCALLOC (descr->nr_registers, long);
    descr->register_offset = XCALLOC (descr->nr_registers, long);
    descr->max_register_size = 0;
    for (i = 0; i < descr->nr_registers; i++)
      {
	descr->sizeof_register[i] = TYPE_LENGTH (REGISTER_VIRTUAL_TYPE (i));
	descr->register_offset[i] = offset;
	offset += descr->sizeof_register[i];
	if (descr->max_register_size < descr->sizeof_register[i])
	  descr->max_register_size = descr->sizeof_register[i];
      }
    /* Set the real size of the register cache buffer.  */
    /* FIXME: cagney/2002-05-22: Should only need to allocate space
       for the raw registers.  Unfortunatly some code still accesses
       the register array directly using the global registers[].
       Until that code has been purged, play safe and over allocating
       the register buffer.  Ulgh!  */
    descr->sizeof_raw_registers = offset;
    /* = descr->register_offset[descr->nr_raw_registers]; */
  }

  set_gdbarch_data (gdbarch, regcache_data_handle, descr);

  /* Sanity check.  Confirm that the assumptions about gdbarch are
     true.  The REGCACHE_DATA_HANDLE is set before doing the checks so
     that targets using the generic methods supplied by regcache don't
     go into infinite recursion trying to, again, create the regcache.  */
  for (i = 0; i < descr->nr_registers; i++)
    {
      gdb_assert (descr->sizeof_register[i] == REGISTER_RAW_SIZE (i));
      gdb_assert (descr->sizeof_register[i] == REGISTER_VIRTUAL_SIZE (i));
      gdb_assert (descr->register_offset[i] == REGISTER_BYTE (i));
    }
  /* gdb_assert (descr->sizeof_raw_registers == REGISTER_BYTES (i));  */
  return descr;
}

d134 1
a134 1
/* The register cache for storing raw register values.  */
d139 2
a140 2
  char *raw_registers;
  char *raw_register_valid_p;
d155 2
a156 4
  regcache->raw_registers
    = XCALLOC (descr->sizeof_raw_registers, char);
  regcache->raw_register_valid_p
    = XCALLOC (descr->sizeof_raw_register_valid_p, char);
d166 2
a167 2
  xfree (regcache->raw_registers);
  xfree (regcache->raw_register_valid_p);
d189 1
a189 1
  char *buf;
d195 3
a197 2
     through to the register cache.  */
  if (src == current_regcache && src->descr->legacy_p)
d201 1
a201 1
      read_register_bytes (0, dst->raw_registers, REGISTER_BYTES);
d206 3
a208 2
     through to the register cache.  */
  if (dst == current_regcache && dst->descr->legacy_p)
d212 1
a212 1
      write_register_bytes (0, src->raw_registers, REGISTER_BYTES);
d215 1
a215 2
  buf = alloca (src->descr->max_register_size);
  for (i = 0; i < src->descr->nr_raw_registers; i++)
d233 4
a236 4
  memcpy (dst->raw_registers, src->raw_registers,
	  dst->descr->sizeof_raw_registers);
  memcpy (dst->raw_register_valid_p, src->raw_register_valid_p,
	  dst->descr->sizeof_raw_register_valid_p);
d263 2
a264 2
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  return regcache->raw_register_valid_p[regnum];
d272 1
a272 1
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
d279 1
a279 1
deprecated_grub_regcache_for_registers (struct regcache *regcache)
d281 1
a281 1
  return regcache->raw_registers;
d285 1
a285 1
deprecated_grub_regcache_for_register_valid (struct regcache *regcache)
d287 1
a287 1
  return regcache->raw_register_valid_p;
d359 1
a359 1
register_buffer (struct regcache *regcache, int regnum)
d361 2
a362 1
  return regcache->raw_registers + regcache->descr->register_offset[regnum];
d573 1
a573 1
  memcpy (myaddr, register_buffer (current_regcache, regnum),
d581 1
a581 15
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  if (regcache->descr->legacy_p
      && regcache->passthrough_p)
    {
      gdb_assert (regcache == current_regcache);
      /* For moment, just use underlying legacy code.  Ulgh!!! This
	 silently and very indirectly updates the regcache's regcache
	 via the global register_valid[].  */
      legacy_read_register_gen (regnum, buf);
      return;
    }
  /* Make certain that the register cache is up-to-date with respect
     to the current thread.  This switching shouldn't be necessary
     only there is still only one target side register cache.  Sigh!
     On the bright side, at least there is a regcache object.  */
d583 5
d589 3
a591 8
      gdb_assert (regcache == current_regcache);
      if (! ptid_equal (registers_ptid, inferior_ptid))
	{
	  registers_changed ();
	  registers_ptid = inferior_ptid;
	}
      if (!register_cached (regnum))
	fetch_register (regnum);
a592 4
  /* Copy the value directly into the register cache.  */
  memcpy (buf, (regcache->raw_registers
		+ regcache->descr->register_offset[regnum]),
	  regcache->descr->sizeof_register[regnum]);
d598 1
a598 3
  gdb_assert (current_regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == current_gdbarch);
  if (current_regcache->descr->legacy_p)
d634 1
a634 2
	  && (memcmp (register_buffer (current_regcache, regnum), myaddr, size)
	      == 0))
d640 1
a640 1
  memcpy (register_buffer (current_regcache, regnum), myaddr, size);
d650 7
a656 4
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);

  if (regcache->passthrough_p
      && regcache->descr->legacy_p)
d658 1
a658 19
      /* For moment, just use underlying legacy code.  Ulgh!!! This
	 silently and very indirectly updates the regcache's buffers
	 via the globals register_valid[] and registers[].  */
      gdb_assert (regcache == current_regcache);
      legacy_write_register_gen (regnum, buf);
      return;
    }

  /* On the sparc, writing %g0 is a no-op, so we don't even want to
     change the registers array if something writes to this register.  */
  if (CANNOT_STORE_REGISTER (regnum))
    return;

  /* Handle the simple case first -> not write through so just store
     value in cache.  */
  if (!regcache->passthrough_p)
    {
      memcpy ((regcache->raw_registers
	       + regcache->descr->register_offset[regnum]), buf,
d660 1
a660 2
      regcache->raw_register_valid_p[regnum] = 1;
      return;
a661 21

  /* Make certain that the correct cache is selected.  */
  gdb_assert (regcache == current_regcache);
  if (! ptid_equal (registers_ptid, inferior_ptid))
    {
      registers_changed ();
      registers_ptid = inferior_ptid;
    }

  /* If we have a valid copy of the register, and new value == old
     value, then don't bother doing the actual store. */
  if (regcache_valid_p (regcache, regnum)
      && (memcmp (register_buffer (regcache, regnum), buf,
		  regcache->descr->sizeof_register[regnum]) == 0))
    return;

  target_prepare_to_store ();
  memcpy (register_buffer (regcache, regnum), buf,
	  regcache->descr->sizeof_register[regnum]);
  regcache->raw_register_valid_p[regnum] = 1;
  store_register (regnum);
d667 1
a667 3
  gdb_assert (current_regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == current_gdbarch);
  if (current_regcache->descr->legacy_p)
d846 1
a846 1
    memcpy (register_buffer (current_regcache, regnum), val, 
d849 1
a849 1
    memset (register_buffer (current_regcache, regnum), '\000', 
d869 1
a869 2
  memcpy (buf, register_buffer (current_regcache, regnum),
	  REGISTER_RAW_SIZE (regnum));
d1039 2
a1040 2
  registers = deprecated_grub_regcache_for_registers (current_regcache);
  register_valid = deprecated_grub_regcache_for_register_valid (current_regcache);
d1047 1
d1065 1
@


1.36.2.6
log
@fixes for HEAD->branch merge.
@
text
@d77 2
a78 2
static void *
init_legacy_regcache_descr (struct gdbarch *gdbarch)
d86 4
d139 2
a140 2
static void *
init_regcache_descr (struct gdbarch *gdbarch)
d146 5
d155 1
a155 1
    return init_legacy_regcache_descr (gdbarch);
a219 6
static struct regcache_descr *
regcache_descr (struct gdbarch *gdbarch)
{
  return gdbarch_data (gdbarch, regcache_data_handle);
}

d1241 1
a1241 2
  regcache_data_handle = register_gdbarch_data (init_regcache_descr,
						xfree_regcache_descr);
@


1.36.2.7
log
@Merge with trunk.
@
text
@d2 3
a4 2
   Copyright 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000, 2001
   Free Software Foundation, Inc.
d37 355
d456 1
a456 1
register_buffer (int regnum)
d458 1
a458 2
  gdb_assert (regnum >= 0 && regnum < (NUM_REGS + NUM_PSEUDO_REGS));
  return &registers[REGISTER_BYTE (regnum)];
d669 1
a669 1
  memcpy (myaddr, register_buffer (regnum),
d674 1
a674 1
regcache_read (int rawnum, char *buf)
d676 31
a706 3
  gdb_assert (rawnum >= 0 && rawnum < (NUM_REGS + NUM_PSEUDO_REGS));
  /* For moment, just use underlying legacy code. Ulgh!!! */
  legacy_read_register_gen (rawnum, buf);
d712 3
a714 1
  if (! gdbarch_register_read_p (current_gdbarch))
d750 2
a751 1
	  && memcmp (register_buffer (regnum), myaddr, size) == 0)
d757 1
a757 1
  memcpy (register_buffer (regnum), myaddr, size);
d764 1
a764 1
regcache_write (int rawnum, char *buf)
d766 50
a815 3
  gdb_assert (rawnum >= 0 && rawnum < (NUM_REGS + NUM_PSEUDO_REGS));
  /* For moment, just use underlying legacy code. Ulgh!!! */
  legacy_write_register_gen (rawnum, buf);
d821 3
a823 1
  if (! gdbarch_register_write_p (current_gdbarch))
d1002 1
a1002 1
    memcpy (register_buffer (regnum), val, 
d1005 1
a1005 1
    memset (register_buffer (regnum), '\000', 
d1025 2
a1026 1
  memcpy (buf, register_buffer (regnum), REGISTER_RAW_SIZE (regnum));
d1194 26
d1221 12
a1232 25
  int sizeof_register_valid;
  /* Come up with the real size of the registers buffer.  */
  int sizeof_registers = REGISTER_BYTES; /* OK use.  */
  for (i = 0; i < NUM_REGS + NUM_PSEUDO_REGS; i++)
    {
      long regend;
      /* Keep extending the buffer so that there is always enough
         space for all registers.  The comparison is necessary since
         legacy code is free to put registers in random places in the
         buffer separated by holes.  Once REGISTER_BYTE() is killed
         this can be greatly simplified.  */
      /* FIXME: cagney/2001-12-04: This code shouldn't need to use
         REGISTER_BYTE().  Unfortunatly, legacy code likes to lay the
         buffer out so that certain registers just happen to overlap.
         Ulgh!  New targets use gdbarch's register read/write and
         entirely avoid this uglyness.  */
      regend = REGISTER_BYTE (i) + REGISTER_RAW_SIZE (i);
      if (sizeof_registers < regend)
	sizeof_registers = regend;
    }
  registers = xmalloc (sizeof_registers);
  sizeof_register_valid = ((NUM_REGS + NUM_PSEUDO_REGS)
			   * sizeof (*register_valid));
  register_valid = xmalloc (sizeof_register_valid);
  memset (register_valid, 0, sizeof_register_valid);
d1238 3
@


1.36.2.8
log
@More merging.
@
text
@d2 2
a3 3

   Copyright 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000,
   2001, 2002 Free Software Foundation, Inc.
a35 343
/* Per-architecture object describing the layout of a register cache.
   Computed once when the architecture is created */

struct gdbarch_data *regcache_descr_handle;

struct regcache_descr
{
  /* The architecture this descriptor belongs to.  */
  struct gdbarch *gdbarch;

  /* Is this a ``legacy'' register cache?  Such caches reserve space
     for raw and pseudo registers and allow access to both.  */
  int legacy_p;

  /* The raw register cache.  This should contain just [0
     .. NUM_RAW_REGISTERS).  However, for older targets, it contains
     space for the full [0 .. NUM_RAW_REGISTERS +
     NUM_PSEUDO_REGISTERS).  */
  int nr_raw_registers;
  long sizeof_raw_registers;
  long sizeof_raw_register_valid_p;

  /* Offset, in bytes, of reach register in the raw register cache.
     Pseudo registers have an offset even though they don't
     (shouldn't) have a correspoinding space in the register cache.
     It is to keep existing code, that relies on
     write/write_register_bytes working.  */
  long *register_offset;

  /* The cooked / frame / virtual register space.  The registers in
     the range [0..NR_RAW_REGISTERS) should be mapped directly onto
     the corresponding raw register.  The next [NR_RAW_REGISTERS
     .. NR_REGISTERS) should have been mapped, via
     gdbarch_register_read/write onto either raw registers or memory.  */
  int nr_registers;
  long *sizeof_register;
  long max_register_size;

};

static void *
init_legacy_regcache_descr (struct gdbarch *gdbarch)
{
  int i;
  struct regcache_descr *descr;
  /* FIXME: cagney/2002-05-11: gdbarch_data() should take that
     ``gdbarch'' as a parameter.  */
  gdb_assert (gdbarch != NULL);

  descr = XMALLOC (struct regcache_descr);
  descr->gdbarch = gdbarch;
  descr->legacy_p = 1;

  /* FIXME: cagney/2002-05-11: Shouldn't be including pseudo-registers
     in the register buffer.  Unfortunatly some architectures do.  */
  descr->nr_registers = NUM_REGS + NUM_PSEUDO_REGS;
  descr->nr_raw_registers = descr->nr_registers;
  descr->sizeof_raw_register_valid_p = descr->nr_registers;

  /* FIXME: cagney/2002-05-11: Instead of using REGISTER_BYTE() this
     code should compute the offets et.al. at runtime.  This currently
     isn't possible because some targets overlap register locations -
     see the mess in read_register_bytes() and write_register_bytes()
     registers.  */
  descr->sizeof_register = XCALLOC (descr->nr_registers, long);
  descr->register_offset = XCALLOC (descr->nr_registers, long);
  descr->max_register_size = 0;
  for (i = 0; i < descr->nr_registers; i++)
    {
      descr->register_offset[i] = REGISTER_BYTE (i);
      descr->sizeof_register[i] = REGISTER_RAW_SIZE (i);
      if (descr->max_register_size < REGISTER_RAW_SIZE (i))
	descr->max_register_size = REGISTER_RAW_SIZE (i);
    }

  /* Come up with the real size of the registers buffer.  */
  descr->sizeof_raw_registers = REGISTER_BYTES; /* OK use.  */
  for (i = 0; i < descr->nr_registers; i++)
    {
      long regend;
      /* Keep extending the buffer so that there is always enough
         space for all registers.  The comparison is necessary since
         legacy code is free to put registers in random places in the
         buffer separated by holes.  Once REGISTER_BYTE() is killed
         this can be greatly simplified.  */
      /* FIXME: cagney/2001-12-04: This code shouldn't need to use
         REGISTER_BYTE().  Unfortunatly, legacy code likes to lay the
         buffer out so that certain registers just happen to overlap.
         Ulgh!  New targets use gdbarch's register read/write and
         entirely avoid this uglyness.  */
      regend = descr->register_offset[i] + descr->sizeof_register[i];
      if (descr->sizeof_raw_registers < regend)
	descr->sizeof_raw_registers = regend;
    }
  return descr;
}

static void *
init_regcache_descr (struct gdbarch *gdbarch)
{
  int i;
  struct regcache_descr *descr;
  gdb_assert (gdbarch != NULL);

  /* If an old style architecture, construct the register cache
     description using all the register macros.  */
  if (!gdbarch_register_read_p (gdbarch)
      && !gdbarch_register_write_p (gdbarch))
    return init_legacy_regcache_descr (gdbarch);

  descr = XMALLOC (struct regcache_descr);
  descr->gdbarch = gdbarch;
  descr->legacy_p = 0;

  /* Total size of the register space.  The raw registers should
     directly map onto the raw register cache while the pseudo's are
     either mapped onto raw-registers or memory.  */
  descr->nr_registers = NUM_REGS + NUM_PSEUDO_REGS;

  /* Construct a strictly RAW register cache.  Don't allow pseudo's
     into the register cache.  */
  descr->nr_raw_registers = NUM_REGS;
  descr->sizeof_raw_register_valid_p = NUM_REGS;

  /* Lay out the register cache.  The pseud-registers are included in
     the layout even though their value isn't stored in the register
     cache.  Some code, via read_register_bytes() access a register
     using an offset/length rather than a register number.

     NOTE: cagney/2002-05-22: Only REGISTER_VIRTUAL_TYPE() needs to be
     used when constructing the register cache.  It is assumed that
     register raw size, virtual size and type length of the type are
     all the same.  */

  {
    long offset = 0;
    descr->sizeof_register = XCALLOC (descr->nr_registers, long);
    descr->register_offset = XCALLOC (descr->nr_registers, long);
    descr->max_register_size = 0;
    for (i = 0; i < descr->nr_registers; i++)
      {
	descr->sizeof_register[i] = TYPE_LENGTH (REGISTER_VIRTUAL_TYPE (i));
	descr->register_offset[i] = offset;
	offset += descr->sizeof_register[i];
	if (descr->max_register_size < descr->sizeof_register[i])
	  descr->max_register_size = descr->sizeof_register[i];
      }
    /* Set the real size of the register cache buffer.  */
    /* FIXME: cagney/2002-05-22: Should only need to allocate space
       for the raw registers.  Unfortunatly some code still accesses
       the register array directly using the global registers[].
       Until that code has been purged, play safe and over allocating
       the register buffer.  Ulgh!  */
    descr->sizeof_raw_registers = offset;
    /* = descr->register_offset[descr->nr_raw_registers]; */
  }

#if 0
  /* Sanity check.  Confirm that the assumptions about gdbarch are
     true.  The REGCACHE_DESCR_HANDLE is set before doing the checks
     so that targets using the generic methods supplied by regcache
     don't go into infinite recursion trying to, again, create the
     regcache.  */
  set_gdbarch_data (gdbarch, regcache_descr_handle, descr);
  for (i = 0; i < descr->nr_registers; i++)
    {
      gdb_assert (descr->sizeof_register[i] == REGISTER_RAW_SIZE (i));
      gdb_assert (descr->sizeof_register[i] == REGISTER_VIRTUAL_SIZE (i));
      gdb_assert (descr->register_offset[i] == REGISTER_BYTE (i));
    }
  /* gdb_assert (descr->sizeof_raw_registers == REGISTER_BYTES (i));  */
#endif

  return descr;
}

static struct regcache_descr *
regcache_descr (struct gdbarch *gdbarch)
{
  return gdbarch_data (gdbarch, regcache_descr_handle);
}

static void
xfree_regcache_descr (struct gdbarch *gdbarch, void *ptr)
{
  struct regcache_descr *descr = ptr;
  if (descr == NULL)
    return;
  xfree (descr->register_offset);
  xfree (descr->sizeof_register);
  descr->register_offset = NULL;
  descr->sizeof_register = NULL;
  xfree (descr);
}

/* The register cache for storing raw register values.  */

struct regcache
{
  struct regcache_descr *descr;
  char *raw_registers;
  char *raw_register_valid_p;
  /* If a value isn't in the cache should the corresponding target be
     queried for a value.  */
  int passthrough_p;
};

struct regcache *
regcache_xmalloc (struct gdbarch *gdbarch)
{
  struct regcache_descr *descr;
  struct regcache *regcache;
  gdb_assert (gdbarch != NULL);
  descr = regcache_descr (gdbarch);
  regcache = XMALLOC (struct regcache);
  regcache->descr = descr;
  regcache->raw_registers
    = XCALLOC (descr->sizeof_raw_registers, char);
  regcache->raw_register_valid_p
    = XCALLOC (descr->sizeof_raw_register_valid_p, char);
  regcache->passthrough_p = 0;
  return regcache;
}

void
regcache_xfree (struct regcache *regcache)
{
  if (regcache == NULL)
    return;
  xfree (regcache->raw_registers);
  xfree (regcache->raw_register_valid_p);
  xfree (regcache);
}

void
regcache_cpy (struct regcache *dst, struct regcache *src)
{
  int i;
  char *buf;
  gdb_assert (src != NULL && dst != NULL);
  gdb_assert (src->descr->gdbarch == dst->descr->gdbarch);
  gdb_assert (src != dst);
  /* FIXME: cagney/2002-05-17: To say this bit is bad is being polite.
     It keeps the existing code working where things rely on going
     through to the register cache.  */
  if (src == current_regcache && src->descr->legacy_p)
    {
      /* ULGH!!!!  Old way.  Use REGISTER bytes and let code below
	 untangle fetch.  */
      read_register_bytes (0, dst->raw_registers, REGISTER_BYTES);
      return;
    }
  /* FIXME: cagney/2002-05-17: To say this bit is bad is being polite.
     It keeps the existing code working where things rely on going
     through to the register cache.  */
  if (dst == current_regcache && dst->descr->legacy_p)
    {
      /* ULGH!!!!  Old way.  Use REGISTER bytes and let code below
	 untangle fetch.  */
      write_register_bytes (0, src->raw_registers, REGISTER_BYTES);
      return;
    }
  buf = alloca (src->descr->max_register_size);
  for (i = 0; i < src->descr->nr_raw_registers; i++)
    {
      /* Should we worry about the valid bit here?  */
      regcache_read (src, i, buf);
      regcache_write (dst, i, buf);
    }
}

void
regcache_cpy_no_passthrough (struct regcache *dst, struct regcache *src)
{
  int i;
  gdb_assert (src != NULL && dst != NULL);
  gdb_assert (src->descr->gdbarch == dst->descr->gdbarch);
  /* NOTE: cagney/2002-05-17: Don't let the caller do a no-passthrough
     move of data into the current_regcache().  Doing this would be
     silly - it would mean that valid_p would be completly invalid.  */
  gdb_assert (dst != current_regcache);
  memcpy (dst->raw_registers, src->raw_registers,
	  dst->descr->sizeof_raw_registers);
  memcpy (dst->raw_register_valid_p, src->raw_register_valid_p,
	  dst->descr->sizeof_raw_register_valid_p);
}

struct regcache *
regcache_dup (struct regcache *src)
{
  struct regcache *newbuf;
  gdb_assert (current_regcache != NULL);
  newbuf = regcache_xmalloc (src->descr->gdbarch);
  regcache_cpy (newbuf, src);
  return newbuf;
}

struct regcache *
regcache_dup_no_passthrough (struct regcache *src)
{
  struct regcache *newbuf;
  gdb_assert (current_regcache != NULL);
  newbuf = regcache_xmalloc (src->descr->gdbarch);
  regcache_cpy_no_passthrough (newbuf, src);
  return newbuf;
}

int
regcache_valid_p (struct regcache *regcache, int regnum)
{
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  return regcache->raw_register_valid_p[regnum];
}

CORE_ADDR
regcache_read_as_address (struct regcache *regcache, int regnum)
{
  char *buf;
  gdb_assert (regcache != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  buf = alloca (regcache->descr->sizeof_register[regnum]);
  regcache_read (regcache, regnum, buf);
  return extract_address (buf, regcache->descr->sizeof_register[regnum]);
}

char *
deprecated_grub_regcache_for_registers (struct regcache *regcache)
{
  return regcache->raw_registers;
}

char *
deprecated_grub_regcache_for_register_valid (struct regcache *regcache)
{
  return regcache->raw_register_valid_p;
}

/* Global structure containing the current regcache.  */
/* FIXME: cagney/2002-05-11: The two global arrays registers[] and
   register_valid[] currently point into this structure.  */
struct regcache *current_regcache;

d100 1
a100 1
register_buffer (struct regcache *regcache, int regnum)
d102 2
a103 1
  return regcache->raw_registers + regcache->descr->register_offset[regnum];
d314 1
a314 1
  memcpy (myaddr, register_buffer (current_regcache, regnum),
d319 1
a319 1
regcache_read (struct regcache *regcache, int regnum, char *buf)
d321 3
a323 31
  gdb_assert (regcache != NULL && buf != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);
  if (regcache->descr->legacy_p
      && regcache->passthrough_p)
    {
      gdb_assert (regcache == current_regcache);
      /* For moment, just use underlying legacy code.  Ulgh!!! This
	 silently and very indirectly updates the regcache's regcache
	 via the global register_valid[].  */
      legacy_read_register_gen (regnum, buf);
      return;
    }
  /* Make certain that the register cache is up-to-date with respect
     to the current thread.  This switching shouldn't be necessary
     only there is still only one target side register cache.  Sigh!
     On the bright side, at least there is a regcache object.  */
  if (regcache->passthrough_p)
    {
      gdb_assert (regcache == current_regcache);
      if (! ptid_equal (registers_ptid, inferior_ptid))
	{
	  registers_changed ();
	  registers_ptid = inferior_ptid;
	}
      if (!register_cached (regnum))
	fetch_register (regnum);
    }
  /* Copy the value directly into the register cache.  */
  memcpy (buf, (regcache->raw_registers
		+ regcache->descr->register_offset[regnum]),
	  regcache->descr->sizeof_register[regnum]);
d329 1
a329 3
  gdb_assert (current_regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == current_gdbarch);
  if (current_regcache->descr->legacy_p)
d365 1
a365 2
	  && (memcmp (register_buffer (current_regcache, regnum), myaddr, size)
	      == 0))
d371 1
a371 1
  memcpy (register_buffer (current_regcache, regnum), myaddr, size);
d378 1
a378 1
regcache_write (struct regcache *regcache, int regnum, char *buf)
d380 3
a382 50
  gdb_assert (regcache != NULL && buf != NULL);
  gdb_assert (regnum >= 0 && regnum < regcache->descr->nr_raw_registers);

  if (regcache->passthrough_p
      && regcache->descr->legacy_p)
    {
      /* For moment, just use underlying legacy code.  Ulgh!!! This
	 silently and very indirectly updates the regcache's buffers
	 via the globals register_valid[] and registers[].  */
      gdb_assert (regcache == current_regcache);
      legacy_write_register_gen (regnum, buf);
      return;
    }

  /* On the sparc, writing %g0 is a no-op, so we don't even want to
     change the registers array if something writes to this register.  */
  if (CANNOT_STORE_REGISTER (regnum))
    return;

  /* Handle the simple case first -> not write through so just store
     value in cache.  */
  if (!regcache->passthrough_p)
    {
      memcpy ((regcache->raw_registers
	       + regcache->descr->register_offset[regnum]), buf,
	      regcache->descr->sizeof_register[regnum]);
      regcache->raw_register_valid_p[regnum] = 1;
      return;
    }

  /* Make certain that the correct cache is selected.  */
  gdb_assert (regcache == current_regcache);
  if (! ptid_equal (registers_ptid, inferior_ptid))
    {
      registers_changed ();
      registers_ptid = inferior_ptid;
    }

  /* If we have a valid copy of the register, and new value == old
     value, then don't bother doing the actual store. */
  if (regcache_valid_p (regcache, regnum)
      && (memcmp (register_buffer (regcache, regnum), buf,
		  regcache->descr->sizeof_register[regnum]) == 0))
    return;

  target_prepare_to_store ();
  memcpy (register_buffer (regcache, regnum), buf,
	  regcache->descr->sizeof_register[regnum]);
  regcache->raw_register_valid_p[regnum] = 1;
  store_register (regnum);
d388 1
a388 3
  gdb_assert (current_regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == current_gdbarch);
  if (current_regcache->descr->legacy_p)
d567 1
a567 1
    memcpy (register_buffer (current_regcache, regnum), val, 
d570 1
a570 1
    memset (register_buffer (current_regcache, regnum), '\000', 
d590 1
a590 2
  memcpy (buf, register_buffer (current_regcache, regnum),
	  REGISTER_RAW_SIZE (regnum));
a757 9
  current_regcache = regcache_xmalloc (current_gdbarch);
  current_regcache->passthrough_p = 1;
  registers = deprecated_grub_regcache_for_registers (current_regcache);
  register_valid = deprecated_grub_regcache_for_register_valid (current_regcache);
}

void
regcache_save (struct regcache *regcache)
{
d759 25
a783 29
  gdb_assert (current_regcache != NULL && regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == regcache->descr->gdbarch);
  regcache_cpy (regcache, current_regcache);
}

void
regcache_save_no_passthrough (struct regcache *regcache)
{
  gdb_assert (current_regcache != NULL && regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == regcache->descr->gdbarch);
  regcache_cpy_no_passthrough (regcache, current_regcache);
}

void
regcache_restore (struct regcache *regcache)
{
  int i;
  gdb_assert (current_regcache != NULL && regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == regcache->descr->gdbarch);
  regcache_cpy (current_regcache, regcache);
}

void
regcache_restore_no_passthrough (struct regcache *regcache)
{
  char *regcache_registers;
  gdb_assert (current_regcache != NULL && regcache != NULL);
  gdb_assert (current_regcache->descr->gdbarch == regcache->descr->gdbarch);
  regcache_cpy_no_passthrough (current_regcache, regcache);
a788 3
  regcache_descr_handle = register_gdbarch_data (init_regcache_descr,
						 xfree_regcache_descr);
  REGISTER_GDBARCH_SWAP (current_regcache);
@


1.36.2.9
log
@merge with trunk
@
text
@d1189 35
@


1.36.2.10
log
@merge with trunk
@
text
@d1006 1
a1006 2
  DEPRECATED_CLEAN_UP_REGISTER_VALUE \
    (regnum, register_buffer (current_regcache, regnum));
@


1.35
log
@* config/m88k/tm-m88k.h: Update copyright.
(m88k_target_write_pc): Declare
(TARGET_WRITE_PC): Redefine using m88k_target_write_pc.
(M88K_NNPC_REGNUM): Rename NNPC_REGNUM.
(SHIFT_INST_REGS): Update definition.
* m88k-tdep.c (m88k_target_write_pc): New function.  Implement
using old definition of TARGET_WRITE_PC.
* regcache.c (generic_target_write_pc): Delete code handling
NNPC_REGNUM.
* gdbarch.sh (NNPC_REGNUM): Delete.
* gdbarch.h, gdbarch.c: Regenerate.

* gdbint.texinfo (Target Architecture Definition): Delete
documentation on NNPC_REGNUM.
@
text
@d48 7
a54 1
   "Not available" means don't try to fetch it again.  */
@


1.34
log
@* h8500-tdep.c (h8500_write_fp): Delete function.
* dwarf2cfi.c (cfi_write_fp): Document as not used.
* mips-tdep.c (mips_gdbarch_init): Do not set write_fp.
* ia64-tdep.c (ia64_gdbarch_init): Do not set write_fp.
* m68hc11-tdep.c (m68hc11_gdbarch_init): Do not set write_fp.
* rs6000-tdep.c (rs6000_gdbarch_init): Do not set write_fp.
* s390-tdep.c (s390_gdbarch_init): Do not set write_fp.
(s390_write_fp):
* sh-tdep.c (sh_gdbarch_init): Do not set write_fp.
* x86-64-tdep.c (i386_gdbarch_init): Do not set write_fp.
* d10v-tdep.c (d10v_gdbarch_init): Do not set write_fp.
(d10v_write_fp): Delete function.
* inferior.h (write_fp, generic_target_write_fp): Delete
declarations.
* regcache.c (generic_target_write_fp): Delete function.
(write_fp): Delete function.
* gdbarch.sh (TARGET_WRITE_FP): Delete.
* gdbarch.h, gdbarch.c: Regenerate.
* config/v850/tm-v850.h (TARGET_WRITE_FP): Delete macro.
* config/sparc/tm-sp64.h (TARGET_WRITE_FP): Delete macro.
(sparc64_write_fp): Delete declaration.
* config/h8500/tm-h8500.h (TARGET_WRITE_FP): Delete macro.
(h8500_write_fp): Delete declaration.
@
text
@a656 2
  if (NNPC_REGNUM >= 0)
    write_register_pid (NNPC_REGNUM, pc + 8, ptid);
@


1.33
log
@2002-03-20  Martin M. Hunt  <hunt@@redhat.com>

	* regcache.c (_initialize_regcache): No need to call
	build_regcache() at this time; it gets called whenever
	the gdbarch changes.
@
text
@d588 2
a589 2
/* read_pc, write_pc, read_sp, write_sp, read_fp, write_fp, etc.
   Special handling for registers PC, SP, and FP.  */
d594 4
a597 4
   generic_target_write_sp(), write_sp(), generic_target_read_fp(),
   read_fp(), generic_target_write_fp(), write_fp will eventually be
   moved out of the reg-cache into either frame.[hc] or to the
   multi-arch framework.  The are not part of the raw register cache.  */
a738 20
}

void
generic_target_write_fp (CORE_ADDR val)
{
#ifdef FP_REGNUM
  if (FP_REGNUM >= 0)
    {
      write_register (FP_REGNUM, val);
      return;
    }
#endif
  internal_error (__FILE__, __LINE__,
		  "generic_target_write_fp");
}

void
write_fp (CORE_ADDR val)
{
  TARGET_WRITE_FP (val);
@


1.32
log
@2002-02-05  Michael Snyder  <msnyder@@redhat.com>

	* regcache.c (fetch_register): Call target_fetch_register
	only if we don't call FETCH_PSEUDO_REGISTER.
	(store_register): Call target_store_register only if we
	don't call STORE_PSEUDO_REGISTER.
@
text
@a804 2
  build_regcache ();

@


1.31
log
@2002-01-28  Michael Snyder  <msnyder@@redhat.com>

	* regcache.c (legacy_read_register_gen): Need to be able to
	read pseudo-register as well as real register.
	(legacy_write_register_gen): Ditto.
@
text
@d128 2
a129 1
  target_fetch_registers (regnum);
d144 2
a145 1
  target_store_registers (regnum);
@


1.30
log
@* config/pa/tm-hppa.h (DEPRECATED_CLEAN_UP_REGISTER_VALUE): Rename
CLEAN_UP_REGISTER_VALUE.
* regcache.c (supply_register): Update only call.
@
text
@d313 1
a313 1
  gdb_assert (rawnum >= 0 && rawnum < NUM_REGS);
d372 1
a372 1
  gdb_assert (rawnum >= 0 && rawnum < NUM_REGS);
@


1.29
log
@Zap stray XCALLOC().
@
text
@d574 2
a575 2
#ifdef CLEAN_UP_REGISTER_VALUE
  CLEAN_UP_REGISTER_VALUE (regnum, register_buffer (regnum));
@


1.28
log
@Expand the regcache so that there is space for pseudo-registers.
@
text
@a768 3
#undef XCALLOC
#define XCALLOC(NR,TYPE) ((TYPE*) xcalloc ((NR), sizeof (TYPE)))

@


1.27
log
@* TODO (register_buffer): Delete.
* regcache.c (register_buffer): Make static.
(regcache_collect): New function.
* regcache.h (register_buffer): Delete declaration.
(regcache_collect): Declare.
* remote.c (store_register_using_P): Rewrite using
regcache_collect.
(remote_store_registers): Ditto.
* go32-nat.c (store_register): Ditto.
@
text
@d96 2
a97 4
  if (regnum < 0)
    return registers;
  else
    return &registers[REGISTER_BYTE (regnum)];
d121 6
a126 3
  if (real_register (regnum))
    target_fetch_registers (regnum);
  else if (pseudo_register (regnum))
d128 1
d136 6
a141 3
  if (real_register (regnum))
    target_store_registers (regnum);
  else if (pseudo_register (regnum))
d143 1
d171 1
a171 6
  for (i = 0; i < NUM_REGS; i++)
    set_register_cached (i, 0);

  /* Assume that if all the hardware regs have changed, 
     then so have the pseudo-registers.  */
  for (i = NUM_REGS; i < NUM_REGS + NUM_PSEUDO_REGS; i++)
d182 7
d198 1
a198 1
     Fetching all real regs might not account for all pseudo-regs.  */
d769 2
d775 21
a795 5
  /* We allocate some extra slop since we do a lot of memcpy's around
     `registers', and failing-soft is better than failing hard.  */
  int sizeof_registers = REGISTER_BYTES + /* SLOP */ 256;
  int sizeof_register_valid = 
    (NUM_REGS + NUM_PSEUDO_REGS) * sizeof (*register_valid);
d797 2
a798 1
  memset (registers, 0, sizeof_registers);
@


1.26
log
@* regcache.c (read_register_bytes): When REGISTER_NAME indicates
that a register should be ignored, supply a value for the register
from the raw registers[] buffer.
@
text
@d93 1
a93 1
char *
d570 7
@


1.25
log
@2001-08-10  Michael Snyder  <msnyder@@redhat.com>

	* regcache.c (legacy_write_register_gen): Don't 'optimize out'
        a write_register to a pseudo-reg.  Target_store_pseudo_register
        needs to get called, because these regs may be computed and may
        have side-effects.
@
text
@a232 3
      if (REGISTER_NAME (regnum) == NULL || *REGISTER_NAME (regnum) == '\0')
	continue;

d241 12
a252 2
      /* Force the cache to fetch the entire register. */
      read_register_gen (regnum, reg_buf);
@


1.24
log
@Multi-arch CANNOT_FETCH_REGISTER() and CANNOT_STORE_REGISTER().
@
text
@a336 7
  /* If we have a valid copy of the register, and new value == old value,
     then don't bother doing the actual store. */

  if (register_cached (regnum)
      && memcmp (register_buffer (regnum), myaddr, size) == 0)
    return;

d338 9
a346 1
    target_prepare_to_store ();
@


1.24.4.1
log
@* regcache.c (read_register_bytes): When REGISTER_NAME indicates
that a register should be ignored, supply a value for the register
from the raw registers[] buffer.
@
text
@d233 3
d244 2
a245 12
      if (REGISTER_NAME (regnum) != NULL && *REGISTER_NAME (regnum) != '\0')
	/* Force the cache to fetch the entire register.  */
	read_register_gen (regnum, reg_buf);
      else
	/* Legacy note: even though this register is ``invalid'' we
           still need to return something.  It would appear that some
           code relies on apparent gaps in the register array also
           being returned.  */
	/* FIXME: cagney/2001-08-18: This is just silly.  It defeats
           the entire register read/write flow of control.  Must
           resist temptation to return 0xdeadbeef.  */
	memcpy (reg_buf, registers + reg_start, reg_len);
@


1.23
log
@Phase 1 of the ptid_t changes.
@
text
@a317 5
/* Registers we shouldn't try to store.  */
#if !defined (CANNOT_STORE_REGISTER)
#define CANNOT_STORE_REGISTER(regnum) 0
#endif

@


1.22
log
@* arch-utils.c (#include "gdbthread.h"): Removed.
(#include "symfile.h"): Removed.
(XMALLOC): Removed unused macro.
* breakpoint.c (tbreak_command): Removed local declaration.
(awatch_command, do_enable_breakpoint, set_breakpoint_count):
Remove duplicate declarations.
(bpstat_should_step, bpstat_have_active_hw_watchpoints)
(remove_solib_event_breakpoints): Fix indentation botch.
* c-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* ch-exp.c (ch_terminal_match_float_literal, parse_expr)
(parse_primval, parse_untyped_expr, parse_opt_untyped_expr):
Removed duplicate declarations.
* ch-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* corefile.c (#include "frame.h"): Removed
(#include "symfile.h"): Removed.
(#include "language.h"): Removed.
* dbxread.c (#include "command.h"): Removed.
* environ.c (#include "gdbcore.h"): Removed.
* event-loop.c (#include "top.h"): Removed.
* f-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
(#include "typeprint.h"): Removed.
(#include "frame.h"): Removed.
* gdbtypes.h (print_type_scalar): Removed declaration.
* infcmd.c (#include "completer.h"): Removed.
* language.c (#include "frame.h"): Removed.
* m2-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
(#include "language.h"): Removed.
* m2-valprint.c (#include "valprint.h"): Removed.
* p-typeprint.c (#include "command.h"): Removed.
(#include "gdbcmd.h"): Removed.
* p-valprint.c (#include "typeprint.h"): Removed.
* parse.c (#include "linespec.h"): Removed.
* regcache.c (#include "frame.h"): Removed.
* remote.c (#include "frame.h"): Removed.
(getpkt_sane): Make static.
* source.c (#include "completer.h"): Removed.
* stack.c (#include "symfile.h"): Removed.
(#include "objfiles.h"): Removed.
* symfile.c (#include "completer.h"): Removed.
* tracepoint.c (#include "completer.h"): Removed.
* values.c (#include "frame.h"): Removed.
* varobj.c (#include "valprint.h"): Removed.
* wrapper.c (#include "frame.h"): Removed.

* memattr.c (create_mem_region): Removed unused variable.
* remote-nrom.c: Removed spurious semicolon after init_nrom_ops.
-------------------------------------------------------------------
@
text
@d52 1
a52 2
/* The thread/process associated with the current set of registers.
   For now, -1 is special, and means `no current process'.  */
d54 1
a54 1
static int registers_pid = -1;
d156 1
a156 1
  registers_pid = -1;
d282 1
a282 1
  if (registers_pid != inferior_pid)
d285 1
a285 1
      registers_pid = inferior_pid;
d334 1
a334 1
  if (registers_pid != inferior_pid)
d337 1
a337 1
      registers_pid = inferior_pid;
d442 1
a442 1
read_register_pid (int regnum, int pid)
d444 1
d448 1
a448 1
  if (pid == inferior_pid)
d451 1
a451 1
  save_pid = inferior_pid;
d453 1
a453 1
  inferior_pid = pid;
d457 1
a457 1
  inferior_pid = save_pid;
d473 1
a473 1
read_signed_register_pid (int regnum, int pid)
d475 1
a475 1
  int save_pid;
d478 1
a478 1
  if (pid == inferior_pid)
d481 1
a481 1
  save_pid = inferior_pid;
d483 1
a483 1
  inferior_pid = pid;
d487 1
a487 1
  inferior_pid = save_pid;
d506 1
a506 1
write_register_pid (int regnum, CORE_ADDR val, int pid)
d508 1
a508 1
  int save_pid;
d510 1
a510 1
  if (pid == inferior_pid)
d516 1
a516 1
  save_pid = inferior_pid;
d518 1
a518 1
  inferior_pid = pid;
d522 1
a522 1
  inferior_pid = save_pid;
d539 1
a539 1
  if (registers_pid != inferior_pid)
d542 1
a542 1
      registers_pid = inferior_pid;
d593 1
a593 1
generic_target_read_pc (int pid)
d598 1
a598 1
      CORE_ADDR pc_val = ADDR_BITS_REMOVE ((CORE_ADDR) read_register_pid (PC_REGNUM, pid));
d608 1
a608 1
read_pc_pid (int pid)
d610 1
a610 1
  int saved_inferior_pid;
d613 3
a615 3
  /* In case pid != inferior_pid. */
  saved_inferior_pid = inferior_pid;
  inferior_pid = pid;
d617 1
a617 1
  pc_val = TARGET_READ_PC (pid);
d619 1
a619 1
  inferior_pid = saved_inferior_pid;
d626 1
a626 1
  return read_pc_pid (inferior_pid);
d630 1
a630 1
generic_target_write_pc (CORE_ADDR pc, int pid)
d634 1
a634 1
    write_register_pid (PC_REGNUM, pc, pid);
d636 1
a636 1
    write_register_pid (NPC_REGNUM, pc + 4, pid);
d638 1
a638 1
    write_register_pid (NNPC_REGNUM, pc + 8, pid);
d646 1
a646 1
write_pc_pid (CORE_ADDR pc, int pid)
d648 1
a648 1
  int saved_inferior_pid;
d650 3
a652 3
  /* In case pid != inferior_pid. */
  saved_inferior_pid = inferior_pid;
  inferior_pid = pid;
d654 1
a654 1
  TARGET_WRITE_PC (pc, pid);
d656 1
a656 1
  inferior_pid = saved_inferior_pid;
d662 1
a662 1
  write_pc_pid (pc, inferior_pid);
d777 4
@


1.21
log
@Re-vamp the register code so that a lot more is routed through
{read,write}_register_gen.  Hook that function with multi-arch.
@
text
@a22 1
#include "frame.h"
@


1.20
log
@Eliminate ARCH_NUM_REGS.
@
text
@d29 1
d217 1
a217 1
read_register_bytes (int inregbyte, char *myaddr, int inlen)
d219 1
a219 1
  int inregend = inregbyte + inlen;
d221 1
a221 6

  if (registers_pid != inferior_pid)
    {
      registers_changed ();
      registers_pid = inferior_pid;
    }
d228 6
a233 1
      int regstart, regend;
d235 1
a235 1
      if (register_cached (regnum))
d238 6
a243 1
      if (REGISTER_NAME (regnum) == NULL || *REGISTER_NAME (regnum) == '\0')
d246 2
a247 2
      regstart = REGISTER_BYTE (regnum);
      regend = regstart + REGISTER_RAW_SIZE (regnum);
d249 4
a252 2
      if (regend <= inregbyte || inregend <= regstart)
	/* The range the user wants to read doesn't overlap with regnum.  */
d255 11
a265 3
      /* We've found an uncached register where at least one byte will be read.
         Update it from the target.  */
      fetch_register (regnum);
d267 2
a268 1
      if (!register_cached (regnum))
d270 1
a270 6
	  /* Sometimes pseudoregs are never marked valid, so that they 
	     will be fetched every time (it can be complicated to know
	     if a pseudoreg is valid, while "fetching" them can be cheap). 
	     */
	  if (regnum < NUM_REGS)
 	    error ("read_register_bytes:  Couldn't update register %d.", regnum);
a272 3

  if (myaddr != NULL)
    memcpy (myaddr, register_buffer (-1) + inregbyte, inlen);
d280 2
a281 2
void
read_register_gen (int regnum, char *myaddr)
d283 1
d297 20
d325 2
a326 2
void
write_register_gen (int regnum, char *myaddr)
d329 1
d360 19
d438 3
a440 11
  if (registers_pid != inferior_pid)
    {
      registers_changed ();
      registers_pid = inferior_pid;
    }

  if (!register_cached (regnum))
    fetch_register (regnum);

  return (extract_unsigned_integer (register_buffer (regnum),
				    REGISTER_RAW_SIZE (regnum)));
d468 3
a470 11
  if (registers_pid != inferior_pid)
    {
      registers_changed ();
      registers_pid = inferior_pid;
    }

  if (!register_cached (regnum))
    fetch_register (regnum);

  return (extract_signed_integer (register_buffer (regnum),
				  REGISTER_RAW_SIZE (regnum)));
d498 1
a498 1
  PTR buf;
a499 12

  /* On the sparc, writing %g0 is a no-op, so we don't even want to
     change the registers array if something writes to this register.  */
  if (CANNOT_STORE_REGISTER (regnum))
    return;

  if (registers_pid != inferior_pid)
    {
      registers_changed ();
      registers_pid = inferior_pid;
    }

d503 1
a503 15

  /* If we have a valid copy of the register, and new value == old value,
     then don't bother doing the actual store. */

  if (register_cached (regnum)
      && memcmp (register_buffer (regnum), buf, size) == 0)
    return;

  if (real_register (regnum))
    target_prepare_to_store ();

  memcpy (register_buffer (regnum), buf, size);

  set_register_cached (regnum, 1);
  store_register (regnum);
d557 6
@


1.19
log
@Update/correct copyright notices.
@
text
@d166 1
a166 1
  for (i = 0; i < ARCH_NUM_REGS; i++)
d188 1
a188 1
  for (i = 0; i < ARCH_NUM_REGS; i++)
@


1.18
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 1
a2 1
   Copyright 1986, 87, 89, 91, 94, 95, 96, 1998, 2000, 2001
@


1.17
log
@Move frame specific register code to the new file frame.c.
@
text
@d28 1
d557 8
@


1.16
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@a139 199
/* FIND_SAVED_REGISTER ()

   Return the address in which frame FRAME's value of register REGNUM
   has been saved in memory.  Or return zero if it has not been saved.
   If REGNUM specifies the SP, the value we return is actually
   the SP value, not an address where it was saved.  */

CORE_ADDR
find_saved_register (struct frame_info *frame, int regnum)
{
  register struct frame_info *frame1 = NULL;
  register CORE_ADDR addr = 0;

  if (frame == NULL)		/* No regs saved if want current frame */
    return 0;

#ifdef HAVE_REGISTER_WINDOWS
  /* We assume that a register in a register window will only be saved
     in one place (since the name changes and/or disappears as you go
     towards inner frames), so we only call get_frame_saved_regs on
     the current frame.  This is directly in contradiction to the
     usage below, which assumes that registers used in a frame must be
     saved in a lower (more interior) frame.  This change is a result
     of working on a register window machine; get_frame_saved_regs
     always returns the registers saved within a frame, within the
     context (register namespace) of that frame. */

  /* However, note that we don't want this to return anything if
     nothing is saved (if there's a frame inside of this one).  Also,
     callers to this routine asking for the stack pointer want the
     stack pointer saved for *this* frame; this is returned from the
     next frame.  */

  if (REGISTER_IN_WINDOW_P (regnum))
    {
      frame1 = get_next_frame (frame);
      if (!frame1)
	return 0;		/* Registers of this frame are active.  */

      /* Get the SP from the next frame in; it will be this
         current frame.  */
      if (regnum != SP_REGNUM)
	frame1 = frame;

      FRAME_INIT_SAVED_REGS (frame1);
      return frame1->saved_regs[regnum];	/* ... which might be zero */
    }
#endif /* HAVE_REGISTER_WINDOWS */

  /* Note that this next routine assumes that registers used in
     frame x will be saved only in the frame that x calls and
     frames interior to it.  This is not true on the sparc, but the
     above macro takes care of it, so we should be all right. */
  while (1)
    {
      QUIT;
      frame1 = get_prev_frame (frame1);
      if (frame1 == 0 || frame1 == frame)
	break;
      FRAME_INIT_SAVED_REGS (frame1);
      if (frame1->saved_regs[regnum])
	addr = frame1->saved_regs[regnum];
    }

  return addr;
}

/* DEFAULT_GET_SAVED_REGISTER ()

   Find register number REGNUM relative to FRAME and put its (raw,
   target format) contents in *RAW_BUFFER.  Set *OPTIMIZED if the
   variable was optimized out (and thus can't be fetched).  Set *LVAL
   to lval_memory, lval_register, or not_lval, depending on whether
   the value was fetched from memory, from a register, or in a strange
   and non-modifiable way (e.g. a frame pointer which was calculated
   rather than fetched).  Set *ADDRP to the address, either in memory
   on as a REGISTER_BYTE offset into the registers array.

   Note that this implementation never sets *LVAL to not_lval.  But
   it can be replaced by defining GET_SAVED_REGISTER and supplying
   your own.

   The argument RAW_BUFFER must point to aligned memory.  */

static void
default_get_saved_register (char *raw_buffer,
			    int *optimized,
			    CORE_ADDR *addrp,
			    struct frame_info *frame,
			    int regnum,
			    enum lval_type *lval)
{
  CORE_ADDR addr;

  if (!target_has_registers)
    error ("No registers.");

  /* Normal systems don't optimize out things with register numbers.  */
  if (optimized != NULL)
    *optimized = 0;
  addr = find_saved_register (frame, regnum);
  if (addr != 0)
    {
      if (lval != NULL)
	*lval = lval_memory;
      if (regnum == SP_REGNUM)
	{
	  if (raw_buffer != NULL)
	    {
	      /* Put it back in target format.  */
	      store_address (raw_buffer, REGISTER_RAW_SIZE (regnum),
			     (LONGEST) addr);
	    }
	  if (addrp != NULL)
	    *addrp = 0;
	  return;
	}
      if (raw_buffer != NULL)
	target_read_memory (addr, raw_buffer, REGISTER_RAW_SIZE (regnum));
    }
  else
    {
      if (lval != NULL)
	*lval = lval_register;
      addr = REGISTER_BYTE (regnum);
      if (raw_buffer != NULL)
	read_register_gen (regnum, raw_buffer);
    }
  if (addrp != NULL)
    *addrp = addr;
}

#if !defined (GET_SAVED_REGISTER)
#define GET_SAVED_REGISTER(raw_buffer, optimized, addrp, frame, regnum, lval) \
  default_get_saved_register(raw_buffer, optimized, addrp, frame, regnum, lval)
#endif

void
get_saved_register (char *raw_buffer,
		    int *optimized,
		    CORE_ADDR *addrp,
		    struct frame_info *frame,
		    int regnum,
		    enum lval_type *lval)
{
  GET_SAVED_REGISTER (raw_buffer, optimized, addrp, frame, regnum, lval);
}

/* READ_RELATIVE_REGISTER_RAW_BYTES_FOR_FRAME

   Copy the bytes of register REGNUM, relative to the input stack frame,
   into our memory at MYADDR, in target byte order.
   The number of bytes copied is REGISTER_RAW_SIZE (REGNUM).

   Returns 1 if could not be read, 0 if could.  */

/* FIXME: This function increases the confusion between FP_REGNUM
   and the virtual/pseudo-frame pointer.  */

static int
read_relative_register_raw_bytes_for_frame (int regnum,
					    char *myaddr,
					    struct frame_info *frame)
{
  int optim;
  if (regnum == FP_REGNUM && frame)
    {
      /* Put it back in target format. */
      store_address (myaddr, REGISTER_RAW_SIZE (FP_REGNUM),
		     (LONGEST) FRAME_FP (frame));

      return 0;
    }

  get_saved_register (myaddr, &optim, (CORE_ADDR *) NULL, frame,
		      regnum, (enum lval_type *) NULL);

  if (register_cached (regnum) < 0)
    return 1;			/* register value not available */

  return optim;
}

/* READ_RELATIVE_REGISTER_RAW_BYTES

   Copy the bytes of register REGNUM, relative to the current stack
   frame, into our memory at MYADDR, in target byte order.  
   The number of bytes copied is REGISTER_RAW_SIZE (REGNUM).

   Returns 1 if could not be read, 0 if could.  */

int
read_relative_register_raw_bytes (int regnum, char *myaddr)
{
  return read_relative_register_raw_bytes_for_frame (regnum, myaddr,
						     selected_frame);
}


@


1.15
log
@2001-02-06  Michael Snyder  <msnyder@@makita.cygnus.com>
	Submitted by Paul Hilfinger (hilfingr@@gnat.com)
	and Andrei Petrov (and@@genesyslab.com).
	* findvar.c: Buffers of size MAX_REGISTER_RAW_SIZE or REGISTER_BYTES
	must be allocated dynamically, since these are no longer constants.
	* infcmd.c: Ditto.
	* regcache.c: Ditto.
	* remote.c: Ditto.
	* sol-thread.c: Ditto.
	* valops.c: Ditto.
	* config/sparc/sun4sol2.mh (MH_CFLAGS): Add -I/usr/include/v9, as a
	work-around for a missing Sun header file in solaris for sparc64.
@
text
@d2 1
a2 1
   Copyright 1986, 87, 89, 91, 94, 95, 96, 1998, 2000
d779 2
a780 1
  internal_error ("generic_target_read_pc");
d817 2
a818 1
  internal_error ("generic_target_write_pc");
d851 2
a852 1
  internal_error ("generic_target_read_sp");
d871 2
a872 1
  internal_error ("generic_target_write_sp");
d888 2
a889 1
  internal_error ("generic_target_read_fp");
d908 2
a909 1
  internal_error ("generic_target_write_fp");
@


1.14
log
@	* regcache.c (set_register_cached, register_buffer,
	real_register, pseudo_register fetch_register, store_register):
	New functions.
	(register_changed, read_relative_register_raw_bytes_for_frame,
	registers_changed, registers_fetched, read_register_bytes,
	read_register_gen, write_register_gen, read_register,
	read_signed_register, write_register, supply_register): Replace
	register_valid[] with register_cached() and
	set_register_cached().
	(read_register_bytes, read_register_gen, write_register_gen,
	read_register, read_signed_register, write_register,
	supply_register): Replace registers[] with register_buffer().
	(read_register_bytes, read_register_gen, read_register,
	read_signed_register): Call fetch_register().
	(write_register_gen, write_register): Call real_register() and
	store_register().
	(write_register_bytes): Call store_register().
	* value.h (set_register_cached, register_buffer): Prototype.
	* remote.c (remote_fetch_registers): Allocate regs[] with a
	run-time size.  Replace register_valid[] with
	set_register_cached().
	(store_register_using_P, remote_store_registers): Replace
	registers[] with register_buffer().
@
text
@d561 1
a561 1
	  char regbuf[MAX_REGISTER_RAW_SIZE];
@


1.13
log
@	* regcache.c: Change "write-back" comment to "write-through".
	Change "regno" to "regnum".
	(read_register, read_signed_register): Remove "raw" from return
	value description.
	(supply_register): Spelling fix.
	* value.h: Change "regno" to "regnum".
@
text
@d72 9
d87 51
a137 1
  register_valid[regnum] = 0;
d317 1
a317 1
  if (register_valid[regnum] < 0)
d365 1
a365 1
    register_valid[i] = 0;
d370 1
a370 1
    register_valid[i] = 0;
d387 1
a387 1
    register_valid[i] = 1;
d432 1
a432 1
      if (register_valid[regnum])
d447 1
a447 4
      if (regnum < NUM_REGS)
	target_fetch_registers (regnum);
      else if (regnum < NUM_REGS + NUM_PSEUDO_REGS)
	FETCH_PSEUDO_REGISTER (regnum);
d449 1
a449 1
      if (!register_valid[regnum])
d456 1
a456 2
	    error ("read_register_bytes:  Couldn't update register %d.",
		   regnum);
d461 1
a461 1
    memcpy (myaddr, &registers[inregbyte], inlen);
d478 4
a481 8
  if (!register_valid[regnum])
    {
      if (regnum < NUM_REGS)
	target_fetch_registers (regnum);
      else if (regnum < NUM_REGS + NUM_PSEUDO_REGS)
	FETCH_PSEUDO_REGISTER (regnum);
    }
  memcpy (myaddr, &registers[REGISTER_BYTE (regnum)],
d514 2
a515 2
  if (register_valid[regnum]
      && memcmp (&registers[REGISTER_BYTE (regnum)], myaddr, size) == 0)
d518 1
a518 1
  if (regnum < NUM_REGS)
d521 1
a521 3
  memcpy (&registers[REGISTER_BYTE (regnum)], myaddr, size);

  register_valid[regnum] = 1;
d523 2
a524 4
  if (regnum < NUM_REGS)
    target_store_registers (regnum);
  else if (regnum < NUM_REGS + NUM_PSEUDO_REGS)
    STORE_PSEUDO_REGISTER (regnum);
d575 1
a575 4
	  if (regnum < NUM_REGS)
	    target_store_registers (regnum);
	  else if (regnum < NUM_REGS + NUM_PSEUDO_REGS)
	    STORE_PSEUDO_REGISTER (regnum);
d592 2
a593 7
  if (!register_valid[regnum])
    {
      if (regnum < NUM_REGS)
	target_fetch_registers (regnum);
      else if (regnum < NUM_REGS + NUM_PSEUDO_REGS)
	FETCH_PSEUDO_REGISTER (regnum);
    }
d595 1
a595 1
  return (extract_unsigned_integer (&registers[REGISTER_BYTE (regnum)],
d630 2
a631 2
  if (!register_valid[regnum])
    target_fetch_registers (regnum);
d633 1
a633 1
  return (extract_signed_integer (&registers[REGISTER_BYTE (regnum)],
d683 2
a684 2
  if (register_valid[regnum]
      && memcmp (&registers[REGISTER_BYTE (regnum)], buf, size) == 0)
d687 1
a687 1
  if (regnum < NUM_REGS)
d690 1
a690 3
  memcpy (&registers[REGISTER_BYTE (regnum)], buf, size);

  register_valid[regnum] = 1;
d692 2
a693 4
  if (regnum < NUM_REGS)
    target_store_registers (regnum);
  else if (regnum < NUM_REGS + NUM_PSEUDO_REGS)
    STORE_PSEUDO_REGISTER (regnum);
d737 1
a737 1
  register_valid[regnum] = 1;
d739 1
a739 1
    memcpy (&registers[REGISTER_BYTE (regnum)], val, 
d742 1
a742 1
    memset (&registers[REGISTER_BYTE (regnum)], '\000', 
d749 1
a749 1
  CLEAN_UP_REGISTER_VALUE (regnum, &registers[REGISTER_BYTE (regnum)]);
@


1.12
log
@2000-11-16  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * regcache.c (read_register_bytes): Failing to set register_valid
        is not necessarily an error, if the register is a pseudo-register.
        Some pseudo-registers are never marked as valid, so that they will
        be read anew every time.  Determining if a pseudo-register is valid
        (or should be marked invalid) may be difficult, whereas just
        recomputing it may be cheap.
@
text
@d35 1
a35 1
/* NOTE: this is a write-back cache.  There is no "dirty" bit for
d341 1
a341 1
   regno as an argument, and therefore can't do a partial register
d358 1
a358 1
  int regno;
d369 1
a369 1
  for (regno = 0; regno < NUM_REGS + NUM_PSEUDO_REGS; regno++)
d373 1
a373 1
      if (register_valid[regno])
d376 1
a376 1
      if (REGISTER_NAME (regno) == NULL || *REGISTER_NAME (regno) == '\0')
d379 2
a380 2
      regstart = REGISTER_BYTE (regno);
      regend = regstart + REGISTER_RAW_SIZE (regno);
d383 1
a383 1
	/* The range the user wants to read doesn't overlap with regno.  */
d388 4
a391 4
      if (regno < NUM_REGS)
	target_fetch_registers (regno);
      else if (regno < NUM_REGS + NUM_PSEUDO_REGS)
	FETCH_PSEUDO_REGISTER (regno);
d393 1
a393 1
      if (!register_valid[regno])
d399 3
a401 2
	  if (regno < NUM_REGS)
	    error ("read_register_bytes:  Couldn't update register %d.", regno);
d409 2
a410 2
/* Read register REGNO into memory at MYADDR, which must be large
   enough for REGISTER_RAW_BYTES (REGNO).  Target byte-order.  If the
d415 1
a415 1
read_register_gen (int regno, char *myaddr)
d423 1
a423 1
  if (!register_valid[regno])
d425 4
a428 4
      if (regno < NUM_REGS)
	target_fetch_registers (regno);
      else if (regno < NUM_REGS + NUM_PSEUDO_REGS)
	FETCH_PSEUDO_REGISTER (regno);
d430 2
a431 2
  memcpy (myaddr, &registers[REGISTER_BYTE (regno)],
	  REGISTER_RAW_SIZE (regno));
d434 2
a435 2
/* Write register REGNO at MYADDR to the target.  MYADDR points at
   REGISTER_RAW_BYTES(REGNO), which must be in target byte-order.  */
d439 1
a439 1
#define CANNOT_STORE_REGISTER(regno) 0
d443 1
a443 1
write_register_gen (int regno, char *myaddr)
d449 1
a449 1
  if (CANNOT_STORE_REGISTER (regno))
d458 1
a458 1
  size = REGISTER_RAW_SIZE (regno);
d463 2
a464 2
  if (register_valid[regno]
      && memcmp (&registers[REGISTER_BYTE (regno)], myaddr, size) == 0)
d467 1
a467 1
  if (regno < NUM_REGS)
d470 1
a470 1
  memcpy (&registers[REGISTER_BYTE (regno)], myaddr, size);
d472 1
a472 1
  register_valid[regno] = 1;
d474 4
a477 4
  if (regno < NUM_REGS)
    target_store_registers (regno);
  else if (regno < NUM_REGS + NUM_PSEUDO_REGS)
    STORE_PSEUDO_REGISTER (regno);
d487 1
a487 1
  int regno;
d496 1
a496 1
  for (regno = 0; regno < NUM_REGS + NUM_PSEUDO_REGS; regno++)
d500 2
a501 2
      regstart = REGISTER_BYTE (regno);
      regend = regstart + REGISTER_RAW_SIZE (regno);
d509 1
a509 1
	write_register_gen (regno, myaddr + (regstart - myregstart));
d522 1
a522 1
	  read_register_gen (regno, regbuf);
d528 4
a531 4
	  if (regno < NUM_REGS)
	    target_store_registers (regno);
	  else if (regno < NUM_REGS + NUM_PSEUDO_REGS)
	    STORE_PSEUDO_REGISTER (regno);
d537 1
a537 2
/* Return the raw contents of register REGNO, regarding it as an
   UNSIGNED integer. */
d540 1
a540 1
read_register (int regno)
d548 1
a548 1
  if (!register_valid[regno])
d550 4
a553 4
      if (regno < NUM_REGS)
	target_fetch_registers (regno);
      else if (regno < NUM_REGS + NUM_PSEUDO_REGS)
	FETCH_PSEUDO_REGISTER (regno);
d556 2
a557 2
  return (extract_unsigned_integer (&registers[REGISTER_BYTE (regno)],
				    REGISTER_RAW_SIZE (regno)));
d561 1
a561 1
read_register_pid (int regno, int pid)
d567 1
a567 1
    return read_register (regno);
d573 1
a573 1
  retval = read_register (regno);
d580 1
a580 2
/* Return the raw contents of register REGNO, regarding it a SIGNED
   integer. */
d583 1
a583 1
read_signed_register (int regno)
d591 2
a592 2
  if (!register_valid[regno])
    target_fetch_registers (regno);
d594 2
a595 2
  return (extract_signed_integer (&registers[REGISTER_BYTE (regno)],
				  REGISTER_RAW_SIZE (regno)));
d599 1
a599 1
read_signed_register_pid (int regno, int pid)
d605 1
a605 1
    return read_signed_register (regno);
d611 1
a611 1
  retval = read_signed_register (regno);
d618 1
a618 1
/* Store VALUE, into the raw contents of register number REGNO.  */
d621 1
a621 1
write_register (int regno, LONGEST val)
d628 1
a628 1
  if (CANNOT_STORE_REGISTER (regno))
d637 1
a637 1
  size = REGISTER_RAW_SIZE (regno);
d644 2
a645 2
  if (register_valid[regno]
      && memcmp (&registers[REGISTER_BYTE (regno)], buf, size) == 0)
d648 1
a648 1
  if (regno < NUM_REGS)
d651 1
a651 1
  memcpy (&registers[REGISTER_BYTE (regno)], buf, size);
d653 1
a653 1
  register_valid[regno] = 1;
d655 4
a658 4
  if (regno < NUM_REGS)
    target_store_registers (regno);
  else if (regno < NUM_REGS + NUM_PSEUDO_REGS)
    STORE_PSEUDO_REGISTER (regno);
d662 1
a662 1
write_register_pid (int regno, CORE_ADDR val, int pid)
d668 1
a668 1
      write_register (regno, val);
d676 1
a676 1
  write_register (regno, val);
d683 1
a683 1
   Record that register REGNO contains VAL.  This is used when the
d688 1
a688 1
   We just set it's value to all zeros.  We might want to record this
d692 1
a692 1
supply_register (int regno, char *val)
d702 1
a702 1
  register_valid[regno] = 1;
d704 2
a705 2
    memcpy (&registers[REGISTER_BYTE (regno)], val, 
	    REGISTER_RAW_SIZE (regno));
d707 2
a708 2
    memset (&registers[REGISTER_BYTE (regno)], '\000', 
	    REGISTER_RAW_SIZE (regno));
d714 1
a714 1
  CLEAN_UP_REGISTER_VALUE (regno, &registers[REGISTER_BYTE (regno)]);
@


1.11
log
@* gdbarch.sh, hp-psymtab-read.c, hpread.c, m3-nat.c, mcore-tdep.c,
mips-tdep.c, monitor.c, regcache.c, remote-es.c, ser-unix.c,
somread.c, tracepoint.c: Fix spelling errors in comments.
* gdbarch.c: Regenerate.

* gnu-nat.c (S_exception_raise_request): Fix typos and spelling
errors in strings.
* m3-nat.c (intercept_exec_calls, mach_thread_parse_id): Likewise.
* mcore-tdep.c (mcore_analyze_prologue): Likewise.
* mips-tdep.c (mips16_next_pc, _initialize_mips_tdep): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-rdp.c (handle_swi): Likewise.
* remote-vx.c (vx_load_command): Likewise.
* sh-tdep.c (sh_do_pseudo_register): Likewise.
* sol-thread.c (td_err_string): Likewise.
* symtab.c (decode_line_2): Likewise.
-------------------------------------------------------------------
@
text
@d394 8
a401 1
	error ("read_register_bytes:  Couldn't update register %d.", regno);
@


1.10
log
@2000-09-01  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * regcache.c (reg_flush_command): New function.  Maintainer-mode
        command, flushes GDB's register cache, for testing purposes.
@
text
@d720 1
a720 1
   existance of a TARGET_READ_PC et.al. macro.  A default generic
@


1.9
log
@Fri Aug 25 16:57:05 2000  David Taylor  <taylor@@texas.cygnus.com>

	* regcache.c (register_changed): New function.
	* value.h: Declare it.
@
text
@d27 1
d871 11
d904 3
@


1.8
log
@Restore GET_SAVED_REGISTERS
@
text
@d71 9
@


1.7
log
@        * regcache.c (TARGET_WRITE_PC, TARGET_READ_PC, TARGET_READ_FP,
        TARGET_WRITE_FP, TARGET_READ_SP, TARGET_WRITE_SP): Move
        initialization from here.
        * gdbarch.sh: To here.
        * gdbarch.h, gdbarch.c: Regenerate.
@
text
@d203 5
@


1.6
log
@2000-07-24  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

         * gdbarch.sh: Add FETCH_PSEUDO_REGISTER and STORE_PSEUDO_REGISTER
         to the gdbarch structure.
         * gdbarch.c: Regenerate.
         * gdbarch.h: Regenerate.
         * inferior.h (FETCH_PSEUDO_REGISTER, STORE_PSEUDO_REGISTER):
         Delete macros.
         * regcache.c (write_register, read_register, write_register_bytes,
         write_register_gen, read_register_bytes, read_register_gen):
         Rename ARCH_FECTH_PSEUDO_REGISTERS to FETCH_PSEUDO_REGISTERS and
         ARCH_STORE_PSEUDO_REGISTER to STORE_PSEUDO_REGISTER.
@
text
@a202 5
#if !defined (GET_SAVED_REGISTER)
#define GET_SAVED_REGISTER(raw_buffer, optimized, addrp, frame, regnum, lval) \
  default_get_saved_register(raw_buffer, optimized, addrp, frame, regnum, lval)
#endif

a712 4
#ifndef TARGET_READ_PC
#define TARGET_READ_PC generic_target_read_pc
#endif

a748 4
#ifndef TARGET_WRITE_PC
#define TARGET_WRITE_PC generic_target_write_pc
#endif

a785 4
#ifndef TARGET_READ_SP
#define TARGET_READ_SP generic_target_read_sp
#endif

a801 4
#ifndef TARGET_WRITE_SP
#define TARGET_WRITE_SP generic_target_write_sp
#endif

a820 4
#ifndef TARGET_READ_FP
#define TARGET_READ_FP generic_target_read_fp
#endif

a835 4

#ifndef TARGET_WRITE_FP
#define TARGET_WRITE_FP generic_target_write_fp
#endif
@


1.5
log
@2000-07-21  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * regcache.c (read_register, read_register_bytes): Fix typos.
@
text
@d381 1
a381 1
	ARCH_FETCH_PSEUDO_REGISTERS (regno);
d410 1
a410 1
	ARCH_FETCH_PSEUDO_REGISTERS (regno);
d459 1
a459 1
    ARCH_STORE_PSEUDO_REGISTERS (regno);
d513 1
a513 1
	    ARCH_STORE_PSEUDO_REGISTERS (regno);
d536 1
a536 1
	ARCH_FETCH_PSEUDO_REGISTERS (regno);
d642 1
a642 1
    ARCH_STORE_PSEUDO_REGISTERS (regno);
@


1.4
log
@2000-07-12  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * regcache.c (registers_changed, registers_fetched): Use
        ARCH_NUM_REGS directly, eliminating an unnecessary variable.

        This change adds pseudo-register capability to GDB.
        Pseudo-registers are handled like registers, but they
        don't come from or live on the target.  They may be
        aliases for an existing register, or they may be computed.
        * defs.h (NUM_PSEUDO_REGISTERS): Define default of zero.
        (ARCH_FETCH_PSEUDO_REGISTERS): Define default of no-op.
        (ARCH_STORE_PSEUDO_REGISTERS): Define default of no-op.
        # regcache.c (registers_changed): Mark pseudo-registers
        invalid, as well as real registers.
        (registers_fetched): Do not mark pseudo-registers as fetched
        at the same time as other (real) registers.
        (read_register_bytes): Fetch pseudo-registers (if any) from
        the target architecture module instead of from the target.
        (read_register_gen): Ditto.
        (read_register): Ditto.
        (write_register_bytes): Store pseudo-registers (if any) to
        the target architecture module instead of to the target.
        (write_register_gen): Ditto.
        (write_register): Ditto.
        (build_regcache): Allocate enough register_valid space for
        pseudo-registers as well as normal (real) ones.
@
text
@d380 1
a380 1
      else if (regno < NUM_PSEUDO_REGS)
d535 1
a535 1
      else if (regno < NUM_PSEUDO_REGS)
@


1.3
log
@Add read_signed_register{,_pid}().  Change return type of
read_register{,_pid}() to ULONGEST.
@
text
@a284 1
  int numregs = ARCH_NUM_REGS;
d295 6
a300 1
  for (i = 0; i < numregs; i++)
a315 1
  int numregs = ARCH_NUM_REGS;
d317 1
a317 1
  for (i = 0; i < numregs; i++)
d319 2
d359 1
a359 1
  for (regno = 0; regno < NUM_REGS; regno++)
d376 1
a376 1
      /* We've found an invalid register where at least one byte will be read.
d378 4
a381 1
      target_fetch_registers (regno);
d406 6
a411 1
    target_fetch_registers (regno);
d449 2
a450 1
  target_prepare_to_store ();
d456 4
a459 1
  target_store_registers (regno);
d478 1
a478 1
  for (regno = 0; regno < NUM_REGS; regno++)
d510 4
a513 1
	  target_store_registers (regno);
d532 6
a537 1
    target_fetch_registers (regno);
d632 2
a633 1
  target_prepare_to_store ();
d639 4
a642 1
  target_store_registers (regno);
d891 2
a892 1
  int sizeof_register_valid = NUM_REGS * sizeof (*register_valid);
@


1.2
log
@2000-07-07  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * findvar.c (_initialize_findvar, build_findvar, write_fp, read_fp,
        generic_target_write_fp, generic_target_read_fp, write_sp, read_sp,
        generic_target_write_sp, generic_target_read_sp, write_pc, read_pc,
        generic_target_write_pc, generic_target_read_pc, write_pc_pid,
        read_pc_pid, supply_register, write_register_pid, write_register,
        read_register_pid, read_register, write_register_bytes,
        read_register_bytes, write_register_gen, read_register_gen,
        registers_fetched, registers_changed, find_saved_register,
        read_relative_register_raw_bytes, default_get_saved_register,
        read_relative_register_raw_bytes_for_frame, get_saved_register):
        Move from this file into new file regcache.c.
        (register_valid, registers_pid, registers): Ditto.
        * regcache.c: New file to hold the register cache.
        (register_cached): New function to read register_valid array.
        * value.h (register_cached): Declare.
        * defs.h (default_get_saved_register): Delete decl of static function.
        * Makefile.in: Add regcache module.
@
text
@d500 1
a500 2
   integer.  This probably should be returning LONGEST rather than
   CORE_ADDR.  */
d502 1
a502 1
CORE_ADDR
d514 1
a514 2
  return ((CORE_ADDR)
	  extract_unsigned_integer (&registers[REGISTER_BYTE (regno)],
d518 1
a518 1
CORE_ADDR
d532 39
@


1.1
log
@Dummy commit for diff purposes.
@
text
@d1 840
@

