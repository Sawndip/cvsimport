head	1.183;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.173
	gdb_7_6-2013-04-26-release:1.173
	gdb_7_6-branch:1.173.0.2
	gdb_7_6-2013-03-12-branchpoint:1.173
	gdb_7_5_1-2012-11-29-release:1.164
	gdb_7_5-2012-08-17-release:1.164
	gdb_7_5-branch:1.164.0.2
	gdb_7_5-2012-07-18-branchpoint:1.164
	gdb_7_4_1-2012-04-26-release:1.160.2.1
	gdb_7_4-2012-01-24-release:1.160.2.1
	gdb_7_4-branch:1.160.0.2
	gdb_7_4-2011-12-13-branchpoint:1.160
	gdb_7_3_1-2011-09-04-release:1.145.2.1
	gdb_7_3-2011-07-26-release:1.145.2.1
	gdb_7_3-branch:1.145.0.2
	gdb_7_3-2011-04-01-branchpoint:1.145
	gdb_7_2-2010-09-02-release:1.137
	gdb_7_2-branch:1.137.0.2
	gdb_7_2-2010-07-07-branchpoint:1.137
	gdb_7_1-2010-03-18-release:1.124.2.2
	gdb_7_1-branch:1.124.0.2
	gdb_7_1-2010-02-18-branchpoint:1.124
	gdb_7_0_1-2009-12-22-release:1.105
	gdb_7_0-2009-10-06-release:1.105
	gdb_7_0-branch:1.105.0.4
	gdb_7_0-2009-09-16-branchpoint:1.105
	arc-sim-20090309:1.84
	msnyder-checkpoint-072509-branch:1.105.0.2
	msnyder-checkpoint-072509-branchpoint:1.105
	arc-insight_6_8-branch:1.84.0.6
	arc-insight_6_8-branchpoint:1.84
	insight_6_8-branch:1.84.0.4
	insight_6_8-branchpoint:1.84
	reverse-20081226-branch:1.94.0.6
	reverse-20081226-branchpoint:1.94
	multiprocess-20081120-branch:1.94.0.4
	multiprocess-20081120-branchpoint:1.94
	reverse-20080930-branch:1.94.0.2
	reverse-20080930-branchpoint:1.94
	reverse-20080717-branch:1.87.0.4
	reverse-20080717-branchpoint:1.87
	msnyder-reverse-20080609-branch:1.87.0.2
	msnyder-reverse-20080609-branchpoint:1.87
	drow-reverse-20070409-branch:1.61.0.2
	drow-reverse-20070409-branchpoint:1.61
	gdb_6_8-2008-03-27-release:1.84
	gdb_6_8-branch:1.84.0.2
	gdb_6_8-2008-02-26-branchpoint:1.84
	gdb_6_7_1-2007-10-29-release:1.75.2.1
	gdb_6_7-2007-10-10-release:1.75.2.1
	gdb_6_7-branch:1.75.0.2
	gdb_6_7-2007-09-07-branchpoint:1.75
	insight_6_6-20070208-release:1.60
	gdb_6_6-2006-12-18-release:1.60
	gdb_6_6-branch:1.60.0.2
	gdb_6_6-2006-11-15-branchpoint:1.60
	insight_6_5-20061003-release:1.57
	gdb-csl-symbian-6_4_50_20060226-12:1.55
	gdb-csl-sourcerygxx-3_4_4-25:1.53
	nickrob-async-20060828-mergepoint:1.58
	gdb-csl-symbian-6_4_50_20060226-11:1.55
	gdb-csl-sourcerygxx-4_1-17:1.55
	gdb-csl-20060226-branch-local-2:1.55
	gdb-csl-sourcerygxx-4_1-14:1.55
	gdb-csl-sourcerygxx-4_1-13:1.55
	gdb-csl-sourcerygxx-4_1-12:1.55
	gdb-csl-sourcerygxx-3_4_4-21:1.55
	gdb_6_5-20060621-release:1.57
	gdb-csl-sourcerygxx-4_1-9:1.55
	gdb-csl-sourcerygxx-4_1-8:1.55
	gdb-csl-sourcerygxx-4_1-7:1.55
	gdb-csl-arm-2006q1-6:1.55
	gdb-csl-sourcerygxx-4_1-6:1.55
	gdb-csl-symbian-6_4_50_20060226-10:1.55
	gdb-csl-symbian-6_4_50_20060226-9:1.55
	gdb-csl-symbian-6_4_50_20060226-8:1.55
	gdb-csl-coldfire-4_1-11:1.55
	gdb-csl-sourcerygxx-3_4_4-19:1.55
	gdb-csl-coldfire-4_1-10:1.55
	gdb_6_5-branch:1.57.0.10
	gdb_6_5-2006-05-14-branchpoint:1.57
	gdb-csl-sourcerygxx-4_1-5:1.55
	nickrob-async-20060513-branch:1.57.0.8
	nickrob-async-20060513-branchpoint:1.57
	gdb-csl-sourcerygxx-4_1-4:1.55
	msnyder-reverse-20060502-branch:1.57.0.6
	msnyder-reverse-20060502-branchpoint:1.57
	gdb-csl-morpho-4_1-4:1.55
	gdb-csl-sourcerygxx-3_4_4-17:1.55
	readline_5_1-import-branch:1.57.0.4
	readline_5_1-import-branchpoint:1.57
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.55
	gdb-csl-symbian-20060226-branch:1.55.0.4
	gdb-csl-symbian-20060226-branchpoint:1.55
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.55
	msnyder-reverse-20060331-branch:1.57.0.2
	msnyder-reverse-20060331-branchpoint:1.57
	gdb-csl-available-20060303-branch:1.56.0.2
	gdb-csl-available-20060303-branchpoint:1.56
	gdb-csl-20060226-branch:1.55.0.2
	gdb-csl-20060226-branchpoint:1.55
	gdb_6_4-20051202-release:1.53
	msnyder-fork-checkpoint-branch:1.53.0.8
	msnyder-fork-checkpoint-branchpoint:1.53
	gdb-csl-gxxpro-6_3-branch:1.53.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.53
	gdb_6_4-branch:1.53.0.4
	gdb_6_4-2005-11-01-branchpoint:1.53
	gdb-csl-arm-20051020-branch:1.53.0.2
	gdb-csl-arm-20051020-branchpoint:1.53
	msnyder-tracepoint-checkpoint-branch:1.49.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.49
	gdb-csl-arm-20050325-2005-q1b:1.47
	gdb-csl-arm-20050325-2005-q1a:1.47
	csl-arm-20050325-branch:1.47.0.2
	csl-arm-20050325-branchpoint:1.47
	gdb-post-i18n-errorwarning-20050211:1.46
	gdb-pre-i18n-errorwarning-20050211:1.45
	gdb_6_3-20041109-release:1.44
	gdb_6_3-branch:1.44.0.4
	gdb_6_3-20041019-branchpoint:1.44
	drow_intercu-merge-20040921:1.44
	drow_intercu-merge-20040915:1.44
	jimb-gdb_6_2-e500-branch:1.44.0.6
	jimb-gdb_6_2-e500-branchpoint:1.44
	gdb_6_2-20040730-release:1.44
	gdb_6_2-branch:1.44.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.44
	gdb_6_1_1-20040616-release:1.41
	gdb_6_1-2004-04-05-release:1.41
	drow_intercu-merge-20040402:1.43
	drow_intercu-merge-20040327:1.43
	ezannoni_pie-20040323-branch:1.43.0.2
	ezannoni_pie-20040323-branchpoint:1.43
	cagney_tramp-20040321-mergepoint:1.43
	cagney_tramp-20040309-branch:1.41.0.6
	cagney_tramp-20040309-branchpoint:1.41
	gdb_6_1-branch:1.41.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.41
	drow_intercu-20040221-branch:1.41.0.2
	drow_intercu-20040221-branchpoint:1.41
	cagney_bfdfile-20040213-branch:1.40.0.4
	cagney_bfdfile-20040213-branchpoint:1.40
	drow-cplus-merge-20040208:1.40
	carlton_dictionary-20040126-merge:1.40
	cagney_bigcore-20040122-branch:1.40.0.2
	cagney_bigcore-20040122-branchpoint:1.40
	drow-cplus-merge-20040113:1.40
	drow-cplus-merge-20031224:1.40
	drow-cplus-merge-20031220:1.40
	carlton_dictionary-20031215-merge:1.40
	drow-cplus-merge-20031214:1.40
	carlton-dictionary-20031111-merge:1.40
	gdb_6_0-2003-10-04-release:1.35
	kettenis_sparc-20030918-branch:1.37.0.4
	kettenis_sparc-20030918-branchpoint:1.37
	carlton_dictionary-20030917-merge:1.37
	ezannoni_pie-20030916-branchpoint:1.37
	ezannoni_pie-20030916-branch:1.37.0.2
	cagney_x86i386-20030821-branch:1.36.0.2
	cagney_x86i386-20030821-branchpoint:1.36
	carlton_dictionary-20030805-merge:1.36
	carlton_dictionary-20030627-merge:1.35
	gdb_6_0-branch:1.35.0.4
	gdb_6_0-2003-06-23-branchpoint:1.35
	jimb-ppc64-linux-20030613-branch:1.35.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.35
	cagney_convert-20030606-branch:1.33.0.2
	cagney_convert-20030606-branchpoint:1.33
	cagney_writestrings-20030508-branch:1.32.0.10
	cagney_writestrings-20030508-branchpoint:1.32
	jimb-ppc64-linux-20030528-branch:1.32.0.8
	jimb-ppc64-linux-20030528-branchpoint:1.32
	carlton_dictionary-20030523-merge:1.32
	cagney_fileio-20030521-branch:1.32.0.6
	cagney_fileio-20030521-branchpoint:1.32
	kettenis_i386newframe-20030517-mergepoint:1.32
	jimb-ppc64-linux-20030509-branch:1.32.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.32
	kettenis_i386newframe-20030504-mergepoint:1.32
	carlton_dictionary-20030430-merge:1.32
	kettenis_i386newframe-20030419-branch:1.32.0.2
	kettenis_i386newframe-20030419-branchpoint:1.32
	carlton_dictionary-20030416-merge:1.32
	cagney_frameaddr-20030409-mergepoint:1.31
	kettenis_i386newframe-20030406-branch:1.29.0.16
	kettenis_i386newframe-20030406-branchpoint:1.29
	cagney_frameaddr-20030403-branchpoint:1.29
	cagney_frameaddr-20030403-branch:1.29.0.14
	cagney_framebase-20030330-mergepoint:1.29
	cagney_framebase-20030326-branch:1.29.0.12
	cagney_framebase-20030326-branchpoint:1.29
	cagney_lazyid-20030317-branch:1.29.0.10
	cagney_lazyid-20030317-branchpoint:1.29
	kettenis-i386newframe-20030316-mergepoint:1.29
	offbyone-20030313-branch:1.29.0.8
	offbyone-20030313-branchpoint:1.29
	kettenis-i386newframe-20030308-branch:1.29.0.6
	kettenis-i386newframe-20030308-branchpoint:1.29
	carlton_dictionary-20030305-merge:1.29
	cagney_offbyone-20030303-branch:1.29.0.4
	cagney_offbyone-20030303-branchpoint:1.29
	carlton_dictionary-20030207-merge:1.29
	interps-20030203-mergepoint:1.29
	interps-20030202-branch:1.29.0.2
	interps-20030202-branchpoint:1.29
	cagney-unwind-20030108-branch:1.28.0.2
	cagney-unwind-20030108-branchpoint:1.28
	carlton_dictionary-20021223-merge:1.28
	gdb_5_3-2002-12-12-release:1.26
	carlton_dictionary-20021115-merge:1.27
	kseitz_interps-20021105-merge:1.27
	kseitz_interps-20021103-merge:1.27
	drow-cplus-merge-20021020:1.26
	drow-cplus-merge-20021025:1.27
	carlton_dictionary-20021025-merge:1.27
	carlton_dictionary-20021011-merge:1.26
	drow-cplus-branch:1.26.0.10
	drow-cplus-branchpoint:1.26
	kseitz_interps-20020930-merge:1.26
	carlton_dictionary-20020927-merge:1.26
	carlton_dictionary-branch:1.26.0.8
	carlton_dictionary-20020920-branchpoint:1.26
	gdb_5_3-branch:1.26.0.6
	gdb_5_3-2002-09-04-branchpoint:1.26
	kseitz_interps-20020829-merge:1.26
	cagney_sysregs-20020825-branch:1.26.0.4
	cagney_sysregs-20020825-branchpoint:1.26
	readline_4_3-import-branch:1.26.0.2
	readline_4_3-import-branchpoint:1.26
	gdb_5_2_1-2002-07-23-release:1.23
	kseitz_interps-20020528-branch:1.25.0.4
	kseitz_interps-20020528-branchpoint:1.25
	cagney_regbuf-20020515-branch:1.25.0.2
	cagney_regbuf-20020515-branchpoint:1.25
	jimb-macro-020506-branch:1.24.0.2
	jimb-macro-020506-branchpoint:1.24
	gdb_5_2-2002-04-29-release:1.23
	gdb_5_2-branch:1.23.0.2
	gdb_5_2-2002-03-03-branchpoint:1.23
	gdb_5_1_1-2002-01-24-release:1.16
	gdb_5_1_0_1-2002-01-03-release:1.16
	cygnus_cvs_20020108_pre:1.21
	gdb_5_1_0_1-2002-01-03-branchpoint:1.16
	gdb_5_1_0_1-2002-01-03-branch:1.16.0.8
	gdb_5_1-2001-11-21-release:1.16
	gdb_s390-2001-09-26-branch:1.16.0.6
	gdb_s390-2001-09-26-branchpoint:1.16
	gdb_5_1-2001-07-29-branch:1.16.0.4
	gdb_5_1-2001-07-29-branchpoint:1.16
	dberlin-typesystem-branch:1.16.0.2
	dberlin-typesystem-branchpoint:1.16
	gdb-post-ptid_t-2001-05-03:1.15
	gdb-pre-ptid_t-2001-05-03:1.14
	insight-precleanup-2001-01-01:1.6;
locks; strict;
comment	@ * @;


1.183
date	2013.09.25.11.52.50;	author uweigand;	state Exp;
branches;
next	1.182;

1.182
date	2013.07.24.19.50.32;	author sergiodj;	state Exp;
branches;
next	1.181;

1.181
date	2013.07.16.20.41.55;	author devans;	state Exp;
branches;
next	1.180;

1.180
date	2013.06.24.22.18.32;	author macro;	state Exp;
branches;
next	1.179;

1.179
date	2013.06.04.13.17.06;	author gary;	state Exp;
branches;
next	1.178;

1.178
date	2013.05.21.23.41.29;	author ppluzhnikov;	state Exp;
branches;
next	1.177;

1.177
date	2013.05.06.22.18.38;	author devans;	state Exp;
branches;
next	1.176;

1.176
date	2013.04.19.15.10.53;	author palves;	state Exp;
branches;
next	1.175;

1.175
date	2013.04.08.14.03.56;	author aristovski;	state Exp;
branches;
next	1.174;

1.174
date	2013.03.20.15.46.24;	author jkratoch;	state Exp;
branches;
next	1.173;

1.173
date	2013.01.31.13.52.52;	author aristovski;	state Exp;
branches;
next	1.172;

1.172
date	2013.01.01.06.32.51;	author brobecke;	state Exp;
branches;
next	1.171;

1.171
date	2012.12.13.21.29.50;	author tromey;	state Exp;
branches;
next	1.170;

1.170
date	2012.12.10.16.42.17;	author palves;	state Exp;
branches;
next	1.169;

1.169
date	2012.11.27.08.11.59;	author qiyao;	state Exp;
branches;
next	1.168;

1.168
date	2012.11.09.19.58.01;	author tromey;	state Exp;
branches;
next	1.167;

1.167
date	2012.08.22.15.17.21;	author tromey;	state Exp;
branches;
next	1.166;

1.166
date	2012.08.14.16.16.04;	author gary;	state Exp;
branches;
next	1.165;

1.165
date	2012.07.23.15.25.12;	author tromey;	state Exp;
branches;
next	1.164;

1.164
date	2012.06.05.15.44.03;	author palves;	state Exp;
branches;
next	1.163;

1.163
date	2012.05.28.20.37.29;	author jkratoch;	state Exp;
branches;
next	1.162;

1.162
date	2012.05.24.16.51.36;	author palves;	state Exp;
branches;
next	1.161;

1.161
date	2012.01.04.08.17.11;	author brobecke;	state Exp;
branches;
next	1.160;

1.160
date	2011.12.03.18.32.29;	author jkratoch;	state Exp;
branches
	1.160.2.1;
next	1.159;

1.159
date	2011.12.02.22.26.51;	author jkratoch;	state Exp;
branches;
next	1.158;

1.158
date	2011.10.18.14.00.41;	author aristovski;	state Exp;
branches;
next	1.157;

1.157
date	2011.10.14.07.58.58;	author jkratoch;	state Exp;
branches;
next	1.156;

1.156
date	2011.10.14.07.55.26;	author jkratoch;	state Exp;
branches;
next	1.155;

1.155
date	2011.10.02.21.05.59;	author jkratoch;	state Exp;
branches;
next	1.154;

1.154
date	2011.08.30.02.48.05;	author qiyao;	state Exp;
branches;
next	1.153;

1.153
date	2011.08.09.12.51.47;	author palves;	state Exp;
branches;
next	1.152;

1.152
date	2011.08.05.15.17.23;	author ppluzhnikov;	state Exp;
branches;
next	1.151;

1.151
date	2011.06.30.18.48.19;	author tromey;	state Exp;
branches;
next	1.150;

1.150
date	2011.05.24.10.48.18;	author palves;	state Exp;
branches;
next	1.149;

1.149
date	2011.05.09.14.25.37;	author palves;	state Exp;
branches;
next	1.148;

1.148
date	2011.04.19.12.32.20;	author muller;	state Exp;
branches;
next	1.147;

1.147
date	2011.04.19.11.38.40;	author muller;	state Exp;
branches;
next	1.146;

1.146
date	2011.04.17.19.17.10;	author jkratoch;	state Exp;
branches;
next	1.145;

1.145
date	2011.03.28.20.21.04;	author jkratoch;	state Exp;
branches
	1.145.2.1;
next	1.144;

1.144
date	2011.01.11.21.53.24;	author msnyder;	state Exp;
branches;
next	1.143;

1.143
date	2011.01.05.22.22.50;	author msnyder;	state Exp;
branches;
next	1.142;

1.142
date	2011.01.01.15.33.15;	author brobecke;	state Exp;
branches;
next	1.141;

1.141
date	2010.12.13.15.45.55;	author kevinb;	state Exp;
branches;
next	1.140;

1.140
date	2010.11.28.04.31.24;	author jkratoch;	state Exp;
branches;
next	1.139;

1.139
date	2010.10.11.08.50.33;	author jkratoch;	state Exp;
branches;
next	1.138;

1.138
date	2010.08.03.22.35.41;	author devans;	state Exp;
branches;
next	1.137;

1.137
date	2010.07.05.18.04.33;	author jkratoch;	state Exp;
branches;
next	1.136;

1.136
date	2010.07.05.18.00.39;	author jkratoch;	state Exp;
branches;
next	1.135;

1.135
date	2010.07.05.17.57.50;	author jkratoch;	state Exp;
branches;
next	1.134;

1.134
date	2010.05.16.23.49.58;	author msnyder;	state Exp;
branches;
next	1.133;

1.133
date	2010.05.05.19.50.10;	author msnyder;	state Exp;
branches;
next	1.132;

1.132
date	2010.04.27.21.02.11;	author brobecke;	state Exp;
branches;
next	1.131;

1.131
date	2010.04.23.21.44.19;	author jkratoch;	state Exp;
branches;
next	1.130;

1.130
date	2010.03.11.22.07.02;	author jkratoch;	state Exp;
branches;
next	1.129;

1.129
date	2010.03.10.20.55.44;	author jkratoch;	state Exp;
branches;
next	1.128;

1.128
date	2010.03.10.20.50.55;	author jkratoch;	state Exp;
branches;
next	1.127;

1.127
date	2010.03.09.18.09.07;	author kseitz;	state Exp;
branches;
next	1.126;

1.126
date	2010.03.08.07.45.49;	author brobecke;	state Exp;
branches;
next	1.125;

1.125
date	2010.02.24.00.29.02;	author palves;	state Exp;
branches;
next	1.124;

1.124
date	2010.02.17.20.47.08;	author hjl;	state Exp;
branches
	1.124.2.1;
next	1.123;

1.123
date	2010.02.17.11.37.23;	author jkratoch;	state Exp;
branches;
next	1.122;

1.122
date	2010.02.15.17.37.35;	author jkratoch;	state Exp;
branches;
next	1.121;

1.121
date	2010.02.13.13.36.55;	author jkratoch;	state Exp;
branches;
next	1.120;

1.120
date	2010.02.13.12.02.28;	author jkratoch;	state Exp;
branches;
next	1.119;

1.119
date	2010.02.11.23.07.23;	author jkratoch;	state Exp;
branches;
next	1.118;

1.118
date	2010.02.04.22.54.41;	author devans;	state Exp;
branches;
next	1.117;

1.117
date	2010.02.01.19.27.54;	author jkratoch;	state Exp;
branches;
next	1.116;

1.116
date	2010.01.27.00.32.09;	author devans;	state Exp;
branches;
next	1.115;

1.115
date	2010.01.14.21.16.52;	author jkratoch;	state Exp;
branches;
next	1.114;

1.114
date	2010.01.14.21.15.00;	author jkratoch;	state Exp;
branches;
next	1.113;

1.113
date	2010.01.14.21.09.04;	author jkratoch;	state Exp;
branches;
next	1.112;

1.112
date	2010.01.14.21.01.24;	author jkratoch;	state Exp;
branches;
next	1.111;

1.111
date	2010.01.14.20.48.26;	author jkratoch;	state Exp;
branches;
next	1.110;

1.110
date	2010.01.08.22.52.03;	author jkratoch;	state Exp;
branches;
next	1.109;

1.109
date	2010.01.01.07.31.41;	author brobecke;	state Exp;
branches;
next	1.108;

1.108
date	2009.12.01.22.46.11;	author jsm28;	state Exp;
branches;
next	1.107;

1.107
date	2009.11.10.21.36.48;	author jsm28;	state Exp;
branches;
next	1.106;

1.106
date	2009.10.19.09.51.42;	author palves;	state Exp;
branches;
next	1.105;

1.105
date	2009.07.17.17.08.23;	author uweigand;	state Exp;
branches;
next	1.104;

1.104
date	2009.07.02.17.25.58;	author uweigand;	state Exp;
branches;
next	1.103;

1.103
date	2009.07.02.17.12.27;	author uweigand;	state Exp;
branches;
next	1.102;

1.102
date	2009.07.02.17.06.44;	author uweigand;	state Exp;
branches;
next	1.101;

1.101
date	2009.06.20.00.16.02;	author palves;	state Exp;
branches;
next	1.100;

1.100
date	2009.05.22.23.49.13;	author palves;	state Exp;
branches;
next	1.99;

1.99
date	2009.05.18.19.08.10;	author palves;	state Exp;
branches;
next	1.98;

1.98
date	2009.05.05.13.24.49;	author uweigand;	state Exp;
branches;
next	1.97;

1.97
date	2009.02.25.02.14.22;	author teawater;	state Exp;
branches;
next	1.96;

1.96
date	2009.02.21.16.14.49;	author palves;	state Exp;
branches;
next	1.95;

1.95
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.94;

1.94
date	2008.09.22.15.20.08;	author palves;	state Exp;
branches;
next	1.93;

1.93
date	2008.09.11.14.31.00;	author uweigand;	state Exp;
branches;
next	1.92;

1.92
date	2008.09.08.21.51.18;	author palves;	state Exp;
branches;
next	1.91;

1.91
date	2008.08.26.17.33.51;	author uweigand;	state Exp;
branches;
next	1.90;

1.90
date	2008.08.26.17.30.35;	author uweigand;	state Exp;
branches;
next	1.89;

1.89
date	2008.08.26.17.21.29;	author uweigand;	state Exp;
branches;
next	1.88;

1.88
date	2008.08.05.00.16.23;	author shebs;	state Exp;
branches;
next	1.87;

1.87
date	2008.06.03.12.59.37;	author drow;	state Exp;
branches;
next	1.86;

1.86
date	2008.05.19.15.49.14;	author uweigand;	state Exp;
branches;
next	1.85;

1.85
date	2008.03.07.19.31.38;	author brobecke;	state Exp;
branches;
next	1.84;

1.84
date	2008.02.22.19.48.05;	author drow;	state Exp;
branches;
next	1.83;

1.83
date	2008.02.21.01.47.32;	author drow;	state Exp;
branches;
next	1.82;

1.82
date	2008.01.29.21.11.24;	author brobecke;	state Exp;
branches;
next	1.81;

1.81
date	2008.01.07.15.19.58;	author vprus;	state Exp;
branches;
next	1.80;

1.80
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.79;

1.79
date	2007.10.24.21.22.08;	author uweigand;	state Exp;
branches;
next	1.78;

1.78
date	2007.10.24.21.21.15;	author uweigand;	state Exp;
branches;
next	1.77;

1.77
date	2007.10.09.17.59.01;	author drow;	state Exp;
branches;
next	1.76;

1.76
date	2007.09.17.19.32.53;	author brobecke;	state Exp;
branches;
next	1.75;

1.75
date	2007.08.23.18.08.38;	author brobecke;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2007.08.22.14.22.02;	author drow;	state Exp;
branches;
next	1.73;

1.73
date	2007.08.10.20.42.45;	author msnyder;	state Exp;
branches;
next	1.72;

1.72
date	2007.08.08.18.08.52;	author msnyder;	state Exp;
branches;
next	1.71;

1.71
date	2007.07.25.02.12.33;	author msnyder;	state Exp;
branches;
next	1.70;

1.70
date	2007.07.12.20.15.24;	author uweigand;	state Exp;
branches;
next	1.69;

1.69
date	2007.07.03.15.58.42;	author drow;	state Exp;
branches;
next	1.68;

1.68
date	2007.07.03.12.14.43;	author uweigand;	state Exp;
branches;
next	1.67;

1.67
date	2007.06.13.17.30.01;	author uweigand;	state Exp;
branches;
next	1.66;

1.66
date	2007.06.01.14.24.36;	author brobecke;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.16.14.07.55;	author drow;	state Exp;
branches;
next	1.64;

1.64
date	2007.04.13.13.54.06;	author drow;	state Exp;
branches;
next	1.63;

1.63
date	2007.04.10.11.51.17;	author drow;	state Exp;
branches;
next	1.62;

1.62
date	2007.04.10.08.47.53;	author schwab;	state Exp;
branches;
next	1.61;

1.61
date	2007.01.09.17.58.58;	author drow;	state Exp;
branches;
next	1.60;

1.60
date	2006.10.18.15.34.39;	author drow;	state Exp;
branches;
next	1.59;

1.59
date	2006.10.17.20.52.32;	author drow;	state Exp;
branches;
next	1.58;

1.58
date	2006.05.18.20.38.56;	author pgilliam;	state Exp;
branches;
next	1.57;

1.57
date	2006.03.09.00.22.09;	author aoliva;	state Exp;
branches
	1.57.8.1;
next	1.56;

1.56
date	2006.02.28.04.28.47;	author aoliva;	state Exp;
branches;
next	1.55;

1.55
date	2006.02.02.22.15.01;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2005.12.17.22.34.02;	author eliz;	state Exp;
branches;
next	1.53;

1.53
date	2005.08.29.09.27.19;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2005.07.01.15.10.26;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2005.06.13.18.39.11;	author mmitchel;	state Exp;
branches;
next	1.50;

1.50
date	2005.06.06.22.24.25;	author manjo;	state Exp;
branches;
next	1.49;

1.49
date	2005.04.27.20.51.52;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2005.04.27.14.30.15;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2005.02.11.18.13.53;	author cagney;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2005.02.11.04.06.05;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2005.01.14.02.04.02;	author msnyder;	state Exp;
branches;
next	1.44;

1.44
date	2004.06.09.20.03.33;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.15.20.38.08;	author cagney;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2004.03.11.17.04.40;	author kevinb;	state Exp;
branches;
next	1.41;

1.41
date	2004.02.21.18.34.45;	author kettenis;	state Exp;
branches
	1.41.2.1
	1.41.6.1;
next	1.40;

1.40
date	2003.11.08.00.13.02;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2003.11.06.02.52.27;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.31.21.13.45;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2003.08.26.23.35.19;	author jimb;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2003.08.05.02.38.06;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.13.21.56.27;	author jimb;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2003.06.11.13.16.29;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.01.23.00.55;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.15.00.28.23;	author kevinb;	state Exp;
branches
	1.32.4.1
	1.32.8.1;
next	1.31;

1.31
date	2003.04.08.19.21.15;	author ezannoni;	state Exp;
branches;
next	1.30;

1.30
date	2003.04.08.18.52.04;	author ezannoni;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.18.15.55.52;	author cagney;	state Exp;
branches
	1.29.14.1;
next	1.28;

1.28
date	2002.12.21.06.43.24;	author kevinb;	state Exp;
branches;
next	1.27;

1.27
date	2002.10.21.18.42.40;	author ezannoni;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.09.16.39.00;	author kettenis;	state Exp;
branches
	1.26.8.1
	1.26.10.1;
next	1.25;

1.25
date	2002.05.12.01.02.58;	author cagney;	state Exp;
branches
	1.25.2.1
	1.25.4.1;
next	1.24;

1.24
date	2002.04.06.01.51.35;	author hjl;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.05.23.28.13;	author jimb;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.23.06.24.20;	author kevinb;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.01.16.17.08;	author fnf;	state Exp;
branches;
next	1.20;

1.20
date	2001.10.02.23.11.20;	author kevinb;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.26.07.03.13;	author kevinb;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.20.20.07.55;	author kevinb;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.29.19.34.08;	author kevinb;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.02.19.37.59;	author drow;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.05.04.04.15.27;	author kevinb;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.16.18.06.44;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.10.06.17.20;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.06.08.21.16;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.22.03.01.27;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.20.18.05.19;	author hunt;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.27.00.43.26;	author fnasser;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.15.02.04.59;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.01.01.49;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.21.01.09.54;	author msnyder;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.10.01.07.59;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.30.23.31.17;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.24.20.05.35;	author kevinb;	state Exp;
branches;
next	;

1.160.2.1
date	2012.01.06.04.43.30;	author brobecke;	state Exp;
branches;
next	;

1.145.2.1
date	2011.05.24.10.58.08;	author palves;	state Exp;
branches;
next	;

1.124.2.1
date	2010.03.14.08.50.54;	author jkratoch;	state Exp;
branches;
next	1.124.2.2;

1.124.2.2
date	2010.03.14.08.51.49;	author jkratoch;	state Exp;
branches;
next	;

1.75.2.1
date	2007.10.09.18.03.30;	author drow;	state Exp;
branches;
next	;

1.57.8.1
date	2006.08.28.07.48.47;	author nickrob;	state Exp;
branches;
next	;

1.47.2.1
date	2005.06.13.18.43.57;	author mmitchel;	state Exp;
branches;
next	;

1.43.2.1
date	2004.03.24.04.10.01;	author ezannoni;	state Exp;
branches;
next	;

1.41.2.1
date	2004.03.27.17.37.51;	author drow;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2004.09.16.17.01.19;	author drow;	state Exp;
branches;
next	;

1.41.6.1
date	2004.03.09.22.59.01;	author cagney;	state Exp;
branches;
next	1.41.6.2;

1.41.6.2
date	2004.03.16.16.05.56;	author cagney;	state Exp;
branches;
next	1.41.6.3;

1.41.6.3
date	2004.03.21.23.57.35;	author cagney;	state Exp;
branches;
next	;

1.37.2.1
date	2003.09.29.17.35.35;	author ezannoni;	state Exp;
branches;
next	;

1.35.2.1
date	2003.06.13.23.18.30;	author jimb;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2003.06.13.23.57.26;	author jimb;	state Exp;
branches;
next	;

1.32.4.1
date	2003.05.13.00.08.58;	author jimb;	state Exp;
branches;
next	;

1.32.8.1
date	2003.06.11.08.57.46;	author jimb;	state Exp;
branches;
next	1.32.8.2;

1.32.8.2
date	2003.06.11.13.00.34;	author jimb;	state Exp;
branches;
next	1.32.8.3;

1.32.8.3
date	2003.06.11.13.20.06;	author jimb;	state Exp;
branches;
next	1.32.8.4;

1.32.8.4
date	2003.06.12.21.41.12;	author jimb;	state Exp;
branches;
next	1.32.8.5;

1.32.8.5
date	2003.06.12.21.50.31;	author jimb;	state Exp;
branches;
next	;

1.29.14.1
date	2003.04.10.21.33.50;	author cagney;	state Exp;
branches;
next	;

1.26.8.1
date	2002.10.25.23.49.54;	author carlton;	state Exp;
branches;
next	1.26.8.2;

1.26.8.2
date	2002.12.23.19.38.42;	author carlton;	state Exp;
branches;
next	1.26.8.3;

1.26.8.3
date	2003.02.07.19.17.52;	author carlton;	state Exp;
branches;
next	1.26.8.4;

1.26.8.4
date	2003.04.16.19.56.54;	author carlton;	state Exp;
branches;
next	1.26.8.5;

1.26.8.5
date	2003.06.27.21.50.09;	author carlton;	state Exp;
branches;
next	1.26.8.6;

1.26.8.6
date	2003.08.05.17.13.14;	author carlton;	state Exp;
branches;
next	1.26.8.7;

1.26.8.7
date	2003.09.17.21.28.31;	author carlton;	state Exp;
branches;
next	1.26.8.8;

1.26.8.8
date	2003.11.11.23.50.54;	author carlton;	state Exp;
branches;
next	;

1.26.10.1
date	2002.10.26.17.12.08;	author drow;	state Exp;
branches;
next	1.26.10.2;

1.26.10.2
date	2003.12.14.20.27.30;	author drow;	state Exp;
branches;
next	;

1.25.2.1
date	2002.06.15.16.42.55;	author cagney;	state Exp;
branches;
next	;

1.25.4.1
date	2002.06.20.01.33.00;	author kseitz;	state Exp;
branches;
next	1.25.4.2;

1.25.4.2
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.16.2.1
date	2001.07.06.19.17.02;	author dberlin;	state Exp;
branches;
next	;


desc
@@


1.183
log
@ChangeLog:
2013-09-25  Andreas Arnez  <arnez@@linux.vnet.ibm.com>

	PR shlibs/8882
	* solib-svr4.c (svr4_read_so_list): Skip the vDSO when reading
	link map entries.

testsuite/ChangeLog:
2013-09-25  Andreas Arnez  <arnez@@linux.vnet.ibm.com>

	PR shlibs/8882
	* gdb.base/corefile.exp: Add a check to assure warning-free
	core-file load.
@
text
@/* Handle SVR4 shared libraries for GDB, the GNU Debugger.

   Copyright (C) 1990-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"

#include "elf/external.h"
#include "elf/common.h"
#include "elf/mips.h"

#include "symtab.h"
#include "bfd.h"
#include "symfile.h"
#include "objfiles.h"
#include "gdbcore.h"
#include "target.h"
#include "inferior.h"
#include "regcache.h"
#include "gdbthread.h"
#include "observer.h"

#include "gdb_assert.h"

#include "solist.h"
#include "solib.h"
#include "solib-svr4.h"

#include "bfd-target.h"
#include "elf-bfd.h"
#include "exec.h"
#include "auxv.h"
#include "exceptions.h"
#include "gdb_bfd.h"
#include "probe.h"

static struct link_map_offsets *svr4_fetch_link_map_offsets (void);
static int svr4_have_link_map_offsets (void);
static void svr4_relocate_main_executable (void);
static void svr4_free_library_list (void *p_list);

/* Link map info to include in an allocated so_list entry.  */

struct lm_info
  {
    /* Amount by which addresses in the binary should be relocated to
       match the inferior.  The direct inferior value is L_ADDR_INFERIOR.
       When prelinking is involved and the prelink base address changes,
       we may need a different offset - the recomputed offset is in L_ADDR.
       It is commonly the same value.  It is cached as we want to warn about
       the difference and compute it only once.  L_ADDR is valid
       iff L_ADDR_P.  */
    CORE_ADDR l_addr, l_addr_inferior;
    unsigned int l_addr_p : 1;

    /* The target location of lm.  */
    CORE_ADDR lm_addr;

    /* Values read in from inferior's fields of the same name.  */
    CORE_ADDR l_ld, l_next, l_prev, l_name;
  };

/* On SVR4 systems, a list of symbols in the dynamic linker where
   GDB can try to place a breakpoint to monitor shared library
   events.

   If none of these symbols are found, or other errors occur, then
   SVR4 systems will fall back to using a symbol as the "startup
   mapping complete" breakpoint address.  */

static const char * const solib_break_names[] =
{
  "r_debug_state",
  "_r_debug_state",
  "_dl_debug_state",
  "rtld_db_dlactivity",
  "__dl_rtld_db_dlactivity",
  "_rtld_debug_state",

  NULL
};

static const char * const bkpt_names[] =
{
  "_start",
  "__start",
  "main",
  NULL
};

static const  char * const main_name_list[] =
{
  "main_$main",
  NULL
};

/* What to do when a probe stop occurs.  */

enum probe_action
{
  /* Something went seriously wrong.  Stop using probes and
     revert to using the older interface.  */
  PROBES_INTERFACE_FAILED,

  /* No action is required.  The shared object list is still
     valid.  */
  DO_NOTHING,

  /* The shared object list should be reloaded entirely.  */
  FULL_RELOAD,

  /* Attempt to incrementally update the shared object list. If
     the update fails or is not possible, fall back to reloading
     the list in full.  */
  UPDATE_OR_RELOAD,
};

/* A probe's name and its associated action.  */

struct probe_info
{
  /* The name of the probe.  */
  const char *name;

  /* What to do when a probe stop occurs.  */
  enum probe_action action;
};

/* A list of named probes and their associated actions.  If all
   probes are present in the dynamic linker then the probes-based
   interface will be used.  */

static const struct probe_info probe_info[] =
{
  { "init_start", DO_NOTHING },
  { "init_complete", FULL_RELOAD },
  { "map_start", DO_NOTHING },
  { "map_failed", DO_NOTHING },
  { "reloc_complete", UPDATE_OR_RELOAD },
  { "unmap_start", DO_NOTHING },
  { "unmap_complete", FULL_RELOAD },
};

#define NUM_PROBES ARRAY_SIZE (probe_info)

/* Return non-zero if GDB_SO_NAME and INFERIOR_SO_NAME represent
   the same shared library.  */

static int
svr4_same_1 (const char *gdb_so_name, const char *inferior_so_name)
{
  if (strcmp (gdb_so_name, inferior_so_name) == 0)
    return 1;

  /* On Solaris, when starting inferior we think that dynamic linker is
     /usr/lib/ld.so.1, but later on, the table of loaded shared libraries
     contains /lib/ld.so.1.  Sometimes one file is a link to another, but
     sometimes they have identical content, but are not linked to each
     other.  We don't restrict this check for Solaris, but the chances
     of running into this situation elsewhere are very low.  */
  if (strcmp (gdb_so_name, "/usr/lib/ld.so.1") == 0
      && strcmp (inferior_so_name, "/lib/ld.so.1") == 0)
    return 1;

  /* Similarly, we observed the same issue with sparc64, but with
     different locations.  */
  if (strcmp (gdb_so_name, "/usr/lib/sparcv9/ld.so.1") == 0
      && strcmp (inferior_so_name, "/lib/sparcv9/ld.so.1") == 0)
    return 1;

  return 0;
}

static int
svr4_same (struct so_list *gdb, struct so_list *inferior)
{
  return (svr4_same_1 (gdb->so_original_name, inferior->so_original_name));
}

static struct lm_info *
lm_info_read (CORE_ADDR lm_addr)
{
  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();
  gdb_byte *lm;
  struct lm_info *lm_info;
  struct cleanup *back_to;

  lm = xmalloc (lmo->link_map_size);
  back_to = make_cleanup (xfree, lm);

  if (target_read_memory (lm_addr, lm, lmo->link_map_size) != 0)
    {
      warning (_("Error reading shared library list entry at %s"),
	       paddress (target_gdbarch (), lm_addr)),
      lm_info = NULL;
    }
  else
    {
      struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;

      lm_info = xzalloc (sizeof (*lm_info));
      lm_info->lm_addr = lm_addr;

      lm_info->l_addr_inferior = extract_typed_address (&lm[lmo->l_addr_offset],
							ptr_type);
      lm_info->l_ld = extract_typed_address (&lm[lmo->l_ld_offset], ptr_type);
      lm_info->l_next = extract_typed_address (&lm[lmo->l_next_offset],
					       ptr_type);
      lm_info->l_prev = extract_typed_address (&lm[lmo->l_prev_offset],
					       ptr_type);
      lm_info->l_name = extract_typed_address (&lm[lmo->l_name_offset],
					       ptr_type);
    }

  do_cleanups (back_to);

  return lm_info;
}

static int
has_lm_dynamic_from_link_map (void)
{
  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();

  return lmo->l_ld_offset >= 0;
}

static CORE_ADDR
lm_addr_check (const struct so_list *so, bfd *abfd)
{
  if (!so->lm_info->l_addr_p)
    {
      struct bfd_section *dyninfo_sect;
      CORE_ADDR l_addr, l_dynaddr, dynaddr;

      l_addr = so->lm_info->l_addr_inferior;

      if (! abfd || ! has_lm_dynamic_from_link_map ())
	goto set_addr;

      l_dynaddr = so->lm_info->l_ld;

      dyninfo_sect = bfd_get_section_by_name (abfd, ".dynamic");
      if (dyninfo_sect == NULL)
	goto set_addr;

      dynaddr = bfd_section_vma (abfd, dyninfo_sect);

      if (dynaddr + l_addr != l_dynaddr)
	{
	  CORE_ADDR align = 0x1000;
	  CORE_ADDR minpagesize = align;

	  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
	    {
	      Elf_Internal_Ehdr *ehdr = elf_tdata (abfd)->elf_header;
	      Elf_Internal_Phdr *phdr = elf_tdata (abfd)->phdr;
	      int i;

	      align = 1;

	      for (i = 0; i < ehdr->e_phnum; i++)
		if (phdr[i].p_type == PT_LOAD && phdr[i].p_align > align)
		  align = phdr[i].p_align;

	      minpagesize = get_elf_backend_data (abfd)->minpagesize;
	    }

	  /* Turn it into a mask.  */
	  align--;

	  /* If the changes match the alignment requirements, we
	     assume we're using a core file that was generated by the
	     same binary, just prelinked with a different base offset.
	     If it doesn't match, we may have a different binary, the
	     same binary with the dynamic table loaded at an unrelated
	     location, or anything, really.  To avoid regressions,
	     don't adjust the base offset in the latter case, although
	     odds are that, if things really changed, debugging won't
	     quite work.

	     One could expect more the condition
	       ((l_addr & align) == 0 && ((l_dynaddr - dynaddr) & align) == 0)
	     but the one below is relaxed for PPC.  The PPC kernel supports
	     either 4k or 64k page sizes.  To be prepared for 64k pages,
	     PPC ELF files are built using an alignment requirement of 64k.
	     However, when running on a kernel supporting 4k pages, the memory
	     mapping of the library may not actually happen on a 64k boundary!

	     (In the usual case where (l_addr & align) == 0, this check is
	     equivalent to the possibly expected check above.)

	     Even on PPC it must be zero-aligned at least for MINPAGESIZE.  */

	  l_addr = l_dynaddr - dynaddr;

	  if ((l_addr & (minpagesize - 1)) == 0
	      && (l_addr & align) == ((l_dynaddr - dynaddr) & align))
	    {
	      if (info_verbose)
		printf_unfiltered (_("Using PIC (Position Independent Code) "
				     "prelink displacement %s for \"%s\".\n"),
				   paddress (target_gdbarch (), l_addr),
				   so->so_name);
	    }
	  else
	    {
	      /* There is no way to verify the library file matches.  prelink
		 can during prelinking of an unprelinked file (or unprelinking
		 of a prelinked file) shift the DYNAMIC segment by arbitrary
		 offset without any page size alignment.  There is no way to
		 find out the ELF header and/or Program Headers for a limited
		 verification if it they match.  One could do a verification
		 of the DYNAMIC segment.  Still the found address is the best
		 one GDB could find.  */

	      warning (_(".dynamic section for \"%s\" "
			 "is not at the expected address "
			 "(wrong library or version mismatch?)"), so->so_name);
	    }
	}

    set_addr:
      so->lm_info->l_addr = l_addr;
      so->lm_info->l_addr_p = 1;
    }

  return so->lm_info->l_addr;
}

/* Per pspace SVR4 specific data.  */

struct svr4_info
{
  CORE_ADDR debug_base;	/* Base of dynamic linker structures.  */

  /* Validity flag for debug_loader_offset.  */
  int debug_loader_offset_p;

  /* Load address for the dynamic linker, inferred.  */
  CORE_ADDR debug_loader_offset;

  /* Name of the dynamic linker, valid if debug_loader_offset_p.  */
  char *debug_loader_name;

  /* Load map address for the main executable.  */
  CORE_ADDR main_lm_addr;

  CORE_ADDR interp_text_sect_low;
  CORE_ADDR interp_text_sect_high;
  CORE_ADDR interp_plt_sect_low;
  CORE_ADDR interp_plt_sect_high;

  /* Nonzero if the list of objects was last obtained from the target
     via qXfer:libraries-svr4:read.  */
  int using_xfer;

  /* Table of struct probe_and_action instances, used by the
     probes-based interface to map breakpoint addresses to probes
     and their associated actions.  Lookup is performed using
     probe_and_action->probe->address.  */
  htab_t probes_table;

  /* List of objects loaded into the inferior, used by the probes-
     based interface.  */
  struct so_list *solib_list;
};

/* Per-program-space data key.  */
static const struct program_space_data *solib_svr4_pspace_data;

/* Free the probes table.  */

static void
free_probes_table (struct svr4_info *info)
{
  if (info->probes_table == NULL)
    return;

  htab_delete (info->probes_table);
  info->probes_table = NULL;
}

/* Free the solib list.  */

static void
free_solib_list (struct svr4_info *info)
{
  svr4_free_library_list (&info->solib_list);
  info->solib_list = NULL;
}

static void
svr4_pspace_data_cleanup (struct program_space *pspace, void *arg)
{
  struct svr4_info *info;

  info = program_space_data (pspace, solib_svr4_pspace_data);
  if (info == NULL)
    return;

  free_probes_table (info);
  free_solib_list (info);

  xfree (info);
}

/* Get the current svr4 data.  If none is found yet, add it now.  This
   function always returns a valid object.  */

static struct svr4_info *
get_svr4_info (void)
{
  struct svr4_info *info;

  info = program_space_data (current_program_space, solib_svr4_pspace_data);
  if (info != NULL)
    return info;

  info = XZALLOC (struct svr4_info);
  set_program_space_data (current_program_space, solib_svr4_pspace_data, info);
  return info;
}

/* Local function prototypes */

static int match_main (const char *);

/* Read program header TYPE from inferior memory.  The header is found
   by scanning the OS auxillary vector.

   If TYPE == -1, return the program headers instead of the contents of
   one program header.

   Return a pointer to allocated memory holding the program header contents,
   or NULL on failure.  If sucessful, and unless P_SECT_SIZE is NULL, the
   size of those contents is returned to P_SECT_SIZE.  Likewise, the target
   architecture size (32-bit or 64-bit) is returned to P_ARCH_SIZE.  */

static gdb_byte *
read_program_header (int type, int *p_sect_size, int *p_arch_size)
{
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());
  CORE_ADDR at_phdr, at_phent, at_phnum, pt_phdr = 0;
  int arch_size, sect_size;
  CORE_ADDR sect_addr;
  gdb_byte *buf;
  int pt_phdr_p = 0;

  /* Get required auxv elements from target.  */
  if (target_auxv_search (&current_target, AT_PHDR, &at_phdr) <= 0)
    return 0;
  if (target_auxv_search (&current_target, AT_PHENT, &at_phent) <= 0)
    return 0;
  if (target_auxv_search (&current_target, AT_PHNUM, &at_phnum) <= 0)
    return 0;
  if (!at_phdr || !at_phnum)
    return 0;

  /* Determine ELF architecture type.  */
  if (at_phent == sizeof (Elf32_External_Phdr))
    arch_size = 32;
  else if (at_phent == sizeof (Elf64_External_Phdr))
    arch_size = 64;
  else
    return 0;

  /* Find the requested segment.  */
  if (type == -1)
    {
      sect_addr = at_phdr;
      sect_size = at_phent * at_phnum;
    }
  else if (arch_size == 32)
    {
      Elf32_External_Phdr phdr;
      int i;

      /* Search for requested PHDR.  */
      for (i = 0; i < at_phnum; i++)
	{
	  int p_type;

	  if (target_read_memory (at_phdr + i * sizeof (phdr),
				  (gdb_byte *)&phdr, sizeof (phdr)))
	    return 0;

	  p_type = extract_unsigned_integer ((gdb_byte *) phdr.p_type,
					     4, byte_order);

	  if (p_type == PT_PHDR)
	    {
	      pt_phdr_p = 1;
	      pt_phdr = extract_unsigned_integer ((gdb_byte *) phdr.p_vaddr,
						  4, byte_order);
	    }

	  if (p_type == type)
	    break;
	}

      if (i == at_phnum)
	return 0;

      /* Retrieve address and size.  */
      sect_addr = extract_unsigned_integer ((gdb_byte *)phdr.p_vaddr,
					    4, byte_order);
      sect_size = extract_unsigned_integer ((gdb_byte *)phdr.p_memsz,
					    4, byte_order);
    }
  else
    {
      Elf64_External_Phdr phdr;
      int i;

      /* Search for requested PHDR.  */
      for (i = 0; i < at_phnum; i++)
	{
	  int p_type;

	  if (target_read_memory (at_phdr + i * sizeof (phdr),
				  (gdb_byte *)&phdr, sizeof (phdr)))
	    return 0;

	  p_type = extract_unsigned_integer ((gdb_byte *) phdr.p_type,
					     4, byte_order);

	  if (p_type == PT_PHDR)
	    {
	      pt_phdr_p = 1;
	      pt_phdr = extract_unsigned_integer ((gdb_byte *) phdr.p_vaddr,
						  8, byte_order);
	    }

	  if (p_type == type)
	    break;
	}

      if (i == at_phnum)
	return 0;

      /* Retrieve address and size.  */
      sect_addr = extract_unsigned_integer ((gdb_byte *)phdr.p_vaddr,
					    8, byte_order);
      sect_size = extract_unsigned_integer ((gdb_byte *)phdr.p_memsz,
					    8, byte_order);
    }

  /* PT_PHDR is optional, but we really need it
     for PIE to make this work in general.  */

  if (pt_phdr_p)
    {
      /* at_phdr is real address in memory. pt_phdr is what pheader says it is.
	 Relocation offset is the difference between the two. */
      sect_addr = sect_addr + (at_phdr - pt_phdr);
    }

  /* Read in requested program header.  */
  buf = xmalloc (sect_size);
  if (target_read_memory (sect_addr, buf, sect_size))
    {
      xfree (buf);
      return NULL;
    }

  if (p_arch_size)
    *p_arch_size = arch_size;
  if (p_sect_size)
    *p_sect_size = sect_size;

  return buf;
}


/* Return program interpreter string.  */
static char *
find_program_interpreter (void)
{
  gdb_byte *buf = NULL;

  /* If we have an exec_bfd, use its section table.  */
  if (exec_bfd
      && bfd_get_flavour (exec_bfd) == bfd_target_elf_flavour)
   {
     struct bfd_section *interp_sect;

     interp_sect = bfd_get_section_by_name (exec_bfd, ".interp");
     if (interp_sect != NULL)
      {
	int sect_size = bfd_section_size (exec_bfd, interp_sect);

	buf = xmalloc (sect_size);
	bfd_get_section_contents (exec_bfd, interp_sect, buf, 0, sect_size);
      }
   }

  /* If we didn't find it, use the target auxillary vector.  */
  if (!buf)
    buf = read_program_header (PT_INTERP, NULL, NULL);

  return (char *) buf;
}


/* Scan for DYNTAG in .dynamic section of ABFD.  If DYNTAG is found 1 is
   returned and the corresponding PTR is set.  */

static int
scan_dyntag (int dyntag, bfd *abfd, CORE_ADDR *ptr)
{
  int arch_size, step, sect_size;
  long dyn_tag;
  CORE_ADDR dyn_ptr, dyn_addr;
  gdb_byte *bufend, *bufstart, *buf;
  Elf32_External_Dyn *x_dynp_32;
  Elf64_External_Dyn *x_dynp_64;
  struct bfd_section *sect;
  struct target_section *target_section;

  if (abfd == NULL)
    return 0;

  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
    return 0;

  arch_size = bfd_get_arch_size (abfd);
  if (arch_size == -1)
    return 0;

  /* Find the start address of the .dynamic section.  */
  sect = bfd_get_section_by_name (abfd, ".dynamic");
  if (sect == NULL)
    return 0;

  for (target_section = current_target_sections->sections;
       target_section < current_target_sections->sections_end;
       target_section++)
    if (sect == target_section->the_bfd_section)
      break;
  if (target_section < current_target_sections->sections_end)
    dyn_addr = target_section->addr;
  else
    {
      /* ABFD may come from OBJFILE acting only as a symbol file without being
	 loaded into the target (see add_symbol_file_command).  This case is
	 such fallback to the file VMA address without the possibility of
	 having the section relocated to its actual in-memory address.  */

      dyn_addr = bfd_section_vma (abfd, sect);
    }

  /* Read in .dynamic from the BFD.  We will get the actual value
     from memory later.  */
  sect_size = bfd_section_size (abfd, sect);
  buf = bufstart = alloca (sect_size);
  if (!bfd_get_section_contents (abfd, sect,
				 buf, 0, sect_size))
    return 0;

  /* Iterate over BUF and scan for DYNTAG.  If found, set PTR and return.  */
  step = (arch_size == 32) ? sizeof (Elf32_External_Dyn)
			   : sizeof (Elf64_External_Dyn);
  for (bufend = buf + sect_size;
       buf < bufend;
       buf += step)
  {
    if (arch_size == 32)
      {
	x_dynp_32 = (Elf32_External_Dyn *) buf;
	dyn_tag = bfd_h_get_32 (abfd, (bfd_byte *) x_dynp_32->d_tag);
	dyn_ptr = bfd_h_get_32 (abfd, (bfd_byte *) x_dynp_32->d_un.d_ptr);
      }
    else
      {
	x_dynp_64 = (Elf64_External_Dyn *) buf;
	dyn_tag = bfd_h_get_64 (abfd, (bfd_byte *) x_dynp_64->d_tag);
	dyn_ptr = bfd_h_get_64 (abfd, (bfd_byte *) x_dynp_64->d_un.d_ptr);
      }
     if (dyn_tag == DT_NULL)
       return 0;
     if (dyn_tag == dyntag)
       {
	 /* If requested, try to read the runtime value of this .dynamic
	    entry.  */
	 if (ptr)
	   {
	     struct type *ptr_type;
	     gdb_byte ptr_buf[8];
	     CORE_ADDR ptr_addr;

	     ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;
	     ptr_addr = dyn_addr + (buf - bufstart) + arch_size / 8;
	     if (target_read_memory (ptr_addr, ptr_buf, arch_size / 8) == 0)
	       dyn_ptr = extract_typed_address (ptr_buf, ptr_type);
	     *ptr = dyn_ptr;
	   }
	 return 1;
       }
  }

  return 0;
}

/* Scan for DYNTAG in .dynamic section of the target's main executable,
   found by consulting the OS auxillary vector.  If DYNTAG is found 1 is
   returned and the corresponding PTR is set.  */

static int
scan_dyntag_auxv (int dyntag, CORE_ADDR *ptr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());
  int sect_size, arch_size, step;
  long dyn_tag;
  CORE_ADDR dyn_ptr;
  gdb_byte *bufend, *bufstart, *buf;

  /* Read in .dynamic section.  */
  buf = bufstart = read_program_header (PT_DYNAMIC, &sect_size, &arch_size);
  if (!buf)
    return 0;

  /* Iterate over BUF and scan for DYNTAG.  If found, set PTR and return.  */
  step = (arch_size == 32) ? sizeof (Elf32_External_Dyn)
			   : sizeof (Elf64_External_Dyn);
  for (bufend = buf + sect_size;
       buf < bufend;
       buf += step)
  {
    if (arch_size == 32)
      {
	Elf32_External_Dyn *dynp = (Elf32_External_Dyn *) buf;

	dyn_tag = extract_unsigned_integer ((gdb_byte *) dynp->d_tag,
					    4, byte_order);
	dyn_ptr = extract_unsigned_integer ((gdb_byte *) dynp->d_un.d_ptr,
					    4, byte_order);
      }
    else
      {
	Elf64_External_Dyn *dynp = (Elf64_External_Dyn *) buf;

	dyn_tag = extract_unsigned_integer ((gdb_byte *) dynp->d_tag,
					    8, byte_order);
	dyn_ptr = extract_unsigned_integer ((gdb_byte *) dynp->d_un.d_ptr,
					    8, byte_order);
      }
    if (dyn_tag == DT_NULL)
      break;

    if (dyn_tag == dyntag)
      {
	if (ptr)
	  *ptr = dyn_ptr;

	xfree (bufstart);
	return 1;
      }
  }

  xfree (bufstart);
  return 0;
}

/* Locate the base address of dynamic linker structs for SVR4 elf
   targets.

   For SVR4 elf targets the address of the dynamic linker's runtime
   structure is contained within the dynamic info section in the
   executable file.  The dynamic section is also mapped into the
   inferior address space.  Because the runtime loader fills in the
   real address before starting the inferior, we have to read in the
   dynamic info section from the inferior address space.
   If there are any errors while trying to find the address, we
   silently return 0, otherwise the found address is returned.  */

static CORE_ADDR
elf_locate_base (void)
{
  struct minimal_symbol *msymbol;
  CORE_ADDR dyn_ptr;

  /* Look for DT_MIPS_RLD_MAP first.  MIPS executables use this
     instead of DT_DEBUG, although they sometimes contain an unused
     DT_DEBUG.  */
  if (scan_dyntag (DT_MIPS_RLD_MAP, exec_bfd, &dyn_ptr)
      || scan_dyntag_auxv (DT_MIPS_RLD_MAP, &dyn_ptr))
    {
      struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;
      gdb_byte *pbuf;
      int pbuf_size = TYPE_LENGTH (ptr_type);

      pbuf = alloca (pbuf_size);
      /* DT_MIPS_RLD_MAP contains a pointer to the address
	 of the dynamic link structure.  */
      if (target_read_memory (dyn_ptr, pbuf, pbuf_size))
	return 0;
      return extract_typed_address (pbuf, ptr_type);
    }

  /* Find DT_DEBUG.  */
  if (scan_dyntag (DT_DEBUG, exec_bfd, &dyn_ptr)
      || scan_dyntag_auxv (DT_DEBUG, &dyn_ptr))
    return dyn_ptr;

  /* This may be a static executable.  Look for the symbol
     conventionally named _r_debug, as a last resort.  */
  msymbol = lookup_minimal_symbol ("_r_debug", NULL, symfile_objfile);
  if (msymbol != NULL)
    return SYMBOL_VALUE_ADDRESS (msymbol);

  /* DT_DEBUG entry not found.  */
  return 0;
}

/* Locate the base address of dynamic linker structs.

   For both the SunOS and SVR4 shared library implementations, if the
   inferior executable has been linked dynamically, there is a single
   address somewhere in the inferior's data space which is the key to
   locating all of the dynamic linker's runtime structures.  This
   address is the value of the debug base symbol.  The job of this
   function is to find and return that address, or to return 0 if there
   is no such address (the executable is statically linked for example).

   For SunOS, the job is almost trivial, since the dynamic linker and
   all of it's structures are statically linked to the executable at
   link time.  Thus the symbol for the address we are looking for has
   already been added to the minimal symbol table for the executable's
   objfile at the time the symbol file's symbols were read, and all we
   have to do is look it up there.  Note that we explicitly do NOT want
   to find the copies in the shared library.

   The SVR4 version is a bit more complicated because the address
   is contained somewhere in the dynamic info section.  We have to go
   to a lot more work to discover the address of the debug base symbol.
   Because of this complexity, we cache the value we find and return that
   value on subsequent invocations.  Note there is no copy in the
   executable symbol tables.  */

static CORE_ADDR
locate_base (struct svr4_info *info)
{
  /* Check to see if we have a currently valid address, and if so, avoid
     doing all this work again and just return the cached address.  If
     we have no cached address, try to locate it in the dynamic info
     section for ELF executables.  There's no point in doing any of this
     though if we don't have some link map offsets to work with.  */

  if (info->debug_base == 0 && svr4_have_link_map_offsets ())
    info->debug_base = elf_locate_base ();
  return info->debug_base;
}

/* Find the first element in the inferior's dynamic link map, and
   return its address in the inferior.  Return zero if the address
   could not be determined.

   FIXME: Perhaps we should validate the info somehow, perhaps by
   checking r_version for a known version number, or r_state for
   RT_CONSISTENT.  */

static CORE_ADDR
solib_svr4_r_map (struct svr4_info *info)
{
  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();
  struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;
  CORE_ADDR addr = 0;
  volatile struct gdb_exception ex;

  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      addr = read_memory_typed_address (info->debug_base + lmo->r_map_offset,
                                        ptr_type);
    }
  exception_print (gdb_stderr, ex);
  return addr;
}

/* Find r_brk from the inferior's debug base.  */

static CORE_ADDR
solib_svr4_r_brk (struct svr4_info *info)
{
  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();
  struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;

  return read_memory_typed_address (info->debug_base + lmo->r_brk_offset,
				    ptr_type);
}

/* Find the link map for the dynamic linker (if it is not in the
   normal list of loaded shared objects).  */

static CORE_ADDR
solib_svr4_r_ldsomap (struct svr4_info *info)
{
  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();
  struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());
  ULONGEST version;

  /* Check version, and return zero if `struct r_debug' doesn't have
     the r_ldsomap member.  */
  version
    = read_memory_unsigned_integer (info->debug_base + lmo->r_version_offset,
				    lmo->r_version_size, byte_order);
  if (version < 2 || lmo->r_ldsomap_offset == -1)
    return 0;

  return read_memory_typed_address (info->debug_base + lmo->r_ldsomap_offset,
				    ptr_type);
}

/* On Solaris systems with some versions of the dynamic linker,
   ld.so's l_name pointer points to the SONAME in the string table
   rather than into writable memory.  So that GDB can find shared
   libraries when loading a core file generated by gcore, ensure that
   memory areas containing the l_name string are saved in the core
   file.  */

static int
svr4_keep_data_in_core (CORE_ADDR vaddr, unsigned long size)
{
  struct svr4_info *info;
  CORE_ADDR ldsomap;
  struct so_list *new;
  struct cleanup *old_chain;
  CORE_ADDR name_lm;

  info = get_svr4_info ();

  info->debug_base = 0;
  locate_base (info);
  if (!info->debug_base)
    return 0;

  ldsomap = solib_svr4_r_ldsomap (info);
  if (!ldsomap)
    return 0;

  new = XZALLOC (struct so_list);
  old_chain = make_cleanup (xfree, new);
  new->lm_info = lm_info_read (ldsomap);
  make_cleanup (xfree, new->lm_info);
  name_lm = new->lm_info ? new->lm_info->l_name : 0;
  do_cleanups (old_chain);

  return (name_lm >= vaddr && name_lm < vaddr + size);
}

/* Implement the "open_symbol_file_object" target_so_ops method.

   If no open symbol file, attempt to locate and open the main symbol
   file.  On SVR4 systems, this is the first link map entry.  If its
   name is here, we can open it.  Useful when attaching to a process
   without first loading its symbol file.  */

static int
open_symbol_file_object (void *from_ttyp)
{
  CORE_ADDR lm, l_name;
  char *filename;
  int errcode;
  int from_tty = *(int *)from_ttyp;
  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();
  struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;
  int l_name_size = TYPE_LENGTH (ptr_type);
  gdb_byte *l_name_buf = xmalloc (l_name_size);
  struct cleanup *cleanups = make_cleanup (xfree, l_name_buf);
  struct svr4_info *info = get_svr4_info ();

  if (symfile_objfile)
    if (!query (_("Attempt to reload symbols from process? ")))
      {
	do_cleanups (cleanups);
	return 0;
      }

  /* Always locate the debug struct, in case it has moved.  */
  info->debug_base = 0;
  if (locate_base (info) == 0)
    {
      do_cleanups (cleanups);
      return 0;	/* failed somehow...  */
    }

  /* First link map member should be the executable.  */
  lm = solib_svr4_r_map (info);
  if (lm == 0)
    {
      do_cleanups (cleanups);
      return 0;	/* failed somehow...  */
    }

  /* Read address of name from target memory to GDB.  */
  read_memory (lm + lmo->l_name_offset, l_name_buf, l_name_size);

  /* Convert the address to host format.  */
  l_name = extract_typed_address (l_name_buf, ptr_type);

  if (l_name == 0)
    {
      do_cleanups (cleanups);
      return 0;		/* No filename.  */
    }

  /* Now fetch the filename from target memory.  */
  target_read_string (l_name, &filename, SO_NAME_MAX_PATH_SIZE - 1, &errcode);
  make_cleanup (xfree, filename);

  if (errcode)
    {
      warning (_("failed to read exec filename from attached file: %s"),
	       safe_strerror (errcode));
      do_cleanups (cleanups);
      return 0;
    }

  /* Have a pathname: read the symbol file.  */
  symbol_file_add_main (filename, from_tty);

  do_cleanups (cleanups);
  return 1;
}

/* Data exchange structure for the XML parser as returned by
   svr4_current_sos_via_xfer_libraries.  */

struct svr4_library_list
{
  struct so_list *head, **tailp;

  /* Inferior address of struct link_map used for the main executable.  It is
     NULL if not known.  */
  CORE_ADDR main_lm;
};

/* Implementation for target_so_ops.free_so.  */

static void
svr4_free_so (struct so_list *so)
{
  xfree (so->lm_info);
}

/* Implement target_so_ops.clear_so.  */

static void
svr4_clear_so (struct so_list *so)
{
  if (so->lm_info != NULL)
    so->lm_info->l_addr_p = 0;
}

/* Free so_list built so far (called via cleanup).  */

static void
svr4_free_library_list (void *p_list)
{
  struct so_list *list = *(struct so_list **) p_list;

  while (list != NULL)
    {
      struct so_list *next = list->next;

      free_so (list);
      list = next;
    }
}

/* Copy library list.  */

static struct so_list *
svr4_copy_library_list (struct so_list *src)
{
  struct so_list *dst = NULL;
  struct so_list **link = &dst;

  while (src != NULL)
    {
      struct so_list *new;

      new = xmalloc (sizeof (struct so_list));
      memcpy (new, src, sizeof (struct so_list));

      new->lm_info = xmalloc (sizeof (struct lm_info));
      memcpy (new->lm_info, src->lm_info, sizeof (struct lm_info));

      new->next = NULL;
      *link = new;
      link = &new->next;

      src = src->next;
    }

  return dst;
}

#ifdef HAVE_LIBEXPAT

#include "xml-support.h"

/* Handle the start of a <library> element.  Note: new elements are added
   at the tail of the list, keeping the list in order.  */

static void
library_list_start_library (struct gdb_xml_parser *parser,
			    const struct gdb_xml_element *element,
			    void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  struct svr4_library_list *list = user_data;
  const char *name = xml_find_attribute (attributes, "name")->value;
  ULONGEST *lmp = xml_find_attribute (attributes, "lm")->value;
  ULONGEST *l_addrp = xml_find_attribute (attributes, "l_addr")->value;
  ULONGEST *l_ldp = xml_find_attribute (attributes, "l_ld")->value;
  struct so_list *new_elem;

  new_elem = XZALLOC (struct so_list);
  new_elem->lm_info = XZALLOC (struct lm_info);
  new_elem->lm_info->lm_addr = *lmp;
  new_elem->lm_info->l_addr_inferior = *l_addrp;
  new_elem->lm_info->l_ld = *l_ldp;

  strncpy (new_elem->so_name, name, sizeof (new_elem->so_name) - 1);
  new_elem->so_name[sizeof (new_elem->so_name) - 1] = 0;
  strcpy (new_elem->so_original_name, new_elem->so_name);

  *list->tailp = new_elem;
  list->tailp = &new_elem->next;
}

/* Handle the start of a <library-list-svr4> element.  */

static void
svr4_library_list_start_list (struct gdb_xml_parser *parser,
			      const struct gdb_xml_element *element,
			      void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  struct svr4_library_list *list = user_data;
  const char *version = xml_find_attribute (attributes, "version")->value;
  struct gdb_xml_value *main_lm = xml_find_attribute (attributes, "main-lm");

  if (strcmp (version, "1.0") != 0)
    gdb_xml_error (parser,
		   _("SVR4 Library list has unsupported version \"%s\""),
		   version);

  if (main_lm)
    list->main_lm = *(ULONGEST *) main_lm->value;
}

/* The allowed elements and attributes for an XML library list.
   The root element is a <library-list>.  */

static const struct gdb_xml_attribute svr4_library_attributes[] =
{
  { "name", GDB_XML_AF_NONE, NULL, NULL },
  { "lm", GDB_XML_AF_NONE, gdb_xml_parse_attr_ulongest, NULL },
  { "l_addr", GDB_XML_AF_NONE, gdb_xml_parse_attr_ulongest, NULL },
  { "l_ld", GDB_XML_AF_NONE, gdb_xml_parse_attr_ulongest, NULL },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

static const struct gdb_xml_element svr4_library_list_children[] =
{
  {
    "library", svr4_library_attributes, NULL,
    GDB_XML_EF_REPEATABLE | GDB_XML_EF_OPTIONAL,
    library_list_start_library, NULL
  },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

static const struct gdb_xml_attribute svr4_library_list_attributes[] =
{
  { "version", GDB_XML_AF_NONE, NULL, NULL },
  { "main-lm", GDB_XML_AF_OPTIONAL, gdb_xml_parse_attr_ulongest, NULL },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

static const struct gdb_xml_element svr4_library_list_elements[] =
{
  { "library-list-svr4", svr4_library_list_attributes, svr4_library_list_children,
    GDB_XML_EF_NONE, svr4_library_list_start_list, NULL },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

/* Parse qXfer:libraries:read packet into *SO_LIST_RETURN.  Return 1 if

   Return 0 if packet not supported, *SO_LIST_RETURN is not modified in such
   case.  Return 1 if *SO_LIST_RETURN contains the library list, it may be
   empty, caller is responsible for freeing all its entries.  */

static int
svr4_parse_libraries (const char *document, struct svr4_library_list *list)
{
  struct cleanup *back_to = make_cleanup (svr4_free_library_list,
					  &list->head);

  memset (list, 0, sizeof (*list));
  list->tailp = &list->head;
  if (gdb_xml_parse_quick (_("target library list"), "library-list.dtd",
			   svr4_library_list_elements, document, list) == 0)
    {
      /* Parsed successfully, keep the result.  */
      discard_cleanups (back_to);
      return 1;
    }

  do_cleanups (back_to);
  return 0;
}

/* Attempt to get so_list from target via qXfer:libraries-svr4:read packet.

   Return 0 if packet not supported, *SO_LIST_RETURN is not modified in such
   case.  Return 1 if *SO_LIST_RETURN contains the library list, it may be
   empty, caller is responsible for freeing all its entries.

   Note that ANNEX must be NULL if the remote does not explicitly allow
   qXfer:libraries-svr4:read packets with non-empty annexes.  Support for
   this can be checked using target_augmented_libraries_svr4_read ().  */

static int
svr4_current_sos_via_xfer_libraries (struct svr4_library_list *list,
				     const char *annex)
{
  char *svr4_library_document;
  int result;
  struct cleanup *back_to;

  gdb_assert (annex == NULL || target_augmented_libraries_svr4_read ());

  /* Fetch the list of shared libraries.  */
  svr4_library_document = target_read_stralloc (&current_target,
						TARGET_OBJECT_LIBRARIES_SVR4,
						annex);
  if (svr4_library_document == NULL)
    return 0;

  back_to = make_cleanup (xfree, svr4_library_document);
  result = svr4_parse_libraries (svr4_library_document, list);
  do_cleanups (back_to);

  return result;
}

#else

static int
svr4_current_sos_via_xfer_libraries (struct svr4_library_list *list,
				     const char *annex)
{
  return 0;
}

#endif

/* If no shared library information is available from the dynamic
   linker, build a fallback list from other sources.  */

static struct so_list *
svr4_default_sos (void)
{
  struct svr4_info *info = get_svr4_info ();
  struct so_list *new;

  if (!info->debug_loader_offset_p)
    return NULL;

  new = XZALLOC (struct so_list);

  new->lm_info = xzalloc (sizeof (struct lm_info));

  /* Nothing will ever check the other fields if we set l_addr_p.  */
  new->lm_info->l_addr = info->debug_loader_offset;
  new->lm_info->l_addr_p = 1;

  strncpy (new->so_name, info->debug_loader_name, SO_NAME_MAX_PATH_SIZE - 1);
  new->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
  strcpy (new->so_original_name, new->so_name);

  return new;
}

/* Read the whole inferior libraries chain starting at address LM.
   Expect the first entry in the chain's previous entry to be PREV_LM.
   Add the entries to the tail referenced by LINK_PTR_PTR.  Ignore the
   first entry if IGNORE_FIRST and set global MAIN_LM_ADDR according
   to it.  Returns nonzero upon success.  If zero is returned the
   entries stored to LINK_PTR_PTR are still valid although they may
   represent only part of the inferior library list.  */

static int
svr4_read_so_list (CORE_ADDR lm, CORE_ADDR prev_lm,
		   struct so_list ***link_ptr_ptr, int ignore_first)
{
  struct so_list *first = NULL;
  CORE_ADDR next_lm;

  for (; lm != 0; prev_lm = lm, lm = next_lm)
    {
      struct so_list *new;
      struct cleanup *old_chain;
      int errcode;
      char *buffer;

      new = XZALLOC (struct so_list);
      old_chain = make_cleanup_free_so (new);

      new->lm_info = lm_info_read (lm);
      if (new->lm_info == NULL)
	{
	  do_cleanups (old_chain);
	  return 0;
	}

      next_lm = new->lm_info->l_next;

      if (new->lm_info->l_prev != prev_lm)
	{
	  warning (_("Corrupted shared library list: %s != %s"),
		   paddress (target_gdbarch (), prev_lm),
		   paddress (target_gdbarch (), new->lm_info->l_prev));
	  do_cleanups (old_chain);
	  return 0;
	}

      /* For SVR4 versions, the first entry in the link map is for the
         inferior executable, so we must ignore it.  For some versions of
         SVR4, it has no name.  For others (Solaris 2.3 for example), it
         does have a name, so we can no longer use a missing name to
         decide when to ignore it.  */
      if (ignore_first && new->lm_info->l_prev == 0)
	{
	  struct svr4_info *info = get_svr4_info ();

	  first = new;
	  info->main_lm_addr = new->lm_info->lm_addr;
	  do_cleanups (old_chain);
	  continue;
	}

      /* Extract this shared object's name.  */
      target_read_string (new->lm_info->l_name, &buffer,
			  SO_NAME_MAX_PATH_SIZE - 1, &errcode);
      if (errcode != 0)
	{
	  /* If this entry's l_name address matches that of the
	     inferior executable, then this is not a normal shared
	     object, but (most likely) a vDSO.  In this case, silently
	     skip it; otherwise emit a warning. */
	  if (first == NULL
	      || new->lm_info->l_name != first->lm_info->l_name)
	    warning (_("Can't read pathname for load map: %s."),
		     safe_strerror (errcode));
	  do_cleanups (old_chain);
	  continue;
	}

      strncpy (new->so_name, buffer, SO_NAME_MAX_PATH_SIZE - 1);
      new->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
      strcpy (new->so_original_name, new->so_name);
      xfree (buffer);

      /* If this entry has no name, or its name matches the name
	 for the main executable, don't include it in the list.  */
      if (! new->so_name[0] || match_main (new->so_name))
	{
	  do_cleanups (old_chain);
	  continue;
	}

      discard_cleanups (old_chain);
      new->next = 0;
      **link_ptr_ptr = new;
      *link_ptr_ptr = &new->next;
    }

  return 1;
}

/* Read the full list of currently loaded shared objects directly
   from the inferior, without referring to any libraries read and
   stored by the probes interface.  Handle special cases relating
   to the first elements of the list.  */

static struct so_list *
svr4_current_sos_direct (struct svr4_info *info)
{
  CORE_ADDR lm;
  struct so_list *head = NULL;
  struct so_list **link_ptr = &head;
  struct cleanup *back_to;
  int ignore_first;
  struct svr4_library_list library_list;

  /* Fall back to manual examination of the target if the packet is not
     supported or gdbserver failed to find DT_DEBUG.  gdb.server/solib-list.exp
     tests a case where gdbserver cannot find the shared libraries list while
     GDB itself is able to find it via SYMFILE_OBJFILE.

     Unfortunately statically linked inferiors will also fall back through this
     suboptimal code path.  */

  info->using_xfer = svr4_current_sos_via_xfer_libraries (&library_list,
							  NULL);
  if (info->using_xfer)
    {
      if (library_list.main_lm)
	info->main_lm_addr = library_list.main_lm;

      return library_list.head ? library_list.head : svr4_default_sos ();
    }

  /* Always locate the debug struct, in case it has moved.  */
  info->debug_base = 0;
  locate_base (info);

  /* If we can't find the dynamic linker's base structure, this
     must not be a dynamically linked executable.  Hmm.  */
  if (! info->debug_base)
    return svr4_default_sos ();

  /* Assume that everything is a library if the dynamic loader was loaded
     late by a static executable.  */
  if (exec_bfd && bfd_get_section_by_name (exec_bfd, ".dynamic") == NULL)
    ignore_first = 0;
  else
    ignore_first = 1;

  back_to = make_cleanup (svr4_free_library_list, &head);

  /* Walk the inferior's link map list, and build our list of
     `struct so_list' nodes.  */
  lm = solib_svr4_r_map (info);
  if (lm)
    svr4_read_so_list (lm, 0, &link_ptr, ignore_first);

  /* On Solaris, the dynamic linker is not in the normal list of
     shared objects, so make sure we pick it up too.  Having
     symbol information for the dynamic linker is quite crucial
     for skipping dynamic linker resolver code.  */
  lm = solib_svr4_r_ldsomap (info);
  if (lm)
    svr4_read_so_list (lm, 0, &link_ptr, 0);

  discard_cleanups (back_to);

  if (head == NULL)
    return svr4_default_sos ();

  return head;
}

/* Implement the "current_sos" target_so_ops method.  */

static struct so_list *
svr4_current_sos (void)
{
  struct svr4_info *info = get_svr4_info ();

  /* If the solib list has been read and stored by the probes
     interface then we return a copy of the stored list.  */
  if (info->solib_list != NULL)
    return svr4_copy_library_list (info->solib_list);

  /* Otherwise obtain the solib list directly from the inferior.  */
  return svr4_current_sos_direct (info);
}

/* Get the address of the link_map for a given OBJFILE.  */

CORE_ADDR
svr4_fetch_objfile_link_map (struct objfile *objfile)
{
  struct so_list *so;
  struct svr4_info *info = get_svr4_info ();

  /* Cause svr4_current_sos() to be run if it hasn't been already.  */
  if (info->main_lm_addr == 0)
    solib_add (NULL, 0, &current_target, auto_solib_add);

  /* svr4_current_sos() will set main_lm_addr for the main executable.  */
  if (objfile == symfile_objfile)
    return info->main_lm_addr;

  /* The other link map addresses may be found by examining the list
     of shared libraries.  */
  for (so = master_so_list (); so; so = so->next)
    if (so->objfile == objfile)
      return so->lm_info->lm_addr;

  /* Not found!  */
  return 0;
}

/* On some systems, the only way to recognize the link map entry for
   the main executable file is by looking at its name.  Return
   non-zero iff SONAME matches one of the known main executable names.  */

static int
match_main (const char *soname)
{
  const char * const *mainp;

  for (mainp = main_name_list; *mainp != NULL; mainp++)
    {
      if (strcmp (soname, *mainp) == 0)
	return (1);
    }

  return (0);
}

/* Return 1 if PC lies in the dynamic symbol resolution code of the
   SVR4 run time loader.  */

int
svr4_in_dynsym_resolve_code (CORE_ADDR pc)
{
  struct svr4_info *info = get_svr4_info ();

  return ((pc >= info->interp_text_sect_low
	   && pc < info->interp_text_sect_high)
	  || (pc >= info->interp_plt_sect_low
	      && pc < info->interp_plt_sect_high)
	  || in_plt_section (pc)
	  || in_gnu_ifunc_stub (pc));
}

/* Given an executable's ABFD and target, compute the entry-point
   address.  */

static CORE_ADDR
exec_entry_point (struct bfd *abfd, struct target_ops *targ)
{
  CORE_ADDR addr;

  /* KevinB wrote ... for most targets, the address returned by
     bfd_get_start_address() is the entry point for the start
     function.  But, for some targets, bfd_get_start_address() returns
     the address of a function descriptor from which the entry point
     address may be extracted.  This address is extracted by
     gdbarch_convert_from_func_ptr_addr().  The method
     gdbarch_convert_from_func_ptr_addr() is the merely the identify
     function for targets which don't use function descriptors.  */
  addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch (),
					     bfd_get_start_address (abfd),
					     targ);
  return gdbarch_addr_bits_remove (target_gdbarch (), addr);
}

/* A probe and its associated action.  */

struct probe_and_action
{
  /* The probe.  */
  struct probe *probe;

  /* The action.  */
  enum probe_action action;
};

/* Returns a hash code for the probe_and_action referenced by p.  */

static hashval_t
hash_probe_and_action (const void *p)
{
  const struct probe_and_action *pa = p;

  return (hashval_t) pa->probe->address;
}

/* Returns non-zero if the probe_and_actions referenced by p1 and p2
   are equal.  */

static int
equal_probe_and_action (const void *p1, const void *p2)
{
  const struct probe_and_action *pa1 = p1;
  const struct probe_and_action *pa2 = p2;

  return pa1->probe->address == pa2->probe->address;
}

/* Register a solib event probe and its associated action in the
   probes table.  */

static void
register_solib_event_probe (struct probe *probe, enum probe_action action)
{
  struct svr4_info *info = get_svr4_info ();
  struct probe_and_action lookup, *pa;
  void **slot;

  /* Create the probes table, if necessary.  */
  if (info->probes_table == NULL)
    info->probes_table = htab_create_alloc (1, hash_probe_and_action,
					    equal_probe_and_action,
					    xfree, xcalloc, xfree);

  lookup.probe = probe;
  slot = htab_find_slot (info->probes_table, &lookup, INSERT);
  gdb_assert (*slot == HTAB_EMPTY_ENTRY);

  pa = XCNEW (struct probe_and_action);
  pa->probe = probe;
  pa->action = action;

  *slot = pa;
}

/* Get the solib event probe at the specified location, and the
   action associated with it.  Returns NULL if no solib event probe
   was found.  */

static struct probe_and_action *
solib_event_probe_at (struct svr4_info *info, CORE_ADDR address)
{
  struct probe lookup_probe;
  struct probe_and_action lookup;
  void **slot;

  lookup_probe.address = address;
  lookup.probe = &lookup_probe;
  slot = htab_find_slot (info->probes_table, &lookup, NO_INSERT);

  if (slot == NULL)
    return NULL;

  return (struct probe_and_action *) *slot;
}

/* Decide what action to take when the specified solib event probe is
   hit.  */

static enum probe_action
solib_event_probe_action (struct probe_and_action *pa)
{
  enum probe_action action;
  unsigned probe_argc;

  action = pa->action;
  if (action == DO_NOTHING || action == PROBES_INTERFACE_FAILED)
    return action;

  gdb_assert (action == FULL_RELOAD || action == UPDATE_OR_RELOAD);

  /* Check that an appropriate number of arguments has been supplied.
     We expect:
       arg0: Lmid_t lmid (mandatory)
       arg1: struct r_debug *debug_base (mandatory)
       arg2: struct link_map *new (optional, for incremental updates)  */
  probe_argc = get_probe_argument_count (pa->probe);
  if (probe_argc == 2)
    action = FULL_RELOAD;
  else if (probe_argc < 2)
    action = PROBES_INTERFACE_FAILED;

  return action;
}

/* Populate the shared object list by reading the entire list of
   shared objects from the inferior.  Handle special cases relating
   to the first elements of the list.  Returns nonzero on success.  */

static int
solist_update_full (struct svr4_info *info)
{
  free_solib_list (info);
  info->solib_list = svr4_current_sos_direct (info);

  return 1;
}

/* Update the shared object list starting from the link-map entry
   passed by the linker in the probe's third argument.  Returns
   nonzero if the list was successfully updated, or zero to indicate
   failure.  */

static int
solist_update_incremental (struct svr4_info *info, CORE_ADDR lm)
{
  struct so_list *tail;
  CORE_ADDR prev_lm;

  /* svr4_current_sos_direct contains logic to handle a number of
     special cases relating to the first elements of the list.  To
     avoid duplicating this logic we defer to solist_update_full
     if the list is empty.  */
  if (info->solib_list == NULL)
    return 0;

  /* Fall back to a full update if we are using a remote target
     that does not support incremental transfers.  */
  if (info->using_xfer && !target_augmented_libraries_svr4_read ())
    return 0;

  /* Walk to the end of the list.  */
  for (tail = info->solib_list; tail->next != NULL; tail = tail->next)
    /* Nothing.  */;
  prev_lm = tail->lm_info->lm_addr;

  /* Read the new objects.  */
  if (info->using_xfer)
    {
      struct svr4_library_list library_list;
      char annex[64];

      xsnprintf (annex, sizeof (annex), "start=%s;prev=%s",
		 phex_nz (lm, sizeof (lm)),
		 phex_nz (prev_lm, sizeof (prev_lm)));
      if (!svr4_current_sos_via_xfer_libraries (&library_list, annex))
	return 0;

      tail->next = library_list.head;
    }
  else
    {
      struct so_list **link = &tail->next;

      /* IGNORE_FIRST may safely be set to zero here because the
	 above check and deferral to solist_update_full ensures
	 that this call to svr4_read_so_list will never see the
	 first element.  */
      if (!svr4_read_so_list (lm, prev_lm, &link, 0))
	return 0;
    }

  return 1;
}

/* Disable the probes-based linker interface and revert to the
   original interface.  We don't reset the breakpoints as the
   ones set up for the probes-based interface are adequate.  */

static void
disable_probes_interface_cleanup (void *arg)
{
  struct svr4_info *info = get_svr4_info ();

  warning (_("Probes-based dynamic linker interface failed.\n"
	     "Reverting to original interface.\n"));

  free_probes_table (info);
  free_solib_list (info);
}

/* Update the solib list as appropriate when using the
   probes-based linker interface.  Do nothing if using the
   standard interface.  */

static void
svr4_handle_solib_event (void)
{
  struct svr4_info *info = get_svr4_info ();
  struct probe_and_action *pa;
  enum probe_action action;
  struct cleanup *old_chain, *usm_chain;
  struct value *val;
  CORE_ADDR pc, debug_base, lm = 0;
  int is_initial_ns;

  /* Do nothing if not using the probes interface.  */
  if (info->probes_table == NULL)
    return;

  /* If anything goes wrong we revert to the original linker
     interface.  */
  old_chain = make_cleanup (disable_probes_interface_cleanup, NULL);

  pc = regcache_read_pc (get_current_regcache ());
  pa = solib_event_probe_at (info, pc);
  if (pa == NULL)
    {
      do_cleanups (old_chain);
      return;
    }

  action = solib_event_probe_action (pa);
  if (action == PROBES_INTERFACE_FAILED)
    {
      do_cleanups (old_chain);
      return;
    }

  if (action == DO_NOTHING)
    {
      discard_cleanups (old_chain);
      return;
    }

  /* evaluate_probe_argument looks up symbols in the dynamic linker
     using find_pc_section.  find_pc_section is accelerated by a cache
     called the section map.  The section map is invalidated every
     time a shared library is loaded or unloaded, and if the inferior
     is generating a lot of shared library events then the section map
     will be updated every time svr4_handle_solib_event is called.
     We called find_pc_section in svr4_create_solib_event_breakpoints,
     so we can guarantee that the dynamic linker's sections are in the
     section map.  We can therefore inhibit section map updates across
     these calls to evaluate_probe_argument and save a lot of time.  */
  inhibit_section_map_updates (current_program_space);
  usm_chain = make_cleanup (resume_section_map_updates_cleanup,
			    current_program_space);

  val = evaluate_probe_argument (pa->probe, 1);
  if (val == NULL)
    {
      do_cleanups (old_chain);
      return;
    }

  debug_base = value_as_address (val);
  if (debug_base == 0)
    {
      do_cleanups (old_chain);
      return;
    }

  /* Always locate the debug struct, in case it moved.  */
  info->debug_base = 0;
  if (locate_base (info) == 0)
    {
      do_cleanups (old_chain);
      return;
    }

  /* GDB does not currently support libraries loaded via dlmopen
     into namespaces other than the initial one.  We must ignore
     any namespace other than the initial namespace here until
     support for this is added to GDB.  */
  if (debug_base != info->debug_base)
    action = DO_NOTHING;

  if (action == UPDATE_OR_RELOAD)
    {
      val = evaluate_probe_argument (pa->probe, 2);
      if (val != NULL)
	lm = value_as_address (val);

      if (lm == 0)
	action = FULL_RELOAD;
    }

  /* Resume section map updates.  */
  do_cleanups (usm_chain);

  if (action == UPDATE_OR_RELOAD)
    {
      if (!solist_update_incremental (info, lm))
	action = FULL_RELOAD;
    }

  if (action == FULL_RELOAD)
    {
      if (!solist_update_full (info))
	{
	  do_cleanups (old_chain);
	  return;
	}
    }

  discard_cleanups (old_chain);
}

/* Helper function for svr4_update_solib_event_breakpoints.  */

static int
svr4_update_solib_event_breakpoint (struct breakpoint *b, void *arg)
{
  struct bp_location *loc;

  if (b->type != bp_shlib_event)
    {
      /* Continue iterating.  */
      return 0;
    }

  for (loc = b->loc; loc != NULL; loc = loc->next)
    {
      struct svr4_info *info;
      struct probe_and_action *pa;

      info = program_space_data (loc->pspace, solib_svr4_pspace_data);
      if (info == NULL || info->probes_table == NULL)
	continue;

      pa = solib_event_probe_at (info, loc->address);
      if (pa == NULL)
	continue;

      if (pa->action == DO_NOTHING)
	{
	  if (b->enable_state == bp_disabled && stop_on_solib_events)
	    enable_breakpoint (b);
	  else if (b->enable_state == bp_enabled && !stop_on_solib_events)
	    disable_breakpoint (b);
	}

      break;
    }

  /* Continue iterating.  */
  return 0;
}

/* Enable or disable optional solib event breakpoints as appropriate.
   Called whenever stop_on_solib_events is changed.  */

static void
svr4_update_solib_event_breakpoints (void)
{
  iterate_over_breakpoints (svr4_update_solib_event_breakpoint, NULL);
}

/* Create and register solib event breakpoints.  PROBES is an array
   of NUM_PROBES elements, each of which is vector of probes.  A
   solib event breakpoint will be created and registered for each
   probe.  */

static void
svr4_create_probe_breakpoints (struct gdbarch *gdbarch,
			       VEC (probe_p) **probes)
{
  int i;

  for (i = 0; i < NUM_PROBES; i++)
    {
      enum probe_action action = probe_info[i].action;
      struct probe *probe;
      int ix;

      for (ix = 0;
	   VEC_iterate (probe_p, probes[i], ix, probe);
	   ++ix)
	{
	  create_solib_event_breakpoint (gdbarch, probe->address);
	  register_solib_event_probe (probe, action);
	}
    }

  svr4_update_solib_event_breakpoints ();
}

/* Both the SunOS and the SVR4 dynamic linkers call a marker function
   before and after mapping and unmapping shared libraries.  The sole
   purpose of this method is to allow debuggers to set a breakpoint so
   they can track these changes.

   Some versions of the glibc dynamic linker contain named probes
   to allow more fine grained stopping.  Given the address of the
   original marker function, this function attempts to find these
   probes, and if found, sets breakpoints on those instead.  If the
   probes aren't found, a single breakpoint is set on the original
   marker function.  */

static void
svr4_create_solib_event_breakpoints (struct gdbarch *gdbarch,
				     CORE_ADDR address)
{
  struct obj_section *os;

  os = find_pc_section (address);
  if (os != NULL)
    {
      int with_prefix;

      for (with_prefix = 0; with_prefix <= 1; with_prefix++)
	{
	  VEC (probe_p) *probes[NUM_PROBES];
	  int all_probes_found = 1;
	  int checked_can_use_probe_arguments = 0;
	  int i;

	  memset (probes, 0, sizeof (probes));
	  for (i = 0; i < NUM_PROBES; i++)
	    {
	      const char *name = probe_info[i].name;
	      struct probe *p;
	      char buf[32];

	      /* Fedora 17 and Red Hat Enterprise Linux 6.2-6.4
		 shipped with an early version of the probes code in
		 which the probes' names were prefixed with "rtld_"
		 and the "map_failed" probe did not exist.  The
		 locations of the probes are otherwise the same, so
		 we check for probes with prefixed names if probes
		 with unprefixed names are not present.  */
	      if (with_prefix)
		{
		  xsnprintf (buf, sizeof (buf), "rtld_%s", name);
		  name = buf;
		}

	      probes[i] = find_probes_in_objfile (os->objfile, "rtld", name);

	      /* The "map_failed" probe did not exist in early
		 versions of the probes code in which the probes'
		 names were prefixed with "rtld_".  */
	      if (strcmp (name, "rtld_map_failed") == 0)
		continue;

	      if (VEC_empty (probe_p, probes[i]))
		{
		  all_probes_found = 0;
		  break;
		}

	      /* Ensure probe arguments can be evaluated.  */
	      if (!checked_can_use_probe_arguments)
		{
		  p = VEC_index (probe_p, probes[i], 0);
		  if (!can_evaluate_probe_arguments (p))
		    {
		      all_probes_found = 0;
		      break;
		    }
		  checked_can_use_probe_arguments = 1;
		}
	    }

	  if (all_probes_found)
	    svr4_create_probe_breakpoints (gdbarch, probes);

	  for (i = 0; i < NUM_PROBES; i++)
	    VEC_free (probe_p, probes[i]);

	  if (all_probes_found)
	    return;
	}
    }

  create_solib_event_breakpoint (gdbarch, address);
}

/* Helper function for gdb_bfd_lookup_symbol.  */

static int
cmp_name_and_sec_flags (asymbol *sym, void *data)
{
  return (strcmp (sym->name, (const char *) data) == 0
	  && (sym->section->flags & (SEC_CODE | SEC_DATA)) != 0);
}
/* Arrange for dynamic linker to hit breakpoint.

   Both the SunOS and the SVR4 dynamic linkers have, as part of their
   debugger interface, support for arranging for the inferior to hit
   a breakpoint after mapping in the shared libraries.  This function
   enables that breakpoint.

   For SunOS, there is a special flag location (in_debugger) which we
   set to 1.  When the dynamic linker sees this flag set, it will set
   a breakpoint at a location known only to itself, after saving the
   original contents of that place and the breakpoint address itself,
   in it's own internal structures.  When we resume the inferior, it
   will eventually take a SIGTRAP when it runs into the breakpoint.
   We handle this (in a different place) by restoring the contents of
   the breakpointed location (which is only known after it stops),
   chasing around to locate the shared libraries that have been
   loaded, then resuming.

   For SVR4, the debugger interface structure contains a member (r_brk)
   which is statically initialized at the time the shared library is
   built, to the offset of a function (_r_debug_state) which is guaran-
   teed to be called once before mapping in a library, and again when
   the mapping is complete.  At the time we are examining this member,
   it contains only the unrelocated offset of the function, so we have
   to do our own relocation.  Later, when the dynamic linker actually
   runs, it relocates r_brk to be the actual address of _r_debug_state().

   The debugger interface structure also contains an enumeration which
   is set to either RT_ADD or RT_DELETE prior to changing the mapping,
   depending upon whether or not the library is being mapped or unmapped,
   and then set to RT_CONSISTENT after the library is mapped/unmapped.  */

static int
enable_break (struct svr4_info *info, int from_tty)
{
  struct minimal_symbol *msymbol;
  const char * const *bkpt_namep;
  asection *interp_sect;
  char *interp_name;
  CORE_ADDR sym_addr;

  info->interp_text_sect_low = info->interp_text_sect_high = 0;
  info->interp_plt_sect_low = info->interp_plt_sect_high = 0;

  /* If we already have a shared library list in the target, and
     r_debug contains r_brk, set the breakpoint there - this should
     mean r_brk has already been relocated.  Assume the dynamic linker
     is the object containing r_brk.  */

  solib_add (NULL, from_tty, &current_target, auto_solib_add);
  sym_addr = 0;
  if (info->debug_base && solib_svr4_r_map (info) != 0)
    sym_addr = solib_svr4_r_brk (info);

  if (sym_addr != 0)
    {
      struct obj_section *os;

      sym_addr = gdbarch_addr_bits_remove
	(target_gdbarch (), gdbarch_convert_from_func_ptr_addr (target_gdbarch (),
							     sym_addr,
							     &current_target));

      /* On at least some versions of Solaris there's a dynamic relocation
	 on _r_debug.r_brk and SYM_ADDR may not be relocated yet, e.g., if
	 we get control before the dynamic linker has self-relocated.
	 Check if SYM_ADDR is in a known section, if it is assume we can
	 trust its value.  This is just a heuristic though, it could go away
	 or be replaced if it's getting in the way.

	 On ARM we need to know whether the ISA of rtld_db_dlactivity (or
	 however it's spelled in your particular system) is ARM or Thumb.
	 That knowledge is encoded in the address, if it's Thumb the low bit
	 is 1.  However, we've stripped that info above and it's not clear
	 what all the consequences are of passing a non-addr_bits_remove'd
	 address to svr4_create_solib_event_breakpoints.  The call to
	 find_pc_section verifies we know about the address and have some
	 hope of computing the right kind of breakpoint to use (via
	 symbol info).  It does mean that GDB needs to be pointed at a
	 non-stripped version of the dynamic linker in order to obtain
	 information it already knows about.  Sigh.  */

      os = find_pc_section (sym_addr);
      if (os != NULL)
	{
	  /* Record the relocated start and end address of the dynamic linker
	     text and plt section for svr4_in_dynsym_resolve_code.  */
	  bfd *tmp_bfd;
	  CORE_ADDR load_addr;

	  tmp_bfd = os->objfile->obfd;
	  load_addr = ANOFFSET (os->objfile->section_offsets,
				SECT_OFF_TEXT (os->objfile));

	  interp_sect = bfd_get_section_by_name (tmp_bfd, ".text");
	  if (interp_sect)
	    {
	      info->interp_text_sect_low =
		bfd_section_vma (tmp_bfd, interp_sect) + load_addr;
	      info->interp_text_sect_high =
		info->interp_text_sect_low
		+ bfd_section_size (tmp_bfd, interp_sect);
	    }
	  interp_sect = bfd_get_section_by_name (tmp_bfd, ".plt");
	  if (interp_sect)
	    {
	      info->interp_plt_sect_low =
		bfd_section_vma (tmp_bfd, interp_sect) + load_addr;
	      info->interp_plt_sect_high =
		info->interp_plt_sect_low
		+ bfd_section_size (tmp_bfd, interp_sect);
	    }

	  svr4_create_solib_event_breakpoints (target_gdbarch (), sym_addr);
	  return 1;
	}
    }

  /* Find the program interpreter; if not found, warn the user and drop
     into the old breakpoint at symbol code.  */
  interp_name = find_program_interpreter ();
  if (interp_name)
    {
      CORE_ADDR load_addr = 0;
      int load_addr_found = 0;
      int loader_found_in_list = 0;
      struct so_list *so;
      bfd *tmp_bfd = NULL;
      struct target_ops *tmp_bfd_target;
      volatile struct gdb_exception ex;

      sym_addr = 0;

      /* Now we need to figure out where the dynamic linker was
         loaded so that we can load its symbols and place a breakpoint
         in the dynamic linker itself.

         This address is stored on the stack.  However, I've been unable
         to find any magic formula to find it for Solaris (appears to
         be trivial on GNU/Linux).  Therefore, we have to try an alternate
         mechanism to find the dynamic linker's base address.  */

      TRY_CATCH (ex, RETURN_MASK_ALL)
        {
	  tmp_bfd = solib_bfd_open (interp_name);
	}
      if (tmp_bfd == NULL)
	goto bkpt_at_symbol;

      /* Now convert the TMP_BFD into a target.  That way target, as
         well as BFD operations can be used.  */
      tmp_bfd_target = target_bfd_reopen (tmp_bfd);
      /* target_bfd_reopen acquired its own reference, so we can
         release ours now.  */
      gdb_bfd_unref (tmp_bfd);

      /* On a running target, we can get the dynamic linker's base
         address from the shared library table.  */
      so = master_so_list ();
      while (so)
	{
	  if (svr4_same_1 (interp_name, so->so_original_name))
	    {
	      load_addr_found = 1;
	      loader_found_in_list = 1;
	      load_addr = lm_addr_check (so, tmp_bfd);
	      break;
	    }
	  so = so->next;
	}

      /* If we were not able to find the base address of the loader
         from our so_list, then try using the AT_BASE auxilliary entry.  */
      if (!load_addr_found)
        if (target_auxv_search (&current_target, AT_BASE, &load_addr) > 0)
	  {
	    int addr_bit = gdbarch_addr_bit (target_gdbarch ());

	    /* Ensure LOAD_ADDR has proper sign in its possible upper bits so
	       that `+ load_addr' will overflow CORE_ADDR width not creating
	       invalid addresses like 0x101234567 for 32bit inferiors on 64bit
	       GDB.  */

	    if (addr_bit < (sizeof (CORE_ADDR) * HOST_CHAR_BIT))
	      {
		CORE_ADDR space_size = (CORE_ADDR) 1 << addr_bit;
		CORE_ADDR tmp_entry_point = exec_entry_point (tmp_bfd,
							      tmp_bfd_target);

		gdb_assert (load_addr < space_size);

		/* TMP_ENTRY_POINT exceeding SPACE_SIZE would be for prelinked
		   64bit ld.so with 32bit executable, it should not happen.  */

		if (tmp_entry_point < space_size
		    && tmp_entry_point + load_addr >= space_size)
		  load_addr -= space_size;
	      }

	    load_addr_found = 1;
	  }

      /* Otherwise we find the dynamic linker's base address by examining
	 the current pc (which should point at the entry point for the
	 dynamic linker) and subtracting the offset of the entry point.

         This is more fragile than the previous approaches, but is a good
         fallback method because it has actually been working well in
         most cases.  */
      if (!load_addr_found)
	{
	  struct regcache *regcache
	    = get_thread_arch_regcache (inferior_ptid, target_gdbarch ());

	  load_addr = (regcache_read_pc (regcache)
		       - exec_entry_point (tmp_bfd, tmp_bfd_target));
	}

      if (!loader_found_in_list)
	{
	  info->debug_loader_name = xstrdup (interp_name);
	  info->debug_loader_offset_p = 1;
	  info->debug_loader_offset = load_addr;
	  solib_add (NULL, from_tty, &current_target, auto_solib_add);
	}

      /* Record the relocated start and end address of the dynamic linker
         text and plt section for svr4_in_dynsym_resolve_code.  */
      interp_sect = bfd_get_section_by_name (tmp_bfd, ".text");
      if (interp_sect)
	{
	  info->interp_text_sect_low =
	    bfd_section_vma (tmp_bfd, interp_sect) + load_addr;
	  info->interp_text_sect_high =
	    info->interp_text_sect_low
	    + bfd_section_size (tmp_bfd, interp_sect);
	}
      interp_sect = bfd_get_section_by_name (tmp_bfd, ".plt");
      if (interp_sect)
	{
	  info->interp_plt_sect_low =
	    bfd_section_vma (tmp_bfd, interp_sect) + load_addr;
	  info->interp_plt_sect_high =
	    info->interp_plt_sect_low
	    + bfd_section_size (tmp_bfd, interp_sect);
	}

      /* Now try to set a breakpoint in the dynamic linker.  */
      for (bkpt_namep = solib_break_names; *bkpt_namep != NULL; bkpt_namep++)
	{
	  sym_addr = gdb_bfd_lookup_symbol (tmp_bfd, cmp_name_and_sec_flags,
					    (void *) *bkpt_namep);
	  if (sym_addr != 0)
	    break;
	}

      if (sym_addr != 0)
	/* Convert 'sym_addr' from a function pointer to an address.
	   Because we pass tmp_bfd_target instead of the current
	   target, this will always produce an unrelocated value.  */
	sym_addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch (),
						       sym_addr,
						       tmp_bfd_target);

      /* We're done with both the temporary bfd and target.  Closing
         the target closes the underlying bfd, because it holds the
         only remaining reference.  */
      target_close (tmp_bfd_target);

      if (sym_addr != 0)
	{
	  svr4_create_solib_event_breakpoints (target_gdbarch (),
					       load_addr + sym_addr);
	  xfree (interp_name);
	  return 1;
	}

      /* For whatever reason we couldn't set a breakpoint in the dynamic
         linker.  Warn and drop into the old code.  */
    bkpt_at_symbol:
      xfree (interp_name);
      warning (_("Unable to find dynamic linker breakpoint function.\n"
               "GDB will be unable to debug shared library initializers\n"
               "and track explicitly loaded dynamic code."));
    }

  /* Scan through the lists of symbols, trying to look up the symbol and
     set a breakpoint there.  Terminate loop when we/if we succeed.  */

  for (bkpt_namep = solib_break_names; *bkpt_namep != NULL; bkpt_namep++)
    {
      msymbol = lookup_minimal_symbol (*bkpt_namep, NULL, symfile_objfile);
      if ((msymbol != NULL) && (SYMBOL_VALUE_ADDRESS (msymbol) != 0))
	{
	  sym_addr = SYMBOL_VALUE_ADDRESS (msymbol);
	  sym_addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch (),
							 sym_addr,
							 &current_target);
	  svr4_create_solib_event_breakpoints (target_gdbarch (), sym_addr);
	  return 1;
	}
    }

  if (interp_name != NULL && !current_inferior ()->attach_flag)
    {
      for (bkpt_namep = bkpt_names; *bkpt_namep != NULL; bkpt_namep++)
	{
	  msymbol = lookup_minimal_symbol (*bkpt_namep, NULL, symfile_objfile);
	  if ((msymbol != NULL) && (SYMBOL_VALUE_ADDRESS (msymbol) != 0))
	    {
	      sym_addr = SYMBOL_VALUE_ADDRESS (msymbol);
	      sym_addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch (),
							     sym_addr,
							     &current_target);
	      svr4_create_solib_event_breakpoints (target_gdbarch (), sym_addr);
	      return 1;
	    }
	}
    }
  return 0;
}

/* Implement the "special_symbol_handling" target_so_ops method.  */

static void
svr4_special_symbol_handling (void)
{
  /* Nothing to do.  */
}

/* Read the ELF program headers from ABFD.  Return the contents and
   set *PHDRS_SIZE to the size of the program headers.  */

static gdb_byte *
read_program_headers_from_bfd (bfd *abfd, int *phdrs_size)
{
  Elf_Internal_Ehdr *ehdr;
  gdb_byte *buf;

  ehdr = elf_elfheader (abfd);

  *phdrs_size = ehdr->e_phnum * ehdr->e_phentsize;
  if (*phdrs_size == 0)
    return NULL;

  buf = xmalloc (*phdrs_size);
  if (bfd_seek (abfd, ehdr->e_phoff, SEEK_SET) != 0
      || bfd_bread (buf, *phdrs_size, abfd) != *phdrs_size)
    {
      xfree (buf);
      return NULL;
    }

  return buf;
}

/* Return 1 and fill *DISPLACEMENTP with detected PIE offset of inferior
   exec_bfd.  Otherwise return 0.

   We relocate all of the sections by the same amount.  This
   behavior is mandated by recent editions of the System V ABI.
   According to the System V Application Binary Interface,
   Edition 4.1, page 5-5:

     ...  Though the system chooses virtual addresses for
     individual processes, it maintains the segments' relative
     positions.  Because position-independent code uses relative
     addressesing between segments, the difference between
     virtual addresses in memory must match the difference
     between virtual addresses in the file.  The difference
     between the virtual address of any segment in memory and
     the corresponding virtual address in the file is thus a
     single constant value for any one executable or shared
     object in a given process.  This difference is the base
     address.  One use of the base address is to relocate the
     memory image of the program during dynamic linking.

   The same language also appears in Edition 4.0 of the System V
   ABI and is left unspecified in some of the earlier editions.

   Decide if the objfile needs to be relocated.  As indicated above, we will
   only be here when execution is stopped.  But during attachment PC can be at
   arbitrary address therefore regcache_read_pc can be misleading (contrary to
   the auxv AT_ENTRY value).  Moreover for executable with interpreter section
   regcache_read_pc would point to the interpreter and not the main executable.

   So, to summarize, relocations are necessary when the start address obtained
   from the executable is different from the address in auxv AT_ENTRY entry.

   [ The astute reader will note that we also test to make sure that
     the executable in question has the DYNAMIC flag set.  It is my
     opinion that this test is unnecessary (undesirable even).  It
     was added to avoid inadvertent relocation of an executable
     whose e_type member in the ELF header is not ET_DYN.  There may
     be a time in the future when it is desirable to do relocations
     on other types of files as well in which case this condition
     should either be removed or modified to accomodate the new file
     type.  - Kevin, Nov 2000. ]  */

static int
svr4_exec_displacement (CORE_ADDR *displacementp)
{
  /* ENTRY_POINT is a possible function descriptor - before
     a call to gdbarch_convert_from_func_ptr_addr.  */
  CORE_ADDR entry_point, displacement;

  if (exec_bfd == NULL)
    return 0;

  /* Therefore for ELF it is ET_EXEC and not ET_DYN.  Both shared libraries
     being executed themselves and PIE (Position Independent Executable)
     executables are ET_DYN.  */

  if ((bfd_get_file_flags (exec_bfd) & DYNAMIC) == 0)
    return 0;

  if (target_auxv_search (&current_target, AT_ENTRY, &entry_point) <= 0)
    return 0;

  displacement = entry_point - bfd_get_start_address (exec_bfd);

  /* Verify the DISPLACEMENT candidate complies with the required page
     alignment.  It is cheaper than the program headers comparison below.  */

  if (bfd_get_flavour (exec_bfd) == bfd_target_elf_flavour)
    {
      const struct elf_backend_data *elf = get_elf_backend_data (exec_bfd);

      /* p_align of PT_LOAD segments does not specify any alignment but
	 only congruency of addresses:
	   p_offset % p_align == p_vaddr % p_align
	 Kernel is free to load the executable with lower alignment.  */

      if ((displacement & (elf->minpagesize - 1)) != 0)
	return 0;
    }

  /* Verify that the auxilliary vector describes the same file as exec_bfd, by
     comparing their program headers.  If the program headers in the auxilliary
     vector do not match the program headers in the executable, then we are
     looking at a different file than the one used by the kernel - for
     instance, "gdb program" connected to "gdbserver :PORT ld.so program".  */

  if (bfd_get_flavour (exec_bfd) == bfd_target_elf_flavour)
    {
      /* Be optimistic and clear OK only if GDB was able to verify the headers
	 really do not match.  */
      int phdrs_size, phdrs2_size, ok = 1;
      gdb_byte *buf, *buf2;
      int arch_size;

      buf = read_program_header (-1, &phdrs_size, &arch_size);
      buf2 = read_program_headers_from_bfd (exec_bfd, &phdrs2_size);
      if (buf != NULL && buf2 != NULL)
	{
	  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());

	  /* We are dealing with three different addresses.  EXEC_BFD
	     represents current address in on-disk file.  target memory content
	     may be different from EXEC_BFD as the file may have been prelinked
	     to a different address after the executable has been loaded.
	     Moreover the address of placement in target memory can be
	     different from what the program headers in target memory say -
	     this is the goal of PIE.

	     Detected DISPLACEMENT covers both the offsets of PIE placement and
	     possible new prelink performed after start of the program.  Here
	     relocate BUF and BUF2 just by the EXEC_BFD vs. target memory
	     content offset for the verification purpose.  */

	  if (phdrs_size != phdrs2_size
	      || bfd_get_arch_size (exec_bfd) != arch_size)
	    ok = 0;
	  else if (arch_size == 32
		   && phdrs_size >= sizeof (Elf32_External_Phdr)
	           && phdrs_size % sizeof (Elf32_External_Phdr) == 0)
	    {
	      Elf_Internal_Ehdr *ehdr2 = elf_tdata (exec_bfd)->elf_header;
	      Elf_Internal_Phdr *phdr2 = elf_tdata (exec_bfd)->phdr;
	      CORE_ADDR displacement = 0;
	      int i;

	      /* DISPLACEMENT could be found more easily by the difference of
		 ehdr2->e_entry.  But we haven't read the ehdr yet, and we
		 already have enough information to compute that displacement
		 with what we've read.  */

	      for (i = 0; i < ehdr2->e_phnum; i++)
		if (phdr2[i].p_type == PT_LOAD)
		  {
		    Elf32_External_Phdr *phdrp;
		    gdb_byte *buf_vaddr_p, *buf_paddr_p;
		    CORE_ADDR vaddr, paddr;
		    CORE_ADDR displacement_vaddr = 0;
		    CORE_ADDR displacement_paddr = 0;

		    phdrp = &((Elf32_External_Phdr *) buf)[i];
		    buf_vaddr_p = (gdb_byte *) &phdrp->p_vaddr;
		    buf_paddr_p = (gdb_byte *) &phdrp->p_paddr;

		    vaddr = extract_unsigned_integer (buf_vaddr_p, 4,
						      byte_order);
		    displacement_vaddr = vaddr - phdr2[i].p_vaddr;

		    paddr = extract_unsigned_integer (buf_paddr_p, 4,
						      byte_order);
		    displacement_paddr = paddr - phdr2[i].p_paddr;

		    if (displacement_vaddr == displacement_paddr)
		      displacement = displacement_vaddr;

		    break;
		  }

	      /* Now compare BUF and BUF2 with optional DISPLACEMENT.  */

	      for (i = 0; i < phdrs_size / sizeof (Elf32_External_Phdr); i++)
		{
		  Elf32_External_Phdr *phdrp;
		  Elf32_External_Phdr *phdr2p;
		  gdb_byte *buf_vaddr_p, *buf_paddr_p;
		  CORE_ADDR vaddr, paddr;
		  asection *plt2_asect;

		  phdrp = &((Elf32_External_Phdr *) buf)[i];
		  buf_vaddr_p = (gdb_byte *) &phdrp->p_vaddr;
		  buf_paddr_p = (gdb_byte *) &phdrp->p_paddr;
		  phdr2p = &((Elf32_External_Phdr *) buf2)[i];

		  /* PT_GNU_STACK is an exception by being never relocated by
		     prelink as its addresses are always zero.  */

		  if (memcmp (phdrp, phdr2p, sizeof (*phdrp)) == 0)
		    continue;

		  /* Check also other adjustment combinations - PR 11786.  */

		  vaddr = extract_unsigned_integer (buf_vaddr_p, 4,
						    byte_order);
		  vaddr -= displacement;
		  store_unsigned_integer (buf_vaddr_p, 4, byte_order, vaddr);

		  paddr = extract_unsigned_integer (buf_paddr_p, 4,
						    byte_order);
		  paddr -= displacement;
		  store_unsigned_integer (buf_paddr_p, 4, byte_order, paddr);

		  if (memcmp (phdrp, phdr2p, sizeof (*phdrp)) == 0)
		    continue;

		  /* prelink can convert .plt SHT_NOBITS to SHT_PROGBITS.  */
		  plt2_asect = bfd_get_section_by_name (exec_bfd, ".plt");
		  if (plt2_asect)
		    {
		      int content2;
		      gdb_byte *buf_filesz_p = (gdb_byte *) &phdrp->p_filesz;
		      CORE_ADDR filesz;

		      content2 = (bfd_get_section_flags (exec_bfd, plt2_asect)
				  & SEC_HAS_CONTENTS) != 0;

		      filesz = extract_unsigned_integer (buf_filesz_p, 4,
							 byte_order);

		      /* PLT2_ASECT is from on-disk file (exec_bfd) while
			 FILESZ is from the in-memory image.  */
		      if (content2)
			filesz += bfd_get_section_size (plt2_asect);
		      else
			filesz -= bfd_get_section_size (plt2_asect);

		      store_unsigned_integer (buf_filesz_p, 4, byte_order,
					      filesz);

		      if (memcmp (phdrp, phdr2p, sizeof (*phdrp)) == 0)
			continue;
		    }

		  ok = 0;
		  break;
		}
	    }
	  else if (arch_size == 64
		   && phdrs_size >= sizeof (Elf64_External_Phdr)
	           && phdrs_size % sizeof (Elf64_External_Phdr) == 0)
	    {
	      Elf_Internal_Ehdr *ehdr2 = elf_tdata (exec_bfd)->elf_header;
	      Elf_Internal_Phdr *phdr2 = elf_tdata (exec_bfd)->phdr;
	      CORE_ADDR displacement = 0;
	      int i;

	      /* DISPLACEMENT could be found more easily by the difference of
		 ehdr2->e_entry.  But we haven't read the ehdr yet, and we
		 already have enough information to compute that displacement
		 with what we've read.  */

	      for (i = 0; i < ehdr2->e_phnum; i++)
		if (phdr2[i].p_type == PT_LOAD)
		  {
		    Elf64_External_Phdr *phdrp;
		    gdb_byte *buf_vaddr_p, *buf_paddr_p;
		    CORE_ADDR vaddr, paddr;
		    CORE_ADDR displacement_vaddr = 0;
		    CORE_ADDR displacement_paddr = 0;

		    phdrp = &((Elf64_External_Phdr *) buf)[i];
		    buf_vaddr_p = (gdb_byte *) &phdrp->p_vaddr;
		    buf_paddr_p = (gdb_byte *) &phdrp->p_paddr;

		    vaddr = extract_unsigned_integer (buf_vaddr_p, 8,
						      byte_order);
		    displacement_vaddr = vaddr - phdr2[i].p_vaddr;

		    paddr = extract_unsigned_integer (buf_paddr_p, 8,
						      byte_order);
		    displacement_paddr = paddr - phdr2[i].p_paddr;

		    if (displacement_vaddr == displacement_paddr)
		      displacement = displacement_vaddr;

		    break;
		  }

	      /* Now compare BUF and BUF2 with optional DISPLACEMENT.  */

	      for (i = 0; i < phdrs_size / sizeof (Elf64_External_Phdr); i++)
		{
		  Elf64_External_Phdr *phdrp;
		  Elf64_External_Phdr *phdr2p;
		  gdb_byte *buf_vaddr_p, *buf_paddr_p;
		  CORE_ADDR vaddr, paddr;
		  asection *plt2_asect;

		  phdrp = &((Elf64_External_Phdr *) buf)[i];
		  buf_vaddr_p = (gdb_byte *) &phdrp->p_vaddr;
		  buf_paddr_p = (gdb_byte *) &phdrp->p_paddr;
		  phdr2p = &((Elf64_External_Phdr *) buf2)[i];

		  /* PT_GNU_STACK is an exception by being never relocated by
		     prelink as its addresses are always zero.  */

		  if (memcmp (phdrp, phdr2p, sizeof (*phdrp)) == 0)
		    continue;

		  /* Check also other adjustment combinations - PR 11786.  */

		  vaddr = extract_unsigned_integer (buf_vaddr_p, 8,
						    byte_order);
		  vaddr -= displacement;
		  store_unsigned_integer (buf_vaddr_p, 8, byte_order, vaddr);

		  paddr = extract_unsigned_integer (buf_paddr_p, 8,
						    byte_order);
		  paddr -= displacement;
		  store_unsigned_integer (buf_paddr_p, 8, byte_order, paddr);

		  if (memcmp (phdrp, phdr2p, sizeof (*phdrp)) == 0)
		    continue;

		  /* prelink can convert .plt SHT_NOBITS to SHT_PROGBITS.  */
		  plt2_asect = bfd_get_section_by_name (exec_bfd, ".plt");
		  if (plt2_asect)
		    {
		      int content2;
		      gdb_byte *buf_filesz_p = (gdb_byte *) &phdrp->p_filesz;
		      CORE_ADDR filesz;

		      content2 = (bfd_get_section_flags (exec_bfd, plt2_asect)
				  & SEC_HAS_CONTENTS) != 0;

		      filesz = extract_unsigned_integer (buf_filesz_p, 8,
							 byte_order);

		      /* PLT2_ASECT is from on-disk file (exec_bfd) while
			 FILESZ is from the in-memory image.  */
		      if (content2)
			filesz += bfd_get_section_size (plt2_asect);
		      else
			filesz -= bfd_get_section_size (plt2_asect);

		      store_unsigned_integer (buf_filesz_p, 8, byte_order,
					      filesz);

		      if (memcmp (phdrp, phdr2p, sizeof (*phdrp)) == 0)
			continue;
		    }

		  ok = 0;
		  break;
		}
	    }
	  else
	    ok = 0;
	}

      xfree (buf);
      xfree (buf2);

      if (!ok)
	return 0;
    }

  if (info_verbose)
    {
      /* It can be printed repeatedly as there is no easy way to check
	 the executable symbols/file has been already relocated to
	 displacement.  */

      printf_unfiltered (_("Using PIE (Position Independent Executable) "
			   "displacement %s for \"%s\".\n"),
			 paddress (target_gdbarch (), displacement),
			 bfd_get_filename (exec_bfd));
    }

  *displacementp = displacement;
  return 1;
}

/* Relocate the main executable.  This function should be called upon
   stopping the inferior process at the entry point to the program.
   The entry point from BFD is compared to the AT_ENTRY of AUXV and if they are
   different, the main executable is relocated by the proper amount.  */

static void
svr4_relocate_main_executable (void)
{
  CORE_ADDR displacement;

  /* If we are re-running this executable, SYMFILE_OBJFILE->SECTION_OFFSETS
     probably contains the offsets computed using the PIE displacement
     from the previous run, which of course are irrelevant for this run.
     So we need to determine the new PIE displacement and recompute the
     section offsets accordingly, even if SYMFILE_OBJFILE->SECTION_OFFSETS
     already contains pre-computed offsets.

     If we cannot compute the PIE displacement, either:

       - The executable is not PIE.

       - SYMFILE_OBJFILE does not match the executable started in the target.
	 This can happen for main executable symbols loaded at the host while
	 `ld.so --ld-args main-executable' is loaded in the target.

     Then we leave the section offsets untouched and use them as is for
     this run.  Either:

       - These section offsets were properly reset earlier, and thus
	 already contain the correct values.  This can happen for instance
	 when reconnecting via the remote protocol to a target that supports
	 the `qOffsets' packet.

       - The section offsets were not reset earlier, and the best we can
	 hope is that the old offsets are still applicable to the new run.  */

  if (! svr4_exec_displacement (&displacement))
    return;

  /* Even DISPLACEMENT 0 is a valid new difference of in-memory vs. in-file
     addresses.  */

  if (symfile_objfile)
    {
      struct section_offsets *new_offsets;
      int i;

      new_offsets = alloca (symfile_objfile->num_sections
			    * sizeof (*new_offsets));

      for (i = 0; i < symfile_objfile->num_sections; i++)
	new_offsets->offsets[i] = displacement;

      objfile_relocate (symfile_objfile, new_offsets);
    }
  else if (exec_bfd)
    {
      asection *asect;

      for (asect = exec_bfd->sections; asect != NULL; asect = asect->next)
	exec_set_section_address (bfd_get_filename (exec_bfd), asect->index,
				  (bfd_section_vma (exec_bfd, asect)
				   + displacement));
    }
}

/* Implement the "create_inferior_hook" target_solib_ops method.

   For SVR4 executables, this first instruction is either the first
   instruction in the dynamic linker (for dynamically linked
   executables) or the instruction at "start" for statically linked
   executables.  For dynamically linked executables, the system
   first exec's /lib/libc.so.N, which contains the dynamic linker,
   and starts it running.  The dynamic linker maps in any needed
   shared libraries, maps in the actual user executable, and then
   jumps to "start" in the user executable.

   We can arrange to cooperate with the dynamic linker to discover the
   names of shared libraries that are dynamically linked, and the base
   addresses to which they are linked.

   This function is responsible for discovering those names and
   addresses, and saving sufficient information about them to allow
   their symbols to be read at a later time.  */

static void
svr4_solib_create_inferior_hook (int from_tty)
{
  struct svr4_info *info;

  info = get_svr4_info ();

  /* Clear the probes-based interface's state.  */
  free_probes_table (info);
  free_solib_list (info);

  /* Relocate the main executable if necessary.  */
  svr4_relocate_main_executable ();

  /* No point setting a breakpoint in the dynamic linker if we can't
     hit it (e.g., a core file, or a trace file).  */
  if (!target_has_execution)
    return;

  if (!svr4_have_link_map_offsets ())
    return;

  if (!enable_break (info, from_tty))
    return;
}

static void
svr4_clear_solib (void)
{
  struct svr4_info *info;

  info = get_svr4_info ();
  info->debug_base = 0;
  info->debug_loader_offset_p = 0;
  info->debug_loader_offset = 0;
  xfree (info->debug_loader_name);
  info->debug_loader_name = NULL;
}

/* Clear any bits of ADDR that wouldn't fit in a target-format
   data pointer.  "Data pointer" here refers to whatever sort of
   address the dynamic linker uses to manage its sections.  At the
   moment, we don't support shared libraries on any processors where
   code and data pointers are different sizes.

   This isn't really the right solution.  What we really need here is
   a way to do arithmetic on CORE_ADDR values that respects the
   natural pointer/address correspondence.  (For example, on the MIPS,
   converting a 32-bit pointer to a 64-bit CORE_ADDR requires you to
   sign-extend the value.  There, simply truncating the bits above
   gdbarch_ptr_bit, as we do below, is no good.)  This should probably
   be a new gdbarch method or something.  */
static CORE_ADDR
svr4_truncate_ptr (CORE_ADDR addr)
{
  if (gdbarch_ptr_bit (target_gdbarch ()) == sizeof (CORE_ADDR) * 8)
    /* We don't need to truncate anything, and the bit twiddling below
       will fail due to overflow problems.  */
    return addr;
  else
    return addr & (((CORE_ADDR) 1 << gdbarch_ptr_bit (target_gdbarch ())) - 1);
}


static void
svr4_relocate_section_addresses (struct so_list *so,
                                 struct target_section *sec)
{
  bfd *abfd = sec->the_bfd_section->owner;

  sec->addr = svr4_truncate_ptr (sec->addr + lm_addr_check (so, abfd));
  sec->endaddr = svr4_truncate_ptr (sec->endaddr + lm_addr_check (so, abfd));
}


/* Architecture-specific operations.  */

/* Per-architecture data key.  */
static struct gdbarch_data *solib_svr4_data;

struct solib_svr4_ops
{
  /* Return a description of the layout of `struct link_map'.  */
  struct link_map_offsets *(*fetch_link_map_offsets)(void);
};

/* Return a default for the architecture-specific operations.  */

static void *
solib_svr4_init (struct obstack *obstack)
{
  struct solib_svr4_ops *ops;

  ops = OBSTACK_ZALLOC (obstack, struct solib_svr4_ops);
  ops->fetch_link_map_offsets = NULL;
  return ops;
}

/* Set the architecture-specific `struct link_map_offsets' fetcher for
   GDBARCH to FLMO.  Also, install SVR4 solib_ops into GDBARCH.  */

void
set_solib_svr4_fetch_link_map_offsets (struct gdbarch *gdbarch,
                                       struct link_map_offsets *(*flmo) (void))
{
  struct solib_svr4_ops *ops = gdbarch_data (gdbarch, solib_svr4_data);

  ops->fetch_link_map_offsets = flmo;

  set_solib_ops (gdbarch, &svr4_so_ops);
}

/* Fetch a link_map_offsets structure using the architecture-specific
   `struct link_map_offsets' fetcher.  */

static struct link_map_offsets *
svr4_fetch_link_map_offsets (void)
{
  struct solib_svr4_ops *ops = gdbarch_data (target_gdbarch (), solib_svr4_data);

  gdb_assert (ops->fetch_link_map_offsets);
  return ops->fetch_link_map_offsets ();
}

/* Return 1 if a link map offset fetcher has been defined, 0 otherwise.  */

static int
svr4_have_link_map_offsets (void)
{
  struct solib_svr4_ops *ops = gdbarch_data (target_gdbarch (), solib_svr4_data);

  return (ops->fetch_link_map_offsets != NULL);
}


/* Most OS'es that have SVR4-style ELF dynamic libraries define a
   `struct r_debug' and a `struct link_map' that are binary compatible
   with the origional SVR4 implementation.  */

/* Fetch (and possibly build) an appropriate `struct link_map_offsets'
   for an ILP32 SVR4 system.  */

struct link_map_offsets *
svr4_ilp32_fetch_link_map_offsets (void)
{
  static struct link_map_offsets lmo;
  static struct link_map_offsets *lmp = NULL;

  if (lmp == NULL)
    {
      lmp = &lmo;

      lmo.r_version_offset = 0;
      lmo.r_version_size = 4;
      lmo.r_map_offset = 4;
      lmo.r_brk_offset = 8;
      lmo.r_ldsomap_offset = 20;

      /* Everything we need is in the first 20 bytes.  */
      lmo.link_map_size = 20;
      lmo.l_addr_offset = 0;
      lmo.l_name_offset = 4;
      lmo.l_ld_offset = 8;
      lmo.l_next_offset = 12;
      lmo.l_prev_offset = 16;
    }

  return lmp;
}

/* Fetch (and possibly build) an appropriate `struct link_map_offsets'
   for an LP64 SVR4 system.  */

struct link_map_offsets *
svr4_lp64_fetch_link_map_offsets (void)
{
  static struct link_map_offsets lmo;
  static struct link_map_offsets *lmp = NULL;

  if (lmp == NULL)
    {
      lmp = &lmo;

      lmo.r_version_offset = 0;
      lmo.r_version_size = 4;
      lmo.r_map_offset = 8;
      lmo.r_brk_offset = 16;
      lmo.r_ldsomap_offset = 40;

      /* Everything we need is in the first 40 bytes.  */
      lmo.link_map_size = 40;
      lmo.l_addr_offset = 0;
      lmo.l_name_offset = 8;
      lmo.l_ld_offset = 16;
      lmo.l_next_offset = 24;
      lmo.l_prev_offset = 32;
    }

  return lmp;
}


struct target_so_ops svr4_so_ops;

/* Lookup global symbol for ELF DSOs linked with -Bsymbolic.  Those DSOs have a
   different rule for symbol lookup.  The lookup begins here in the DSO, not in
   the main executable.  */

static struct symbol *
elf_lookup_lib_symbol (const struct objfile *objfile,
		       const char *name,
		       const domain_enum domain)
{
  bfd *abfd;

  if (objfile == symfile_objfile)
    abfd = exec_bfd;
  else
    {
      /* OBJFILE should have been passed as the non-debug one.  */
      gdb_assert (objfile->separate_debug_objfile_backlink == NULL);

      abfd = objfile->obfd;
    }

  if (abfd == NULL || scan_dyntag (DT_SYMBOLIC, abfd, NULL) != 1)
    return NULL;

  return lookup_global_symbol_from_objfile (objfile, name, domain);
}

extern initialize_file_ftype _initialize_svr4_solib; /* -Wmissing-prototypes */

void
_initialize_svr4_solib (void)
{
  solib_svr4_data = gdbarch_data_register_pre_init (solib_svr4_init);
  solib_svr4_pspace_data
    = register_program_space_data_with_cleanup (NULL, svr4_pspace_data_cleanup);

  svr4_so_ops.relocate_section_addresses = svr4_relocate_section_addresses;
  svr4_so_ops.free_so = svr4_free_so;
  svr4_so_ops.clear_so = svr4_clear_so;
  svr4_so_ops.clear_solib = svr4_clear_solib;
  svr4_so_ops.solib_create_inferior_hook = svr4_solib_create_inferior_hook;
  svr4_so_ops.special_symbol_handling = svr4_special_symbol_handling;
  svr4_so_ops.current_sos = svr4_current_sos;
  svr4_so_ops.open_symbol_file_object = open_symbol_file_object;
  svr4_so_ops.in_dynsym_resolve_code = svr4_in_dynsym_resolve_code;
  svr4_so_ops.bfd_open = solib_bfd_open;
  svr4_so_ops.lookup_lib_global_symbol = elf_lookup_lib_symbol;
  svr4_so_ops.same = svr4_same;
  svr4_so_ops.keep_data_in_core = svr4_keep_data_in_core;
  svr4_so_ops.update_breakpoints = svr4_update_solib_event_breakpoints;
  svr4_so_ops.handle_event = svr4_handle_solib_event;
}
@


1.182
log
@2013-07-24  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* breakpoint.c (create_longjmp_master_breakpoint): Check if probe
	interface can evaluate arguments.  Fallback to the old mode if it
	cannot.
	(create_exception_master_breakpoint): Likewise.
	* elfread.c (elf_can_evaluate_probe_arguments): New function.
	(struct sym_probe_fns elf_probe_fns): Export function above to the
	probe interface.
	* probe.c (can_evaluate_probe_arguments): New function.
	* probe.h (struct probe_ops) <can_evaluate_probe_arguments>: New
	function pointer.
	(can_evaluate_probe_arguments): New function prototype.
	* solib-svr4.c (svr4_create_solib_event_breakpoints): Check if
	probe interface can evaluate arguments.  Fallback to the old mode
	if it cannot.
	* stap-probe.c (stap_get_probe_argument_count): Check if probe
	interface can evaluate arguments.  Warning the user if it cannot.
	(stap_can_evaluate_probe_arguments): New function.
	(struct probe_ops stap_probe_ops): Export function above to the
	probe interface.
	* symfile.h (struct sym_probe_fns) <can_evaluate_probe_arguments>:
	New function pointer.
@
text
@d1313 1
d1353 1
d1364 8
a1371 2
	  warning (_("Can't read pathname for load map: %s."),
		   safe_strerror (errcode));
@


1.181
log
@	* target.h (struct target_section): Delete member bfd.
	All users updated to use the_bfd_section->owner instead.
	* exec.c (add_to_section_table): Assert bfd is expected value.
	Remove initialization of target_section.bfd.
	(remove_target_sections): Update.
	(section_table_available_memory): Update.
	(section_table_xfer_memory_partial): Update.
	(print_section_info): Update.
	(exec_set_section_address): Update.
	* record-full.c (record_full_core_xfer_partial): Update.
	* solib-svr4.c (svr4_relocate_section_addresses): Update.
	* solib-target.c (solib_target_relocate_section_addresses): Update.
	* symfile.c (build_section_addr_info_from_section_table): Update.
	* target.c (memory_xfer_live_readonly_partial): Update.
	(memory_xfer_partial_1): Update.
@
text
@d1981 1
d1988 1
d2017 12
@


1.180
log
@	* objfiles.h (pc_in_section): New prototype.
	(in_plt_section): Remove name argument, replace prototype with
	static inline function.
	* mips-tdep.h: Include "objfiles.h".
	(in_mips_stubs_section): New function.
	* hppa-tdep.h (gdbarch_tdep): Remove name argument of
	in_solib_call_trampoline member.
	(hppa_in_solib_call_trampoline): Remove name argument.
	* objfiles.c (pc_in_section): New function.
	(in_plt_section): Remove function.
	* mips-linux-tdep.c: Include "objfiles.h".
	(mips_linux_in_dynsym_stub): Call in_mips_stubs_section.  Remove
	name argument.  Return 1 rather than the low 16-bit halfword of
	any instruction examined.
	(mips_linux_in_dynsym_resolve_code): Update
	mips_linux_in_dynsym_stub call accordingly.
	* mips-tdep.c (mips_stub_frame_sniffer): Use in_mips_stubs_section
	rather than an equivalent hand-coded sequence.
	* hppa-hpux-tdep.c (in_opd_section): Remove function.
	(hppa32_hpux_in_solib_call_trampoline): Remove name argument.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.
	(hppa64_hpux_find_global_pointer): Use pc_in_section rather than
	in_opd_section.
	* hppa-tdep.c (hppa_stub_unwind_sniffer): Remove name argument
	on call to tdep->in_solib_call_trampoline.
	(hppa_in_solib_call_trampoline): Remove name argument, update
	according to in_plt_section change.
	(hppa_skip_trampoline_code): Update according to in_plt_section
	change.
	* aarch64-tdep.c (aarch64_stub_unwind_sniffer): Likewise.
	* arm-symbian-tdep.c (arm_symbian_skip_trampoline_code):
	Likewise.
	* arm-tdep.c (arm_stub_unwind_sniffer): Likewise.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): Likewise.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Likewise.
	* nios2-tdep.c (nios2_stub_frame_sniffer): Likewise.
	* nto-tdep.c (nto_relocate_section_addresses): Likewise.
	* s390-tdep.c (s390_stub_frame_sniffer): Likewise.
	* sh-tdep.c (sh_stub_unwind_sniffer): Likewise.
	* solib-dsbt.c (dsbt_in_dynsym_resolve_code): Likewise.
	* solib-frv.c (frv_in_dynsym_resolve_code): Likewise.
	* solib-svr4.c (svr4_in_dynsym_resolve_code): Likewise.
	* solib-target.c (solib_target_in_dynsym_resolve_code): Likewise.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise.
	* tic6x-tdep.c (tic6x_stub_unwind_sniffer): Likewise.
@
text
@d2910 4
a2913 4
  sec->addr    = svr4_truncate_ptr (sec->addr    + lm_addr_check (so,
								  sec->bfd));
  sec->endaddr = svr4_truncate_ptr (sec->endaddr + lm_addr_check (so,
								  sec->bfd));
@


1.179
log
@2013-06-04  Gary Benson  <gbenson@@redhat.com>

	* breakpoint.h (handle_solib_event): Moved function declaration
	to solib.h.
	* breakpoint.c (handle_solib_event): Moved function to solib.c.
	(bpstat_stop_status): Pass new argument to handle_solib_event.
	* solib.h (update_solib_breakpoints): New function declaration.
	(handle_solib_event): Moved function declaration from
	breakpoint.h.
	* solib.c (update_solib_breakpoints): New function.
	(handle_solib_event): Moved function from breakpoint.c.
	Updated to call solib_ops->handle_event if not NULL.
	* solist.h (target_so_ops): New fields "update_breakpoints" and
	"handle_event".
	* infrun.c (set_stop_on_solib_events): New function.
	(_initialize_infrun): Use the above for "set
	stop-on-solib-events".
	(handle_inferior_event): Pass new argument to handle_solib_event.
	* solib-svr4.c (probe.h): New include.
	(svr4_free_library_list): New forward declaration.
	(probe_action): New enum.
	(probe_info): New struct.
	(probe_info): New static variable.
	(NUM_PROBES): New definition.
	(svr4_info): New fields "using_xfer", "probes_table" and
	"solib_list".
	(free_probes_table): New function.
	(free_solib_list): New function.
	(svr4_pspace_data_cleanup): Free probes table and solib list.
	(svr4_copy_library_list): New function.
	(svr4_current_sos_via_xfer_libraries): New parameter "annex".
	(svr4_read_so_list): New parameter "prev_lm".
	(svr4_current_sos_direct): Renamed from "svr4_current_sos".
	(svr4_current_sos): New function.
	(probe_and_action): New struct.
	(hash_probe_and_action): New function.
	(equal_probe_and_action): Likewise.
	(register_solib_event_probe): Likewise.
	(solib_event_probe_at): Likewise.
	(solib_event_probe_action): Likewise.
	(solist_update_full): Likewise.
	(solist_update_incremental): Likewise.
	(disable_probes_interface_cleanup): Likewise.
	(svr4_handle_solib_event): Likewise.
	(svr4_update_solib_event_breakpoint): Likewise.
	(svr4_update_solib_event_breakpoints): Likewise.
	(svr4_create_solib_event_breakpoints): Likewise.
	(enable_break): Free probes table before creating breakpoints.
	Use svr4_create_solib_event_breakpoints to create breakpoints.
	(svr4_solib_create_inferior_hook): Free the solib list.
	(_initialize_svr4_solib): Initialise
	svr4_so_ops.handle_solib_event and svr4_so_ops.update_breakpoints.
@
text
@d1535 1
a1535 1
	  || in_plt_section (pc, NULL)
@


1.178
log
@2013-05-21  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* solib-svr4.c (svr4_free_so): Protect against NULL dereference.
@
text
@d49 1
d54 1
d111 49
d367 14
d386 21
d413 6
d1086 28
d1229 1
a1229 1
/* Attempt to get so_list from target via qXfer:libraries:read packet.
d1233 5
a1237 1
   empty, caller is responsible for freeing all its entries.  */
d1240 2
a1241 1
svr4_current_sos_via_xfer_libraries (struct svr4_library_list *list)
d1247 2
d1252 1
a1252 1
						NULL);
d1266 2
a1267 1
svr4_current_sos_via_xfer_libraries (struct svr4_library_list *list)
d1301 7
a1307 3
/* Read the whole inferior libraries chain starting at address LM.  Add the
   entries to the tail referenced by LINK_PTR_PTR.  Ignore the first entry if
   IGNORE_FIRST and set global MAIN_LM_ADDR according to it.  */
d1309 3
a1311 3
static void
svr4_read_so_list (CORE_ADDR lm, struct so_list ***link_ptr_ptr,
		   int ignore_first)
d1313 1
a1313 1
  CORE_ADDR prev_lm = 0, next_lm;
d1329 1
a1329 1
	  break;
d1340 1
a1340 1
	  break;
d1386 2
d1390 4
a1393 1
/* Implement the "current_sos" target_so_ops method.  */
d1396 1
a1396 1
svr4_current_sos (void)
a1400 1
  struct svr4_info *info;
d1413 3
a1415 1
  if (svr4_current_sos_via_xfer_libraries (&library_list))
d1418 1
a1418 4
	{
	  info = get_svr4_info ();
	  info->main_lm_addr = library_list.main_lm;
	}
a1422 2
  info = get_svr4_info ();

d1445 1
a1445 1
    svr4_read_so_list (lm, &link_ptr, ignore_first);
d1453 1
a1453 1
    svr4_read_so_list (lm, &link_ptr, 0);
d1463 16
d1561 470
d2114 1
a2114 1
	 address to create_solib_event_breakpoint.  The call to
d2152 1
a2152 1
	  create_solib_event_breakpoint (target_gdbarch (), sym_addr);
d2310 2
a2311 1
	  create_solib_event_breakpoint (target_gdbarch (), load_addr + sym_addr);
d2337 1
a2337 1
	  create_solib_event_breakpoint (target_gdbarch (), sym_addr);
d2353 1
a2353 1
	      create_solib_event_breakpoint (target_gdbarch (), sym_addr);
d2849 4
d3095 2
@


1.177
log
@	* solist.h (struct target_so_ops): New member clear_so.
	* solib-svr4.c (svr4_clear_so): New function.
	(_initialize_svr4_solib): Set svr4_so_ops.clear_so.
	* solib.c (clear_so): Renamed from free_so_symbols.
	All callers updated.  Call target clear_so if it exists.
@
text
@d974 2
a975 1
  so->lm_info->l_addr_p = 0;
@


1.176
log
@-Wpointer-sign: gdb_byte -> char.

This is sort of the opposite of the previous patch.  Places that
manipulate strings or interfaces that return strings are changed to
use char* instead of gdb_byte*.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* avr-tdep.c (avr_io_reg_read_command): New local 'bufstr'.  Use
	it to get a string view of the byte buffer.
	* i386-cygwin-tdep.c (core_process_module_section): Change local 'buf'
	type to gdb_byte *.  Adjust.
	* linux-tdep.c (linux_info_proc, linux_find_memory_regions_full):
	Change local to char *.
	* solib-darwin.c (find_program_interpreter): Change return type to
	char *.  Adjust.
	(darwin_solib_get_all_image_info_addr_at_init): Adjust.
	* solib-dsbt.c (enable_break2): Change local 'buf' to char *.
	* solib-frv.c (enable_break2): Change local 'buf' to char *.
	* solib-spu.c (spu_current_sos): Add gdb_byte * cast.
	* solib-svr4.c (find_program_interpreter): Change return type to
	char *.  Adjust.
	(enable_break): Change local 'interp_name' to char *.
	* spu-multiarch.c (spu_xfer_partial): Add cast to 'char *'.
	* spu-tdep.c (spu_pseudo_register_read_spu): Add cast to 'char *'.
	(spu_pseudo_register_write_spu): Use char for string buffer.
	Adjust.
	(info_spu_event_command, info_spu_signal_command): Add casts to
	'char *'.
@
text
@d969 8
d2459 1
@


1.175
log
@Add const to lm_addr_check.

* solib-svr4.c (lm_addr_check): Add const qualifier to 'so' arg.
@
text
@d499 1
a499 1
static gdb_byte *
d524 1
a524 1
  return buf;
d1449 1
a1449 1
  gdb_byte *interp_name;
@


1.174
log
@gdb/
	Code cleanup.
	* bfd-target.c (target_bfd_xclose): Remove parameter quitting.
	* bsd-kvm.c (bsd_kvm_close): Likewise.
	* bsd-uthread.c (bsd_uthread_close): Likewise.
	* corelow.c (core_close): Likewise.
	(core_close_cleanup): Remove parameter quitting from a caller.
	* event-top.c (async_disconnect): Likewise.
	* exec.c (exec_close_1): Remove parameter quitting.
	* go32-nat.c (go32_close): Likewise.
	* linux-nat.c (linux_nat_close): Remove parameter quitting.  Remove
	parameter quitting from a caller.
	* mips-linux-nat.c (super_close): Remove parameter quitting from the
	variable.
	(mips_linux_close): Remove parameter quitting.  Remove parameter
	quitting from a caller.
	* monitor.c (monitor_close): Remove parameter quitting.
	* monitor.h (monitor_close): Likewise.
	* record-btrace.c (record_btrace_close): Likewise.
	* record-full.c (record_full_close): Likewise.
	* remote-m32r-sdi.c (m32r_close): Remove parameter quitting and remove
	it also from fprintf_unfiltered.
	* remote-mips.c (mips_close): Remove parameter quitting.
	(mips_detach): Remove parameter quitting from a caller.
	* remote-sim.c (gdbsim_close): Remove parameter quitting.
	(gdbsim_close): Remove duplicate function comment.  Remove parameter
	quitting and remove it also from printf_filtered.
	* remote.c (remote_close): Remove parameter quitting.
	* solib-svr4.c (enable_break): Remove parameter quitting from a caller.
	* target.c (update_current_target): Remove parameter int from to_close
	de_fault.
	(push_target, unpush_target, pop_target): Remove parameter quitting from
	a caller.
	(pop_all_targets_above, pop_all_targets): Remove parameter quitting.
	Remove parameter quitting from a caller.
	(target_preopen): Remove parameter quitting from a caller.
	(target_close): Remove parameter quitting.  Remove parameter quitting
	from a caller two times.  Remove parameter quitting also from
	fprintf_unfiltered.
	* target.h (struct target_ops): Remove parameter quitting and as int
	from fields to_xclose and to_close.
	(extern struct target_ops current_target):
	(target_close, pop_all_targets): Remove parameter quitting.  Update the
	comment.
	(pop_all_targets_above): Remove parameter quitting.
	* top.c (quit_target): Remove parameter quitting from a caller.
	* tracepoint.c (tfile_close): Remove parameter quitting.
	* windows-nat.c (windows_close): Remove parameter quitting.
@
text
@d192 1
a192 1
lm_addr_check (struct so_list *so, bfd *abfd)
@


1.173
log
@        * solib-svr4.c (svr4_keep_data_in_core): Remove unused lmo.
        (svr4_read_so_list): Remove unused lmo.
        * solib-target.c (solib_target_relocate_section_addresses): Remove
        unused flags.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00744.html
@
text
@d1678 1
a1678 1
      target_close (tmp_bfd_target, 0);
@


1.172
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a850 1
  struct link_map_offsets *lmo;
a863 1
  lmo = svr4_fetch_link_map_offsets ();
a1175 1
      struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();
@


1.171
log
@	* solib-svr4.c (enable_break): Use SECT_OFF_TEXT.
@
text
@d3 1
a3 2
   Copyright (C) 1990-1996, 1998-2001, 2003-2012 Free Software
   Foundation, Inc.
@


1.170
log
@2012-12-10  Pedro Alves  <palves@@redhat.com>

	* solib-svr4.c (svr4_solib_create_inferior_hook) [_SCO_DS]: Remove
	dead SCO code, and adjust function description comment.
@
text
@d1507 1
a1507 1
				os->objfile->sect_index_text);
@


1.169
log
@gdb/
2012-11-27  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Kazu Hirata  <kazu@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* objfiles.c (init_entry_point_info): Call
	gdbarch_convert_from_func_ptr_addr and
	gdbarch_addr_bits_remove here ...
	(entry_point_address_query): ... instead of here.
	* solib-svr4.c (exec_entry_point): Call
	gdbarch_addr_bits_remove.
	* symfile.c (generic_load): Call gdbarch_addr_bits_remove on
	the entry address.
@
text
@d2215 1
a2215 11
   their symbols to be read at a later time.

   FIXME

   Between enable_break() and disable_break(), this code does not
   properly handle hitting breakpoints which the user might have
   set in the startup code or in the dynamic linker itself.  Proper
   handling will probably have to wait until the implementation is
   changed to use the "breakpoint handler function" method.

   Also, what if child has exit()ed?  Must exit loop somehow.  */
a2219 4
#if defined(_SCO_DS)
  struct inferior *inf;
  struct thread_info *tp;
#endif /* defined(_SCO_DS) */
a2236 25

#if defined(_SCO_DS)
  /* SCO needs the loop below, other systems should be using the
     special shared library breakpoints and the shared library breakpoint
     service routine.

     Now run the target.  It will eventually hit the breakpoint, at
     which point all of the libraries will have been mapped in and we
     can go groveling around in the dynamic linker structures to find
     out what we need to know about them.  */

  inf = current_inferior ();
  tp = inferior_thread ();

  clear_proceed_status ();
  inf->control.stop_soon = STOP_QUIETLY;
  tp->suspend.stop_signal = GDB_SIGNAL_0;
  do
    {
      target_resume (pid_to_ptid (-1), 0, tp->suspend.stop_signal);
      wait_for_inferior ();
    }
  while (tp->suspend.stop_signal != GDB_SIGNAL_TRAP);
  inf->control.stop_soon = NO_STOP_QUIETLY;
#endif /* defined(_SCO_DS) */
@


1.168
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d1391 2
d1401 1
a1401 1
  return gdbarch_convert_from_func_ptr_addr (target_gdbarch (),
d1404 1
@


1.167
log
@	* auto-load.c (_initialize_auto_load): Update.
	* solib-svr4.c (_initialize_svr4_solib): Update
	* solib-dsbt.c (_initialize_dsbt_solib): Update.
	* solib-darwin.c (_initialize_darwin_solib): Update.
	* registry.h: New file.
	* python/py-progspace.c (gdbpy_initialize_pspace): Update.
	* python/py-inferior.c (gdbpy_initialize_inferior): Update.
	* progspace.h: Include registry.h.  Use DECLARE_REGISTRY.
	(register_program_space_data_with_cleanup)
	(register_program_space_data, program_space_alloc_data)
	(clear_program_space_data, set_program_space_data)
	(program_space_data): Don't declare.
	* progspace.c: Use DEFINE_REGISTRY.
	(struct program_space_data, struct
	program_space_data_registration, struct
	program_space_data_registry, program_space_data_registry)
	(register_program_space_data_with_cleanup)
	(register_program_space_data, program_space_alloc_data)
	(program_space_free_data, clear_program_space_data)
	(set_program_space_data, program_space_data): Remove.
	* objfiles.h: Include registry.h.  Use DECLARE_REGISTRY.
	(struct objfile) <data, num_data>: Replace with REGISTRY_FIELDS.
	(register_objfile_data_with_cleanup, register_objfile_data)
	(clear_objfile_data, set_objfile_data, objfile_data): Don't
	declare.
	* objfiles.c: Use DEFINE_REGISTRY.
	(struct objfile_data, struct objfile_data_registration, struct
	objfile_data_registry, objfile_data_registry)
	(register_objfile_data_with_cleanup, register_objfile_data)
	(objfile_alloc_data, objfile_free_data, clear_objfile_data)
	(set_objfile_data, objfile_data): Remove.
	(_initialize_objfiles): Update.
	* jit.c (_initialize_jit): Update.
	* inflow.c (_initialize_inflow): Update.
	* inferior.h: Include registry.h.  Use DECLARE_REGISTRY.
	(struct inferior) <data, num_data>: Replace with REGISTRY_FIELDS.
	(register_inferior_data_with_cleanup, register_inferior_data)
	(clear_inferior_data, set_inferior_data, inferior_data): Don't
	declare.
	* inferior.c: Use DEFINE_REGISTRY.
	(struct inferior_data, struct inferior_data_registration, struct
	inferior_data_registry, inferior_data_registry)
	(register_inferior_data_with_cleanup, register_inferior_data)
	(inferior_alloc_data, inferior_free_data  clear_inferior_data)
	(set_inferior_data, inferior_data): Remove.
	* auxv.c (_initialize_auxv): Update.
	* ada-lang.c (_initialize_ada_language): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* i386-nat.c (i386_use_watchpoints): Update.
@
text
@d158 1
a158 1
	       paddress (target_gdbarch, lm_addr)),
d163 1
a163 1
      struct type *ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;
d267 1
a267 1
				   paddress (target_gdbarch, l_addr),
d366 1
a366 1
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch);
d615 1
a615 1
	     ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;
d635 1
a635 1
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch);
d712 1
a712 1
      struct type *ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;
d790 1
a790 1
  struct type *ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;
d809 1
a809 1
  struct type *ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;
d822 2
a823 2
  struct type *ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch);
d892 1
a892 1
  struct type *ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;
d1200 2
a1201 2
		   paddress (target_gdbarch, prev_lm),
		   paddress (target_gdbarch, new->lm_info->l_prev));
d1399 1
a1399 1
  return gdbarch_convert_from_func_ptr_addr (target_gdbarch,
d1471 1
a1471 1
	(target_gdbarch, gdbarch_convert_from_func_ptr_addr (target_gdbarch,
d1525 1
a1525 1
	  create_solib_event_breakpoint (target_gdbarch, sym_addr);
d1588 1
a1588 1
	    int addr_bit = gdbarch_addr_bit (target_gdbarch);
d1624 1
a1624 1
	    = get_thread_arch_regcache (inferior_ptid, target_gdbarch);
d1672 1
a1672 1
	sym_addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch,
d1683 1
a1683 1
	  create_solib_event_breakpoint (target_gdbarch, load_addr + sym_addr);
d1706 1
a1706 1
	  sym_addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch,
d1709 1
a1709 1
	  create_solib_event_breakpoint (target_gdbarch, sym_addr);
d1722 1
a1722 1
	      sym_addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch,
d1725 1
a1725 1
	      create_solib_event_breakpoint (target_gdbarch, sym_addr);
d1866 1
a1866 1
	  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch);
d2121 1
a2121 1
			 paddress (target_gdbarch, displacement),
d2304 1
a2304 1
  if (gdbarch_ptr_bit (target_gdbarch) == sizeof (CORE_ADDR) * 8)
d2309 1
a2309 1
    return addr & (((CORE_ADDR) 1 << gdbarch_ptr_bit (target_gdbarch)) - 1);
d2367 1
a2367 1
  struct solib_svr4_ops *ops = gdbarch_data (target_gdbarch, solib_svr4_data);
d2378 1
a2378 1
  struct solib_svr4_ops *ops = gdbarch_data (target_gdbarch, solib_svr4_data);
@


1.166
log
@2012-08-14  Gary Benson  <gbenson@@redhat.com>

	* solib-svr4.c (svr4_free_library_list): Use free_so.
@
text
@d2487 1
a2487 1
    = register_program_space_data_with_cleanup (svr4_pspace_data_cleanup);
@


1.165
log
@	* solib-svr4.c (enable_break): Update.
	* bfd-target.h (target_bfd_reopen): Update documentation.
@
text
@d983 1
a983 1
      svr4_free_so (list);
@


1.164
log
@2012-06-05  Joakim Tjernlund  <Joakim.Tjernlund@@transmode.se>

	* solib-svr4.c (enable_break): Don't fallback to setting the solib
	event breakpoint at _start, __start or main if a program
	interpreter is not found.
@
text
@d49 1
d1562 1
a1562 2
         well as BFD operations can be used.  Note that closing the
         target will also close the underlying bfd.  */
d1564 3
d1676 3
a1678 2
      /* We're done with both the temporary bfd and target.  Remember,
         closing the target closes the underlying bfd.  */
@


1.163
log
@gdb/
	* solib-svr4.c (svr4_current_sos): New comment on
	svr4_current_sos_via_xfer_libraries fall back.

gdb/gdbserver/
	* linux-low.c (linux_qxfer_libraries_svr4): Return -1 if R_DEBUG is -1.

gdb/testsuite/
	* gdb.server/solib-list-lib.c: New file.
	* gdb.server/solib-list-main.c: New file.
	* gdb.server/solib-list.exp: New file.
@
text
@d1710 1
a1710 1
  if (!current_inferior ()->attach_flag)
@


1.162
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d1263 8
@


1.161
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2252 1
a2252 1
  tp->suspend.stop_signal = TARGET_SIGNAL_0;
d2258 1
a2258 1
  while (tp->suspend.stop_signal != TARGET_SIGNAL_TRAP);
@


1.160
log
@gdb/
	Fix compilation --without-expat.
	* solib-svr4.c (svr4_free_so, svr4_free_library_list): Move them here
	from ...
	[HAVE_LIBEXPAT] (svr4_free_so, svr4_free_library_list): ... here.
@
text
@d3 2
a4 3
   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
   2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.160.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 2
   Copyright (C) 1990-1996, 1998-2001, 2003-2012 Free Software
   Foundation, Inc.
@


1.159
log
@gdb/
	* Makefile.in (XMLFILES): Add library-list-svr4.dtd.
	* features/library-list-svr4.dtd: New file.
	* remote.c (PACKET_qXfer_libraries_svr4): New.
	(remote_protocol_features): new entry for PACKET_qXfer_libraries_svr4.
	(remote_xfer_partial): Handle TARGET_OBJECT_LIBRARIES_SVR4.
	* solib-svr4.c (struct svr4_library_list): New.
	[HAVE_LIBEXPAT]: Include xml-support.h.
	[HAVE_LIBEXPAT] (svr4_library_list_start_library)
	[HAVE_LIBEXPAT] (svr4_library_list_start_list, svr4_library_attributes)
	[HAVE_LIBEXPAT] (svr4_library_list_children)
	[HAVE_LIBEXPAT] (svr4_library_list_attributes)
	[HAVE_LIBEXPAT] (svr4_library_list_elements, svr4_parse_libraries)
	[HAVE_LIBEXPAT] (svr4_current_sos_via_xfer_libraries)
	[!HAVE_LIBEXPAT] (svr4_current_sos_via_xfer_libraries): New.
	(svr4_read_so_list): Extend the corruption message by addresses.
	(svr4_current_sos): New variable library_list, call
	svr4_current_sos_via_xfer_libraries.
	* target.h (enum target_object): New TARGET_OBJECT_LIBRARIES_SVR4.

gdb/gdbserver/
	* linux-low.c (get_phdr_phnum_from_proc_auxv, get_dynamic, get_r_debug)
	(read_one_ptr, struct link_map_offsets, linux_qxfer_libraries_svr4):
	New.
	(struct linux_target_ops): Install linux_qxfer_libraries_svr4.
	* linux-low.h (struct process_info_private): New member r_debug.
	* server.c (handle_qxfer_libraries): Call
	the_target->qxfer_libraries_svr4.
	(handle_qxfer_libraries_svr4): New function.
	(qxfer_packets): New entry "libraries-svr4".
	(handle_query): Check QXFER_LIBRARIES_SVR4 and report libraries-svr4.
	* target.h (struct target_ops): New member qxfer_libraries_svr4.
	* remote.c (remote_xfer_partial): Call add_packet_config_cmd for
	PACKET_qXfer_libraries_svr4.

gdb/doc/
	* gdb.texinfo (Requirements, Remote Protocol): Reference also `Library
	List Format for SVR4 Targets'.
	(General Query Packets): New item qXfer:libraries-svr4:read.
	(Library List Format for SVR4 Targets): New node.

gdb/testsuite/
	* gdb.base/solib-corrupted.exp: Suppress test on is_remote target.
	(corrupted list): Adjust the expectation.
@
text
@d964 24
a1076 24
/* Implementation for target_so_ops.free_so.  */

static void
svr4_free_so (struct so_list *so)
{
  xfree (so->lm_info);
}

/* Free so_list built so far (called via cleanup).  */

static void
svr4_free_library_list (void *p_list)
{
  struct so_list *list = *(struct so_list **) p_list;

  while (list != NULL)
    {
      struct so_list *next = list->next;

      svr4_free_so (list);
      list = next;
    }
}

@


1.158
log
@	* solib-svr4.c (read_program_header): New variables pt_phdr, pt_phdr_p,
	initialize them from target PT_PHDR p_vaddr, relocate sect_addr by
	pt_phdr if PT_PHDR was found.

	* gdb.base/attach-pie-noexec.c: New files.
	* gdb.base/attach-pie-noexec.exp: New files.
@
text
@d952 101
d1077 63
d1199 3
a1201 1
	  warning (_("Corrupted shared library list"));
d1262 12
@


1.157
log
@gdb/
	Drop lazy lm_info reading.
	* solib-svr4.c (struct lm_info): Remove field lm.  New fields l_addr_p,
	l_addr_inferior, l_ld, l_next, l_prev and l_name.
	(lm_info_read): New function.
	(lm_addr_from_link_map, lm_dynamic_from_link_map): Remove.
	(lm_addr_check): Use l_addr_p.  No longer use lm_addr_from_link_map and
	lm_dynamic_from_link_map.
	(lm_next, lm_prev, lm_name): Remove.
	(svr4_keep_data_in_core): Use lm_info_read, drop the lm_info entries
	initialization incl. read_memory.  No longer use lm_name.
	(svr4_free_so): Drop lm_info->lm freeing.
	(svr4_default_sos): Initialize lminfo with zeroes.  Use l_addr_p.  Drop
	explicit lm_addr and lm initialization.
	(svr4_read_so_list): Use lm_info_read, drop the initailization of
	fields by hand, incl. read_memory.  No longer use lm_next, lm_prev and
	lm_name.
@
text
@d367 1
a367 1
  CORE_ADDR at_phdr, at_phent, at_phnum;
d371 1
d405 2
d411 11
a421 2
	  if (extract_unsigned_integer ((gdb_byte *)phdr.p_type,
					4, byte_order) == type)
d442 2
d448 11
a458 2
	  if (extract_unsigned_integer ((gdb_byte *)phdr.p_type,
					4, byte_order) == type)
d472 10
@


1.156
log
@gdb/
	* defs.h (struct so_list): New forward declaration.
	(make_cleanup_free_so): New declaration.
	* solib-svr4.c (ignore_first_link_map_entry): Remove.
	(svr4_free_so): Move the function here from downwards.  Handle NULL
	so->lm_info.
	(svr4_free_library_list): New.
	(svr4_read_so_list): New, moved here code from svr4_current_sos.
	Use more cleanups.  Use new parameter ignore_first instead of
	ignore_first_link_map_entry.
	(svr4_current_sos): New variable ignore_first, initialize it.  New
	variable back_to, use it for svr4_free_library_list protection.
	(svr4_free_so): Remove - move upwards.
	* utils.c: Include solist.h.
	(do_free_so, make_cleanup_free_so): New functions.
@
text
@a58 5
    /* Pointer to copy of link map from inferior.  The type is char *
       rather than void *, so that we may use byte offsets to find the
       various fields without the need for a cast.  */
    gdb_byte *lm;

d60 8
a67 5
       match the inferior.  This could most often be taken directly
       from lm, but when prelinking is involved and the prelink base
       address changes, we may need a different offset, we want to
       warn about the difference and compute it only once.  */
    CORE_ADDR l_addr;
d71 3
d144 2
a145 4
/* link map access functions.  */

static CORE_ADDR
lm_addr_from_link_map (struct so_list *so)
d148 32
a179 1
  struct type *ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;
d181 1
a181 2
  return extract_typed_address (so->lm_info->lm + lmo->l_addr_offset,
				ptr_type);
a192 10
lm_dynamic_from_link_map (struct so_list *so)
{
  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();
  struct type *ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;

  return extract_typed_address (so->lm_info->lm + lmo->l_ld_offset,
				ptr_type);
}

static CORE_ADDR
d195 1
a195 1
  if (so->lm_info->l_addr == (CORE_ADDR)-1)
d200 1
a200 1
      l_addr = lm_addr_from_link_map (so);
d205 1
a205 1
      l_dynaddr = lm_dynamic_from_link_map (so);
d289 1
a294 30
static CORE_ADDR
lm_next (struct so_list *so)
{
  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();
  struct type *ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;

  return extract_typed_address (so->lm_info->lm + lmo->l_next_offset,
				ptr_type);
}

static CORE_ADDR
lm_prev (struct so_list *so)
{
  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();
  struct type *ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;

  return extract_typed_address (so->lm_info->lm + lmo->l_prev_offset,
				ptr_type);
}

static CORE_ADDR
lm_name (struct so_list *so)
{
  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();
  struct type *ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;

  return extract_typed_address (so->lm_info->lm + lmo->l_name_offset,
				ptr_type);
}

d836 1
a836 1
  new->lm_info = xmalloc (sizeof (struct lm_info));
d838 1
a838 6
  new->lm_info->l_addr = (CORE_ADDR)-1;
  new->lm_info->lm_addr = ldsomap;
  new->lm_info->lm = xzalloc (lmo->link_map_size);
  make_cleanup (xfree, new->lm_info->lm);
  read_memory (ldsomap, new->lm_info->lm, lmo->link_map_size);
  name_lm = lm_name (new);
a923 2
  if (so->lm_info)
    xfree (so->lm_info->lm);
d957 1
a957 1
  new->lm_info = xmalloc (sizeof (struct lm_info));
d959 1
a959 2
  /* Nothing will ever check the cached copy of the link
     map if we set l_addr.  */
d961 1
a961 2
  new->lm_info->lm_addr = 0;
  new->lm_info->lm = NULL;
d991 6
a996 6
      new->lm_info = xmalloc (sizeof (struct lm_info));
      new->lm_info->l_addr = (CORE_ADDR) -1;
      new->lm_info->lm_addr = lm;
      new->lm_info->lm = xzalloc (lmo->link_map_size);

      read_memory (lm, new->lm_info->lm, lmo->link_map_size);
d998 1
a998 1
      next_lm = lm_next (new);
d1000 1
a1000 1
      if (lm_prev (new) != prev_lm)
d1012 1
a1012 1
      if (ignore_first && lm_prev (new) == 0)
d1022 1
a1022 1
      target_read_string (lm_name (new), &buffer,
@


1.155
log
@gdb/
	Code cleanup.
	* solib-svr4.c (svr4_default_sos):  Remove variables head and link_ptr.
	Rearrange the code for it.
@
text
@a304 11
static int
ignore_first_link_map_entry (struct so_list *so)
{
  /* Assume that everything is a library if the dynamic loader was loaded
     late by a static executable.  */
  if (exec_bfd && bfd_get_section_by_name (exec_bfd, ".dynamic") == NULL)
    return 0;

  return lm_prev (so) == 0;
}

d934 26
d989 3
a991 1
/* Implement the "current_sos" target_so_ops method.  */
d993 3
a995 2
static struct so_list *
svr4_current_sos (void)
d997 1
a997 11
  CORE_ADDR lm, prev_lm;
  struct so_list *head = 0;
  struct so_list **link_ptr = &head;
  CORE_ADDR ldsomap = 0;
  struct svr4_info *info;

  info = get_svr4_info ();

  /* Always locate the debug struct, in case it has moved.  */
  info->debug_base = 0;
  locate_base (info);
d999 1
a999 11
  /* If we can't find the dynamic linker's base structure, this
     must not be a dynamically linked executable.  Hmm.  */
  if (! info->debug_base)
    return svr4_default_sos ();

  /* Walk the inferior's link map list, and build our list of
     `struct so_list' nodes.  */
  prev_lm = 0;
  lm = solib_svr4_r_map (info);

  while (lm)
d1002 7
a1008 3
      struct so_list *new = XZALLOC (struct so_list);
      struct cleanup *old_chain = make_cleanup (xfree, new);
      CORE_ADDR next_lm;
d1011 1
a1011 3
      make_cleanup (xfree, new->lm_info);

      new->lm_info->l_addr = (CORE_ADDR)-1;
a1013 1
      make_cleanup (xfree, new->lm_info->lm);
d1022 2
a1023 2
	  free_so (new);
	  next_lm = 0;
d1031 1
a1031 1
      else if (ignore_first_link_map_entry (new) && ldsomap == 0)
d1033 2
d1036 2
a1037 1
	  free_so (new);
d1039 5
a1043 1
      else
d1045 4
a1048 28
	  int errcode;
	  char *buffer;

	  /* Extract this shared object's name.  */
	  target_read_string (lm_name (new), &buffer,
			      SO_NAME_MAX_PATH_SIZE - 1, &errcode);
	  if (errcode != 0)
	    warning (_("Can't read pathname for load map: %s."),
		     safe_strerror (errcode));
	  else
	    {
	      strncpy (new->so_name, buffer, SO_NAME_MAX_PATH_SIZE - 1);
	      new->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
	      strcpy (new->so_original_name, new->so_name);
	    }
	  xfree (buffer);

	  /* If this entry has no name, or its name matches the name
	     for the main executable, don't include it in the list.  */
	  if (! new->so_name[0]
	      || match_main (new->so_name))
	    free_so (new);
	  else
	    {
	      new->next = 0;
	      *link_ptr = new;
	      link_ptr = &new->next;
	    }
d1051 8
a1058 8
      prev_lm = lm;
      lm = next_lm;

      /* On Solaris, the dynamic linker is not in the normal list of
	 shared objects, so make sure we pick it up too.  Having
	 symbol information for the dynamic linker is quite crucial
	 for skipping dynamic linker resolver code.  */
      if (lm == 0 && ldsomap == 0)
d1060 2
a1061 2
	  lm = ldsomap = solib_svr4_r_ldsomap (info);
	  prev_lm = 0;
d1065 3
d1069 49
a2084 8
static void
svr4_free_so (struct so_list *so)
{
  xfree (so->lm_info->lm);
  xfree (so->lm_info);
}


@


1.154
log
@	gdb/
	* solib-dsbt.c (bfd_lookup_symbol): Removed.
	(cmp_name): New.
	(enable_break2): Update caller.
	* solib-frv.c (bfd_lookup_symbol): Removed.
	(cmp_name): New.
	(enable_break2): Update caller.
	* solib-pa64.c (bfd_lookup_symbol): Removed.
	(cmp_name): New.
	* solib-svr4.c (bfd_lookup_symbol): Removed.
	(cmp_name_and_sec_flags): New.
	(enable_break): Update caller.
	* solib.c (gdb_bfd_lookup_symbol_from_symtab): New.
	(gdb_bfd_lookup_symbol_from_dyn_symtab): New.
	(gdb_bfd_lookup_symbol): New.
	* solib.h: Functions declarations.
@
text
@d952 1
d954 2
a955 2
  struct so_list *head = NULL;
  struct so_list **link_ptr = &head;
d957 1
a957 3
  if (info->debug_loader_offset_p)
    {
      struct so_list *new = XZALLOC (struct so_list);
d959 1
a959 1
      new->lm_info = xmalloc (sizeof (struct lm_info));
d961 5
a965 10
      /* Nothing will ever check the cached copy of the link
	 map if we set l_addr.  */
      new->lm_info->l_addr = info->debug_loader_offset;
      new->lm_info->lm_addr = 0;
      new->lm_info->lm = NULL;

      strncpy (new->so_name, info->debug_loader_name,
	       SO_NAME_MAX_PATH_SIZE - 1);
      new->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
      strcpy (new->so_original_name, new->so_name);
d967 3
a969 3
      *link_ptr = new;
      link_ptr = &new->next;
    }
d971 1
a971 1
  return head;
@


1.153
log
@2011-08-09  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* elfread.c (elf_symtab_read): Ditto.
	* maint.c (maintenance_command): Ditto.
	* somread.c (som_symtab_read): Ditto.
	* solib.c (solib_find, solib_map_sections, update_solib_list)
	(solib_add, info_sharedlibrary_command, solib_name_from_address)
	(solib_create_inferior_hook, in_solib_dynsym_resolve_code)
	(sharedlibrary_command, no_shared_libraries): Rework comments.
	* solib-irix.c (locate_base, disable_break, enable_break)
	(irix_solib_create_inferior_hook, irix_solib_create_inferior_hook)
	(irix_current_sos, irix_open_symbol_file_object)
	(irix_special_symbol_handling): Ditto.
	* solib-sunos.c (locate_base, first_link_map_member)
	(sunos_current_sos, disable_break, enable_break)
	(sunos_special_symbol_handling, sunos_solib_create_inferior_hook):
	Ditto.
	* solib-svr4.c (bfd_lookup_symbol, elf_locate_base, locate_base)
	(open_symbol_file_object, svr4_current_sos, enable_break)
	(svr4_special_symbol_handling, svr4_solib_create_inferior_hook):
	Ditto.
	* solib-frv.c (bfd_lookup_symbol, open_symbol_file_object)
	(frv_current_sos, enable_break, frv_special_symbol_handling)
	(frv_solib_create_inferior_hook): Ditto.
	* solist.h (struct target_so_ops): Extend the comments of the
	special_symbol_handling, current_sos and open_symbol_file_object
	methods.
@
text
@a372 80
/* Lookup the value for a specific symbol.

   An expensive way to lookup the value of a single symbol for
   bfd's that are only temporary anyway.  This is used by the
   shared library support to find the address of the debugger
   notification routine in the shared library.

   The returned symbol may be in a code or data section; functions
   will normally be in a code section, but may be in a data section
   if this architecture uses function descriptors.

   Note that 0 is specifically allowed as an error return (no
   such symbol).  */

static CORE_ADDR
bfd_lookup_symbol (bfd *abfd, const char *symname)
{
  long storage_needed;
  asymbol *sym;
  asymbol **symbol_table;
  unsigned int number_of_symbols;
  unsigned int i;
  struct cleanup *back_to;
  CORE_ADDR symaddr = 0;

  storage_needed = bfd_get_symtab_upper_bound (abfd);

  if (storage_needed > 0)
    {
      symbol_table = (asymbol **) xmalloc (storage_needed);
      back_to = make_cleanup (xfree, symbol_table);
      number_of_symbols = bfd_canonicalize_symtab (abfd, symbol_table);

      for (i = 0; i < number_of_symbols; i++)
	{
	  sym = *symbol_table++;
	  if (strcmp (sym->name, symname) == 0
              && (sym->section->flags & (SEC_CODE | SEC_DATA)) != 0)
	    {
	      /* BFD symbols are section relative.  */
	      symaddr = sym->value + sym->section->vma;
	      break;
	    }
	}
      do_cleanups (back_to);
    }

  if (symaddr)
    return symaddr;

  /* On FreeBSD, the dynamic linker is stripped by default.  So we'll
     have to check the dynamic string table too.  */

  storage_needed = bfd_get_dynamic_symtab_upper_bound (abfd);

  if (storage_needed > 0)
    {
      symbol_table = (asymbol **) xmalloc (storage_needed);
      back_to = make_cleanup (xfree, symbol_table);
      number_of_symbols = bfd_canonicalize_dynamic_symtab (abfd, symbol_table);

      for (i = 0; i < number_of_symbols; i++)
	{
	  sym = *symbol_table++;

	  if (strcmp (sym->name, symname) == 0
              && (sym->section->flags & (SEC_CODE | SEC_DATA)) != 0)
	    {
	      /* BFD symbols are section relative.  */
	      symaddr = sym->value + sym->section->vma;
	      break;
	    }
	}
      do_cleanups (back_to);
    }

  return symaddr;
}


d1176 8
d1432 2
a1433 1
	  sym_addr = bfd_lookup_symbol (tmp_bfd, *bkpt_namep);
@


1.152
log
@Clean up trailing white space
@
text
@d373 1
a373 11
/*

   LOCAL FUNCTION

   bfd_lookup_symbol -- lookup the value for a specific symbol

   SYNOPSIS

   CORE_ADDR bfd_lookup_symbol (bfd *abfd, char *symname)

   DESCRIPTION
d385 1
a385 2
   such symbol).
 */
d756 2
a757 13

/*

   LOCAL FUNCTION

   elf_locate_base -- locate the base address of dynamic linker structs
   for SVR4 elf targets.

   SYNOPSIS

   CORE_ADDR elf_locate_base (void)

   DESCRIPTION
d766 1
a766 3
   silently return 0, otherwise the found address is returned.

 */
d807 1
a807 11
/*

   LOCAL FUNCTION

   locate_base -- locate the base address of dynamic linker structs

   SYNOPSIS

   CORE_ADDR locate_base (struct svr4_info *)

   DESCRIPTION
d830 1
a830 3
   executable symbol tables.

 */
d950 1
a950 5
/*

  LOCAL FUNCTION

  open_symbol_file_object
d952 4
a955 15
  SYNOPSIS

  void open_symbol_file_object (void *from_tty)

  DESCRIPTION

  If no open symbol file, attempt to locate and open the main symbol
  file.  On SVR4 systems, this is the first link map entry.  If its
  name is here, we can open it.  Useful when attaching to a process
  without first loading its symbol file.

  If FROM_TTYP dereferences to a non-zero integer, allow messages to
  be printed.  This parameter is a pointer rather than an int because
  open_symbol_file_object() is called via catch_errors() and
  catch_errors() requires a pointer argument.  */
d1060 1
a1060 18
/* LOCAL FUNCTION

   current_sos -- build a list of currently loaded shared objects

   SYNOPSIS

   struct so_list *current_sos ()

   DESCRIPTION

   Build a list of `struct so_list' objects describing the shared
   objects currently loaded in the inferior.  This list does not
   include an entry for the main executable file.

   Note that we only gather information directly available from the
   inferior --- we don't examine any of the shared library files
   themselves.  The declaration of `struct so_list' says which fields
   we provide values for.  */
d1256 1
a1256 11
/*

   LOCAL FUNCTION

   enable_break -- arrange for dynamic linker to hit breakpoint

   SYNOPSIS

   int enable_break (void)

   DESCRIPTION
d1286 1
a1286 2
   and then set to RT_CONSISTENT after the library is mapped/unmapped.
 */
d1573 1
a1573 24
/*

   LOCAL FUNCTION

   special_symbol_handling -- additional shared library symbol handling

   SYNOPSIS

   void special_symbol_handling ()

   DESCRIPTION

   Once the symbols from a shared object have been loaded in the usual
   way, we are called to do any system specific symbol handling that
   is needed.

   For SunOS4, this consisted of grunging around in the dynamic
   linkers structures to find symbol definitions for "common" symbols
   and adding them to the minimal symbol table for the runtime common
   objfile.

   However, for SVR4, there's nothing to do.

 */
d1578 1
d2035 1
a2035 22
/*

   GLOBAL FUNCTION

   svr4_solib_create_inferior_hook -- shared library startup support

   SYNOPSIS

   void svr4_solib_create_inferior_hook (int from_tty)

   DESCRIPTION

   When gdb starts up the inferior, it nurses it along (through the
   shell) until it is ready to execute it's first instruction.  At this
   point, this function gets called via expansion of the macro
   SOLIB_CREATE_INFERIOR_HOOK.

   For SunOS executables, this first instruction is typically the
   one at "_start", or a similar text label, regardless of whether
   the executable is statically or dynamically linked.  The runtime
   startup code takes care of dynamically linking in any shared
   libraries, once gdb allows the inferior to continue.
d2046 3
a2048 4
   For both SunOS shared libraries, and SVR4 shared libraries, we
   can arrange to cooperate with the dynamic linker to discover the
   names of shared libraries that are dynamically linked, and the
   base addresses to which they are linked.
d2062 1
a2062 2
   Also, what if child has exit()ed?  Must exit loop somehow.
 */
@


1.151
log
@	* symfile-mem.c (symbol_file_add_from_memory): Call do_cleanups.
	* solib-svr4.c (open_symbol_file_object): Call do_cleanups on all
	return paths.  Defer final do_cleanups until last return.
	* arm-tdep.c (arm_exidx_new_objfile): Make null cleanup after
	early return.
@
text
@d119 2
a120 2
     /usr/lib/ld.so.1, but later on, the table of loaded shared libraries 
     contains /lib/ld.so.1.  Sometimes one file is a link to another, but 
d1665 1
a1665 1
   way, we are called to do any system specific symbol handling that 
d1740 1
a1740 1
   
d2362 1
a2362 1
  
d2393 1
a2393 1
  
@


1.150
log
@2011-05-24  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* solib-svr4.c (svr4_solib_create_inferior_hook): Skip setting
	shared library event breakpoint if there's no execution.

	gdb/testsuite/
	* gdb.trace/tfile.exp: Add test that opening the basic.tf trace
	file doesn't error, using MI.
@
text
@d1024 4
a1027 1
      return 0;
d1032 4
a1035 1
    return 0;	/* failed somehow...  */
d1040 4
a1043 1
    return 0;	/* failed somehow...  */
a1050 3
  /* Free l_name_buf.  */
  do_cleanups (cleanups);

d1052 4
a1055 1
    return 0;		/* No filename.  */
d1065 1
d1072 1
@


1.149
log
@2011-05-09  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.h (wait_for_inferior): Remove `thread_exec_as_sigtrap'
	parameter.
	* infrun.c (proceed, start_remote): Adjust.
	(wait_for_inferior): Remove `thread_exec_as_sigtrap' parameter,
	and adjust to not handle it.
	* solib-irix.c (irix_solib_create_inferior_hook): Adjust.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Adjust.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Adjust.
	* windows-nat.c (do_initial_windows_stuff): Adjust.
	* infcmd.c (attach_command): Adjust.
	(notice_new_inferior): Adjust.
@
text
@d2191 5
@


1.148
log
@	* solib-svr4.c (svr4_keep_data_in_core): Rename local variable
	lm_name to name_lm to avoid conflict with lm_name function.
@
text
@d2216 1
a2216 1
      wait_for_inferior (0);
@


1.147
log
@	ARI fixes: Use only lowercase function name for static functions.
	* nto-tdep.c (LM_ADDR): Rename to...
	(lm_addr): New function name.
	(nto_relocate_section_addresses): Adapt to change above.
	* solib-sunos.c (LM_ADDR): Rename to...
	(lm_addr): New function name.
	(LM_NEXT): Rename to...
	(lm_next): New function name.
	(sunos_current_sos, sunos_relocate_section_addresses): Adapt to
	function name changes above.
	* solib-svr4.c (LM_ADDR_FROM_LINK_MAP): Rename to...
	(lm_addr_from_link_map): New function name.
	(HAS_LM_DYNAMIC_FROM_LINK_MAP): Rename to...
	(has_lm_dynamic_from_link_map): New function name.
	(LM_DYNAMIC_FROM_LINK_MAP): Rename to...
	(lm_dynamic_from_link_map): New function name.
	(LM_ADDR_CHECK): Rename to...
	(lm_addr_check): New function name.
	(LM_NEXT): Rename to...
	(lm_next): New function name.
	(LM_PREV): Rename to...
	(lm_prev): New function name.
	(LM_NAME): Rename to...
	(lm_name): New function name.
	(IGNORE_FIRST_LINK_MAP_ENTRY): Rename to...
	(ignore_first_link_map_entry): New function name.
	(svr4_keep_data_in_core): Adapt to function name changes above.
	(svr4_current_sos): Likewise.
	(enable_break): Likewise.
	(svr4_relocate_section_addresses): Likewise.
@
text
@d957 1
a957 1
  CORE_ADDR lm_name;
d980 1
a980 1
  lm_name = lm_name (new);
d983 1
a983 1
  return (lm_name >= vaddr && lm_name < vaddr + size);
@


1.146
log
@gdb/
	Fix libraries displacement if they change whether they were prelinked.
	* solib-svr4.c (LM_ADDR_CHECK): Set L_ADDR even if the DYNAMIC pointer
	does not match.  Comment why.

gdb/testsuite/
	* gdb.base/break-interp-lib.c (v, vptr): New variables.
	* gdb.base/break-interp.exp (test_attach): New comment.
@
text
@d146 1
a146 1
LM_ADDR_FROM_LINK_MAP (struct so_list *so)
d156 1
a156 1
HAS_LM_DYNAMIC_FROM_LINK_MAP (void)
d164 1
a164 1
LM_DYNAMIC_FROM_LINK_MAP (struct so_list *so)
d174 1
a174 1
LM_ADDR_CHECK (struct so_list *so, bfd *abfd)
d181 1
a181 1
      l_addr = LM_ADDR_FROM_LINK_MAP (so);
d183 1
a183 1
      if (! abfd || ! HAS_LM_DYNAMIC_FROM_LINK_MAP ())
d186 1
a186 1
      l_dynaddr = LM_DYNAMIC_FROM_LINK_MAP (so);
d276 1
a276 1
LM_NEXT (struct so_list *so)
d286 1
a286 1
LM_PREV (struct so_list *so)
d296 1
a296 1
LM_NAME (struct so_list *so)
d306 1
a306 1
IGNORE_FIRST_LINK_MAP_ENTRY (struct so_list *so)
d313 1
a313 1
  return LM_PREV (so) == 0;
d980 1
a980 1
  lm_name = LM_NAME (new);
d1161 1
a1161 1
      next_lm = LM_NEXT (new);
d1163 1
a1163 1
      if (LM_PREV (new) != prev_lm)
d1175 1
a1175 1
      else if (IGNORE_FIRST_LINK_MAP_ENTRY (new) && ldsomap == 0)
d1186 1
a1186 1
	  target_read_string (LM_NAME (new), &buffer,
d1487 1
a1487 1
	      load_addr = LM_ADDR_CHECK (so, tmp_bfd);
d2273 1
a2273 1
  sec->addr    = svr4_truncate_ptr (sec->addr    + LM_ADDR_CHECK (so,
d2275 1
a2275 1
  sec->endaddr = svr4_truncate_ptr (sec->endaddr + LM_ADDR_CHECK (so,
@


1.145
log
@gdb/
	GDB internal type support for STT_GNU_IFUNC.
	* elfread.c (record_minimal_symbol): Support mst_text_gnu_ifunc.
	(elf_symtab_read): Set mst_text_gnu_ifunc for
	BSF_GNU_INDIRECT_FUNCTION.
	* eval.c (evaluate_subexp_standard): Support TYPE_GNU_IFUNC.
	* gdbtypes.c (init_type): Support TYPE_FLAG_GNU_IFUNC,
	builtin_func_func, nodebug_text_gnu_ifunc_symbol and
	nodebug_got_plt_symbol.
	* gdbtypes.h (enum type_flag_value): New entry TYPE_FLAG_GNU_IFUNC.
	(TYPE_GNU_IFUNC): New.
	(struct main_type): New field flag_gnu_ifunc.
	(struct builtin_type): New field builtin_func_func.
	(struct objfile_type): New fields nodebug_text_gnu_ifunc_symbol and
	nodebug_got_plt_symbol.
	* minsyms.c (lookup_minimal_symbol_text): Support mst_text_gnu_ifunc.
	(in_gnu_ifunc_stub): New.
	(prim_record_minimal_symbol, find_solib_trampoline_target): Support
	mst_text_gnu_ifunc.
	* parse.c (write_exp_msymbol): New variable ifunc_msym.  Detect and
	support mst_text_gnu_ifunc.  Support mst_slot_got_plt.
	* solib-svr4.c (svr4_in_dynsym_resolve_code): Return true also for
	in_gnu_ifunc_stub.
	* symmisc.c (dump_msymbols): Support mst_text_gnu_ifunc.
	* symtab.c (search_symbols): Likewise.
	* symtab.h (enum minimal_symbol_type): New fields mst_text_gnu_ifunc
	and mst_slot_got_plt.
	(in_gnu_ifunc_stub): New declaration.
@
text
@d240 2
a244 2
	      l_addr = l_dynaddr - dynaddr;

d252 14
a265 3
	    warning (_(".dynamic section for \"%s\" "
		       "is not at the expected address "
		       "(wrong library or version mismatch?)"), so->so_name);
@


1.145.2.1
log
@2011-05-24  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* solib-svr4.c (svr4_solib_create_inferior_hook): Skip setting
	shared library event breakpoint if there's no execution.

	gdb/testsuite/
	* gdb.trace/tfile.exp: Add test that opening the basic.tf trace
	file doesn't error, using MI.
@
text
@a2179 5
  /* No point setting a breakpoint in the dynamic linker if we can't
     hit it (e.g., a core file, or a trace file).  */
  if (!target_has_execution)
    return;

@


1.144
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d1279 2
a1280 1
	  || in_plt_section (pc, NULL));
@


1.143
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d55 1
a55 1
/* Link map info to include in an allocated so_list entry */
d143 1
a143 1
/* link map access functions */
d309 1
a309 1
  CORE_ADDR debug_base;	/* Base of dynamic linker structures */
d597 1
a597 1
/* Scan for DYNTAG in .dynamic section of ABFD. If DYNTAG is found 1 is
d995 1
a995 1
  catch_errors() requires a pointer argument. */
d1018 1
a1018 1
    return 0;	/* failed somehow... */
d1023 1
a1023 1
    return 0;	/* failed somehow... */
d1163 1
a1163 1
         decide when to ignore it. */
d1689 1
a1689 1
   behavior is mandated by recent editions of the System V ABI. 
d2048 1
a2048 1
   stopping the inferior process at the entry point to the program. 
d2081 1
a2081 2
	 hope is that the old offsets are still applicable to the new run.
   */
d2193 1
a2193 1
     out what we need to know about them. */
d2397 1
a2397 1
/* Lookup global symbol for ELF DSOs linked with -Bsymbolic. Those DSOs have a
@


1.142
log
@run copyright.sh for 2011.
@
text
@d1372 2
a1373 2
							      sym_addr,
							      &current_target));
d1791 2
a1792 2
	     different from what the program headers in target memory say - this
	     is the goal of PIE.
d1802 2
a1803 1
	  else if (arch_size == 32 && phdrs_size >= sizeof (Elf32_External_Phdr)
d1866 2
a1867 1
		  vaddr = extract_unsigned_integer (buf_vaddr_p, 4, byte_order);
d1871 2
a1872 1
		  paddr = extract_unsigned_integer (buf_paddr_p, 4, byte_order);
d1911 2
a1912 1
	  else if (arch_size == 64 && phdrs_size >= sizeof (Elf64_External_Phdr)
d1975 2
a1976 1
		  vaddr = extract_unsigned_integer (buf_vaddr_p, 8, byte_order);
d1980 2
a1981 1
		  paddr = extract_unsigned_integer (buf_paddr_p, 8, byte_order);
@


1.141
log
@	* solib-svr4.c (enable_break): Don't attempt to place breakpoints,
	when attaching, on the names in bkpt_names: _start, __start, and
	main.
@
text
@d4 1
a4 1
   2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@


1.140
log
@gdb/
	Rename and move inferior_thread_state and inferior_status.
	* gdbthread.h (struct thread_control_state): New struct, move fields
	step_range_start, step_range_end, step_frame_id, step_stack_frame_id,
	trap_expected, proceed_to_finish, in_infcall, step_over_calls,
	stop_step and stop_bpstat here from struct thread_info.
	(struct thread_suspend_state): New struct, move field stop_signal here
	from struct thread_info.
	(struct thread_info): Move the fields above from this struct.
	* inferior.h: Move the inferior_thread_state and inferior_status
	declarations comment to their definitions at infrun.c.
	(struct inferior_control_state): New struct, move field stop_soon from
	struct inferior here.
	(struct inferior_suspend_state): New empty struct.
	(struct inferior): New fields control and suspend.  Move out field
	stop_soon.
	* infrun.c (struct inferior_thread_state): Rename to ...
	(infcall_suspend_state): ... here.  Replace field stop_signal by
	fields thread_suspend and inferior_suspend.
	(save_inferior_thread_state): Rename to ...
	(save_infcall_suspend_state): ... here.  New variable inf.  Update the
	code for new fields.
	(restore_inferior_thread_state): Rename to ...
	(restore_infcall_suspend_state): ... here.  New variable inf.  Update
	the code for new fields.
	(do_restore_inferior_thread_state_cleanup): Rename to ...
	(do_restore_infcall_suspend_state_cleanup): ... here.
	(make_cleanup_restore_inferior_thread_state): Rename to ...
	(make_cleanup_restore_infcall_suspend_state): ... here.
	(discard_inferior_thread_state): Rename to ...
	(discard_infcall_suspend_state): ... here.
	(get_inferior_thread_state_regcache): Rename to ...
	(get_infcall_suspend_state_regcache): ... here.
	(struct inferior_status): Rename to ...
	(struct infcall_control_state): ... here.  Replace fields
	step_range_start, step_range_end, step_frame_id, step_stack_frame_id,
	trap_expected, proceed_to_finish, in_infcall, step_over_calls,
	stop_step, stop_bpstat and stop_soon by fields thread_control and
	inferior_control.
	(save_inferior_status): Rename to ...
	(save_infcall_control_state): ... here.  Update the code for new
	fields.
	(restore_inferior_status): Rename to ...
	(restore_infcall_control_state): ... here.  Update the code for new
	fields.
	(do_restore_inferior_status_cleanup): Rename to ...
	(do_restore_infcall_control_state_cleanup): ... here.
	(make_cleanup_restore_inferior_status): Rename to ...
	(make_cleanup_restore_infcall_control_state): ... here.
	(discard_inferior_status): Rename to ...
	(discard_infcall_control_state): ... here.
	* alpha-tdep.c, breakpoint.c, dummy-frame.c, dummy-frame.h,
	exceptions.c, fbsd-nat.c, gdbthread.h, infcall.c, infcmd.c,
	inferior.c, inferior.h, infrun.c, linux-nat.c, mi/mi-interp.c,
	mips-tdep.c, procfs.c, solib-irix.c, solib-osf.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, thread.c, windows-nat.c: Update all the
	references to the moved fields and renamed functions.
@
text
@d1610 1
a1610 1
  for (bkpt_namep = bkpt_names; *bkpt_namep != NULL; bkpt_namep++)
d1612 1
a1612 2
      msymbol = lookup_minimal_symbol (*bkpt_namep, NULL, symfile_objfile);
      if ((msymbol != NULL) && (SYMBOL_VALUE_ADDRESS (msymbol) != 0))
d1614 10
a1623 6
	  sym_addr = SYMBOL_VALUE_ADDRESS (msymbol);
	  sym_addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch,
							 sym_addr,
							 &current_target);
	  create_solib_event_breakpoint (target_gdbarch, sym_addr);
	  return 1;
@


1.139
log
@gdb/
	Fix attaching to re-prelinked executables on ppc64.
	* solib-svr4.c (svr4_exec_displacement): New variable plt2_asect,
	initialize it, try to adjust FILESZ field by it.
@
text
@d2191 2
a2192 2
  inf->stop_soon = STOP_QUIETLY;
  tp->stop_signal = TARGET_SIGNAL_0;
d2195 1
a2195 1
      target_resume (pid_to_ptid (-1), 0, tp->stop_signal);
d2198 2
a2199 2
  while (tp->stop_signal != TARGET_SIGNAL_TRAP);
  inf->stop_soon = NO_STOP_QUIETLY;
@


1.138
log
@	* breakpoint.c (bpdisp_text): Constify bpdisps.
	* solib-svr4.c (solib_break_names): Constify.
	(bkpt_names, main_name_list): Constify.
	(match_main): Constify soname arg.
	(bfd_lookup_symbol): Constify symname arg.
	(enable_break): Constify bkpt_namep.
	* symtab.c (search_symbols): Constify types, types2, types3, types4.
	(symtab_symbol_info): Constify classnames.
@
text
@d1847 1
d1873 28
d1953 1
d1979 28
@


1.137
log
@gdb/
	Fix re-run of PIE executable, PR shlibs/11776.
	* solib-svr4.c (svr4_relocate_main_executable) <symfile_objfile>: Remove
	the part of pre-set SYMFILE_OBJFILE->SECTION_OFFSETS.

gdb/testsuite/
	Fix re-run of PIE executable, PR shlibs/11776.
	* gdb.base/break-interp.exp (test_ld): Turn off "disable-randomization".
	Remove $displacement_main to match the solib-svr4.c change.  New "kill"
	and re-"run" of the inferior.
@
text
@d83 1
a83 1
static char *solib_break_names[] =
d95 1
a95 1
static char *bkpt_names[] =
d103 1
a103 1
static char *main_name_list[] =
d360 1
a360 3
static int match_main (char *);

static CORE_ADDR bfd_lookup_symbol (bfd *, char *);
d388 1
a388 1
bfd_lookup_symbol (bfd *abfd, char *symname)
d1254 1
a1254 1
match_main (char *soname)
d1256 1
a1256 1
  char **mainp;
d1348 1
a1348 1
  char **bkpt_namep;
@


1.136
log
@gdb/
	* auxv.c (memory_xfer_auxv): Update attach comment.
	* solib-svr4.c (svr4_special_symbol_handling): Remove the call to
	svr4_relocate_main_executable.
	(svr4_solib_create_inferior_hook): Make the call to
	svr4_relocate_main_executable unconditional.

gdb/testsuite/
	* gdb.base/attach-pie-misread.exp, gdb.base/attach-pie-misread.c: New.
	* gdb.base/break-interp.exp (reach, test_core, test_ld): Require each
	displacement message exactly once.
@
text
@d1992 26
a2017 11
  if (symfile_objfile)
    {
      int i;

      /* Remote target may have already set specific offsets by `qOffsets'
	 which should be preferred.  */

      for (i = 0; i < symfile_objfile->num_sections; i++)
	if (ANOFFSET (symfile_objfile->section_offsets, i) != 0)
	  return;
    }
@


1.135
log
@gdb/
	Fix attaching to PIEs prelinked on the disk after the process was
	started.
	* solib-svr4.c (svr4_exec_displacement): New variable arch_size.
	Verify it against bfd_get_arch_size.  Try to match arbitrary
	displacement for the phdrs comparison.

gdb/testsuite/
	* gdb.base/break-interp.exp: Run $binpie with new value "ATTACH", new
	code for it.  New variable relink_args.
	(prelinkYES): Call prelinkNO.
	(test_attach): Accept new parameter relink_args.  Re-prelink the binary
	in such case.  Move the core code to ...
	(test_attach_gdb): ... a new function.  Send GDB command "file".
	Extend expected "Attaching to " string.
@
text
@a1655 1
  svr4_relocate_main_executable ();
d2098 1
a2098 2
  if (current_inferior ()->attach_flag == 0)
    svr4_relocate_main_executable ();
@


1.134
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* scm-exp.c: White space.
	* scm-lang.c: White space.
	* scm-valprint.c: White space.
	* sentinel-frame.c: White space.
	* ser-base.c: White space.
	* ser-go32.c: White space.
	* serial.c: White space.
	* ser-mingw.c: White space.
	* ser-pipe.c: White space.
	* ser-tcp.c: White space.
	* ser-unix.c: White space.
	* solib.c: White space.
	* solib-darwin.c: White space.
	* solib-frv.c: White space.
	* solib-irix.c: White space.
	* solib-osf.c: White space.
	* solib-pa64.c: White space.
	* solib-som.c: White space.
	* solib-spu.c: White space.
	* solib-svr4.c: White space.
	* solib-target.c: White space.
	* source.c: White space.
	* stabsread.c: White space.
	* stack.c: White space.
	* std-regs.c: White space.
	* symfile.c: White space.
	* symmisc.c: White space.
	* symtab.c: White space.
@
text
@d1778 1
d1780 1
a1780 1
      buf = read_program_header (-1, &phdrs_size, NULL);
d1782 177
a1958 4
      if (buf != NULL && buf2 != NULL
	  && (phdrs_size != phdrs2_size
	      || memcmp (buf, buf2, phdrs_size) != 0))
	ok = 0;
@


1.133
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* solib-svr4.c (find_program_interpreter): Delete unused variable.
	(svr4_solib_create_inferior_hook): Add ifdef around
	conditionally-used variable declarations.
@
text
@d726 1
d735 1
d798 1
d1525 1
d2072 1
@


1.132
log
@Expand description of solib-svr4.c:solib_svr4_r_map

2010-04-27  Joel Brobecker  <brobecker@@adacore.com>

        * solib-svr4.c (solib_svr4_r_map): Expand function description.
@
text
@a583 1
	CORE_ADDR sect_addr = bfd_section_vma (exec_bfd, interp_sect);
d1912 1
d1915 1
@


1.131
log
@gdb/
	Fix deadlock on looped list of loaded shared objects.
	* solib-svr4.c (LM_PREV): New function.
	(IGNORE_FIRST_LINK_MAP_ENTRY): Use it.
	(svr4_current_sos): Check for correct l_prev.  New variables prev_lm
	and next_lm.  Clear prev_lm for solib_svr4_r_ldsomap.
	* config/djgpp/fnchange.lst: Add translation for solib-corrupted.exp.

gdb/testsuite/
	Fix deadlock on looped list of loaded shared objects.
	* gdb.base/solib-corrupted.exp: New.
@
text
@d872 2
a873 1
   return its address in the inferior.
@


1.130
log
@gdb/
	* solib-svr4.c (LM_ADDR_CHECK) <info_verbose>: Use printf_unfiltered
	for the PIC displacement, print also the displacement value.
	(svr4_exec_displacement):  Print DISPLACEMENT if INFO_VERBOSE.

gdb/testsuite/
	* gdb.base/break-interp.exp: Create new displacement parameter value
	for the test_ld calls.
	(reach): New parameter displacement, verify its content.  New push of
	pf_prefix "reach-$func:".  Import global expect_out.
	(test_core): New parameter displacement, verify its content.  New push
	of pf_prefix "core:".  New command "set verbose on".  Import global
	expect_out.
	(test_attach): New parameter displacement, verify its content.  New
	push of pf_prefix "attach:".  New command "set verbose on".  Import
	global expect_out.
	(test_ld): New parameter displacement, pass it to the reach, test_core
	and test_attach calls and verify its content in the "ld.so exit" test.
	* gdb.base/prelink.exp: Remove gdb_exit and final return.
	(prelink): Update expected text, use gdb_test.
@
text
@d275 10
a296 3
  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();
  struct type *ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;

d302 1
a302 2
  return extract_typed_address (so->lm_info->lm + lmo->l_prev_offset,
				ptr_type) == 0;
d1110 1
a1110 1
  CORE_ADDR lm;
d1129 1
d1137 1
d1149 8
a1156 1
      lm = LM_NEXT (new);
d1163 1
a1163 1
      if (IGNORE_FIRST_LINK_MAP_ENTRY (new) && ldsomap == 0)
d1200 3
d1208 4
a1211 1
	lm = ldsomap = solib_svr4_r_ldsomap (info);
@


1.129
log
@gdb/
	* solib-svr4.c (svr4_exec_displacement): Return now success, new
	parameter displacementp.  Update comment.
	(svr4_relocate_main_executable): Return if non-zero SECTION_OFFSETS
	element exists.  Return if svr4_exec_displacement was not successful.
	Update comment.
@
text
@d246 4
a249 6
		{
		  warning (_(".dynamic section for \"%s\" "
			     "is not at the expected address"), so->so_name);
		  warning (_("difference appears to be caused by prelink, "
			     "adjusting expectations"));
		}
d1768 12
@


1.128
log
@gdb/
	* solib-svr4.c (read_program_header): Support type == -1 to read
	all program headers.
	(read_program_headers_from_bfd): New function.
	(svr4_static_exec_displacement): Remove and move the comment ...
	(svr4_exec_displacement): ... here.  Remove variable found.  New
	variable displacement.  Check also DYNAMIC.  Verify DISPLACEMENT
	alignment for ELF targets.  Compare target vs. exec_bfd PHDRs for ELF
	targets using read_program_headers_from_bfd.  Remove the call of
	svr4_static_exec_displacement.
@
text
@d1662 4
a1665 1
/* We relocate all of the sections by the same amount.  This
d1705 2
a1706 2
static CORE_ADDR
svr4_exec_displacement (void)
d1770 2
a1771 1
  return displacement;
d1782 16
a1797 1
  CORE_ADDR displacement = svr4_exec_displacement ();
d1799 2
a1800 3
  /* Even if DISPLACEMENT is 0 still try to relocate it as this is a new
     difference of in-memory vs. in-file addresses and we could already
     relocate the executable at this function to improper address before.  */
@


1.127
log
@dwarf2_physname patchset:

	Based on work from Daniel Jacobowitz  <dan@@codesourcery.com>
	* c-typeprint.c (cp_type_print_method_args): For non-static methods,
	print out const or volatile qualifiers, too.
	(c_type_print_args): Add parameters show_artificial and language.
	Skip artificial parameters when requested.
	Use the appropriate language printer.
	(c_type_print_varspec): Tell c_type_print_args to skip artificial
	parameters and pass language_c.
	* dwarf2read.c (die_list): New file global.
	(struct partial_die_info): Update comments for name field.
	(pdi_needs_namespace): Renamed to ...
	(die_needs_namespace): ... this. Rewrite.
	(dwarf2_linkage_name): Remove.
	(add_partial_symbol): Do not predicate the call to
	partial_die_full_name based on pdi_needs_namespace.
	Remove call to cp_check_possible_namespace_symbols and associated
	outdated comments.
	(guess_structure_name): Do not inspect child subprogram DIEs.
	(dwarf2_fullname): Update comments.
	Use die_needs_namespace to assist in computing the name.
	(read_func_scope): Use dwarf2_name to get the DIE's name.
	Use dwarf2_physname to get the "linkage name" of the DIE.
	(dwarf2_add_member_field): Use dwarf2_physname instead of
	dwarf2_linkage_name.
	(read_structure_type): For structs and classes, set TYPE_NAME, too.
	(determine_class): Remove.
	(read_partial_die): Ignore DW_AT_MIPS_linkage_name for all languages
	except Ada.
	(new_symbol): Unconditionally call dwarf2_name.
	Compute the "linkage name" using dwarf2_physname.
	Use dwarf2_name instead of dwarf2_full_name for enumerator DIEs.
	When determining to scan for anonymous C++ namespaces, ignore
	the linkage name.
	(dwarf2_physname): New function.
	(dwarf2_full_name): Move content to new function and call
	that.
	(dwarf2_compute_name): "New" function.
	(_initialize_dwarf2_read): Initialize die_list.
	* gnu-v3-eabi.c (gnu_v3_find_method_in): Remove unused variable
	physname.
	(gnu_v3_print_method_ptr): Use the physname for virtual methods
	without a demangled name.
	Print out type information for non-virtual methods.
        * linespec.c (decode_line_1): Force ANY string using "::" (or
	"." for java) to use decode_compound, and clean up any stray quoting.
        If we found a file symtab, re-evaluate whether the remainder is_quoted.
        (decode_compound): Stop consuming at an open parenthesis.
        Keep template parameters.
        Keep any overload information.
        Keep keywords like "const".
        Remove paren_pointer.
        Move is_quoted check from set_flags to here.
        Remove #if 0 code from 2000. Ten years is long enough.
        (find_method): Before comparing symbol names, canonicalize the string
        from the user.
        If a specific overload is requested, find it. Otherwise throw an error.
	(find_method_overload_end): New function.
	(set_flags): Remove.
        (decode_compound): Assume that parentheses are matched.
        It's a lot easier.
	* symtab.c (symbol_find_demangled_name): Add DMGL_VERBOSE flag
	to cplus_demangle.
	* linespec.c (decode_line_1): Keep important keywords like
	"const" and "volatile".
	* symtab.h (SYMBOL_CPLUS_DEMANGLED_NAME): Remove.
	* typeprint.h (c_type_print_args): Add declaration.
	* ui-file.c (do_ui_file_obsavestring): New function.
	(ui_file_obsavestring): New function.
	* ui-file.h (ui_file_obsavestring): Add declaration.
	* valops.c (find_overload_match): Resolve the object to
	a non-pointer type.
	If the object is a data member, search the object for the member
	and return with staticp set.
	Use SYMBOL_NATURAL_NAME instead of SYMBOL_CPLUS_DEMANGLED_NAME.
	Do not attempt to extract a function name from non-function types.
	If the extracted function name and the original name are the same,
	we don't have a C++ method.

	From Jan Kratochvil  <jan.kratochvil@@redhat.com>:
    	* dwarf2read.c (new_symbol <DW_TAG_enumerator>): Call dwarf2_full_name.

	* ada-lang.c (ada_lookup_symbol): Remove linkage_name parameters
	and arguments from symbol lookups.
	* ax-gdb.c (gen_expr): Likewise.
	* cp-namespace.c (cp_lookup_symbol_nonlocal, lookup_namespace_scope,
	cp_lookup_symbol_namespace, lookup_symbol_file, lookup_nested_type,
	lookup_possible_namespace_symbol): Likewise.
	* cp-support.c (read_in_psymtabs): Likewise.
	* cp-support.h (cp_lookup_symbol_nonlocal): Likewise.
	* language.h (la_lookup_symbol_nonlocal): Likewise.
	* scm-valprint.c (scm_inferior_print): Likewise.
	* solib-darwin.c (darwin_relocate_section_addresses): Likewise.
	* solib-svr.c (elf_lookup_lib): Likewise.
	* solib.c (show_auto_solib_add): Likewise.
	* solist.h (lookup_lib_global, solib_global_lookup): Likewise.
	* symmisc.c (maintenance_check_symtabs): Likewise.
	* symtab.c (lookup_symbol_in_language, lookup_symbol_aux,
	lookup_symbol_aux_local, lookup_symbol_aux_block,
	lookup_symbol_from_objfile, lookup_symbol_aux_symtabs,
	lookup_symbol_aux_psymtabs,basic_lookup_symbol_nonlocal,
	lookup_symbol_static, lookup_symbol_global, symbol_matches_domain,
	basic_lookup_transparent_type, find_main_psymtab,
	lookup_block_symbol): Likewise.
	* symtab.h (basic_lookp_symbol_nonlocal, lookup_symbol_static,
	lookup_symbol_global, lookup_symbol_aux_block,
	lookup_symbol_partial_symbol, lookup_block_symbol,
	lookup_global_symbol, value_maybe_namespace_elt): Likewise.
@
text
@d454 3
d489 7
a495 2
  /* Find .dynamic section via the PT_DYNAMIC PHDR.  */
  if (arch_size == 32)
d1636 2
a1637 33
/* Decide if the objfile needs to be relocated.  As indicated above,
   we will only be here when execution is stopped at the beginning
   of the program.  Relocation is necessary if the address at which
   we are presently stopped differs from the start address stored in
   the executable AND there's no interpreter section.  The condition
   regarding the interpreter section is very important because if
   there *is* an interpreter section, execution will begin there
   instead.  When there is an interpreter section, the start address
   is (presumably) used by the interpreter at some point to start
   execution of the program.

   If there is an interpreter, it is normal for it to be set to an
   arbitrary address at the outset.  The job of finding it is
   handled in enable_break().

   So, to summarize, relocations are necessary when there is no
   interpreter section and the start address obtained from the
   executable is different from the address at which GDB is
   currently stopped.
   
   [ The astute reader will note that we also test to make sure that
     the executable in question has the DYNAMIC flag set.  It is my
     opinion that this test is unnecessary (undesirable even).  It
     was added to avoid inadvertent relocation of an executable
     whose e_type member in the ELF header is not ET_DYN.  There may
     be a time in the future when it is desirable to do relocations
     on other types of files as well in which case this condition
     should either be removed or modified to accomodate the new file
     type.  (E.g, an ET_EXEC executable which has been built to be
     position-independent could safely be relocated by the OS if
     desired.  It is true that this violates the ABI, but the ABI
     has been known to be bent from time to time.)  - Kevin, Nov 2000. ]
   */
d1639 2
a1640 2
static CORE_ADDR
svr4_static_exec_displacement (void)
d1642 16
a1657 10
  asection *interp_sect;
  struct regcache *regcache
    = get_thread_arch_regcache (inferior_ptid, target_gdbarch);
  CORE_ADDR pc = regcache_read_pc (regcache);

  interp_sect = bfd_get_section_by_name (exec_bfd, ".interp");
  if (interp_sect == NULL 
      && (bfd_get_file_flags (exec_bfd) & DYNAMIC) != 0
      && (exec_entry_point (exec_bfd, &exec_ops) != pc))
    return pc - exec_entry_point (exec_bfd, &exec_ops);
d1659 1
a1659 1
  return 0;
d1681 20
a1700 1
   ABI and is left unspecified in some of the earlier editions.  */
a1704 1
  int found;
d1707 1
a1707 1
  CORE_ADDR entry_point;
d1712 54
a1765 2
  if (target_auxv_search (&current_target, AT_ENTRY, &entry_point) == 1)
    return entry_point - bfd_get_start_address (exec_bfd);
d1767 1
a1767 1
  return svr4_static_exec_displacement ();
@


1.126
log
@Memory error when reading wrong core file.

        * solib-svr4.c (solib_svr4_r_map): catch and print all exception
        errors while reading the inferior memory, and return zero if
        an exception was raised.
@
text
@a2043 1
		       const char *linkage_name,
d2061 1
a2061 2
  return lookup_global_symbol_from_objfile
		(objfile, name, linkage_name, domain);
@


1.125
log
@	* breakpoint.c (breakpoint_init_inferior): Also delete
	bp_shlib_event breakpoints.
	* solib-frv.c (enable_break): Remove call to
	remove_solib_event_breakpoints.
	* solib-svr4.c (enable_break): Ditto.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Ditto.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Ditto.
	* solib-som.c (som_solib_create_inferior_hook): Ditto.
	* solib-spu.c (spu_enable_break): Ditto.
@
text
@d871 2
d874 7
a880 2
  return read_memory_typed_address (info->debug_base + lmo->r_map_offset,
				    ptr_type);
@


1.124
log
@Use CORE_ADDR instead of ULONGEST on address.

2010-02-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR shlibs/11293
	* solib-svr4.c (enable_break): Check size of CORE_ADDR instead
	of ULONGEST for address size.
@
text
@a1317 4
  /* First, remove all the solib event breakpoints.  Their addresses
     may have changed since the last time we ran the program.  */
  remove_solib_event_breakpoints ();

@


1.124.2.1
log
@gdb/
	* solib-svr4.c (read_program_header): Support type == -1 to read
	all program headers.
	(read_program_headers_from_bfd): New function.
	(svr4_static_exec_displacement): Remove and move the comment ...
	(svr4_exec_displacement): ... here.  Remove variable found.  New
	variable displacement.  Check also DYNAMIC.  Verify DISPLACEMENT
	alignment for ELF targets.  Compare target vs. exec_bfd PHDRs for ELF
	targets using read_program_headers_from_bfd.  Remove the call of
	svr4_static_exec_displacement.
@
text
@a453 3
   If TYPE == -1, return the program headers instead of the contents of
   one program header.

d486 2
a487 7
  /* Find the requested segment.  */
  if (type == -1)
    {
      sect_addr = at_phdr;
      sect_size = at_phent * at_phnum;
    }
  else if (arch_size == 32)
d1625 33
a1657 2
/* Read the ELF program headers from ABFD.  Return the contents and
   set *PHDRS_SIZE to the size of the program headers.  */
d1659 2
a1660 2
static gdb_byte *
read_program_headers_from_bfd (bfd *abfd, int *phdrs_size)
d1662 10
a1671 2
  Elf_Internal_Ehdr *ehdr;
  gdb_byte *buf;
d1673 1
a1673 15
  ehdr = elf_elfheader (abfd);

  *phdrs_size = ehdr->e_phnum * ehdr->e_phentsize;
  if (*phdrs_size == 0)
    return NULL;

  buf = xmalloc (*phdrs_size);
  if (bfd_seek (abfd, ehdr->e_phoff, SEEK_SET) != 0
      || bfd_bread (buf, *phdrs_size, abfd) != *phdrs_size)
    {
      xfree (buf);
      return NULL;
    }

  return buf;
d1695 1
a1695 20
   ABI and is left unspecified in some of the earlier editions.

   Decide if the objfile needs to be relocated.  As indicated above, we will
   only be here when execution is stopped.  But during attachment PC can be at
   arbitrary address therefore regcache_read_pc can be misleading (contrary to
   the auxv AT_ENTRY value).  Moreover for executable with interpreter section
   regcache_read_pc would point to the interpreter and not the main executable.

   So, to summarize, relocations are necessary when the start address obtained
   from the executable is different from the address in auxv AT_ENTRY entry.
   
   [ The astute reader will note that we also test to make sure that
     the executable in question has the DYNAMIC flag set.  It is my
     opinion that this test is unnecessary (undesirable even).  It
     was added to avoid inadvertent relocation of an executable
     whose e_type member in the ELF header is not ET_DYN.  There may
     be a time in the future when it is desirable to do relocations
     on other types of files as well in which case this condition
     should either be removed or modified to accomodate the new file
     type.  - Kevin, Nov 2000. ]  */
d1700 1
d1703 1
a1703 1
  CORE_ADDR entry_point, displacement;
d1708 2
a1709 54
  /* Therefore for ELF it is ET_EXEC and not ET_DYN.  Both shared libraries
     being executed themselves and PIE (Position Independent Executable)
     executables are ET_DYN.  */

  if ((bfd_get_file_flags (exec_bfd) & DYNAMIC) == 0)
    return 0;

  if (target_auxv_search (&current_target, AT_ENTRY, &entry_point) <= 0)
    return 0;

  displacement = entry_point - bfd_get_start_address (exec_bfd);

  /* Verify the DISPLACEMENT candidate complies with the required page
     alignment.  It is cheaper than the program headers comparison below.  */

  if (bfd_get_flavour (exec_bfd) == bfd_target_elf_flavour)
    {
      const struct elf_backend_data *elf = get_elf_backend_data (exec_bfd);

      /* p_align of PT_LOAD segments does not specify any alignment but
	 only congruency of addresses:
	   p_offset % p_align == p_vaddr % p_align
	 Kernel is free to load the executable with lower alignment.  */

      if ((displacement & (elf->minpagesize - 1)) != 0)
	return 0;
    }

  /* Verify that the auxilliary vector describes the same file as exec_bfd, by
     comparing their program headers.  If the program headers in the auxilliary
     vector do not match the program headers in the executable, then we are
     looking at a different file than the one used by the kernel - for
     instance, "gdb program" connected to "gdbserver :PORT ld.so program".  */

  if (bfd_get_flavour (exec_bfd) == bfd_target_elf_flavour)
    {
      /* Be optimistic and clear OK only if GDB was able to verify the headers
	 really do not match.  */
      int phdrs_size, phdrs2_size, ok = 1;
      gdb_byte *buf, *buf2;

      buf = read_program_header (-1, &phdrs_size, NULL);
      buf2 = read_program_headers_from_bfd (exec_bfd, &phdrs2_size);
      if (buf != NULL && buf2 != NULL
	  && (phdrs_size != phdrs2_size
	      || memcmp (buf, buf2, phdrs_size) != 0))
	ok = 0;

      xfree (buf);
      xfree (buf2);

      if (!ok)
	return 0;
    }
d1711 1
a1711 1
  return displacement;
@


1.124.2.2
log
@gdb/
	* solib-svr4.c (svr4_exec_displacement): Return now success, new
	parameter displacementp.  Update comment.
	(svr4_relocate_main_executable): Return if non-zero SECTION_OFFSETS
	element exists.  Return if svr4_exec_displacement was not successful.
	Update comment.
@
text
@d1659 1
a1659 4
/* Return 1 and fill *DISPLACEMENTP with detected PIE offset of inferior
   exec_bfd.  Otherwise return 0.

   We relocate all of the sections by the same amount.  This
d1699 2
a1700 2
static int
svr4_exec_displacement (CORE_ADDR *displacementp)
d1764 1
a1764 2
  *displacementp = displacement;
  return 1;
d1775 1
a1775 16
  CORE_ADDR displacement;

  if (symfile_objfile)
    {
      int i;

      /* Remote target may have already set specific offsets by `qOffsets'
	 which should be preferred.  */

      for (i = 0; i < symfile_objfile->num_sections; i++)
	if (ANOFFSET (symfile_objfile->section_offsets, i) != 0)
	  return;
    }

  if (! svr4_exec_displacement (&displacement))
    return;
d1777 3
a1779 2
  /* Even DISPLACEMENT 0 is a valid new difference of in-memory vs. in-file
     addresses.  */
@


1.123
log
@gdb/
	* solib-svr4.c (enable_break <target_auxv_search>): New variable
	addr_bit.  Adjust LOAD_ADDR sign for cross-arch inferiors.
@
text
@d1462 1
a1462 1
	    if (addr_bit < (sizeof (ULONGEST) * HOST_CHAR_BIT))
d1464 1
a1464 1
		CORE_ADDR space_size = (ULONGEST) 1 << addr_bit;
@


1.122
log
@gdb/
	* solib-svr4.c (LM_ADDR_CHECK): New variable minpagesize.  Optionally
	initialize it from ELF BFD.  Extend the prelink condition by it.
@
text
@d1454 26
a1479 1
          load_addr_found = 1;
@


1.121
log
@gdb/
	* solib-svr4.c: (LM_ADDR_CHECK): Move variable align to a more inner
	block.
@
text
@d197 1
d210 2
d236 3
a238 1
	     equivalent to the possibly expected check above.)  */
d240 2
a241 1
	  if ((l_addr & align) == ((l_dynaddr - dynaddr) & align))
@


1.120
log
@gdb/
	* solib-svr4.c: (LM_ADDR_CHECK): Print successful prelink adjustment
	only if INFO_VERBOSE.

gdb/testsuite/
	* gdb.base/prelink.exp (set verbose on): New.
@
text
@d179 1
a179 1
      CORE_ADDR l_addr, l_dynaddr, dynaddr, align = 0x1000;
d196 2
@


1.119
log
@gdb/
	* solib-svr4.c (LM_ADDR_CHECK): New comment on PPC-aware condition.
@
text
@d237 7
a243 4
	      warning (_(".dynamic section for \"%s\" "
		     "is not at the expected address"), so->so_name);
	      warning (_("difference appears to be caused by prelink, "
			 "adjusting expectations"));
@


1.118
log
@	* solib-svr4.c (enable_break): Add comment.
@
text
@d220 13
a232 1
	     quite work.  */
@


1.117
log
@gdb/
	* solib-svr4.c (scan_dyntag): New variable dyn_addr.  Replace gdb_assert
	by a conditional setting DYN_ADDR.  Use DYN_ADDR.
	* config/djgpp/fnchange.lst: Add translations for
	symbol-without-target_section.exp and symbol-without-target_section.c.

gdb/testsuite/
	* gdb.base/symbol-without-target_section.exp,
	gdb.base/symbol-without-target_section.c: New.
@
text
@d1321 19
@


1.116
log
@	* solib-svr4.c (solib_break_names): Add __dl_rtld_db_dlactivity.
@
text
@d573 1
a573 1
  CORE_ADDR dyn_ptr;
d600 11
a610 1
  gdb_assert (target_section < current_target_sections->sections_end);
d652 1
a652 1
	     ptr_addr = target_section->addr + (buf - bufstart) + arch_size / 8;
@


1.115
log
@gdb/
	* solib-svr4.c (svr4_exec_displacement): New comment for entry_point.
	Replace exec_entry_point call by bfd_get_start_address.
@
text
@d89 1
@


1.114
log
@gdb/
	Support Valgrind attachments broken by the PIE support.
	* auxv.c: Include gdbcore.h.
	(procfs_xfer_auxv): Make static.  Reduce its comment.  Drop its
	parameters ops, object and annex.  Remove their assertions.
	(ld_so_xfer_auxv, memory_xfer_auxv): New function.
	* auxv.h (procfs_xfer_auxv): Remove comment.  Rename to ...
	(memory_xfer_auxv): ... here.
	* linux-nat.c (linux_xfer_partial): Rename procfs_xfer_auxv to
	memory_xfer_auxv.
	* procfs.c (procfs_xfer_partial): Likewise.
	* solib-svr4.c (svr4_relocate_main_executable): New prototype.
	(svr4_special_symbol_handling): Call svr4_relocate_main_executable.
	(svr4_solib_create_inferior_hook): Conditionalize the
	svr4_relocate_main_executable call.

gdb/testsuite/
	* gdb.base/valgrind-db-attach.exp, gdb.base/valgrind-db-attach.c: New.
@
text
@d1623 2
d1631 1
a1631 1
    return entry_point - exec_entry_point (exec_bfd, &current_target);
@


1.113
log
@gdb/
	* solib-svr4.c (scan_dyntag): Remove variable dyn_addr.  New variable
	target_section.  Find SECT in current_target_sections, gdb_assert it.
	(elf_lookup_lib_symbol): Pass the binary file if given symfile_objfile.
	New variable abfd.
	* symtab.c (lookup_objfile_from_block): Return the binary file instead
	of separate debug info file.

gdb/testsuite/
	* gdb.base/break-interp.exp (test_core): New proc.
	(test_ld): Call it.
@
text
@d53 1
d1544 1
d1734 2
a1735 1
  svr4_relocate_main_executable ();
@


1.112
log
@gdb/
	Support PIEs with no symfile_objfile.
	* exec.c (print_section_info <abfd == exec_bfd>): Relocate Entry point.
	* solib-svr4.c (svr4_relocate_main_executable <exec_bfd>): New block.

gdb/testsuite/
	Support PIEs with no symfile_objfile.
	* gdb.base/break-interp.exp: New argument at the test_ld calls.
	(test_ld): New parameter trynosym.
	(test_ld <$trynosym>): New block.
@
text
@d571 1
a571 1
  CORE_ADDR dyn_ptr, dyn_addr;
d576 1
d592 7
a598 1
  dyn_addr = bfd_section_vma (abfd, sect);
d640 1
a640 1
	     ptr_addr = dyn_addr + (buf - bufstart) + arch_size / 8;
d1961 13
a1973 2
  if (objfile->obfd == NULL
     || scan_dyntag (DT_SYMBOLIC, objfile->obfd, NULL) != 1)
@


1.111
log
@gdb/
	* solib-svr4.c (svr4_relocate_main_executable): Move the static exec
	code part to ...
	(svr4_static_exec_displacement): ... a new function.
	(svr4_exec_displacement): New function.
	(svr4_relocate_main_executable): Call svr4_exec_displacement.  Allocate
	new_offsets using alloca now.  Remove variable old_chain and changed.
	Call objfile_relocate unconditionally now.

gdb/testsuite/
	* gdb.base/break-interp.exp: New file.
@
text
@d1652 9
@


1.110
log
@gdb/
	Add from_tty to solib_create_inferior_hook.
	* infcmd.c (post_create_inferior): Move solib_add after
	solib_create_inferior_hook.  Pass from_tty to
	solib_create_inferior_hook.  Call solib_add and SOLIB_ADD with
	0 from_tty and comment why.
	* infrun.c (follow_exec): Pass from_tty solib_create_inferior_hook as 0.
	* linux-nat.c (linux_child_follow_fork): Likewise.
	* nto-procfs.c (procfs_post_attach, procfs_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): New parameter
	from_tty.
	* solib-frv.c (frv_solib_create_inferior_hook): Likewise.
	* solib-irix.c (irix_solib_create_inferior_hook): Likewise.
	* solib-null.c (null_solib_create_inferior_hook): Likewise.
	* solib-osf.c (osf_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-som.c (som_solib_create_inferior_hook): Likewise.
	* solib-spu.c (spu_solib_create_inferior_hook): New parameter from_tty.
	Pass it to svr4_so_ops.solib_create_inferior_hook.
	* solib-sunos.c (sunos_solib_create_inferior_hook): New parameter
	from_tty.
	* solib-svr4.c (enable_break): New parameter from_tty.  Pass it to
	solib_add.
	(svr4_solib_create_inferior_hook): New parameter from_tty.  Pass it to
	enable_break.
	* solib-target.c (solib_target_solib_create_inferior_hook): New
	parameter from_tty.
	* solib.c (solib_create_inferior_hook): New parameter from_tty.  Pass
	it to ops->solib_create_inferior_hook.
	(reload_shared_libraries): Pass from_tty to solib_create_inferior_hook.
	Move solib_add after solib_create_inferior_hook, call it now with
	from_tty as 0.  New comment there.
	* solib.h (solib_create_inferior_hook): New parameter from_tty.
	* solist.h (struct target_so_ops <solib_create_inferior_hook>):
	Likewise.
@
text
@d1538 19
a1556 4
/* Relocate the main executable.  This function should be called upon
   stopping the inferior process at the entry point to the program. 
   The entry point from BFD is compared to the PC and if they are
   different, the main executable is relocated by the proper amount. 
d1558 13
a1570 4
   As written it will only attempt to relocate executables which
   lack interpreter sections.  It seems likely that only dynamic
   linker executables will get relocated, though it should work
   properly for a position-independent static executable as well.  */
d1572 2
a1573 2
static void
svr4_relocate_main_executable (void)
a1579 34
  /* Decide if the objfile needs to be relocated.  As indicated above,
     we will only be here when execution is stopped at the beginning
     of the program.  Relocation is necessary if the address at which
     we are presently stopped differs from the start address stored in
     the executable AND there's no interpreter section.  The condition
     regarding the interpreter section is very important because if
     there *is* an interpreter section, execution will begin there
     instead.  When there is an interpreter section, the start address
     is (presumably) used by the interpreter at some point to start
     execution of the program.

     If there is an interpreter, it is normal for it to be set to an
     arbitrary address at the outset.  The job of finding it is
     handled in enable_break().

     So, to summarize, relocations are necessary when there is no
     interpreter section and the start address obtained from the
     executable is different from the address at which GDB is
     currently stopped.
     
     [ The astute reader will note that we also test to make sure that
       the executable in question has the DYNAMIC flag set.  It is my
       opinion that this test is unnecessary (undesirable even).  It
       was added to avoid inadvertent relocation of an executable
       whose e_type member in the ELF header is not ET_DYN.  There may
       be a time in the future when it is desirable to do relocations
       on other types of files as well in which case this condition
       should either be removed or modified to accomodate the new file
       type.  (E.g, an ET_EXEC executable which has been built to be
       position-independent could safely be relocated by the OS if
       desired.  It is true that this violates the ABI, but the ABI
       has been known to be bent from time to time.)  - Kevin, Nov 2000. ]
     */

d1584 56
a1640 1
      struct cleanup *old_chain;
d1642 4
a1645 34
      int i, changed;
      CORE_ADDR displacement;
      
      /* It is necessary to relocate the objfile.  The amount to
	 relocate by is simply the address at which we are stopped
	 minus the starting address from the executable.

	 We relocate all of the sections by the same amount.  This
	 behavior is mandated by recent editions of the System V ABI. 
	 According to the System V Application Binary Interface,
	 Edition 4.1, page 5-5:

	   ...  Though the system chooses virtual addresses for
	   individual processes, it maintains the segments' relative
	   positions.  Because position-independent code uses relative
	   addressesing between segments, the difference between
	   virtual addresses in memory must match the difference
	   between virtual addresses in the file.  The difference
	   between the virtual address of any segment in memory and
	   the corresponding virtual address in the file is thus a
	   single constant value for any one executable or shared
	   object in a given process.  This difference is the base
	   address.  One use of the base address is to relocate the
	   memory image of the program during dynamic linking.

	 The same language also appears in Edition 4.0 of the System V
	 ABI and is left unspecified in some of the earlier editions.  */

      displacement = pc - exec_entry_point (exec_bfd, &exec_ops);
      changed = 0;

      new_offsets = xcalloc (symfile_objfile->num_sections,
			     sizeof (struct section_offsets));
      old_chain = make_cleanup (xfree, new_offsets);
d1648 1
a1648 8
	{
	  if (displacement != ANOFFSET (symfile_objfile->section_offsets, i))
	    changed = 1;
	  new_offsets->offsets[i] = displacement;
	}

      if (changed)
	objfile_relocate (symfile_objfile, new_offsets);
d1650 1
a1650 1
      do_cleanups (old_chain);
@


1.109
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d1268 1
a1268 1
enable_break (struct svr4_info *info)
d1288 1
a1288 1
  solib_add (NULL, 0, &current_target, auto_solib_add);
d1415 1
a1415 1
	  solib_add (NULL, 0, &current_target, auto_solib_add);
d1654 1
a1654 1
   void svr4_solib_create_inferior_hook ()
d1699 1
a1699 1
svr4_solib_create_inferior_hook (void)
d1713 1
a1713 1
  if (!enable_break (info))
@


1.108
log
@	* gcore.c: Include solib.h.
	(gcore_create_callback): Call solib_keep_data_in_core when
	considering not saving memory in core file.
	* solib-svr4.c (svr4_keep_data_in_core): New.
	(_initialize_svr4_solib): Initialize
	svr4_so_ops.keep_data_in_core.
	* solib.c (solib_keep_data_in_core): New.
	* solib.h (solib_keep_data_in_core): Declare.
	* solist.h (struct target_so_ops): Add keep_data_in_core.
@
text
@d4 1
a4 1
   2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009
@


1.107
log
@	* solib-svr4.c (enable_break): Call
	gdbarch_convert_from_func_ptr_addr on results of looking up
	fallback symbol names.
@
text
@d869 44
d1965 1
@


1.106
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d1439 5
a1443 2
	  create_solib_event_breakpoint (target_gdbarch,
					 SYMBOL_VALUE_ADDRESS (msymbol));
d1453 5
a1457 2
	  create_solib_event_breakpoint (target_gdbarch,
					 SYMBOL_VALUE_ADDRESS (msymbol));
@


1.105
log
@	* solib.c (solib_bfd_open): Do not call ops->bfd_open.
	(solib_map_sections): Call ops->bfd_open instead of solib_bfd_open.
	* solib-frv.c (_initialize_frv_solib): Initialize bfd_open member.
	* solib-irix.c (_initialize_irix_solib): Likewise.
	* solib-null.c (_initialize_null_solib): Likewise.
	* solib-osf.c (_initialize_osf_solib): Likewise.
	* solib-pa64.c (_initialize_pa64_solib): Likewise.
	* solib-som.c (_initialize_som_solib): Likewise.
	* solib-sunos.c (_initialize_sunos_solib): Likewise.
	* solib-svr4.c (_initialize_svr4_solib): Likewise.
	* solib-target.c (_initialize_solib_target): Likewise.
@
text
@d276 1
a276 1
/* Per-inferior SVR4 specific data.  */
a279 2
  int pid;

d293 5
d300 2
a301 2
/* List of known processes using solib-svr4 shared libraries, storing
   the required bookkeeping for each.  */
d303 2
a304 9
typedef struct svr4_info *svr4_info_p;
DEF_VEC_P(svr4_info_p);
VEC(svr4_info_p) *svr4_info = NULL;

/* Get svr4 data for inferior PID (target id).  If none is found yet,
   add it now.  This function always returns a valid object.  */

struct svr4_info *
get_svr4_info (int pid)
d306 1
a306 15
  int ix;
  struct svr4_info *it;

  gdb_assert (pid != 0);

  for (ix = 0; VEC_iterate (svr4_info_p, svr4_info, ix, it); ++ix)
    {
      if (it->pid == pid)
	return it;
    }

  it = XZALLOC (struct svr4_info);
  it->pid = pid;

  VEC_safe_push (svr4_info_p, svr4_info, it);
d308 2
a309 1
  return it;
d312 2
a313 2
/* Get rid of any svr4 related bookkeeping for inferior PID (target
   id).  */
d315 2
a316 2
static void
remove_svr4_info (int pid)
d318 1
a318 12
  int ix;
  struct svr4_info *it;

  for (ix = 0; VEC_iterate (svr4_info_p, svr4_info, ix, it); ++ix)
    {
      if (it->pid == pid)
	{
	  VEC_unordered_remove (svr4_info_p, svr4_info, ix);
	  return;
	}
    }
}
d320 7
a326 10
/* This is an "inferior_exit" observer.  Inferior PID (target id) is
   being removed from the inferior list, because it exited, was
   killed, detached, or we just dropped the connection to the debug
   interface --- discard any solib-svr4 related bookkeeping for this
   inferior.  */

static void
solib_svr4_inferior_exit (int pid)
{
  remove_svr4_info (pid);
d903 1
a903 1
  struct svr4_info *info = get_svr4_info (PIDGET (inferior_ptid));
d954 1
a954 2
  struct inferior *inf = current_inferior ();
  struct svr4_info *info = get_svr4_info (inf->pid);
a1008 1
  struct inferior *inf;
d1011 1
a1011 5
  if (ptid_equal (inferior_ptid, null_ptid))
    return NULL;

  inf = current_inferior ();
  info = get_svr4_info (inf->pid);
d1108 1
a1108 1
  struct svr4_info *info = get_svr4_info (PIDGET (inferior_ptid));
a1147 4
static CORE_ADDR interp_text_sect_low;
static CORE_ADDR interp_text_sect_high;
static CORE_ADDR interp_plt_sect_low;
static CORE_ADDR interp_plt_sect_high;
d1152 6
a1157 2
  return ((pc >= interp_text_sect_low && pc < interp_text_sect_high)
	  || (pc >= interp_plt_sect_low && pc < interp_plt_sect_high)
a1230 1
  struct inferior *inf = current_inferior ();
d1236 2
a1237 2
  interp_text_sect_low = interp_text_sect_high = 0;
  interp_plt_sect_low = interp_plt_sect_high = 0;
d1273 1
a1273 1
	      interp_text_sect_low =
d1275 3
a1277 2
	      interp_text_sect_high =
		interp_text_sect_low + bfd_section_size (tmp_bfd, interp_sect);
d1282 1
a1282 1
	      interp_plt_sect_low =
d1284 3
a1286 2
	      interp_plt_sect_high =
		interp_plt_sect_low + bfd_section_size (tmp_bfd, interp_sect);
d1379 1
a1379 1
	  interp_text_sect_low =
d1381 3
a1383 2
	  interp_text_sect_high =
	    interp_text_sect_low + bfd_section_size (tmp_bfd, interp_sect);
d1388 1
a1388 1
	  interp_plt_sect_low =
d1390 3
a1392 2
	  interp_plt_sect_high =
	    interp_plt_sect_low + bfd_section_size (tmp_bfd, interp_sect);
d1655 1
a1655 1
  info = get_svr4_info (PIDGET (inferior_ptid));
d1695 8
a1702 1
  remove_svr4_info (PIDGET (inferior_ptid));
d1901 2
a1914 2

  observer_attach_inferior_exit (solib_svr4_inferior_exit);
@


1.104
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d1937 1
@


1.103
log
@	* breakpoint.h (struct breakpoint): New member GDBARCH.
	* breakpoint.c: Include "arch-utils.h".
	(set_raw_breakpoint_without_location): Add GDBARCH parameter.
	Use it to set breakpoint architecture.
	(set_raw_breakpoint): Add GDBARCH parameter.
	(create_internal_breakpoint): Likewise.
	(create_catchpoint): Likewise.
	(create_fork_vfork_event_catchpoint): Likewise.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise.
	(break_command_really): Likewise.
	(create_ada_exception_breakpoint): Likewise.
	Update local callers to pass architecture:
	(create_internal_breakpoint): Update.
	(create_overlay_event_breakpoint): Update.
	(create_longjmp_master_breakpoint): Update.
	(create_thread_event_breakpoint): Update.
	(create_solib_event_breakpoint): Update.
	(create_catchpoint): Update.
	(create_fork_vfork_event_catchpoint): Update.
	(set_momentary_breakpoint): Update.
	(clone_momentary_breakpoint): Update.
	(create_breakpoint): Update.
	(create_breakpoints): Update.
	(break_command_really): Update.
	(break_command_1): Update.
	(set_breakpoint): Update.
	(watch_command_1): Update.
	(catch_fork_command_1): Update.
	(catch_exec_commnd_1): Update.
	(handle_gnu_v3_exceptions): Update.
	(create_ada_exception_breakpoint): Update.
	(catch_ada_exception_command): Update.
	(catch_assert_command): Update.
	(trace_command): Update.

	* breakpoint.h (struct bp_location): New member GDBARCH.
	* breakpoint.c (get_sal_arch): New function.
	(set_raw_breakpoint): Set location architecture.
	(add_location_to_breakpoint): Likewise.
	(clone_momentary_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(update_watchpoint): Likewise.
	(bp_loc_is_permanent): Use location architecture instead of
	current_gdbarch.
	(adjust_breakpoint_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	Update callers of adjust_breakpoint_address to pass
	breakpoint location architecture:
	(set_raw_breakpoint): Update.
	(watch_command_1): Update.

        * tracepoint.c: (collect_symbol): Add GDBARCH parameter, use instead
	of current_gdbarch.
	(add_local_symbols): Add GDBARCH parameter.  Pass to collect_symbol.
	(encode_actions): Pass tracepoint architecture to add_local_symbols
	(encode_actions): Use tracepoint architecture instead of
	current_gdbarch.  Pass it to add_local_symbols and collect_symbol.

	* breakpoint.h (struct breakpoint_ops): Replace last_addr parameter
	of print_one callback with last_loc.
	* breakpoint.c (print_one_breakpoint_location): Replace last_addr
	parameter with last_loc.
	(print_one_breakpoint): Likewise.
	(do_captured_breakpoint_query): Update call.
	(breakpoint_1): Pass last_loc instead of last_addr to
	print_one_breakpoint.  Pass last location architecture instead of
	current_gdbarch to set_next_address.
	Update all implementations of the print_one callback:
	* breakpoint.c (print_one_catch_fork): Update.
	(print_one_catch_vfork): Update.
	(print_one_catch_exec): Update.
	(print_one_exception_catchpoint): Update.
	* ada-lang.c (print_one_exception): Update.
	(print_one_catch_exception): Update.
	(print_one_catch_exception_unhandled): Update.
	(print_one_catch_assert): Update.

	* breakpoint.c (print_one_breakpoint_location): Add PRINT_ADDRESS_BITS
	parameter.  Use it instead of gdbarch_addr_bit (current_gdbarch).
	(print_one_breakpoint): Add PRINT_ADDRESS_BITS parameter and pass it
	to print_one_breakpoint_location.
	(breakpoint_address_bits): New function.
	(do_captured_breakpoint_query): Compute number of address bits to print
	and pass it to print_one_breakpoint.
	(breakpoint_1): Likewise.  Use it instead of current_gdbarch.

	* breakpoint.h (create_thread_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_thread_event_breakpoint): Likewise.
	Update callers to create_thread_event_breakpoint:
	* aix-thread.c (pd_enable): Update.
	* linux-thread-db.c (enable_thread_event): Update.

	* breakpoint.h (create_solib_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_solib_event_breakpoint): Likewise.
	Update callers to create_solib_event_breakpoint:
	* solib-frv.c (enable_break, enable_break2): Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-som.c (som_solib_create_inferior_hook): Update.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Update.
	* solib-svr4.c (enable_break): Update.

	* breakpoint.h (insert_single_step_breakpoint): Add GDBARCH.
	* breakpoint.c (insert_single_step_breakpoint): Likewise.
	Update callers to insert_single_step_breakpoint:
	* alpha-tdep.c (alpha_software_single_step): Update.
	* arm-linux-tdep.c (arm_linux_software_single_step): Update.
	* arm-tdep.c (arm_software_single_step): Update.
	* cris-tdep.c (cris_software_single_step): Update.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Update.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Update.
	* sparc-tdep.c (sparc_software_single_step): Update.
	* spu-tdep.c (spu_software_single_step): Update.
	* mips-tdep.c (deal_with_atomic_sequence): Add GDBARCH parameter.
	Pass it to insert_single_step_breakpoint.
	(mips_software_single_step): Pass architecture to
	deal_with_atomic_sequence and insert_single_step_breakpoint.

	* breakpoint.h (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	* breakpoint.c (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	Update callers to deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint:
	* breakpoint.c (single_step_gdbarch): New static variable.
	(insert_single_step_breakpoint): Pass GDBARCH parameter to
	deprecated_insert_raw_breakpoint.  Store it in single_step_gdbarch.
	(remove_single_step_breakpoints): Pass architecture stored in
	single_step_gdbarch to deprecated_remove_raw_breakpoint.
	* rs6000-nat.c (exec_one_dummy_insn): Update.
	* solib-irix.c (enable_break, disable_break): Update.
	* procfs.c (procfs_mourn_inferior): Update.
	(remove_dbx_link_breakpoint): Update.

	* breakpoint.h (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	* breakpoint.c (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	Update callers to set_breakpoint, set_momentary_breakpoint and
	set_momentary_breakpoint_at_pc:
	* breakpoint.c (set_momentary_breakpoint_at_pc): Update.
	(until_break_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* infcmd.c (finish_backward, finish_forward): Update.
	* infrun.c (insert_step_resume_breakpoint_at_sal): Add GDBARCH
	parameter.  Pass it to set_momentary_breakpoint.
	(insert_longjmp_resume_breakpoint): Add GDBARCH parameter.
	Pass it to set_momentary_breakpoint_at_pc.
	(handle_inferior_event): Update.
	(insert_step_resume_breakpoint_at_frame): Update.
	(insert_step_resume_breakpoint_at_caller): Update..
	* mi/mi-cmd-break.c: Include "arch-utils.h".
	(mi_cmd_break_insert): Update.

	* target.h (struct target_ops): Add GDBARCH parameter to
	to_insert_breakpoint, to_remove_breakpoint, to_insert_hw_breakpoint,
	and to_remove_hw_breakpoint members.
	(target_insert_breakpoint, target_remove_breakpoint,
	target_insert_hw_breakpoint, target_remove_hw_breakpoint): Add GDBARCH
	parameter, pass to target routine.
	(memory_remove_breakpoint, memory_insert_breakpoint): Add GDBARCH
	parameter.
	* target.c (debug_to_insert_breakpoint, debug_to_remove_breakpoint,
	debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint): Add
	GDBARCH parameter, pass to target routine.
	(update_current_target): Update function signature.
	* breakpoint.c (insert_bp_location, remove_breakpoint,
	deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint):
	Pass architecture to target_ routines.
	Update all implementations of the target breakpoint routines to take
	GDBARCH parameter and use it instead of GDBARCH as appropriate:
	* corelow.c (ignore): Update.
	* exec.c (ignore): Update.
	* mem-break.c (memory_insert_breakpoint): Update.
	(memory_remove_breakpoint): Update.
	* monitor.c (monitor_insert_breakpoint): Update.
	(monitor_remove_breakpoint): Update.
	* record.c (record_insert_breakpoint): Update.
	(record_beneath_to_insert_breakpoint): Update.
	(record_remove_breakpoint): Update.
	(record_beneath_to_remove_breakpoint): Update.
	* remote.c (remote_insert_breakpoint): Update.
	(remote_remove_breakpoint): Update.
	(remote_insert_hw_breakpoint): Update.
	(remote_remove_hw_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_insert_breakpoint): Update.
	(m32r_remove_breakpoint): Update.
	* remote-mips.c (mips_insert_breakpoint): Update.
	(mips_remove_breakpoint): Update.
	* i386-nat.c (i386_insert_hw_breakpoint): Update.
	(i386_remove_hw_breakpoint): Update.
	* nto-procfs.c (procfs_insert_breakpoint):  Update.
	(procfs_remove_breakpoint): Update.
	(procfs_insert_hw_breakpoint): Update.
	(procfs_remove_hw_breakpoint): Update.

doc/ChangeLog:

	* gdbint.texi (Examples of Use of @@code{ui_out} functions):
	Update example code extrated from breakpoint.c.
@
text
@d468 1
d505 2
a506 1
	  if (extract_unsigned_integer ((gdb_byte *)phdr.p_type, 4) == type)
d514 4
a517 2
      sect_addr = extract_unsigned_integer ((gdb_byte *)phdr.p_vaddr, 4);
      sect_size = extract_unsigned_integer ((gdb_byte *)phdr.p_memsz, 4);
d531 2
a532 1
	  if (extract_unsigned_integer ((gdb_byte *)phdr.p_type, 4) == type)
d540 4
a543 2
      sect_addr = extract_unsigned_integer ((gdb_byte *)phdr.p_vaddr, 8);
      sect_size = extract_unsigned_integer ((gdb_byte *)phdr.p_memsz, 8);
d683 1
d704 4
a707 2
	dyn_tag = extract_unsigned_integer ((gdb_byte *) dynp->d_tag, 4);
	dyn_ptr = extract_unsigned_integer ((gdb_byte *) dynp->d_un.d_ptr, 4);
d712 4
a715 2
	dyn_tag = extract_unsigned_integer ((gdb_byte *) dynp->d_tag, 8);
	dyn_ptr = extract_unsigned_integer ((gdb_byte *) dynp->d_un.d_ptr, 8);
d885 1
d892 1
a892 1
				    lmo->r_version_size);
@


1.102
log
@	* target.h (struct target_ops): New member to_thread_architecture.
	(target_thread_architecture): New macro.
	* target.c (update_current_target): Inherit to_thread_architecture.
	(default_thread_architecture): New function.
	(debug_to_thread_architecture): New function.
	(setup_target_debug): Handle to_thread_architecture.

	* regcache.h (get_thread_arch_regcache): New.
	* regcache.c (struct regcache_list): New data type.
	(current_regcache): Hold regcache list instead of single regcache.
	(current_thread_ptid, current_thread_arch): New static variables.
	(get_thread_arch_regcache): New function.
	(get_thread_regcache): Use it.  Call target_thread_architecture.
	(regcache_thread_ptid_changed): Update to current_regcache changes.
	(registers_changed): Likewise.  Reset current_thread_arch and
	current_thread_ptid.

	* remote.c (remote_wait): Access target registers in target_gdbarch.
	* linux-nat.c (linux_nat_do_thread_registers): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* solib-svr4.c (enable_break): Likewise.
	(svr4_relocate_main_executable): Likewise.
@
text
@d1312 1
a1312 1
	  create_solib_event_breakpoint (sym_addr);
d1438 1
a1438 1
	  create_solib_event_breakpoint (load_addr + sym_addr);
d1460 2
a1461 1
	  create_solib_event_breakpoint (SYMBOL_VALUE_ADDRESS (msymbol));
d1471 2
a1472 1
	  create_solib_event_breakpoint (SYMBOL_VALUE_ADDRESS (msymbol));
@


1.101
log
@	* solib-svr4.c (IGNORE_FIRST_LINK_MAP_ENTRY): Avoid dereferencing
	NULL pointer.
	(scan_dyntag): Skip if input bfd isn't elf flavoured.
	(locate_base): Call elf_locate_base even without an exec_bfd.
@
text
@d1383 2
a1384 1
	  struct regcache *regcache = get_thread_regcache (inferior_ptid);
d1521 2
a1522 1
  struct regcache *regcache = get_thread_regcache (inferior_ptid);
@


1.100
log
@	* target.h (struct section_table): Rename to ...
	(struct target_section): ... this.
	* exec.c: Adjust all references.
	* exec.h: Adjust all references.
	* nto-tdep.c: Adjust all references.
	* nto-tdep.h: Adjust all references.
	* ppc-linux-tdep.c: Adjust all references.
	* rs6000-nat.c: Adjust all references.
	* s390-tdep.c: Adjust all references.
	* solib-darwin.c: Adjust all references.
	* solib-frv.c: Adjust all references.
	* solib-irix.c: Adjust all references.
	* solib-null.c: Adjust all references.
	* solib-osf.c: Adjust all references.
	* solib-pa64.c: Adjust all references.
	* solib-som.c: Adjust all references.
	* solib-sunos.c: Adjust all references.
	* solib-svr4.c: Adjust all references.
	* solib-target.c: Adjust all references.
	* solib.c: Adjust all references.
	* solist.h: Adjust all references.
	* symfile.c: Adjust all references.
	* symfile.h: Adjust all references.
	* target.c: Adjust all references.
@
text
@d269 1
a269 1
  if (bfd_get_section_by_name (exec_bfd, ".dynamic") == NULL)
d603 4
d609 1
a609 1
   return 0;
d832 1
a832 5
    {
      if (exec_bfd != NULL
	  && bfd_get_flavour (exec_bfd) == bfd_target_elf_flavour)
	info->debug_base = elf_locate_base ();
    }
@


1.99
log
@	* solib-svr4.c: Include observer.h.
	(debug_base, debug_loader_offset_p, debug_loader_offset)
	(debug_loader_name, main_lm_addr): Move these globals...
	(struct svr4_info): ... into this new structure.
	(svr4_info_p): New typedef.
	(svr4_info): New global.
	(get_svr4_info, remove_svr4_info, solib_svr4_inferior_exit): New
	functions.
	(locate_base, solib_svr4_r_map, solib_svr4_r_brk)
	(solib_svr4_r_ldsomap): Add svr4_info argument.  Adjust to
	per-inferior svr4.
	(open_symbol_file_object): Adjust to per-inferior svr4.
	(svr4_default_sos, svr4_current_sos, svr4_fetch_objfile_link_map):
	Ditto.
	(enable_break): Add svr4_info argument.  Adjust to per-inferior
	svr4.
	(enable_break, svr4_solib_create_inferior_hook, svr4_clear_solib):
	Adjust to per-inferior svr4.
	(_initialize_svr4_solib): Install the solib_svr4_inferior_exit
	observer.
@
text
@d1750 1
a1750 1
                                 struct section_table *sec)
@


1.98
log
@	* inferior.h (read_pc, write_pc): Remove.
	* regcache.c (read_pc, write_pc): Remove.

	* infrun.c (displaced_step_fixup): Use regcache_read_pc instead
	of read_pc.
	(handle_inferior_event): Use regcache_read_pc instead of read_pc
	when determining value of stop_pc.  Replace subsequent uses of
	read_pc by inspecting already-retrieved stop_pc value.
	(keep_going): Use regcache_read_pc instead of read_pc.

	* breakpoint.c (watchpoint_check): Use current frame architecture
	and PC instead of current_gdbarch and read_pc ().
	* tracepoint.c (set_traceframe_context): Replace PC argument
	with FRAME argument.
	(trace_start_command, finish_tfind_command): Update calls.
	(finish_tfind_command): Compare frame IDs to identify transitions
	between frames.
	(trace_find_pc_command): Use regcache_read_pc instead of read_pc.
	* rs6000-nat.c (exec_one_dummy_insn): Pass in regcache instead
	of gdbarch.  Use regcache_read_pc and regcache_write_pc instead
	of read_pc and write_pc.
	(store_register): Make regcache argument non-const.  Update call
	to exec_one_dummy_insn.

	* thread.c (switch_to_thread): Use regcache_read_pc instead of read_pc.
	* infcmd.c (post_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (enable_break, svr4_relocate_main_executable): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Likewise.
	* record.c (record_wait): Likewise.
	* procfs.c (procfs_wait): Likewise.
	* remote-mips.c (common_open, mips_wait): Likewise.
	* remote-m32r-sdi.c (m32r_resume): Likewise.

	* symfile.c (generic_load): Use regcache_write_pc instead of write_pc.
	* monitor.c (monitor_create_inferior, monitor_load): Likewise.
	* m32r-rom.c (m32r_load, m32r_upload_command): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior, m32r_load): Likewise.
	* remote-mips.c (mips_create_inferior, mips_load): Likewise.

	* solib-darwin.c: Include "regcache.h".
	* solib-pa64.c: Include "regcache.h".
	* solib-svr4.c: Include "regcache.h.".

	* symfile.c: Do not mention read_pc or write_pc in comments.
	* dink32-rom.c: Likewise.
	* m32r-rom.c: Likewise.
	* mips-tdep.c: Likewise.
@
text
@d37 1
d276 1
a276 1
static CORE_ADDR debug_base;	/* Base of dynamic linker structures */
d278 53
a330 2
/* Validity flag for debug_loader_offset.  */
static int debug_loader_offset_p;
d332 5
a336 2
/* Load address for the dynamic linker, inferred.  */
static CORE_ADDR debug_loader_offset;
d338 15
a352 2
/* Name of the dynamic linker, valid if debug_loader_offset_p.  */
static char *debug_loader_name;
d354 5
a358 2
/* Load map address for the main executable.  */
static CORE_ADDR main_lm_addr;
d789 1
a789 1
   CORE_ADDR locate_base (void)
d819 1
a819 1
locate_base (void)
d827 1
a827 1
  if (debug_base == 0 && svr4_have_link_map_offsets ())
d831 1
a831 1
	debug_base = elf_locate_base ();
d833 1
a833 1
  return (debug_base);
d844 1
a844 1
solib_svr4_r_map (void)
d849 2
a850 1
  return read_memory_typed_address (debug_base + lmo->r_map_offset, ptr_type);
d856 1
a856 1
solib_svr4_r_brk (void)
d861 2
a862 1
  return read_memory_typed_address (debug_base + lmo->r_brk_offset, ptr_type);
d869 1
a869 1
solib_svr4_r_ldsomap (void)
d877 3
a879 2
  version = read_memory_unsigned_integer (debug_base + lmo->r_version_offset,
					  lmo->r_version_size);
d883 1
a883 1
  return read_memory_typed_address (debug_base + lmo->r_ldsomap_offset,
d921 1
d928 2
a929 2
  debug_base = 0;
  if (locate_base () == 0)
d933 1
a933 1
  lm = solib_svr4_r_map ();
d972 3
d978 1
a978 1
  if (debug_loader_offset_p)
d986 1
a986 1
      new->lm_info->l_addr = debug_loader_offset;
d990 2
a991 1
      strncpy (new->so_name, debug_loader_name, SO_NAME_MAX_PATH_SIZE - 1);
d1028 8
d1038 2
a1039 2
  debug_base = 0;
  locate_base ();
d1043 1
a1043 1
  if (! debug_base)
d1048 1
a1048 1
  lm = solib_svr4_r_map ();
d1075 1
a1075 1
	  main_lm_addr = new->lm_info->lm_addr;
d1115 1
a1115 1
	lm = ldsomap = solib_svr4_r_ldsomap ();
d1132 1
d1135 1
a1135 1
  if (main_lm_addr == 0)
d1140 1
a1140 1
    return main_lm_addr;
d1248 1
a1248 1
enable_break (void)
d1255 1
d1271 2
a1272 2
  if (debug_base && solib_svr4_r_map () != 0)
    sym_addr = solib_svr4_r_brk ();
d1390 3
a1392 3
	  debug_loader_name = xstrdup (interp_name);
	  debug_loader_offset_p = 1;
	  debug_loader_offset = load_addr;
d1670 3
d1680 1
a1680 1
  if (!enable_break ())
d1712 1
a1712 6
  debug_base = 0;
  debug_loader_offset_p = 0;
  debug_loader_offset = 0;
  xfree (debug_loader_name);
  debug_loader_name = NULL;
  main_lm_addr = 0;
d1922 2
@


1.97
log
@2009-02-25  Hui Zhu  <teawater@@gmail.com>

	* cli/cli-script.c (define_command): Add _() to query.
	* gnu-nat.c (inf_validate_task_sc): Ditto.
	* infcmd.c (kill_if_already_running): Ditto.
	(jump_command): Ditto.
	(attach_command): Ditto.
	* inflow.c (kill_command): Ditto.
	* infrun.c (handle_command): Ditto.
	* maint.c (maintenance_dump_me): Ditto.
	* memattr.c (mem_delete_command): Ditto.
	* monitor.c (monitor_interrupt_query): Ditto.
	* nto-procfs.c (interrupt_query): Ditto.
	* printcmd.c (undisplay_command): Ditto.
	* remote-mips.c (mips_kill): Ditto.
	* remote.c (interrupt_query): Ditto.
	* solib-irix.c (irix_open_symbol_file_object): Ditto.
	* solib-osf.c (osf_open_symbol_file_object): Ditto.
	* solib-pa64.c (pa64_open_symbol_file_object): Ditto.
	* solib-som.c (som_open_symbol_file_object): Ditto.
	* solib-svr4.c (open_symbol_file_object): Ditto.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Ditto.
	* target.c (kill_or_be_killed): Ditto.
	* tracepoint.c (delete_trace_command): Ditto.
	* top.c (quit_confirm): Add _() to s that will be used
	in query.
@
text
@d35 1
d1293 5
a1297 2
	load_addr = (read_pc ()
		     - exec_entry_point (tmp_bfd, tmp_bfd_target));
d1431 2
a1432 1
  CORE_ADDR pc = read_pc ();
@


1.96
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d848 1
a848 1
    if (!query ("Attempt to reload symbols from process? "))
@


1.95
log
@        Updated copyright notices for most files.
@
text
@d152 1
a152 1
HAS_LM_DYNAMIC_FROM_LINK_MAP ()
@


1.94
log
@	Make the stop_soon global be per-inferior instead.

	* infcmd.c (attach_command_post_wait): Adjust.
	(attach_command): Likewise.

	* inferior.h (stop_soon): Delete.
	(struct inferior): Add stop_soon member.

	* infrun.c (stop_soon): Delete.
	(clear_proceed_status, start_remote)
	(fetch_inferior_event, handle_inferior_event): Adjust.
	(signal_stop_state): Don't check stop_soon here.  Check in callers
	instead.
	(save_inferior_status, restore_inferior_status): Adjust.

	* linux-nat.c (linux_nat_resume, linux_nat_wait): Always pass
	signals to common code if starting up the inferior.

	* inferior.h (struct inferior_info): Added stop_soon member.
	* inferior.c (add_inferior) Clear stop_soon.

	* mips-tdep.c (heuristic_proc_start): Adjust.
	* nto-procfs.c (procfs_create_inferior): Adjust.
	* solib-irix.c (irix_solib_create_inferior_hook): Adjust.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Adjust.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Adjust.

	* win32-nat.c (do_initial_win32_stuff): Adjust.

	* alpha-tdep.c (alpha_heuristic_proc_start): Adjust.
@
text
@d4 2
a5 1
   2001, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.93
log
@	* solib-svr4.c (LM_ADDR_FROM_LINK_MAP): Use builtin types of
	target_gdbarch instead of builtin_type_void_data_ptr.
	(LM_DYNAMIC_FROM_LINK_MAP, LM_NEXT, LM_NAME,
	IGNORE_FIRST_LINK_MAP_ENTRY, scan_dyntag, elf_locate_base,
	solib_svr4_r_map, solib_svr4_r_brk, solib_svr4_r_ldsomap,
	open_symbol_file_object): Likewise.
	* nto-tdep.c (LM_ADDR): Likewise.
@
text
@d1573 1
d1595 1
d1599 1
a1599 1
  stop_soon = STOP_QUIETLY;
d1607 1
a1607 1
  stop_soon = NO_STOP_QUIETLY;
@


1.92
log
@	Remove the global stop_signal in favour of a per-thread
	stop_signal.

	* inferior.h (stop_signal): Delete.
	* gdbthread.h (save_infrun_state, load_infrun_state): Remove
	stop_signal argument.
	* thread.c (load_infrun_state, save_infrun_state): Remove
	stop_signal argument.  Don't reference it.

	* infcmd.c (stop_signal): Delete.
	(program_info): Adjust.
	* infrun.c (resume): Clear stop_signal.
	(proceed): Adjust.  Pass the last stop_signal to the thread we're
	resuming.
	(context_switch): Don't context-switch stop_signal.
	(handle_inferior_event, keep_going): Adjust.
	(save_inferior_status, restore_inferior_status): Adjust.

	* fbsd-nat.c: Include "gdbthread.h".
	(find_signalled_thread, find_stop_signal): New.
	(fbsd_make_corefile_notes): Use it.
	* fork-child.c (startup_inferior): Adjust.

	* linux-nat.c (get_pending_status): Adjust.
	(linux_nat_do_thread_registers): Adjust.
	(find_signalled_thread, find_stop_signal): New.
	(linux_nat_do_thread_registers): Add stop_signal parameter.
	(struct linux_nat_corefile_thread_data): Add stop_signal member.
	(linux_nat_corefile_thread_callback): Pass stop_signal.
	(linux_nat_do_registers): Delete.
	(linux_nat_make_corefile_notes): Use find_stop_signal.  Assume
	there's always a thread.

	* procfs.c (find_signalled_thread, find_stop_signal): New.
	(find_stop_signal): New.
	(procfs_do_thread_registers): Add stop_signal parameter.
	(struct procfs_corefile_thread_data): Add stop_signal member.
	(procfs_corefile_thread_callback): Pass args->stop_signal.
	(procfs_make_note_section): Find the last stop_signal.

	* solib-irix.c: Include gdbthread.h.
	(irix_solib_create_inferior_hook): Adjust.
	* solib-osf.c: Include gdbthread.h.
	(osf_solib_create_inferior_hook): Adjust.
	* solib-sunos.c: Include gdbthread.h.
	(sunos_solib_create_inferior_hook): Adjust.
	* solib-svr4.c: Include gdbthread.h.
	(svr4_solib_create_inferior_hook): Adjust.

	* win32-nat.c (do_initial_win32_stuff): Adjust.
@
text
@d144 1
d147 1
a147 1
				builtin_type_void_data_ptr);
d162 1
d165 1
a165 1
				builtin_type_void_data_ptr);
d242 1
d245 1
a245 1
				builtin_type_void_data_ptr);
d252 1
d255 1
a255 1
				builtin_type_void_data_ptr);
d262 1
d270 1
a270 1
				builtin_type_void_data_ptr) == 0;
d575 1
d579 1
d582 1
a582 2
	       dyn_ptr = extract_typed_address (ptr_buf,
						builtin_type_void_data_ptr);
d682 1
d684 1
a684 1
      int pbuf_size = TYPE_LENGTH (builtin_type_void_data_ptr);
d690 1
a690 1
      return extract_typed_address (pbuf, builtin_type_void_data_ptr);
d774 1
d776 1
a776 2
  return read_memory_typed_address (debug_base + lmo->r_map_offset,
				    builtin_type_void_data_ptr);
d785 1
d787 1
a787 2
  return read_memory_typed_address (debug_base + lmo->r_brk_offset,
				    builtin_type_void_data_ptr);
d797 1
d808 1
a808 1
				    builtin_type_void_data_ptr);
d841 2
a842 1
  int l_name_size = TYPE_LENGTH (builtin_type_void_data_ptr);
d864 1
a864 1
  l_name = extract_typed_address (l_name_buf, builtin_type_void_data_ptr);
@


1.91
log
@	* solib-svr4.c (read_program_header): New function.
	(scan_dyntag_auxv): New function.
	(elf_locate_base): Use it if scan_dyntag fails.
	(find_program_interpreter): New function.
	(enable_break): Use it instead of .interp section.
@
text
@d34 1
d1564 2
d1585 2
d1589 1
a1589 1
  stop_signal = TARGET_SIGNAL_0;
d1592 1
a1592 1
      target_resume (pid_to_ptid (-1), 0, stop_signal);
d1595 1
a1595 1
  while (stop_signal != TARGET_SIGNAL_TRAP);
@


1.90
log
@ChangeLog:

	* remote.h (remote_filename_p, remote_bfd_open): Add prototypes.
	* remote.c (remote_bfd_iovec_open, remote_bfd_iovec_close,
	remote_bfd_iovec_pread, remote_bfd_iovec_stat, remote_filename_p,
	remote_bfd_open): New functions.
	(remote_hostio_send_command): Fail safely if remote connection
	is not set up.

	* solist.h (solib_open): Remove prototype.
	(solib_bfd_open): Add prototype.
	* solib.c: Include "remote.h".
	(solib_open): Remove, replace by ...
	(solib_bfd_open): ... this new function.  Handle remote BFDs.
	(solib_map_sections): Replace solib_open by solib_bfd_open.
	* solib-frv.c: Include "exceptions.h".
	(enable_break2): Replace solib_open by solib_bfd_open.
	* solib-svr4.c: Include "exceptions.h".
	(enable_break): Replace solib_open by solib_bfd_open.

	* symfile.c: Include "remote.h".
	(build_id_verify): Handle remote BFDs.
	(separate_debug_file_exists): Use BFD to access file.  Handle
	remote BFDs.
	(symfile_bfd_open): Handle remote BFDs.
	(reread_symbols): Handle remote BFDs.

	* NEWS: Mention "remote:" argument prefix to "set sysroot".

doc/ChangeLog:

	* gdb.texinfo (Commands to Specify Files): Document "remote:"
	argument prefix to "set sysroot".
@
text
@d377 131
d585 53
d672 2
a673 1
  if (scan_dyntag (DT_MIPS_RLD_MAP, exec_bfd, &dyn_ptr))
d686 2
a687 1
  if (scan_dyntag (DT_DEBUG, exec_bfd, &dyn_ptr))
d1153 1
d1216 1
a1216 1
  /* Find the .interp section; if not found, warn the user and drop
d1218 2
a1219 2
  interp_sect = bfd_get_section_by_name (exec_bfd, ".interp");
  if (interp_sect)
a1220 2
      unsigned int interp_sect_size;
      char *buf;
a1228 2
      /* Read the contents of the .interp section into a local buffer;
         the contents specify the dynamic linker this program uses.  */
a1229 4
      interp_sect_size = bfd_section_size (exec_bfd, interp_sect);
      buf = alloca (interp_sect_size);
      bfd_get_section_contents (exec_bfd, interp_sect,
				buf, 0, interp_sect_size);
d1242 1
a1242 1
	  tmp_bfd = solib_bfd_open (buf);
d1257 1
a1257 1
	  if (svr4_same_1 (buf, so->so_original_name))
d1286 1
a1286 1
	  debug_loader_name = xstrdup (buf);
d1334 1
d1341 1
@


1.89
log
@	* gdbarch.sh (target_gdbarch): New global variable.
	(deprecated_current_gdbarch_select_hack): Set it.
	* gdbarch.c, gdbarch.h: Regenerate.

	* arch-utils.c (gdbarch_update_p): Use target_gdbarch instead
	of current_gdbarch.
	* target-descriptions.c (target_find_description): Likewise.
	* arm-tdep.c (arm_update_current_architecture): Likewise.
	(show_fp_model, arm_show_abi, arm_show_fallback_mode,
	arm_show_force_mode): Likewise.
	* mips-tdep.c (show_mask_address, show_mipsfpu_command,
	show_mips_abi): Likewise.
	* mep-tdep.c (me_module_register_set, current_me_module): Likewise.

	* target.c (target_translate_tls_address): Use target_gdbarch
	instead of current_gdbarch.
	* remote.c (struct packet_reg): Likewise.
	(get_remote_arch_state, packet_reg_from_regnum,
	packet_reg_from_pnum, remote_check_symbols, remote_wait,
	remote_address_masked, remote_insert_breakpoint,
	remote_insert_hw_breakpoint, remote_read_description): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* remote-mips.c (mips_open, mips_common_breakpoint): Likewise.
	* cris-tdep.c (cris_can_use_hardware_watchpoint): Likewise.

	* solib.c (solib_open, solib_map_sections, solib_read_symbols,
	solib_add, info_sharedlibrary_command, solib_address,
	solib_create_inferior_hook, in_solib_dynsym_resolve_code,
	solib_global_lookup): Likewise.
	* solib-frv.c (enable_break2, frv_relocate_main_executable): Likewise.
	* solib-irix.c (irix_current_sos, irix_open_symbol_file_object):
	Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (exec_entry_point, enable_break, svr4_free_so,
	set_solib_svr4_fetch_link_map_offsets, svr4_fetch_link_map_offsets):
	Likewise.
	* nto-tdep.c (nto_find_and_open_solib, nto_init_solib_absolute_prefix,
	nto_truncate_ptr): Likewise.
	* mips-linux-tdep.c (mips_linux_in_dynsym_stub): Likewise.
@
text
@d45 1
d1042 1
a1042 2
      int tmp_fd = -1;
      char *tmp_pathname = NULL;
d1061 4
a1064 4
      tmp_fd = solib_open (buf, &tmp_pathname);
      if (tmp_fd >= 0)
	tmp_bfd = bfd_fopen (tmp_pathname, gnutarget, FOPEN_RB, tmp_fd);

a1067 8
      /* Make sure the dynamic linker's really a useful object.  */
      if (!bfd_check_format (tmp_bfd, bfd_object))
	{
	  warning (_("Unable to grok dynamic linker %s as an object file"), buf);
	  bfd_close (tmp_bfd);
	  goto bkpt_at_symbol;
	}

a1160 1
      xfree (tmp_pathname);
@


1.88
log
@	* solib-svr4.c (BKPT_AT_SYMBOL): Remove, always defined.
	(bkpt_names): Remove SOLIB_BKPT_NAME, never defined.
	(enable_break): Remove test of BKPT_AT_SYMBOL.
@
text
@d912 1
a912 1
  return gdbarch_convert_from_func_ptr_addr (current_gdbarch,
d990 1
a990 1
	(current_gdbarch, gdbarch_convert_from_func_ptr_addr (current_gdbarch,
d1152 1
a1152 1
	sym_addr = gdbarch_convert_from_func_ptr_addr (current_gdbarch,
d1458 1
a1458 1
  if (gdbarch_ptr_bit (current_gdbarch) == sizeof (CORE_ADDR) * 8)
d1463 1
a1463 1
    return addr & (((CORE_ADDR) 1 << gdbarch_ptr_bit (current_gdbarch)) - 1);
d1521 1
a1521 1
  struct solib_svr4_ops *ops = gdbarch_data (current_gdbarch, solib_svr4_data);
d1532 1
a1532 1
  struct solib_svr4_ops *ops = gdbarch_data (current_gdbarch, solib_svr4_data);
@


1.87
log
@	* solib-svr4.c (struct lm_info): Add lm_addr.
	(main_lm_addr): New.
	(svr4_default_sos): Set lm_addr.
	(svr4_current_sos): Set lm_addr and main_lm_addr.
	(svr4_fetch_objfile_link_map): Rewrite.
	(svr4_clear_solib): Clear main_lm_addr.
@
text
@a87 3
#define BKPT_AT_SYMBOL 1

#if defined (BKPT_AT_SYMBOL)
a89 3
#ifdef SOLIB_BKPT_NAME
  SOLIB_BKPT_NAME,		/* Prefer configured name if it exists. */
#endif
a94 1
#endif
a962 2
#ifdef BKPT_AT_SYMBOL

a1196 2
#endif /* BKPT_AT_SYMBOL */

@


1.86
log
@	* language.h (struct language_defn): Remove SYMTAB parameter from
	la_lookup_symbol_nonlocal callback function pointer.

	* ada-lang.h (ada_lookup_encoded_symbol): Remove SYMTAB parameter.
	(ada_lookup_encoded_symbol): Likewise.
	* ada-lang.c (ada_lookup_encoded_symbol): Remove SYMTAB parameter.
	Always call fixup_symbol_section.
	(ada_lookup_symbol): Remove SYMTAB parameter.
	(ada_lookup_symbol_nonlocal): Likewise.
	* ada-exp.y (write_object_renaming): Update.
	(find_primitive_type): Likewise.

	* cp-support.h (cp_lookup_symbol_nonlocal): Remove SYMTAB parameter.
	(cp_lookup_symbol_namespace): Likewise.
	* cp-namespace.c (lookup_namespace_scope): Remove SYMTAB parameter.
	(lookup_symbol_file): Likewise.
	(lookup_possible_namespace_symbol): Likewise.
	(cp_lookup_symbol_nonlocal): Likewise.
	(cp_lookup_symbol_namespace): Likewise.
	(cp_lookup_nested_type): Update.

	* scm-valprint.c (scm_inferior_print): Update.
	* valops.c (value_maybe_namespace_elt): Update.

	* solist.h (struct target_so_ops): Remove SYMTAB parameter from
	lookup_lib_global_symbol callback function pointer.
	(solib_global_lookup): Remove SYMTAB parameter.
	* solib.c (solib_global_lookup): Remove SYMTAB parameter.
	* solib-svr4.c (elf_lookup_lib_symbol): Likewise.

	* symtab.h (basic_lookup_symbol_nonlocal): Remove SYMTAB parameter.
	(lookup_symbol_static): Likewise.
	(lookup_symbol_global): Likewise.
	(lookup_symbol_aux_block): Likewise.
	(lookup_global_symbol_from_objfile): Likewise.
	* symtab.c (lookup_symbol_aux): Remove SYMTAB parameter.
	(lookup_symbol_aux_local): Likewise.
	(lookup_symbol_aux_block): Likewise.
	(lookup_symbol_aux_symtabs): Likewise.
	(lookup_symbol_aux_psymtabs): Likewise.
	(lookup_global_symbol_from_objfile): Likewise.
	(basic_lookup_symbol_nonlocal): Likewise.
	(lookup_symbol_static): Likewise.
	(lookup_symbol_global): Likewise.

	(lookup_symbol_in_language): Do not pass SYMTAB to lookup_symbol_aux.
@
text
@d64 3
d284 3
d717 1
d781 1
d795 4
a798 1
	free_so (new);
d847 1
a847 5
/* Get the address of the link_map for a given OBJFILE.  Loop through
   the link maps, and return the address of the one corresponding to
   the given objfile.  Note that this function takes into account that
   objfile can be the main executable, not just a shared library.  The
   main executable has always an empty name field in the linkmap.  */
d852 1
a852 1
  CORE_ADDR lm;
d854 13
a866 2
  if (locate_base () == 0)
    return 0;   /* failed somehow... */
d868 1
a868 56
  /* Position ourselves on the first link map.  */
  lm = solib_svr4_r_map ();  
  while (lm)
    {
      /* Get info on the layout of the r_debug and link_map structures. */
      struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();
      int errcode;
      char *buffer;
      struct lm_info objfile_lm_info;
      struct cleanup *old_chain;
      CORE_ADDR name_address;
      int l_name_size = TYPE_LENGTH (builtin_type_void_data_ptr);
      gdb_byte *l_name_buf = xmalloc (l_name_size);
      old_chain = make_cleanup (xfree, l_name_buf);

      /* Set up the buffer to contain the portion of the link_map
         structure that gdb cares about.  Note that this is not the
         whole link_map structure.  */
      objfile_lm_info.lm = xzalloc (lmo->link_map_size);
      make_cleanup (xfree, objfile_lm_info.lm);

      /* Read the link map into our internal structure.  */
      read_memory (lm, objfile_lm_info.lm, lmo->link_map_size);

      /* Read address of name from target memory to GDB.  */
      read_memory (lm + lmo->l_name_offset, l_name_buf, l_name_size);

      /* Extract this object's name.  */
      name_address = extract_typed_address (l_name_buf,
					    builtin_type_void_data_ptr);
      target_read_string (name_address, &buffer,
      			  SO_NAME_MAX_PATH_SIZE - 1, &errcode);
      make_cleanup (xfree, buffer);
      if (errcode != 0)
	warning (_("Can't read pathname for load map: %s."),
		 safe_strerror (errcode));
      else
  	{
	  /* Is this the linkmap for the file we want?  */
	  /* If the file is not a shared library and has no name,
	     we are sure it is the main executable, so we return that.  */

	  if (buffer 
	      && ((strcmp (buffer, objfile->name) == 0)
		  || (!(objfile->flags & OBJF_SHARED) 
		      && (strcmp (buffer, "") == 0))))
  	    {
    	      do_cleanups (old_chain);
    	      return lm;
      	    }
  	}
      /* Not the file we wanted, continue checking.  */
      lm = extract_typed_address (objfile_lm_info.lm + lmo->l_next_offset,
				  builtin_type_void_data_ptr);
      do_cleanups (old_chain);
    }
d1442 1
@


1.85
log
@        * solib-svr4.c (svr4_same_1): New function, originally extracted
        from svr4_same and expanded to handle the sparc64 case.
        (svr4_same): Move up and reimplement using svr4_same_1.
        (enable_break): Use svr4_same_1 to do shared library name comparisons.
@
text
@d1661 1
a1661 1
		       const domain_enum domain, struct symtab **symtab)
d1668 1
a1668 1
		(objfile, name, linkage_name, domain, symtab);
@


1.84
log
@	* solib-svr4.c (enable_break): Convert r_brk to a code address.
@
text
@d106 34
d1132 1
a1132 1
	  if (strcmp (buf, so->so_original_name) == 0)
a1670 19
static int
svr4_same (struct so_list *gdb, struct so_list *inferior)
{
  if (! strcmp (gdb->so_original_name, inferior->so_original_name))
    return 1;

  /* On Solaris, when starting inferior we think that dynamic linker is
     /usr/lib/ld.so.1, but later on, the table of loaded shared libraries 
     contains /lib/ld.so.1.  Sometimes one file is a link to another, but 
     sometimes they have identical content, but are not linked to each
     other.  We don't restrict this check for Solaris, but the chances
     of running into this situation elsewhere are very low.  */
  if (strcmp (gdb->so_original_name, "/usr/lib/ld.so.1") == 0
      && strcmp (inferior->so_original_name, "/lib/ld.so.1") == 0)
    return 1;

  return 0;
}

@


1.83
log
@	* mipsnbsd-tdep.c (mipsnbsd_ilp32_fetch_link_map_offsets): Set
	r_brk_offset.
	(mipsnbsd_lp64_fetch_link_map_offsets): Likewise.
	* solib-svr4.c (solib_svr4_r_brk): New.
	(open_symbol_file_object, svr4_current_sos): Always check the
	debug base.
	(svr4_fetch_objfile_link_map): Do not set debug_base.
	(enable_break): Use r_brk if it is set.
	(svr4_ilp32_fetch_link_map_offsets): Set r_brk_offset.
	(svr4_lp64_fetch_link_map_offsets): Likewise.
	* solib-svr4.h (struct link_map_offsets): Add r_brk_offset.
@
text
@d1001 5
@


1.82
log
@        * infrun.c (wait_for_inferior): Add treat_exec_as_sigtrap parameter
        and use it.
        (proceed, start_remote): Update call to wait_for_inferior.
        * inferior.h (wait_for_inferior): Update declaration.
        * fork-child.c, infcmd.c, solib-irix.c, solib-osf.c, solib-sunos.c,
        solib-svr4.c, win32-nat.c: Update calls to wait_for_inferior.
        * inf-ttrace.c (inf_ttrace_wait): Report TTEVT_EXEC events as
        TARGET_WAITKIND_EXECD instead of TARGET_WAITKIND_STOPPED.
@
text
@d551 11
d620 3
a622 1
  if ((debug_base = locate_base ()) == 0)
d717 6
a722 2
  /* Make sure we've looked up the inferior's dynamic linker's base
     structure.  */
d724 1
a724 8
    {
      debug_base = locate_base ();

      /* If we can't find the dynamic linker's base structure, this
	 must not be a dynamically linked executable.  Hmm.  */
      if (! debug_base)
	return svr4_default_sos ();
    }
d813 1
a813 1
  if ((debug_base = locate_base ()) == 0)
d978 1
d987 48
a1049 1
      CORE_ADDR sym_addr = 0;
d1053 1
a1089 1
      solib_add (NULL, 0, &current_target, auto_solib_add);
d1565 1
d1596 1
@


1.81
log
@	Ignore change in name of dynamic linker during
	execution, on Solaris.  This also unbreaks pending breakpoints.

	* solist.h (struct target_so_ops): New field same.
        * solib-svr4.c (svr4_same): New.
        (_initialize_svr4_solib): Register svr4_same.
        * solib.c (update_solib_list): Use ops->same, if available.
@
text
@d1367 1
a1367 1
      wait_for_inferior ();
@


1.80
log
@	Updated copyright notices for most files.
@
text
@d1572 19
d1607 1
@


1.79
log
@	* solib-svr4.c (set_solib_svr4_fetch_link_map_offsets): Call
	set_solib_ops to install SVR4 operations.
	(_initialize_svr4_solib): Do not set current_target_so_ops.

	* config/i386/i386gnu.mh (NATDEPFILES): Move solib.o, solib-svr4.o ...
	* config/i386/i386gnu.mt (TDEPFILES): ... to here.
@
text
@d4 1
a4 1
   2001, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.78
log
@	* solib-svr4.c (legacy_svr4_fetch_link_map_offsets_hook): Remove.
	(solib_svr4_init): Initialize fetch_link_map_offsets to NULL.
	* solib-svr4.h (legacy_svr4_fetch_link_map_offsets_hook): Remove.
	* solib-legacy.c: Remove file.

	* config/alpha/alpha-linux.mt (TDEPFILES): Remove solib-legacy.o.
	* config/arm/linux.mt (TDEPFILES): Likewise.
	* config/i386/i386gnu.mh (NATDEPFILES): Likewise.
	* config/ia64/linux.mt (TDEPFILES): Likewise.
	* config/m32r/linux.mt (TDEPFILES): Likewise.
	* config/powerpc/linux.mt (TDEPFILES): Likewise.
	* config/s390/s390.mt (TDEPFILES): Likewise.

	* alpha-linux-tdep.c (alpha_linux_init_abi): Call
	set_solib_svr4_fetch_link_map_offsets.
	* i386gnu-tdep.c (i386gnu_init_abi): Likewise.
	* ia64-linux-tdep.c (ia64_linux_init_abi): Likewise.

	* i386gnu-tdep.c: Include "solib-svr4.h".
	* Makefile.in: Update dependencies.
@
text
@d1452 1
a1452 1
   GDBARCH to FLMO.  */
d1461 2
a1587 3

  /* FIXME: Don't do this here.  *_gdbarch_init() should set so_ops. */
  current_target_so_ops = &svr4_so_ops;
@


1.77
log
@	* solib-svr4.c (enable_break): Add the dynamic linker also if
	auxv succeeds.

	* gdb.server/server-run.exp: Test for dynamic linker symbols.
@
text
@a48 4
/* This hook is set to a function that provides native link map
   offsets if the code in solib-legacy.c is linked in.  */
struct link_map_offsets *(*legacy_svr4_fetch_link_map_offsets_hook) (void);

d1447 1
a1447 1
  ops->fetch_link_map_offsets = legacy_svr4_fetch_link_map_offsets_hook;
@


1.76
log
@        * solib-svr4.c: Add include of "auxv.h".
        (enable_break): Use the AT_BASE auxiliary entry if available.
        * Makefile.in (solib-svr4.o): Update dependencies.
@
text
@d989 1
d1042 1
d1063 4
a1067 2
	  load_addr = (read_pc ()
		       - exec_entry_point (tmp_bfd, tmp_bfd_target));
@


1.75
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d44 1
a1011 5
      /* TODO drow/2006-09-12: This is somewhat fragile, because it
	 relies on read_pc.  On both Solaris and GNU/Linux we can use
	 the AT_BASE auxilliary entry, which GDB now knows how to
	 access, to find the base address.  */

d1047 6
d1055 5
a1059 1
	 dynamic linker) and subtracting the offset of the entry point.  */
@


1.75.2.1
log
@	* solib-svr4.c (enable_break): Add the dynamic linker also if
	auxv succeeds.

	* gdb.server/server-run.exp: Test for dynamic linker symbols.
@
text
@a987 1
      int loader_found_in_list = 0;
a1044 1
	      loader_found_in_list = 1;
a1054 4
	load_addr = (read_pc ()
		     - exec_entry_point (tmp_bfd, tmp_bfd_target));

      if (!loader_found_in_list)
d1056 2
@


1.74
log
@	* solib-svr4.c (scan_dyntag): Only read target memory when necessary.
	Fix formatting.
	(elf_locate_base): Look for DT_MIPS_RLD_MAP first.  Expand comments.
	(elf_lookup_lib_symbol): Fix formatting.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.73
log
@2007-08-10  Michael Snyder  <msnyder@@access-company.com>

	* solib-svr4.c (enable_break): Don't free tmp_pathname until
	after closing bfd.
@
text
@d357 1
a357 1
  gdb_byte *bufend, *buf;
d374 2
a375 1
  /* Read in .dynamic section, silently ignore errors.  */
d377 4
a380 8
  buf = alloca (sect_size);
  if (target_read_memory (dyn_addr, buf, sect_size))
    {
      /* If target_read_memory fails, try reading the BFD file.  */
      if (!bfd_get_section_contents (abfd, sect,
				     buf, 0, sect_size))
	return 0;
    }
d395 1
a395 1
      else
d405 2
d408 11
a418 2
	   *ptr = dyn_ptr;
         return 1;
d456 3
a458 5
  /* Find DT_DEBUG.  */
  if (scan_dyntag (DT_DEBUG, exec_bfd, &dyn_ptr))
    return dyn_ptr;

  /* Find DT_MIPS_RLD_MAP.  */
d471 4
d1562 1
a1562 1
  return  lookup_global_symbol_from_objfile
@


1.72
log
@2007-08-08  Michael Snyder  <msnyder@@access-company.com>

	* solib-svr4.c (open_symbol_file_object): Memory leak.
	(svr4_current_sos): Ditto.
	(enable_break): Ditto.
@
text
@a1010 1
      xfree (tmp_pathname);
d1104 1
@


1.71
log
@2007-07-23  Michael Snyder  <msnyder@@access-company.com>

	* solib-svr4.c (svr4_fetch_objfile_link_map): Null pointer check of
	'buffer' must cover both branches that call strcmp (Coverity).
@
text
@d626 1
a634 1
  make_cleanup (xfree, filename);
a753 1
	      xfree (buffer);
d756 1
d1011 1
@


1.70
log
@	* solib-svr4.c (LM_ADDR_CHECK): Relax prelink recognition heuristic.
@
text
@d842 5
a846 2
	  if ((buffer && strcmp (buffer, objfile->name) == 0)
              || (!(objfile->flags & OBJF_SHARED) && (strcmp (buffer, "") == 0)))
@


1.69
log
@2007-07-03  Paul Gilliam  <pgilliam@@us.ibm.com>
	    Thiago Bauermann  <bauerman@@br.ibm.com>
	    Joseph S. Myers  <joseph@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	gdb/
	* remote.c (remote_check_symbols): Use
	gdbarch_convert_from_func_ptr_addr.
	* infcall.c (find_function_addr): Handle function descriptors
	without debugging information.
	* ppc-linux-tdep.c (ppc_linux_convert_from_func_ptr_addr): Renamed
	from ppc64_linux_convert_from_func_ptr_addr.  Handle -msecure-plt.
	(ppc_linux_init_abi): Always set convert_from_func_ptr_addr.
	* solib-svr4.c (solib_break_names): Remove "._dl_debug_state".
	(bfd_lookup_symbol): Do not take a SECT_FLAGS argument.  Always
	allow SEC_CODE and SEC_DATA.
	(enable_break): Update calls.  Pass current_target to solib_add.
	Use gdbarch_convert_from_func_ptr_addr.

	gdb/gdbserver/
	* remote-utils.c (look_up_one_symbol): Handle 'm' packets.
@
text
@d187 1
a187 1
	  if ((l_addr & align) == 0 && ((dynaddr - l_dynaddr) & align) == 0)
@


1.68
log
@2007-07-03  Markus Deuling  <deuling@@de.ibm.com>

	* cp-namespace.c (lookup_symbol_file): Add block to
	lookup_symbol_global call.
	* Makefile.in (solist_h): Add dependency on symtab header.
	(symtab.o): Add dependency on solist header.
	* solib.c (solib_global_lookup): New function.
	* solib-svr4.c (scan_dyntag): Likewise.
	(elf_locate_base): Call helper routine scan_dyntag.
	(elf_lookup_lib_symbol): New function.
	(_initialize_svr4_solib): Add elf_lookup_lib_symbol to svr4_so_ops.
	* solist.h (symtab.h): New include.
	(struct target_so_ops): New member lookup_lib_global_symbol.
	(solib_global_lookup): New prototype.
	* symtab.c: New include solist.h.
	(lookup_objfile_from_block): New function.
	(lookup_global_symbol_from_objfile): New function.
	(basic_lookup_symbol_nonlocal): Add block to lookup_symbol_global call.
	(lookup_symbol_global): Call library-specific lookup procedure.
	* symtab.h (lookup_global_symbol_from_objfile): New prototype.

	* NEWS: Document framework.

testsuite/

	* gdb.base/solib-symbol.exp: New file (testcase multiple symbol lookup).
	* gdb.base/solib-symbol-lib.c: Likewise.
	* gdb.base/solib-symbol-main.c: Likewise.
@
text
@a86 10
  /* On the 64-bit PowerPC, the linker symbol with the same name as
     the C function points to a function descriptor, not to the entry
     point.  The linker symbol whose name is the C function name
     prefixed with a '.' points to the function's entry point.  So
     when we look through this table, we ignore symbols that point
     into the data section (thus skipping the descriptor's symbol),
     and eventually try this one, giving us the real entry point
     address.  */
  "._dl_debug_state",

d256 1
a256 1
static CORE_ADDR bfd_lookup_symbol (bfd *, char *, flagword);
d266 1
a266 1
   CORE_ADDR bfd_lookup_symbol (bfd *abfd, char *symname, flagword sect_flags)
d273 1
a273 1
   interface structures in the shared library.
d275 3
a277 2
   If SECT_FLAGS is non-zero, only match symbols in sections whose
   flags include all those in SECT_FLAGS.
d284 1
a284 1
bfd_lookup_symbol (bfd *abfd, char *symname, flagword sect_flags)
d306 1
a306 1
              && (sym->section->flags & sect_flags) == sect_flags)
d308 1
a308 1
	      /* Bfd symbols are section relative. */
d335 1
a335 1
              && (sym->section->flags & sect_flags) == sect_flags)
d337 1
a337 1
	      /* Bfd symbols are section relative. */
d1027 1
a1027 1
      solib_add (NULL, 0, NULL, auto_solib_add);
d1050 1
a1050 1
	  solib_add (NULL, 0, NULL, auto_solib_add);
d1075 1
a1075 10
          /* On ABI's that use function descriptors, there are usually
             two linker symbols associated with each C function: one
             pointing at the actual entry point of the machine code,
             and one pointing at the function's descriptor.  The
             latter symbol has the same name as the C function.

             What we're looking for here is the machine code entry
             point, so we are only interested in symbols in code
             sections.  */
	  sym_addr = bfd_lookup_symbol (tmp_bfd, *bkpt_namep, SEC_CODE);
d1080 8
@


1.67
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_PTR_BIT): Replace with gdbarch_ptr_bit.
	* solib-svr4.c (svr4_truncate_ptr): Likewise.
	* solib-pa64.c (read_dynamic_info): Likewise.
	* solib-legacy.c (legacy_svr4_fetch_link_map_offsets): Likewise.
	* solib.c (info_sharedlibrary_command): Likewise.
	* s390-nat.c (SUBOFF): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	* procfs.c (info_proc_mappings): Likewise.
	* printcmd.c (decode_format): Likewise.
	* nto-tdep.c (nto_truncate_ptr): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips64_linux_get_longjmp_target): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* jv-valprint.c (java_value_print): Likewise.
	* jv-lang.c (get_java_object_header_size): Likewise.
	* hppa-tdep.c (skip_prologue_hard_way, hppa_frame_cache): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code)
	(hppa_hpux_unwind_adjust_stub): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
	* gdbtypes.c (make_pointer_type, make_reference_type)
	(smash_to_memberptr_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d357 70
d454 2
a455 6
  struct bfd_section *dyninfo_sect;
  int dyninfo_sect_size;
  CORE_ADDR dyninfo_addr;
  gdb_byte *buf;
  gdb_byte *bufend;
  int arch_size;
d457 6
a462 3
  /* Find the start address of the .dynamic section.  */
  dyninfo_sect = bfd_get_section_by_name (exec_bfd, ".dynamic");
  if (dyninfo_sect == NULL)
d464 6
a469 8
      /* This may be a static executable.  Look for the symbol
	 conventionally named _r_debug, as a last resort.  */
      struct minimal_symbol *msymbol;

      msymbol = lookup_minimal_symbol ("_r_debug", NULL, symfile_objfile);
      if (msymbol != NULL)
	return SYMBOL_VALUE_ADDRESS (msymbol);
      else
d471 1
d474 5
a478 86
  dyninfo_addr = bfd_section_vma (exec_bfd, dyninfo_sect);

  /* Read in .dynamic section, silently ignore errors.  */
  dyninfo_sect_size = bfd_section_size (exec_bfd, dyninfo_sect);
  buf = alloca (dyninfo_sect_size);
  if (target_read_memory (dyninfo_addr, buf, dyninfo_sect_size))
    return 0;

  /* Find the DT_DEBUG entry in the the .dynamic section.
     For mips elf we look for DT_MIPS_RLD_MAP, mips elf apparently has
     no DT_DEBUG entries.  */

  arch_size = bfd_get_arch_size (exec_bfd);
  if (arch_size == -1)	/* failure */
    return 0;

  if (arch_size == 32)
    { /* 32-bit elf */
      for (bufend = buf + dyninfo_sect_size;
	   buf < bufend;
	   buf += sizeof (Elf32_External_Dyn))
	{
	  Elf32_External_Dyn *x_dynp = (Elf32_External_Dyn *) buf;
	  long dyn_tag;
	  CORE_ADDR dyn_ptr;

	  dyn_tag = bfd_h_get_32 (exec_bfd, (bfd_byte *) x_dynp->d_tag);
	  if (dyn_tag == DT_NULL)
	    break;
	  else if (dyn_tag == DT_DEBUG)
	    {
	      dyn_ptr = bfd_h_get_32 (exec_bfd, 
				      (bfd_byte *) x_dynp->d_un.d_ptr);
	      return dyn_ptr;
	    }
	  else if (dyn_tag == DT_MIPS_RLD_MAP)
	    {
	      gdb_byte *pbuf;
	      int pbuf_size = TYPE_LENGTH (builtin_type_void_data_ptr);

	      pbuf = alloca (pbuf_size);
	      /* DT_MIPS_RLD_MAP contains a pointer to the address
		 of the dynamic link structure.  */
	      dyn_ptr = bfd_h_get_32 (exec_bfd, 
				      (bfd_byte *) x_dynp->d_un.d_ptr);
	      if (target_read_memory (dyn_ptr, pbuf, pbuf_size))
		return 0;
	      return extract_typed_address (pbuf, builtin_type_void_data_ptr);
	    }
	}
    }
  else /* 64-bit elf */
    {
      for (bufend = buf + dyninfo_sect_size;
	   buf < bufend;
	   buf += sizeof (Elf64_External_Dyn))
	{
	  Elf64_External_Dyn *x_dynp = (Elf64_External_Dyn *) buf;
	  long dyn_tag;
	  CORE_ADDR dyn_ptr;

	  dyn_tag = bfd_h_get_64 (exec_bfd, (bfd_byte *) x_dynp->d_tag);
	  if (dyn_tag == DT_NULL)
	    break;
	  else if (dyn_tag == DT_DEBUG)
	    {
	      dyn_ptr = bfd_h_get_64 (exec_bfd, 
				      (bfd_byte *) x_dynp->d_un.d_ptr);
	      return dyn_ptr;
	    }
	  else if (dyn_tag == DT_MIPS_RLD_MAP)
	    {
	      gdb_byte *pbuf;
	      int pbuf_size = TYPE_LENGTH (builtin_type_void_data_ptr);

	      pbuf = alloca (pbuf_size);
	      /* DT_MIPS_RLD_MAP contains a pointer to the address
		 of the dynamic link structure.  */
	      dyn_ptr = bfd_h_get_64 (exec_bfd, 
				      (bfd_byte *) x_dynp->d_un.d_ptr);
	      if (target_read_memory (dyn_ptr, pbuf, pbuf_size))
		return 0;
	      return extract_typed_address (pbuf, builtin_type_void_data_ptr);
	    }
	}
    }
d1544 18
d1577 1
@


1.66
log
@        * solib-svr4.c (svr4_solib_create_inferior_hook): Remove warning.
@
text
@d1408 1
a1408 1
   TARGET_PTR_BIT, as we do below, is no good.)  This should probably
d1413 1
a1413 1
  if (TARGET_PTR_BIT == sizeof (CORE_ADDR) * 8)
d1418 1
a1418 1
    return addr & (((CORE_ADDR) 1 << TARGET_PTR_BIT) - 1);
@


1.65
log
@	* config/mips/linux.mt (DEPRECATED_TM_FILE): Delete.
	* config/mips/tm-linux.h: Delete.
	* mips-linux-tdep.c (mips_svr4_so_ops): New.
	(mips_linux_in_dynsym_resolve_code): Make static.  Use
	svr4_in_dynsym_resolve_code.
	(mips_linux_init_abi): Initialize mips_svr4_so_ops.  Call
	set_solib_ops.
	* solib-svr4.c (svr4_in_dynsym_resolve_code, svr4_so_ops): Make
	global.
	* solib-svr4.h (svr4_so_ops, svr4_in_dynsym_resolve_code): Declare.
	* Makefile.in (mips-linux-tdep.o): Update.
	* solib.c (set_solib_ops): New.
	(current_target_so_ops): Update comment.
	* solib.h (set_solib_ops): New prototype.
@
text
@d1351 1
a1351 5
    {
      warning (_("no shared library support for this OS / ABI"));
      return;

    }
@


1.64
log
@	* solib-svr4.c (IGNORE_FIRST_LINK_MAP_ENTRY): Do not ignore the
	first entry for static executables.
	(breakpoint_addr): Delete unused variable.
	(elf_locate_base): Search for _r_debug in static executables.
	(enable_break): Do not set breakpoint_addr.  Scan solib_break_names
	also.
@
text
@d904 1
a904 1
static int
d1559 1
a1559 1
static struct target_so_ops svr4_so_ops;
@


1.63
log
@	* solib-svr4.c (enable_break): Simplify return value.
	(svr4_solib_create_inferior_hook): Do not warn if enable_break fails.
@
text
@d242 5
a251 1
static CORE_ADDR breakpoint_addr;	/* Address where end bkpt is set */
d394 12
a405 1
    return 0;
d1129 12
a1140 2
  /* Scan through the list of symbols, trying to look up the symbol and
     set a breakpoint there.  Terminate loop when we/if we succeed. */
a1141 1
  breakpoint_addr = 0;
@


1.62
log
@	* solib-svr4.h (struct link_map_offsets): Remove l_addr_size,
	l_ld_size, l_next_size, l_prev_size, l_name_size.

	* solib-svr4.c (LM_ADDR_FROM_LINK_MAP): Use extract_typed_address
	to extract addresses from link map.
	(LM_DYNAMIC_FROM_LINK_MAP): Likewise.
	(LM_NEXT): Likewise.
	(LM_NAME): Likewise.
	(IGNORE_FIRST_LINK_MAP_ENTRY): Likewise.
	(elf_locate_base): Likewise.
	(open_symbol_file_object): Likewise.
	(svr4_fetch_objfile_link_map): Likewise.
	(SOLIB_EXTRACT_ADDRESS): Remove unused macro.
	(HAS_LM_DYNAMIC_FROM_LINK_MAP): Test l_ld_offset instead of
	l_ld_size.
        (svr4_ilp32_fetch_link_map_offsets): Don't set removed members.
	(svr4_lp64_fetch_link_map_offsets): Likewise.

	* solib-legacy.c (legacy_svr4_fetch_link_map_offsets): Don't set
	removed members.  Set l_ld_offset to -1 if not present.
@
text
@a961 2
  int success = 0;

a1126 4

  /* Nothing good happened.  */
  success = 0;

d1129 1
a1129 1
  return (success);
d1334 1
a1334 4
    {
      warning (_("shared library handler failed to enable breakpoint"));
      return;
    }
@


1.61
log
@Copyright updates for 2007.
@
text
@a120 13
/* Macro to extract an address from a solib structure.  When GDB is
   configured for some 32-bit targets (e.g. Solaris 2.7 sparc), BFD is
   configured to handle 64-bit targets, so CORE_ADDR is 64 bits.  We
   have to extract only the significant bits of addresses to get the
   right address when accessing the core file BFD.

   Assume that the address is unsigned.  */

#define SOLIB_EXTRACT_ADDRESS(MEMBER) \
	extract_unsigned_integer (&(MEMBER), sizeof (MEMBER))

/* local data declarations */

d128 2
a129 3
  return (CORE_ADDR) extract_signed_integer (so->lm_info->lm
					     + lmo->l_addr_offset,
					     lmo->l_addr_size);
d137 1
a137 1
  return (lmo->l_ld_size != 0);
d145 2
a146 5
  gdb_assert (lmo->l_ld_size != 0);

  return (CORE_ADDR) extract_signed_integer (so->lm_info->lm
					     + lmo->l_ld_offset,
					     lmo->l_ld_size);
d224 2
a225 3
  /* Assume that the address is unsigned.  */
  return extract_unsigned_integer (so->lm_info->lm + lmo->l_next_offset,
				   lmo->l_next_size);
d233 2
a234 3
  /* Assume that the address is unsigned.  */
  return extract_unsigned_integer (so->lm_info->lm + lmo->l_name_offset,
				   lmo->l_name_size);
d242 2
a243 3
  /* Assume that the address is unsigned.  */
  return extract_unsigned_integer (so->lm_info->lm + lmo->l_prev_offset,
				   lmo->l_prev_size) == 0;
d429 1
a429 1
	      int pbuf_size = TARGET_PTR_BIT / HOST_CHAR_BIT;
d438 1
a438 1
	      return extract_unsigned_integer (pbuf, pbuf_size);
d464 1
a464 1
	      int pbuf_size = TARGET_PTR_BIT / HOST_CHAR_BIT;
d473 1
a473 1
	      return extract_unsigned_integer (pbuf, pbuf_size);
d603 2
a604 1
  gdb_byte *l_name_buf = xmalloc (lmo->l_name_size);
d620 1
a620 1
  read_memory (lm + lmo->l_name_offset, l_name_buf, lmo->l_name_size);
d622 2
a623 3
  /* Convert the address to host format.  Assume that the address is
     unsigned.  */
  l_name = extract_unsigned_integer (l_name_buf, lmo->l_name_size);
d819 2
a820 1
      gdb_byte *l_name_buf = xmalloc (lmo->l_name_size);
d833 1
a833 1
      read_memory (lm + lmo->l_name_offset, l_name_buf, lmo->l_name_size);
d835 3
a837 3
      /* Extract this object's name.  Assume that the address is
         unsigned.  */
      name_address = extract_unsigned_integer (l_name_buf, lmo->l_name_size);
d856 3
a858 4
      /* Not the file we wanted, continue checking.  Assume that the
         address is unsigned.  */
      lm = extract_unsigned_integer (objfile_lm_info.lm + lmo->l_next_offset,
				     lmo->l_next_size);
a1503 1
      lmo.l_addr_size = 4;
a1504 1
      lmo.l_name_size = 4;
a1505 1
      lmo.l_ld_size = 4;
a1506 1
      lmo.l_next_size = 4;
a1507 1
      lmo.l_prev_size = 4;
a1533 1
      lmo.l_addr_size = 8;
a1534 1
      lmo.l_name_size = 8;
a1535 1
      lmo.l_ld_size = 8;
a1536 1
      lmo.l_next_size = 8;
a1537 1
      lmo.l_prev_size = 8;
@


1.60
log
@	* solib-svr4.c (debug_loader_offset_p, debug_loader_offset)
	(debug_loader_name, svr4_default_sos): New.
	(svr4_current_sos): Call svr4_default_sos.
	(enable_break): Add a comment about AT_BASE.  Set the new
	variables and retry solib_add.
	(svr4_clear_solib): Clear the new variables.
@
text
@d3 2
a4 3
   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
   2000, 2001, 2003, 2004, 2005, 2006
   Free Software Foundation, Inc.
@


1.59
log
@	* solib-svr4.c (LM_ADDR_CHECK): Suggest shared library mismatch.
@
text
@d270 9
d669 31
d736 1
a736 1
	return 0;
d742 1
d809 3
d1030 6
a1035 1
      tmp_fd  = solib_open (buf, &tmp_pathname);
d1074 8
a1081 2
	load_addr = (read_pc ()
		     - exec_entry_point (tmp_bfd, tmp_bfd_target));
d1393 4
@


1.58
log
@2006-05-18  Paul Gilliam  <pgilliam@@us.ibm.com

	* solib-svr4.c (enable_break): Breakup a long line into 3 shorter ones.
@
text
@a189 3
	  warning (_(".dynamic section for \"%s\" "
		     "is not at the expected address"), so->so_name);

d218 3
d224 4
@


1.57
log
@gdb/ChangeLog:
* solib-svr4.c (svr4_current_sos): Move up initialization of
l_addr, such that it clearly covers all cases.
gdb/testsuite/ChangeLog:
* gdb.base/prelink.exp: Anchor tested-for regular expression
on gdb prompt.
@
text
@d1073 3
a1075 1
      warning (_("Unable to find dynamic linker breakpoint function.\nGDB will be unable to debug shared library initializers\nand track explicitly loaded dynamic code."));
@


1.57.8.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d1073 1
a1073 3
      warning (_("Unable to find dynamic linker breakpoint function.\n"
               "GDB will be unable to debug shared library initializers\n"
               "and track explicitly loaded dynamic code."));
@


1.56
log
@gdb/ChangeLog:
* solib-svr4.h (struct link_map_offsets): Add l_ld_offset and
l_ld_size fields.
* solib-svr4.c (struct lm_info): Add l_addr field.
(LM_ADDR_FROM_LINK_MAP): Renamed from LM_ADDR.
(HAS_LM_DYNAMIC_FROM_LINK_MAP): New.
(LM_DYNAMIC_FROM_LINK_MAP): New.
(LM_ADDR_CHECK): New.  Use it instead of LM_ADDR.
(svr4_current_sos): Initialize l_addr.  Adjust.
(svr4_relocate_section_addresses): Adjust.
(svr4_ilp32_fetch_link_map_offsets): Define new members.
(svr4_lp64_fetch_link_map_offsets): Likewise.
* solib-legacy.c (legacy_svr4_fetch_link_map_offsets): Likewise.
* mipsnbsd-tdep.c (mipsnbsd_ilp32_fetch_link_map_offsets): Likewise.
(mipsnbsd_lp64_fetch_link_map_offsets): Likewise.
* Makefile.in (solib-svr4.o): Depend on $(elf_bfd_h).
gdb/testsuite/ChangeLog:
* gdb.base/prelink.exp: New test.
* gdb.base/prelink.c, gdb.base/prelink-lib.c: New sources.
@
text
@d707 1
a747 2
	      new->lm_info->l_addr = (CORE_ADDR)-1;

@


1.55
log
@* solib-svr4.h (struct link_map_offsets): Remove r_debug_size and
r_map_size members.  Add r_version_offset, r_version_size and
r_ldsomap_offset members.
* solib-svr4.c (solib_svr4_r_map): Renamed from
fetch_link_map_member.  Simplify using read_memory_typed_address.
(solib_svr4_r_ldsomap): New function.
(open_symbol_file_object): Use solib_svr_r_map.
(svr4_current_sos): Use solib_svr4_r_map and look for the dynamic
linker by using solib_svr4_r_ldsomap.
(svr4_ilp32_fetch_link_map_offsets)
(svr4_lp64_fetch_link_map_offsets): Adjust for changes to `struct
link_map_offsets'.
* solib-legacy.c (legacy_svr4_fetch_link_map_offsets): Adjust for
changes to `struct link_map_offsets'.
* mipsnbsd-tdep.c (mipsnbsd_ilp32_fetch_link_map_offsets)
(mipsnbsd_lp64_fetch_link_map_offsets): Adjust for changes to
`struct link_map_offsets'.
@
text
@d45 1
d63 7
d138 1
a138 1
LM_ADDR (struct so_list *so)
d142 2
a143 1
  return (CORE_ADDR) extract_signed_integer (so->lm_info->lm + lmo->l_addr_offset, 
d147 86
d747 2
d1012 1
a1012 1
	      load_addr = LM_ADDR (so);
d1372 4
a1375 2
  sec->addr    = svr4_truncate_ptr (sec->addr    + LM_ADDR (so));
  sec->endaddr = svr4_truncate_ptr (sec->endaddr + LM_ADDR (so));
d1464 2
d1499 2
@


1.54
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d4 1
a4 1
   2000, 2001, 2003, 2004, 2005
d450 2
a451 1
/*
d453 3
a455 1
   LOCAL FUNCTION
d457 4
a460 1
   first_link_map_member -- locate first member in dynamic linker's map
d462 3
a464 1
   SYNOPSIS
d466 2
a467 8
   static CORE_ADDR first_link_map_member (void)

   DESCRIPTION

   Find the first element in the inferior's dynamic link map, and
   return its address in the inferior.  This function doesn't copy the
   link map entry itself into our address space; current_sos actually
   does the reading.  */
d470 1
a470 1
first_link_map_member (void)
a471 1
  CORE_ADDR lm = 0;
d473 1
a473 2
  gdb_byte *r_map_buf = xmalloc (lmo->r_map_size);
  struct cleanup *cleanups = make_cleanup (xfree, r_map_buf);
d475 6
a480 4
  read_memory (debug_base + lmo->r_map_offset, r_map_buf, lmo->r_map_size);

  /* Assume that the address is unsigned.  */
  lm = extract_unsigned_integer (r_map_buf, lmo->r_map_size);
d482 2
a483 7
  /* FIXME:  Perhaps we should validate the info somehow, perhaps by
     checking r_version for a known version number, or r_state for
     RT_CONSISTENT. */

  do_cleanups (cleanups);

  return (lm);
d527 2
a528 1
  if ((lm = first_link_map_member ()) == 0)
d586 1
d602 1
a602 1
  lm = first_link_map_member ();  
d624 1
a624 1
      if (IGNORE_FIRST_LINK_MAP_ENTRY (new))
d658 7
d686 1
a686 1
  lm = first_link_map_member ();  
d1354 2
a1355 2
      /* Everything we need is in the first 8 bytes.  */
      lmo.r_debug_size = 8;
d1357 1
a1357 1
      lmo.r_map_size   = 4;
d1362 1
a1362 1
      lmo.l_addr_size   = 4;
d1364 1
a1364 1
      lmo.l_name_size   = 4;
d1366 1
a1366 1
      lmo.l_next_size   = 4;
d1368 1
a1368 1
      lmo.l_prev_size   = 4;
d1387 2
a1388 2
      /* Everything we need is in the first 16 bytes.  */
      lmo.r_debug_size = 16;
d1390 1
a1390 1
      lmo.r_map_size   = 8;
d1395 1
a1395 1
      lmo.l_addr_size   = 8;
d1397 1
a1397 1
      lmo.l_name_size   = 8;
d1399 1
a1399 1
      lmo.l_next_size   = 8;
d1401 1
a1401 1
      lmo.l_prev_size   = 8;
@


1.53
log
@* solib-svr4.c (svr4_current_sos, svr4_fetch_objfile_link_map):
Use XZALLOC and xzalloc instead of xmalloc where appropriate.
@
text
@d3 1
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.52
log
@* solib-svr4.c: Include "solib.h".
* Makefile.in (solib-svr4.o): Update dependencies.
@
text
@d607 1
a607 2
      struct so_list *new
	= (struct so_list *) xmalloc (sizeof (struct so_list));
a609 2
      memset (new, 0, sizeof (*new));

d613 1
a613 1
      new->lm_info->lm = xmalloc (lmo->link_map_size);
a614 1
      memset (new->lm_info->lm, 0, lmo->link_map_size);
d696 1
a696 1
      objfile_lm_info.lm = xmalloc (lmo->link_map_size);
a697 1
      memset (objfile_lm_info.lm, 0, lmo->link_map_size);
@


1.51
log
@	* corelow.c (core_open): Use bfd_fopen, not bfd_fdopenr.
	* exec.c (exec_file_attach): Likewise.
	* solib-frv.c (enable_break2): Likewise.
	* solib-svr4.c (enable_break): Likewise.
	* solib.c (solib_map_sections): Likewise.
	* symfile.c (symfile_bfd_open): Likewise.
@
text
@d41 1
@


1.50
log
@ solib-svr4.c gdb_byteised.
@
text
@d886 1
a886 1
	tmp_bfd = bfd_fdopenr (tmp_pathname, gnutarget, tmp_fd);
@


1.49
log
@* solib-svr4.c (_initialize_svr4_solib)
[SVR4_FETCH_LINK_MAP_OFFSETS]: Don't set non-existent variable
svr4_legacy_fetch_link_map_offsets.
@
text
@d60 1
a60 1
    char *lm;
d295 2
a296 2
  char *buf;
  char *bufend;
d340 1
a340 1
	      char *pbuf;
d375 1
a375 1
	      char *pbuf;
d471 1
a471 1
  char *r_map_buf = xmalloc (lmo->r_map_size);
d518 1
a518 1
  char *l_name_buf = xmalloc (lmo->l_name_size);
d693 1
a693 1
      char *l_name_buf = xmalloc (lmo->l_name_size);
@


1.48
log
@* solib-svr4.c: Update copyright year.  Include "gdb_assert.h".
(SVR4_FETCH_LINK_MAP_OFFSETS): Don't define if not already
defined.
(legacy_fetch_link_map_offsets): Remove prototype.
(fetch_link_map_offsets_gdbarch_data): Remove.
(LM_ADDR, LM_NEXT, IGNORE_FIRST_LINK_MAP_ENTRY)
(first_link_map_member, open_symbol_file_object, svr4_current_sos)
(svr4_fetch_objfile_link_map): Call svr4_fetch_link_map_offsets
instead of SVR4_FETCH_LINK_MAP_OFFSETS.
(solib_svr4_data): New variable.
(struct solib_svr4_ops): New.
(solib_svr4_init): New fynction.
(legacy_fetch_link_map_offsets, init_fetch_link_map_offsets):
Remove functions.
(svr4_fetch_link_map_offsets, svr4_have_link_map_offsets): Rewrite
using the new `struct solib_svr4_ops'.
(_initialize_svr4_solib): Replace registration of per-architecture
data.  Add temporary hack to set
svr4_legacy_fetch_link_map_offsets if SVR4_FETCH_LINK_MAP_OFFSETS
is set.
* Makefile.in (solib-svr4.o): Update dependencies.
@
text
@a1414 5
  /* FIXME: Eliminate this ASAP.  */
#ifdef SVR4_FETCH_LINK_MAP_OFFSETS
  svr4_legacy_fetch_link_map_offsets = SVR4_FETCH_LINK_MAP_OFFSETS;
#endif

@


1.47
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d4 1
a4 1
   2000, 2001, 2003, 2004
d38 2
a45 4
#ifndef SVR4_FETCH_LINK_MAP_OFFSETS
#define SVR4_FETCH_LINK_MAP_OFFSETS() svr4_fetch_link_map_offsets ()
#endif

a46 1
static struct link_map_offsets *legacy_fetch_link_map_offsets (void);
d49 3
a51 10
/* fetch_link_map_offsets_gdbarch_data is a handle used to obtain the
   architecture specific link map offsets fetching function.  */

static struct gdbarch_data *fetch_link_map_offsets_gdbarch_data;

/* legacy_svr4_fetch_link_map_offsets_hook is a pointer to a function
   which is used to fetch link map offsets.  It will only be set
   by solib-legacy.c, if at all.  */

struct link_map_offsets *(*legacy_svr4_fetch_link_map_offsets_hook) (void) = 0;
d131 1
a131 1
  struct link_map_offsets *lmo = SVR4_FETCH_LINK_MAP_OFFSETS ();
d140 1
a140 1
  struct link_map_offsets *lmo = SVR4_FETCH_LINK_MAP_OFFSETS ();
d150 1
a150 1
  struct link_map_offsets *lmo = SVR4_FETCH_LINK_MAP_OFFSETS ();
d160 1
a160 1
  struct link_map_offsets *lmo = SVR4_FETCH_LINK_MAP_OFFSETS ();
d470 1
a470 1
  struct link_map_offsets *lmo = SVR4_FETCH_LINK_MAP_OFFSETS ();
d517 1
a517 1
  struct link_map_offsets *lmo = SVR4_FETCH_LINK_MAP_OFFSETS ();
d605 1
a605 1
      struct link_map_offsets *lmo = SVR4_FETCH_LINK_MAP_OFFSETS ();
d687 1
a687 1
      struct link_map_offsets *lmo = SVR4_FETCH_LINK_MAP_OFFSETS ();
d1276 1
d1278 1
d1280 2
a1281 7
/* Fetch a link_map_offsets structure for native targets using struct
   definitions from link.h.  See solib-legacy.c for the function
   which does the actual work.
   
   Note: For non-native targets (i.e. cross-debugging situations),
   a target specific fetch_link_map_offsets() function should be
   defined and registered via set_solib_svr4_fetch_link_map_offsets().  */
d1283 1
a1283 2
static struct link_map_offsets *
legacy_fetch_link_map_offsets (void)
d1285 3
a1287 10
  if (legacy_svr4_fetch_link_map_offsets_hook)
    return legacy_svr4_fetch_link_map_offsets_hook ();
  else
    {
      internal_error (__FILE__, __LINE__,
                      _("legacy_fetch_link_map_offsets called without legacy "
		      "link_map support enabled."));
      return 0;
    }
}
d1289 1
a1289 2
/* Fetch a link_map_offsets structure using the method registered in the
   architecture vector.  */
d1291 2
a1292 2
static struct link_map_offsets *
svr4_fetch_link_map_offsets (void)
d1294 1
a1294 2
  struct link_map_offsets *(*flmo)(void) =
    gdbarch_data (current_gdbarch, fetch_link_map_offsets_gdbarch_data);
d1296 3
a1298 9
  if (flmo == NULL)
    {
      internal_error (__FILE__, __LINE__, 
                      _("svr4_fetch_link_map_offsets: fetch_link_map_offsets "
		      "method not defined for this architecture."));
      return 0;
    }
  else
    return (flmo ());
d1301 6
a1306 3
/* Return 1 if a link map offset fetcher has been defined, 0 otherwise.  */
static int
svr4_have_link_map_offsets (void)
d1308 3
a1310 8
  struct link_map_offsets *(*flmo)(void) =
    gdbarch_data (current_gdbarch, fetch_link_map_offsets_gdbarch_data);
  if (flmo == NULL
      || (flmo == legacy_fetch_link_map_offsets 
          && legacy_svr4_fetch_link_map_offsets_hook == NULL))
    return 0;
  else
    return 1;
d1313 2
a1314 4
/* set_solib_svr4_fetch_link_map_offsets() is intended to be called by
   a <arch>_gdbarch_init() function.  It is used to establish an
   architecture specific link_map_offsets fetcher for the architecture
   being defined.  */
d1316 2
a1317 3
void
set_solib_svr4_fetch_link_map_offsets (struct gdbarch *gdbarch,
                                       struct link_map_offsets *(*flmo) (void))
d1319 4
a1322 1
  deprecated_set_gdbarch_data (gdbarch, fetch_link_map_offsets_gdbarch_data, flmo);
d1325 1
a1325 9
/* Initialize the architecture-specific link_map_offsets fetcher.
   This is called after <arch>_gdbarch_init() has set up its `struct
   gdbarch' for the new architecture, and is only called if the
   link_map_offsets fetcher isn't already initialized (which is
   usually done by calling set_solib_svr4_fetch_link_map_offsets()
   above in <arch>_gdbarch_init()).  Therefore we attempt to provide a
   reasonable alternative (for native targets anyway) if the
   <arch>_gdbarch_init() fails to call
   set_solib_svr4_fetch_link_map_offsets().  */
d1327 2
a1328 2
static void *
init_fetch_link_map_offsets (struct gdbarch *gdbarch)
d1330 2
a1331 1
  return legacy_fetch_link_map_offsets;
d1333 1
d1413 6
a1418 2
  fetch_link_map_offsets_gdbarch_data =
    gdbarch_data_register_post_init (init_fetch_link_map_offsets);
@


1.47.2.1
log
@	* corelow.c (core_open): Use bfd_fopen, not bfd_fdopenr.
	* exec.c (exec_file_attach): Likewise.
	* solib-frv.c (enable_break2): Likewise.
	* solib-svr4.c (enable_break): Likewise.
	* solib.c (solib_map_sections): Likewise.
	* symfile.c (symfile_bfd_open): Likewise.
@
text
@d896 1
a896 1
	tmp_bfd = bfd_fopen (tmp_pathname, gnutarget, FOPEN_RB, tmp_fd);
@


1.46
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d1304 2
a1305 2
                      "legacy_fetch_link_map_offsets called without legacy "
		      "link_map support enabled.");
d1322 2
a1323 2
                      "svr4_fetch_link_map_offsets: fetch_link_map_offsets "
		      "method not defined for this architecture.");
@


1.45
log
@2005-01-13  Michael Snyder  <msnyder@@redhat.com>

	* solib-aix.c: Whitespace tweaks.
	* solib.c: Whitespace tweaks.
	* solib-frv.c: Whitespace tweaks.
	* solib.h: Whitespace tweaks.
	* solib-irix.c: Whitespace tweaks.
	* solib-som.c: Whitespace tweaks.
	* solib-sunos.c: Whitespace tweaks.
	* solib-svr4.[ch]: Whitespace tweaks.
@
text
@d560 1
a560 1
      warning ("failed to read exec filename from attached file: %s",
d649 2
a650 4
	    {
	      warning ("current_sos: Can't read pathname for load map: %s\n",
		       safe_strerror (errcode));
	    }
d726 2
a727 4
    	{
	  warning ("svr4_fetch_objfile_link_map: Can't read pathname for load map: %s\n",
  		   safe_strerror (errcode));
  	}
d904 1
a904 1
	  warning ("Unable to grok dynamic linker %s as an object file", buf);
d985 1
a985 1
      warning ("Unable to find dynamic linker breakpoint function.\nGDB will be unable to debug shared library initializers\nand track explicitly loaded dynamic code.");
d1206 1
a1206 1
      warning ("no shared library support for this OS / ABI");
d1213 1
a1213 1
      warning ("shared library handler failed to enable breakpoint");
@


1.44
log
@2004-06-09  Andrew Cagney  <cagney@@gnu.org>

	* solib-svr4.c [HANDLE_SVR4_EXEC_EMULATORS]: Delete #ifdef code.
@
text
@d59 1
a59 1
   by solib-legacy.c, if at all. */
d61 1
a61 1
struct link_map_offsets *(*legacy_svr4_fetch_link_map_offsets_hook)(void) = 0;
d1158 1
a1158 1
   void svr4_solib_create_inferior_hook()
@


1.43
log
@2004-03-15  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (gdbarch_data_pre_init_fytpe)
	(gdbarch_data_register_pre_init, gdbarch_data_post_init_fytpe)
	(gdbarch_data_register_post_init): Replace gdbarch_data_init_ftype
	and register_gdbarch_data.
	(deprecated_set_gdbarch_data): Rename set_gdbarch_data.
	(struct gdbarch_data): Replace "init" by "pre_init" and
	"post_init".
	* gdbarch.h, gdbarch.c: Re-generate.
	* dwarf2-frame.c (dwarf2_frame_init): Replace "gdbarch" paramter
	with"obstack", use OBSTACK_ZALLOC.
	(dwarf2_frame_ops): Delete.
	(dwarf2_frame_set_init_reg): Use gdbarch_data.
	(dwarf2_frame_init_reg): Use gdbarch_data.
	(_initialize_dwarf2_frame): Use gdbarch_data_register_pre_init.
	* solib-svr4.c (set_solib_svr4_fetch_link_map_offsets)
	(_initialize_svr4_solib): Update.
	* user-regs.c (_initialize_user_regs): Update.
	* reggroups.c (_initialize_reggroup): Update.
	* regcache.c (_initialize_regcache): Update.
	* mips-linux-tdep.c (_initialize_mips_linux_tdep): Update.
	* libunwind-frame.c (_initialize_libunwind_frame): Update.
	* gnu-v3-abi.c (init_gnuv3_ops): Update.
	* frame-unwind.c (_initialize_frame_unwind): Update.
	* frame-base.c (_initialize_frame_base): Update.
	* user-regs.c (user_reg_add): Update.
	* reggroups.c (reggroup_add): Update.
	* mips-linux-tdep.c (set_mips_linux_register_addr): Update.
	* libunwind-frame.c (libunwind_frame_set_descr): Update.
	* frame-unwind.c (frame_unwind_append_sniffer): Update.
	* frame-base.c (frame_base_table): Update.
	* remote.c (_initialize_remote): Update.
	* gdb_obstack.h (OBSTACK_ZALLOC, OBSTACK_CALLOC): Define.
@
text
@a274 127
#ifdef HANDLE_SVR4_EXEC_EMULATORS

/*
   Solaris BCP (the part of Solaris which allows it to run SunOS4
   a.out files) throws in another wrinkle. Solaris does not fill
   in the usual a.out link map structures when running BCP programs,
   the only way to get at them is via groping around in the dynamic
   linker.
   The dynamic linker and it's structures are located in the shared
   C library, which gets run as the executable's "interpreter" by
   the kernel.

   Note that we can assume nothing about the process state at the time
   we need to find these structures.  We may be stopped on the first
   instruction of the interpreter (C shared library), the first
   instruction of the executable itself, or somewhere else entirely
   (if we attached to the process for example).
 */

static char *debug_base_symbols[] =
{
  "r_debug",			/* Solaris 2.3 */
  "_r_debug",			/* Solaris 2.1, 2.2 */
  NULL
};

static int look_for_base (int, CORE_ADDR);

/*

   LOCAL FUNCTION

   look_for_base -- examine file for each mapped address segment

   SYNOPSYS

   static int look_for_base (int fd, CORE_ADDR baseaddr)

   DESCRIPTION

   This function is passed to proc_iterate_over_mappings, which
   causes it to get called once for each mapped address space, with
   an open file descriptor for the file mapped to that space, and the
   base address of that mapped space.

   Our job is to find the debug base symbol in the file that this
   fd is open on, if it exists, and if so, initialize the dynamic
   linker structure base address debug_base.

   Note that this is a computationally expensive proposition, since
   we basically have to open a bfd on every call, so we specifically
   avoid opening the exec file.
 */

static int
look_for_base (int fd, CORE_ADDR baseaddr)
{
  bfd *interp_bfd;
  CORE_ADDR address = 0;
  char **symbolp;

  /* If the fd is -1, then there is no file that corresponds to this
     mapped memory segment, so skip it.  Also, if the fd corresponds
     to the exec file, skip it as well. */

  if (fd == -1
      || (exec_bfd != NULL
	  && fdmatch (fileno ((FILE *) (exec_bfd->iostream)), fd)))
    {
      return (0);
    }

  /* Try to open whatever random file this fd corresponds to.  Note that
     we have no way currently to find the filename.  Don't gripe about
     any problems we might have, just fail. */

  if ((interp_bfd = bfd_fdopenr ("unnamed", gnutarget, fd)) == NULL)
    {
      return (0);
    }
  if (!bfd_check_format (interp_bfd, bfd_object))
    {
      /* FIXME-leak: on failure, might not free all memory associated with
         interp_bfd.  */
      bfd_close (interp_bfd);
      return (0);
    }

  /* Now try to find our debug base symbol in this file, which we at
     least know to be a valid ELF executable or shared library. */

  for (symbolp = debug_base_symbols; *symbolp != NULL; symbolp++)
    {
      address = bfd_lookup_symbol (interp_bfd, *symbolp, 0);
      if (address != 0)
	{
	  break;
	}
    }
  if (address == 0)
    {
      /* FIXME-leak: on failure, might not free all memory associated with
         interp_bfd.  */
      bfd_close (interp_bfd);
      return (0);
    }

  /* Eureka!  We found the symbol.  But now we may need to relocate it
     by the base address.  If the symbol's value is less than the base
     address of the shared library, then it hasn't yet been relocated
     by the dynamic linker, and we have to do it ourself.  FIXME: Note
     that we make the assumption that the first segment that corresponds
     to the shared library has the base address to which the library
     was relocated. */

  if (address < baseaddr)
    {
      address += baseaddr;
    }
  debug_base = address;
  /* FIXME-leak: on failure, might not free all memory associated with
     interp_bfd.  */
  bfd_close (interp_bfd);
  return (1);
}
#endif /* HANDLE_SVR4_EXEC_EMULATORS */

a454 5
#ifdef HANDLE_SVR4_EXEC_EMULATORS
      /* Try it the hard way for emulated executables.  */
      else if (!ptid_equal (inferior_ptid, null_ptid) && target_has_execution)
	proc_iterate_over_mappings (look_for_base);
#endif
@


1.43.2.1
log
@2004-03-23  Elena Zannoni  <ezannoni@@redhat.com>

       * solib-svr4.c (svr4_solib_create_inferior_hook): Disable
       breakpoints at startup.
       (elf_locate_base): Find out where the entry point for the program
       is, using the auxv vector, if possible. Compute the address of
       .dynamic using it.
       (svr4_current_sos): Don't ignore the first entry if we have PIE,
       it's our main program. Delete code that was skipping over the
       solib entry for main executable.
       * solist.h (struct so_list): Add fields main and main_relocated.
        (add_to_target_sections): Export.
       * solib.c (symbol_add_stub): Handle main executable in shared
       library list. Ignore it if it has been relocated already. Add it
       as the main symbol file, otherwise.
       * infrun.c (handle_inferior_event): Re-enable startup breakpoints.

       * solib-svr4.c (elf_locate_base, first_link_map_member)
       svr4_current_sos, enable_break): Add debugging output.
       * solist.h (debug_solib): Export.
       * solib.c (debug_solib): New variable to enable debugging output.
       (symbol_add_stub, update_solib_list, update_solib_list)
       (add_to_target_sections): Add debugging output.
       (_initialize_solib): Add new comand to enable printing of
       debugging output.
       (add_to_target_sections): New function. Factored out from
       update_solib_list.
       (update_solib_list): Call add_to_target_sections.

       * varobj.h (varobj_refresh): New prototype.
       * varobj.c (varobj_refresh): New function.
       * symfile.c (reread_symbols): Make sure that we recompute the
       entry point for the program.
       (symbol_file_clear): Clear the solibs as well, if we change symbol
       files.
       (clear_symtab_users): Refresh the varobjs that depend on the symtabs
       we are clearing.
       * objfiles.c (entry_point_address): Rewrite, to fetch entry point
       from auxv vector, if possible.
       Add include of elf/common.h.
       * breakpoint.h (enum bptype): Add bp type bp_startup_disabled.
       (re_enable_breakpoints_at_startup)
       (disable_breakpoints_at_startup): Add prototypes
       * breakpoint.c (re_enable_breakpoints_at_startup)
       (disable_breakpoints_at_startup): New functions.
       (describe_other_breakpoints, delete_breakpoint)
       (breakpoint_re_set_one): Handle new bp type.
       * auxv.h (target_auxv_parse, target_auxv_search): Update.
       * auxv.c (target_auxv_parse, target_auxv_search)
       (fprint_target_auxv): Use ULONGEST instead of CORE_ADDR for
       variable. Change variable name to at_type.
@
text
@a181 1
#if 0
a182 1
#endif
d431 1
a431 1
  CORE_ADDR dyninfo_addr, relocated_dyninfo_addr, entry_addr;
a434 23
  int ret;

  /* Find the address of the entry point of the program from the
     auxv vector.  */
  ret = target_auxv_search (&current_target, AT_ENTRY, &entry_addr);

  if (ret == 0 || ret == -1)
    {
      /* No auxv info, maybe an older kernel. Fake our way through.  */
      entry_addr = bfd_get_start_address (exec_bfd); 

      if (debug_solib)
	fprintf_unfiltered (gdb_stdlog,
			    "elf_locate_base: program entry address not found. Using bfd's 0x%s for %s\n",
			    paddr_nz (entry_addr), exec_bfd->filename);
    }
  else
    {
      if (debug_solib)
	fprintf_unfiltered (gdb_stdlog,
			    "elf_locate_base: found program entry address 0x%s for %s\n",
			    paddr_nz (entry_addr), exec_bfd->filename);
    }
d439 1
a439 15
    { 
      if (debug_solib)
	fprintf_unfiltered (gdb_stdlog,
			    "elf_locate_base: .dynamic section not found in %s -- return now\n",
			    exec_bfd->filename);
      return 0;
    }
  else
    { 
      if (debug_solib)
	fprintf_unfiltered (gdb_stdlog,
			    "elf_locate_base: .dynamic section found in %s\n",
			    exec_bfd->filename);
    }

a440 11
  if (debug_solib)
    fprintf_unfiltered (gdb_stdlog,
			"elf_locate_base: unrelocated .dynamic addr 0x%s\n",
			paddr_nz (dyninfo_addr));

  relocated_dyninfo_addr = dyninfo_addr
    + entry_addr - bfd_get_start_address(exec_bfd);
  if (debug_solib) 
    fprintf_unfiltered (gdb_stdlog, 
			"elf_locate_base: relocated .dyn addr 0x%s for %s\n",
			paddr_nz(relocated_dyninfo_addr), exec_bfd->filename);
d445 2
a446 11
  if (debug_solib) 
    fprintf_unfiltered (gdb_stdlog, 
                        "elf_locate_base: read in .dynamic section\n");
  if (target_read_memory (relocated_dyninfo_addr, buf, dyninfo_sect_size))
    { 
      if (debug_solib)
	fprintf_unfiltered (gdb_stdlog,
			    "elf_locate_base: couldn't read .dynamic section at 0x%s -- return now\n",
			    paddr_nz (relocated_dyninfo_addr));
      return 0;
    }
a472 4
              if (debug_solib)
                fprintf_unfiltered (gdb_stdlog,
				    "elf_locate_base: DT_DEBUG entry has value 0x%s -- return now\n",
				    paddr_nz (dyn_ptr));
a615 4
  if (debug_solib)
    fprintf_unfiltered (gdb_stdlog, 
                        "first_link_map_member: read at 0x%s\n",
                        paddr_nz (debug_base + lmo->r_map_offset));
a728 4
  if (debug_solib)
    fprintf_unfiltered (gdb_stdlog, 
                        "svr4_current_sos: exec_bfd %s\n",
                        exec_bfd->filename);
d739 1
a739 7
	{
	  if (debug_solib)
	    fprintf_unfiltered (gdb_stdlog, 
				"svr4_current_sos: no DT_DEBUG found in %s -- return now\n",
				exec_bfd->filename);
	  return 0;
	}
d744 1
a744 5
  if (debug_solib)
    fprintf_unfiltered (gdb_stdlog, 
                        "svr4_current_sos: walk link map in %s\n",
                        exec_bfd->filename);
  lm = first_link_map_member (); 
a760 3
      if (debug_solib)
        fprintf_unfiltered (gdb_stdlog, 
                            "svr4_current_sos: read lm at 0x%s\n", paddr_nz(lm));
a764 5
      if (debug_solib)
        fprintf_unfiltered (gdb_stdlog,
                            "svr4_current_sos: is first link entry? %d\n",
                            IGNORE_FIRST_LINK_MAP_ENTRY (new));

d771 1
a771 56
	{

	  if (bfd_get_start_address (exec_bfd) == entry_point_address ())
	    {
	      free_so (new);
	    }
	  else
	    {
	      struct so_list *gdb_solib;
	      if (debug_solib)
		fprintf_unfiltered (gdb_stdlog,
				    "svr4_current_sos: Processing first link map entry\n");
	      strncpy (new->so_name, exec_bfd->filename,
		       SO_NAME_MAX_PATH_SIZE - 1);
	      new->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
	      strcpy (new->so_original_name, new->so_name);
	      /*new->main = 1;*/
	      new->main_relocated = 0;
            
	      if (debug_solib)
		{ 
		  fprintf_unfiltered (gdb_stdlog,
				      "svr4_current_sos: Processing nameless DSO\n");
		  fprintf_unfiltered (gdb_stdlog,
				      "svr4_current_sos: adding name %s\n",
				      new->so_name);
		}

	      for (gdb_solib = master_so_list (); gdb_solib; gdb_solib = gdb_solib->next)
		{
		  if (debug_solib)
		    fprintf_unfiltered (gdb_stdlog,
					"svr4_current_sos: compare gdb %s and new %s\n",
					gdb_solib->so_name, new->so_name);
		  if (!strcmp (gdb_solib->so_name, new->so_name))
		    if (gdb_solib->main_relocated)
		      { 
			if (debug_solib)
			  fprintf_unfiltered (gdb_stdlog,
					      "svr4_current_sos: found main relocated\n");
			break;
		      }
		}

	      if ((gdb_solib && !gdb_solib->main_relocated) || (!gdb_solib))
		{
		  add_to_target_sections (0 /*from_tty*/, &current_target, new);
		  new->main = 1;
		}
	      /* We need this in the list of shared libs we return because
		 solib_add_stub will loop through it and add the symbol file.  */
	      new->next = 0;
	      *link_ptr = new;
	      link_ptr = &new->next; 
	    }
	}
a777 4
	  if (debug_solib)
	    fprintf_unfiltered (gdb_stdlog, 
                                "svr4_current_sos: read LM_NAME\n");

d782 1
a782 1
	      warning ("svr4_current_sos: Can't read pathname for load map: %s\n",
a786 5
              if (debug_solib)
                fprintf_unfiltered (gdb_stdlog, 
                                    "svr4_current_sos: LM_NAME is <%s>\n",
                                    buffer);

a790 9
	      if (debug_solib)
		{
		  fprintf_unfiltered (gdb_stdlog, 
				      "svr4_current_sos: Processing DSO: %s\n",
				      new->so_name);
		  fprintf_unfiltered (gdb_stdlog,
				      "svr4_current_sos: first link entry %d\n",
				      IGNORE_FIRST_LINK_MAP_ENTRY (new));
		}
d793 11
a803 4
	  new->next = 0;
	  *link_ptr = new;
	  link_ptr = &new->next;

a808 5
  if (debug_solib)
    fprintf_unfiltered (gdb_stdlog, 
                        "svr4_current_sos: ENDS %s\n",
                        exec_bfd->filename);

d827 1
a827 1
  lm = first_link_map_member ();
d888 1
a888 1
#if 0
a901 1
#endif
a1000 5

  if (debug_solib)
     fprintf_unfiltered (gdb_stdlog,
                         "enable_break: search for .interp in %s\n",
                         exec_bfd->filename);
a1033 3
      if (debug_solib)
         fprintf_unfiltered (gdb_stdlog,
                            "enable_break: opening %s\n", tmp_pathname);
a1114 3
          if (debug_solib)
            fprintf_unfiltered (gdb_stdlog,
                               "enable_break: solib bp set\n");
a1373 2
 
   disable_breakpoints_at_startup (1); 
@


1.42
log
@	* solist.h (master_so_list): New function.
	* solib.c (master_so_list): Likewise.
	* solib-svr4.c (enable_break): Iterate over so_list entries
	obtained from master list instead of entries obtained directly
	via svr4_current_sos().
@
text
@d1489 1
a1489 1
  set_gdbarch_data (gdbarch, fetch_link_map_offsets_gdbarch_data, flmo);
d1587 1
a1587 1
    register_gdbarch_data (init_fetch_link_map_offsets);
@


1.41
log
@* solib-svr4.h: Update copyright year.
(svr4_ilp32_fetch_link_map_offsets)
(svr4_lp64_fetch_link_map_offsets): New prototype.
* solib-svr4.c: Update copyright year.
(svr4_ilp32_fetch_link_map_offsets)
(svr4_lp64_fetch_link_map_offsets): New function.
@
text
@d1007 1
a1007 1
      struct so_list *inferior_sos;
d1050 5
a1054 4
      /* If the entry in _DYNAMIC for the dynamic linker has already
         been filled in, we can read its base address from there. */
      inferior_sos = svr4_current_sos ();
      if (inferior_sos)
d1056 1
a1056 6
	  /* Connected to a running target.  Update our shared library table. */
	  solib_add (NULL, 0, NULL, auto_solib_add);
	}
      while (inferior_sos)
	{
	  if (strcmp (buf, inferior_sos->so_original_name) == 0)
d1059 1
a1059 1
	      load_addr = LM_ADDR (inferior_sos);
d1062 1
a1062 1
	  inferior_sos = inferior_sos->next;
@


1.41.2.1
log
@Merge mainline to intercu branch.
@
text
@d1007 1
a1007 1
      struct so_list *so;
d1050 4
a1053 5
      /* On a running target, we can get the dynamic linker's base
         address from the shared library table.  */
      solib_add (NULL, 0, NULL, auto_solib_add);
      so = master_so_list ();
      while (so)
d1055 6
a1060 1
	  if (strcmp (buf, so->so_original_name) == 0)
d1063 1
a1063 1
	      load_addr = LM_ADDR (so);
d1066 1
a1066 1
	  so = so->next;
d1493 1
a1493 1
  deprecated_set_gdbarch_data (gdbarch, fetch_link_map_offsets_gdbarch_data, flmo);
d1591 1
a1591 1
    gdbarch_data_register_post_init (init_fetch_link_map_offsets);
@


1.41.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d275 127
d582 5
@


1.41.6.1
log
@Jumbo patch.  Experiments with tramp-frame.
@
text
@d1591 1
a1591 1
    register_gdbarch_data (NULL, init_fetch_link_map_offsets);
@


1.41.6.2
log
@Dump of tramp-frame stuff.
@
text
@d1493 1
a1493 1
  deprecated_set_gdbarch_data (gdbarch, fetch_link_map_offsets_gdbarch_data, flmo);
d1591 1
a1591 1
    gdbarch_data_register_post_init (init_fetch_link_map_offsets);
@


1.41.6.3
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d1007 1
a1007 1
      struct so_list *so;
d1050 4
a1053 5
      /* On a running target, we can get the dynamic linker's base
         address from the shared library table.  */
      solib_add (NULL, 0, NULL, auto_solib_add);
      so = master_so_list ();
      while (so)
d1055 6
a1060 1
	  if (strcmp (buf, so->so_original_name) == 0)
d1063 1
a1063 1
	      load_addr = LM_ADDR (so);
d1066 1
a1066 1
	  so = so->next;
@


1.40
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@d4 2
a5 1
   2000, 2001, 2003 Free Software Foundation, Inc.
d1511 71
@


1.39
log
@2003-11-05  Andrew Cagney  <cagney@@redhat.com>

	* xcoffread.c (find_linenos): Replace "sec_ptr" and "bfd" with
	"struct bfd_section" and "struct bfd".
	* target.h (struct section_table): Ditto.
	* rs6000-nat.c (xcoff_relocate_core): Ditto.
	* solib-svr4.c (elf_locate_base): Ditto.
	* pa64solib.c (dld_cache_t): Ditto.
	* objfiles.h (struct obj_section): Ditto.
	* objfiles.c (add_to_objfile_sections): Ditto.
	* exec.c (bfdsec_to_vmap): Ditto.
	(add_to_section_table): Ditto.
	(build_section_table): Ditto.
	* corelow.c (get_core_register_section): Ditto.
	* coffread.c (find_linenos): Ditto.
	* elfread.c (elf_interpreter): Delete #if0'd function.

	* mips-tdep.c (mips_dump_tdep): Delete code prinint VX_NUM_REGS.
	* config/sparc/tm-vxsparc.h (VX_NUM_REGS): Delete macro.
	* config/mips/tm-vxmips.h (VX_NUM_REGS): Delete macro.
	* config/m68k/tm-vx68.h (VX_NUM_REGS): Delete macro.

	* arch-utils.h (generic_cannot_extract_struct_value_address):
	Delete declaration.
	* wince.c (_initialize_wince): Fix multi-line string.
	* ia64-tdep.c (floatformat_valid): Convert to ISO C.
@
text
@d231 1
a231 1
	  if (STREQ (sym->name, symname)
d260 1
a260 1
	  if (STREQ (sym->name, symname)
@


1.38
log
@2003-10-31  Andrew Cagney  <cagney@@redhat.com>

	* solib-svr4.c: Update copyright.  Include "bfd-target.h" and
	"exec.h".
	(exec_entry_point): New function.
	(enable_break): Create a "tmp_bfd_target", use that and
	entry_point_address when computing the relocation offset.
	(svr4_relocate_main_executable): Ditto with exec_bfd and exec_ops.
	* Makefile.in (solib-svr4.o): Update dependencies.
@
text
@d428 1
a428 1
  sec_ptr dyninfo_sect;
@


1.37
log
@* solib-svr4.c (bfd_lookup_symbol): New SECT_FLAGS argument.
(enable_break): Pass SEC_CODE as the SECT_FLAGS argument to
bfd_lookup_symbol, since we only want symbols in code sections.
(look_for_base): Pass zero as the SECT_FLAGS argument to
bfd_lookup_symbol, since we're not concerned about which section
the symbol is in.
@
text
@d2 3
a4 3
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
   2001
   Free Software Foundation, Inc.
d40 3
d917 18
d1008 1
d1044 5
d1072 2
a1073 1
	load_addr = read_pc () - tmp_bfd->start_address;
d1111 3
a1113 2
      /* We're done with the temporary bfd.  */
      bfd_close (tmp_bfd);
d1232 1
a1232 1
      && bfd_get_start_address (exec_bfd) != pc)
d1264 1
a1264 1
      displacement = pc - bfd_get_start_address (exec_bfd);
@


1.37.2.1
log
@2003-09-29  Elena Zannoni  <ezannoni@@redhat.com>

	* solib-svr4.c: Include gdbcmd.h.
	(debug_solib): New variable.
	(elf_locate_base): Add some debugging statements.
	(svr4_current_sos): Likewise.
	(enable_break): Likewise.
	(svr4_relocate_main_executable): Likewise.
	(_initialize_svr4_solib): Add new 'set' command to control
	debugging output.
	* Makefile.in (solib-svr4.o): Update dependencies.
@
text
@a35 1
#include "gdbcmd.h"
a118 3
/* Control the printing of debugging statements.  */
static int debug_solib;

d435 1
a435 7
    { 
      if (debug_solib)
	fprintf_unfiltered (gdb_stdlog,
			    "elf_locate_base: didn't find .dynamic in %s\n",
			    exec_bfd->filename);
      return 0;
    }
d442 1
a442 7
    { 
      if (debug_solib)
	fprintf_unfiltered (gdb_stdlog,
			    "elf_locate_base: coudn't read 0x%s\n",
			    paddr_nz (dyninfo_addr));
      return 0;
    }
a468 4
              if (debug_solib)
                fprintf_unfiltered (gdb_stdlog,
				    "elf_locate_base: DT_DEBUG entry has value 0x%s\n",
				    paddr_nz (dyn_ptr));
d735 1
a735 6
	{
	  if (debug_solib)
	    fprintf_unfiltered (gdb_stdlog, 
				"svr4_current_sos: no DT_DEBUG found\n");
	  return 0;
	}
a786 4
	      if (debug_solib)
		fprintf_unfiltered (gdb_stdlog, 
				    "svr4_current_sos: Processing DSO: %s\n",
				    new->so_name);
a978 4
  if (debug_solib)
    fprintf_unfiltered (gdb_stdlog,
			"enable_break: search for .interp in %s\n",
			exec_bfd->filename);
a1010 4
      if (debug_solib)
	fprintf_unfiltered (gdb_stdlog,
                            "enable_break: opening %s\n", tmp_pathname);

a1088 3
          if (debug_solib)
            fprintf_unfiltered (gdb_stdlog,
				"enable_break: solib bp set\n");
a1234 5
      fprintf_unfiltered (gdb_stdlog,
                          "relocate_main: current pc is %s, bfd_start_address is %s\n",
                          paddr_nz (pc),
                          paddr_nz (bfd_get_start_address (exec_bfd)));

a1502 4
  add_show_from_set (add_set_cmd ("solib", no_class, var_zinteger,
				  (char *) &debug_solib,
				  "Set debugging of GNU/Linux shlib module.\n\
Enables printf debugging output.\n", &setdebuglist), &showdebuglist);
@


1.36
log
@2003-08-04  Andrew Cagney  <cagney@@redhat.com>

	* solib-svr4.c (_initialize_svr4_solib): Update
	register_gdbarch_data call.
	* mips-linux-tdep.c (_initialize_mips_linux_tdep): Ditto.
@
text
@d180 1
a180 1
static CORE_ADDR bfd_lookup_symbol (bfd *, char *);
d190 1
a190 1
   CORE_ADDR bfd_lookup_symbol (bfd *abfd, char *symname)
d199 3
d207 1
a207 1
bfd_lookup_symbol (bfd *abfd, char *symname)
d228 2
a229 1
	  if (STREQ (sym->name, symname))
d256 3
a258 1
	  if (STREQ (sym->name, symname))
d364 1
a364 1
      address = bfd_lookup_symbol (interp_bfd, *symbolp);
d1069 10
a1078 1
	  sym_addr = bfd_lookup_symbol (tmp_bfd, *bkpt_namep);
@


1.35
log
@* solib-svr4.c (solib_break_names): Recognize the 64-bit PowerPC
Linux entry point symbols for _dl_debug_state, too.
@
text
@d1475 1
a1475 1
    register_gdbarch_data (init_fetch_link_map_offsets, 0);
@


1.35.2.1
log
@* gdbarch.sh (gdbarch_bfd_entry_point): New gdbarch method.
* arch-utils.c (generic_bfd_entry_point): New function.
* arch-utils.h (generic_bfd_entry_point): New declaration.
* gdbarch.c, gdbarch.h: Regenerated.
* solib-svr4.c (enable_break): Call it, instead of accessing
tmp_bfd->start_address directly.
@
text
@d1039 1
a1039 2
	load_addr = (read_pc ()
                     - gdbarch_bfd_entry_point (current_gdbarch, tmp_bfd));
@


1.35.2.2
log
@* solib-svr4.c (bfd_lookup_symbol): New SECT_FLAGS argument.
(enable_break): Pass SEC_CODE as the SECT_FLAGS argument to
bfd_lookup_symbol, since we only want symbols in code sections.
(look_for_base): Pass zero as the SECT_FLAGS argument to
bfd_lookup_symbol, since we're not concerned about which section
the symbol is in.
@
text
@d180 1
a180 1
static CORE_ADDR bfd_lookup_symbol (bfd *, char *, flagword);
d190 1
a190 1
   CORE_ADDR bfd_lookup_symbol (bfd *abfd, char *symname, flagword sect_flags)
a198 3
   If SECT_FLAGS is non-zero, only match symbols in sections whose
   flags include all those in SECT_FLAGS.

d204 1
a204 1
bfd_lookup_symbol (bfd *abfd, char *symname, flagword sect_flags)
d225 1
a225 2
	  if (STREQ (sym->name, symname)
              && (sym->section->flags & sect_flags) == sect_flags)
d252 1
a252 3

	  if (STREQ (sym->name, symname)
              && (sym->section->flags & sect_flags) == sect_flags)
d358 1
a358 1
      address = bfd_lookup_symbol (interp_bfd, *symbolp, 0);
d1064 1
a1064 10
          /* On ABI's that use function descriptors, there are usually
             two linker symbols associated with each C function: one
             pointing at the actual entry point of the machine code,
             and one pointing at the function's descriptor.  The
             latter symbol has the same name as the C function.

             What we're looking for here is the machine code entry
             point, so we are only interested in symbols in code
             sections.  */
	  sym_addr = bfd_lookup_symbol (tmp_bfd, *bkpt_namep, SEC_CODE);
@


1.34
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_push_return_address): Make static.
	(xstormy16_save_dummy_frame_tos): Make static.
	(_initialize_xstormy16_tdep): Add declaration.
	* vax-tdep.c (_initialize_vax_tdep): Add declaration.
	* v850-tdep.c: Make local functions static.
	(_initialize_v850_tdep): Add declaration.
	* sparc-tdep.c: Make local functions static.
	(_initialize_sparc_tdep): Add declaration.
	* sh-tdep.c: Make local functions static.
	(_initialize_sh_tdep): Add declaration.
	* sh3-rom.c (_initialize_sh3_rom): Add declaration.
	* s390-tdep.c: Make local functions static.
	(_initialize_s390_tdep): Add declaration.
	* dbxread.c (find_stab_function_addr): Make static.
	* ppc-bdm.c (_initialize_bdm_ppc): Add declaration.
	* ocd.c (_initialize_remote_ocd): Add declaration.
	* dink32-rom.c (_initialize_dink32_rom): Add declaration.
	* ppcbug-rom.c (_initialize_ppcbug_rom): Add declaration.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Add declaration.
	* ns32knbsd-tdep.c (_initialize_ns32knbsd_tdep): Add declaration.
	* mips-tdep.c (_initialize_mips_tdep): Add declaration.
	* remote-array.c (_initialize_array): Add declaration.
	(_initialize_remote_monitors): Add declaration.
	* remote-mips.c: Make local functions static.
	(_initialize_remote_mips): Add declaration.
	* mcore-tdep.c: Make all local functions static.
	(_initialize_mcore_tdep): Add declaration.
	* dbug-rom.c (_initialize_dbug_rom): Add declaration.
	* abug-rom.c (_initialize_abug_rom): Add declaration.
	* rom68k-rom.c (_initialize_rom68k): Add declaration.
	* cpu32bug-rom.c (_initialize_cpu32bug_rom): Add declaration.
	* m68k-tdep.c (_initialize_m68k_tdep): Add declaration.
	* remote-est.c (_initialize_est): Add declaration.
	* m68hc11-tdep.c (_initialize_m68hc11_tdep): Add declaration.
	(m68hc11_call_dummy_address): Make static.
	* ia64-tdep.c: Make local functions static.
	(_initialize_ia64_tdep): Add declaration.
	* solib-legacy.c (_initialize_svr4_lm): Add declaration.
	* monitor.c (monitor_wait_filter): Make static.
	(_initialize_remote_monitors): Add declaration.
	* remote-hms.c (_initialize_remote_hms): Add declaration.
	* remote-e7000.c (fetch_regs_from_dump): Make static.
	(expect_n): Make static.
	(_initialize_remote_e7000): Add declaration.
	* ser-e7kpc.c: Always include "defs.h".
	(_initialize_ser_e7000pc): Add declaration.
	* h8300-tdep.c (_initialize_h8300_tdep): Add declaration.
	* cris-tdep.c: Make all but one function static.
	(_initialize_cris_tdep): Add declaration.
	* solib-svr4.c (_initialize_svr4_solib): Add declaration.
	* solib.c (update_solib_list): Make static.
	(_initialize_solib): Add declaration.
	* avr-tdep.c (avr_breakpoint_from_pc): Make static.
	(_initialize_avr_tdep): Add declaration.
	* remote-rdi.c (voiddummy): Make static.
	(_initialize_remote_rdi): Add declaration.
	* arm-tdep.c (_initialize_arm_tdep): Add declaration.
	* remote-rdp.c (send_rdp): Make static.
	(_initialize_remote_rdp): Add declaration.
	* alpha-tdep.c (_initialize_alpha_tdep): Add declaration.
@
text
@d84 11
@


1.33
log
@2003-06-01  Andrew Cagney  <cagney@@redhat.com>

	* solib-irix.c (extract_mips_address): Inline extract_address,
	replacing it with extract_signed_integer.
	* solib-svr4.c (SOLIB_EXTRACT_ADDRESS): Ditto.
	(LM_NAME, IGNORE_FIRST_LINK_MAP_ENTRY): Ditto.
	(first_link_map_member, open_symbol_file_object): Ditto.
	(svr4_fetch_objfile_link_map, svr4_fetch_objfile_link_map): Ditto.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS): Ditto.
	(LM_NEXT, LM_NAME): Ditto.
@
text
@d1458 2
@


1.32
log
@	* solib-svr4.c (svr4_have_link_map_offsets): New function.
	(locate_base): Return early if there aren't any link map offsets.
	(svr4_solib_create_inferior_hook): Warn if shared library support
	is unavailable.
@
text
@d108 7
a114 5
/* Macro to extract an address from a solib structure.
   When GDB is configured for some 32-bit targets (e.g. Solaris 2.7
   sparc), BFD is configured to handle 64-bit targets, so CORE_ADDR is
   64 bits.  We have to extract only the significant bits of addresses
   to get the right address when accessing the core file BFD.  */
d117 1
a117 1
	extract_address (&(MEMBER), sizeof (MEMBER))
d137 3
a139 1
  return extract_address (so->lm_info->lm + lmo->l_next_offset, lmo->l_next_size);
d147 3
a149 1
  return extract_address (so->lm_info->lm + lmo->l_name_offset, lmo->l_name_size);
d157 3
a159 2
  return extract_address (so->lm_info->lm + lmo->l_prev_offset,
                          lmo->l_prev_size) == 0;
d597 2
a598 1
  lm = extract_address (r_map_buf, lmo->r_map_size);
d656 3
a658 2
  /* Convert the address to host format.  */
  l_name = extract_address (l_name_buf, lmo->l_name_size);
d832 3
a834 3
      /* Extract this object's name.  */
      name_address = extract_address (l_name_buf,
				      lmo->l_name_size);
d855 4
a858 3
      /* Not the file we wanted, continue checking.  */
      lm = extract_address (objfile_lm_info.lm + lmo->l_next_offset,
			    lmo->l_next_size);
@


1.32.8.1
log
@* solib-svr4.c (bfd_lookup_symbol): New SECT_FLAGS argument.
(enable_break): Pass SEC_CODE as the SECT_FLAGS argument to
bfd_lookup_symbol, since we only want symbols in code sections.
(look_for_base): Pass zero as the SECT_FLAGS argument to
bfd_lookup_symbol, since we're not concerned about which section
the symbol is in.
@
text
@d162 1
a162 1
static CORE_ADDR bfd_lookup_symbol (bfd *, char *, flagword);
d172 1
a172 1
   CORE_ADDR bfd_lookup_symbol (bfd *abfd, char *symname, flagword sect_flags)
a180 3
   If SECT_FLAGS is non-zero, only match symbols in sections whose
   flags include all those in SECT_FLAGS.

d186 1
a186 1
bfd_lookup_symbol (bfd *abfd, char *symname, flagword sect_flags)
d207 1
a207 2
	  if (STREQ (sym->name, symname)
              && (sym->section->flags & sect_flags) == sect_flags)
d234 1
a234 3

	  if (STREQ (sym->name, symname)
              && (sym->section->flags & sect_flags) == sect_flags)
d340 1
a340 1
      address = bfd_lookup_symbol (interp_bfd, *symbolp, 0);
d1042 1
a1042 10
          /* On ABI's that use function descriptors, there are usually
             two linker symbols associated with each C function: one
             pointing at the actual entry point of the machine code,
             and one pointing at the function's descriptor.  The
             latter symbol has the same name as the C function.

             What we're looking for here is the machine code entry
             point, so we are only interested in symbols in code
             sections.  */
	  sym_addr = bfd_lookup_symbol (tmp_bfd, *bkpt_namep, SEC_CODE);
@


1.32.8.2
log
@* solib-svr4.c (solib_break_names): Recognize the 64-bit PowerPC
Linux entry point symbols for _dl_debug_state, too.
@
text
@a81 1
  "._dl_debug_state",
@


1.32.8.3
log
@* gdbarch.sh (gdbarch_bfd_entry_point): New gdbarch method.
* arch-utils.c (generic_bfd_entry_point): New function.
* arch-utils.h (generic_bfd_entry_point): New declaration.
* gdbarch.c, gdbarch.h: Regenerated.
* solib-svr4.c (enable_break): Call it, instead of accessing
tmp_bfd->start_address directly.
@
text
@d1025 1
a1025 2
	load_addr = (read_pc ()
                     - generic_bfd_entry_point (current_gdbarch, tmp_bfd));
@


1.32.8.4
log
@Revert patch for revision.
@
text
@d1025 2
a1026 1
	load_addr = read_pc () - tmp_bfd->start_address;
@


1.32.8.5
log
@* gdbarch.sh (gdbarch_bfd_entry_point): New gdbarch method.
* arch-utils.c (generic_bfd_entry_point): New function.
* arch-utils.h (generic_bfd_entry_point): New declaration.
* gdbarch.c, gdbarch.h: Regenerated.
* solib-svr4.c (enable_break): Call it, instead of accessing
tmp_bfd->start_address directly.
@
text
@d1025 1
a1025 2
	load_addr = (read_pc ()
                     - gdbarch_bfd_entry_point (current_gdbarch, tmp_bfd));
@


1.32.4.1
log
@Patch from Will Schmidt <willschm@@us.ibm.com>:

These changes enable support of PPC64 architecture.
* config/powerpc/ppc64linux.mh: New file.
* config/powerpc/ppc64linux.mt: New file.
* config/powerpc/tm-ppc64linux.h: New file.
* ppc64-linux-tdep.c: New file.
* configure.host: Add clause for powerpc64-*-linux*
* configure.tgt: Add clause for powerpc64-*-linux*
* elfread.c (record_minimal_symbol_and_info): If
DROP_TEXT_NAME_PREFIX_CHAR is #defined, then drop a leading
instance of that char from the names of text symbols.
(elf_symtab_read): If SKIP_DATA_IN_OPD is #defined, ignore data
symbols in the .opd section.
* ppc-linux-nat.c (PTRACE_XFER_TYPE): Change the default for this
to 'long'.
(PPC_PTRACE_POKEUSR_3264, PPC_PTRACE_PEEKUSR_3264,
PPC_PTRACE_POKEDATA_3264, PPC_PTRACE_PEEKDATA_3264): Provide
default definitions for these.
(ARCH64): New macro.
(ppc_wordsize_pid): New function.
(kernel_u_size): Handle 64-bit case.
(ppc_register_u_addr): Same.
(fetch_register): Use the *_3264 requests when
debugging a 64-bit process from a 32-bit GDB.
(store_register): Same.
(GDB_MAX_ALLOCA, child_xfer_memory, udot_info): Copied from
infptrace.c.
(_initialize_ppc_linux_nat): New function, to register our copy of
the udot_info command.
* ppc-linux-tdep.c (TDEP): New macro.
(ppc64_linux_svr4_fetch_link_map_offsets): New function.
(read_memory_addr): Copied from rs6000-tdep.c.
(ppc64_linux_convert_from_func_ptr_addr): New function.
* rs6000-tdep.c (skip_prologue): Recognize more instructions for
saving the 'lr' and 'cr' registers; don't just pre-emptively mask
in the 'st' opcode as soon as we see an 'mflr' or 'mfcr' opcode.
Recognize more instructions for updating the stack pointer, and
loading the TOC pointer.
(registers_powerpc64, registers_a35): New register tables.
(rs6000_gdbarch_init): Register the 64-bit solib functions.
* solib-svr4.c (solib_break_names): If SOLIB_BREAK_NAME is
#defined, include an entry for it.
(enable_break): Call CONVERT_FROM_FUNC_PTR_ADDR when trying to
guess the linker's base address.
* config/powerpc/tm-linux.h
(ppc64_linux_svr4_fetch_link_map_offsets,
ppc64_linux_convert_from_func_ptr_addr): New declarations.
@
text
@a78 3
#if defined (SOLIB_BREAK_NAME)
  SOLIB_BREAK_NAME,
#endif
d1018 1
a1018 1
	load_addr = read_pc () - CONVERT_FROM_FUNC_PTR_ADDR(tmp_bfd->start_address);
@


1.31
log
@2003-04-08  Elena Zannoni  <ezannoni@@redhat.com>

        * infrun.c (stop_soon): Rename from stop_soon_quietly.
	(struct inferior_status): Rename stop_soon_quietly field to stop_soon.
	(clear_proceed_status): Rename stop_soon_quietly to stop_soon.
	(start_remote): Ditto.
	(handle_inferior_event): Ditto.
	(save_inferior_status): Ditto.
	(restore_inferior_status): Ditto.
	* infcmd.c (attach_command): Ditto.
	* fork-child.c (startup_inferior): Ditto.
        * inferior.h (stop_soon): Rename from stop_soon_quietly.
	* alpha-tdep.c (heuristic_proc_start): Ditto.
	* mips-tdep.c (heuristic_proc_start): Ditto.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Ditto.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Ditto.
	* solib-osf.c (osf_solib_create_inferior_hook): Ditto.
	* solib-irix.c (irix_solib_create_inferior_hook): Ditto.
	* remote-vx.c (vx_create_inferior): Ditto.
@
text
@d46 1
d546 2
a547 1
     section for ELF executables.  */
d549 1
a549 1
  if (debug_base == 0)
d1278 7
d1402 14
@


1.30
log
@2003-04-08  Elena Zannoni  <ezannoni@@redhat.com>

	* infrun.c (stop_soon_quietly): Make it an enum, to better
	override the default behavior of handle_inferior_event.
	(clear_proceed_status): Update uses of stop_soon_quietly to
	reflect that it is now an enum.
	(start_remote): Ditto.
	(handle_inferior_event): Change logic a bit if stop_soon_quietly
	is set to handle the new GNU/Linux kernel behavior for
	attach/sigstop.  Update uses of stop_soon_quietly.
	* inferior.h (enum stop_kind): New enum.
	* infcmd.c (attach_command): Use STOP_QUIETLY_NO_SIGSTOP.
	Reset normal handle_inferior_event behavior, afterwards.
	* fork-child.c (startup_inferior): Update.
	* alpha-tdep.c (heuristic_proc_start): Update.
	* solib-svr4.c (svr4_solib_create_inferior_hook): Update.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Update.
	* solib-osf.c (osf_solib_create_inferior_hook): Update.
	* solib-irix.c (irix_solib_create_inferior_hook): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* mips-tdep.c (heuristic_proc_start): Update.
@
text
@d1293 1
a1293 1
  stop_soon_quietly = STOP_QUIETLY;
d1301 1
a1301 1
  stop_soon_quietly = NO_STOP_QUIETLY;
@


1.29
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@d1293 1
a1293 1
  stop_soon_quietly = 1;
d1301 1
a1301 1
  stop_soon_quietly = 0;
@


1.29.14.1
log
@Merge with mainline.
@
text
@d1293 1
a1293 1
  stop_soon = STOP_QUIETLY;
d1301 1
a1301 1
  stop_soon = NO_STOP_QUIETLY;
@


1.28
log
@Add DT_MIPS_RLD_MAP case for 64-bit targets.
@
text
@d200 1
a200 1
      back_to = make_cleanup (xfree, (PTR) symbol_table);
d227 1
a227 1
      back_to = make_cleanup (xfree, (PTR) symbol_table);
@


1.27
log
@2002-10-21  Elena Zannoni  <ezannoni@@redhat.com>

        * solib-svr4.c (svr4_fetch_objfile_link_map): New function.
        * solib-svr4.h (svr4_fetch_objfile_link_map): Export.
@
text
@d449 1
d451 1
a451 1
	      pbuf = alloca (TARGET_PTR_BIT / HOST_CHAR_BIT);
d456 1
a456 1
	      if (target_read_memory (dyn_ptr, pbuf, sizeof (pbuf)))
d458 1
a458 1
	      return extract_unsigned_integer (pbuf, sizeof (pbuf));
d480 14
@


1.26
log
@* solib-svr4.c (init_fetch_link_map_offsets): Simply return
legacy_fetch_link_map_offsets.  Adjust comment to reflect reality
after Andrew's 2002-06-08 gdbarch change.
@
text
@d765 71
@


1.26.10.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a764 71
/* Get the address of the link_map for a given OBJFILE.  Loop through
   the link maps, and return the address of the one corresponding to
   the given objfile.  Note that this function takes into account that
   objfile can be the main executable, not just a shared library.  The
   main executable has always an empty name field in the linkmap.  */

CORE_ADDR
svr4_fetch_objfile_link_map (struct objfile *objfile)
{
  CORE_ADDR lm;

  if ((debug_base = locate_base ()) == 0)
    return 0;   /* failed somehow... */

  /* Position ourselves on the first link map.  */
  lm = first_link_map_member ();  
  while (lm)
    {
      /* Get info on the layout of the r_debug and link_map structures. */
      struct link_map_offsets *lmo = SVR4_FETCH_LINK_MAP_OFFSETS ();
      int errcode;
      char *buffer;
      struct lm_info objfile_lm_info;
      struct cleanup *old_chain;
      CORE_ADDR name_address;
      char *l_name_buf = xmalloc (lmo->l_name_size);
      old_chain = make_cleanup (xfree, l_name_buf);

      /* Set up the buffer to contain the portion of the link_map
         structure that gdb cares about.  Note that this is not the
         whole link_map structure.  */
      objfile_lm_info.lm = xmalloc (lmo->link_map_size);
      make_cleanup (xfree, objfile_lm_info.lm);
      memset (objfile_lm_info.lm, 0, lmo->link_map_size);

      /* Read the link map into our internal structure.  */
      read_memory (lm, objfile_lm_info.lm, lmo->link_map_size);

      /* Read address of name from target memory to GDB.  */
      read_memory (lm + lmo->l_name_offset, l_name_buf, lmo->l_name_size);

      /* Extract this object's name.  */
      name_address = extract_address (l_name_buf,
				      lmo->l_name_size);
      target_read_string (name_address, &buffer,
      			  SO_NAME_MAX_PATH_SIZE - 1, &errcode);
      make_cleanup (xfree, buffer);
      if (errcode != 0)
    	{
	  warning ("svr4_fetch_objfile_link_map: Can't read pathname for load map: %s\n",
  		   safe_strerror (errcode));
  	}
      else
  	{
	  /* Is this the linkmap for the file we want?  */
	  /* If the file is not a shared library and has no name,
	     we are sure it is the main executable, so we return that.  */
	  if ((buffer && strcmp (buffer, objfile->name) == 0)
              || (!(objfile->flags & OBJF_SHARED) && (strcmp (buffer, "") == 0)))
  	    {
    	      do_cleanups (old_chain);
    	      return lm;
      	    }
  	}
      /* Not the file we wanted, continue checking.  */
      lm = extract_address (objfile_lm_info.lm + lmo->l_next_offset,
			    lmo->l_next_size);
      do_cleanups (old_chain);
    }
  return 0;
}
@


1.26.10.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 3
a4 3

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
   2000, 2001, 2003 Free Software Foundation, Inc.
a39 3
#include "bfd-target.h"
#include "exec.h"

a45 1
static int svr4_have_link_map_offsets (void);
a82 11

  /* On the 64-bit PowerPC, the linker symbol with the same name as
     the C function points to a function descriptor, not to the entry
     point.  The linker symbol whose name is the C function name
     prefixed with a '.' points to the function's entry point.  So
     when we look through this table, we ignore symbols that point
     into the data section (thus skipping the descriptor's symbol),
     and eventually try this one, giving us the real entry point
     address.  */
  "._dl_debug_state",

d107 5
a111 7
/* Macro to extract an address from a solib structure.  When GDB is
   configured for some 32-bit targets (e.g. Solaris 2.7 sparc), BFD is
   configured to handle 64-bit targets, so CORE_ADDR is 64 bits.  We
   have to extract only the significant bits of addresses to get the
   right address when accessing the core file BFD.

   Assume that the address is unsigned.  */
d114 1
a114 1
	extract_unsigned_integer (&(MEMBER), sizeof (MEMBER))
d134 1
a134 3
  /* Assume that the address is unsigned.  */
  return extract_unsigned_integer (so->lm_info->lm + lmo->l_next_offset,
				   lmo->l_next_size);
d142 1
a142 3
  /* Assume that the address is unsigned.  */
  return extract_unsigned_integer (so->lm_info->lm + lmo->l_name_offset,
				   lmo->l_name_size);
d150 2
a151 3
  /* Assume that the address is unsigned.  */
  return extract_unsigned_integer (so->lm_info->lm + lmo->l_prev_offset,
				   lmo->l_prev_size) == 0;
d161 1
a161 1
static CORE_ADDR bfd_lookup_symbol (bfd *, char *, flagword);
d171 1
a171 1
   CORE_ADDR bfd_lookup_symbol (bfd *abfd, char *symname, flagword sect_flags)
a179 3
   If SECT_FLAGS is non-zero, only match symbols in sections whose
   flags include all those in SECT_FLAGS.

d185 1
a185 1
bfd_lookup_symbol (bfd *abfd, char *symname, flagword sect_flags)
d200 1
a200 1
      back_to = make_cleanup (xfree, symbol_table);
d206 1
a206 2
	  if (strcmp (sym->name, symname) == 0
              && (sym->section->flags & sect_flags) == sect_flags)
d227 1
a227 1
      back_to = make_cleanup (xfree, symbol_table);
d233 1
a233 3

	  if (strcmp (sym->name, symname) == 0
              && (sym->section->flags & sect_flags) == sect_flags)
d339 1
a339 1
      address = bfd_lookup_symbol (interp_bfd, *symbolp, 0);
d400 1
a400 1
  struct bfd_section *dyninfo_sect;
a448 1
	      int pbuf_size = TARGET_PTR_BIT / HOST_CHAR_BIT;
d450 1
a450 1
	      pbuf = alloca (pbuf_size);
d455 1
a455 1
	      if (target_read_memory (dyn_ptr, pbuf, pbuf_size))
d457 1
a457 1
	      return extract_unsigned_integer (pbuf, pbuf_size);
a479 14
	  else if (dyn_tag == DT_MIPS_RLD_MAP)
	    {
	      char *pbuf;
	      int pbuf_size = TARGET_PTR_BIT / HOST_CHAR_BIT;

	      pbuf = alloca (pbuf_size);
	      /* DT_MIPS_RLD_MAP contains a pointer to the address
		 of the dynamic link structure.  */
	      dyn_ptr = bfd_h_get_64 (exec_bfd, 
				      (bfd_byte *) x_dynp->d_un.d_ptr);
	      if (target_read_memory (dyn_ptr, pbuf, pbuf_size))
		return 0;
	      return extract_unsigned_integer (pbuf, pbuf_size);
	    }
d530 1
a530 2
     section for ELF executables.  There's no point in doing any of this
     though if we don't have some link map offsets to work with.  */
d532 1
a532 1
  if (debug_base == 0 && svr4_have_link_map_offsets ())
d573 1
a573 2
  /* Assume that the address is unsigned.  */
  lm = extract_unsigned_integer (r_map_buf, lmo->r_map_size);
d631 2
a632 3
  /* Convert the address to host format.  Assume that the address is
     unsigned.  */
  l_name = extract_unsigned_integer (l_name_buf, lmo->l_name_size);
d806 3
a808 3
      /* Extract this object's name.  Assume that the address is
         unsigned.  */
      name_address = extract_unsigned_integer (l_name_buf, lmo->l_name_size);
d829 3
a831 4
      /* Not the file we wanted, continue checking.  Assume that the
         address is unsigned.  */
      lm = extract_unsigned_integer (objfile_lm_info.lm + lmo->l_next_offset,
				     lmo->l_next_size);
a869 18
/* Given an executable's ABFD and target, compute the entry-point
   address.  */

static CORE_ADDR
exec_entry_point (struct bfd *abfd, struct target_ops *targ)
{
  /* KevinB wrote ... for most targets, the address returned by
     bfd_get_start_address() is the entry point for the start
     function.  But, for some targets, bfd_get_start_address() returns
     the address of a function descriptor from which the entry point
     address may be extracted.  This address is extracted by
     gdbarch_convert_from_func_ptr_addr().  The method
     gdbarch_convert_from_func_ptr_addr() is the merely the identify
     function for targets which don't use function descriptors.  */
  return gdbarch_convert_from_func_ptr_addr (current_gdbarch,
					     bfd_get_start_address (abfd),
					     targ);
}
a942 1
      struct target_ops *tmp_bfd_target;
a977 5
      /* Now convert the TMP_BFD into a target.  That way target, as
         well as BFD operations can be used.  Note that closing the
         target will also close the underlying bfd.  */
      tmp_bfd_target = target_bfd_reopen (tmp_bfd);

d1001 1
a1001 2
	load_addr = (read_pc ()
		     - exec_entry_point (tmp_bfd, tmp_bfd_target));
d1025 1
a1025 10
          /* On ABI's that use function descriptors, there are usually
             two linker symbols associated with each C function: one
             pointing at the actual entry point of the machine code,
             and one pointing at the function's descriptor.  The
             latter symbol has the same name as the C function.

             What we're looking for here is the machine code entry
             point, so we are only interested in symbols in code
             sections.  */
	  sym_addr = bfd_lookup_symbol (tmp_bfd, *bkpt_namep, SEC_CODE);
d1030 2
a1031 3
      /* We're done with both the temporary bfd and target.  Remember,
         closing the target closes the underlying bfd.  */
      target_close (tmp_bfd_target, 0);
d1150 1
a1150 1
      && (exec_entry_point (exec_bfd, &exec_ops) != pc))
d1182 1
a1182 1
      displacement = pc - exec_entry_point (exec_bfd, &exec_ops);
a1260 7
  if (!svr4_have_link_map_offsets ())
    {
      warning ("no shared library support for this OS / ABI");
      return;

    }

d1278 1
a1278 1
  stop_soon = STOP_QUIETLY;
d1286 1
a1286 1
  stop_soon = NO_STOP_QUIETLY;
a1379 14
/* Return 1 if a link map offset fetcher has been defined, 0 otherwise.  */
static int
svr4_have_link_map_offsets (void)
{
  struct link_map_offsets *(*flmo)(void) =
    gdbarch_data (current_gdbarch, fetch_link_map_offsets_gdbarch_data);
  if (flmo == NULL
      || (flmo == legacy_fetch_link_map_offsets 
          && legacy_svr4_fetch_link_map_offsets_hook == NULL))
    return 0;
  else
    return 1;
}

a1409 2
extern initialize_file_ftype _initialize_svr4_solib; /* -Wmissing-prototypes */

d1414 1
a1414 1
    register_gdbarch_data (init_fetch_link_map_offsets);
@


1.26.8.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@a764 71
/* Get the address of the link_map for a given OBJFILE.  Loop through
   the link maps, and return the address of the one corresponding to
   the given objfile.  Note that this function takes into account that
   objfile can be the main executable, not just a shared library.  The
   main executable has always an empty name field in the linkmap.  */

CORE_ADDR
svr4_fetch_objfile_link_map (struct objfile *objfile)
{
  CORE_ADDR lm;

  if ((debug_base = locate_base ()) == 0)
    return 0;   /* failed somehow... */

  /* Position ourselves on the first link map.  */
  lm = first_link_map_member ();  
  while (lm)
    {
      /* Get info on the layout of the r_debug and link_map structures. */
      struct link_map_offsets *lmo = SVR4_FETCH_LINK_MAP_OFFSETS ();
      int errcode;
      char *buffer;
      struct lm_info objfile_lm_info;
      struct cleanup *old_chain;
      CORE_ADDR name_address;
      char *l_name_buf = xmalloc (lmo->l_name_size);
      old_chain = make_cleanup (xfree, l_name_buf);

      /* Set up the buffer to contain the portion of the link_map
         structure that gdb cares about.  Note that this is not the
         whole link_map structure.  */
      objfile_lm_info.lm = xmalloc (lmo->link_map_size);
      make_cleanup (xfree, objfile_lm_info.lm);
      memset (objfile_lm_info.lm, 0, lmo->link_map_size);

      /* Read the link map into our internal structure.  */
      read_memory (lm, objfile_lm_info.lm, lmo->link_map_size);

      /* Read address of name from target memory to GDB.  */
      read_memory (lm + lmo->l_name_offset, l_name_buf, lmo->l_name_size);

      /* Extract this object's name.  */
      name_address = extract_address (l_name_buf,
				      lmo->l_name_size);
      target_read_string (name_address, &buffer,
      			  SO_NAME_MAX_PATH_SIZE - 1, &errcode);
      make_cleanup (xfree, buffer);
      if (errcode != 0)
    	{
	  warning ("svr4_fetch_objfile_link_map: Can't read pathname for load map: %s\n",
  		   safe_strerror (errcode));
  	}
      else
  	{
	  /* Is this the linkmap for the file we want?  */
	  /* If the file is not a shared library and has no name,
	     we are sure it is the main executable, so we return that.  */
	  if ((buffer && strcmp (buffer, objfile->name) == 0)
              || (!(objfile->flags & OBJF_SHARED) && (strcmp (buffer, "") == 0)))
  	    {
    	      do_cleanups (old_chain);
    	      return lm;
      	    }
  	}
      /* Not the file we wanted, continue checking.  */
      lm = extract_address (objfile_lm_info.lm + lmo->l_next_offset,
			    lmo->l_next_size);
      do_cleanups (old_chain);
    }
  return 0;
}
@


1.26.8.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a448 1
	      int pbuf_size = TARGET_PTR_BIT / HOST_CHAR_BIT;
d450 1
a450 1
	      pbuf = alloca (pbuf_size);
d455 1
a455 1
	      if (target_read_memory (dyn_ptr, pbuf, pbuf_size))
d457 1
a457 1
	      return extract_unsigned_integer (pbuf, pbuf_size);
a478 14
	    }
	  else if (dyn_tag == DT_MIPS_RLD_MAP)
	    {
	      char *pbuf;
	      int pbuf_size = TARGET_PTR_BIT / HOST_CHAR_BIT;

	      pbuf = alloca (pbuf_size);
	      /* DT_MIPS_RLD_MAP contains a pointer to the address
		 of the dynamic link structure.  */
	      dyn_ptr = bfd_h_get_64 (exec_bfd, 
				      (bfd_byte *) x_dynp->d_un.d_ptr);
	      if (target_read_memory (dyn_ptr, pbuf, pbuf_size))
		return 0;
	      return extract_unsigned_integer (pbuf, pbuf_size);
@


1.26.8.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d200 1
a200 1
      back_to = make_cleanup (xfree, symbol_table);
d227 1
a227 1
      back_to = make_cleanup (xfree, symbol_table);
@


1.26.8.4
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a45 1
static int svr4_have_link_map_offsets (void);
d545 1
a545 2
     section for ELF executables.  There's no point in doing any of this
     though if we don't have some link map offsets to work with.  */
d547 1
a547 1
  if (debug_base == 0 && svr4_have_link_map_offsets ())
a1275 7
  if (!svr4_have_link_map_offsets ())
    {
      warning ("no shared library support for this OS / ABI");
      return;

    }

d1293 1
a1293 1
  stop_soon = STOP_QUIETLY;
d1301 1
a1301 1
  stop_soon = NO_STOP_QUIETLY;
a1392 14
}

/* Return 1 if a link map offset fetcher has been defined, 0 otherwise.  */
static int
svr4_have_link_map_offsets (void)
{
  struct link_map_offsets *(*flmo)(void) =
    gdbarch_data (current_gdbarch, fetch_link_map_offsets_gdbarch_data);
  if (flmo == NULL
      || (flmo == legacy_fetch_link_map_offsets 
          && legacy_svr4_fetch_link_map_offsets_hook == NULL))
    return 0;
  else
    return 1;
@


1.26.8.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a83 11

  /* On the 64-bit PowerPC, the linker symbol with the same name as
     the C function points to a function descriptor, not to the entry
     point.  The linker symbol whose name is the C function name
     prefixed with a '.' points to the function's entry point.  So
     when we look through this table, we ignore symbols that point
     into the data section (thus skipping the descriptor's symbol),
     and eventually try this one, giving us the real entry point
     address.  */
  "._dl_debug_state",

d108 5
a112 7
/* Macro to extract an address from a solib structure.  When GDB is
   configured for some 32-bit targets (e.g. Solaris 2.7 sparc), BFD is
   configured to handle 64-bit targets, so CORE_ADDR is 64 bits.  We
   have to extract only the significant bits of addresses to get the
   right address when accessing the core file BFD.

   Assume that the address is unsigned.  */
d115 1
a115 1
	extract_unsigned_integer (&(MEMBER), sizeof (MEMBER))
d135 1
a135 3
  /* Assume that the address is unsigned.  */
  return extract_unsigned_integer (so->lm_info->lm + lmo->l_next_offset,
				   lmo->l_next_size);
d143 1
a143 3
  /* Assume that the address is unsigned.  */
  return extract_unsigned_integer (so->lm_info->lm + lmo->l_name_offset,
				   lmo->l_name_size);
d151 2
a152 3
  /* Assume that the address is unsigned.  */
  return extract_unsigned_integer (so->lm_info->lm + lmo->l_prev_offset,
				   lmo->l_prev_size) == 0;
d590 1
a590 2
  /* Assume that the address is unsigned.  */
  lm = extract_unsigned_integer (r_map_buf, lmo->r_map_size);
d648 2
a649 3
  /* Convert the address to host format.  Assume that the address is
     unsigned.  */
  l_name = extract_unsigned_integer (l_name_buf, lmo->l_name_size);
d823 3
a825 3
      /* Extract this object's name.  Assume that the address is
         unsigned.  */
      name_address = extract_unsigned_integer (l_name_buf, lmo->l_name_size);
d846 3
a848 4
      /* Not the file we wanted, continue checking.  Assume that the
         address is unsigned.  */
      lm = extract_unsigned_integer (objfile_lm_info.lm + lmo->l_next_offset,
				     lmo->l_next_size);
a1446 2

extern initialize_file_ftype _initialize_svr4_solib; /* -Wmissing-prototypes */
@


1.26.8.6
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d1475 1
a1475 1
    register_gdbarch_data (init_fetch_link_map_offsets);
@


1.26.8.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d180 1
a180 1
static CORE_ADDR bfd_lookup_symbol (bfd *, char *, flagword);
d190 1
a190 1
   CORE_ADDR bfd_lookup_symbol (bfd *abfd, char *symname, flagword sect_flags)
a198 3
   If SECT_FLAGS is non-zero, only match symbols in sections whose
   flags include all those in SECT_FLAGS.

d204 1
a204 1
bfd_lookup_symbol (bfd *abfd, char *symname, flagword sect_flags)
d225 1
a225 2
	  if (STREQ (sym->name, symname)
              && (sym->section->flags & sect_flags) == sect_flags)
d252 1
a252 3

	  if (STREQ (sym->name, symname)
              && (sym->section->flags & sect_flags) == sect_flags)
d358 1
a358 1
      address = bfd_lookup_symbol (interp_bfd, *symbolp, 0);
d1063 1
a1063 10
          /* On ABI's that use function descriptors, there are usually
             two linker symbols associated with each C function: one
             pointing at the actual entry point of the machine code,
             and one pointing at the function's descriptor.  The
             latter symbol has the same name as the C function.

             What we're looking for here is the machine code entry
             point, so we are only interested in symbols in code
             sections.  */
	  sym_addr = bfd_lookup_symbol (tmp_bfd, *bkpt_namep, SEC_CODE);
@


1.26.8.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d2 3
a4 3

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
   2000, 2001, 2003 Free Software Foundation, Inc.
a39 3
#include "bfd-target.h"
#include "exec.h"

d228 1
a228 1
	  if (strcmp (sym->name, symname) == 0
d257 1
a257 1
	  if (strcmp (sym->name, symname) == 0
d425 1
a425 1
  struct bfd_section *dyninfo_sect;
a913 18
/* Given an executable's ABFD and target, compute the entry-point
   address.  */

static CORE_ADDR
exec_entry_point (struct bfd *abfd, struct target_ops *targ)
{
  /* KevinB wrote ... for most targets, the address returned by
     bfd_get_start_address() is the entry point for the start
     function.  But, for some targets, bfd_get_start_address() returns
     the address of a function descriptor from which the entry point
     address may be extracted.  This address is extracted by
     gdbarch_convert_from_func_ptr_addr().  The method
     gdbarch_convert_from_func_ptr_addr() is the merely the identify
     function for targets which don't use function descriptors.  */
  return gdbarch_convert_from_func_ptr_addr (current_gdbarch,
					     bfd_get_start_address (abfd),
					     targ);
}
a986 1
      struct target_ops *tmp_bfd_target;
a1021 5
      /* Now convert the TMP_BFD into a target.  That way target, as
         well as BFD operations can be used.  Note that closing the
         target will also close the underlying bfd.  */
      tmp_bfd_target = target_bfd_reopen (tmp_bfd);

d1045 1
a1045 2
	load_addr = (read_pc ()
		     - exec_entry_point (tmp_bfd, tmp_bfd_target));
d1083 2
a1084 3
      /* We're done with both the temporary bfd and target.  Remember,
         closing the target closes the underlying bfd.  */
      target_close (tmp_bfd_target, 0);
d1203 1
a1203 1
      && (exec_entry_point (exec_bfd, &exec_ops) != pc))
d1235 1
a1235 1
      displacement = pc - exec_entry_point (exec_bfd, &exec_ops);
@


1.25
log
@* gdbarch.sh (gdbarch_data): Add gdbarch parameter.
* gdbarch.h, gdbarch.c: Regenerate.
* gnu-v3-abi.c: Update copyright.
(vtable_address_point_offset): Update.
(gnuv3_rtti_type): Update.
(gnuv3_baseclass_offset): Update.
* solib-svr4.c (svr4_fetch_link_map_offsets): Update.
(init_fetch_link_map_offsets): Update.
* remote.c (get_remote_state): Update.
@
text
@d1321 8
a1328 6
/* Initialize the architecture specific link_map_offsets fetcher. 
   This is called after <arch>_gdbarch_init() has set up its struct
   gdbarch for the new architecture, so care must be taken to use the
   value set by set_solib_svr4_fetch_link_map_offsets(), above.  We
   do, however, attempt to provide a reasonable alternative (for
   native targets anyway) if the <arch>_gdbarch_init() fails to call
d1334 1
a1334 7
  struct link_map_offsets *(*flmo) =
    gdbarch_data (gdbarch, fetch_link_map_offsets_gdbarch_data);

  if (flmo == NULL)
    return legacy_fetch_link_map_offsets;
  else
    return flmo;
@


1.25.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d1321 6
a1326 8
/* Initialize the architecture-specific link_map_offsets fetcher.
   This is called after <arch>_gdbarch_init() has set up its `struct
   gdbarch' for the new architecture, and is only called if the
   link_map_offsets fetcher isn't already initialized (which is
   usually done by calling set_solib_svr4_fetch_link_map_offsets()
   above in <arch>_gdbarch_init()).  Therefore we attempt to provide a
   reasonable alternative (for native targets anyway) if the
   <arch>_gdbarch_init() fails to call
d1332 7
a1338 1
  return legacy_fetch_link_map_offsets;
@


1.25.4.2
log
@merge from mainline
@
text
@a764 71
/* Get the address of the link_map for a given OBJFILE.  Loop through
   the link maps, and return the address of the one corresponding to
   the given objfile.  Note that this function takes into account that
   objfile can be the main executable, not just a shared library.  The
   main executable has always an empty name field in the linkmap.  */

CORE_ADDR
svr4_fetch_objfile_link_map (struct objfile *objfile)
{
  CORE_ADDR lm;

  if ((debug_base = locate_base ()) == 0)
    return 0;   /* failed somehow... */

  /* Position ourselves on the first link map.  */
  lm = first_link_map_member ();  
  while (lm)
    {
      /* Get info on the layout of the r_debug and link_map structures. */
      struct link_map_offsets *lmo = SVR4_FETCH_LINK_MAP_OFFSETS ();
      int errcode;
      char *buffer;
      struct lm_info objfile_lm_info;
      struct cleanup *old_chain;
      CORE_ADDR name_address;
      char *l_name_buf = xmalloc (lmo->l_name_size);
      old_chain = make_cleanup (xfree, l_name_buf);

      /* Set up the buffer to contain the portion of the link_map
         structure that gdb cares about.  Note that this is not the
         whole link_map structure.  */
      objfile_lm_info.lm = xmalloc (lmo->link_map_size);
      make_cleanup (xfree, objfile_lm_info.lm);
      memset (objfile_lm_info.lm, 0, lmo->link_map_size);

      /* Read the link map into our internal structure.  */
      read_memory (lm, objfile_lm_info.lm, lmo->link_map_size);

      /* Read address of name from target memory to GDB.  */
      read_memory (lm + lmo->l_name_offset, l_name_buf, lmo->l_name_size);

      /* Extract this object's name.  */
      name_address = extract_address (l_name_buf,
				      lmo->l_name_size);
      target_read_string (name_address, &buffer,
      			  SO_NAME_MAX_PATH_SIZE - 1, &errcode);
      make_cleanup (xfree, buffer);
      if (errcode != 0)
    	{
	  warning ("svr4_fetch_objfile_link_map: Can't read pathname for load map: %s\n",
  		   safe_strerror (errcode));
  	}
      else
  	{
	  /* Is this the linkmap for the file we want?  */
	  /* If the file is not a shared library and has no name,
	     we are sure it is the main executable, so we return that.  */
	  if ((buffer && strcmp (buffer, objfile->name) == 0)
              || (!(objfile->flags & OBJF_SHARED) && (strcmp (buffer, "") == 0)))
  	    {
    	      do_cleanups (old_chain);
    	      return lm;
      	    }
  	}
      /* Not the file we wanted, continue checking.  */
      lm = extract_address (objfile_lm_info.lm + lmo->l_next_offset,
			    lmo->l_next_size);
      do_cleanups (old_chain);
    }
  return 0;
}
@


1.25.2.1
log
@merge from trunk
@
text
@d1321 6
a1326 8
/* Initialize the architecture-specific link_map_offsets fetcher.
   This is called after <arch>_gdbarch_init() has set up its `struct
   gdbarch' for the new architecture, and is only called if the
   link_map_offsets fetcher isn't already initialized (which is
   usually done by calling set_solib_svr4_fetch_link_map_offsets()
   above in <arch>_gdbarch_init()).  Therefore we attempt to provide a
   reasonable alternative (for native targets anyway) if the
   <arch>_gdbarch_init() fails to call
d1332 7
a1338 1
  return legacy_fetch_link_map_offsets;
@


1.24
log
@2002-04-05  H.J. Lu  (hjl@@gnu.org)

	* solib-svr4.c (bkpt_names): Add "__start".
@
text
@d1296 1
a1296 1
    gdbarch_data (fetch_link_map_offsets_gdbarch_data);
d1333 1
a1333 1
    gdbarch_data (fetch_link_map_offsets_gdbarch_data);
@


1.23
log
@* solib-svr4.c (svr4_truncate_ptr): New function.
(svr4_relocate_section_addresses): Do the address arithmetic with
the appropriate truncation for target addresses, even when
CORE_ADDR is larger than a target address.
@
text
@d95 1
@


1.22
log
@Fix xcalloc() calls so order of arguments is not reversed.
@
text
@d1231 26
d1261 2
a1262 2
  sec->addr += LM_ADDR (so);
  sec->endaddr += LM_ADDR (so);
d1264 1
@


1.21
log
@Approved by kev@@cygnus.com
ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* coff-solib.c (coff_solib_add): Add new readsyms arg.
	* irix5-nat.c (solib_add): Ditto.
	* osfsolib.c (solib_add): Ditto.
	* pa64solib.c (pa64_solib_add): Ditto.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* solib.c (solib_add): Ditto.
	* somsolib.c (som_solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* coff-solib.h (coff_solib_add): Add new readsyms arg to prototype.
	* pa64solib.c (add_to_solist): Ditto.
	* pa64solib.c (read_dld_descriptor): Ditto.
	* pa64solib.h (pa64_solib_add): Ditto.
	* solib.h (solib_add): Ditto.
	* somsolib.h (som_solib_add): Ditto.
	* config/i386/tm-cygwin.h (child_solib_add): Ditto.

	* coff-solib.c (coff_solib_add):  If readsyms is zero don't read
	symbols but do any other needed work for shared libs.
	* irix5-nat.c: Ditto.
	* osfsolib.c (solib_add): Ditto.
	* solib.c (solib_add): Ditto.
	* win32-nat.c (child_solib_add): Ditto.
	* xcoffsolib.c (solib_add): Ditto.

	* irix5-nat.c (sharedlibrary_command): Pass 1 as readsyms to
	solib_add to force reading of shared library symbols.
	* osfsolib.c (sharedlibrary_command;): Ditto.
	* pa64solib.c (pa64_solib_sharedlibrary_command): Ditto.
	* solib.c (sharedlibrary_command): Ditto.
	* somsolib.c (som_solib_sharedlibrary_command): Ditto.
	* xcoffsolib.c (sharedlibrary_command): Ditto.

	* coff-solib.c (coff_solib_create_inferior_hook): Call solib_add
	unconditionally with auto_solib_add.
	* irix5-nat.c (solib_create_inferior_hook): Ditto.
	* osfsolib.c (solib_create_inferior_hook): Ditto.
	* solib.c (solib_create_inferior_hook): Ditto.
	* solib-osf.c (osf_solib_create_inferior_hook): Ditto.
	* solib-svr4.c (enable_break): Ditto.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Ditto.

	* corelow.c (solib_add_stub): Add auto_solib_add to args passed
	via SOLIB_ADD.
	* sol-thread.c (sol_thread_attach): Ditto.
	* config/rs6000/nm-rs6000.h (SOLIB_ADD): Ditto.

	* infcmd.c (attach_command): Remove auto_solib_add decl.
	Call SOLIB_ADD directly with auto_solib_add.
	* infrun.c (handle_inferior_event): Ditto.

	* coff-solib.h (SOLIB_ADD): Add readsyms arg.
	* pa64solib.h (SOLIB_ADD): Ditto.
	* solib.h (SOLIB_ADD): Ditto.
	* somsolib.h (SOLIB_ADD): Ditto.
	* config/i386/tm-cygwin.h (SOLIB_ADD): Ditto.

	* fork-child.c (clone_and_follow_inferior): Remove unused
	auto_solib_add decl.

	* pa64solib.c (pa64_solib_add): Call add_to_solist with readsyms.
	(read_dld_descriptor): Ditto.
	(pa64_solib_add): Call read_dld_descriptor with	readsyms.
	(pa64_solib_in_dynamic_linker): Ditto.

	* corelow.c (symfile.h): Need this for auto_solib_add declaration.
	* sol-thread.c (symfile.h): Ditto.

Approved by eliz@@is.elta.co.il
doc/ChangeLog entry:

	2001-11-01  Fred Fish  <fnf@@redhat.com>

	* gdbint.texinfo (SOLIB_ADD): Document additional new
	"readsyms" arg.
@
text
@d1113 2
a1114 2
      new_offsets = xcalloc (sizeof (struct section_offsets),
			     symfile_objfile->num_sections);
@


1.20
log
@Split SVR4/SunOS solib support.
@
text
@d912 1
a912 1
	  solib_add (NULL, 0, NULL);
@


1.19
log
@Use gdbarch data mechanism instead of gdbarch swap mechanism to manage
the fetching of architecture specific link map offsets.
@
text
@d1 1
a1 1
/* Handle SunOS and SVR4 shared libraries for GDB, the GNU Debugger.
a23 1
#include "regcache.h"
a24 12

#include <sys/types.h>
#include <signal.h>
#include "gdb_string.h"
#include <sys/param.h>
#include <fcntl.h>

#ifndef SVR4_SHARED_LIBS
 /* SunOS shared libs need the nlist structure.  */
#include <a.out.h>
#include <link.h>
#else
a27 1
#endif
a33 1
#include "command.h"
a34 2
#include "frame.h"
#include "gdb_regex.h"
a35 3
#include "environ.h"
#include "language.h"
#include "gdbcmd.h"
a75 1
#ifdef SVR4_SHARED_LIBS
a84 1
#endif
d88 1
a88 1
#if defined (BKPT_AT_SYMBOL) && defined (SVR4_SHARED_LIBS)
a99 11
/* Symbols which are used to locate the base of the link map structures. */

#ifndef SVR4_SHARED_LIBS
static char *debug_base_symbols[] =
{
  "_DYNAMIC",
  "_DYNAMIC__MGC",
  NULL
};
#endif

a105 1

a116 14
#ifndef SVR4_SHARED_LIBS

/* NOTE: converted the macros LM_ADDR, LM_NEXT, LM_NAME and
   IGNORE_FIRST_LINK_MAP_ENTRY into functions (see below).
   MVS, June 2000  */

static struct link_dynamic dynamic_copy;
static struct link_dynamic_2 ld_2_copy;
static struct ld_debug debug_copy;
static CORE_ADDR debug_addr;
static CORE_ADDR flag_addr;

#endif /* !SVR4_SHARED_LIBS */

a143 10
#ifndef SVR4_SHARED_LIBS

static int 
IGNORE_FIRST_LINK_MAP_ENTRY (struct so_list *so)
{
  return 0;
}

#else /* SVR4_SHARED_LIBS */

a152 2
#endif /* !SVR4_SHARED_LIBS */

a159 106
#ifndef SVR4_SHARED_LIBS

/* Allocate the runtime common object file.  */

static void
allocate_rt_common_objfile (void)
{
  struct objfile *objfile;
  struct objfile *last_one;

  objfile = (struct objfile *) xmalloc (sizeof (struct objfile));
  memset (objfile, 0, sizeof (struct objfile));
  objfile->md = NULL;
  obstack_specify_allocation (&objfile->psymbol_cache.cache, 0, 0,
			      xmalloc, xfree);
  obstack_specify_allocation (&objfile->psymbol_obstack, 0, 0, xmalloc,
			      xfree);
  obstack_specify_allocation (&objfile->symbol_obstack, 0, 0, xmalloc,
			      xfree);
  obstack_specify_allocation (&objfile->type_obstack, 0, 0, xmalloc,
			      xfree);
  objfile->name = mstrsave (objfile->md, "rt_common");

  /* Add this file onto the tail of the linked list of other such files. */

  objfile->next = NULL;
  if (object_files == NULL)
    object_files = objfile;
  else
    {
      for (last_one = object_files;
	   last_one->next;
	   last_one = last_one->next);
      last_one->next = objfile;
    }

  rt_common_objfile = objfile;
}

/* Read all dynamically loaded common symbol definitions from the inferior
   and put them into the minimal symbol table for the runtime common
   objfile.  */

static void
solib_add_common_symbols (CORE_ADDR rtc_symp)
{
  struct rtc_symb inferior_rtc_symb;
  struct nlist inferior_rtc_nlist;
  int len;
  char *name;

  /* Remove any runtime common symbols from previous runs.  */

  if (rt_common_objfile != NULL && rt_common_objfile->minimal_symbol_count)
    {
      obstack_free (&rt_common_objfile->symbol_obstack, 0);
      obstack_specify_allocation (&rt_common_objfile->symbol_obstack, 0, 0,
				  xmalloc, xfree);
      rt_common_objfile->minimal_symbol_count = 0;
      rt_common_objfile->msymbols = NULL;
    }

  init_minimal_symbol_collection ();
  make_cleanup_discard_minimal_symbols ();

  while (rtc_symp)
    {
      read_memory (rtc_symp,
		   (char *) &inferior_rtc_symb,
		   sizeof (inferior_rtc_symb));
      read_memory (SOLIB_EXTRACT_ADDRESS (inferior_rtc_symb.rtc_sp),
		   (char *) &inferior_rtc_nlist,
		   sizeof (inferior_rtc_nlist));
      if (inferior_rtc_nlist.n_type == N_COMM)
	{
	  /* FIXME: The length of the symbol name is not available, but in the
	     current implementation the common symbol is allocated immediately
	     behind the name of the symbol. */
	  len = inferior_rtc_nlist.n_value - inferior_rtc_nlist.n_un.n_strx;

	  name = xmalloc (len);
	  read_memory (SOLIB_EXTRACT_ADDRESS (inferior_rtc_nlist.n_un.n_name),
		       name, len);

	  /* Allocate the runtime common objfile if necessary. */
	  if (rt_common_objfile == NULL)
	    allocate_rt_common_objfile ();

	  prim_record_minimal_symbol (name, inferior_rtc_nlist.n_value,
				      mst_bss, rt_common_objfile);
	  xfree (name);
	}
      rtc_symp = SOLIB_EXTRACT_ADDRESS (inferior_rtc_symb.rtc_next);
    }

  /* Install any minimal symbols that have been collected as the current
     minimal symbols for the runtime common objfile.  */

  install_minimal_symbols (rt_common_objfile);
}

#endif /* SVR4_SHARED_LIBS */


#ifdef SVR4_SHARED_LIBS

a485 2
#endif /* SVR4_SHARED_LIBS */

a525 24

#ifndef SVR4_SHARED_LIBS

  struct minimal_symbol *msymbol;
  CORE_ADDR address = 0;
  char **symbolp;

  /* For SunOS, we want to limit the search for the debug base symbol to the
     executable being debugged, since there is a duplicate named symbol in the
     shared library.  We don't want the shared library versions. */

  for (symbolp = debug_base_symbols; *symbolp != NULL; symbolp++)
    {
      msymbol = lookup_minimal_symbol (*symbolp, NULL, symfile_objfile);
      if ((msymbol != NULL) && (SYMBOL_VALUE_ADDRESS (msymbol) != 0))
	{
	  address = SYMBOL_VALUE_ADDRESS (msymbol);
	  return (address);
	}
    }
  return (0);

#else /* SVR4_SHARED_LIBS */

a542 3

#endif /* !SVR4_SHARED_LIBS */

a565 14

#ifndef SVR4_SHARED_LIBS

  read_memory (debug_base, (char *) &dynamic_copy, sizeof (dynamic_copy));
  if (dynamic_copy.ld_version >= 2)
    {
      /* It is a version that we can deal with, so read in the secondary
         structure and find the address of the link map list from it. */
      read_memory (SOLIB_EXTRACT_ADDRESS (dynamic_copy.ld_un.ld_2),
		   (char *) &ld_2_copy, sizeof (struct link_dynamic_2));
      lm = SOLIB_EXTRACT_ADDRESS (ld_2_copy.ld_loaded);
    }

#else /* SVR4_SHARED_LIBS */
a579 2
#endif /* !SVR4_SHARED_LIBS */

a582 1
#ifdef SVR4_SHARED_LIBS
a654 10
#else

static int
open_symbol_file_object (void *from_ttyp)
{
  return 1;
}

#endif /* SVR4_SHARED_LIBS */

a782 1

a784 1
#ifdef SVR4_SHARED_LIBS
a796 60
#else /* !SVR4_SHARED_LIBS */
static int
svr4_in_dynsym_resolve_code (CORE_ADDR pc)
{
  return 0;
}
#endif /* SVR4_SHARED_LIBS */

/*

   LOCAL FUNCTION

   disable_break -- remove the "mapping changed" breakpoint

   SYNOPSIS

   static int disable_break ()

   DESCRIPTION

   Removes the breakpoint that gets hit when the dynamic linker
   completes a mapping change.

 */

#ifndef SVR4_SHARED_LIBS

static int
disable_break (void)
{
  int status = 1;

  int in_debugger = 0;

  /* Read the debugger structure from the inferior to retrieve the
     address of the breakpoint and the original contents of the
     breakpoint address.  Remove the breakpoint by writing the original
     contents back. */

  read_memory (debug_addr, (char *) &debug_copy, sizeof (debug_copy));

  /* Set `in_debugger' to zero now. */

  write_memory (flag_addr, (char *) &in_debugger, sizeof (in_debugger));

  breakpoint_addr = SOLIB_EXTRACT_ADDRESS (debug_copy.ldd_bp_addr);
  write_memory (breakpoint_addr, (char *) &debug_copy.ldd_bp_inst,
		sizeof (debug_copy.ldd_bp_inst));

  /* For the SVR4 version, we always know the breakpoint address.  For the
     SunOS version we don't know it until the above code is executed.
     Grumble if we are stopped anywhere besides the breakpoint address. */

  if (stop_pc != breakpoint_addr)
    {
      warning ("stopped at unknown breakpoint while handling shared libraries");
    }

  return (status);
}
a797 1
#endif /* #ifdef SVR4_SHARED_LIBS */
a846 32
#ifndef SVR4_SHARED_LIBS

  int j;
  int in_debugger;

  /* Get link_dynamic structure */

  j = target_read_memory (debug_base, (char *) &dynamic_copy,
			  sizeof (dynamic_copy));
  if (j)
    {
      /* unreadable */
      return (0);
    }

  /* Calc address of debugger interface structure */

  debug_addr = SOLIB_EXTRACT_ADDRESS (dynamic_copy.ldd);

  /* Calc address of `in_debugger' member of debugger interface structure */

  flag_addr = debug_addr + (CORE_ADDR) ((char *) &debug_copy.ldd_in_debugger -
					(char *) &debug_copy);

  /* Write a value of 1 to this member.  */

  in_debugger = 1;
  write_memory (flag_addr, (char *) &in_debugger, sizeof (in_debugger));
  success = 1;

#else /* SVR4_SHARED_LIBS */

a856 1
#ifdef SVR4_SHARED_LIBS
a971 1
#endif
a991 2
#endif /* !SVR4_SHARED_LIBS */

d1011 1
a1011 1
   For SunOS4, this consists of grunging around in the dynamic
d1016 2
a1022 38
#ifndef SVR4_SHARED_LIBS
  int j;

  if (debug_addr == 0)
    {
      /* Get link_dynamic structure */

      j = target_read_memory (debug_base, (char *) &dynamic_copy,
			      sizeof (dynamic_copy));
      if (j)
	{
	  /* unreadable */
	  return;
	}

      /* Calc address of debugger interface structure */
      /* FIXME, this needs work for cross-debugging of core files
         (byteorder, size, alignment, etc).  */

      debug_addr = SOLIB_EXTRACT_ADDRESS (dynamic_copy.ldd);
    }

  /* Read the debugger structure from the inferior, just to make sure
     we have a current copy. */

  j = target_read_memory (debug_addr, (char *) &debug_copy,
			  sizeof (debug_copy));
  if (j)
    return;			/* unreadable */

  /* Get common symbol definitions for the loaded object. */

  if (debug_copy.ldd_cp)
    {
      solib_add_common_symbols (SOLIB_EXTRACT_ADDRESS (debug_copy.ldd_cp));
    }

#endif /* !SVR4_SHARED_LIBS */
a1188 12
  /* If we are using the BKPT_AT_SYMBOL code, then we don't need the base
     yet.  In fact, in the case of a SunOS4 executable being run on
     Solaris, we can't get it yet.  current_sos will get it when it needs
     it.  */
#if !(defined (SVR4_SHARED_LIBS) && defined (BKPT_AT_SYMBOL))
  if ((debug_base = locate_base ()) == 0)
    {
      /* Can't find the symbol or the executable is statically linked. */
      return;
    }
#endif

d1195 2
a1196 2
#if !defined(SVR4_SHARED_LIBS) || defined(_SCO_DS)
  /* SCO and SunOS need the loop below, other systems should be using the
d1215 1
a1215 22

#if !defined(_SCO_DS)
  /* We are now either at the "mapping complete" breakpoint (or somewhere
     else, a condition we aren't prepared to deal with anyway), so adjust
     the PC as necessary after a breakpoint, disable the breakpoint, and
     add any shared libraries that were mapped in. */

  if (DECR_PC_AFTER_BREAK)
    {
      stop_pc -= DECR_PC_AFTER_BREAK;
      write_register (PC_REGNUM, stop_pc);
    }

  if (!disable_break ())
    {
      warning ("shared library handler failed to disable breakpoint");
    }

  if (auto_solib_add)
    solib_add ((char *) 0, 0, (struct target_ops *) 0);
#endif /* ! _SCO_DS */
#endif
@


1.18
log
@Make set_solib_svr4_fetch_link_map_offsets() work as intended.
@
text
@d61 1
a61 1
#define SVR4_FETCH_LINK_MAP_OFFSETS() fetch_link_map_offsets ()
d64 2
a65 1
static struct link_map_offsets *default_svr4_fetch_link_map_offsets (void);
d67 4
a70 13
/* fetch_link_map_offsets is the pointer to the architecture specific
   link map offsets fetching function.  It uses the gdbarch_swap
   mechanism to change its value when the architecture changes.  */
static struct link_map_offsets *(*fetch_link_map_offsets)(void) = 
  default_svr4_fetch_link_map_offsets;

/* fetch_link_map_offsets_init is like the above, but obtains its
   value from a call to set_solib_svr4_fetch_link_map_offsets().
   This latter function is intended to be called from a *_gdbarch_init()
   function.  The value of ``fetch_link_map_offsets_init'' is used
   to actually set ``fetch_link_map_offsets'' when the architecture
   is installed.  */
static struct link_map_offsets *(*fetch_link_map_offsets_init)(void) = 0;
d75 1
a139 21
/* Fetch (and possibly build) an appropriate link_map_offsets structure
   for native targets using struct definitions from link.h.  
   
   Note: For non-native targets (i.e. cross-debugging situations),
   you need to define a target specific fetch_link_map_offsets()
   function and call set_solib_svr4_fetch_link_map_offsets () to
   register this function.  */

static struct link_map_offsets *
default_svr4_fetch_link_map_offsets (void)
{
  if (legacy_svr4_fetch_link_map_offsets_hook)
    return legacy_svr4_fetch_link_map_offsets_hook ();
  else
    {
      internal_error (__FILE__, __LINE__,
"default_svr4_fetch_link_map_offsets called without legacy link_map support enabled.");
      return 0;
    }
}

d1629 42
d1672 3
a1674 7
   a <arch>_gdbarch_init() function.  It uses ``fetch_link_map_offsets_init''
   to temporarily hold a pointer to the link map offsets fetcher for
   a particular architecture.  Once the architecture is actually installed,
   init_fetch_link_map_offsets(), below, will be called to install this
   value in ``fetch_link_map_offsets''.  After that, the gdbarch_swap
   machinery will manage the contents of this variable whenever the
   architecture changes.  */
d1677 2
a1678 1
set_solib_svr4_fetch_link_map_offsets (struct link_map_offsets *(*flmo) (void))
d1680 1
a1680 1
  fetch_link_map_offsets_init = flmo;
d1683 7
a1689 4
/* Initialize the value of ``fetch_link_map_offsets'' when a new
   architecture is created.  set_solib_svr4_fetch_link_map_offsets()
   is used to set the value that ``fetch_link_map_offsets'' should
   be initialized to.  */
d1691 2
a1692 2
static void
init_fetch_link_map_offsets (void)
d1694 5
a1698 2
  if (fetch_link_map_offsets_init != NULL)
    fetch_link_map_offsets = fetch_link_map_offsets_init;
d1700 1
a1700 3
    fetch_link_map_offsets = default_svr4_fetch_link_map_offsets;

  fetch_link_map_offsets_init = NULL;
d1708 2
a1709 3
  register_gdbarch_swap (&fetch_link_map_offsets,
                         sizeof (fetch_link_map_offsets),
			 init_fetch_link_map_offsets);
a1722 1

@


1.17
log
@Applied Daniel Jacobowitz's patch for reattaching in the presence of
remote SVR4 shared libraries.
@
text
@d65 4
d72 8
d1657 9
d1669 1
a1669 1
  fetch_link_map_offsets = flmo;
d1672 5
d1680 6
a1685 1
  set_solib_svr4_fetch_link_map_offsets (default_svr4_fetch_link_map_offsets);
@


1.16
log
@2001-07-02  Daniel Jacobowitz  <drow@@mvista.com>
        * solib-svr4.c: Include "elf/mips.h".
        (elf_locate_base): Make DT_MIPS_RLD_MAP block unconditional.
@
text
@d1201 3
a1203 1
      CORE_ADDR load_addr;
d1240 24
a1263 4
      /* We find the dynamic linker's base address by examining the
         current pc (which point at the entry point for the dynamic
         linker) and subtracting the offset of the entry point.  */
      load_addr = read_pc () - tmp_bfd->start_address;
@


1.16.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d879 1
a879 1
  symbol_file_command (filename, from_tty);
@


1.15
log
@Phase 1 of the ptid_t changes.
@
text
@d40 1
a626 1
#ifdef DT_MIPS_RLD_MAP
a639 1
#endif
@


1.14
log
@Change type of ``storage_needed'' from unsigned int to long.
@
text
@d747 1
a747 1
      else if (inferior_pid != 0 && target_has_execution)
d1574 1
a1574 1
      target_resume (-1, 0, stop_signal);
@


1.13
log
@Cleanup solib-svr4.c by moving legacy code out to its own file.
@
text
@d367 1
a367 1
  unsigned int storage_needed;
@


1.12
log
@Update/correct copyright notices.
@
text
@a22 1
#define _SYSCALL32	/* for Sparc64 cross Sparc32 */
d36 1
d39 1
a39 4
#endif

#ifdef HAVE_LINK_H
#include <link.h>
d59 13
d135 6
a140 1
   for native targets using struct definitions from link.h.  */
d142 1
a142 1
struct link_map_offsets *
d145 3
a147 14
#ifdef HAVE_LINK_H
  static struct link_map_offsets lmo;
  static struct link_map_offsets *lmp = 0;
#if defined (HAVE_STRUCT_LINK_MAP32)
  static struct link_map_offsets lmo32;
  static struct link_map_offsets *lmp32 = 0;
#endif

#ifndef offsetof
#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
#endif
#define fieldsize(TYPE, MEMBER) (sizeof (((TYPE *)0)->MEMBER))

  if (lmp == 0)
d149 3
a151 33
      lmp = &lmo;

#ifdef SVR4_SHARED_LIBS
      lmo.r_debug_size = sizeof (struct r_debug);

      lmo.r_map_offset = offsetof (struct r_debug, r_map);
      lmo.r_map_size = fieldsize (struct r_debug, r_map);

      lmo.link_map_size = sizeof (struct link_map);

      lmo.l_addr_offset = offsetof (struct link_map, l_addr);
      lmo.l_addr_size = fieldsize (struct link_map, l_addr);

      lmo.l_next_offset = offsetof (struct link_map, l_next);
      lmo.l_next_size = fieldsize (struct link_map, l_next);

      lmo.l_prev_offset = offsetof (struct link_map, l_prev);
      lmo.l_prev_size = fieldsize (struct link_map, l_prev);

      lmo.l_name_offset = offsetof (struct link_map, l_name);
      lmo.l_name_size = fieldsize (struct link_map, l_name);
#else /* !SVR4_SHARED_LIBS */
      lmo.link_map_size = sizeof (struct link_map);

      lmo.l_addr_offset = offsetof (struct link_map, lm_addr);
      lmo.l_addr_size = fieldsize (struct link_map, lm_addr);

      lmo.l_next_offset = offsetof (struct link_map, lm_next);
      lmo.l_next_size = fieldsize (struct link_map, lm_next);

      lmo.l_name_offset = offsetof (struct link_map, lm_name);
      lmo.l_name_size = fieldsize (struct link_map, lm_name);
#endif /* SVR4_SHARED_LIBS */
a152 41

#if defined (HAVE_STRUCT_LINK_MAP32)
  if (lmp32 == 0)
    {
      lmp32 = &lmo32;

      lmo32.r_debug_size = sizeof (struct r_debug32);

      lmo32.r_map_offset = offsetof (struct r_debug32, r_map);
      lmo32.r_map_size = fieldsize (struct r_debug32, r_map);

      lmo32.link_map_size = sizeof (struct link_map32);

      lmo32.l_addr_offset = offsetof (struct link_map32, l_addr);
      lmo32.l_addr_size = fieldsize (struct link_map32, l_addr);

      lmo32.l_next_offset = offsetof (struct link_map32, l_next);
      lmo32.l_next_size = fieldsize (struct link_map32, l_next);

      lmo32.l_prev_offset = offsetof (struct link_map32, l_prev);
      lmo32.l_prev_size = fieldsize (struct link_map32, l_prev);

      lmo32.l_name_offset = offsetof (struct link_map32, l_name);
      lmo32.l_name_size = fieldsize (struct link_map32, l_name);
    }
#endif /* defined (HAVE_STRUCT_LINK_MAP32) */

#if defined (HAVE_STRUCT_LINK_MAP32)
  if (bfd_get_arch_size (exec_bfd) == 32)
    return lmp32;
  else
#endif
    return lmp;

#else

  internal_error (__FILE__, __LINE__,
		  "default_svr4_fetch_link_map_offsets called without HAVE_LINK_H defined.");
  return 0;

#endif /* HAVE_LINK_H */
d887 1
a887 1
open_symbol_file_object (int *from_ttyp)
d1624 12
d1641 4
a1650 1
  svr4_so_ops.open_symbol_file_object = open_symbol_file_object;
@


1.11
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 98, 1999, 2000, 2001
@


1.10
log
@Made changes to shared library support and added more of the support needed
for AIX/IA-64.
@
text
@d24 1
@


1.9
log
@2001-02-20  Martin M. Hunt  <hunt@@redhat.com>

	* solib-svr4.c (LM_ADDR): LM_ADDR is a signed offset, so
	extract_signed_integer() should be called instead of
	extract_address().
@
text
@a1087 2
#ifdef SVR4_SHARED_LIBS

d1090 1
a1090 1

d1096 2
a1097 2
int
in_svr4_dynsym_resolve_code (CORE_ADDR pc)
d1103 7
a1109 1
#endif
d1310 1
a1310 1
         text and plt section for in_svr4_dynsym_resolve_code.  */
d1701 2
@


1.8
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d252 2
a253 1
  return extract_address (so->lm_info->lm + lmo->l_addr_offset, lmo->l_addr_size);
@


1.7
log
@2001-01-26  Fernando Nasser  <fnasser@@redhat.com>

        Fix double parsing of filenames passed as command line arguments
        to GDB (causes weird handling of escape characters).
        Also, remove dependencies on the CLI from libgdb.
        * call-cmds.h: Remove declaration of exec_file_command().
        * gdbcore.h: Remove declaration of exec_file_command().
        Add declarations for exec_open() and exec_file_clear().
        * symfile.h: Add declarations for symbol_file_add_main() and
        symbol_file_clear().
        * exec.c (exec_open): New function. Implements to_open for exec
        targets.
        (exec_file_clear): New function. Makes GDB forget about a previously
        specified executable file.
        (exec_file_attach): Move parsing of arguments from here ...
        (exec_file_command): ... to here.
        (init_exec_ops): Use exec_open(), not exec_file_command() to
        implement to_open for exec targets.
        * symfile.c (symbol_file_add_main): New function. Call symbol_file_add()        with default values.  Used when the file name has already been parsed.
        (symbol_file_clear): New function. Makes GDB forget about previously
        read symbols.
        (symbol_file_command): Call the above function instead of inline code.
        * main.c: Include "symfile.h" and "gdbcore.h" instead of the deprecated
        "call-cmds.h".
        (captured_main): Call exec_file_attach() and symbol_file_add_main()
        instead of exec_file_command() and symbol_file_command().
        (captured_main): Add comment.
        * corefile.c: Include "symfile.h".
        (core_file_command): Call symbol_file_add_main() instead of
        symbol_file_command().
        (reopen_exec_file): Call exec_open() instead of exec_file_command().
        * infcmd.c: Include "symfile.h".
        (attach_command): Call symbol_file_add_main() instead of
        symbol_file_command().
        * infrun.c: Remove comment about the inclusion of "symfile.h",
        not any longer appropriate.
        (follow_exec): Call symbol_file_add_main() instead of
        symbol_file_command().
        * remote-es.c: Include "symfile.h".
        (es1800_load): Call symbol_file_add_main() instead of
        symbol_file_command().
        * remote-vx.c: Remove comment about the inclusion of "symfile.h",
        not any longer appropriate.
        (vx-wait): Call symbol_file_add_main() instead of
        symbol_file_command().
        * solib-svr4.c (open_symbol_file_object): Call symbol_file_add_main()
        instead of symbol_file_command().
        * v850ice.c (ice_file): Call exec_open(), exec_file_attach() and
        symbol_file_add_main() instead of exec_file_command() and
        symbol_file_command().
        * Makefile.in: Update dependencies.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 98, 1999, 2000
d213 2
a214 1
  internal_error ("default_svr4_fetch_link_map_offsets called without HAVE_LINK_H defined.");
@


1.6
log
@Applied solib-svr4.c changes for NetBSD from Matthew Green.
@
text
@d943 1
a943 1
  symbol_file_command (filename, from_tty);
@


1.5
log
@Replace free() with xfree().
@
text
@d85 1
@


1.4
log
@2000-11-20  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * solist.h: Declare new function solib_open.
        * solib.c (solib_open): New function.  Abstracts some of the
        code from solib_map_sections, for finding the binary solib file.
        (solib_map_sections): Call solib_open.
        * solib-svr4.c (enable_break): Call solib_open.
@
text
@d311 1
a311 1
			      xmalloc, free);
d313 1
a313 1
			      free);
d315 1
a315 1
			      free);
d317 1
a317 1
			      free);
d354 1
a354 1
				  xmalloc, free);
d387 1
a387 1
	  free (name);
d442 1
a442 1
      back_to = make_cleanup (free, (PTR) symbol_table);
d469 1
a469 1
      back_to = make_cleanup (free, (PTR) symbol_table);
d856 1
a856 1
  struct cleanup *cleanups = make_cleanup (free, r_map_buf);
d905 1
a905 1
  struct cleanup *cleanups = make_cleanup (free, l_name_buf);
d940 1
a940 1
  make_cleanup (free, filename);
d1003 1
a1003 1
      struct cleanup *old_chain = make_cleanup (free, new);
d1008 1
a1008 1
      make_cleanup (free, new->lm_info);
d1011 1
a1011 1
      make_cleanup (free, new->lm_info->lm);
d1042 1
a1042 1
	      free (buffer);
d1525 1
a1525 1
      old_chain = make_cleanup (free, new_offsets);
d1670 2
a1671 2
  free (so->lm_info->lm);
  free (so->lm_info);
@


1.3
log
@Add code for relocating dynamic executables.
@
text
@a289 1

a296 10
/* If non-zero, this is a prefix that will be added to the front of the name
   shared libraries with an absolute filename for loading.  */
static char *solib_absolute_prefix = NULL;

/* If non-empty, this is a search path for loading non-absolute shared library
   symbol files.  This takes precedence over the environment variables PATH
   and LD_LIBRARY_PATH.  */
static char *solib_search_path = NULL;


d1261 3
a1263 1
      bfd *tmp_bfd;
d1281 5
a1285 1
      tmp_bfd = bfd_openr (buf, gnutarget);
@


1.2
log
@solib.c relocation improvements
@
text
@d1440 106
d1598 1
a1598 1
void
d1601 3
@


1.1
log
@Reorganize solib.c.
@
text
@d1570 8
d1583 1
a1583 1
  svr4_so_ops.lm_addr = LM_ADDR;
@
