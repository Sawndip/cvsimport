head	1.43;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.43
	gdb_7_6-2013-04-26-release:1.43
	gdb_7_6-branch:1.43.0.2
	gdb_7_6-2013-03-12-branchpoint:1.43
	gdb_7_5_1-2012-11-29-release:1.42
	gdb_7_5-2012-08-17-release:1.42
	gdb_7_5-branch:1.42.0.2
	gdb_7_5-2012-07-18-branchpoint:1.42
	gdb_7_4_1-2012-04-26-release:1.40.4.1
	gdb_7_4-2012-01-24-release:1.40.4.1
	gdb_7_4-branch:1.40.0.4
	gdb_7_4-2011-12-13-branchpoint:1.40
	gdb_7_3_1-2011-09-04-release:1.40
	gdb_7_3-2011-07-26-release:1.40
	gdb_7_3-branch:1.40.0.2
	gdb_7_3-2011-04-01-branchpoint:1.40
	gdb_7_2-2010-09-02-release:1.37
	gdb_7_2-branch:1.37.0.4
	gdb_7_2-2010-07-07-branchpoint:1.37
	gdb_7_1-2010-03-18-release:1.37
	gdb_7_1-branch:1.37.0.2
	gdb_7_1-2010-02-18-branchpoint:1.37
	gdb_7_0_1-2009-12-22-release:1.36
	gdb_7_0-2009-10-06-release:1.36
	gdb_7_0-branch:1.36.0.4
	gdb_7_0-2009-09-16-branchpoint:1.36
	arc-sim-20090309:1.28
	msnyder-checkpoint-072509-branch:1.36.0.2
	msnyder-checkpoint-072509-branchpoint:1.36
	arc-insight_6_8-branch:1.28.0.6
	arc-insight_6_8-branchpoint:1.28
	insight_6_8-branch:1.28.0.4
	insight_6_8-branchpoint:1.28
	reverse-20081226-branch:1.32.0.6
	reverse-20081226-branchpoint:1.32
	multiprocess-20081120-branch:1.32.0.4
	multiprocess-20081120-branchpoint:1.32
	reverse-20080930-branch:1.32.0.2
	reverse-20080930-branchpoint:1.32
	reverse-20080717-branch:1.29.0.4
	reverse-20080717-branchpoint:1.29
	msnyder-reverse-20080609-branch:1.29.0.2
	msnyder-reverse-20080609-branchpoint:1.29
	drow-reverse-20070409-branch:1.22.0.2
	drow-reverse-20070409-branchpoint:1.22
	gdb_6_8-2008-03-27-release:1.28
	gdb_6_8-branch:1.28.0.2
	gdb_6_8-2008-02-26-branchpoint:1.28
	gdb_6_7_1-2007-10-29-release:1.24
	gdb_6_7-2007-10-10-release:1.24
	gdb_6_7-branch:1.24.0.2
	gdb_6_7-2007-09-07-branchpoint:1.24
	insight_6_6-20070208-release:1.19
	gdb_6_6-2006-12-18-release:1.19
	gdb_6_6-branch:1.19.0.18
	gdb_6_6-2006-11-15-branchpoint:1.19
	insight_6_5-20061003-release:1.19
	gdb-csl-symbian-6_4_50_20060226-12:1.19
	gdb-csl-sourcerygxx-3_4_4-25:1.18
	nickrob-async-20060828-mergepoint:1.19
	gdb-csl-symbian-6_4_50_20060226-11:1.19
	gdb-csl-sourcerygxx-4_1-17:1.19
	gdb-csl-20060226-branch-local-2:1.19
	gdb-csl-sourcerygxx-4_1-14:1.19
	gdb-csl-sourcerygxx-4_1-13:1.19
	gdb-csl-sourcerygxx-4_1-12:1.19
	gdb-csl-sourcerygxx-3_4_4-21:1.19
	gdb_6_5-20060621-release:1.19
	gdb-csl-sourcerygxx-4_1-9:1.19
	gdb-csl-sourcerygxx-4_1-8:1.19
	gdb-csl-sourcerygxx-4_1-7:1.19
	gdb-csl-arm-2006q1-6:1.19
	gdb-csl-sourcerygxx-4_1-6:1.19
	gdb-csl-symbian-6_4_50_20060226-10:1.19
	gdb-csl-symbian-6_4_50_20060226-9:1.19
	gdb-csl-symbian-6_4_50_20060226-8:1.19
	gdb-csl-coldfire-4_1-11:1.19
	gdb-csl-sourcerygxx-3_4_4-19:1.19
	gdb-csl-coldfire-4_1-10:1.19
	gdb_6_5-branch:1.19.0.16
	gdb_6_5-2006-05-14-branchpoint:1.19
	gdb-csl-sourcerygxx-4_1-5:1.19
	nickrob-async-20060513-branch:1.19.0.14
	nickrob-async-20060513-branchpoint:1.19
	gdb-csl-sourcerygxx-4_1-4:1.19
	msnyder-reverse-20060502-branch:1.19.0.12
	msnyder-reverse-20060502-branchpoint:1.19
	gdb-csl-morpho-4_1-4:1.19
	gdb-csl-sourcerygxx-3_4_4-17:1.19
	readline_5_1-import-branch:1.19.0.10
	readline_5_1-import-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.19
	gdb-csl-symbian-20060226-branch:1.19.0.8
	gdb-csl-symbian-20060226-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.19
	msnyder-reverse-20060331-branch:1.19.0.6
	msnyder-reverse-20060331-branchpoint:1.19
	gdb-csl-available-20060303-branch:1.19.0.4
	gdb-csl-available-20060303-branchpoint:1.19
	gdb-csl-20060226-branch:1.19.0.2
	gdb-csl-20060226-branchpoint:1.19
	gdb_6_4-20051202-release:1.18
	msnyder-fork-checkpoint-branch:1.18.0.8
	msnyder-fork-checkpoint-branchpoint:1.18
	gdb-csl-gxxpro-6_3-branch:1.18.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.18
	gdb_6_4-branch:1.18.0.4
	gdb_6_4-2005-11-01-branchpoint:1.18
	gdb-csl-arm-20051020-branch:1.18.0.2
	gdb-csl-arm-20051020-branchpoint:1.18
	msnyder-tracepoint-checkpoint-branch:1.17.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.17
	gdb-csl-arm-20050325-2005-q1b:1.16
	gdb-csl-arm-20050325-2005-q1a:1.16
	csl-arm-20050325-branch:1.16.0.2
	csl-arm-20050325-branchpoint:1.16
	gdb-post-i18n-errorwarning-20050211:1.16
	gdb-pre-i18n-errorwarning-20050211:1.16
	gdb_6_3-20041109-release:1.14
	gdb_6_3-branch:1.14.0.4
	gdb_6_3-20041019-branchpoint:1.14
	drow_intercu-merge-20040921:1.14
	drow_intercu-20040221-branch:1.14.0.2
	drow_intercu-merge-20040915:1.14
	jimb-gdb_6_2-e500-branch:1.13.0.6
	jimb-gdb_6_2-e500-branchpoint:1.13
	gdb_6_2-20040730-release:1.13
	gdb_6_2-branch:1.13.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.13
	gdb_5_3-2002-12-12-release:1.9
	carlton_dictionary-20021115-merge:1.9
	kseitz_interps-20021105-merge:1.9
	kseitz_interps-20021103-merge:1.9
	drow-cplus-merge-20021020:1.9
	drow-cplus-merge-20021025:1.9
	carlton_dictionary-20021025-merge:1.9
	carlton_dictionary-20021011-merge:1.9
	drow-cplus-branch:1.9.0.10
	drow-cplus-branchpoint:1.9
	kseitz_interps-20020930-merge:1.9
	carlton_dictionary-20020927-merge:1.9
	carlton_dictionary-branch:1.9.0.8
	carlton_dictionary-20020920-branchpoint:1.9
	gdb_5_3-branch:1.9.0.6
	gdb_5_3-2002-09-04-branchpoint:1.9
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.4
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.9.0.2
	readline_4_3-import-branchpoint:1.9
	gdb_5_2_1-2002-07-23-release:1.7
	kseitz_interps-20020528-branch:1.8.0.4
	kseitz_interps-20020528-branchpoint:1.8
	cagney_regbuf-20020515-branch:1.8.0.2
	cagney_regbuf-20020515-branchpoint:1.8
	jimb-macro-020506-branch:1.7.0.4
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.7
	gdb_5_2-branch:1.7.0.2
	gdb_5_2-2002-03-03-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.6
	gdb_5_1_0_1-2002-01-03-release:1.6
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.6.0.8
	gdb_5_1-2001-11-21-release:1.6
	gdb_s390-2001-09-26-branch:1.6.0.6
	gdb_s390-2001-09-26-branchpoint:1.6
	gdb_5_1-2001-07-29-branch:1.6.0.4
	gdb_5_1-2001-07-29-branchpoint:1.6
	dberlin-typesystem-branch:1.6.0.2
	dberlin-typesystem-branchpoint:1.6
	gdb-post-ptid_t-2001-05-03:1.6
	gdb-pre-ptid_t-2001-05-03:1.6
	insight-precleanup-2001-01-01:1.3
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.3
	gdb-premipsmulti-2000-06-06-branch:1.1.1.3.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.3
	gdb-post-params-removal-2000-06-04:1.1.1.3
	gdb-pre-params-removal-2000-06-04:1.1.1.3
	gdb-post-params-removal-2000-05-28:1.1.1.3
	gdb-pre-params-removal-2000-05-28:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.43
date	2013.01.01.06.32.47;	author brobecke;	state Exp;
branches;
next	1.42;

1.42
date	2012.05.16.14.35.06;	author macro;	state Exp;
branches;
next	1.41;

1.41
date	2012.01.04.08.17.06;	author brobecke;	state Exp;
branches;
next	1.40;

1.40
date	2011.03.18.18.52.31;	author palves;	state Exp;
branches
	1.40.4.1;
next	1.39;

1.39
date	2011.01.09.03.20.33;	author msnyder;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.01.15.33.10;	author brobecke;	state Exp;
branches;
next	1.37;

1.37
date	2010.01.01.07.31.37;	author brobecke;	state Exp;
branches;
next	1.36;

1.36
date	2009.07.02.17.25.55;	author uweigand;	state Exp;
branches;
next	1.35;

1.35
date	2009.07.02.12.46.19;	author uweigand;	state Exp;
branches;
next	1.34;

1.34
date	2009.02.22.01.02.17;	author palves;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.31;

1.31
date	2008.09.05.11.42.31;	author uweigand;	state Exp;
branches;
next	1.30;

1.30
date	2008.08.25.21.03.29;	author uweigand;	state Exp;
branches;
next	1.29;

1.29
date	2008.04.22.11.03.42;	author corinna;	state Exp;
branches;
next	1.28;

1.28
date	2008.01.11.13.20.02;	author deuling;	state Exp;
branches;
next	1.27;

1.27
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.07.06.33.00;	author deuling;	state Exp;
branches;
next	1.25;

1.25
date	2007.11.02.14.27.14;	author uweigand;	state Exp;
branches;
next	1.24;

1.24
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.15.22.44.56;	author uweigand;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.27.20.17.19;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2007.01.29.17.31.06;	author drow;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.09.17.58.52;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.12.11.53.00;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.14.11.50.36;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.07.00.09.54;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.13.02.15.32;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.31.21.53.17;	author cagney;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2004.06.07.02.02.51;	author tausq;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.30.18.16.31;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.24.21.00.09;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.16.20.39.08;	author cagney;	state dead;
branches;
next	1.9;

1.9
date	2002.07.24.23.51.35;	author cagney;	state Exp;
branches
	1.9.8.1
	1.9.10.1;
next	1.8;

1.8
date	2002.05.13.17.20.58;	author cagney;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.11.13.02.39.29;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.02.14.47.21;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.06.08.21.10;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.18.00.34.51;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.40.4.1
date	2012.01.06.04.43.20;	author brobecke;	state Exp;
branches;
next	;

1.14.2.1
date	2004.09.16.17.01.13;	author drow;	state Exp;
branches;
next	;

1.9.8.1
date	2002.12.23.19.38.33;	author carlton;	state dead;
branches;
next	;

1.9.10.1
date	2003.12.14.20.27.21;	author drow;	state dead;
branches;
next	;

1.8.4.1
date	2002.08.09.18.34.25;	author kseitz;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.05.05.14.42.41;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.07.53;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Target-dependent code for the Motorola 88000 series.

   Copyright (C) 2004-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "dis-asm.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
#include "gdbcore.h"
#include "gdbtypes.h"
#include "regcache.h"
#include "regset.h"
#include "symtab.h"
#include "trad-frame.h"
#include "value.h"

#include "gdb_assert.h"
#include "gdb_string.h"

#include "m88k-tdep.h"

/* Fetch the instruction at PC.  */

static unsigned long
m88k_fetch_instruction (CORE_ADDR pc, enum bfd_endian byte_order)
{
  return read_memory_unsigned_integer (pc, 4, byte_order);
}

/* Register information.  */

/* Return the name of register REGNUM.  */

static const char *
m88k_register_name (struct gdbarch *gdbarch, int regnum)
{
  static char *register_names[] =
  {
    "r0",  "r1",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7",
    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",
    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",
    "epsr", "fpsr", "fpcr", "sxip", "snip", "sfip"
  };

  if (regnum >= 0 && regnum < ARRAY_SIZE (register_names))
    return register_names[regnum];

  return NULL;
}

/* Return the GDB type object for the "standard" data type of data in
   register REGNUM.  */

static struct type *
m88k_register_type (struct gdbarch *gdbarch, int regnum)
{
  /* SXIP, SNIP, SFIP and R1 contain code addresses.  */
  if ((regnum >= M88K_SXIP_REGNUM && regnum <= M88K_SFIP_REGNUM)
      || regnum == M88K_R1_REGNUM)
    return builtin_type (gdbarch)->builtin_func_ptr;

  /* R30 and R31 typically contains data addresses.  */
  if (regnum == M88K_R30_REGNUM || regnum == M88K_R31_REGNUM)
    return builtin_type (gdbarch)->builtin_data_ptr;

  return builtin_type (gdbarch)->builtin_int32;
}


static CORE_ADDR
m88k_addr_bits_remove (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  /* All instructures are 4-byte aligned.  The lower 2 bits of SXIP,
     SNIP and SFIP are used for special purposes: bit 0 is the
     exception bit and bit 1 is the valid bit.  */
  return addr & ~0x3;
}

/* Use the program counter to determine the contents and size of a
   breakpoint instruction.  Return a pointer to a string of bytes that
   encode a breakpoint instruction, store the length of the string in
   *LEN and optionally adjust *PC to point to the correct memory
   location for inserting the breakpoint.  */
   
static const gdb_byte *
m88k_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pc, int *len)
{
  /* tb 0,r0,511 */
  static gdb_byte break_insn[] = { 0xf0, 0x00, 0xd1, 0xff };

  *len = sizeof (break_insn);
  return break_insn;
}

static CORE_ADDR
m88k_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  CORE_ADDR pc;

  pc = frame_unwind_register_unsigned (next_frame, M88K_SXIP_REGNUM);
  return m88k_addr_bits_remove (gdbarch, pc);
}

static void
m88k_write_pc (struct regcache *regcache, CORE_ADDR pc)
{
  /* According to the MC88100 RISC Microprocessor User's Manual,
     section 6.4.3.1.2:

     "... can be made to return to a particular instruction by placing
     a valid instruction address in the SNIP and the next sequential
     instruction address in the SFIP (with V bits set and E bits
     clear).  The rte resumes execution at the instruction pointed to
     by the SNIP, then the SFIP."

     The E bit is the least significant bit (bit 0).  The V (valid)
     bit is bit 1.  This is why we logical or 2 into the values we are
     writing below.  It turns out that SXIP plays no role when
     returning from an exception so nothing special has to be done
     with it.  We could even (presumably) give it a totally bogus
     value.  */

  regcache_cooked_write_unsigned (regcache, M88K_SXIP_REGNUM, pc);
  regcache_cooked_write_unsigned (regcache, M88K_SNIP_REGNUM, pc | 2);
  regcache_cooked_write_unsigned (regcache, M88K_SFIP_REGNUM, (pc + 4) | 2);
}


/* The functions on this page are intended to be used to classify
   function arguments.  */

/* Check whether TYPE is "Integral or Pointer".  */

static int
m88k_integral_or_pointer_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_INT:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_ENUM:
    case TYPE_CODE_RANGE:
      {
	/* We have byte, half-word, word and extended-word/doubleword
           integral types.  */
	int len = TYPE_LENGTH (type);
	return (len == 1 || len == 2 || len == 4 || len == 8);
      }
      return 1;
    case TYPE_CODE_PTR:
    case TYPE_CODE_REF:
      {
	/* Allow only 32-bit pointers.  */
	return (TYPE_LENGTH (type) == 4);
      }
      return 1;
    default:
      break;
    }

  return 0;
}

/* Check whether TYPE is "Floating".  */

static int
m88k_floating_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_FLT:
      {
	int len = TYPE_LENGTH (type);
	return (len == 4 || len == 8);
      }
    default:
      break;
    }

  return 0;
}

/* Check whether TYPE is "Structure or Union".  */

static int
m88k_structure_or_union_p (const struct type *type)
{
  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      return 1;
    default:
      break;
    }

  return 0;
}

/* Check whether TYPE has 8-byte alignment.  */

static int
m88k_8_byte_align_p (struct type *type)
{
  if (m88k_structure_or_union_p (type))
    {
      int i;

      for (i = 0; i < TYPE_NFIELDS (type); i++)
	{
	  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));

	  if (m88k_8_byte_align_p (subtype))
	    return 1;
	}
    }

  if (m88k_integral_or_pointer_p (type) || m88k_floating_p (type))
    return (TYPE_LENGTH (type) == 8);

  return 0;
}

/* Check whether TYPE can be passed in a register.  */

static int
m88k_in_register_p (struct type *type)
{
  if (m88k_integral_or_pointer_p (type) || m88k_floating_p (type))
    return 1;

  if (m88k_structure_or_union_p (type) && TYPE_LENGTH (type) == 4)
    return 1;

  return 0;
}

static CORE_ADDR
m88k_store_arguments (struct regcache *regcache, int nargs,
		      struct value **args, CORE_ADDR sp)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  int num_register_words = 0;
  int num_stack_words = 0;
  int i;

  for (i = 0; i < nargs; i++)
    {
      struct type *type = value_type (args[i]);
      int len = TYPE_LENGTH (type);

      if (m88k_integral_or_pointer_p (type) && len < 4)
	{
	  args[i] = value_cast (builtin_type (gdbarch)->builtin_int32,
				args[i]);
	  type = value_type (args[i]);
	  len = TYPE_LENGTH (type);
	}

      if (m88k_in_register_p (type))
	{
	  int num_words = 0;

	  if (num_register_words % 2 == 1 && m88k_8_byte_align_p (type))
	    num_words++;

	  num_words += ((len + 3) / 4);
	  if (num_register_words + num_words <= 8)
	    {
	      num_register_words += num_words;
	      continue;
	    }

	  /* We've run out of available registers.  Pass the argument
             on the stack.  */
	}

      if (num_stack_words % 2 == 1 && m88k_8_byte_align_p (type))
	num_stack_words++;

      num_stack_words += ((len + 3) / 4);
    }

  /* Allocate stack space.  */
  sp = align_down (sp - 32 - num_stack_words * 4, 16);
  num_stack_words = num_register_words = 0;

  for (i = 0; i < nargs; i++)
    {
      const bfd_byte *valbuf = value_contents (args[i]);
      struct type *type = value_type (args[i]);
      int len = TYPE_LENGTH (type);
      int stack_word = num_stack_words;

      if (m88k_in_register_p (type))
	{
	  int register_word = num_register_words;

	  if (register_word % 2 == 1 && m88k_8_byte_align_p (type))
	    register_word++;

	  gdb_assert (len == 4 || len == 8);

	  if (register_word + len / 8 < 8)
	    {
	      int regnum = M88K_R2_REGNUM + register_word;

	      regcache_raw_write (regcache, regnum, valbuf);
	      if (len > 4)
		regcache_raw_write (regcache, regnum + 1, valbuf + 4);

	      num_register_words = (register_word + len / 4);
	      continue;
	    }
	}

      if (stack_word % 2 == -1 && m88k_8_byte_align_p (type))
	stack_word++;

      write_memory (sp + stack_word * 4, valbuf, len);
      num_stack_words = (stack_word + (len + 3) / 4);
    }

  return sp;
}

static CORE_ADDR
m88k_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
		      struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		      struct value **args, CORE_ADDR sp, int struct_return,
		      CORE_ADDR struct_addr)
{
  /* Set up the function arguments.  */
  sp = m88k_store_arguments (regcache, nargs, args, sp);
  gdb_assert (sp % 16 == 0);

  /* Store return value address.  */
  if (struct_return)
    regcache_raw_write_unsigned (regcache, M88K_R12_REGNUM, struct_addr);

  /* Store the stack pointer and return address in the appropriate
     registers.  */
  regcache_raw_write_unsigned (regcache, M88K_R31_REGNUM, sp);
  regcache_raw_write_unsigned (regcache, M88K_R1_REGNUM, bp_addr);

  /* Return the stack pointer.  */
  return sp;
}

static struct frame_id
m88k_dummy_id (struct gdbarch *arch, struct frame_info *this_frame)
{
  CORE_ADDR sp;

  sp = get_frame_register_unsigned (this_frame, M88K_R31_REGNUM);
  return frame_id_build (sp, get_frame_pc (this_frame));
}


/* Determine, for architecture GDBARCH, how a return value of TYPE
   should be returned.  If it is supposed to be returned in registers,
   and READBUF is non-zero, read the appropriate value from REGCACHE,
   and copy it into READBUF.  If WRITEBUF is non-zero, write the value
   from WRITEBUF into REGCACHE.  */

static enum return_value_convention
m88k_return_value (struct gdbarch *gdbarch, struct value *function,
		   struct type *type, struct regcache *regcache,
		   gdb_byte *readbuf, const gdb_byte *writebuf)
{
  int len = TYPE_LENGTH (type);
  gdb_byte buf[8];

  if (!m88k_integral_or_pointer_p (type) && !m88k_floating_p (type))
    return RETURN_VALUE_STRUCT_CONVENTION;

  if (readbuf)
    {
      /* Read the contents of R2 and (if necessary) R3.  */
      regcache_cooked_read (regcache, M88K_R2_REGNUM, buf);
      if (len > 4)
	{
	  regcache_cooked_read (regcache, M88K_R3_REGNUM, buf + 4);
	  gdb_assert (len == 8);
	  memcpy (readbuf, buf, len);
	}
      else
	{
	  /* Just stripping off any unused bytes should preserve the
             signed-ness just fine.  */
	  memcpy (readbuf, buf + 4 - len, len);
	}
    }

  if (writebuf)
    {
      /* Read the contents to R2 and (if necessary) R3.  */
      if (len > 4)
	{
	  gdb_assert (len == 8);
	  memcpy (buf, writebuf, 8);
	  regcache_cooked_write (regcache, M88K_R3_REGNUM, buf + 4);
	}
      else
	{
	  /* ??? Do we need to do any sign-extension here?  */
	  memcpy (buf + 4 - len, writebuf, len);
	}
      regcache_cooked_write (regcache, M88K_R2_REGNUM, buf);
    }

  return RETURN_VALUE_REGISTER_CONVENTION;
}

/* Default frame unwinder.  */

struct m88k_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  CORE_ADDR pc;

  int sp_offset;
  int fp_offset;

  /* Table of saved registers.  */
  struct trad_frame_saved_reg *saved_regs;
};

/* Prologue analysis.  */

/* Macros for extracting fields from instructions.  */

#define BITMASK(pos, width) (((0x1 << (width)) - 1) << (pos))
#define EXTRACT_FIELD(val, pos, width) ((val) >> (pos) & BITMASK (0, width))
#define	SUBU_OFFSET(x)	((unsigned)(x & 0xFFFF))
#define	ST_OFFSET(x)	((unsigned)((x) & 0xFFFF))
#define	ST_SRC(x)	EXTRACT_FIELD ((x), 21, 5)
#define	ADDU_OFFSET(x)	((unsigned)(x & 0xFFFF))

/* Possible actions to be taken by the prologue analyzer for the
   instructions it encounters.  */

enum m88k_prologue_insn_action
{
  M88K_PIA_SKIP,		/* Ignore.  */
  M88K_PIA_NOTE_ST,		/* Note register store.  */
  M88K_PIA_NOTE_STD,		/* Note register pair store.  */
  M88K_PIA_NOTE_SP_ADJUSTMENT,	/* Note stack pointer adjustment.  */
  M88K_PIA_NOTE_FP_ASSIGNMENT,	/* Note frame pointer assignment.  */
  M88K_PIA_NOTE_BRANCH,		/* Note branch.  */
  M88K_PIA_NOTE_PROLOGUE_END	/* Note end of prologue.  */
};

/* Table of instructions that may comprise a function prologue.  */

struct m88k_prologue_insn
{
  unsigned long insn;
  unsigned long mask;
  enum m88k_prologue_insn_action action;
};

struct m88k_prologue_insn m88k_prologue_insn_table[] =
{
  /* Various register move instructions.  */
  { 0x58000000, 0xf800ffff, M88K_PIA_SKIP },     /* or/or.u with immed of 0 */
  { 0xf4005800, 0xfc1fffe0, M88K_PIA_SKIP },     /* or rd,r0,rs */
  { 0xf4005800, 0xfc00ffff, M88K_PIA_SKIP },     /* or rd,rs,r0 */

  /* Various other instructions.  */
  { 0x58000000, 0xf8000000, M88K_PIA_SKIP },     /* or/or.u */

  /* Stack pointer setup: "subu sp,sp,n" where n is a multiple of 8.  */
  { 0x67ff0000, 0xffff0007, M88K_PIA_NOTE_SP_ADJUSTMENT },

  /* Frame pointer assignment: "addu r30,r31,n".  */
  { 0x63df0000, 0xffff0000, M88K_PIA_NOTE_FP_ASSIGNMENT },

  /* Store to stack instructions; either "st rx,sp,n" or "st.d rx,sp,n".  */
  { 0x241f0000, 0xfc1f0000, M88K_PIA_NOTE_ST },  /* st rx,sp,n */
  { 0x201f0000, 0xfc1f0000, M88K_PIA_NOTE_STD }, /* st.d rs,sp,n */

  /* Instructions needed for setting up r25 for pic code.  */
  { 0x5f200000, 0xffff0000, M88K_PIA_SKIP },     /* or.u r25,r0,offset_high */
  { 0xcc000002, 0xffffffff, M88K_PIA_SKIP },     /* bsr.n Lab */
  { 0x5b390000, 0xffff0000, M88K_PIA_SKIP },     /* or r25,r25,offset_low */
  { 0xf7396001, 0xffffffff, M88K_PIA_SKIP },     /* Lab: addu r25,r25,r1 */

  /* Various branch or jump instructions which have a delay slot --
     these do not form part of the prologue, but the instruction in
     the delay slot might be a store instruction which should be
     noted.  */
  { 0xc4000000, 0xe4000000, M88K_PIA_NOTE_BRANCH },
                                      /* br.n, bsr.n, bb0.n, or bb1.n */
  { 0xec000000, 0xfc000000, M88K_PIA_NOTE_BRANCH }, /* bcnd.n */
  { 0xf400c400, 0xfffff7e0, M88K_PIA_NOTE_BRANCH }, /* jmp.n or jsr.n */

  /* Catch all.  Ends prologue analysis.  */
  { 0x00000000, 0x00000000, M88K_PIA_NOTE_PROLOGUE_END }
};

/* Do a full analysis of the function prologue at PC and update CACHE
   accordingly.  Bail out early if LIMIT is reached.  Return the
   address where the analysis stopped.  If LIMIT points beyond the
   function prologue, the return address should be the end of the
   prologue.  */

static CORE_ADDR
m88k_analyze_prologue (struct gdbarch *gdbarch,
		       CORE_ADDR pc, CORE_ADDR limit,
		       struct m88k_frame_cache *cache)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR end = limit;

  /* Provide a dummy cache if necessary.  */
  if (cache == NULL)
    {
      size_t sizeof_saved_regs =
	(M88K_R31_REGNUM + 1) * sizeof (struct trad_frame_saved_reg);

      cache = alloca (sizeof (struct m88k_frame_cache));
      cache->saved_regs = alloca (sizeof_saved_regs);

      /* We only initialize the members we care about.  */
      cache->saved_regs[M88K_R1_REGNUM].addr = -1;
      cache->fp_offset = -1;
    }

  while (pc < limit)
    {
      struct m88k_prologue_insn *pi = m88k_prologue_insn_table;
      unsigned long insn = m88k_fetch_instruction (pc, byte_order);

      while ((insn & pi->mask) != pi->insn)
	pi++;

      switch (pi->action)
	{
	case M88K_PIA_SKIP:
	  /* If we have a frame pointer, and R1 has been saved,
             consider this instruction as not being part of the
             prologue.  */
	  if (cache->fp_offset != -1
	      && cache->saved_regs[M88K_R1_REGNUM].addr != -1)
	    return min (pc, end);
	  break;

	case M88K_PIA_NOTE_ST:
	case M88K_PIA_NOTE_STD:
	  /* If no frame has been allocated, the stores aren't part of
             the prologue.  */
	  if (cache->sp_offset == 0)
	    return min (pc, end);

	  /* Record location of saved registers.  */
	  {
	    int regnum = ST_SRC (insn) + M88K_R0_REGNUM;
	    ULONGEST offset = ST_OFFSET (insn);

	    cache->saved_regs[regnum].addr = offset;
	    if (pi->action == M88K_PIA_NOTE_STD && regnum < M88K_R31_REGNUM)
	      cache->saved_regs[regnum + 1].addr = offset + 4;
	  }
	  break;

	case M88K_PIA_NOTE_SP_ADJUSTMENT:
	  /* A second stack pointer adjustment isn't part of the
             prologue.  */
	  if (cache->sp_offset != 0)
	    return min (pc, end);

	  /* Store stack pointer adjustment.  */
	  cache->sp_offset = -SUBU_OFFSET (insn);
	  break;

	case M88K_PIA_NOTE_FP_ASSIGNMENT:
	  /* A second frame pointer assignment isn't part of the
             prologue.  */
	  if (cache->fp_offset != -1)
	    return min (pc, end);

	  /* Record frame pointer assignment.  */
	  cache->fp_offset = ADDU_OFFSET (insn);
	  break;

	case M88K_PIA_NOTE_BRANCH:
	  /* The branch instruction isn't part of the prologue, but
             the instruction in the delay slot might be.  Limit the
             prologue analysis to the delay slot and record the branch
             instruction as the end of the prologue.  */
	  limit = min (limit, pc + 2 * M88K_INSN_SIZE);
	  end = pc;
	  break;

	case M88K_PIA_NOTE_PROLOGUE_END:
	  return min (pc, end);
	}

      pc += M88K_INSN_SIZE;
    }

  return end;
}

/* An upper limit to the size of the prologue.  */
const int m88k_max_prologue_size = 128 * M88K_INSN_SIZE;

/* Return the address of first real instruction of the function
   starting at PC.  */

static CORE_ADDR
m88k_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  struct symtab_and_line sal;
  CORE_ADDR func_start, func_end;

  /* This is the preferred method, find the end of the prologue by
     using the debugging information.  */
  if (find_pc_partial_function (pc, NULL, &func_start, &func_end))
    {
      sal = find_pc_line (func_start, 0);

      if (sal.end < func_end && pc <= sal.end)
	return sal.end;
    }

  return m88k_analyze_prologue (gdbarch, pc, pc + m88k_max_prologue_size,
				NULL);
}

static struct m88k_frame_cache *
m88k_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct m88k_frame_cache *cache;
  CORE_ADDR frame_sp;

  if (*this_cache)
    return *this_cache;

  cache = FRAME_OBSTACK_ZALLOC (struct m88k_frame_cache);
  cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);
  cache->fp_offset = -1;

  cache->pc = get_frame_func (this_frame);
  if (cache->pc != 0)
    m88k_analyze_prologue (gdbarch, cache->pc, get_frame_pc (this_frame),
			   cache);

  /* Calculate the stack pointer used in the prologue.  */
  if (cache->fp_offset != -1)
    {
      CORE_ADDR fp;

      fp = get_frame_register_unsigned (this_frame, M88K_R30_REGNUM);
      frame_sp = fp - cache->fp_offset;
    }
  else
    {
      /* If we know where the return address is saved, we can take a
         solid guess at what the frame pointer should be.  */
      if (cache->saved_regs[M88K_R1_REGNUM].addr != -1)
	cache->fp_offset = cache->saved_regs[M88K_R1_REGNUM].addr - 4;
      frame_sp = get_frame_register_unsigned (this_frame, M88K_R31_REGNUM);
    }

  /* Now that we know the stack pointer, adjust the location of the
     saved registers.  */
  {
    int regnum;

    for (regnum = M88K_R0_REGNUM; regnum < M88K_R31_REGNUM; regnum ++)
      if (cache->saved_regs[regnum].addr != -1)
	cache->saved_regs[regnum].addr += frame_sp;
  }

  /* Calculate the frame's base.  */
  cache->base = frame_sp - cache->sp_offset;
  trad_frame_set_value (cache->saved_regs, M88K_R31_REGNUM, cache->base);

  /* Identify SXIP with the return address in R1.  */
  cache->saved_regs[M88K_SXIP_REGNUM] = cache->saved_regs[M88K_R1_REGNUM];

  *this_cache = cache;
  return cache;
}

static void
m88k_frame_this_id (struct frame_info *this_frame, void **this_cache,
		    struct frame_id *this_id)
{
  struct m88k_frame_cache *cache = m88k_frame_cache (this_frame, this_cache);

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;

  (*this_id) = frame_id_build (cache->base, cache->pc);
}

static struct value *
m88k_frame_prev_register (struct frame_info *this_frame,
			  void **this_cache, int regnum)
{
  struct m88k_frame_cache *cache = m88k_frame_cache (this_frame, this_cache);

  if (regnum == M88K_SNIP_REGNUM || regnum == M88K_SFIP_REGNUM)
    {
      struct value *value;
      CORE_ADDR pc;

      value = trad_frame_get_prev_register (this_frame, cache->saved_regs,
					    M88K_SXIP_REGNUM);
      pc = value_as_long (value);
      release_value (value);
      value_free (value);

      if (regnum == M88K_SFIP_REGNUM)
	pc += 4;

      return frame_unwind_got_constant (this_frame, regnum, pc + 4);
    }

  return trad_frame_get_prev_register (this_frame, cache->saved_regs, regnum);
}

static const struct frame_unwind m88k_frame_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  m88k_frame_this_id,
  m88k_frame_prev_register,
  NULL,
  default_frame_sniffer
};


static CORE_ADDR
m88k_frame_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct m88k_frame_cache *cache = m88k_frame_cache (this_frame, this_cache);

  if (cache->fp_offset != -1)
    return cache->base + cache->sp_offset + cache->fp_offset;

  return 0;
}

static const struct frame_base m88k_frame_base =
{
  &m88k_frame_unwind,
  m88k_frame_base_address,
  m88k_frame_base_address,
  m88k_frame_base_address
};


/* Core file support.  */

/* Supply register REGNUM from the buffer specified by GREGS and LEN
   in the general-purpose register set REGSET to register cache
   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */

static void
m88k_supply_gregset (const struct regset *regset,
		     struct regcache *regcache,
		     int regnum, const void *gregs, size_t len)
{
  const gdb_byte *regs = gregs;
  int i;

  for (i = 0; i < M88K_NUM_REGS; i++)
    {
      if (regnum == i || regnum == -1)
	regcache_raw_supply (regcache, i, regs + i * 4);
    }
}

/* Motorola 88000 register set.  */

static struct regset m88k_gregset =
{
  NULL,
  m88k_supply_gregset
};

/* Return the appropriate register set for the core section identified
   by SECT_NAME and SECT_SIZE.  */

static const struct regset *
m88k_regset_from_core_section (struct gdbarch *gdbarch,
			       const char *sect_name, size_t sect_size)
{
  if (strcmp (sect_name, ".reg") == 0 && sect_size >= M88K_NUM_REGS * 4)
    return &m88k_gregset;

  return NULL;
}


static struct gdbarch *
m88k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;

  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* Allocate space for the new architecture.  */
  gdbarch = gdbarch_alloc (&info, NULL);

  /* There is no real `long double'.  */
  set_gdbarch_long_double_bit (gdbarch, 64);
  set_gdbarch_long_double_format (gdbarch, floatformats_ieee_double);

  set_gdbarch_num_regs (gdbarch, M88K_NUM_REGS);
  set_gdbarch_register_name (gdbarch, m88k_register_name);
  set_gdbarch_register_type (gdbarch, m88k_register_type);

  /* Register numbers of various important registers.  */
  set_gdbarch_sp_regnum (gdbarch, M88K_R31_REGNUM);
  set_gdbarch_pc_regnum (gdbarch, M88K_SXIP_REGNUM);

  /* Core file support.  */
  set_gdbarch_regset_from_core_section
    (gdbarch, m88k_regset_from_core_section);

  set_gdbarch_print_insn (gdbarch, print_insn_m88k);

  set_gdbarch_skip_prologue (gdbarch, m88k_skip_prologue);

  /* Stack grows downward.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);

  /* Call dummy code.  */
  set_gdbarch_push_dummy_call (gdbarch, m88k_push_dummy_call);
  set_gdbarch_dummy_id (gdbarch, m88k_dummy_id);

  /* Return value info.  */
  set_gdbarch_return_value (gdbarch, m88k_return_value);

  set_gdbarch_addr_bits_remove (gdbarch, m88k_addr_bits_remove);
  set_gdbarch_breakpoint_from_pc (gdbarch, m88k_breakpoint_from_pc);
  set_gdbarch_unwind_pc (gdbarch, m88k_unwind_pc);
  set_gdbarch_write_pc (gdbarch, m88k_write_pc);

  frame_base_set_default (gdbarch, &m88k_frame_base);
  frame_unwind_append_unwinder (gdbarch, &m88k_frame_unwind);

  return gdbarch;
}


/* Provide a prototype to silence -Wmissing-prototypes.  */
void _initialize_m88k_tdep (void);

void
_initialize_m88k_tdep (void)
{
  gdbarch_register (bfd_arch_m88k, m88k_gdbarch_init, NULL);
}
@


1.42
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@d3 1
a3 1
   Copyright (C) 2004-2005, 2007-2012 Free Software Foundation, Inc.
@


1.41
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d386 1
a386 1
m88k_return_value (struct gdbarch *gdbarch, struct type *func_type,
@


1.40
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d3 1
a3 2
   Copyright (C) 2004, 2005, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.40.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2004-2005, 2007-2012 Free Software Foundation, Inc.
@


1.39
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* m2-exp.y: Comment cleanup, mostly periods and spaces.
	* m2-lang.c: Ditto.
	* m2-typeprint.c: Ditto.
	* m2-valprint.c: Ditto.
	* m32c-tdep.c: Ditto.
	* m32r-linux-nat.c: Ditto.
	* m32r-rom.c: Ditto.
	* m32r-tdep.c: Ditto.
	* m32r-tdep.h: Ditto.
	* m68hc11-tdep.c: Ditto.
	* m58klinux-nat.c: Ditto.
	* m68k-tdep.c: Ditto.
	* m88k-tdep.c: Ditto.
	* m88k-tdep.h: Ditto.
	* machoread.c: Ditto.
	* macrocmd.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* mdebugread.h: Ditto.
	* memattr.c: Ditto.
	* memattr.h: Ditto.
	* memory-map.h: Ditto.
	* mep-tdep.c: Ditto.
	* microblaze-rom.c: Ditto.
	* microblaze-tdep.c: Ditto.
	* minsyms.c: Ditto.
	* mips-irix-tdep.c: Ditto.
	* mips-linux-nat.c: Ditto.
	* mips-linux-tdep.c: Ditto.
	* mips-linux-tdep.h: Ditto.
	* mipsnbsd-nat.c: Ditto.
	* mipsnbsd-tdep.c: Ditto.
	* mipsread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mips-tdep.h: Ditto.
	* mn10300-linux-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* mn10300-tdep.h: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* moxie-tdep.c: Ditto.
	* moxie-tdep.h: Ditto.
	* mt-tdep.c: Ditto.
@
text
@d752 1
@


1.38
log
@run copyright.sh for 2011.
@
text
@d71 1
a71 1
   register REGNUM. */
d862 1
a862 1
  /* Return value info */
@


1.37
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d3 1
a3 1
   Copyright (C) 2004, 2005, 2007, 2008, 2009, 2010
@


1.36
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d3 2
a4 1
   Copyright (C) 2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.35
log
@	* gdbtypes.h (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(struct builtin_type): New members builtin_int0, builtin_int8,
	builtin_uint8, builtin_int16, builtin_uint16, builtin_int32,
	builtin_uint32, builtin_int64, builtin_uint64, builtin_int128,
	and builtin_uint128.
	* gdbtypes.c (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(gdbtypes_post_init): Initialize fixed-size integer types.

	* dwarf2expr.c (unsigned_address_type, signed_address_type): Add
	GDBARCH argument.  Return platform-specific type.
	(dwarf2_read_address, execute_stack_op): Update calls.

	* target-descriptions.c (tdesc_gdb_type): Use platform-specific types
	instead of global builtin_int_... variables.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	* printcmd.c (do_examine): Likewise.
	* jv-exp.y (parse_number): Likewise.

	* alpha-tdep.c (alpha_register_type, alpha_push_dummy_call,
	alpha_store_return_value): Likewise.
	* amd64-linux-tdep.c (amd64_linux_register_type): Likewise.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c h8300_register_type): Likewise.
	* hppa-tdep.c (hppa64_push_dummy_call, hppa32_register_type,
	hppa64_register_type): Likewise.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Likewise.
	* iq2000-tdep.c (iq2000_register_type): Likewise.
	* lm32-tdep.c (lm32_register_type, lm32_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68hc11-tdep.c (m68hc11_register_type, m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m88k-tdep.c (m88k_register_type, m88k_store_arguments): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_register_type, mips_pseudo_register_type,
	mips_print_fp_register): Likewise.
	* moxie-tdep.c (moxie_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type, mt_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* score-tdep.c (score_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type, sparc32_store_arguments):
	Likewise.
	* sparc64-tdep.c (sparc64_register_type, sparc64_store_arguments):
	Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* xstormy16-tdep.c (xstormy16_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.

	* mt-tdep.c (struct gdbarch_tdep): New data structure.
	(mt_gdbarch_init): Alloc TDEP structures.
	(mt_register_type): Cache coprocessor type in TDEP instead of
	static global variable.

	* xtensa-tdep.h (struct gdbarch_tdep): Add type_entries member.
	* xtensa-tdep.c (type_entries): Remove.
	(xtensa_register_type): Cache fixed-size types in TDEP instead
	of in global variable.
@
text
@d42 1
a42 1
m88k_fetch_instruction (CORE_ADDR pc)
d44 1
a44 1
  return read_memory_unsigned_integer (pc, 4);
d529 2
a530 1
m88k_analyze_prologue (CORE_ADDR pc, CORE_ADDR limit,
d533 1
d553 1
a553 1
      unsigned long insn = m88k_fetch_instruction (pc);
d648 2
a649 1
  return m88k_analyze_prologue (pc, pc + m88k_max_prologue_size, NULL);
d655 1
d668 2
a669 1
    m88k_analyze_prologue (cache->pc, get_frame_pc (this_frame), cache);
@


1.34
log
@	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
        * alpha-linux-tdep.c (alpha_linux_regset_from_core_section): Make
	it static.
        * alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Declare.
        * amd64fbsd-tdep.c (amd64fbsd_init_abi): Make it static.
        * amd64nbsd-tdep.c (_initialize_amd64nbsd_ndep): Rename to ...
	(_initialize_amd64nbsd_tdep): ... this.
	* arm-linux-tdep.c (arm_linux_software_single_step): Make it static.
	(_initialize_arm_linux_tdep): Declare.
	* armbsd-tdep.c (armbsd_fpreg_offset): Make it static.
	* armnbsd-tdep.c (_initialize_arm_netbsd_tdep): Declare.
	* armobsd-tdep.c (_initialize_armobsd_tdep): Declare.
	* avr-tdep.c (avr_return_value): Make it static.
	(avr_frame_unwind_cache): Ditto.
	* bsd-uthread.c (bsd_uthread_inferior_created): Ditto.
	(bsd_uthread_solib_loaded): Ditto.
	(bsd_uthread_solib_unloaded): Ditto.
	(bsd_uthread_target): Ditto.
	(_initialize_bsd_uthread): Declare.
	* cris-tdep.c (crisv32_single_step_through_delay): Make it static.
	(cris_frame_unwind_cache): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_use_struct_convention): Ditto.
	(h8300h_use_struct_convention): Ditto.
	* hppa-tdep.c (hppa_sign_extend, hppa_low_hppa_sign_extend):
	Ditto.
	* hppa-tdep.h (hppa_low_sign_extend, hppa_sign_extend): Delete
	declarations.
	* hppabsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_find_global_pointer): Make it static.
	* hppabsd-tdep.h: New.
	* hppanbsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Remove declaration.
	(_initialize_hppabsd_tdep): Remove declaration.
	(_initialize_hppanbsd_tdep): Declare.
	* hppaobsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Delete declaration.
	(hppaobsd_init_abi): Make it static.
	* i386-nto-tdep.c (_initialize_i386nto_tdep): Declare.
	* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Declare.
	* ia64-linux-tdep.c (_initialize_ia64_linux_tdep): Declare.
	* ia64-tdep.c (ia64_register_reggroup_p): Make it static.
	* iq2000-tdep.c (_initialize_iq2000_tdep): Declare.
	* m32c-tdep.c (m32c_register_reggroup_p): Make it static.
	(m32c_analyze_prologue, m32c_virtual_frame_pointer): Ditto.
	(_initialize_m32c_tdep): Declare.
	* m32r-rom.c (_initialize_m32r_rom): Declare.
	* m32r-tdep.c (m32r_skip_prologue): Make it static.
	(m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Make it static.
	(m68hc11_return_value): Ditto.
	* m68klinux-tdep.c (_initialize_m68k_linux_tdep): Declare.
	* m88k-tdep.c (m88k_frame_cache): Make it static.
	* mep-tdep.c (mep_gdb_print_insn): Ditto.
	(mep_return_value): Ditto.
	(_initialize_mep_tdep): Declare.
	* mips-irix-tdep.c (_initialize_mips_irix_tdep): Declare.
	* mips-linux-tdep.c (supply_64bit_reg): Make it static.
	(mips_linux_syscall_next_pc): Ditto.
	(_initialize_mips_linux_tdep): Declare.
	* mips-tdep.c (mips_single_step_through_delay): Make it static.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Declare.
	* mn10300-linux-tdep.c (_initialize_mn10300_linux_tdep): Declare.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Declare.
	* mt-tdep.c (_initialize_mt_tdep): Declare.
	* nbsd-tdep.c: Include nbsd-tdep.h.
	* nto-tdep.c (find_load_phdr): Make it static.
	(_initialize_nto_tdep): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Make it
	static.
	(_initialize_ppc_linux_tdep): Declare.
	* remote-m32r-sdi.c (m32r_can_use_hw_watchpoint)
	(m32r_insert_watchpoint, m32r_remove_watchpoint)
	(m32r_stopped_data_address, m32r_stopped_by_watchpoint): Make
	static.
	* rs6000-aix-tdep.c (_initialize_rs6000_aix_tdep): Declare.
	* rs6000-nat.c: Include xcoffread.h.
	(find_toc_address): Don't extern declare get_toc_offset.  Adjust
	to call xcoff_get_to_offset.
	* rs6000-tdep.c (ppc_vsx_support_p, ppc_displaced_step_fixup)
	(rs6000_skip_main_prologue, rs6000_in_solib_return_trampoline)
	(rs6000_skip_trampoline_code): Make static.
	* s390-tdep.c (s390_regset_from_core_section): Ditto.
	* sh-tdep.c (sh_register_reggroup_p): Ditto.
	* shnbsd-tdep.c (shnbsd_regset_from_core_section): Ditto.
	(_initialize_shnbsd_tdep): Declare.
	* solib-frv.c (displacement_from_map): Make static.
	(_initialize_frv_solib): Declare.
	* solib-irix.c (fetch_lm_info): Make static.
	(_initialize_irix_solib): Declare.
	* solib-som.c: Include solib-som.h.
	(som_solib_select): Line break.
	* sparc-tdep.c (sparc_regset_from_core_section): Make static.
	* sparcnbsd-tdep.c (_initialize_sparnbsd_tdep): Rename to ...
	(_initialize_sparcnbsd_tdep): ... this.
	* spu-tdep.c (spu_software_single_step): Make it static.
	(_initialize_spu_tdep): Declare.
	* vax-tdep.c (vax_frame_cache): Make it static.
	* xcoffread.c: Include xcoffread.h.
	(get_toc_offset): Rename to ...
	(xcoff_get_toc_offset): ... this.
	(_initialize_xcoffread): Declare.
	* xcoffread.h: New.
	* xtensa-linux-tdep.c (_initialize_xtensa_linux_tdep): Declare.
	* xtensa-tdep.c (xtensa_skip_prologue, xtensa_derive_tdep): Make
	static.
	(_initialize_xtensa_tdep): Declare.
@
text
@d84 1
a84 1
  return builtin_type_int32;
d261 1
d273 2
a274 1
	  args[i] = value_cast (builtin_type_int32, args[i]);
@


1.33
log
@        Updated copyright notices for most files.
@
text
@d647 1
a647 1
struct m88k_frame_cache *
@


1.32
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.31
log
@	* gdbarch.sh (addr_bits_remove): Change type to 'm'.
	(smash_text_address): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.

	* arch-utils.c (core_addr_identity): Add gdbarch parameter.
	* arch-utils.h (core_addr_identity): Likewise.
	* arm-tdep.c (arm_addr_bits_remove): Likewise.
	(arm_smash_text_address): Likewise.
	* hppa-tdep.c (hppa_smash_text_address): Likewise.
	* m88k-tdep.c (m88k_addr_bits_remove): Likewise.
	* s390-tdep.c (s390_addr_bits_remove): Likewise.

	* mips-tdep.c (mips_addr_bits_remove): Add gdbarch parameter.
	Use it instead of current_gdbarch.

	* arm-tdep.c (arm_prologue_prev_register, arm_unwind_pc,
	arm_dwarf2_prev_register): Update calls.
	* m88k-tdep.c (m88k_unwind_pc): Update call.
@
text
@d78 1
a78 1
    return builtin_type_void_func_ptr;
d82 1
a82 1
    return builtin_type_void_data_ptr;
@


1.30
log
@	* m88k-tdep.c: Update for unwinder changes.
@
text
@d89 1
a89 1
m88k_addr_bits_remove (CORE_ADDR addr)
d119 1
a119 1
  return m88k_addr_bits_remove (pc);
@


1.29
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d368 1
a368 1
m88k_unwind_dummy_id (struct gdbarch *arch, struct frame_info *next_frame)
d372 2
a373 2
  sp = frame_unwind_register_unsigned (next_frame, M88K_R31_REGNUM);
  return frame_id_build (sp, frame_pc_unwind (next_frame));
d648 1
a648 1
m88k_frame_cache (struct frame_info *next_frame, void **this_cache)
d657 1
a657 1
  cache->saved_regs = trad_frame_alloc_saved_regs (next_frame);
d660 1
a660 1
  cache->pc = frame_func_unwind (next_frame, NORMAL_FRAME);
d662 1
a662 1
    m88k_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);
d669 1
a669 1
      fp = frame_unwind_register_unsigned (next_frame, M88K_R30_REGNUM);
d678 1
a678 1
      frame_sp = frame_unwind_register_unsigned (next_frame, M88K_R31_REGNUM);
d703 1
a703 1
m88k_frame_this_id (struct frame_info *next_frame, void **this_cache,
d706 1
a706 1
  struct m88k_frame_cache *cache = m88k_frame_cache (next_frame, this_cache);
d715 3
a717 5
static void
m88k_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, gdb_byte *valuep)
d719 1
a719 1
  struct m88k_frame_cache *cache = m88k_frame_cache (next_frame, this_cache);
d723 8
a730 3
      if (valuep)
	{
	  CORE_ADDR pc;
d732 2
a733 9
	  trad_frame_get_prev_register (next_frame, cache->saved_regs,
					M88K_SXIP_REGNUM, optimizedp,
					lvalp, addrp, realnump, valuep);

	  pc = extract_unsigned_integer (valuep, 4);
	  if (regnum == M88K_SFIP_REGNUM)
	    pc += 4;
	  store_unsigned_integer (valuep, 4, pc + 4);
	}
d735 1
a735 6
      /* It's a computed value.  */
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      return;
d738 1
a738 2
  trad_frame_get_prev_register (next_frame, cache->saved_regs, regnum,
				optimizedp, lvalp, addrp, realnump, valuep);
d745 3
a747 1
  m88k_frame_prev_register
a748 6

static const struct frame_unwind *
m88k_frame_sniffer (struct frame_info *next_frame)
{
  return &m88k_frame_unwind;
}
d752 1
a752 1
m88k_frame_base_address (struct frame_info *next_frame, void **this_cache)
d754 1
a754 1
  struct m88k_frame_cache *cache = m88k_frame_cache (next_frame, this_cache);
d852 1
a852 1
  set_gdbarch_unwind_dummy_id (gdbarch, m88k_unwind_dummy_id);
d863 1
a863 1
  frame_unwind_append_sniffer (gdbarch, m88k_frame_sniffer);
@


1.28
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d384 3
a386 3
m88k_return_value (struct gdbarch *gdbarch, struct type *type,
		   struct regcache *regcache, gdb_byte *readbuf,
		   const gdb_byte *writebuf)
@


1.27
log
@	Updated copyright notices for most files.
@
text
@d629 1
a629 1
m88k_skip_prologue (CORE_ADDR pc)
@


1.26
log
@*** empty log message ***
@
text
@d3 1
a3 1
   Copyright (C) 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.25
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d104 1
a104 1
m88k_breakpoint_from_pc (CORE_ADDR *pc, int *len)
@


1.24
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d52 1
a52 1
m88k_register_name (int regnum)
@


1.23
log
@	* gdbarch.sh (read_pc): Add REGCACHE argument.  Remove PTID argument.
	(write_pc): Likewise.  Remove default implementation, add predicate.
	* gdbarch.c, gdbarch.h: Regenerate.
	* regcache.c (read_pc_pid): Use current regcache instead of calling
	read_register_pid.
	(write_pc_pid): Check gdbarch_write_pc predicate, implement default
	case inline.
	(generic_target_write_pc): Remove.
	* inferior.h (generic_target_write_pc): Remove.
	* frv-tdep.c (frv_gdbarch_init): Do not install it.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Likewise.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	* sh64-tdep.c (sh64_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.

	* avr-tdep.c (avr_read_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling read_register_pid.
	* hppa-hpux-tdep.c (hppa_hpux_read_pc): Likewise.
	* hppa-tdep.c (hppa_read_pc): Likewise.
	* hppa-tdep.h (hppa_read_pc): Likewise.
	* ia64-tdep.c (ia64_read_pc): Likewise.
	* m32r-tdep.c (m32r_read_pc): Likewise.
	* mep-tdep.c (mep_read_pc): Likewise.
	* mn10300-tdep.c (mn10300_read_pc): Likewise.
	* spu-tdep.c (spu_read_pc): Likewise.

	* arm-tdep.c (arm_write_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling write_register_pid.
	* avr-tdep.c (avr_write_pc): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_write_pc): Likewise.
	* hppa-tdep.c (hppa_write_pc): Likewise.
	* hppa-tdep.h (hppa_write_pc): Likewise.
	* i386-linux-tdep.c (i386_linux_write_pc): Likewise.
	* amd64-linux-tdep.c (amd64_linux_write_pc): Likewise.
	* ia64-linux-tdep.c (ia64_linux_write_pc): Likewise.
	* ia64-tdep.c (ia64_write_pc): Likewise.
	* ia64-tdep.h (ia64_write_pc): Likewise.
	* m32r-tdep.c (m32r_write_pc): Likewise.
	* m88k-tdep.c (m88k_write_pc): Likewise.
	* mep-tdep.c (mep_write_pc): Likewise.
	* mips-tdep.c (mips_write_pc): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.
	* mn10300-tdep.c (mn10300_write_pc): Likewise.
	* sparc-tdep.c (sparc_write_pc): Likewise.
	* spu-tdep.c (spu_write_pc): Likewise.

	* mips-tdep.c (read_signed_register): Remove.
	(read_signed_register_pid): Likewise.
	(mips_read_pc): Add REGCACHE argument.  Remove PTID argument.
	Use REGCACHE instead of calling read_signed_register_pid.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.22
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@d125 1
a125 1
m88k_write_pc (CORE_ADDR pc, ptid_t ptid)
d143 3
a145 3
  write_register_pid (M88K_SXIP_REGNUM, pc, ptid);
  write_register_pid (M88K_SNIP_REGNUM, pc | 2, ptid);
  write_register_pid (M88K_SFIP_REGNUM, (pc + 4) | 2, ptid);
@


1.21
log
@	* doublest.c (floatformat_from_length): Use the right element from
	gdbarch floatformats.
	(floatformat_from_type, extract_typed_floating)
	(store_typed_floating): Likewise.
	* doublest.h: Remove declarations for undefined floatformat arrays.
	* gdbarch.sh (float_format, double_format, long_double_format): Change
	to pairs.
	(pformat): Update for pairs.
	* gdbarch.c, gdbarch.h: Regenerated.
	* gdbtypes.c (floatformats_ieee_single, floatformats_ieee_double)
	(floatformats_ieee_double_littlebyte_bigword)
	(floatformats_i387_ext, floatformats_m68881_ext, floatformats_arm_ext)
	(floatformats_ia64_spill, floatformats_ia64_quad, floatformats_vax_f)
	(floatformats_vax_d): New variables.
	(builtin_type_ieee_single, builtin_type_ieee_double)
	(builtin_type_arm_ext, builtin_type_ia64_spill)
	(builtin_type_ia64_quad): Replace arrays with individual types.
	(builtin_type_ieee_single_big, builtin_type_ieee_single_little)
	(builtin_type_ieee_double_big, builtin_type_ieee_double_little)
	(builtin_type_ieee_double_littlebyte_bigword, builtin_type_i960_ext)
	(builtin_type_m88110_ext, builtin_type_m88110_harris_ext)
	(builtin_type_arm_ext_big, builtin_type_arm_ext_littlebyte_bigword)
	(builtin_type_ia64_spill_big, builtin_type_ia64_spill_little)
	(builtin_type_ia64_quad_big, builtin_type_ia64_quad_little): Delete
	unused and endian-specific types.
	(recursive_dump_type): Update for floatformat pairs.
	(build_flt): Move higher.  Handle bit == -1.  Take a floatformat pair.
	(build_gdbtypes): Use build_flt.
	(_initialize_gdbtypes): Update set of initialized types.
	* gdbtypes.h: Update declarations to match gdbtypes.c.
	(struct main_type): Store a pointer to two floatformats.
	* arch-utils.c (default_float_format, default_double_format): Delete.
	* arch-utils.h (default_float_format, default_double_format): Delete.

	* arm-tdep.c, avr-tdep.c, hppa-tdep.c, hppabsd-tdep.c, i386-tdep.c,
	ia64-tdep.c,  iq2000-tdep.c, m68k-tdep.c, m88k-tdep.c,
	mips-linux-tdep.c, mips-tdep.c, mt-tdep.c, ppcobsd-tdep.c,
	sparc-linux-tdep.c, sparc-tdep.c, sparcnbsd-tdep.c, spu-tdep.c,
	vax-tdep.c, alpha-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d662 1
a662 1
  cache->pc = frame_func_unwind (next_frame);
d664 1
a664 4
    {
      CORE_ADDR addr_in_block = frame_unwind_address_in_block (next_frame);
      m88k_analyze_prologue (cache->pc, addr_in_block, cache);
    }
@


1.20
log
@Copyright updates for 2007.
@
text
@d848 1
a848 1
  set_gdbarch_long_double_format (gdbarch, &floatformat_ieee_double_big);
@


1.19
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 1
a3 1
   Copyright (C) 2004, 2005 Free Software Foundation, Inc.
@


1.18
log
@* m88k-tdep.c (m88k_frame_prev_register): Change type of last
argument to `gdb_byte *'.
@
text
@d3 1
a3 1
   Copyright 2004, 2005 Free Software Foundation, Inc.
d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.17
log
@* m88k-tdep.c (m88k_breakpoint_from_pc): Change return type to
`const gdb_byte *'.  Use gdb_byte for break_insn.
(m88k_return_value): Change type of readbuf and
writebuf arguments to `gdb_byte *'.  Use gdb_byte for buf.
(m88k_supply_gregset): Use `gdb_byte *' for regs.
@
text
@d724 1
a724 1
			  int *realnump, void *valuep)
@


1.16
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d105 1
a105 1
static const unsigned char *
d109 1
a109 1
  static unsigned char break_insn[] = { 0xf0, 0x00, 0xd1, 0xff };
d387 2
a388 2
		   struct regcache *regcache, void *readbuf,
		   const void *writebuf)
d391 1
a391 1
  char buf[8];
d801 1
a801 1
  const char *regs = gregs;
@


1.15
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* sparc-tdep.c: Replace VALUE_TYPE with value_type.
	* v850-tdep.c, sparc64-tdep.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, s390-tdep.c, mcore-tdep.c: Ditto.
	* h8300-tdep.c, arm-linux-tdep.c, amd64-tdep.c: Ditto.
	* hppa-tdep.c, mips-tdep.c, m88k-tdep.c: Ditto.
	* m68hc11-tdep.c, m32r-tdep.c, ia64-tdep.c: Ditto.
	* frv-tdep.c, cris-tdep.c, avr-tdep.c, alpha-tdep.c: Ditto.
@
text
@d3 1
a3 1
   Copyright 2004 Free Software Foundation, Inc.
d309 1
a309 1
      char *valbuf = VALUE_CONTENTS (args[i]);
@


1.14
log
@2004-07-31  Andrew Cagney  <cagney@@gnu.org>

	* trad-frame.c (trad_frame_get_prev_register): Rename
	trad_frame_get_prev_register.
	* vax-tdep.c (vax_frame_prev_register): Update.
	* trad-frame.h: Update.
	* trad-frame.c (trad_frame_get_register): Update.
	* sparcobsd-tdep.c (sparc32obsd_frame_prev_register): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64obsd-tdep.c (sparc64obsd_frame_prev_register): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_prev_register):
	Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_prev_register):
	Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_prev_register):
	Update.
	* sparc-linux-tdep.c (sparc32_linux_sigtramp_frame_prev_register):
	Update.
	* s390-tdep.c (s390_frame_prev_register)
	(s390_stub_frame_prev_register)
	(s390_sigtramp_frame_prev_register): Update.
	* rs6000-tdep.c (rs6000_frame_prev_register): Update.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_prev_register): Update.
	* mips-tdep.c (mips_mdebug_frame_prev_register): Update.
	* m88k-tdep.c (m88k_frame_prev_register)
	* m68hc11-tdep.c (m68hc11_frame_prev_register)
	* m32r-tdep.c (m32r_frame_prev_register): Update.
	* hppa-tdep.c (hppa_frame_prev_register_helper)
	* frv-tdep.c (frv_frame_prev_register): Update.
	* d10v-tdep.c (d10v_frame_prev_register): Update.
	* cris-tdep.c (cris_frame_prev_register): Update.
	* avr-tdep.c (avr_frame_prev_register): Update.
	* arm-tdep.c (arm_prologue_prev_register)
	(arm_sigtramp_prev_register): Update.
@
text
@d269 1
a269 1
      struct type *type = VALUE_TYPE (args[i]);
d275 1
a275 1
	  type = VALUE_TYPE (args[i]);
d310 1
a310 1
      struct type *type = VALUE_TYPE (args[i]);
@


1.14.2.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@@


1.13
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (PUSH_DUMMY_CALL): Change CORE_ADDR func_addr argument
	to struct value *function.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.
	* infcall.c (call_function_by_hand): Pass entire function value
	to push_dummy_call.

	* Makefile.in (alpha-tdep.o, frv-tdep.o, ia64-tdep.o, mips-tdep.o)
	(ppc-sysv-tdep.o, rs6000-tdep.o): Update dependencies.
	* alpha-tdep.c (alpha_push_dummy_call): Update call signature.
	* amd64-tdep.c (amd64_push_dummy_call): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* avr-tdep.c (avr_push_dummy_call): Likewise.
	* cris-tdep.c (cris_push_dummy_call): Likewise.
	* d10v-tdep.c (d10v_push_dummy_call): Likewise.
	* frv-tdep.c (frv_push_dummy_call): Likewise.
	* h8300-tdep.c (h8300_push_dummy_call): Likewise.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_push_dummy_call): Likewise.
	* i386-tdep.c (i386_push_dummy_call): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	* m68k-tdep.c (m68k_push_dummy_call): Likewise.
	* m88k-tdep.c (m88k_push_dummy_call): Likewise.
	* mips-tdep.c (mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
	* s390-tdep.c (s390_push_dummy_call): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu)
	(sh_push_dummy_call_nofpu): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_call): Likewise.
	* sparc64-tdep.c (sparc64_push_dummy_call): Likewise.
	* vax-tdep.c (vax_push_dummy_call): Likewise.
@
text
@d734 3
a736 3
	  trad_frame_prev_register (next_frame, cache->saved_regs,
				    M88K_SXIP_REGNUM, optimizedp,
				    lvalp, addrp, realnump, valuep);
d752 2
a753 2
  trad_frame_prev_register (next_frame, cache->saved_regs, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
@


1.12
log
@* m88k-tdep.c (m88k_analyze_prologue): Fix handling of branch
instructions.
(m88k_frame_prev_register): Simplify code a bit.
@
text
@d347 1
a347 1
m88k_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
@


1.11
log
@Add OpenBSD/m88k support.
* NEWS (New native configurations): Mention OpenBSD/m88k.
* m88k-tdep.c, m88k-tdep.h, m88kbsd-nat.c, config/m88k/nm-obsd.h,
config/m88k/obsd.mh, config/m88k/obsd.mt: New files.
* Makefile.in (m88k_tdep_h): New variable.
(ALLDEPFILES): Add m88k-tdep.c and m88kbsd-nat.c.
(m88kbsd-nat.o, m88k-tdep.o): New dependencies.
* configure.host: Add m88*-*-openbsd*.
* configure.tgt: Add m88*-*-openbsd*.
@
text
@d610 1
a610 1
	  limit = pc + M88K_INSN_SIZE;
d739 1
a739 1
	  if (regnum == M88K_SNIP_REGNUM)
d741 1
a741 3
	  else if (regnum == M88K_SFIP_REGNUM)
	    pc += 8;
	  store_unsigned_integer (valuep, 4, pc);
@


1.10
log
@2002-12-16  Andrew Cagney  <ac131313@@redhat.com>

	* config/arc/arc.mt, config/arc/tm-arc.h: Delete.
	* config/d30v/d30v.mt, config/d30v/tm-d30v.h: Delete.
	* config/fr30/fr30.mt, config/fr30/tm-fr30.h: Delete.
	* config/i386/i386aix.mh, config/i386/i386aix.mt: Delete.
	* config/i386/i386m3.mh, config/i386/i386m3.mt: Delete.
	* config/i386/i386mach.mh, config/i386/i386os9k.mt: Delete.
	* config/i386/nm-i386aix.h, config/i386/nm-i386mach.h: Delete.
	* config/i386/nm-m3.h, config/i386/tm-i386aix.h: Delete.
	* config/i386/tm-i386m3.h, config/i386/tm-i386mk.h: Delete.
	* config/i386/xm-i386aix.h, config/i386/xm-i386m3.h: Delete.
	* config/i386/xm-i386mach.h, config/i386/xm-i386mk.h: Delete.
	* config/i960/mon960.mt, config/i960/nindy960.mt: Delete.
	* config/i960/tm-i960.h, config/i960/tm-mon960.h: Delete.
	* config/i960/tm-nindy960.h, config/i960/tm-vx960.h: Delete.
	* config/i960/vxworks960.mt, config/m68k/apollo68b.mh: Delete.
	* config/m68k/apollo68b.mt, config/m68k/apollo68v.mh: Delete.
	* config/m68k/hp300bsd.mh, config/m68k/hp300bsd.mt: Delete.
	* config/m68k/hp300hpux.mh, config/m68k/hp300hpux.mt: Delete.
	* config/m88k/delta88.mh, config/m88k/delta88.mt: Delete.
	* config/m88k/delta88v4.mh, config/m88k/delta88v4.mt: Delete.
	* config/m88k/m88k.mh, config/m88k/m88k.mt: Delete.
	* config/m88k/nm-delta88v4.h, config/m88k/nm-m88k.h: Delete.
	* config/m88k/tm-delta88.h, config/m88k/tm-delta88v4.h: Delete.
	* config/m88k/tm-m88k.h, config/m88k/xm-delta88.h: Delete.
	* config/m88k/xm-dgux.h: Delete.
	* fr30-tdep.c, i386aix-nat.c, i386m3-nat.c: Delete.
	* i386mach-nat.c, i960-tdep.c, m88k-nat.c: Delete.
	* os9kread.c, remote-bug.c, remote-nindy.c: Delete.
	* remote-nrom.c, remote-os9k.c, remote-vx960.c: Delete.
	* d30v-tdep.c, arc-tdep.c, cxux-nat.c, dst.h, dstread.c: Delete.
	* ch-exp.c, ch-lang.c, ch-lang.h, ch-typeprint.c: Delete.
	* ch-valprint.c: Delete.
@
text
@d1 897
a897 661
// OBSOLETE /* Target-machine dependent code for Motorola 88000 series, for GDB.
// OBSOLETE 
// OBSOLETE    Copyright 1988, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998,
// OBSOLETE    2000, 2001, 2002 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "setjmp.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE /* Size of an instruction */
// OBSOLETE #define	BYTES_PER_88K_INSN	4
// OBSOLETE 
// OBSOLETE void frame_find_saved_regs ();
// OBSOLETE 
// OBSOLETE /* Is this target an m88110?  Otherwise assume m88100.  This has
// OBSOLETE    relevance for the ways in which we screw with instruction pointers.  */
// OBSOLETE 
// OBSOLETE int target_is_m88110 = 0;
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m88k_target_write_pc (CORE_ADDR pc, ptid_t ptid)
// OBSOLETE {
// OBSOLETE   /* According to the MC88100 RISC Microprocessor User's Manual,
// OBSOLETE      section 6.4.3.1.2:
// OBSOLETE 
// OBSOLETE      ... can be made to return to a particular instruction by placing
// OBSOLETE      a valid instruction address in the SNIP and the next sequential
// OBSOLETE      instruction address in the SFIP (with V bits set and E bits
// OBSOLETE      clear).  The rte resumes execution at the instruction pointed to
// OBSOLETE      by the SNIP, then the SFIP.
// OBSOLETE 
// OBSOLETE      The E bit is the least significant bit (bit 0).  The V (valid)
// OBSOLETE      bit is bit 1.  This is why we logical or 2 into the values we are
// OBSOLETE      writing below.  It turns out that SXIP plays no role when
// OBSOLETE      returning from an exception so nothing special has to be done
// OBSOLETE      with it.  We could even (presumably) give it a totally bogus
// OBSOLETE      value.
// OBSOLETE 
// OBSOLETE      -- Kevin Buettner */
// OBSOLETE 
// OBSOLETE   write_register_pid (SXIP_REGNUM, pc, ptid);
// OBSOLETE   write_register_pid (SNIP_REGNUM, (pc | 2), ptid);
// OBSOLETE   write_register_pid (SFIP_REGNUM, (pc | 2) + 4, ptid);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* The type of a register.  */
// OBSOLETE struct type *
// OBSOLETE m88k_register_type (int regnum)
// OBSOLETE {
// OBSOLETE   if (regnum >= XFP_REGNUM)
// OBSOLETE     return builtin_type_m88110_ext;
// OBSOLETE   else if (regnum == PC_REGNUM || regnum == FP_REGNUM || regnum == SP_REGNUM)
// OBSOLETE     return builtin_type_void_func_ptr;
// OBSOLETE   else
// OBSOLETE     return builtin_type_int32;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* The m88k kernel aligns all instructions on 4-byte boundaries.  The
// OBSOLETE    kernel also uses the least significant two bits for its own hocus
// OBSOLETE    pocus.  When gdb receives an address from the kernel, it needs to
// OBSOLETE    preserve those right-most two bits, but gdb also needs to be careful
// OBSOLETE    to realize that those two bits are not really a part of the address
// OBSOLETE    of an instruction.  Shrug.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE m88k_addr_bits_remove (CORE_ADDR addr)
// OBSOLETE {
// OBSOLETE   return ((addr) & ~3);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Given a GDB frame, determine the address of the calling function's frame.
// OBSOLETE    This will be used to create a new GDB frame struct, and then
// OBSOLETE    INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.
// OBSOLETE 
// OBSOLETE    For us, the frame address is its stack pointer value, so we look up
// OBSOLETE    the function prologue to determine the caller's sp value, and return it.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE frame_chain (struct frame_info *thisframe)
// OBSOLETE {
// OBSOLETE 
// OBSOLETE   frame_find_saved_regs (thisframe, (struct frame_saved_regs *) 0);
// OBSOLETE   /* NOTE:  this depends on frame_find_saved_regs returning the VALUE, not
// OBSOLETE      the ADDRESS, of SP_REGNUM.  It also depends on the cache of
// OBSOLETE      frame_find_saved_regs results.  */
// OBSOLETE   if (thisframe->fsr->regs[SP_REGNUM])
// OBSOLETE     return thisframe->fsr->regs[SP_REGNUM];
// OBSOLETE   else
// OBSOLETE     return thisframe->frame;	/* Leaf fn -- next frame up has same SP. */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE frameless_function_invocation (struct frame_info *frame)
// OBSOLETE {
// OBSOLETE 
// OBSOLETE   frame_find_saved_regs (frame, (struct frame_saved_regs *) 0);
// OBSOLETE   /* NOTE:  this depends on frame_find_saved_regs returning the VALUE, not
// OBSOLETE      the ADDRESS, of SP_REGNUM.  It also depends on the cache of
// OBSOLETE      frame_find_saved_regs results.  */
// OBSOLETE   if (frame->fsr->regs[SP_REGNUM])
// OBSOLETE     return 0;			/* Frameful -- return addr saved somewhere */
// OBSOLETE   else
// OBSOLETE     return 1;			/* Frameless -- no saved return address */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE init_extra_frame_info (int fromleaf, struct frame_info *frame)
// OBSOLETE {
// OBSOLETE   frame->fsr = 0;		/* Not yet allocated */
// OBSOLETE   frame->args_pointer = 0;	/* Unknown */
// OBSOLETE   frame->locals_pointer = 0;	/* Unknown */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Examine an m88k function prologue, recording the addresses at which
// OBSOLETE    registers are saved explicitly by the prologue code, and returning
// OBSOLETE    the address of the first instruction after the prologue (but not
// OBSOLETE    after the instruction at address LIMIT, as explained below).
// OBSOLETE 
// OBSOLETE    LIMIT places an upper bound on addresses of the instructions to be
// OBSOLETE    examined.  If the prologue code scan reaches LIMIT, the scan is
// OBSOLETE    aborted and LIMIT is returned.  This is used, when examining the
// OBSOLETE    prologue for the current frame, to keep examine_prologue () from
// OBSOLETE    claiming that a given register has been saved when in fact the
// OBSOLETE    instruction that saves it has not yet been executed.  LIMIT is used
// OBSOLETE    at other times to stop the scan when we hit code after the true
// OBSOLETE    function prologue (e.g. for the first source line) which might
// OBSOLETE    otherwise be mistaken for function prologue.
// OBSOLETE 
// OBSOLETE    The format of the function prologue matched by this routine is
// OBSOLETE    derived from examination of the source to gcc 1.95, particularly
// OBSOLETE    the routine output_prologue () in config/out-m88k.c.
// OBSOLETE 
// OBSOLETE    subu r31,r31,n                       # stack pointer update
// OBSOLETE 
// OBSOLETE    (st rn,r31,offset)?                  # save incoming regs
// OBSOLETE    (st.d rn,r31,offset)?
// OBSOLETE 
// OBSOLETE    (addu r30,r31,n)?                    # frame pointer update
// OBSOLETE 
// OBSOLETE    (pic sequence)?                      # PIC code prologue
// OBSOLETE 
// OBSOLETE    (or   rn,rm,0)?                      # Move parameters to other regs
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE /* Macros for extracting fields from instructions.  */
// OBSOLETE 
// OBSOLETE #define BITMASK(pos, width) (((0x1 << (width)) - 1) << (pos))
// OBSOLETE #define EXTRACT_FIELD(val, pos, width) ((val) >> (pos) & BITMASK (0, width))
// OBSOLETE #define	SUBU_OFFSET(x)	((unsigned)(x & 0xFFFF))
// OBSOLETE #define	ST_OFFSET(x)	((unsigned)((x) & 0xFFFF))
// OBSOLETE #define	ST_SRC(x)	EXTRACT_FIELD ((x), 21, 5)
// OBSOLETE #define	ADDU_OFFSET(x)	((unsigned)(x & 0xFFFF))
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * prologue_insn_tbl is a table of instructions which may comprise a
// OBSOLETE  * function prologue.  Associated with each table entry (corresponding
// OBSOLETE  * to a single instruction or group of instructions), is an action.
// OBSOLETE  * This action is used by examine_prologue (below) to determine
// OBSOLETE  * the state of certain machine registers and where the stack frame lives.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE enum prologue_insn_action
// OBSOLETE {
// OBSOLETE   PIA_SKIP,			/* don't care what the instruction does */
// OBSOLETE   PIA_NOTE_ST,			/* note register stored and where */
// OBSOLETE   PIA_NOTE_STD,			/* note pair of registers stored and where */
// OBSOLETE   PIA_NOTE_SP_ADJUSTMENT,	/* note stack pointer adjustment */
// OBSOLETE   PIA_NOTE_FP_ASSIGNMENT,	/* note frame pointer assignment */
// OBSOLETE   PIA_NOTE_PROLOGUE_END,	/* no more prologue */
// OBSOLETE };
// OBSOLETE 
// OBSOLETE struct prologue_insns
// OBSOLETE   {
// OBSOLETE     unsigned long insn;
// OBSOLETE     unsigned long mask;
// OBSOLETE     enum prologue_insn_action action;
// OBSOLETE   };
// OBSOLETE 
// OBSOLETE struct prologue_insns prologue_insn_tbl[] =
// OBSOLETE {
// OBSOLETE   /* Various register move instructions */
// OBSOLETE   {0x58000000, 0xf800ffff, PIA_SKIP},	/* or/or.u with immed of 0 */
// OBSOLETE   {0xf4005800, 0xfc1fffe0, PIA_SKIP},	/* or rd, r0, rs */
// OBSOLETE   {0xf4005800, 0xfc00ffff, PIA_SKIP},	/* or rd, rs, r0 */
// OBSOLETE 
// OBSOLETE   /* Stack pointer setup: "subu sp, sp, n" where n is a multiple of 8 */
// OBSOLETE   {0x67ff0000, 0xffff0007, PIA_NOTE_SP_ADJUSTMENT},
// OBSOLETE 
// OBSOLETE   /* Frame pointer assignment: "addu r30, r31, n" */
// OBSOLETE   {0x63df0000, 0xffff0000, PIA_NOTE_FP_ASSIGNMENT},
// OBSOLETE 
// OBSOLETE   /* Store to stack instructions; either "st rx, sp, n" or "st.d rx, sp, n" */
// OBSOLETE   {0x241f0000, 0xfc1f0000, PIA_NOTE_ST},	/* st rx, sp, n */
// OBSOLETE   {0x201f0000, 0xfc1f0000, PIA_NOTE_STD},	/* st.d rs, sp, n */
// OBSOLETE 
// OBSOLETE   /* Instructions needed for setting up r25 for pic code. */
// OBSOLETE   {0x5f200000, 0xffff0000, PIA_SKIP},	/* or.u r25, r0, offset_high */
// OBSOLETE   {0xcc000002, 0xffffffff, PIA_SKIP},	/* bsr.n Lab */
// OBSOLETE   {0x5b390000, 0xffff0000, PIA_SKIP},	/* or r25, r25, offset_low */
// OBSOLETE   {0xf7396001, 0xffffffff, PIA_SKIP},	/* Lab: addu r25, r25, r1 */
// OBSOLETE 
// OBSOLETE   /* Various branch or jump instructions which have a delay slot -- these
// OBSOLETE      do not form part of the prologue, but the instruction in the delay
// OBSOLETE      slot might be a store instruction which should be noted. */
// OBSOLETE   {0xc4000000, 0xe4000000, PIA_NOTE_PROLOGUE_END},
// OBSOLETE 					/* br.n, bsr.n, bb0.n, or bb1.n */
// OBSOLETE   {0xec000000, 0xfc000000, PIA_NOTE_PROLOGUE_END},	/* bcnd.n */
// OBSOLETE   {0xf400c400, 0xfffff7e0, PIA_NOTE_PROLOGUE_END}	/* jmp.n or jsr.n */
// OBSOLETE 
// OBSOLETE };
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or
// OBSOLETE    is not the address of a valid instruction, the address of the next
// OBSOLETE    instruction beyond ADDR otherwise.  *PWORD1 receives the first word
// OBSOLETE    of the instruction. */
// OBSOLETE 
// OBSOLETE #define NEXT_PROLOGUE_INSN(addr, lim, pword1) \
// OBSOLETE   (((addr) < (lim)) ? next_insn (addr, pword1) : 0)
// OBSOLETE 
// OBSOLETE /* Read the m88k instruction at 'memaddr' and return the address of 
// OBSOLETE    the next instruction after that, or 0 if 'memaddr' is not the
// OBSOLETE    address of a valid instruction.  The instruction
// OBSOLETE    is stored at 'pword1'.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE next_insn (CORE_ADDR memaddr, unsigned long *pword1)
// OBSOLETE {
// OBSOLETE   *pword1 = read_memory_integer (memaddr, BYTES_PER_88K_INSN);
// OBSOLETE   return memaddr + BYTES_PER_88K_INSN;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Read a register from frames called by us (or from the hardware regs).  */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE read_next_frame_reg (struct frame_info *frame, int regno)
// OBSOLETE {
// OBSOLETE   for (; frame; frame = frame->next)
// OBSOLETE     {
// OBSOLETE       if (regno == SP_REGNUM)
// OBSOLETE 	return FRAME_FP (frame);
// OBSOLETE       else if (frame->fsr->regs[regno])
// OBSOLETE 	return read_memory_integer (frame->fsr->regs[regno], 4);
// OBSOLETE     }
// OBSOLETE   return read_register (regno);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Examine the prologue of a function.  `ip' points to the first instruction.
// OBSOLETE    `limit' is the limit of the prologue (e.g. the addr of the first 
// OBSOLETE    linenumber, or perhaps the program counter if we're stepping through).
// OBSOLETE    `frame_sp' is the stack pointer value in use in this frame.  
// OBSOLETE    `fsr' is a pointer to a frame_saved_regs structure into which we put
// OBSOLETE    info about the registers saved by this frame.  
// OBSOLETE    `fi' is a struct frame_info pointer; we fill in various fields in it
// OBSOLETE    to reflect the offsets of the arg pointer and the locals pointer.  */
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE examine_prologue (register CORE_ADDR ip, register CORE_ADDR limit,
// OBSOLETE 		  CORE_ADDR frame_sp, struct frame_saved_regs *fsr,
// OBSOLETE 		  struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   register CORE_ADDR next_ip;
// OBSOLETE   register int src;
// OBSOLETE   unsigned long insn;
// OBSOLETE   int size, offset;
// OBSOLETE   char must_adjust[32];		/* If set, must adjust offsets in fsr */
// OBSOLETE   int sp_offset = -1;		/* -1 means not set (valid must be mult of 8) */
// OBSOLETE   int fp_offset = -1;		/* -1 means not set */
// OBSOLETE   CORE_ADDR frame_fp;
// OBSOLETE   CORE_ADDR prologue_end = 0;
// OBSOLETE 
// OBSOLETE   memset (must_adjust, '\0', sizeof (must_adjust));
// OBSOLETE   next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn);
// OBSOLETE 
// OBSOLETE   while (next_ip)
// OBSOLETE     {
// OBSOLETE       struct prologue_insns *pip;
// OBSOLETE 
// OBSOLETE       for (pip = prologue_insn_tbl; (insn & pip->mask) != pip->insn;)
// OBSOLETE 	if (++pip >= prologue_insn_tbl + sizeof prologue_insn_tbl)
// OBSOLETE 	  goto end_of_prologue_found;	/* not a prologue insn */
// OBSOLETE 
// OBSOLETE       switch (pip->action)
// OBSOLETE 	{
// OBSOLETE 	case PIA_NOTE_ST:
// OBSOLETE 	case PIA_NOTE_STD:
// OBSOLETE 	  if (sp_offset != -1)
// OBSOLETE 	    {
// OBSOLETE 	      src = ST_SRC (insn);
// OBSOLETE 	      offset = ST_OFFSET (insn);
// OBSOLETE 	      must_adjust[src] = 1;
// OBSOLETE 	      fsr->regs[src++] = offset;	/* Will be adjusted later */
// OBSOLETE 	      if (pip->action == PIA_NOTE_STD && src < 32)
// OBSOLETE 		{
// OBSOLETE 		  offset += 4;
// OBSOLETE 		  must_adjust[src] = 1;
// OBSOLETE 		  fsr->regs[src++] = offset;
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    goto end_of_prologue_found;
// OBSOLETE 	  break;
// OBSOLETE 	case PIA_NOTE_SP_ADJUSTMENT:
// OBSOLETE 	  if (sp_offset == -1)
// OBSOLETE 	    sp_offset = -SUBU_OFFSET (insn);
// OBSOLETE 	  else
// OBSOLETE 	    goto end_of_prologue_found;
// OBSOLETE 	  break;
// OBSOLETE 	case PIA_NOTE_FP_ASSIGNMENT:
// OBSOLETE 	  if (fp_offset == -1)
// OBSOLETE 	    fp_offset = ADDU_OFFSET (insn);
// OBSOLETE 	  else
// OBSOLETE 	    goto end_of_prologue_found;
// OBSOLETE 	  break;
// OBSOLETE 	case PIA_NOTE_PROLOGUE_END:
// OBSOLETE 	  if (!prologue_end)
// OBSOLETE 	    prologue_end = ip;
// OBSOLETE 	  break;
// OBSOLETE 	case PIA_SKIP:
// OBSOLETE 	default:
// OBSOLETE 	  /* Do nothing */
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       ip = next_ip;
// OBSOLETE       next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE end_of_prologue_found:
// OBSOLETE 
// OBSOLETE   if (prologue_end)
// OBSOLETE     ip = prologue_end;
// OBSOLETE 
// OBSOLETE   /* We're done with the prologue.  If we don't care about the stack
// OBSOLETE      frame itself, just return.  (Note that fsr->regs has been trashed,
// OBSOLETE      but the one caller who calls with fi==0 passes a dummy there.)  */
// OBSOLETE 
// OBSOLETE   if (fi == 0)
// OBSOLETE     return ip;
// OBSOLETE 
// OBSOLETE   /*
// OBSOLETE      OK, now we have:
// OBSOLETE 
// OBSOLETE      sp_offset  original (before any alloca calls) displacement of SP
// OBSOLETE      (will be negative).
// OBSOLETE 
// OBSOLETE      fp_offset  displacement from original SP to the FP for this frame
// OBSOLETE      or -1.
// OBSOLETE 
// OBSOLETE      fsr->regs[0..31]   displacement from original SP to the stack
// OBSOLETE      location where reg[0..31] is stored.
// OBSOLETE 
// OBSOLETE      must_adjust[0..31] set if corresponding offset was set.
// OBSOLETE 
// OBSOLETE      If alloca has been called between the function prologue and the current
// OBSOLETE      IP, then the current SP (frame_sp) will not be the original SP as set by
// OBSOLETE      the function prologue.  If the current SP is not the original SP, then the
// OBSOLETE      compiler will have allocated an FP for this frame, fp_offset will be set,
// OBSOLETE      and we can use it to calculate the original SP.
// OBSOLETE 
// OBSOLETE      Then, we figure out where the arguments and locals are, and relocate the
// OBSOLETE      offsets in fsr->regs to absolute addresses.  */
// OBSOLETE 
// OBSOLETE   if (fp_offset != -1)
// OBSOLETE     {
// OBSOLETE       /* We have a frame pointer, so get it, and base our calc's on it.  */
// OBSOLETE       frame_fp = (CORE_ADDR) read_next_frame_reg (fi->next, ACTUAL_FP_REGNUM);
// OBSOLETE       frame_sp = frame_fp - fp_offset;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* We have no frame pointer, therefore frame_sp is still the same value
// OBSOLETE          as set by prologue.  But where is the frame itself?  */
// OBSOLETE       if (must_adjust[SRP_REGNUM])
// OBSOLETE 	{
// OBSOLETE 	  /* Function header saved SRP (r1), the return address.  Frame starts
// OBSOLETE 	     4 bytes down from where it was saved.  */
// OBSOLETE 	  frame_fp = frame_sp + fsr->regs[SRP_REGNUM] - 4;
// OBSOLETE 	  fi->locals_pointer = frame_fp;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* Function header didn't save SRP (r1), so we are in a leaf fn or
// OBSOLETE 	     are otherwise confused.  */
// OBSOLETE 	  frame_fp = -1;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* The locals are relative to the FP (whether it exists as an allocated
// OBSOLETE      register, or just as an assumed offset from the SP) */
// OBSOLETE   fi->locals_pointer = frame_fp;
// OBSOLETE 
// OBSOLETE   /* The arguments are just above the SP as it was before we adjusted it
// OBSOLETE      on entry.  */
// OBSOLETE   fi->args_pointer = frame_sp - sp_offset;
// OBSOLETE 
// OBSOLETE   /* Now that we know the SP value used by the prologue, we know where
// OBSOLETE      it saved all the registers.  */
// OBSOLETE   for (src = 0; src < 32; src++)
// OBSOLETE     if (must_adjust[src])
// OBSOLETE       fsr->regs[src] += frame_sp;
// OBSOLETE 
// OBSOLETE   /* The saved value of the SP is always known.  */
// OBSOLETE   /* (we hope...) */
// OBSOLETE   if (fsr->regs[SP_REGNUM] != 0
// OBSOLETE       && fsr->regs[SP_REGNUM] != frame_sp - sp_offset)
// OBSOLETE     fprintf_unfiltered (gdb_stderr, "Bad saved SP value %lx != %lx, offset %x!\n",
// OBSOLETE 			fsr->regs[SP_REGNUM],
// OBSOLETE 			frame_sp - sp_offset, sp_offset);
// OBSOLETE 
// OBSOLETE   fsr->regs[SP_REGNUM] = frame_sp - sp_offset;
// OBSOLETE 
// OBSOLETE   return (ip);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Given an ip value corresponding to the start of a function,
// OBSOLETE    return the ip of the first instruction after the function 
// OBSOLETE    prologue.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE m88k_skip_prologue (CORE_ADDR ip)
// OBSOLETE {
// OBSOLETE   struct frame_saved_regs saved_regs_dummy;
// OBSOLETE   struct symtab_and_line sal;
// OBSOLETE   CORE_ADDR limit;
// OBSOLETE 
// OBSOLETE   sal = find_pc_line (ip, 0);
// OBSOLETE   limit = (sal.end) ? sal.end : 0xffffffff;
// OBSOLETE 
// OBSOLETE   return (examine_prologue (ip, limit, (CORE_ADDR) 0, &saved_regs_dummy,
// OBSOLETE 			    (struct frame_info *) 0));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Put here the code to store, into a struct frame_saved_regs,
// OBSOLETE    the addresses of the saved registers of frame described by FRAME_INFO.
// OBSOLETE    This includes special registers such as pc and fp saved in special
// OBSOLETE    ways in the stack frame.  sp is even more special:
// OBSOLETE    the address we return for it IS the sp for the next frame.
// OBSOLETE 
// OBSOLETE    We cache the result of doing this in the frame_obstack, since it is
// OBSOLETE    fairly expensive.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE frame_find_saved_regs (struct frame_info *fi, struct frame_saved_regs *fsr)
// OBSOLETE {
// OBSOLETE   register struct frame_saved_regs *cache_fsr;
// OBSOLETE   CORE_ADDR ip;
// OBSOLETE   struct symtab_and_line sal;
// OBSOLETE   CORE_ADDR limit;
// OBSOLETE 
// OBSOLETE   if (!fi->fsr)
// OBSOLETE     {
// OBSOLETE       cache_fsr = (struct frame_saved_regs *)
// OBSOLETE 	frame_obstack_alloc (sizeof (struct frame_saved_regs));
// OBSOLETE       memset (cache_fsr, '\0', sizeof (struct frame_saved_regs));
// OBSOLETE       fi->fsr = cache_fsr;
// OBSOLETE 
// OBSOLETE       /* Find the start and end of the function prologue.  If the PC
// OBSOLETE          is in the function prologue, we only consider the part that
// OBSOLETE          has executed already.  In the case where the PC is not in
// OBSOLETE          the function prologue, we set limit to two instructions beyond
// OBSOLETE          where the prologue ends in case if any of the prologue instructions
// OBSOLETE          were moved into a delay slot of a branch instruction. */
// OBSOLETE 
// OBSOLETE       ip = get_pc_function_start (fi->pc);
// OBSOLETE       sal = find_pc_line (ip, 0);
// OBSOLETE       limit = (sal.end && sal.end < fi->pc) ? sal.end + 2 * BYTES_PER_88K_INSN
// OBSOLETE 	: fi->pc;
// OBSOLETE 
// OBSOLETE       /* This will fill in fields in *fi as well as in cache_fsr.  */
// OBSOLETE #ifdef SIGTRAMP_FRAME_FIXUP
// OBSOLETE       if (fi->signal_handler_caller)
// OBSOLETE 	SIGTRAMP_FRAME_FIXUP (fi->frame);
// OBSOLETE #endif
// OBSOLETE       examine_prologue (ip, limit, fi->frame, cache_fsr, fi);
// OBSOLETE #ifdef SIGTRAMP_SP_FIXUP
// OBSOLETE       if (fi->signal_handler_caller && fi->fsr->regs[SP_REGNUM])
// OBSOLETE 	SIGTRAMP_SP_FIXUP (fi->fsr->regs[SP_REGNUM]);
// OBSOLETE #endif
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (fsr)
// OBSOLETE     *fsr = *fi->fsr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the address of the locals block for the frame
// OBSOLETE    described by FI.  Returns 0 if the address is unknown.
// OBSOLETE    NOTE!  Frame locals are referred to by negative offsets from the
// OBSOLETE    argument pointer, so this is the same as frame_args_address().  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE frame_locals_address (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   struct frame_saved_regs fsr;
// OBSOLETE 
// OBSOLETE   if (fi->args_pointer)		/* Cached value is likely there.  */
// OBSOLETE     return fi->args_pointer;
// OBSOLETE 
// OBSOLETE   /* Nope, generate it.  */
// OBSOLETE 
// OBSOLETE   get_frame_saved_regs (fi, &fsr);
// OBSOLETE 
// OBSOLETE   return fi->args_pointer;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the address of the argument block for the frame
// OBSOLETE    described by FI.  Returns 0 if the address is unknown.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE frame_args_address (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   struct frame_saved_regs fsr;
// OBSOLETE 
// OBSOLETE   if (fi->args_pointer)		/* Cached value is likely there.  */
// OBSOLETE     return fi->args_pointer;
// OBSOLETE 
// OBSOLETE   /* Nope, generate it.  */
// OBSOLETE 
// OBSOLETE   get_frame_saved_regs (fi, &fsr);
// OBSOLETE 
// OBSOLETE   return fi->args_pointer;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the saved PC from this frame.
// OBSOLETE 
// OBSOLETE    If the frame has a memory copy of SRP_REGNUM, use that.  If not,
// OBSOLETE    just use the register SRP_REGNUM itself.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE frame_saved_pc (struct frame_info *frame)
// OBSOLETE {
// OBSOLETE   return read_next_frame_reg (frame, SRP_REGNUM);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE #define DUMMY_FRAME_SIZE 192
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE write_word (CORE_ADDR sp, ULONGEST word)
// OBSOLETE {
// OBSOLETE   register int len = REGISTER_SIZE;
// OBSOLETE   char buffer[MAX_REGISTER_RAW_SIZE];
// OBSOLETE 
// OBSOLETE   store_unsigned_integer (buffer, len, word);
// OBSOLETE   write_memory (sp, buffer, len);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m88k_push_dummy_frame (void)
// OBSOLETE {
// OBSOLETE   register CORE_ADDR sp = read_register (SP_REGNUM);
// OBSOLETE   register int rn;
// OBSOLETE   int offset;
// OBSOLETE 
// OBSOLETE   sp -= DUMMY_FRAME_SIZE;	/* allocate a bunch of space */
// OBSOLETE 
// OBSOLETE   for (rn = 0, offset = 0; rn <= SP_REGNUM; rn++, offset += 4)
// OBSOLETE     write_word (sp + offset, read_register (rn));
// OBSOLETE 
// OBSOLETE   write_word (sp + offset, read_register (SXIP_REGNUM));
// OBSOLETE   offset += 4;
// OBSOLETE 
// OBSOLETE   write_word (sp + offset, read_register (SNIP_REGNUM));
// OBSOLETE   offset += 4;
// OBSOLETE 
// OBSOLETE   write_word (sp + offset, read_register (SFIP_REGNUM));
// OBSOLETE   offset += 4;
// OBSOLETE 
// OBSOLETE   write_word (sp + offset, read_register (PSR_REGNUM));
// OBSOLETE   offset += 4;
// OBSOLETE 
// OBSOLETE   write_word (sp + offset, read_register (FPSR_REGNUM));
// OBSOLETE   offset += 4;
// OBSOLETE 
// OBSOLETE   write_word (sp + offset, read_register (FPCR_REGNUM));
// OBSOLETE   offset += 4;
// OBSOLETE 
// OBSOLETE   write_register (SP_REGNUM, sp);
// OBSOLETE   write_register (ACTUAL_FP_REGNUM, sp);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE pop_frame (void)
// OBSOLETE {
// OBSOLETE   register struct frame_info *frame = get_current_frame ();
// OBSOLETE   register int regnum;
// OBSOLETE   struct frame_saved_regs fsr;
// OBSOLETE 
// OBSOLETE   get_frame_saved_regs (frame, &fsr);
// OBSOLETE 
// OBSOLETE   if (PC_IN_CALL_DUMMY (read_pc (), read_register (SP_REGNUM), frame->frame))
// OBSOLETE     {
// OBSOLETE       /* FIXME: I think get_frame_saved_regs should be handling this so
// OBSOLETE          that we can deal with the saved registers properly (e.g. frame
// OBSOLETE          1 is a call dummy, the user types "frame 2" and then "print $ps").  */
// OBSOLETE       register CORE_ADDR sp = read_register (ACTUAL_FP_REGNUM);
// OBSOLETE       int offset;
// OBSOLETE 
// OBSOLETE       for (regnum = 0, offset = 0; regnum <= SP_REGNUM; regnum++, offset += 4)
// OBSOLETE 	(void) write_register (regnum, read_memory_integer (sp + offset, 4));
// OBSOLETE 
// OBSOLETE       write_register (SXIP_REGNUM, read_memory_integer (sp + offset, 4));
// OBSOLETE       offset += 4;
// OBSOLETE 
// OBSOLETE       write_register (SNIP_REGNUM, read_memory_integer (sp + offset, 4));
// OBSOLETE       offset += 4;
// OBSOLETE 
// OBSOLETE       write_register (SFIP_REGNUM, read_memory_integer (sp + offset, 4));
// OBSOLETE       offset += 4;
// OBSOLETE 
// OBSOLETE       write_register (PSR_REGNUM, read_memory_integer (sp + offset, 4));
// OBSOLETE       offset += 4;
// OBSOLETE 
// OBSOLETE       write_register (FPSR_REGNUM, read_memory_integer (sp + offset, 4));
// OBSOLETE       offset += 4;
// OBSOLETE 
// OBSOLETE       write_register (FPCR_REGNUM, read_memory_integer (sp + offset, 4));
// OBSOLETE       offset += 4;
// OBSOLETE 
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       for (regnum = FP_REGNUM; regnum > 0; regnum--)
// OBSOLETE 	if (fsr.regs[regnum])
// OBSOLETE 	  write_register (regnum,
// OBSOLETE 			  read_memory_integer (fsr.regs[regnum], 4));
// OBSOLETE       write_pc (frame_saved_pc (frame));
// OBSOLETE     }
// OBSOLETE   reinit_frame_cache ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_m88k_tdep (void)
// OBSOLETE {
// OBSOLETE   tm_print_insn = print_insn_m88k;
// OBSOLETE }
@


1.9
log
@Obsolete m88k.
@
text
@@


1.9.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.9.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.8
log
@* config/m88k/tm-m88k.h: Update copyright.
(m88k_target_write_pc): Declare
(TARGET_WRITE_PC): Redefine using m88k_target_write_pc.
(M88K_NNPC_REGNUM): Rename NNPC_REGNUM.
(SHIFT_INST_REGS): Update definition.
* m88k-tdep.c (m88k_target_write_pc): New function.  Implement
using old definition of TARGET_WRITE_PC.
* regcache.c (generic_target_write_pc): Delete code handling
NNPC_REGNUM.
* gdbarch.sh (NNPC_REGNUM): Delete.
* gdbarch.h, gdbarch.c: Regenerate.

* gdbint.texinfo (Target Architecture Definition): Delete
documentation on NNPC_REGNUM.
@
text
@d1 661
a661 661
/* Target-machine dependent code for Motorola 88000 series, for GDB.

   Copyright 1988, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998,
   2000, 2001, 2002 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "defs.h"
#include "frame.h"
#include "inferior.h"
#include "value.h"
#include "gdbcore.h"
#include "symtab.h"
#include "setjmp.h"
#include "value.h"
#include "regcache.h"

/* Size of an instruction */
#define	BYTES_PER_88K_INSN	4

void frame_find_saved_regs ();

/* Is this target an m88110?  Otherwise assume m88100.  This has
   relevance for the ways in which we screw with instruction pointers.  */

int target_is_m88110 = 0;

void
m88k_target_write_pc (CORE_ADDR pc, ptid_t ptid)
{
  /* According to the MC88100 RISC Microprocessor User's Manual,
     section 6.4.3.1.2:

     ... can be made to return to a particular instruction by placing
     a valid instruction address in the SNIP and the next sequential
     instruction address in the SFIP (with V bits set and E bits
     clear).  The rte resumes execution at the instruction pointed to
     by the SNIP, then the SFIP.

     The E bit is the least significant bit (bit 0).  The V (valid)
     bit is bit 1.  This is why we logical or 2 into the values we are
     writing below.  It turns out that SXIP plays no role when
     returning from an exception so nothing special has to be done
     with it.  We could even (presumably) give it a totally bogus
     value.

     -- Kevin Buettner */

  write_register_pid (SXIP_REGNUM, pc, ptid);
  write_register_pid (SNIP_REGNUM, (pc | 2), ptid);
  write_register_pid (SFIP_REGNUM, (pc | 2) + 4, ptid);
}

/* The type of a register.  */
struct type *
m88k_register_type (int regnum)
{
  if (regnum >= XFP_REGNUM)
    return builtin_type_m88110_ext;
  else if (regnum == PC_REGNUM || regnum == FP_REGNUM || regnum == SP_REGNUM)
    return builtin_type_void_func_ptr;
  else
    return builtin_type_int32;
}


/* The m88k kernel aligns all instructions on 4-byte boundaries.  The
   kernel also uses the least significant two bits for its own hocus
   pocus.  When gdb receives an address from the kernel, it needs to
   preserve those right-most two bits, but gdb also needs to be careful
   to realize that those two bits are not really a part of the address
   of an instruction.  Shrug.  */

CORE_ADDR
m88k_addr_bits_remove (CORE_ADDR addr)
{
  return ((addr) & ~3);
}


/* Given a GDB frame, determine the address of the calling function's frame.
   This will be used to create a new GDB frame struct, and then
   INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.

   For us, the frame address is its stack pointer value, so we look up
   the function prologue to determine the caller's sp value, and return it.  */

CORE_ADDR
frame_chain (struct frame_info *thisframe)
{

  frame_find_saved_regs (thisframe, (struct frame_saved_regs *) 0);
  /* NOTE:  this depends on frame_find_saved_regs returning the VALUE, not
     the ADDRESS, of SP_REGNUM.  It also depends on the cache of
     frame_find_saved_regs results.  */
  if (thisframe->fsr->regs[SP_REGNUM])
    return thisframe->fsr->regs[SP_REGNUM];
  else
    return thisframe->frame;	/* Leaf fn -- next frame up has same SP. */
}

int
frameless_function_invocation (struct frame_info *frame)
{

  frame_find_saved_regs (frame, (struct frame_saved_regs *) 0);
  /* NOTE:  this depends on frame_find_saved_regs returning the VALUE, not
     the ADDRESS, of SP_REGNUM.  It also depends on the cache of
     frame_find_saved_regs results.  */
  if (frame->fsr->regs[SP_REGNUM])
    return 0;			/* Frameful -- return addr saved somewhere */
  else
    return 1;			/* Frameless -- no saved return address */
}

void
init_extra_frame_info (int fromleaf, struct frame_info *frame)
{
  frame->fsr = 0;		/* Not yet allocated */
  frame->args_pointer = 0;	/* Unknown */
  frame->locals_pointer = 0;	/* Unknown */
}

/* Examine an m88k function prologue, recording the addresses at which
   registers are saved explicitly by the prologue code, and returning
   the address of the first instruction after the prologue (but not
   after the instruction at address LIMIT, as explained below).

   LIMIT places an upper bound on addresses of the instructions to be
   examined.  If the prologue code scan reaches LIMIT, the scan is
   aborted and LIMIT is returned.  This is used, when examining the
   prologue for the current frame, to keep examine_prologue () from
   claiming that a given register has been saved when in fact the
   instruction that saves it has not yet been executed.  LIMIT is used
   at other times to stop the scan when we hit code after the true
   function prologue (e.g. for the first source line) which might
   otherwise be mistaken for function prologue.

   The format of the function prologue matched by this routine is
   derived from examination of the source to gcc 1.95, particularly
   the routine output_prologue () in config/out-m88k.c.

   subu r31,r31,n                       # stack pointer update

   (st rn,r31,offset)?                  # save incoming regs
   (st.d rn,r31,offset)?

   (addu r30,r31,n)?                    # frame pointer update

   (pic sequence)?                      # PIC code prologue

   (or   rn,rm,0)?                      # Move parameters to other regs
 */

/* Macros for extracting fields from instructions.  */

#define BITMASK(pos, width) (((0x1 << (width)) - 1) << (pos))
#define EXTRACT_FIELD(val, pos, width) ((val) >> (pos) & BITMASK (0, width))
#define	SUBU_OFFSET(x)	((unsigned)(x & 0xFFFF))
#define	ST_OFFSET(x)	((unsigned)((x) & 0xFFFF))
#define	ST_SRC(x)	EXTRACT_FIELD ((x), 21, 5)
#define	ADDU_OFFSET(x)	((unsigned)(x & 0xFFFF))

/*
 * prologue_insn_tbl is a table of instructions which may comprise a
 * function prologue.  Associated with each table entry (corresponding
 * to a single instruction or group of instructions), is an action.
 * This action is used by examine_prologue (below) to determine
 * the state of certain machine registers and where the stack frame lives.
 */

enum prologue_insn_action
{
  PIA_SKIP,			/* don't care what the instruction does */
  PIA_NOTE_ST,			/* note register stored and where */
  PIA_NOTE_STD,			/* note pair of registers stored and where */
  PIA_NOTE_SP_ADJUSTMENT,	/* note stack pointer adjustment */
  PIA_NOTE_FP_ASSIGNMENT,	/* note frame pointer assignment */
  PIA_NOTE_PROLOGUE_END,	/* no more prologue */
};

struct prologue_insns
  {
    unsigned long insn;
    unsigned long mask;
    enum prologue_insn_action action;
  };

struct prologue_insns prologue_insn_tbl[] =
{
  /* Various register move instructions */
  {0x58000000, 0xf800ffff, PIA_SKIP},	/* or/or.u with immed of 0 */
  {0xf4005800, 0xfc1fffe0, PIA_SKIP},	/* or rd, r0, rs */
  {0xf4005800, 0xfc00ffff, PIA_SKIP},	/* or rd, rs, r0 */

  /* Stack pointer setup: "subu sp, sp, n" where n is a multiple of 8 */
  {0x67ff0000, 0xffff0007, PIA_NOTE_SP_ADJUSTMENT},

  /* Frame pointer assignment: "addu r30, r31, n" */
  {0x63df0000, 0xffff0000, PIA_NOTE_FP_ASSIGNMENT},

  /* Store to stack instructions; either "st rx, sp, n" or "st.d rx, sp, n" */
  {0x241f0000, 0xfc1f0000, PIA_NOTE_ST},	/* st rx, sp, n */
  {0x201f0000, 0xfc1f0000, PIA_NOTE_STD},	/* st.d rs, sp, n */

  /* Instructions needed for setting up r25 for pic code. */
  {0x5f200000, 0xffff0000, PIA_SKIP},	/* or.u r25, r0, offset_high */
  {0xcc000002, 0xffffffff, PIA_SKIP},	/* bsr.n Lab */
  {0x5b390000, 0xffff0000, PIA_SKIP},	/* or r25, r25, offset_low */
  {0xf7396001, 0xffffffff, PIA_SKIP},	/* Lab: addu r25, r25, r1 */

  /* Various branch or jump instructions which have a delay slot -- these
     do not form part of the prologue, but the instruction in the delay
     slot might be a store instruction which should be noted. */
  {0xc4000000, 0xe4000000, PIA_NOTE_PROLOGUE_END},
					/* br.n, bsr.n, bb0.n, or bb1.n */
  {0xec000000, 0xfc000000, PIA_NOTE_PROLOGUE_END},	/* bcnd.n */
  {0xf400c400, 0xfffff7e0, PIA_NOTE_PROLOGUE_END}	/* jmp.n or jsr.n */

};


/* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or
   is not the address of a valid instruction, the address of the next
   instruction beyond ADDR otherwise.  *PWORD1 receives the first word
   of the instruction. */

#define NEXT_PROLOGUE_INSN(addr, lim, pword1) \
  (((addr) < (lim)) ? next_insn (addr, pword1) : 0)

/* Read the m88k instruction at 'memaddr' and return the address of 
   the next instruction after that, or 0 if 'memaddr' is not the
   address of a valid instruction.  The instruction
   is stored at 'pword1'.  */

CORE_ADDR
next_insn (CORE_ADDR memaddr, unsigned long *pword1)
{
  *pword1 = read_memory_integer (memaddr, BYTES_PER_88K_INSN);
  return memaddr + BYTES_PER_88K_INSN;
}

/* Read a register from frames called by us (or from the hardware regs).  */

static int
read_next_frame_reg (struct frame_info *frame, int regno)
{
  for (; frame; frame = frame->next)
    {
      if (regno == SP_REGNUM)
	return FRAME_FP (frame);
      else if (frame->fsr->regs[regno])
	return read_memory_integer (frame->fsr->regs[regno], 4);
    }
  return read_register (regno);
}

/* Examine the prologue of a function.  `ip' points to the first instruction.
   `limit' is the limit of the prologue (e.g. the addr of the first 
   linenumber, or perhaps the program counter if we're stepping through).
   `frame_sp' is the stack pointer value in use in this frame.  
   `fsr' is a pointer to a frame_saved_regs structure into which we put
   info about the registers saved by this frame.  
   `fi' is a struct frame_info pointer; we fill in various fields in it
   to reflect the offsets of the arg pointer and the locals pointer.  */

static CORE_ADDR
examine_prologue (register CORE_ADDR ip, register CORE_ADDR limit,
		  CORE_ADDR frame_sp, struct frame_saved_regs *fsr,
		  struct frame_info *fi)
{
  register CORE_ADDR next_ip;
  register int src;
  unsigned long insn;
  int size, offset;
  char must_adjust[32];		/* If set, must adjust offsets in fsr */
  int sp_offset = -1;		/* -1 means not set (valid must be mult of 8) */
  int fp_offset = -1;		/* -1 means not set */
  CORE_ADDR frame_fp;
  CORE_ADDR prologue_end = 0;

  memset (must_adjust, '\0', sizeof (must_adjust));
  next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn);

  while (next_ip)
    {
      struct prologue_insns *pip;

      for (pip = prologue_insn_tbl; (insn & pip->mask) != pip->insn;)
	if (++pip >= prologue_insn_tbl + sizeof prologue_insn_tbl)
	  goto end_of_prologue_found;	/* not a prologue insn */

      switch (pip->action)
	{
	case PIA_NOTE_ST:
	case PIA_NOTE_STD:
	  if (sp_offset != -1)
	    {
	      src = ST_SRC (insn);
	      offset = ST_OFFSET (insn);
	      must_adjust[src] = 1;
	      fsr->regs[src++] = offset;	/* Will be adjusted later */
	      if (pip->action == PIA_NOTE_STD && src < 32)
		{
		  offset += 4;
		  must_adjust[src] = 1;
		  fsr->regs[src++] = offset;
		}
	    }
	  else
	    goto end_of_prologue_found;
	  break;
	case PIA_NOTE_SP_ADJUSTMENT:
	  if (sp_offset == -1)
	    sp_offset = -SUBU_OFFSET (insn);
	  else
	    goto end_of_prologue_found;
	  break;
	case PIA_NOTE_FP_ASSIGNMENT:
	  if (fp_offset == -1)
	    fp_offset = ADDU_OFFSET (insn);
	  else
	    goto end_of_prologue_found;
	  break;
	case PIA_NOTE_PROLOGUE_END:
	  if (!prologue_end)
	    prologue_end = ip;
	  break;
	case PIA_SKIP:
	default:
	  /* Do nothing */
	  break;
	}

      ip = next_ip;
      next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn);
    }

end_of_prologue_found:

  if (prologue_end)
    ip = prologue_end;

  /* We're done with the prologue.  If we don't care about the stack
     frame itself, just return.  (Note that fsr->regs has been trashed,
     but the one caller who calls with fi==0 passes a dummy there.)  */

  if (fi == 0)
    return ip;

  /*
     OK, now we have:

     sp_offset  original (before any alloca calls) displacement of SP
     (will be negative).

     fp_offset  displacement from original SP to the FP for this frame
     or -1.

     fsr->regs[0..31]   displacement from original SP to the stack
     location where reg[0..31] is stored.

     must_adjust[0..31] set if corresponding offset was set.

     If alloca has been called between the function prologue and the current
     IP, then the current SP (frame_sp) will not be the original SP as set by
     the function prologue.  If the current SP is not the original SP, then the
     compiler will have allocated an FP for this frame, fp_offset will be set,
     and we can use it to calculate the original SP.

     Then, we figure out where the arguments and locals are, and relocate the
     offsets in fsr->regs to absolute addresses.  */

  if (fp_offset != -1)
    {
      /* We have a frame pointer, so get it, and base our calc's on it.  */
      frame_fp = (CORE_ADDR) read_next_frame_reg (fi->next, ACTUAL_FP_REGNUM);
      frame_sp = frame_fp - fp_offset;
    }
  else
    {
      /* We have no frame pointer, therefore frame_sp is still the same value
         as set by prologue.  But where is the frame itself?  */
      if (must_adjust[SRP_REGNUM])
	{
	  /* Function header saved SRP (r1), the return address.  Frame starts
	     4 bytes down from where it was saved.  */
	  frame_fp = frame_sp + fsr->regs[SRP_REGNUM] - 4;
	  fi->locals_pointer = frame_fp;
	}
      else
	{
	  /* Function header didn't save SRP (r1), so we are in a leaf fn or
	     are otherwise confused.  */
	  frame_fp = -1;
	}
    }

  /* The locals are relative to the FP (whether it exists as an allocated
     register, or just as an assumed offset from the SP) */
  fi->locals_pointer = frame_fp;

  /* The arguments are just above the SP as it was before we adjusted it
     on entry.  */
  fi->args_pointer = frame_sp - sp_offset;

  /* Now that we know the SP value used by the prologue, we know where
     it saved all the registers.  */
  for (src = 0; src < 32; src++)
    if (must_adjust[src])
      fsr->regs[src] += frame_sp;

  /* The saved value of the SP is always known.  */
  /* (we hope...) */
  if (fsr->regs[SP_REGNUM] != 0
      && fsr->regs[SP_REGNUM] != frame_sp - sp_offset)
    fprintf_unfiltered (gdb_stderr, "Bad saved SP value %lx != %lx, offset %x!\n",
			fsr->regs[SP_REGNUM],
			frame_sp - sp_offset, sp_offset);

  fsr->regs[SP_REGNUM] = frame_sp - sp_offset;

  return (ip);
}

/* Given an ip value corresponding to the start of a function,
   return the ip of the first instruction after the function 
   prologue.  */

CORE_ADDR
m88k_skip_prologue (CORE_ADDR ip)
{
  struct frame_saved_regs saved_regs_dummy;
  struct symtab_and_line sal;
  CORE_ADDR limit;

  sal = find_pc_line (ip, 0);
  limit = (sal.end) ? sal.end : 0xffffffff;

  return (examine_prologue (ip, limit, (CORE_ADDR) 0, &saved_regs_dummy,
			    (struct frame_info *) 0));
}

/* Put here the code to store, into a struct frame_saved_regs,
   the addresses of the saved registers of frame described by FRAME_INFO.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special:
   the address we return for it IS the sp for the next frame.

   We cache the result of doing this in the frame_obstack, since it is
   fairly expensive.  */

void
frame_find_saved_regs (struct frame_info *fi, struct frame_saved_regs *fsr)
{
  register struct frame_saved_regs *cache_fsr;
  CORE_ADDR ip;
  struct symtab_and_line sal;
  CORE_ADDR limit;

  if (!fi->fsr)
    {
      cache_fsr = (struct frame_saved_regs *)
	frame_obstack_alloc (sizeof (struct frame_saved_regs));
      memset (cache_fsr, '\0', sizeof (struct frame_saved_regs));
      fi->fsr = cache_fsr;

      /* Find the start and end of the function prologue.  If the PC
         is in the function prologue, we only consider the part that
         has executed already.  In the case where the PC is not in
         the function prologue, we set limit to two instructions beyond
         where the prologue ends in case if any of the prologue instructions
         were moved into a delay slot of a branch instruction. */

      ip = get_pc_function_start (fi->pc);
      sal = find_pc_line (ip, 0);
      limit = (sal.end && sal.end < fi->pc) ? sal.end + 2 * BYTES_PER_88K_INSN
	: fi->pc;

      /* This will fill in fields in *fi as well as in cache_fsr.  */
#ifdef SIGTRAMP_FRAME_FIXUP
      if (fi->signal_handler_caller)
	SIGTRAMP_FRAME_FIXUP (fi->frame);
#endif
      examine_prologue (ip, limit, fi->frame, cache_fsr, fi);
#ifdef SIGTRAMP_SP_FIXUP
      if (fi->signal_handler_caller && fi->fsr->regs[SP_REGNUM])
	SIGTRAMP_SP_FIXUP (fi->fsr->regs[SP_REGNUM]);
#endif
    }

  if (fsr)
    *fsr = *fi->fsr;
}

/* Return the address of the locals block for the frame
   described by FI.  Returns 0 if the address is unknown.
   NOTE!  Frame locals are referred to by negative offsets from the
   argument pointer, so this is the same as frame_args_address().  */

CORE_ADDR
frame_locals_address (struct frame_info *fi)
{
  struct frame_saved_regs fsr;

  if (fi->args_pointer)		/* Cached value is likely there.  */
    return fi->args_pointer;

  /* Nope, generate it.  */

  get_frame_saved_regs (fi, &fsr);

  return fi->args_pointer;
}

/* Return the address of the argument block for the frame
   described by FI.  Returns 0 if the address is unknown.  */

CORE_ADDR
frame_args_address (struct frame_info *fi)
{
  struct frame_saved_regs fsr;

  if (fi->args_pointer)		/* Cached value is likely there.  */
    return fi->args_pointer;

  /* Nope, generate it.  */

  get_frame_saved_regs (fi, &fsr);

  return fi->args_pointer;
}

/* Return the saved PC from this frame.

   If the frame has a memory copy of SRP_REGNUM, use that.  If not,
   just use the register SRP_REGNUM itself.  */

CORE_ADDR
frame_saved_pc (struct frame_info *frame)
{
  return read_next_frame_reg (frame, SRP_REGNUM);
}


#define DUMMY_FRAME_SIZE 192

static void
write_word (CORE_ADDR sp, ULONGEST word)
{
  register int len = REGISTER_SIZE;
  char buffer[MAX_REGISTER_RAW_SIZE];

  store_unsigned_integer (buffer, len, word);
  write_memory (sp, buffer, len);
}

void
m88k_push_dummy_frame (void)
{
  register CORE_ADDR sp = read_register (SP_REGNUM);
  register int rn;
  int offset;

  sp -= DUMMY_FRAME_SIZE;	/* allocate a bunch of space */

  for (rn = 0, offset = 0; rn <= SP_REGNUM; rn++, offset += 4)
    write_word (sp + offset, read_register (rn));

  write_word (sp + offset, read_register (SXIP_REGNUM));
  offset += 4;

  write_word (sp + offset, read_register (SNIP_REGNUM));
  offset += 4;

  write_word (sp + offset, read_register (SFIP_REGNUM));
  offset += 4;

  write_word (sp + offset, read_register (PSR_REGNUM));
  offset += 4;

  write_word (sp + offset, read_register (FPSR_REGNUM));
  offset += 4;

  write_word (sp + offset, read_register (FPCR_REGNUM));
  offset += 4;

  write_register (SP_REGNUM, sp);
  write_register (ACTUAL_FP_REGNUM, sp);
}

void
pop_frame (void)
{
  register struct frame_info *frame = get_current_frame ();
  register int regnum;
  struct frame_saved_regs fsr;

  get_frame_saved_regs (frame, &fsr);

  if (PC_IN_CALL_DUMMY (read_pc (), read_register (SP_REGNUM), frame->frame))
    {
      /* FIXME: I think get_frame_saved_regs should be handling this so
         that we can deal with the saved registers properly (e.g. frame
         1 is a call dummy, the user types "frame 2" and then "print $ps").  */
      register CORE_ADDR sp = read_register (ACTUAL_FP_REGNUM);
      int offset;

      for (regnum = 0, offset = 0; regnum <= SP_REGNUM; regnum++, offset += 4)
	(void) write_register (regnum, read_memory_integer (sp + offset, 4));

      write_register (SXIP_REGNUM, read_memory_integer (sp + offset, 4));
      offset += 4;

      write_register (SNIP_REGNUM, read_memory_integer (sp + offset, 4));
      offset += 4;

      write_register (SFIP_REGNUM, read_memory_integer (sp + offset, 4));
      offset += 4;

      write_register (PSR_REGNUM, read_memory_integer (sp + offset, 4));
      offset += 4;

      write_register (FPSR_REGNUM, read_memory_integer (sp + offset, 4));
      offset += 4;

      write_register (FPCR_REGNUM, read_memory_integer (sp + offset, 4));
      offset += 4;

    }
  else
    {
      for (regnum = FP_REGNUM; regnum > 0; regnum--)
	if (fsr.regs[regnum])
	  write_register (regnum,
			  read_memory_integer (fsr.regs[regnum], 4));
      write_pc (frame_saved_pc (frame));
    }
  reinit_frame_cache ();
}

void
_initialize_m88k_tdep (void)
{
  tm_print_insn = print_insn_m88k;
}
@


1.8.4.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d1 661
a661 661
// OBSOLETE /* Target-machine dependent code for Motorola 88000 series, for GDB.
// OBSOLETE 
// OBSOLETE    Copyright 1988, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998,
// OBSOLETE    2000, 2001, 2002 Free Software Foundation, Inc.
// OBSOLETE 
// OBSOLETE    This file is part of GDB.
// OBSOLETE 
// OBSOLETE    This program is free software; you can redistribute it and/or modify
// OBSOLETE    it under the terms of the GNU General Public License as published by
// OBSOLETE    the Free Software Foundation; either version 2 of the License, or
// OBSOLETE    (at your option) any later version.
// OBSOLETE 
// OBSOLETE    This program is distributed in the hope that it will be useful,
// OBSOLETE    but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE    GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE    You should have received a copy of the GNU General Public License
// OBSOLETE    along with this program; if not, write to the Free Software
// OBSOLETE    Foundation, Inc., 59 Temple Place - Suite 330,
// OBSOLETE    Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "defs.h"
// OBSOLETE #include "frame.h"
// OBSOLETE #include "inferior.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "gdbcore.h"
// OBSOLETE #include "symtab.h"
// OBSOLETE #include "setjmp.h"
// OBSOLETE #include "value.h"
// OBSOLETE #include "regcache.h"
// OBSOLETE 
// OBSOLETE /* Size of an instruction */
// OBSOLETE #define	BYTES_PER_88K_INSN	4
// OBSOLETE 
// OBSOLETE void frame_find_saved_regs ();
// OBSOLETE 
// OBSOLETE /* Is this target an m88110?  Otherwise assume m88100.  This has
// OBSOLETE    relevance for the ways in which we screw with instruction pointers.  */
// OBSOLETE 
// OBSOLETE int target_is_m88110 = 0;
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m88k_target_write_pc (CORE_ADDR pc, ptid_t ptid)
// OBSOLETE {
// OBSOLETE   /* According to the MC88100 RISC Microprocessor User's Manual,
// OBSOLETE      section 6.4.3.1.2:
// OBSOLETE 
// OBSOLETE      ... can be made to return to a particular instruction by placing
// OBSOLETE      a valid instruction address in the SNIP and the next sequential
// OBSOLETE      instruction address in the SFIP (with V bits set and E bits
// OBSOLETE      clear).  The rte resumes execution at the instruction pointed to
// OBSOLETE      by the SNIP, then the SFIP.
// OBSOLETE 
// OBSOLETE      The E bit is the least significant bit (bit 0).  The V (valid)
// OBSOLETE      bit is bit 1.  This is why we logical or 2 into the values we are
// OBSOLETE      writing below.  It turns out that SXIP plays no role when
// OBSOLETE      returning from an exception so nothing special has to be done
// OBSOLETE      with it.  We could even (presumably) give it a totally bogus
// OBSOLETE      value.
// OBSOLETE 
// OBSOLETE      -- Kevin Buettner */
// OBSOLETE 
// OBSOLETE   write_register_pid (SXIP_REGNUM, pc, ptid);
// OBSOLETE   write_register_pid (SNIP_REGNUM, (pc | 2), ptid);
// OBSOLETE   write_register_pid (SFIP_REGNUM, (pc | 2) + 4, ptid);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* The type of a register.  */
// OBSOLETE struct type *
// OBSOLETE m88k_register_type (int regnum)
// OBSOLETE {
// OBSOLETE   if (regnum >= XFP_REGNUM)
// OBSOLETE     return builtin_type_m88110_ext;
// OBSOLETE   else if (regnum == PC_REGNUM || regnum == FP_REGNUM || regnum == SP_REGNUM)
// OBSOLETE     return builtin_type_void_func_ptr;
// OBSOLETE   else
// OBSOLETE     return builtin_type_int32;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* The m88k kernel aligns all instructions on 4-byte boundaries.  The
// OBSOLETE    kernel also uses the least significant two bits for its own hocus
// OBSOLETE    pocus.  When gdb receives an address from the kernel, it needs to
// OBSOLETE    preserve those right-most two bits, but gdb also needs to be careful
// OBSOLETE    to realize that those two bits are not really a part of the address
// OBSOLETE    of an instruction.  Shrug.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE m88k_addr_bits_remove (CORE_ADDR addr)
// OBSOLETE {
// OBSOLETE   return ((addr) & ~3);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Given a GDB frame, determine the address of the calling function's frame.
// OBSOLETE    This will be used to create a new GDB frame struct, and then
// OBSOLETE    INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.
// OBSOLETE 
// OBSOLETE    For us, the frame address is its stack pointer value, so we look up
// OBSOLETE    the function prologue to determine the caller's sp value, and return it.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE frame_chain (struct frame_info *thisframe)
// OBSOLETE {
// OBSOLETE 
// OBSOLETE   frame_find_saved_regs (thisframe, (struct frame_saved_regs *) 0);
// OBSOLETE   /* NOTE:  this depends on frame_find_saved_regs returning the VALUE, not
// OBSOLETE      the ADDRESS, of SP_REGNUM.  It also depends on the cache of
// OBSOLETE      frame_find_saved_regs results.  */
// OBSOLETE   if (thisframe->fsr->regs[SP_REGNUM])
// OBSOLETE     return thisframe->fsr->regs[SP_REGNUM];
// OBSOLETE   else
// OBSOLETE     return thisframe->frame;	/* Leaf fn -- next frame up has same SP. */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE frameless_function_invocation (struct frame_info *frame)
// OBSOLETE {
// OBSOLETE 
// OBSOLETE   frame_find_saved_regs (frame, (struct frame_saved_regs *) 0);
// OBSOLETE   /* NOTE:  this depends on frame_find_saved_regs returning the VALUE, not
// OBSOLETE      the ADDRESS, of SP_REGNUM.  It also depends on the cache of
// OBSOLETE      frame_find_saved_regs results.  */
// OBSOLETE   if (frame->fsr->regs[SP_REGNUM])
// OBSOLETE     return 0;			/* Frameful -- return addr saved somewhere */
// OBSOLETE   else
// OBSOLETE     return 1;			/* Frameless -- no saved return address */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE init_extra_frame_info (int fromleaf, struct frame_info *frame)
// OBSOLETE {
// OBSOLETE   frame->fsr = 0;		/* Not yet allocated */
// OBSOLETE   frame->args_pointer = 0;	/* Unknown */
// OBSOLETE   frame->locals_pointer = 0;	/* Unknown */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Examine an m88k function prologue, recording the addresses at which
// OBSOLETE    registers are saved explicitly by the prologue code, and returning
// OBSOLETE    the address of the first instruction after the prologue (but not
// OBSOLETE    after the instruction at address LIMIT, as explained below).
// OBSOLETE 
// OBSOLETE    LIMIT places an upper bound on addresses of the instructions to be
// OBSOLETE    examined.  If the prologue code scan reaches LIMIT, the scan is
// OBSOLETE    aborted and LIMIT is returned.  This is used, when examining the
// OBSOLETE    prologue for the current frame, to keep examine_prologue () from
// OBSOLETE    claiming that a given register has been saved when in fact the
// OBSOLETE    instruction that saves it has not yet been executed.  LIMIT is used
// OBSOLETE    at other times to stop the scan when we hit code after the true
// OBSOLETE    function prologue (e.g. for the first source line) which might
// OBSOLETE    otherwise be mistaken for function prologue.
// OBSOLETE 
// OBSOLETE    The format of the function prologue matched by this routine is
// OBSOLETE    derived from examination of the source to gcc 1.95, particularly
// OBSOLETE    the routine output_prologue () in config/out-m88k.c.
// OBSOLETE 
// OBSOLETE    subu r31,r31,n                       # stack pointer update
// OBSOLETE 
// OBSOLETE    (st rn,r31,offset)?                  # save incoming regs
// OBSOLETE    (st.d rn,r31,offset)?
// OBSOLETE 
// OBSOLETE    (addu r30,r31,n)?                    # frame pointer update
// OBSOLETE 
// OBSOLETE    (pic sequence)?                      # PIC code prologue
// OBSOLETE 
// OBSOLETE    (or   rn,rm,0)?                      # Move parameters to other regs
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE /* Macros for extracting fields from instructions.  */
// OBSOLETE 
// OBSOLETE #define BITMASK(pos, width) (((0x1 << (width)) - 1) << (pos))
// OBSOLETE #define EXTRACT_FIELD(val, pos, width) ((val) >> (pos) & BITMASK (0, width))
// OBSOLETE #define	SUBU_OFFSET(x)	((unsigned)(x & 0xFFFF))
// OBSOLETE #define	ST_OFFSET(x)	((unsigned)((x) & 0xFFFF))
// OBSOLETE #define	ST_SRC(x)	EXTRACT_FIELD ((x), 21, 5)
// OBSOLETE #define	ADDU_OFFSET(x)	((unsigned)(x & 0xFFFF))
// OBSOLETE 
// OBSOLETE /*
// OBSOLETE  * prologue_insn_tbl is a table of instructions which may comprise a
// OBSOLETE  * function prologue.  Associated with each table entry (corresponding
// OBSOLETE  * to a single instruction or group of instructions), is an action.
// OBSOLETE  * This action is used by examine_prologue (below) to determine
// OBSOLETE  * the state of certain machine registers and where the stack frame lives.
// OBSOLETE  */
// OBSOLETE 
// OBSOLETE enum prologue_insn_action
// OBSOLETE {
// OBSOLETE   PIA_SKIP,			/* don't care what the instruction does */
// OBSOLETE   PIA_NOTE_ST,			/* note register stored and where */
// OBSOLETE   PIA_NOTE_STD,			/* note pair of registers stored and where */
// OBSOLETE   PIA_NOTE_SP_ADJUSTMENT,	/* note stack pointer adjustment */
// OBSOLETE   PIA_NOTE_FP_ASSIGNMENT,	/* note frame pointer assignment */
// OBSOLETE   PIA_NOTE_PROLOGUE_END,	/* no more prologue */
// OBSOLETE };
// OBSOLETE 
// OBSOLETE struct prologue_insns
// OBSOLETE   {
// OBSOLETE     unsigned long insn;
// OBSOLETE     unsigned long mask;
// OBSOLETE     enum prologue_insn_action action;
// OBSOLETE   };
// OBSOLETE 
// OBSOLETE struct prologue_insns prologue_insn_tbl[] =
// OBSOLETE {
// OBSOLETE   /* Various register move instructions */
// OBSOLETE   {0x58000000, 0xf800ffff, PIA_SKIP},	/* or/or.u with immed of 0 */
// OBSOLETE   {0xf4005800, 0xfc1fffe0, PIA_SKIP},	/* or rd, r0, rs */
// OBSOLETE   {0xf4005800, 0xfc00ffff, PIA_SKIP},	/* or rd, rs, r0 */
// OBSOLETE 
// OBSOLETE   /* Stack pointer setup: "subu sp, sp, n" where n is a multiple of 8 */
// OBSOLETE   {0x67ff0000, 0xffff0007, PIA_NOTE_SP_ADJUSTMENT},
// OBSOLETE 
// OBSOLETE   /* Frame pointer assignment: "addu r30, r31, n" */
// OBSOLETE   {0x63df0000, 0xffff0000, PIA_NOTE_FP_ASSIGNMENT},
// OBSOLETE 
// OBSOLETE   /* Store to stack instructions; either "st rx, sp, n" or "st.d rx, sp, n" */
// OBSOLETE   {0x241f0000, 0xfc1f0000, PIA_NOTE_ST},	/* st rx, sp, n */
// OBSOLETE   {0x201f0000, 0xfc1f0000, PIA_NOTE_STD},	/* st.d rs, sp, n */
// OBSOLETE 
// OBSOLETE   /* Instructions needed for setting up r25 for pic code. */
// OBSOLETE   {0x5f200000, 0xffff0000, PIA_SKIP},	/* or.u r25, r0, offset_high */
// OBSOLETE   {0xcc000002, 0xffffffff, PIA_SKIP},	/* bsr.n Lab */
// OBSOLETE   {0x5b390000, 0xffff0000, PIA_SKIP},	/* or r25, r25, offset_low */
// OBSOLETE   {0xf7396001, 0xffffffff, PIA_SKIP},	/* Lab: addu r25, r25, r1 */
// OBSOLETE 
// OBSOLETE   /* Various branch or jump instructions which have a delay slot -- these
// OBSOLETE      do not form part of the prologue, but the instruction in the delay
// OBSOLETE      slot might be a store instruction which should be noted. */
// OBSOLETE   {0xc4000000, 0xe4000000, PIA_NOTE_PROLOGUE_END},
// OBSOLETE 					/* br.n, bsr.n, bb0.n, or bb1.n */
// OBSOLETE   {0xec000000, 0xfc000000, PIA_NOTE_PROLOGUE_END},	/* bcnd.n */
// OBSOLETE   {0xf400c400, 0xfffff7e0, PIA_NOTE_PROLOGUE_END}	/* jmp.n or jsr.n */
// OBSOLETE 
// OBSOLETE };
// OBSOLETE 
// OBSOLETE 
// OBSOLETE /* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or
// OBSOLETE    is not the address of a valid instruction, the address of the next
// OBSOLETE    instruction beyond ADDR otherwise.  *PWORD1 receives the first word
// OBSOLETE    of the instruction. */
// OBSOLETE 
// OBSOLETE #define NEXT_PROLOGUE_INSN(addr, lim, pword1) \
// OBSOLETE   (((addr) < (lim)) ? next_insn (addr, pword1) : 0)
// OBSOLETE 
// OBSOLETE /* Read the m88k instruction at 'memaddr' and return the address of 
// OBSOLETE    the next instruction after that, or 0 if 'memaddr' is not the
// OBSOLETE    address of a valid instruction.  The instruction
// OBSOLETE    is stored at 'pword1'.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE next_insn (CORE_ADDR memaddr, unsigned long *pword1)
// OBSOLETE {
// OBSOLETE   *pword1 = read_memory_integer (memaddr, BYTES_PER_88K_INSN);
// OBSOLETE   return memaddr + BYTES_PER_88K_INSN;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Read a register from frames called by us (or from the hardware regs).  */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE read_next_frame_reg (struct frame_info *frame, int regno)
// OBSOLETE {
// OBSOLETE   for (; frame; frame = frame->next)
// OBSOLETE     {
// OBSOLETE       if (regno == SP_REGNUM)
// OBSOLETE 	return FRAME_FP (frame);
// OBSOLETE       else if (frame->fsr->regs[regno])
// OBSOLETE 	return read_memory_integer (frame->fsr->regs[regno], 4);
// OBSOLETE     }
// OBSOLETE   return read_register (regno);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Examine the prologue of a function.  `ip' points to the first instruction.
// OBSOLETE    `limit' is the limit of the prologue (e.g. the addr of the first 
// OBSOLETE    linenumber, or perhaps the program counter if we're stepping through).
// OBSOLETE    `frame_sp' is the stack pointer value in use in this frame.  
// OBSOLETE    `fsr' is a pointer to a frame_saved_regs structure into which we put
// OBSOLETE    info about the registers saved by this frame.  
// OBSOLETE    `fi' is a struct frame_info pointer; we fill in various fields in it
// OBSOLETE    to reflect the offsets of the arg pointer and the locals pointer.  */
// OBSOLETE 
// OBSOLETE static CORE_ADDR
// OBSOLETE examine_prologue (register CORE_ADDR ip, register CORE_ADDR limit,
// OBSOLETE 		  CORE_ADDR frame_sp, struct frame_saved_regs *fsr,
// OBSOLETE 		  struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   register CORE_ADDR next_ip;
// OBSOLETE   register int src;
// OBSOLETE   unsigned long insn;
// OBSOLETE   int size, offset;
// OBSOLETE   char must_adjust[32];		/* If set, must adjust offsets in fsr */
// OBSOLETE   int sp_offset = -1;		/* -1 means not set (valid must be mult of 8) */
// OBSOLETE   int fp_offset = -1;		/* -1 means not set */
// OBSOLETE   CORE_ADDR frame_fp;
// OBSOLETE   CORE_ADDR prologue_end = 0;
// OBSOLETE 
// OBSOLETE   memset (must_adjust, '\0', sizeof (must_adjust));
// OBSOLETE   next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn);
// OBSOLETE 
// OBSOLETE   while (next_ip)
// OBSOLETE     {
// OBSOLETE       struct prologue_insns *pip;
// OBSOLETE 
// OBSOLETE       for (pip = prologue_insn_tbl; (insn & pip->mask) != pip->insn;)
// OBSOLETE 	if (++pip >= prologue_insn_tbl + sizeof prologue_insn_tbl)
// OBSOLETE 	  goto end_of_prologue_found;	/* not a prologue insn */
// OBSOLETE 
// OBSOLETE       switch (pip->action)
// OBSOLETE 	{
// OBSOLETE 	case PIA_NOTE_ST:
// OBSOLETE 	case PIA_NOTE_STD:
// OBSOLETE 	  if (sp_offset != -1)
// OBSOLETE 	    {
// OBSOLETE 	      src = ST_SRC (insn);
// OBSOLETE 	      offset = ST_OFFSET (insn);
// OBSOLETE 	      must_adjust[src] = 1;
// OBSOLETE 	      fsr->regs[src++] = offset;	/* Will be adjusted later */
// OBSOLETE 	      if (pip->action == PIA_NOTE_STD && src < 32)
// OBSOLETE 		{
// OBSOLETE 		  offset += 4;
// OBSOLETE 		  must_adjust[src] = 1;
// OBSOLETE 		  fsr->regs[src++] = offset;
// OBSOLETE 		}
// OBSOLETE 	    }
// OBSOLETE 	  else
// OBSOLETE 	    goto end_of_prologue_found;
// OBSOLETE 	  break;
// OBSOLETE 	case PIA_NOTE_SP_ADJUSTMENT:
// OBSOLETE 	  if (sp_offset == -1)
// OBSOLETE 	    sp_offset = -SUBU_OFFSET (insn);
// OBSOLETE 	  else
// OBSOLETE 	    goto end_of_prologue_found;
// OBSOLETE 	  break;
// OBSOLETE 	case PIA_NOTE_FP_ASSIGNMENT:
// OBSOLETE 	  if (fp_offset == -1)
// OBSOLETE 	    fp_offset = ADDU_OFFSET (insn);
// OBSOLETE 	  else
// OBSOLETE 	    goto end_of_prologue_found;
// OBSOLETE 	  break;
// OBSOLETE 	case PIA_NOTE_PROLOGUE_END:
// OBSOLETE 	  if (!prologue_end)
// OBSOLETE 	    prologue_end = ip;
// OBSOLETE 	  break;
// OBSOLETE 	case PIA_SKIP:
// OBSOLETE 	default:
// OBSOLETE 	  /* Do nothing */
// OBSOLETE 	  break;
// OBSOLETE 	}
// OBSOLETE 
// OBSOLETE       ip = next_ip;
// OBSOLETE       next_ip = NEXT_PROLOGUE_INSN (ip, limit, &insn);
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE end_of_prologue_found:
// OBSOLETE 
// OBSOLETE   if (prologue_end)
// OBSOLETE     ip = prologue_end;
// OBSOLETE 
// OBSOLETE   /* We're done with the prologue.  If we don't care about the stack
// OBSOLETE      frame itself, just return.  (Note that fsr->regs has been trashed,
// OBSOLETE      but the one caller who calls with fi==0 passes a dummy there.)  */
// OBSOLETE 
// OBSOLETE   if (fi == 0)
// OBSOLETE     return ip;
// OBSOLETE 
// OBSOLETE   /*
// OBSOLETE      OK, now we have:
// OBSOLETE 
// OBSOLETE      sp_offset  original (before any alloca calls) displacement of SP
// OBSOLETE      (will be negative).
// OBSOLETE 
// OBSOLETE      fp_offset  displacement from original SP to the FP for this frame
// OBSOLETE      or -1.
// OBSOLETE 
// OBSOLETE      fsr->regs[0..31]   displacement from original SP to the stack
// OBSOLETE      location where reg[0..31] is stored.
// OBSOLETE 
// OBSOLETE      must_adjust[0..31] set if corresponding offset was set.
// OBSOLETE 
// OBSOLETE      If alloca has been called between the function prologue and the current
// OBSOLETE      IP, then the current SP (frame_sp) will not be the original SP as set by
// OBSOLETE      the function prologue.  If the current SP is not the original SP, then the
// OBSOLETE      compiler will have allocated an FP for this frame, fp_offset will be set,
// OBSOLETE      and we can use it to calculate the original SP.
// OBSOLETE 
// OBSOLETE      Then, we figure out where the arguments and locals are, and relocate the
// OBSOLETE      offsets in fsr->regs to absolute addresses.  */
// OBSOLETE 
// OBSOLETE   if (fp_offset != -1)
// OBSOLETE     {
// OBSOLETE       /* We have a frame pointer, so get it, and base our calc's on it.  */
// OBSOLETE       frame_fp = (CORE_ADDR) read_next_frame_reg (fi->next, ACTUAL_FP_REGNUM);
// OBSOLETE       frame_sp = frame_fp - fp_offset;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       /* We have no frame pointer, therefore frame_sp is still the same value
// OBSOLETE          as set by prologue.  But where is the frame itself?  */
// OBSOLETE       if (must_adjust[SRP_REGNUM])
// OBSOLETE 	{
// OBSOLETE 	  /* Function header saved SRP (r1), the return address.  Frame starts
// OBSOLETE 	     4 bytes down from where it was saved.  */
// OBSOLETE 	  frame_fp = frame_sp + fsr->regs[SRP_REGNUM] - 4;
// OBSOLETE 	  fi->locals_pointer = frame_fp;
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* Function header didn't save SRP (r1), so we are in a leaf fn or
// OBSOLETE 	     are otherwise confused.  */
// OBSOLETE 	  frame_fp = -1;
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* The locals are relative to the FP (whether it exists as an allocated
// OBSOLETE      register, or just as an assumed offset from the SP) */
// OBSOLETE   fi->locals_pointer = frame_fp;
// OBSOLETE 
// OBSOLETE   /* The arguments are just above the SP as it was before we adjusted it
// OBSOLETE      on entry.  */
// OBSOLETE   fi->args_pointer = frame_sp - sp_offset;
// OBSOLETE 
// OBSOLETE   /* Now that we know the SP value used by the prologue, we know where
// OBSOLETE      it saved all the registers.  */
// OBSOLETE   for (src = 0; src < 32; src++)
// OBSOLETE     if (must_adjust[src])
// OBSOLETE       fsr->regs[src] += frame_sp;
// OBSOLETE 
// OBSOLETE   /* The saved value of the SP is always known.  */
// OBSOLETE   /* (we hope...) */
// OBSOLETE   if (fsr->regs[SP_REGNUM] != 0
// OBSOLETE       && fsr->regs[SP_REGNUM] != frame_sp - sp_offset)
// OBSOLETE     fprintf_unfiltered (gdb_stderr, "Bad saved SP value %lx != %lx, offset %x!\n",
// OBSOLETE 			fsr->regs[SP_REGNUM],
// OBSOLETE 			frame_sp - sp_offset, sp_offset);
// OBSOLETE 
// OBSOLETE   fsr->regs[SP_REGNUM] = frame_sp - sp_offset;
// OBSOLETE 
// OBSOLETE   return (ip);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Given an ip value corresponding to the start of a function,
// OBSOLETE    return the ip of the first instruction after the function 
// OBSOLETE    prologue.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE m88k_skip_prologue (CORE_ADDR ip)
// OBSOLETE {
// OBSOLETE   struct frame_saved_regs saved_regs_dummy;
// OBSOLETE   struct symtab_and_line sal;
// OBSOLETE   CORE_ADDR limit;
// OBSOLETE 
// OBSOLETE   sal = find_pc_line (ip, 0);
// OBSOLETE   limit = (sal.end) ? sal.end : 0xffffffff;
// OBSOLETE 
// OBSOLETE   return (examine_prologue (ip, limit, (CORE_ADDR) 0, &saved_regs_dummy,
// OBSOLETE 			    (struct frame_info *) 0));
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Put here the code to store, into a struct frame_saved_regs,
// OBSOLETE    the addresses of the saved registers of frame described by FRAME_INFO.
// OBSOLETE    This includes special registers such as pc and fp saved in special
// OBSOLETE    ways in the stack frame.  sp is even more special:
// OBSOLETE    the address we return for it IS the sp for the next frame.
// OBSOLETE 
// OBSOLETE    We cache the result of doing this in the frame_obstack, since it is
// OBSOLETE    fairly expensive.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE frame_find_saved_regs (struct frame_info *fi, struct frame_saved_regs *fsr)
// OBSOLETE {
// OBSOLETE   register struct frame_saved_regs *cache_fsr;
// OBSOLETE   CORE_ADDR ip;
// OBSOLETE   struct symtab_and_line sal;
// OBSOLETE   CORE_ADDR limit;
// OBSOLETE 
// OBSOLETE   if (!fi->fsr)
// OBSOLETE     {
// OBSOLETE       cache_fsr = (struct frame_saved_regs *)
// OBSOLETE 	frame_obstack_alloc (sizeof (struct frame_saved_regs));
// OBSOLETE       memset (cache_fsr, '\0', sizeof (struct frame_saved_regs));
// OBSOLETE       fi->fsr = cache_fsr;
// OBSOLETE 
// OBSOLETE       /* Find the start and end of the function prologue.  If the PC
// OBSOLETE          is in the function prologue, we only consider the part that
// OBSOLETE          has executed already.  In the case where the PC is not in
// OBSOLETE          the function prologue, we set limit to two instructions beyond
// OBSOLETE          where the prologue ends in case if any of the prologue instructions
// OBSOLETE          were moved into a delay slot of a branch instruction. */
// OBSOLETE 
// OBSOLETE       ip = get_pc_function_start (fi->pc);
// OBSOLETE       sal = find_pc_line (ip, 0);
// OBSOLETE       limit = (sal.end && sal.end < fi->pc) ? sal.end + 2 * BYTES_PER_88K_INSN
// OBSOLETE 	: fi->pc;
// OBSOLETE 
// OBSOLETE       /* This will fill in fields in *fi as well as in cache_fsr.  */
// OBSOLETE #ifdef SIGTRAMP_FRAME_FIXUP
// OBSOLETE       if (fi->signal_handler_caller)
// OBSOLETE 	SIGTRAMP_FRAME_FIXUP (fi->frame);
// OBSOLETE #endif
// OBSOLETE       examine_prologue (ip, limit, fi->frame, cache_fsr, fi);
// OBSOLETE #ifdef SIGTRAMP_SP_FIXUP
// OBSOLETE       if (fi->signal_handler_caller && fi->fsr->regs[SP_REGNUM])
// OBSOLETE 	SIGTRAMP_SP_FIXUP (fi->fsr->regs[SP_REGNUM]);
// OBSOLETE #endif
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (fsr)
// OBSOLETE     *fsr = *fi->fsr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the address of the locals block for the frame
// OBSOLETE    described by FI.  Returns 0 if the address is unknown.
// OBSOLETE    NOTE!  Frame locals are referred to by negative offsets from the
// OBSOLETE    argument pointer, so this is the same as frame_args_address().  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE frame_locals_address (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   struct frame_saved_regs fsr;
// OBSOLETE 
// OBSOLETE   if (fi->args_pointer)		/* Cached value is likely there.  */
// OBSOLETE     return fi->args_pointer;
// OBSOLETE 
// OBSOLETE   /* Nope, generate it.  */
// OBSOLETE 
// OBSOLETE   get_frame_saved_regs (fi, &fsr);
// OBSOLETE 
// OBSOLETE   return fi->args_pointer;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the address of the argument block for the frame
// OBSOLETE    described by FI.  Returns 0 if the address is unknown.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE frame_args_address (struct frame_info *fi)
// OBSOLETE {
// OBSOLETE   struct frame_saved_regs fsr;
// OBSOLETE 
// OBSOLETE   if (fi->args_pointer)		/* Cached value is likely there.  */
// OBSOLETE     return fi->args_pointer;
// OBSOLETE 
// OBSOLETE   /* Nope, generate it.  */
// OBSOLETE 
// OBSOLETE   get_frame_saved_regs (fi, &fsr);
// OBSOLETE 
// OBSOLETE   return fi->args_pointer;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Return the saved PC from this frame.
// OBSOLETE 
// OBSOLETE    If the frame has a memory copy of SRP_REGNUM, use that.  If not,
// OBSOLETE    just use the register SRP_REGNUM itself.  */
// OBSOLETE 
// OBSOLETE CORE_ADDR
// OBSOLETE frame_saved_pc (struct frame_info *frame)
// OBSOLETE {
// OBSOLETE   return read_next_frame_reg (frame, SRP_REGNUM);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE #define DUMMY_FRAME_SIZE 192
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE write_word (CORE_ADDR sp, ULONGEST word)
// OBSOLETE {
// OBSOLETE   register int len = REGISTER_SIZE;
// OBSOLETE   char buffer[MAX_REGISTER_RAW_SIZE];
// OBSOLETE 
// OBSOLETE   store_unsigned_integer (buffer, len, word);
// OBSOLETE   write_memory (sp, buffer, len);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE m88k_push_dummy_frame (void)
// OBSOLETE {
// OBSOLETE   register CORE_ADDR sp = read_register (SP_REGNUM);
// OBSOLETE   register int rn;
// OBSOLETE   int offset;
// OBSOLETE 
// OBSOLETE   sp -= DUMMY_FRAME_SIZE;	/* allocate a bunch of space */
// OBSOLETE 
// OBSOLETE   for (rn = 0, offset = 0; rn <= SP_REGNUM; rn++, offset += 4)
// OBSOLETE     write_word (sp + offset, read_register (rn));
// OBSOLETE 
// OBSOLETE   write_word (sp + offset, read_register (SXIP_REGNUM));
// OBSOLETE   offset += 4;
// OBSOLETE 
// OBSOLETE   write_word (sp + offset, read_register (SNIP_REGNUM));
// OBSOLETE   offset += 4;
// OBSOLETE 
// OBSOLETE   write_word (sp + offset, read_register (SFIP_REGNUM));
// OBSOLETE   offset += 4;
// OBSOLETE 
// OBSOLETE   write_word (sp + offset, read_register (PSR_REGNUM));
// OBSOLETE   offset += 4;
// OBSOLETE 
// OBSOLETE   write_word (sp + offset, read_register (FPSR_REGNUM));
// OBSOLETE   offset += 4;
// OBSOLETE 
// OBSOLETE   write_word (sp + offset, read_register (FPCR_REGNUM));
// OBSOLETE   offset += 4;
// OBSOLETE 
// OBSOLETE   write_register (SP_REGNUM, sp);
// OBSOLETE   write_register (ACTUAL_FP_REGNUM, sp);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE pop_frame (void)
// OBSOLETE {
// OBSOLETE   register struct frame_info *frame = get_current_frame ();
// OBSOLETE   register int regnum;
// OBSOLETE   struct frame_saved_regs fsr;
// OBSOLETE 
// OBSOLETE   get_frame_saved_regs (frame, &fsr);
// OBSOLETE 
// OBSOLETE   if (PC_IN_CALL_DUMMY (read_pc (), read_register (SP_REGNUM), frame->frame))
// OBSOLETE     {
// OBSOLETE       /* FIXME: I think get_frame_saved_regs should be handling this so
// OBSOLETE          that we can deal with the saved registers properly (e.g. frame
// OBSOLETE          1 is a call dummy, the user types "frame 2" and then "print $ps").  */
// OBSOLETE       register CORE_ADDR sp = read_register (ACTUAL_FP_REGNUM);
// OBSOLETE       int offset;
// OBSOLETE 
// OBSOLETE       for (regnum = 0, offset = 0; regnum <= SP_REGNUM; regnum++, offset += 4)
// OBSOLETE 	(void) write_register (regnum, read_memory_integer (sp + offset, 4));
// OBSOLETE 
// OBSOLETE       write_register (SXIP_REGNUM, read_memory_integer (sp + offset, 4));
// OBSOLETE       offset += 4;
// OBSOLETE 
// OBSOLETE       write_register (SNIP_REGNUM, read_memory_integer (sp + offset, 4));
// OBSOLETE       offset += 4;
// OBSOLETE 
// OBSOLETE       write_register (SFIP_REGNUM, read_memory_integer (sp + offset, 4));
// OBSOLETE       offset += 4;
// OBSOLETE 
// OBSOLETE       write_register (PSR_REGNUM, read_memory_integer (sp + offset, 4));
// OBSOLETE       offset += 4;
// OBSOLETE 
// OBSOLETE       write_register (FPSR_REGNUM, read_memory_integer (sp + offset, 4));
// OBSOLETE       offset += 4;
// OBSOLETE 
// OBSOLETE       write_register (FPCR_REGNUM, read_memory_integer (sp + offset, 4));
// OBSOLETE       offset += 4;
// OBSOLETE 
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     {
// OBSOLETE       for (regnum = FP_REGNUM; regnum > 0; regnum--)
// OBSOLETE 	if (fsr.regs[regnum])
// OBSOLETE 	  write_register (regnum,
// OBSOLETE 			  read_memory_integer (fsr.regs[regnum], 4));
// OBSOLETE       write_pc (frame_saved_pc (frame));
// OBSOLETE     }
// OBSOLETE   reinit_frame_cache ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE _initialize_m88k_tdep (void)
// OBSOLETE {
// OBSOLETE   tm_print_insn = print_insn_m88k;
// OBSOLETE }
@


1.7
log
@Zap REGISTER_CONVERTIBLE from m88k.
@
text
@d2 3
a4 2
   Copyright 1988, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000,
   2001 Free Software Foundation, Inc.
d42 26
@


1.6
log
@Make --target=m88k buildable again.
@
text
@d42 13
@


1.5
log
@Update/correct copyright notices.
@
text
@d249 1
a249 1
  unsigned int insn;
d392 1
a392 1
    fprintf_unfiltered (gdb_stderr, "Bad saved SP value %x != %x, offset %x!\n",
a570 1
  register CORE_ADDR fp;
a573 1
  fp = FRAME_FP (frame);
d576 1
a576 1
  if (PC_IN_CALL_DUMMY (read_pc (), read_register (SP_REGNUM), FRAME_FP (fi)))
@


1.4
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1988, 1990, 1991, 1994, 1995, 2001 Free Software
   Foundation, Inc.
@


1.3
log
@Protoization.
@
text
@d2 2
a3 1
   Copyright 1988, 1990, 1991, 1994, 1995 Free Software Foundation, Inc.
d30 1
@


1.2
log
@Protoization.
@
text
@d404 1
a404 2
m88k_skip_prologue (ip)
CORE_ADDR (ip);
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d48 1
a48 2
m88k_addr_bits_remove (addr)
     CORE_ADDR addr;
d62 1
a62 2
frame_chain (thisframe)
     struct frame_info *thisframe;
d67 2
a68 2
 	    the ADDRESS, of SP_REGNUM.  It also depends on the cache of
	    frame_find_saved_regs results.  */
d76 1
a76 2
frameless_function_invocation (frame)
     struct frame_info *frame;
d81 2
a82 2
 	    the ADDRESS, of SP_REGNUM.  It also depends on the cache of
	    frame_find_saved_regs results.  */
d90 1
a90 3
init_extra_frame_info (fromleaf, frame)
     int fromleaf;
     struct frame_info *frame;
d92 2
a93 2
  frame->fsr = 0;			/* Not yet allocated */
  frame->args_pointer = 0;		/* Unknown */
d116 1
a116 1
   subu r31,r31,n			# stack pointer update
d118 1
a118 1
   (st rn,r31,offset)?			# save incoming regs
d121 1
a121 1
   (addu r30,r31,n)?			# frame pointer update
d123 1
a123 1
   (pic sequence)?			# PIC code prologue
d125 2
a126 2
   (or   rn,rm,0)?			# Move parameters to other regs
*/
d145 2
a146 1
enum prologue_insn_action {
d155 2
a156 1
struct prologue_insns {
d160 1
a160 1
};
d162 2
a163 1
struct prologue_insns prologue_insn_tbl[] = {
d165 3
a167 3
  { 0x58000000, 0xf800ffff, PIA_SKIP },		/* or/or.u with immed of 0 */
  { 0xf4005800, 0xfc1fffe0, PIA_SKIP },		/* or rd, r0, rs */
  { 0xf4005800, 0xfc00ffff, PIA_SKIP },		/* or rd, rs, r0 */
d170 1
a170 1
  { 0x67ff0000, 0xffff0007, PIA_NOTE_SP_ADJUSTMENT },
d173 1
a173 1
  { 0x63df0000, 0xffff0000, PIA_NOTE_FP_ASSIGNMENT },
d176 2
a177 2
  { 0x241f0000, 0xfc1f0000, PIA_NOTE_ST },	/* st rx, sp, n */
  { 0x201f0000, 0xfc1f0000, PIA_NOTE_STD },	/* st.d rs, sp, n */
d180 4
a183 4
  { 0x5f200000, 0xffff0000, PIA_SKIP },		/* or.u r25, r0, offset_high */
  { 0xcc000002, 0xffffffff, PIA_SKIP },		/* bsr.n Lab */
  { 0x5b390000, 0xffff0000, PIA_SKIP },		/* or r25, r25, offset_low */
  { 0xf7396001, 0xffffffff, PIA_SKIP },		/* Lab: addu r25, r25, r1 */
d188 4
a191 4
  { 0xc4000000, 0xe4000000, PIA_NOTE_PROLOGUE_END }, 
  					/* br.n, bsr.n, bb0.n, or bb1.n */
  { 0xec000000, 0xfc000000, PIA_NOTE_PROLOGUE_END }, /* bcnd.n */
  { 0xf400c400, 0xfffff7e0, PIA_NOTE_PROLOGUE_END } /* jmp.n or jsr.n */
d210 1
a210 3
next_insn (memaddr, pword1)
     unsigned long *pword1;
     CORE_ADDR memaddr;
d219 1
a219 3
read_next_frame_reg(frame, regno)
     struct frame_info *frame;
     int regno;
d221 2
a222 1
  for (; frame; frame = frame->next) {
d226 3
a228 3
	return read_memory_integer(frame->fsr->regs[regno], 4);
  }
  return read_register(regno);
d241 3
a243 6
examine_prologue (ip, limit, frame_sp, fsr, fi)
     register CORE_ADDR ip;
     register CORE_ADDR limit;
     CORE_ADDR frame_sp;
     struct frame_saved_regs *fsr;
     struct frame_info *fi;
d260 1
a260 1
      struct prologue_insns *pip; 
d262 3
a264 3
      for (pip=prologue_insn_tbl; (insn & pip->mask) != pip->insn; )
	  if (++pip >= prologue_insn_tbl + sizeof prologue_insn_tbl)
	      goto end_of_prologue_found;	/* not a prologue insn */
d268 14
a281 13
	  case PIA_NOTE_ST:
	  case PIA_NOTE_STD:
	    if (sp_offset != -1) {
		src = ST_SRC (insn);
		offset = ST_OFFSET (insn);
		must_adjust[src] = 1;
		fsr->regs[src++] = offset;	/* Will be adjusted later */
		if (pip->action == PIA_NOTE_STD && src < 32)
		  {
		    offset += 4;
		    must_adjust[src] = 1;
		    fsr->regs[src++] = offset;
		  }
d283 23
a305 23
	    else
		goto end_of_prologue_found;
	    break;
	  case PIA_NOTE_SP_ADJUSTMENT:
	    if (sp_offset == -1)
		sp_offset = -SUBU_OFFSET (insn);
	    else
		goto end_of_prologue_found;
	    break;
	  case PIA_NOTE_FP_ASSIGNMENT:
	    if (fp_offset == -1)
		fp_offset = ADDU_OFFSET (insn);
	    else
		goto end_of_prologue_found;
	    break;
	  case PIA_NOTE_PROLOGUE_END:
	    if (!prologue_end)
		prologue_end = ip;
	    break;
	  case PIA_SKIP:
	  default :
	    /* Do nothing */
	    break;
d314 2
a315 2
    if (prologue_end)
	ip = prologue_end;
d327 2
a328 2
     	sp_offset	original (before any alloca calls) displacement of SP
			(will be negative).
d330 2
a331 2
	fp_offset	displacement from original SP to the FP for this frame
			or -1.
d333 2
a334 2
	fsr->regs[0..31]	displacement from original SP to the stack
				location where reg[0..31] is stored.
d336 1
a336 1
	must_adjust[0..31]	set if corresponding offset was set.
d347 23
a369 16
  if (fp_offset != -1) {
    /* We have a frame pointer, so get it, and base our calc's on it.  */
    frame_fp = (CORE_ADDR) read_next_frame_reg (fi->next, ACTUAL_FP_REGNUM);
    frame_sp = frame_fp - fp_offset;
  } else {
    /* We have no frame pointer, therefore frame_sp is still the same value
       as set by prologue.  But where is the frame itself?  */
    if (must_adjust[SRP_REGNUM]) {
      /* Function header saved SRP (r1), the return address.  Frame starts
	 4 bytes down from where it was saved.  */
      frame_fp = frame_sp + fsr->regs[SRP_REGNUM] - 4;
      fi->locals_pointer = frame_fp;
    } else {
      /* Function header didn't save SRP (r1), so we are in a leaf fn or
	 are otherwise confused.  */
      frame_fp = -1;
a370 1
  }
d385 1
a385 1
 
d388 5
a392 5
  if (fsr->regs[SP_REGNUM] != 0 
   && fsr->regs[SP_REGNUM] != frame_sp - sp_offset)
    fprintf_unfiltered(gdb_stderr, "Bad saved SP value %x != %x, offset %x!\n",
        fsr->regs[SP_REGNUM],
	frame_sp - sp_offset, sp_offset);
d404 2
a405 2
skip_prologue (ip)
     CORE_ADDR (ip);
d415 1
a415 1
			    (struct frame_info *)0 ));
d428 1
a428 3
frame_find_saved_regs (fi, fsr)
     struct frame_info *fi;
     struct frame_saved_regs *fsr;
d443 6
a448 6
	 is in the function prologue, we only consider the part that
	 has executed already.  In the case where the PC is not in
	 the function prologue, we set limit to two instructions beyond
	 where the prologue ends in case if any of the prologue instructions
	 were moved into a delay slot of a branch instruction. */
         
d451 2
a452 2
      limit = (sal.end && sal.end < fi->pc) ? sal.end + 2 * BYTES_PER_88K_INSN 
					    : fi->pc;
d457 1
a457 1
	SIGTRAMP_FRAME_FIXUP(fi->frame);
d462 1
a462 1
	SIGTRAMP_SP_FIXUP(fi->fsr->regs[SP_REGNUM]);
d476 1
a476 2
frame_locals_address (fi)
     struct frame_info *fi;
d480 1
a480 1
  if (fi->args_pointer)	/* Cached value is likely there.  */
d494 1
a494 2
frame_args_address (fi)
     struct frame_info *fi;
d514 1
a514 2
frame_saved_pc (frame)
     struct frame_info *frame;
d516 1
a516 1
  return read_next_frame_reg(frame, SRP_REGNUM);
d523 1
a523 3
write_word (sp, word)
     CORE_ADDR sp;
     ULONGEST word;
d533 1
a533 1
m88k_push_dummy_frame()
d541 4
a544 4
  for (rn = 0, offset = 0; rn <= SP_REGNUM; rn++, offset+=4)
    write_word (sp+offset, read_register(rn));
  
  write_word (sp+offset, read_register (SXIP_REGNUM));
d547 1
a547 1
  write_word (sp+offset, read_register (SNIP_REGNUM));
d550 1
a550 1
  write_word (sp+offset, read_register (SFIP_REGNUM));
d553 1
a553 1
  write_word (sp+offset, read_register (PSR_REGNUM));
d556 1
a556 1
  write_word (sp+offset, read_register (FPSR_REGNUM));
d559 1
a559 1
  write_word (sp+offset, read_register (FPCR_REGNUM));
d567 1
a567 1
pop_frame ()
d580 2
a581 2
	 that we can deal with the saved registers properly (e.g. frame
	 1 is a call dummy, the user types "frame 2" and then "print $ps").  */
d585 4
a588 4
      for (regnum = 0, offset = 0; regnum <= SP_REGNUM; regnum++, offset+=4)
	(void) write_register (regnum, read_memory_integer (sp+offset, 4));
  
      write_register (SXIP_REGNUM, read_memory_integer (sp+offset, 4));
d591 1
a591 1
      write_register (SNIP_REGNUM, read_memory_integer (sp+offset, 4));
d594 1
a594 1
      write_register (SFIP_REGNUM, read_memory_integer (sp+offset, 4));
d597 1
a597 1
      write_register (PSR_REGNUM, read_memory_integer (sp+offset, 4));
d600 1
a600 1
      write_register (FPSR_REGNUM, read_memory_integer (sp+offset, 4));
d603 1
a603 1
      write_register (FPCR_REGNUM, read_memory_integer (sp+offset, 4));
d607 1
a607 1
  else 
d609 4
a612 4
      for (regnum = FP_REGNUM ; regnum > 0 ; regnum--)
	  if (fsr.regs[regnum])
	      write_register (regnum,
			      read_memory_integer (fsr.regs[regnum], 4));
d619 1
a619 1
_initialize_m88k_tdep ()
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990504 snapshot
@
text
@d404 1
a404 1
m88k_skip_prologue (ip)
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d68 2
a69 2
     the ADDRESS, of SP_REGNUM.  It also depends on the cache of
     frame_find_saved_regs results.  */
d83 2
a84 2
     the ADDRESS, of SP_REGNUM.  It also depends on the cache of
     frame_find_saved_regs results.  */
d96 2
a97 2
  frame->fsr = 0;		/* Not yet allocated */
  frame->args_pointer = 0;	/* Unknown */
d120 1
a120 1
   subu r31,r31,n                       # stack pointer update
d122 1
a122 1
   (st rn,r31,offset)?                  # save incoming regs
d125 1
a125 1
   (addu r30,r31,n)?                    # frame pointer update
d127 1
a127 1
   (pic sequence)?                      # PIC code prologue
d129 2
a130 2
   (or   rn,rm,0)?                      # Move parameters to other regs
 */
d149 1
a149 2
enum prologue_insn_action
{
d158 1
a158 2
struct prologue_insns
  {
d162 1
a162 1
  };
d164 1
a164 2
struct prologue_insns prologue_insn_tbl[] =
{
d166 3
a168 3
  {0x58000000, 0xf800ffff, PIA_SKIP},	/* or/or.u with immed of 0 */
  {0xf4005800, 0xfc1fffe0, PIA_SKIP},	/* or rd, r0, rs */
  {0xf4005800, 0xfc00ffff, PIA_SKIP},	/* or rd, rs, r0 */
d171 1
a171 1
  {0x67ff0000, 0xffff0007, PIA_NOTE_SP_ADJUSTMENT},
d174 1
a174 1
  {0x63df0000, 0xffff0000, PIA_NOTE_FP_ASSIGNMENT},
d177 2
a178 2
  {0x241f0000, 0xfc1f0000, PIA_NOTE_ST},	/* st rx, sp, n */
  {0x201f0000, 0xfc1f0000, PIA_NOTE_STD},	/* st.d rs, sp, n */
d181 4
a184 4
  {0x5f200000, 0xffff0000, PIA_SKIP},	/* or.u r25, r0, offset_high */
  {0xcc000002, 0xffffffff, PIA_SKIP},	/* bsr.n Lab */
  {0x5b390000, 0xffff0000, PIA_SKIP},	/* or r25, r25, offset_low */
  {0xf7396001, 0xffffffff, PIA_SKIP},	/* Lab: addu r25, r25, r1 */
d189 4
a192 4
  {0xc4000000, 0xe4000000, PIA_NOTE_PROLOGUE_END},
					/* br.n, bsr.n, bb0.n, or bb1.n */
  {0xec000000, 0xfc000000, PIA_NOTE_PROLOGUE_END},	/* bcnd.n */
  {0xf400c400, 0xfffff7e0, PIA_NOTE_PROLOGUE_END}	/* jmp.n or jsr.n */
d222 1
a222 1
read_next_frame_reg (frame, regno)
d226 1
a226 2
  for (; frame; frame = frame->next)
    {
d230 3
a232 3
	return read_memory_integer (frame->fsr->regs[regno], 4);
    }
  return read_register (regno);
d267 1
a267 1
      struct prologue_insns *pip;
d269 3
a271 3
      for (pip = prologue_insn_tbl; (insn & pip->mask) != pip->insn;)
	if (++pip >= prologue_insn_tbl + sizeof prologue_insn_tbl)
	  goto end_of_prologue_found;	/* not a prologue insn */
d275 13
a287 14
	case PIA_NOTE_ST:
	case PIA_NOTE_STD:
	  if (sp_offset != -1)
	    {
	      src = ST_SRC (insn);
	      offset = ST_OFFSET (insn);
	      must_adjust[src] = 1;
	      fsr->regs[src++] = offset;	/* Will be adjusted later */
	      if (pip->action == PIA_NOTE_STD && src < 32)
		{
		  offset += 4;
		  must_adjust[src] = 1;
		  fsr->regs[src++] = offset;
		}
d289 23
a311 23
	  else
	    goto end_of_prologue_found;
	  break;
	case PIA_NOTE_SP_ADJUSTMENT:
	  if (sp_offset == -1)
	    sp_offset = -SUBU_OFFSET (insn);
	  else
	    goto end_of_prologue_found;
	  break;
	case PIA_NOTE_FP_ASSIGNMENT:
	  if (fp_offset == -1)
	    fp_offset = ADDU_OFFSET (insn);
	  else
	    goto end_of_prologue_found;
	  break;
	case PIA_NOTE_PROLOGUE_END:
	  if (!prologue_end)
	    prologue_end = ip;
	  break;
	case PIA_SKIP:
	default:
	  /* Do nothing */
	  break;
d320 2
a321 2
  if (prologue_end)
    ip = prologue_end;
d333 2
a334 2
     sp_offset  original (before any alloca calls) displacement of SP
     (will be negative).
d336 2
a337 2
     fp_offset  displacement from original SP to the FP for this frame
     or -1.
d339 2
a340 2
     fsr->regs[0..31]   displacement from original SP to the stack
     location where reg[0..31] is stored.
d342 1
a342 1
     must_adjust[0..31] set if corresponding offset was set.
d353 16
a368 23
  if (fp_offset != -1)
    {
      /* We have a frame pointer, so get it, and base our calc's on it.  */
      frame_fp = (CORE_ADDR) read_next_frame_reg (fi->next, ACTUAL_FP_REGNUM);
      frame_sp = frame_fp - fp_offset;
    }
  else
    {
      /* We have no frame pointer, therefore frame_sp is still the same value
         as set by prologue.  But where is the frame itself?  */
      if (must_adjust[SRP_REGNUM])
	{
	  /* Function header saved SRP (r1), the return address.  Frame starts
	     4 bytes down from where it was saved.  */
	  frame_fp = frame_sp + fsr->regs[SRP_REGNUM] - 4;
	  fi->locals_pointer = frame_fp;
	}
      else
	{
	  /* Function header didn't save SRP (r1), so we are in a leaf fn or
	     are otherwise confused.  */
	  frame_fp = -1;
	}
d370 1
d385 1
a385 1

d388 5
a392 5
  if (fsr->regs[SP_REGNUM] != 0
      && fsr->regs[SP_REGNUM] != frame_sp - sp_offset)
    fprintf_unfiltered (gdb_stderr, "Bad saved SP value %x != %x, offset %x!\n",
			fsr->regs[SP_REGNUM],
			frame_sp - sp_offset, sp_offset);
d405 1
a405 1
CORE_ADDR (ip);
d415 1
a415 1
			    (struct frame_info *) 0));
d445 6
a450 6
         is in the function prologue, we only consider the part that
         has executed already.  In the case where the PC is not in
         the function prologue, we set limit to two instructions beyond
         where the prologue ends in case if any of the prologue instructions
         were moved into a delay slot of a branch instruction. */

d453 2
a454 2
      limit = (sal.end && sal.end < fi->pc) ? sal.end + 2 * BYTES_PER_88K_INSN
	: fi->pc;
d459 1
a459 1
	SIGTRAMP_FRAME_FIXUP (fi->frame);
d464 1
a464 1
	SIGTRAMP_SP_FIXUP (fi->fsr->regs[SP_REGNUM]);
d483 1
a483 1
  if (fi->args_pointer)		/* Cached value is likely there.  */
d521 1
a521 1
  return read_next_frame_reg (frame, SRP_REGNUM);
d540 1
a540 1
m88k_push_dummy_frame ()
d548 4
a551 4
  for (rn = 0, offset = 0; rn <= SP_REGNUM; rn++, offset += 4)
    write_word (sp + offset, read_register (rn));

  write_word (sp + offset, read_register (SXIP_REGNUM));
d554 1
a554 1
  write_word (sp + offset, read_register (SNIP_REGNUM));
d557 1
a557 1
  write_word (sp + offset, read_register (SFIP_REGNUM));
d560 1
a560 1
  write_word (sp + offset, read_register (PSR_REGNUM));
d563 1
a563 1
  write_word (sp + offset, read_register (FPSR_REGNUM));
d566 1
a566 1
  write_word (sp + offset, read_register (FPCR_REGNUM));
d587 2
a588 2
         that we can deal with the saved registers properly (e.g. frame
         1 is a call dummy, the user types "frame 2" and then "print $ps").  */
d592 4
a595 4
      for (regnum = 0, offset = 0; regnum <= SP_REGNUM; regnum++, offset += 4)
	(void) write_register (regnum, read_memory_integer (sp + offset, 4));

      write_register (SXIP_REGNUM, read_memory_integer (sp + offset, 4));
d598 1
a598 1
      write_register (SNIP_REGNUM, read_memory_integer (sp + offset, 4));
d601 1
a601 1
      write_register (SFIP_REGNUM, read_memory_integer (sp + offset, 4));
d604 1
a604 1
      write_register (PSR_REGNUM, read_memory_integer (sp + offset, 4));
d607 1
a607 1
      write_register (FPSR_REGNUM, read_memory_integer (sp + offset, 4));
d610 1
a610 1
      write_register (FPCR_REGNUM, read_memory_integer (sp + offset, 4));
d614 1
a614 1
  else
d616 4
a619 4
      for (regnum = FP_REGNUM; regnum > 0; regnum--)
	if (fsr.regs[regnum])
	  write_register (regnum,
			  read_memory_integer (fsr.regs[regnum], 4));
@

