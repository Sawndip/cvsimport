head	1.110;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.110
	gdb_7_6-2013-04-26-release:1.110
	gdb_7_6-branch:1.110.0.2
	gdb_7_6-2013-03-12-branchpoint:1.110
	gdb_7_5_1-2012-11-29-release:1.104
	gdb_7_5-2012-08-17-release:1.104
	gdb_7_5-branch:1.104.0.2
	gdb_7_5-2012-07-18-branchpoint:1.104
	gdb_7_4_1-2012-04-26-release:1.100.2.1
	gdb_7_4-2012-01-24-release:1.100.2.1
	gdb_7_4-branch:1.100.0.2
	gdb_7_4-2011-12-13-branchpoint:1.100
	gdb_7_3_1-2011-09-04-release:1.99
	gdb_7_3-2011-07-26-release:1.99
	gdb_7_3-branch:1.99.0.2
	gdb_7_3-2011-04-01-branchpoint:1.99
	gdb_7_2-2010-09-02-release:1.85
	gdb_7_2-branch:1.85.0.2
	gdb_7_2-2010-07-07-branchpoint:1.85
	gdb_7_1-2010-03-18-release:1.81
	gdb_7_1-branch:1.81.0.2
	gdb_7_1-2010-02-18-branchpoint:1.81
	gdb_7_0_1-2009-12-22-release:1.76
	gdb_7_0-2009-10-06-release:1.76
	gdb_7_0-branch:1.76.0.4
	gdb_7_0-2009-09-16-branchpoint:1.76
	arc-sim-20090309:1.58
	msnyder-checkpoint-072509-branch:1.76.0.2
	msnyder-checkpoint-072509-branchpoint:1.76
	arc-insight_6_8-branch:1.58.0.6
	arc-insight_6_8-branchpoint:1.58
	insight_6_8-branch:1.58.0.4
	insight_6_8-branchpoint:1.58
	reverse-20081226-branch:1.67.0.6
	reverse-20081226-branchpoint:1.67
	multiprocess-20081120-branch:1.67.0.4
	multiprocess-20081120-branchpoint:1.67
	reverse-20080930-branch:1.67.0.2
	reverse-20080930-branchpoint:1.67
	reverse-20080717-branch:1.60.0.4
	reverse-20080717-branchpoint:1.60
	msnyder-reverse-20080609-branch:1.60.0.2
	msnyder-reverse-20080609-branchpoint:1.60
	drow-reverse-20070409-branch:1.46.0.2
	drow-reverse-20070409-branchpoint:1.46
	gdb_6_8-2008-03-27-release:1.58
	gdb_6_8-branch:1.58.0.2
	gdb_6_8-2008-02-26-branchpoint:1.58
	gdb_6_7_1-2007-10-29-release:1.49
	gdb_6_7-2007-10-10-release:1.49
	gdb_6_7-branch:1.49.0.2
	gdb_6_7-2007-09-07-branchpoint:1.49
	insight_6_6-20070208-release:1.45
	gdb_6_6-2006-12-18-release:1.45
	gdb_6_6-branch:1.45.0.18
	gdb_6_6-2006-11-15-branchpoint:1.45
	insight_6_5-20061003-release:1.45
	gdb-csl-symbian-6_4_50_20060226-12:1.45
	gdb-csl-sourcerygxx-3_4_4-25:1.43
	nickrob-async-20060828-mergepoint:1.45
	gdb-csl-symbian-6_4_50_20060226-11:1.45
	gdb-csl-sourcerygxx-4_1-17:1.45
	gdb-csl-20060226-branch-local-2:1.45
	gdb-csl-sourcerygxx-4_1-14:1.45
	gdb-csl-sourcerygxx-4_1-13:1.45
	gdb-csl-sourcerygxx-4_1-12:1.45
	gdb-csl-sourcerygxx-3_4_4-21:1.45
	gdb_6_5-20060621-release:1.45
	gdb-csl-sourcerygxx-4_1-9:1.45
	gdb-csl-sourcerygxx-4_1-8:1.45
	gdb-csl-sourcerygxx-4_1-7:1.45
	gdb-csl-arm-2006q1-6:1.45
	gdb-csl-sourcerygxx-4_1-6:1.45
	gdb-csl-symbian-6_4_50_20060226-10:1.45
	gdb-csl-symbian-6_4_50_20060226-9:1.45
	gdb-csl-symbian-6_4_50_20060226-8:1.45
	gdb-csl-coldfire-4_1-11:1.45
	gdb-csl-sourcerygxx-3_4_4-19:1.45
	gdb-csl-coldfire-4_1-10:1.45
	gdb_6_5-branch:1.45.0.16
	gdb_6_5-2006-05-14-branchpoint:1.45
	gdb-csl-sourcerygxx-4_1-5:1.45
	nickrob-async-20060513-branch:1.45.0.14
	nickrob-async-20060513-branchpoint:1.45
	gdb-csl-sourcerygxx-4_1-4:1.45
	msnyder-reverse-20060502-branch:1.45.0.12
	msnyder-reverse-20060502-branchpoint:1.45
	gdb-csl-morpho-4_1-4:1.45
	gdb-csl-sourcerygxx-3_4_4-17:1.45
	readline_5_1-import-branch:1.45.0.10
	readline_5_1-import-branchpoint:1.45
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.45
	gdb-csl-symbian-20060226-branch:1.45.0.8
	gdb-csl-symbian-20060226-branchpoint:1.45
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.45
	msnyder-reverse-20060331-branch:1.45.0.6
	msnyder-reverse-20060331-branchpoint:1.45
	gdb-csl-available-20060303-branch:1.45.0.4
	gdb-csl-available-20060303-branchpoint:1.45
	gdb-csl-20060226-branch:1.45.0.2
	gdb-csl-20060226-branchpoint:1.45
	gdb_6_4-20051202-release:1.43
	msnyder-fork-checkpoint-branch:1.43.0.8
	msnyder-fork-checkpoint-branchpoint:1.43
	gdb-csl-gxxpro-6_3-branch:1.43.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.43
	gdb_6_4-branch:1.43.0.4
	gdb_6_4-2005-11-01-branchpoint:1.43
	gdb-csl-arm-20051020-branch:1.43.0.2
	gdb-csl-arm-20051020-branchpoint:1.43
	msnyder-tracepoint-checkpoint-branch:1.40.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.40
	gdb-csl-arm-20050325-2005-q1b:1.39
	gdb-csl-arm-20050325-2005-q1a:1.39
	csl-arm-20050325-branch:1.39.0.2
	csl-arm-20050325-branchpoint:1.39
	gdb-post-i18n-errorwarning-20050211:1.38
	gdb-pre-i18n-errorwarning-20050211:1.37
	gdb_6_3-20041109-release:1.24
	gdb_6_3-branch:1.24.0.2
	gdb_6_3-20041019-branchpoint:1.24
	drow_intercu-merge-20040921:1.24
	drow_intercu-merge-20040915:1.23
	jimb-gdb_6_2-e500-branch:1.23.0.6
	jimb-gdb_6_2-e500-branchpoint:1.23
	gdb_6_2-20040730-release:1.23
	gdb_6_2-branch:1.23.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.23
	gdb_6_1_1-20040616-release:1.21
	gdb_6_1-2004-04-05-release:1.21
	drow_intercu-merge-20040402:1.22
	drow_intercu-merge-20040327:1.21
	ezannoni_pie-20040323-branch:1.21.0.16
	ezannoni_pie-20040323-branchpoint:1.21
	cagney_tramp-20040321-mergepoint:1.21
	cagney_tramp-20040309-branch:1.21.0.14
	cagney_tramp-20040309-branchpoint:1.21
	gdb_6_1-branch:1.21.0.12
	gdb_6_1-2004-03-01-gmt-branchpoint:1.21
	drow_intercu-20040221-branch:1.21.0.10
	drow_intercu-20040221-branchpoint:1.21
	cagney_bfdfile-20040213-branch:1.21.0.8
	cagney_bfdfile-20040213-branchpoint:1.21
	drow-cplus-merge-20040208:1.21
	carlton_dictionary-20040126-merge:1.21
	cagney_bigcore-20040122-branch:1.21.0.6
	cagney_bigcore-20040122-branchpoint:1.21
	drow-cplus-merge-20040113:1.21
	drow-cplus-merge-20031224:1.21
	drow-cplus-merge-20031220:1.21
	carlton_dictionary-20031215-merge:1.21
	drow-cplus-merge-20031214:1.21
	carlton-dictionary-20031111-merge:1.21
	gdb_6_0-2003-10-04-release:1.20
	kettenis_sparc-20030918-branch:1.21.0.4
	kettenis_sparc-20030918-branchpoint:1.21
	carlton_dictionary-20030917-merge:1.21
	ezannoni_pie-20030916-branchpoint:1.21
	ezannoni_pie-20030916-branch:1.21.0.2
	cagney_x86i386-20030821-branch:1.20.0.16
	cagney_x86i386-20030821-branchpoint:1.20
	carlton_dictionary-20030805-merge:1.20
	carlton_dictionary-20030627-merge:1.20
	gdb_6_0-branch:1.20.0.14
	gdb_6_0-2003-06-23-branchpoint:1.20
	jimb-ppc64-linux-20030613-branch:1.20.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.20
	cagney_convert-20030606-branch:1.20.0.10
	cagney_convert-20030606-branchpoint:1.20
	cagney_writestrings-20030508-branch:1.20.0.8
	cagney_writestrings-20030508-branchpoint:1.20
	jimb-ppc64-linux-20030528-branch:1.20.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.20
	carlton_dictionary-20030523-merge:1.20
	cagney_fileio-20030521-branch:1.20.0.4
	cagney_fileio-20030521-branchpoint:1.20
	kettenis_i386newframe-20030517-mergepoint:1.20
	jimb-ppc64-linux-20030509-branch:1.20.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.20
	kettenis_i386newframe-20030504-mergepoint:1.20
	carlton_dictionary-20030430-merge:1.20
	kettenis_i386newframe-20030419-branch:1.19.0.12
	kettenis_i386newframe-20030419-branchpoint:1.19
	carlton_dictionary-20030416-merge:1.19
	cagney_frameaddr-20030409-mergepoint:1.19
	kettenis_i386newframe-20030406-branch:1.19.0.10
	kettenis_i386newframe-20030406-branchpoint:1.19
	cagney_frameaddr-20030403-branchpoint:1.19
	cagney_frameaddr-20030403-branch:1.19.0.8
	cagney_framebase-20030330-mergepoint:1.19
	cagney_framebase-20030326-branch:1.19.0.6
	cagney_framebase-20030326-branchpoint:1.19
	cagney_lazyid-20030317-branch:1.19.0.4
	cagney_lazyid-20030317-branchpoint:1.19
	kettenis-i386newframe-20030316-mergepoint:1.19
	offbyone-20030313-branch:1.19.0.2
	offbyone-20030313-branchpoint:1.19
	kettenis-i386newframe-20030308-branch:1.18.0.6
	kettenis-i386newframe-20030308-branchpoint:1.18
	carlton_dictionary-20030305-merge:1.18
	cagney_offbyone-20030303-branch:1.18.0.4
	cagney_offbyone-20030303-branchpoint:1.18
	carlton_dictionary-20030207-merge:1.18
	interps-20030203-mergepoint:1.18
	interps-20030202-branch:1.18.0.2
	interps-20030202-branchpoint:1.18
	cagney-unwind-20030108-branch:1.17.0.2
	cagney-unwind-20030108-branchpoint:1.17
	carlton_dictionary-20021223-merge:1.16
	gdb_5_3-2002-12-12-release:1.16
	carlton_dictionary-20021115-merge:1.16
	kseitz_interps-20021105-merge:1.16
	kseitz_interps-20021103-merge:1.16
	drow-cplus-merge-20021020:1.16
	drow-cplus-merge-20021025:1.16
	carlton_dictionary-20021025-merge:1.16
	carlton_dictionary-20021011-merge:1.16
	drow-cplus-branch:1.16.0.10
	drow-cplus-branchpoint:1.16
	kseitz_interps-20020930-merge:1.16
	carlton_dictionary-20020927-merge:1.16
	carlton_dictionary-branch:1.16.0.8
	carlton_dictionary-20020920-branchpoint:1.16
	gdb_5_3-branch:1.16.0.6
	gdb_5_3-2002-09-04-branchpoint:1.16
	kseitz_interps-20020829-merge:1.16
	cagney_sysregs-20020825-branch:1.16.0.4
	cagney_sysregs-20020825-branchpoint:1.16
	readline_4_3-import-branch:1.16.0.2
	readline_4_3-import-branchpoint:1.16
	gdb_5_2_1-2002-07-23-release:1.13
	kseitz_interps-20020528-branch:1.15.0.6
	kseitz_interps-20020528-branchpoint:1.15
	cagney_regbuf-20020515-branch:1.15.0.4
	cagney_regbuf-20020515-branchpoint:1.15
	jimb-macro-020506-branch:1.15.0.2
	jimb-macro-020506-branchpoint:1.15
	gdb_5_2-2002-04-29-release:1.13
	gdb_5_2-branch:1.13.0.2
	gdb_5_2-2002-03-03-branchpoint:1.13
	gdb_5_1_1-2002-01-24-release:1.7.4.1
	gdb_5_1_0_1-2002-01-03-release:1.7.4.1
	cygnus_cvs_20020108_pre:1.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7.4.1
	gdb_5_1_0_1-2002-01-03-branch:1.7.4.1.0.2
	gdb_5_1-2001-11-21-release:1.7.4.1
	gdb_s390-2001-09-26-branch:1.7.0.6
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.4
	gdb_5_1-2001-07-29-branchpoint:1.7
	dberlin-typesystem-branch:1.7.0.2
	dberlin-typesystem-branchpoint:1.7
	gdb-post-ptid_t-2001-05-03:1.7
	gdb-pre-ptid_t-2001-05-03:1.7
	insight-precleanup-2001-01-01:1.5
	gdb-post-protoization-2000-07-29:1.5
	gdb-pre-protoization-2000-07-29:1.4
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	insight-2000-02-04:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.110
date	2013.01.31.18.37.37;	author aristovski;	state Exp;
branches;
next	1.109;

1.109
date	2013.01.25.22.31.43;	author sivachandra;	state Exp;
branches;
next	1.108;

1.108
date	2013.01.25.17.16.40;	author aburgess;	state Exp;
branches;
next	1.107;

1.107
date	2013.01.01.06.41.29;	author brobecke;	state Exp;
branches;
next	1.106;

1.106
date	2012.09.14.12.46.55;	author siddhesh;	state Exp;
branches;
next	1.105;

1.105
date	2012.08.16.07.36.20;	author qiyao;	state Exp;
branches;
next	1.104;

1.104
date	2012.06.09.07.36.43;	author sivachandra;	state Exp;
branches;
next	1.103;

1.103
date	2012.05.18.21.02.50;	author sergiodj;	state Exp;
branches;
next	1.102;

1.102
date	2012.02.07.04.48.23;	author devans;	state Exp;
branches;
next	1.101;

1.101
date	2012.01.04.08.27.57;	author brobecke;	state Exp;
branches;
next	1.100;

1.100
date	2011.10.14.20.22.17;	author kseitz;	state Exp;
branches
	1.100.2.1;
next	1.99;

1.99
date	2011.02.18.19.10.46;	author jkratoch;	state Exp;
branches;
next	1.98;

1.98
date	2011.02.14.11.30.37;	author palves;	state Exp;
branches;
next	1.97;

1.97
date	2011.01.12.16.10.05;	author jkratoch;	state Exp;
branches;
next	1.96;

1.96
date	2011.01.12.01.23.28;	author msnyder;	state Exp;
branches;
next	1.95;

1.95
date	2011.01.10.17.14.13;	author msnyder;	state Exp;
branches;
next	1.94;

1.94
date	2011.01.05.22.22.53;	author msnyder;	state Exp;
branches;
next	1.93;

1.93
date	2011.01.01.15.33.19;	author brobecke;	state Exp;
branches;
next	1.92;

1.92
date	2010.12.14.10.23.41;	author kwerner;	state Exp;
branches;
next	1.91;

1.91
date	2010.11.29.21.18.16;	author tromey;	state Exp;
branches;
next	1.90;

1.90
date	2010.11.03.14.21.57;	author kwerner;	state Exp;
branches;
next	1.89;

1.89
date	2010.11.03.14.06.27;	author kwerner;	state Exp;
branches;
next	1.88;

1.88
date	2010.10.19.20.53.14;	author swagiaal;	state Exp;
branches;
next	1.87;

1.87
date	2010.10.08.16.50.53;	author kwerner;	state Exp;
branches;
next	1.86;

1.86
date	2010.08.11.16.48.26;	author kwerner;	state Exp;
branches;
next	1.85;

1.85
date	2010.06.07.16.11.31;	author swagiaal;	state Exp;
branches;
next	1.84;

1.84
date	2010.05.17.18.48.51;	author msnyder;	state Exp;
branches;
next	1.83;

1.83
date	2010.05.06.18.26.13;	author msnyder;	state Exp;
branches;
next	1.82;

1.82
date	2010.03.16.20.51.23;	author jkratoch;	state Exp;
branches;
next	1.81;

1.81
date	2010.02.11.21.45.25;	author palves;	state Exp;
branches;
next	1.80;

1.80
date	2010.02.08.18.27.53;	author cmoller;	state Exp;
branches;
next	1.79;

1.79
date	2010.01.20.18.06.15;	author tromey;	state Exp;
branches;
next	1.78;

1.78
date	2010.01.01.07.31.43;	author brobecke;	state Exp;
branches;
next	1.77;

1.77
date	2009.12.30.17.33.33;	author bauermann;	state Exp;
branches;
next	1.76;

1.76
date	2009.07.02.17.25.59;	author uweigand;	state Exp;
branches;
next	1.75;

1.75
date	2009.07.02.12.57.14;	author uweigand;	state Exp;
branches;
next	1.74;

1.74
date	2009.07.02.12.20.17;	author uweigand;	state Exp;
branches;
next	1.73;

1.73
date	2009.06.29.13.24.41;	author uweigand;	state Exp;
branches;
next	1.72;

1.72
date	2009.06.17.18.47.35;	author uweigand;	state Exp;
branches;
next	1.71;

1.71
date	2009.06.03.17.47.54;	author uweigand;	state Exp;
branches;
next	1.70;

1.70
date	2009.01.13.10.34.31;	author palves;	state Exp;
branches;
next	1.69;

1.69
date	2009.01.03.05.57.54;	author brobecke;	state Exp;
branches;
next	1.68;

1.68
date	2008.12.28.14.14.19;	author jkratoch;	state Exp;
branches;
next	1.67;

1.67
date	2008.09.11.14.25.49;	author uweigand;	state Exp;
branches;
next	1.66;

1.66
date	2008.09.11.14.16.14;	author uweigand;	state Exp;
branches;
next	1.65;

1.65
date	2008.09.11.14.15.01;	author uweigand;	state Exp;
branches;
next	1.64;

1.64
date	2008.09.11.14.14.20;	author uweigand;	state Exp;
branches;
next	1.63;

1.63
date	2008.09.11.14.13.46;	author uweigand;	state Exp;
branches;
next	1.62;

1.62
date	2008.09.11.14.11.40;	author uweigand;	state Exp;
branches;
next	1.61;

1.61
date	2008.09.11.14.10.24;	author uweigand;	state Exp;
branches;
next	1.60;

1.60
date	2008.04.30.21.13.49;	author drow;	state Exp;
branches;
next	1.59;

1.59
date	2008.04.22.06.53.18;	author deuling;	state Exp;
branches;
next	1.58;

1.58
date	2008.02.04.00.23.04;	author devans;	state Exp;
branches;
next	1.57;

1.57
date	2008.02.03.01.51.04;	author devans;	state Exp;
branches;
next	1.56;

1.56
date	2008.01.30.07.28.16;	author hilfingr;	state Exp;
branches;
next	1.55;

1.55
date	2008.01.29.14.24.43;	author muller;	state Exp;
branches;
next	1.54;

1.54
date	2008.01.18.17.07.40;	author deuling;	state Exp;
branches;
next	1.53;

1.53
date	2008.01.17.19.55.09;	author muller;	state Exp;
branches;
next	1.52;

1.52
date	2008.01.07.22.33.57;	author bauermann;	state Exp;
branches;
next	1.51;

1.51
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.50;

1.50
date	2007.10.25.18.01.58;	author bauermann;	state Exp;
branches;
next	1.49;

1.49
date	2007.08.23.18.08.46;	author brobecke;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.12.16.33.20;	author uweigand;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.12.15.33.04;	author uweigand;	state Exp;
branches;
next	1.46;

1.46
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.45;

1.45
date	2006.01.24.21.21.12;	author jimb;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.17.22.34.03;	author eliz;	state Exp;
branches;
next	1.43;

1.43
date	2005.08.21.09.33.11;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2005.08.11.13.45.40;	author schwab;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.06.06.52.25;	author woodzltc;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.09.21.20.35;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2005.03.08.14.35.17;	author nathan;	state Exp;
branches;
next	1.38;

1.38
date	2005.02.11.04.06.08;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2005.02.08.04.57.03;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2005.02.08.02.29.17;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2005.02.07.15.04.43;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2005.02.07.00.09.55;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2005.02.02.22.34.35;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2005.02.02.00.20.05;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2005.01.28.16.45.15;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2004.11.21.19.52.13;	author drow;	state Exp;
branches;
next	1.29;

1.29
date	2004.11.13.00.53.09;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2004.11.12.21.45.07;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2004.11.10.18.52.24;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.09.14.43.26;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2004.11.02.14.18.13;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.20.20.18.39;	author jjohnstn;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.27.07.57.15;	author dsl;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.01.12.08.30;	author hilfingr;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.14.16.32.14;	author cagney;	state Exp;
branches
	1.21.10.1;
next	1.20;

1.20
date	2003.04.21.16.48.40;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.08.19.27.12;	author cagney;	state Exp;
branches
	1.19.12.1;
next	1.18;

1.18
date	2003.01.14.00.49.04;	author cagney;	state Exp;
branches
	1.18.6.1;
next	1.17;

1.17
date	2003.01.02.14.27.27;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.01.17.18.33;	author cagney;	state Exp;
branches
	1.16.8.1
	1.16.10.1;
next	1.15;

1.15
date	2002.04.10.00.11.51;	author jingham;	state Exp;
branches
	1.15.6.1;
next	1.14;

1.14
date	2002.03.27.21.35.35;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.22.25.49;	author drow;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.04.05.20.08;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.16.01.58.07;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.16.01.19.09;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.24.17.16.53;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.01.18.39.23;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.07.02.57.08;	author jtc;	state Exp;
branches
	1.7.2.1
	1.7.4.1;
next	1.6;

1.6
date	2001.03.06.08.21.18;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.21.20.03.08;	author msnyder;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.28.01.12.33;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.14.18.43.41;	author jimb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.07;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.100.2.1
date	2012.01.06.04.54.33;	author brobecke;	state Exp;
branches;
next	;

1.21.10.1
date	2004.04.02.16.47.49;	author drow;	state Exp;
branches;
next	1.21.10.2;

1.21.10.2
date	2004.09.16.17.01.26;	author drow;	state Exp;
branches;
next	1.21.10.3;

1.21.10.3
date	2004.09.21.20.44.18;	author drow;	state Exp;
branches;
next	;

1.19.12.1
date	2003.05.04.11.37.46;	author kettenis;	state Exp;
branches;
next	;

1.18.6.1
date	2003.03.16.14.01.51;	author kettenis;	state Exp;
branches;
next	;

1.16.8.1
date	2002.11.28.00.53.24;	author carlton;	state Exp;
branches;
next	1.16.8.2;

1.16.8.2
date	2003.02.07.19.17.54;	author carlton;	state Exp;
branches;
next	1.16.8.3;

1.16.8.3
date	2003.04.16.19.56.56;	author carlton;	state Exp;
branches;
next	1.16.8.4;

1.16.8.4
date	2003.05.01.00.46.53;	author carlton;	state Exp;
branches;
next	1.16.8.5;

1.16.8.5
date	2003.09.17.21.28.35;	author carlton;	state Exp;
branches;
next	;

1.16.10.1
date	2003.12.14.20.27.33;	author drow;	state Exp;
branches;
next	;

1.15.6.1
date	2002.08.09.18.34.27;	author kseitz;	state Exp;
branches;
next	;

1.7.2.1
date	2001.07.06.19.17.04;	author dberlin;	state Exp;
branches;
next	;

1.7.4.1
date	2001.10.16.01.18.27;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.07;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.11.02;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.12.14.01.05.39;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.110
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

	* charset.c (intermediate_encoding): Remove unused i.
	* completer.c (signal_completer): Remove unused i.
	* continuations.c (discard_my_continuations_1): Remove unused
	continuation_ptr.
	* corelow.c (core_close): Remove unuseD name.
	(get_core_siginfo): Remove unused pid.
	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Remove unused
	i, cps.
	* dwarf2loc.c (dwarf2_compile_expr_to_ax): Remove unused base_offset.
	(loclist_describe_location): Remove unused first.
	* event-top.c (command_line_handler): Remove unused got_eof.
	* exec.c (exec_close_1): Remove unused need_symtab_cleanup.
	(resize_section_table): Remove unused old_value.
	* gdb_bfd.c (gdb_bfd_map_section): Remove unused header.
	* gnu-v3-abi.c (compute_vtable_size): Remove unused addr.
	* i386-tdep.c (i386_process_record): Remove unused rex.
	* infcmd.c (get_return_value): Remove unused uiout.
	* jv-lang.c (type_from_class): Remove unused is_array.
	* jv-valprint.c (java_val_print): Remove unused i.
	* linux-nat.c (linux_nat_stop_lwp): Remove unused ptid.
	* linux-thread-db.c (thread_db_find_new_threads_2): Remove unuseD pid.
	* m2-typeprint.c (m2_print_type): Remove unused code.
	* macroexp.c (get_character_constant): Remove unused body_start.
	(macro_stringify): Remove unused result.
	* objc-lang.c (find_methods): Remove unused gdbarch.
	* objfiles.c (filter_overlapping_sections): Remove unused abfd1, abfd2.
	* regcache.c (regcache_cooked_read): Remove unused gdbarch.
	* stack.c (print_frame_args): Remove unused summary.
	* thread.c (thread_apply_command): Remove unused p.
	* valarith.c (value_x_unop): Remove unused mangle_ptr.
	* valops.c (search_struct_method): Remove unused skip.
	* valprint.c (generic_val_print): Remove unused byte_order.
	* varobj.c (varobj_update): Remove unused changed.
	* cli/cli-cmds.c (complete_command): Remove unused next_item.
	(alias_command): Remove unused c.
	* mi/mi-cmd-catch.c (mi_catch_load_unload): Remove unused c.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Remove unused
	format.
	(mi_cmd_data_write_memory): Remove unused word_format.
	(mi_cmd_data_write_memory_bytes): Remove unused r.
	* python/py-gdb-readline.c (gdbpy_readline_wrapper): Remove unused
	p_start, p_end.
	* python/python.c (_initialize_python): Remove unused cmd_name, cmd.
	* tui/tui-disasm.c (tui_set_disassem_content): Remove unused
	line_width.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00766.html
@
text
@/* Perform arithmetic and other operations on values, for GDB.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "value.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "expression.h"
#include "target.h"
#include "language.h"
#include "gdb_string.h"
#include "doublest.h"
#include "dfp.h"
#include <math.h>
#include "infcall.h"
#include "exceptions.h"

/* Define whether or not the C operator '/' truncates towards zero for
   differently signed operands (truncation direction is undefined in C).  */

#ifndef TRUNCATION_TOWARDS_ZERO
#define TRUNCATION_TOWARDS_ZERO ((-5 / 2) == -2)
#endif

void _initialize_valarith (void);


/* Given a pointer, return the size of its target.
   If the pointer type is void *, then return 1.
   If the target type is incomplete, then error out.
   This isn't a general purpose function, but just a 
   helper for value_ptradd.  */

static LONGEST
find_size_for_pointer_math (struct type *ptr_type)
{
  LONGEST sz = -1;
  struct type *ptr_target;

  gdb_assert (TYPE_CODE (ptr_type) == TYPE_CODE_PTR);
  ptr_target = check_typedef (TYPE_TARGET_TYPE (ptr_type));

  sz = TYPE_LENGTH (ptr_target);
  if (sz == 0)
    {
      if (TYPE_CODE (ptr_type) == TYPE_CODE_VOID)
	sz = 1;
      else
	{
	  const char *name;
	  
	  name = TYPE_NAME (ptr_target);
	  if (name == NULL)
	    name = TYPE_TAG_NAME (ptr_target);
	  if (name == NULL)
	    error (_("Cannot perform pointer math on incomplete types, "
		   "try casting to a known type, or void *."));
	  else
	    error (_("Cannot perform pointer math on incomplete type \"%s\", "
		   "try casting to a known type, or void *."), name);
	}
    }
  return sz;
}

/* Given a pointer ARG1 and an integral value ARG2, return the
   result of C-style pointer arithmetic ARG1 + ARG2.  */

struct value *
value_ptradd (struct value *arg1, LONGEST arg2)
{
  struct type *valptrtype;
  LONGEST sz;
  struct value *result;

  arg1 = coerce_array (arg1);
  valptrtype = check_typedef (value_type (arg1));
  sz = find_size_for_pointer_math (valptrtype);

  result = value_from_pointer (valptrtype,
			       value_as_address (arg1) + sz * arg2);
  if (VALUE_LVAL (result) != lval_internalvar)
    set_value_component_location (result, arg1);
  return result;
}

/* Given two compatible pointer values ARG1 and ARG2, return the
   result of C-style pointer arithmetic ARG1 - ARG2.  */

LONGEST
value_ptrdiff (struct value *arg1, struct value *arg2)
{
  struct type *type1, *type2;
  LONGEST sz;

  arg1 = coerce_array (arg1);
  arg2 = coerce_array (arg2);
  type1 = check_typedef (value_type (arg1));
  type2 = check_typedef (value_type (arg2));

  gdb_assert (TYPE_CODE (type1) == TYPE_CODE_PTR);
  gdb_assert (TYPE_CODE (type2) == TYPE_CODE_PTR);

  if (TYPE_LENGTH (check_typedef (TYPE_TARGET_TYPE (type1)))
      != TYPE_LENGTH (check_typedef (TYPE_TARGET_TYPE (type2))))
    error (_("First argument of `-' is a pointer and "
	     "second argument is neither\n"
	     "an integer nor a pointer of the same type."));

  sz = TYPE_LENGTH (check_typedef (TYPE_TARGET_TYPE (type1)));
  if (sz == 0) 
    {
      warning (_("Type size unknown, assuming 1. "
               "Try casting to a known type, or void *."));
      sz = 1;
    }

  return (value_as_long (arg1) - value_as_long (arg2)) / sz;
}

/* Return the value of ARRAY[IDX].

   ARRAY may be of type TYPE_CODE_ARRAY or TYPE_CODE_STRING.  If the
   current language supports C-style arrays, it may also be TYPE_CODE_PTR.

   See comments in value_coerce_array() for rationale for reason for
   doing lower bounds adjustment here rather than there.
   FIXME:  Perhaps we should validate that the index is valid and if
   verbosity is set, warn about invalid indices (but still use them).  */

struct value *
value_subscript (struct value *array, LONGEST index)
{
  int c_style = current_language->c_style_arrays;
  struct type *tarray;

  array = coerce_ref (array);
  tarray = check_typedef (value_type (array));

  if (TYPE_CODE (tarray) == TYPE_CODE_ARRAY
      || TYPE_CODE (tarray) == TYPE_CODE_STRING)
    {
      struct type *range_type = TYPE_INDEX_TYPE (tarray);
      LONGEST lowerbound, upperbound;

      get_discrete_bounds (range_type, &lowerbound, &upperbound);
      if (VALUE_LVAL (array) != lval_memory)
	return value_subscripted_rvalue (array, index, lowerbound);

      if (c_style == 0)
	{
	  if (index >= lowerbound && index <= upperbound)
	    return value_subscripted_rvalue (array, index, lowerbound);
	  /* Emit warning unless we have an array of unknown size.
	     An array of unknown size has lowerbound 0 and upperbound -1.  */
	  if (upperbound > -1)
	    warning (_("array or string index out of range"));
	  /* fall doing C stuff */
	  c_style = 1;
	}

      index -= lowerbound;
      array = value_coerce_array (array);
    }

  if (c_style)
    return value_ind (value_ptradd (array, index));
  else
    error (_("not an array or string"));
}

/* Return the value of EXPR[IDX], expr an aggregate rvalue
   (eg, a vector register).  This routine used to promote floats
   to doubles, but no longer does.  */

struct value *
value_subscripted_rvalue (struct value *array, LONGEST index, int lowerbound)
{
  struct type *array_type = check_typedef (value_type (array));
  struct type *elt_type = check_typedef (TYPE_TARGET_TYPE (array_type));
  unsigned int elt_size = TYPE_LENGTH (elt_type);
  unsigned int elt_offs = elt_size * longest_to_int (index - lowerbound);
  struct value *v;

  if (index < lowerbound || (!TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED (array_type)
			     && elt_offs >= TYPE_LENGTH (array_type)))
    error (_("no such vector element"));

  if (VALUE_LVAL (array) == lval_memory && value_lazy (array))
    v = allocate_value_lazy (elt_type);
  else
    {
      v = allocate_value (elt_type);
      value_contents_copy (v, value_embedded_offset (v),
			   array, value_embedded_offset (array) + elt_offs,
			   elt_size);
    }

  set_value_component_location (v, array);
  VALUE_REGNUM (v) = VALUE_REGNUM (array);
  VALUE_FRAME_ID (v) = VALUE_FRAME_ID (array);
  set_value_offset (v, value_offset (array) + elt_offs);
  return v;
}


/* Check to see if either argument is a structure, or a reference to
   one.  This is called so we know whether to go ahead with the normal
   binop or look for a user defined function instead.

   For now, we do not overload the `=' operator.  */

int
binop_types_user_defined_p (enum exp_opcode op,
			    struct type *type1, struct type *type2)
{
  if (op == BINOP_ASSIGN || op == BINOP_CONCAT)
    return 0;

  type1 = check_typedef (type1);
  if (TYPE_CODE (type1) == TYPE_CODE_REF)
    type1 = check_typedef (TYPE_TARGET_TYPE (type1));

  type2 = check_typedef (type2);
  if (TYPE_CODE (type2) == TYPE_CODE_REF)
    type2 = check_typedef (TYPE_TARGET_TYPE (type2));

  return (TYPE_CODE (type1) == TYPE_CODE_STRUCT
	  || TYPE_CODE (type2) == TYPE_CODE_STRUCT);
}

/* Check to see if either argument is a structure, or a reference to
   one.  This is called so we know whether to go ahead with the normal
   binop or look for a user defined function instead.

   For now, we do not overload the `=' operator.  */

int
binop_user_defined_p (enum exp_opcode op,
		      struct value *arg1, struct value *arg2)
{
  return binop_types_user_defined_p (op, value_type (arg1), value_type (arg2));
}

/* Check to see if argument is a structure.  This is called so
   we know whether to go ahead with the normal unop or look for a 
   user defined function instead.

   For now, we do not overload the `&' operator.  */

int
unop_user_defined_p (enum exp_opcode op, struct value *arg1)
{
  struct type *type1;

  if (op == UNOP_ADDR)
    return 0;
  type1 = check_typedef (value_type (arg1));
  if (TYPE_CODE (type1) == TYPE_CODE_REF)
    type1 = check_typedef (TYPE_TARGET_TYPE (type1));
  return TYPE_CODE (type1) == TYPE_CODE_STRUCT;
}

/* Try to find an operator named OPERATOR which takes NARGS arguments
   specified in ARGS.  If the operator found is a static member operator
   *STATIC_MEMFUNP will be set to 1, and otherwise 0.
   The search if performed through find_overload_match which will handle
   member operators, non member operators, operators imported implicitly or
   explicitly, and perform correct overload resolution in all of the above
   situations or combinations thereof.  */

static struct value *
value_user_defined_cpp_op (struct value **args, int nargs, char *operator,
                           int *static_memfuncp)
{

  struct symbol *symp = NULL;
  struct value *valp = NULL;

  find_overload_match (args, nargs, operator, BOTH /* could be method */,
                       &args[0] /* objp */,
                       NULL /* pass NULL symbol since symbol is unknown */,
                       &valp, &symp, static_memfuncp, 0);

  if (valp)
    return valp;

  if (symp)
    {
      /* This is a non member function and does not
         expect a reference as its first argument
         rather the explicit structure.  */
      args[0] = value_ind (args[0]);
      return value_of_variable (symp, 0);
    }

  error (_("Could not find %s."), operator);
}

/* Lookup user defined operator NAME.  Return a value representing the
   function, otherwise return NULL.  */

static struct value *
value_user_defined_op (struct value **argp, struct value **args, char *name,
                       int *static_memfuncp, int nargs)
{
  struct value *result = NULL;

  if (current_language->la_language == language_cplus)
    result = value_user_defined_cpp_op (args, nargs, name, static_memfuncp);
  else
    result = value_struct_elt (argp, args, name, static_memfuncp,
                               "structure");

  return result;
}

/* We know either arg1 or arg2 is a structure, so try to find the right
   user defined function.  Create an argument vector that calls 
   arg1.operator @@ (arg1,arg2) and return that value (where '@@' is any
   binary operator which is legal for GNU C++).

   OP is the operatore, and if it is BINOP_ASSIGN_MODIFY, then OTHEROP
   is the opcode saying how to modify it.  Otherwise, OTHEROP is
   unused.  */

struct value *
value_x_binop (struct value *arg1, struct value *arg2, enum exp_opcode op,
	       enum exp_opcode otherop, enum noside noside)
{
  struct value **argvec;
  char *ptr;
  char tstr[13];
  int static_memfuncp;

  arg1 = coerce_ref (arg1);
  arg2 = coerce_ref (arg2);

  /* now we know that what we have to do is construct our
     arg vector and find the right function to call it with.  */

  if (TYPE_CODE (check_typedef (value_type (arg1))) != TYPE_CODE_STRUCT)
    error (_("Can't do that binary op on that type"));	/* FIXME be explicit */

  argvec = (struct value **) alloca (sizeof (struct value *) * 4);
  argvec[1] = value_addr (arg1);
  argvec[2] = arg2;
  argvec[3] = 0;

  /* Make the right function name up.  */
  strcpy (tstr, "operator__");
  ptr = tstr + 8;
  switch (op)
    {
    case BINOP_ADD:
      strcpy (ptr, "+");
      break;
    case BINOP_SUB:
      strcpy (ptr, "-");
      break;
    case BINOP_MUL:
      strcpy (ptr, "*");
      break;
    case BINOP_DIV:
      strcpy (ptr, "/");
      break;
    case BINOP_REM:
      strcpy (ptr, "%");
      break;
    case BINOP_LSH:
      strcpy (ptr, "<<");
      break;
    case BINOP_RSH:
      strcpy (ptr, ">>");
      break;
    case BINOP_BITWISE_AND:
      strcpy (ptr, "&");
      break;
    case BINOP_BITWISE_IOR:
      strcpy (ptr, "|");
      break;
    case BINOP_BITWISE_XOR:
      strcpy (ptr, "^");
      break;
    case BINOP_LOGICAL_AND:
      strcpy (ptr, "&&");
      break;
    case BINOP_LOGICAL_OR:
      strcpy (ptr, "||");
      break;
    case BINOP_MIN:
      strcpy (ptr, "<?");
      break;
    case BINOP_MAX:
      strcpy (ptr, ">?");
      break;
    case BINOP_ASSIGN:
      strcpy (ptr, "=");
      break;
    case BINOP_ASSIGN_MODIFY:
      switch (otherop)
	{
	case BINOP_ADD:
	  strcpy (ptr, "+=");
	  break;
	case BINOP_SUB:
	  strcpy (ptr, "-=");
	  break;
	case BINOP_MUL:
	  strcpy (ptr, "*=");
	  break;
	case BINOP_DIV:
	  strcpy (ptr, "/=");
	  break;
	case BINOP_REM:
	  strcpy (ptr, "%=");
	  break;
	case BINOP_BITWISE_AND:
	  strcpy (ptr, "&=");
	  break;
	case BINOP_BITWISE_IOR:
	  strcpy (ptr, "|=");
	  break;
	case BINOP_BITWISE_XOR:
	  strcpy (ptr, "^=");
	  break;
	case BINOP_MOD:	/* invalid */
	default:
	  error (_("Invalid binary operation specified."));
	}
      break;
    case BINOP_SUBSCRIPT:
      strcpy (ptr, "[]");
      break;
    case BINOP_EQUAL:
      strcpy (ptr, "==");
      break;
    case BINOP_NOTEQUAL:
      strcpy (ptr, "!=");
      break;
    case BINOP_LESS:
      strcpy (ptr, "<");
      break;
    case BINOP_GTR:
      strcpy (ptr, ">");
      break;
    case BINOP_GEQ:
      strcpy (ptr, ">=");
      break;
    case BINOP_LEQ:
      strcpy (ptr, "<=");
      break;
    case BINOP_MOD:		/* invalid */
    default:
      error (_("Invalid binary operation specified."));
    }

  argvec[0] = value_user_defined_op (&arg1, argvec + 1, tstr,
                                     &static_memfuncp, 2);

  if (argvec[0])
    {
      if (static_memfuncp)
	{
	  argvec[1] = argvec[0];
	  argvec++;
	}
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	{
	  struct type *return_type;

	  return_type
	    = TYPE_TARGET_TYPE (check_typedef (value_type (argvec[0])));
	  return value_zero (return_type, VALUE_LVAL (arg1));
	}
      return call_function_by_hand (argvec[0], 2 - static_memfuncp,
				    argvec + 1);
    }
  throw_error (NOT_FOUND_ERROR,
               _("member function %s not found"), tstr);
#ifdef lint
  return call_function_by_hand (argvec[0], 2 - static_memfuncp, argvec + 1);
#endif
}

/* We know that arg1 is a structure, so try to find a unary user
   defined operator that matches the operator in question.
   Create an argument vector that calls arg1.operator @@ (arg1)
   and return that value (where '@@' is (almost) any unary operator which
   is legal for GNU C++).  */

struct value *
value_x_unop (struct value *arg1, enum exp_opcode op, enum noside noside)
{
  struct gdbarch *gdbarch = get_type_arch (value_type (arg1));
  struct value **argvec;
  char *ptr;
  char tstr[13], mangle_tstr[13];
  int static_memfuncp, nargs;

  arg1 = coerce_ref (arg1);

  /* now we know that what we have to do is construct our
     arg vector and find the right function to call it with.  */

  if (TYPE_CODE (check_typedef (value_type (arg1))) != TYPE_CODE_STRUCT)
    error (_("Can't do that unary op on that type"));	/* FIXME be explicit */

  argvec = (struct value **) alloca (sizeof (struct value *) * 4);
  argvec[1] = value_addr (arg1);
  argvec[2] = 0;

  nargs = 1;

  /* Make the right function name up.  */
  strcpy (tstr, "operator__");
  ptr = tstr + 8;
  strcpy (mangle_tstr, "__");
  switch (op)
    {
    case UNOP_PREINCREMENT:
      strcpy (ptr, "++");
      break;
    case UNOP_PREDECREMENT:
      strcpy (ptr, "--");
      break;
    case UNOP_POSTINCREMENT:
      strcpy (ptr, "++");
      argvec[2] = value_from_longest (builtin_type (gdbarch)->builtin_int, 0);
      argvec[3] = 0;
      nargs ++;
      break;
    case UNOP_POSTDECREMENT:
      strcpy (ptr, "--");
      argvec[2] = value_from_longest (builtin_type (gdbarch)->builtin_int, 0);
      argvec[3] = 0;
      nargs ++;
      break;
    case UNOP_LOGICAL_NOT:
      strcpy (ptr, "!");
      break;
    case UNOP_COMPLEMENT:
      strcpy (ptr, "~");
      break;
    case UNOP_NEG:
      strcpy (ptr, "-");
      break;
    case UNOP_PLUS:
      strcpy (ptr, "+");
      break;
    case UNOP_IND:
      strcpy (ptr, "*");
      break;
    case STRUCTOP_PTR:
      strcpy (ptr, "->");
      break;
    default:
      error (_("Invalid unary operation specified."));
    }

  argvec[0] = value_user_defined_op (&arg1, argvec + 1, tstr,
                                     &static_memfuncp, nargs);

  if (argvec[0])
    {
      if (static_memfuncp)
	{
	  argvec[1] = argvec[0];
	  nargs --;
	  argvec++;
	}
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	{
	  struct type *return_type;

	  return_type
	    = TYPE_TARGET_TYPE (check_typedef (value_type (argvec[0])));
	  return value_zero (return_type, VALUE_LVAL (arg1));
	}
      return call_function_by_hand (argvec[0], nargs, argvec + 1);
    }
  throw_error (NOT_FOUND_ERROR,
               _("member function %s not found"), tstr);

  return 0;			/* For lint -- never reached */
}


/* Concatenate two values with the following conditions:

   (1)  Both values must be either bitstring values or character string
   values and the resulting value consists of the concatenation of
   ARG1 followed by ARG2.

   or

   One value must be an integer value and the other value must be
   either a bitstring value or character string value, which is
   to be repeated by the number of times specified by the integer
   value.


   (2)  Boolean values are also allowed and are treated as bit string
   values of length 1.

   (3)  Character values are also allowed and are treated as character
   string values of length 1.  */

struct value *
value_concat (struct value *arg1, struct value *arg2)
{
  struct value *inval1;
  struct value *inval2;
  struct value *outval = NULL;
  int inval1len, inval2len;
  int count, idx;
  char *ptr;
  char inchar;
  struct type *type1 = check_typedef (value_type (arg1));
  struct type *type2 = check_typedef (value_type (arg2));
  struct type *char_type;

  /* First figure out if we are dealing with two values to be concatenated
     or a repeat count and a value to be repeated.  INVAL1 is set to the
     first of two concatenated values, or the repeat count.  INVAL2 is set
     to the second of the two concatenated values or the value to be 
     repeated.  */

  if (TYPE_CODE (type2) == TYPE_CODE_INT)
    {
      struct type *tmp = type1;

      type1 = tmp;
      tmp = type2;
      inval1 = arg2;
      inval2 = arg1;
    }
  else
    {
      inval1 = arg1;
      inval2 = arg2;
    }

  /* Now process the input values.  */

  if (TYPE_CODE (type1) == TYPE_CODE_INT)
    {
      /* We have a repeat count.  Validate the second value and then
         construct a value repeated that many times.  */
      if (TYPE_CODE (type2) == TYPE_CODE_STRING
	  || TYPE_CODE (type2) == TYPE_CODE_CHAR)
	{
	  struct cleanup *back_to;

	  count = longest_to_int (value_as_long (inval1));
	  inval2len = TYPE_LENGTH (type2);
	  ptr = (char *) xmalloc (count * inval2len);
	  back_to = make_cleanup (xfree, ptr);
	  if (TYPE_CODE (type2) == TYPE_CODE_CHAR)
	    {
	      char_type = type2;

	      inchar = (char) unpack_long (type2,
					   value_contents (inval2));
	      for (idx = 0; idx < count; idx++)
		{
		  *(ptr + idx) = inchar;
		}
	    }
	  else
	    {
	      char_type = TYPE_TARGET_TYPE (type2);

	      for (idx = 0; idx < count; idx++)
		{
		  memcpy (ptr + (idx * inval2len), value_contents (inval2),
			  inval2len);
		}
	    }
	  outval = value_string (ptr, count * inval2len, char_type);
	  do_cleanups (back_to);
	}
      else if (TYPE_CODE (type2) == TYPE_CODE_BOOL)
	{
	  error (_("unimplemented support for boolean repeats"));
	}
      else
	{
	  error (_("can't repeat values of that type"));
	}
    }
  else if (TYPE_CODE (type1) == TYPE_CODE_STRING
	   || TYPE_CODE (type1) == TYPE_CODE_CHAR)
    {
      struct cleanup *back_to;

      /* We have two character strings to concatenate.  */
      if (TYPE_CODE (type2) != TYPE_CODE_STRING
	  && TYPE_CODE (type2) != TYPE_CODE_CHAR)
	{
	  error (_("Strings can only be concatenated with other strings."));
	}
      inval1len = TYPE_LENGTH (type1);
      inval2len = TYPE_LENGTH (type2);
      ptr = (char *) xmalloc (inval1len + inval2len);
      back_to = make_cleanup (xfree, ptr);
      if (TYPE_CODE (type1) == TYPE_CODE_CHAR)
	{
	  char_type = type1;

	  *ptr = (char) unpack_long (type1, value_contents (inval1));
	}
      else
	{
	  char_type = TYPE_TARGET_TYPE (type1);

	  memcpy (ptr, value_contents (inval1), inval1len);
	}
      if (TYPE_CODE (type2) == TYPE_CODE_CHAR)
	{
	  *(ptr + inval1len) =
	    (char) unpack_long (type2, value_contents (inval2));
	}
      else
	{
	  memcpy (ptr + inval1len, value_contents (inval2), inval2len);
	}
      outval = value_string (ptr, inval1len + inval2len, char_type);
      do_cleanups (back_to);
    }
  else if (TYPE_CODE (type1) == TYPE_CODE_BOOL)
    {
      /* We have two bitstrings to concatenate.  */
      if (TYPE_CODE (type2) != TYPE_CODE_BOOL)
	{
	  error (_("Booleans can only be concatenated "
		   "with other bitstrings or booleans."));
	}
      error (_("unimplemented support for boolean concatenation."));
    }
  else
    {
      /* We don't know how to concatenate these operands.  */
      error (_("illegal operands for concatenation."));
    }
  return (outval);
}

/* Integer exponentiation: V1**V2, where both arguments are
   integers.  Requires V1 != 0 if V2 < 0.  Returns 1 for 0 ** 0.  */

static LONGEST
integer_pow (LONGEST v1, LONGEST v2)
{
  if (v2 < 0)
    {
      if (v1 == 0)
	error (_("Attempt to raise 0 to negative power."));
      else
	return 0;
    }
  else 
    {
      /* The Russian Peasant's Algorithm.  */
      LONGEST v;
      
      v = 1;
      for (;;)
	{
	  if (v2 & 1L) 
	    v *= v1;
	  v2 >>= 1;
	  if (v2 == 0)
	    return v;
	  v1 *= v1;
	}
    }
}

/* Integer exponentiation: V1**V2, where both arguments are
   integers.  Requires V1 != 0 if V2 < 0.  Returns 1 for 0 ** 0.  */

static ULONGEST
uinteger_pow (ULONGEST v1, LONGEST v2)
{
  if (v2 < 0)
    {
      if (v1 == 0)
	error (_("Attempt to raise 0 to negative power."));
      else
	return 0;
    }
  else 
    {
      /* The Russian Peasant's Algorithm.  */
      ULONGEST v;
      
      v = 1;
      for (;;)
	{
	  if (v2 & 1L) 
	    v *= v1;
	  v2 >>= 1;
	  if (v2 == 0)
	    return v;
	  v1 *= v1;
	}
    }
}

/* Obtain decimal value of arguments for binary operation, converting from
   other types if one of them is not decimal floating point.  */
static void
value_args_as_decimal (struct value *arg1, struct value *arg2,
		       gdb_byte *x, int *len_x, enum bfd_endian *byte_order_x,
		       gdb_byte *y, int *len_y, enum bfd_endian *byte_order_y)
{
  struct type *type1, *type2;

  type1 = check_typedef (value_type (arg1));
  type2 = check_typedef (value_type (arg2));

  /* At least one of the arguments must be of decimal float type.  */
  gdb_assert (TYPE_CODE (type1) == TYPE_CODE_DECFLOAT
	      || TYPE_CODE (type2) == TYPE_CODE_DECFLOAT);

  if (TYPE_CODE (type1) == TYPE_CODE_FLT
      || TYPE_CODE (type2) == TYPE_CODE_FLT)
    /* The DFP extension to the C language does not allow mixing of
     * decimal float types with other float types in expressions
     * (see WDTR 24732, page 12).  */
    error (_("Mixing decimal floating types with "
	     "other floating types is not allowed."));

  /* Obtain decimal value of arg1, converting from other types
     if necessary.  */

  if (TYPE_CODE (type1) == TYPE_CODE_DECFLOAT)
    {
      *byte_order_x = gdbarch_byte_order (get_type_arch (type1));
      *len_x = TYPE_LENGTH (type1);
      memcpy (x, value_contents (arg1), *len_x);
    }
  else if (is_integral_type (type1))
    {
      *byte_order_x = gdbarch_byte_order (get_type_arch (type2));
      *len_x = TYPE_LENGTH (type2);
      decimal_from_integral (arg1, x, *len_x, *byte_order_x);
    }
  else
    error (_("Don't know how to convert from %s to %s."), TYPE_NAME (type1),
	     TYPE_NAME (type2));

  /* Obtain decimal value of arg2, converting from other types
     if necessary.  */

  if (TYPE_CODE (type2) == TYPE_CODE_DECFLOAT)
    {
      *byte_order_y = gdbarch_byte_order (get_type_arch (type2));
      *len_y = TYPE_LENGTH (type2);
      memcpy (y, value_contents (arg2), *len_y);
    }
  else if (is_integral_type (type2))
    {
      *byte_order_y = gdbarch_byte_order (get_type_arch (type1));
      *len_y = TYPE_LENGTH (type1);
      decimal_from_integral (arg2, y, *len_y, *byte_order_y);
    }
  else
    error (_("Don't know how to convert from %s to %s."), TYPE_NAME (type1),
	     TYPE_NAME (type2));
}

/* Perform a binary operation on two operands which have reasonable
   representations as integers or floats.  This includes booleans,
   characters, integers, or floats.
   Does not support addition and subtraction on pointers;
   use value_ptradd, value_ptrsub or value_ptrdiff for those operations.  */

static struct value *
scalar_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)
{
  struct value *val;
  struct type *type1, *type2, *result_type;

  arg1 = coerce_ref (arg1);
  arg2 = coerce_ref (arg2);

  type1 = check_typedef (value_type (arg1));
  type2 = check_typedef (value_type (arg2));

  if ((TYPE_CODE (type1) != TYPE_CODE_FLT
       && TYPE_CODE (type1) != TYPE_CODE_DECFLOAT
       && !is_integral_type (type1))
      || (TYPE_CODE (type2) != TYPE_CODE_FLT
	  && TYPE_CODE (type2) != TYPE_CODE_DECFLOAT
	  && !is_integral_type (type2)))
    error (_("Argument to arithmetic operation not a number or boolean."));

  if (TYPE_CODE (type1) == TYPE_CODE_DECFLOAT
      || TYPE_CODE (type2) == TYPE_CODE_DECFLOAT)
    {
      int len_v1, len_v2, len_v;
      enum bfd_endian byte_order_v1, byte_order_v2, byte_order_v;
      gdb_byte v1[16], v2[16];
      gdb_byte v[16];

      /* If only one type is decimal float, use its type.
	 Otherwise use the bigger type.  */
      if (TYPE_CODE (type1) != TYPE_CODE_DECFLOAT)
	result_type = type2;
      else if (TYPE_CODE (type2) != TYPE_CODE_DECFLOAT)
	result_type = type1;
      else if (TYPE_LENGTH (type2) > TYPE_LENGTH (type1))
	result_type = type2;
      else
	result_type = type1;

      len_v = TYPE_LENGTH (result_type);
      byte_order_v = gdbarch_byte_order (get_type_arch (result_type));

      value_args_as_decimal (arg1, arg2, v1, &len_v1, &byte_order_v1,
					 v2, &len_v2, &byte_order_v2);

      switch (op)
	{
	case BINOP_ADD:
	case BINOP_SUB:
	case BINOP_MUL:
	case BINOP_DIV:
	case BINOP_EXP:
	  decimal_binop (op, v1, len_v1, byte_order_v1,
			     v2, len_v2, byte_order_v2,
			     v, len_v, byte_order_v);
	  break;

	default:
	  error (_("Operation not valid for decimal floating point number."));
	}

      val = value_from_decfloat (result_type, v);
    }
  else if (TYPE_CODE (type1) == TYPE_CODE_FLT
	   || TYPE_CODE (type2) == TYPE_CODE_FLT)
    {
      /* FIXME-if-picky-about-floating-accuracy: Should be doing this
         in target format.  real.c in GCC probably has the necessary
         code.  */
      DOUBLEST v1, v2, v = 0;

      v1 = value_as_double (arg1);
      v2 = value_as_double (arg2);

      switch (op)
	{
	case BINOP_ADD:
	  v = v1 + v2;
	  break;

	case BINOP_SUB:
	  v = v1 - v2;
	  break;

	case BINOP_MUL:
	  v = v1 * v2;
	  break;

	case BINOP_DIV:
	  v = v1 / v2;
	  break;

	case BINOP_EXP:
	  errno = 0;
	  v = pow (v1, v2);
	  if (errno)
	    error (_("Cannot perform exponentiation: %s"),
		   safe_strerror (errno));
	  break;

	case BINOP_MIN:
	  v = v1 < v2 ? v1 : v2;
	  break;
	      
	case BINOP_MAX:
	  v = v1 > v2 ? v1 : v2;
	  break;

	default:
	  error (_("Integer-only operation on floating point number."));
	}

      /* If only one type is float, use its type.
	 Otherwise use the bigger type.  */
      if (TYPE_CODE (type1) != TYPE_CODE_FLT)
	result_type = type2;
      else if (TYPE_CODE (type2) != TYPE_CODE_FLT)
	result_type = type1;
      else if (TYPE_LENGTH (type2) > TYPE_LENGTH (type1))
	result_type = type2;
      else
	result_type = type1;

      val = allocate_value (result_type);
      store_typed_floating (value_contents_raw (val), value_type (val), v);
    }
  else if (TYPE_CODE (type1) == TYPE_CODE_BOOL
	   || TYPE_CODE (type2) == TYPE_CODE_BOOL)
    {
      LONGEST v1, v2, v = 0;

      v1 = value_as_long (arg1);
      v2 = value_as_long (arg2);

      switch (op)
	{
	case BINOP_BITWISE_AND:
	  v = v1 & v2;
	  break;

	case BINOP_BITWISE_IOR:
	  v = v1 | v2;
	  break;

	case BINOP_BITWISE_XOR:
	  v = v1 ^ v2;
          break;
              
        case BINOP_EQUAL:
          v = v1 == v2;
          break;
          
        case BINOP_NOTEQUAL:
          v = v1 != v2;
	  break;

	default:
	  error (_("Invalid operation on booleans."));
	}

      result_type = type1;

      val = allocate_value (result_type);
      store_signed_integer (value_contents_raw (val),
			    TYPE_LENGTH (result_type),
			    gdbarch_byte_order (get_type_arch (result_type)),
			    v);
    }
  else
    /* Integral operations here.  */
    {
      /* Determine type length of the result, and if the operation should
	 be done unsigned.  For exponentiation and shift operators,
	 use the length and type of the left operand.  Otherwise,
	 use the signedness of the operand with the greater length.
	 If both operands are of equal length, use unsigned operation
	 if one of the operands is unsigned.  */
      if (op == BINOP_RSH || op == BINOP_LSH || op == BINOP_EXP)
	result_type = type1;
      else if (TYPE_LENGTH (type1) > TYPE_LENGTH (type2))
	result_type = type1;
      else if (TYPE_LENGTH (type2) > TYPE_LENGTH (type1))
	result_type = type2;
      else if (TYPE_UNSIGNED (type1))
	result_type = type1;
      else if (TYPE_UNSIGNED (type2))
	result_type = type2;
      else
	result_type = type1;

      if (TYPE_UNSIGNED (result_type))
	{
	  LONGEST v2_signed = value_as_long (arg2);
	  ULONGEST v1, v2, v = 0;

	  v1 = (ULONGEST) value_as_long (arg1);
	  v2 = (ULONGEST) v2_signed;

	  switch (op)
	    {
	    case BINOP_ADD:
	      v = v1 + v2;
	      break;

	    case BINOP_SUB:
	      v = v1 - v2;
	      break;

	    case BINOP_MUL:
	      v = v1 * v2;
	      break;

	    case BINOP_DIV:
	    case BINOP_INTDIV:
	      if (v2 != 0)
		v = v1 / v2;
	      else
		error (_("Division by zero"));
	      break;

	    case BINOP_EXP:
              v = uinteger_pow (v1, v2_signed);
	      break;

	    case BINOP_REM:
	      if (v2 != 0)
		v = v1 % v2;
	      else
		error (_("Division by zero"));
	      break;

	    case BINOP_MOD:
	      /* Knuth 1.2.4, integer only.  Note that unlike the C '%' op,
	         v1 mod 0 has a defined value, v1.  */
	      if (v2 == 0)
		{
		  v = v1;
		}
	      else
		{
		  v = v1 / v2;
		  /* Note floor(v1/v2) == v1/v2 for unsigned.  */
		  v = v1 - (v2 * v);
		}
	      break;

	    case BINOP_LSH:
	      v = v1 << v2;
	      break;

	    case BINOP_RSH:
	      v = v1 >> v2;
	      break;

	    case BINOP_BITWISE_AND:
	      v = v1 & v2;
	      break;

	    case BINOP_BITWISE_IOR:
	      v = v1 | v2;
	      break;

	    case BINOP_BITWISE_XOR:
	      v = v1 ^ v2;
	      break;

	    case BINOP_LOGICAL_AND:
	      v = v1 && v2;
	      break;

	    case BINOP_LOGICAL_OR:
	      v = v1 || v2;
	      break;

	    case BINOP_MIN:
	      v = v1 < v2 ? v1 : v2;
	      break;

	    case BINOP_MAX:
	      v = v1 > v2 ? v1 : v2;
	      break;

	    case BINOP_EQUAL:
	      v = v1 == v2;
	      break;

            case BINOP_NOTEQUAL:
              v = v1 != v2;
              break;

	    case BINOP_LESS:
	      v = v1 < v2;
	      break;

	    case BINOP_GTR:
	      v = v1 > v2;
	      break;

	    case BINOP_LEQ:
	      v = v1 <= v2;
	      break;

	    case BINOP_GEQ:
	      v = v1 >= v2;
	      break;

	    default:
	      error (_("Invalid binary operation on numbers."));
	    }

	  val = allocate_value (result_type);
	  store_unsigned_integer (value_contents_raw (val),
				  TYPE_LENGTH (value_type (val)),
				  gdbarch_byte_order
				    (get_type_arch (result_type)),
				  v);
	}
      else
	{
	  LONGEST v1, v2, v = 0;

	  v1 = value_as_long (arg1);
	  v2 = value_as_long (arg2);

	  switch (op)
	    {
	    case BINOP_ADD:
	      v = v1 + v2;
	      break;

	    case BINOP_SUB:
	      v = v1 - v2;
	      break;

	    case BINOP_MUL:
	      v = v1 * v2;
	      break;

	    case BINOP_DIV:
	    case BINOP_INTDIV:
	      if (v2 != 0)
		v = v1 / v2;
	      else
		error (_("Division by zero"));
              break;

	    case BINOP_EXP:
              v = integer_pow (v1, v2);
	      break;

	    case BINOP_REM:
	      if (v2 != 0)
		v = v1 % v2;
	      else
		error (_("Division by zero"));
	      break;

	    case BINOP_MOD:
	      /* Knuth 1.2.4, integer only.  Note that unlike the C '%' op,
	         X mod 0 has a defined value, X.  */
	      if (v2 == 0)
		{
		  v = v1;
		}
	      else
		{
		  v = v1 / v2;
		  /* Compute floor.  */
		  if (TRUNCATION_TOWARDS_ZERO && (v < 0) && ((v1 % v2) != 0))
		    {
		      v--;
		    }
		  v = v1 - (v2 * v);
		}
	      break;

	    case BINOP_LSH:
	      v = v1 << v2;
	      break;

	    case BINOP_RSH:
	      v = v1 >> v2;
	      break;

	    case BINOP_BITWISE_AND:
	      v = v1 & v2;
	      break;

	    case BINOP_BITWISE_IOR:
	      v = v1 | v2;
	      break;

	    case BINOP_BITWISE_XOR:
	      v = v1 ^ v2;
	      break;

	    case BINOP_LOGICAL_AND:
	      v = v1 && v2;
	      break;

	    case BINOP_LOGICAL_OR:
	      v = v1 || v2;
	      break;

	    case BINOP_MIN:
	      v = v1 < v2 ? v1 : v2;
	      break;

	    case BINOP_MAX:
	      v = v1 > v2 ? v1 : v2;
	      break;

	    case BINOP_EQUAL:
	      v = v1 == v2;
	      break;

            case BINOP_NOTEQUAL:
              v = v1 != v2;
              break;

	    case BINOP_LESS:
	      v = v1 < v2;
	      break;

	    case BINOP_GTR:
	      v = v1 > v2;
	      break;

	    case BINOP_LEQ:
	      v = v1 <= v2;
	      break;

	    case BINOP_GEQ:
	      v = v1 >= v2;
	      break;

	    default:
	      error (_("Invalid binary operation on numbers."));
	    }

	  val = allocate_value (result_type);
	  store_signed_integer (value_contents_raw (val),
				TYPE_LENGTH (value_type (val)),
				gdbarch_byte_order
				  (get_type_arch (result_type)),
				v);
	}
    }

  return val;
}

/* Widen a scalar value SCALAR_VALUE to vector type VECTOR_TYPE by
   replicating SCALAR_VALUE for each element of the vector.  Only scalar
   types that can be cast to the type of one element of the vector are
   acceptable.  The newly created vector value is returned upon success,
   otherwise an error is thrown.  */

struct value *
value_vector_widen (struct value *scalar_value, struct type *vector_type)
{
  /* Widen the scalar to a vector.  */
  struct type *eltype, *scalar_type;
  struct value *val, *elval;
  LONGEST low_bound, high_bound;
  int i;

  CHECK_TYPEDEF (vector_type);

  gdb_assert (TYPE_CODE (vector_type) == TYPE_CODE_ARRAY
	      && TYPE_VECTOR (vector_type));

  if (!get_array_bounds (vector_type, &low_bound, &high_bound))
    error (_("Could not determine the vector bounds"));

  eltype = check_typedef (TYPE_TARGET_TYPE (vector_type));
  elval = value_cast (eltype, scalar_value);

  scalar_type = check_typedef (value_type (scalar_value));

  /* If we reduced the length of the scalar then check we didn't loose any
     important bits.  */
  if (TYPE_LENGTH (eltype) < TYPE_LENGTH (scalar_type)
      && !value_equal (elval, scalar_value))
    error (_("conversion of scalar to vector involves truncation"));

  val = allocate_value (vector_type);
  for (i = 0; i < high_bound - low_bound + 1; i++)
    /* Duplicate the contents of elval into the destination vector.  */
    memcpy (value_contents_writeable (val) + (i * TYPE_LENGTH (eltype)),
	    value_contents_all (elval), TYPE_LENGTH (eltype));

  return val;
}

/* Performs a binary operation on two vector operands by calling scalar_binop
   for each pair of vector components.  */

static struct value *
vector_binop (struct value *val1, struct value *val2, enum exp_opcode op)
{
  struct value *val, *tmp, *mark;
  struct type *type1, *type2, *eltype1, *eltype2;
  int t1_is_vec, t2_is_vec, elsize, i;
  LONGEST low_bound1, high_bound1, low_bound2, high_bound2;

  type1 = check_typedef (value_type (val1));
  type2 = check_typedef (value_type (val2));

  t1_is_vec = (TYPE_CODE (type1) == TYPE_CODE_ARRAY
	       && TYPE_VECTOR (type1)) ? 1 : 0;
  t2_is_vec = (TYPE_CODE (type2) == TYPE_CODE_ARRAY
	       && TYPE_VECTOR (type2)) ? 1 : 0;

  if (!t1_is_vec || !t2_is_vec)
    error (_("Vector operations are only supported among vectors"));

  if (!get_array_bounds (type1, &low_bound1, &high_bound1)
      || !get_array_bounds (type2, &low_bound2, &high_bound2))
    error (_("Could not determine the vector bounds"));

  eltype1 = check_typedef (TYPE_TARGET_TYPE (type1));
  eltype2 = check_typedef (TYPE_TARGET_TYPE (type2));
  elsize = TYPE_LENGTH (eltype1);

  if (TYPE_CODE (eltype1) != TYPE_CODE (eltype2)
      || elsize != TYPE_LENGTH (eltype2)
      || TYPE_UNSIGNED (eltype1) != TYPE_UNSIGNED (eltype2)
      || low_bound1 != low_bound2 || high_bound1 != high_bound2)
    error (_("Cannot perform operation on vectors with different types"));

  val = allocate_value (type1);
  mark = value_mark ();
  for (i = 0; i < high_bound1 - low_bound1 + 1; i++)
    {
      tmp = value_binop (value_subscript (val1, i),
			 value_subscript (val2, i), op);
      memcpy (value_contents_writeable (val) + i * elsize,
	      value_contents_all (tmp),
	      elsize);
     }
  value_free_to_mark (mark);

  return val;
}

/* Perform a binary operation on two operands.  */

struct value *
value_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)
{
  struct value *val;
  struct type *type1 = check_typedef (value_type (arg1));
  struct type *type2 = check_typedef (value_type (arg2));
  int t1_is_vec = (TYPE_CODE (type1) == TYPE_CODE_ARRAY
		   && TYPE_VECTOR (type1));
  int t2_is_vec = (TYPE_CODE (type2) == TYPE_CODE_ARRAY
		   && TYPE_VECTOR (type2));

  if (!t1_is_vec && !t2_is_vec)
    val = scalar_binop (arg1, arg2, op);
  else if (t1_is_vec && t2_is_vec)
    val = vector_binop (arg1, arg2, op);
  else
    {
      /* Widen the scalar operand to a vector.  */
      struct value **v = t1_is_vec ? &arg2 : &arg1;
      struct type *t = t1_is_vec ? type2 : type1;
      
      if (TYPE_CODE (t) != TYPE_CODE_FLT
	  && TYPE_CODE (t) != TYPE_CODE_DECFLOAT
	  && !is_integral_type (t))
	error (_("Argument to operation not a number or boolean."));

      /* Replicate the scalar value to make a vector value.  */
      *v = value_vector_widen (*v, t1_is_vec ? type1 : type2);

      val = vector_binop (arg1, arg2, op);
    }

  return val;
}

/* Simulate the C operator ! -- return 1 if ARG1 contains zero.  */

int
value_logical_not (struct value *arg1)
{
  int len;
  const gdb_byte *p;
  struct type *type1;

  arg1 = coerce_array (arg1);
  type1 = check_typedef (value_type (arg1));

  if (TYPE_CODE (type1) == TYPE_CODE_FLT)
    return 0 == value_as_double (arg1);
  else if (TYPE_CODE (type1) == TYPE_CODE_DECFLOAT)
    return decimal_is_zero (value_contents (arg1), TYPE_LENGTH (type1),
			    gdbarch_byte_order (get_type_arch (type1)));

  len = TYPE_LENGTH (type1);
  p = value_contents (arg1);

  while (--len >= 0)
    {
      if (*p++)
	break;
    }

  return len < 0;
}

/* Perform a comparison on two string values (whose content are not
   necessarily null terminated) based on their length.  */

static int
value_strcmp (struct value *arg1, struct value *arg2)
{
  int len1 = TYPE_LENGTH (value_type (arg1));
  int len2 = TYPE_LENGTH (value_type (arg2));
  const gdb_byte *s1 = value_contents (arg1);
  const gdb_byte *s2 = value_contents (arg2);
  int i, len = len1 < len2 ? len1 : len2;

  for (i = 0; i < len; i++)
    {
      if (s1[i] < s2[i])
        return -1;
      else if (s1[i] > s2[i])
        return 1;
      else
        continue;
    }

  if (len1 < len2)
    return -1;
  else if (len1 > len2)
    return 1;
  else
    return 0;
}

/* Simulate the C operator == by returning a 1
   iff ARG1 and ARG2 have equal contents.  */

int
value_equal (struct value *arg1, struct value *arg2)
{
  int len;
  const gdb_byte *p1;
  const gdb_byte *p2;
  struct type *type1, *type2;
  enum type_code code1;
  enum type_code code2;
  int is_int1, is_int2;

  arg1 = coerce_array (arg1);
  arg2 = coerce_array (arg2);

  type1 = check_typedef (value_type (arg1));
  type2 = check_typedef (value_type (arg2));
  code1 = TYPE_CODE (type1);
  code2 = TYPE_CODE (type2);
  is_int1 = is_integral_type (type1);
  is_int2 = is_integral_type (type2);

  if (is_int1 && is_int2)
    return longest_to_int (value_as_long (value_binop (arg1, arg2,
						       BINOP_EQUAL)));
  else if ((code1 == TYPE_CODE_FLT || is_int1)
	   && (code2 == TYPE_CODE_FLT || is_int2))
    {
      /* NOTE: kettenis/20050816: Avoid compiler bug on systems where
	 `long double' values are returned in static storage (m68k).  */
      DOUBLEST d = value_as_double (arg1);

      return d == value_as_double (arg2);
    }
  else if ((code1 == TYPE_CODE_DECFLOAT || is_int1)
	   && (code2 == TYPE_CODE_DECFLOAT || is_int2))
    {
      gdb_byte v1[16], v2[16];
      int len_v1, len_v2;
      enum bfd_endian byte_order_v1, byte_order_v2;

      value_args_as_decimal (arg1, arg2, v1, &len_v1, &byte_order_v1,
					 v2, &len_v2, &byte_order_v2);

      return decimal_compare (v1, len_v1, byte_order_v1,
			      v2, len_v2, byte_order_v2) == 0;
    }

  /* FIXME: Need to promote to either CORE_ADDR or LONGEST, whichever
     is bigger.  */
  else if (code1 == TYPE_CODE_PTR && is_int2)
    return value_as_address (arg1) == (CORE_ADDR) value_as_long (arg2);
  else if (code2 == TYPE_CODE_PTR && is_int1)
    return (CORE_ADDR) value_as_long (arg1) == value_as_address (arg2);

  else if (code1 == code2
	   && ((len = (int) TYPE_LENGTH (type1))
	       == (int) TYPE_LENGTH (type2)))
    {
      p1 = value_contents (arg1);
      p2 = value_contents (arg2);
      while (--len >= 0)
	{
	  if (*p1++ != *p2++)
	    break;
	}
      return len < 0;
    }
  else if (code1 == TYPE_CODE_STRING && code2 == TYPE_CODE_STRING)
    {
      return value_strcmp (arg1, arg2) == 0;
    }
  else
    {
      error (_("Invalid type combination in equality test."));
      return 0;			/* For lint -- never reached.  */
    }
}

/* Compare values based on their raw contents.  Useful for arrays since
   value_equal coerces them to pointers, thus comparing just the address
   of the array instead of its contents.  */

int
value_equal_contents (struct value *arg1, struct value *arg2)
{
  struct type *type1, *type2;

  type1 = check_typedef (value_type (arg1));
  type2 = check_typedef (value_type (arg2));

  return (TYPE_CODE (type1) == TYPE_CODE (type2)
	  && TYPE_LENGTH (type1) == TYPE_LENGTH (type2)
	  && memcmp (value_contents (arg1), value_contents (arg2),
		     TYPE_LENGTH (type1)) == 0);
}

/* Simulate the C operator < by returning 1
   iff ARG1's contents are less than ARG2's.  */

int
value_less (struct value *arg1, struct value *arg2)
{
  enum type_code code1;
  enum type_code code2;
  struct type *type1, *type2;
  int is_int1, is_int2;

  arg1 = coerce_array (arg1);
  arg2 = coerce_array (arg2);

  type1 = check_typedef (value_type (arg1));
  type2 = check_typedef (value_type (arg2));
  code1 = TYPE_CODE (type1);
  code2 = TYPE_CODE (type2);
  is_int1 = is_integral_type (type1);
  is_int2 = is_integral_type (type2);

  if (is_int1 && is_int2)
    return longest_to_int (value_as_long (value_binop (arg1, arg2,
						       BINOP_LESS)));
  else if ((code1 == TYPE_CODE_FLT || is_int1)
	   && (code2 == TYPE_CODE_FLT || is_int2))
    {
      /* NOTE: kettenis/20050816: Avoid compiler bug on systems where
	 `long double' values are returned in static storage (m68k).  */
      DOUBLEST d = value_as_double (arg1);

      return d < value_as_double (arg2);
    }
  else if ((code1 == TYPE_CODE_DECFLOAT || is_int1)
	   && (code2 == TYPE_CODE_DECFLOAT || is_int2))
    {
      gdb_byte v1[16], v2[16];
      int len_v1, len_v2;
      enum bfd_endian byte_order_v1, byte_order_v2;

      value_args_as_decimal (arg1, arg2, v1, &len_v1, &byte_order_v1,
					 v2, &len_v2, &byte_order_v2);

      return decimal_compare (v1, len_v1, byte_order_v1,
			      v2, len_v2, byte_order_v2) == -1;
    }
  else if (code1 == TYPE_CODE_PTR && code2 == TYPE_CODE_PTR)
    return value_as_address (arg1) < value_as_address (arg2);

  /* FIXME: Need to promote to either CORE_ADDR or LONGEST, whichever
     is bigger.  */
  else if (code1 == TYPE_CODE_PTR && is_int2)
    return value_as_address (arg1) < (CORE_ADDR) value_as_long (arg2);
  else if (code2 == TYPE_CODE_PTR && is_int1)
    return (CORE_ADDR) value_as_long (arg1) < value_as_address (arg2);
  else if (code1 == TYPE_CODE_STRING && code2 == TYPE_CODE_STRING)
    return value_strcmp (arg1, arg2) < 0;
  else
    {
      error (_("Invalid type combination in ordering comparison."));
      return 0;
    }
}

/* The unary operators +, - and ~.  They free the argument ARG1.  */

struct value *
value_pos (struct value *arg1)
{
  struct type *type;

  arg1 = coerce_ref (arg1);
  type = check_typedef (value_type (arg1));

  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    return value_from_double (type, value_as_double (arg1));
  else if (TYPE_CODE (type) == TYPE_CODE_DECFLOAT)
    return value_from_decfloat (type, value_contents (arg1));
  else if (is_integral_type (type))
    {
      return value_from_longest (type, value_as_long (arg1));
    }
  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type))
    {
      struct value *val = allocate_value (type);

      memcpy (value_contents_raw (val), value_contents (arg1),
              TYPE_LENGTH (type));
      return val;
    }
  else
    {
      error (_("Argument to positive operation not a number."));
      return 0;			/* For lint -- never reached.  */
    }
}

struct value *
value_neg (struct value *arg1)
{
  struct type *type;

  arg1 = coerce_ref (arg1);
  type = check_typedef (value_type (arg1));

  if (TYPE_CODE (type) == TYPE_CODE_DECFLOAT)
    {
      struct value *val = allocate_value (type);
      int len = TYPE_LENGTH (type);
      gdb_byte decbytes[16];  /* a decfloat is at most 128 bits long.  */

      memcpy (decbytes, value_contents (arg1), len);

      if (gdbarch_byte_order (get_type_arch (type)) == BFD_ENDIAN_LITTLE)
	decbytes[len-1] = decbytes[len - 1] | 0x80;
      else
	decbytes[0] = decbytes[0] | 0x80;

      memcpy (value_contents_raw (val), decbytes, len);
      return val;
    }
  else if (TYPE_CODE (type) == TYPE_CODE_FLT)
    return value_from_double (type, -value_as_double (arg1));
  else if (is_integral_type (type))
    {
      return value_from_longest (type, -value_as_long (arg1));
    }
  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type))
    {
      struct value *tmp, *val = allocate_value (type);
      struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type));
      int i;
      LONGEST low_bound, high_bound;

      if (!get_array_bounds (type, &low_bound, &high_bound))
	error (_("Could not determine the vector bounds"));

      for (i = 0; i < high_bound - low_bound + 1; i++)
	{
	  tmp = value_neg (value_subscript (arg1, i));
	  memcpy (value_contents_writeable (val) + i * TYPE_LENGTH (eltype),
		  value_contents_all (tmp), TYPE_LENGTH (eltype));
	}
      return val;
    }
  else
    {
      error (_("Argument to negate operation not a number."));
      return 0;			/* For lint -- never reached.  */
    }
}

struct value *
value_complement (struct value *arg1)
{
  struct type *type;
  struct value *val;

  arg1 = coerce_ref (arg1);
  type = check_typedef (value_type (arg1));

  if (is_integral_type (type))
    val = value_from_longest (type, ~value_as_long (arg1));
  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY && TYPE_VECTOR (type))
    {
      struct value *tmp;
      struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type));
      int i;
      LONGEST low_bound, high_bound;

      if (!get_array_bounds (type, &low_bound, &high_bound))
	error (_("Could not determine the vector bounds"));

      val = allocate_value (type);
      for (i = 0; i < high_bound - low_bound + 1; i++)
        {
          tmp = value_complement (value_subscript (arg1, i));
          memcpy (value_contents_writeable (val) + i * TYPE_LENGTH (eltype),
                  value_contents_all (tmp), TYPE_LENGTH (eltype));
        }
    }
  else
    error (_("Argument to complement operation not an integer, boolean."));

  return val;
}

/* The INDEX'th bit of SET value whose value_type is TYPE,
   and whose value_contents is valaddr.
   Return -1 if out of range, -2 other error.  */

int
value_bit_index (struct type *type, const gdb_byte *valaddr, int index)
{
  struct gdbarch *gdbarch = get_type_arch (type);
  LONGEST low_bound, high_bound;
  LONGEST word;
  unsigned rel_index;
  struct type *range = TYPE_INDEX_TYPE (type);

  if (get_discrete_bounds (range, &low_bound, &high_bound) < 0)
    return -2;
  if (index < low_bound || index > high_bound)
    return -1;
  rel_index = index - low_bound;
  word = extract_unsigned_integer (valaddr + (rel_index / TARGET_CHAR_BIT), 1,
				   gdbarch_byte_order (gdbarch));
  rel_index %= TARGET_CHAR_BIT;
  if (gdbarch_bits_big_endian (gdbarch))
    rel_index = TARGET_CHAR_BIT - 1 - rel_index;
  return (word >> rel_index) & 1;
}

int
value_in (struct value *element, struct value *set)
{
  int member;
  struct type *settype = check_typedef (value_type (set));
  struct type *eltype = check_typedef (value_type (element));

  if (TYPE_CODE (eltype) == TYPE_CODE_RANGE)
    eltype = TYPE_TARGET_TYPE (eltype);
  if (TYPE_CODE (settype) != TYPE_CODE_SET)
    error (_("Second argument of 'IN' has wrong type"));
  if (TYPE_CODE (eltype) != TYPE_CODE_INT
      && TYPE_CODE (eltype) != TYPE_CODE_CHAR
      && TYPE_CODE (eltype) != TYPE_CODE_ENUM
      && TYPE_CODE (eltype) != TYPE_CODE_BOOL)
    error (_("First argument of 'IN' has wrong type"));
  member = value_bit_index (settype, value_contents (set),
			    value_as_long (element));
  if (member < 0)
    error (_("First argument of 'IN' not in range"));
  return member;
}

void
_initialize_valarith (void)
{
}
@


1.109
log
@	* valops.c (find_overload_match): Remove unused argument 'lax'.
	* value.h: Remove unused argument 'lax' from the declaration of
	find_overload_match.
	* eval.c (value_subexp_standard): Do not pass a 'lax' argument
	to find_overload_match.
	* valarith.c (value_user_defined_cpp_op): Do not pass a 'lax'
	argument to find_overload_match.
@
text
@d513 1
a513 1
  char *ptr, *mangle_ptr;
a534 1
  mangle_ptr = mangle_tstr + 2;
@


1.108
log
@http://sourceware.org/ml/gdb-patches/2012-11/msg00312.html

gdb/ChangeLog
        * valarith.c (value_vector_widen): New function for replicating a
        scalar into a vector.
        (value_binop): Use value_vector_widen to widen scalar to vector
        rather than casting, this better matches gcc C behaviour.
        * valops.c (value_casst): Update logic for casting between vector
        types, and for casting from scalar to vector, try to match gcc C
        behaviour.
        * value.h (value_vector_widen): Declare.
        * opencl-lang.c (opencl_value_cast): New opencl specific casting
        function, handle special case for casting scalar to vector.
        (opencl_relop): Use opencl_value_cast.
        (evaluate_subexp_opencl): Use opencl_value_cast instead of
        value_cast, and handle BINOP_ASSIGN, UNOP_CAST, and UNOP_CAST_TYPE
        in order to use opencl_value_cast.

gdb/testsuite/ChangeLog
        * gdb.base/gnu_vector.c: New variable for use in tests.
        * gdb.base/gnu_vector.exp: Update and extend tests to reflect
        changes in scalar to vector casting and widening.
        * gdb.python/py-type.c: New variables for use in tests.
        * gdb.python/py-type.exp: Update vector related tests to reflect
        changes in scalar to vector casting and widening.
@
text
@d297 1
a297 1
                       0 /* strict match */, &args[0], /* objp */
@


1.107
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d1349 43
d1471 3
a1473 1
      *v = value_cast (t1_is_vec ? type1 : type2, *v);
@


1.106
log
@	* valarith.c (value_concat): Replace unsafe ALLOCA with
	XMALLOC/XFREE.
@
text
@d3 1
a3 2
   Copyright (C) 1986, 1988-2005, 2007-2012 Free Software Foundation,
   Inc.
@


1.105
log
@gdb/
	* gdbtypes.h (enum type_code): Define TYPE_CODE_BITSTRING -1.
	* arm-tdep.c (arm_type_align): Remove code handling TYPE_CODE_BITSTRING.
	* c-typeprint.c (c_type_print_varspec_prefix): Likewise.
	(c_type_print_varspec_suffix): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* f-typeprint.c (f_type_print_varspec_prefix): Likewise.
	(f_type_print_varspec_suffix): Likewise.
	* gdbtypes.c (is_scalar_type): Likewise.
	(recursive_dump_type): Likewise.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix): Likewise.
	(pascal_type_print_varspec_suffix): Likewise.
	(pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_val_print): Likewise.
	* valops.c (value_slice): Likewise.
	* valprint.c (scalar_type_p): Likewise.
	* valarith.c (value_bitstring_subscript): Remove.
	(value_concat): Remove code handling TYPE_CODE_BITSTRING.
	Remove comment on TYPE_CODE_BITSTRING.

	* stabsread.c (read_type): Don't set TYPE_CODE (type) to
	TYPE_CODE_BITSTRING.

	* python/py-type.c (pyty_codes): Move ENTRY (TYPE_CODE_BITSTRING) to
	slot 0.

gdb/doc:
	* gdb.texinfo (Types In Python): Mention gdb.TYPE_CODE_BITSTRING
	is deprecated.
@
text
@d671 2
d675 2
a676 1
	  ptr = (char *) alloca (count * inval2len);
d699 1
d713 2
d723 2
a724 1
      ptr = (char *) alloca (inval1len + inval2len);
d747 1
@


1.104
log
@2012-06-09  Siva Chandra Reddy  <sivachandra@@google.com>

	* valarith.c (binop_types_user_defined_p): Fix a typo.
@
text
@a141 1
   To access TYPE_CODE_BITSTRING values, use value_bitstring_subscript.
a222 40
/* Return the value of BITSTRING[IDX] as (boolean) type TYPE.  */

struct value *
value_bitstring_subscript (struct type *type,
			   struct value *bitstring, LONGEST index)
{

  struct type *bitstring_type, *range_type;
  struct value *v;
  int offset, byte, bit_index;
  LONGEST lowerbound, upperbound;

  bitstring_type = check_typedef (value_type (bitstring));
  gdb_assert (TYPE_CODE (bitstring_type) == TYPE_CODE_BITSTRING);

  range_type = TYPE_INDEX_TYPE (bitstring_type);
  get_discrete_bounds (range_type, &lowerbound, &upperbound);
  if (index < lowerbound || index > upperbound)
    error (_("bitstring index out of range"));

  index -= lowerbound;
  offset = index / TARGET_CHAR_BIT;
  byte = *((char *) value_contents (bitstring) + offset);

  bit_index = index % TARGET_CHAR_BIT;
  byte >>= (gdbarch_bits_big_endian (get_type_arch (bitstring_type)) ?
	    TARGET_CHAR_BIT - 1 - bit_index : bit_index);

  v = value_from_longest (type, byte & 1);

  set_value_bitpos (v, bit_index);
  set_value_bitsize (v, 1);
  set_value_component_location (v, bitstring);
  VALUE_FRAME_ID (v) = VALUE_FRAME_ID (bitstring);

  set_value_offset (v, offset + value_offset (bitstring));

  return v;
}

d697 1
a697 2
      else if (TYPE_CODE (type2) == TYPE_CODE_BITSTRING
	       || TYPE_CODE (type2) == TYPE_CODE_BOOL)
d699 1
a699 1
	  error (_("unimplemented support for bitstring/boolean repeats"));
d741 1
a741 2
  else if (TYPE_CODE (type1) == TYPE_CODE_BITSTRING
	   || TYPE_CODE (type1) == TYPE_CODE_BOOL)
d744 1
a744 2
      if (TYPE_CODE (type2) != TYPE_CODE_BITSTRING
	  && TYPE_CODE (type2) != TYPE_CODE_BOOL)
d746 1
a746 1
	  error (_("Bitstrings or booleans can only be concatenated "
d749 1
a749 1
      error (_("unimplemented support for bitstring/boolean concatenation."));
@


1.103
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d282 1
a282 1
  type2 = check_typedef (type1);
@


1.102
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@d1393 1
a1393 1
  struct type *type1, *type2, *eltype1, *eltype2, *result_type;
@


1.101
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d67 1
a67 1
	  char *name;
@


1.100
log
@	PR c++/13225
	* eval.c (evaluate_subexp_standard): Do not construct
	an array of types; pass the value array directly to
	find_overload_match.
	* gdbtypes.h (NULL_POINTER_CONVERSION_BADNESS): Declare.
	(rank_function): Take an array of values instead of types.
	(rank_one_type): Add struct value * parameter.
	* gdbtypes.c (NULL_POINTER_CONVERSION_BADNESS): Define.
	(rank_function): For each argument, pass the argument's
	value to rank_one_type.
	(rank_one_type): Add VALUE parameter.
	If the parameter type is a pointer and the argument type
	is an integer, return NULL_POINTER_CONVERSION_BADNESS if
	VALUE is zero.
	Update all calls to rank_one_type, passing NULL for new
	VALUE parameter.
	* valarith.c (value_user_defined_cpp_op): Do not construct
	an array of types; pass the value array directly to
	find_overload_match.
	* valops.c (find_overload_method_list): Take an array of
	values instead of types.
	Save the type of OBJP for later use.
	Update calls to find_oload_champ, and find_oload_champ_namespace.
	(find_oload_champ_namespace): Take an array of values instead
	of types.
	(find_oload_champ_namespace_loop): Likewise.
	(find_oload_champ): Likewise.
	(classify_oload_match): Inspect all arguments
	until INCOMPATIBLE is found. Return the worst badness found
	otherwise.
	(compare_parameters): Update call to rank_one_type.
	* value.h (find_overload_match): Take an array of values instead
	of types.
@
text
@d3 2
a4 3
   Copyright (C) 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009,
   2010, 2011 Free Software Foundation, Inc.
@


1.100.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 2
   Copyright (C) 1986, 1988-2005, 2007-2012 Free Software Foundation,
   Inc.
@


1.99
log
@gdb/
	* cp-support.c (make_symbol_overload_list_namespace): Do not call
	make_symbol_overload_list_block with NULL BLOCK.
	* valarith.c (unop_user_defined_p): Resolve also TYPE_CODE_TYPEDEF.

gdb/testsuite/
	* gdb.cp/typedef-operator.exp: New file.
	* gdb.cp/typedef-operator.cc: New file.
@
text
@a337 2
  struct type **arg_types;
  int i;
d339 1
a339 6
  arg_types = (struct type **) alloca (nargs * (sizeof (struct type *)));
  /* Prepare list of argument types for overload resolution.  */
  for (i = 0; i < nargs; i++)
    arg_types[i] = value_type (args[i]);

  find_overload_match (arg_types, nargs, operator, BOTH /* could be method */,
@


1.98
log
@	gdb/
	* value.h (value_contents_copy, value_contents_copy_raw): Declare.
	* value.c (value_contents_copy_raw, value_contents_copy): New
	functions.
	(value_primitive_field): Use value_contents_copy_raw instead of
	memcpy.
	* valops.c (value_fetch_lazy): Use value_contents_copy instead of
	memcpy.
	(value_array, value_slice): Ditto.
	* valarith.c (value_subscripted_rvalue): Use
	value_contents_copy_raw instead of memcpy.

	gdb/testsuite/
	* gdb.trace/unavailable.exp (gdb_collect_globals_test): Add new
	tests for building arrays from unavailable values, subscripting
	non-memory rvalue unvailable arrays, and accessing fields or
	baseclasses of non-lazy unavailable values,
	* gdb.trace/unavailable.cc (small_struct, small_struct_b): New
	struct types.
	(g_smallstruct, g_smallstruct_b): New globals.
@
text
@d318 3
a320 9
  for (;;)
    {
      if (TYPE_CODE (type1) == TYPE_CODE_STRUCT)
	return 1;
      else if (TYPE_CODE (type1) == TYPE_CODE_REF)
	type1 = TYPE_TARGET_TYPE (type1);
      else
	return 0;
    }
@


1.97
log
@gdb/
	Make value allocations more lazy.
	* ada-lang.c (coerce_unspec_val_to_type): Use allocate_value_lazy
	instead of allocate_value and set_value_lazy when possible.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full): Use allocate_value_lazy
	instead of allocate_value and set_value_lazy.
	* findvar.c (value_of_register_lazy): Likewise.
	(read_var_value): Remove V preallocation, call just check_typedef in
	advance.  Move allocate_value to LOC_CONST, LOC_LABEL,
	LOC_CONST_BYTES.  Use allocate_value_lazy in LOC_STATIC, LOC_ARG,
	LOC_REF_ARG, LOC_LOCAL, LOC_BLOCK.  Set ADDR instead of
	set_value_address and break in LOC_BLOCK.  Use allocate_value_lazy and
	remove lval_memory set in LOC_REGPARM_ADDR.  Use allocate_value_lazy
	in LOC_UNRESOLVED and LOC_OPTIMIZED_OUT.  Add setting lval_memory at
	the end, remove set_value_lazy there.
	* valarith.c (value_subscripted_rvalue): Use allocate_value_lazy
	instead of allocate_value and set_value_lazy when possible.
	* valops.c (value_fetch_lazy): Do nop for value_optimized_out VAL.
	* value.c (allocate_computed_value): Use allocate_value_lazy instead
	of allocate_value and set_value_lazy.
	(value_from_contents_and_address): Use allocate_value_lazy instead of
	allocate_value and set_value_lazy when possible.
@
text
@d213 3
a215 2
      memcpy (value_contents_writeable (v),
	      value_contents (array) + elt_offs, elt_size);
@


1.96
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* ui-file.c: Comment cleanup, mostly periods and spaces.
	* ui-file.h: Ditto.
	* ui-out.c: Ditto.
	* ui-out.h: Ditto.
	* utils.c: Ditto.
	* v850-tdep.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* value.h: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vax-tdep.c: Ditto.
	* vec.c: Ditto.
	* vec.h: Ditto.
	* version.h: Ditto.
	* windows-nat.c: Ditto.
	* windows-tdep.c: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xml-support.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* xtensa-tdep.c: Ditto.
	* xtensa-tdep.h: Ditto.
@
text
@a207 1
  v = allocate_value (elt_type);
d209 1
a209 1
    set_value_lazy (v, 1);
d211 5
a215 2
    memcpy (value_contents_writeable (v),
	    value_contents (array) + elt_offs, elt_size);
@


1.95
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* charset.c (validate): Internationalization.
	* coffread.c (read_one_sym): Ditto.
	* dwarf2read.c (dwarf2_attach_fields_to_type): Ditto.
	* h8300-tdep.c (H8300_extract_return_value): Ditto.
	* inflow.c (new_tty): Ditto.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* mep-tdep.c (mep_store_return_value): Ditto.
	* score-tdep.c (score7_fetch_insn): Ditto.
	* ser-mingw.c (pipe_windows_open): Ditto.
	* sh64-tdep.c (sh64_extract_return_value): Ditto.
	* spu-tdep.c (spu_register_type): Ditto.
	* tracepoint.c (trace_find_command): Ditto.
	* valarith.c (value_pos): Ditto.
@
text
@d37 1
a37 1
   differently signed operands (truncation direction is undefined in C). */
d50 1
a50 2
   helper for value_ptradd.
*/
d148 1
a148 1
   verbosity is set, warn about invalid indices (but still use them). */
d345 1
a345 1
  /* Prepare list of argument types for overload resolution */
d419 1
a419 1
  /* make the right function name up */
d556 1
a556 1
   defined operator that matches the operator in question.  
d584 1
a584 1
  /* make the right function name up */
d677 1
a677 2
   string values of length 1.
 */
d697 1
a697 1
     repeated. */
d714 1
a714 1
  /* Now process the input values. */
d719 1
a719 1
         construct a value repeated that many times. */
d762 1
a762 1
      /* We have two character strings to concatenate. */
d797 1
a797 1
      /* We have two bitstrings to concatenate. */
d808 1
a808 1
      /* We don't know how to concatenate these operands. */
d816 1
d829 1
a829 1
      /* The Russian Peasant's Algorithm */
d847 1
d860 1
a860 1
      /* The Russian Peasant's Algorithm */
d1178 1
a1178 1
	         v1 mod 0 has a defined value, v1. */
d1186 1
a1186 1
		  /* Note floor(v1/v2) == v1/v2 for unsigned. */
d1304 1
a1304 1
	         X mod 0 has a defined value, X. */
d1312 1
a1312 1
		  /* Compute floor. */
d1514 1
a1514 1
   necessarily null terminated) based on their length */
d1620 1
a1620 1
      return 0;			/* For lint -- never reached */
d1735 1
a1735 1
      return 0;			/* For lint -- never reached */
d1751 1
a1751 1
      gdb_byte decbytes[16];  /* a decfloat is at most 128 bits long */
d1790 1
a1790 1
      return 0;			/* For lint -- never reached */
d1831 1
a1831 1
   Return -1 if out of range, -2 other error. */
@


1.94
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d1734 1
a1734 1
      error ("Argument to positive operation not a number.");
@


1.93
log
@run copyright.sh for 2011.
@
text
@d125 3
a127 3
    error (_("\
First argument of `-' is a pointer and second argument is neither\n\
an integer nor a pointer of the same type."));
d546 2
a547 1
      return call_function_by_hand (argvec[0], 2 - static_memfuncp, argvec + 1);
d803 2
a804 1
	  error (_("Bitstrings or booleans can only be concatenated with other bitstrings or booleans."));
d897 2
a898 1
    error (_("Mixing decimal floating types with other floating types is not allowed."));
d1041 2
a1042 1
	    error (_("Cannot perform exponentiation: %s"), safe_strerror (errno));
@


1.92
log
@gdb:
	* valops.c (value_one): Use get_array_bounds to compute the number
	of array elements instead of dividing the length of the array by the
	length of the element types.
	* valarith.c (value_complement, value_neg): Likewise.
@
text
@d5 1
a5 1
   2010 Free Software Foundation, Inc.
@


1.91
log
@gdb
	* opencl-lang.c (lval_func_check_synthetic_pointer): New
	function.
	* value.h (struct lval_funcs) <indirect, check_synthetic_pointer>:
	New fields.
	(value_bits_synthetic_pointer): Declare.
	* value.c (value_bits_synthetic_pointer): New function.
	* valprint.c (valprint_check_validity): Handle synthetic
	pointers.
	* valops.c (value_ind): Use new 'indirect' lval_funcs method.
	* valarith.c (value_ptradd): Use set_value_component_location.
	* p-valprint.c (pascal_object_print_value_fields): Handle
	synthetic pointers.
	* jv-valprint.c (java_print_value_fields): Handle synthetic
	pointers.
	* dwarf2read.c (dwarf_stack_op_name): Add
	DW_OP_GNU_implicit_pointer.
	(dwarf2_fetch_die_location_block): Add get_frame_pc, baton
	arguments.  Handle location lists.
	(fill_in_loclist_baton): New function.
	(dwarf2_symbol_mark_computed): Use it.
	* dwarf2loc.h (dwarf2_find_location_expression): Declare.
	(dwarf2_fetch_die_location_block): Add get_frame_pc, baton
	arguments.
	* dwarf2loc.c (dwarf2_find_location_expression): Rename from
	find_location_expression.  No longer static.  Update all callers.
	(dwarf_expr_frame_pc): New function.
	(per_cu_dwarf_call): Add get_frame_pc, baton arguments.  Update
	all callers.
	(struct piece_closure) <per_cu>: New field.
	(allocate_piece_closure): Add per_cu argument.
	(read_pieced_value): Handle DWARF_VALUE_IMPLICIT_POINTER.
	(check_pieced_value_bits): Remove validity argument, add check_for
	argument.  Handle DWARF_VALUE_IMPLICIT_POINTER.
	(check_pieced_value_validity, check_pieced_value_invalid):
	Update.
	(check_pieced_synthetic_pointer): New function.
	(get_frame_address_in_block_wrapper): New function.
	(indirect_pieced_value): New function.
	(pieced_value_funcs): Update.
	(invalid_synthetic_pointer): New function.
	(dwarf2_evaluate_loc_desc_full): Rename from
	dwarf2_evaluate_loc_desc.  Add byte_offset argument.
	(dwarf2_evaluate_loc_desc): Rewrite.
	(dwarf2_loc_desc_needs_frame): Set new field on context.
	(get_ax_pc): New function.
	(disassemble_dwarf_expression): Handle
	DW_OP_GNU_implicit_pointer.
	* dwarf2expr.h (enum dwarf_value_location)
	<DWARF_VALUE_IMPLICIT_POINTER>: New constant.
	(struct dwarf_expr_context) <get_frame_pc>: New field.
	(struct dwarf_expr_piece) <v.ptr>: New field.
	* dwarf2expr.c (add_piece): Handle DWARF_VALUE_IMPLICIT_POINTER.
	(execute_stack_op): Handle DW_OP_GNU_implicit_pointer.
	* dwarf2-frame.c (no_get_frame_pc): New function.
	(execute_stack_op): Set new field on context.
	* cp-valprint.c (cp_print_value_fields): Handle synthetic
	pointers.
gdb/testsuite
	* gdb.dwarf2/implptr.exp: New file.
	* gdb.dwarf2/implptr.c: New file.
	* gdb.dwarf2/implptr.S: New file.
@
text
@d1769 2
a1770 1
      int i, n = TYPE_LENGTH (type) / TYPE_LENGTH (eltype);
d1772 4
a1775 1
      for (i = 0; i < n; i++)
d1805 5
a1809 1
      int i, n = TYPE_LENGTH (type) / TYPE_LENGTH (eltype);
d1812 1
a1812 1
      for (i = 0; i < n; i++)
@


1.90
log
@gdb:
	* dwarf2read.c (read_array_type): Read the DW_AT_byte_size from the
	DIE and set the length of the type.
	* gdbtypes.h (get_array_bounds): Move here from valprint.h.
	* gdbtypes.c (get_array_bounds): Move here from valprint.c and
	return 0 if the corresponding bounds of the type are undefined.
	* valprint.h (get_array_bounds): Move declaration to gdbtypes.h.
	* valprint.c (get_array_bounds): Move implementation to gdbtypes.c.
	(val_print_array_elements): Use get_array_bounds to compute the number
	of array elements instead of dividing the length of the array by the
	length of the element types.
	* valarith.c (vector_binop): Likewise.
	* valops.c (value_cast): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* c-typeprint.c (c_type_print_varspec_suffix): Likewise.

gdb/testsuite:
	* gdb.base/gnu_vector.exp: Adjust expect messages.
@
text
@d93 1
d99 5
a103 2
  return value_from_pointer (valptrtype,
			     value_as_address (arg1) + sz * arg2);
@


1.89
log
@gdb:
	* valarith.c (value_pos, value_neg, value_complement): Handle
	vector types.
	* valops.c (value_one): Likewise.

gdb/testsuite:
	* gdb.base/gnu_vector.exp: Add unary operator tests.
@
text
@d1397 2
a1398 1
  int t1_is_vec, t2_is_vec, elsize, n, i;
d1411 4
d1417 1
d1420 3
a1422 2
      || TYPE_LENGTH (eltype1) != TYPE_LENGTH (eltype2)
      || TYPE_UNSIGNED (eltype1) != TYPE_UNSIGNED (eltype2))
a1424 6
  elsize = TYPE_LENGTH (eltype1);
  n = TYPE_LENGTH (type1) / elsize;

  if (n != TYPE_LENGTH (type2) / TYPE_LENGTH (eltype2))
    error (_("Cannot perform operation on vectors with different sizes"));

d1427 1
a1427 1
  for (i = 0; i < n; i++)
@


1.88
log
@Support overloading of 'operator->'.

2010-10-19  Sami Wagiaalla  <swagiaal@@redhat.com>

	 PR C++/11500:
	* valarith.c (value_x_unop): Handle STRUCTOP_PTR.
	* eval.c (evaluate_subexp_standard): Check for overload of
	'operator->'.
	* valarith.c (value_x_binop): Throw NOT_FOUND_ERROR.
	(value_x_unop): Ditto.
	* valops.c: Include "exceptions.h".
	(find_overload_match): Throw NOT_FOUND_ERROR.
	(value_struct_elt): Ditto.

2010-10-19  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/smartp.exp: New test.
	* gdb.cp/smartp.cc : New test.
@
text
@d1715 8
d1760 14
d1785 1
d1790 18
a1807 2
  if (!is_integral_type (type))
    error (_("Argument to complement operation not an integer or boolean."));
d1809 1
a1809 1
  return value_from_longest (type, ~value_as_long (arg1));
@


1.87
log
@gdb:
	* valops.c (value_cast): Handle vector types.
	* valarith.c (value_binop): Widen scalar to vector if appropriate.
gdb/testsuite:
	* gdb.base/gnu_vector.c (ia, ib, fa, fb): New variables.
	* gdb.base/gnu_vector.exp: Add tests for scalar to vector widening.
@
text
@d544 2
a545 1
  error (_("member function %s not found"), tstr);
d620 3
d648 3
a650 1
  error (_("member function %s not found"), tstr);
@


1.86
log
@gdb/ChangeLog:* gdb/valarith.c (vector_binop): New function.(scalar_binop): Likewise.(value_binop): Call scalar_binop or vector_binop depending on the types.* gdb/eval.c (ptrmath_type_p): Return 0 in case of TYPE_VECTOR.(evaluate_subexp_with_coercion): Add vector check to not convert vectorsto pointers.* gdb/value.c (coerce_array): Add vector check to not coerce vectors.testsuite/ChangeLog:* gdb.base/Makefile.in (EXECUTABLES): Add gnu_vector.* gdb.base/gnu_vector.c: New File.* gdb.base/gnu_vector.exp: Likewise.
@
text
@d1438 1
d1441 19
d1461 5
a1465 5
  if ((TYPE_CODE (type1) == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))
	  || (TYPE_CODE (type2) == TYPE_CODE_ARRAY && TYPE_VECTOR (type2)))
    return vector_binop (arg1, arg2, op);
  else
    return scalar_binop (arg1, arg2, op);
@


1.85
log
@Test and support all cpp operator types.

2010-06-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	* value.h: Created oload_search_type enum.
	(find_overload_match): Use oload_search_type enum.
	* valops.c (find_overload_match): Support combined member and
	non-member search.
	* eval.c (evaluate_subexp_standard): Calls to
	find_overload_match now use oload_search_type enum.
	(oload_method_static): Verify index is a proper value.
	* valarith.c (value_user_defined_cpp_op): Search for and handle
	both member and non-member operators.
	(value_user_defined_cpp_op): New function.
	(value_user_defined_op): New function.
	(value_x_unop): Use value_user_defined_op.
	(value_x_binop): Ditto.
	* cp-support.c (make_symbol_overload_list_using): Added block
	iteration.
	Add check for namespace aliases and imported declarations.

2010-06-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/koenig.exp: Test for ADL operators.
	* gdb.cp/koenig.cc: Added ADL operators.
	* gdb.cp/operator.exp: New test.
	* gdb.cp/operator.cc: New test.
@
text
@d932 2
a933 2
struct value *
value_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)
d1382 65
@


1.84
log
@2010-05-17  Michael Snyder  <msnyder@@vmware.com>

	* valarith.c: White space.
	* valops.c: White space.
	* valprint.c: White space.
	* value.c: White space.
	* varobj.c: White space.
	* xcoffread.c: White space.
	* xml-support.c: White space.
	* xml-tdesc.c: White space.
@
text
@d34 1
d323 61
d524 2
a525 1
  argvec[0] = value_struct_elt (&arg1, argvec + 1, tstr, &static_memfuncp, "structure");
d623 2
a624 1
  argvec[0] = value_struct_elt (&arg1, argvec + 1, tstr, &static_memfuncp, "structure");
@


1.83
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* eval.c (evaluate_subexp_standard): Delete unused variable.
	* valops.c (value_cast_pointers): Delete unused variable.
	(value_dynamic_cast): Delete unused variable.
	(value_array): Delete unused variable.
	(find_overload_match): Delete unused variable.
	* valarith.c (value_subscript): Delete unused variable.
	(value_binop): Delete unused variable.
	* valprint.c (_initialize_valprint): Delete unused variable.
	* printcmd.c (print_command_1): Delete unused variable.
	(address_info): Delete unused variable.
	(printf_command): Delete unused variable.
@
text
@d160 1
a161 1

d307 1
d474 1
d573 1
d629 1
d656 1
d667 1
d701 1
d707 1
d938 1
d997 1
d1061 1
d1187 1
d1412 1
d1508 1
d1630 1
d1650 1
@


1.82
log
@gdb/
	* dwarf2read.c (read_subrange_type): Set TYPE_HIGH_BOUND_UNDEFINED.
	* valarith.c (value_subscripted_rvalue): Suppress error if
	TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
@
text
@a148 1
  struct value *bound;
a882 1
      struct type *v_type;
@


1.81
log
@	* ax-gdb.c (gen_exp_binop_rest) [BINOP_SUBSCRIPT]: Error out on
	non-subscriptable types.
	* valarith.c (binop_types_user_defined_p): New, abstracted out
	from ...
	(binop_user_defined_p): ... this.
	* value.h (binop_types_user_defined_p): Declare.
@
text
@d201 2
a202 1
  if (index < lowerbound || elt_offs >= TYPE_LENGTH (array_type))
@


1.80
log
@PR gdb/10728
* valarith.c (value_ptrdiff): Added a test for a zero type length,
	warn if found, and assume length = 1.
* gdb.cp/pr10728-x.h: New file.
* gdb.cp/pr10728-x.cc: New file.
* gdb.cp/pr10728-y.cc: New file.
* gdb.cp/pr10728.exp: New file.
* gdb.cp/Makefile.in (EXECUTABLES): Add pr10728
@
text
@d266 2
a267 1
binop_user_defined_p (enum exp_opcode op, struct value *arg1, struct value *arg2)
a268 1
  struct type *type1, *type2;
d272 1
a272 1
  type1 = check_typedef (value_type (arg1));
d276 1
a276 1
  type2 = check_typedef (value_type (arg2));
d284 13
@


1.79
log
@gdb
	PR backtrace/10770:
	* valarith.c (value_binop): Handle BINOP_GTR, BINOP_LEQ, and
	BINOP_GEQ.  Handle BINOP_NOTEQUAL in the signed case.
	* dwarf2expr.c (new_dwarf_expr_context): Allocate
	dwarf_stack_values, not CORE_ADDRs.
	(execute_stack_op): Change DW_OP_div and comparison operators to
	use signed operands.
gdb/testsuite
	PR backtrace/10770:
	* gdb.dwarf2/pr10770.exp: New file.
	* gdb.dwarf2/pr10770.c: New file.
	* gdb.dwarf2/Makefile.in (EXECUTABLES): Add pr10770.
@
text
@d125 7
@


1.78
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d1131 12
d1252 4
d1260 12
@


1.77
log
@gdb/
	* valarith.c (value_equal_contents): New function.
	* value.h (value_equal_contents): Declare.
	* breakpoint.c (watchpoint_check): Use value_equal_contents
	instead of value_equal.

gdb/testsuite/
	* gdb.base/watchpoint.exp (test_watchpoint_in_big_blob): New function.
	(top level): Call test_watchpoint_in_big_blob.
	* gdb.base/watchpoint.c (buf): Change size to value too big for hardware
	watchpoints.
	(func3): Write to buf.
@
text
@d4 2
a5 2
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009
   Free Software Foundation, Inc.
@


1.76
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d1400 18
@


1.75
log
@	* gdbtypes.c (make_pointer_type, make_reference_type,
	smash_to_memberptr_type, lookup_array_range_type, check_stub_method):
	Use type architecture instead of current_gdbarch.

	* gdbtypes.h (address_space_name_to_int, address_space_int_to_name):
	Add GDBARCH paramter.
	* gdbtypes.c (address_space_name_to_int, address_space_int_to_name):
	Add GDBARCH parameter.   Use it instead of current_gdbarch.
	* c-typeprint.c (c_type_print_modifier): Update call.
	* parse.c (push_type_address_space): Likewise.

	* findvar.c (extract_typed_address, store_typed_address): Use type
	architecture instead of current_gdbarch.

	* value.c (value_as_address, unpack_field_as_long): Use type architecture
	instead of current_gdbarch.

	* doublest.c (floatformat_from_length): Add GDBARCH argument.  Use it
	instead of current_gdbarch.
	(floatformat_from_type): Pass type architecture.

	* infcall.c (find_function_addr): Use type architecture instead
	of current_gdbarch.

	* valarith.c (value_bitstring_subscript, value_x_binop, value_neg,
	value_bit_index): Use type architecture instead of current_gdbarch.
	* valops.c (value_cast, value_slice): Likewise.

	* value.h (modify_field): Add TYPE argument.
	* value.c (modify_field): Add TYPE argument.  Use type architecture
	instead of current_gdbarch.
	(set_internalvar_component): Likewise.
	* eval.c (evaluate_struct_tuple): Update call.
	* valops.c (value_assign): Likewise.
	* ada-lang.c (modify_general_field): Likewise.  Add TYPE argument.
	(make_array_descriptor): Update calls.
	(move_bits): Add BITS_BIG_ENDIAN_P argument.  Use it instead of
	current_gdbarch.
	(ada_value_assign, value_assign_to_component): Update calls.
	(decode_packed_array, ada_value_primitive_packed_val, ada_value_assign,
	value_assign_to_component): Use type arch instead of current_gdbarch.

	* printcmd.c (float_type_from_length): Remove GDBARCH argument,
	use type architecture instead.
	(print_scalar_formatted, printf_command): Update calls.  Use type
	architecture instead of current_gdbarch.
	* valprint.c (val_print_type_code_int): Use type architecture
	instead of current_gdbarch.
	* varobj.c (value_get_print_value): Likewise.
	* python/python-prettyprint.c (print_string_repr): Add GDBARCH
	argument.  Use it instead of current_gdbarch.
	(apply_val_pretty_printer): Update call.

	* ada-valprint.c (ada_val_print_1): Use type architecture instead
	of current_gdbarch.
	* c-valprint.c (print_function_pointer_address): Add GDBARCH argument.
	Use it instead of current_gdbarch.
	(c_val_print): Update calls passing type architecture.
	* f-valprint.c (f_val_print): Use type architecture instead of
	current_gdbarch.
	* jv-valprint (java_value_print): Likewise.
	* m2-valprint.c (print_function_pointer_address): Add GDBARCH argument.
	Use it instead of current_gdbarch.
	(print_unpacked_pointer): Update calls passing type architecture.
	* scm-valprint.c (scm_scmval_print): Use type architecture instead of
	current_gdbarch.

	* gnu-v3-abi.c (get_class_arch): Remove.
	(gnuv3_rtti_type): Use get_type_arch instead of get_class_arch.  Remove
	special-case check for Java classes.
	(gnuv3_virtual_fn_field, gnuv3_baseclass_offset, gnuv3_print_method_ptr,
	gnuv3_method_ptr_size, gnuv3_make_method_ptr, gnuv3_method_ptr_to_value):
	Use get_type_arch instead of get_class_arch.
@
text
@d776 2
a777 1
		       gdb_byte *x, int *len_x, gdb_byte *y, int *len_y)
d800 1
d806 1
d808 1
a808 1
      decimal_from_integral (arg1, x, *len_x);
d819 1
d825 1
d827 1
a827 1
      decimal_from_integral (arg2, y, *len_y);
d865 1
d881 1
d883 2
a884 1
      value_args_as_decimal (arg1, arg2, v1, &len_v1, v2, &len_v2);
d893 3
a895 1
	  decimal_binop (op, v1, len_v1, v2, len_v2, v, len_v);
d1003 1
d1138 2
d1251 2
d1275 2
a1276 1
    return decimal_is_zero (value_contents (arg1), TYPE_LENGTH (type1));
d1360 1
d1362 2
a1363 1
      value_args_as_decimal (arg1, arg2, v1, &len_v1, v2, &len_v2);
d1365 2
a1366 1
      return decimal_compare (v1, len_v1, v2, len_v2) == 0;
d1437 1
d1439 2
a1440 1
      value_args_as_decimal (arg1, arg2, v1, &len_v1, v2, &len_v2);
d1442 2
a1443 1
      return decimal_compare (v1, len_v1, v2, len_v2) == -1;
d1556 2
a1557 1
  word = extract_unsigned_integer (valaddr + (rel_index / TARGET_CHAR_BIT), 1);
@


1.74
log
@	* ada-lang.c (assign_component): Use platform-specific integer type
	instead of builtin_type_int32 type.
	(ada_evaluate_subexp) [OP_ATR_SIZE]: Likewise.

	* ax-gdb.c (gen_expr) [UNOP_NEG]: Use platform-specific integer type
	instead of builtin_type_int8 type.
	* valarith.c (value_x_unop): Likewise.
	* python/python-value.c (valpy_absolute): Avoid reference to
	builtin_type_int8 type.

	* eval.c (evaluate_subexp_standard): Use platform-specific integer
	type instead of builtin_type_int8 as EVAL_SKIP return value type.
	* ada-lang.c (ada_evaluate_subexp): Likewise.
	* jv-lang.c (evaluate_subexp_java): Likewise.
	* m2-lang.c (evaluate_subexp_modula2): Likewise.
	* scm-lang.c (evaluate_exp): Likewise.

	* value.h (value_bitstring): Add INDEX_TYPE argument.
	* valops.c (value_bitstring): Add INDEX_TYPE argument, use it instead
	of builtin_type_int32 as base range type.
	* eval.c (evaluate_subexp_standard): Update value_bitstring call.
@
text
@d236 1
a236 1
  byte >>= (gdbarch_bits_big_endian (current_gdbarch) ?
d474 1
a474 1
  struct gdbarch *gdbarch = current_gdbarch;
d1482 1
a1482 1
      if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
d1524 1
d1536 1
a1536 1
  if (gdbarch_bits_big_endian (current_gdbarch))
@


1.73
log
@	* value.h (value_subscript, value_subscripted_rvalue,
	value_bitstring_subscript, value_ptradd): Use LONGEST instead
	of value as type of the index argument.
	(value_ptrsub): Remove.
	* valarith.c (value_subscript, value_subscripted_rvalue,
	value_bitstring_subscript, value_ptradd): Use LONGEST instead
	of value as type of the index argument.
	(value_ptrsub): Remove.

	* wrapper.h (gdb_value_subscript): Use LONGEST instead of
	value as type of the index argument.
	* wrapper.c (gdb_value_subscript): Likewise.

	Update calls to gdb_value_subscript, value_subscript,
	value_subscripted_rvalue, value_bitstring_subscript and
	value_ptradd to use LONGEST instead of value as index
	argument type.  Use value_ptradd instead of value_ptrsub.
	* ada-lang.c (ada_value_subscript, ada_value_ptr_subscript,
	ada_tag_name_2): Update.
	* ada-tasks.c (read_atcb): Update.
	* eval.c (evaluate_subexp_standard): Update.
	* valarith.c (value_subscript): Update.
	* gnu-v2-abi.c (gnuv2_virtual_fn_field): Update.
	* gnu-v3-abi.c (gnuv3_get_virtual_fn, gnuv3_baseclass_offset,
	gnuv3_method_ptr_to_value): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* m2-lang.c (evaluate_subexp_modula2): Update.
	* python/python-value.c (valpy_getitem, valpy_binop): Update.
	* wrapper.c (gdb_value_subscript): Update.
	* varobj.c (c_describe_child): Update.
@
text
@d474 1
d509 1
a509 1
      argvec[2] = value_from_longest (builtin_type_int8, 0);
d515 1
a515 1
      argvec[2] = value_from_longest (builtin_type_int8, 0);
@


1.72
log
@	* gdbtypes.c (create_string_type): Receive character type as argument.
	* gdbtypes.h (create_string_type): Add character type argument.
        * dwarf2read.c (read_tag_string_type): Pass character type to
	create_string_type.

	* value.h (value_string): Add character type argument.
	* valops.c (value_string): Add character type argument.  Pass it to
	create_string_type.  Do not allocate space in inferior.
	* valarith.c (value_concat): Pass character type to value_string.

	* value.h (value_typed_string): Rename to ...
	(value_cstring): ... this.
	* valops.c (value_typed_string): Rename to ...
	(value_cstring): ... this.
	* c-lang.c (evaluate_subexp_c): Update.

	* python/python-value.c (builtin_type_pychar): New define.
	(convert_value_from_python): Call value_cstring instead
	of value_from_string.
	* value.c (value_from_string): Remove.
	* value.h (value_from_string): Remove.

	* eval.c (evaluate_subexp_standard): Pass character type to
	value_string.  Pass expression architecture to value_nsstring
	and lookup_child_selector.
	* objc-lang.h (lookup_objc_class): Add GDBARCH parameter.
	(lookup_child_selector): Likewise.
	(value_nsstring): Likewise.
	* objc-lang.c (lookup_objc_class): Add GDBARCH parameter.
	Pass character type to value_string..
	(lookup_child_selector): Likewise.
	(value_nsstring): Add GDBARCH parameter, use it instead of
	objfile architecture.  Pass architecture to lookup_objc_class
	and lookup_child_selector. Pass character type to value_string.
	(end_msglist): Pass architecture to lookup_objc_class.
	* objc-exp.y: Pass architecture to lookup_objc_class.
@
text
@d49 1
a49 1
   helper for value_ptrsub & value_ptradd.
d88 1
a88 1
value_ptradd (struct value *arg1, struct value *arg2)
a96 24
  if (!is_integral_type (value_type (arg2)))
    error (_("Argument to arithmetic operation not a number or boolean."));

  return value_from_pointer (valptrtype,
			     value_as_address (arg1)
			       + (sz * value_as_long (arg2)));
}

/* Given a pointer ARG1 and an integral value ARG2, return the
   result of C-style pointer arithmetic ARG1 - ARG2.  */

struct value *
value_ptrsub (struct value *arg1, struct value *arg2)
{
  struct type *valptrtype;
  LONGEST sz;

  arg1 = coerce_array (arg1);
  valptrtype = check_typedef (value_type (arg1));
  sz = find_size_for_pointer_math (valptrtype);

  if (!is_integral_type (value_type (arg2)))
    error (_("Argument to arithmetic operation not a number or boolean."));

d98 1
a98 2
			     value_as_address (arg1)
			       - (sz * value_as_long (arg2)));
d140 1
a140 1
value_subscript (struct value *array, struct value *idx)
d157 1
a157 1
	return value_subscripted_rvalue (array, idx, lowerbound);
a160 1
	  LONGEST index = value_as_long (idx);
d162 1
a162 1
	    return value_subscripted_rvalue (array, idx, lowerbound);
d171 1
a171 6
      if (lowerbound != 0)
	{
	  bound = value_from_longest (value_type (idx), (LONGEST) lowerbound);
	  idx = value_binop (idx, bound, BINOP_SUB);
	}

d176 1
a176 1
    return value_ind (value_ptradd (array, idx));
d186 1
a186 1
value_subscripted_rvalue (struct value *array, struct value *idx, int lowerbound)
a190 1
  LONGEST index = value_as_long (idx);
d215 1
a215 1
			   struct value *bitstring, struct value *idx)
a218 1
  LONGEST index = value_as_long (idx);
@


1.71
log
@	* dfp.h (decimal_binop): Convert LEN_RESULT to input parameter.
	* dfp.c (promote_decimal): Remove.
	(decimal_binop): Convert LEN_RESULT to input parameter.
	Remove call to decimal_binop.
	(decimal_compare): Remove call to decimal_binop.

	* valarith.c (value_binop): Pass desired result type length
	to decimal_binop.
@
text
@d627 1
d663 1
d673 1
d680 1
a680 1
	  outval = value_string (ptr, count * inval2len);
d706 1
d711 1
d723 1
a723 1
      outval = value_string (ptr, inval1len + inval2len);
@


1.70
log
@2009-01-13  Jim Blandy  <jimb@@codesourcery.com>

	Abstract out common code for copying value locations.

	* value.h (set_value_component_location): New declaration.
	* value.c (set_value_component_location): New function.
	(value_primitive_field): Use it.
	* valarith.c (value_subscript, value_subscripted_rvalue): Same.
	* valops.c (search_struct_field, value_slice): Same.
	* ada-lang.c (coerce_unspec_val_to_type)
	(ada_value_primitive_packed_val): Same.
@
text
@d890 13
d912 1
a912 1
	  decimal_binop (op, v1, len_v1, v2, len_v2, v, &len_v);
a918 11
      /* If only one type is decimal float, use its type.
	 Otherwise use the bigger type.  */
      if (TYPE_CODE (type1) != TYPE_CODE_DECFLOAT)
	result_type = type2;
      else if (TYPE_CODE (type2) != TYPE_CODE_DECFLOAT)
	result_type = type1;
      else if (TYPE_LENGTH (type2) > TYPE_LENGTH (type1))
	result_type = type2;
      else
	result_type = type1;

@


1.69
log
@        Updated copyright notices for most files.
@
text
@d236 1
a236 5
  if (VALUE_LVAL (array) == lval_internalvar)
    VALUE_LVAL (v) = lval_internalvar_component;
  else
    VALUE_LVAL (v) = VALUE_LVAL (array);
  VALUE_ADDRESS (v) = VALUE_ADDRESS (array);
d276 1
a276 5

  VALUE_LVAL (v) = VALUE_LVAL (bitstring);
  if (VALUE_LVAL (bitstring) == lval_internalvar)
    VALUE_LVAL (v) = lval_internalvar_component;
  VALUE_ADDRESS (v) = VALUE_ADDRESS (bitstring);
@


1.68
log
@	Fix TYPE_HIGH_BOUND for TYPE_CODE_RANGE using arbitrary TYPE_NFIELDS in
	preparation for supporting DW_AT_byte_stride.
	* ada-lang.c (packed_array_type, ada_index_type): Use TYPE_INDEX_TYPE.
	(ada_array_bound_from_type): Move `index_type' declaration to the
	function start.  New variable `retval'.  Return the bounds for
	TYPE_CODE_RANGE using TYPE_LOW_BOUND and TYPE_HIGH_BOUND.  Abort on
	invalid index type codes.
	* ada-typeprint.c (print_range): Set `upper_bound' for TYPE_CODE_RANGE
	now using TYPE_HIGH_BOUND.
	* ada-valprint.c (val_print_packed_array_elements): Use `index_type'.
	* eval.c (evaluate_subexp_standard): Use TYPE_INDEX_TYPE.
	* gdbtypes.c (create_range_type): Use TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	refer to the number of fields only through TYPE_NFIELDS.
	(create_array_type): Use TYPE_INDEX_TYPE.
	(check_typedef): Use TYPE_INDEX_TYPE, TYPE_LOW_BOUND, TYPE_HIGH_BOUND.
	* gdbtypes.h (TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED)
	(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED): Use TYPE_INDEX_TYPE.
	(TYPE_ARRAY_UPPER_BOUND_VALUE, TYPE_ARRAY_LOWER_BOUND_VALUE): Use
	TYPE_INDEX_TYPE, TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	* hppa-tdep.c (hppa_alignof <TYPE_CODE_ARRAY>): Use TYPE_INDEX_TYPE.
	* mdebugread.c (parse_type): Use TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	* valarith.c (value_bit_index): Use TYPE_INDEX_TYPE.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
@


1.67
log
@	* valarith.c (value_x_unop): Use builtin_type_int8 as type for
	UNOP_POSTINCREMENT/UNOP_POSTDECREMENT constant 0 argument.
	(value_bit_index): Use extract_unsigned_integer
	instead of unpack_long to read single byte.
@
text
@d1560 1
a1560 1
  struct type *range = TYPE_FIELD_TYPE (type, 0);
@


1.66
log
@	* value.h (coerce_enum, coerce_number): Remove prototypes.
	* value.c (coerce_enum, coerce_number): Remove.
	* valarith.c (value_x_binop): Do not call coerce_enum.
	(value_x_unop): Likewise.
	(value_logical_not): Call coerce_array instead of coerce_number.
@
text
@d549 1
a549 1
      argvec[2] = value_from_longest (builtin_type_int, 0);
d555 1
a555 1
      argvec[2] = value_from_longest (builtin_type_int, 0);
d1566 1
a1566 2
  word = unpack_long (builtin_type_unsigned_char,
		      valaddr + (rel_index / TARGET_CHAR_BIT));
@


1.65
log
@	* eval.c (evaluate_subexp_standard): Add calls to binop_promote
	and unop_promote before calling value_binop et. al.
	* ada-lang.c (ada_evaluate_subexp): Add calls to binop_promote
	and unop_promote before calling value_binop et. al.

	* valarith.c (value_binop): Do not call binop_promote or unop_promote.
	(value_pos): Do not call unop_promote.
	(value_neg, value_complement): Likewise.
@
text
@a361 2
  arg1 = coerce_enum (arg1);
  arg2 = coerce_enum (arg2);
a520 1
  arg1 = coerce_enum (arg1);
d1287 1
a1287 1
  arg1 = coerce_number (arg1);
@


1.64
log
@	* value.h (unop_promote, binop_promote): Add prototypes.
	* eval.c (unop_promote, binop_promote): New functions.
	* valarith.c (unop_result_type, binop_result_type): Remove.
	(value_binop): Call binop_promote or unop_promote.
	Inline remaining parts of binop_result_type.  Remove special
	code to truncate integer values for unsigned operations.
	(value_pos): Call unop_promote.  Inline remaining parts of
	unop_result_type.
	(value_neg, value_complement): Likewise.
@
text
@a878 8
  /* For shift and integer exponentiation operations,
     only promote the first argument.  */
  if ((op == BINOP_LSH || op == BINOP_RSH || op == BINOP_EXP)
      && is_integral_type (value_type (arg2)))
    unop_promote (current_language, current_gdbarch, &arg1);
  else
    binop_promote (current_language, current_gdbarch, &arg1, &arg2);

a1483 2
  unop_promote (current_language, current_gdbarch, &arg1);

a1506 2
  unop_promote (current_language, current_gdbarch, &arg1);

a1543 2
  unop_promote (current_language, current_gdbarch, &arg1);

@


1.63
log
@	* value.h (value_add, value_sub): Remove.
	(value_ptradd, value_ptrsub, value_ptrdiff): Add prototypes.
	* valarith.c (value_add, value_sub): Remove.
	(value_ptradd, value_ptrsub, value_ptrdiff): New functions.
	(find_size_for_pointer_math): Add assertion.  Update comment.
	(value_binop): Update comment.

	* eval.c (ptrmath_type_p): New function.
	(evaluate_subexp_standard): Replace value_add and value_sub
	by value_ptradd, value_ptrsub, value_ptrdiff or value_binop.
	Use builtin_type_uint8 instead of builtin_type_char to hold
	the increment for BINOP_{PRE,POST}{IN,DE}CREMENT operations.
	* valarith.c (value_subscript): Replace value_add by
	value_ptradd.  Replace value_sub by value_binop.
	* ada-lang.c (ada_value_ptr_subscript): Likewise.
	(ada_tag_name_2): Replace value_add by value_ptradd.
	(ada_evaluate_subexp): Replace value_add and value_sub by
	value_binop.
	* m2-lang.c (evaluate_subexp_modula2): Replace value_add
	by value_ptradd.
	* gnu-v2-abi.c (gnuv2_virtual_fn_field): Likewise.
	* gnu-v3-abi.c (gnuv3_method_ptr_to_value): Likewise.
@
text
@a41 4
static struct type *unop_result_type (enum exp_opcode op, struct type *type1);
static struct type *binop_result_type (enum exp_opcode op, struct type *type1,
				       struct type *type2);

a749 288
/* Return result type of OP performed on TYPE1.
   The result type follows ANSI C rules.
   If the result is not appropropriate for any particular language then it
   needs to patch this function to return the correct type.  */

static struct type *
unop_result_type (enum exp_opcode op, struct type *type1)
{
  struct type *result_type;

  type1 = check_typedef (type1);
  result_type = type1;

  switch (op)
    {
    case UNOP_PLUS:
    case UNOP_NEG:
      break;
    case UNOP_COMPLEMENT:
      /* Reject floats and decimal floats.  */
      if (!is_integral_type (type1))
	error (_("Argument to complement operation not an integer or boolean."));
      break;
    default:
      error (_("Invalid unary operation on numbers."));
    }

  if (TYPE_CODE (type1) == TYPE_CODE_DECFLOAT
      || TYPE_CODE (type1) == TYPE_CODE_FLT)
    {
      return result_type;
    }
  else if (is_integral_type (type1))
    {
      /* Perform integral promotion for ANSI C/C++.
	 If not appropropriate for any particular language it needs to
	 modify this function to return the correct result for it.  */
      if (TYPE_LENGTH (type1) < TYPE_LENGTH (builtin_type_int))
	result_type = builtin_type_int;

      return result_type;
    }
  else
    {
      error (_("Argument to unary operation not a number."));
      return 0; /* For lint -- never reached */
    }
}

/* Return result type of OP performed on TYPE1, TYPE2.
   If the result is not appropropriate for any particular language then it
   needs to patch this function to return the correct type.  */

static struct type *
binop_result_type (enum exp_opcode op, struct type *type1, struct type *type2)
{
  type1 = check_typedef (type1);
  type2 = check_typedef (type2);

  if ((TYPE_CODE (type1) != TYPE_CODE_FLT
       && TYPE_CODE (type1) != TYPE_CODE_DECFLOAT
       && !is_integral_type (type1))
      ||
      (TYPE_CODE (type2) != TYPE_CODE_FLT
       && TYPE_CODE (type2) != TYPE_CODE_DECFLOAT
       && !is_integral_type (type2)))
    error (_("Argument to arithmetic operation not a number or boolean."));

  if (TYPE_CODE (type1) == TYPE_CODE_DECFLOAT
      || TYPE_CODE (type2) == TYPE_CODE_DECFLOAT)
    {
      switch (op)
	{
	case BINOP_ADD:
	case BINOP_SUB:
	case BINOP_MUL:
	case BINOP_DIV:
	case BINOP_EXP:
	  break;
	default:
	  error (_("Operation not valid for decimal floating point number."));
	}

      if (TYPE_CODE (type1) != TYPE_CODE_DECFLOAT)
	/* If type1 is not a decimal float, the type of the result is the type
	   of the decimal float argument, type2.  */
	return type2;
      else if (TYPE_CODE (type2) != TYPE_CODE_DECFLOAT)
	/* Same logic, for the case where type2 is not a decimal float.  */
	return type1;
      else
	/* Both are decimal floats, the type of the result is the bigger
	   of the two.  */
	return (TYPE_LENGTH (type1) > TYPE_LENGTH (type2)) ? type1 : type2;
    }
  else if (TYPE_CODE (type1) == TYPE_CODE_FLT
	   || TYPE_CODE (type2) == TYPE_CODE_FLT)
    {
      switch (op)
	{
	case BINOP_ADD:
	case BINOP_SUB:
	case BINOP_MUL:
	case BINOP_DIV:
	case BINOP_EXP:
	case BINOP_MIN:
	case BINOP_MAX:
	  break;
	default:
	  error (_("Integer-only operation on floating point number."));
	}

      switch (current_language->la_language)
	{
	case language_c:
	case language_cplus:
	case language_asm:
	case language_objc:
	  /* Perform ANSI/ISO-C promotions.
	     If only one type is float, use its type.
	     Otherwise use the bigger type.  */
	  if (TYPE_CODE (type1) != TYPE_CODE_FLT)
	    return type2;
	  else if (TYPE_CODE (type2) != TYPE_CODE_FLT)
	    return type1;
	  else
	    return (TYPE_LENGTH (type1) > TYPE_LENGTH (type2)) ? type1 : type2;

	default:
	  /* For other languages the result type is unchanged from gdb
	     version 6.7 for backward compatibility.
	     If either arg was long double, make sure that value is also long
	     double.  Otherwise use double.  */
	  if (TYPE_LENGTH (type1) * 8 > gdbarch_double_bit (current_gdbarch)
	      || TYPE_LENGTH (type2) * 8 > gdbarch_double_bit (current_gdbarch))
	    return builtin_type_long_double;
	  else
	    return builtin_type_double;
	}
    }
  else if (TYPE_CODE (type1) == TYPE_CODE_BOOL
	   && TYPE_CODE (type2) == TYPE_CODE_BOOL)
    {
      switch (op)
	{
	case BINOP_BITWISE_AND:
	case BINOP_BITWISE_IOR:
	case BINOP_BITWISE_XOR:
        case BINOP_EQUAL:
        case BINOP_NOTEQUAL:
	  break;
	default:
	  error (_("Invalid operation on booleans."));
	}

      return type1;
    }
  else
    /* Integral operations here.  */
    /* FIXME: Also mixed integral/booleans, with result an integer.  */
    {
      unsigned int promoted_len1 = TYPE_LENGTH (type1);
      unsigned int promoted_len2 = TYPE_LENGTH (type2);
      int is_unsigned1 = TYPE_UNSIGNED (type1);
      int is_unsigned2 = TYPE_UNSIGNED (type2);
      unsigned int result_len;
      int unsigned_operation;

      /* Determine type length and signedness after promotion for
         both operands.  */
      if (promoted_len1 < TYPE_LENGTH (builtin_type_int))
	{
	  is_unsigned1 = 0;
	  promoted_len1 = TYPE_LENGTH (builtin_type_int);
	}
      if (promoted_len2 < TYPE_LENGTH (builtin_type_int))
	{
	  is_unsigned2 = 0;
	  promoted_len2 = TYPE_LENGTH (builtin_type_int);
	}

      /* Determine type length of the result, and if the operation should
	 be done unsigned.  For exponentiation and shift operators,
	 use the length and type of the left operand.  Otherwise,
	 use the signedness of the operand with the greater length.
	 If both operands are of equal length, use unsigned operation
	 if one of the operands is unsigned.  */
      if (op == BINOP_RSH || op == BINOP_LSH || op == BINOP_EXP)
	{
	  /* In case of the shift operators and exponentiation the type of
	     the result only depends on the type of the left operand.  */
	  unsigned_operation = is_unsigned1;
	  result_len = promoted_len1;
	}
      else if (promoted_len1 > promoted_len2)
	{
	  unsigned_operation = is_unsigned1;
	  result_len = promoted_len1;
	}
      else if (promoted_len2 > promoted_len1)
	{
	  unsigned_operation = is_unsigned2;
	  result_len = promoted_len2;
	}
      else
	{
	  unsigned_operation = is_unsigned1 || is_unsigned2;
	  result_len = promoted_len1;
	}

      switch (op)
	{
	case BINOP_ADD:
	case BINOP_SUB:
	case BINOP_MUL:
	case BINOP_DIV:
	case BINOP_INTDIV:
	case BINOP_EXP:
	case BINOP_REM:
	case BINOP_MOD:
	case BINOP_LSH:
	case BINOP_RSH:
	case BINOP_BITWISE_AND:
	case BINOP_BITWISE_IOR:
	case BINOP_BITWISE_XOR:
	case BINOP_LOGICAL_AND:
	case BINOP_LOGICAL_OR:
	case BINOP_MIN:
	case BINOP_MAX:
	case BINOP_EQUAL:
	case BINOP_NOTEQUAL:
	case BINOP_LESS:
	  break;

	default:
	  error (_("Invalid binary operation on numbers."));
	}

      switch (current_language->la_language)
	{
	case language_c:
	case language_cplus:
	case language_asm:
	case language_objc:
	  if (result_len <= TYPE_LENGTH (builtin_type_int))
	    {
	      return (unsigned_operation
		      ? builtin_type_unsigned_int
		      : builtin_type_int);
	    }
	  else if (result_len <= TYPE_LENGTH (builtin_type_long))
	    {
	      return (unsigned_operation
		      ? builtin_type_unsigned_long
		      : builtin_type_long);
	    }
	  else
	    {
	      return (unsigned_operation
		      ? builtin_type_unsigned_long_long
		      : builtin_type_long_long);
	    }

	default:
	  /* For other languages the result type is unchanged from gdb
	     version 6.7 for backward compatibility.
	     If either arg was long long, make sure that value is also long
	     long.  Otherwise use long.  */
	  if (unsigned_operation)
	    {
	      if (result_len > gdbarch_long_bit (current_gdbarch) / HOST_CHAR_BIT)
		return builtin_type_unsigned_long_long;
	      else
		return builtin_type_unsigned_long;
	    }
	  else
	    {
	      if (result_len > gdbarch_long_bit (current_gdbarch) / HOST_CHAR_BIT)
		return builtin_type_long_long;
	      else
		return builtin_type_long;
	    }
	}
    }

  return NULL; /* avoid -Wall warning */
}

d877 9
a885 1
  struct type *result_type;
d890 10
a899 1
  result_type = binop_result_type (op, value_type (arg1), value_type (arg2));
d901 2
a902 1
  if (TYPE_CODE (result_type) == TYPE_CODE_DECFLOAT)
d925 11
d938 2
a939 1
  else if (TYPE_CODE (result_type) == TYPE_CODE_FLT)
d985 11
d999 2
a1000 1
  else if (TYPE_CODE (result_type) == TYPE_CODE_BOOL)
d1032 2
d1042 18
a1059 1
      int unsigned_operation = TYPE_UNSIGNED (result_type);
d1061 1
a1061 1
      if (unsigned_operation)
a1062 1
	  unsigned int len1, len2, result_len;
a1067 15
	  /* Truncate values to the type length of the result.
	     Things are mildly tricky because binop_result_type may
	     return a long which on amd64 is 8 bytes, and that's a problem if
	     ARG1, ARG2 are both <= 4 bytes: we need to truncate the values
	     at 4 bytes not 8.  So fetch the lengths of the original types
	     and truncate at the larger of the two.  */
	  len1 = TYPE_LENGTH (value_type (arg1));
	  len2 = TYPE_LENGTH (value_type (arg1));
	  result_len = len1 > len2 ? len1 : len2;
	  if (result_len < sizeof (ULONGEST))
	    {
	      v1 &= ((LONGEST) 1 << HOST_CHAR_BIT * result_len) - 1;
	      v2 &= ((LONGEST) 1 << HOST_CHAR_BIT * result_len) - 1;
	    }

d1491 2
a1492 1
  struct type *result_type;
a1495 1
  result_type = unop_result_type (UNOP_PLUS, value_type (arg1));
d1498 1
a1498 1
    return value_from_double (result_type, value_as_double (arg1));
d1500 1
a1500 1
    return value_from_decfloat (result_type, value_contents (arg1));
d1503 1
a1503 1
      return value_from_longest (result_type, value_as_long (arg1));
d1516 2
a1517 1
  struct type *result_type;
a1520 1
  result_type = unop_result_type (UNOP_NEG, value_type (arg1));
d1524 1
a1524 1
      struct value *val = allocate_value (result_type);
d1539 1
a1539 1
    return value_from_double (result_type, -value_as_double (arg1));
d1542 1
a1542 1
      return value_from_longest (result_type, -value_as_long (arg1));
d1555 2
a1556 1
  struct type *result_type;
a1559 1
  result_type = unop_result_type (UNOP_COMPLEMENT, value_type (arg1));
d1564 1
a1564 1
  return value_from_longest (result_type, ~value_as_long (arg1));
@


1.62
log
@	* language.h (struct language_arch_info): New members
	bool_type_default and bool_type_symbol.
	(lang_bool_type): Remove prototype.
	(LA_BOOL_TYPE): Remove macro.
	(language_bool_type): Add prototype.
	* language.c (lang_bool_type): Remove.
	(language_bool_type): New function.

	* value.h (value_in): Change return value to int.
	* value.c (value_in): Return int instead of struct value *.

	* eval.c (evaluate_subexp_standard): Call language_bool_type instead
	of using LA_BOOL_TYPE.  Update call to value_in.
	* ada-lang.c (ada_evaluate_subexp): Call language_bool_type instead
	of using LA_BOOL_TYPE or builtin_type_int for boolean values.

	* language.c (unknown_language_arch_info): Set bool_type_default member
	of struct language_arch_info.
	* ada-lang.c (ada_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
	* c-lang.c (c_language_arch_info): Set bool_type_default member
	of struct language_arch_info.
	(cplus_language_arch_info): Set bool_type_symbol and bool_type_default
	members of struct language_arch_info.
	* f-lang.c (f_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
	* jv-lang.c (java_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
	* m2-lang.c (m2_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
	* p-lang.c (p_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
@
text
@d53 1
a53 1
   helper for value_sub & value_add.
d62 1
d88 3
d92 1
a92 1
value_add (struct value *arg1, struct value *arg2)
d94 1
a94 2
  struct value *valint;
  struct value *valptr;
a95 1
  struct type *type1, *type2, *valptrtype;
d98 13
a110 3
  arg2 = coerce_array (arg2);
  type1 = check_typedef (value_type (arg1));
  type2 = check_typedef (value_type (arg2));
d112 5
a116 20
  if ((TYPE_CODE (type1) == TYPE_CODE_PTR
       || TYPE_CODE (type2) == TYPE_CODE_PTR)
      &&
      (is_integral_type (type1) || is_integral_type (type2)))
    /* Exactly one argument is a pointer, and one is an integer.  */
    {
      struct value *retval;

      if (TYPE_CODE (type1) == TYPE_CODE_PTR)
	{
	  valptr = arg1;
	  valint = arg2;
	  valptrtype = type1;
	}
      else
	{
	  valptr = arg2;
	  valint = arg1;
	  valptrtype = type2;
	}
d118 3
a120 1
      sz = find_size_for_pointer_math (valptrtype);
d122 2
a123 5
      retval = value_from_pointer (valptrtype,
				   value_as_address (valptr)
				   + (sz * value_as_long (valint)));
      return retval;
    }
d125 3
a127 1
  return value_binop (arg1, arg2, BINOP_ADD);
d130 5
a134 2
struct value *
value_sub (struct value *arg1, struct value *arg2)
d137 2
d144 2
a145 6
  if (TYPE_CODE (type1) == TYPE_CODE_PTR)
    {
      if (is_integral_type (type2))
	{
	  /* pointer - integer.  */
	  LONGEST sz = find_size_for_pointer_math (type1);
d147 3
a149 17
	  return value_from_pointer (type1,
				     (value_as_address (arg1)
				      - (sz * value_as_long (arg2))));
	}
      else if (TYPE_CODE (type2) == TYPE_CODE_PTR
	       && TYPE_LENGTH (check_typedef (TYPE_TARGET_TYPE (type1)))
	       == TYPE_LENGTH (check_typedef (TYPE_TARGET_TYPE (type2))))
	{
	  /* pointer to <type x> - pointer to <type x>.  */
	  LONGEST sz = TYPE_LENGTH (check_typedef (TYPE_TARGET_TYPE (type1)));
	  return value_from_longest
	    (builtin_type_long,	/* FIXME -- should be ptrdiff_t */
	     (value_as_long (arg1) - value_as_long (arg2)) / sz);
	}
      else
	{
	  error (_("\
a151 2
	}
    }
d153 2
a154 1
  return value_binop (arg1, arg2, BINOP_SUB);
d203 2
a204 2
	  bound = value_from_longest (builtin_type_int, (LONGEST) lowerbound);
	  idx = value_sub (idx, bound);
d211 1
a211 1
    return value_ind (value_add (array, idx));
d1163 1
a1163 1
   use value_add or value_sub if you want to handle those possibilities.  */
@


1.61
log
@	* value.h (value_bitstring_subscript): New prototype.
	* valarith.h (value_bitstring_subscript): New function.
	(value_subscript): No longer handle TYPE_CODE_BITSTRING.
	* eval.c (evaluate_subexp_standard): Call value_bitstring_subscript
	instead of value_subscript to handle TYPE_CODE_BITSTRING.
@
text
@d1854 1
a1854 1
struct value *
d1873 1
a1873 1
  return value_from_longest (LA_BOOL_TYPE, member);
@


1.60
log
@	* ada-lang.c (ada_value_primitive_packed_val): Only check
	value_lazy for memory lvals.
	* findvar.c (value_of_register_lazy): New function.
	(locate_var_value): Only check value_lazy for memory lvals.
	* valarith.c (value_subscripted_rvalue): Likewise.
	* valops.c (value_fetch_lazy): Handle both memory and register
	lvals.
	(search_struct_field, value_slice): Only check value_lazy for memory
	lvals.
	* value.c (struct value): Update comment for lazy.
	(value_primitive_field): Only check value_lazy for memory lvals.
	* value.h (value_lazy): Update comment.
	(value_of_register_lazy): Declare.
@
text
@d174 5
a225 28
  if (TYPE_CODE (tarray) == TYPE_CODE_BITSTRING)
    {
      struct type *range_type = TYPE_INDEX_TYPE (tarray);
      LONGEST index = value_as_long (idx);
      struct value *v;
      int offset, byte, bit_index;
      LONGEST lowerbound, upperbound;
      get_discrete_bounds (range_type, &lowerbound, &upperbound);
      if (index < lowerbound || index > upperbound)
	error (_("bitstring index out of range"));
      index -= lowerbound;
      offset = index / TARGET_CHAR_BIT;
      byte = *((char *) value_contents (array) + offset);
      bit_index = index % TARGET_CHAR_BIT;
      byte >>= (gdbarch_bits_big_endian (current_gdbarch) ?
		TARGET_CHAR_BIT - 1 - bit_index : bit_index);
      v = value_from_longest (LA_BOOL_TYPE, byte & 1);
      set_value_bitpos (v, bit_index);
      set_value_bitsize (v, 1);
      VALUE_LVAL (v) = VALUE_LVAL (array);
      if (VALUE_LVAL (array) == lval_internalvar)
	VALUE_LVAL (v) = lval_internalvar_component;
      VALUE_ADDRESS (v) = VALUE_ADDRESS (array);
      VALUE_FRAME_ID (v) = VALUE_FRAME_ID (array);
      set_value_offset (v, offset + value_offset (array));
      return v;
    }

d266 46
@


1.59
log
@
	* eval.c (evaluate_subexp_standard): Use value_subscripted_rvalue for
	multi_f77_subscript to support values from registers.
	* valarith.c (value_subscripted_rvalue): Remove prototype and static.
	* value.h (value_subscripted_rvalue): Add prototype.

	* f-typeprint.c (f_type_print_base): Add support for TYPE_CODE_UNION.
	Fix output.
	* f-valprint.c (f_val_print): Likewise.
@
text
@d273 1
a273 1
  if (value_lazy (array))
@


1.58
log
@	* eval.c (evaluate_subexp_standard): Fix type of result of mixed
	integer/float division operations when EVAL_AVOID_SIDE_EFFECTS.
	* valops.c (value_one): New function.
	* value.h (value_one): Declare.

	Fix argument promotion for binary arithmetic ops for C.
	* valarith.c (unop_result_type): New fn.
	(binop_result_type): New fn.
	(value_binop): Move result type computation to binop_result_type.
	(value_pos, value_neg, value_complement): Move result type
	computation to unop_result_type.

	* gdb.base/whatis-exp.exp: Fix expected result of whatis x+y, x-y, x*y.
@
text
@a41 1
static struct value *value_subscripted_rvalue (struct value *, struct value *, int);
d259 1
a259 1
static struct value *
@


1.57
log
@	* valarith.c (value_binop): Handle unsigned BINOP_REM division by zero.
@
text
@d43 3
d748 287
d1163 1
a1163 1
  struct type *type1, *type2;
a1166 2
  type1 = check_typedef (value_type (arg1));
  type2 = check_typedef (value_type (arg2));
d1168 1
a1168 6
  if ((TYPE_CODE (type1) != TYPE_CODE_FLT
       && TYPE_CODE (type1) != TYPE_CODE_DECFLOAT && !is_integral_type (type1))
      ||
      (TYPE_CODE (type2) != TYPE_CODE_FLT
       && TYPE_CODE (type2) != TYPE_CODE_DECFLOAT && !is_integral_type (type2)))
    error (_("Argument to arithmetic operation not a number or boolean."));
d1170 1
a1170 3
  if (TYPE_CODE (type1) == TYPE_CODE_DECFLOAT
      ||
      TYPE_CODE (type2) == TYPE_CODE_DECFLOAT)
d1193 1
a1193 13
      if (TYPE_CODE (type1) != TYPE_CODE_DECFLOAT)
	/* If arg1 is not a decimal float, the type of the result is the type
	   of the decimal float argument, arg2.  */
	v_type = type2;
      else if (TYPE_CODE (type2) != TYPE_CODE_DECFLOAT)
	/* Same logic, for the case where arg2 is not a decimal float.  */
	v_type = type1;
      else
	/* len_v is equal either to len_v1 or to len_v2.  the type of the
	   result is the type of the argument with the same length as v.  */
	v_type = (len_v == len_v1)? type1 : type2;

      val = value_from_decfloat (v_type, v);
d1195 1
a1195 3
  else if (TYPE_CODE (type1) == TYPE_CODE_FLT
	   ||
	   TYPE_CODE (type2) == TYPE_CODE_FLT)
d1203 1
d1241 1
a1241 9
      /* If either arg was long double, make sure that value is also long
         double.  */

      if (TYPE_LENGTH (type1) * 8 > gdbarch_double_bit (current_gdbarch)
	  || TYPE_LENGTH (type2) * 8 > gdbarch_double_bit (current_gdbarch))
	val = allocate_value (builtin_type_long_double);
      else
	val = allocate_value (builtin_type_double);

d1244 1
a1244 3
  else if (TYPE_CODE (type1) == TYPE_CODE_BOOL
	   &&
	   TYPE_CODE (type2) == TYPE_CODE_BOOL)
d1276 1
a1276 1
      val = allocate_value (type1);
d1278 1
a1278 1
			    TYPE_LENGTH (type1),
a1282 3
    /* FIXME:  Also mixed integral/booleans, with result an integer. */
    /* FIXME: This implements ANSI C rules (also correct for C++).
       What about FORTRAN and (the deleted) chill ?  */
d1284 1
a1284 48
      unsigned int promoted_len1 = TYPE_LENGTH (type1);
      unsigned int promoted_len2 = TYPE_LENGTH (type2);
      int is_unsigned1 = TYPE_UNSIGNED (type1);
      int is_unsigned2 = TYPE_UNSIGNED (type2);
      unsigned int result_len;
      int unsigned_operation;

      /* Determine type length and signedness after promotion for
         both operands.  */
      if (promoted_len1 < TYPE_LENGTH (builtin_type_int))
	{
	  is_unsigned1 = 0;
	  promoted_len1 = TYPE_LENGTH (builtin_type_int);
	}
      if (promoted_len2 < TYPE_LENGTH (builtin_type_int))
	{
	  is_unsigned2 = 0;
	  promoted_len2 = TYPE_LENGTH (builtin_type_int);
	}

      /* Determine type length of the result, and if the operation should
         be done unsigned.  For exponentiation and shift operators,
         use the length and type of the left operand.  Otherwise,
         use the signedness of the operand with the greater length.
         If both operands are of equal length, use unsigned operation
         if one of the operands is unsigned.  */
      if (op == BINOP_RSH || op == BINOP_LSH || op == BINOP_EXP)
	{
	  /* In case of the shift operators and exponentiation the type of
	     the result only depends on the type of the left operand.  */
	  unsigned_operation = is_unsigned1;
	  result_len = promoted_len1;
	}
      else if (promoted_len1 > promoted_len2)
	{
	  unsigned_operation = is_unsigned1;
	  result_len = promoted_len1;
	}
      else if (promoted_len2 > promoted_len1)
	{
	  unsigned_operation = is_unsigned2;
	  result_len = promoted_len2;
	}
      else
	{
	  unsigned_operation = is_unsigned1 || is_unsigned2;
	  result_len = promoted_len1;
	}
d1288 1
d1294 9
a1302 1
	  /* Truncate values to the type length of the result.  */
d1409 1
a1409 13
	  /* This is a kludge to get around the fact that we don't
	     know how to determine the result type from the types of
	     the operands.  (I'm not really sure how much we feel the
	     need to duplicate the exact rules of the current
	     language.  They can get really hairy.  But not to do so
	     makes it hard to document just what we *do* do).  */

	  /* Can't just call init_type because we wouldn't know what
	     name to give the type.  */
	  val = allocate_value
	    (result_len > gdbarch_long_bit (current_gdbarch) / HOST_CHAR_BIT
	     ? builtin_type_unsigned_long_long
	     : builtin_type_unsigned_long);
d1520 1
a1520 13
	  /* This is a kludge to get around the fact that we don't
	     know how to determine the result type from the types of
	     the operands.  (I'm not really sure how much we feel the
	     need to duplicate the exact rules of the current
	     language.  They can get really hairy.  But not to do so
	     makes it hard to document just what we *do* do).  */

	  /* Can't just call init_type because we wouldn't know what
	     name to give the type.  */
	  val = allocate_value
	    (result_len > gdbarch_long_bit (current_gdbarch) / HOST_CHAR_BIT
	     ? builtin_type_long_long
	     : builtin_type_long);
d1732 1
a1734 1

d1736 1
d1739 1
a1739 1
    return value_from_double (type, value_as_double (arg1));
d1741 1
a1741 1
    return value_from_decfloat (type, value_contents (arg1));
d1744 1
a1744 6
      /* Perform integral promotion for ANSI C/C++.  FIXME: What about
         FORTRAN and (the deleted) chill ?  */
      if (TYPE_LENGTH (type) < TYPE_LENGTH (builtin_type_int))
	type = builtin_type_int;

      return value_from_longest (type, value_as_long (arg1));
d1757 1
a1757 1
  struct type *result_type = value_type (arg1);
a1759 1

d1761 1
d1779 1
a1779 2

  if (TYPE_CODE (type) == TYPE_CODE_FLT)
a1782 5
      /* Perform integral promotion for ANSI C/C++.  FIXME: What about
         FORTRAN and (the deleted) chill ?  */
      if (TYPE_LENGTH (type) < TYPE_LENGTH (builtin_type_int))
	result_type = builtin_type_int;

d1796 1
a1796 1
  struct type *result_type = value_type (arg1);
a1798 1

d1800 1
a1804 5
  /* Perform integral promotion for ANSI C/C++.
     FIXME: What about FORTRAN ?  */
  if (TYPE_LENGTH (type) < TYPE_LENGTH (builtin_type_int))
    result_type = builtin_type_int;

@


1.56
log
@2008-01-30  Paul N. Hilfinger  <hilfinger@@adacore.com>

	* valarith.c (value_binop): Add floating-point BINOP_MIN and
	BINOP_MAX cases.
	For BINOP_EXP, use length and signedness of left operand only for
	result, as for shifts.
	For integral operands to BINOP_EXP, use new integer_pow and
	uinteger_pow functions so as to get full range of results.
	(integer_pow): New function.
	(uinteger_pow): New function.

2008-01-30  Paul N. Hilfinger  <hilfinger@@adacore.com>

	* gdb.ada/exprs: New test program.
	* gdb.ada/exprs.exp: New testcase.
@
text
@d1119 4
a1122 1
	      v = v1 % v2;
@


1.55
log
@	* valarith.c (value_binop): Handle unsigned integer
	division by zero.
@
text
@d746 60
d961 8
d1050 3
a1052 2
         be done unsigned.
         Use the signedness of the operand with the greater length.
d1055 1
a1055 1
      if (op == BINOP_RSH || op == BINOP_LSH)
d1057 2
a1058 2
	  /* In case of the shift operators the type of the result only
	     depends on the type of the left operand.  */
d1080 1
d1083 1
a1083 1
	  v2 = (ULONGEST) value_as_long (arg2);
d1115 1
a1115 4
	      errno = 0;
	      v = pow (v1, v2);
	      if (errno)
		error (_("Cannot perform exponentiation: %s"), safe_strerror (errno));
d1235 1
a1235 4
	      errno = 0;
	      v = pow (v1, v2);
	      if (errno)
		error (_("Cannot perform exponentiation: %s"), safe_strerror (errno));
@


1.54
log
@	* gdbarch.sh (function_list): Add new property bits_big_endian to
	gdbarch structure.
	* gdbarch.{c,h}: Regenerate.

	* value.c (struct value): Replace BITS_BIG_ENDIAN by
	gdbarch_bits_big_endian (comment).
	(unpack_field_as_long, modify_field): Likewise.
	* value.h: Likewise (comment).
	* valops.c (value_slice): Likewise.
	* valarith.c (value_subscript, value_bit_index): Likewise.
	* gdbtypes.h (field): Likewise (comment).
	* eval.c (evaluate_subexp_standard): Likewise.
	* dwarf2read.c (dwarf2_add_field): Likewise.
	* ada-lang.c (decode_packed_array, ada_value_primitive_packed_val)
	(move_bits, ada_value_assign, value_assign_to_component): Likewise.

	* defs.h (BITS_BIG_ENDIAN): Remove.



	* gdbint.texinfo (Target Conditionals): Replace the description of
	BITS_BIG_ENDIAN with a description of gdbarch_bits_big_endian.
@
text
@d1038 4
a1041 1
	      v = v1 / v2;
@


1.53
log
@	* valarith.c (value_binop): Handle BINOP_INTDIV
	for unsigned and signed integers.
@
text
@d233 2
a234 1
      byte >>= (BITS_BIG_ENDIAN ? TARGET_CHAR_BIT - 1 - bit_index : bit_index);
d1579 1
a1579 1
  if (BITS_BIG_ENDIAN)
@


1.52
log
@	* Makefile.in (dfp.o): Depend on expression.h, gdbtypes.h and value.h.
	(valarith.o): Depend on dfp.h.
	(valops.o): Likewise.
	* dfp.c: Include expression.h, gdbtypes.h, value.h and dfp.h.
	(set_decnumber_context): New function.
	(decimal_check_errors): Likewise.
	(decimal_from_number): Likewise.
	(decimal_to_number): Likewise.
	(decimal_from_string): Use set_decnumber_context and
	decimal_check_errors.
	(decimal_from_integral): New function.
	(decimal_from_floating): Likewise.
	(decimal_to_double): Likewise.
	(promote_decimal): Likewise.
	(decimal_binop): Likewise.
	(decimal_is_zero): Likewise.
	(decimal_compare): Likewise.
	(decimal_convert): Likewise.
	* dfp.h (decimal_from_integral): New prototype.
	(decimal_from_floating): Likewise.
	(decimal_to_double): Likewise.
	(decimal_binop): Likewise.
	(decimal_is_zero): Likewise.
	(decimal_compare): Likewise.
	(decimal_convert): Likewise.
	* eval.c (evaluate_subexp_standard): Remove expect_type argument from
	call to value_from_decfloat.
	* valarith.c: Include dfp.h.
	(value_args_as_decimal): New function.
	(value_binop): Add if block to handle TYPE_CODE_DECFLOAT values.
	(value_logical_not): Likewise.
	(value_equal): Likewise.
	(value_less): Likewise.
	(value_pos): Likewise.
	(value_neg): Formatting fix.
	* valops.c: Include dfp.h.
	(value_cast): Add if block to handle TYPE_CODE_DECFLOAT values.
	* value.c (unpack_long): Add case to handle TYPE_CODE_DECFLOAT.
	(unpack_double): Add if block to handle TYPE_CODE_DECFLOAT.
	(value_from_decfloat): Remove expect_type argument.
	* value.h (value_from_decfloat): Update prototype.
@
text
@d1036 1
d1156 1
@


1.51
log
@	Updated copyright notices for most files.
@
text
@d31 1
d745 56
d819 2
a820 1
  if ((TYPE_CODE (type1) != TYPE_CODE_FLT && !is_integral_type (type1))
d822 2
a823 1
      (TYPE_CODE (type2) != TYPE_CODE_FLT && !is_integral_type (type2)))
d826 1
a826 1
  if (TYPE_CODE (type1) == TYPE_CODE_FLT
d828 40
a867 1
      TYPE_CODE (type2) == TYPE_CODE_FLT)
d1278 2
d1358 10
d1432 10
d1473 2
d1507 1
a1507 1
      memcpy(decbytes, value_contents(arg1), len);
@


1.50
log
@2007-10-25  Wu Zhou  <woodzltc@@cn.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* c-exp.y (YYSTYPE): Add typed_val_decfloat for decimal
	floating point in YYSTYPE union.
	(DECFLOAT) Add token and expression element handling code.
	(parse_number): Parse DFP constants, which end with suffix 'df',
	'dd' or 'dl'.  Return DECFLOAT.
	* eval.c (evaluate_subexp_standard): Call value_from_decfloat to
	handle OP_DECFLOAT.
	* expression.h (enum exp_opcode): Add an opcode (OP_DECFLOAT)
	for DFP constants.
	(union exp_element): Add decfloatconst to represent DFP
	elements, which is 16 bytes by default.
	* parse.c (write_exp_elt_decfloatcst): New function to write a
	decimal float const into the expression.
	(operator_length_standard): Set operator length for OP_DECFLOAT
	to 4.
	* parser-defs.h (write_exp_elt_decfloatcst): Prototype.
	* valarith.c (value_neg): Add code to handle the negation
	operation of DFP values.
	* value.c (value_from_decfloat): New function to get the value
	from a decimal floating point.
	* value.h (value_from_decfloat): Prototype.
@
text
@d4 1
a4 1
   1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007
@


1.49
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d1379 17
@


1.48
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_FLOAT_BIT): Replace by gdbarch_float_bit.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* mdebugread.c (_initialize_mdebugread): Likewise.
	* m2-lang.c (m2_create_fundamental_type)
	(_initialize_m2_language): Likewise.
	* gdbtypes.c (build_gdbtypes): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbarch.sh (TARGET_FLOAT_FORMAT): Replace by gdbarch_float_format.
	* value.c (unpack_double): Likewise (comment).
	* gdbtypes.c (build_gdbtypes): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* gdbarch.sh (TARGET_DOUBLE_BIT): Replace by gdbarch_double_bit.
	* valarith.c (value_binop): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* mdebugread.c (_initialize_mdebugread): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* gdbtypes.c (build_gdbtypes): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* cris-tdep.c (cris_gdbarch_init): Likewise (comment).
	* c-lang.c (c_create_fundamental_type): Likewise.
	* ada-lex.l (processReal): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbarch.sh (TARGET_DOUBLE_FORMAT): Replace by gdbarch_double_format.
	* value.c (unpack_double): Likewise (comment).
	* gdbtypes.c (build_gdbtypes): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* gdbarch.sh (TARGET_LONG_DOUBLE_BIT): Replace by
	gdbarch_long_double_bit.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* gdbtypes.c (build_gdbtypes): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* ada-lex.l (processReal): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbarch.sh (TARGET_LONG_DOUBLE_FORMAT): Replace by
	gdbarch_long_double_format.
	* gdbtypes.c (build_gdbtypes): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.47
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_SHORT_BIT): Replace by gdbarch_int_bit.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* gdbarch.sh (TARGET_INT_BIT): Replace by gdbarch_int_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type, ada_language_arch_info)
	(gdbtypes_post_init, build_gdbtypes): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* parse.c (build_parse): Likewise.
	* xcoffread.c (_initialize_xcoffread): Likewise.
	* stabsread.c (define_symbol, read_one_struct_field, read_enum_type)
	(read_range_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* f-lang.c (build_fortran_types, f_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type, _initialize_m2_language)
	(m2_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (coff_read_enum_type): Likewise.
	* mdebugread.c (parse_symbol, _initialize_mdebugread): Likewise.
	* dwarf2read.c (new_symbol): Likewise.
	* gdbarch.sh (TARGET_LONG_BIT): Replace by gdbarch_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* valarith.c (value_binop): Likewise.
	* symfile.c (read_target_long_array, simple_overlay_update_1): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* symfile.c (TARGET_LONG_BYTES): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (decode_base_type): Likewise.
	* gdbarch.sh (TARGET_LONG_LONG_BIT): Replace by gdbarch_long_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (gdbtypes_post_init, build_gdbtypes): Likewise.
	* stabsread.c (read_range_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d811 2
a812 2
      if (TYPE_LENGTH (type1) * 8 > TARGET_DOUBLE_BIT
	  || TYPE_LENGTH (type2) * 8 > TARGET_DOUBLE_BIT)
@


1.46
log
@Copyright updates for 2007.
@
text
@d1031 1
a1031 1
	    (result_len > TARGET_LONG_BIT / HOST_CHAR_BIT
d1156 1
a1156 1
	    (result_len > TARGET_LONG_BIT / HOST_CHAR_BIT
@


1.45
log
@2006-01-24  Jim Blandy  <jimb@@redhat.com>

	* valarith.c (binop_user_defined_p): Handle refs to typedefs.
@
text
@d3 2
a4 2
   Copyright (C) 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
@


1.44
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d288 3
a290 3
/* Check to see if either argument is a structure.  This is called so
   we know whether to go ahead with the normal binop or look for a 
   user defined function instead.
d300 1
d302 3
d306 3
d310 1
a310 5
	  || TYPE_CODE (type2) == TYPE_CODE_STRUCT
	  || (TYPE_CODE (type1) == TYPE_CODE_REF
	      && TYPE_CODE (TYPE_TARGET_TYPE (type1)) == TYPE_CODE_STRUCT)
	  || (TYPE_CODE (type2) == TYPE_CODE_REF
	      && TYPE_CODE (TYPE_TARGET_TYPE (type2)) == TYPE_CODE_STRUCT));
@


1.43
log
@* valarith.c (value_equal, value_less): Avoid compiler bug on
systems where `long double' values are returned in static storage.
@
text
@d3 1
a3 1
   Copyright 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.42
log
@	PR exp/1978
	* valarith.c (value_binop): Fix result type for the shift
	operators.
@
text
@d4 2
a5 2
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free
   Software Foundation, Inc.
d1251 6
a1256 1
    return value_as_double (arg1) == value_as_double (arg2);
d1315 6
a1320 1
    return value_as_double (arg1) < value_as_double (arg2);
@


1.41
log
@	* f-exp.y (yyparse): Add code to support exponentiation expression.
	(yylex): Add code to scan exponentiation operator.
	* eval.c (evaluate_subexp_standard): Add support for BINOP_EXP.
	* valarith.c (value_binop): Reset errno to 0 before calling pow
	to do exponentiation operation.
@
text
@d886 8
a893 1
      if (promoted_len1 > promoted_len2)
@


1.40
log
@2005-05-09  Andrew Cagney  <cagney@@gnu.org>

	Use gdb_byte in preference to bfd_byte.
	* gdbarch.sh: Update.
	* gdbarch.h, gdbarch.c: Re-generate.
	* ada-lang.c, ada-lang.h, ada-valprint.c, arch-utils.c: Update.
	* c-lang.c, c-lang.h, c-valprint.c, cp-valprint.c: Update.
	* f-lang.c, f-lang.h, f-valprint.c, gdbcore.h, jv-lang.h: Update.
	* jv-valprint.c, language.c, language.h, m2-lang.c: Update.
	* m2-lang.h, m2-valprint.c, objc-lang.c, p-lang.c: Update.
	* p-lang.h, p-valprint.c, regcache.c, scm-lang.c: Update.
	* scm-lang.h, scm-valprint.c, target.c, target.h: Update.
	* tramp-frame.c, valarith.c, valops.c, valprint.c: Update.
	* valprint.h, value.c, value.h: Update.
@
text
@d794 6
a799 5
        case BINOP_EXP:
          v = pow (v1, v2);
          if (errno)
            error (_("Cannot perform exponentiation: %s"), safe_strerror (errno));
          break;
d933 6
a938 5
            case BINOP_EXP:
              v = pow (v1, v2);
              if (errno)
                error (_("Cannot perform exponentiation: %s"), safe_strerror (errno));
              break;
d1055 5
a1059 4
            case BINOP_EXP:
              v = pow (v1, v2);
              if (errno)
                error (_("Cannot perform exponentiation: %s"), safe_strerror (errno));
@


1.39
log
@	* ax-gdb.c (gen_expr): Add UNOP_PLUS case.
	* c-exp.y (exp): Add unary plus.
	* eval.c (evaluate_subexp_standard): Add UNOP_PLUS case.
	* valarith.c (value_x_unop): Add UNOP_PLUS case.
	(value_pos): New.
	* value.h (value_pos): Declare.

	* gdb.cp/userdef.cc (A1::operator+): New unary plus.
	(A2): New class.
	(main): Test operator+.
	* gdb.cp/userdef.exp: Test unary plus.  Use A2::operator+ for
	breakpoint test.
@
text
@d1161 1
a1161 1
  const bfd_byte *p;
d1190 2
a1191 2
  const bfd_byte *s1 = value_contents (arg1);
  const bfd_byte *s2 = value_contents (arg2);
d1219 2
a1220 2
  const bfd_byte *p1;
  const bfd_byte *p2;
d1402 1
a1402 1
value_bit_index (struct type *type, const bfd_byte *valaddr, int index)
@


1.38
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d563 3
d1319 28
a1346 1
/* The unary operators - and ~.  Both free the argument ARG1.  */
@


1.37
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.c (set_value_bitpos, set_value_bitsize): Define.
	* value.h (set_value_bitpos, set_value_bitsize): Declare.
	* ada-lang.c, valarith.c: Update.
@
text
@d76 2
a77 2
	    error ("Cannot perform pointer math on incomplete types, "
		   "try casting to a known type, or void *.");
d79 2
a80 2
	    error ("Cannot perform pointer math on incomplete type \"%s\", "
		   "try casting to a known type, or void *.", name);
d163 1
a163 1
	  error ("\
d165 1
a165 1
an integer nor a pointer of the same type.");
d206 1
a206 1
	    warning ("array or string index out of range");
d229 1
a229 1
	error ("bitstring index out of range");
d250 1
a250 1
    error ("not an array or string");
d268 1
a268 1
    error ("no such vector element");
d361 1
a361 1
    error ("Can't do that binary op on that type");	/* FIXME be explicit */
d447 1
a447 1
	  error ("Invalid binary operation specified.");
d473 1
a473 1
      error ("Invalid binary operation specified.");
d494 1
a494 1
  error ("member function %s not found", tstr);
d521 1
a521 1
    error ("Can't do that unary op on that type");	/* FIXME be explicit */
d567 1
a567 1
      error ("Invalid unary operation specified.");
d589 1
a589 1
  error ("member function %s not found", tstr);
d682 1
a682 1
	  error ("unimplemented support for bitstring/boolean repeats");
d686 1
a686 1
	  error ("can't repeat values of that type");
d696 1
a696 1
	  error ("Strings can only be concatenated with other strings.");
d727 1
a727 1
	  error ("Bitstrings or booleans can only be concatenated with other bitstrings or booleans.");
d729 1
a729 1
      error ("unimplemented support for bitstring/boolean concatenation.");
d734 1
a734 1
      error ("illegal operands for concatenation.");
d761 1
a761 1
    error ("Argument to arithmetic operation not a number or boolean.");
d794 1
a794 1
            error ("Cannot perform exponentiation: %s", safe_strerror (errno));
d798 1
a798 1
	  error ("Integer-only operation on floating point number.");
d843 1
a843 1
	  error ("Invalid operation on booleans.");
d932 1
a932 1
                error ("Cannot perform exponentiation: %s", safe_strerror (errno));
d1003 1
a1003 1
	      error ("Invalid binary operation on numbers.");
d1047 1
a1047 1
		error ("Division by zero");
d1053 1
a1053 1
                error ("Cannot perform exponentiation: %s", safe_strerror (errno));
d1060 1
a1060 1
		error ("Division by zero");
d1127 1
a1127 1
	      error ("Invalid binary operation on numbers.");
d1266 1
a1266 1
      error ("Invalid type combination in equality test.");
d1311 1
a1311 1
      error ("Invalid type combination in ordering comparison.");
d1341 1
a1341 1
      error ("Argument to negate operation not a number.");
d1357 1
a1357 1
    error ("Argument to complement operation not an integer or boolean.");
d1400 1
a1400 1
    error ("Second argument of 'IN' has wrong type");
d1405 1
a1405 1
    error ("First argument of 'IN' has wrong type");
d1409 1
a1409 1
    error ("First argument of 'IN' not in range");
@


1.36
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (set_value_offset): Declare.
	* value.c (set_value_offset): Declare.
	* gnu-v2-abi.c, jv-valprint.c, valarith.c, valops.c: Update.
	* findvar.c: Update.
@
text
@d236 2
a237 2
      v->bitpos = bit_index;
      v->bitsize = 1;
@


1.35
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_LAZY): Delete
	(set_value_lazy): Declare.
	* value.c (set_value_lazy): Define.
	* valops.c, valarith.c, jv-valprint.c, jv-lang.c: Update.
	* gnu-v2-abi.c, findvar.c, dwarf2loc.c, ada-lang.c: Update.
@
text
@d243 1
a243 1
      v->offset = offset + value_offset (array);
d284 1
a284 1
  v->offset = value_offset (array) + elt_offs;
@


1.34
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d272 1
a272 1
    VALUE_LAZY (v) = 1;
@


1.33
log
@2005-02-02  Andrew Cagney  <cagney@@gnu.org>

	* value.h (value_lazy): Declare.
	* varobj.c, value.c, valops.c, valarith.c, printcmd.c: Update.
	* cp-valprint.c, breakpoint.c, ada-lang.c: Update.
@
text
@d232 1
a232 1
      byte = *((char *) VALUE_CONTENTS (array) + offset);
d274 2
a275 1
    memcpy (VALUE_CONTENTS (v), VALUE_CONTENTS (array) + elt_offs, elt_size);
d663 1
a663 1
					   VALUE_CONTENTS (inval2));
d673 1
a673 1
		  memcpy (ptr + (idx * inval2len), VALUE_CONTENTS (inval2),
d703 1
a703 1
	  *ptr = (char) unpack_long (type1, VALUE_CONTENTS (inval1));
d707 1
a707 1
	  memcpy (ptr, VALUE_CONTENTS (inval1), inval1len);
d712 1
a712 1
	    (char) unpack_long (type2, VALUE_CONTENTS (inval2));
d716 1
a716 1
	  memcpy (ptr + inval1len, VALUE_CONTENTS (inval2), inval2len);
d1158 1
a1158 1
  char *p;
d1168 1
a1168 1
  p = VALUE_CONTENTS (arg1);
d1187 2
a1188 2
  char *s1 = VALUE_CONTENTS (arg1);
  char *s2 = VALUE_CONTENTS (arg2);
d1216 2
a1217 1
  char *p1, *p2;
d1251 2
a1252 2
      p1 = VALUE_CONTENTS (arg1);
      p2 = VALUE_CONTENTS (arg2);
d1368 1
a1368 1
   and whose VALUE_CONTENTS is valaddr.
d1406 1
a1406 1
  member = value_bit_index (settype, VALUE_CONTENTS (set),
@


1.32
log
@2005-02-01  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents_all_raw)
	(value_contents_raw): New functions.
	* value.h (VALUE_CONTENTS_ALL_RAW, VALUE_CONTENTS_RAW): Delete.
	(value_contents_raw, value_contents_all_raw): Declare functions.
	(VALUE_CONTENTS, VALUE_CONTENTS_ALL): Update.
	* std-regs.c, valarith.c, valops.c, eval.c: Update.
	* tracepoint.c, findvar.c: Update.
@
text
@d271 1
a271 1
  if (VALUE_LAZY (array))
@


1.31
log
@2005-01-28  Andrew Cagney  <cagney@@gnu.org>

	* value.h (value_bit_index, print_floating)
	(find_rt_vbase_offset): Make buffer a const bfd_byte.
	* valprint.c (print_floating): Update.
	* valarith.c (value_bit_index): Update.
	* valops.c (find_rt_vbase_offset): Update.
@
text
@d4 2
a5 2
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d809 1
a809 1
      store_typed_floating (VALUE_CONTENTS_RAW (val), value_type (val), v);
d846 1
a846 1
      store_signed_integer (VALUE_CONTENTS_RAW (val),
d1018 1
a1018 1
	  store_unsigned_integer (VALUE_CONTENTS_RAW (val),
d1142 1
a1142 1
	  store_signed_integer (VALUE_CONTENTS_RAW (val),
@


1.30
log
@	* valarith.c (value_subscript): Copy VALUE_FRAME_ID.
	(value_subscripted_rvalue): Likewise.
	* valops.c (search_struct_field, value_slice): Likewise.
@
text
@d1370 1
a1370 1
value_bit_index (struct type *type, char *valaddr, int index)
@


1.29
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	Merge VALUE_REGNO and VALUE_FRAME_REGNUM into VALUE_REGNUM.
	* value.h (VALUE_REGNO, VALUE_FRAME_REGNUM): Delete.
	(VALUE_REGNUM): Define.
	(struct value): Delete location.regnum, rename "regno" to
	"regnum".
	* value.c, valops.c, valarith.c, findvar.c: Update.
@
text
@d242 1
d282 1
@


1.28
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_TYPE, VALUE_NEXT, VALUE_OFFSET, VALUE_BITSIZE)
	(VALUE_BITPOS): Delete.
	(value_type, value_offset, value_bitsize, value_bitpos): Declare.
	* value.c (value_type, value_offset, value_bitpos)
	(value_bitsize): New functions.  Update references.
	* arm-tdep.c, gnu-v3-abi.c, hpacc-abi.c, gnu-v2-abi.c: Update.
	* f-valprint.c, cp-valprint.c, c-valprint.c: Update.
	* ada-valprint.c, typeprint.c, scm-valprint.c, scm-exp.c: Update.
	* p-valprint.c, jv-valprint.c, jv-lang.c, varobj.c: Update.
	* objc-lang.c, ada-lang.c, std-regs.c, stack.c: Update.
	* infcall.c, linespec.c, printcmd.c, valarith.c: Update.
	* valops.c, eval.c, findvar.c, breakpoint.c: Update.
	* tracepoint.c, ax-gdb.c, mi/mi-main.c, cli/cli-dump.c:
	* rs6000-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d280 1
a280 1
  VALUE_REGNO (v) = VALUE_REGNO (array);
@


1.27
log
@2004-11-10  Andrew Cagney  <cagney@@gnu.org>

	* value.h (COERCE_REF, COERCE_ARRAY, COERCE_NUMBER, COERCE_ENUM)
	(coerce_ref, coerce_array, coerce_number, coerce_enum): Replace
	macros with function declarations.
	* value.c (coerce_ref, coerce_array, coerce_number)
	(coerce_enum): New functions.
	(value_as_long, value_as_address): Update.
	* ada-lang.c (ada_coerce_ref, ada_value_binop)
	(ada_evaluate_subexp, ada_value_assign, ada_value_struct_elt): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* valarith.c (value_less, value_neg, value_complement)
	(value_binop, value_add, value_subscript, value_x_binop)
	(value_logical_not, value_sub): Update.
	* valops.c (check_field, value_struct_elt, value_ind)
	(value_find_oload_method_list, value_cast, value_assign): Update.
	* eval.c (evaluate_subexp_standard): Update.
@
text
@d96 2
a97 2
  type1 = check_typedef (VALUE_TYPE (arg1));
  type2 = check_typedef (VALUE_TYPE (arg2));
d137 2
a138 2
  type1 = check_typedef (VALUE_TYPE (arg1));
  type2 = check_typedef (VALUE_TYPE (arg2));
d186 1
a186 1
  tarray = check_typedef (VALUE_TYPE (array));
d236 2
a237 2
      VALUE_BITPOS (v) = bit_index;
      VALUE_BITSIZE (v) = 1;
d242 1
a242 1
      VALUE_OFFSET (v) = offset + VALUE_OFFSET (array);
d259 1
a259 1
  struct type *array_type = check_typedef (VALUE_TYPE (array));
d281 1
a281 1
  VALUE_OFFSET (v) = VALUE_OFFSET (array) + elt_offs;
d297 2
a298 2
  type1 = check_typedef (VALUE_TYPE (arg1));
  type2 = check_typedef (VALUE_TYPE (arg2));
d319 1
a319 1
  type1 = check_typedef (VALUE_TYPE (arg1));
d357 1
a357 1
  if (TYPE_CODE (check_typedef (VALUE_TYPE (arg1))) != TYPE_CODE_STRUCT)
d486 1
a486 1
	    = TYPE_TARGET_TYPE (check_typedef (VALUE_TYPE (argvec[0])));
d517 1
a517 1
  if (TYPE_CODE (check_typedef (VALUE_TYPE (arg1))) != TYPE_CODE_STRUCT)
d581 1
a581 1
	    = TYPE_TARGET_TYPE (check_typedef (VALUE_TYPE (argvec[0])));
d622 2
a623 2
  struct type *type1 = check_typedef (VALUE_TYPE (arg1));
  struct type *type2 = check_typedef (VALUE_TYPE (arg2));
d752 2
a753 2
  type1 = check_typedef (VALUE_TYPE (arg1));
  type2 = check_typedef (VALUE_TYPE (arg2));
d807 1
a807 1
      store_typed_floating (VALUE_CONTENTS_RAW (val), VALUE_TYPE (val), v);
d1017 1
a1017 1
				  TYPE_LENGTH (VALUE_TYPE (val)),
d1141 1
a1141 1
				TYPE_LENGTH (VALUE_TYPE (val)),
d1159 1
a1159 1
  type1 = check_typedef (VALUE_TYPE (arg1));
d1182 2
a1183 2
  int len1 = TYPE_LENGTH (VALUE_TYPE (arg1));
  int len2 = TYPE_LENGTH (VALUE_TYPE (arg2));
d1222 2
a1223 2
  type1 = check_typedef (VALUE_TYPE (arg1));
  type2 = check_typedef (VALUE_TYPE (arg2));
d1281 2
a1282 2
  type1 = check_typedef (VALUE_TYPE (arg1));
  type2 = check_typedef (VALUE_TYPE (arg2));
d1318 1
a1318 1
  struct type *result_type = VALUE_TYPE (arg1);
d1322 1
a1322 1
  type = check_typedef (VALUE_TYPE (arg1));
d1346 1
a1346 1
  struct type *result_type = VALUE_TYPE (arg1);
d1350 1
a1350 1
  type = check_typedef (VALUE_TYPE (arg1));
d1363 1
a1363 1
/* The INDEX'th bit of SET value whose VALUE_TYPE is TYPE,
d1391 2
a1392 2
  struct type *settype = check_typedef (VALUE_TYPE (set));
  struct type *eltype = check_typedef (VALUE_TYPE (element));
@


1.26
log
@2004-11-09  Andrew Cagney  <cagney@@gnu.org>

	* value.h (struct value): Delete field bfd_section.
	(VALUE_BFD_SECTION): Delete macro.
	(COERCE_REF): Update.
	(value_at, value_at_lazy): Delete asection parameter.
	* printcmd.c (print_formatted, x_command): Update.
	(do_examine): Delete asection parameter.
	(next_section): Delete variable.
	* valops.c (value_cast, value_at, value_at_lazy)
	(value_coerce_function, value_addr, value_ind, value_string)
	(find_rt_vbase_offset, value_full_object): Update.
	* hpacc-abi.c (hpacc_virtual_fn_field)
	(hpacc_value_rtti_type): Update.
	* gnu-v3-abi.c (gnuv3_rtti_type, gnuv3_virtual_fn_field)
	(gnuv3_baseclass_offset): Update.
	* f-valprint.c (f_val_print): Update.
	* c-valprint.c (c_val_print): Update.
	* p-valprint.c (pascal_val_print): Update.
	* jv-valprint.c (java_value_print): Update.
	* jv-lang.c (java_class_from_object, evaluate_subexp_java): Update.
	* ada-lang.c (ada_value_primitive_packed_val)
	(ada_evaluate_subexp): Update.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Update.
	* expprint.c (print_subexp_standard): Update.
	* infcall.c (call_function_by_hand): Update.
	* valarith.c (value_add): Update.
	* eval.c (evaluate_subexp_standard): Update.
	* values.c (allocate_value, value_copy, value_static_field): Update.
	* findvar.c (read_var_value, locate_var_value): Update.
@
text
@d94 2
a95 2
  COERCE_ARRAY (arg1);
  COERCE_ARRAY (arg2);
d135 2
a136 2
  COERCE_ARRAY (arg1);
  COERCE_ARRAY (arg2);
d185 1
a185 1
  COERCE_REF (array);
d349 4
a352 4
  COERCE_REF (arg1);
  COERCE_REF (arg2);
  COERCE_ENUM (arg1);
  COERCE_ENUM (arg2);
d511 2
a512 2
  COERCE_REF (arg1);
  COERCE_ENUM (arg1);
d750 2
a751 2
  COERCE_REF (arg1);
  COERCE_REF (arg2);
d1158 1
a1158 1
  COERCE_NUMBER (arg1);
d1219 2
a1220 2
  COERCE_ARRAY (arg1);
  COERCE_ARRAY (arg2);
d1278 2
a1279 2
  COERCE_ARRAY (arg1);
  COERCE_ARRAY (arg2);
d1320 1
a1320 1
  COERCE_REF (arg1);
d1348 1
a1348 1
  COERCE_REF (arg1);
@


1.25
log
@2004-11-02  Andrew Cagney  <cagney@@gnu.org>

	* value.h (COERCE_VARYING_ARRAY): Delete.
	* valops.c (value_cast, value_slice): Delete use.
	* valarith.c (value_subscript, value_concat): Delete use.
@
text
@a124 1
      VALUE_BFD_SECTION (retval) = VALUE_BFD_SECTION (valptr);
@


1.24
log
@
2004-09-20  Jeff Johnston  <jjohnstn@@redhat.com>

        * dwarf2read.c (typename_concat): Change prototype to accept obstack
        and dwarf2_cu struct pointer as arguments.  Change function to use
        obstack if provided and use dwarf2_cu to determine language-specific
        separator.
        (partial_die_parent_scope): Change comment to include java.  Use
        new version of typename_concat instead of obconcat.
        (partial_die_full_name): Use typename_concat.
        (read_namespace): Ditto.
        (read_enumeration_type): Use typename_concat instead of obconcat.
        (new_symbol): Ditto.
        (add_partial_symbol): Enhance tests for C++ to also test for Java.
        (guess_structure_name): Ditto.
        (read_subroutine_type): Ditto.
        (read_structure_type): Ditto.
        (is_vtable_name): Add Java support.
        (determine_class_name): Switch to new typename_concat call.
        (determine_prefix): Switch to new typename_concat call.
        * jv-exp.y (FuncStart): New pattern.
        (MethodInvocation): Add support for simple function calls.  Change
        warning message for other forms of inferior call currently not
        supported.
        * valarith.c (value_subscript): Treat an array with upper-bound
        of -1 as unknown size.
@
text
@a187 1
  COERCE_VARYING_ARRAY (array, tarray);
a625 3
  COERCE_VARYING_ARRAY (arg1, type1);
  COERCE_VARYING_ARRAY (arg2, type2);

@


1.23
log
@2004-06-27    <david@@streamline-computing.com>

	Partial fix for PR cli/1056.
	* valarith.c (value_binop): Check for zero in division and
	remainder evaluation.
@
text
@d205 4
a208 1
	  warning ("array or string index out of range");
@


1.22
log
@* valarith.c: Update copyright notice.
(value_add): Handle range types.
(value_sub): Ditto.
(value_equal): Ditto.
(value_less): Ditto.
(value_neg): Ditto.
(value_complement): Ditto.
(value_binop): Simplify slightly by using is_integral_type and
eliminiating unnecessary COERCE_ENUMs.
@
text
@d1043 4
a1046 1
	      v = v1 / v2;
d1056 4
a1059 1
	      v = v1 % v2;
@


1.21
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d4 1
a4 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
d94 2
a95 2
  COERCE_NUMBER (arg1);
  COERCE_NUMBER (arg2);
d102 1
a102 2
      (TYPE_CODE (type1) == TYPE_CODE_INT
       || TYPE_CODE (type2) == TYPE_CODE_INT))
d136 2
a137 2
  COERCE_NUMBER (arg1);
  COERCE_NUMBER (arg2);
d143 1
a143 1
      if (TYPE_CODE (type2) == TYPE_CODE_INT)
a753 2
  COERCE_ENUM (arg1);
  COERCE_ENUM (arg2);
d757 1
a757 5
  if ((TYPE_CODE (type1) != TYPE_CODE_FLT
       && TYPE_CODE (type1) != TYPE_CODE_CHAR
       && TYPE_CODE (type1) != TYPE_CODE_INT
       && TYPE_CODE (type1) != TYPE_CODE_BOOL
       && TYPE_CODE (type1) != TYPE_CODE_RANGE)
d759 1
a759 5
      (TYPE_CODE (type2) != TYPE_CODE_FLT
       && TYPE_CODE (type2) != TYPE_CODE_CHAR
       && TYPE_CODE (type2) != TYPE_CODE_INT
       && TYPE_CODE (type2) != TYPE_CODE_BOOL
       && TYPE_CODE (type2) != TYPE_CODE_RANGE))
d1213 1
d1215 2
a1216 2
  COERCE_NUMBER (arg1);
  COERCE_NUMBER (arg2);
d1222 2
d1225 1
a1225 2
  if ((code1 == TYPE_CODE_INT || code1 == TYPE_CODE_BOOL) &&
      (code2 == TYPE_CODE_INT || code2 == TYPE_CODE_BOOL))
d1228 2
a1229 2
  else if ((code1 == TYPE_CODE_FLT || code1 == TYPE_CODE_INT || code1 == TYPE_CODE_BOOL)
	   && (code2 == TYPE_CODE_FLT || code2 == TYPE_CODE_INT || code2 == TYPE_CODE_BOOL))
d1234 1
a1234 1
  else if (code1 == TYPE_CODE_PTR && (code2 == TYPE_CODE_INT || code2 == TYPE_CODE_BOOL))
d1236 1
a1236 1
  else if (code2 == TYPE_CODE_PTR && (code1 == TYPE_CODE_INT || code1 == TYPE_CODE_BOOL))
d1272 1
d1274 2
a1275 2
  COERCE_NUMBER (arg1);
  COERCE_NUMBER (arg2);
d1281 2
d1284 1
a1284 2
  if ((code1 == TYPE_CODE_INT || code1 == TYPE_CODE_BOOL) &&
      (code2 == TYPE_CODE_INT || code2 == TYPE_CODE_BOOL))
d1287 2
a1288 2
  else if ((code1 == TYPE_CODE_FLT || code1 == TYPE_CODE_INT || code1 == TYPE_CODE_BOOL)
	   && (code2 == TYPE_CODE_FLT || code2 == TYPE_CODE_INT || code2 == TYPE_CODE_BOOL))
d1295 1
a1295 1
  else if (code1 == TYPE_CODE_PTR && (code2 == TYPE_CODE_INT || code2 == TYPE_CODE_BOOL))
d1297 1
a1297 1
  else if (code2 == TYPE_CODE_PTR && (code1 == TYPE_CODE_INT || code1 == TYPE_CODE_BOOL))
a1316 1
  COERCE_ENUM (arg1);
d1322 1
a1322 1
  else if (TYPE_CODE (type) == TYPE_CODE_INT || TYPE_CODE (type) == TYPE_CODE_BOOL)
a1342 1
  int typecode;
a1344 1
  COERCE_ENUM (arg1);
d1348 1
a1348 2
  typecode = TYPE_CODE (type);
  if ((typecode != TYPE_CODE_INT) && (typecode != TYPE_CODE_BOOL))
@


1.21.10.1
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d4 1
a4 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
d94 2
a95 2
  COERCE_ARRAY (arg1);
  COERCE_ARRAY (arg2);
d102 2
a103 1
      (is_integral_type (type1) || is_integral_type (type2)))
d137 2
a138 2
  COERCE_ARRAY (arg1);
  COERCE_ARRAY (arg2);
d144 1
a144 1
      if (is_integral_type (type2))
d755 2
d760 5
a764 1
  if ((TYPE_CODE (type1) != TYPE_CODE_FLT && !is_integral_type (type1))
d766 5
a770 1
      (TYPE_CODE (type2) != TYPE_CODE_FLT && !is_integral_type (type2)))
a1223 1
  int is_int1, is_int2;
d1225 2
a1226 2
  COERCE_ARRAY (arg1);
  COERCE_ARRAY (arg2);
a1231 2
  is_int1 = is_integral_type (type1);
  is_int2 = is_integral_type (type2);
d1233 2
a1234 1
  if (is_int1 && is_int2)
d1237 2
a1238 2
  else if ((code1 == TYPE_CODE_FLT || is_int1)
	   && (code2 == TYPE_CODE_FLT || is_int2))
d1243 1
a1243 1
  else if (code1 == TYPE_CODE_PTR && is_int2)
d1245 1
a1245 1
  else if (code2 == TYPE_CODE_PTR && is_int1)
a1280 1
  int is_int1, is_int2;
d1282 2
a1283 2
  COERCE_ARRAY (arg1);
  COERCE_ARRAY (arg2);
a1288 2
  is_int1 = is_integral_type (type1);
  is_int2 = is_integral_type (type2);
d1290 2
a1291 1
  if (is_int1 && is_int2)
d1294 2
a1295 2
  else if ((code1 == TYPE_CODE_FLT || is_int1)
	   && (code2 == TYPE_CODE_FLT || is_int2))
d1302 1
a1302 1
  else if (code1 == TYPE_CODE_PTR && is_int2)
d1304 1
a1304 1
  else if (code2 == TYPE_CODE_PTR && is_int1)
d1324 1
d1330 1
a1330 1
  else if (is_integral_type (type))
d1351 1
d1354 1
d1358 2
a1359 1
  if (!is_integral_type (type))
@


1.21.10.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d1043 1
a1043 4
	      if (v2 != 0)
		v = v1 / v2;
	      else
		error ("Division by zero");
d1053 1
a1053 4
	      if (v2 != 0)
		v = v1 % v2;
	      else
		error ("Division by zero");
@


1.21.10.3
log
@Merge from mainline.
@
text
@d205 1
a205 4
	  /* Emit warning unless we have an array of unknown size.
	     An array of unknown size has lowerbound 0 and upperbound -1.  */
	  if (upperbound > -1)
	    warning ("array or string index out of range");
@


1.20
log
@2003-04-21  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c: New file.
	* infcall.h: New file.
	* valarith.c: Include "infcall.h".
	* scm-lang.c, objc-lang.cm, hppa-tdep.c, gcore.c: Ditto.
	* eval.c, ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (valarith.o, scm-lang.o): Update dependencies.
	(objc-lang.o, hppa-tdep.o, gcore.o): Update dependencies.
	(eval.o, ada-valprint.o, ada-lang.o): Update dependencies.
	(SFILES): Add "infcall.c"
	(COMMON_OBS): Add "infcall.o".
	(infcall.o): Specify dependencies.
	* value.h (call_function_by_hand): Delete declaration.
	* inferior.h (run_stack_dummy): Delete declaration.
	* infcmd.c (breakpoint_auto_delete_contents): Move to "infcall.c".
	(run_stack_dummy): Move to "infcall.c", merged into
	call_function_by_hand.
	* valops.c (call_function_by_hand): Moved to "infcall.c".
	(find_function_addr, value_arg_coerce): Ditto.
	(unwindonsignal_p, coerce_float_to_double): Ditto.
	(_initialize_valops): Move "set/show coerce-float-to-double", and
	"set/show unwindonsignal" commands to "infcall.c".
	* v850-tdep.c, target.h: Update comments.
	* sparc-tdep.c (sparc_fix_call_dummy): Update comments.
	* sh-tdep.c (sh_init_extra_frame_info): Update comments.
	(sh64_init_extra_frame_info): Update comments.
	* mn10300-tdep.c: Update comments.
	* mcore-tdep.c (mcore_init_extra_frame_info): Update comments.
	* config/sparc/tm-sparc.h: Update comments.
	* breakpoint.h: Update comments.
	* avr-tdep.c (avr_init_extra_frame_info): Update comments.
	* arm-tdep.c: Update comment.
@
text
@d1161 2
a1162 2
  register int len;
  register char *p;
d1219 2
a1220 2
  register int len;
  register char *p1, *p2;
d1278 2
a1279 2
  register enum type_code code1;
  register enum type_code code2;
d1320 2
a1321 2
  register struct type *type;
  register struct type *result_type = VALUE_TYPE (arg1);
d1349 2
a1350 2
  register struct type *type;
  register struct type *result_type = VALUE_TYPE (arg1);
@


1.19
log
@2003-03-08  Andrew Cagney  <cagney@@redhat.com>

	* valarith.c (value_subscripted_rvalue): Copy the array's REGNO to
	the result.
@
text
@d34 1
@


1.19.12.1
log
@Merge from mainline.
@
text
@a33 1
#include "infcall.h"
@


1.18
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@d279 1
@


1.18.6.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@a278 1
  VALUE_REGNO (v) = VALUE_REGNO (array);
@


1.17
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* valarith.c (value_binop): Delete obsolete code and comments.
	* configure.host: Ditto.
	* buildsym.h (make_blockvector): Ditto.
	* buildsym.c (make_blockvector): Ditto.
	* defs.h (enum language): Ditto.
	(chill_demangle): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* dwarfread.c (CHILL_PRODUCER): Ditto.
	(set_cu_language): Ditto.
	(handle_producer): Ditto.
	* expprint.c (print_subexp): Ditto.
	* gdbtypes.c (chill_varying_type): Ditto.
	* gdbtypes.h (builtin_type_chill_bool): Ditto.
	(builtin_type_chill_char, builtin_type_chill_long): Ditto.
	(builtin_type_chill_ulong, builtin_type_chill_real): Ditto.
	(chill_varying_type): Ditto.
	* language.h (_LANG_chill): Ditto.
	* language.c (binop_result_type, integral_type): Ditto.
	(character_type, string_type, structured_type): Ditto.
	(lang_bool_type, binop_type_check): Ditto.
	* stabsread.h (os9k_stabs): Ditto.
	* stabsread.c (os9k_type_vector, dbx_lookup_type): Ditto.
	(define_symbol, read_type, read_struct_fields): Ditto.
	(read_array_type, read_enum_type, read_huge_number): Ditto.
	(read_range_type, start_stabs): Ditto.
	* symfile.c (init_filename_language_table): Ditto.
	(add_psymbol_with_dem_name_to_list): Ditto.
	* symtab.c (symbol_init_language_specific): Ditto.
	(symbol_init_demangled_name, symbol_demangled_name): Ditto.
	* symtab.h (struct general_symbol_info): Ditto.
	(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* valops.c (value_cast, search_struct_field, value_slice): Delete
	obsolete code.
	(varying_to_slice): Delete function.
	* value.h (COERCE_VARYING_ARRAY): Delete obsolete macro contents.
	(varying_to_slice): Delete declaration.
	* MAINTAINERS: Update.
@
text
@d2 1
d4 2
a5 2
   1996, 1997, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
@


1.16
log
@2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* NEWS: Menion that CHILL has been made obsolete.

* gdbtypes.c (chill_varying_type): Make chill references obsolete.
* gdbserver/Makefile.in: Ditto.
* stabsread.c (read_range_type): Ditto.
* gdbtypes.h: Ditto.
* language.c (binop_type_check): Ditto.
(binop_result_type): Ditto.
(integral_type): Ditto.
(character_type): Ditto.
(string_type): Ditto.
(boolean_type): Ditto.
(structured_type): Ditto.
(lang_bool_type): Ditto.
(binop_type_check): Ditto.
* language.h (_LANG_chill): Ditto.
* dwarfread.c (set_cu_language): Ditto.
* dwarfread.c (CHILL_PRODUCER): Ditto.
* dwarfread.c (handle_producer): Ditto.
* expression.h (enum exp_opcode): Ditto.
* eval.c: Ditto for comments.
* typeprint.c (typedef_print) [_LANG_chill]: Ditto.
* expprint.c (print_subexp): Ditto.
(print_subexp): Ditto.
* valops.c (value_cast): Ditto.
(search_struct_field): Ditto.
* value.h (COERCE_VARYING_ARRAY): Ditto.
* symfile.c (init_filename_language_table): Ditto.
(add_psymbol_with_dem_name_to_list): Ditto.
* valarith.c (value_binop): Ditto.
(value_neg): Ditto.
* valops.c (value_slice): Ditto.
* symtab.h (union language_specific): Ditto.
(SYMBOL_INIT_LANGUAGE_SPECIFIC): Ditto.
(SYMBOL_DEMANGLED_NAME): Ditto.
(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
* defs.h (enum language): Ditto.
* symtab.c (got_symtab): Ditto.
* utils.c (fprintf_symbol_filtered): Ditto.

* ch-typeprint.c: Make file obsolete.
* ch-valprint.c: Make file obsolete.
* ch-lang.h: Make file obsolete.
* ch-exp.c: Make file obsolete.
* ch-lang.c: Make file obsolete.

* Makefile.in (FLAGS_TO_PASS): Do not pass CHILL or CHILLFLAGS or
CHILL_LIB.
(TARGET_FLAGS_TO_PASS): Ditto.
(CHILLFLAGS): Obsolete.
(CHILL): Obsolete.
(CHILL_FOR_TARGET): Obsolete.
(CHILL_LIB): Obsolete.
(SFILES): Remove ch-exp.c, ch-lang.c, ch-typeprint.c and
ch-valprint.c.
(HFILES_NO_SRCDIR): Remove ch-lang.h.
(COMMON_OBS): Remove ch-valprint.o, ch-typeprint.o, ch-exp.o and
ch-lang.o.
(ch-exp.o, ch-lang.o, ch-typeprint.o, ch-valprint.o): Delete
targets.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* stabs.texinfo, gdb.texinfo, gdbint.texinfo: Obsolete references
to CHILL.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* Makefile.in (TARGET_FLAGS_TO_PASS): Remove CHILLFLAGS, CHILL,
CHILL_FOR_TARGET and CHILL_LIB.
* configure.in (configdirs): Remove gdb.chill.
* configure: Regenerate.
* lib/gdb.exp: Obsolete references to chill.
* gdb.fortran/types.exp: Ditto.
* gdb.fortran/exprs.exp: Ditto.
@
text
@d862 1
a862 1
       What about FORTRAN and (OBSOLETE) chill ?  */
a948 6
	      /* OBSOLETE Chill specifies that v2 must be > 0, so check for that. */
	      /* OBSOLETE if (current_language->la_language == language_chill */
	      /* OBSOLETE     && value_as_long (arg2) <= 0) */
	      /* OBSOLETE { */
	      /* OBSOLETE   error ("Second operand of MOD must be greater than zero."); */
	      /* OBSOLETE } */
a1066 6
	      /* OBSOLETE Chill specifies that v2 must be > 0, so check for that. */
	      /* OBSOLETE if (current_language->la_language == language_chill */
	      /* OBSOLETE     && v2 <= 0) */
	      /* OBSOLETE { */
	      /* OBSOLETE   error ("Second operand of MOD must be greater than zero."); */
	      /* OBSOLETE } */
d1330 1
a1330 1
         FORTRAN and (OBSOLETE) chill ?  */
@


1.16.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a1 1

d3 2
a4 2
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
   Foundation, Inc.
a32 1
#include "infcall.h"
a277 1
  VALUE_REGNO (v) = VALUE_REGNO (array);
d862 1
a862 1
       What about FORTRAN and (the deleted) chill ?  */
d949 6
d1073 6
d1170 2
a1171 2
  int len;
  char *p;
d1228 2
a1229 2
  int len;
  char *p1, *p2;
d1287 2
a1288 2
  enum type_code code1;
  enum type_code code2;
d1329 2
a1330 2
  struct type *type;
  struct type *result_type = VALUE_TYPE (arg1);
d1342 1
a1342 1
         FORTRAN and (the deleted) chill ?  */
d1358 2
a1359 2
  struct type *type;
  struct type *result_type = VALUE_TYPE (arg1);
@


1.16.8.1
log
@2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (add_partial_enumeration): New function.
	(scan_partial_symbols): Call add_partial_enumeration.
	(locate_pdi_sibling): New function.
	(scan_partial_symbols): Call locate_pdi_sibling.  Get rid of
	nesting_level.
	(pdi_needs_namespace): New function.
	(add_partial_symbol): Add 'namespace' arg; calculate full name
	when appropriate.
	(scan_partial_symbols): Update calls to add_partial_symbol.
	(add_partial_enumeration): Ditto.
	(read_enumeration): Add processing_current_prefix to name when
	appropriate.
	(new_symbol): Set names of enumerators and typedefs appropriately
	if processing_has_namespace_info.
	* symtab.c (lookup_symbol_namespace): Rename 'namespace' argument
	to 'namespace_name'.
	* symtab.h: Ditto.
	* symtab.c (lookup_symbol_namespace): Delete FIXME comments; add a
	new one.
	(lookup_symbol_aux_file): New function.
	(lookup_symbol_aux): Delete FIXME comment.
	(lookup_symbol_aux): Don't search static block explicitly; delete
	FIXME comments.
	* valops.c (value_namespace_elt): Update call to
	lookup_symbol_namespace.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* symtab.c (lookup_symbol_namespace): Delete 'using' argument and
	add 'block' argument; get using directives via iterators.
	(lookup_symbol_aux_using_loop): Delete 'using' argument and add
	'block' argument.
	(lookup_symbol_aux_using): Don't calculate using directives.
	* block.c (block_using_iterator_first): New function.
	(block_using_iterator_next): Ditto.
	* block.h: Add comment.
	(struct block_using_iterator): New struct.
	Declare block_using_iterator_first, block_using_iterator_next.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (read_structure_scope): Set type name and
	processing_current_prefix appropriately.
	(new_symbol): Make sure that, in symbols associated to class
	types, the name includes appropriate namespaces.
	* buildsym.h: Rename processing_current_namespace to
	processing_current_prefix.
	* buildsym.c (finish_block): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	(read_namespace): Ditto.  Also rename previous_namespace to
	previous_prefix.

	Now come a thousand and one const correctness fixes:
	* p-typeprint.c (pascal_print_type): Const.
	(pascal_type_print_method_args): Const.
	* p-lang.h: Const.
	* m2-typeprint.c (m2_print_type): Const.
	* valops.c (hand_function_call): Const.
	* jv-lang.c (java_primitive_type_from_name): Const.
	* jv-lang.h: Const.
	* jv-typeprint.c (java_print_type): Const.
	* language.c: (unk_lang_print_type): Const.
	* stack.c (frame_info): Const.
	* linespec.c (find_methods): Const.
	(find_method_name): Const
	* f-lang.h: Const.
	* f-typeprint.c (f_print_type): Const.
	* c-typeprint.c (c_print_type): Const.
	* c-lang.h: Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (lookup_primitive_typename): Const.
	* stack.c (print_frame): Const.
	(func_command): Delete pointless cast.
	* linespec.c (find_method_name): Const.
	* language.h: Const.
	* symfile.c (compare_psymbols): Const.
	* symtab.c (completion_list_add_name): Const.
	* breakpoint.c (break_at_finish_at_depth_command_1): Remove
	useless cast.
	(break_at_finish_command_1): Ditto.
	* typeprint.c (type_print): Const.
	* symtab.h: Const.
	* symtab.c (gdb_mangle_name): Const.
	(symbol_init_demangled_name): Const.
	(symbol_demangled_name): Const.
	* defs.h: Const.
	* printcmd.c (build_address_symbolic): Const.
	* valops.c (search_struct_method): Const.
	* cp-valprint.c (cp_is_vtbl_ptr_type): Const.
	(cp_print_value): Const.
	(cp_print_class_member): Const.
	* c-typeprint.c (cp_type_print_derivation_info): Const.
	(c_type_print_varspec_prefix): Const.
	(c_type_print_base): Const.
	* p-valprint.c (pascal_object_is_vtbl_ptr_type): Const.
	(pascal_object_print_value): Const.
	(pascal_object_print_class_member): Const.
	* p-typeprint.c (pascal_type_print_derivation_info): Const.
	(pascal_type_print_varspec_prefix): Const.
	(pascal_type_print_base): Const.
	* jv-typeprint.c (java_type_print_base): Const.
	* jv-lang.h (java_demangle_type_signature): Const.
	* jv-lang.c (java_demangle_type_signature): Const.
	(java_demangled_signature_length): Const.
	(java_demangled_signature_copy): Const.
	* jv-typeprint.c (java_type_print_derivation_info): Const.
	* jv-valprint.c (java_value_print): Const.
	(java_print_value_fields): Const.
	* jv-lang.c (is_object_type): Const.
	(evaluate_subexp_java): Const.
	* stabsread.c (read_cpp_abbrev): Const.
	(complain_about_struct_wipeout): Const.
	(cleanup_undefined_types): Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (add_name): Second arg const.
	(lookup_typename): Const.
	(lookup_unsigned_typename): Const.
	(lookup_signed_typename): Const.
	* linespec.c (find_methods): const char *class_name.
	* symtab.c (gdb_mangle_name): const char *newname.
	* valops.c (destructor_name_p): const char *dname.
	(search_struct_field): First arg const.
	* gdbtypes.c (check_typedef): const char *name (multiple places).
	(cfront_mangle_name): const char *newname.
	* gdbtypes.c (add_mangled_type): const char *tname.
	* valops.c (find_overload_match): const char *obj_type_name.
	* utils.c (gdb_print_host_address): Make first arg const.
	* defs.h: Declare first arg of gdb_print_host_address to be
	const.
	* valarith.c (find_size_for_pointer_math): const char *name.

2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/m-data.cc (main): Add marker comment.
	* gdb.c++/m-data.exp: Use marker comment instead of line numbers.
	* gdb.c++/m-data.cc: Delete superfluous namespace.
	* gdb.c++/m-static.cc: Ditto.
	* gdb.c++/m-static1.cc: Ditto.
	* carlton_runtest: Compare based on gdb.sum, not based on output.
	* carlton_runnamespace: Ditto.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Put tests for CClass.
	* gdb.c++/namespace.cc (C): Add CClass.
@
text
@d68 1
a68 1
	  const char *name;
@


1.16.8.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a1 1

d3 2
a4 2
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
   Foundation, Inc.
d862 1
a862 1
       What about FORTRAN and (the deleted) chill ?  */
d949 6
d1073 6
d1342 1
a1342 1
         FORTRAN and (the deleted) chill ?  */
@


1.16.8.3
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a278 1
  VALUE_REGNO (v) = VALUE_REGNO (array);
@


1.16.8.4
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@a33 1
#include "infcall.h"
@


1.16.8.5
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d1161 2
a1162 2
  int len;
  char *p;
d1219 2
a1220 2
  int len;
  char *p1, *p2;
d1278 2
a1279 2
  enum type_code code1;
  enum type_code code2;
d1320 2
a1321 2
  struct type *type;
  struct type *result_type = VALUE_TYPE (arg1);
d1349 2
a1350 2
  struct type *type;
  struct type *result_type = VALUE_TYPE (arg1);
@


1.15
log
@2002-04-04  Jim Ingham  <jingham@@apple.com>

       * valarith.c (find_size_for_pointer_math): New function, either returns
       the size for a pointer's target, returns 1 for void *, or errors for
       incomplete types.
       (value_add, value_sub): use find_size_for_pointer_math.
@
text
@d862 1
a862 1
       What about FORTRAN and chill?  */
d949 6
a954 6
	      /* Chill specifies that v2 must be > 0, so check for that. */
	      if (current_language->la_language == language_chill
		  && value_as_long (arg2) <= 0)
		{
		  error ("Second operand of MOD must be greater than zero.");
		}
d1073 6
a1078 6
	      /* Chill specifies that v2 must be > 0, so check for that. */
	      if (current_language->la_language == language_chill
		  && v2 <= 0)
		{
		  error ("Second operand of MOD must be greater than zero.");
		}
d1341 2
a1342 2
      /* Perform integral promotion for ANSI C/C++.
         FIXME: What about FORTRAN and chill ?  */
@


1.15.6.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d862 1
a862 1
       What about FORTRAN and (OBSOLETE) chill ?  */
d949 6
a954 6
	      /* OBSOLETE Chill specifies that v2 must be > 0, so check for that. */
	      /* OBSOLETE if (current_language->la_language == language_chill */
	      /* OBSOLETE     && value_as_long (arg2) <= 0) */
	      /* OBSOLETE { */
	      /* OBSOLETE   error ("Second operand of MOD must be greater than zero."); */
	      /* OBSOLETE } */
d1073 6
a1078 6
	      /* OBSOLETE Chill specifies that v2 must be > 0, so check for that. */
	      /* OBSOLETE if (current_language->la_language == language_chill */
	      /* OBSOLETE     && v2 <= 0) */
	      /* OBSOLETE { */
	      /* OBSOLETE   error ("Second operand of MOD must be greater than zero."); */
	      /* OBSOLETE } */
d1341 2
a1342 2
      /* Perform integral promotion for ANSI C/C++.  FIXME: What about
         FORTRAN and (OBSOLETE) chill ?  */
@


1.14
log
@s/strerror/safe_strerror/
@
text
@d46 38
d89 1
a89 1
  register int len;
d118 3
a120 3
      len = TYPE_LENGTH (check_typedef (TYPE_TARGET_TYPE (valptrtype)));
      if (len == 0)
	len = 1;		/* For (void *) */
d123 1
a123 1
				   + (len * value_as_long (valint)));
d145 2
a146 1
	  LONGEST sz = TYPE_LENGTH (check_typedef (TYPE_TARGET_TYPE (type1)));
@


1.13
log
@2002-02-16  Daniel Jacobowitz  <drow@@mvista.com>

        * valarith.c (value_x_unop): Fix decrement; support post-decrement.

2002-02-16  Daniel Jacobowitz  <drow@@mvista.com>

        From Peter Schauer <Peter.Schauer@@Regent.E-Technik.TU-Muenchen.DE>:
        * valops.c (value_arg_coerce): Don't take the address of a reference
        to convert an argument to a reference.
@
text
@d762 1
a762 1
            error ("Cannot perform exponentiation: %s", strerror (errno));
d900 1
a900 1
                error ("Cannot perform exponentiation: %s", strerror (errno));
d1024 1
a1024 1
                error ("Cannot perform exponentiation: %s", strerror (errno));
@


1.12
log
@s/value_ptr/struct value */
@
text
@d467 1
a467 1
  int static_memfuncp;
d478 1
a478 1
  argvec = (struct value **) alloca (sizeof (struct value *) * 3);
d482 2
d495 1
a495 1
      strcpy (ptr, "++");
d499 3
d504 4
a507 1
      strcpy (ptr, "++");
d532 1
d542 1
a542 1
      return call_function_by_hand (argvec[0], 1 - static_memfuncp, argvec + 1);
@


1.11
log
@* value.h (value_as_address): Rename value_as_pointer.
* eval.c, findvar.c, gnu-v2-abi.c, gnu-v3-abi.c, jv-lang.c,
jv-valprint.c, printcmd.c, stack.c, top.c, valarith.c, valops.c,
values.c: Update.
@
text
@d2 2
a3 2
   Copyright 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
   1997, 1998, 1999, 2000
d41 1
a41 1
static value_ptr value_subscripted_rvalue (value_ptr, value_ptr, int);
d46 2
a47 2
value_ptr
value_add (value_ptr arg1, value_ptr arg2)
d49 2
a50 1
  register value_ptr valint, valptr;
d66 1
a66 1
      value_ptr retval;
d93 2
a94 2
value_ptr
value_sub (value_ptr arg1, value_ptr arg2)
d139 2
a140 2
value_ptr
value_subscript (value_ptr array, value_ptr idx)
d142 1
a142 1
  value_ptr bound;
d183 1
a183 1
      value_ptr v;
d215 2
a216 2
static value_ptr
value_subscripted_rvalue (value_ptr array, value_ptr idx, int lowerbound)
d223 1
a223 1
  value_ptr v;
d250 1
a250 1
binop_user_defined_p (enum exp_opcode op, value_ptr arg1, value_ptr arg2)
d272 1
a272 1
unop_user_defined_p (enum exp_opcode op, value_ptr arg1)
d298 2
a299 2
value_ptr
value_x_binop (value_ptr arg1, value_ptr arg2, enum exp_opcode op,
d302 1
a302 1
  value_ptr *argvec;
d318 1
a318 1
  argvec = (value_ptr *) alloca (sizeof (value_ptr) * 4);
d461 2
a462 2
value_ptr
value_x_unop (value_ptr arg1, enum exp_opcode op, enum noside noside)
d464 1
a464 1
  value_ptr *argvec;
d478 1
a478 1
  argvec = (value_ptr *) alloca (sizeof (value_ptr) * 3);
d561 2
a562 2
value_ptr
value_concat (value_ptr arg1, value_ptr arg2)
d564 3
a566 1
  register value_ptr inval1, inval2, outval = NULL;
d696 2
a697 2
value_ptr
value_binop (value_ptr arg1, value_ptr arg2, enum exp_opcode op)
d699 1
a699 1
  register value_ptr val;
d1120 1
a1120 1
value_logical_not (value_ptr arg1)
d1148 1
a1148 1
value_strcmp (register value_ptr arg1, register value_ptr arg2)
d1178 1
a1178 1
value_equal (register value_ptr arg1, register value_ptr arg2)
d1237 1
a1237 1
value_less (register value_ptr arg1, register value_ptr arg2)
d1278 2
a1279 2
value_ptr
value_neg (register value_ptr arg1)
d1307 2
a1308 2
value_ptr
value_complement (register value_ptr arg1)
d1355 2
a1356 2
value_ptr
value_in (value_ptr element, value_ptr set)
@


1.10
log
@202001-10-15  Jim Ingham  <jingham@@inghji.apple.com>
* valarith.c (value_sub): Don't pass a raw type to
value_from_pointer, it has to go through check_typedef first.
@
text
@d83 1
a83 1
				   value_as_pointer (valptr)
d108 1
a108 1
				     (value_as_pointer (arg1)
d1202 1
a1202 1
    return value_as_pointer (arg1) == (CORE_ADDR) value_as_long (arg2);
d1204 1
a1204 1
    return (CORE_ADDR) value_as_long (arg1) == value_as_pointer (arg2);
d1256 1
a1256 1
    return value_as_pointer (arg1) < value_as_pointer (arg2);
d1261 1
a1261 1
    return value_as_pointer (arg1) < (CORE_ADDR) value_as_long (arg2);
d1263 1
a1263 1
    return (CORE_ADDR) value_as_long (arg1) < value_as_pointer (arg2);
@


1.9
log
@* doublest.h (store_floating, extract_floating): Add comment
indicating these functions are deprecated.
(extract_typed_floating, store_typed_floating): Declare.
* doublest.c: Include "gdbtypes.h".
(extract_typed_floating, store_typed_floating): Define.

* stabsread.c (define_symbol): Use store_typed_floating.
* valarith.c (value_binop): Ditto.
* values.c (unpack_long): Use extract_typed_floating.
(unpack_double): Ditto.
@
text
@d107 1
a107 1
	  return value_from_pointer (VALUE_TYPE (arg1),
@


1.8
log
@* defs.h (HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_LONG_DOUBLE_FORMAT, DOUBLEST)
(floatformat_to_doublest, floatformat_from_doublest)
(floatformat_is_negative, floatformat_is_nan)
(floatformat_mantissa, store_floating)
(extract_floating): Move declaration from here.
* doublest.h: To here.  New file.
* utils.c (get_field, floatformat_to_doublest, put_field)
(ldfrexp, floatformat_from_doublest, floatformat_is_negative)
(floatformat_is_nan, floatformat_mantissa)
(FLOATFORMAT_CHAR_BIT): Move from here.
* doublest.c: To here.  New file.
* findvar.c (store_floating, extract_floating): Move from here.
* doublest.c: To here.
* Makefile.in (SFILES): Add doublest.c.
(COMMON_OBS): Add doublest.o.
(doublest.o): Specify dependencies.
(doublest_h): Define.

* config/m88k/tm-m88k.h: Include "doublest.h".
* config/i960/tm-i960.h: Ditto.
* config/i386/tm-symmetry.h: Ditto.
* rs6000-tdep.c, valarith.c: Ditto.
* valprint.c, stabsread.c, sh-tdep.c: Ditto.
* ia64-tdep.c, i387-tdep.c, i386-tdep.c: Ditto.
* values.c, arm-tdep.c, arm-linux-tdep.c: Ditto.
* alpha-tdep.c, ax.h, expression.h: Ditto.
* sh-tdep.c, parse.c, top.c, value.h: Ditto.

* Makefile.in (arm-tdep.o): Add $(doublest_h).
(i386-tdep.o, i387-tdep.o, ia64-tdep.o): Ditto.
(rs6000-tdep.o, stabsread.o, valarith.o): Ditto.
(values.o, valprint.o, arm-linux-tdep.o): Ditto.
(alpha-tdep.o, ax_h, parse.o, top.o, value_h): Ditto.
(parser_defs_h): Ditto.
(expression_h): Add $(doublest_h) and $(symtab_h).
@
text
@d766 1
a766 2
      store_floating (VALUE_CONTENTS_RAW (val), TYPE_LENGTH (VALUE_TYPE (val)),
		      v);
@


1.7
log
@2001-03-06  J.T. Conklin  <jtc@@redback.com>

        * symtab.h (decode_line_1): Removed declaration.

        * symfile.c (#include <assert.h>): Removed.

        * arch-utils.c (#include <ctype.h>): Removed.
        * c-typeprint.c: Likewise.
        * dbxread.c: Likewise.
        * gdbtypes.c: Likewise.
        * target.c: Likewise.
        * os9kread.c: Likewise.

        * c-valprint.c (#include "demangle.h"): Removed.
        * ch-typeprint.c: Likewise.
        * eval.c: Likewise.
        * f-typeprint.c: Likewise.
        * f-valprint.c: Likewise.
        * m2-typeprint.c: Likewise.
        * typeprint.c: Likewise.
        * p-typeprint.c: Likewise.
        * valarith.c: Likewise.
        * valprint.c: Likewise.

        * m2-typeprint.c (#include "gdb_string.h"): Removed.
        * nlmread.c: Likewise.

        * mdebugread.c (#include "gdb-stabs.h"): Removed.
        * minsyms.c: Likewise.
        * mipsread.c: Likewise.
        * nlmread.c: Likewise.

        * m2-typeprint.c (#include "obstack.h"): Removed.
        * m2-valprint.c: Likewise.

        * event-loop.c (#include <setjmp.h>): Removed.
@
text
@d31 1
@


1.7.4.1
log
@202001-10-15  Jim Ingham  <jingham@@inghji.apple.com>
* valarith.c (value_sub): Don't pass a raw type to
value_from_pointer, it has to go through check_typedef first.
@
text
@d106 1
a106 1
	  return value_from_pointer (type1,
@


1.7.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d78 1
a78 1
      len = TYPE_LENGTH (check_typedef (POINTER_TARGET_TYPE (valptrtype)));
d105 1
a105 1
	  LONGEST sz = TYPE_LENGTH (check_typedef (POINTER_TARGET_TYPE (type1)));
d111 2
a112 2
	       && TYPE_LENGTH (check_typedef (POINTER_TARGET_TYPE (type1)))
	       == TYPE_LENGTH (check_typedef (POINTER_TARGET_TYPE (type2))))
d115 1
a115 1
	  LONGEST sz = TYPE_LENGTH (check_typedef (POINTER_TARGET_TYPE (type1)));
d151 1
a151 1
      struct range_type *range_type = ARRAY_RANGE_TYPE (tarray);
d153 1
a153 2
      lowerbound = RANGE_LOWER_BOUND (range_type);
      upperbound = RANGE_UPPER_BOUND (range_type);
d176 1
d179 1
a179 1
      struct range_type *range_type = SET_RANGE_TYPE (tarray);
d184 1
a184 2
      lowerbound = RANGE_LOWER_BOUND (range_type);
      upperbound = RANGE_UPPER_BOUND (range_type);
d1338 2
a1339 4
  struct range_type *range = SET_RANGE_TYPE (type);
  low_bound = RANGE_LOWER_BOUND (range);
  high_bound = RANGE_UPPER_BOUND (range);
  if (low_bound < 0 || high_bound < 0)
d1359 1
a1359 1
    eltype = RANGE_INDEX_TYPE (eltype);
@


1.6
log
@Update/correct copyright notices.
@
text
@a29 1
#include "demangle.h"
@


1.5
log
@Protoization.
@
text
@d2 2
a3 1
   Copyright 1986, 89, 91, 92, 93, 94, 95, 96, 97, 1998
@


1.4
log
@2000-07-20  Michael Snyder  <msnyder@@cleaver.cygnus.com>

      * valarith.c (value_sub): Call check_typedef.
@
text
@d46 1
a46 2
value_add (arg1, arg2)
     value_ptr arg1, arg2;
d92 1
a92 2
value_sub (arg1, arg2)
     value_ptr arg1, arg2;
d138 1
a138 2
value_subscript (array, idx)
     value_ptr array, idx;
d214 1
a214 3
value_subscripted_rvalue (array, idx, lowerbound)
     value_ptr array, idx;
     int lowerbound;
d248 1
a248 3
binop_user_defined_p (op, arg1, arg2)
     enum exp_opcode op;
     value_ptr arg1, arg2;
d270 1
a270 3
unop_user_defined_p (op, arg1)
     enum exp_opcode op;
     value_ptr arg1;
d297 2
a298 4
value_x_binop (arg1, arg2, op, otherop, noside)
     value_ptr arg1, arg2;
     enum exp_opcode op, otherop;
     enum noside noside;
d460 1
a460 4
value_x_unop (arg1, op, noside)
     value_ptr arg1;
     enum exp_opcode op;
     enum noside noside;
d560 1
a560 2
value_concat (arg1, arg2)
     value_ptr arg1, arg2;
d693 1
a693 3
value_binop (arg1, arg2, op)
     value_ptr arg1, arg2;
     enum exp_opcode op;
d1117 1
a1117 2
value_logical_not (arg1)
     value_ptr arg1;
d1145 1
a1145 2
value_strcmp (arg1, arg2)
     register value_ptr arg1, arg2;
d1175 1
a1175 3
value_equal (arg1, arg2)
     register value_ptr arg1, arg2;

d1234 1
a1234 2
value_less (arg1, arg2)
     register value_ptr arg1, arg2;
d1276 1
a1276 2
value_neg (arg1)
     register value_ptr arg1;
d1305 1
a1305 2
value_complement (arg1)
     register value_ptr arg1;
d1333 1
a1333 4
value_bit_index (type, valaddr, index)
     struct type *type;
     char *valaddr;
     int index;
d1353 1
a1353 2
value_in (element, set)
     value_ptr element, set;
d1375 1
a1375 1
_initialize_valarith ()
@


1.3
log
@PARAMS removal.
@
text
@d113 2
a114 2
	       && TYPE_LENGTH (TYPE_TARGET_TYPE (type1))
	       == TYPE_LENGTH (TYPE_TARGET_TYPE (type2)))
@


1.2
log
@* gdbarch.sh (POINTER_TO_ADDRESS, ADDRESS_TO_POINTER): Two new
functions which architectures can redefine, defaulting to
generic_pointer_to_address and generic_address_to_pointer.
* findvar.c (extract_typed_address, store_typed_address,
generic_pointer_to_address, generic_address_to_pointer): New
functions.
(POINTER_TO_ADDRESS, ADDRESS_TO_POINTER): Provide default
definitions.
(extract_address, store_address): Doc fixes.
* values.c (value_as_pointer): Doc fix.
(value_from_pointer): New function.
* defs.h (extract_typed_address, store_typed_address): New
declarations.
* inferior.h (generic_address_to_pointer,
generic_pointer_to_address): New declarations.
* value.h (value_from_pointer): New declaration.

* ax-gdb.c (const_var_ref): Use value_from_pointer, not
value_from_longest.
* blockframe.c (generic_push_dummy_frame): Use read_pc and
read_sp, not read_register.
* c-valprint.c (c_val_print): Use extract_typed_address instead of
extract_address to extract vtable entries and references.
* cp-valprint.c (cp_print_value_fields): Use value_from_pointer
instead of value_from_longest to extract the vtable's address.
* eval.c (evaluate_subexp_standard): Use value_from_pointer
instead of value_from_longest to compute `this', and for doing
pointer-to-member dereferencing.
* findvar.c (read_register): Use extract_unsigned_integer, not
extract_address.
(read_var_value): Use store_typed_address instead of store_address
for building label values.
(locate_var_value): Use value_from_pointer instead of
value_from_longest.
* hppa-tdep.c (find_stub_with_shl_get): Use value_from_pointer,
instead of value_from_longest, to build arguments to __d_shl_get.
* printcmd.c (set_next_address): Use value_from_pointer, not
value_from_longest.
(x_command): Use value_from_pointer, not value_from_longest.
* tracepoint.c (set_traceframe_context): Use value_from_pointer,
not value_from_longest.
* valarith.c (value_add, value_sub): Use value_from_pointer, not
value_from_longest.
* valops.c (find_function_in_inferior, value_coerce_array,
value_coerce_function, value_addr, hand_function_call): Same.
* value.h (COERCE_REF): Use unpack_pointer, not unpack_long.
* values.c (unpack_long): Use extract_typed_address to produce
addresses from pointers and references, not extract_address.
(value_from_longest): Use store_typed_address instead of
store_address to produce pointer and reference values.
@
text
@d40 1
a40 1
static value_ptr value_subscripted_rvalue PARAMS ((value_ptr, value_ptr, int));
d42 1
a42 1
void _initialize_valarith PARAMS ((void));
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 1
d43 1
a44 1

d82 2
a83 2
      retval = value_from_longest (valptrtype,
				   value_as_long (valptr)
d108 3
a110 3
	  return value_from_longest
	    (VALUE_TYPE (arg1),
	     value_as_long (arg1) - (sz * value_as_long (arg2)));
d114 1
a114 1
		  == TYPE_LENGTH (TYPE_TARGET_TYPE (type2)))
d119 1
a119 1
	    (builtin_type_long,		/* FIXME -- should be ptrdiff_t */
d192 1
a192 1
      byte = *((char*)VALUE_CONTENTS (array) + offset);
d276 2
a277 1
int unop_user_defined_p (op, arg1)
d311 1
a311 1
  value_ptr * argvec;
d325 1
a325 1
    error ("Can't do that binary op on that type");  /* FIXME be explicit */
d332 3
a334 3
  /* make the right function name up */  
  strcpy(tstr, "operator__");
  ptr = tstr+8;
d337 46
a382 16
    case BINOP_ADD:		strcpy(ptr,"+"); break;
    case BINOP_SUB:		strcpy(ptr,"-"); break;
    case BINOP_MUL:		strcpy(ptr,"*"); break;
    case BINOP_DIV:		strcpy(ptr,"/"); break;
    case BINOP_REM:		strcpy(ptr,"%"); break;
    case BINOP_LSH:		strcpy(ptr,"<<"); break;
    case BINOP_RSH:		strcpy(ptr,">>"); break;
    case BINOP_BITWISE_AND:	strcpy(ptr,"&"); break;
    case BINOP_BITWISE_IOR:	strcpy(ptr,"|"); break;
    case BINOP_BITWISE_XOR:	strcpy(ptr,"^"); break;
    case BINOP_LOGICAL_AND:	strcpy(ptr,"&&"); break;
    case BINOP_LOGICAL_OR:	strcpy(ptr,"||"); break;
    case BINOP_MIN:		strcpy(ptr,"<?"); break;
    case BINOP_MAX:		strcpy(ptr,">?"); break;
    case BINOP_ASSIGN:		strcpy(ptr,"="); break;
    case BINOP_ASSIGN_MODIFY:	
d385 25
a409 9
	case BINOP_ADD:		strcpy(ptr,"+="); break;
	case BINOP_SUB:		strcpy(ptr,"-="); break;
	case BINOP_MUL:		strcpy(ptr,"*="); break;
	case BINOP_DIV:		strcpy(ptr,"/="); break;
	case BINOP_REM:		strcpy(ptr,"%="); break;
	case BINOP_BITWISE_AND:	strcpy(ptr,"&="); break;
	case BINOP_BITWISE_IOR:	strcpy(ptr,"|="); break;
	case BINOP_BITWISE_XOR:	strcpy(ptr,"^="); break;
	case BINOP_MOD:		/* invalid */
d414 22
a435 8
    case BINOP_SUBSCRIPT: strcpy(ptr,"[]"); break;
    case BINOP_EQUAL:	  strcpy(ptr,"=="); break;
    case BINOP_NOTEQUAL:  strcpy(ptr,"!="); break;
    case BINOP_LESS:      strcpy(ptr,"<"); break;
    case BINOP_GTR:       strcpy(ptr,">"); break;
    case BINOP_GEQ:       strcpy(ptr,">="); break;
    case BINOP_LEQ:       strcpy(ptr,"<="); break;
    case BINOP_MOD:	  /* invalid */
d440 2
a441 2
  argvec[0] = value_struct_elt (&arg1, argvec+1, tstr, &static_memfuncp, "structure");
  
d476 1
a476 1
  value_ptr * argvec;
d488 1
a488 1
    error ("Can't do that unary op on that type");  /* FIXME be explicit */
d494 5
a498 5
  /* make the right function name up */  
  strcpy(tstr,"operator__");
  ptr = tstr+8;
  strcpy(mangle_tstr, "__");
  mangle_ptr = mangle_tstr+2;
d501 24
a524 8
    case UNOP_PREINCREMENT:	strcpy(ptr,"++"); break;
    case UNOP_PREDECREMENT:	strcpy(ptr,"++"); break;
    case UNOP_POSTINCREMENT:	strcpy(ptr,"++"); break;
    case UNOP_POSTDECREMENT:	strcpy(ptr,"++"); break;
    case UNOP_LOGICAL_NOT:	strcpy(ptr,"!"); break;
    case UNOP_COMPLEMENT:	strcpy(ptr,"~"); break;
    case UNOP_NEG:		strcpy(ptr,"-"); break;
    case UNOP_IND:		strcpy(ptr,"*"); break;
d529 1
a529 1
  argvec[0] = value_struct_elt (&arg1, argvec+1, tstr, &static_memfuncp, "structure");
d548 1
a548 1
  return 0;  /* For lint -- never reached */
d550 1
a551 1

d554 3
a556 3
   (1)	Both values must be either bitstring values or character string
	values and the resulting value consists of the concatenation of
	ARG1 followed by ARG2.
d558 1
a558 1
	or
d560 4
a563 4
	One value must be an integer value and the other value must be
	either a bitstring value or character string value, which is
	to be repeated by the number of times specified by the integer
	value.
d566 2
a567 2
    (2)	Boolean values are also allowed and are treated as bit string
    	values of length 1.
d569 3
a571 3
    (3)	Character values are also allowed and are treated as character
    	string values of length 1.
*/
d577 1
a577 1
  register value_ptr inval1, inval2, outval;
d613 1
a613 1
	 construct a value repeated that many times. */
d650 1
a650 1
      || TYPE_CODE (type1) == TYPE_CODE_CHAR)
d671 1
a671 1
	  *(ptr + inval1len) = 
d690 1
a690 1
    }      
d698 1
a699 1

d740 3
a742 3
	 in target format.  real.c in GCC probably has the necessary
	 code.  */
      DOUBLEST v1, v2, v;
d763 6
d774 1
a774 1
	 double.  */
d776 2
a777 2
      if (TYPE_LENGTH(type1) * 8 > TARGET_DOUBLE_BIT
	  || TYPE_LENGTH(type2) * 8 > TARGET_DOUBLE_BIT)
d788 36
a823 28
      {
	  LONGEST v1, v2, v;
	  v1 = value_as_long (arg1);
	  v2 = value_as_long (arg2);
	  
	  switch (op)
	    {
	    case BINOP_BITWISE_AND:
	      v = v1 & v2;
	      break;
	      
	    case BINOP_BITWISE_IOR:
	      v = v1 | v2;
	      break;
	      
	    case BINOP_BITWISE_XOR:
	      v = v1 ^ v2;
	      break;
	      
	    default:
	      error ("Invalid operation on booleans.");
	    }
	  
	  val = allocate_value (type1);
	  store_signed_integer (VALUE_CONTENTS_RAW (val),
				TYPE_LENGTH (type1),
				v);
      }
d838 1
a838 1
	 both operands.  */
d851 4
a854 4
	 be done unsigned.
	 Use the signedness of the operand with the greater length.
	 If both operands are of equal length, use unsigned operation
	 if one of the operands is unsigned.  */
d873 1
a873 1
	  ULONGEST v1, v2, v;
d883 1
a883 1
	  
d889 1
a889 1
	      
d893 1
a893 1
	      
d897 1
a897 1
	      
d901 7
a907 1
	      
d911 1
a911 1
	      
d916 1
a916 1
	      if (current_language -> la_language == language_chill
d927 1
a927 1
		  v = v1/v2;
d932 1
a932 1
	      
d936 1
a936 1
	      
d940 1
a940 1
	      
d944 1
a944 1
	      
d948 1
a948 1
	      
d952 1
a952 1
	      
d956 1
a956 1
	      
d960 1
a960 1
	      
d964 1
a964 1
	      
d973 4
d980 1
a980 1
	      
d1004 1
a1004 1
	  LONGEST v1, v2, v;
d1007 1
a1007 1
	  
d1013 1
a1013 1
	      
d1017 1
a1017 1
	      
d1021 1
a1021 1
	      
d1024 6
d1031 1
a1031 1
	      
d1035 1
a1035 1
	      
d1040 1
a1040 1
	      if (current_language -> la_language == language_chill
d1051 1
a1051 1
		  v = v1/v2;
d1060 1
a1060 1
	      
d1064 1
a1064 1
	      
d1068 1
a1068 1
	      
d1072 1
a1072 1
	      
d1076 1
a1076 1
	      
d1080 1
a1080 1
	      
d1084 1
a1084 1
	      
d1088 1
a1088 1
	      
d1092 1
a1092 1
	      
d1104 1
a1104 1
	      
d1159 31
d1240 4
d1247 1
a1247 1
      return 0;  /* For lint -- never reached */
d1286 2
a1287 1

d1310 1
a1310 1
    return value_from_double (result_type, - value_as_double (arg1));
d1314 1
a1314 1
	 FIXME: What about FORTRAN and chill ?  */
d1318 6
a1323 1
      return value_from_longest (result_type, - value_as_long (arg1));
a1324 4
  else {
    error ("Argument to negate operation not a number.");
    return 0;  /* For lint -- never reached */
  }
d1333 1
a1333 1
  int typecode; 
d1349 1
a1349 1
  return value_from_longest (result_type, ~ value_as_long (arg1));
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d41 1
a42 1

d112 1
a112 1
	       == TYPE_LENGTH (TYPE_TARGET_TYPE (type2)))
d117 1
a117 1
	    (builtin_type_long,	/* FIXME -- should be ptrdiff_t */
d190 1
a190 1
      byte = *((char *) VALUE_CONTENTS (array) + offset);
d274 1
a274 2
int
unop_user_defined_p (op, arg1)
d308 1
a308 1
  value_ptr *argvec;
d322 1
a322 1
    error ("Can't do that binary op on that type");	/* FIXME be explicit */
d329 3
a331 3
  /* make the right function name up */
  strcpy (tstr, "operator__");
  ptr = tstr + 8;
d334 16
a349 46
    case BINOP_ADD:
      strcpy (ptr, "+");
      break;
    case BINOP_SUB:
      strcpy (ptr, "-");
      break;
    case BINOP_MUL:
      strcpy (ptr, "*");
      break;
    case BINOP_DIV:
      strcpy (ptr, "/");
      break;
    case BINOP_REM:
      strcpy (ptr, "%");
      break;
    case BINOP_LSH:
      strcpy (ptr, "<<");
      break;
    case BINOP_RSH:
      strcpy (ptr, ">>");
      break;
    case BINOP_BITWISE_AND:
      strcpy (ptr, "&");
      break;
    case BINOP_BITWISE_IOR:
      strcpy (ptr, "|");
      break;
    case BINOP_BITWISE_XOR:
      strcpy (ptr, "^");
      break;
    case BINOP_LOGICAL_AND:
      strcpy (ptr, "&&");
      break;
    case BINOP_LOGICAL_OR:
      strcpy (ptr, "||");
      break;
    case BINOP_MIN:
      strcpy (ptr, "<?");
      break;
    case BINOP_MAX:
      strcpy (ptr, ">?");
      break;
    case BINOP_ASSIGN:
      strcpy (ptr, "=");
      break;
    case BINOP_ASSIGN_MODIFY:
d352 9
a360 25
	case BINOP_ADD:
	  strcpy (ptr, "+=");
	  break;
	case BINOP_SUB:
	  strcpy (ptr, "-=");
	  break;
	case BINOP_MUL:
	  strcpy (ptr, "*=");
	  break;
	case BINOP_DIV:
	  strcpy (ptr, "/=");
	  break;
	case BINOP_REM:
	  strcpy (ptr, "%=");
	  break;
	case BINOP_BITWISE_AND:
	  strcpy (ptr, "&=");
	  break;
	case BINOP_BITWISE_IOR:
	  strcpy (ptr, "|=");
	  break;
	case BINOP_BITWISE_XOR:
	  strcpy (ptr, "^=");
	  break;
	case BINOP_MOD:	/* invalid */
d365 8
a372 22
    case BINOP_SUBSCRIPT:
      strcpy (ptr, "[]");
      break;
    case BINOP_EQUAL:
      strcpy (ptr, "==");
      break;
    case BINOP_NOTEQUAL:
      strcpy (ptr, "!=");
      break;
    case BINOP_LESS:
      strcpy (ptr, "<");
      break;
    case BINOP_GTR:
      strcpy (ptr, ">");
      break;
    case BINOP_GEQ:
      strcpy (ptr, ">=");
      break;
    case BINOP_LEQ:
      strcpy (ptr, "<=");
      break;
    case BINOP_MOD:		/* invalid */
d377 2
a378 2
  argvec[0] = value_struct_elt (&arg1, argvec + 1, tstr, &static_memfuncp, "structure");

d413 1
a413 1
  value_ptr *argvec;
d425 1
a425 1
    error ("Can't do that unary op on that type");	/* FIXME be explicit */
d431 5
a435 5
  /* make the right function name up */
  strcpy (tstr, "operator__");
  ptr = tstr + 8;
  strcpy (mangle_tstr, "__");
  mangle_ptr = mangle_tstr + 2;
d438 8
a445 24
    case UNOP_PREINCREMENT:
      strcpy (ptr, "++");
      break;
    case UNOP_PREDECREMENT:
      strcpy (ptr, "++");
      break;
    case UNOP_POSTINCREMENT:
      strcpy (ptr, "++");
      break;
    case UNOP_POSTDECREMENT:
      strcpy (ptr, "++");
      break;
    case UNOP_LOGICAL_NOT:
      strcpy (ptr, "!");
      break;
    case UNOP_COMPLEMENT:
      strcpy (ptr, "~");
      break;
    case UNOP_NEG:
      strcpy (ptr, "-");
      break;
    case UNOP_IND:
      strcpy (ptr, "*");
      break;
d450 1
a450 1
  argvec[0] = value_struct_elt (&arg1, argvec + 1, tstr, &static_memfuncp, "structure");
d469 1
a469 1
  return 0;			/* For lint -- never reached */
d471 1
a472 1

d475 3
a477 3
   (1)  Both values must be either bitstring values or character string
   values and the resulting value consists of the concatenation of
   ARG1 followed by ARG2.
d479 1
a479 1
   or
d481 4
a484 4
   One value must be an integer value and the other value must be
   either a bitstring value or character string value, which is
   to be repeated by the number of times specified by the integer
   value.
d487 2
a488 2
   (2)  Boolean values are also allowed and are treated as bit string
   values of length 1.
d490 3
a492 3
   (3)  Character values are also allowed and are treated as character
   string values of length 1.
 */
d534 1
a534 1
         construct a value repeated that many times. */
d571 1
a571 1
	   || TYPE_CODE (type1) == TYPE_CODE_CHAR)
d592 1
a592 1
	  *(ptr + inval1len) =
d611 1
a611 1
    }
d619 1
a621 1

d661 2
a662 2
         in target format.  real.c in GCC probably has the necessary
         code.  */
d689 1
a689 1
         double.  */
d691 2
a692 2
      if (TYPE_LENGTH (type1) * 8 > TARGET_DOUBLE_BIT
	  || TYPE_LENGTH (type2) * 8 > TARGET_DOUBLE_BIT)
d703 28
a730 28
    {
      LONGEST v1, v2, v;
      v1 = value_as_long (arg1);
      v2 = value_as_long (arg2);

      switch (op)
	{
	case BINOP_BITWISE_AND:
	  v = v1 & v2;
	  break;

	case BINOP_BITWISE_IOR:
	  v = v1 | v2;
	  break;

	case BINOP_BITWISE_XOR:
	  v = v1 ^ v2;
	  break;

	default:
	  error ("Invalid operation on booleans.");
	}

      val = allocate_value (type1);
      store_signed_integer (VALUE_CONTENTS_RAW (val),
			    TYPE_LENGTH (type1),
			    v);
    }
d745 1
a745 1
         both operands.  */
d758 4
a761 4
         be done unsigned.
         Use the signedness of the operand with the greater length.
         If both operands are of equal length, use unsigned operation
         if one of the operands is unsigned.  */
d790 1
a790 1

d796 1
a796 1

d800 1
a800 1

d804 1
a804 1

d808 1
a808 1

d812 1
a812 1

d817 1
a817 1
	      if (current_language->la_language == language_chill
d828 1
a828 1
		  v = v1 / v2;
d833 1
a833 1

d837 1
a837 1

d841 1
a841 1

d845 1
a845 1

d849 1
a849 1

d853 1
a853 1

d857 1
a857 1

d861 1
a861 1

d865 1
a865 1

d877 1
a877 1

d904 1
a904 1

d910 1
a910 1

d914 1
a914 1

d918 1
a918 1

d922 1
a922 1

d926 1
a926 1

d931 1
a931 1
	      if (current_language->la_language == language_chill
d942 1
a942 1
		  v = v1 / v2;
d951 1
a951 1

d955 1
a955 1

d959 1
a959 1

d963 1
a963 1

d967 1
a967 1

d971 1
a971 1

d975 1
a975 1

d979 1
a979 1

d983 1
a983 1

d995 1
a995 1

d1103 1
a1103 1
      return 0;			/* For lint -- never reached */
d1165 1
a1165 1
    return value_from_double (result_type, -value_as_double (arg1));
d1169 1
a1169 1
         FIXME: What about FORTRAN and chill ?  */
d1173 1
a1173 6
      return value_from_longest (result_type, -value_as_long (arg1));
    }
  else
    {
      error ("Argument to negate operation not a number.");
      return 0;			/* For lint -- never reached */
d1175 4
d1187 1
a1187 1
  int typecode;
d1203 1
a1203 1
  return value_from_longest (result_type, ~value_as_long (arg1));
@


1.1.1.3
log
@import gdb-1999-12-13 snapshot
@
text
@a30 1
#include <math.h>
d576 1
a576 1
  register value_ptr inval1, inval2, outval = NULL;
d741 1
a741 1
      DOUBLEST v1, v2, v = 0;
a761 6
        case BINOP_EXP:
          v = pow (v1, v2);
          if (errno)
            error ("Cannot perform exponentiation: %s", strerror (errno));
          break;

d782 1
a782 1
      LONGEST v1, v2, v = 0;
a797 8
          break;
              
        case BINOP_EQUAL:
          v = v1 == v2;
          break;
          
        case BINOP_NOTEQUAL:
          v = v1 != v2;
d858 1
a858 1
	  ULONGEST v1, v2, v = 0;
a886 6
            case BINOP_EXP:
              v = pow (v1, v2);
              if (errno)
                error ("Cannot perform exponentiation: %s", strerror (errno));
              break;

a951 4
            case BINOP_NOTEQUAL:
              v = v1 != v2;
              break;

d979 1
a979 1
	  LONGEST v1, v2, v = 0;
a998 6
              break;

            case BINOP_EXP:
              v = pow (v1, v2);
              if (errno)
                error ("Cannot perform exponentiation: %s", strerror (errno));
a1127 31
/* Perform a comparison on two string values (whose content are not
   necessarily null terminated) based on their length */

static int
value_strcmp (arg1, arg2)
     register value_ptr arg1, arg2;
{
  int len1 = TYPE_LENGTH (VALUE_TYPE (arg1));
  int len2 = TYPE_LENGTH (VALUE_TYPE (arg2));
  char *s1 = VALUE_CONTENTS (arg1);
  char *s2 = VALUE_CONTENTS (arg2);
  int i, len = len1 < len2 ? len1 : len2;

  for (i = 0; i < len; i++)
    {
      if (s1[i] < s2[i])
        return -1;
      else if (s1[i] > s2[i])
        return 1;
      else
        continue;
    }

  if (len1 < len2)
    return -1;
  else if (len1 > len2)
    return 1;
  else
    return 0;
}

a1177 4
  else if (code1 == TYPE_CODE_STRING && code2 == TYPE_CODE_STRING)
    {
      return value_strcmp (arg1, arg2) == 0;
    }
d1220 1
a1220 2
  else if (code1 == TYPE_CODE_STRING && code2 == TYPE_CODE_STRING)
    return value_strcmp (arg1, arg2) < 0;
@


