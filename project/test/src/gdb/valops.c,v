head	1.318;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.312
	gdb_7_6-2013-04-26-release:1.312
	gdb_7_6-branch:1.312.0.2
	gdb_7_6-2013-03-12-branchpoint:1.312
	gdb_7_5_1-2012-11-29-release:1.297
	gdb_7_5-2012-08-17-release:1.297
	gdb_7_5-branch:1.297.0.2
	gdb_7_5-2012-07-18-branchpoint:1.297
	gdb_7_4_1-2012-04-26-release:1.290.2.1
	gdb_7_4-2012-01-24-release:1.290.2.1
	gdb_7_4-branch:1.290.0.2
	gdb_7_4-2011-12-13-branchpoint:1.290
	gdb_7_3_1-2011-09-04-release:1.275
	gdb_7_3-2011-07-26-release:1.275
	gdb_7_3-branch:1.275.0.2
	gdb_7_3-2011-04-01-branchpoint:1.275
	gdb_7_2-2010-09-02-release:1.248
	gdb_7_2-branch:1.248.0.2
	gdb_7_2-2010-07-07-branchpoint:1.248
	gdb_7_1-2010-03-18-release:1.237
	gdb_7_1-branch:1.237.0.2
	gdb_7_1-2010-02-18-branchpoint:1.237
	gdb_7_0_1-2009-12-22-release:1.225.2.1
	gdb_7_0-2009-10-06-release:1.225.2.1
	gdb_7_0-branch:1.225.0.2
	gdb_7_0-2009-09-16-branchpoint:1.225
	arc-sim-20090309:1.183
	msnyder-checkpoint-072509-branch:1.224.0.2
	msnyder-checkpoint-072509-branchpoint:1.224
	arc-insight_6_8-branch:1.183.0.6
	arc-insight_6_8-branchpoint:1.183
	insight_6_8-branch:1.183.0.4
	insight_6_8-branchpoint:1.183
	reverse-20081226-branch:1.203.0.2
	reverse-20081226-branchpoint:1.203
	multiprocess-20081120-branch:1.202.0.2
	multiprocess-20081120-branchpoint:1.202
	reverse-20080930-branch:1.200.0.2
	reverse-20080930-branchpoint:1.200
	reverse-20080717-branch:1.192.0.2
	reverse-20080717-branchpoint:1.192
	msnyder-reverse-20080609-branch:1.191.0.2
	msnyder-reverse-20080609-branchpoint:1.191
	drow-reverse-20070409-branch:1.170.0.2
	drow-reverse-20070409-branchpoint:1.170
	gdb_6_8-2008-03-27-release:1.183
	gdb_6_8-branch:1.183.0.2
	gdb_6_8-2008-02-26-branchpoint:1.183
	gdb_6_7_1-2007-10-29-release:1.178
	gdb_6_7-2007-10-10-release:1.178
	gdb_6_7-branch:1.178.0.2
	gdb_6_7-2007-09-07-branchpoint:1.178
	insight_6_6-20070208-release:1.165
	gdb_6_6-2006-12-18-release:1.165
	gdb_6_6-branch:1.165.0.2
	gdb_6_6-2006-11-15-branchpoint:1.165
	insight_6_5-20061003-release:1.163
	gdb-csl-symbian-6_4_50_20060226-12:1.163.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.161
	nickrob-async-20060828-mergepoint:1.164
	gdb-csl-symbian-6_4_50_20060226-11:1.163.2.1
	gdb-csl-sourcerygxx-4_1-17:1.163.2.1
	gdb-csl-20060226-branch-local-2:1.163.2.1
	gdb-csl-sourcerygxx-4_1-14:1.163.2.1
	gdb-csl-sourcerygxx-4_1-13:1.163.2.1
	gdb-csl-sourcerygxx-4_1-12:1.163.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.163.2.1
	gdb_6_5-20060621-release:1.163
	gdb-csl-sourcerygxx-4_1-9:1.163.2.1
	gdb-csl-sourcerygxx-4_1-8:1.163.2.1
	gdb-csl-sourcerygxx-4_1-7:1.163.2.1
	gdb-csl-arm-2006q1-6:1.163.2.1
	gdb-csl-sourcerygxx-4_1-6:1.163.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.163.2.1
	gdb-csl-symbian-6_4_50_20060226-9:1.163.2.1
	gdb-csl-symbian-6_4_50_20060226-8:1.163.2.1
	gdb-csl-coldfire-4_1-11:1.163.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.163.2.1
	gdb-csl-coldfire-4_1-10:1.163.2.1
	gdb_6_5-branch:1.163.0.14
	gdb_6_5-2006-05-14-branchpoint:1.163
	gdb-csl-sourcerygxx-4_1-5:1.163.2.1
	nickrob-async-20060513-branch:1.163.0.12
	nickrob-async-20060513-branchpoint:1.163
	gdb-csl-sourcerygxx-4_1-4:1.163.2.1
	msnyder-reverse-20060502-branch:1.163.0.10
	msnyder-reverse-20060502-branchpoint:1.163
	gdb-csl-morpho-4_1-4:1.163.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.163.2.1
	readline_5_1-import-branch:1.163.0.8
	readline_5_1-import-branchpoint:1.163
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.163.2.1
	gdb-csl-symbian-20060226-branch:1.163.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.163.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.163.2.1
	msnyder-reverse-20060331-branch:1.163.0.6
	msnyder-reverse-20060331-branchpoint:1.163
	gdb-csl-available-20060303-branch:1.163.0.4
	gdb-csl-available-20060303-branchpoint:1.163
	gdb-csl-20060226-branch:1.163.0.2
	gdb-csl-20060226-branchpoint:1.163
	gdb_6_4-20051202-release:1.161
	msnyder-fork-checkpoint-branch:1.161.0.10
	msnyder-fork-checkpoint-branchpoint:1.161
	gdb-csl-gxxpro-6_3-branch:1.161.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.161
	gdb_6_4-branch:1.161.0.6
	gdb_6_4-2005-11-01-branchpoint:1.161
	gdb-csl-arm-20051020-branch:1.161.0.4
	gdb-csl-arm-20051020-branchpoint:1.161
	msnyder-tracepoint-checkpoint-branch:1.161.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.161
	gdb-csl-arm-20050325-2005-q1b:1.155
	gdb-csl-arm-20050325-2005-q1a:1.155
	csl-arm-20050325-branch:1.155.0.2
	csl-arm-20050325-branchpoint:1.155
	gdb-post-i18n-errorwarning-20050211:1.152
	gdb-pre-i18n-errorwarning-20050211:1.151
	gdb_6_3-20041109-release:1.131
	gdb_6_3-branch:1.131.0.2
	gdb_6_3-20041019-branchpoint:1.131
	drow_intercu-merge-20040921:1.131
	drow_intercu-merge-20040915:1.131
	jimb-gdb_6_2-e500-branch:1.127.0.6
	jimb-gdb_6_2-e500-branchpoint:1.127
	gdb_6_2-20040730-release:1.127
	gdb_6_2-branch:1.127.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.127
	gdb_6_1_1-20040616-release:1.121
	gdb_6_1-2004-04-05-release:1.121
	drow_intercu-merge-20040402:1.121
	drow_intercu-merge-20040327:1.121
	ezannoni_pie-20040323-branch:1.121.0.10
	ezannoni_pie-20040323-branchpoint:1.121
	cagney_tramp-20040321-mergepoint:1.121
	cagney_tramp-20040309-branch:1.121.0.8
	cagney_tramp-20040309-branchpoint:1.121
	gdb_6_1-branch:1.121.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.121
	drow_intercu-20040221-branch:1.121.0.4
	drow_intercu-20040221-branchpoint:1.121
	cagney_bfdfile-20040213-branch:1.121.0.2
	cagney_bfdfile-20040213-branchpoint:1.121
	drow-cplus-merge-20040208:1.121
	carlton_dictionary-20040126-merge:1.120
	cagney_bigcore-20040122-branch:1.120.0.2
	cagney_bigcore-20040122-branchpoint:1.120
	drow-cplus-merge-20040113:1.119
	drow-cplus-merge-20031224:1.119
	drow-cplus-merge-20031220:1.119
	carlton_dictionary-20031215-merge:1.119
	drow-cplus-merge-20031214:1.119
	carlton-dictionary-20031111-merge:1.119
	gdb_6_0-2003-10-04-release:1.113
	kettenis_sparc-20030918-branch:1.115.0.4
	kettenis_sparc-20030918-branchpoint:1.115
	carlton_dictionary-20030917-merge:1.115
	ezannoni_pie-20030916-branchpoint:1.115
	ezannoni_pie-20030916-branch:1.115.0.2
	cagney_x86i386-20030821-branch:1.113.0.4
	cagney_x86i386-20030821-branchpoint:1.113
	carlton_dictionary-20030805-merge:1.113
	carlton_dictionary-20030627-merge:1.113
	gdb_6_0-branch:1.113.0.2
	gdb_6_0-2003-06-23-branchpoint:1.113
	jimb-ppc64-linux-20030613-branch:1.112.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.112
	cagney_convert-20030606-branch:1.110.0.2
	cagney_convert-20030606-branchpoint:1.110
	cagney_writestrings-20030508-branch:1.108.0.4
	cagney_writestrings-20030508-branchpoint:1.108
	jimb-ppc64-linux-20030528-branch:1.109.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.109
	carlton_dictionary-20030523-merge:1.109
	cagney_fileio-20030521-branch:1.109.0.2
	cagney_fileio-20030521-branchpoint:1.109
	kettenis_i386newframe-20030517-mergepoint:1.109
	jimb-ppc64-linux-20030509-branch:1.108.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.108
	kettenis_i386newframe-20030504-mergepoint:1.105
	carlton_dictionary-20030430-merge:1.105
	kettenis_i386newframe-20030419-branch:1.104.0.6
	kettenis_i386newframe-20030419-branchpoint:1.104
	carlton_dictionary-20030416-merge:1.104
	cagney_frameaddr-20030409-mergepoint:1.104
	kettenis_i386newframe-20030406-branch:1.104.0.4
	kettenis_i386newframe-20030406-branchpoint:1.104
	cagney_frameaddr-20030403-branchpoint:1.104
	cagney_frameaddr-20030403-branch:1.104.0.2
	cagney_framebase-20030330-mergepoint:1.102
	cagney_framebase-20030326-branch:1.98.0.2
	cagney_framebase-20030326-branchpoint:1.98
	cagney_lazyid-20030317-branch:1.94.0.2
	cagney_lazyid-20030317-branchpoint:1.94
	kettenis-i386newframe-20030316-mergepoint:1.94
	offbyone-20030313-branch:1.93.0.6
	offbyone-20030313-branchpoint:1.93
	kettenis-i386newframe-20030308-branch:1.93.0.4
	kettenis-i386newframe-20030308-branchpoint:1.93
	carlton_dictionary-20030305-merge:1.93
	cagney_offbyone-20030303-branch:1.93.0.2
	cagney_offbyone-20030303-branchpoint:1.93
	carlton_dictionary-20030207-merge:1.89
	interps-20030203-mergepoint:1.89
	interps-20030202-branch:1.89.0.2
	interps-20030202-branchpoint:1.89
	cagney-unwind-20030108-branch:1.86.0.2
	cagney-unwind-20030108-branchpoint:1.86
	carlton_dictionary-20021223-merge:1.84
	gdb_5_3-2002-12-12-release:1.69
	carlton_dictionary-20021115-merge:1.79
	kseitz_interps-20021105-merge:1.78
	kseitz_interps-20021103-merge:1.78
	drow-cplus-merge-20021020:1.76
	drow-cplus-merge-20021025:1.78
	carlton_dictionary-20021025-merge:1.78
	carlton_dictionary-20021011-merge:1.75
	drow-cplus-branch:1.75.0.4
	drow-cplus-branchpoint:1.75
	kseitz_interps-20020930-merge:1.75
	carlton_dictionary-20020927-merge:1.75
	carlton_dictionary-branch:1.75.0.2
	carlton_dictionary-20020920-branchpoint:1.75
	gdb_5_3-branch:1.69.0.6
	gdb_5_3-2002-09-04-branchpoint:1.69
	kseitz_interps-20020829-merge:1.69
	cagney_sysregs-20020825-branch:1.69.0.4
	cagney_sysregs-20020825-branchpoint:1.69
	readline_4_3-import-branch:1.69.0.2
	readline_4_3-import-branchpoint:1.69
	gdb_5_2_1-2002-07-23-release:1.52
	kseitz_interps-20020528-branch:1.59.0.4
	kseitz_interps-20020528-branchpoint:1.59
	cagney_regbuf-20020515-branch:1.59.0.2
	cagney_regbuf-20020515-branchpoint:1.59
	jimb-macro-020506-branch:1.56.0.2
	jimb-macro-020506-branchpoint:1.56
	gdb_5_2-2002-04-29-release:1.52
	gdb_5_2-branch:1.52.0.2
	gdb_5_2-2002-03-03-branchpoint:1.52
	gdb_5_1_1-2002-01-24-release:1.38
	gdb_5_1_0_1-2002-01-03-release:1.38
	cygnus_cvs_20020108_pre:1.48
	gdb_5_1_0_1-2002-01-03-branchpoint:1.38
	gdb_5_1_0_1-2002-01-03-branch:1.38.0.6
	gdb_5_1-2001-11-21-release:1.38
	gdb_s390-2001-09-26-branch:1.38.0.4
	gdb_s390-2001-09-26-branchpoint:1.38
	gdb_5_1-2001-07-29-branch:1.38.0.2
	gdb_5_1-2001-07-29-branchpoint:1.38
	dberlin-typesystem-branch:1.36.0.2
	dberlin-typesystem-branchpoint:1.36
	gdb-post-ptid_t-2001-05-03:1.35
	gdb-pre-ptid_t-2001-05-03:1.35
	insight-precleanup-2001-01-01:1.28
	gdb-post-protoization-2000-07-29:1.23
	gdb-pre-protoization-2000-07-29:1.22
	gdb-premipsmulti-2000-06-06-branch:1.16.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.16
	gdb-post-params-removal-2000-06-04:1.16
	gdb-pre-params-removal-2000-06-04:1.16
	gdb-post-params-removal-2000-05-28:1.16
	gdb-pre-params-removal-2000-05-28:1.15
	gdb_5_0-2000-05-19-release:1.8
	gdb_4_18_2-2000-05-18-release:1.8
	gdb_4_95_1-2000-05-11-snapshot:1.8
	gdb_4_95_0-2000-04-27-snapshot:1.8
	gdb_5_0-2000-04-10-branch:1.8.0.2
	gdb_5_0-2000-04-10-branchpoint:1.8
	repo-unification-2000-02-06:1.1.1.11
	insight-2000-02-04:1.1.1.11
	gdb-2000-02-04:1.1.1.11
	gdb-2000-02-02:1.1.1.11
	gdb-2000-02-01:1.1.1.11
	gdb-2000-01-31:1.1.1.11
	gdb-2000-01-26:1.1.1.10
	gdb-2000-01-24:1.1.1.10
	gdb-2000-01-17:1.1.1.10
	gdb-2000-01-10:1.1.1.10
	gdb-2000-01-05:1.1.1.10
	gdb-1999-12-21:1.1.1.10
	gdb-1999-12-13:1.1.1.10
	gdb-1999-12-07:1.1.1.10
	gdb-1999-12-06:1.1.1.10
	gdb-1999-11-16:1.1.1.9
	gdb-1999-11-08:1.1.1.9
	gdb-1999-11-01:1.1.1.9
	gdb-1999-10-25:1.1.1.9
	gdb-1999-10-18:1.1.1.9
	gdb-1999-10-11:1.1.1.8
	gdb-1999-10-04:1.1.1.7
	gdb-1999-09-28:1.1.1.7
	gdb-1999-09-21:1.1.1.7
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.6
	gdb-1999-08-23:1.1.1.6
	gdb-1999-08-16:1.1.1.6
	gdb-1999-08-09:1.1.1.6
	gdb-1999-08-02:1.1.1.6
	gdb-1999-07-26:1.1.1.6
	gdb-1999-07-19:1.1.1.6
	gdb-1999-07-12:1.1.1.6
	gdb-post-reformat-19990707:1.1.1.6
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.6
	gdb-pre-reformat-19990707:1.1.1.5
	gdb-1999-07-07:1.1.1.5
	gdb-1999-07-05:1.1.1.5
	gdb-1999-06-28:1.1.1.4
	gdb-1999-06-21:1.1.1.4
	gdb-1999-06-14:1.1.1.4
	gdb-1999-06-07:1.1.1.4
	gdb-1999-06-01:1.1.1.4
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.318
date	2013.08.29.14.25.22;	author sagovic;	state Exp;
branches;
next	1.317;

1.317
date	2013.08.29.12.25.03;	author sagovic;	state Exp;
branches;
next	1.316;

1.316
date	2013.08.05.15.51.02;	author tromey;	state Exp;
branches;
next	1.315;

1.315
date	2013.08.01.23.59.47;	author devans;	state Exp;
branches;
next	1.314;

1.314
date	2013.07.18.23.09.49;	author qiyao;	state Exp;
branches;
next	1.313;

1.313
date	2013.07.04.09.49.43;	author aburgess;	state Exp;
branches;
next	1.312;

1.312
date	2013.02.11.18.05.33;	author sergiodj;	state Exp;
branches;
next	1.311;

1.311
date	2013.01.31.18.37.37;	author aristovski;	state Exp;
branches;
next	1.310;

1.310
date	2013.01.25.22.31.43;	author sivachandra;	state Exp;
branches;
next	1.309;

1.309
date	2013.01.25.17.16.41;	author aburgess;	state Exp;
branches;
next	1.308;

1.308
date	2013.01.01.06.41.29;	author brobecke;	state Exp;
branches;
next	1.307;

1.307
date	2012.12.14.17.16.16;	author tromey;	state Exp;
branches;
next	1.306;

1.306
date	2012.12.06.21.41.02;	author tromey;	state Exp;
branches;
next	1.305;

1.305
date	2012.12.03.19.59.14;	author tromey;	state Exp;
branches;
next	1.304;

1.304
date	2012.09.27.08.57.16;	author siddhesh;	state Exp;
branches;
next	1.303;

1.303
date	2012.09.25.12.48.53;	author siddhesh;	state Exp;
branches;
next	1.302;

1.302
date	2012.09.14.00.54.58;	author qiyao;	state Exp;
branches;
next	1.301;

1.301
date	2012.08.16.07.36.20;	author qiyao;	state Exp;
branches;
next	1.300;

1.300
date	2012.08.13.00.54.04;	author qiyao;	state Exp;
branches;
next	1.299;

1.299
date	2012.08.02.09.36.40;	author qiyao;	state Exp;
branches;
next	1.298;

1.298
date	2012.07.23.18.08.29;	author siddhesh;	state Exp;
branches;
next	1.297;

1.297
date	2012.06.24.07.28.10;	author qiyao;	state Exp;
branches;
next	1.296;

1.296
date	2012.06.15.14.38.30;	author tromey;	state Exp;
branches;
next	1.295;

1.295
date	2012.06.15.14.35.33;	author tromey;	state Exp;
branches;
next	1.294;

1.294
date	2012.05.21.19.47.53;	author tromey;	state Exp;
branches;
next	1.293;

1.293
date	2012.02.21.13.48.59;	author xgsa;	state Exp;
branches;
next	1.292;

1.292
date	2012.02.07.04.48.23;	author devans;	state Exp;
branches;
next	1.291;

1.291
date	2012.01.04.08.27.57;	author brobecke;	state Exp;
branches;
next	1.290;

1.290
date	2011.11.09.19.50.13;	author tromey;	state Exp;
branches
	1.290.2.1;
next	1.289;

1.289
date	2011.10.20.12.31.28;	author pmuldoon;	state Exp;
branches;
next	1.288;

1.288
date	2011.10.14.20.22.17;	author kseitz;	state Exp;
branches;
next	1.287;

1.287
date	2011.10.09.19.36.06;	author jkratoch;	state Exp;
branches;
next	1.286;

1.286
date	2011.09.08.15.26.08;	author jkratoch;	state Exp;
branches;
next	1.285;

1.285
date	2011.09.08.14.54.19;	author jkratoch;	state Exp;
branches;
next	1.284;

1.284
date	2011.07.27.19.31.30;	author jkratoch;	state Exp;
branches;
next	1.283;

1.283
date	2011.07.27.19.25.56;	author jkratoch;	state Exp;
branches;
next	1.282;

1.282
date	2011.07.14.15.00.20;	author jkratoch;	state Exp;
branches;
next	1.281;

1.281
date	2011.06.30.19.29.54;	author tromey;	state Exp;
branches;
next	1.280;

1.280
date	2011.06.27.19.21.50;	author tromey;	state Exp;
branches;
next	1.279;

1.279
date	2011.06.17.20.46.47;	author tromey;	state Exp;
branches;
next	1.278;

1.278
date	2011.06.17.20.35.09;	author tromey;	state Exp;
branches;
next	1.277;

1.277
date	2011.06.17.20.24.22;	author tromey;	state Exp;
branches;
next	1.276;

1.276
date	2011.05.06.14.12.18;	author jkratoch;	state Exp;
branches;
next	1.275;

1.275
date	2011.03.29.17.04.30;	author tromey;	state Exp;
branches;
next	1.274;

1.274
date	2011.03.18.18.42.41;	author palves;	state Exp;
branches;
next	1.273;

1.273
date	2011.02.26.02.07.09;	author msnyder;	state Exp;
branches;
next	1.272;

1.272
date	2011.02.14.11.35.45;	author palves;	state Exp;
branches;
next	1.271;

1.271
date	2011.02.14.11.32.16;	author palves;	state Exp;
branches;
next	1.270;

1.270
date	2011.02.14.11.30.37;	author palves;	state Exp;
branches;
next	1.269;

1.269
date	2011.02.14.11.27.36;	author palves;	state Exp;
branches;
next	1.268;

1.268
date	2011.02.14.11.25.59;	author palves;	state Exp;
branches;
next	1.267;

1.267
date	2011.02.14.11.21.25;	author palves;	state Exp;
branches;
next	1.266;

1.266
date	2011.01.29.10.30.19;	author jkratoch;	state Exp;
branches;
next	1.265;

1.265
date	2011.01.12.16.10.05;	author jkratoch;	state Exp;
branches;
next	1.264;

1.264
date	2011.01.12.01.23.28;	author msnyder;	state Exp;
branches;
next	1.263;

1.263
date	2011.01.11.15.10.02;	author msnyder;	state Exp;
branches;
next	1.262;

1.262
date	2011.01.05.22.22.53;	author msnyder;	state Exp;
branches;
next	1.261;

1.261
date	2011.01.01.15.33.19;	author brobecke;	state Exp;
branches;
next	1.260;

1.260
date	2010.12.14.10.23.41;	author kwerner;	state Exp;
branches;
next	1.259;

1.259
date	2010.12.01.16.49.41;	author uweigand;	state Exp;
branches;
next	1.258;

1.258
date	2010.11.29.21.18.16;	author tromey;	state Exp;
branches;
next	1.257;

1.257
date	2010.11.10.17.47.23;	author devans;	state Exp;
branches;
next	1.256;

1.256
date	2010.11.04.20.26.23;	author swagiaal;	state Exp;
branches;
next	1.255;

1.255
date	2010.11.03.14.21.57;	author kwerner;	state Exp;
branches;
next	1.254;

1.254
date	2010.11.03.14.06.27;	author kwerner;	state Exp;
branches;
next	1.253;

1.253
date	2010.10.19.20.53.15;	author swagiaal;	state Exp;
branches;
next	1.252;

1.252
date	2010.10.08.16.50.53;	author kwerner;	state Exp;
branches;
next	1.251;

1.251
date	2010.09.24.14.47.53;	author swagiaal;	state Exp;
branches;
next	1.250;

1.250
date	2010.09.22.15.48.58;	author swagiaal;	state Exp;
branches;
next	1.249;

1.249
date	2010.07.14.14.54.58;	author kwerner;	state Exp;
branches;
next	1.248;

1.248
date	2010.06.28.20.35.52;	author jkratoch;	state Exp;
branches
	1.248.2.1;
next	1.247;

1.247
date	2010.06.27.16.26.41;	author devans;	state Exp;
branches;
next	1.246;

1.246
date	2010.06.11.15.36.05;	author tromey;	state Exp;
branches;
next	1.245;

1.245
date	2010.06.07.16.11.31;	author swagiaal;	state Exp;
branches;
next	1.244;

1.244
date	2010.05.17.18.48.51;	author msnyder;	state Exp;
branches;
next	1.243;

1.243
date	2010.05.08.09.26.47;	author muller;	state Exp;
branches;
next	1.242;

1.242
date	2010.05.07.18.49.26;	author msnyder;	state Exp;
branches;
next	1.241;

1.241
date	2010.05.07.14.46.26;	author swagiaal;	state Exp;
branches;
next	1.240;

1.240
date	2010.05.06.18.26.13;	author msnyder;	state Exp;
branches;
next	1.239;

1.239
date	2010.03.15.17.29.36;	author swagiaal;	state Exp;
branches;
next	1.238;

1.238
date	2010.03.09.18.09.08;	author kseitz;	state Exp;
branches;
next	1.237;

1.237
date	2010.02.08.20.55.43;	author tromey;	state Exp;
branches;
next	1.236;

1.236
date	2010.02.04.21.04.30;	author tromey;	state Exp;
branches;
next	1.235;

1.235
date	2010.02.02.23.40.27;	author tromey;	state Exp;
branches;
next	1.234;

1.234
date	2010.02.02.16.45.16;	author tromey;	state Exp;
branches;
next	1.233;

1.233
date	2010.01.26.16.47.34;	author swagiaal;	state Exp;
branches;
next	1.232;

1.232
date	2010.01.18.20.54.34;	author tromey;	state Exp;
branches;
next	1.231;

1.231
date	2010.01.01.07.31.43;	author brobecke;	state Exp;
branches;
next	1.230;

1.230
date	2009.12.10.20.57.10;	author cmoller;	state Exp;
branches;
next	1.229;

1.229
date	2009.12.04.20.26.33;	author drow;	state Exp;
branches;
next	1.228;

1.228
date	2009.12.02.19.29.42;	author ppluzhnikov;	state Exp;
branches;
next	1.227;

1.227
date	2009.11.10.22.17.58;	author kseitz;	state Exp;
branches;
next	1.226;

1.226
date	2009.09.28.09.16.15;	author uweigand;	state Exp;
branches;
next	1.225;

1.225
date	2009.08.31.20.18.45;	author devans;	state Exp;
branches
	1.225.2.1;
next	1.224;

1.224
date	2009.07.21.18.15.32;	author drow;	state Exp;
branches;
next	1.223;

1.223
date	2009.07.02.17.25.59;	author uweigand;	state Exp;
branches;
next	1.222;

1.222
date	2009.07.02.17.21.07;	author uweigand;	state Exp;
branches;
next	1.221;

1.221
date	2009.07.02.12.57.14;	author uweigand;	state Exp;
branches;
next	1.220;

1.220
date	2009.07.02.12.42.36;	author uweigand;	state Exp;
branches;
next	1.219;

1.219
date	2009.07.02.12.20.17;	author uweigand;	state Exp;
branches;
next	1.218;

1.218
date	2009.07.02.12.18.46;	author uweigand;	state Exp;
branches;
next	1.217;

1.217
date	2009.06.28.00.20.22;	author drow;	state Exp;
branches;
next	1.216;

1.216
date	2009.06.24.16.51.57;	author uweigand;	state Exp;
branches;
next	1.215;

1.215
date	2009.06.17.18.47.35;	author uweigand;	state Exp;
branches;
next	1.214;

1.214
date	2009.06.17.18.43.24;	author uweigand;	state Exp;
branches;
next	1.213;

1.213
date	2009.06.16.18.39.41;	author kseitz;	state Exp;
branches;
next	1.212;

1.212
date	2009.06.03.18.16.44;	author uweigand;	state Exp;
branches;
next	1.211;

1.211
date	2009.05.28.00.53.52;	author tromey;	state Exp;
branches;
next	1.210;

1.210
date	2009.03.20.23.04.34;	author tromey;	state Exp;
branches;
next	1.209;

1.209
date	2009.02.06.22.50.52;	author palves;	state Exp;
branches;
next	1.208;

1.208
date	2009.02.02.21.50.12;	author tromey;	state Exp;
branches;
next	1.207;

1.207
date	2009.01.15.15.38.07;	author uweigand;	state Exp;
branches;
next	1.206;

1.206
date	2009.01.13.10.34.31;	author palves;	state Exp;
branches;
next	1.205;

1.205
date	2009.01.03.05.57.54;	author brobecke;	state Exp;
branches;
next	1.204;

1.204
date	2008.12.29.06.02.06;	author brobecke;	state Exp;
branches;
next	1.203;

1.203
date	2008.11.26.16.27.28;	author guitton;	state Exp;
branches;
next	1.202;

1.202
date	2008.10.08.12.49.13;	author jkratoch;	state Exp;
branches;
next	1.201;

1.201
date	2008.10.02.22.06.07;	author jkratoch;	state Exp;
branches;
next	1.200;

1.200
date	2008.09.11.14.27.34;	author uweigand;	state Exp;
branches;
next	1.199;

1.199
date	2008.09.11.14.27.00;	author uweigand;	state Exp;
branches;
next	1.198;

1.198
date	2008.09.11.14.24.28;	author uweigand;	state Exp;
branches;
next	1.197;

1.197
date	2008.09.11.14.22.33;	author uweigand;	state Exp;
branches;
next	1.196;

1.196
date	2008.09.11.14.17.58;	author uweigand;	state Exp;
branches;
next	1.195;

1.195
date	2008.09.08.22.16.51;	author drow;	state Exp;
branches;
next	1.194;

1.194
date	2008.08.21.20.13.08;	author uweigand;	state Exp;
branches;
next	1.193;

1.193
date	2008.07.27.02.00.03;	author tromey;	state Exp;
branches;
next	1.192;

1.192
date	2008.07.15.22.13.42;	author schwab;	state Exp;
branches;
next	1.191;

1.191
date	2008.06.06.18.29.00;	author ppluzhnikov;	state Exp;
branches;
next	1.190;

1.190
date	2008.05.19.15.50.10;	author uweigand;	state Exp;
branches;
next	1.189;

1.189
date	2008.05.19.15.49.14;	author uweigand;	state Exp;
branches;
next	1.188;

1.188
date	2008.04.30.21.16.45;	author drow;	state Exp;
branches;
next	1.187;

1.187
date	2008.04.30.21.13.49;	author drow;	state Exp;
branches;
next	1.186;

1.186
date	2008.04.06.08.56.36;	author vprus;	state Exp;
branches;
next	1.185;

1.185
date	2008.04.01.16.12.49;	author aristovski;	state Exp;
branches;
next	1.184;

1.184
date	2008.03.21.15.02.37;	author drow;	state Exp;
branches;
next	1.183;

1.183
date	2008.02.04.00.23.04;	author devans;	state Exp;
branches;
next	1.182;

1.182
date	2008.01.18.17.07.40;	author deuling;	state Exp;
branches;
next	1.181;

1.181
date	2008.01.07.22.33.57;	author bauermann;	state Exp;
branches;
next	1.180;

1.180
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.179;

1.179
date	2007.11.02.19.35.19;	author uweigand;	state Exp;
branches;
next	1.178;

1.178
date	2007.08.23.18.08.46;	author brobecke;	state Exp;
branches;
next	1.177;

1.177
date	2007.08.22.01.53.19;	author msnyder;	state Exp;
branches;
next	1.176;

1.176
date	2007.08.14.00.31.40;	author msnyder;	state Exp;
branches;
next	1.175;

1.175
date	2007.06.13.17.59.51;	author uweigand;	state Exp;
branches;
next	1.174;

1.174
date	2007.06.12.16.51.13;	author uweigand;	state Exp;
branches;
next	1.173;

1.173
date	2007.06.09.14.12.52;	author uweigand;	state Exp;
branches;
next	1.172;

1.172
date	2007.06.06.15.23.06;	author uweigand;	state Exp;
branches;
next	1.171;

1.171
date	2007.06.05.22.47.50;	author uweigand;	state Exp;
branches;
next	1.170;

1.170
date	2007.02.27.19.46.04;	author drow;	state Exp;
branches;
next	1.169;

1.169
date	2007.02.22.15.13.26;	author uweigand;	state Exp;
branches;
next	1.168;

1.168
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.167;

1.167
date	2007.01.08.17.34.12;	author uweigand;	state Exp;
branches;
next	1.166;

1.166
date	2007.01.03.18.05.43;	author drow;	state Exp;
branches;
next	1.165;

1.165
date	2006.10.09.19.28.14;	author drow;	state Exp;
branches;
next	1.164;

1.164
date	2006.07.13.04.31.42;	author drow;	state Exp;
branches;
next	1.163;

1.163
date	2005.12.17.22.34.03;	author eliz;	state Exp;
branches
	1.163.2.1
	1.163.4.1
	1.163.12.1;
next	1.162;

1.162
date	2005.12.07.23.07.53;	author drow;	state Exp;
branches;
next	1.161;

1.161
date	2005.05.27.04.39.32;	author cagney;	state Exp;
branches;
next	1.160;

1.160
date	2005.05.26.20.48.59;	author cagney;	state Exp;
branches;
next	1.159;

1.159
date	2005.05.22.14.53.34;	author cagney;	state Exp;
branches;
next	1.158;

1.158
date	2005.05.19.17.55.53;	author cagney;	state Exp;
branches;
next	1.157;

1.157
date	2005.05.09.21.20.35;	author cagney;	state Exp;
branches;
next	1.156;

1.156
date	2005.04.28.16.15.17;	author cagney;	state Exp;
branches;
next	1.155;

1.155
date	2005.02.24.13.51.35;	author cagney;	state Exp;
branches;
next	1.154;

1.154
date	2005.02.18.15.25.29;	author cagney;	state Exp;
branches;
next	1.153;

1.153
date	2005.02.11.18.13.54;	author cagney;	state Exp;
branches;
next	1.152;

1.152
date	2005.02.11.04.06.08;	author cagney;	state Exp;
branches;
next	1.151;

1.151
date	2005.02.08.02.29.18;	author cagney;	state Exp;
branches;
next	1.150;

1.150
date	2005.02.08.00.25.31;	author cagney;	state Exp;
branches;
next	1.149;

1.149
date	2005.02.07.23.51.03;	author cagney;	state Exp;
branches;
next	1.148;

1.148
date	2005.02.07.20.17.28;	author cagney;	state Exp;
branches;
next	1.147;

1.147
date	2005.02.07.17.06.29;	author cagney;	state Exp;
branches;
next	1.146;

1.146
date	2005.02.07.15.04.43;	author cagney;	state Exp;
branches;
next	1.145;

1.145
date	2005.02.07.00.09.55;	author cagney;	state Exp;
branches;
next	1.144;

1.144
date	2005.02.02.22.34.35;	author cagney;	state Exp;
branches;
next	1.143;

1.143
date	2005.02.02.21.36.15;	author cagney;	state Exp;
branches;
next	1.142;

1.142
date	2005.02.02.20.31.34;	author cagney;	state Exp;
branches;
next	1.141;

1.141
date	2005.02.02.00.20.05;	author cagney;	state Exp;
branches;
next	1.140;

1.140
date	2005.01.28.16.45.15;	author cagney;	state Exp;
branches;
next	1.139;

1.139
date	2004.11.21.19.52.13;	author drow;	state Exp;
branches;
next	1.138;

1.138
date	2004.11.15.22.17.59;	author cagney;	state Exp;
branches;
next	1.137;

1.137
date	2004.11.13.02.29.48;	author cagney;	state Exp;
branches;
next	1.136;

1.136
date	2004.11.13.00.53.09;	author cagney;	state Exp;
branches;
next	1.135;

1.135
date	2004.11.12.21.45.07;	author cagney;	state Exp;
branches;
next	1.134;

1.134
date	2004.11.10.18.52.24;	author cagney;	state Exp;
branches;
next	1.133;

1.133
date	2004.11.09.14.43.26;	author cagney;	state Exp;
branches;
next	1.132;

1.132
date	2004.11.02.14.18.13;	author cagney;	state Exp;
branches;
next	1.131;

1.131
date	2004.09.14.03.01.48;	author jimb;	state Exp;
branches;
next	1.130;

1.130
date	2004.09.14.02.51.27;	author jimb;	state Exp;
branches;
next	1.129;

1.129
date	2004.08.03.00.57.27;	author cagney;	state Exp;
branches;
next	1.128;

1.128
date	2004.07.26.14.53.05;	author cagney;	state Exp;
branches;
next	1.127;

1.127
date	2004.06.10.17.39.27;	author cagney;	state Exp;
branches;
next	1.126;

1.126
date	2004.05.05.15.42.53;	author cagney;	state Exp;
branches;
next	1.125;

1.125
date	2004.04.30.14.12.46;	author cagney;	state Exp;
branches;
next	1.124;

1.124
date	2004.04.26.09.49.36;	author orjanf;	state Exp;
branches;
next	1.123;

1.123
date	2004.04.21.23.52.21;	author cagney;	state Exp;
branches;
next	1.122;

1.122
date	2004.04.08.21.18.13;	author cagney;	state Exp;
branches;
next	1.121;

1.121
date	2004.02.02.20.44.52;	author carlton;	state Exp;
branches
	1.121.4.1;
next	1.120;

1.120
date	2004.01.14.16.54.41;	author carlton;	state Exp;
branches;
next	1.119;

1.119
date	2003.11.08.00.13.03;	author cagney;	state Exp;
branches;
next	1.118;

1.118
date	2003.11.06.22.54.01;	author cagney;	state Exp;
branches;
next	1.117;

1.117
date	2003.10.02.20.28.30;	author cagney;	state Exp;
branches;
next	1.116;

1.116
date	2003.09.25.16.39.38;	author carlton;	state Exp;
branches;
next	1.115;

1.115
date	2003.09.16.18.56.35;	author cagney;	state Exp;
branches;
next	1.114;

1.114
date	2003.09.14.16.32.14;	author cagney;	state Exp;
branches;
next	1.113;

1.113
date	2003.06.14.22.35.25;	author cagney;	state Exp;
branches;
next	1.112;

1.112
date	2003.06.12.15.33.45;	author carlton;	state Exp;
branches;
next	1.111;

1.111
date	2003.06.11.23.29.48;	author carlton;	state Exp;
branches;
next	1.110;

1.110
date	2003.06.05.20.59.16;	author cagney;	state Exp;
branches
	1.110.2.1;
next	1.109;

1.109
date	2003.05.14.17.43.20;	author ezannoni;	state Exp;
branches;
next	1.108;

1.108
date	2003.05.08.22.03.35;	author carlton;	state Exp;
branches;
next	1.107;

1.107
date	2003.05.08.20.52.49;	author cagney;	state Exp;
branches;
next	1.106;

1.106
date	2003.05.05.17.56.56;	author cagney;	state Exp;
branches;
next	1.105;

1.105
date	2003.04.21.16.48.40;	author cagney;	state Exp;
branches;
next	1.104;

1.104
date	2003.03.31.23.52.38;	author cagney;	state Exp;
branches
	1.104.6.1;
next	1.103;

1.103
date	2003.03.31.19.01.21;	author cagney;	state Exp;
branches;
next	1.102;

1.102
date	2003.03.30.14.59.01;	author cagney;	state Exp;
branches;
next	1.101;

1.101
date	2003.03.30.14.32.09;	author cagney;	state Exp;
branches;
next	1.100;

1.100
date	2003.03.27.15.29.44;	author cagney;	state Exp;
branches;
next	1.99;

1.99
date	2003.03.26.22.39.52;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2003.03.25.22.56.40;	author cagney;	state Exp;
branches
	1.98.2.1;
next	1.97;

1.97
date	2003.03.25.20.38.47;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2003.03.25.18.54.16;	author cagney;	state Exp;
branches;
next	1.95;

1.95
date	2003.03.24.03.54.50;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2003.03.13.21.45.41;	author cagney;	state Exp;
branches;
next	1.93;

1.93
date	2003.02.27.17.48.47;	author cagney;	state Exp;
branches
	1.93.4.1;
next	1.92;

1.92
date	2003.02.25.21.36.21;	author carlton;	state Exp;
branches;
next	1.91;

1.91
date	2003.02.20.17.17.25;	author carlton;	state Exp;
branches;
next	1.90;

1.90
date	2003.02.20.00.01.07;	author carlton;	state Exp;
branches;
next	1.89;

1.89
date	2003.01.30.16.44.20;	author drow;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2003.01.21.19.43.48;	author cagney;	state Exp;
branches;
next	1.87;

1.87
date	2003.01.19.17.39.16;	author cagney;	state Exp;
branches;
next	1.86;

1.86
date	2003.01.04.22.37.47;	author drow;	state Exp;
branches
	1.86.2.1;
next	1.85;

1.85
date	2003.01.02.14.27.27;	author cagney;	state Exp;
branches;
next	1.84;

1.84
date	2002.12.04.00.05.53;	author cagney;	state Exp;
branches;
next	1.83;

1.83
date	2002.11.29.19.15.15;	author cagney;	state Exp;
branches;
next	1.82;

1.82
date	2002.11.28.21.38.43;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2002.11.24.19.48.13;	author cagney;	state Exp;
branches;
next	1.80;

1.80
date	2002.11.22.16.32.45;	author schwab;	state Exp;
branches;
next	1.79;

1.79
date	2002.11.07.02.45.27;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2002.10.23.21.33.07;	author msnyder;	state Exp;
branches;
next	1.77;

1.77
date	2002.10.23.19.22.28;	author msnyder;	state Exp;
branches;
next	1.76;

1.76
date	2002.10.14.02.02.42;	author fedor;	state Exp;
branches;
next	1.75;

1.75
date	2002.09.19.03.58.41;	author cagney;	state Exp;
branches
	1.75.2.1
	1.75.4.1;
next	1.74;

1.74
date	2002.09.19.01.34.51;	author msnyder;	state Exp;
branches;
next	1.73;

1.73
date	2002.09.18.15.37.18;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2002.09.14.02.09.39;	author drow;	state Exp;
branches;
next	1.71;

1.71
date	2002.09.13.00.38.48;	author brobecke;	state Exp;
branches;
next	1.70;

1.70
date	2002.09.13.00.18.33;	author brobecke;	state Exp;
branches;
next	1.69;

1.69
date	2002.08.21.17.24.31;	author jimb;	state Exp;
branches;
next	1.68;

1.68
date	2002.08.21.15.34.36;	author kseitz;	state Exp;
branches;
next	1.67;

1.67
date	2002.08.19.23.19.53;	author carlton;	state Exp;
branches;
next	1.66;

1.66
date	2002.08.01.17.18.33;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2002.07.12.19.15.30;	author drow;	state Exp;
branches;
next	1.64;

1.64
date	2002.07.10.17.18.16;	author drow;	state Exp;
branches;
next	1.63;

1.63
date	2002.07.03.20.36.54;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2002.07.03.18.31.29;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2002.06.18.23.41.02;	author dhoward;	state Exp;
branches;
next	1.60;

1.60
date	2002.06.14.14.34.26;	author drow;	state Exp;
branches;
next	1.59;

1.59
date	2002.05.13.14.00.36;	author drow;	state Exp;
branches
	1.59.2.1
	1.59.4.1;
next	1.58;

1.58
date	2002.05.12.03.09.12;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2002.05.12.02.20.38;	author drow;	state Exp;
branches;
next	1.56;

1.56
date	2002.05.02.19.00.36;	author ezannoni;	state Exp;
branches;
next	1.55;

1.55
date	2002.04.26.03.37.42;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2002.04.23.03.00.57;	author thorpej;	state Exp;
branches;
next	1.53;

1.53
date	2002.03.22.18.57.08;	author drow;	state Exp;
branches;
next	1.52;

1.52
date	2002.02.16.22.25.49;	author drow;	state Exp;
branches;
next	1.51;

1.51
date	2002.02.10.05.50.34;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2002.02.04.02.14.46;	author drow;	state Exp;
branches;
next	1.49;

1.49
date	2002.01.08.02.09.31;	author msnyder;	state Exp;
branches;
next	1.48;

1.48
date	2002.01.06.22.09.08;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2002.01.05.04.30.19;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2002.01.04.17.51.38;	author drow;	state Exp;
branches;
next	1.45;

1.45
date	2002.01.04.05.20.08;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2001.12.12.02.11.52;	author fnf;	state Exp;
branches;
next	1.43;

1.43
date	2001.12.07.22.16.43;	author drow;	state Exp;
branches;
next	1.42;

1.42
date	2001.12.07.22.14.30;	author drow;	state Exp;
branches;
next	1.41;

1.41
date	2001.11.13.16.44.13;	author jimb;	state Exp;
branches;
next	1.40;

1.40
date	2001.11.06.18.06.00;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2001.10.16.01.58.07;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2001.07.10.21.24.48;	author jimb;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.10.21.15.28;	author jimb;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.19.15.20.14;	author dberlin;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2001.04.27.00.19.09;	author jimb;	state Exp;
branches;
next	1.34;

1.34
date	2001.03.19.20.08.16;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.06.08.21.18;	author kevinb;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.01.01.39.22;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2001.02.06.20.05.41;	author msnyder;	state Exp;
branches;
next	1.30;

1.30
date	2001.02.06.18.07.48;	author taylor;	state Exp;
branches;
next	1.29;

1.29
date	2001.01.04.19.58.31;	author nsd;	state Exp;
branches;
next	1.28;

1.28
date	2000.12.15.01.01.50;	author kevinb;	state Exp;
branches;
next	1.27;

1.27
date	2000.11.08.05.10.18;	author kevinb;	state Exp;
branches;
next	1.26;

1.26
date	2000.10.26.07.41.25;	author schauer;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.30.00.58.58;	author msnyder;	state Exp;
branches;
next	1.24;

1.24
date	2000.08.04.03.17.57;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.17.19.41.10;	author dberlin;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.15.17.40.30;	author dberlin;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.12.08.31.49;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2000.07.09.05.15.50;	author nsd;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.15.18.54.48;	author msnyder;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.12.14.39.14;	author fnasser;	state Exp;
branches;
next	1.16;

1.16
date	2000.05.28.01.12.33;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.22.09.02.23;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.20.10.29.51;	author jtc;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.15.06.27.18;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.22.06.44.39;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.21.04.17.18;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.17.02.27.37;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.14.18.43.41;	author jimb;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.09.13.02.10;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.04.04.53.50;	author dberlin;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.13.10.01.23;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.13.07.30.00;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.10.08.02.58;	author dberlin;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.23.15.53.33;	author fnasser;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.22.19.17.27;	author jimb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.290.2.1
date	2012.01.06.04.54.33;	author brobecke;	state Exp;
branches;
next	;

1.248.2.1
date	2010.09.23.20.07.38;	author swagiaal;	state Exp;
branches;
next	;

1.225.2.1
date	2009.09.29.00.41.24;	author uweigand;	state Exp;
branches;
next	;

1.163.2.1
date	2006.04.03.00.47.41;	author drow;	state Exp;
branches;
next	;

1.163.4.1
date	2006.04.02.21.52.40;	author drow;	state Exp;
branches;
next	;

1.163.12.1
date	2006.08.28.07.48.47;	author nickrob;	state Exp;
branches;
next	;

1.121.4.1
date	2004.09.16.17.01.26;	author drow;	state Exp;
branches;
next	;

1.110.2.1
date	2003.06.06.18.02.30;	author cagney;	state Exp;
branches;
next	1.110.2.2;

1.110.2.2
date	2003.06.08.22.14.42;	author cagney;	state Exp;
branches;
next	1.110.2.3;

1.110.2.3
date	2003.06.09.17.41.21;	author kettenis;	state Exp;
branches;
next	;

1.104.6.1
date	2003.05.04.11.37.46;	author kettenis;	state Exp;
branches;
next	1.104.6.2;

1.104.6.2
date	2003.05.18.09.44.26;	author kettenis;	state Exp;
branches;
next	;

1.98.2.1
date	2003.03.30.16.35.23;	author cagney;	state Exp;
branches;
next	;

1.93.4.1
date	2003.03.16.14.01.51;	author kettenis;	state Exp;
branches;
next	;

1.89.2.1
date	2003.02.03.06.02.45;	author cagney;	state Exp;
branches;
next	1.89.2.2;

1.89.2.2
date	2003.02.04.01.26.54;	author cagney;	state Exp;
branches;
next	;

1.86.2.1
date	2003.01.20.00.38.14;	author cagney;	state Exp;
branches;
next	;

1.75.2.1
date	2002.09.24.00.04.52;	author carlton;	state Exp;
branches;
next	1.75.2.2;

1.75.2.2
date	2002.10.18.23.42.58;	author carlton;	state Exp;
branches;
next	1.75.2.3;

1.75.2.3
date	2002.10.25.23.49.55;	author carlton;	state Exp;
branches;
next	1.75.2.4;

1.75.2.4
date	2002.11.15.19.19.00;	author carlton;	state Exp;
branches;
next	1.75.2.5;

1.75.2.5
date	2002.11.23.00.42.54;	author carlton;	state Exp;
branches;
next	1.75.2.6;

1.75.2.6
date	2002.11.24.18.47.18;	author carlton;	state Exp;
branches;
next	1.75.2.7;

1.75.2.7
date	2002.11.28.00.53.24;	author carlton;	state Exp;
branches;
next	1.75.2.8;

1.75.2.8
date	2002.12.21.00.17.44;	author carlton;	state Exp;
branches;
next	1.75.2.9;

1.75.2.9
date	2002.12.23.19.38.49;	author carlton;	state Exp;
branches;
next	1.75.2.10;

1.75.2.10
date	2003.01.25.01.04.30;	author carlton;	state Exp;
branches;
next	1.75.2.11;

1.75.2.11
date	2003.01.29.01.23.20;	author carlton;	state Exp;
branches;
next	1.75.2.12;

1.75.2.12
date	2003.02.01.01.17.22;	author carlton;	state Exp;
branches;
next	1.75.2.13;

1.75.2.13
date	2003.02.07.19.17.54;	author carlton;	state Exp;
branches;
next	1.75.2.14;

1.75.2.14
date	2003.02.12.00.38.07;	author carlton;	state Exp;
branches;
next	1.75.2.15;

1.75.2.15
date	2003.02.12.23.37.10;	author carlton;	state Exp;
branches;
next	1.75.2.16;

1.75.2.16
date	2003.02.22.01.33.13;	author carlton;	state Exp;
branches;
next	1.75.2.17;

1.75.2.17
date	2003.03.06.00.56.33;	author carlton;	state Exp;
branches;
next	1.75.2.18;

1.75.2.18
date	2003.03.07.22.52.55;	author carlton;	state Exp;
branches;
next	1.75.2.19;

1.75.2.19
date	2003.04.16.19.56.57;	author carlton;	state Exp;
branches;
next	1.75.2.20;

1.75.2.20
date	2003.05.01.00.46.53;	author carlton;	state Exp;
branches;
next	1.75.2.21;

1.75.2.21
date	2003.05.08.01.10.52;	author carlton;	state Exp;
branches;
next	1.75.2.22;

1.75.2.22
date	2003.05.23.18.40.46;	author carlton;	state Exp;
branches;
next	1.75.2.23;

1.75.2.23
date	2003.06.27.21.50.13;	author carlton;	state Exp;
branches;
next	1.75.2.24;

1.75.2.24
date	2003.09.17.21.28.35;	author carlton;	state Exp;
branches;
next	1.75.2.25;

1.75.2.25
date	2003.09.20.00.32.31;	author carlton;	state Exp;
branches;
next	1.75.2.26;

1.75.2.26
date	2003.11.11.23.50.58;	author carlton;	state Exp;
branches;
next	1.75.2.27;

1.75.2.27
date	2003.11.12.00.20.58;	author carlton;	state Exp;
branches;
next	1.75.2.28;

1.75.2.28
date	2004.01.26.19.11.34;	author carlton;	state Exp;
branches;
next	;

1.75.4.1
date	2002.10.26.17.12.09;	author drow;	state Exp;
branches;
next	1.75.4.2;

1.75.4.2
date	2003.12.14.20.27.33;	author drow;	state Exp;
branches;
next	1.75.4.3;

1.75.4.3
date	2004.02.09.19.43.49;	author drow;	state Exp;
branches;
next	;

1.59.2.1
date	2002.05.16.00.54.56;	author cagney;	state Exp;
branches;
next	1.59.2.2;

1.59.2.2
date	2002.05.16.19.08.01;	author cagney;	state Exp;
branches;
next	1.59.2.3;

1.59.2.3
date	2002.06.15.16.42.55;	author cagney;	state Exp;
branches;
next	1.59.2.4;

1.59.2.4
date	2002.06.21.16.19.32;	author cagney;	state Exp;
branches;
next	1.59.2.5;

1.59.2.5
date	2002.07.03.18.43.58;	author cagney;	state Exp;
branches;
next	;

1.59.4.1
date	2002.06.20.01.33.16;	author kseitz;	state Exp;
branches;
next	1.59.4.2;

1.59.4.2
date	2002.07.22.21.47.04;	author kseitz;	state Exp;
branches;
next	1.59.4.3;

1.59.4.3
date	2002.07.22.22.00.25;	author kseitz;	state Exp;
branches;
next	1.59.4.4;

1.59.4.4
date	2002.08.09.18.34.27;	author kseitz;	state Exp;
branches;
next	1.59.4.5;

1.59.4.5
date	2002.08.21.16.33.23;	author kseitz;	state Exp;
branches;
next	1.59.4.6;

1.59.4.6
date	2002.08.30.22.52.46;	author kseitz;	state Exp;
branches;
next	1.59.4.7;

1.59.4.7
date	2002.10.01.00.46.15;	author kseitz;	state Exp;
branches;
next	1.59.4.8;

1.59.4.8
date	2002.11.04.00.17.33;	author ezannoni;	state Exp;
branches;
next	;

1.36.2.1
date	2001.07.06.19.17.04;	author dberlin;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.04;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.47;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.25.18.03.48;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.06.01.15.40.56;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.05.17.54.18;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.07.07.20.11.04;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.09.22.03.25.12;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.10.12.04.37.25;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.10.19.02.46.40;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.12.07.03.56.07;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2000.02.01.03.19.12;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.318
log
@2013-08-29  Sanimir Agovic  <sanimir.agovic@@intel.com>

	* valops.c (do_search_struct_field): Pass v2 instead of base_type to
	value_type.
@
text
@/* Perform non-arithmetic operations on values, for GDB.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "value.h"
#include "frame.h"
#include "inferior.h"
#include "gdbcore.h"
#include "target.h"
#include "demangle.h"
#include "language.h"
#include "gdbcmd.h"
#include "regcache.h"
#include "cp-abi.h"
#include "block.h"
#include "infcall.h"
#include "dictionary.h"
#include "cp-support.h"
#include "dfp.h"
#include "tracepoint.h"
#include <errno.h>
#include "gdb_string.h"
#include "gdb_assert.h"
#include "cp-support.h"
#include "observer.h"
#include "objfiles.h"
#include "symtab.h"
#include "exceptions.h"

extern unsigned int overload_debug;
/* Local functions.  */

static int typecmp (int staticp, int varargs, int nargs,
		    struct field t1[], struct value *t2[]);

static struct value *search_struct_field (const char *, struct value *, 
					  int, struct type *, int);

static struct value *search_struct_method (const char *, struct value **,
					   struct value **,
					   int, int *, struct type *);

static int find_oload_champ_namespace (struct value **, int,
				       const char *, const char *,
				       struct symbol ***,
				       struct badness_vector **,
				       const int no_adl);

static
int find_oload_champ_namespace_loop (struct value **, int,
				     const char *, const char *,
				     int, struct symbol ***,
				     struct badness_vector **, int *,
				     const int no_adl);

static int find_oload_champ (struct value **, int, int, int,
			     struct fn_field *, struct symbol **,
			     struct badness_vector **);

static int oload_method_static (int, struct fn_field *, int);

enum oload_classification { STANDARD, NON_STANDARD, INCOMPATIBLE };

static enum
oload_classification classify_oload_match (struct badness_vector *,
					   int, int);

static struct value *value_struct_elt_for_reference (struct type *,
						     int, struct type *,
						     char *,
						     struct type *,
						     int, enum noside);

static struct value *value_namespace_elt (const struct type *,
					  char *, int , enum noside);

static struct value *value_maybe_namespace_elt (const struct type *,
						char *, int,
						enum noside);

static CORE_ADDR allocate_space_in_inferior (int);

static struct value *cast_into_complex (struct type *, struct value *);

static struct fn_field *find_method_list (struct value **, const char *,
					  int, struct type *, int *,
					  struct type **, int *);

void _initialize_valops (void);

#if 0
/* Flag for whether we want to abandon failed expression evals by
   default.  */

static int auto_abandon = 0;
#endif

int overload_resolution = 0;
static void
show_overload_resolution (struct ui_file *file, int from_tty,
			  struct cmd_list_element *c, 
			  const char *value)
{
  fprintf_filtered (file, _("Overload resolution in evaluating "
			    "C++ functions is %s.\n"),
		    value);
}

/* Find the address of function name NAME in the inferior.  If OBJF_P
   is non-NULL, *OBJF_P will be set to the OBJFILE where the function
   is defined.  */

struct value *
find_function_in_inferior (const char *name, struct objfile **objf_p)
{
  struct symbol *sym;

  sym = lookup_symbol (name, 0, VAR_DOMAIN, 0);
  if (sym != NULL)
    {
      if (SYMBOL_CLASS (sym) != LOC_BLOCK)
	{
	  error (_("\"%s\" exists in this program but is not a function."),
		 name);
	}

      if (objf_p)
	*objf_p = SYMBOL_SYMTAB (sym)->objfile;

      return value_of_variable (sym, NULL);
    }
  else
    {
      struct bound_minimal_symbol msymbol = 
	lookup_bound_minimal_symbol (name);

      if (msymbol.minsym != NULL)
	{
	  struct objfile *objfile = msymbol.objfile;
	  struct gdbarch *gdbarch = get_objfile_arch (objfile);

	  struct type *type;
	  CORE_ADDR maddr;
	  type = lookup_pointer_type (builtin_type (gdbarch)->builtin_char);
	  type = lookup_function_type (type);
	  type = lookup_pointer_type (type);
	  maddr = SYMBOL_VALUE_ADDRESS (msymbol.minsym);

	  if (objf_p)
	    *objf_p = objfile;

	  return value_from_pointer (type, maddr);
	}
      else
	{
	  if (!target_has_execution)
	    error (_("evaluation of this expression "
		     "requires the target program to be active"));
	  else
	    error (_("evaluation of this expression requires the "
		     "program to have a function \"%s\"."),
		   name);
	}
    }
}

/* Allocate NBYTES of space in the inferior using the inferior's
   malloc and return a value that is a pointer to the allocated
   space.  */

struct value *
value_allocate_space_in_inferior (int len)
{
  struct objfile *objf;
  struct value *val = find_function_in_inferior ("malloc", &objf);
  struct gdbarch *gdbarch = get_objfile_arch (objf);
  struct value *blocklen;

  blocklen = value_from_longest (builtin_type (gdbarch)->builtin_int, len);
  val = call_function_by_hand (val, 1, &blocklen);
  if (value_logical_not (val))
    {
      if (!target_has_execution)
	error (_("No memory available to program now: "
		 "you need to start the target first"));
      else
	error (_("No memory available to program: call to malloc failed"));
    }
  return val;
}

static CORE_ADDR
allocate_space_in_inferior (int len)
{
  return value_as_long (value_allocate_space_in_inferior (len));
}

/* Cast struct value VAL to type TYPE and return as a value.
   Both type and val must be of TYPE_CODE_STRUCT or TYPE_CODE_UNION
   for this to work.  Typedef to one of the codes is permitted.
   Returns NULL if the cast is neither an upcast nor a downcast.  */

static struct value *
value_cast_structs (struct type *type, struct value *v2)
{
  struct type *t1;
  struct type *t2;
  struct value *v;

  gdb_assert (type != NULL && v2 != NULL);

  t1 = check_typedef (type);
  t2 = check_typedef (value_type (v2));

  /* Check preconditions.  */
  gdb_assert ((TYPE_CODE (t1) == TYPE_CODE_STRUCT
	       || TYPE_CODE (t1) == TYPE_CODE_UNION)
	      && !!"Precondition is that type is of STRUCT or UNION kind.");
  gdb_assert ((TYPE_CODE (t2) == TYPE_CODE_STRUCT
	       || TYPE_CODE (t2) == TYPE_CODE_UNION)
	      && !!"Precondition is that value is of STRUCT or UNION kind");

  if (TYPE_NAME (t1) != NULL
      && TYPE_NAME (t2) != NULL
      && !strcmp (TYPE_NAME (t1), TYPE_NAME (t2)))
    return NULL;

  /* Upcasting: look in the type of the source to see if it contains the
     type of the target as a superclass.  If so, we'll need to
     offset the pointer rather than just change its type.  */
  if (TYPE_NAME (t1) != NULL)
    {
      v = search_struct_field (type_name_no_tag (t1),
			       v2, 0, t2, 1);
      if (v)
	return v;
    }

  /* Downcasting: look in the type of the target to see if it contains the
     type of the source as a superclass.  If so, we'll need to
     offset the pointer rather than just change its type.  */
  if (TYPE_NAME (t2) != NULL)
    {
      /* Try downcasting using the run-time type of the value.  */
      int full, top, using_enc;
      struct type *real_type;

      real_type = value_rtti_type (v2, &full, &top, &using_enc);
      if (real_type)
	{
	  v = value_full_object (v2, real_type, full, top, using_enc);
	  v = value_at_lazy (real_type, value_address (v));

	  /* We might be trying to cast to the outermost enclosing
	     type, in which case search_struct_field won't work.  */
	  if (TYPE_NAME (real_type) != NULL
	      && !strcmp (TYPE_NAME (real_type), TYPE_NAME (t1)))
	    return v;

	  v = search_struct_field (type_name_no_tag (t2), v, 0, real_type, 1);
	  if (v)
	    return v;
	}

      /* Try downcasting using information from the destination type
	 T2.  This wouldn't work properly for classes with virtual
	 bases, but those were handled above.  */
      v = search_struct_field (type_name_no_tag (t2),
			       value_zero (t1, not_lval), 0, t1, 1);
      if (v)
	{
	  /* Downcasting is possible (t1 is superclass of v2).  */
	  CORE_ADDR addr2 = value_address (v2);

	  addr2 -= value_address (v) + value_embedded_offset (v);
	  return value_at (type, addr2);
	}
    }

  return NULL;
}

/* Cast one pointer or reference type to another.  Both TYPE and
   the type of ARG2 should be pointer types, or else both should be
   reference types.  If SUBCLASS_CHECK is non-zero, this will force a
   check to see whether TYPE is a superclass of ARG2's type.  If
   SUBCLASS_CHECK is zero, then the subclass check is done only when
   ARG2 is itself non-zero.  Returns the new pointer or reference.  */

struct value *
value_cast_pointers (struct type *type, struct value *arg2,
		     int subclass_check)
{
  struct type *type1 = check_typedef (type);
  struct type *type2 = check_typedef (value_type (arg2));
  struct type *t1 = check_typedef (TYPE_TARGET_TYPE (type1));
  struct type *t2 = check_typedef (TYPE_TARGET_TYPE (type2));

  if (TYPE_CODE (t1) == TYPE_CODE_STRUCT
      && TYPE_CODE (t2) == TYPE_CODE_STRUCT
      && (subclass_check || !value_logical_not (arg2)))
    {
      struct value *v2;

      if (TYPE_CODE (type2) == TYPE_CODE_REF)
	v2 = coerce_ref (arg2);
      else
	v2 = value_ind (arg2);
      gdb_assert (TYPE_CODE (check_typedef (value_type (v2)))
		  == TYPE_CODE_STRUCT && !!"Why did coercion fail?");
      v2 = value_cast_structs (t1, v2);
      /* At this point we have what we can have, un-dereference if needed.  */
      if (v2)
	{
	  struct value *v = value_addr (v2);

	  deprecated_set_value_type (v, type);
	  return v;
	}
   }

  /* No superclass found, just change the pointer type.  */
  arg2 = value_copy (arg2);
  deprecated_set_value_type (arg2, type);
  set_value_enclosing_type (arg2, type);
  set_value_pointed_to_offset (arg2, 0);	/* pai: chk_val */
  return arg2;
}

/* Cast value ARG2 to type TYPE and return as a value.
   More general than a C cast: accepts any two types of the same length,
   and if ARG2 is an lvalue it can be cast into anything at all.  */
/* In C++, casts may change pointer or object representations.  */

struct value *
value_cast (struct type *type, struct value *arg2)
{
  enum type_code code1;
  enum type_code code2;
  int scalar;
  struct type *type2;

  int convert_to_boolean = 0;

  if (value_type (arg2) == type)
    return arg2;

  code1 = TYPE_CODE (check_typedef (type));

  /* Check if we are casting struct reference to struct reference.  */
  if (code1 == TYPE_CODE_REF)
    {
      /* We dereference type; then we recurse and finally
         we generate value of the given reference.  Nothing wrong with 
	 that.  */
      struct type *t1 = check_typedef (type);
      struct type *dereftype = check_typedef (TYPE_TARGET_TYPE (t1));
      struct value *val =  value_cast (dereftype, arg2);

      return value_ref (val); 
    }

  code2 = TYPE_CODE (check_typedef (value_type (arg2)));

  if (code2 == TYPE_CODE_REF)
    /* We deref the value and then do the cast.  */
    return value_cast (type, coerce_ref (arg2)); 

  CHECK_TYPEDEF (type);
  code1 = TYPE_CODE (type);
  arg2 = coerce_ref (arg2);
  type2 = check_typedef (value_type (arg2));

  /* You can't cast to a reference type.  See value_cast_pointers
     instead.  */
  gdb_assert (code1 != TYPE_CODE_REF);

  /* A cast to an undetermined-length array_type, such as 
     (TYPE [])OBJECT, is treated like a cast to (TYPE [N])OBJECT,
     where N is sizeof(OBJECT)/sizeof(TYPE).  */
  if (code1 == TYPE_CODE_ARRAY)
    {
      struct type *element_type = TYPE_TARGET_TYPE (type);
      unsigned element_length = TYPE_LENGTH (check_typedef (element_type));

      if (element_length > 0 && TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED (type))
	{
	  struct type *range_type = TYPE_INDEX_TYPE (type);
	  int val_length = TYPE_LENGTH (type2);
	  LONGEST low_bound, high_bound, new_length;

	  if (get_discrete_bounds (range_type, &low_bound, &high_bound) < 0)
	    low_bound = 0, high_bound = 0;
	  new_length = val_length / element_length;
	  if (val_length % element_length != 0)
	    warning (_("array element type size does not "
		       "divide object size in cast"));
	  /* FIXME-type-allocation: need a way to free this type when
	     we are done with it.  */
	  range_type = create_range_type ((struct type *) NULL,
					  TYPE_TARGET_TYPE (range_type),
					  low_bound,
					  new_length + low_bound - 1);
	  deprecated_set_value_type (arg2, 
				     create_array_type ((struct type *) NULL,
							element_type, 
							range_type));
	  return arg2;
	}
    }

  if (current_language->c_style_arrays
      && TYPE_CODE (type2) == TYPE_CODE_ARRAY
      && !TYPE_VECTOR (type2))
    arg2 = value_coerce_array (arg2);

  if (TYPE_CODE (type2) == TYPE_CODE_FUNC)
    arg2 = value_coerce_function (arg2);

  type2 = check_typedef (value_type (arg2));
  code2 = TYPE_CODE (type2);

  if (code1 == TYPE_CODE_COMPLEX)
    return cast_into_complex (type, arg2);
  if (code1 == TYPE_CODE_BOOL)
    {
      code1 = TYPE_CODE_INT;
      convert_to_boolean = 1;
    }
  if (code1 == TYPE_CODE_CHAR)
    code1 = TYPE_CODE_INT;
  if (code2 == TYPE_CODE_BOOL || code2 == TYPE_CODE_CHAR)
    code2 = TYPE_CODE_INT;

  scalar = (code2 == TYPE_CODE_INT || code2 == TYPE_CODE_FLT
	    || code2 == TYPE_CODE_DECFLOAT || code2 == TYPE_CODE_ENUM
	    || code2 == TYPE_CODE_RANGE);

  if ((code1 == TYPE_CODE_STRUCT || code1 == TYPE_CODE_UNION)
      && (code2 == TYPE_CODE_STRUCT || code2 == TYPE_CODE_UNION)
      && TYPE_NAME (type) != 0)
    {
      struct value *v = value_cast_structs (type, arg2);

      if (v)
	return v;
    }

  if (code1 == TYPE_CODE_FLT && scalar)
    return value_from_double (type, value_as_double (arg2));
  else if (code1 == TYPE_CODE_DECFLOAT && scalar)
    {
      enum bfd_endian byte_order = gdbarch_byte_order (get_type_arch (type));
      int dec_len = TYPE_LENGTH (type);
      gdb_byte dec[16];

      if (code2 == TYPE_CODE_FLT)
	decimal_from_floating (arg2, dec, dec_len, byte_order);
      else if (code2 == TYPE_CODE_DECFLOAT)
	decimal_convert (value_contents (arg2), TYPE_LENGTH (type2),
			 byte_order, dec, dec_len, byte_order);
      else
	/* The only option left is an integral type.  */
	decimal_from_integral (arg2, dec, dec_len, byte_order);

      return value_from_decfloat (type, dec);
    }
  else if ((code1 == TYPE_CODE_INT || code1 == TYPE_CODE_ENUM
	    || code1 == TYPE_CODE_RANGE)
	   && (scalar || code2 == TYPE_CODE_PTR
	       || code2 == TYPE_CODE_MEMBERPTR))
    {
      LONGEST longest;

      /* When we cast pointers to integers, we mustn't use
         gdbarch_pointer_to_address to find the address the pointer
         represents, as value_as_long would.  GDB should evaluate
         expressions just as the compiler would --- and the compiler
         sees a cast as a simple reinterpretation of the pointer's
         bits.  */
      if (code2 == TYPE_CODE_PTR)
        longest = extract_unsigned_integer
		    (value_contents (arg2), TYPE_LENGTH (type2),
		     gdbarch_byte_order (get_type_arch (type2)));
      else
        longest = value_as_long (arg2);
      return value_from_longest (type, convert_to_boolean ?
				 (LONGEST) (longest ? 1 : 0) : longest);
    }
  else if (code1 == TYPE_CODE_PTR && (code2 == TYPE_CODE_INT  
				      || code2 == TYPE_CODE_ENUM 
				      || code2 == TYPE_CODE_RANGE))
    {
      /* TYPE_LENGTH (type) is the length of a pointer, but we really
	 want the length of an address! -- we are really dealing with
	 addresses (i.e., gdb representations) not pointers (i.e.,
	 target representations) here.

	 This allows things like "print *(int *)0x01000234" to work
	 without printing a misleading message -- which would
	 otherwise occur when dealing with a target having two byte
	 pointers and four byte addresses.  */

      int addr_bit = gdbarch_addr_bit (get_type_arch (type2));
      LONGEST longest = value_as_long (arg2);

      if (addr_bit < sizeof (LONGEST) * HOST_CHAR_BIT)
	{
	  if (longest >= ((LONGEST) 1 << addr_bit)
	      || longest <= -((LONGEST) 1 << addr_bit))
	    warning (_("value truncated"));
	}
      return value_from_longest (type, longest);
    }
  else if (code1 == TYPE_CODE_METHODPTR && code2 == TYPE_CODE_INT
	   && value_as_long (arg2) == 0)
    {
      struct value *result = allocate_value (type);

      cplus_make_method_ptr (type, value_contents_writeable (result), 0, 0);
      return result;
    }
  else if (code1 == TYPE_CODE_MEMBERPTR && code2 == TYPE_CODE_INT
	   && value_as_long (arg2) == 0)
    {
      /* The Itanium C++ ABI represents NULL pointers to members as
	 minus one, instead of biasing the normal case.  */
      return value_from_longest (type, -1);
    }
  else if (code1 == TYPE_CODE_ARRAY && TYPE_VECTOR (type)
	   && code2 == TYPE_CODE_ARRAY && TYPE_VECTOR (type2)
	   && TYPE_LENGTH (type) != TYPE_LENGTH (type2))
    error (_("Cannot convert between vector values of different sizes"));
  else if (code1 == TYPE_CODE_ARRAY && TYPE_VECTOR (type) && scalar
	   && TYPE_LENGTH (type) != TYPE_LENGTH (type2))
    error (_("can only cast scalar to vector of same size"));
  else if (code1 == TYPE_CODE_VOID)
    {
      return value_zero (type, not_lval);
    }
  else if (TYPE_LENGTH (type) == TYPE_LENGTH (type2))
    {
      if (code1 == TYPE_CODE_PTR && code2 == TYPE_CODE_PTR)
	return value_cast_pointers (type, arg2, 0);

      arg2 = value_copy (arg2);
      deprecated_set_value_type (arg2, type);
      set_value_enclosing_type (arg2, type);
      set_value_pointed_to_offset (arg2, 0);	/* pai: chk_val */
      return arg2;
    }
  else if (VALUE_LVAL (arg2) == lval_memory)
    return value_at_lazy (type, value_address (arg2));
  else
    {
      error (_("Invalid cast."));
      return 0;
    }
}

/* The C++ reinterpret_cast operator.  */

struct value *
value_reinterpret_cast (struct type *type, struct value *arg)
{
  struct value *result;
  struct type *real_type = check_typedef (type);
  struct type *arg_type, *dest_type;
  int is_ref = 0;
  enum type_code dest_code, arg_code;

  /* Do reference, function, and array conversion.  */
  arg = coerce_array (arg);

  /* Attempt to preserve the type the user asked for.  */
  dest_type = type;

  /* If we are casting to a reference type, transform
     reinterpret_cast<T&>(V) to *reinterpret_cast<T*>(&V).  */
  if (TYPE_CODE (real_type) == TYPE_CODE_REF)
    {
      is_ref = 1;
      arg = value_addr (arg);
      dest_type = lookup_pointer_type (TYPE_TARGET_TYPE (dest_type));
      real_type = lookup_pointer_type (real_type);
    }

  arg_type = value_type (arg);

  dest_code = TYPE_CODE (real_type);
  arg_code = TYPE_CODE (arg_type);

  /* We can convert pointer types, or any pointer type to int, or int
     type to pointer.  */
  if ((dest_code == TYPE_CODE_PTR && arg_code == TYPE_CODE_INT)
      || (dest_code == TYPE_CODE_INT && arg_code == TYPE_CODE_PTR)
      || (dest_code == TYPE_CODE_METHODPTR && arg_code == TYPE_CODE_INT)
      || (dest_code == TYPE_CODE_INT && arg_code == TYPE_CODE_METHODPTR)
      || (dest_code == TYPE_CODE_MEMBERPTR && arg_code == TYPE_CODE_INT)
      || (dest_code == TYPE_CODE_INT && arg_code == TYPE_CODE_MEMBERPTR)
      || (dest_code == arg_code
	  && (dest_code == TYPE_CODE_PTR
	      || dest_code == TYPE_CODE_METHODPTR
	      || dest_code == TYPE_CODE_MEMBERPTR)))
    result = value_cast (dest_type, arg);
  else
    error (_("Invalid reinterpret_cast"));

  if (is_ref)
    result = value_cast (type, value_ref (value_ind (result)));

  return result;
}

/* A helper for value_dynamic_cast.  This implements the first of two
   runtime checks: we iterate over all the base classes of the value's
   class which are equal to the desired class; if only one of these
   holds the value, then it is the answer.  */

static int
dynamic_cast_check_1 (struct type *desired_type,
		      const gdb_byte *valaddr,
		      int embedded_offset,
		      CORE_ADDR address,
		      struct value *val,
		      struct type *search_type,
		      CORE_ADDR arg_addr,
		      struct type *arg_type,
		      struct value **result)
{
  int i, result_count = 0;

  for (i = 0; i < TYPE_N_BASECLASSES (search_type) && result_count < 2; ++i)
    {
      int offset = baseclass_offset (search_type, i, valaddr, embedded_offset,
				     address, val);

      if (class_types_same_p (desired_type, TYPE_BASECLASS (search_type, i)))
	{
	  if (address + embedded_offset + offset >= arg_addr
	      && address + embedded_offset + offset < arg_addr + TYPE_LENGTH (arg_type))
	    {
	      ++result_count;
	      if (!*result)
		*result = value_at_lazy (TYPE_BASECLASS (search_type, i),
					 address + embedded_offset + offset);
	    }
	}
      else
	result_count += dynamic_cast_check_1 (desired_type,
					      valaddr,
					      embedded_offset + offset,
					      address, val,
					      TYPE_BASECLASS (search_type, i),
					      arg_addr,
					      arg_type,
					      result);
    }

  return result_count;
}

/* A helper for value_dynamic_cast.  This implements the second of two
   runtime checks: we look for a unique public sibling class of the
   argument's declared class.  */

static int
dynamic_cast_check_2 (struct type *desired_type,
		      const gdb_byte *valaddr,
		      int embedded_offset,
		      CORE_ADDR address,
		      struct value *val,
		      struct type *search_type,
		      struct value **result)
{
  int i, result_count = 0;

  for (i = 0; i < TYPE_N_BASECLASSES (search_type) && result_count < 2; ++i)
    {
      int offset;

      if (! BASETYPE_VIA_PUBLIC (search_type, i))
	continue;

      offset = baseclass_offset (search_type, i, valaddr, embedded_offset,
				 address, val);
      if (class_types_same_p (desired_type, TYPE_BASECLASS (search_type, i)))
	{
	  ++result_count;
	  if (*result == NULL)
	    *result = value_at_lazy (TYPE_BASECLASS (search_type, i),
				     address + embedded_offset + offset);
	}
      else
	result_count += dynamic_cast_check_2 (desired_type,
					      valaddr,
					      embedded_offset + offset,
					      address, val,
					      TYPE_BASECLASS (search_type, i),
					      result);
    }

  return result_count;
}

/* The C++ dynamic_cast operator.  */

struct value *
value_dynamic_cast (struct type *type, struct value *arg)
{
  int full, top, using_enc;
  struct type *resolved_type = check_typedef (type);
  struct type *arg_type = check_typedef (value_type (arg));
  struct type *class_type, *rtti_type;
  struct value *result, *tem, *original_arg = arg;
  CORE_ADDR addr;
  int is_ref = TYPE_CODE (resolved_type) == TYPE_CODE_REF;

  if (TYPE_CODE (resolved_type) != TYPE_CODE_PTR
      && TYPE_CODE (resolved_type) != TYPE_CODE_REF)
    error (_("Argument to dynamic_cast must be a pointer or reference type"));
  if (TYPE_CODE (TYPE_TARGET_TYPE (resolved_type)) != TYPE_CODE_VOID
      && TYPE_CODE (TYPE_TARGET_TYPE (resolved_type)) != TYPE_CODE_CLASS)
    error (_("Argument to dynamic_cast must be pointer to class or `void *'"));

  class_type = check_typedef (TYPE_TARGET_TYPE (resolved_type));
  if (TYPE_CODE (resolved_type) == TYPE_CODE_PTR)
    {
      if (TYPE_CODE (arg_type) != TYPE_CODE_PTR
	  && ! (TYPE_CODE (arg_type) == TYPE_CODE_INT
		&& value_as_long (arg) == 0))
	error (_("Argument to dynamic_cast does not have pointer type"));
      if (TYPE_CODE (arg_type) == TYPE_CODE_PTR)
	{
	  arg_type = check_typedef (TYPE_TARGET_TYPE (arg_type));
	  if (TYPE_CODE (arg_type) != TYPE_CODE_CLASS)
	    error (_("Argument to dynamic_cast does "
		     "not have pointer to class type"));
	}

      /* Handle NULL pointers.  */
      if (value_as_long (arg) == 0)
	return value_zero (type, not_lval);

      arg = value_ind (arg);
    }
  else
    {
      if (TYPE_CODE (arg_type) != TYPE_CODE_CLASS)
	error (_("Argument to dynamic_cast does not have class type"));
    }

  /* If the classes are the same, just return the argument.  */
  if (class_types_same_p (class_type, arg_type))
    return value_cast (type, arg);

  /* If the target type is a unique base class of the argument's
     declared type, just cast it.  */
  if (is_ancestor (class_type, arg_type))
    {
      if (is_unique_ancestor (class_type, arg))
	return value_cast (type, original_arg);
      error (_("Ambiguous dynamic_cast"));
    }

  rtti_type = value_rtti_type (arg, &full, &top, &using_enc);
  if (! rtti_type)
    error (_("Couldn't determine value's most derived type for dynamic_cast"));

  /* Compute the most derived object's address.  */
  addr = value_address (arg);
  if (full)
    {
      /* Done.  */
    }
  else if (using_enc)
    addr += top;
  else
    addr += top + value_embedded_offset (arg);

  /* dynamic_cast<void *> means to return a pointer to the
     most-derived object.  */
  if (TYPE_CODE (resolved_type) == TYPE_CODE_PTR
      && TYPE_CODE (TYPE_TARGET_TYPE (resolved_type)) == TYPE_CODE_VOID)
    return value_at_lazy (type, addr);

  tem = value_at (type, addr);

  /* The first dynamic check specified in 5.2.7.  */
  if (is_public_ancestor (arg_type, TYPE_TARGET_TYPE (resolved_type)))
    {
      if (class_types_same_p (rtti_type, TYPE_TARGET_TYPE (resolved_type)))
	return tem;
      result = NULL;
      if (dynamic_cast_check_1 (TYPE_TARGET_TYPE (resolved_type),
				value_contents_for_printing (tem),
				value_embedded_offset (tem),
				value_address (tem), tem,
				rtti_type, addr,
				arg_type,
				&result) == 1)
	return value_cast (type,
			   is_ref ? value_ref (result) : value_addr (result));
    }

  /* The second dynamic check specified in 5.2.7.  */
  result = NULL;
  if (is_public_ancestor (arg_type, rtti_type)
      && dynamic_cast_check_2 (TYPE_TARGET_TYPE (resolved_type),
			       value_contents_for_printing (tem),
			       value_embedded_offset (tem),
			       value_address (tem), tem,
			       rtti_type, &result) == 1)
    return value_cast (type,
		       is_ref ? value_ref (result) : value_addr (result));

  if (TYPE_CODE (resolved_type) == TYPE_CODE_PTR)
    return value_zero (type, not_lval);

  error (_("dynamic_cast failed"));
}

/* Create a value of type TYPE that is zero, and return it.  */

struct value *
value_zero (struct type *type, enum lval_type lv)
{
  struct value *val = allocate_value (type);

  VALUE_LVAL (val) = (lv == lval_computed ? not_lval : lv);
  return val;
}

/* Create a not_lval value of numeric type TYPE that is one, and return it.  */

struct value *
value_one (struct type *type)
{
  struct type *type1 = check_typedef (type);
  struct value *val;

  if (TYPE_CODE (type1) == TYPE_CODE_DECFLOAT)
    {
      enum bfd_endian byte_order = gdbarch_byte_order (get_type_arch (type));
      gdb_byte v[16];

      decimal_from_string (v, TYPE_LENGTH (type), byte_order, "1");
      val = value_from_decfloat (type, v);
    }
  else if (TYPE_CODE (type1) == TYPE_CODE_FLT)
    {
      val = value_from_double (type, (DOUBLEST) 1);
    }
  else if (is_integral_type (type1))
    {
      val = value_from_longest (type, (LONGEST) 1);
    }
  else if (TYPE_CODE (type1) == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))
    {
      struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type1));
      int i;
      LONGEST low_bound, high_bound;
      struct value *tmp;

      if (!get_array_bounds (type1, &low_bound, &high_bound))
	error (_("Could not determine the vector bounds"));

      val = allocate_value (type);
      for (i = 0; i < high_bound - low_bound + 1; i++)
	{
	  tmp = value_one (eltype);
	  memcpy (value_contents_writeable (val) + i * TYPE_LENGTH (eltype),
		  value_contents_all (tmp), TYPE_LENGTH (eltype));
	}
    }
  else
    {
      error (_("Not a numeric type."));
    }

  /* value_one result is never used for assignments to.  */
  gdb_assert (VALUE_LVAL (val) == not_lval);

  return val;
}

/* Helper function for value_at, value_at_lazy, and value_at_lazy_stack.  */

static struct value *
get_value_at (struct type *type, CORE_ADDR addr, int lazy)
{
  struct value *val;

  if (TYPE_CODE (check_typedef (type)) == TYPE_CODE_VOID)
    error (_("Attempt to dereference a generic pointer."));

  val = value_from_contents_and_address (type, NULL, addr);

  if (!lazy)
    value_fetch_lazy (val);

  return val;
}

/* Return a value with type TYPE located at ADDR.

   Call value_at only if the data needs to be fetched immediately;
   if we can be 'lazy' and defer the fetch, perhaps indefinately, call
   value_at_lazy instead.  value_at_lazy simply records the address of
   the data and sets the lazy-evaluation-required flag.  The lazy flag
   is tested in the value_contents macro, which is used if and when
   the contents are actually required.

   Note: value_at does *NOT* handle embedded offsets; perform such
   adjustments before or after calling it.  */

struct value *
value_at (struct type *type, CORE_ADDR addr)
{
  return get_value_at (type, addr, 0);
}

/* Return a lazy value with type TYPE located at ADDR (cf. value_at).  */

struct value *
value_at_lazy (struct type *type, CORE_ADDR addr)
{
  return get_value_at (type, addr, 1);
}

void
read_value_memory (struct value *val, int embedded_offset,
		   int stack, CORE_ADDR memaddr,
		   gdb_byte *buffer, size_t length)
{
  if (length)
    {
      VEC(mem_range_s) *available_memory;

      if (!traceframe_available_memory (&available_memory, memaddr, length))
	{
	  if (stack)
	    read_stack (memaddr, buffer, length);
	  else
	    read_memory (memaddr, buffer, length);
	}
      else
	{
	  struct target_section_table *table;
	  struct cleanup *old_chain;
	  CORE_ADDR unavail;
	  mem_range_s *r;
	  int i;

	  /* Fallback to reading from read-only sections.  */
	  table = target_get_section_table (&exec_ops);
	  available_memory =
	    section_table_available_memory (available_memory,
					    memaddr, length,
					    table->sections,
					    table->sections_end);

	  old_chain = make_cleanup (VEC_cleanup(mem_range_s),
				    &available_memory);

	  normalize_mem_ranges (available_memory);

	  /* Mark which bytes are unavailable, and read those which
	     are available.  */

	  unavail = memaddr;

	  for (i = 0;
	       VEC_iterate (mem_range_s, available_memory, i, r);
	       i++)
	    {
	      if (mem_ranges_overlap (r->start, r->length,
				      memaddr, length))
		{
		  CORE_ADDR lo1, hi1, lo2, hi2;
		  CORE_ADDR start, end;

		  /* Get the intersection window.  */
		  lo1 = memaddr;
		  hi1 = memaddr + length;
		  lo2 = r->start;
		  hi2 = r->start + r->length;
		  start = max (lo1, lo2);
		  end = min (hi1, hi2);

		  gdb_assert (end - memaddr <= length);

		  if (start > unavail)
		    mark_value_bytes_unavailable (val,
						  (embedded_offset
						   + unavail - memaddr),
						  start - unavail);
		  unavail = end;

		  read_memory (start, buffer + start - memaddr, end - start);
		}
	    }

	  if (unavail != memaddr + length)
	    mark_value_bytes_unavailable (val,
					  embedded_offset + unavail - memaddr,
					  (memaddr + length) - unavail);

	  do_cleanups (old_chain);
	}
    }
}

/* Store the contents of FROMVAL into the location of TOVAL.
   Return a new value with the location of TOVAL and contents of FROMVAL.  */

struct value *
value_assign (struct value *toval, struct value *fromval)
{
  struct type *type;
  struct value *val;
  struct frame_id old_frame;

  if (!deprecated_value_modifiable (toval))
    error (_("Left operand of assignment is not a modifiable lvalue."));

  toval = coerce_ref (toval);

  type = value_type (toval);
  if (VALUE_LVAL (toval) != lval_internalvar)
    fromval = value_cast (type, fromval);
  else
    {
      /* Coerce arrays and functions to pointers, except for arrays
	 which only live in GDB's storage.  */
      if (!value_must_coerce_to_target (fromval))
	fromval = coerce_array (fromval);
    }

  CHECK_TYPEDEF (type);

  /* Since modifying a register can trash the frame chain, and
     modifying memory can trash the frame cache, we save the old frame
     and then restore the new frame afterwards.  */
  old_frame = get_frame_id (deprecated_safe_get_selected_frame ());

  switch (VALUE_LVAL (toval))
    {
    case lval_internalvar:
      set_internalvar (VALUE_INTERNALVAR (toval), fromval);
      return value_of_internalvar (get_type_arch (type),
				   VALUE_INTERNALVAR (toval));

    case lval_internalvar_component:
      {
	int offset = value_offset (toval);

	/* Are we dealing with a bitfield?

	   It is important to mention that `value_parent (toval)' is
	   non-NULL iff `value_bitsize (toval)' is non-zero.  */
	if (value_bitsize (toval))
	  {
	    /* VALUE_INTERNALVAR below refers to the parent value, while
	       the offset is relative to this parent value.  */
	    gdb_assert (value_parent (value_parent (toval)) == NULL);
	    offset += value_offset (value_parent (toval));
	  }

	set_internalvar_component (VALUE_INTERNALVAR (toval),
				   offset,
				   value_bitpos (toval),
				   value_bitsize (toval),
				   fromval);
      }
      break;

    case lval_memory:
      {
	const gdb_byte *dest_buffer;
	CORE_ADDR changed_addr;
	int changed_len;
        gdb_byte buffer[sizeof (LONGEST)];

	if (value_bitsize (toval))
	  {
	    struct value *parent = value_parent (toval);

	    changed_addr = value_address (parent) + value_offset (toval);
	    changed_len = (value_bitpos (toval)
			   + value_bitsize (toval)
			   + HOST_CHAR_BIT - 1)
	      / HOST_CHAR_BIT;

	    /* If we can read-modify-write exactly the size of the
	       containing type (e.g. short or int) then do so.  This
	       is safer for volatile bitfields mapped to hardware
	       registers.  */
	    if (changed_len < TYPE_LENGTH (type)
		&& TYPE_LENGTH (type) <= (int) sizeof (LONGEST)
		&& ((LONGEST) changed_addr % TYPE_LENGTH (type)) == 0)
	      changed_len = TYPE_LENGTH (type);

	    if (changed_len > (int) sizeof (LONGEST))
	      error (_("Can't handle bitfields which "
		       "don't fit in a %d bit word."),
		     (int) sizeof (LONGEST) * HOST_CHAR_BIT);

	    read_memory (changed_addr, buffer, changed_len);
	    modify_field (type, buffer, value_as_long (fromval),
			  value_bitpos (toval), value_bitsize (toval));
	    dest_buffer = buffer;
	  }
	else
	  {
	    changed_addr = value_address (toval);
	    changed_len = TYPE_LENGTH (type);
	    dest_buffer = value_contents (fromval);
	  }

	write_memory_with_notification (changed_addr, dest_buffer, changed_len);
      }
      break;

    case lval_register:
      {
	struct frame_info *frame;
	struct gdbarch *gdbarch;
	int value_reg;

	/* Figure out which frame this is in currently.  */
	frame = frame_find_by_id (VALUE_FRAME_ID (toval));
	value_reg = VALUE_REGNUM (toval);

	if (!frame)
	  error (_("Value being assigned to is no longer active."));

	gdbarch = get_frame_arch (frame);
	if (gdbarch_convert_register_p (gdbarch, VALUE_REGNUM (toval), type))
	  {
	    /* If TOVAL is a special machine register requiring
	       conversion of program values to a special raw
	       format.  */
	    gdbarch_value_to_register (gdbarch, frame,
				       VALUE_REGNUM (toval), type,
				       value_contents (fromval));
	  }
	else
	  {
	    if (value_bitsize (toval))
	      {
		struct value *parent = value_parent (toval);
		int offset = value_offset (parent) + value_offset (toval);
		int changed_len;
		gdb_byte buffer[sizeof (LONGEST)];
		int optim, unavail;

		changed_len = (value_bitpos (toval)
			       + value_bitsize (toval)
			       + HOST_CHAR_BIT - 1)
		  / HOST_CHAR_BIT;

		if (changed_len > (int) sizeof (LONGEST))
		  error (_("Can't handle bitfields which "
			   "don't fit in a %d bit word."),
			 (int) sizeof (LONGEST) * HOST_CHAR_BIT);

		if (!get_frame_register_bytes (frame, value_reg, offset,
					       changed_len, buffer,
					       &optim, &unavail))
		  {
		    if (optim)
		      error (_("value has been optimized out"));
		    if (unavail)
		      throw_error (NOT_AVAILABLE_ERROR,
				   _("value is not available"));
		  }

		modify_field (type, buffer, value_as_long (fromval),
			      value_bitpos (toval), value_bitsize (toval));

		put_frame_register_bytes (frame, value_reg, offset,
					  changed_len, buffer);
	      }
	    else
	      {
		put_frame_register_bytes (frame, value_reg,
					  value_offset (toval),
					  TYPE_LENGTH (type),
					  value_contents (fromval));
	      }
	  }

	if (deprecated_register_changed_hook)
	  deprecated_register_changed_hook (-1);
	break;
      }

    case lval_computed:
      {
	const struct lval_funcs *funcs = value_computed_funcs (toval);

	if (funcs->write != NULL)
	  {
	    funcs->write (toval, fromval);
	    break;
	  }
      }
      /* Fall through.  */

    default:
      error (_("Left operand of assignment is not an lvalue."));
    }

  /* Assigning to the stack pointer, frame pointer, and other
     (architecture and calling convention specific) registers may
     cause the frame cache and regcache to be out of date.  Assigning to memory
     also can.  We just do this on all assignments to registers or
     memory, for simplicity's sake; I doubt the slowdown matters.  */
  switch (VALUE_LVAL (toval))
    {
    case lval_memory:
    case lval_register:
    case lval_computed:

      observer_notify_target_changed (&current_target);

      /* Having destroyed the frame cache, restore the selected
	 frame.  */

      /* FIXME: cagney/2002-11-02: There has to be a better way of
	 doing this.  Instead of constantly saving/restoring the
	 frame.  Why not create a get_selected_frame() function that,
	 having saved the selected frame's ID can automatically
	 re-find the previously selected frame automatically.  */

      {
	struct frame_info *fi = frame_find_by_id (old_frame);

	if (fi != NULL)
	  select_frame (fi);
      }

      break;
    default:
      break;
    }
  
  /* If the field does not entirely fill a LONGEST, then zero the sign
     bits.  If the field is signed, and is negative, then sign
     extend.  */
  if ((value_bitsize (toval) > 0)
      && (value_bitsize (toval) < 8 * (int) sizeof (LONGEST)))
    {
      LONGEST fieldval = value_as_long (fromval);
      LONGEST valmask = (((ULONGEST) 1) << value_bitsize (toval)) - 1;

      fieldval &= valmask;
      if (!TYPE_UNSIGNED (type) 
	  && (fieldval & (valmask ^ (valmask >> 1))))
	fieldval |= ~valmask;

      fromval = value_from_longest (type, fieldval);
    }

  /* The return value is a copy of TOVAL so it shares its location
     information, but its contents are updated from FROMVAL.  This
     implies the returned value is not lazy, even if TOVAL was.  */
  val = value_copy (toval);
  set_value_lazy (val, 0);
  memcpy (value_contents_raw (val), value_contents (fromval),
	  TYPE_LENGTH (type));

  /* We copy over the enclosing type and pointed-to offset from FROMVAL
     in the case of pointer types.  For object types, the enclosing type
     and embedded offset must *not* be copied: the target object refered
     to by TOVAL retains its original dynamic type after assignment.  */
  if (TYPE_CODE (type) == TYPE_CODE_PTR)
    {
      set_value_enclosing_type (val, value_enclosing_type (fromval));
      set_value_pointed_to_offset (val, value_pointed_to_offset (fromval));
    }

  return val;
}

/* Extend a value VAL to COUNT repetitions of its type.  */

struct value *
value_repeat (struct value *arg1, int count)
{
  struct value *val;

  if (VALUE_LVAL (arg1) != lval_memory)
    error (_("Only values in memory can be extended with '@@'."));
  if (count < 1)
    error (_("Invalid number %d of repetitions."), count);

  val = allocate_repeat_value (value_enclosing_type (arg1), count);

  VALUE_LVAL (val) = lval_memory;
  set_value_address (val, value_address (arg1));

  read_value_memory (val, 0, value_stack (val), value_address (val),
		     value_contents_all_raw (val),
		     TYPE_LENGTH (value_enclosing_type (val)));

  return val;
}

struct value *
value_of_variable (struct symbol *var, const struct block *b)
{
  struct frame_info *frame;

  if (!symbol_read_needs_frame (var))
    frame = NULL;
  else if (!b)
    frame = get_selected_frame (_("No frame selected."));
  else
    {
      frame = block_innermost_frame (b);
      if (!frame)
	{
	  if (BLOCK_FUNCTION (b) && !block_inlined_p (b)
	      && SYMBOL_PRINT_NAME (BLOCK_FUNCTION (b)))
	    error (_("No frame is currently executing in block %s."),
		   SYMBOL_PRINT_NAME (BLOCK_FUNCTION (b)));
	  else
	    error (_("No frame is currently executing in specified block"));
	}
    }

  return read_var_value (var, frame);
}

struct value *
address_of_variable (struct symbol *var, const struct block *b)
{
  struct type *type = SYMBOL_TYPE (var);
  struct value *val;

  /* Evaluate it first; if the result is a memory address, we're fine.
     Lazy evaluation pays off here.  */

  val = value_of_variable (var, b);

  if ((VALUE_LVAL (val) == lval_memory && value_lazy (val))
      || TYPE_CODE (type) == TYPE_CODE_FUNC)
    {
      CORE_ADDR addr = value_address (val);

      return value_from_pointer (lookup_pointer_type (type), addr);
    }

  /* Not a memory address; check what the problem was.  */
  switch (VALUE_LVAL (val))
    {
    case lval_register:
      {
	struct frame_info *frame;
	const char *regname;

	frame = frame_find_by_id (VALUE_FRAME_ID (val));
	gdb_assert (frame);

	regname = gdbarch_register_name (get_frame_arch (frame),
					 VALUE_REGNUM (val));
	gdb_assert (regname && *regname);

	error (_("Address requested for identifier "
		 "\"%s\" which is in register $%s"),
	       SYMBOL_PRINT_NAME (var), regname);
	break;
      }

    default:
      error (_("Can't take address of \"%s\" which isn't an lvalue."),
	     SYMBOL_PRINT_NAME (var));
      break;
    }

  return val;
}

/* Return one if VAL does not live in target memory, but should in order
   to operate on it.  Otherwise return zero.  */

int
value_must_coerce_to_target (struct value *val)
{
  struct type *valtype;

  /* The only lval kinds which do not live in target memory.  */
  if (VALUE_LVAL (val) != not_lval
      && VALUE_LVAL (val) != lval_internalvar)
    return 0;

  valtype = check_typedef (value_type (val));

  switch (TYPE_CODE (valtype))
    {
    case TYPE_CODE_ARRAY:
      return TYPE_VECTOR (valtype) ? 0 : 1;
    case TYPE_CODE_STRING:
      return 1;
    default:
      return 0;
    }
}

/* Make sure that VAL lives in target memory if it's supposed to.  For
   instance, strings are constructed as character arrays in GDB's
   storage, and this function copies them to the target.  */

struct value *
value_coerce_to_target (struct value *val)
{
  LONGEST length;
  CORE_ADDR addr;

  if (!value_must_coerce_to_target (val))
    return val;

  length = TYPE_LENGTH (check_typedef (value_type (val)));
  addr = allocate_space_in_inferior (length);
  write_memory (addr, value_contents (val), length);
  return value_at_lazy (value_type (val), addr);
}

/* Given a value which is an array, return a value which is a pointer
   to its first element, regardless of whether or not the array has a
   nonzero lower bound.

   FIXME: A previous comment here indicated that this routine should
   be substracting the array's lower bound.  It's not clear to me that
   this is correct.  Given an array subscripting operation, it would
   certainly work to do the adjustment here, essentially computing:

   (&array[0] - (lowerbound * sizeof array[0])) + (index * sizeof array[0])

   However I believe a more appropriate and logical place to account
   for the lower bound is to do so in value_subscript, essentially
   computing:

   (&array[0] + ((index - lowerbound) * sizeof array[0]))

   As further evidence consider what would happen with operations
   other than array subscripting, where the caller would get back a
   value that had an address somewhere before the actual first element
   of the array, and the information about the lower bound would be
   lost because of the coercion to pointer type.  */

struct value *
value_coerce_array (struct value *arg1)
{
  struct type *type = check_typedef (value_type (arg1));

  /* If the user tries to do something requiring a pointer with an
     array that has not yet been pushed to the target, then this would
     be a good time to do so.  */
  arg1 = value_coerce_to_target (arg1);

  if (VALUE_LVAL (arg1) != lval_memory)
    error (_("Attempt to take address of value not located in memory."));

  return value_from_pointer (lookup_pointer_type (TYPE_TARGET_TYPE (type)),
			     value_address (arg1));
}

/* Given a value which is a function, return a value which is a pointer
   to it.  */

struct value *
value_coerce_function (struct value *arg1)
{
  struct value *retval;

  if (VALUE_LVAL (arg1) != lval_memory)
    error (_("Attempt to take address of value not located in memory."));

  retval = value_from_pointer (lookup_pointer_type (value_type (arg1)),
			       value_address (arg1));
  return retval;
}

/* Return a pointer value for the object for which ARG1 is the
   contents.  */

struct value *
value_addr (struct value *arg1)
{
  struct value *arg2;
  struct type *type = check_typedef (value_type (arg1));

  if (TYPE_CODE (type) == TYPE_CODE_REF)
    {
      /* Copy the value, but change the type from (T&) to (T*).  We
         keep the same location information, which is efficient, and
         allows &(&X) to get the location containing the reference.  */
      arg2 = value_copy (arg1);
      deprecated_set_value_type (arg2, 
				 lookup_pointer_type (TYPE_TARGET_TYPE (type)));
      return arg2;
    }
  if (TYPE_CODE (type) == TYPE_CODE_FUNC)
    return value_coerce_function (arg1);

  /* If this is an array that has not yet been pushed to the target,
     then this would be a good time to force it to memory.  */
  arg1 = value_coerce_to_target (arg1);

  if (VALUE_LVAL (arg1) != lval_memory)
    error (_("Attempt to take address of value not located in memory."));

  /* Get target memory address.  */
  arg2 = value_from_pointer (lookup_pointer_type (value_type (arg1)),
			     (value_address (arg1)
			      + value_embedded_offset (arg1)));

  /* This may be a pointer to a base subobject; so remember the
     full derived object's type ...  */
  set_value_enclosing_type (arg2,
			    lookup_pointer_type (value_enclosing_type (arg1)));
  /* ... and also the relative position of the subobject in the full
     object.  */
  set_value_pointed_to_offset (arg2, value_embedded_offset (arg1));
  return arg2;
}

/* Return a reference value for the object for which ARG1 is the
   contents.  */

struct value *
value_ref (struct value *arg1)
{
  struct value *arg2;
  struct type *type = check_typedef (value_type (arg1));

  if (TYPE_CODE (type) == TYPE_CODE_REF)
    return arg1;

  arg2 = value_addr (arg1);
  deprecated_set_value_type (arg2, lookup_reference_type (type));
  return arg2;
}

/* Given a value of a pointer type, apply the C unary * operator to
   it.  */

struct value *
value_ind (struct value *arg1)
{
  struct type *base_type;
  struct value *arg2;

  arg1 = coerce_array (arg1);

  base_type = check_typedef (value_type (arg1));

  if (VALUE_LVAL (arg1) == lval_computed)
    {
      const struct lval_funcs *funcs = value_computed_funcs (arg1);

      if (funcs->indirect)
	{
	  struct value *result = funcs->indirect (arg1);

	  if (result)
	    return result;
	}
    }

  if (TYPE_CODE (base_type) == TYPE_CODE_PTR)
    {
      struct type *enc_type;

      /* We may be pointing to something embedded in a larger object.
         Get the real type of the enclosing object.  */
      enc_type = check_typedef (value_enclosing_type (arg1));
      enc_type = TYPE_TARGET_TYPE (enc_type);

      if (TYPE_CODE (check_typedef (enc_type)) == TYPE_CODE_FUNC
	  || TYPE_CODE (check_typedef (enc_type)) == TYPE_CODE_METHOD)
	/* For functions, go through find_function_addr, which knows
	   how to handle function descriptors.  */
	arg2 = value_at_lazy (enc_type, 
			      find_function_addr (arg1, NULL));
      else
	/* Retrieve the enclosing object pointed to.  */
	arg2 = value_at_lazy (enc_type, 
			      (value_as_address (arg1)
			       - value_pointed_to_offset (arg1)));

      return readjust_indirect_value_type (arg2, enc_type, base_type, arg1);
    }

  error (_("Attempt to take contents of a non-pointer value."));
  return 0;			/* For lint -- never reached.  */
}

/* Create a value for an array by allocating space in GDB, copying the
   data into that space, and then setting up an array value.

   The array bounds are set from LOWBOUND and HIGHBOUND, and the array
   is populated from the values passed in ELEMVEC.

   The element type of the array is inherited from the type of the
   first element, and all elements must have the same size (though we
   don't currently enforce any restriction on their types).  */

struct value *
value_array (int lowbound, int highbound, struct value **elemvec)
{
  int nelem;
  int idx;
  unsigned int typelength;
  struct value *val;
  struct type *arraytype;

  /* Validate that the bounds are reasonable and that each of the
     elements have the same size.  */

  nelem = highbound - lowbound + 1;
  if (nelem <= 0)
    {
      error (_("bad array bounds (%d, %d)"), lowbound, highbound);
    }
  typelength = TYPE_LENGTH (value_enclosing_type (elemvec[0]));
  for (idx = 1; idx < nelem; idx++)
    {
      if (TYPE_LENGTH (value_enclosing_type (elemvec[idx])) != typelength)
	{
	  error (_("array elements must all be the same size"));
	}
    }

  arraytype = lookup_array_range_type (value_enclosing_type (elemvec[0]),
				       lowbound, highbound);

  if (!current_language->c_style_arrays)
    {
      val = allocate_value (arraytype);
      for (idx = 0; idx < nelem; idx++)
	value_contents_copy (val, idx * typelength, elemvec[idx], 0,
			     typelength);
      return val;
    }

  /* Allocate space to store the array, and then initialize it by
     copying in each element.  */

  val = allocate_value (arraytype);
  for (idx = 0; idx < nelem; idx++)
    value_contents_copy (val, idx * typelength, elemvec[idx], 0, typelength);
  return val;
}

struct value *
value_cstring (char *ptr, ssize_t len, struct type *char_type)
{
  struct value *val;
  int lowbound = current_language->string_lower_bound;
  ssize_t highbound = len / TYPE_LENGTH (char_type);
  struct type *stringtype
    = lookup_array_range_type (char_type, lowbound, highbound + lowbound - 1);

  val = allocate_value (stringtype);
  memcpy (value_contents_raw (val), ptr, len);
  return val;
}

/* Create a value for a string constant by allocating space in the
   inferior, copying the data into that space, and returning the
   address with type TYPE_CODE_STRING.  PTR points to the string
   constant data; LEN is number of characters.

   Note that string types are like array of char types with a lower
   bound of zero and an upper bound of LEN - 1.  Also note that the
   string may contain embedded null bytes.  */

struct value *
value_string (char *ptr, ssize_t len, struct type *char_type)
{
  struct value *val;
  int lowbound = current_language->string_lower_bound;
  ssize_t highbound = len / TYPE_LENGTH (char_type);
  struct type *stringtype
    = lookup_string_range_type (char_type, lowbound, highbound + lowbound - 1);

  val = allocate_value (stringtype);
  memcpy (value_contents_raw (val), ptr, len);
  return val;
}


/* See if we can pass arguments in T2 to a function which takes
   arguments of types T1.  T1 is a list of NARGS arguments, and T2 is
   a NULL-terminated vector.  If some arguments need coercion of some
   sort, then the coerced values are written into T2.  Return value is
   0 if the arguments could be matched, or the position at which they
   differ if not.

   STATICP is nonzero if the T1 argument list came from a static
   member function.  T2 will still include the ``this'' pointer, but
   it will be skipped.

   For non-static member functions, we ignore the first argument,
   which is the type of the instance variable.  This is because we
   want to handle calls with objects from derived classes.  This is
   not entirely correct: we should actually check to make sure that a
   requested operation is type secure, shouldn't we?  FIXME.  */

static int
typecmp (int staticp, int varargs, int nargs,
	 struct field t1[], struct value *t2[])
{
  int i;

  if (t2 == 0)
    internal_error (__FILE__, __LINE__, 
		    _("typecmp: no argument list"));

  /* Skip ``this'' argument if applicable.  T2 will always include
     THIS.  */
  if (staticp)
    t2 ++;

  for (i = 0;
       (i < nargs) && TYPE_CODE (t1[i].type) != TYPE_CODE_VOID;
       i++)
    {
      struct type *tt1, *tt2;

      if (!t2[i])
	return i + 1;

      tt1 = check_typedef (t1[i].type);
      tt2 = check_typedef (value_type (t2[i]));

      if (TYPE_CODE (tt1) == TYPE_CODE_REF
      /* We should be doing hairy argument matching, as below.  */
	  && (TYPE_CODE (check_typedef (TYPE_TARGET_TYPE (tt1)))
	      == TYPE_CODE (tt2)))
	{
	  if (TYPE_CODE (tt2) == TYPE_CODE_ARRAY)
	    t2[i] = value_coerce_array (t2[i]);
	  else
	    t2[i] = value_ref (t2[i]);
	  continue;
	}

      /* djb - 20000715 - Until the new type structure is in the
	 place, and we can attempt things like implicit conversions,
	 we need to do this so you can take something like a map<const
	 char *>, and properly access map["hello"], because the
	 argument to [] will be a reference to a pointer to a char,
	 and the argument will be a pointer to a char.  */
      while (TYPE_CODE(tt1) == TYPE_CODE_REF
	     || TYPE_CODE (tt1) == TYPE_CODE_PTR)
	{
	  tt1 = check_typedef( TYPE_TARGET_TYPE(tt1) );
	}
      while (TYPE_CODE(tt2) == TYPE_CODE_ARRAY
	     || TYPE_CODE(tt2) == TYPE_CODE_PTR
	     || TYPE_CODE(tt2) == TYPE_CODE_REF)
	{
	  tt2 = check_typedef (TYPE_TARGET_TYPE(tt2));
	}
      if (TYPE_CODE (tt1) == TYPE_CODE (tt2))
	continue;
      /* Array to pointer is a `trivial conversion' according to the
	 ARM.  */

      /* We should be doing much hairier argument matching (see
         section 13.2 of the ARM), but as a quick kludge, just check
         for the same type code.  */
      if (TYPE_CODE (t1[i].type) != TYPE_CODE (value_type (t2[i])))
	return i + 1;
    }
  if (varargs || t2[i] == NULL)
    return 0;
  return i + 1;
}

/* Helper class for do_search_struct_field that updates *RESULT_PTR
   and *LAST_BOFFSET, and possibly throws an exception if the field
   search has yielded ambiguous results.  */

static void
update_search_result (struct value **result_ptr, struct value *v,
		      int *last_boffset, int boffset,
		      const char *name, struct type *type)
{
  if (v != NULL)
    {
      if (*result_ptr != NULL
	  /* The result is not ambiguous if all the classes that are
	     found occupy the same space.  */
	  && *last_boffset != boffset)
	error (_("base class '%s' is ambiguous in type '%s'"),
	       name, TYPE_SAFE_NAME (type));
      *result_ptr = v;
      *last_boffset = boffset;
    }
}

/* A helper for search_struct_field.  This does all the work; most
   arguments are as passed to search_struct_field.  The result is
   stored in *RESULT_PTR, which must be initialized to NULL.
   OUTERMOST_TYPE is the type of the initial type passed to
   search_struct_field; this is used for error reporting when the
   lookup is ambiguous.  */

static void
do_search_struct_field (const char *name, struct value *arg1, int offset,
			struct type *type, int looking_for_baseclass,
			struct value **result_ptr,
			int *last_boffset,
			struct type *outermost_type)
{
  int i;
  int nbases;

  CHECK_TYPEDEF (type);
  nbases = TYPE_N_BASECLASSES (type);

  if (!looking_for_baseclass)
    for (i = TYPE_NFIELDS (type) - 1; i >= nbases; i--)
      {
	const char *t_field_name = TYPE_FIELD_NAME (type, i);

	if (t_field_name && (strcmp_iw (t_field_name, name) == 0))
	  {
	    struct value *v;

	    if (field_is_static (&TYPE_FIELD (type, i)))
	      {
		v = value_static_field (type, i);
		if (v == 0)
		  error (_("field %s is nonexistent or "
			   "has been optimized out"),
			 name);
	      }
	    else
	      v = value_primitive_field (arg1, offset, i, type);
	    *result_ptr = v;
	    return;
	  }

	if (t_field_name
	    && (t_field_name[0] == '\0'
		|| (TYPE_CODE (type) == TYPE_CODE_UNION
		    && (strcmp_iw (t_field_name, "else") == 0))))
	  {
	    struct type *field_type = TYPE_FIELD_TYPE (type, i);

	    if (TYPE_CODE (field_type) == TYPE_CODE_UNION
		|| TYPE_CODE (field_type) == TYPE_CODE_STRUCT)
	      {
		/* Look for a match through the fields of an anonymous
		   union, or anonymous struct.  C++ provides anonymous
		   unions.

		   In the GNU Chill (now deleted from GDB)
		   implementation of variant record types, each
		   <alternative field> has an (anonymous) union type,
		   each member of the union represents a <variant
		   alternative>.  Each <variant alternative> is
		   represented as a struct, with a member for each
		   <variant field>.  */

		struct value *v = NULL;
		int new_offset = offset;

		/* This is pretty gross.  In G++, the offset in an
		   anonymous union is relative to the beginning of the
		   enclosing struct.  In the GNU Chill (now deleted
		   from GDB) implementation of variant records, the
		   bitpos is zero in an anonymous union field, so we
		   have to add the offset of the union here.  */
		if (TYPE_CODE (field_type) == TYPE_CODE_STRUCT
		    || (TYPE_NFIELDS (field_type) > 0
			&& TYPE_FIELD_BITPOS (field_type, 0) == 0))
		  new_offset += TYPE_FIELD_BITPOS (type, i) / 8;

		do_search_struct_field (name, arg1, new_offset, 
					field_type,
					looking_for_baseclass, &v,
					last_boffset,
					outermost_type);
		if (v)
		  {
		    *result_ptr = v;
		    return;
		  }
	      }
	  }
      }

  for (i = 0; i < nbases; i++)
    {
      struct value *v = NULL;
      struct type *basetype = check_typedef (TYPE_BASECLASS (type, i));
      /* If we are looking for baseclasses, this is what we get when
         we hit them.  But it could happen that the base part's member
         name is not yet filled in.  */
      int found_baseclass = (looking_for_baseclass
			     && TYPE_BASECLASS_NAME (type, i) != NULL
			     && (strcmp_iw (name, 
					    TYPE_BASECLASS_NAME (type, 
								 i)) == 0));
      int boffset = value_embedded_offset (arg1) + offset;

      if (BASETYPE_VIA_VIRTUAL (type, i))
	{
	  struct value *v2;

	  boffset = baseclass_offset (type, i,
				      value_contents_for_printing (arg1),
				      value_embedded_offset (arg1) + offset,
				      value_address (arg1),
				      arg1);

	  /* The virtual base class pointer might have been clobbered
	     by the user program.  Make sure that it still points to a
	     valid memory location.  */

	  boffset += value_embedded_offset (arg1) + offset;
	  if (boffset < 0
	      || boffset >= TYPE_LENGTH (value_enclosing_type (arg1)))
	    {
	      CORE_ADDR base_addr;

	      base_addr = value_address (arg1) + boffset;
	      v2 = value_at_lazy (basetype, base_addr);
	      if (target_read_memory (base_addr, 
				      value_contents_raw (v2),
				      TYPE_LENGTH (value_type (v2))) != 0)
		error (_("virtual baseclass botch"));
	    }
	  else
	    {
	      v2 = value_copy (arg1);
	      deprecated_set_value_type (v2, basetype);
	      set_value_embedded_offset (v2, boffset);
	    }

	  if (found_baseclass)
	    v = v2;
	  else
	    {
	      do_search_struct_field (name, v2, 0,
				      TYPE_BASECLASS (type, i),
				      looking_for_baseclass,
				      result_ptr, last_boffset,
				      outermost_type);
	    }
	}
      else if (found_baseclass)
	v = value_primitive_field (arg1, offset, i, type);
      else
	{
	  do_search_struct_field (name, arg1,
				  offset + TYPE_BASECLASS_BITPOS (type, 
								  i) / 8,
				  basetype, looking_for_baseclass,
				  result_ptr, last_boffset,
				  outermost_type);
	}

      update_search_result (result_ptr, v, last_boffset,
			    boffset, name, outermost_type);
    }
}

/* Helper function used by value_struct_elt to recurse through
   baseclasses.  Look for a field NAME in ARG1.  Adjust the address of
   ARG1 by OFFSET bytes, and search in it assuming it has (class) type
   TYPE.  If found, return value, else return NULL.

   If LOOKING_FOR_BASECLASS, then instead of looking for struct
   fields, look for a baseclass named NAME.  */

static struct value *
search_struct_field (const char *name, struct value *arg1, int offset,
		     struct type *type, int looking_for_baseclass)
{
  struct value *result = NULL;
  int boffset = 0;

  do_search_struct_field (name, arg1, offset, type, looking_for_baseclass,
			  &result, &boffset, type);
  return result;
}

/* Helper function used by value_struct_elt to recurse through
   baseclasses.  Look for a field NAME in ARG1.  Adjust the address of
   ARG1 by OFFSET bytes, and search in it assuming it has (class) type
   TYPE.

   If found, return value, else if name matched and args not return
   (value) -1, else return NULL.  */

static struct value *
search_struct_method (const char *name, struct value **arg1p,
		      struct value **args, int offset,
		      int *static_memfuncp, struct type *type)
{
  int i;
  struct value *v;
  int name_matched = 0;
  char dem_opname[64];

  CHECK_TYPEDEF (type);
  for (i = TYPE_NFN_FIELDS (type) - 1; i >= 0; i--)
    {
      const char *t_field_name = TYPE_FN_FIELDLIST_NAME (type, i);

      /* FIXME!  May need to check for ARM demangling here.  */
      if (strncmp (t_field_name, "__", 2) == 0 ||
	  strncmp (t_field_name, "op", 2) == 0 ||
	  strncmp (t_field_name, "type", 4) == 0)
	{
	  if (cplus_demangle_opname (t_field_name, dem_opname, DMGL_ANSI))
	    t_field_name = dem_opname;
	  else if (cplus_demangle_opname (t_field_name, dem_opname, 0))
	    t_field_name = dem_opname;
	}
      if (t_field_name && (strcmp_iw (t_field_name, name) == 0))
	{
	  int j = TYPE_FN_FIELDLIST_LENGTH (type, i) - 1;
	  struct fn_field *f = TYPE_FN_FIELDLIST1 (type, i);

	  name_matched = 1;
	  check_stub_method_group (type, i);
	  if (j > 0 && args == 0)
	    error (_("cannot resolve overloaded method "
		     "`%s': no arguments supplied"), name);
	  else if (j == 0 && args == 0)
	    {
	      v = value_fn_field (arg1p, f, j, type, offset);
	      if (v != NULL)
		return v;
	    }
	  else
	    while (j >= 0)
	      {
		if (!typecmp (TYPE_FN_FIELD_STATIC_P (f, j),
			      TYPE_VARARGS (TYPE_FN_FIELD_TYPE (f, j)),
			      TYPE_NFIELDS (TYPE_FN_FIELD_TYPE (f, j)),
			      TYPE_FN_FIELD_ARGS (f, j), args))
		  {
		    if (TYPE_FN_FIELD_VIRTUAL_P (f, j))
		      return value_virtual_fn_field (arg1p, f, j, 
						     type, offset);
		    if (TYPE_FN_FIELD_STATIC_P (f, j) 
			&& static_memfuncp)
		      *static_memfuncp = 1;
		    v = value_fn_field (arg1p, f, j, type, offset);
		    if (v != NULL)
		      return v;       
		  }
		j--;
	      }
	}
    }

  for (i = TYPE_N_BASECLASSES (type) - 1; i >= 0; i--)
    {
      int base_offset;
      int this_offset;

      if (BASETYPE_VIA_VIRTUAL (type, i))
	{
	  struct type *baseclass = check_typedef (TYPE_BASECLASS (type, i));
	  struct value *base_val;
	  const gdb_byte *base_valaddr;

	  /* The virtual base class pointer might have been
	     clobbered by the user program.  Make sure that it
	    still points to a valid memory location.  */

	  if (offset < 0 || offset >= TYPE_LENGTH (type))
	    {
	      gdb_byte *tmp;
	      struct cleanup *back_to;
	      CORE_ADDR address;

	      tmp = xmalloc (TYPE_LENGTH (baseclass));
	      back_to = make_cleanup (xfree, tmp);
	      address = value_address (*arg1p);

	      if (target_read_memory (address + offset,
				      tmp, TYPE_LENGTH (baseclass)) != 0)
		error (_("virtual baseclass botch"));

	      base_val = value_from_contents_and_address (baseclass,
							  tmp,
							  address + offset);
	      base_valaddr = value_contents_for_printing (base_val);
	      this_offset = 0;
	      do_cleanups (back_to);
	    }
	  else
	    {
	      base_val = *arg1p;
	      base_valaddr = value_contents_for_printing (*arg1p);
	      this_offset = offset;
	    }

	  base_offset = baseclass_offset (type, i, base_valaddr,
					  this_offset, value_address (base_val),
					  base_val);
	}
      else
	{
	  base_offset = TYPE_BASECLASS_BITPOS (type, i) / 8;
	}
      v = search_struct_method (name, arg1p, args, base_offset + offset,
				static_memfuncp, TYPE_BASECLASS (type, i));
      if (v == (struct value *) - 1)
	{
	  name_matched = 1;
	}
      else if (v)
	{
	  /* FIXME-bothner:  Why is this commented out?  Why is it here?  */
	  /* *arg1p = arg1_tmp; */
	  return v;
	}
    }
  if (name_matched)
    return (struct value *) - 1;
  else
    return NULL;
}

/* Given *ARGP, a value of type (pointer to a)* structure/union,
   extract the component named NAME from the ultimate target
   structure/union and return it as a value with its appropriate type.
   ERR is used in the error message if *ARGP's type is wrong.

   C++: ARGS is a list of argument types to aid in the selection of
   an appropriate method.  Also, handle derived types.

   STATIC_MEMFUNCP, if non-NULL, points to a caller-supplied location
   where the truthvalue of whether the function that was resolved was
   a static member function or not is stored.

   ERR is an error message to be printed in case the field is not
   found.  */

struct value *
value_struct_elt (struct value **argp, struct value **args,
		  const char *name, int *static_memfuncp, const char *err)
{
  struct type *t;
  struct value *v;

  *argp = coerce_array (*argp);

  t = check_typedef (value_type (*argp));

  /* Follow pointers until we get to a non-pointer.  */

  while (TYPE_CODE (t) == TYPE_CODE_PTR || TYPE_CODE (t) == TYPE_CODE_REF)
    {
      *argp = value_ind (*argp);
      /* Don't coerce fn pointer to fn and then back again!  */
      if (TYPE_CODE (check_typedef (value_type (*argp))) != TYPE_CODE_FUNC)
	*argp = coerce_array (*argp);
      t = check_typedef (value_type (*argp));
    }

  if (TYPE_CODE (t) != TYPE_CODE_STRUCT
      && TYPE_CODE (t) != TYPE_CODE_UNION)
    error (_("Attempt to extract a component of a value that is not a %s."),
	   err);

  /* Assume it's not, unless we see that it is.  */
  if (static_memfuncp)
    *static_memfuncp = 0;

  if (!args)
    {
      /* if there are no arguments ...do this...  */

      /* Try as a field first, because if we succeed, there is less
         work to be done.  */
      v = search_struct_field (name, *argp, 0, t, 0);
      if (v)
	return v;

      /* C++: If it was not found as a data field, then try to
         return it as a pointer to a method.  */
      v = search_struct_method (name, argp, args, 0, 
				static_memfuncp, t);

      if (v == (struct value *) - 1)
	error (_("Cannot take address of method %s."), name);
      else if (v == 0)
	{
	  if (TYPE_NFN_FIELDS (t))
	    error (_("There is no member or method named %s."), name);
	  else
	    error (_("There is no member named %s."), name);
	}
      return v;
    }

    v = search_struct_method (name, argp, args, 0, 
			      static_memfuncp, t);
  
  if (v == (struct value *) - 1)
    {
      error (_("One of the arguments you tried to pass to %s could not "
	       "be converted to what the function wants."), name);
    }
  else if (v == 0)
    {
      /* See if user tried to invoke data as function.  If so, hand it
         back.  If it's not callable (i.e., a pointer to function),
         gdb should give an error.  */
      v = search_struct_field (name, *argp, 0, t, 0);
      /* If we found an ordinary field, then it is not a method call.
	 So, treat it as if it were a static member function.  */
      if (v && static_memfuncp)
	*static_memfuncp = 1;
    }

  if (!v)
    throw_error (NOT_FOUND_ERROR,
                 _("Structure has no component named %s."), name);
  return v;
}

/* Search through the methods of an object (and its bases) to find a
   specified method.  Return the pointer to the fn_field list of
   overloaded instances.

   Helper function for value_find_oload_list.
   ARGP is a pointer to a pointer to a value (the object).
   METHOD is a string containing the method name.
   OFFSET is the offset within the value.
   TYPE is the assumed type of the object.
   NUM_FNS is the number of overloaded instances.
   BASETYPE is set to the actual type of the subobject where the
      method is found.
   BOFFSET is the offset of the base subobject where the method is found.  */

static struct fn_field *
find_method_list (struct value **argp, const char *method,
		  int offset, struct type *type, int *num_fns,
		  struct type **basetype, int *boffset)
{
  int i;
  struct fn_field *f;
  CHECK_TYPEDEF (type);

  *num_fns = 0;

  /* First check in object itself.  */
  for (i = TYPE_NFN_FIELDS (type) - 1; i >= 0; i--)
    {
      /* pai: FIXME What about operators and type conversions?  */
      const char *fn_field_name = TYPE_FN_FIELDLIST_NAME (type, i);

      if (fn_field_name && (strcmp_iw (fn_field_name, method) == 0))
	{
	  int len = TYPE_FN_FIELDLIST_LENGTH (type, i);
	  struct fn_field *f = TYPE_FN_FIELDLIST1 (type, i);

	  *num_fns = len;
	  *basetype = type;
	  *boffset = offset;

	  /* Resolve any stub methods.  */
	  check_stub_method_group (type, i);

	  return f;
	}
    }

  /* Not found in object, check in base subobjects.  */
  for (i = TYPE_N_BASECLASSES (type) - 1; i >= 0; i--)
    {
      int base_offset;

      if (BASETYPE_VIA_VIRTUAL (type, i))
	{
	  base_offset = baseclass_offset (type, i,
					  value_contents_for_printing (*argp),
					  value_offset (*argp) + offset,
					  value_address (*argp), *argp);
	}
      else /* Non-virtual base, simply use bit position from debug
	      info.  */
	{
	  base_offset = TYPE_BASECLASS_BITPOS (type, i) / 8;
	}
      f = find_method_list (argp, method, base_offset + offset,
			    TYPE_BASECLASS (type, i), num_fns, 
			    basetype, boffset);
      if (f)
	return f;
    }
  return NULL;
}

/* Return the list of overloaded methods of a specified name.

   ARGP is a pointer to a pointer to a value (the object).
   METHOD is the method name.
   OFFSET is the offset within the value contents.
   NUM_FNS is the number of overloaded instances.
   BASETYPE is set to the type of the base subobject that defines the
      method.
   BOFFSET is the offset of the base subobject which defines the method.  */

static struct fn_field *
value_find_oload_method_list (struct value **argp, const char *method,
			      int offset, int *num_fns, 
			      struct type **basetype, int *boffset)
{
  struct type *t;

  t = check_typedef (value_type (*argp));

  /* Code snarfed from value_struct_elt.  */
  while (TYPE_CODE (t) == TYPE_CODE_PTR || TYPE_CODE (t) == TYPE_CODE_REF)
    {
      *argp = value_ind (*argp);
      /* Don't coerce fn pointer to fn and then back again!  */
      if (TYPE_CODE (check_typedef (value_type (*argp))) != TYPE_CODE_FUNC)
	*argp = coerce_array (*argp);
      t = check_typedef (value_type (*argp));
    }

  if (TYPE_CODE (t) != TYPE_CODE_STRUCT
      && TYPE_CODE (t) != TYPE_CODE_UNION)
    error (_("Attempt to extract a component of a "
	     "value that is not a struct or union"));

  return find_method_list (argp, method, 0, t, num_fns, 
			   basetype, boffset);
}

/* Given an array of arguments (ARGS) (which includes an
   entry for "this" in the case of C++ methods), the number of
   arguments NARGS, the NAME of a function, and whether it's a method or
   not (METHOD), find the best function that matches on the argument types
   according to the overload resolution rules.

   METHOD can be one of three values:
     NON_METHOD for non-member functions.
     METHOD: for member functions.
     BOTH: used for overload resolution of operators where the
       candidates are expected to be either member or non member
       functions.  In this case the first argument ARGTYPES
       (representing 'this') is expected to be a reference to the
       target object, and will be dereferenced when attempting the
       non-member search.

   In the case of class methods, the parameter OBJ is an object value
   in which to search for overloaded methods.

   In the case of non-method functions, the parameter FSYM is a symbol
   corresponding to one of the overloaded functions.

   Return value is an integer: 0 -> good match, 10 -> debugger applied
   non-standard coercions, 100 -> incompatible.

   If a method is being searched for, VALP will hold the value.
   If a non-method is being searched for, SYMP will hold the symbol 
   for it.

   If a method is being searched for, and it is a static method,
   then STATICP will point to a non-zero value.

   If NO_ADL argument dependent lookup is disabled.  This is used to prevent
   ADL overload candidates when performing overload resolution for a fully
   qualified name.

   Note: This function does *not* check the value of
   overload_resolution.  Caller must check it to see whether overload
   resolution is permitted.  */

int
find_overload_match (struct value **args, int nargs,
		     const char *name, enum oload_search_type method,
		     struct value **objp, struct symbol *fsym,
		     struct value **valp, struct symbol **symp, 
		     int *staticp, const int no_adl)
{
  struct value *obj = (objp ? *objp : NULL);
  struct type *obj_type = obj ? value_type (obj) : NULL;
  /* Index of best overloaded function.  */
  int func_oload_champ = -1;
  int method_oload_champ = -1;

  /* The measure for the current best match.  */
  struct badness_vector *method_badness = NULL;
  struct badness_vector *func_badness = NULL;

  struct value *temp = obj;
  /* For methods, the list of overloaded methods.  */
  struct fn_field *fns_ptr = NULL;
  /* For non-methods, the list of overloaded function symbols.  */
  struct symbol **oload_syms = NULL;
  /* Number of overloaded instances being considered.  */
  int num_fns = 0;
  struct type *basetype = NULL;
  int boffset;

  struct cleanup *all_cleanups = make_cleanup (null_cleanup, NULL);

  const char *obj_type_name = NULL;
  const char *func_name = NULL;
  enum oload_classification match_quality;
  enum oload_classification method_match_quality = INCOMPATIBLE;
  enum oload_classification func_match_quality = INCOMPATIBLE;

  /* Get the list of overloaded methods or functions.  */
  if (method == METHOD || method == BOTH)
    {
      gdb_assert (obj);

      /* OBJ may be a pointer value rather than the object itself.  */
      obj = coerce_ref (obj);
      while (TYPE_CODE (check_typedef (value_type (obj))) == TYPE_CODE_PTR)
	obj = coerce_ref (value_ind (obj));
      obj_type_name = TYPE_NAME (value_type (obj));

      /* First check whether this is a data member, e.g. a pointer to
	 a function.  */
      if (TYPE_CODE (check_typedef (value_type (obj))) == TYPE_CODE_STRUCT)
	{
	  *valp = search_struct_field (name, obj, 0,
				       check_typedef (value_type (obj)), 0);
	  if (*valp)
	    {
	      *staticp = 1;
	      do_cleanups (all_cleanups);
	      return 0;
	    }
	}

      /* Retrieve the list of methods with the name NAME.  */
      fns_ptr = value_find_oload_method_list (&temp, name, 
					      0, &num_fns, 
					      &basetype, &boffset);
      /* If this is a method only search, and no methods were found
         the search has faild.  */
      if (method == METHOD && (!fns_ptr || !num_fns))
	error (_("Couldn't find method %s%s%s"),
	       obj_type_name,
	       (obj_type_name && *obj_type_name) ? "::" : "",
	       name);
      /* If we are dealing with stub method types, they should have
	 been resolved by find_method_list via
	 value_find_oload_method_list above.  */
      if (fns_ptr)
	{
	  gdb_assert (TYPE_DOMAIN_TYPE (fns_ptr[0].type) != NULL);
	  method_oload_champ = find_oload_champ (args, nargs, method,
	                                         num_fns, fns_ptr,
	                                         oload_syms, &method_badness);

	  method_match_quality =
	      classify_oload_match (method_badness, nargs,
	                            oload_method_static (method, fns_ptr,
	                                                 method_oload_champ));

	  make_cleanup (xfree, method_badness);
	}

    }

  if (method == NON_METHOD || method == BOTH)
    {
      const char *qualified_name = NULL;

      /* If the overload match is being search for both as a method
         and non member function, the first argument must now be
         dereferenced.  */
      if (method == BOTH)
	args[0] = value_ind (args[0]);

      if (fsym)
        {
          qualified_name = SYMBOL_NATURAL_NAME (fsym);

          /* If we have a function with a C++ name, try to extract just
	     the function part.  Do not try this for non-functions (e.g.
	     function pointers).  */
          if (qualified_name
              && TYPE_CODE (check_typedef (SYMBOL_TYPE (fsym)))
	      == TYPE_CODE_FUNC)
            {
	      char *temp;

	      temp = cp_func_name (qualified_name);

	      /* If cp_func_name did not remove anything, the name of the
	         symbol did not include scope or argument types - it was
	         probably a C-style function.  */
	      if (temp)
		{
		  make_cleanup (xfree, temp);
		  if (strcmp (temp, qualified_name) == 0)
		    func_name = NULL;
		  else
		    func_name = temp;
		}
            }
        }
      else
	{
	  func_name = name;
	  qualified_name = name;
	}

      /* If there was no C++ name, this must be a C-style function or
	 not a function at all.  Just return the same symbol.  Do the
	 same if cp_func_name fails for some reason.  */
      if (func_name == NULL)
        {
	  *symp = fsym;
	  do_cleanups (all_cleanups);
          return 0;
        }

      func_oload_champ = find_oload_champ_namespace (args, nargs,
                                                     func_name,
                                                     qualified_name,
                                                     &oload_syms,
                                                     &func_badness,
                                                     no_adl);

      if (func_oload_champ >= 0)
	func_match_quality = classify_oload_match (func_badness, nargs, 0);

      make_cleanup (xfree, oload_syms);
      make_cleanup (xfree, func_badness);
    }

  /* Did we find a match ?  */
  if (method_oload_champ == -1 && func_oload_champ == -1)
    throw_error (NOT_FOUND_ERROR,
                 _("No symbol \"%s\" in current context."),
                 name);

  /* If we have found both a method match and a function
     match, find out which one is better, and calculate match
     quality.  */
  if (method_oload_champ >= 0 && func_oload_champ >= 0)
    {
      switch (compare_badness (func_badness, method_badness))
        {
	  case 0: /* Top two contenders are equally good.  */
	    /* FIXME: GDB does not support the general ambiguous case.
	     All candidates should be collected and presented the
	     user.  */
	    error (_("Ambiguous overload resolution"));
	    break;
	  case 1: /* Incomparable top contenders.  */
	    /* This is an error incompatible candidates
	       should not have been proposed.  */
	    error (_("Internal error: incompatible "
		     "overload candidates proposed"));
	    break;
	  case 2: /* Function champion.  */
	    method_oload_champ = -1;
	    match_quality = func_match_quality;
	    break;
	  case 3: /* Method champion.  */
	    func_oload_champ = -1;
	    match_quality = method_match_quality;
	    break;
	  default:
	    error (_("Internal error: unexpected overload comparison result"));
	    break;
        }
    }
  else
    {
      /* We have either a method match or a function match.  */
      if (method_oload_champ >= 0)
	match_quality = method_match_quality;
      else
	match_quality = func_match_quality;
    }

  if (match_quality == INCOMPATIBLE)
    {
      if (method == METHOD)
	error (_("Cannot resolve method %s%s%s to any overloaded instance"),
	       obj_type_name,
	       (obj_type_name && *obj_type_name) ? "::" : "",
	       name);
      else
	error (_("Cannot resolve function %s to any overloaded instance"),
	       func_name);
    }
  else if (match_quality == NON_STANDARD)
    {
      if (method == METHOD)
	warning (_("Using non-standard conversion to match "
		   "method %s%s%s to supplied arguments"),
		 obj_type_name,
		 (obj_type_name && *obj_type_name) ? "::" : "",
		 name);
      else
	warning (_("Using non-standard conversion to match "
		   "function %s to supplied arguments"),
		 func_name);
    }

  if (staticp != NULL)
    *staticp = oload_method_static (method, fns_ptr, method_oload_champ);

  if (method_oload_champ >= 0)
    {
      if (TYPE_FN_FIELD_VIRTUAL_P (fns_ptr, method_oload_champ))
	*valp = value_virtual_fn_field (&temp, fns_ptr, method_oload_champ,
					basetype, boffset);
      else
	*valp = value_fn_field (&temp, fns_ptr, method_oload_champ,
				basetype, boffset);
    }
  else
    *symp = oload_syms[func_oload_champ];

  if (objp)
    {
      struct type *temp_type = check_typedef (value_type (temp));
      struct type *objtype = check_typedef (obj_type);

      if (TYPE_CODE (temp_type) != TYPE_CODE_PTR
	  && (TYPE_CODE (objtype) == TYPE_CODE_PTR
	      || TYPE_CODE (objtype) == TYPE_CODE_REF))
	{
	  temp = value_addr (temp);
	}
      *objp = temp;
    }

  do_cleanups (all_cleanups);

  switch (match_quality)
    {
    case INCOMPATIBLE:
      return 100;
    case NON_STANDARD:
      return 10;
    default:				/* STANDARD */
      return 0;
    }
}

/* Find the best overload match, searching for FUNC_NAME in namespaces
   contained in QUALIFIED_NAME until it either finds a good match or
   runs out of namespaces.  It stores the overloaded functions in
   *OLOAD_SYMS, and the badness vector in *OLOAD_CHAMP_BV.  The
   calling function is responsible for freeing *OLOAD_SYMS and
   *OLOAD_CHAMP_BV.  If NO_ADL, argument dependent lookup is not 
   performned.  */

static int
find_oload_champ_namespace (struct value **args, int nargs,
			    const char *func_name,
			    const char *qualified_name,
			    struct symbol ***oload_syms,
			    struct badness_vector **oload_champ_bv,
			    const int no_adl)
{
  int oload_champ;

  find_oload_champ_namespace_loop (args, nargs,
				   func_name,
				   qualified_name, 0,
				   oload_syms, oload_champ_bv,
				   &oload_champ,
				   no_adl);

  return oload_champ;
}

/* Helper function for find_oload_champ_namespace; NAMESPACE_LEN is
   how deep we've looked for namespaces, and the champ is stored in
   OLOAD_CHAMP.  The return value is 1 if the champ is a good one, 0
   if it isn't.  Other arguments are the same as in
   find_oload_champ_namespace

   It is the caller's responsibility to free *OLOAD_SYMS and
   *OLOAD_CHAMP_BV.  */

static int
find_oload_champ_namespace_loop (struct value **args, int nargs,
				 const char *func_name,
				 const char *qualified_name,
				 int namespace_len,
				 struct symbol ***oload_syms,
				 struct badness_vector **oload_champ_bv,
				 int *oload_champ,
				 const int no_adl)
{
  int next_namespace_len = namespace_len;
  int searched_deeper = 0;
  int num_fns = 0;
  struct cleanup *old_cleanups;
  int new_oload_champ;
  struct symbol **new_oload_syms;
  struct badness_vector *new_oload_champ_bv;
  char *new_namespace;

  if (next_namespace_len != 0)
    {
      gdb_assert (qualified_name[next_namespace_len] == ':');
      next_namespace_len +=  2;
    }
  next_namespace_len +=
    cp_find_first_component (qualified_name + next_namespace_len);

  /* Initialize these to values that can safely be xfree'd.  */
  *oload_syms = NULL;
  *oload_champ_bv = NULL;

  /* First, see if we have a deeper namespace we can search in.
     If we get a good match there, use it.  */

  if (qualified_name[next_namespace_len] == ':')
    {
      searched_deeper = 1;

      if (find_oload_champ_namespace_loop (args, nargs,
					   func_name, qualified_name,
					   next_namespace_len,
					   oload_syms, oload_champ_bv,
					   oload_champ, no_adl))
	{
	  return 1;
	}
    };

  /* If we reach here, either we're in the deepest namespace or we
     didn't find a good match in a deeper namespace.  But, in the
     latter case, we still have a bad match in a deeper namespace;
     note that we might not find any match at all in the current
     namespace.  (There's always a match in the deepest namespace,
     because this overload mechanism only gets called if there's a
     function symbol to start off with.)  */

  old_cleanups = make_cleanup (xfree, *oload_syms);
  make_cleanup (xfree, *oload_champ_bv);
  new_namespace = alloca (namespace_len + 1);
  strncpy (new_namespace, qualified_name, namespace_len);
  new_namespace[namespace_len] = '\0';
  new_oload_syms = make_symbol_overload_list (func_name,
					      new_namespace);

  /* If we have reached the deepest level perform argument
     determined lookup.  */
  if (!searched_deeper && !no_adl)
    {
      int ix;
      struct type **arg_types;

      /* Prepare list of argument types for overload resolution.  */
      arg_types = (struct type **)
	alloca (nargs * (sizeof (struct type *)));
      for (ix = 0; ix < nargs; ix++)
	arg_types[ix] = value_type (args[ix]);
      make_symbol_overload_list_adl (arg_types, nargs, func_name);
    }

  while (new_oload_syms[num_fns])
    ++num_fns;

  new_oload_champ = find_oload_champ (args, nargs, 0, num_fns,
				      NULL, new_oload_syms,
				      &new_oload_champ_bv);

  /* Case 1: We found a good match.  Free earlier matches (if any),
     and return it.  Case 2: We didn't find a good match, but we're
     not the deepest function.  Then go with the bad match that the
     deeper function found.  Case 3: We found a bad match, and we're
     the deepest function.  Then return what we found, even though
     it's a bad match.  */

  if (new_oload_champ != -1
      && classify_oload_match (new_oload_champ_bv, nargs, 0) == STANDARD)
    {
      *oload_syms = new_oload_syms;
      *oload_champ = new_oload_champ;
      *oload_champ_bv = new_oload_champ_bv;
      do_cleanups (old_cleanups);
      return 1;
    }
  else if (searched_deeper)
    {
      xfree (new_oload_syms);
      xfree (new_oload_champ_bv);
      discard_cleanups (old_cleanups);
      return 0;
    }
  else
    {
      *oload_syms = new_oload_syms;
      *oload_champ = new_oload_champ;
      *oload_champ_bv = new_oload_champ_bv;
      do_cleanups (old_cleanups);
      return 0;
    }
}

/* Look for a function to take NARGS args of ARGS.  Find
   the best match from among the overloaded methods or functions
   (depending on METHOD) given by FNS_PTR or OLOAD_SYMS, respectively.
   The number of methods/functions in the list is given by NUM_FNS.
   Return the index of the best match; store an indication of the
   quality of the match in OLOAD_CHAMP_BV.

   It is the caller's responsibility to free *OLOAD_CHAMP_BV.  */

static int
find_oload_champ (struct value **args, int nargs, int method,
		  int num_fns, struct fn_field *fns_ptr,
		  struct symbol **oload_syms,
		  struct badness_vector **oload_champ_bv)
{
  int ix;
  /* A measure of how good an overloaded instance is.  */
  struct badness_vector *bv;
  /* Index of best overloaded function.  */
  int oload_champ = -1;
  /* Current ambiguity state for overload resolution.  */
  int oload_ambiguous = 0;
  /* 0 => no ambiguity, 1 => two good funcs, 2 => incomparable funcs.  */

  *oload_champ_bv = NULL;

  /* Consider each candidate in turn.  */
  for (ix = 0; ix < num_fns; ix++)
    {
      int jj;
      int static_offset = oload_method_static (method, fns_ptr, ix);
      int nparms;
      struct type **parm_types;

      if (method)
	{
	  nparms = TYPE_NFIELDS (TYPE_FN_FIELD_TYPE (fns_ptr, ix));
	}
      else
	{
	  /* If it's not a method, this is the proper place.  */
	  nparms = TYPE_NFIELDS (SYMBOL_TYPE (oload_syms[ix]));
	}

      /* Prepare array of parameter types.  */
      parm_types = (struct type **) 
	xmalloc (nparms * (sizeof (struct type *)));
      for (jj = 0; jj < nparms; jj++)
	parm_types[jj] = (method
			  ? (TYPE_FN_FIELD_ARGS (fns_ptr, ix)[jj].type)
			  : TYPE_FIELD_TYPE (SYMBOL_TYPE (oload_syms[ix]), 
					     jj));

      /* Compare parameter types to supplied argument types.  Skip
         THIS for static methods.  */
      bv = rank_function (parm_types, nparms, 
			  args + static_offset,
			  nargs - static_offset);

      if (!*oload_champ_bv)
	{
	  *oload_champ_bv = bv;
	  oload_champ = 0;
	}
      else /* See whether current candidate is better or worse than
	      previous best.  */
	switch (compare_badness (bv, *oload_champ_bv))
	  {
	  case 0:		/* Top two contenders are equally good.  */
	    oload_ambiguous = 1;
	    break;
	  case 1:		/* Incomparable top contenders.  */
	    oload_ambiguous = 2;
	    break;
	  case 2:		/* New champion, record details.  */
	    *oload_champ_bv = bv;
	    oload_ambiguous = 0;
	    oload_champ = ix;
	    break;
	  case 3:
	  default:
	    break;
	  }
      xfree (parm_types);
      if (overload_debug)
	{
	  if (method)
	    fprintf_filtered (gdb_stderr,
			      "Overloaded method instance %s, # of parms %d\n",
			      fns_ptr[ix].physname, nparms);
	  else
	    fprintf_filtered (gdb_stderr,
			      "Overloaded function instance "
			      "%s # of parms %d\n",
			      SYMBOL_DEMANGLED_NAME (oload_syms[ix]), 
			      nparms);
	  for (jj = 0; jj < nargs - static_offset; jj++)
	    fprintf_filtered (gdb_stderr,
			      "...Badness @@ %d : %d\n", 
			      jj, bv->rank[jj].rank);
	  fprintf_filtered (gdb_stderr, "Overload resolution "
			    "champion is %d, ambiguous? %d\n", 
			    oload_champ, oload_ambiguous);
	}
    }

  return oload_champ;
}

/* Return 1 if we're looking at a static method, 0 if we're looking at
   a non-static method or a function that isn't a method.  */

static int
oload_method_static (int method, struct fn_field *fns_ptr, int index)
{
  if (method && fns_ptr && index >= 0
      && TYPE_FN_FIELD_STATIC_P (fns_ptr, index))
    return 1;
  else
    return 0;
}

/* Check how good an overload match OLOAD_CHAMP_BV represents.  */

static enum oload_classification
classify_oload_match (struct badness_vector *oload_champ_bv,
		      int nargs,
		      int static_offset)
{
  int ix;
  enum oload_classification worst = STANDARD;

  for (ix = 1; ix <= nargs - static_offset; ix++)
    {
      /* If this conversion is as bad as INCOMPATIBLE_TYPE_BADNESS
         or worse return INCOMPATIBLE.  */
      if (compare_ranks (oload_champ_bv->rank[ix],
                         INCOMPATIBLE_TYPE_BADNESS) <= 0)
	return INCOMPATIBLE;	/* Truly mismatched types.  */
      /* Otherwise If this conversion is as bad as
         NS_POINTER_CONVERSION_BADNESS or worse return NON_STANDARD.  */
      else if (compare_ranks (oload_champ_bv->rank[ix],
                              NS_POINTER_CONVERSION_BADNESS) <= 0)
	worst = NON_STANDARD;	/* Non-standard type conversions
				   needed.  */
    }

  /* If no INCOMPATIBLE classification was found, return the worst one
     that was found (if any).  */
  return worst;
}

/* C++: return 1 is NAME is a legitimate name for the destructor of
   type TYPE.  If TYPE does not have a destructor, or if NAME is
   inappropriate for TYPE, an error is signaled.  Parameter TYPE should not yet
   have CHECK_TYPEDEF applied, this function will apply it itself.  */

int
destructor_name_p (const char *name, struct type *type)
{
  if (name[0] == '~')
    {
      const char *dname = type_name_no_tag_or_error (type);
      const char *cp = strchr (dname, '<');
      unsigned int len;

      /* Do not compare the template part for template classes.  */
      if (cp == NULL)
	len = strlen (dname);
      else
	len = cp - dname;
      if (strlen (name + 1) != len || strncmp (dname, name + 1, len) != 0)
	error (_("name of destructor must equal name of class"));
      else
	return 1;
    }
  return 0;
}

/* C++: Given an aggregate type CURTYPE, and a member name NAME,
   return the appropriate member (or the address of the member, if
   WANT_ADDRESS).  This function is used to resolve user expressions
   of the form "DOMAIN::NAME".  For more details on what happens, see
   the comment before value_struct_elt_for_reference.  */

struct value *
value_aggregate_elt (struct type *curtype, char *name,
		     struct type *expect_type, int want_address,
		     enum noside noside)
{
  switch (TYPE_CODE (curtype))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      return value_struct_elt_for_reference (curtype, 0, curtype, 
					     name, expect_type,
					     want_address, noside);
    case TYPE_CODE_NAMESPACE:
      return value_namespace_elt (curtype, name, 
				  want_address, noside);
    default:
      internal_error (__FILE__, __LINE__,
		      _("non-aggregate type in value_aggregate_elt"));
    }
}

/* Compares the two method/function types T1 and T2 for "equality" 
   with respect to the methods' parameters.  If the types of the
   two parameter lists are the same, returns 1; 0 otherwise.  This
   comparison may ignore any artificial parameters in T1 if
   SKIP_ARTIFICIAL is non-zero.  This function will ALWAYS skip
   the first artificial parameter in T1, assumed to be a 'this' pointer.

   The type T2 is expected to have come from make_params (in eval.c).  */

static int
compare_parameters (struct type *t1, struct type *t2, int skip_artificial)
{
  int start = 0;

  if (TYPE_NFIELDS (t1) > 0 && TYPE_FIELD_ARTIFICIAL (t1, 0))
    ++start;

  /* If skipping artificial fields, find the first real field
     in T1.  */
  if (skip_artificial)
    {
      while (start < TYPE_NFIELDS (t1)
	     && TYPE_FIELD_ARTIFICIAL (t1, start))
	++start;
    }

  /* Now compare parameters.  */

  /* Special case: a method taking void.  T1 will contain no
     non-artificial fields, and T2 will contain TYPE_CODE_VOID.  */
  if ((TYPE_NFIELDS (t1) - start) == 0 && TYPE_NFIELDS (t2) == 1
      && TYPE_CODE (TYPE_FIELD_TYPE (t2, 0)) == TYPE_CODE_VOID)
    return 1;

  if ((TYPE_NFIELDS (t1) - start) == TYPE_NFIELDS (t2))
    {
      int i;

      for (i = 0; i < TYPE_NFIELDS (t2); ++i)
	{
	  if (compare_ranks (rank_one_type (TYPE_FIELD_TYPE (t1, start + i),
					    TYPE_FIELD_TYPE (t2, i), NULL),
	                     EXACT_MATCH_BADNESS) != 0)
	    return 0;
	}

      return 1;
    }

  return 0;
}

/* C++: Given an aggregate type CURTYPE, and a member name NAME,
   return the address of this member as a "pointer to member" type.
   If INTYPE is non-null, then it will be the type of the member we
   are looking for.  This will help us resolve "pointers to member
   functions".  This function is used to resolve user expressions of
   the form "DOMAIN::NAME".  */

static struct value *
value_struct_elt_for_reference (struct type *domain, int offset,
				struct type *curtype, char *name,
				struct type *intype, 
				int want_address,
				enum noside noside)
{
  struct type *t = curtype;
  int i;
  struct value *v, *result;

  if (TYPE_CODE (t) != TYPE_CODE_STRUCT
      && TYPE_CODE (t) != TYPE_CODE_UNION)
    error (_("Internal error: non-aggregate type "
	     "to value_struct_elt_for_reference"));

  for (i = TYPE_NFIELDS (t) - 1; i >= TYPE_N_BASECLASSES (t); i--)
    {
      const char *t_field_name = TYPE_FIELD_NAME (t, i);

      if (t_field_name && strcmp (t_field_name, name) == 0)
	{
	  if (field_is_static (&TYPE_FIELD (t, i)))
	    {
	      v = value_static_field (t, i);
	      if (v == NULL)
		error (_("static field %s has been optimized out"),
		       name);
	      if (want_address)
		v = value_addr (v);
	      return v;
	    }
	  if (TYPE_FIELD_PACKED (t, i))
	    error (_("pointers to bitfield members not allowed"));

	  if (want_address)
	    return value_from_longest
	      (lookup_memberptr_type (TYPE_FIELD_TYPE (t, i), domain),
	       offset + (LONGEST) (TYPE_FIELD_BITPOS (t, i) >> 3));
	  else if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    return allocate_value (TYPE_FIELD_TYPE (t, i));
	  else
	    error (_("Cannot reference non-static field \"%s\""), name);
	}
    }

  /* C++: If it was not found as a data field, then try to return it
     as a pointer to a method.  */

  /* Perform all necessary dereferencing.  */
  while (intype && TYPE_CODE (intype) == TYPE_CODE_PTR)
    intype = TYPE_TARGET_TYPE (intype);

  for (i = TYPE_NFN_FIELDS (t) - 1; i >= 0; --i)
    {
      const char *t_field_name = TYPE_FN_FIELDLIST_NAME (t, i);
      char dem_opname[64];

      if (strncmp (t_field_name, "__", 2) == 0 
	  || strncmp (t_field_name, "op", 2) == 0 
	  || strncmp (t_field_name, "type", 4) == 0)
	{
	  if (cplus_demangle_opname (t_field_name, 
				     dem_opname, DMGL_ANSI))
	    t_field_name = dem_opname;
	  else if (cplus_demangle_opname (t_field_name, 
					  dem_opname, 0))
	    t_field_name = dem_opname;
	}
      if (t_field_name && strcmp (t_field_name, name) == 0)
	{
	  int j;
	  int len = TYPE_FN_FIELDLIST_LENGTH (t, i);
	  struct fn_field *f = TYPE_FN_FIELDLIST1 (t, i);

	  check_stub_method_group (t, i);

	  if (intype)
	    {
	      for (j = 0; j < len; ++j)
		{
		  if (compare_parameters (TYPE_FN_FIELD_TYPE (f, j), intype, 0)
		      || compare_parameters (TYPE_FN_FIELD_TYPE (f, j),
					     intype, 1))
		    break;
		}

	      if (j == len)
		error (_("no member function matches "
			 "that type instantiation"));
	    }
	  else
	    {
	      int ii;

	      j = -1;
	      for (ii = 0; ii < len; ++ii)
		{
		  /* Skip artificial methods.  This is necessary if,
		     for example, the user wants to "print
		     subclass::subclass" with only one user-defined
		     constructor.  There is no ambiguity in this case.
		     We are careful here to allow artificial methods
		     if they are the unique result.  */
		  if (TYPE_FN_FIELD_ARTIFICIAL (f, ii))
		    {
		      if (j == -1)
			j = ii;
		      continue;
		    }

		  /* Desired method is ambiguous if more than one
		     method is defined.  */
		  if (j != -1 && !TYPE_FN_FIELD_ARTIFICIAL (f, j))
		    error (_("non-unique member `%s' requires "
			     "type instantiation"), name);

		  j = ii;
		}

	      if (j == -1)
		error (_("no matching member function"));
	    }

	  if (TYPE_FN_FIELD_STATIC_P (f, j))
	    {
	      struct symbol *s = 
		lookup_symbol (TYPE_FN_FIELD_PHYSNAME (f, j),
			       0, VAR_DOMAIN, 0);

	      if (s == NULL)
		return NULL;

	      if (want_address)
		return value_addr (read_var_value (s, 0));
	      else
		return read_var_value (s, 0);
	    }

	  if (TYPE_FN_FIELD_VIRTUAL_P (f, j))
	    {
	      if (want_address)
		{
		  result = allocate_value
		    (lookup_methodptr_type (TYPE_FN_FIELD_TYPE (f, j)));
		  cplus_make_method_ptr (value_type (result),
					 value_contents_writeable (result),
					 TYPE_FN_FIELD_VOFFSET (f, j), 1);
		}
	      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
		return allocate_value (TYPE_FN_FIELD_TYPE (f, j));
	      else
		error (_("Cannot reference virtual member function \"%s\""),
		       name);
	    }
	  else
	    {
	      struct symbol *s = 
		lookup_symbol (TYPE_FN_FIELD_PHYSNAME (f, j),
			       0, VAR_DOMAIN, 0);

	      if (s == NULL)
		return NULL;

	      v = read_var_value (s, 0);
	      if (!want_address)
		result = v;
	      else
		{
		  result = allocate_value (lookup_methodptr_type (TYPE_FN_FIELD_TYPE (f, j)));
		  cplus_make_method_ptr (value_type (result),
					 value_contents_writeable (result),
					 value_address (v), 0);
		}
	    }
	  return result;
	}
    }
  for (i = TYPE_N_BASECLASSES (t) - 1; i >= 0; i--)
    {
      struct value *v;
      int base_offset;

      if (BASETYPE_VIA_VIRTUAL (t, i))
	base_offset = 0;
      else
	base_offset = TYPE_BASECLASS_BITPOS (t, i) / 8;
      v = value_struct_elt_for_reference (domain,
					  offset + base_offset,
					  TYPE_BASECLASS (t, i),
					  name, intype, 
					  want_address, noside);
      if (v)
	return v;
    }

  /* As a last chance, pretend that CURTYPE is a namespace, and look
     it up that way; this (frequently) works for types nested inside
     classes.  */

  return value_maybe_namespace_elt (curtype, name, 
				    want_address, noside);
}

/* C++: Return the member NAME of the namespace given by the type
   CURTYPE.  */

static struct value *
value_namespace_elt (const struct type *curtype,
		     char *name, int want_address,
		     enum noside noside)
{
  struct value *retval = value_maybe_namespace_elt (curtype, name,
						    want_address, 
						    noside);

  if (retval == NULL)
    error (_("No symbol \"%s\" in namespace \"%s\"."), 
	   name, TYPE_TAG_NAME (curtype));

  return retval;
}

/* A helper function used by value_namespace_elt and
   value_struct_elt_for_reference.  It looks up NAME inside the
   context CURTYPE; this works if CURTYPE is a namespace or if CURTYPE
   is a class and NAME refers to a type in CURTYPE itself (as opposed
   to, say, some base class of CURTYPE).  */

static struct value *
value_maybe_namespace_elt (const struct type *curtype,
			   char *name, int want_address,
			   enum noside noside)
{
  const char *namespace_name = TYPE_TAG_NAME (curtype);
  struct symbol *sym;
  struct value *result;

  sym = cp_lookup_symbol_namespace (namespace_name, name,
				    get_selected_block (0), VAR_DOMAIN);

  if (sym == NULL)
    {
      char *concatenated_name = alloca (strlen (namespace_name) + 2
					+ strlen (name) + 1);

      sprintf (concatenated_name, "%s::%s", namespace_name, name);
      sym = lookup_static_symbol_aux (concatenated_name, VAR_DOMAIN);
    }

  if (sym == NULL)
    return NULL;
  else if ((noside == EVAL_AVOID_SIDE_EFFECTS)
	   && (SYMBOL_CLASS (sym) == LOC_TYPEDEF))
    result = allocate_value (SYMBOL_TYPE (sym));
  else
    result = value_of_variable (sym, get_selected_block (0));

  if (result && want_address)
    result = value_addr (result);

  return result;
}

/* Given a pointer or a reference value V, find its real (RTTI) type.

   Other parameters FULL, TOP, USING_ENC as with value_rtti_type()
   and refer to the values computed for the object pointed to.  */

struct type *
value_rtti_indirect_type (struct value *v, int *full, 
			  int *top, int *using_enc)
{
  struct value *target;
  struct type *type, *real_type, *target_type;

  type = value_type (v);
  type = check_typedef (type);
  if (TYPE_CODE (type) == TYPE_CODE_REF)
    target = coerce_ref (v);
  else if (TYPE_CODE (type) == TYPE_CODE_PTR)
    target = value_ind (v);
  else
    return NULL;

  real_type = value_rtti_type (target, full, top, using_enc);

  if (real_type)
    {
      /* Copy qualifiers to the referenced object.  */
      target_type = value_type (target);
      real_type = make_cv_type (TYPE_CONST (target_type),
				TYPE_VOLATILE (target_type), real_type, NULL);
      if (TYPE_CODE (type) == TYPE_CODE_REF)
        real_type = lookup_reference_type (real_type);
      else if (TYPE_CODE (type) == TYPE_CODE_PTR)
        real_type = lookup_pointer_type (real_type);
      else
        internal_error (__FILE__, __LINE__, _("Unexpected value type."));

      /* Copy qualifiers to the pointer/reference.  */
      real_type = make_cv_type (TYPE_CONST (type), TYPE_VOLATILE (type),
				real_type, NULL);
    }

  return real_type;
}

/* Given a value pointed to by ARGP, check its real run-time type, and
   if that is different from the enclosing type, create a new value
   using the real run-time type as the enclosing type (and of the same
   type as ARGP) and return it, with the embedded offset adjusted to
   be the correct offset to the enclosed object.  RTYPE is the type,
   and XFULL, XTOP, and XUSING_ENC are the other parameters, computed
   by value_rtti_type().  If these are available, they can be supplied
   and a second call to value_rtti_type() is avoided.  (Pass RTYPE ==
   NULL if they're not available.  */

struct value *
value_full_object (struct value *argp, 
		   struct type *rtype, 
		   int xfull, int xtop,
		   int xusing_enc)
{
  struct type *real_type;
  int full = 0;
  int top = -1;
  int using_enc = 0;
  struct value *new_val;

  if (rtype)
    {
      real_type = rtype;
      full = xfull;
      top = xtop;
      using_enc = xusing_enc;
    }
  else
    real_type = value_rtti_type (argp, &full, &top, &using_enc);

  /* If no RTTI data, or if object is already complete, do nothing.  */
  if (!real_type || real_type == value_enclosing_type (argp))
    return argp;

  /* In a destructor we might see a real type that is a superclass of
     the object's type.  In this case it is better to leave the object
     as-is.  */
  if (full
      && TYPE_LENGTH (real_type) < TYPE_LENGTH (value_enclosing_type (argp)))
    return argp;

  /* If we have the full object, but for some reason the enclosing
     type is wrong, set it.  */
  /* pai: FIXME -- sounds iffy */
  if (full)
    {
      argp = value_copy (argp);
      set_value_enclosing_type (argp, real_type);
      return argp;
    }

  /* Check if object is in memory.  */
  if (VALUE_LVAL (argp) != lval_memory)
    {
      warning (_("Couldn't retrieve complete object of RTTI "
		 "type %s; object may be in register(s)."), 
	       TYPE_NAME (real_type));

      return argp;
    }

  /* All other cases -- retrieve the complete object.  */
  /* Go back by the computed top_offset from the beginning of the
     object, adjusting for the embedded offset of argp if that's what
     value_rtti_type used for its computation.  */
  new_val = value_at_lazy (real_type, value_address (argp) - top +
			   (using_enc ? 0 : value_embedded_offset (argp)));
  deprecated_set_value_type (new_val, value_type (argp));
  set_value_embedded_offset (new_val, (using_enc
				       ? top + value_embedded_offset (argp)
				       : top));
  return new_val;
}


/* Return the value of the local variable, if one exists.  Throw error
   otherwise, such as if the request is made in an inappropriate context.  */

struct value *
value_of_this (const struct language_defn *lang)
{
  struct symbol *sym;
  struct block *b;
  struct frame_info *frame;

  if (!lang->la_name_of_this)
    error (_("no `this' in current language"));

  frame = get_selected_frame (_("no frame selected"));

  b = get_frame_block (frame, NULL);

  sym = lookup_language_this (lang, b);
  if (sym == NULL)
    error (_("current stack frame does not contain a variable named `%s'"),
	   lang->la_name_of_this);

  return read_var_value (sym, frame);
}

/* Return the value of the local variable, if one exists.  Return NULL
   otherwise.  Never throw error.  */

struct value *
value_of_this_silent (const struct language_defn *lang)
{
  struct value *ret = NULL;
  volatile struct gdb_exception except;

  TRY_CATCH (except, RETURN_MASK_ERROR)
    {
      ret = value_of_this (lang);
    }

  return ret;
}

/* Create a slice (sub-string, sub-array) of ARRAY, that is LENGTH
   elements long, starting at LOWBOUND.  The result has the same lower
   bound as the original ARRAY.  */

struct value *
value_slice (struct value *array, int lowbound, int length)
{
  struct type *slice_range_type, *slice_type, *range_type;
  LONGEST lowerbound, upperbound;
  struct value *slice;
  struct type *array_type;

  array_type = check_typedef (value_type (array));
  if (TYPE_CODE (array_type) != TYPE_CODE_ARRAY
      && TYPE_CODE (array_type) != TYPE_CODE_STRING)
    error (_("cannot take slice of non-array"));

  range_type = TYPE_INDEX_TYPE (array_type);
  if (get_discrete_bounds (range_type, &lowerbound, &upperbound) < 0)
    error (_("slice from bad array or bitstring"));

  if (lowbound < lowerbound || length < 0
      || lowbound + length - 1 > upperbound)
    error (_("slice out of range"));

  /* FIXME-type-allocation: need a way to free this type when we are
     done with it.  */
  slice_range_type = create_range_type ((struct type *) NULL,
					TYPE_TARGET_TYPE (range_type),
					lowbound, 
					lowbound + length - 1);

    {
      struct type *element_type = TYPE_TARGET_TYPE (array_type);
      LONGEST offset =
	(lowbound - lowerbound) * TYPE_LENGTH (check_typedef (element_type));

      slice_type = create_array_type ((struct type *) NULL, 
				      element_type,
				      slice_range_type);
      TYPE_CODE (slice_type) = TYPE_CODE (array_type);

      if (VALUE_LVAL (array) == lval_memory && value_lazy (array))
	slice = allocate_value_lazy (slice_type);
      else
	{
	  slice = allocate_value (slice_type);
	  value_contents_copy (slice, 0, array, offset,
			       TYPE_LENGTH (slice_type));
	}

      set_value_component_location (slice, array);
      VALUE_FRAME_ID (slice) = VALUE_FRAME_ID (array);
      set_value_offset (slice, value_offset (array) + offset);
    }
  return slice;
}

/* Create a value for a FORTRAN complex number.  Currently most of the
   time values are coerced to COMPLEX*16 (i.e. a complex number
   composed of 2 doubles.  This really should be a smarter routine
   that figures out precision inteligently as opposed to assuming
   doubles.  FIXME: fmb  */

struct value *
value_literal_complex (struct value *arg1, 
		       struct value *arg2,
		       struct type *type)
{
  struct value *val;
  struct type *real_type = TYPE_TARGET_TYPE (type);

  val = allocate_value (type);
  arg1 = value_cast (real_type, arg1);
  arg2 = value_cast (real_type, arg2);

  memcpy (value_contents_raw (val),
	  value_contents (arg1), TYPE_LENGTH (real_type));
  memcpy (value_contents_raw (val) + TYPE_LENGTH (real_type),
	  value_contents (arg2), TYPE_LENGTH (real_type));
  return val;
}

/* Cast a value into the appropriate complex data type.  */

static struct value *
cast_into_complex (struct type *type, struct value *val)
{
  struct type *real_type = TYPE_TARGET_TYPE (type);

  if (TYPE_CODE (value_type (val)) == TYPE_CODE_COMPLEX)
    {
      struct type *val_real_type = TYPE_TARGET_TYPE (value_type (val));
      struct value *re_val = allocate_value (val_real_type);
      struct value *im_val = allocate_value (val_real_type);

      memcpy (value_contents_raw (re_val),
	      value_contents (val), TYPE_LENGTH (val_real_type));
      memcpy (value_contents_raw (im_val),
	      value_contents (val) + TYPE_LENGTH (val_real_type),
	      TYPE_LENGTH (val_real_type));

      return value_literal_complex (re_val, im_val, type);
    }
  else if (TYPE_CODE (value_type (val)) == TYPE_CODE_FLT
	   || TYPE_CODE (value_type (val)) == TYPE_CODE_INT)
    return value_literal_complex (val, 
				  value_zero (real_type, not_lval), 
				  type);
  else
    error (_("cannot cast non-number to complex"));
}

void
_initialize_valops (void)
{
  add_setshow_boolean_cmd ("overload-resolution", class_support,
			   &overload_resolution, _("\
Set overload resolution in evaluating C++ functions."), _("\
Show overload resolution in evaluating C++ functions."), 
			   NULL, NULL,
			   show_overload_resolution,
			   &setlist, &showlist);
  overload_resolution = 1;
}
@


1.317
log
@cleanup: use value_lazy_at instead of allocate_value_lazy/attribute setter

I came across a pattern used to construct a value in the following way:

  struct value *val = allocate_value_lazy (type);
  VALUE_LVAL (val) = lval_memory;
  set_value_address (val, address);

Instead we fold the above call into:

  value_at_lazy (type, addr);

2013-08-27  Sanimir Agovic  <sanimir.agovic@@intel.com>

	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full): Use value_at_lazy instead
	of assembling value via allocate_value_lazy and attribute setter.
	* findvar.c (default_read_var_value): Use value_at_lazy instead of
	assembling value via allocate_value_lazy and attribute setter.
	* valops.c (do_search_struct_field): Use value_at_lazy instead of
	assembling value via allocate_value_lazy and attribute setter.
@
text
@d1957 1
a1957 1
				      TYPE_LENGTH (value_type (basetype))) != 0)
@


1.316
log
@remove msymbol_objfile

This is another patch in my ongoing series to "split" objfile to share
more read-only data across inferiors.  See

    http://sourceware.org/gdb/wiki/ObjfileSplitting

When symbols are finally shared, there will be no back-link from the
symbol to its containing objfile, because there may be more than one
such objfile.  So, all such back-links must be removed.

One hidden back-link is the msymbol_objfile function.  Since
(eventually) a symbol may appear in more than one objfile, trying to
look up the objfile given just a symbol cannot work.

This patch removes msymbol_objfile in favor of using a bound minimal
symbol.  It introduces a new function to make this conversion simpler
in some spots.

The bonus of this patch is that using msymbol_objfile is slower than
simply looking up the owning objfile in the first place.

Built and regtested on x86-64 Fedora 18.

	* ada-exp.y (write_var_or_type): Use bound_minimal_symbol.
	* ada-lang.c (ada_lookup_simple_minsym): Return
	bound_minimal_symbol.
	* ada-lang.h (ada_lookup_simple_minsym): Update.
	* c-exp.y (variable): Use lookup_bound_minimal_symbol.
	* f-exp.y (variable): Use lookup_bound_minimal_symbol.
	* go-exp.y (variable): Use lookup_bound_minimal_symbol.
	* jv-exp.y (push_expression_name): Use lookup_bound_minimal_symbol.
	* m2-exp.y (variable): Use lookup_bound_minimal_symbol.
	* minsyms.c (msymbol_objfile): Remove.
	(lookup_minimal_symbol_internal): New function, from
	lookup_minimal_symbol.
	(lookup_minimal_symbol): Rewrite using
	lookup_minimal_symbol_internal.
	(lookup_bound_minimal_symbol): New function.
	* minsyms.h (msymbol_objfile): Remove.
	(lookup_bound_minimal_symbol): Declare.
	* p-exp.y (variable): Use lookup_bound_minimal_symbol.
	* parse.c (write_exp_msymbol): Change parameter to a
	bound_minimal_symbol.
	(write_dollar_variable): Use lookup_bound_minimal_symbol.
	* parser-defs.h (write_exp_msymbol): Update.
	* printcmd.c (address_info): Use lookup_bound_minimal_symbol.
	* symfile.c (simple_read_overlay_table): Use
	lookup_bound_minimal_symbol.
	* symtab.c (skip_prologue_sal): Don't use msymbol_objfile.
	(search_symbols): Likewise.
	(print_msymbol_info): Take a bound_minimal_symbol argument.
	(symtab_symbol_info, rbreak_command): Update.
	* symtab.h (struct symbol_search) <msymbol>: Change type
	to bound_minimal_symbol.
	* valops.c (find_function_in_inferior): Use
	lookup_bound_minimal_symbol.
	* value.c (value_fn_field): Use lookup_bound_minimal_symbol.
@
text
@a1952 1
	      v2  = allocate_value (basetype);
d1954 1
d1957 1
a1957 1
				      TYPE_LENGTH (basetype)) != 0)
a1958 2
	      VALUE_LVAL (v2) = lval_memory;
	      set_value_address (v2, base_addr);
@


1.315
log
@	PR symtab/15695
	* valops.c (value_struct_elt): Add missing call to check_typedef.
	(value_find_oload_method_list): Ditto.

	testsuite/
	* gdb.base/func-ptr.exp: New file.
	* gdb.base/func-ptr.c: New file.
@
text
@d152 2
a153 2
      struct minimal_symbol *msymbol = 
	lookup_minimal_symbol (name, NULL, NULL);
d155 1
a155 1
      if (msymbol != NULL)
d157 1
a157 1
	  struct objfile *objfile = msymbol_objfile (msymbol);
d165 1
a165 1
	  maddr = SYMBOL_VALUE_ADDRESS (msymbol);
@


1.314
log
@gdb/

	* target.c (update_current_target): Change the default action
	of 'to_traceframe_info' from tcomplain to return_zero.
	* target.h (struct target_ops) <to_traceframe_info>: Add more
	comments.
	* valops.c (read_value_memory): Call
	traceframe_available_memory unconditionally.

gdb/testsuite/

	* gdb.trace/read-memory.exp (test_from_remote): Update test.
	(teset_from_exec): Likewise.
@
text
@d2191 1
a2191 1
      if (TYPE_CODE (value_type (*argp)) != TYPE_CODE_FUNC)
d2355 1
a2355 1
      if (TYPE_CODE (value_type (*argp)) != TYPE_CODE_FUNC)
@


1.313
log
@http://sourceware.org/ml/gdb-patches/2013-07/msg00056.html

	* valops.c: Don't include "user-regs.h".
	(value_fetch_lazy): Moved to value.c.
	* value.c: Include "user-regs.h".
	(value_fetch_lazy): Moved from valops.c.
@
text
@d958 1
a958 2
      if (get_traceframe_number () < 0
	  || !traceframe_available_memory (&available_memory, memaddr, length))
@


1.312
log
@gdb/:
2013-02-11  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* valops.c (value_assign): Handling bitfield offset in
	`lval_internalvar_component' case.

gdb/testsuite/:
2013-02-11  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* gdb.base/bitfields.c (struct internalvartest): New declaration.
	* gdb.base/bitfields.exp (bitfield_internalvar): New function.
@
text
@a37 1
#include "user-regs.h"
a948 161
/* Called only from the value_contents and value_contents_all()
   macros, if the current data for a variable needs to be loaded into
   value_contents(VAL).  Fetches the data from the user's process, and
   clears the lazy flag to indicate that the data in the buffer is
   valid.

   If the value is zero-length, we avoid calling read_memory, which
   would abort.  We mark the value as fetched anyway -- all 0 bytes of
   it.

   This function returns a value because it is used in the
   value_contents macro as part of an expression, where a void would
   not work.  The value is ignored.  */

int
value_fetch_lazy (struct value *val)
{
  gdb_assert (value_lazy (val));
  allocate_value_contents (val);
  if (value_bitsize (val))
    {
      /* To read a lazy bitfield, read the entire enclosing value.  This
	 prevents reading the same block of (possibly volatile) memory once
         per bitfield.  It would be even better to read only the containing
         word, but we have no way to record that just specific bits of a
         value have been fetched.  */
      struct type *type = check_typedef (value_type (val));
      enum bfd_endian byte_order = gdbarch_byte_order (get_type_arch (type));
      struct value *parent = value_parent (val);
      LONGEST offset = value_offset (val);
      LONGEST num;

      if (!value_bits_valid (val,
			     TARGET_CHAR_BIT * offset + value_bitpos (val),
			     value_bitsize (val)))
	error (_("value has been optimized out"));

      if (!unpack_value_bits_as_long (value_type (val),
				      value_contents_for_printing (parent),
				      offset,
				      value_bitpos (val),
				      value_bitsize (val), parent, &num))
	mark_value_bytes_unavailable (val,
				      value_embedded_offset (val),
				      TYPE_LENGTH (type));
      else
	store_signed_integer (value_contents_raw (val), TYPE_LENGTH (type),
			      byte_order, num);
    }
  else if (VALUE_LVAL (val) == lval_memory)
    {
      CORE_ADDR addr = value_address (val);
      struct type *type = check_typedef (value_enclosing_type (val));

      if (TYPE_LENGTH (type))
	read_value_memory (val, 0, value_stack (val),
			   addr, value_contents_all_raw (val),
			   TYPE_LENGTH (type));
    }
  else if (VALUE_LVAL (val) == lval_register)
    {
      struct frame_info *frame;
      int regnum;
      struct type *type = check_typedef (value_type (val));
      struct value *new_val = val, *mark = value_mark ();

      /* Offsets are not supported here; lazy register values must
	 refer to the entire register.  */
      gdb_assert (value_offset (val) == 0);

      while (VALUE_LVAL (new_val) == lval_register && value_lazy (new_val))
	{
	  frame = frame_find_by_id (VALUE_FRAME_ID (new_val));
	  regnum = VALUE_REGNUM (new_val);

	  gdb_assert (frame != NULL);

	  /* Convertible register routines are used for multi-register
	     values and for interpretation in different types
	     (e.g. float or int from a double register).  Lazy
	     register values should have the register's natural type,
	     so they do not apply.  */
	  gdb_assert (!gdbarch_convert_register_p (get_frame_arch (frame),
						   regnum, type));

	  new_val = get_frame_register_value (frame, regnum);
	}

      /* If it's still lazy (for instance, a saved register on the
	 stack), fetch it.  */
      if (value_lazy (new_val))
	value_fetch_lazy (new_val);

      /* If the register was not saved, mark it optimized out.  */
      if (value_optimized_out (new_val))
	set_value_optimized_out (val, 1);
      else
	{
	  set_value_lazy (val, 0);
	  value_contents_copy (val, value_embedded_offset (val),
			       new_val, value_embedded_offset (new_val),
			       TYPE_LENGTH (type));
	}

      if (frame_debug)
	{
	  struct gdbarch *gdbarch;
	  frame = frame_find_by_id (VALUE_FRAME_ID (val));
	  regnum = VALUE_REGNUM (val);
	  gdbarch = get_frame_arch (frame);

	  fprintf_unfiltered (gdb_stdlog,
			      "{ value_fetch_lazy "
			      "(frame=%d,regnum=%d(%s),...) ",
			      frame_relative_level (frame), regnum,
			      user_reg_map_regnum_to_name (gdbarch, regnum));

	  fprintf_unfiltered (gdb_stdlog, "->");
	  if (value_optimized_out (new_val))
	    fprintf_unfiltered (gdb_stdlog, " optimized out");
	  else
	    {
	      int i;
	      const gdb_byte *buf = value_contents (new_val);

	      if (VALUE_LVAL (new_val) == lval_register)
		fprintf_unfiltered (gdb_stdlog, " register=%d",
				    VALUE_REGNUM (new_val));
	      else if (VALUE_LVAL (new_val) == lval_memory)
		fprintf_unfiltered (gdb_stdlog, " address=%s",
				    paddress (gdbarch,
					      value_address (new_val)));
	      else
		fprintf_unfiltered (gdb_stdlog, " computed");

	      fprintf_unfiltered (gdb_stdlog, " bytes=");
	      fprintf_unfiltered (gdb_stdlog, "[");
	      for (i = 0; i < register_size (gdbarch, regnum); i++)
		fprintf_unfiltered (gdb_stdlog, "%02x", buf[i]);
	      fprintf_unfiltered (gdb_stdlog, "]");
	    }

	  fprintf_unfiltered (gdb_stdlog, " }\n");
	}

      /* Dispose of the intermediate values.  This prevents
	 watchpoints from trying to watch the saved frame pointer.  */
      value_free_to_mark (mark);
    }
  else if (VALUE_LVAL (val) == lval_computed
	   && value_computed_funcs (val)->read != NULL)
    value_computed_funcs (val)->read (val);
  else if (value_optimized_out (val))
    /* Keep it optimized out.  */;
  else
    internal_error (__FILE__, __LINE__, _("Unexpected lazy value type."));

  set_value_lazy (val, 0);
  return 0;
}

@


1.311
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

	* charset.c (intermediate_encoding): Remove unused i.
	* completer.c (signal_completer): Remove unused i.
	* continuations.c (discard_my_continuations_1): Remove unused
	continuation_ptr.
	* corelow.c (core_close): Remove unuseD name.
	(get_core_siginfo): Remove unused pid.
	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Remove unused
	i, cps.
	* dwarf2loc.c (dwarf2_compile_expr_to_ax): Remove unused base_offset.
	(loclist_describe_location): Remove unused first.
	* event-top.c (command_line_handler): Remove unused got_eof.
	* exec.c (exec_close_1): Remove unused need_symtab_cleanup.
	(resize_section_table): Remove unused old_value.
	* gdb_bfd.c (gdb_bfd_map_section): Remove unused header.
	* gnu-v3-abi.c (compute_vtable_size): Remove unused addr.
	* i386-tdep.c (i386_process_record): Remove unused rex.
	* infcmd.c (get_return_value): Remove unused uiout.
	* jv-lang.c (type_from_class): Remove unused is_array.
	* jv-valprint.c (java_val_print): Remove unused i.
	* linux-nat.c (linux_nat_stop_lwp): Remove unused ptid.
	* linux-thread-db.c (thread_db_find_new_threads_2): Remove unuseD pid.
	* m2-typeprint.c (m2_print_type): Remove unused code.
	* macroexp.c (get_character_constant): Remove unused body_start.
	(macro_stringify): Remove unused result.
	* objc-lang.c (find_methods): Remove unused gdbarch.
	* objfiles.c (filter_overlapping_sections): Remove unused abfd1, abfd2.
	* regcache.c (regcache_cooked_read): Remove unused gdbarch.
	* stack.c (print_frame_args): Remove unused summary.
	* thread.c (thread_apply_command): Remove unused p.
	* valarith.c (value_x_unop): Remove unused mangle_ptr.
	* valops.c (search_struct_method): Remove unused skip.
	* valprint.c (generic_val_print): Remove unused byte_order.
	* varobj.c (varobj_update): Remove unused changed.
	* cli/cli-cmds.c (complete_command): Remove unused next_item.
	(alias_command): Remove unused c.
	* mi/mi-cmd-catch.c (mi_catch_load_unload): Remove unused c.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Remove unused
	format.
	(mi_cmd_data_write_memory): Remove unused word_format.
	(mi_cmd_data_write_memory_bytes): Remove unused r.
	* python/py-gdb-readline.c (gdbpy_readline_wrapper): Remove unused
	p_start, p_end.
	* python/python.c (_initialize_python): Remove unused cmd_name, cmd.
	* tui/tui-disasm.c (tui_set_disassem_content): Remove unused
	line_width.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00766.html
@
text
@d1236 21
a1256 5
      set_internalvar_component (VALUE_INTERNALVAR (toval),
				 value_offset (toval),
				 value_bitpos (toval),
				 value_bitsize (toval),
				 fromval);
@


1.310
log
@	* valops.c (find_overload_match): Remove unused argument 'lax'.
	* value.h: Remove unused argument 'lax' from the declaration of
	find_overload_match.
	* eval.c (value_subexp_standard): Do not pass a 'lax' argument
	to find_overload_match.
	* valarith.c (value_user_defined_cpp_op): Do not pass a 'lax'
	argument to find_overload_match.
@
text
@a2238 1
      int skip = 0;
@


1.309
log
@http://sourceware.org/ml/gdb-patches/2012-11/msg00312.html

gdb/ChangeLog
        * valarith.c (value_vector_widen): New function for replicating a
        scalar into a vector.
        (value_binop): Use value_vector_widen to widen scalar to vector
        rather than casting, this better matches gcc C behaviour.
        * valops.c (value_casst): Update logic for casting between vector
        types, and for casting from scalar to vector, try to match gcc C
        behaviour.
        * value.h (value_vector_widen): Declare.
        * opencl-lang.c (opencl_value_cast): New opencl specific casting
        function, handle special case for casting scalar to vector.
        (opencl_relop): Use opencl_value_cast.
        (evaluate_subexp_opencl): Use opencl_value_cast instead of
        value_cast, and handle BINOP_ASSIGN, UNOP_CAST, and UNOP_CAST_TYPE
        in order to use opencl_value_cast.

gdb/testsuite/ChangeLog
        * gdb.base/gnu_vector.c: New variable for use in tests.
        * gdb.base/gnu_vector.exp: Update and extend tests to reflect
        changes in scalar to vector casting and widening.
        * gdb.python/py-type.c: New variables for use in tests.
        * gdb.python/py-type.exp: Update vector related tests to reflect
        changes in scalar to vector casting and widening.
@
text
@d2519 3
a2521 5
   arguments NARGS, the NAME of a function whether it's a method or
   not (METHOD), and the degree of laxness (LAX) in conforming to
   overload resolution rules in ANSI C++, find the best function that
   matches on the argument types according to the overload resolution
   rules.
d2560 1
a2560 1
		     int lax, struct value **objp, struct symbol *fsym,
@


1.308
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d549 7
a555 23
  else if (code1 == TYPE_CODE_ARRAY && TYPE_VECTOR (type) && scalar)
    {
      /* Widen the scalar to a vector.  */
      struct type *eltype;
      struct value *val;
      LONGEST low_bound, high_bound;
      int i;

      if (!get_array_bounds (type, &low_bound, &high_bound))
	error (_("Could not determine the vector bounds"));

      eltype = check_typedef (TYPE_TARGET_TYPE (type));
      arg2 = value_cast (eltype, arg2);
      val = allocate_value (type);

      for (i = 0; i < high_bound - low_bound + 1; i++)
	{
	  /* Duplicate the contents of arg2 into the destination vector.  */
	  memcpy (value_contents_writeable (val) + (i * TYPE_LENGTH (eltype)),
		  value_contents_all (arg2), TYPE_LENGTH (eltype));
	}
      return val;
    }
@


1.307
log
@	* symtab.c (check_field): Now static.  Move from...
	* valops.c (check_field): ... here.  Remove.
	* value.h (check_field): Don't declare.
@
text
@d3 1
a3 1
   Copyright (C) 1986-2012 Free Software Foundation, Inc.
@


1.306
log
@2012-12-06  Pedro Alves  <palves@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	* valops.c (value_cast): Move TYPE_CODE_VOID case earlier.
testsuite
	* gdb.base/exprs.exp: Add tests for cast to void.
@
text
@a3182 36
/* Given TYPE, a structure/union,
   return 1 if the component named NAME from the ultimate target
   structure/union is defined, otherwise, return 0.  */

int
check_field (struct type *type, const char *name)
{
  int i;

  /* The type may be a stub.  */
  CHECK_TYPEDEF (type);

  for (i = TYPE_NFIELDS (type) - 1; i >= TYPE_N_BASECLASSES (type); i--)
    {
      const char *t_field_name = TYPE_FIELD_NAME (type, i);

      if (t_field_name && (strcmp_iw (t_field_name, name) == 0))
	return 1;
    }

  /* C++: If it was not found as a data field, then try to return it
     as a pointer to a method.  */

  for (i = TYPE_NFN_FIELDS (type) - 1; i >= 0; --i)
    {
      if (strcmp_iw (TYPE_FN_FIELDLIST_NAME (type, i), name) == 0)
	return 1;
    }

  for (i = TYPE_N_BASECLASSES (type) - 1; i >= 0; i--)
    if (check_field (TYPE_BASECLASS (type, i), name))
      return 1;

  return 0;
}

@


1.305
log
@	* ada-exp.y (write_object_renaming, write_var_or_type)
	(write_ambiguous_var, write_var_from_sym): Make blocks const.
	* ada-lang.c (replace_operator_with_call)
	(find_old_style_renaming_symbol): Make blocks const.
	* ada-lang.h (ada_find_renaming_symbol): Update.
	(struct ada_symbol_info) <block>: Now const.
	* breakpoint.c (watch_command_1): Update.
	* breakpoint.h (struct watchpoint) <exp_valid_block,
	cond_exp_valid_block>: Now const.
	* c-exp.y (classify_inner_name, classify_name): Make block
	argument const.
	* expprint.c (print_subexp_standard) <OP_VAR_VALUE>: Make 'b'
	const.
	* expression.h (innermost_block, parse_exp_1): Update.
	(union exp_element) <block>: Now const.
	* gdbtypes.c (lookup_template_type, lookup_enum, lookup_union)
	(lookup_struct): Make block argument const.
	* gdbtypes.h (lookup_template_type): Update.
	* go-exp.y (classify_name, classify_packaged_name)
	(package_name_p): Make block argument const.
	* objc-lang.c (lookup_struct_typedef): Make block argument const.
	* objc-lang.h (lookup_struct_typedef): Update.
	* parse.c (parse_exp_in_context, parse_exp_1)
	(write_exp_elt_block): Make block arguments const.
	(expression_context_block, innermost_block): Now const.
	* parser-defs.h (write_exp_elt_block): Update.
	(expression_context_block, innermost_block, block_found): Now
	const.
	* printcmd.c (struct display) <block>: Now const.
	* symtab.h (lookup_struct, lookup_union, lookup_enum): Update.
	* valops.c (address_of_variable): Make block argument const.
	* value.h (value_of_variable): Update.
	* varobj.c (struct varobj_root) <valid_block>: Now const.
@
text
@d572 4
a588 4
  else if (code1 == TYPE_CODE_VOID)
    {
      return value_zero (type, not_lval);
    }
@


1.304
log
@	* gdbtypes.c (lookup_array_range_type): Expand parameters
	LOW_BOUND and HIGH_BOUND to LONGEST.
	(lookup_string_range_type): Likewise.
	* gdbtypes.h (lookup_array_range_type): Likewise.
	(lookup_string_range_type): Likewise.
	* valops.c (value_cstring): Expand parameter LEN to ssize_t.
	Expand HIGHBOUND to ssize_t.
	(value_string): Likewise.
	* value.h (value_cstring): Expand parameter LEN to ssize_t.
	(value_string): Likewise.
@
text
@d1519 1
a1519 1
address_of_variable (struct symbol *var, struct block *b)
@


1.303
log
@	* ada-valprint.c (ada_val_print_1): Eliminate single-use
	variable LEN.
	* alpha-tdep.c (alpha_extract_return_value): Use TYPE_LENGTH
	directly.
	(alpha_store_return_value): Likewise.
	* amd64-tdep.c (amd64_classify_aggregate): Likewise.
	(amd64_push_arguments): Likewise.
	* ax-gdb.c (gen_trace_static_fields): Likewise.
	(gen_traced_pop): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* breakpoint.c (update_watchpoint): Likewise.
	* findcmd.c (parse_find_args): Use local variable for type
	instead of length.
	* findvar.c (default_read_var_value): Use TYPE_LENGTH directly.
	* h8300-tdep.c (h8300h_extract_return_value): Likewise.
	(h8300_store_return_value): Likewise.
	* i386-darwin-tdep.c (i386_darwin_push_dummy_call): Likewise.
	Use i386_darwin_arg_type_alignment directly.
	* infcall.c (call_function_by_hand): Use TYPE_LENGTH directly.
	* lm32-tdep.c (lm32_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	(m68hc11_extract_return_value): Likewise.
	* mep-tdep.c (mep_push_dummy_call): Likewise.
	* printcmd.c (float_type_from_length): Likewise.
	* s390-tdep.c (s390_value_from_register): Likewise.
	* stack.c (read_frame_arg): Likewise.
	* tracepoint.c (encode_actions_1): Likewise.
	* valops.c (value_fetch_lazy): Use local variable for type
	instead of length.  Use TYPE_LENGTH directly.
	* value.c (value_contents_equal): Use TYPE_LENGTH directly.
@
text
@d1841 1
a1841 1
value_cstring (char *ptr, int len, struct type *char_type)
d1845 1
a1845 1
  int highbound = len / TYPE_LENGTH (char_type);
d1864 1
a1864 1
value_string (char *ptr, int len, struct type *char_type)
d1868 1
a1868 1
  int highbound = len / TYPE_LENGTH (char_type);
@


1.302
log
@gdb/
	* valops.c (value_assign): Move observer_notify_target_changed
	below to replace reinit_frame_cache.
@
text
@a996 1
      int length = TYPE_LENGTH (type);
d1010 1
a1010 1
				      length);
d1012 1
a1012 1
	store_signed_integer (value_contents_raw (val), length,
d1018 1
a1018 1
      int length = TYPE_LENGTH (check_typedef (value_enclosing_type (val)));
d1020 1
a1020 1
      if (length)
d1022 2
a1023 1
			   addr, value_contents_all_raw (val), length);
@


1.301
log
@gdb/
	* gdbtypes.h (enum type_code): Define TYPE_CODE_BITSTRING -1.
	* arm-tdep.c (arm_type_align): Remove code handling TYPE_CODE_BITSTRING.
	* c-typeprint.c (c_type_print_varspec_prefix): Likewise.
	(c_type_print_varspec_suffix): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* f-typeprint.c (f_type_print_varspec_prefix): Likewise.
	(f_type_print_varspec_suffix): Likewise.
	* gdbtypes.c (is_scalar_type): Likewise.
	(recursive_dump_type): Likewise.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix): Likewise.
	(pascal_type_print_varspec_suffix): Likewise.
	(pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_val_print): Likewise.
	* valops.c (value_slice): Likewise.
	* valprint.c (scalar_type_p): Likewise.
	* valarith.c (value_bitstring_subscript): Remove.
	(value_concat): Remove code handling TYPE_CODE_BITSTRING.
	Remove comment on TYPE_CODE_BITSTRING.

	* stabsread.c (read_type): Don't set TYPE_CODE (type) to
	TYPE_CODE_BITSTRING.

	* python/py-type.c (pyty_codes): Move ENTRY (TYPE_CODE_BITSTRING) to
	slot 0.

gdb/doc:
	* gdb.texinfo (Types In Python): Mention gdb.TYPE_CODE_BITSTRING
	is deprecated.
@
text
@a1376 1
	observer_notify_target_changed (&current_target);
d1398 1
a1398 1
     cause the frame cache to be out of date.  Assigning to memory
d1407 1
a1407 1
      reinit_frame_cache ();
@


1.300
log
@gdb/
	* std-operator.def: Remove OP_BITSTRING.
	* breakpoint.c (watchpoint_exp_is_const): Update.
	* eval.c (evaluate_subexp_standard): Remove handling to
	OP_BITSTRING.
	* expprint.c (print_subexp_standard): Likewise.
	(dump_subexp_body_standard): Likewise.
	* parse.c (operator_length_standard): Likewise.
	* valops.c (value_bitstring): Remove.
	* value.h: Remove the declaration of 'value_bitstring'.
@
text
@d3747 1
a3747 2
      && TYPE_CODE (array_type) != TYPE_CODE_STRING
      && TYPE_CODE (array_type) != TYPE_CODE_BITSTRING)
a3763 8
  if (TYPE_CODE (array_type) == TYPE_CODE_BITSTRING)
    {
      int i;

      slice_type = create_set_type ((struct type *) NULL,
				    slice_range_type);
      TYPE_CODE (slice_type) = TYPE_CODE_BITSTRING;
      slice = value_zero (slice_type, not_lval);
a3764 23
      for (i = 0; i < length; i++)
	{
	  int element = value_bit_index (array_type,
					 value_contents (array),
					 lowbound + i);

	  if (element < 0)
	    error (_("internal error accessing bitstring"));
	  else if (element > 0)
	    {
	      int j = i % TARGET_CHAR_BIT;

	      if (gdbarch_bits_big_endian (get_type_arch (array_type)))
		j = TARGET_CHAR_BIT - 1 - j;
	      value_contents_raw (slice)[i / TARGET_CHAR_BIT] |= (1 << j);
	    }
	}
      /* We should set the address, bitssize, and bitspos, so the
         slice can be used on the LHS, but that may require extensions
         to value_assign.  For now, just leave as a non_lval.
         FIXME.  */
    }
  else
@


1.299
log
@gdb/
	* dwarf2loc.c (entry_values_debug): Add 'unsigned'.
	(_initialize_dwarf2loc): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* dwarf2loc.h: Update the declaration of 'entry_values_debug'.
	* dwarf2read.c (dwarf2_die_debug): Add 'unsigned'.
	(_initialize_dwarf2_read): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* darwin-nat.c (dwarwin_debug_flag): Add 'unsigned'.
	(_initialize_darwin_inferior): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* frame.c (frame_debug): Add 'unsigned'.
	(_intialize_frame): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* frame.h: Update the declaration of 'frame_debug'.
	* gdbtypes.c (overload_debug): Add 'unsigned'.
	(_initialize_gdbtypes): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* inferior.h: Update declaration of 'debug_infrun'.
	* infrun.c (debug_infrun): Add 'unsigned'.
	(_initialize_infrun): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* jit.c (jit_debug): Add 'unsigned'.
	(_initialize_jit): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* linux-nat.c (debug_linux_nat): Add 'unsigned'.
	(_initialize_linux_nat): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* linux-thread-db.c (libthread_db_debug): Add 'unsigned'.
	(_initialize_thread_db): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* machoread.c (mach_o_debug_level): Add 'unsigned'.
	(_initialize_machoread): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* mi/mi-cmd-var.c: Update the declaration of 'varobjdebug'.
	* microblaze-tdep.c (microblaze_debug_flag): Add 'unsigned'.
	(_initialize_microblaze_tdep): Call add_setshow_zuinteger_cmd
	intead of add_setshow_zinteger_cmd.
	* mips-tdep.c (mips_debug): Add 'unsigned'.
	(_initialize_mips_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* monitor.c (monitor_debug): Add 'unsigned'.
	(_initialize_remote_monitors): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* observer.c (observer_debug): Add 'unsigned'.
	(_initialize_observer): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* parse.c (expressiondebug): Add 'unsigned'.
	(_initialize_parse): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.c (record_debug): Add 'unsigned'.
	(_initialize_record): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.h: Update the declaration of 'record_debug'.
	* stap-probe.c (stap_expression_debug): Add 'unsigned'.
	(_initialize_stap_probe): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* serial.c (global_serial_debug_p): Add 'unsigned'.
	(_initialize_serial): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-dsbt.c (solib_dsbt_debug): Add 'unsigned'.
	(_initialize_dsbt_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-frv.c (solib_frv_debug): Add 'unsigned'.
	(_initialize_frv_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* target.c (targetdebug): Add 'unsigned'.
	(initialize_targets): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* valops.c (overload_debug): Add 'unsigned'.
	* varobj.c (varobjdebug): Add 'unsigned'.
	(_initialize_varobj): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* xtensa-tdep.c (xtensa_debug_level): Add 'unsigned'.
	(_initialize_xtensa_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.

	* arch-utils.h: Remove the declaration of 'gdbarch_debug'.
	* gdbarch.sh (gdbarch_debug): Add 'unsigned'.
	(extern void _initialize_gdbarch): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* gdbarch.c, gdbarch.h: Re-generated.
@
text
@a1877 13
struct value *
value_bitstring (char *ptr, int len, struct type *index_type)
{
  struct value *val;
  struct type *domain_type
    = create_range_type (NULL, index_type, 0, len - 1);
  struct type *type = create_set_type (NULL, domain_type);

  TYPE_CODE (type) = TYPE_CODE_BITSTRING;
  val = allocate_value (type);
  memcpy (value_contents_raw (val), ptr, TYPE_LENGTH (type));
  return val;
}
@


1.298
log
@	* p-valprint.c (pascal_object_print_value): Replace potentially
	unsafe alloca with xmalloc/xfree.
	* valops.c (search_struct_method): Likewise.
@
text
@d49 1
a49 1
extern int overload_debug;
@


1.297
log
@gdb:
	* corefile.c (write_memory_with_notification): New.
	* gdbcore.h: Declare write_memory_with_notification.
	* ada-lang.c (ada_value_assign): Replace 'write_memory' and
	'observer_notify_memory_changed' with 'write_memory_with_notification'.
	* valops.c (value_assign): Likewise.
	* python/py-inferior.c (infpy_write_memory): Call
	'write_memory_with_notification'.
@
text
@d2284 7
a2290 2
	      gdb_byte *tmp = alloca (TYPE_LENGTH (baseclass));
	      CORE_ADDR address = value_address (*arg1p);
d2301 1
@


1.296
log
@	* valops.c (value_find_oload_method_list): Now static.
	* value.h (value_find_oload_method_list): Don't declare.
@
text
@d1302 1
a1302 3
	write_memory (changed_addr, dest_buffer, changed_len);
	observer_notify_memory_changed (changed_addr, changed_len,
					dest_buffer);
@


1.295
log
@	* valops.c (find_overload_match): Use value_ind.
@
text
@d2515 1
a2515 1
struct fn_field *
@


1.294
log
@	PR c++/7173:
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Return early for Java
	types.
	* value.h (value_cast_pointers): Update.
	* valops.c (value_cast_pointers): Add 'subclass_check' argument.
	(value_cast): Update.
	(update_search_result): New function.
	(do_search_struct_field): New, from search_struct_field.  Check
	for ambiguous results.
	(search_struct_field): Rewrite.
	* infcall.c (value_arg_coerce): Update.
	* eval.c (evaluate_subexp_standard) <STRUCTOP_MEMBER>: Use
	value_cast_pointers.
	* ada-lang.c (ada_convert_actual): Update.
testsuite
	* gdb.cp/inherit.exp (test_print_mi_members): Expect errors.
	Remove kfails.
	(test_print_mi_member_types): Likewise.
@
text
@d2684 1
a2684 2
	deprecated_set_value_type (args[0],
				   TYPE_TARGET_TYPE (value_type (args[0])));
@


1.293
log
@gdb/
	* c-valprint.c (c_value_print): Use value_rtti_indirect_type
	instead of value_rtti_target_type.
	* eval.c (evaluate_subexp_standard): Use value_rtti_indirect_type
	instead of value_rtti_target_type.
	* typeprint.c (whatis_exp): Use value_rtti_indirect_type instead of
	value_rtti_target_type.
	* valops.c (value_ind): Extract function readjust_indirect_value_type.
	(value_rtti_target_type): Rename to ...
	(value_rtti_indirect_type): ... here and make it indirect.  Update
	function comment.
	* value.c (readjust_indirect_value_type): New function.
	(coerce_ref): Support for enclosing type setting for references
	with readjust_indirect_value_type.
	* value.h (readjust_value_type): New declaration.
	(value_rtti_target_type): Rename to ...
	(value_rtti_indirect_type): ... here.
@
text
@d304 4
a307 1
   reference types.  Returns the new pointer or reference.  */
d310 2
a311 1
value_cast_pointers (struct type *type, struct value *arg2)
d320 1
a320 1
      && !value_logical_not (arg2))
d575 1
a575 1
	return value_cast_pointers (type, arg2);
d1983 21
a2003 4
/* Helper function used by value_struct_elt to recurse through
   baseclasses.  Look for a field NAME in ARG1.  Adjust the address of
   ARG1 by OFFSET bytes, and search in it assuming it has (class) type
   TYPE.  If found, return value, else return NULL.
d2005 13
a2017 6
   If LOOKING_FOR_BASECLASS, then instead of looking for struct
   fields, look for a baseclass named NAME.  */

static struct value *
search_struct_field (const char *name, struct value *arg1, int offset,
		     struct type *type, int looking_for_baseclass)
d2043 3
a2045 6
	      {
		v = value_primitive_field (arg1, offset, i, type);
		if (v == 0)
		  error (_("there is no field named %s"), name);
	      }
	    return v;
d2070 1
a2070 1
		struct value *v;
d2084 5
a2088 3
		v = search_struct_field (name, arg1, new_offset, 
					 field_type,
					 looking_for_baseclass);
d2090 4
a2093 1
		  return v;
d2100 1
a2100 1
      struct value *v;
d2110 1
a2113 1
	  int boffset;
d2149 9
a2157 4
	    return v2;
	  v = search_struct_field (name, v2, 0,
				   TYPE_BASECLASS (type, i),
				   looking_for_baseclass);
d2162 11
a2172 6
	v = search_struct_field (name, arg1,
				 offset + TYPE_BASECLASS_BITPOS (type, 
								 i) / 8,
				 basetype, looking_for_baseclass);
      if (v)
	return v;
d2174 20
a2193 1
  return NULL;
@


1.292
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@d1775 1
a1775 9
      /* Re-adjust type.  */
      deprecated_set_value_type (arg2, TYPE_TARGET_TYPE (base_type));
      /* Add embedding info.  */
      set_value_enclosing_type (arg2, enc_type);
      set_value_embedded_offset (arg2, value_pointed_to_offset (arg1));

      /* We may be pointing to an object of some derived type.  */
      arg2 = value_full_object (arg2, NULL, 0, 0, 0);
      return arg2;
d3521 1
a3521 2
/* Given a pointer value V, find the real (RTTI) type of the object it
   points to.
d3527 2
a3528 2
value_rtti_target_type (struct value *v, int *full, 
			int *top, int *using_enc)
d3531 1
d3533 28
a3560 1
  target = value_ind (v);
d3562 1
a3562 1
  return value_rtti_type (target, full, top, using_enc);
@


1.291
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2008 1
a2008 1
	char *t_field_name = TYPE_FIELD_NAME (type, i);
d2166 1
a2166 1
      char *t_field_name = TYPE_FN_FIELDLIST_NAME (type, i);
d2410 1
a2410 1
      char *fn_field_name = TYPE_FN_FIELDLIST_NAME (type, i);
d3157 1
a3157 1
      char *t_field_name = TYPE_FIELD_NAME (type, i);
d3283 1
a3283 1
      char *t_field_name = TYPE_FIELD_NAME (t, i);
d3320 1
a3320 1
      char *t_field_name = TYPE_FN_FIELDLIST_NAME (t, i);
@


1.290
log
@gdb
	PR c++/13342:
	* valops.c (value_full_object): Return early if real type is
	smaller than the enclosing type.
gdb/testsuite
	* gdb.cp/destrprint.exp: New file.
	* gdb.cp/destrprint.cc: New file.
@
text
@d3 1
a3 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.290.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1986-2012 Free Software Foundation, Inc.
@


1.289
log
@2011-10-20  Phil Muldoon  <pmuldoon@@redhat.com>

	PR python/12656

	* python/py-frame.c (frapy_read_var): Use const struct *block.
	* python/py-type.c (typy_lookup_typename): Likewise.
	(typy_lookup_type): Likewise.
	(typy_legacy_template_argument): Likewise.
	(typy_template_argument): Likewise.
	(gdbpy_lookup_type): Likewise.
	* python/py-symbol.c (gdbpy_lookup_symbol): Likewise.
	* python/py-block.c (blpy_block_object): Likewise.
	(blpy_iter): Likewise.
	(blpy_get_start): Likewise.
	(blpy_get_end): Likewise.
	(blpy_get_function): Likewise.
	(blpy_get_superblock): Likewise.
	(set_block):  Likewise.
	(block_to_block_object): Likewise.
	(block_object_to_block): Likewise.
	(blpy_is_valid): Likewise.
	(blpy_get_global_block): New function.
	(blpy_get_static_block): New function.
	(blpy_is_global): New function.
	(blpy_is_static): New function.
	* blockframe.c (block_innermost_frame): Likewise.
	* valops.c (value_of_variable): Likewise.
	* frame.h: Update prototypes.
	* python/python-internal.h: Likewise.
	* value.h: Likewise.

2011-10-20  Phil Muldoon  <pmuldoon@@redhat.com>

	PR python/12656

	* gdb.texinfo (Blocks In Python): Document is_static, is_global,
	global_block, static_block function.

2011-10-20  Phil Muldoon  <pmuldoon@@redhat.com>

	PR python/12656

	* gdb.python/py-block.exp: Add is_global, is_static, static_block,
	global_block tests.
@
text
@d3584 7
@


1.288
log
@	PR c++/13225
	* eval.c (evaluate_subexp_standard): Do not construct
	an array of types; pass the value array directly to
	find_overload_match.
	* gdbtypes.h (NULL_POINTER_CONVERSION_BADNESS): Declare.
	(rank_function): Take an array of values instead of types.
	(rank_one_type): Add struct value * parameter.
	* gdbtypes.c (NULL_POINTER_CONVERSION_BADNESS): Define.
	(rank_function): For each argument, pass the argument's
	value to rank_one_type.
	(rank_one_type): Add VALUE parameter.
	If the parameter type is a pointer and the argument type
	is an integer, return NULL_POINTER_CONVERSION_BADNESS if
	VALUE is zero.
	Update all calls to rank_one_type, passing NULL for new
	VALUE parameter.
	* valarith.c (value_user_defined_cpp_op): Do not construct
	an array of types; pass the value array directly to
	find_overload_match.
	* valops.c (find_overload_method_list): Take an array of
	values instead of types.
	Save the type of OBJP for later use.
	Update calls to find_oload_champ, and find_oload_champ_namespace.
	(find_oload_champ_namespace): Take an array of values instead
	of types.
	(find_oload_champ_namespace_loop): Likewise.
	(find_oload_champ): Likewise.
	(classify_oload_match): Inspect all arguments
	until INCOMPATIBLE is found. Return the worst badness found
	otherwise.
	(compare_parameters): Update call to rank_one_type.
	* value.h (find_overload_match): Take an array of values instead
	of types.
@
text
@d1494 1
a1494 1
value_of_variable (struct symbol *var, struct block *b)
@


1.287
log
@gdb/
	Make some lval_funcs methods to default on NULL.
	* valops.c (value_fetch_lazy): Check if lval_computed read method is
	NULL.
	(value_assign): Check if lval_computed write method is NULL.
	* value.h (struct lval_funcs): Comment NULL values for read and write
	methods.
@
text
@d64 1
a64 1
static int find_oload_champ_namespace (struct type **, int,
d71 1
a71 1
int find_oload_champ_namespace_loop (struct type **, int,
d77 1
a77 1
static int find_oload_champ (struct type **, int, int, int,
d2494 1
a2494 1
/* Given an array of argument types (ARGTYPES) (which includes an
d2537 1
a2537 1
find_overload_match (struct type **arg_types, int nargs, 
d2544 1
d2613 1
a2613 1
	  method_oload_champ = find_oload_champ (arg_types, nargs, method,
d2635 2
a2636 1
	arg_types[0] = TYPE_TARGET_TYPE (arg_types[0]);
d2682 1
a2682 1
      func_oload_champ = find_oload_champ_namespace (arg_types, nargs,
d2786 1
a2786 1
      struct type *obj_type = check_typedef (value_type (*objp));
d2789 2
a2790 2
	  && (TYPE_CODE (obj_type) == TYPE_CODE_PTR
	      || TYPE_CODE (obj_type) == TYPE_CODE_REF))
d2819 1
a2819 1
find_oload_champ_namespace (struct type **arg_types, int nargs,
d2828 1
a2828 1
  find_oload_champ_namespace_loop (arg_types, nargs,
d2848 1
a2848 1
find_oload_champ_namespace_loop (struct type **arg_types, int nargs,
d2885 1
a2885 1
      if (find_oload_champ_namespace_loop (arg_types, nargs,
d2914 11
a2924 1
    make_symbol_overload_list_adl (arg_types, nargs, func_name);
d2929 1
a2929 1
  new_oload_champ = find_oload_champ (arg_types, nargs, 0, num_fns,
d2966 1
a2966 1
/* Look for a function to take NARGS args of types ARG_TYPES.  Find
d2976 1
a2976 1
find_oload_champ (struct type **arg_types, int nargs, int method,
d3022 1
a3022 1
			  arg_types + static_offset,
d3096 1
d3109 1
a3109 1
	return NON_STANDARD;	/* Non-standard type conversions
d3113 3
a3115 1
  return STANDARD;		/* Only standard conversions needed.  */
d3249 1
a3249 1
	                                   TYPE_FIELD_TYPE (t2, i)),
@


1.286
log
@gdb/
	* findvar.c (read_var_value): Never return NULL, throw an error
	instead.  Update the function comment.  State symbol name in the error
	messages.
	* python/py-frame.c (frapy_read_var): Remove handling of NULL from
	read_var_value.
	* stack.c (print_frame_args): Likewise.
	* valops.c (value_of_variable): Likewise.
@
text
@d1113 2
a1114 1
  else if (VALUE_LVAL (val) == lval_computed)
d1385 5
a1389 1
	funcs->write (toval, fromval);
d1391 1
a1391 1
      break;
@


1.285
log
@gdb/
	* eval.c (evaluate_subexp_standard) <OP_THIS>: Update the value_of_this
	caller to value_of_this.
	* p-exp.y: Update the value_of_this caller to value_of_this_silent.
	Twice.
	* valops.c (value_of_this): Remove parameter complain and variable ret.
	Update function comment.  Never return NULL by this code.
	(value_of_this_silent): New function.
	* value.h (value_of_this): Remove parameter complain.
	(value_of_this_silent): New declaration.
@
text
@a1490 1
  struct value *val;
d1511 1
a1511 5
  val = read_var_value (var, frame);
  if (!val)
    error (_("Address of symbol \"%s\" is unknown."), SYMBOL_PRINT_NAME (var));

  return val;
@


1.284
log
@gdb/
2011-07-27  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	* eval.c (evaluate_subexp_standard): Remove not_lval from all calls of
	value_one.
	* valops.c (value_one): Remove parameter lv.  Do not pass it to itself.
	Assert the result kind.
	* value.h (value_one): Remove parameter lv.
@
text
@d3603 2
a3604 3
/* Return the value of the local variable, if one exists.
   Flag COMPLAIN signals an error if the request is made in an
   inappropriate context.  */
d3607 1
a3607 1
value_of_this (const struct language_defn *lang, int complain)
a3610 1
  struct value * ret;
d3614 1
a3614 5
    {
      if (complain)
	error (_("no `this' in current language"));
      return 0;
    }
d3616 1
a3616 8
  if (complain)
    frame = get_selected_frame (_("no frame selected"));
  else
    {
      frame = deprecated_safe_get_selected_frame ();
      if (frame == 0)
	return 0;
    }
d3622 16
d3639 1
a3639 5
      if (complain)
	error (_("current stack frame does not contain a variable named `%s'"),
	       lang->la_name_of_this);
      else
	return NULL;
a3641 3
  ret = read_var_value (sym, frame);
  if (ret == 0 && complain)
    error (_("`%s' argument unreadable"), lang->la_name_of_this);
@


1.283
log
@gdb/
	Fix crash on lval_computed values.
	* valops.c (value_zero): Use not_lval for lval_computed.

gdb/testsuite/
	Fix crash on lval_computed values.
	* gdb.dwarf2/implptr.exp (print sizeof (j[0])): New test.
@
text
@d867 1
a867 1
/* Create a value of numeric type TYPE that is one, and return it.  */
d870 1
a870 1
value_one (struct type *type, enum lval_type lv)
d904 1
a904 1
	  tmp = value_one (eltype, lv);
d914 3
a916 1
  VALUE_LVAL (val) = lv;
@


1.282
log
@gdb/
	Code cleanup - constify struct lval_funcs.
	* dwarf2loc.c (pieced_value_funcs): Make it const.
	* infrun.c (siginfo_value_funcs): Likewise.
	* opencl-lang.c (opencl_value_funcs): Likewise.
	* valops.c (value_assign, value_ind): Make the funcs variable const.
	* value.c (struct value): Make location.computed.funcs target const.
	Rearrange the comments.
	(allocate_computed_value): Make the funcs parameter target const.
	(value_computed_funcs): Return the funcs target const.
	(value_free, value_copy, set_value_component_location): Make the funcs
	variable const.
	* value.h (allocate_computed_value): Make the funcs parameter target
	const.
	(value_computed_funcs): Return the funcs target const.
	* windows-tdep.c (tlb_value_funcs): Make it const.
@
text
@d863 1
a863 1
  VALUE_LVAL (val) = lv;
@


1.281
log
@	* varobj.c (varobj_create): Call do_cleanups on early exit path.
	* valops.c (find_overload_match): Call do_cleanups on early exit
	path.
	* solib.c (solib_find): Call do_cleanups on early exit path.
@
text
@d1380 1
a1380 1
	struct lval_funcs *funcs = value_computed_funcs (toval);
d1743 1
a1743 1
      struct lval_funcs *funcs = value_computed_funcs (arg1);
@


1.280
log
@	* valops.c (find_overload_match): Call do_cleanups before early
	return.
	* top.c (execute_command): Call do_cleanups before early return.
	(command_loop): Likewise.
	* stack.c (backtrace_command): Make a null cleanup early.  Don't
	conditionally call do_cleanups.
	* python/py-value.c (TRY_CATCH): Move cleanup handling into
	TRY_CATCH.
	* python/py-breakpoint.c (gdbpy_breakpoint_has_py_cond): Rearrange
	so cleanups are always run.
	* mi/mi-cmd-var.c (mi_cmd_var_delete): Reset old_cleanups.
	* findcmd.c (parse_find_args): Call do_cleanups on early return
	path.
	* dbxread.c (elfstab_build_psymtabs): Make a null cleanup early.
	Don't conditionally call do_cleanups.
	* cli/cli-script.c (execute_user_command): Initialize 'old_chain'
	later.
@
text
@d2588 1
@


1.279
log
@	* valops.c (value_of_this): Use lookup_language_this.
	* symtab.h (lookup_language_this): Declare.
	* symtab.c (lookup_language_this): New function.
	(lookup_symbol_aux): Use lookup_language_this.
	* ax-gdb.c (gen_expr) <OP_THIS>: Use lookup_language_this.
@
text
@d2673 1
@


1.278
log
@	* value.h (value_of_this): Update.
	(value_of_local): Remove.
	* valops.c (value_of_this): Rename from value_of_local.  Change
	parameters.
	* p-exp.y (exp): Update.
	(variable): Likewise.
	* eval.c (evaluate_subexp_standard) <OP_THIS>: Use value_of_this.
@
text
@d3606 1
a3606 1
  struct symbol *func, *sym;
a3609 1
  const char *name = lang->la_name_of_this;
d3611 1
a3611 1
  if (!name)
d3627 1
a3627 17
  func = get_frame_function (frame);
  if (!func)
    {
      if (complain)
	error (_("no `%s' in nameless context"), name);
      else
	return 0;
    }

  b = SYMBOL_BLOCK_VALUE (func);
  if (dict_empty (BLOCK_DICT (b)))
    {
      if (complain)
	error (_("no args, no `%s'"), name);
      else
	return 0;
    }
d3629 1
a3629 3
  /* Calling lookup_block_symbol is necessary to get the LOC_REGISTER
     symbol instead of the LOC_ARG one (if both exist).  */
  sym = lookup_block_symbol (b, name, VAR_DOMAIN);
d3634 1
a3634 1
	       name);
d3641 1
a3641 1
    error (_("`%s' argument unreadable"), name);
@


1.277
log
@	* valops.c (value_of_local): Complain if NAME is NULL.
	* std-operator.def (OP_OBJC_SELF): Remove.
	* parse.c (operator_length_standard) <OP_OBJC_SELF>: Remove.
	* objc-exp.y (name_not_typename): Use OP_THIS.
	* expprint.c (print_subexp_standard) <OP_THIS>: Print language's
	name for "this".
	<OP_OBJC_SELF>: Remove.
	* eval.c (evaluate_subexp_standard) <OP_OBJC_SELF>: Remove.
@
text
@d3604 1
a3604 1
value_of_local (const char *name, int complain)
d3610 1
a3663 12
/* C++/Objective-C: return the value of the class instance variable,
   if one exists.  Flag COMPLAIN signals an error if the request is
   made in an inappropriate context.  */

struct value *
value_of_this (int complain)
{
  if (!current_language->la_name_of_this)
    return 0;
  return value_of_local (current_language->la_name_of_this, complain);
}

@


1.276
log
@gdb/
	* c-exp.y (qualified_name): Call destructor_name_p with $1.type.
	(classify_inner_name): Call cp_lookup_nested_type with
	yylval.tsym.type.
	* cp-namespace.c (cp_lookup_nested_type): New variable
	saved_parent_type.  Call CHECK_TYPEDEF for parent_type.  Call
	type_name_no_tag_or_error with saved_parent_type.
	* dwarf2read.c (load_partial_dies): Read in any children of
	DW_TAG_typedef with complaint in such case.
	* gdbtypes.c (type_name_no_tag_or_error): New function.
	* gdbtypes.h (type_name_no_tag_or_error): New prototype.
	* valops.c (destructor_name_p): New comment for parameter type.  Remove
	type const.  Make dname and cp const.  Call type_name_no_tag_or_error.
	* value.h (destructor_name_p): Remove type const.
@
text
@d3611 7
@


1.275
log
@gdb
	* dwarf2read.c (fixup_partial_die): Handle linkage name on
	otherwise anonymous types.
	(dwarf2_name): Likewise.
	* valops.c (value_struct_elt_for_reference): Refine artificial
	type logic.  Call error if j==-1.
gdb/testsuite
	* gdb.cp/anon-struct.cc: New file.
	* gdb.cp/anon-struct.exp: New file.
@
text
@d3101 3
a3103 1
   inappropriate for TYPE, an error is signaled.  */
d3105 1
a3105 1
destructor_name_p (const char *name, const struct type *type)
d3109 2
a3110 2
      char *dname = type_name_no_tag (type);
      char *cp = strchr (dname, '<');
@


1.274
log
@	gdb/
	* dwarf2loc.c (read_pieced_value): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	(write_pieced_value): Handle get_frame_register_bytes returning
	that the register piece is unavailable/optimized out when doing a
	read-modify write of a bitfield.
	* findvar.c (value_from_register): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	* frame.c (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.  Throw error on bad debug info.  Use
	frame_register instead of frame_register_read, to fill in the new
	arguments.
	* frame.h (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.
	* valops.c: (value_assign): Adjust, and handle
	get_frame_register_bytes failing.
	* spu-tdep.c: Include exceptions.h.
	(spu_software_single_step): Adjust, and handle
	get_frame_register_bytes failing.
	(spu_get_longjmp_target): Ditto.
	* gdbarch.sh (register_to_value): Change to return int.  New
	parameters `optimizedp' and `unavailablep'.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.c (i386_register_to_value): Adjust to new
	gdbarch_register_to_value interface.
	* i387-tdep.c (i387_register_to_value): Ditto.
	* i387-tdep.h (i387_register_to_value): Ditto.
	* alpha-tdep.c (alpha_register_to_value): Ditto.
	* ia64-tdep.c (ia64_register_to_value): Ditto.
	* m68k-tdep.c (m68k_register_to_value): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* rs6000-tdep.c (rs6000_register_to_value): Ditto.
@
text
@d3342 1
a3342 2
	      for (ii = 0; ii < TYPE_FN_FIELDLIST_LENGTH (t, i);
		   ++ii)
d3347 3
a3349 2
		     constructor.  There is no ambiguity in this
		     case.  */
d3351 5
a3355 1
		    continue;
d3359 1
a3359 1
		  if (j != -1)
d3365 3
@


1.273
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@d1346 10
a1355 2
		get_frame_register_bytes (frame, value_reg, offset,
					  changed_len, buffer);
@


1.272
log
@	gdb/
	* exceptions.h (NOT_AVAILABLE_ERROR): New error.
	* value.c: Include "exceptions.h".
	(require_available): Throw NOT_AVAILABLE_ERROR instead of a
	generic error.
	* cp-abi.c: Include gdb_assert.h.
	(baseclass_offset): Add `embedded_offset' and `val' parameters.
	Assert the method is implemented.  Wrap NOT_AVAILABLE_ERROR
	errors.
	* cp-abi.h (baseclass_offset): Add `embedded_offset' and `val'
	parameters.  No longer returns -1 on error.
	(struct cp_abi_ops) <baseclass_offset>: Add `embedded_offset' and
	`val' parameters.
	* cp-valprint.c: Include exceptions.h.
	(cp_print_value): Handle NOT_AVAILABLE_ERROR errors when fetching
	the baseclass_offset.  Handle unavailable base classes.  Use
	val_print_invalid_address.
	* p-valprint.c: Include exceptions.h.
	(pascal_object_print_value): Handle NOT_AVAILABLE_ERROR errors
	when fetching the baseclass_offset.  No longer expect
	baseclass_offset returning -1.  Handle unavailable base classes.
	Use val_print_invalid_address.
	* valops.c (dynamic_cast_check_1): Rename `contents' parameter to
	`valaddr' parameter, and change its type to gdb_byte pointer.  Add
	`embedded_offset' and `val' parameters.  Adjust.
	(dynamic_cast_check_2): Rename `contents' parameter to `valaddr'
	parameter, and change its type to gdb_byte pointer.  Add
	`embedded_offset' and `val' parameters.  Adjust.  No longer expect
	baseclass_offset returning -1.
	(value_dynamic_cast): Use value_contents_for_printing rather than
	value_contents.  Adjust.
	(search_struct_field): No longer expect baseclass_offset returning
	-1.
	(search_struct_method): If reading memory from the target is
	necessary, wrap it in a new value to pass to baseclass_offset.  No
	longer expect baseclass_offset returning -1.
	(find_method_list): No longer expect baseclass_offset returning
	-1.  Use value_contents_for_printing rather than value_contents.
	* valprint.c (val_print_invalid_address): New function.
	* valprint.h (val_print_invalid_address): Declare.
	* gdbtypes.c (is_unique_ancestor_worker): New `embedded_offset'
	and `val' parameters.  No longer expect baseclass_offset returning
	-1.  Adjust.
	* gnu-v2-abi.c: Include "exceptions.h".
	(gnuv2_baseclass_offset): Add `embedded_offset' and `val'
	parameters.  Handle unavailable memory.  Recurse through
	gnuv2_baseclass_offset directly, rather than through
	baseclass_offset.  No longer returns -1 on not found, instead
	throw an error.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Add `embedded_offset' and
	`val' parameters.  Adjust.

	gdb/testsuite/
	* gdb.trace/unavailable.cc (class Base, class Middle, class
	Derived): New types.
	(derived_unavail, derived_partial, derived_whole): New globals.
	(virtual_partial): New global.
	(virtualp): Point at virtual_partial.
	* gdb.trace/unavailable.exp (gdb_collect_globals_test): Add tests
	related to unavailable vptr.
@
text
@d2619 3
a2621 3
      /* If the the overload match is being search for both
         as a method and non member function, the first argument
         must now be dereferenced.  */
d2696 3
a2698 3
	    /* FIXME: GDB does not support the general ambiguous
	     case.  All candidates should be collected and presented
	     the the user.  */
d3180 1
a3180 1
   with respect to the the methods' parameters.  If the types of the
@


1.271
log
@	gdb/
	* valops.c (value_repeat): Use read_value_memory instead of
	read_memory.

	gdb/testsuite/
	* gdb.trace/unavailable.exp (gdb_collect_globals_test): Test that
	value repeat handles unavailableness.
@
text
@d655 2
a656 1
		      const bfd_byte *contents,
d658 1
d668 2
a669 1
      int offset = baseclass_offset (search_type, i, contents, address);
a670 2
      if (offset == -1)
	error (_("virtual baseclass botch"));
d673 2
a674 2
	  if (address + offset >= arg_addr
	      && address + offset < arg_addr + TYPE_LENGTH (arg_type))
d679 1
a679 1
					 address + offset);
d684 3
a686 2
					      contents + offset,
					      address + offset,
d702 2
a703 1
		      const bfd_byte *contents,
d705 1
d718 2
a719 3
      offset = baseclass_offset (search_type, i, contents, address);
      if (offset == -1)
	error (_("virtual baseclass botch"));
d725 1
a725 1
				     address + offset);
d729 3
a731 2
					      contents + offset,
					      address + offset,
d829 3
a831 1
				value_contents (tem), value_address (tem),
d843 3
a845 1
			       value_contents (tem), value_address (tem),
d1334 1
d2087 4
a2090 6
				      value_contents (arg1) + offset,
				      value_address (arg1)
				      + value_embedded_offset (arg1)
				      + offset);
	  if (boffset == -1)
	    error (_("virtual baseclass botch"));
d2212 2
d2218 1
d2228 1
d2230 1
a2230 1
	      if (target_read_memory (value_address (*arg1p) + offset,
d2233 6
a2238 1
	      base_valaddr = tmp;
d2241 5
a2245 1
	    base_valaddr = value_contents (*arg1p) + offset;
d2248 2
a2249 3
					  value_address (*arg1p) + offset);
	  if (base_offset == -1)
	    error (_("virtual baseclass botch"));
a2426 1
	  base_offset = value_offset (*argp) + offset;
d2428 3
a2430 4
					  value_contents (*argp) + base_offset,
					  value_address (*argp) + base_offset);
	  if (base_offset == -1)
	    error (_("virtual baseclass botch"));
@


1.270
log
@	gdb/
	* value.h (value_contents_copy, value_contents_copy_raw): Declare.
	* value.c (value_contents_copy_raw, value_contents_copy): New
	functions.
	(value_primitive_field): Use value_contents_copy_raw instead of
	memcpy.
	* valops.c (value_fetch_lazy): Use value_contents_copy instead of
	memcpy.
	(value_array, value_slice): Ditto.
	* valarith.c (value_subscripted_rvalue): Use
	value_contents_copy_raw instead of memcpy.

	gdb/testsuite/
	* gdb.trace/unavailable.exp (gdb_collect_globals_test): Add new
	tests for building arrays from unavailable values, subscripting
	non-memory rvalue unvailable arrays, and accessing fields or
	baseclasses of non-lazy unavailable values,
	* gdb.trace/unavailable.cc (small_struct, small_struct_b): New
	struct types.
	(g_smallstruct, g_smallstruct_b): New globals.
@
text
@a1458 3
  read_memory (value_address (arg1),
	       value_contents_all_raw (val),
	       TYPE_LENGTH (value_enclosing_type (val)));
d1462 4
@


1.269
log
@	<unavailable> references.

	gdb/
	* valops.c (get_value_at): Use value_from_contents_and_address,
	avoiding read_memory.
@
text
@d1047 1
a1047 1
      /* If the register was not saved, mark it unavailable.  */
d1051 6
a1056 2
	memcpy (value_contents_raw (val), value_contents (new_val),
		TYPE_LENGTH (type));
d1772 2
a1773 3
/* Create a value for an array by allocating space in GDB, copying
   copying the data into that space, and then setting up an array
   value.
d1815 2
a1816 5
	{
	  memcpy (value_contents_all_raw (val) + (idx * typelength),
		  value_contents_all (elemvec[idx]),
		  typelength);
	}
d1825 1
a1825 3
    memcpy (value_contents_writeable (val) + (idx * typelength),
	    value_contents_all (elemvec[idx]),
	    typelength);
d3712 2
a3713 3
	  memcpy (value_contents_writeable (slice),
		  value_contents (array) + offset,
		  TYPE_LENGTH (slice_type));
@


1.268
log
@	gdb/
	* value.h (unpack_bits_as_long): Delete declaration.
	(unpack_value_bits_as_long): Declare.
	(unpack_value_field_as_long): Declare.
	(value_field_bitfield): Declare.
	* value.c (unpack_bits_as_long): Rename to...
	(unpack_value_bits_as_long_1): ... this.  Add embedded_offset and
	value parameters.  Return the extracted result in a new output
	parameter.  If the value contents are unavailable, return false,
	otherwise return true.
	(unpack_value_bits_as_long): New.
	(unpack_field_as_long): Rename to...
	(unpack_value_field_as_long_1): ... this.  Add embedded_offset and
	Add embedded_offset and value parameters.  Return the extracted
	result in a new output parameter. If the value contents are
	unavailable, return false, otherwise return true.
	(unpack_value_field_as_long): New.
	(unpack_field_as_long_1): New.
	(unpack_field_as_long): Reimplement as wrapper around
	unpack_value_field_as_long_1.
	(value_field_bitfield): New function.
	* valops.c (value_fetch_lazy): When fetching a bitfield, use
	unpack_value_bits_as_long.  Mark the value as unavailable, if it
	is unavailable.
	* jv-valprint.c (java_print_value_fields): Use
	value_field_bitfield.
	* p-valprint.c (pascal_object_print_value_fields): Use
	value_field_bitfield.
	* cp-valprint.c (cp_print_value_fields): Use value_field_bitfield.
@
text
@d920 1
a920 9
  if (lazy)
    {
      val = allocate_value_lazy (type);
    }
  else
    {
      val = allocate_value (type);
      read_memory (addr, value_contents_all_raw (val), TYPE_LENGTH (type));
    }
d922 2
a923 2
  VALUE_LVAL (val) = lval_memory;
  set_value_address (val, addr);
@


1.267
log
@	Mark pieces of values as unavailable if the corresponding memory
	is unavailable.

	gdb/
	* valops.c: Include tracepoint.h.
	(value_fetch_lazy): Use read_value_memory.
	(read_value_memory): New.
	* value.h (read_value_memory): Declare.
	* dwarf2loc.c (read_pieced_value): Use read_value_memory.
	* exec.c (section_table_available_memory): New function.
	* exec.h (section_table_available_memory): Declare.
@
text
@d992 1
a992 5
      LONGEST num = unpack_bits_as_long (value_type (val),
					 (value_contents_for_printing (parent)
					  + offset),
					 value_bitpos (val),
					 value_bitsize (val));
d1000 11
a1010 1
      store_signed_integer (value_contents_raw (val), length, byte_order, num);
@


1.266
log
@gdb/
	Fix crash.
	* valops.c (compare_parameters): Verify TYPE_NFIELDS before
	touching TYPE_FIELD_ARTIFICIAL.

gdb/testsuite/
	* gdb.cp/noparam.exp: New file.
	* gdb.cp/noparam.cc: New file.
@
text
@d41 1
a41 1

d1012 2
a1013 6
	{
	  if (value_stack (val))
	    read_stack (addr, value_contents_all_raw (val), length);
	  else
	    read_memory (addr, value_contents_all_raw (val), length);
	}
d1112 83
@


1.265
log
@gdb/
	Make value allocations more lazy.
	* ada-lang.c (coerce_unspec_val_to_type): Use allocate_value_lazy
	instead of allocate_value and set_value_lazy when possible.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full): Use allocate_value_lazy
	instead of allocate_value and set_value_lazy.
	* findvar.c (value_of_register_lazy): Likewise.
	(read_var_value): Remove V preallocation, call just check_typedef in
	advance.  Move allocate_value to LOC_CONST, LOC_LABEL,
	LOC_CONST_BYTES.  Use allocate_value_lazy in LOC_STATIC, LOC_ARG,
	LOC_REF_ARG, LOC_LOCAL, LOC_BLOCK.  Set ADDR instead of
	set_value_address and break in LOC_BLOCK.  Use allocate_value_lazy and
	remove lval_memory set in LOC_REGPARM_ADDR.  Use allocate_value_lazy
	in LOC_UNRESOLVED and LOC_OPTIMIZED_OUT.  Add setting lval_memory at
	the end, remove set_value_lazy there.
	* valarith.c (value_subscripted_rvalue): Use allocate_value_lazy
	instead of allocate_value and set_value_lazy when possible.
	* valops.c (value_fetch_lazy): Do nop for value_optimized_out VAL.
	* value.c (allocate_computed_value): Use allocate_value_lazy instead
	of allocate_value and set_value_lazy.
	(value_from_contents_and_address): Use allocate_value_lazy instead of
	allocate_value and set_value_lazy when possible.
@
text
@d3100 1
a3100 1
  if (TYPE_FIELD_ARTIFICIAL (t1, 0))
@


1.264
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* ui-file.c: Comment cleanup, mostly periods and spaces.
	* ui-file.h: Ditto.
	* ui-out.c: Ditto.
	* ui-out.h: Ditto.
	* utils.c: Ditto.
	* v850-tdep.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* value.h: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vax-tdep.c: Ditto.
	* vec.c: Ditto.
	* vec.h: Ditto.
	* version.h: Ditto.
	* windows-nat.c: Ditto.
	* windows-tdep.c: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xml-support.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* xtensa-tdep.c: Ditto.
	* xtensa-tdep.h: Ditto.
@
text
@d1107 2
@


1.263
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Internationalization.
	* c-lang.c: Ditto.
	* charset.c: Ditto.
	* fork-child.c: Ditto.
	* nto-procfs.c: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* procfs.c: Ditto.
	* remote-mips.c: Ditto.
	* remote.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* target.c: Ditto.
	* valops.c: Ditto.
	* value.c: Ditto.
	* xml-support.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
@
text
@d371 1
a371 1
         we generate value of the given reference. Nothing wrong with 
d1423 1
a1423 1
     Lazy evaluation pays off here. */
d1531 1
a1531 2
   lost because of the coercion to pointer type.
 */
d1595 1
a1595 1
  /* Get target memory address */
d1669 1
a1669 1
	/* Retrieve the enclosing object pointed to */
d1893 1
a1893 1
   baseclasses.  Look for a field NAME in ARG1. Adjust the address of
d2008 1
a2008 1
	     by the user program. Make sure that it still points to a
d2053 1
a2053 1
   baseclasses.  Look for a field NAME in ARG1. Adjust the address of
d2075 1
a2075 1
      /* FIXME!  May need to check for ARM demangling here */
d2134 1
a2134 1
	     clobbered by the user program. Make sure that it
d2183 1
a2183 1
   an appropriate method. Also, handle derived types.
d2288 1
a2288 2
   BOFFSET is the offset of the base subobject where the method is found.
*/
d2359 1
a2359 2
   BOFFSET is the offset of the base subobject which defines the method. 
*/
d2402 1
a2402 1
       functions. In this case the first argument ARGTYPES
d2429 1
a2429 2
   resolution is permitted.
*/
d2769 1
a2769 1
  /* First, see if we have a deeper namespace we can search in.  
d3102 1
a3102 1
     in T1. */
d3110 1
a3110 1
  /* Now compare parameters */
d3463 1
a3463 1
  /* Check if object is in memory */
@


1.262
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d1108 1
a1108 1
    internal_error (__FILE__, __LINE__, "Unexpected lazy value type.");
@


1.261
log
@run copyright.sh for 2011.
@
text
@d125 2
a126 2
  fprintf_filtered (file, _("\
Overload resolution in evaluating C++ functions is %s.\n"),
d178 2
a179 1
	    error (_("evaluation of this expression requires the target program to be active"));
d181 3
a183 1
	    error (_("evaluation of this expression requires the program to have a function \"%s\"."), name);
d205 2
a206 1
	error (_("No memory available to program now: you need to start the target first"));
d326 2
a327 2
      gdb_assert (TYPE_CODE (check_typedef (value_type (v2))) == TYPE_CODE_STRUCT
		  && !!"Why did coercion fail?");
d413 2
a414 1
	    warning (_("array element type size does not divide object size in cast"));
d766 2
a767 1
	    error (_("Argument to dynamic_cast does not have pointer to class type"));
d1067 3
a1069 2
	  fprintf_unfiltered (gdb_stdlog, "\
{ value_fetch_lazy (frame=%d,regnum=%d(%s),...) ",
d1190 2
a1191 1
	      error (_("Can't handle bitfields which don't fit in a %d bit word."),
d1250 2
a1251 1
		  error (_("Can't handle bitfields which don't fit in a %d bit word."),
d1491 3
a1493 3
/* Make sure that VAL lives in target memory if it's supposed to.  For instance,
   strings are constructed as character arrays in GDB's storage, and this
   function copies them to the target.  */
d1850 2
a1851 1
	  && (TYPE_CODE (check_typedef (TYPE_TARGET_TYPE (tt1))) == TYPE_CODE (tt2)))
d1924 2
a1925 1
		  error (_("field %s is nonexistent or has been optimized out"),
d2094 2
a2095 1
	    error (_("cannot resolve overloaded method `%s': no arguments supplied"), name);
d2217 2
a2218 1
    error (_("Attempt to extract a component of a value that is not a %s."), err);
d2256 2
a2257 1
      error (_("One of the arguments you tried to pass to %s could not be converted to what the function wants."), name);
d2385 2
a2386 1
    error (_("Attempt to extract a component of a value that is not a struct or union"));
d2542 2
a2543 1
              && TYPE_CODE (check_typedef (SYMBOL_TYPE (fsym))) == TYPE_CODE_FUNC)
d2613 2
a2614 1
	    error (_("Internal error: incompatible overload candidates proposed"));
d2652 2
a2653 1
	warning (_("Using non-standard conversion to match method %s%s%s to supplied arguments"),
d2658 2
a2659 1
	warning (_("Using non-standard conversion to match function %s to supplied arguments"),
d2939 1
a2939 1
			      "Overloaded method instance %s, # of parms %d\n", 
d2943 2
a2944 1
			      "Overloaded function instance %s # of parms %d\n",
d2951 2
a2952 2
	  fprintf_filtered (gdb_stderr,
			    "Overload resolution champion is %d, ambiguous? %d\n", 
d3160 2
a3161 1
    error (_("Internal error: non-aggregate type to value_struct_elt_for_reference"));
d3229 2
a3230 1
		      || compare_parameters (TYPE_FN_FIELD_TYPE (f, j), intype, 1))
d3235 2
a3236 1
		error (_("no member function matches that type instantiation"));
d3257 2
a3258 1
		    error (_("non-unique member `%s' requires type instantiation"), name);
d3470 2
a3471 1
      warning (_("Couldn't retrieve complete object of RTTI type %s; object may be in register(s)."), 
d3536 1
a3536 1
	error (_("current stack frame does not contain a variable named `%s'"), 
@


1.260
log
@gdb:
	* valops.c (value_one): Use get_array_bounds to compute the number
	of array elements instead of dividing the length of the array by the
	length of the element types.
	* valarith.c (value_complement, value_neg): Likewise.
@
text
@d5 1
a5 1
   2008, 2009, 2010 Free Software Foundation, Inc.
@


1.259
log
@	* valops.c (value_assign): Returned value is never lazy.  If a
	C++ class type is returned, fix incorrect enclosing type / embedded
	offset.  If internal variable is returned, allocate new internalvar
	value using value_of_internalvar.

	* NEWS: Document changes in behavior of "print x = 0" and similar
	expressions.
@
text
@d880 2
a881 1
      int i, n = TYPE_LENGTH (type1) / TYPE_LENGTH (eltype);
d884 3
d888 1
a888 1
      for (i = 0; i < n; i++)
@


1.258
log
@gdb
	* opencl-lang.c (lval_func_check_synthetic_pointer): New
	function.
	* value.h (struct lval_funcs) <indirect, check_synthetic_pointer>:
	New fields.
	(value_bits_synthetic_pointer): Declare.
	* value.c (value_bits_synthetic_pointer): New function.
	* valprint.c (valprint_check_validity): Handle synthetic
	pointers.
	* valops.c (value_ind): Use new 'indirect' lval_funcs method.
	* valarith.c (value_ptradd): Use set_value_component_location.
	* p-valprint.c (pascal_object_print_value_fields): Handle
	synthetic pointers.
	* jv-valprint.c (java_print_value_fields): Handle synthetic
	pointers.
	* dwarf2read.c (dwarf_stack_op_name): Add
	DW_OP_GNU_implicit_pointer.
	(dwarf2_fetch_die_location_block): Add get_frame_pc, baton
	arguments.  Handle location lists.
	(fill_in_loclist_baton): New function.
	(dwarf2_symbol_mark_computed): Use it.
	* dwarf2loc.h (dwarf2_find_location_expression): Declare.
	(dwarf2_fetch_die_location_block): Add get_frame_pc, baton
	arguments.
	* dwarf2loc.c (dwarf2_find_location_expression): Rename from
	find_location_expression.  No longer static.  Update all callers.
	(dwarf_expr_frame_pc): New function.
	(per_cu_dwarf_call): Add get_frame_pc, baton arguments.  Update
	all callers.
	(struct piece_closure) <per_cu>: New field.
	(allocate_piece_closure): Add per_cu argument.
	(read_pieced_value): Handle DWARF_VALUE_IMPLICIT_POINTER.
	(check_pieced_value_bits): Remove validity argument, add check_for
	argument.  Handle DWARF_VALUE_IMPLICIT_POINTER.
	(check_pieced_value_validity, check_pieced_value_invalid):
	Update.
	(check_pieced_synthetic_pointer): New function.
	(get_frame_address_in_block_wrapper): New function.
	(indirect_pieced_value): New function.
	(pieced_value_funcs): Update.
	(invalid_synthetic_pointer): New function.
	(dwarf2_evaluate_loc_desc_full): Rename from
	dwarf2_evaluate_loc_desc.  Add byte_offset argument.
	(dwarf2_evaluate_loc_desc): Rewrite.
	(dwarf2_loc_desc_needs_frame): Set new field on context.
	(get_ax_pc): New function.
	(disassemble_dwarf_expression): Handle
	DW_OP_GNU_implicit_pointer.
	* dwarf2expr.h (enum dwarf_value_location)
	<DWARF_VALUE_IMPLICIT_POINTER>: New constant.
	(struct dwarf_expr_context) <get_frame_pc>: New field.
	(struct dwarf_expr_piece) <v.ptr>: New field.
	* dwarf2expr.c (add_piece): Handle DWARF_VALUE_IMPLICIT_POINTER.
	(execute_stack_op): Handle DW_OP_GNU_implicit_pointer.
	* dwarf2-frame.c (no_get_frame_pc): New function.
	(execute_stack_op): Set new field on context.
	* cp-valprint.c (cp_print_value_fields): Handle synthetic
	pointers.
gdb/testsuite
	* gdb.dwarf2/implptr.exp: New file.
	* gdb.dwarf2/implptr.c: New file.
	* gdb.dwarf2/implptr.S: New file.
@
text
@d1141 2
a1142 5
      val = value_copy (fromval);
      set_value_enclosing_type (val, value_enclosing_type (fromval));
      set_value_embedded_offset (val, value_embedded_offset (fromval));
      set_value_pointed_to_offset (val, value_pointed_to_offset (fromval));
      return val;
d1328 3
d1332 1
d1335 10
a1344 4
  deprecated_set_value_type (val, type);
  set_value_enclosing_type (val, value_enclosing_type (fromval));
  set_value_embedded_offset (val, value_embedded_offset (fromval));
  set_value_pointed_to_offset (val, value_pointed_to_offset (fromval));
@


1.257
log
@	* value.c (set_value_enclosing_type): Renamed from
	value_change_enclosing_type.  All callers updated.
	* value.h (set_value_enclosing_type): Update.
	* valops.c (value_full_object): Always return a copy if we need to
	make changes to the input value.
@
text
@d1621 13
@


1.256
log
@Create and use struct rank.

2010-11-04  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdbtypes.h: Create struct rank.
	Convert all 'BADNESS' macros to const struct rank declarations.
	(sum_ranks): New function.
	(compare_ranks): New function.
	* valops.c (find_oload_champ): Updated.
	(classify_oload_match): Use compare_ranks.
	Improved comments.
	(compare_parameters): Use compare_ranks.
	* gdbtypes.c: Initialize 'BADNESS' constants.
	(sum_ranks): New function.
	(compare_ranks): New function.
	(compare_badness): Use compare_ranks.
	(rank_function): Use global constants instead of literals.
	(rank_one_type): Ditto.
	Return struct rank.
	Use sum_ranks.
@
text
@d338 1
a338 1
  arg2 = value_change_enclosing_type (arg2, type);
d572 1
a572 1
      arg2 = value_change_enclosing_type (arg2, type);
d1142 1
a1142 2
      val = value_change_enclosing_type (val, 
					 value_enclosing_type (fromval));
d1144 1
a1144 2
      set_value_pointed_to_offset (val, 
				   value_pointed_to_offset (fromval));
d1335 1
a1335 2
  val = value_change_enclosing_type (val, 
				     value_enclosing_type (fromval));
d1583 2
a1584 1
  arg2 = value_change_enclosing_type (arg2, lookup_pointer_type (value_enclosing_type (arg1)));
d1645 1
a1645 1
      arg2 = value_change_enclosing_type (arg2, enc_type);
d3414 2
a3415 1
      argp = value_change_enclosing_type (argp, real_type);
@


1.255
log
@gdb:
	* dwarf2read.c (read_array_type): Read the DW_AT_byte_size from the
	DIE and set the length of the type.
	* gdbtypes.h (get_array_bounds): Move here from valprint.h.
	* gdbtypes.c (get_array_bounds): Move here from valprint.c and
	return 0 if the corresponding bounds of the type are undefined.
	* valprint.h (get_array_bounds): Move declaration to gdbtypes.h.
	* valprint.c (get_array_bounds): Move implementation to gdbtypes.c.
	(val_print_array_elements): Use get_array_bounds to compute the number
	of array elements instead of dividing the length of the array by the
	length of the element types.
	* valarith.c (vector_binop): Likewise.
	* valops.c (value_cast): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* c-typeprint.c (c_type_print_varspec_suffix): Likewise.

gdb/testsuite:
	* gdb.base/gnu_vector.exp: Adjust expect messages.
@
text
@d2908 1
a2908 1
			      jj, bv->rank[jj]);
d2942 4
a2945 1
      if (oload_champ_bv->rank[ix] >= 100)
d2947 4
a2950 1
      else if (oload_champ_bv->rank[ix] >= 10)
d3086 3
a3088 3
	  if (rank_one_type (TYPE_FIELD_TYPE (t1, start + i),
			      TYPE_FIELD_TYPE (t2, i))
	      != 0)
@


1.254
log
@gdb:
	* valarith.c (value_pos, value_neg, value_complement): Handle
	vector types.
	* valops.c (value_one): Likewise.

gdb/testsuite:
	* gdb.base/gnu_vector.exp: Add unary operator tests.
@
text
@d547 5
a551 1
      int i, n;
a555 1
      n = TYPE_LENGTH (type) / TYPE_LENGTH (eltype);
d557 1
a557 1
      for (i = 0; i < n; i++)
@


1.253
log
@Support overloading of 'operator->'.

2010-10-19  Sami Wagiaalla  <swagiaal@@redhat.com>

	 PR C++/11500:
	* valarith.c (value_x_unop): Handle STRUCTOP_PTR.
	* eval.c (evaluate_subexp_standard): Check for overload of
	'operator->'.
	* valarith.c (value_x_binop): Throw NOT_FOUND_ERROR.
	(value_x_unop): Ditto.
	* valops.c: Include "exceptions.h".
	(find_overload_match): Throw NOT_FOUND_ERROR.
	(value_struct_elt): Ditto.

2010-10-19  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/smartp.exp: New test.
	* gdb.cp/smartp.cc : New test.
@
text
@d874 14
@


1.252
log
@gdb:
	* valops.c (value_cast): Handle vector types.
	* valarith.c (value_binop): Widen scalar to vector if appropriate.
gdb/testsuite:
	* gdb.base/gnu_vector.c (ia, ib, fa, fb): New variables.
	* gdb.base/gnu_vector.exp: Add tests for scalar to vector widening.
@
text
@d49 1
d2219 2
a2220 1
    error (_("Structure has no component named %s."), name);
d2538 3
a2540 1
    error (_("No symbol \"%s\" in current context."), name);
@


1.251
log
@Fix find_oload_champ_namespace_loop memory leak.

2010-09-24  Sami Wagiaalla  <swagiaal@@redhat.com>

	* valops.c (find_oload_champ_namespace_loop): replace incorrect
	discard_cleanups do_cleanups.
@
text
@d424 2
a425 1
      && TYPE_CODE (type2) == TYPE_CODE_ARRAY)
d541 20
@


1.250
log
@Fix PR 12028: "GDB crashes on a double free during overload resolution "

2010-09-22  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR C++/12028
	* valops.c (find_oload_champ_namespace_loop): removed incorrect
	'old_cleanups' reassignment.

2010-09-22  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/pr12028.cc: New.
	* gdb.cp/pr12028.exp: New.
@
text
@d2763 1
a2763 1
      discard_cleanups (old_cleanups);
@


1.249
log
@gdb/ChangeLog:* valops.c (value_assign): Do not call to value_coerce_to_target.(value_must_coerce_to_target): Return 0 in case of TYPE_VECTOR.gdb/testsuite/ChangeLog:* gdb.arch/altivec-abi.exp: New tests.
@
text
@d2716 1
a2716 1
  old_cleanups = make_cleanup (xfree, *oload_champ_bv);
@


1.248
log
@gdb/
	* cp-namespace.c (cp_lookup_nested_type): New variable
	concatenated_name.  Turn the current return condition into a reverse
	one.  Call also lookup_static_symbol_aux on the constructed qualified
	name.
	* symtab.c (lookup_symbol_aux): Move variable objfile and searching in
	other files into a called ...
	(lookup_static_symbol_aux): ... new function here.
	* symtab.h (lookup_static_symbol_aux): New prototype.
	* valops.c (value_maybe_namespace_elt): Call also
	lookup_static_symbol_aux if we failed otherwise.

gdb/testsuite/
	* gdb.cp/namespace.exp (whatis C::cOtherFileType)
	(whatis ::C::cOtherFileType, whatis C::cOtherFileVar)
	(whatis ::C::cOtherFileVar, print C::cOtherFileVar)
	(print ::C::cOtherFileVar)
	(whatis C::OtherFileClass::cOtherFileClassType)
	(whatis ::C::OtherFileClass::cOtherFileClassType)
	(print C::OtherFileClass::cOtherFileClassVar)
	(print ::cOtherFileClassVar)
	(print ::C::OtherFileClass::cOtherFileClassVar): New tests.
	(ptype OtherFileClass, ptype ::C::OtherFileClass): Permit arbitrary
	trailing content.
	* gdb.cp/namespace1.cc (C::OtherFileClass::cOtherFileClassType)
	(C::OtherFileClass::cOtherFileClassVar)
	(C::OtherFileClass::cOtherFileClassVar_use, C::cOtherFileType)
	(C::cOtherFileVar, C::cOtherFileVar_use): New.
@
text
@d1082 1
a1082 4
    {
      toval = value_coerce_to_target (toval);
      fromval = value_cast (type, fromval);
    }
d1427 1
@


1.248.2.1
log
@Fix PR 12028: "GDB crashes on a double free during overload resolution "

2010-09-23  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR C++/12028
	* valops.c (find_oload_champ_namespace_loop): removed incorrect
	'old_cleanups' reassignment.

2010-09-23  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/pr12028.cc: New.
	* gdb.cp/pr12028.exp: New.
@
text
@d2718 1
a2718 1
  make_cleanup (xfree, *oload_champ_bv);
@


1.247
log
@	* valops.c (search_struct_field): Fix typo in error message.
@
text
@d3287 10
a3296 2
				    get_selected_block (0), 
				    VAR_DOMAIN);
@


1.246
log
@gdb
	PR gdb/9977, PR exp/11636:
	* value.h (value_offset): Update.
	(struct lval_funcs) <check_validity>: New field.
	<copy_closure>: Make argument const.
	(value_computed_closure): Update.
	(value_contents_for_printing): Declare.
	(value_bits_valid): Likewise.
	(val_print): Likewise.
	(set_value_component_location): Update.
	(value_entirely_optimized_out): Declare.
	* value.c (value_offset): Argument now const.
	(require_not_optimized_out): New function.
	(value_contents_for_printing): New function.
	(value_contents_all): Call require_not_optimized_out.
	(value_contents): Likewise.
	(value_bits_valid): New function.
	(value_computed_closure): Argument now const.
	(set_value_component_location): Make 'whole' argument const.
	(value_entirely_optimized_out): New function.
	(value_bitsize): Argument now 'const'.
	(value_bitpos): Likewise.
	(value_type): Likewise.
	* valprint.h (val_print_array_elements): Update.
	* valprint.c (val_print): Add 'val' argument.  Use
	valprint_check_validity.
	(valprint_check_validity): New function.
	(value_check_printable): Use value_entirely_optimized_out.
	(common_val_print): Update.
	(value_print): Likewise.
	(val_print_array_elements): Add 'val' argument.
	* valops.c (value_fetch_lazy): Use value_contents_for_printing,
	value_bits_valid.  Reinit frame cache for lval_computed.
	* sh64-tdep.c (sh64_do_register): Update.
	* scm-valprint.c (scm_val_print): Add 'val' argument.
	* scm-lang.h (scm_val_print): Update.
	* python/python.h (apply_val_pretty_printer): Update.
	* python/py-prettyprint.c (apply_val_pretty_printer): Add 'val'
	argument.  Call set_value_component_location.
	* printcmd.c (print_scalar_formatted): Update.
	* p-valprint.c (pascal_val_print): Add 'val' argument.
	(pascal_object_print_value_fields): Likewise.
	(pascal_object_print_value): Likewise.
	(pascal_object_print_static_field): Update.
	* p-lang.h (pascal_val_print): Update.
	(pascal_object_print_value_fields): Update.
	* mt-tdep.c (mt_registers_info): Update.
	* mi/mi-main.c (get_register): Update.
	(mi_cmd_data_evaluate_expression): Use common_val_print.
	* m2-valprint.c (m2_print_array_contents): Add 'val' argument.
	(m2_print_unbounded_array): Likewise.
	(m2_val_print): Likewise.
	* m2-lang.h (m2_val_print): Update.
	* language.h (struct language_defn) <la_val_print>: Add 'val'
	argument.
	(LA_VAL_PRINT): Likewise.
	* language.c (unk_lang_val_print): Add 'val' argument.
	* jv-valprint.c (java_print_value_fields): Add 'val' argument.
	(java_val_print): Likewise.
	* jv-lang.h (java_val_print): Add 'val' argument.
	* infcmd.c (default_print_registers_info): Update.
	* f-valprint.c (f77_print_array_1): Add 'val' argument.
	(f77_print_array): Likewise.
	(f_val_print): Likewise.
	* f-lang.h (f_val_print): Add 'val' argument.
	* dwarf2loc.c (read_pieced_value): Use value_bitsize and
	value_bitpos.
	<DWARF_VALUE_OPTIMIZED_OUT>: Don't print warning.  Call
	set_value_optimized_out.
	(write_pieced_value): Use value_bitsize and value_bitpos.
	<default>: Don't exit loop.
	(check_pieced_value_validity): New function.
	(pieced_value_funcs): Reference check_pieced_value_validity,
	check_pieced_value_invalid.
	(copy_pieced_value_closure): Update.
	(check_pieced_value_bits): New function.
	(check_pieced_value_invalid): New function.
	* d-valprint.c (dynamic_array_type): Add 'val' argument.
	(d_val_print): Likewise.
	* d-lang.h (d_val_print): Update.
	* cp-valprint.c (cp_print_value_fields): Add 'val' argument.
	(cp_print_value_fields_rtti): Likewise.
	(cp_print_value): Likewise.
	(cp_print_static_field): Update.
	* c-valprint.c (c_val_print): Add 'val' argument.
	(c_value_print): Update.
	* c-lang.h (c_val_print): Update.
	(cp_print_value_fields): Likewise.
	(cp_print_value_fields_rtti): Likewise.
	* ada-valprint.c (struct ada_val_print_args): Remove.
	(val_print_packed_array_elements): Add 'val' argument.
	(ada_val_print): Likewise.  Rewrite.
	(ada_val_print_stub): Remove.
	(ada_val_print_array): Add 'val' argument.
	(ada_val_print_1): Likewise.
	(print_variant_part): Likewise.
	(ada_value_print): Update.
	(print_record): Add 'val' argument.
	(print_field_values): Likewise.
	* ada-lang.h (ada_val_print): Update.
gdb/testsuite
	PR gdb/9977, PR exp/11636::
	* gdb.dwarf2/pieces.exp (pieces_test_f3): Remove kfail.
	(pieces_test_f6): Update expected output.
@
text
@d1855 1
a1855 1
		  error (_("field %s is nonexistent or has been optimised out"),
@


1.245
log
@Test and support all cpp operator types.

2010-06-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	* value.h: Created oload_search_type enum.
	(find_overload_match): Use oload_search_type enum.
	* valops.c (find_overload_match): Support combined member and
	non-member search.
	* eval.c (evaluate_subexp_standard): Calls to
	find_overload_match now use oload_search_type enum.
	(oload_method_static): Verify index is a proper value.
	* valarith.c (value_user_defined_cpp_op): Search for and handle
	both member and non-member operators.
	(value_user_defined_cpp_op): New function.
	(value_user_defined_op): New function.
	(value_x_unop): Use value_user_defined_op.
	(value_x_binop): Ditto.
	* cp-support.c (make_symbol_overload_list_using): Added block
	iteration.
	Add check for namespace aliases and imported declarations.

2010-06-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/koenig.exp: Test for ADL operators.
	* gdb.cp/koenig.cc: Added ADL operators.
	* gdb.cp/operator.exp: New test.
	* gdb.cp/operator.cc: New test.
@
text
@d944 2
a945 1
					 value_contents (parent) + offset,
d950 5
d1255 1
@


1.244
log
@2010-05-17  Michael Snyder  <msnyder@@vmware.com>

	* valarith.c: White space.
	* valops.c: White space.
	* valprint.c: White space.
	* value.c: White space.
	* varobj.c: White space.
	* xcoffread.c: White space.
	* xml-support.c: White space.
	* xml-tdesc.c: White space.
@
text
@d2318 10
d2355 2
a2356 2
		     const char *name, int method, int lax, 
		     struct value **objp, struct symbol *fsym,
d2362 3
a2364 1
  int oload_champ;
d2366 3
a2368 1
  struct badness_vector *oload_champ_bv = NULL;
d2384 2
d2388 1
a2388 1
  if (method)
d2411 1
d2415 3
a2417 1
      if (!fns_ptr || !num_fns)
d2425 15
a2439 4
      gdb_assert (TYPE_DOMAIN_TYPE (fns_ptr[0].type) != NULL);
      oload_champ = find_oload_champ (arg_types, nargs, method, 
				      num_fns, fns_ptr, 
				      oload_syms, &oload_champ_bv);
d2441 2
a2442 1
  else
d2446 6
d2494 10
d2505 1
a2505 8
      make_cleanup (xfree, oload_champ_bv);

      oload_champ = find_oload_champ_namespace (arg_types, nargs,
						func_name,
						qualified_name,
						&oload_syms,
						&oload_champ_bv,
						no_adl);
d2509 1
a2509 1
  if (oload_champ == -1)
d2512 39
a2550 5
  /* Check how bad the best match is.  */
  match_quality =
    classify_oload_match (oload_champ_bv, nargs,
			  oload_method_static (method, fns_ptr,
					       oload_champ));
d2554 1
a2554 1
      if (method)
d2565 1
a2565 1
      if (method)
d2575 4
a2578 1
  if (method)
d2580 2
a2581 4
      if (staticp != NULL)
	*staticp = oload_method_static (method, fns_ptr, oload_champ);
      if (TYPE_FN_FIELD_VIRTUAL_P (fns_ptr, oload_champ))
	*valp = value_virtual_fn_field (&temp, fns_ptr, oload_champ, 
d2584 1
a2584 1
	*valp = value_fn_field (&temp, fns_ptr, oload_champ, 
d2588 1
a2588 3
    {
      *symp = oload_syms[oload_champ];
    }
d2877 2
a2878 1
  if (method && TYPE_FN_FIELD_STATIC_P (fns_ptr, index))
@


1.243
log
@	* valops.c (find_overload_match): Add missing i18n markup.
@
text
@d137 1
d156 1
d290 1
d328 1
d371 1
d397 1
d403 1
d454 1
d515 1
a516 1
      LONGEST longest = value_as_long (arg2);
d529 1
d637 1
d823 1
a824 1

d840 1
d948 1
d1125 1
a1126 1

d1263 1
d1371 1
d1513 1
a1514 1
  struct type *type = check_typedef (value_type (arg1));
d1556 1
a1557 1
  struct type *type = check_typedef (value_type (arg1));
d1582 1
d1722 1
d1843 1
d1866 1
d1998 1
d2013 1
a2014 1

d2063 1
d2227 1
d2248 1
d2521 1
d2871 1
d2956 1
d3096 1
d3127 1
d3423 1
d3429 1
@


1.242
log
@2010-05-07  Michael Snyder  <msnyder@@vmware.com>

	* valops.c (value_cast_pointers): Restore unused variable 'type1',
	and use it to compute variable 't1'.
@
text
@d2448 1
a2448 1
    error ("No symbol \"%s\" in current context.", name);
@


1.241
log
@Add ADL support

2010-05-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR C++/7943:
	* valops.c (find_overload_match): Handle fsym == NULL case.
	Add int no_adl argument.
	(find_oload_champ_namespace_loop): Call make_symbol_overload_list_adl
	when appropriate.
	Add int no_adl argument.
	(find_oload_champ_namespace): 	Add int no_adl argument.
	* parse.c (operator_length_standard): Return length for OP_ADL_FUNC
	expression.
	* expprint.c (op_name_standard): Added string for OP_ADL_FUNC case.
	* eval.c (evaluate_subexp_standard): Added OP_ADL_FUNC case.
	Evaluate arguments and use them to perform ADL lookup.
	Pass no_adl argument to find_overload_match.
	Disable adl lookup when evaluating a fully qualified OP_FUNCALL.
	* cp-support.h: Added prototype for
	make_symbol_overload_list_namespace.
	* cp-support.c (make_symbol_overload_list_namespace): New function.
	(make_symbol_overload_list_adl_namespace): New function.
	(make_symbol_overload_list_adl): New function.
	(make_symbol_overload_list_using): Moved code to add function to
	overload set to make_symbol_overload_list_namespace.
	* c-exp.y: create UNKNOWN_CPP_NAME token.
	Add parse rule for ADL functions.
	(classify_name): Recognize an UNKNOWN_CPP_NAME.

2010-05-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/koenig.exp: New test.
	* gdb.cp/koenig.cc: New test program.
@
text
@d303 1
d305 1
a305 1
  struct type *t1 = check_typedef (TYPE_TARGET_TYPE (type));
@


1.240
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* eval.c (evaluate_subexp_standard): Delete unused variable.
	* valops.c (value_cast_pointers): Delete unused variable.
	(value_dynamic_cast): Delete unused variable.
	(value_array): Delete unused variable.
	(find_overload_match): Delete unused variable.
	* valarith.c (value_subscript): Delete unused variable.
	(value_binop): Delete unused variable.
	* valprint.c (_initialize_valprint): Delete unused variable.
	* printcmd.c (print_command_1): Delete unused variable.
	(address_info): Delete unused variable.
	(printf_command): Delete unused variable.
@
text
@d66 2
a67 1
				       struct badness_vector **);
d73 2
a74 1
				     struct badness_vector **, int *);
d2311 4
d2325 1
a2325 1
		     int *staticp)
d2341 2
a2342 1
  struct cleanup *old_cleanups = NULL;
d2345 1
a2345 1
  char *func_name = NULL;
d2390 1
a2390 1
      const char *qualified_name = SYMBOL_NATURAL_NAME (fsym);
d2392 31
a2422 16
      /* If we have a function with a C++ name, try to extract just
	 the function part.  Do not try this for non-functions (e.g.
	 function pointers).  */
      if (qualified_name
	  && TYPE_CODE (check_typedef (SYMBOL_TYPE (fsym))) == TYPE_CODE_FUNC)
	{
	  func_name = cp_func_name (qualified_name);

	  /* If cp_func_name did not remove anything, the name of the
	     symbol did not include scope or argument types - it was
	     probably a C-style function.  */
	  if (func_name && strcmp (func_name, qualified_name) == 0)
	    {
	      xfree (func_name);
	      func_name = NULL;
	    }
a2433 1
      old_cleanups = make_cleanup (xfree, func_name);
d2441 2
a2442 1
						&oload_champ_bv);
d2445 4
a2449 1

d2506 2
a2507 2
  if (old_cleanups != NULL)
    do_cleanups (old_cleanups);
d2525 2
a2526 1
   *OLOAD_CHAMP_BV.  */
d2533 2
a2534 1
			    struct badness_vector **oload_champ_bv)
d2542 2
a2543 1
				   &oload_champ);
d2551 2
a2552 1
   if it isn't.
d2564 2
a2565 1
				 int *oload_champ)
d2599 1
a2599 1
					   oload_champ))
d2620 6
a2657 1
      gdb_assert (new_oload_champ != -1);
@


1.239
log
@
    2010-03-15  Sami Wagiaalla  <swagiaal@@redhat.com>

        PR c++/7936:
        * cp-support.h: Added char *declaration element to using_direct
        data struct.
        (cp_add_using): Added char *declaration argument.
        (cp_add_using_directive): Ditto.
        (cp_lookup_symbol_imports): made extern.
        * cp-namespace.c: Updated with the above changes.
        * dwarf2read.c (read_import_statement): Ditto.
        (read_namespace): Ditto.
        (read_import_statement): Support import declarations.
        * cp-namespace.c (cp_lookup_symbol_imports): Check for imported
        declarations.
        Added support for 'declaration_only' search.
        (cp_lookup_symbol_namespace): Attempt to search for the name as
        is before consideration of imports.
        * symtab.c (lookup_symbol_aux_local): Added a 'declaration_only'
        search at every block level search.
        Now takes language argument.
        (lookup_symbol_aux): Updated.

    2010-03-15  Sami Wagiaalla  <swagiaal@@redhat.com>

        * gdb.cp/shadow.exp: Removed kfail; test has been fix.
        * gdb.cp/nsusing.exp: Ditto.
@
text
@a300 1
  struct type *type1 = check_typedef (type);
d697 1
a697 1
  int unambiguous = 0, full, top, using_enc;
a1615 1
  CORE_ADDR addr;
a2334 2
  int ix;
  int static_offset;
@


1.238
log
@dwarf2_physname patchset:

	Based on work from Daniel Jacobowitz  <dan@@codesourcery.com>
	* c-typeprint.c (cp_type_print_method_args): For non-static methods,
	print out const or volatile qualifiers, too.
	(c_type_print_args): Add parameters show_artificial and language.
	Skip artificial parameters when requested.
	Use the appropriate language printer.
	(c_type_print_varspec): Tell c_type_print_args to skip artificial
	parameters and pass language_c.
	* dwarf2read.c (die_list): New file global.
	(struct partial_die_info): Update comments for name field.
	(pdi_needs_namespace): Renamed to ...
	(die_needs_namespace): ... this. Rewrite.
	(dwarf2_linkage_name): Remove.
	(add_partial_symbol): Do not predicate the call to
	partial_die_full_name based on pdi_needs_namespace.
	Remove call to cp_check_possible_namespace_symbols and associated
	outdated comments.
	(guess_structure_name): Do not inspect child subprogram DIEs.
	(dwarf2_fullname): Update comments.
	Use die_needs_namespace to assist in computing the name.
	(read_func_scope): Use dwarf2_name to get the DIE's name.
	Use dwarf2_physname to get the "linkage name" of the DIE.
	(dwarf2_add_member_field): Use dwarf2_physname instead of
	dwarf2_linkage_name.
	(read_structure_type): For structs and classes, set TYPE_NAME, too.
	(determine_class): Remove.
	(read_partial_die): Ignore DW_AT_MIPS_linkage_name for all languages
	except Ada.
	(new_symbol): Unconditionally call dwarf2_name.
	Compute the "linkage name" using dwarf2_physname.
	Use dwarf2_name instead of dwarf2_full_name for enumerator DIEs.
	When determining to scan for anonymous C++ namespaces, ignore
	the linkage name.
	(dwarf2_physname): New function.
	(dwarf2_full_name): Move content to new function and call
	that.
	(dwarf2_compute_name): "New" function.
	(_initialize_dwarf2_read): Initialize die_list.
	* gnu-v3-eabi.c (gnu_v3_find_method_in): Remove unused variable
	physname.
	(gnu_v3_print_method_ptr): Use the physname for virtual methods
	without a demangled name.
	Print out type information for non-virtual methods.
        * linespec.c (decode_line_1): Force ANY string using "::" (or
	"." for java) to use decode_compound, and clean up any stray quoting.
        If we found a file symtab, re-evaluate whether the remainder is_quoted.
        (decode_compound): Stop consuming at an open parenthesis.
        Keep template parameters.
        Keep any overload information.
        Keep keywords like "const".
        Remove paren_pointer.
        Move is_quoted check from set_flags to here.
        Remove #if 0 code from 2000. Ten years is long enough.
        (find_method): Before comparing symbol names, canonicalize the string
        from the user.
        If a specific overload is requested, find it. Otherwise throw an error.
	(find_method_overload_end): New function.
	(set_flags): Remove.
        (decode_compound): Assume that parentheses are matched.
        It's a lot easier.
	* symtab.c (symbol_find_demangled_name): Add DMGL_VERBOSE flag
	to cplus_demangle.
	* linespec.c (decode_line_1): Keep important keywords like
	"const" and "volatile".
	* symtab.h (SYMBOL_CPLUS_DEMANGLED_NAME): Remove.
	* typeprint.h (c_type_print_args): Add declaration.
	* ui-file.c (do_ui_file_obsavestring): New function.
	(ui_file_obsavestring): New function.
	* ui-file.h (ui_file_obsavestring): Add declaration.
	* valops.c (find_overload_match): Resolve the object to
	a non-pointer type.
	If the object is a data member, search the object for the member
	and return with staticp set.
	Use SYMBOL_NATURAL_NAME instead of SYMBOL_CPLUS_DEMANGLED_NAME.
	Do not attempt to extract a function name from non-function types.
	If the extracted function name and the original name are the same,
	we don't have a C++ method.

	From Jan Kratochvil  <jan.kratochvil@@redhat.com>:
    	* dwarf2read.c (new_symbol <DW_TAG_enumerator>): Call dwarf2_full_name.

	* ada-lang.c (ada_lookup_symbol): Remove linkage_name parameters
	and arguments from symbol lookups.
	* ax-gdb.c (gen_expr): Likewise.
	* cp-namespace.c (cp_lookup_symbol_nonlocal, lookup_namespace_scope,
	cp_lookup_symbol_namespace, lookup_symbol_file, lookup_nested_type,
	lookup_possible_namespace_symbol): Likewise.
	* cp-support.c (read_in_psymtabs): Likewise.
	* cp-support.h (cp_lookup_symbol_nonlocal): Likewise.
	* language.h (la_lookup_symbol_nonlocal): Likewise.
	* scm-valprint.c (scm_inferior_print): Likewise.
	* solib-darwin.c (darwin_relocate_section_addresses): Likewise.
	* solib-svr.c (elf_lookup_lib): Likewise.
	* solib.c (show_auto_solib_add): Likewise.
	* solist.h (lookup_lib_global, solib_global_lookup): Likewise.
	* symmisc.c (maintenance_check_symtabs): Likewise.
	* symtab.c (lookup_symbol_in_language, lookup_symbol_aux,
	lookup_symbol_aux_local, lookup_symbol_aux_block,
	lookup_symbol_from_objfile, lookup_symbol_aux_symtabs,
	lookup_symbol_aux_psymtabs,basic_lookup_symbol_nonlocal,
	lookup_symbol_static, lookup_symbol_global, symbol_matches_domain,
	basic_lookup_transparent_type, find_main_psymtab,
	lookup_block_symbol): Likewise.
	* symtab.h (basic_lookp_symbol_nonlocal, lookup_symbol_static,
	lookup_symbol_global, lookup_symbol_aux_block,
	lookup_symbol_partial_symbol, lookup_block_symbol,
	lookup_global_symbol, value_maybe_namespace_elt): Likewise.
@
text
@d3146 1
a3146 1
  sym = cp_lookup_symbol_namespace(namespace_name, name,
d3148 1
a3148 1
				    VAR_DOMAIN, 1);
@


1.237
log
@gdb
	PR c++/8017:
	* value.h: Update.
	* valops.c (search_struct_field): Make 'name' const.
	(search_struct_method): Likewise.
	(find_method_list): Make 'method' const.
	(value_struct_elt): Make 'name' and 'err' const.
	(value_find_oload_method_list): Make 'method' const.
	(find_overload_match): Make 'name' const.
	* eval.c (evaluate_subexp_standard): New locals function,
	function_name.
	<OP_FUNCALL>: Handle OP_SCOPE specially.
gdb/testsuite
	PR c++/8017:
	* gdb.cp/overload.exp: Add tests.
	* gdb.cp/overload.cc (struct K): New.
	(namespace N): New.
	(main): Call new functions.
	(K::staticoverload): Define.
@
text
@d2349 5
d2355 13
a2367 5
      /* Hack: evaluate_subexp_standard often passes in a pointer
         value rather than the object itself, so try again.  */
      if ((!obj_type_name || !*obj_type_name) 
	  && (TYPE_CODE (value_type (obj)) == TYPE_CODE_PTR))
	obj_type_name = TYPE_NAME (TYPE_TARGET_TYPE (value_type (obj)));
d2387 19
a2405 1
      const char *qualified_name = SYMBOL_CPLUS_DEMANGLED_NAME (fsym);
d2407 3
a2409 8
      /* If we have a C++ name, try to extract just the function
	 part.  */
      if (qualified_name)
	func_name = cp_func_name (qualified_name);

      /* If there was no C++ name, this must be a C-style function.
	 Just return the same symbol.  Do the same if cp_func_name
	 fails for some reason.  */
d3146 1
a3146 1
  sym = cp_lookup_symbol_namespace (namespace_name, name, NULL,
d3290 1
a3290 1
  sym = lookup_block_symbol (b, name, NULL, VAR_DOMAIN);
@


1.236
log
@gdb
	* valops.c (search_struct_field): Account for
	value_embedded_offset.  Fix check for virtual base past the end of
	the object.  Use value_copy when making a slice of the value.
gdb/testsuite
	* gdb.cp/virtbase.exp: Make test case names unique.
@
text
@d56 1
a56 1
static struct value *search_struct_field (char *, struct value *, 
d59 3
a61 3
static struct value *search_struct_method (char *, struct value **,
				       struct value **,
				       int, int *, struct type *);
d103 1
a103 1
static struct fn_field *find_method_list (struct value **, char *,
d1809 1
a1809 1
search_struct_field (char *name, struct value *arg1, int offset,
d1966 1
a1966 1
search_struct_method (char *name, struct value **arg1p,
d2096 1
a2096 1
		  char *name, int *static_memfuncp, char *err)
d2191 1
a2191 1
find_method_list (struct value **argp, char *method,
d2261 1
a2261 1
value_find_oload_method_list (struct value **argp, char *method, 
d2318 1
a2318 1
		     char *name, int method, int lax, 
@


1.235
log
@gdb
	* valops.c (value_cast_structs): Try downcasting using the RTTI
	type.
gdb/testsuite
	* gdb.cp/virtbase.exp: Add regression tests.
	* gdb.cp/virtbase.cc (RHA, RHB, RHC): New classes.
	(main): Instantiate RHC.
@
text
@d1906 3
a1908 1
				      value_address (arg1) + offset);
d1916 3
a1918 2
	  boffset += offset;
	  if (boffset < 0 || boffset >= TYPE_LENGTH (type))
d1933 3
a1935 12
	      if (VALUE_LVAL (arg1) == lval_memory && value_lazy (arg1))
		v2  = allocate_value_lazy (basetype);
	      else
		{
		  v2  = allocate_value (basetype);
		  memcpy (value_contents_raw (v2),
			  value_contents_raw (arg1) + boffset,
			  TYPE_LENGTH (basetype));
		}
	      set_value_component_location (v2, arg1);
	      VALUE_FRAME_ID (v2) = VALUE_FRAME_ID (arg1);
	      set_value_offset (v2, value_offset (arg1) + boffset);
@


1.234
log
@gdb
	PR c++/11226, PR c++/9629, PR c++/9688, PR c++/8890:
	* valops.c (search_struct_field): Compute nbases after calling
	CHECK_TYPEDEF.
	(check_field): Call CHECK_TYPEDEF.
	* cp-valprint.c (cp_print_value): Pass correct address to
	baseclass_offset.  Fix check for virtual base past the end of the
	object.  Don't offset address passed to cp_print_value_fields or
	apply_val_pretty_printer.
	(cp_print_value_fields): Fix call to val_print.
	(cp_print_value_fields_rtti): New function.
	* c-valprint.c (c_val_print): Use cp_print_value_fields_rtti.
	* p-valprint.c (pascal_object_print_value_fields): Fix call to
	val_print.
	* python/py-prettyprint.c (apply_val_pretty_printer): Add embedded
	offset to address.
	* language.h (struct language_defn) <la_val_print>: Document.
	* c-lang.h (cp_print_value_fields_rtti): Declare.
gdb/testsuite
	PR c++/11226, PR c++/9629, PR c++/9688, PR c++/8890:
	* gdb.cp/virtbase.cc: New file.
	* gdb.cp/virtbase.exp: New file.
	* gdb.cp/userdef.exp: Allow 'struct' or 'class'.
@
text
@d253 1
a253 2
     offset the pointer rather than just change its type.
     FIXME: This fails silently with virtual inheritance.  */
d256 24
@


1.233
log
@ 2010-01-14  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/nsrecurs.exp: New test.
	* gdb.cp/nsrecurs.cc: New test program.
	* gdb.cp/nsstress.exp: New test.
	* gdb.cp/nsstress.cc: New test program.
	* gdb.cp/nsdecl.exp: New test.
	* gdb.cp/nsdecl.cc: New test program.


 2010-01-26  Sami Wagiaalla  <swagiaal@@redhat.com>

	* cp-namespace.c (cp_lookup_symbol_namespace): Added
	search_parent argument.
	(cp_add_using): Initialize 'searched' field.
	(reset_directive_searched): New function.
	* cp-support.h: Add 'searched' field to using_direct struct.
	(cp_lookup_symbol_imports): Ditto.
	* cp-namespace.c (cp_lookup_symbol_imports): Ditto.
	Perform recursive search.
	Implement non parent search.
	* valops.c (value_maybe_namespace_elt): Updated.
@
text
@d1790 1
a1790 1
  int nbases = TYPE_N_BASECLASSES (type);
d1793 1
d2767 3
@


1.232
log
@gdb
	PR c++/9680:
	* c-exp.y (REINTERPRET_CAST, DYNAMIC_CAST, STATIC_CAST)
	(CONST_CAST): New tokens.
	(exp): Add new productions.
	(ident_tokens): Add const_cast, dynamic_cast, static_cast, and
	reinterpret_cast.
	(is_cast_operator): New function.
	(yylex): Handle cast operators specially.
	* eval.c (evaluate_subexp_standard) <UNOP_DYNAMIC_CAST,
	UNOP_REINTERPRET_CAST>: New cases.
	* expprint.c (print_subexp_standard): Likewise.
	(op_name_standard): Likewise.
	(dump_subexp_body_standard): Likewise.
	* parse.c (operator_length_standard): Likewise.
	* expression.h (enum exp_opcode): New constants UNOP_DYNAMIC_CAST,
	UNOP_REINTERPRET_CAST.
	* gdbtypes.c (class_types_same_p): New function.
	(is_ancestor): Use it.
	(is_public_ancestor): New function.
	(is_unique_ancestor_worker): Likewise.
	(is_unique_ancestor): Likewise.
	* gdbtypes.h (class_types_same_p, is_public_ancestor)
	(is_unique_ancestor): Declare.
	* valops.c (value_reinterpret_cast): New function.
	(dynamic_cast_check_1): Likewise.
	(dynamic_cast_check_2): Likewise.
	(value_dynamic_cast): Likewise.
	* value.h (value_reinterpret_cast, value_dynamic_cast): Declare.
gdb/testsuite
	PR c++/9680:
	* gdb.cp/casts.cc: Add new classes and variables.
	* gdb.cp/casts.exp: Test new operators.
@
text
@d3101 1
a3101 1
				    VAR_DOMAIN);
@


1.231
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d530 252
@


1.230
log
@Fix for PR 9399 gdb can't call or print a const function that uses virtual inheritance
@
text
@d5 1
a5 1
   2008, 2009 Free Software Foundation, Inc.
@


1.229
log
@	* valops.c (value_struct_elt_for_reference): Do not rely on
	field order.
@
text
@d235 5
@


1.228
log
@gdb/ChangeLog:

2009-12-02  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* ada-lang.c (ada_value_assign): Use observer_notify_memory_changed.
	* valops.c (value_assign): Likewise.
	* defs.h (deprecated_memory_changed_hook): Remove.
	* top.c (deprecated_memory_changed_hook): Likewise.
	* interps.c (clear_interpreter_hooks): Adjust.

gdb/gdbtk/ChangeLog:

2009-12-02  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* generic/gdbtk-hooks.c (gdbtk_memory_changed): Adjust.
	(gdbtk_add_hooks): Adjust.

gdb/doc/ChangeLog:

2009-12-02  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* observer.texi: New memory_changed observer.
@
text
@d2703 2
a2704 1
		error (_("no member function matches that type instantiation"));	    }
d2708 2
a2709 4
	      /* Skip artificial methods.  This is necessary if, for example,
		 the user wants to "print subclass::subclass" with only
		 one user-defined constructor.  There is no ambiguity in this
		 case.  */
d2713 5
d2719 8
a2726 1
		    --len;
a2727 9

	      /* Desired method is ambiguous if more than one method is
		 defined.  */
	      if (len > 1)
		error (_("non-unique member `%s' requires type instantiation"), name);

	      /* This assumes, of course, that all artificial methods appear
		 BEFORE any concrete methods.  */
	      j = TYPE_FN_FIELDLIST_LENGTH (t, i) - 1;
@


1.227
log
@	* c-exp.y: Add new rule for resolving method overloads.
	* eval.c (make_params): New function.
	(free_param_types): New function.
	(evaluate_subexp_standard): Pass expect_type to value_aggregate_elt.
	Handle case TYPE_INSTANCE.
	(evaluate_subexp_for_address): Pass expect_type to value_aggregate_elt.
	* expression.h (enum exp_opcode): Add TYPE_INSTANCE.
	(compare_parameters): Add declaration.
	* parse.c (operator_length_standard): Add TYPE_INSTANCE.
	* valops.c (value_aggregate_elt): Add new expect_type parameter.
	Pass expect_type to value_struct_elt_for_reference.
	(value_struct_elt_for_reference): Add expect_type parameter and use
	compare_parameters.
	Check for overload matches with and without artificial parameters.
	Skip artificial methods.
	(compare_parameters): New function.
	* value.h (value_aggregate_elt): Add new expect_type parameter.
@
text
@d864 2
a865 2
	if (deprecated_memory_changed_hook)
	  deprecated_memory_changed_hook (changed_addr, changed_len);
@


1.226
log
@	* valops.c (value_assign): Respect parent offset when
	assigning to a bitfield.
@
text
@d2539 2
a2540 2
value_aggregate_elt (struct type *curtype,
		     char *name, int want_address,
d2548 1
a2548 1
					     name, NULL,
d2559 51
d2687 2
a2688 1
	  int j = TYPE_FN_FIELDLIST_LENGTH (t, i);
a2692 2
	  if (intype == 0 && j > 1)
	    error (_("non-unique member `%s' requires type instantiation"), name);
d2695 31
a2725 5
	      while (j--)
		if (TYPE_FN_FIELD_TYPE (f, j) == intype)
		  break;
	      if (j < 0)
		error (_("no member function matches that type instantiation"));
a2726 2
	  else
	    j = 0;
@


1.225
log
@	Implement TARGET_OBJECT_STACK_MEMORY.
	* NEWS: Add note on new "set stack-cache" option.
	* corefile.c (read_stack): New function.
	* dcache.c (dcache_struct): New member ptid.
	(dcache_enable_p): Mark as obsolete.
	(show_dcache_enabled_p): Flag option as deprecated.
	(dcache_invalidate): Update ptid.
	(dcache_invalidate_line): New function.
	(dcache_read_line): No longer check cacheable attribute, stack
	accesses get cached despite attribute.
	(dcache_init): Set ptid.
	(dcache_xfer_memory): Flush cache if from different ptid than before.
	Update cache after write.
	(dcache_update): New function.
	(dcache_info): Report ptid.
	(_initialize_dcache): Update text for `remotecache' to indicate it
	is obsolete.
	* dcache.h (dcache_update): Declare.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Mark values on stack with
	set_value_stack.
	* frame-unwind.c (frame_unwind_got_memory): Ditto.
	* gdbcore.h (read_stack): Declare.
	* memattr.c (mem_enable_command): Call target_dcache_invalidate
	instead of dcache_invalidate.
	(mem_disable_command, mem_delete_command): Ditto.
	* target.c (stack_cache_enabled_p_1): New static global.
	(stack_cache_enabled_p): New static global.
	(set_stack_cache_enabled_p): New function.
	(show_stack_cache_enabled_p): New function.
	(target_dcache): Make static.
	(target_dcache_invalidate): New function.
	(target_load, target_resume): Call target_dcache_invalidate
	instead of dcache_invalidate.
	(memory_xfer_partial): New arg object, all callers updated.
	Check for existing inferior before calling dcache routines.
	When writing non-TARGET_OBJECT_STACK_MEMORY, notify dcache.
	(target_xfer_partial): Call memory_xfer_partial for
	TARGET_OBJECT_STACK_MEMORY.
	(target_read_stack): New function.
	(initialize_targets): Install new option `stack-cache'.
	* target.h: Remove #include of dcache.h.
	(enum target_object): New value TARGET_OBJECT_STACK_MEMORY.
	(target_dcache): Delete.
	(target_dcache_invalidate): Declare.
	(target_read_stack): Declare.
	* top.c (prepare_execute_command): New function.
	(execute_command): Call prepare_execute_command
	instead of free_all_values.
	* top.h (prepare_execute_command): Declare.
	* valops.c (get_value_at): New function.
	(value_at): Guts moved to get_value_at.
	(value_at_lazy): Similarly.
	(value_fetch_lazy): Call read_stack for stack values.
	* value.c (struct value): New member `stack'.
	(value_stack, set_value_stack): New functions.
	* value.h (value_stack, set_value_stack): Declare.
	* mi/mi-main.c (mi_cmd_execute): Call prepare_execute_command
	instead of free_all_values.

	doc/
	* gdb.texinfo (Caching Data of Remote Targets): Update text.
	Mark `set/show remotecache' options as obsolete.
	Document new `set/show stack-cache' option.
	Update text for `info dcache'.
@
text
@d830 3
d844 1
a844 1
		&& ((LONGEST) value_address (toval) % TYPE_LENGTH (type)) == 0)
d851 1
a851 1
	    read_memory (value_address (toval), buffer, changed_len);
a853 1
	    changed_addr = value_address (toval);
d896 2
d910 1
a910 2
		get_frame_register_bytes (frame, value_reg,
					  value_offset (toval),
d916 1
a916 2
		put_frame_register_bytes (frame, value_reg,
					  value_offset (toval),
@


1.225.2.1
log
@	* valops.c (value_assign): Respect parent offset when
	assigning to a bitfield.
@
text
@a829 3
	    struct value *parent = value_parent (toval);
	    changed_addr = value_address (parent) + value_offset (toval);

d841 1
a841 1
		&& ((LONGEST) changed_addr % TYPE_LENGTH (type)) == 0)
d848 1
a848 1
	    read_memory (changed_addr, buffer, changed_len);
d851 1
a893 2
		struct value *parent = value_parent (toval);
		int offset = value_offset (parent) + value_offset (toval);
d906 2
a907 1
		get_frame_register_bytes (frame, value_reg, offset,
d913 2
a914 1
		put_frame_register_bytes (frame, value_reg, offset,
@


1.224
log
@	gdb/
	* valops.c (value_fetch_lazy): Handle bitfields explicitly.
	(value_assign): Remove unnecessary FIXME.  Honor the container
	type of bitfields if possible.
	* value.c (struct value): Add parent field.
	(value_parent): New function.
	(value_free): Free the parent also.
	(value_copy): Copy the parent also.
	(value_primitive_field): Do not read the contents of a lazy
	value to create a child bitfield value.  Set bitpos and offset
	according to the container type if possible.
	(unpack_bits_as_long): Rename from unpack_field_as_long.  Take
	field_type, bitpos, and bitsize instead of type and fieldno.
	(unpack_field_as_long): Use unpack_bits_as_long.
	* value.h (value_parent, unpack_bits_as_long): New prototypes.
@
text
@d568 26
d609 1
a609 13
  struct value *val;

  if (TYPE_CODE (check_typedef (type)) == TYPE_CODE_VOID)
    error (_("Attempt to dereference a generic pointer."));

  val = allocate_value (type);

  read_memory (addr, value_contents_all_raw (val), TYPE_LENGTH (type));

  VALUE_LVAL (val) = lval_memory;
  set_value_address (val, addr);

  return val;
d617 1
a617 11
  struct value *val;

  if (TYPE_CODE (check_typedef (type)) == TYPE_CODE_VOID)
    error (_("Attempt to dereference a generic pointer."));

  val = allocate_value_lazy (type);

  VALUE_LVAL (val) = lval_memory;
  set_value_address (val, addr);

  return val;
d663 6
a668 1
	read_memory (addr, value_contents_all_raw (val), length);
@


1.223
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d635 19
a653 1
  if (VALUE_LVAL (val) == lval_memory)
a820 2
	    /* We assume that the argument to read_memory is in units
	       of host chars.  FIXME: Is that correct?  */
d826 9
@


1.222
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d425 1
d430 1
a430 1
	decimal_from_floating (arg2, dec, dec_len);
d433 1
a433 1
			 dec, dec_len);
d436 1
a436 1
	decimal_from_integral (arg2, dec, dec_len);
d454 3
a456 2
        longest = extract_unsigned_integer (value_contents (arg2),
                                            TYPE_LENGTH (type2));
d546 1
d548 1
a548 1
      decimal_from_string (v, TYPE_LENGTH (type), "1");
@


1.221
log
@	* gdbtypes.c (make_pointer_type, make_reference_type,
	smash_to_memberptr_type, lookup_array_range_type, check_stub_method):
	Use type architecture instead of current_gdbarch.

	* gdbtypes.h (address_space_name_to_int, address_space_int_to_name):
	Add GDBARCH paramter.
	* gdbtypes.c (address_space_name_to_int, address_space_int_to_name):
	Add GDBARCH parameter.   Use it instead of current_gdbarch.
	* c-typeprint.c (c_type_print_modifier): Update call.
	* parse.c (push_type_address_space): Likewise.

	* findvar.c (extract_typed_address, store_typed_address): Use type
	architecture instead of current_gdbarch.

	* value.c (value_as_address, unpack_field_as_long): Use type architecture
	instead of current_gdbarch.

	* doublest.c (floatformat_from_length): Add GDBARCH argument.  Use it
	instead of current_gdbarch.
	(floatformat_from_type): Pass type architecture.

	* infcall.c (find_function_addr): Use type architecture instead
	of current_gdbarch.

	* valarith.c (value_bitstring_subscript, value_x_binop, value_neg,
	value_bit_index): Use type architecture instead of current_gdbarch.
	* valops.c (value_cast, value_slice): Likewise.

	* value.h (modify_field): Add TYPE argument.
	* value.c (modify_field): Add TYPE argument.  Use type architecture
	instead of current_gdbarch.
	(set_internalvar_component): Likewise.
	* eval.c (evaluate_struct_tuple): Update call.
	* valops.c (value_assign): Likewise.
	* ada-lang.c (modify_general_field): Likewise.  Add TYPE argument.
	(make_array_descriptor): Update calls.
	(move_bits): Add BITS_BIG_ENDIAN_P argument.  Use it instead of
	current_gdbarch.
	(ada_value_assign, value_assign_to_component): Update calls.
	(decode_packed_array, ada_value_primitive_packed_val, ada_value_assign,
	value_assign_to_component): Use type arch instead of current_gdbarch.

	* printcmd.c (float_type_from_length): Remove GDBARCH argument,
	use type architecture instead.
	(print_scalar_formatted, printf_command): Update calls.  Use type
	architecture instead of current_gdbarch.
	* valprint.c (val_print_type_code_int): Use type architecture
	instead of current_gdbarch.
	* varobj.c (value_get_print_value): Likewise.
	* python/python-prettyprint.c (print_string_repr): Add GDBARCH
	argument.  Use it instead of current_gdbarch.
	(apply_val_pretty_printer): Update call.

	* ada-valprint.c (ada_val_print_1): Use type architecture instead
	of current_gdbarch.
	* c-valprint.c (print_function_pointer_address): Add GDBARCH argument.
	Use it instead of current_gdbarch.
	(c_val_print): Update calls passing type architecture.
	* f-valprint.c (f_val_print): Use type architecture instead of
	current_gdbarch.
	* jv-valprint (java_value_print): Likewise.
	* m2-valprint.c (print_function_pointer_address): Add GDBARCH argument.
	Use it instead of current_gdbarch.
	(print_unpacked_pointer): Update calls passing type architecture.
	* scm-valprint.c (scm_scmval_print): Use type architecture instead of
	current_gdbarch.

	* gnu-v3-abi.c (get_class_arch): Remove.
	(gnuv3_rtti_type): Use get_type_arch instead of get_class_arch.  Remove
	special-case check for Java classes.
	(gnuv3_virtual_fn_field, gnuv3_baseclass_offset, gnuv3_print_method_ptr,
	gnuv3_method_ptr_size, gnuv3_make_method_ptr, gnuv3_method_ptr_to_value):
	Use get_type_arch instead of get_class_arch.
@
text
@d705 3
a707 2
		fprintf_unfiltered (gdb_stdlog, " address=0x%s",
				    paddr_nz (value_address (new_val)));
@


1.220
log
@	* gdbtypes.h (builtin_type_void): Remove.
	* gdbtypes.c (builtin_type_void): Remove.
	(_initialize_gdbtypes): Do not initialize it.

	(safe_parse_type): Add GDBARCH argument.  Use it to construct
	void return type.
	(check_stub_method): Update call.

	* infcall.c (call_function_by_hand): Use platform-specific type
	instead of builtin_type_void.
	* valops.c (value_cast): Use input void type instead of
	builtin_type_void.
@
text
@d474 1
a474 1
      int addr_bit = gdbarch_addr_bit (current_gdbarch);
d811 1
a811 1
	    modify_field (buffer, value_as_long (fromval),
d872 2
a873 3
		modify_field (buffer, value_as_long (fromval),
			      value_bitpos (toval), 
			      value_bitsize (toval));
d2949 1
a2949 1
	      if (gdbarch_bits_big_endian (current_gdbarch))
@


1.219
log
@	* ada-lang.c (assign_component): Use platform-specific integer type
	instead of builtin_type_int32 type.
	(ada_evaluate_subexp) [OP_ATR_SIZE]: Likewise.

	* ax-gdb.c (gen_expr) [UNOP_NEG]: Use platform-specific integer type
	instead of builtin_type_int8 type.
	* valarith.c (value_x_unop): Likewise.
	* python/python-value.c (valpy_absolute): Avoid reference to
	builtin_type_int8 type.

	* eval.c (evaluate_subexp_standard): Use platform-specific integer
	type instead of builtin_type_int8 as EVAL_SKIP return value type.
	* ada-lang.c (ada_evaluate_subexp): Likewise.
	* jv-lang.c (evaluate_subexp_java): Likewise.
	* m2-lang.c (evaluate_subexp_modula2): Likewise.
	* scm-lang.c (evaluate_exp): Likewise.

	* value.h (value_bitstring): Add INDEX_TYPE argument.
	* valops.c (value_bitstring): Add INDEX_TYPE argument, use it instead
	of builtin_type_int32 as base range type.
	* eval.c (evaluate_subexp_standard): Update value_bitstring call.
@
text
@d514 1
a514 1
      return value_zero (builtin_type_void, not_lval);
@


1.218
log
@	* gdbtypes.c (lookup_array_range_type): Add prototype.
	(lookup_string_range_type): Likewise.
	* gdbtypes.c (lookup_array_range_type): New function.
	(lookup_string_range_type): Likewise.

	* ax-gdb.c (gen_repeat): Use lookup_array_range_type.
	* parse.c (follow_types): Likewise.
	* jv-lang.c (java_array_type): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
	* mt-tdep.c (mt_register_type): Likewise.
	* sh-tdep.c (sh_sh4_build_float_register_type): Likewise.
	* sh64-tdep.c (sh64_build_float_register_type): Likewise.
	* value.c (allocate_repeat_value): Likewise.
	* valops.c (value_array, value_cstring): Likewise.
	* valops.c (value_string): Use lookup_string_range_type.
@
text
@d1381 1
a1381 1
value_bitstring (char *ptr, int len)
d1384 3
a1386 5
  struct type *domain_type = create_range_type (NULL, 
						builtin_type_int32,
						0, len - 1);
  struct type *type = create_set_type ((struct type *) NULL, 
				       domain_type);
@


1.217
log
@	gdb/
	* NEWS: Document inlined function support.
	* Makefile.in (SFILES): Add inline-frame.c.
	(COMMON_OBS): Add inline-frame.o.
	* block.c (contained_in): Rewrite to use lexical nesting.
	(block_linkage_function): Skip inlined function blocks.
	(block_inlined_p): New.
	* block.h (struct block): Update comment.
	(block_inlined_p): New prototype.
	* blockframe.c (get_frame_block): Handle inlined functions.
	(get_frame_function): Do not use block_linkage_function.
	(block_innermost_frame): Use get_frame_block and contained_in.
	* breakpoint.c (watchpoint_check): Remove extra reinit_frame_cache.
	Skip over inlined functions.  Simplify epilogue check.
	(bpstat_check_breakpoint_conditions): Use get_stack_frame_id.
	Update comments.
	(set_momentary_breakpoint): Only accept non-inlined frames.
	(watch_command_1): Use frame_unwind_caller_pc and
	frame_unwind_caller_id instead of get_prev_frame.
	(until_break_command): Likewise.  Use get_stack_frame_id.
	* buildsym.c (end_symtab): Set SYMBOL_SYMTAB for block functions.
	* dwarf2loc.c (dwarf_expr_frame_base): Use block_linkage_function.
	* dwarf2read.c (process_die): Handle DW_TAG_inlined_subroutine.
	(read_func_scope, new_symbol): Likewise.  Handle arguments specially
	for inlined functions without call site information.
	(inherit_abstract_dies): Allow tag mismatch for inlined subroutines.
	(die_specification): Treat DW_AT_abstract_origin as a specification.
	(read_type_die): Handle DW_TAG_inlined_subroutine.
	* frame-unwind.c (frame_unwind_init): Add inline_frame_unwind.
	* frame.c (fprint_frame_id): Print inline depth.
	(fprint_frame_type): Handle INLINE_FRAME and SENTINEL_FRAME.
	(skip_inlined_frames, get_stack_frame_id): New.
	(frame_unwind_caller_id): Use skip_inlined_frames.
	(frame_id_inlined_p): New.
	(frame_id_eq): Make the logic match the comments.  Add inline_depth
	check.
	(frame_id_inner): Handle inlined functions.
	(frame_unwind_pc): New function, copied from frame_unwind_caller_pc.
	(frame_unwind_caller_pc): Use skip_inlined_frames and frame_unwind_pc.
	(get_prev_frame_1): Check for inline frames.  Split out frame
	allocation to get_prev_frame_raw.
	(get_prev_frame_raw): New function.
	(get_prev_frame): Handle inline frames.
	(get_frame_pc): Use frame_unwind_pc.
	(get_frame_address_in_block): Skip inlined frames on both sides.
	(pc_notcurrent): Delete.
	(find_frame_sal): Rewrite to handle inline call sites.  Use
	get_frame_address_in_block.
	(deprecated_update_frame_pc_hack): Make static.
	* frame.h: Update comments.
	(struct frame_id): Add inline_depth.
	(enum frame_type): Add INLINE_FRAME.
	(frame_id_inlined_p, get_stack_frame_id): New prototypes.
	* gdbthread.h (struct thread_info): Add step_stack_frame_id field.
	* infcmd.c (set_step_frame): New function.
	(step_once): Use set_step_frame.  Handle inlined functions.
	(until_next_command): Use set_step_frame.
	(finish_backward), finish_forward): Use get_stack_frame_id.
	(finish_command): Support inlined functions.
	* inferior.h (set_step_info): New prototype.
	* infrun.c (RESUME_ALL): Use minus_one_ptid.
	(clear_proceed_status): Clear step_stack_frame_id.
	(init_wait_for_inferior): Call clear_inline_frame_state.
	(init_execution_control_state): Make static.
	(set_step_info): New function.
	(init_thread_stepping_state): Do not set the symtab or line here.
	(stepped_in_from): New function.
	(handle_inferior_event): Handle inlined functions.  Use set_step_info.
	(insert_step_resume_breakpoint_at_frame): Use get_stack_frame_id.
	(struct inferior_status): Add step_stack_frame_id.
	(save_inferior_status, restore_inferior_status): Save and restore
	step_stack_frame_id.
	* inline-frame.c, inline-frame.h: New files.
	* minsyms.c (prim_record_minimal_symbol_and_info): Use XCALLOC.
	* regcache.c (regcache_write_pc): Call reinit_frame_cache.
	* s390-tdep.c (s390_prologue_frame_unwind_cache): Handle INLINE_FRAME.
	* stack.c (frame_show_address): New.
	(print_frame_info, print_frame): Use it.
	(find_frame_funname): Use get_frame_function.  Handle inlined blocks.
	(frame_info): Mark inlined functions.
	(backtrace_command_1): Use get_current_user_frame.
	(print_frame_local_vars, print_frame_label_vars): Update comments.
	(return_command): Refuse inlined functions.
	* symtab.c (lookup_symbol_aux_local): Stop at inlined function
	boundaries.
	(find_function_start_sal): Avoid inlined functions.
	(completion_list_add_fields): New function.
	(default_make_symbol_completion_list): Use it.  Use block_static_block
	and block_global_block.  Check for inlined functions.
	(skip_prologue_using_sal): Avoid line number comparison across
	inlining.
	* symtab.h (struct symbol): Add is_inlined.
	(SYMBOL_INLINED): New.
	* target.c (target_resume): Call clear_inline_frame_state.
	* valops.c (value_of_variable): Check block_inlined_p.

	gdb/doc/
	* gdb.texinfo (Debugging Optimized Code): New chapter.
	(Compiling for Debugging): Reference it.  Move some
	text to the new section.

	gdb/testsuite/
	* gdb.base/break.exp: Add an XFAIL for gcc/36748.
	* gdb.cp/annota2.exp: Accept frames-invalid in more places.
	* gdb.opt/Makefile.in (EXECUTABLES): Update.
	* gdb.opt/clobbered-registers-O2.exp: Update to GPL v3.
	* gdb.opt/inline-bt.c, gdb.opt/inline-bt.exp,
	gdb.opt/inline-cmds.c, gdb.opt/inline-cmds.exp,
	gdb.opt/inline-locals.c, gdb.opt/inline-locals.exp,
	gdb.opt/inline-markers.c: New files.
	* lib/gdb.exp (skip_inline_frame_tests): New function.
	(skip_inline_var_tests): New function.
@
text
@a1296 1
  struct type *rangetype;
d1317 2
a1318 6
  rangetype = create_range_type ((struct type *) NULL, 
				 builtin_type_int32,
				 lowbound, highbound);
  arraytype = create_array_type ((struct type *) NULL,
				 value_enclosing_type (elemvec[0]), 
				 rangetype);
a1348 4
  struct type *rangetype = create_range_type ((struct type *) NULL,
					      builtin_type_int32,
					      lowbound, 
					      highbound + lowbound - 1);
d1350 1
a1350 1
    = create_array_type ((struct type *) NULL, char_type, rangetype);
a1371 4
  struct type *rangetype = create_range_type ((struct type *) NULL,
					      builtin_type_int32,
					      lowbound, 
					      highbound + lowbound - 1);
d1373 1
a1373 1
    = create_string_type ((struct type *) NULL, char_type, rangetype);
@


1.216
log
@	* valops.c (value_one): Reimplement broken decimal-float case.
@
text
@d1006 1
a1006 1
	  if (BLOCK_FUNCTION (b)
@


1.215
log
@	* gdbtypes.c (create_string_type): Receive character type as argument.
	* gdbtypes.h (create_string_type): Add character type argument.
        * dwarf2read.c (read_tag_string_type): Pass character type to
	create_string_type.

	* value.h (value_string): Add character type argument.
	* valops.c (value_string): Add character type argument.  Pass it to
	create_string_type.  Do not allocate space in inferior.
	* valarith.c (value_concat): Pass character type to value_string.

	* value.h (value_typed_string): Rename to ...
	(value_cstring): ... this.
	* valops.c (value_typed_string): Rename to ...
	(value_cstring): ... this.
	* c-lang.c (evaluate_subexp_c): Update.

	* python/python-value.c (builtin_type_pychar): New define.
	(convert_value_from_python): Call value_cstring instead
	of value_from_string.
	* value.c (value_from_string): Remove.
	* value.h (value_from_string): Remove.

	* eval.c (evaluate_subexp_standard): Pass character type to
	value_string.  Pass expression architecture to value_nsstring
	and lookup_child_selector.
	* objc-lang.h (lookup_objc_class): Add GDBARCH parameter.
	(lookup_child_selector): Likewise.
	(value_nsstring): Likewise.
	* objc-lang.c (lookup_objc_class): Add GDBARCH parameter.
	Pass character type to value_string..
	(lookup_child_selector): Likewise.
	(value_nsstring): Add GDBARCH parameter, use it instead of
	objfile architecture.  Pass architecture to lookup_objc_class
	and lookup_child_selector. Pass character type to value_string.
	(end_msglist): Pass architecture to lookup_objc_class.
	* objc-exp.y: Pass architecture to lookup_objc_class.
@
text
@d540 1
a540 1
  struct value *val = NULL; /* avoid -Wall warning */
a543 2
      struct value *int_one = value_from_longest (builtin_type_int32, 1);
      struct value *val;
d545 1
a545 2

      decimal_from_integral (int_one, v, TYPE_LENGTH (builtin_type_int32));
@


1.214
log
@	* dummy-frame.c (deprecated_pc_in_call_dummy): Add GDBARCH parameter,
	use it instead of current_gdbarch.
	* frame.h (deprecated_pc_in_call_dummy): Add GDBARCH parameter.
	* arm-tdep.c (arm_skip_prologue): Pass architecture to
	deprecated_pc_in_call_dummy.

	* symtab.c (skip_prologue_using_sal): Add GDBARCH parameter.
	Use it instead of current_gdbarch.
	* symtab.h (skip_prologue_using_sal): Add GDBARCH parameter.
	* breakpoint.c (expand_line_sal_maybe): Pass architecture to
	skip_prologue_using_sal.
	* arm-tdep.c (skip_prologue_using_sal): Likewise.
	* lm32-tdep.c (lm32_skip_prologue): Likewise.
	* m32-tdep.c (m32c_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* moxie-tdep.c (moxie_skip_prologue): Likewise.
	* mt-tdep.c (mt_frame_unwind_cache): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* frv-tdep.c (frv_analyze_prologue): Add GDBARCH parameter, pass
	it to skip_prologue_using_sal.  Update call sites ...
	(frv_skip_prologue, frv_frame_unwind_cache): ... here.

	* mn10300-tdep.c (struct mn10300_prologue): Add GDBARCH member.
	(check_for_saved): Use it instead of current_gdbarch.
	(mn10300_analyze_prologue): Set it.

	* value.c (using_struct_return): Add GDBARCH parameter.  Use it
	instead of current_gdbarch.
	* value.h (using_struct_return): Add GDBARCH parameter.
	* eval.c (evaluate_subexp_standard): Pass architecture to
	using_struct_return.
	* infcall.c (call_function_by_hand): Likewise.
	* stack.c (return_command): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.

	* symtab.c (in_prologue): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.
	* symtab.h (in_prologue): Add GDBARCH parameter.
	* infrun.c (handle_inferior_event): Pass architecture to in_prologue.

	* eval.c (evaluate_subexp_standard): Use expression architecture
	instead of current_gdbarch.

	* c-lang.c (evaluate_subexp_c): Use expression architecture and
	language instead of current_gdbarch and current_language.

	* printcmd.c (do_one_display): Use expression architecture instead
	of current_gdbarch.

	* infcmd.c (print_return_value): Use architecture of stop_regcache
	instead of current_gdbarch.
	(print_vector_info, print_float_info): Remove GDBARCH argument,
	use frame architecture instead.
	(vector_info, float_info): Update calls.

	* objc-lang.c (objc_skip_trampoline): Use frame architecture
	instead of current_gdbarch.

	* parse.c (write_dollar_variable): Use parse architecture instead
	of current_gdbarch.

	* source.c (line_info): Use objfile architecture instead of
	current_gdbarch.

	* symtab.c (find_function_start_sal): Use gdbarch instead of
	current_gdbarch.
	(print_msymbol_info): Use objfile architecture instead of
	current_gdbarch.

	* valops.c (value_assign): Use frame architecture instead of
	current_gdbarch.
@
text
@d1352 1
a1352 1
value_typed_string (char *ptr, int len, struct type *char_type)
d1379 1
a1379 1
value_string (char *ptr, int len)
d1383 1
d1387 1
a1387 1
					      len + lowbound - 1);
d1389 1
a1389 2
    = create_string_type ((struct type *) NULL, rangetype);
  CORE_ADDR addr;
d1391 3
a1393 16
  if (current_language->c_style_arrays == 0)
    {
      val = allocate_value (stringtype);
      memcpy (value_contents_raw (val), ptr, len);
      return val;
    }


  /* Allocate space to store the string in the inferior, and then copy
     LEN bytes from PTR in gdb to that address in the inferior.  */

  addr = allocate_space_in_inferior (len);
  write_memory (addr, (gdb_byte *) ptr, len);

  val = value_at_lazy (stringtype, addr);
  return (val);
@


1.213
log
@	* linespec.c (collect_methods): Delete.
	(add_matching_methods): Reove destructor special case.
	(find_method): Call find_methods directly instead of
	collect_methods.
	* valops.c (value_struct_elt): Remove destructor
	special cases.
	(check_field): Likewise.
	(value_struct_elt_for_reference): Likewise.
	(destructor_name_p): Remove misleading comment about dtors
	being "special cases".
	* gdbtypes.h (get_destructor_fn_field): Remove. No longer needed.
	* gdbtypes.c (get_destructor_fn_field): Likewise.
@
text
@d835 1
d844 3
a846 3
	
	if (gdbarch_convert_register_p
	    (current_gdbarch, VALUE_REGNUM (toval), type))
d851 1
a851 1
	    gdbarch_value_to_register (current_gdbarch, frame, 
@


1.212
log
@	* value.h (struct internalvar): Remove.
	(get_internalvar_integer): Add prototype.
	(set_internalvar_integer): Add prototype.
	(clear_internalvar): Add prototype.

	* value.c (struct internalvar): Move here.  Add type member.  Remove
	endian member.  Add union_internalvar member instead of value member.
	(init_if_undefined_command): Use intvar->type.
	(create_internalvar): Do not initialize value/endian, but type.
	(create_internalvar_type_lazy): Call create_internalvar.
	(value_of_internalvar): Handle host-side internalvar contents.
	(set_internalvar_component): Likewise.
	(set_internalvar): Likewise.
	(get_internalvar_integer): New function.
	(clear_internalvar): Likewise.
	(set_internalvar_integer): Likewise.
	(preserve_values): Handle host-side internalvar contents.

	* breakpoint.c (set_breakpoint_count, set_tracepoint_count): Call
	set_internalvar_integer instead of set_internalvar.
	* findcmd.c (find_command): Likewise.
	* infrun.c (handle_inferior_event): Likewise.
	* source.c (forward_search_command, reverse_search_command): Likewise.
	* tracepoint.c (set_traceframe_num, set_tracepoint_num,
	set_traceframe_context): Likewise.

	* printcmd.c (x_command): Call clear_internalvar instead of
	set_internalvar.
	* tracepoint.c (set_traceframe_context): Likewise.

	* breakpoint.c (get_number_trailer): Call get_internalvar_integer
	instead of value_of_internalvar.
	* linespec.c (decode_dollar): Likewise.

	* expprint.c (dump_subexp_body_standard): Use internalvar_name
	instead of accessing internalvar private elements.
	* valops.c (value_assign): Copy from original source instead of
	accessing internalvar private elements.
@
text
@a1851 4

      if (destructor_name_p (name, t))
	error (_("Cannot get value of destructor"));

a1866 26
  if (destructor_name_p (name, t))
    {
      if (!args[1])
	{
	  /* Destructors are a special case.  */
	  int m_index, f_index;

	  v = NULL;
	  if (get_destructor_fn_field (t, &m_index, &f_index))
	    {
	      v = value_fn_field (NULL, 
				  TYPE_FN_FIELDLIST1 (t, m_index),
				  f_index, NULL, 0);
	    }
	  if (v == NULL)
	    error (_("could not find destructor function named %s."), 
		   name);
	  else
	    return v;
	}
      else
	{
	  error (_("destructor should not have any argument"));
	}
    }
  else
a2471 2
  /* Destructors are a special case.  */

a2509 8
  /* Destructors are a special case.  */
  if (destructor_name_p (name, type))
    {
      int m_index, f_index;

      return get_destructor_fn_field (type, &m_index, &f_index);
    }

a2604 6
  /* Destructors are a special case.  */
  if (destructor_name_p (name, t))
    {
      error (_("member pointers to destructors not implemented yet"));
    }

@


1.211
log
@2009-05-27  Tom Tromey  <tromey@@redhat.com>
	    Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* mi/mi-main.c (mi_cmd_data_evaluate_expression): Use
	value_address.
	* cli/cli-dump.c (dump_value_to_file): Use value_address.
	* valprint.c (common_val_print): Likewise.
	* v850-tdep.c (v850_push_dummy_call): Use value_address.
	* tracepoint.c (encode_actions): Use value_address.
	* printcmd.c (print_formatted): Use value_address.
	(x_command): Likewise.
	* p-valprint.c (pascal_object_print_static_field): Use
	value_address.
	* mn10300-tdep.c (mn10300_push_dummy_call): Use value_address.
	* mips-tdep.c (mips_eabi_push_dummy_call): Use value_address.
	* m32r-tdep.c (m32r_push_dummy_call): Use value_address.
	* jv-valprint.c (java_value_print): Use value_address.
	* infcall.c (find_function_addr): Use value_address.
	* gnu-v3-abi.c (gnuv3_rtti_type): Use value_address.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Use value_address.
	* frv-tdep.c (frv_push_dummy_call): Use value_address.
	* frame.c (frame_register_unwind): Use value_address.
	(frame_unwind_register_value): Likewise.
	* darwin-nat-info.c (info_mach_region_command): Use
	value_address.
	* cp-valprint.c (cp_print_static_field): Use value_address.
	* c-valprint.c (c_value_print): Use value_address.
	* breakpoint.c (update_watchpoint): Use value_address.
	(can_use_hardware_watchpoint): Likewise.
	* ada-valprint.c (ada_val_print_1): Use value_address.
	(ada_value_print): Likewise.
	* ada-tasks.c (read_fat_string_value): Use value_address.
	* jv-lang.c (java_link_class_type): Use set_value_address.
	(java_link_class_type): Likewise.
	(get_java_utf8_name): Use value_address.
	(type_from_class): Likewise.
	(java_link_class_type): Likewise.
	* findvar.c (value_of_register): Use set_value_address.
	(read_var_value): Likewise.
	(read_var_value): Likewise.
	* eval.c (evaluate_subexp_standard): Use set_value_address.
	(evaluate_subexp_standard): Use value_address.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Use set_value_address.
	* ada-lang.c (coerce_unspec_val_to_type): Use set_value_address.
	(ada_value_primitive_packed_val): Likewise.
	(ensure_lval): Likewise.
	(thin_data_pntr): Use value_address.
	(desc_bounds): Likewise.
	(ada_value_primitive_packed_val): Likewise.
	(value_assign_to_component): Likewise.
	(ensure_lval): Likewise.
	(make_array_descriptor): Likewise.
	(ada_to_fixed_value): Likewise.
	(unwrap_value): Likewise.
	* value.c (deprecated_value_address_hack): Remove.
	(value_address): New function.
	(value_raw_address): Likewise.
	(set_value_address): Likewise.
	(value_fn_field): Use set_value_address.
	(value_from_contents_and_address): Likewise.
	(value_fn_field): Likewise.
	(allocate_value_lazy): Don't use VALUE_ADDRESS.
	(value_as_address): Use value_address.
	(value_static_field): Likewise.
	* valops.c (search_struct_field): Use set_value_address.
	(value_at): Likewise.
	(value_at_lazy): Likewise.
	(value_repeat): Likewise.
	(value_cast_structs): Use value_address.
	(value_cast): Likewise.
	(value_fetch_lazy): Likewise.
	(value_assign): Likewise.
	(value_repeat): Likewise.
	(address_of_variable): Likewise.
	(value_coerce_array): Likewise.
	(value_coerce_function): Likewise.
	(value_addr): Likewise.
	(search_struct_field): Likewise.
	(search_struct_method): Likewise.
	(find_method_list): Likewise.
	(value_struct_elt_for_reference): Likewise.
	(value_full_object): Likewise.
	* jv-valprint.c (java_value_print): Use set_value_address.
	* value.h (deprecated_value_address_hack): Remove.
	(VALUE_ADDRESS): Remove.
	(value_address): Declare.
	(value_raw_address): Declare.
	(set_value_address): Declare.
@
text
@d777 1
a777 1
      val = value_copy (VALUE_INTERNALVAR (toval)->value);
@


1.210
log
@gdb:
2009-03-19  Tom Tromey  <tromey@@redhat.com>
	    Julian Brown  <julian@@codesourcery.com>

	PR i18n/7220, PR i18n/7821, PR exp/8815, PR exp/9103,
	PR i18n/9401, PR exp/9613:
	* NEWS: Update
	* value.h (value_typed_string): Declare.
	(val_print_string): Update.
	* valprint.h (print_char_chars): Update.
	* valprint.c (print_char_chars): Add type argument.  Update.
	(val_print_string): Likewise.
	* valops.c (value_typed_string): New function.
	* utils.c (host_char_to_target): New function.
	(parse_escape): Use host_char_to_target, host_hex_value.  Update.
	Remove '^' case.
	(no_control_char_error): Remove.
	* typeprint.c (print_type_scalar): Update.
	* scm-valprint.c (scm_scmval_print): Update.
	* scm-lang.h (scm_printchar, scm_printstr): Update.
	* scm-lang.c (scm_printchar): Add type argument.
	(scm_printstr): Likewise.
	* printcmd.c (print_formatted): Update.
	(print_scalar_formatted): Update.
	(printf_command) <wide_string_arg, wide_char_arg>: New constants.
	Handle '%lc' and '%ls'.
	* parser-defs.h (struct typed_stoken): New type.
	(struct stoken_vector): Likewise.
	(write_exp_string_vector): Declare.
	* parse.c (write_exp_string_vector): New function.
	* p-valprint.c (pascal_val_print): Update.
	* p-lang.h (is_pascal_string_type, pascal_printchar,
	pascal_printstr): Update.
	* p-lang.c (is_pascal_string_type): Remove 'char_size' argument.
	Add 'char_type' argument.
	(pascal_emit_char): Add type argument.
	(pascal_printchar): Likewise.
	(pascal_printstr): Likewise.
	* objc-lang.c (objc_emit_char): Add type argument.
	(objc_printchar): Likewise.
	(objc_printstr): Likewise.
	* macroexp.c (get_character_constant): Handle unicode characters.
	Use c_parse_escape.
	(get_string_literal): Handle unicode strings.  Use
	c_parse_escape.
	* m2-valprint.c (print_unpacked_pointer): Update.
	(m2_print_array_contents): Update.
	(m2_val_print): Update.
	* m2-lang.c (m2_emit_char): Add type argument.
	(m2_printchar): Likewise.
	(m2_printstr): Likewise.
	* language.h (struct language_defn) <la_printchar>: Add type
	argument.
	<la_printstr, la_emitchar>: Likewise.
	(LA_PRINT_CHAR): Likewise.
	(LA_PRINT_STRING): Likewise.
	(LA_EMIT_CHAR): Likewise.
	* language.c (unk_lang_emit_char): Add type argument.
	(unk_lang_printchar): Likewise.
	(unk_lang_printstr): Likewise.
	* jv-valprint.c (java_val_print): Update.
	* jv-lang.c (java_emit_char): Add type argument.
	* f-valprint.c (f_val_print): Update.
	* f-lang.c (f_emit_char): Add type argument.
	(f_printchar): Likewise.
	(f_printstr): Likewise.
	* expprint.c (print_subexp_standard): Update.
	* charset.h (target_wide_charset): Declare.
	(c_target_char_has_backslash_escape, c_parse_backslash,
	host_char_print_literally, host_char_to_target,
	target_char_to_host, target_char_to_control_char): Remove.
	(enum transliterations): New type.
	(convert_between_encodings): Declare.
	(HOST_ESCAPE_CHAR): New define.
	(host_letter_to_control_character, host_hex_value): Declare.
	(enum wchar_iterate_result): New enum.
	(struct wchar_iterator): Declare.
	(make_wchar_iterator, make_cleanup_wchar_iterator, wchar_iterator,
	wchar_push_back): Declare.
	* charset-list.h: New file.
	* c-valprint.c (textual_name): New function.
	(textual_element_type): Handle wide character types.
	(c_val_print): Pass original type to textual_element_type.  Handle
	wide character types.
	(c_value_print): Use textual_element_type.  Pass original type of
	value to val_print.
	* c-lang.h (enum c_string_type): New type.
	(c_printchar, c_printstr): Update.
	* c-lang.c (classify_type): New function.
	(print_wchar): Likewise.
	(c_emit_char): Add type argument.  Handle wide characters.
	(c_printchar): Likewise.
	(c_printstr): Add type argument.  Handle wide and multibyte
	character sets.
	(convert_ucn): New function.
	(emit_numeric_character): Likewise.
	(convert_octal): Likewise.
	(convert_hex): Likewise.
	(ADVANCE): New macro.
	(convert_escape): New function.
	(parse_one_string): Likewise.
	(evaluate_subexp_c): Likewise.
	(exp_descriptor_c): New global.
	(c_language_defn): Use exp_descriptor_c.
	(cplus_language_defn): Likewise.
	(asm_language_defn): Likewise.
	(minimal_language_defn): Likewise.
	(charset_for_string_type): New function.
	* c-exp.y (%union): Add 'svec' and 'tsval'.
	(CHAR): New token.
	(exp): Add CHAR production.
	(string_exp): Rewrite.
	(exp) <string_exp>: Rewrite.
	(tempbuf): Now global.
	(tempbuf_init): New global.
	(parse_string_or_char): New function.
	(yylex) <tempbuf>: Now global.
	<tokptr, tempbufindex, tempbufsize, token_string, class_prefix>:
	Remove.
	Handle 'u', 'U', and 'L' prefixes.  Call parse_string_or_char.
	(c_parse_escape): New function.
	* auxv.c (fprint_target_auxv): Update.
	* ada-valprint.c (ada_emit_char): Add type argument.
	(ada_printchar): Likewise.
	(ada_print_scalar): Update.
	(printstr): Add type argument.  Update calls to ada_emit_char.
	(ada_printstr): Add type argument.
	(ada_val_print_array): Update.
	(ada_val_print_1): Likewise.
	* ada-lang.c (emit_char): Add type argument.
	* ada-lang.h (ada_emit_char, ada_printchar, ada_printstr): Add
	type arguments.
	* gdb_locale.h: Include langinfo.h.
	* charset.c (_initialize_charset): Set default host charset from
	the locale.  Don't register charsets.  Add target-wide-charset
	commands.  Call find_charset_names.
	(struct charset, struct translation): Remove.
	(GDB_DEFAULT_HOST_CHARSET): Remove.
	(GDB_DEFAULT_TARGET_WIDE_CHARSET): New define.
	(target_wide_charset_name): New global.
	(show_host_charset_name): Handle "auto".
	(show_target_wide_charset_name): New function.
	(host_charset_enum, target_charset_enum): Remove.
	(charset_enum): New global.
	(all_charsets, register_charset, lookup_charset, all_translations,
	register_translation, lookup_translation): Remove.
	(simple_charset, ascii_print_literally, ascii_to_control): Remove.
	(iso_8859_print_literally, iso_8859_to_control,
	iso_8859_family_charset): Remove.
	(ebcdic_print_literally, ebcdic_to_control,
	ebcdic_family_charset): Remove.
	(struct cached_iconv, check_iconv_cache, cached_iconv_convert,
	register_iconv_charsets): Remove.
	(target_wide_charset_be_name, target_wide_charset_le_name): New
	globals.
	(identity_either_char_to_other): Remove.
	(set_be_le_names, validate): New functions.
	(backslashable, backslashed, represented): Remove.
	(default_c_target_char_has_backslash_escape): Remove.
	(default_c_parse_backslash, iconv_convert): Remove.
	(ascii_to_iso_8859_1_table, ascii_to_ebcdic_us_table,
	ascii_to_ibm1047_table, iso_8859_1_to_ascii_table,
	iso_8859_1_to_ebcdic_us_table, iso_8859_1_to_ibm1047_table,
	ebcdic_us_to_ascii_table, ebcdic_us_to_iso_8859_1_table,
	ebcdic_us_to_ibm1047_table, ibm1047_to_ascii_table,
	ibm1047_to_iso_8859_1_table, ibm1047_to_ebcdic_us_table): Remove.
	(table_convert_char, table_translation, simple_table_translation):
	Remove.
	(current_host_charset, current_target_charset,
	c_target_char_has_backslash_escape_func,
	c_target_char_has_backslash_escape_baton): Remove.
	(c_parse_backslash_func, c_parse_backslash_baton): Remove.
	(host_char_to_target_func, host_char_to_target_baton): Remove.
	(target_char_to_host_func, target_char_to_host_baton): Remove.
	(cached_iconv_host_to_target, cached_iconv_target_to_host):
	Remove.
	(lookup_charset_or_error, check_valid_host_charset): Remove.
	(set_host_and_target_charsets): Remove.
	(set_host_charset, set_target_charset): Remove.
	(set_host_charset_sfunc, set_target_charset_sfunc): Rewrite.
	(set_target_wide_charset_sfunc): New function.
	(show_charset): Print target wide character set.
	(host_charset, target_charset): Rewrite.
	(target_wide_charset): New function.
	(c_target_char_has_backslash_escape): Remove.
	(c_parse_backslash): Remove.
	(host_letter_to_control_character): New function.
	(host_char_print_literally): Remove.
	(host_hex_value): New function.
	(target_char_to_control_char): Remove.
	(cleanup_iconv): New function.
	(convert_between_encodings): New function.
	(target_char_to_host): Remove.
	(struct wchar_iterator): Define.
	(make_wchar_iterator, make_cleanup_wchar_iterator, wchar_iterator,
	wchar_push_back): New functions.
	(do_cleanup_iterator): New function.
	(char_ptr): New typedef.
	(charsets): New global.
	(add_one, find_charset_names): New functions.
	(default_charset_names): New global.
	(auto_host_charset_name): Likewise.
	* aclocal.m4, config.in, configure: Rebuild.
	* configure.ac: Call AM_LANGINFO_CODESET.
	(GDB_DEFAULT_HOST_CHARSET): Default to UTF-8.
	(AM_ICONV): Invoke earlier.
	* acinclude.m4: Include codeset.m4.  Subst LIBICONV_INCLUDE and
	LIBICONV_LIBDIR.  Check for libiconv in build tree.
	* Makefile.in (LIBICONV_LIBDIR, LIBICONV_INCLUDE): New macros.
	(INTERNAL_CFLAGS_BASE): Add LIBICONV_INCLUDE.
	(INTERNAL_LDFLAGS): Add LIBICONV_LIBDIR.
	* gdb_obstack.h (obstack_grow_wstr): New define.
        * gdb_wchar.h: New file.
        * defs.h: Include it.
gdb/testsuite:
	* gdb.base/store.exp: Update for change to escape output.
	* gdb.base/callfuncs.exp (fetch_all_registers): Update for change
	to escape output.
	* gdb.base/pointers.exp: Update for change to escape output.
	* gdb.base/long_long.exp (gdb_test_long_long): Update for change
	to escape output.
	* gdb.base/constvars.exp (do_constvar_tests): Update for change to
	escape output.
	* gdb.base/call-rt-st.exp (print_struct_call): Update for change
	to escape output.
	* gdb.cp/ref-types.exp (gdb_start_again): Update for change to
	escape output.
	* gdb.base/setvar.exp: Update for change to escape output.
	* lib/gdb.exp (default_gdb_start): Set LC_CTYPE to C.
	* gdb.base/printcmds.exp (test_print_all_chars): Update for change
	to escape output.
	(test_print_string_constants): Likewise.
	* gdb.base/charset.exp (valid_host_charset): Check size of
	wchar_t.  Handle UCS-2 and UCS-4.  Add tests for wide and unicode
	cases.  Handle "auto"-related output.
	* gdb.base/charset.c (char16_t, char32_t): New typedefs.
	(uvar, Uvar): New globals.
gdb/doc:
	* gdb.texinfo (Character Sets): Remove obsolete text.  Document
	set target-wide-charset.
	(Requirements): Mention iconv.
@
text
@d257 2
a258 4
	  CORE_ADDR addr2 = VALUE_ADDRESS (v2);
	  addr2 -= (VALUE_ADDRESS (v)
		    + value_offset (v)
		    + value_embedded_offset (v));
d511 1
a511 2
    return value_at_lazy (type, 
			  VALUE_ADDRESS (arg2) + value_offset (arg2));
d593 1
a593 1
  VALUE_ADDRESS (val) = addr;
d611 1
a611 1
  VALUE_ADDRESS (val) = addr;
d637 1
a637 1
      CORE_ADDR addr = VALUE_ADDRESS (val) + value_offset (val);
d709 1
a709 1
				    paddr_nz (VALUE_ADDRESS (new_val)));
d813 1
a813 2
	    read_memory (VALUE_ADDRESS (toval) + value_offset (toval),
			 buffer, changed_len);
d816 1
a816 1
	    changed_addr = VALUE_ADDRESS (toval) + value_offset (toval);
d821 1
a821 1
	    changed_addr = VALUE_ADDRESS (toval) + value_offset (toval);
d984 1
a984 1
  read_memory (VALUE_ADDRESS (arg1) + value_offset (arg1),
d988 1
a988 1
  VALUE_ADDRESS (val) = VALUE_ADDRESS (arg1) + value_offset (arg1);
d1038 1
a1038 1
      CORE_ADDR addr = VALUE_ADDRESS (val);
d1154 1
a1154 1
			     (VALUE_ADDRESS (arg1) + value_offset (arg1)));
d1169 1
a1169 1
			       (VALUE_ADDRESS (arg1) + value_offset (arg1)));
d1204 1
a1204 2
			     (VALUE_ADDRESS (arg1)
			      + value_offset (arg1)
d1616 1
a1616 2
				      VALUE_ADDRESS (arg1)
				      + value_offset (arg1) + offset);
d1630 1
a1630 2
	      base_addr = 
		VALUE_ADDRESS (arg1) + value_offset (arg1) + boffset;
d1636 1
a1636 1
	      VALUE_ADDRESS (v2) = base_addr;
d1759 1
a1759 2
	      if (target_read_memory (VALUE_ADDRESS (*arg1p)
				      + value_offset (*arg1p) + offset,
d1768 1
a1768 2
					  VALUE_ADDRESS (*arg1p)
					  + value_offset (*arg1p) + offset);
d1977 1
a1977 1
					  VALUE_ADDRESS (*argp) + base_offset);
d2737 1
a2737 1
					 VALUE_ADDRESS (v), 0);
d2896 1
a2896 1
  new_val = value_at_lazy (real_type, VALUE_ADDRESS (argp) - top +
@


1.209
log
@gdb/
2009-02-06  Jim Blandy  <jimb@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Vladimir Prus  <vladimir@@codesourcery.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	* defs.h (enum lval_type): New value: lval_computed.
	* value.h (struct lval_funcs): New type.
	(allocate_computed_value, value_computed_funcs)
	(value_computed_closure): New declarations.
	* value.c (struct value): Add a structure to the location union
	for computed lvalues, containing 'funcs' and 'closure' members.
	(allocate_computed_value, value_computed_funcs)
	(value_computed_closure): New functions.
	(value_free): For computed lvalues, call the closure's
	'free_closure' function before freeing the value itself.
	(value_copy): If we're copying an lval_computed value, call the
	closure's 'copy_closure' function.
	(set_value_component_location): If the original value is a
	computed lvalue, then call the closure's 'copy_closure' function.
	(value_of_internalvar): If an internal variable's value is a
	computed lvalue, make retrieving its value produce an equivalent
	computed lvalue.
	* valops.c (value_fetch_lazy): Unlazy computed lvalues by calling
	their read function.
	(value_assign): Assign to computed lvalues by calling their write
	function.

gdb/doc/
2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	* gdbint.texinfo (Values): New chapter.
@
text
@d1355 18
@


1.208
log
@gdb
	PR exp/9059:
	* valops.c (find_overload_match): Follow typedefs before taking
	address of object argument.
gdb/testsuite
	PR exp/9059:
	* gdb.cp/call-c.exp: Add regression test.
	* gdb.cp/call-c.cc (FooHandle): New typedef.
	(main): New variable 'handle'.
@
text
@d730 2
d900 9
a908 1
      
@


1.207
log
@	* value.h (address_of_variable): Add prototype.
	(locate_var_value): Remove prototype.

	* findvar.c (read_var_value): Do not attempt to default frame
	to selected frame.
	(locate_var_value): Remove function.
	* valops.c (value_of_variable): Retrieve selected frame for
	symbols that require a frame when called with NULL block.
	* valops.c (address_of_variable): New function.

	* eval.c (evaluate_subexp_for_address): Call address_of_variable
	instead of calling locate_var_value.
	(evaluate_subexp_with_coercion): Likewise.
@
text
@d2176 5
a2180 3
      if (TYPE_CODE (value_type (temp)) != TYPE_CODE_PTR
	  && (TYPE_CODE (value_type (*objp)) == TYPE_CODE_PTR
	      || TYPE_CODE (value_type (*objp)) == TYPE_CODE_REF))
@


1.206
log
@2009-01-13  Jim Blandy  <jimb@@codesourcery.com>

	Abstract out common code for copying value locations.

	* value.h (set_value_component_location): New declaration.
	* value.c (set_value_component_location): New function.
	(value_primitive_field): Use it.
	* valarith.c (value_subscript, value_subscripted_rvalue): Same.
	* valops.c (search_struct_field, value_slice): Same.
	* ada-lang.c (coerce_unspec_val_to_type)
	(ada_value_primitive_packed_val): Same.
@
text
@d991 1
a991 1
  struct frame_info *frame = NULL;
d993 5
a997 3
  if (!b)
    frame = NULL;		/* Use selected frame.  */
  else if (symbol_read_needs_frame (var))
d1018 48
@


1.205
log
@        Updated copyright notices for most files.
@
text
@d1578 1
a1578 2
	      VALUE_LVAL (v2) = VALUE_LVAL (arg1);
	      VALUE_ADDRESS (v2) = VALUE_ADDRESS (arg1);
d2986 1
a2986 6
      if (VALUE_LVAL (array) == lval_internalvar)
	VALUE_LVAL (slice) = lval_internalvar_component;
      else
	VALUE_LVAL (slice) = VALUE_LVAL (array);

      VALUE_ADDRESS (slice) = VALUE_ADDRESS (array);
@


1.204
log
@        * valops.c (find_method_list): Minor reformatting in comment.
@
text
@d5 1
a5 1
   2008 Free Software Foundation, Inc.
@


1.203
log
@	* value.h (allocate_value_lazy): New function declaration.
	(value_free): Remove macro, make it a function.
	* value.c (value): Move actual content outside of the memory space
	of the struct; add a pointer to this actual content.
	(allocate_value_lazy, allocate_value_contents): New function.
	(allocate_value): Reimplement using these two new functions.
	(value_contents_raw, value_contents_all_raw): If no memory
	has been allocated yet for the actual content, allocate it.
	(value_contents_all): Resync with struct value's changes.
	(value_free): New function.
	(value_copy, value_primitive_field): Use new function
	allocate_value_lazy to allocate lazy values.
	(value_change_enclosing_type): Resync with struct value's changes.
	As the value is not reallocated, remove the special handling for
	the value chain (now obsolete).
	* valops.c (value_at_lazy): Use new function allocate_value_lazy.
	(value_fetch_lazy): Allocate value content. Use allocate_value_lazy
	to allocate lazy values.
	(value_slice): Use allocate_value_lazy to allocate lazy values.
@
text
@d1854 1
a1854 1
   specified method. Return the pointer to the fn_field list of
@


1.202
log
@	Convert static_kind into loc_kind enum.
	* gdbtypes.h (enum field_loc_kind): New.
	(union field_location): New field dwarf_block.
	(struct field): Rename static_kind as loc_kind.
	(FIELD_STATIC_KIND): Rename to ...
	(FIELD_LOC_KIND): ... here.
	(TYPE_FIELD_STATIC_KIND): Rename to ...
	(TYPE_FIELD_LOC_KIND): ... here and use there now new FIELD_LOC_KIND.
	(TYPE_FIELD_STATIC_HAS_ADDR): Remove.
	(TYPE_FIELD_STATIC): Remove.
	(TYPE_FIELD_BITPOS): Reformat.
	(SET_FIELD_BITPOS): New.
	(FIELD_PHYSADDR): Rename to ...
	(FIELD_STATIC_PHYSADDR): ... here.
	(TYPE_FIELD_STATIC_PHYSADDR): Follow the FIELD_PHYSADDR rename.
	(SET_FIELD_PHYSADDR): Use new FIELD_LOC_KIND.
	(FIELD_PHYSNAME): Rename to ...
	(FIELD_STATIC_PHYSNAME): ... here.
	(TYPE_FIELD_STATIC_PHYSNAME): Follow the FIELD_PHYSNAME rename.
	(SET_FIELD_PHYSNAME): Use new FIELD_LOC_KIND.
	(FIELD_DWARF_BLOCK, TYPE_FIELD_DWARF_BLOCK, SET_FIELD_DWARF_BLOCK): New.
	(field_is_static): New declaration.
	* gdbtypes.c (field_is_static): New function.
	(copy_type_recursive): Update throughout.
	* amd64-tdep.c, c-typeprint.c, coffread.c, cp-valprint.c, dwarf2read.c,
	eval.c, jv-typeprint.c, jv-valprint.c, mdebugread.c, p-typeprint.c,
	p-valprint.c, valops.c, value.c, varobj.c: Update throughout.
@
text
@d611 1
a611 1
  val = allocate_value (type);
a614 1
  set_value_lazy (val, 1);
d636 2
d1539 1
a1539 1
	  struct value *v2 = allocate_value (basetype);
d1557 1
d1569 9
a1581 6
	      if (VALUE_LVAL (arg1) == lval_memory && value_lazy (arg1))
		set_value_lazy (v2, 1);
	      else
		memcpy (value_contents_raw (v2),
			value_contents_raw (arg1) + boffset,
			TYPE_LENGTH (basetype));
a2976 1
      slice = allocate_value (slice_type);
d2978 1
a2978 1
	set_value_lazy (slice, 1);
d2980 6
a2985 3
	memcpy (value_contents_writeable (slice),
		value_contents (array) + offset,
		TYPE_LENGTH (slice_type));
@


1.201
log
@gdb/
	Replace TYPE_ARRAY_{UPPER,LOWER}_BOUND_TYPE by a bit if {un,}defined.
	* c-typeprint.c (c_type_print_varspec_suffix), m2-typeprint.c
	(m2_array), p-typeprint.c (pascal_type_print_varspec_prefix),
	valops.c (value_cast), varobj.c (c_number_of_children): Replace
	TYPE_ARRAY_UPPER_BOUND_TYPE compared to BOUND_CANNOT_BE_DETERMINED by
	TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
	* parse.c (follow_types): Use TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
	* f-valprint.c (f77_get_dynamic_upperbound): Replace with ...
	(f77_get_upperbound): ... this function handling now only
	TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
	(f77_get_dynamic_lowerbound): Replace with ...
	(f77_get_lowerbound): ... this function handling now only
	TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED.
	(f77_get_dynamic_length_of_aggregate, f77_create_arrayprint_offset_tbl):
	Update their callers.
	* eval.c (evaluate_subexp_standard): Update their callers.
	* f-lang.h (f77_get_dynamic_upperbound, f77_get_upperbound)
	(f77_get_dynamic_lowerbound, f77_get_lowerbound): Update their
	prototypes.
	(BOUND_FETCH_OK, BOUND_FETCH_ERROR): Remove.
	* f-typeprint.c (f_type_print_varspec_suffix, f_type_print_base): Remove
	the lower_bound_was_default variable.  Update the
	f77_get_dynamic_upperbound, f77_get_upperbound and
	TYPE_ARRAY_UPPER_BOUND_TYPE calls.
	* gdbtypes.c (print_bound_type): Remove the function.
	(recursive_dump_type): Remove its calls printing UPPER_BOUND_TYPE and
	LOWER_BOUND_TYPE.
	* gdbtypes.h (enum array_bound_type): Remove.
	(struct main_type): Remove the fields upper_bound_type and
	lower_bound_type.  Comment the new overload of the field artificial.
	(TYPE_ARRAY_UPPER_BOUND_TYPE): Replace by ...
	(TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED): ... this macro.
	(TYPE_ARRAY_LOWER_BOUND_TYPE): Replace by ...
	(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED): ... this macro.

gdb/testsuite/
	* gdb.base/maint.exp (maint print type): Remove printing
	UPPER_BOUND_TYPE and LOWER_BOUND_TYPE.
@
text
@d1462 1
a1462 1
	    if (TYPE_FIELD_STATIC (type, i))
d2543 1
a2543 1
	  if (TYPE_FIELD_STATIC (t, i))
@


1.200
log
@	* valops.c: Include "objfiles.h" and "symtab.h".
	(find_function_in_inferior): New argument OBJF_P.  Use it to return
	objfile where function is defined.  Use per-objfile arch types
	instead of builtin_type_ to define default return type.

	* linux-fork.c (checkpoint_command): Update calls.  Use per-objfile
	architecture to define inferior call argument types.
	* gcore.c (derive_heap_segment): Likewise.
	* objc-lang.c (value_nsstring): Likewise.
	* scm-lang.c (scm_lookup_name): Likewise.
	* scm-valprint.c (scm_inferior_print): Likewise.
	* valops.c (value_allocate_space_in_inferior): Likewise.

	* eval.c (evaluate_subexp_standard): Update calls.
	* objc-lang.c (lookup_objc_class, print_object_command): Likewise.

	* linux-fork.c: Include "objfiles.h".
	* scm-lang.c: Include "objfiles.h".
	* scm-valprint.c: Include "objfiles.h".
@
text
@d364 1
a364 2
      if (element_length > 0
	&& TYPE_ARRAY_UPPER_BOUND_TYPE (type) == BOUND_CANNOT_BE_DETERMINED)
@


1.199
log
@ChangeLog:

	* gdbarch.sh (name_of_malloc): Remove.
	* gdbarch.c, gdbarch.h: Re-generate.
	* valops.c (value_allocate_space_in_inferior): Do not call
	gdbarch_name_of_malloc.

doc/ChangeLog:

	* gdbint.texinfo (Target Conditionals): Remove documentation
	for gdbarch_name_of_malloc.
@
text
@d47 2
d127 3
a129 1
/* Find the address of function name NAME in the inferior.  */
d132 1
a132 1
find_function_in_inferior (const char *name)
d143 4
d155 3
d160 1
a160 1
	  type = lookup_pointer_type (builtin_type_char);
d164 4
d187 3
a190 1
  struct value *val = find_function_in_inferior ("malloc");
d192 1
a192 1
  blocklen = value_from_longest (builtin_type_int, (LONGEST) len);
@


1.198
log
@	* cp-abi.h (cplus_method_ptr_size): Add TO_TYPE parameter.
	(cplus_make_method_ptr): Add TYPE parameter.
	* cp-abi.c (cplus_method_ptr_size): Add TO_TYPE parameter.  Pass it
	on to current_cp_abi.method_ptr_size callback.
	(cplus_make_method_ptr): Add TYPE parameter.  Pass it on to
	current_cp_abi.make_method_ptr callback.

	* gdbtypes.c (lookup_methodptr_type): Pass target type
	argument to cplus_method_ptr_size.
	* valops.c (value_cast): Pass type argument to cplus_make_method_ptr.
	(value_struct_elt_for_reference): Likewise.

	* gnu-v3-abi.c (get_class_arch): New function.
	(vtable_address_point_offset): Add GDBARCH parameter.  Use it
	instead of current_gdbarch.  Update all callers.
	(gnuv3_get_vtable): Likewise.
	(gnuv3_get_virtual_fn): Likewise.
	(gnuv3_decode_method_ptr): Likewise.
	(gnuv3_rtti_type): Call get_class_arch to determine architecture.
	Use it instead of current_gdbarch.
	(gnuv3_virtual_fn_field): Likewise.
	(gnuv3_baseclass_offset): Likewise.
	(gnuv3_print_method_ptr): Likewise.
	(gnuv3_method_ptr_to_value): Likewise.
	(gnuv3_method_ptr_size): Add TYPE parameter.  Use it to determine
	class architecture.  Use architecture types instead of builtin types.
	(gnuv3_make_method_ptr): Likewise.

	* cp-valprint.c (cp_print_class_member): Expect pointer type
	instead of class type.  Use its length when extracting value.
	* c-valprint.c (c_val_print): Update call to cp_print_class_member.
@
text
@d173 1
a173 2
  struct value *val = 
    find_function_in_inferior (gdbarch_name_of_malloc (current_gdbarch));
@


1.197
log
@	* ada-lang.c (ada_coerce_to_simple_array_type): Use builtin_type_int32
	instead of builtin_type_int as default unspecified integral type.
	(ada_index_type, ada_array_bound_from_type, ada_variant_discrim_type,
	assign_component, to_fixed_range_type): Likewise.
	* ada-typeprint.c (print_range, print_range_bound,
	print_range_type_named): Likewise.
	* ada-valprint.c (print_optional_low_bound, ada_val_print_1): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* gnu-v2-abi.c (gnuv2_virtual_fn_field): Likewise.
	* gnu-v3-abi.c (gnuv3_get_virtual_fn, gnuv3_baseclass_offset,
	build_gdb_vtable_type): Likewise.
	* jv-lang.c (java_array_type): Likewise.
	* m2-typeprint.c (m2_print_bounds, m2_is_long_set_of_type): Likewise.
	* m2-valprint.c (m2_print_long_set): Likewise.
	* parse.c (follow_types): Likewise.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* valops.c (value_one, value_array, value_string,
	value_bitstring): Likewise.
	* value.c (allocate_repeat_value, value_from_string): Likewise.
	* varobj.c (c_describe_child): Likewise.
	* mt-tdep.c (mt_register_type): Likewise.
	* sh-tdep.c (sh_sh4_build_float_register_type): Likewise.
	* sh64-tdep.c (sh64_build_float_register_type): Likewise.
@
text
@d476 1
a476 1
      cplus_make_method_ptr (value_contents_writeable (result), 0, 0);
d2621 2
a2622 1
		  cplus_make_method_ptr (value_contents_writeable (result),
d2645 2
a2646 1
		  cplus_make_method_ptr (value_contents_writeable (result),
@


1.196
log
@	* valops.c (value_ind): No longer allow dereferencing an
	integer type.
	* eval.c (evaluate_subexp_standard): Handle deferencing an
	integer type here.
	* ada-lang.c (ada_evaluate_subexp): Likewise.
@
text
@d532 1
a532 1
      struct value *int_one = value_from_longest (builtin_type_int, 1);
d536 1
a536 1
      decimal_from_integral (int_one, v, TYPE_LENGTH (builtin_type_int));
d1250 1
a1250 1
				 builtin_type_int,
d1294 1
a1294 1
					      builtin_type_int,
d1324 1
a1324 1
						builtin_type_int,
@


1.195
log
@	* valops.c (value_cast_structs): Return NULL for failure.
	(value_cast): Handle NULL from value_cast_structs.
	(value_fetch_lazy): Call check_typedef.  Remove unused variable.

	testsuite/
	* gdb.base/structs3.c, gdb.base/structs3.exp: New files.
@
text
@d1175 1
a1175 8
  /* Allow * on an integer so we can cast it to whatever we want.
     This returns an int, which seems like the most C-like thing to
     do.  "long long" variables are rare enough that
     BUILTIN_TYPE_LONGEST would seem to be a mistake.  */
  if (TYPE_CODE (base_type) == TYPE_CODE_INT)
    return value_at_lazy (builtin_type_int,
			  (CORE_ADDR) value_as_address (arg1));
  else if (TYPE_CODE (base_type) == TYPE_CODE_PTR)
@


1.194
log
@	* frame.h (frame_map_regnum_to_name): Remove prototype.
	(frame_map_name_to_regnum): Remove prototype.
	* frame.c (frame_map_regnum_to_name): Remove.
	(frame_map_name_to_regnum): Remove.
	(frame_unwind_register_value): Use user_reg_map_regnum_to_name
	instead of frame_map_regnum_to_name.
	* ax-gdb.c: Include "user-regs.h".
	(gen_expr): Use user_reg_map_name_to_regnum instead of
	frame_map_name_to_regnum.
	* eval.c:  Include "user-regs.h".
	(evaluate_subexp_standard): Use user_reg_map_name_to_regnum
	instead of frame_map_name_to_regnum.
	* infcmd.c (registers_info): Likewise.
	* parse.c: Include "user-regs.h".
	(write_dollar_variable): Use user_reg_map_name_to_regnum
	instead of frame_map_name_to_regnum.
	* tracepoint.c: Include "user-regs.h".
	(encode_actions): Use user_reg_map_name_to_regnum
	instead of frame_map_name_to_regnum.
	* valops.c: Include "user-regs.h".
	(value_fetch_lazy): Use user_reg_map_regnum_to_name instead
	of frame_map_regnum_to_name.
@
text
@d196 2
a197 1
   for this to work. Typedef to one of the codes is permitted.  */
d248 2
a249 1
  return v2;
d402 6
a407 1
    return value_cast_structs (type, arg2);
d625 1
a625 1
      int length = TYPE_LENGTH (value_enclosing_type (val));
a626 1
      struct type *type = value_type (val);
@


1.193
log
@gdb:
	PR gdb/1158:
	* valops.c (value_struct_elt): Treat function-valued field as a
	static method.
gdb/testsuite:
	* gdb.base/callfuncs.c (struct struct_with_fnptr): New struct.
	(function_struct, function_struct_ptr): New globals.
	* gdb.base/callfuncs.exp (do_function_calls): Test calling via a
	function pointer in a struct.
@
text
@d40 1
d667 1
d670 1
d675 1
a675 1
			      frame_map_regnum_to_name (frame, regnum));
d696 1
a696 3
	      for (i = 0;
		   i < register_size (get_frame_arch (frame), regnum);
		   i++)
@


1.192
log
@* valops.c (value_cast_pointers): Follow typedefs when checking
result of coercion.
@
text
@d1822 4
@


1.191
log
@2008-06-06  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	PR gdb/1147
	* gdb/valopts.c (find_overload_match): Handle references
	to pointers.
@
text
@d271 1
a271 1
      gdb_assert (TYPE_CODE (value_type (v2)) == TYPE_CODE_STRUCT
@


1.190
log
@	* symtab.h (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	* symtab.c (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	(search_symbols): Update.

	* linespec.c (find_methods, collect_methods): Update.
	(add_matching_methods, add_constructors): Update.
	(decode_compound, decode_dollar, decode_variable): Update.
	(lookup_prefix_sym): Update.

	(symbol_found): Remove SYM_SYMTAB parameter.
	Use SYMBOL_SYMTAB (sym) instead.

	* gdbtypes.c (lookup_typename): Update.
	(lookup_struct, lookup_union, lookup_enum): Update.
	(lookup_template_type): Update.
	(check_typedef): Update.
	* language.c (lang_bool_type): Update.
	* mdebugread.c (parse_procedure): Update.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* parse.c (write_dollar_variable): Update.
	* printcmd.c (address_info): Update.
	* source.c (select_source_symtab): Update.
	* stack.c (print_frame_args, print_frame_arg_vars): Update.
	* valops.c (find_function_in_inferior): Update.
	(value_struct_elt_for_reference): Update.
	* value.c (value_static_field, value_fn_field): Update.

	* alpha-mdebug-tdep.c (find_proc_desc): Update.
	* arm-tdep.c (arm_skip_prologue): Update.
	* mt-tdep.c (mt_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Update.

	* ada-lang.h (struct ada_symbol_info): Remove SYMTAB member.
	* ada-lang.c (ada_add_block_symbols): Remove SYMTAB parameter.
	(add_defn_to_vec): Likewise.
	(ada_add_block_symbols): Likewise.
	(lookup_cached_symbol, cache_symbol): Likewise.
	(standard_lookup): Update.
	(ada_lookup_symbol_list): Update.

	* c-valprint.c (c_val_print): Update.
	* cp-support.c (cp_lookup_rtti_type): Update.
	* jv-lang.c (java_lookup_class, get_java_object_type): Update.
	* objc-lang.c (lookup_struct_typedef, find_imps): Update.
	* p-valprint.c (pascal_val_print): Update.
	* scm-lang.c (scm_lookup_name): Update.

	* c-exp.y: Update.
	* f-exp.y: Update.
	* jv-exp.y: Update.
	* m2-exp.y: Update.
	* objc-exp.y: Update.
	* p-exp.y: Update.
@
text
@d2104 2
a2105 1
	  && TYPE_CODE (value_type (*objp)) == TYPE_CODE_PTR)
@


1.189
log
@	* language.h (struct language_defn): Remove SYMTAB parameter from
	la_lookup_symbol_nonlocal callback function pointer.

	* ada-lang.h (ada_lookup_encoded_symbol): Remove SYMTAB parameter.
	(ada_lookup_encoded_symbol): Likewise.
	* ada-lang.c (ada_lookup_encoded_symbol): Remove SYMTAB parameter.
	Always call fixup_symbol_section.
	(ada_lookup_symbol): Remove SYMTAB parameter.
	(ada_lookup_symbol_nonlocal): Likewise.
	* ada-exp.y (write_object_renaming): Update.
	(find_primitive_type): Likewise.

	* cp-support.h (cp_lookup_symbol_nonlocal): Remove SYMTAB parameter.
	(cp_lookup_symbol_namespace): Likewise.
	* cp-namespace.c (lookup_namespace_scope): Remove SYMTAB parameter.
	(lookup_symbol_file): Likewise.
	(lookup_possible_namespace_symbol): Likewise.
	(cp_lookup_symbol_nonlocal): Likewise.
	(cp_lookup_symbol_namespace): Likewise.
	(cp_lookup_nested_type): Update.

	* scm-valprint.c (scm_inferior_print): Update.
	* valops.c (value_maybe_namespace_elt): Update.

	* solist.h (struct target_so_ops): Remove SYMTAB parameter from
	lookup_lib_global_symbol callback function pointer.
	(solib_global_lookup): Remove SYMTAB parameter.
	* solib.c (solib_global_lookup): Remove SYMTAB parameter.
	* solib-svr4.c (elf_lookup_lib_symbol): Likewise.

	* symtab.h (basic_lookup_symbol_nonlocal): Remove SYMTAB parameter.
	(lookup_symbol_static): Likewise.
	(lookup_symbol_global): Likewise.
	(lookup_symbol_aux_block): Likewise.
	(lookup_global_symbol_from_objfile): Likewise.
	* symtab.c (lookup_symbol_aux): Remove SYMTAB parameter.
	(lookup_symbol_aux_local): Likewise.
	(lookup_symbol_aux_block): Likewise.
	(lookup_symbol_aux_symtabs): Likewise.
	(lookup_symbol_aux_psymtabs): Likewise.
	(lookup_global_symbol_from_objfile): Likewise.
	(basic_lookup_symbol_nonlocal): Likewise.
	(lookup_symbol_static): Likewise.
	(lookup_symbol_global): Likewise.

	(lookup_symbol_in_language): Do not pass SYMTAB to lookup_symbol_aux.
@
text
@d130 1
a130 1
  sym = lookup_symbol (name, 0, VAR_DOMAIN, 0, NULL);
d2600 1
a2600 1
			       0, VAR_DOMAIN, 0, NULL);
d2629 1
a2629 1
			       0, VAR_DOMAIN, 0, NULL);
@


1.188
log
@	Convert frame unwinders to use the current frame and
	"struct value".

	* frame.c (frame_debug): Make global.
	(get_frame_id): Pass this frame to unwinder routines.
	(frame_pc_unwind): Remove unused unwind->prev_pc support.
	(do_frame_register_read): Do not discard the return value of
	frame_register_read.
	(frame_register_unwind): Remove debug messages.  Use
	frame_unwind_register_value.
	(frame_unwind_register_value, get_frame_register_value): New
	functions.
	(create_new_frame, get_frame_base_address, get_frame_locals_address)
	(get_frame_args_address, get_frame_type): Pass this frame to
	unwinder routines.
	(frame_cleanup_after_sniffer, frame_prepare_for_sniffer): New
	functions.
	* frame.h: Update comments.
	(frame_debug, frame_unwind_register_value, get_frame_register_value)
	(frame_prepare_for_sniffer): Declare.
	* frame-unwind.h: Update comments and parameter names.
	(default_frame_sniffer): Declare.
	(frame_prev_register_ftype): Return a struct value *.
	(struct frame_unwind): Remove prev_pc member.
	(frame_unwind_sniffer_ftype, frame_unwind_append_sniffer): Delete.
	(frame_unwind_append_unwinder, frame_unwind_got_optimized)
	(frame_unwind_got_register, frame_unwind_got_memory)
	(frame_unwind_got_constant, frame_unwind_got_address): Declare.
	* frame-base.h: Update comments and parameter names.
	* valops.c (value_fetch_lazy): Use get_frame_register_value.  Iterate
	if necessary.  Add debugging output.
	* sentinel-frame.c (sentinel_frame_prev_register)
	(sentinel_frame_this_id): Update for new signature.
	(sentinel_frame_prev_pc): Delete.
	(sentinel_frame_unwinder): Remove prev_pc.
	* ia64-tdep.c (ia64_libunwind_frame_unwind): Do not initialize
	prev_pc.
	* libunwind-frame.c (libunwind_frame_unwind): Likewise.
	* frame-unwind.c (struct frame_unwind_table_entry): Remove sniffer.
	(frame_unwind_append_sniffer): Delete.
	(frame_unwind_append_unwinder): New function.
	(frame_unwind_find_by_frame): Take this frame.  Only use sniffers
	from unwinders.  Use frame_prepare_for_sniffer.
	(default_frame_sniffer, frame_unwind_got_optimized)
	(frame_unwind_got_register, frame_unwind_got_memory)
	(frame_unwind_got_constant, frame_unwind_got_address): New functions.
	* dummy-frame.c (dummy_frame_sniffer): Use gdbarch_dummy_id.
	(dummy_frame_prev_register, dummy_frame_this_id): Update for new
	signature.
	* gdbarch.sh: Replace unwind_dummy_id with dummy_id.
	* gdbarch.c, gdbarch.c: Regenerated.
	* frame-base.c (default_frame_base_address)
	(default_frame_locals_address, default_frame_args_address): Update
	for new signature.
	(frame_base_find_by_frame): Pass this frame to unwinder routines.
	* infcall.c (call_function_by_hand): Update comments.
	* Makefile.in (frame-unwind.o): Update dependencies.

	* gdbint.texinfo (Stack Frames): New chapter.
	(Algorithms): Move Frames text to the new chapter.
	(Target Conditionals): Delete SAVE_DUMMY_FRAME_TOS.  Document
	gdbarch_dummy_id instead of gdbarch_unwind_dummy_id.
@
text
@d2708 1
a2708 1
				    VAR_DOMAIN, NULL);
@


1.187
log
@	* ada-lang.c (ada_value_primitive_packed_val): Only check
	value_lazy for memory lvals.
	* findvar.c (value_of_register_lazy): New function.
	(locate_var_value): Only check value_lazy for memory lvals.
	* valarith.c (value_subscripted_rvalue): Likewise.
	* valops.c (value_fetch_lazy): Handle both memory and register
	lvals.
	(search_struct_field, value_slice): Only check value_lazy for memory
	lvals.
	* value.c (struct value): Update comment for lazy.
	(value_primitive_field): Only check value_lazy for memory lvals.
	* value.h (value_lazy): Update comment.
	(value_of_register_lazy): Declare.
@
text
@d625 2
a626 2
      struct frame_info *frame = frame_find_by_id (VALUE_FRAME_ID (val));
      int regnum = VALUE_REGNUM (val);
d628 1
d630 3
a632 1
      gdb_assert (frame != NULL);
d634 25
a658 11
      /* Convertible register routines are used for multi-register
	 values and for interpretation in different types (e.g. float
	 or int from a double register).  Lazy register values should
	 have the register's natural type, so they do not apply.  */
      gdb_assert (!gdbarch_convert_register_p (get_frame_arch (frame), regnum,
					       type));

      /* Get the data.  */
      if (!get_frame_register_bytes (frame, regnum, value_offset (val),
				     TYPE_LENGTH (value_type (val)),
				     value_contents_raw (val)))
d660 46
@


1.186
log
@	Fix breakpoint condition that use member variables.
        * valops.c (check_field): Remove.
        (check_field_in): Rename to check_field.
        (value_of_this): Use la_name_of_this.
        * value.h (check_field): Adjust prototype.

        * language.h (la_value_of_this): Rename to la_name_of_this.
        * language.c (unknown_language_defn): Specify "this" for
        name_of_this.
        (auto_language_defn): Likewise.
        (local_language_defn): Likewise.
        * ada-lang.c (ada_language_defn): Adjust comment.
        * c-lang.c (c_language_defn): Adjust comment.
        (cplus_language_defn): Specify "this" for name_of_this.
        (asm_language_defn): Adjust comment.
        (minimal_language_defn): Adjust comment.
        * f-lang.c (f_language_defn): Specify NULL for name_of_this.
        * jv-lang.c (java_language_defn): Specify "this" for name_of_this.
        * m2-lang.c (m2_language_defn): Specify "this" for name_of_this.
        * objc-lang.c (objc_language_defn): Specify "self" for
        name_of_this.
        * p-lang.c (pascal_language_defn): Specify "this" for
        name_of_this.
        * scm-lang.c (scm_language_defn): Specify NULL for name_of_this.

        * symtab.c (lookup_symbol_aux): Lookup "this" in the
        proper scope, and check for field in type of "this", without
        trying to create a value.
@
text
@d614 4
a617 2
  CORE_ADDR addr = VALUE_ADDRESS (val) + value_offset (val);
  int length = TYPE_LENGTH (value_enclosing_type (val));
d619 27
a645 3
  struct type *type = value_type (val);
  if (length)
    read_memory (addr, value_contents_all_raw (val), length);
d1493 1
a1493 1
	      if (value_lazy (arg1))
d2888 1
a2888 1
      if (value_lazy (array))
@


1.185
log
@	* valops.c (value_cast_structs): New function. Cast related
	STRUCT types up/down and return cast value. The body of this
	function comes mostly from value_cast_pointers.
	(value_cast_pointers): Code for actual cast STRUCT-STRUCT moved
	to value_cast_structs. Now value_cast_pointers needs only create
	appropriate reference after using value_cast_structs for actual
	casting.
	(value_cast): Handle references.
@
text
@a82 2
static int check_field_in (struct type *, const char *);

d2339 1
a2339 1
/* Helper function for check_field: Given TYPE, a structure/union,
d2343 2
a2344 2
static int
check_field_in (struct type *type, const char *name)
d2373 1
a2373 1
    if (check_field_in (TYPE_BASECLASS (type, i), name))
a2378 32

/* C++: Given ARG1, a value of type (pointer to a)* structure/union,
   return 1 if the component named NAME from the ultimate target
   structure/union is defined, otherwise, return 0.  */

int
check_field (struct value *arg1, const char *name)
{
  struct type *t;

  arg1 = coerce_array (arg1);

  t = value_type (arg1);

  /* Follow pointers until we get to a non-pointer.  */

  for (;;)
    {
      CHECK_TYPEDEF (t);
      if (TYPE_CODE (t) != TYPE_CODE_PTR 
	  && TYPE_CODE (t) != TYPE_CODE_REF)
	break;
      t = TYPE_TARGET_TYPE (t);
    }

  if (TYPE_CODE (t) != TYPE_CODE_STRUCT
      && TYPE_CODE (t) != TYPE_CODE_UNION)
    error (_("Internal error: `this' is not an aggregate"));

  return check_field_in (t, name);
}

d2784 3
a2786 4
  if (current_language->la_language == language_objc)
    return value_of_local ("self", complain);
  else
    return value_of_local ("this", complain);
@


1.184
log
@	* eval.c (evaluate_subexp_for_address): Clarify error message.
	Use value_must_coerce_to_target.
	* infcall.c (value_arg_coerce): Call value_coerce_to_target.
	* valops.c (value_assign): Call value_coerce_to_target when
	assigning to anything but internalvars.  Leave GDB-side arrays
	as arrays when assigning to internalvars.
	(value_must_coerce_to_target, value_coerce_to_target): New.
	(value_coerce_array, value_addr): Call value_coerce_to_target.
	(value_array): Create the array in GDB's memory instead of
	the inferior's.
	* value.h (value_must_coerce_to_target, value_coerce_to_target):
	Declare.

	* gdb.texinfo (Expressions): Update description of malloced arrays.

	* gdb.base/printcmds.exp (test_print_array_constants): Do not expect
	*& to work on created array elements.
	(Top level): Test print $pc with a file.  Test string operations
	without a target.
	* gdb.base/ptype.exp: Do not expect *& to work on created array
	elements.
@
text
@d195 56
d258 1
d267 1
a267 1
      struct value *v;
d269 9
a277 4
      /* Look in the type of the source to see if it contains the
	 type of the target as a superclass.  If so, we'll need to
	 offset the pointer rather than just change its type.  */
      if (TYPE_NAME (t1) != NULL)
d279 3
a281 32
	  struct value *v2;

	  if (TYPE_CODE (type2) == TYPE_CODE_REF)
	    v2 = coerce_ref (arg2);
	  else
	    v2 = value_ind (arg2);
	  v = search_struct_field (type_name_no_tag (t1),
				   v2, 0, t2, 1);
	  if (v)
	    {
	      v = value_addr (v);
	      deprecated_set_value_type (v, type);
	      return v;
	    }
	}

      /* Look in the type of the target to see if it contains the
	 type of the source as a superclass.  If so, we'll need to
	 offset the pointer rather than just change its type.
	 FIXME: This fails silently with virtual inheritance.  */
      if (TYPE_NAME (t2) != NULL)
	{
	  v = search_struct_field (type_name_no_tag (t2),
				   value_zero (t1, not_lval), 0, t1, 1);
	  if (v)
	    {
	      CORE_ADDR addr2 = value_as_address (arg2);
	      addr2 -= (VALUE_ADDRESS (v)
			+ value_offset (v)
			+ value_embedded_offset (v));
	      return value_from_pointer (type, addr2);
	    }
d283 1
a283 1
    }
d311 20
d398 2
a399 2
  if (code1 == TYPE_CODE_STRUCT
      && code2 == TYPE_CODE_STRUCT
d401 1
a401 12
    {
      /* Look in the type of the source to see if it contains the
         type of the target as a superclass.  If so, we'll need to
         offset the object in addition to changing its type.  */
      struct value *v = search_struct_field (type_name_no_tag (type),
					     arg2, 0, type2, 1);
      if (v)
	{
	  deprecated_set_value_type (v, type);
	  return v;
	}
    }
@


1.183
log
@	* eval.c (evaluate_subexp_standard): Fix type of result of mixed
	integer/float division operations when EVAL_AVOID_SIDE_EFFECTS.
	* valops.c (value_one): New function.
	* value.h (value_one): Declare.

	Fix argument promotion for binary arithmetic ops for C.
	* valarith.c (unop_result_type): New fn.
	(binop_result_type): New fn.
	(value_binop): Move result type computation to binop_result_type.
	(value_pos, value_neg, value_complement): Move result type
	computation to unop_result_type.

	* gdb.base/whatis-exp.exp: Fix expected result of whatis x+y, x-y, x*y.
@
text
@d603 4
a606 1
    fromval = value_cast (type, fromval);
d608 7
a614 1
    fromval = coerce_array (fromval);
d864 44
d937 5
d987 4
d1081 1
a1081 1
/* Create a value for an array by allocating space in the inferior,
d1139 2
a1140 4
  /* Allocate space to store the array in the inferior, and then
     initialize it by copying in each element.  FIXME: Is it worth it
     to create a local buffer in which to collect each value and then
     write all the bytes in one operation?  */
d1142 1
a1142 1
  addr = allocate_space_in_inferior (nelem * typelength);
d1144 4
a1147 11
    {
      write_memory (addr + (idx * typelength),
		    value_contents_all (elemvec[idx]),
		    typelength);
    }

  /* Create the array type and set up an array value to be evaluated
     lazily.  */

  val = value_at_lazy (arraytype, addr);
  return (val);
@


1.182
log
@	* gdbarch.sh (function_list): Add new property bits_big_endian to
	gdbarch structure.
	* gdbarch.{c,h}: Regenerate.

	* value.c (struct value): Replace BITS_BIG_ENDIAN by
	gdbarch_bits_big_endian (comment).
	(unpack_field_as_long, modify_field): Likewise.
	* value.h: Likewise (comment).
	* valops.c (value_slice): Likewise.
	* valarith.c (value_subscript, value_bit_index): Likewise.
	* gdbtypes.h (field): Likewise (comment).
	* eval.c (evaluate_subexp_standard): Likewise.
	* dwarf2read.c (dwarf2_add_field): Likewise.
	* ada-lang.c (decode_packed_array, ada_value_primitive_packed_val)
	(move_bits, ada_value_assign, value_assign_to_component): Likewise.

	* defs.h (BITS_BIG_ENDIAN): Remove.



	* gdbint.texinfo (Target Conditionals): Replace the description of
	BITS_BIG_ENDIAN with a description of gdbarch_bits_big_endian.
@
text
@d474 34
@


1.181
log
@	* Makefile.in (dfp.o): Depend on expression.h, gdbtypes.h and value.h.
	(valarith.o): Depend on dfp.h.
	(valops.o): Likewise.
	* dfp.c: Include expression.h, gdbtypes.h, value.h and dfp.h.
	(set_decnumber_context): New function.
	(decimal_check_errors): Likewise.
	(decimal_from_number): Likewise.
	(decimal_to_number): Likewise.
	(decimal_from_string): Use set_decnumber_context and
	decimal_check_errors.
	(decimal_from_integral): New function.
	(decimal_from_floating): Likewise.
	(decimal_to_double): Likewise.
	(promote_decimal): Likewise.
	(decimal_binop): Likewise.
	(decimal_is_zero): Likewise.
	(decimal_compare): Likewise.
	(decimal_convert): Likewise.
	* dfp.h (decimal_from_integral): New prototype.
	(decimal_from_floating): Likewise.
	(decimal_to_double): Likewise.
	(decimal_binop): Likewise.
	(decimal_is_zero): Likewise.
	(decimal_compare): Likewise.
	(decimal_convert): Likewise.
	* eval.c (evaluate_subexp_standard): Remove expect_type argument from
	call to value_from_decfloat.
	* valarith.c: Include dfp.h.
	(value_args_as_decimal): New function.
	(value_binop): Add if block to handle TYPE_CODE_DECFLOAT values.
	(value_logical_not): Likewise.
	(value_equal): Likewise.
	(value_less): Likewise.
	(value_pos): Likewise.
	(value_neg): Formatting fix.
	* valops.c: Include dfp.h.
	(value_cast): Add if block to handle TYPE_CODE_DECFLOAT values.
	* value.c (unpack_long): Add case to handle TYPE_CODE_DECFLOAT.
	(unpack_double): Add if block to handle TYPE_CODE_DECFLOAT.
	(value_from_decfloat): Remove expect_type argument.
	* value.h (value_from_decfloat): Update prototype.
@
text
@d2746 1
a2746 1
	      if (BITS_BIG_ENDIAN)
@


1.180
log
@	Updated copyright notices for most files.
@
text
@d39 1
d342 2
a343 1
	    || code2 == TYPE_CODE_ENUM || code2 == TYPE_CODE_RANGE);
d362 16
@


1.179
log
@	* gdbtypes.h (struct cplus_struct_type): Remove runtime_ptr member.
	(TYPE_RUNTIME_PTR, TYPE_VTABLE, TYPE_HAS_VTABLE,
	TYPE_PRIMARY_BASE, TYPE_VIRTUAL_BASE_LIST): Remove macros.
	(HP_ACC_VFUNC_START, HP_ACC_VBASE_START, HP_ACC_TYPEINFO_OFFSET,
	HP_ACC_TOP_OFFSET_OFFSET): Likewise.
	(has_vtable, primary_base_class, virtual_base_list_length,
	virtual_base_list_length_skip_primaries, virtual_base_index,
	virtual_base_index_skip_primaries, class_index_in_primary_list,
	count_virtual_fns): Remove prototypes.
	* gdbtypes.c (has_vtable, primary_base_class, current_vbase_list,
	virtual_base_list_aux, virtual_base_list, virtual_base_list_length,
	virtual_base_list_length_skip_primaries, virtual_base_index,
	virtual_base_index_skip_primaries, class_index_in_primary_list,
	count_virtual_fns): Remove.

	* cp-valprint.c (cp_print_hpacc_virtual_table_entries): Remove.
	(hpacc_vtbl_ptr_name, hpacc_vtbl_ptr_type_name): Remove.
	(cp_print_value_fields): Remove support for HP aCC vtables.
	(cp_print_value): Likewise.
	* c-typeprint.c (c_type_print_base): Likewise.

	* value.h (find_rt_vbase_offset): Remove prototype.
	* valops.c (find_rt_vbase_offset): Remove.
	(search_struct_method): Remove support for HP aCC vtables.
	(find_method_list): Likewise.
@
text
@d3 3
a5 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007 Free Software Foundation, Inc.
@


1.178
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@a1348 94

/* Return the offset (in bytes) of the virtual base of type BASETYPE
 * in an object pointed to by VALADDR (on the host), assumed to be of
 * type TYPE.  OFFSET is number of bytes beyond start of ARG to start
 * looking (in case VALADDR is the contents of an enclosing object).
 *
 * This routine recurses on the primary base of the derived class
 * because the virtual base entries of the primary base appear before
 * the other virtual base entries.
 *
 * If the virtual base is not found, a negative integer is returned.
 * The magnitude of the negative integer is the number of entries in
 * the virtual table to skip over (entries corresponding to various
 * ancestral classes in the chain of primary bases).
 *
 * Important: This assumes the HP / Taligent C++ runtime conventions.
 * Use baseclass_offset() instead to deal with g++ conventions.  */

void
find_rt_vbase_offset (struct type *type, struct type *basetype,
		      const gdb_byte *valaddr, int offset, 
		      int *boffset_p, int *skip_p)
{
  int boffset;			/* Offset of virtual base.  */
  int index;			/* Displacement to use in virtual
				   table.  */
  int skip;

  struct value *vp;
  CORE_ADDR vtbl;		/* The virtual table pointer.  */
  struct type *pbc;		/* The primary base class.  */

  /* Look for the virtual base recursively in the primary base, first.
   * This is because the derived class object and its primary base
   * subobject share the primary virtual table.  */

  boffset = 0;
  pbc = TYPE_PRIMARY_BASE (type);
  if (pbc)
    {
      find_rt_vbase_offset (pbc, basetype, valaddr,
			    offset, &boffset, &skip);
      if (skip < 0)
	{
	  *boffset_p = boffset;
	  *skip_p = -1;
	  return;
	}
    }
  else
    skip = 0;


  /* Find the index of the virtual base according to HP/Taligent
     runtime spec.  (Depth-first, left-to-right.)  */
  index = virtual_base_index_skip_primaries (basetype, type);

  if (index < 0)
    {
      *skip_p = skip + virtual_base_list_length_skip_primaries (type);
      *boffset_p = 0;
      return;
    }

  /* pai: FIXME -- 32x64 possible problem.  */
  /* First word (4 bytes) in object layout is the vtable pointer.  */
  vtbl = *(CORE_ADDR *) (valaddr + offset);

  /* Before the constructor is invoked, things are usually zero'd
     out.  */
  if (vtbl == 0)
    error (_("Couldn't find virtual table -- object may not be constructed yet."));


  /* Find virtual base's offset -- jump over entries for primary base
   * ancestors, then use the index computed above.  But also adjust by
   * HP_ACC_VBASE_START for the vtable slots before the start of the
   * virtual base entries.  Offset is negative -- virtual base entries
   * appear _before_ the address point of the virtual table.  */

  /* pai: FIXME -- 32x64 problem, if word = 8 bytes, change multiplier
     & use long type */

  /* epstein : FIXME -- added param for overlay section. May not be
     correct.  */
  vp = value_at (builtin_type_int, 
		 vtbl + 4 * (-skip - index - HP_ACC_VBASE_START));
  boffset = value_as_long (vp);
  *skip_p = -1;
  *boffset_p = boffset;
  return;
}


d1425 8
a1432 1
	  if (TYPE_HAS_VTABLE (type))
d1434 6
a1439 9
	      /* HP aCC compiled type, search for virtual base offset
	         according to HP/Taligent runtime spec.  */
	      int skip;
	      find_rt_vbase_offset (type, TYPE_BASECLASS (type, i),
				    value_contents_all (*arg1p),
				    offset + value_embedded_offset (*arg1p),
				    &base_offset, &skip);
	      if (skip >= 0)
		error (_("Virtual base class offset not found in vtable"));
d1442 1
a1442 20
	    {
	      struct type *baseclass = 
		check_typedef (TYPE_BASECLASS (type, i));
	      const gdb_byte *base_valaddr;

	      /* The virtual base class pointer might have been
	         clobbered by the user program. Make sure that it
	         still points to a valid memory location.  */

	      if (offset < 0 || offset >= TYPE_LENGTH (type))
		{
		  gdb_byte *tmp = alloca (TYPE_LENGTH (baseclass));
		  if (target_read_memory (VALUE_ADDRESS (*arg1p)
					  + value_offset (*arg1p) + offset,
					  tmp, TYPE_LENGTH (baseclass)) != 0)
		    error (_("virtual baseclass botch"));
		  base_valaddr = tmp;
		}
	      else
		base_valaddr = value_contents (*arg1p) + offset;
d1444 5
a1448 7
	      base_offset =
		baseclass_offset (type, i, base_valaddr,
				  VALUE_ADDRESS (*arg1p)
				  + value_offset (*arg1p) + offset);
	      if (base_offset == -1)
		error (_("virtual baseclass botch"));
	    }
d1648 6
a1653 23
	  if (TYPE_HAS_VTABLE (type))
	    {
	      /* HP aCC compiled type, search for virtual base offset
	       * according to HP/Taligent runtime spec.  */
	      int skip;
	      find_rt_vbase_offset (type, TYPE_BASECLASS (type, i),
				    value_contents_all (*argp),
				    offset + value_embedded_offset (*argp),
				    &base_offset, &skip);
	      if (skip >= 0)
		error (_("Virtual base class offset not found in vtable"));
	    }
	  else
	    {
	      /* probably g++ runtime model */
	      base_offset = value_offset (*argp) + offset;
	      base_offset =
		baseclass_offset (type, i,
				  value_contents (*argp) + base_offset,
				  VALUE_ADDRESS (*argp) + base_offset);
	      if (base_offset == -1)
		error (_("virtual baseclass botch"));
	    }
@


1.177
log
@2007-08-21  Michael Snyder  <msnyder@@access-company.com>

	* valops.c (find_overload_match): Guard against NULL.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.176
log
@2007-08-13  Michael Snyder  <msnyder@@access-company.com>

	* valops.c: Whitespace clean-up.
@
text
@d1898 1
@


1.175
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_ADDR_BIT): Replace by gdbarch_addr_bit.
	* valops.c (value_cast): Likewise.
	* utils.c (strlen_paddr, paddr, paddr_nz, paddress): Likewise.
	* ui-out.c (ui_out_field_core_addr): Likewise.
	* tracepoint.c (tracepoints_info): Likewise.
	* symtab.c (print_msymbol_info): Likewise.
	* solib-irix.c (irix_current_sos)
	(irix_open_symbol_file_object): Likewise.
	* remote.c (build_remote_gdbarch_data): Likewise.
	* prologue-value.c (make_pv_area): Likewise.
	* procfs.c (info_mappings_callback): Likewise.
	* printcmd.c (print_scalar_formatted)
	(deprecated_print_address_numeric): Likewise.
	* memattr.c (mem_info_command): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* gdbtypes.c (build_flt, gdbtypes_post_init): Likewise.
	* exec.c (print_section_info): Likewise.
	* dwarf2read.c (read_subrange_type): Likewise.
	* dwarf2loc.c (find_location_expression): Likewise.
	* dwarf2expr.c (dwarf2_read_address, unsigned_address_type)
	(signed_address_type, execute_stack_op): Likewise.
	* breakpoint.c (print_one_breakpoint, breakpoint_1): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d3 3
a5 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
   Free Software Foundation, Inc.
d54 2
a55 2
static struct value *search_struct_field (char *, struct value *, int,
				      struct type *, int);
d61 4
a64 5
static int find_oload_champ_namespace (struct type **arg_types, int nargs,
				       const char *func_name,
				       const char *qualified_name,
				       struct symbol ***oload_syms,
				       struct badness_vector **oload_champ_bv);
d67 8
a74 13
int find_oload_champ_namespace_loop (struct type **arg_types, int nargs,
				     const char *func_name,
				     const char *qualified_name,
				     int namespace_len,
				     struct symbol ***oload_syms,
				     struct badness_vector **oload_champ_bv,
				     int *oload_champ);

static int find_oload_champ (struct type **arg_types, int nargs, int method,
			     int num_fns,
			     struct fn_field *fns_ptr,
			     struct symbol **oload_syms,
			     struct badness_vector **oload_champ_bv);
d76 1
a76 2
static int oload_method_static (int method, struct fn_field *fns_ptr,
				int index);
d81 2
a82 4
oload_classification classify_oload_match (struct badness_vector
					   * oload_champ_bv,
					   int nargs,
					   int static_offset);
d86 12
a97 15
static struct value *value_struct_elt_for_reference (struct type *domain,
						     int offset,
						     struct type *curtype,
						     char *name,
						     struct type *intype,
						     int want_address,
						     enum noside noside);

static struct value *value_namespace_elt (const struct type *curtype,
					  char *name, int want_address,
					  enum noside noside);

static struct value *value_maybe_namespace_elt (const struct type *curtype,
						char *name, int want_address,
						enum noside noside);
d103 3
a105 5
static struct fn_field *find_method_list (struct value ** argp, char *method,
					  int offset,
					  struct type *type, int *num_fns,
					  struct type **basetype,
					  int *boffset);
d109 3
a111 1
/* Flag for whether we want to abandon failed expression evals by default.  */
a112 1
#if 0
d119 2
a120 1
			  struct cmd_list_element *c, const char *value)
d145 2
a146 1
      struct minimal_symbol *msymbol = lookup_minimal_symbol (name, NULL, NULL);
d167 3
a169 2
/* Allocate NBYTES of space in the inferior using the inferior's malloc
   and return a value that is a pointer to the allocated space. */
d175 2
a176 2
  struct value *val = find_function_in_inferior
			(gdbarch_name_of_malloc (current_gdbarch));
d288 3
a290 3
  /* A cast to an undetermined-length array_type, such as (TYPE [])OBJECT,
     is treated like a cast to (TYPE [N])OBJECT,
     where N is sizeof(OBJECT)/sizeof(TYPE). */
d306 2
a307 2
	  /* FIXME-type-allocation: need a way to free this type when we are
	     done with it.  */
d312 4
a315 2
	  deprecated_set_value_type (arg2, create_array_type ((struct type *) NULL,
							      element_type, range_type));
d353 1
a353 1
					 arg2, 0, type2, 1);
d383 3
a385 3
  else if (code1 == TYPE_CODE_PTR && (code2 == TYPE_CODE_INT  ||
				      code2 == TYPE_CODE_ENUM ||
				      code2 == TYPE_CODE_RANGE))
d434 2
a435 1
    return value_at_lazy (type, VALUE_ADDRESS (arg2) + value_offset (arg2));
d468 1
a468 1
   adjustments before or after calling it. */
d513 7
a519 6
   If the value is zero-length, we avoid calling read_memory, which would
   abort.  We mark the value as fetched anyway -- all 0 bytes of it.

   This function returns a value because it is used in the value_contents
   macro as part of an expression, where a void would not work.  The
   value is ignored.  */
d558 3
a560 3
  /* Since modifying a register can trash the frame chain, and modifying memory
     can trash the frame cache, we save the old frame and then restore the new
     frame afterwards.  */
d568 2
a569 1
      val = value_change_enclosing_type (val, value_enclosing_type (fromval));
d571 2
a572 1
      set_value_pointed_to_offset (val, value_pointed_to_offset (fromval));
d592 2
a593 2
	    /* We assume that the argument to read_memory is in units of
	       host chars.  FIXME:  Is that correct?  */
d639 5
a643 4
	       conversion of program values to a special raw format.  */
	    gdbarch_value_to_register (current_gdbarch,
				       frame, VALUE_REGNUM (toval),
				       type, value_contents (fromval));
d666 2
a667 1
			      value_bitpos (toval), value_bitsize (toval));
d704 2
a705 1
      /* Having destoroyed the frame cache, restore the selected frame.  */
d724 3
a726 2
  /* If the field does not entirely fill a LONGEST, then zero the sign bits.
     If the field is signed, and is negative, then sign extend. */
d734 2
a735 1
      if (!TYPE_UNSIGNED (type) && (fieldval & (valmask ^ (valmask >> 1))))
d745 2
a746 1
  val = value_change_enclosing_type (val, value_enclosing_type (fromval));
d805 8
a812 8
/* Given a value which is an array, return a value which is a pointer to its
   first element, regardless of whether or not the array has a nonzero lower
   bound.

   FIXME:  A previous comment here indicated that this routine should be
   substracting the array's lower bound.  It's not clear to me that this
   is correct.  Given an array subscripting operation, it would certainly
   work to do the adjustment here, essentially computing:
d816 3
a818 2
   However I believe a more appropriate and logical place to account for
   the lower bound is to do so in value_subscript, essentially computing:
d822 5
a826 5
   As further evidence consider what would happen with operations other
   than array subscripting, where the caller would get back a value that
   had an address somewhere before the actual first element of the array,
   and the information about the lower bound would be lost because of
   the coercion to pointer type.
d857 2
a858 1
/* Return a pointer value for the object for which ARG1 is the contents.  */
d868 3
a870 3
      /* Copy the value, but change the type from (T&) to (T*).
         We keep the same location information, which is efficient,
         and allows &(&X) to get the location containing the reference. */
d872 2
a873 1
      deprecated_set_value_type (arg2, lookup_pointer_type (TYPE_TARGET_TYPE (type)));
d889 1
a889 1
     full derived object's type ... */
d891 2
a892 1
  /* ... and also the relative position of the subobject in the full object */
d897 2
a898 1
/* Return a reference value for the object for which ARG1 is the contents.  */
d914 2
a915 1
/* Given a value of a pointer type, apply the C unary * operator to it.  */
d928 2
a929 2
     This returns an int, which seems like the most C-like thing
     to do.  "long long" variables are rare enough that
d937 2
a938 2
      /* We may be pointing to something embedded in a larger object */
      /* Get the real type of the enclosing object */
d946 2
a947 1
	arg2 = value_at_lazy (enc_type, find_function_addr (arg1, NULL));
d950 3
a952 2
	arg2 = value_at_lazy (enc_type, (value_as_address (arg1)
					 - value_pointed_to_offset (arg1)));
d954 1
a954 1
      /* Re-adjust type */
d956 1
a956 1
      /* Add embedding info */
d960 1
a960 1
      /* We may be pointing to an object of some derived type */
d966 1
a966 1
  return 0;			/* For lint -- never reached */
d969 3
a971 2
/* Create a value for an array by allocating space in the inferior, copying
   the data into that space, and then setting up an array value.
d973 2
a974 2
   The array bounds are set from LOWBOUND and HIGHBOUND, and the array is
   populated from the values passed in ELEMVEC.
d978 1
a978 1
   don't currently enforce any restriction on their types). */
d991 2
a992 2
  /* Validate that the bounds are reasonable and that each of the elements
     have the same size. */
d1008 2
a1009 1
  rangetype = create_range_type ((struct type *) NULL, builtin_type_int,
d1012 2
a1013 1
			      value_enclosing_type (elemvec[0]), rangetype);
d1027 4
a1030 4
  /* Allocate space to store the array in the inferior, and then initialize
     it by copying in each element.  FIXME:  Is it worth it to create a
     local buffer in which to collect each value and then write all the
     bytes in one operation? */
d1040 2
a1041 1
  /* Create the array type and set up an array value to be evaluated lazily. */
d1047 8
a1054 7
/* Create a value for a string constant by allocating space in the inferior,
   copying the data into that space, and returning the address with type
   TYPE_CODE_STRING.  PTR points to the string constant data; LEN is number
   of characters.
   Note that string types are like array of char types with a lower bound of
   zero and an upper bound of LEN - 1.  Also note that the string may contain
   embedded null bytes. */
d1063 2
a1064 1
					      lowbound, len + lowbound - 1);
d1066 1
a1066 1
  = create_string_type ((struct type *) NULL, rangetype);
d1077 2
a1078 2
  /* Allocate space to store the string in the inferior, and then
     copy LEN bytes from PTR in gdb to that address in the inferior. */
d1091 2
a1092 1
  struct type *domain_type = create_range_type (NULL, builtin_type_int,
d1094 2
a1095 1
  struct type *type = create_set_type ((struct type *) NULL, domain_type);
d1102 10
a1111 9
/* See if we can pass arguments in T2 to a function which takes arguments
   of types T1.  T1 is a list of NARGS arguments, and T2 is a NULL-terminated
   vector.  If some arguments need coercion of some sort, then the coerced
   values are written into T2.  Return value is 0 if the arguments could be
   matched, or the position at which they differ if not.

   STATICP is nonzero if the T1 argument list came from a
   static member function.  T2 will still include the ``this'' pointer,
   but it will be skipped.
d1114 3
a1116 3
   which is the type of the instance variable.  This is because we want
   to handle calls with objects from derived classes.  This is not
   entirely correct: we should actually check to make sure that a
d1126 2
a1127 1
    internal_error (__FILE__, __LINE__, _("typecmp: no argument list"));
d1129 2
a1130 1
  /* Skip ``this'' argument if applicable.  T2 will always include THIS.  */
d1162 3
a1164 3
	 and the argument will be a pointer to a char. */
      while ( TYPE_CODE(tt1) == TYPE_CODE_REF ||
	      TYPE_CODE (tt1) == TYPE_CODE_PTR)
d1168 3
a1170 3
      while ( TYPE_CODE(tt2) == TYPE_CODE_ARRAY ||
	      TYPE_CODE(tt2) == TYPE_CODE_PTR ||
	      TYPE_CODE(tt2) == TYPE_CODE_REF)
d1172 1
a1172 1
	  tt2 = check_typedef( TYPE_TARGET_TYPE(tt2) );
d1176 2
a1177 1
      /* Array to pointer is a `trivial conversion' according to the ARM.  */
d1179 3
a1181 3
      /* We should be doing much hairier argument matching (see section 13.2
         of the ARM), but as a quick kludge, just check for the same type
         code.  */
d1190 4
a1193 4
/* Helper function used by value_struct_elt to recurse through baseclasses.
   Look for a field NAME in ARG1. Adjust the address of ARG1 by OFFSET bytes,
   and search in it assuming it has (class) type TYPE.
   If found, return value, else return NULL.
d1195 2
a1196 2
   If LOOKING_FOR_BASECLASS, then instead of looking for struct fields,
   look for a baseclass named NAME.  */
d1240 3
a1242 2
		/* Look for a match through the fields of an anonymous union,
		   or anonymous struct.  C++ provides anonymous unions.
d1260 1
a1260 1
		   have to add the offset of the union here. */
d1266 2
a1267 1
		v = search_struct_field (name, arg1, new_offset, field_type,
d1279 3
a1281 3
      /* If we are looking for baseclasses, this is what we get when we
         hit them.  But it could happen that the base part's member name
         is not yet filled in.  */
d1284 3
a1286 1
			     && (strcmp_iw (name, TYPE_BASECLASS_NAME (type, i)) == 0));
d1300 3
a1302 3
	  /* The virtual base class pointer might have been clobbered by the
	     user program. Make sure that it still points to a valid memory
	     location.  */
d1309 4
a1312 2
	      base_addr = VALUE_ADDRESS (arg1) + value_offset (arg1) + boffset;
	      if (target_read_memory (base_addr, value_contents_raw (v2),
d1334 2
a1335 1
	  v = search_struct_field (name, v2, 0, TYPE_BASECLASS (type, i),
d1342 2
a1343 1
			       offset + TYPE_BASECLASS_BITPOS (type, i) / 8,
d1357 3
a1359 3
 * This routine recurses on the primary base of the derived class because
 * the virtual base entries of the primary base appear before the other
 * virtual base entries.
d1366 2
a1367 3
 * Important: This assumes the HP / Taligent C++ runtime
 * conventions. Use baseclass_offset() instead to deal with g++
 * conventions.  */
d1371 2
a1372 2
		      const gdb_byte *valaddr, int offset, int *boffset_p,
		      int *skip_p)
d1374 3
a1376 2
  int boffset;			/* offset of virtual base */
  int index;			/* displacement to use in virtual table */
d1380 2
a1381 2
  CORE_ADDR vtbl;		/* the virtual table pointer */
  struct type *pbc;		/* the primary base class */
d1391 2
a1392 1
      find_rt_vbase_offset (pbc, basetype, valaddr, offset, &boffset, &skip);
d1405 1
a1405 1
     runtime spec. (Depth-first, left-to-right.)  */
d1415 2
a1416 2
  /* pai: FIXME -- 32x64 possible problem */
  /* First word (4 bytes) in object layout is the vtable pointer */
d1419 2
a1420 1
  /* Before the constructor is invoked, things are usually zero'd out. */
d1429 1
a1429 1
   * appear _before_ the address point of the virtual table. */
d1434 4
a1437 2
  /* epstein : FIXME -- added param for overlay section. May not be correct */
  vp = value_at (builtin_type_int, vtbl + 4 * (-skip - index - HP_ACC_VBASE_START));
d1445 7
a1451 5
/* Helper function used by value_struct_elt to recurse through baseclasses.
   Look for a field NAME in ARG1. Adjust the address of ARG1 by OFFSET bytes,
   and search in it assuming it has (class) type TYPE.
   If found, return value, else if name matched and args not return (value)-1,
   else return NULL. */
d1501 4
a1504 2
		      return value_virtual_fn_field (arg1p, f, j, type, offset);
		    if (TYPE_FN_FIELD_STATIC_P (f, j) && static_memfuncp)
d1535 2
a1536 1
	      struct type *baseclass = check_typedef (TYPE_BASECLASS (type, i));
d1539 3
a1541 3
	      /* The virtual base class pointer might have been clobbered by the
	         user program. Make sure that it still points to a valid memory
	         location.  */
d1575 2
a1576 2
/* FIXME-bothner:  Why is this commented out?  Why is it here?  */
/*        *arg1p = arg1_tmp; */
d1587 2
a1588 2
   extract the component named NAME from the ultimate target structure/union
   and return it as a value with its appropriate type.
d1598 2
a1599 1
   ERR is an error message to be printed in case the field is not found.  */
d1635 2
a1636 2
      /* Try as a field first, because if we succeed, there
         is less work to be done.  */
d1647 2
a1648 1
      v = search_struct_method (name, argp, args, 0, static_memfuncp, t);
d1672 2
a1673 1
	      v = value_fn_field (NULL, TYPE_FN_FIELDLIST1 (t, m_index),
d1677 2
a1678 1
	    error (_("could not find destructor function named %s."), name);
d1688 2
a1689 1
    v = search_struct_method (name, argp, args, 0, static_memfuncp, t);
d1697 2
a1698 2
      /* See if user tried to invoke data as function.  If so,
         hand it back.  If it's not callable (i.e., a pointer to function),
d1708 14
a1721 11
/* Search through the methods of an object (and its bases)
 * to find a specified method. Return the pointer to the
 * fn_field list of overloaded instances.
 * Helper function for value_find_oload_list.
 * ARGP is a pointer to a pointer to a value (the object)
 * METHOD is a string containing the method name
 * OFFSET is the offset within the value
 * TYPE is the assumed type of the object
 * NUM_FNS is the number of overloaded instances
 * BASETYPE is set to the actual type of the subobject where the method is found
 * BOFFSET is the offset of the base subobject where the method is found */
d1724 2
a1725 2
find_method_list (struct value **argp, char *method, int offset,
		  struct type *type, int *num_fns,
d1734 1
a1734 1
  /* First check in object itself */
d1737 1
a1737 1
      /* pai: FIXME What about operators and type conversions? */
d1755 1
a1755 1
  /* Not found in object, check in base subobjects */
d1785 2
a1786 2
      else
	/* non-virtual base, simply use bit position from debug info */
d1791 2
a1792 2
			    TYPE_BASECLASS (type, i), num_fns, basetype,
			    boffset);
d1800 9
a1808 6
 * ARGP is a pointer to a pointer to a value (the object)
 * METHOD is the method name
 * OFFSET is the offset within the value contents
 * NUM_FNS is the number of overloaded instances
 * BASETYPE is set to the type of the base subobject that defines the method
 * BOFFSET is the offset of the base subobject which defines the method */
d1811 3
a1813 3
value_find_oload_method_list (struct value **argp, char *method, int offset,
			      int *num_fns, struct type **basetype,
			      int *boffset)
d1819 1
a1819 1
  /* code snarfed from value_struct_elt */
d1833 2
a1834 1
  return find_method_list (argp, method, 0, t, num_fns, basetype, boffset);
d1855 2
a1856 1
   If a non-method is being searched for, SYMP will hold the symbol for it.
d1864 1
a1864 1
 */
d1867 5
a1871 3
find_overload_match (struct type **arg_types, int nargs, char *name, int method,
		     int lax, struct value **objp, struct symbol *fsym,
		     struct value **valp, struct symbol **symp, int *staticp)
d1874 4
a1877 5

  int oload_champ;		/* Index of best overloaded function */

  struct badness_vector *oload_champ_bv = NULL;		/* The measure for the current best match */

d1879 6
a1884 3
  struct fn_field *fns_ptr = NULL;	/* For methods, the list of overloaded methods */
  struct symbol **oload_syms = NULL;	/* For non-methods, the list of overloaded function symbols */
  int num_fns = 0;		/* Number of overloaded instances being considered */
d1895 1
a1895 1
  /* Get the list of overloaded methods or functions */
d1900 3
a1902 3
         value rather than the object itself, so try again */
      if ((!obj_type_name || !*obj_type_name) &&
	  (TYPE_CODE (value_type (obj)) == TYPE_CODE_PTR))
d1905 2
a1906 2
      fns_ptr = value_find_oload_method_list (&temp, name, 0,
					      &num_fns,
d1914 2
a1915 2
	 been resolved by find_method_list via value_find_oload_method_list
	 above.  */
d1917 3
a1919 2
      oload_champ = find_oload_champ (arg_types, nargs, method, num_fns,
				      fns_ptr, oload_syms, &oload_champ_bv);
d1952 4
a1955 4
  match_quality
    = classify_oload_match (oload_champ_bv, nargs,
			    oload_method_static (method, fns_ptr,
						 oload_champ));
d1985 2
a1986 1
	*valp = value_virtual_fn_field (&temp, fns_ptr, oload_champ, basetype, boffset);
d1988 2
a1989 1
	*valp = value_fn_field (&temp, fns_ptr, oload_champ, basetype, boffset);
d2075 2
a2076 2
  next_namespace_len
    += cp_find_first_component (qualified_name + next_namespace_len);
d2082 2
a2083 2
  /* First, see if we have a deeper namespace we can search in.  If we
     get a good match there, use it.  */
d2171 7
a2177 4
  struct badness_vector *bv;	/* A measure of how good an overloaded instance is */
  int oload_champ = -1;		/* Index of best overloaded function */
  int oload_ambiguous = 0;	/* Current ambiguity state for overload resolution */
  /* 0 => no ambiguity, 1 => two good funcs, 2 => incomparable funcs */
d2181 1
a2181 1
  /* Consider each candidate in turn */
d2195 2
a2196 2
	  /* If it's not a method, this is the proper place */
	  nparms=TYPE_NFIELDS(SYMBOL_TYPE(oload_syms[ix]));
d2199 3
a2201 2
      /* Prepare array of parameter types */
      parm_types = (struct type **) xmalloc (nparms * (sizeof (struct type *)));
d2205 2
a2206 1
			  : TYPE_FIELD_TYPE (SYMBOL_TYPE (oload_syms[ix]), jj));
d2208 4
a2211 3
      /* Compare parameter types to supplied argument types.  Skip THIS for
         static methods.  */
      bv = rank_function (parm_types, nparms, arg_types + static_offset,
d2219 2
a2220 2
      else
	/* See whether current candidate is better or worse than previous best */
d2223 2
a2224 2
	  case 0:
	    oload_ambiguous = 1;	/* top two contenders are equally good */
d2226 2
a2227 2
	  case 1:
	    oload_ambiguous = 2;	/* incomparable top contenders */
d2229 2
a2230 2
	  case 2:
	    *oload_champ_bv = bv;	/* new champion, record details */
d2242 3
a2244 1
	    fprintf_filtered (gdb_stderr,"Overloaded method instance %s, # of parms %d\n", fns_ptr[ix].physname, nparms);
d2246 4
a2249 1
	    fprintf_filtered (gdb_stderr,"Overloaded function instance %s # of parms %d\n", SYMBOL_DEMANGLED_NAME (oload_syms[ix]), nparms);
d2251 6
a2256 2
	    fprintf_filtered (gdb_stderr,"...Badness @@ %d : %d\n", jj, bv->rank[jj]);
	  fprintf_filtered (gdb_stderr,"Overload resolution champion is %d, ambiguous? %d\n", oload_champ, oload_ambiguous);
d2287 1
a2287 1
	return INCOMPATIBLE;	/* truly mismatched types */
d2289 2
a2290 1
	return NON_STANDARD;	/* non-standard type conversions needed */
d2296 3
a2298 3
/* C++: return 1 is NAME is a legitimate name for the destructor
   of type TYPE.  If TYPE does not have a destructor, or
   if NAME is inappropriate for TYPE, an error is signaled.  */
d2302 1
a2302 1
  /* destructors are a special case.  */
d2324 2
a2325 2
   return 1 if the component named NAME from the ultimate
   target structure/union is defined, otherwise, return 0. */
d2339 2
a2340 2
  /* C++: If it was not found as a data field, then try to
     return it as a pointer to a method.  */
d2365 2
a2366 2
   return 1 if the component named NAME from the ultimate
   target structure/union is defined, otherwise, return 0.  */
d2382 2
a2383 1
      if (TYPE_CODE (t) != TYPE_CODE_PTR && TYPE_CODE (t) != TYPE_CODE_REF)
d2410 2
a2411 1
      return value_struct_elt_for_reference (curtype, 0, curtype, name, NULL,
d2414 2
a2415 1
      return value_namespace_elt (curtype, name, want_address, noside);
d2423 5
a2427 5
   return the address of this member as a "pointer to member"
   type.  If INTYPE is non-null, then it will be the type
   of the member we are looking for.  This will help us resolve
   "pointers to member functions".  This function is used
   to resolve user expressions of the form "DOMAIN::NAME".  */
d2432 2
a2433 1
				struct type *intype, int want_address,
d2474 2
a2475 2
  /* C++: If it was not found as a data field, then try to
     return it as a pointer to a method.  */
d2492 3
a2494 3
      if (strncmp (t_field_name, "__", 2) == 0 ||
	  strncmp (t_field_name, "op", 2) == 0 ||
	  strncmp (t_field_name, "type", 4) == 0)
d2496 2
a2497 1
	  if (cplus_demangle_opname (t_field_name, dem_opname, DMGL_ANSI))
d2499 2
a2500 1
	  else if (cplus_demangle_opname (t_field_name, dem_opname, 0))
d2525 3
a2527 2
	      struct symbol *s = lookup_symbol (TYPE_FN_FIELD_PHYSNAME (f, j),
						0, VAR_DOMAIN, 0, NULL);
d2554 3
a2556 2
	      struct symbol *s = lookup_symbol (TYPE_FN_FIELD_PHYSNAME (f, j),
						0, VAR_DOMAIN, 0, NULL);
d2585 2
a2586 3
					  name,
					  intype, want_address,
					  noside);
d2595 2
a2596 1
  return value_maybe_namespace_elt (curtype, name, want_address, noside);
d2608 2
a2609 1
						    want_address, noside);
d2612 2
a2613 2
    error (_("No symbol \"%s\" in namespace \"%s\"."), name,
	   TYPE_TAG_NAME (curtype));
d2634 2
a2635 2
				    get_selected_block (0), VAR_DOMAIN,
				    NULL);
d2651 3
a2653 2
/* Given a pointer value V, find the real (RTTI) type
   of the object it points to.
d2655 1
a2655 1
   and refer to the values computed for the object pointed to. */
d2658 2
a2659 1
value_rtti_target_type (struct value *v, int *full, int *top, int *using_enc)
d2672 5
a2676 5
   be the correct offset to the enclosed object
   RTYPE is the type, and XFULL, XTOP, and XUSING_ENC are the other
   parameters, computed by value_rtti_type(). If these are available,
   they can be supplied and a second call to value_rtti_type() is avoided.
   (Pass RTYPE == NULL if they're not available */
d2679 3
a2681 1
value_full_object (struct value *argp, struct type *rtype, int xfull, int xtop,
d2700 1
a2700 1
  /* If no RTTI data, or if object is already complete, do nothing */
d2705 2
a2706 1
     type is wrong, set it *//* pai: FIXME -- sounds iffy */
d2716 2
a2717 1
      warning (_("Couldn't retrieve complete object of RTTI type %s; object may be in register(s)."), TYPE_NAME (real_type));
d2722 4
a2725 4
  /* All other cases -- retrieve the complete object */
  /* Go back by the computed top_offset from the beginning of the object,
     adjusting for the embedded offset of argp if that's what value_rtti_type
     used for its computation. */
a2735 2


d2781 2
a2782 1
	error (_("current stack frame does not contain a variable named `%s'"), name);
d2806 3
a2808 3
/* Create a slice (sub-string, sub-array) of ARRAY, that is LENGTH elements
   long, starting at LOWBOUND.  The result has the same lower bound as
   the original ARRAY.  */
d2817 1
d2823 1
d2827 1
d2831 1
d2836 2
a2837 1
					lowbound, lowbound + length - 1);
d2841 3
a2843 1
      slice_type = create_set_type ((struct type *) NULL, slice_range_type);
d2846 1
d2862 4
a2865 3
      /* We should set the address, bitssize, and bitspos, so the clice
         can be used on the LHS, but that may require extensions to
         value_assign.  For now, just leave as a non_lval.  FIXME.  */
d2870 5
a2874 3
      LONGEST offset
	= (lowbound - lowerbound) * TYPE_LENGTH (check_typedef (element_type));
      slice_type = create_array_type ((struct type *) NULL, element_type,
d2877 1
d2885 1
d2890 1
d2898 2
a2899 2
/* Create a value for a FORTRAN complex number.  Currently most of
   the time values are coerced to COMPLEX*16 (i.e. a complex number
d2902 1
a2902 1
   doubles. FIXME: fmb */
d2905 3
a2907 1
value_literal_complex (struct value *arg1, struct value *arg2, struct type *type)
d2923 1
a2923 1
/* Cast a value into the appropriate complex data type. */
d2929 1
d2946 3
a2948 1
    return value_literal_complex (val, value_zero (real_type, not_lval), type);
d2959 2
a2960 2
Show overload resolution in evaluating C++ functions."), NULL,
			   NULL,
@


1.174
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (REGISTER_TO_VALUE): Replace by gdbarch_register_to_value.
	* findvar.c (value_from_register): Likewise.
	* gdbarch.sh (VALUE_TO_REGISTER): Replace by gdbarch_value_to_register.
	* valops.c (value_assign): Likewise.
	* gdbarch.sh (CONVERT_REGISTER_P): Replace by
	gdbarch_convert_register_p.
	* findvar.c (value_from_register): Likewise.
	* valops.c (value_assign): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d405 1
a405 1
      int addr_bit = TARGET_ADDR_BIT;
@


1.173
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NAME_OF_MALLOC): Replace by gdbarch_name_of_malloc.
	* valops.c (value_allocate_space_in_inferior): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d639 2
a640 1
	if (CONVERT_REGISTER_P (VALUE_REGNUM (toval), type))
d644 3
a646 2
	    VALUE_TO_REGISTER (frame, VALUE_REGNUM (toval),
			       type, value_contents (fromval));
@


1.172
log
@2007-06-06  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (ADDRESS_TO_POINTER): Replace by
	gdbarch_address_to_pointer.
	* findvar.c (store_typed_address): Likewise.
	* gdbtypes.c (make_pointer_type): Likewise (comment).
	* procfs.c (procfs_address_to_host_pointer): Likewise.
	* std-regs.c (value_of_builtin_frame_reg): Likewise.
	(value_of_builtin_frame_fp_reg): Likewise.
	(value_of_builtin_frame_pc_reg): Likewise.
	* utils.c (paddress): Likewise (comment).
	* gdbarch.sh (POINTER_TO_ADDRESS): Replace by
	gdbarch_pointer_to_address.
	* findvar.c (extract_typed_address): Likewise.
	* gdbtypes.c (make_pointer_type): Likewise (comment).
	* valops.c (value_cast): Likewise (comment).
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d185 2
a186 1
  struct value *val = find_function_in_inferior (NAME_OF_MALLOC);
@


1.171
log
@	* hppa-hpux-tdep.c (args_for_find_stub, HP_ACC_EH_notify_hook,
	HP_ACC_EH_set_hook_value, HP_ACC_EH_notify_callback, HP_ACC_EH_break,
	HP_ACC_EH_catch_throw, HP_ACC_EH_catch_catch, __eh_notification,
	hp_cxx_exception_support, hp_cxx_exception_support_initialized,
	eh_notify_hook_addr, eh_notify_callback_addr, eh_break_addr,
	eh_catch_throw_addr, break_callback_sal, setup_d_pid_in_inferior,
	find_stub_with_shl_get, cover_find_stub_with_shl_get,
	initialize_hp_cxx_exception_support, child_enable_exception_callback,
	current_ex_event, child_get_current_exception_event): Remove.
	(hppa_hpux_inferior_created): Remove.
	(hppa_hpux_init_abi): Do not install hppa_hpux_inferior_created.

	* breakpoint.h (deprecated_exception_catchpoints_are_fragile): Remove.
	(deprecated_exception_support_initialized): Remove.
	* breakpoint.c (deprecated_exception_catchpoints_are_fragile): Remove.
	(deprecated_exception_support_initialized): Remove.
	(breakpoint_init_inferior): Remove handling of non-zero
	deprecated_exception_catchpoints_are_fragile.

	* symtab.h (deprecated_hp_som_som_object_present): Remove.
	* symtab.c (deprecated_hp_som_som_object_present): Remove.
	* c-typeprint.c (c_type_print_base): Remove handling of non-zero
	deprecated_hp_som_som_object_present.
	* eval.c (evaluate_subexp_standard): Likewise.
	* valops.c (value_cast): Likewise.

	* parse.c (parse_nested_classes_for_hpacc, coloncolon): Remove.
	* parser-defs.h (parse_nested_classes_for_hpacc): Remove.
	* c-exp.y (yylex): Do not call parse_nested_classes_for_hpacc.
@
text
@d377 1
a377 1
         POINTER_TO_ADDRESS to find the address the pointer
@


1.170
log
@	* frame.c (deprecated_selected_frame): Rename to...
	(selected_frame): ...this.  Make static.
	(get_selected_frame, select_frame): Update.
	* frame.h (deprected_select_frame): Delete.
	(deprecated_safe_get_selected_frame): Update comments.

	* breakpoint.c, cli/cli-cmds.c, f-valprint.c, infcmd.c, inflow.c,
	infrun.c, stack.c, tui/tui-disasm.c, tui/tui-source.c,
	tui/tui-winsource.c, valops.c, varobj.c, findvar.c, macroscope.c,
	parse.c, regcache.h, sh64-tdep.c, tui/tui-hooks.c, tui/tui-win.c,
	tui/tui.c: Replace references to deprecated_selected_frame.
@
text
@a375 15
      /* If target compiled by HP aCC.  */
      if (deprecated_hp_som_som_object_present
	  && code2 == TYPE_CODE_MEMBERPTR)
	{
	  unsigned int *ptr;
	  struct value *retvalp;

	  /* With HP aCC, pointers to data members have a bias.  */
	  retvalp = value_from_longest (type, value_as_long (arg2));
	  /* force evaluation */
	  ptr = (unsigned int *) value_contents (retvalp);
	  *ptr &= ~0x20000000;	/* zap 29th bit to remove bias */
	  return retvalp;
	}

@


1.169
log
@	* valops.c (value_ind): Fix unary * handling of TYPE_CODE_INT.
@
text
@d581 1
a581 1
  old_frame = get_frame_id (deprecated_selected_frame);
d2670 1
d2672 3
a2674 1
  if (deprecated_selected_frame == 0)
d2676 2
a2677 3
      if (complain)
	error (_("no frame selected"));
      else
d2681 1
a2681 1
  func = get_frame_function (deprecated_selected_frame);
d2710 1
a2710 1
  ret = read_var_value (sym, deprecated_selected_frame);
@


1.168
log
@Copyright updates for 2007.
@
text
@d937 1
a937 1
			  (CORE_ADDR) value_as_long (arg1));
@


1.167
log
@	* frame.c (get_frame_register_bytes): New function.
	(put_frame_register_bytes): Likewise.
	* frame.h (get_frame_register_bytes): Declare.
	(put_frame_register_bytes): Likewise.
	* findvar.c (value_from_register): Always construct lval_register
	values.  Use get_frame_register_bytes.
	* valops.c (value_assign): Use get_frame_register_bytes and
	put_frame_register_bytes.
@
text
@d3 2
a4 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006
@


1.166
log
@	* NEWS: Mention pointer to member improvements.
	* Makefile.in (gnu-v3-abi.o): Delete special rule.
	(eval.o, gnu-v3-abi.o, ia64-tdep.o): Update.
	* ada-valprint.c (ada_print_scalar): Update for new type codes.
	* c-typeprint.c (c_print_type): Update for new type codes.
	(c_type_print_varspec_prefix, c_type_print_varspec_suffix)
	(c_type_print_base): Likewise.
	(c_type_print_args): Rewrite.
	* c-valprint.c (c_val_print): Update for new type codes.  Remove
	support for references to members.  Treat methods like functions.
	* cp-abi.c (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New.
	* cp-abi.h (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New prototypes.
	(struct cp_abi_ops): Add corresponding members.
	* cp-valprint.c (cp_print_class_method): Delete.
	(cp_find_class_member): New function.
	(cp_print_class_member): Use it.  Simplify support for bogus
	member pointers.
	* dwarf2read.c (quirk_gcc_member_function_pointer): Use
	lookup_methodptr_type.
	(read_tag_ptr_to_member_type): Likewise, and lookup_memberptr_type.
	* eval.c (evaluate_subexp_standard): Implement EVAL_SKIP for
	OP_SCOPE.  Update call to value_aggregate_elt.  Rewrite member
	pointer support.
	(evaluate_subexp_for_address): Handle OP_SCOPE explicitly.  Handle
	references returned by user defined operators.
	* f-typeprint.c (f_print_type, f_type_print_varspec_prefix)
	(f_type_print_varspec_suffix): Remove support for member pointers.
	* gdbtypes.c (lookup_memberptr_type): Renamed from lookup_member_type
	and adjusted.
	(smash_to_memberptr_type): Likewise, from smash_to_member_type.
	(lookup_methodptr_type): New.
	(rank_one_type): Adjust for TYPE_CODE_MEMBERPTR.
	(recursive_dump_type): Update for new types.
	* gdbtypes.h (enum type_code): Replace TYPE_CODE_MEMBER with
	TYPE_CODE_MEMBERPTR and TYPE_CODE_METHODPTR.
	(lookup_memberptr_type, lookup_methodptr_type)
	(smash_to_memberptr_type): New prototypes.
	(smash_to_method_type): Formatting fix.
	(lookup_member_type, smash_to_member_type): Delete prototypes.
	* gnu-v3-abi.c (gnuv3_get_vtable, gnuv3_get_virtual_fn): New.
	Do not rely on debug information for the vptr or the method's
	enclosing type.  Handle function descriptors for IA64.
	(gnuv3_virtual_fn_field): Rewrite using the new functions.
	(gnuv3_find_method_in, gnuv3_print_method_ptr)
	(gnuv3_method_ptr_size, gnuv3_make_method_ptr)
	(gnuv3_method_ptr_to_value): New.
	(init_gnuv3_ops): Set new members of gnu_v3_abi_ops.
	* hpread.c (hpread_type_lookup): Update for new types.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-typeprint.c (m2_print_type): Remove explicit support
	for member pointers.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix)
	(pascal_type_print_varspec_suffix, pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_object_print_class_method, pascal_object_print_class_member):
	Delete.
	* p-lang.h (pascal_object_print_class_method)
	(pascal_object_print_class_member): Delete prototypes.
	* stabsread.c (read_type): Update for new types.
	* typeprint.c (print_type_scalar): Likewise.
	* valops.c (value_struct_elt_for_reference, value_namespace_elt)
	(value_maybe_namespace_elt, value_aggregate_elt): Add want_address
	argument.  Construct a pointer to member if the address of a
	function or data member is requested.
	(value_cast_pointers): Don't modify the input value.
	(value_cast): Adjust pointer to member handling for new types.
	Allow null pointer to member constants.  Don't modify the input
	value.
	(value_ind): Remove pointer to member check.  Handle function
	descriptors for function pointers.
	(value_struct_elt, value_find_oload_method_list, check_field):
	Remove pointer to member checks.
	* value.c (unpack_long): Allow pointers to data members.
	(value_from_longest): Allow member pointers.
	* value.h (value_aggregate_elt): Add want_address.
	* varobj.c (c_variable_editable): Remove check for members.
	* gdbarch.sh: Add vtable_function_descriptors and vbit_in_delta.
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): Handle descriptors
	in virtual tables.
	(ia64_gdbarch_init): Call set_gdbarch_vtable_function_descriptors.
	* c-lang.h (cp_print_class_method): Delete prototype.
	* arm-tdep.c (arm_gdbarch_init): Call set_gdbarch_vbit_in_delta.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	* gdbarch.c, gdbarch.h: Regenerated.

	* gdb.cp/classes.exp (test_pointers_to_class_members): Update expected
	output.  Test the types of members and member pointers.
	* gdb.cp/inherit.exp (test_print_mi_member_types): Remove KFAILs for
	gdb/2092.
	* gdb.cp/member-ptr.exp: Search for a comment instead of a
	statement.  Enable for GCC.  Update expected output for some tests
	and add new tests.  Remove obsolete GCC KFAILs.  Allow GCC's class
	layout.
	* gdb.cp/member-ptr.cc (Padding, Padding::vspacer, Base, Base::get_x)
	(Base::vget_base, Left, Left::vget, Right, Right::vget, Diamond)
	(Diamond::vget_base): New.
	(main): Add new tests.
	* gdb.cp/printmethod.exp: Update expected output for member functions.
	* gdb.cp/virtfunc.exp (test_virtual_calls): Add a KFAIL for
	print pEe->D::vg().
@
text
@d654 1
a654 2
	if (VALUE_LVAL (toval) == lval_register
	    && CONVERT_REGISTER_P (VALUE_REGNUM (toval), type))
d663 4
a666 20
	    /* TOVAL is stored in a series of registers in the frame
	       specified by the structure.  Copy that value out,
	       modify it, and copy it back in.  */
	    int amount_copied;
	    int amount_to_copy;
	    gdb_byte *buffer;
	    int reg_offset;
	    int byte_offset;
	    int regno;

	    /* Locate the first register that falls in the value that
	       needs to be transfered.  Compute the offset of the
	       value in that register.  */
	    {
	      int offset;
	      for (reg_offset = value_reg, offset = 0;
		   offset + register_size (current_gdbarch, reg_offset) <= value_offset (toval);
		   reg_offset++);
	      byte_offset = value_offset (toval) - offset;
	    }
d668 20
a687 4
	    /* Compute the number of register aligned values that need
	       to be copied.  */
	    if (value_bitsize (toval))
	      amount_to_copy = byte_offset + 1;
d689 7
a695 25
	      amount_to_copy = byte_offset + TYPE_LENGTH (type);
	    
	    /* And a bounce buffer.  Be slightly over generous.  */
	    buffer = alloca (amount_to_copy + MAX_REGISTER_SIZE);

	    /* Copy it in.  */
	    for (regno = reg_offset, amount_copied = 0;
		 amount_copied < amount_to_copy;
		 amount_copied += register_size (current_gdbarch, regno), regno++)
	      frame_register_read (frame, regno, buffer + amount_copied);
	    
	    /* Modify what needs to be modified.  */
	    if (value_bitsize (toval))
	      modify_field (buffer + byte_offset,
			    value_as_long (fromval),
			    value_bitpos (toval), value_bitsize (toval));
	    else
	      memcpy (buffer + byte_offset, value_contents (fromval),
		      TYPE_LENGTH (type));

	    /* Copy it out.  */
	    for (regno = reg_offset, amount_copied = 0;
		 amount_copied < amount_to_copy;
		 amount_copied += register_size (current_gdbarch, regno), regno++)
	      put_frame_register (frame, regno, buffer + amount_copied);
a696 1
	  }
@


1.165
log
@2006-10-09  Paul Pluzhnikov  <ppluzhnikov@@charter.net>

	PR c++/2116
	* valops.c (find_overload_match): Check for a NULL name.

2006-10-09  Daniel Jacobowitz  <dan@@codesourcery.com>

	PR c++/2116
	* gdb.cp/call-c.cc, gdb.cp/call-c.exp, gdb.cp/call-c-1.c: New.
@
text
@d4 2
a5 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d101 1
d105 1
a105 1
					  char *name,
d109 1
a109 1
						char *name,
d264 1
d372 2
a373 1
	   && (scalar || code2 == TYPE_CODE_PTR))
d377 3
a379 2
      if (deprecated_hp_som_som_object_present	/* if target compiled by HP aCC */
	  && (code2 == TYPE_CODE_PTR))
d384 6
a389 17
	  switch (TYPE_CODE (TYPE_TARGET_TYPE (type2)))
	    {
	      /* With HP aCC, pointers to data members have a bias */
	    case TYPE_CODE_MEMBER:
	      retvalp = value_from_longest (type, value_as_long (arg2));
	      /* force evaluation */
	      ptr = (unsigned int *) value_contents (retvalp);
	      *ptr &= ~0x20000000;	/* zap 29th bit to remove bias */
	      return retvalp;

	      /* While pointers to methods don't really point to a function */
	    case TYPE_CODE_METHOD:
	      error (_("Pointers to methods not supported with HP aCC"));

	    default:
	      break;		/* fall out and go to normal handling */
	    }
d431 14
d450 1
a951 3
  if (TYPE_CODE (base_type) == TYPE_CODE_MEMBER)
    error (_("not implemented: member types in value_ind"));

d966 11
a976 3
      /* Retrieve the enclosing object pointed to */
      arg2 = value_at_lazy (enc_type, (value_as_address (arg1)
				       - value_pointed_to_offset (arg1)));
a1615 3
  if (TYPE_CODE (t) == TYPE_CODE_MEMBER)
    error (_("not implemented: member type in value_struct_elt"));

a1811 3
  if (TYPE_CODE (t) == TYPE_CODE_MEMBER)
    error (_("Not implemented: member type in value_find_oload_lis"));

a2344 3
  if (TYPE_CODE (t) == TYPE_CODE_MEMBER)
    error (_("not implemented: member type in check_field"));

d2353 4
a2356 4
   return the appropriate member.  This function is used to resolve
   user expressions of the form "DOMAIN::NAME".  For more details on
   what happens, see the comment before
   value_struct_elt_for_reference.  */
d2360 1
a2360 1
		     char *name,
d2368 1
a2368 1
					     noside);
d2370 1
a2370 1
      return value_namespace_elt (curtype, name, noside);
d2387 1
a2387 1
				struct type *intype,
d2392 1
a2392 1
  struct value *v;
d2410 2
d2417 8
a2424 4
	  return value_from_longest
	    (lookup_reference_type (lookup_member_type (TYPE_FIELD_TYPE (t, i),
							domain)),
	     offset + (LONGEST) (TYPE_FIELD_BITPOS (t, i) >> 3));
d2475 13
d2490 12
a2501 5
	      return value_from_longest
		(lookup_reference_type
		 (lookup_member_type (TYPE_FN_FIELD_TYPE (f, j),
				      domain)),
		 (LONGEST) METHOD_PTR_FROM_VOFFSET (TYPE_FN_FIELD_VOFFSET (f, j)));
d2508 5
a2512 3
		{
		  v = 0;
		}
d2515 3
a2517 6
		  v = read_var_value (s, 0);
#if 0
		  VALUE_TYPE (v) = lookup_reference_type
		    (lookup_member_type (TYPE_FN_FIELD_TYPE (f, j),
					 domain));
#endif
a2518 1
	      return v;
d2520 1
d2536 1
a2536 1
					  intype,
d2546 1
a2546 1
  return value_maybe_namespace_elt (curtype, name, noside);
d2554 1
a2554 1
		     char *name,
d2558 1
a2558 1
						    noside);
d2575 1
a2575 1
			   char *name,
d2580 1
d2590 1
a2590 1
    return allocate_value (SYMBOL_TYPE (sym));
d2592 6
a2597 1
    return value_of_variable (sym, get_selected_block (0));
@


1.164
log
@gdb/
	* infcall.c (value_arg_coerce): Use value_cast_pointers for
	references.  Avoid value_cast to a reference type.  Don't silently
	convert pointers to references.
	* valops.c (value_cast_pointers): New, based on value_cast.
	(value_cast): Use it.  Reject reference types.
	(value_ref): New.
	(typecmp): Use it.
	* value.h (value_cast_pointers, value_ref): New prototypes.
gdb/testsuite/
	* gdb.cp/ref-params.exp: New test.
	* gdb.cp/ref-params.cc: New source file.
	* gdb.cp/Makefile.in (EXECUTABLES): Add ref-params.
@
text
@a1891 1
      func_name	= cp_func_name (qualified_name);
d1893 8
a1900 2
      /* If the name is NULL this must be a C-style function.
         Just return the same symbol. */
@


1.163
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d204 64
d291 4
d440 1
a440 8
	{
	  struct type *t1 = check_typedef (TYPE_TARGET_TYPE (type));
	  struct type *t2 = check_typedef (TYPE_TARGET_TYPE (type2));
	  if (TYPE_CODE (t1) == TYPE_CODE_STRUCT
	      && TYPE_CODE (t2) == TYPE_CODE_STRUCT
	      && !value_logical_not (arg2))
	    {
	      struct value *v;
a441 35
	      /* Look in the type of the source to see if it contains the
	         type of the target as a superclass.  If so, we'll need to
	         offset the pointer rather than just change its type.  */
	      if (TYPE_NAME (t1) != NULL)
		{
		  v = search_struct_field (type_name_no_tag (t1),
					   value_ind (arg2), 0, t2, 1);
		  if (v)
		    {
		      v = value_addr (v);
		      deprecated_set_value_type (v, type);
		      return v;
		    }
		}

	      /* Look in the type of the target to see if it contains the
	         type of the source as a superclass.  If so, we'll need to
	         offset the pointer rather than just change its type.
	         FIXME: This fails silently with virtual inheritance.  */
	      if (TYPE_NAME (t2) != NULL)
		{
		  v = search_struct_field (type_name_no_tag (t2),
				       value_zero (t1, not_lval), 0, t1, 1);
		  if (v)
		    {
                      CORE_ADDR addr2 = value_as_address (arg2);
                      addr2 -= (VALUE_ADDRESS (v)
                                + value_offset (v)
                                + value_embedded_offset (v));
                      return value_from_pointer (type, addr2);
		    }
		}
	    }
	  /* No superclass found, just fall through to change ptr type.  */
	}
d915 16
d1151 1
a1151 1
	    t2[i] = value_addr (t2[i]);
@


1.163.12.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a203 64
/* Cast one pointer or reference type to another.  Both TYPE and
   the type of ARG2 should be pointer types, or else both should be
   reference types.  Returns the new pointer or reference.  */

struct value *
value_cast_pointers (struct type *type, struct value *arg2)
{
  struct type *type2 = check_typedef (value_type (arg2));
  struct type *t1 = check_typedef (TYPE_TARGET_TYPE (type));
  struct type *t2 = check_typedef (TYPE_TARGET_TYPE (type2));

  if (TYPE_CODE (t1) == TYPE_CODE_STRUCT
      && TYPE_CODE (t2) == TYPE_CODE_STRUCT
      && !value_logical_not (arg2))
    {
      struct value *v;

      /* Look in the type of the source to see if it contains the
	 type of the target as a superclass.  If so, we'll need to
	 offset the pointer rather than just change its type.  */
      if (TYPE_NAME (t1) != NULL)
	{
	  struct value *v2;

	  if (TYPE_CODE (type2) == TYPE_CODE_REF)
	    v2 = coerce_ref (arg2);
	  else
	    v2 = value_ind (arg2);
	  v = search_struct_field (type_name_no_tag (t1),
				   v2, 0, t2, 1);
	  if (v)
	    {
	      v = value_addr (v);
	      deprecated_set_value_type (v, type);
	      return v;
	    }
	}

      /* Look in the type of the target to see if it contains the
	 type of the source as a superclass.  If so, we'll need to
	 offset the pointer rather than just change its type.
	 FIXME: This fails silently with virtual inheritance.  */
      if (TYPE_NAME (t2) != NULL)
	{
	  v = search_struct_field (type_name_no_tag (t2),
				   value_zero (t1, not_lval), 0, t1, 1);
	  if (v)
	    {
	      CORE_ADDR addr2 = value_as_address (arg2);
	      addr2 -= (VALUE_ADDRESS (v)
			+ value_offset (v)
			+ value_embedded_offset (v));
	      return value_from_pointer (type, addr2);
	    }
	}
    }

  /* No superclass found, just change the pointer type.  */
  deprecated_set_value_type (arg2, type);
  arg2 = value_change_enclosing_type (arg2, type);
  set_value_pointed_to_offset (arg2, 0);	/* pai: chk_val */
  return arg2;
}

a226 4
  /* You can't cast to a reference type.  See value_cast_pointers
     instead.  */
  gdb_assert (code1 != TYPE_CODE_REF);

d372 8
a379 1
	return value_cast_pointers (type, arg2);
d381 35
a888 16
/* Return a reference value for the object for which ARG1 is the contents.  */

struct value *
value_ref (struct value *arg1)
{
  struct value *arg2;

  struct type *type = check_typedef (value_type (arg1));
  if (TYPE_CODE (type) == TYPE_CODE_REF)
    return arg1;

  arg2 = value_addr (arg1);
  deprecated_set_value_type (arg2, lookup_reference_type (type));
  return arg2;
}

d1109 1
a1109 1
	    t2[i] = value_ref (t2[i]);
@


1.163.2.1
log
@Merge XML and VFP support to this branch.
@
text
@d547 1
a547 1
  old_frame = get_frame_id (deprecated_safe_get_selected_frame ());
a2607 1
  struct frame_info *frame;
d2609 1
a2609 3
  if (complain)
    frame = get_selected_frame (_("no frame selected"));
  else
d2611 3
a2613 2
      frame = deprecated_safe_get_selected_frame ();
      if (frame == 0)
d2617 1
a2617 1
  func = get_frame_function (frame);
d2646 1
a2646 1
  ret = read_var_value (sym, frame);
@


1.163.4.1
log
@Add a Debian patch that prevents some bogus "No selected frame" errors.
This needs to go to mainline separately.
@
text
@d547 1
a547 1
  old_frame = get_frame_id (deprecated_safe_get_selected_frame ());
a2607 1
  struct frame_info *frame;
d2609 1
a2609 3
  if (complain)
    frame = get_selected_frame (_("no frame selected"));
  else
d2611 3
a2613 2
      frame = deprecated_safe_get_selected_frame ();
      if (frame == 0)
d2617 1
a2617 1
  func = get_frame_function (frame);
d2646 1
a2646 1
  ret = read_var_value (sym, frame);
@


1.162
log
@gdb/
	* valops.c (value_struct_elt): Clarify error message.
gdb/testsuite/
2005-12-07  Christophe Lyon  <christophe.lyon@@st.com>
	* gdb.cp/printmethod.cc (main): Call virt and nonvirt, to force
	code generation for these functions.
	* gdb.cp/printmethod.exp: Expect "&A::nonvirt()" instead of an
	error message.
@
text
@d3 1
a3 1
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.161
log
@2005-05-27  Andrew Cagney  <cagney@@gnu.org>

	* jv-lang.c (get_java_utf8_name): Add cast.
	(evaluate_subexp_java): Use gdb_byte for buffers.
	* jv-valprint.c (java_value_print, java_value_print): Use gdb_byte
	for buffers.
	* scm-lang.c (scm_get_field, scm_unpack)
	(scm_evaluate_string): Use gdb_byte for buffers.
	(scm_lookup_name): Add cast.
	* scm-valprint.c (scm_scmval_print, scm_scmval_print): Use
	gdb_byte for buffers.
	* tui/tui.h (tui_get_command_dimension): Make parameters unsigned.
	* tui/tui.c (tui_get_command_dimension): Make parameters unsigned.
	* value.h (check_field): Change "name" to a string.
	* valops.c (check_field): Change "name" to a string.
	* scm-lang.h (scm_parse): Use gdb_byte for buffers.
	* source.c (get_current_source_symtab_and_line)
	(set_current_source_symtab_and_line): Initialize all fields of sal
	structures.
	* cli/cli-cmds.c (list_command): Use gdb_byte for buffers.
@
text
@d1590 1
a1590 1
	error (_("Cannot take address of a method"));
@


1.160
log
@2005-05-26  Andrew Cagney  <cagney@@gnu.org>

	* command.h (add_setshow_integer_cmd): Make VAR an integer.
	* cli/cli-decode.c (add_setshow_integer_cmd): Update to match.
	* valops.c (value_string): Add a cast.
	* eval.c (evaluate_subexp_standard): Use gdb_byte for byte buffers.
	* breakpoint.c (re_enable_breakpoints_in_shlibs): Use gdb_byte for
	byte buffers.
	* target.h (struct target_ops): For to_insert_hw_breakpoint and
	to_remove_hw_breakpoint use gdb_byte for byte buffer parameters.
	* breakpoint.h (struct bp_location): Make shadow_contents a
	gdb_byte buffer.
	* cli/cli-setshow.c (do_setshow_command): Fix cast.
	* cli/cli-dump.c (restore_section_callback)
	(restore_binary_file): Use gdb_byte for byte buffers.
	* proc-service.c (ps_ptwrite, ps_ptread, ps_pdwrite): Fix casts.
	(ps_xfer_memory): Use gdb_byte for byte buffers.
	* tracepoint.c (mem2hex): Use gdb_byte for byte buffers, and char
	for string buffers.
	* ser-tcp.c (net_open): Make len a socklen_t.
@
text
@d2272 1
a2272 1
check_field (struct value *arg1, const gdb_byte *name)
@


1.159
log
@2005-05-22  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (frame_register_unwind, frame_unwind_register)
	(get_frame_register, frame_register, put_frame_register)
	(get_frame_memory, safe_frame_unwind_memory)
	(frame_register_read): Use gdb_byte for byte buffer parameters.
	* trad-frame.h (trad_frame_get_register)
	(frame_get_prev_register): Ditto.
	* frame-unwind.h (frame_prev_register_ftype): Ditto.
	* frame.c (frame_pop, frame_register, frame_unwind_register)
	(get_frame_register, frame_unwind_register_signed)
	(frame_unwind_register_unsigned, frame_unwind_unsigned_register)
	(frame_register_read, get_frame_memory): Update.
	* trad-frame.c (trad_frame_get_prev_register): Update.
	(trad_frame_get_register): Update.
	* gdbcore.h (deprecated_read_memory_nobpt, read_memory): Ditto.
	* breakpoint.c (deprecated_read_memory_nobpt): Update.
	* corefile.c (read_memory): Update.
	* tramp-frame.c (tramp_frame_prev_register): Update.
	* valops.c (value_assign): Update.
	* sentinel-frame.c (sentinel_frame_prev_register): Update.
	* std-regs.c (value_of_builtin_frame_fp_reg)
	(value_of_builtin_frame_pc_reg): Update.
	* infcmd.c (default_print_registers_info): Update
	* dummy-frame.c (dummy_frame_prev_register): Update.
	* findvar.c (value_of_register, value_from_register): Update.
	* tui/tui-regs.c (tui_register_format, tui_get_register): Update.
	* mi/mi-main.c (register_changed_p, get_register): Update.
@
text
@d1042 1
a1042 1
  write_memory (addr, ptr, len);
@


1.158
log
@2005-05-19  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (extract_signed_integer, extract_unsigned_integer)
	(extract_long_unsigned_integer, extract_typed_address)
	(store_signed_integer, store_unsigned_integer)
	(store_typed_address): Use gdb_byte for byte buffer parameters.
	(push_bytes, push_word): Delete declaration.
	* valops.c (push_bytes, push_word): Delete function.
	* findvar.c (extract_signed_integer, extract_unsigned_integer)
	(extract_typed_address, store_signed_integer)
	(store_unsigned_integer): Update.

Index: defs.h
===================================================================
RCS file: /cvs/src/src/gdb/defs.h,v
retrieving revision 1.185
diff -p -u -r1.185 defs.h
--- defs.h	9 May 2005 17:20:18 -0000	1.185
+++ defs.h	19 May 2005 17:54:12 -0000
@@@@ -1042,27 +1042,25 @@@@ enum { MAX_REGISTER_SIZE = 16 };

 /* In findvar.c.  */

-extern LONGEST extract_signed_integer (const void *, int);
+extern LONGEST extract_signed_integer (const gdb_byte *, int);

-extern ULONGEST extract_unsigned_integer (const void *, int);
+extern ULONGEST extract_unsigned_integer (const gdb_byte *, int);

-extern int extract_long_unsigned_integer (const void *, int, LONGEST *);
+extern int extract_long_unsigned_integer (const gdb_byte *, int, LONGEST *);

-extern CORE_ADDR extract_typed_address (const void *buf, struct type *type);
+extern CORE_ADDR extract_typed_address (const gdb_byte *buf,
+					struct type *type);

-extern void store_signed_integer (void *, int, LONGEST);
+extern void store_signed_integer (gdb_byte *, int, LONGEST);

-extern void store_unsigned_integer (void *, int, ULONGEST);
+extern void store_unsigned_integer (gdb_byte *, int, ULONGEST);

-extern void store_typed_address (void *buf, struct type *type, CORE_ADDR addr);
+extern void store_typed_address (gdb_byte *buf, struct type *type,
+				 CORE_ADDR addr);

 
 /* From valops.c */

-extern CORE_ADDR push_bytes (CORE_ADDR, char *, int);
-
-extern CORE_ADDR push_word (CORE_ADDR, ULONGEST);
-
 extern int watchdog;

 /* Hooks for alternate command interfaces.  */
Index: findvar.c
===================================================================
RCS file: /cvs/src/src/gdb/findvar.c,v
retrieving revision 1.91
diff -p -u -r1.91 findvar.c
--- findvar.c	14 May 2005 06:07:41 -0000	1.91
+++ findvar.c	19 May 2005 17:54:12 -0000
@@@@ -49,7 +49,7 @@@@ you lose
 #endif

 LONGEST
-extract_signed_integer (const void *addr, int len)
+extract_signed_integer (const gdb_byte *addr, int len)
 {
   LONGEST retval;
   const unsigned char *p;
@@@@ -83,7 +83,7 @@@@ That operation is not available on integ
 }

 ULONGEST
-extract_unsigned_integer (const void *addr, int len)
+extract_unsigned_integer (const gdb_byte *addr, int len)
 {
   ULONGEST retval;
   const unsigned char *p;
@@@@ -117,16 +117,18 @@@@ That operation is not available on integ
    function returns 1 and sets *PVAL.  Otherwise it returns 0.  */

 int
-extract_long_unsigned_integer (const void *addr, int orig_len, LONGEST *pval)
+extract_long_unsigned_integer (const gdb_byte *addr, int orig_len,
+			       LONGEST *pval)
 {
-  char *p, *first_addr;
+  const gdb_byte *p;
+  const gdb_byte *first_addr;
   int len;

   len = orig_len;
   if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
     {
-      for (p = (char *) addr;
-	   len > (int) sizeof (LONGEST) && p < (char *) addr + orig_len;
+      for (p = addr;
+	   len > (int) sizeof (LONGEST) && p < addr + orig_len;
 	   p++)
 	{
 	  if (*p == 0)
@@@@ -138,9 +140,9 @@@@ extract_long_unsigned_integer (const voi
     }
   else
     {
-      first_addr = (char *) addr;
-      for (p = (char *) addr + orig_len - 1;
-	   len > (int) sizeof (LONGEST) && p >= (char *) addr;
+      first_addr = addr;
+      for (p = addr + orig_len - 1;
+	   len > (int) sizeof (LONGEST) && p >= addr;
 	   p--)
 	{
 	  if (*p == 0)
@@@@ -164,7 +166,7 @@@@ extract_long_unsigned_integer (const voi
 /* Treat the bytes at BUF as a pointer of type TYPE, and return the
    address it represents.  */
 CORE_ADDR
-extract_typed_address (const void *buf, struct type *type)
+extract_typed_address (const gdb_byte *buf, struct type *type)
 {
   if (TYPE_CODE (type) != TYPE_CODE_PTR
       && TYPE_CODE (type) != TYPE_CODE_REF)
@@@@ -177,11 +179,11 @@@@ extract_typed_address (const void *buf,


 void
-store_signed_integer (void *addr, int len, LONGEST val)
+store_signed_integer (gdb_byte *addr, int len, LONGEST val)
 {
-  unsigned char *p;
-  unsigned char *startaddr = (unsigned char *) addr;
-  unsigned char *endaddr = startaddr + len;
+  gdb_byte *p;
+  gdb_byte *startaddr = addr;
+  gdb_byte *endaddr = startaddr + len;

   /* Start at the least significant end of the integer, and work towards
      the most significant.  */
@@@@ -204,7 +206,7 @@@@ store_signed_integer (void *addr, int le
 }

 void
-store_unsigned_integer (void *addr, int len, ULONGEST val)
+store_unsigned_integer (gdb_byte *addr, int len, ULONGEST val)
 {
   unsigned char *p;
   unsigned char *startaddr = (unsigned char *) addr;
@@@@ -233,7 +235,7 @@@@ store_unsigned_integer (void *addr, int
 /* Store the address ADDR as a pointer of type TYPE at BUF, in target
    form.  */
 void
-store_typed_address (void *buf, struct type *type, CORE_ADDR addr)
+store_typed_address (gdb_byte *buf, struct type *type, CORE_ADDR addr)
 {
   if (TYPE_CODE (type) != TYPE_CODE_PTR
       && TYPE_CODE (type) != TYPE_CODE_REF)
Index: valops.c
===================================================================
RCS file: /cvs/src/src/gdb/valops.c,v
retrieving revision 1.157
diff -p -u -r1.157 valops.c
--- valops.c	9 May 2005 21:20:35 -0000	1.157
+++ valops.c	19 May 2005 17:54:12 -0000
@@@@ -933,54 +933,6 @@@@ value_ind (struct value *arg1)
   return 0;			/* For lint -- never reached */
 }
 
-/* Pushing small parts of stack frames.  */
-
-/* Push one word (the size of object that a register holds).  */
-
-CORE_ADDR
-push_word (CORE_ADDR sp, ULONGEST word)
-{
-  int len = DEPRECATED_REGISTER_SIZE;
-  char buffer[MAX_REGISTER_SIZE];
-
-  store_unsigned_integer (buffer, len, word);
-  if (INNER_THAN (1, 2))
-    {
-      /* stack grows downward */
-      sp -= len;
-      write_memory (sp, buffer, len);
-    }
-  else
-    {
-      /* stack grows upward */
-      write_memory (sp, buffer, len);
-      sp += len;
-    }
-
-  return sp;
-}
-
-/* Push LEN bytes with data at BUFFER.  */
-
-CORE_ADDR
-push_bytes (CORE_ADDR sp, char *buffer, int len)
-{
-  if (INNER_THAN (1, 2))
-    {
-      /* stack grows downward */
-      sp -= len;
-      write_memory (sp, buffer, len);
-    }
-  else
-    {
-      /* stack grows upward */
-      write_memory (sp, buffer, len);
-      sp += len;
-    }
-
-  return sp;
-}
-
 /* Create a value for an array by allocating space in the inferior, copying
    the data into that space, and then setting up an array value.
@
text
@d572 1
a572 1
        char buffer[sizeof (LONGEST)];
d634 1
a634 1
	    char *buffer;
d658 1
a658 1
	    buffer = (char *) alloca (amount_to_copy + MAX_REGISTER_SIZE);
@


1.157
log
@2005-05-09  Andrew Cagney  <cagney@@gnu.org>

	Use gdb_byte in preference to bfd_byte.
	* gdbarch.sh: Update.
	* gdbarch.h, gdbarch.c: Re-generate.
	* ada-lang.c, ada-lang.h, ada-valprint.c, arch-utils.c: Update.
	* c-lang.c, c-lang.h, c-valprint.c, cp-valprint.c: Update.
	* f-lang.c, f-lang.h, f-valprint.c, gdbcore.h, jv-lang.h: Update.
	* jv-valprint.c, language.c, language.h, m2-lang.c: Update.
	* m2-lang.h, m2-valprint.c, objc-lang.c, p-lang.c: Update.
	* p-lang.h, p-valprint.c, regcache.c, scm-lang.c: Update.
	* scm-lang.h, scm-valprint.c, target.c, target.h: Update.
	* tramp-frame.c, valarith.c, valops.c, valprint.c: Update.
	* valprint.h, value.c, value.h: Update.
@
text
@a935 48
/* Pushing small parts of stack frames.  */

/* Push one word (the size of object that a register holds).  */

CORE_ADDR
push_word (CORE_ADDR sp, ULONGEST word)
{
  int len = DEPRECATED_REGISTER_SIZE;
  char buffer[MAX_REGISTER_SIZE];

  store_unsigned_integer (buffer, len, word);
  if (INNER_THAN (1, 2))
    {
      /* stack grows downward */
      sp -= len;
      write_memory (sp, buffer, len);
    }
  else
    {
      /* stack grows upward */
      write_memory (sp, buffer, len);
      sp += len;
    }

  return sp;
}

/* Push LEN bytes with data at BUFFER.  */

CORE_ADDR
push_bytes (CORE_ADDR sp, char *buffer, int len)
{
  if (INNER_THAN (1, 2))
    {
      /* stack grows downward */
      sp -= len;
      write_memory (sp, buffer, len);
    }
  else
    {
      /* stack grows upward */
      write_memory (sp, buffer, len);
      sp += len;
    }

  return sp;
}

@


1.156
log
@2005-04-28  Andrew Cagney  <cagney@@gnu.org>

	* valops.c (check_field): Make buffer a bfd_byte.
	* value.c (unpack_long, unpack_double, unpack_pointer)
	(unpack_field_as_long, modify_field): Ditto.
	* value.h: Update declarations.
@
text
@d569 1
a569 1
	const bfd_byte *dest_buffer;
d1367 1
a1367 1
		      const bfd_byte *valaddr, int offset, int *boffset_p,
d1523 1
a1523 1
	      const bfd_byte *base_valaddr;
d1531 1
a1531 1
		  bfd_byte *tmp = alloca (TYPE_LENGTH (baseclass));
d2320 1
a2320 1
check_field (struct value *arg1, const bfd_byte *name)
@


1.155
log
@2005-02-24  Andrew Cagney  <cagney@@gnu.org>

	Add show_VARIABLE functions, update add_setshow call.
	* varobj.c (_initialize_varobj, show_varobjdebug): Add and update.
	* valprint.c (_initialize_valprint, show_print_max)
	(show_stop_print_at_null, show_repeat_count_threshold)
	(show_prettyprint_structs, show_unionprint)
	(show_prettyprint_arrays, show_addressprint, show_input_radix)
	(show_output_radix): Ditto.
	* valops.c (_initialize_valops, show_overload_resolution): Ditto.
	* utils.c (initialize_utils, show_chars_per_line)
	(show_lines_per_page, show_demangle, show_pagination_enabled)
	(show_sevenbit_strings, show_asm_demangle): Ditto
	* tui/tui-win.c (_initialize_tui_win, show_tui_border_kind)
	(show_tui_border_mode, show_tui_active_border_mode): Ditto.
	* top.c (init_main, show_new_async_prompt)
	(show_async_command_editing_p, show_write_history_p)
	(show_history_size, show_history_filename, show_caution)
	(show_annotation_level, init_main): Ditto.
	* target.c (initialize_targets, show_targetdebug)
	(show_trust_readonly): Ditto.
	* symfile.c (_initialize_symfile, show_symbol_reloading)
	(show_ext_args, show_download_write_size)
	(show_debug_file_directory): Ditto.
	* source.c (_initialize_source, show_lines_to_list): Ditto.
	* solib.c (_initialize_solib, show_auto_solib_add)
	(show_solib_search_path): Ditto.
	* p-valprint.c (_initialize_pascal_valprint)
	(show_pascal_static_field_print): Ditto.
	* printcmd.c (_initialize_printcmd, show_max_symbolic_offset)
	(show_print_symbol_filename): Add and update.
	* parse.c (_initialize_parse, show_expressiondebug): Dito.
	* observer.c (_initialize_observer, show_observer_debug): Dito.
	* maint.c (_initialize_maint_cmds, show_watchdog)
	(show_maintenance_profile_p): Dito.
	* linux-nat.c (_initialize_linux_nat, show_debug_linux_nat): Dito.
	* infrun.c (_initialize_infrun, show_debug_infrun)
	(show_stop_on_solib_events, show_follow_fork_mode_string)
	(show_scheduler_mode, show_step_stop_if_no_debug): Ditto.
	* infcall.c (_initialize_infcall, show_coerce_float_to_double_p)
	(show_unwind_on_signal_p): Ditto.
	* gdbtypes.c (build_gdbtypes, show_opaque_type_resolution)
	(_initialize_gdbtypes, show_overload_debug): Ditto.
	* gdb-events.c, gdb-events.sh (_initialize_gdb_events)
	(show_gdb_events_debug): Ditto.
	* gdbarch.c, gdbarch.sh (show_gdbarch_debug)
	(_initialize_gdbarch): Ditto.
	* frame.c (_initialize_frame, show_backtrace_past_main)
	(show_backtrace_past_entry, show_backtrace_limit)
	(show_frame_debug): Ditto.
	* exec.c (_initialize_exec, show_write_files): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read)
	(show_dwarf2_max_cache_age): Ditto.
	* demangle.c (_initialize_demangler)
	(show_demangling_style_names): Ditto.
	* dcache.c (_initialize_dcache, show_dcache_enabled_p): Ditto.
	* cp-valprint.c (show_static_field_print)
	(_initialize_cp_valprint, show_vtblprint, show_objectprint): Ditto.
	* corefile.c (_initialize_core, show_gnutarget_string): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging)
	(show_logging_overwrite, show_logging_redirect)
	(show_logging_filename): Ditto.
	* cli/cli-cmds.c (show_info_verbose, show_history_expansion_p)
	(init_cli_cmds, show_baud_rate, show_remote_debug)
	(show_remote_timeout, show_max_user_call_depth): Ditto.
	* charset.c (show_host_charset_name, show_target_charset_name)
	(initialize_charset): Ditto.
	* breakpoint.c (show_can_use_hw_watchpoints)
	(show_pending_break_support, _initialize_breakpoint): Ditto.
@
text
@d2320 1
a2320 1
check_field (struct value *arg1, const char *name)
@


1.154
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_boolean_command through out.  Delete #ifdef 0'ed
	code adding set/show boolean commands.
	* cp-valprint.c, dcache.c, exec.c, gdbtypes.c, infrun.c: Update.
	* monitor.c, p-valprint.c, pa64solib.c, printcmd.c: Update.
	* proc-api.c, remote-mips.c, remote.c, solib.c: Update.
	* somsolib.c, symfile.c, top.c, utils.c, valops.c: Update.
	* valprint.c, win32-nat.c, wince.c, xcoffsolib.c: Update.
	* cli/cli-cmds.c: Update.
@
text
@d129 8
d2849 1
a2849 1
			   NULL, /* FIXME: i18n: */
@


1.153
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d2836 7
a2842 13
#if 0
  deprecated_add_show_from_set
    (add_set_cmd ("abandon", class_support, var_boolean, (char *) &auto_abandon,
		  "Set automatic abandonment of expressions upon failure.",
		  &setlist),
     &showlist);
#endif

  deprecated_add_show_from_set
    (add_set_cmd ("overload-resolution", class_support, var_boolean, (char *) &overload_resolution,
		  "Set overload resolution in evaluating C++ functions.",
		  &setlist),
     &showlist);
@


1.152
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d1124 1
a1124 1
    internal_error (__FILE__, __LINE__, "typecmp: no argument list");
d2361 1
a2361 1
		      "non-aggregate type in value_aggregate_elt");
@


1.151
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (set_value_offset): Declare.
	* value.c (set_value_offset): Declare.
	* gnu-v2-abi.c, jv-valprint.c, valarith.c, valops.c: Update.
	* findvar.c: Update.
@
text
@d141 1
a141 1
	  error ("\"%s\" exists in this program but is not a function.",
d162 1
a162 1
	    error ("evaluation of this expression requires the target program to be active");
d164 1
a164 1
	    error ("evaluation of this expression requires the program to have a function \"%s\".", name);
d183 1
a183 1
	error ("No memory available to program now: you need to start the target first");
d185 1
a185 1
	error ("No memory available to program: call to malloc failed");
d236 1
a236 1
	    warning ("array element type size does not divide object size in cast");
d315 1
a315 1
	      error ("Pointers to methods not supported with HP aCC");
d357 1
a357 1
	    warning ("value truncated");
d421 1
a421 1
      error ("Invalid cast.");
d455 1
a455 1
    error ("Attempt to dereference a generic pointer.");
d475 1
a475 1
    error ("Attempt to dereference a generic pointer.");
d525 1
a525 1
    error ("Left operand of assignment is not a modifiable lvalue.");
d576 1
a576 1
	      error ("Can't handle bitfields which don't fit in a %d bit word.",
d609 1
a609 1
	  error ("Value being assigned to is no longer active.");
d681 1
a681 1
      error ("Left operand of assignment is not an lvalue.");
d749 1
a749 1
    error ("Only values in memory can be extended with '@@'.");
d751 1
a751 1
    error ("Invalid number %d of repetitions.", count);
d779 1
a779 1
	    error ("No frame is currently executing in block %s.",
d782 1
a782 1
	    error ("No frame is currently executing in specified block");
d788 1
a788 1
    error ("Address of symbol \"%s\" is unknown.", SYMBOL_PRINT_NAME (var));
d822 1
a822 1
    error ("Attempt to take address of value not located in memory.");
d837 1
a837 1
    error ("Attempt to take address of value not located in memory.");
d865 1
a865 1
    error ("Attempt to take address of value not located in memory.");
d894 1
a894 1
    error ("not implemented: member types in value_ind");
d924 1
a924 1
  error ("Attempt to take contents of a non-pointer value.");
d1003 1
a1003 1
      error ("bad array bounds (%d, %d)", lowbound, highbound);
d1010 1
a1010 1
	  error ("array elements must all be the same size");
d1214 1
a1214 1
		  error ("field %s is nonexistent or has been optimised out",
d1221 1
a1221 1
		  error ("there is no field named %s", name);
d1289 1
a1289 1
	    error ("virtual baseclass botch");
d1303 1
a1303 1
		error ("virtual baseclass botch");
d1407 1
a1407 1
    error ("Couldn't find virtual table -- object may not be constructed yet.");
d1466 1
a1466 1
	    error ("cannot resolve overloaded method `%s': no arguments supplied", name);
d1510 1
a1510 1
		error ("Virtual base class offset not found in vtable");
d1527 1
a1527 1
		    error ("virtual baseclass botch");
d1538 1
a1538 1
		error ("virtual baseclass botch");
d1601 1
a1601 1
    error ("not implemented: member type in value_struct_elt");
d1605 1
a1605 1
    error ("Attempt to extract a component of a value that is not a %s.", err);
d1625 1
a1625 1
	error ("Cannot get value of destructor");
d1630 1
a1630 1
	error ("Cannot take address of a method");
d1634 1
a1634 1
	    error ("There is no member or method named %s.", name);
d1636 1
a1636 1
	    error ("There is no member named %s.", name);
d1655 1
a1655 1
	    error ("could not find destructor function named %s.", name);
d1661 1
a1661 1
	  error ("destructor should not have any argument");
d1669 1
a1669 1
      error ("One of the arguments you tried to pass to %s could not be converted to what the function wants.", name);
d1680 1
a1680 1
    error ("Structure has no component named %s.", name);
d1744 1
a1744 1
		error ("Virtual base class offset not found in vtable");
d1755 1
a1755 1
		error ("virtual baseclass botch");
d1800 1
a1800 1
    error ("Not implemented: member type in value_find_oload_lis");
d1804 1
a1804 1
    error ("Attempt to extract a component of a value that is not a struct or union");
d1876 1
a1876 1
	error ("Couldn't find method %s%s%s",
d1921 1
a1921 1
	error ("Cannot resolve method %s%s%s to any overloaded instance",
d1926 1
a1926 1
	error ("Cannot resolve function %s to any overloaded instance",
d1932 1
a1932 1
	warning ("Using non-standard conversion to match method %s%s%s to supplied arguments",
d1937 1
a1937 1
	warning ("Using non-standard conversion to match function %s to supplied arguments",
d2259 1
a2259 1
	error ("name of destructor must equal name of class");
d2331 1
a2331 1
    error ("not implemented: member type in check_field");
d2335 1
a2335 1
    error ("Internal error: `this' is not an aggregate");
d2384 1
a2384 1
    error ("Internal error: non-aggregate type to value_struct_elt_for_reference");
d2396 1
a2396 1
		error ("static field %s has been optimized out",
d2401 1
a2401 1
	    error ("pointers to bitfield members not allowed");
d2416 1
a2416 1
      error ("member pointers to destructors not implemented yet");
d2445 1
a2445 1
	    error ("non-unique member `%s' requires type instantiation", name);
d2452 1
a2452 1
		error ("no member function matches that type instantiation");
d2524 1
a2524 1
    error ("No symbol \"%s\" in namespace \"%s\".", name,
d2617 1
a2617 1
      warning ("Couldn't retrieve complete object of RTTI type %s; object may be in register(s).", TYPE_NAME (real_type));
d2652 1
a2652 1
	error ("no frame selected");
d2661 1
a2661 1
	error ("no `%s' in nameless context", name);
d2670 1
a2670 1
	error ("no args, no `%s'", name);
d2681 1
a2681 1
	error ("current stack frame does not contain a variable named `%s'", name);
d2688 1
a2688 1
    error ("`%s' argument unreadable", name);
d2720 1
a2720 1
    error ("cannot take slice of non-array");
d2723 1
a2723 1
    error ("slice from bad array or bitstring");
d2726 1
a2726 1
    error ("slice out of range");
d2744 1
a2744 1
	    error ("internal error accessing bitstring");
d2830 1
a2830 1
    error ("cannot cast non-number to complex");
@


1.150
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (deprecated_set_value_modifiable)
	(deprecated_value_modifiable): Declare.
	* value.c (deprecated_set_value_modifiable): Define.
	(deprecated_value_modifiable): Define.
	* ada-lang.c, valops.c, breakpoint.c, tracepoint.c: Update.
@
text
@d1312 1
a1312 1
	      v2->offset = value_offset (arg1) + boffset;
d2778 1
a2778 1
      slice->offset = value_offset (array) + offset;
@


1.149
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (deprecated_set_value_type): Declare.
	* value.c (deprecated_set_value_type): Define.
	* hpacc-abi.c, gnu-v2-abi.c, cp-valprint.c: Update.
	* c-valprint.c, jv-lang.c, objc-lang.c, ada-lang.c: Update.
	* infcall.c, printcmd.c, valops.c, eval.c, p-exp.y: Update.
	* ax-gdb.c, tracepoint.c: Update.
@
text
@d524 1
a524 1
  if (!toval->modifiable)
@


1.148
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_POINTED_TO_OFFSET): Delete.
	(set_value_pointed_to_offset, value_pointed_to_offset): Declare.
	* value.c (set_value_pointed_to_offset): Define
	(value_pointed_to_offset): Define.
	* valops.c: Update.
@
text
@d243 2
a244 2
	  arg2->type = create_array_type ((struct type *) NULL,
					  element_type, range_type);
d285 1
a285 1
	  v->type = type;
d383 1
a383 1
		      v->type = type;
d408 1
a408 1
      arg2->type = type;
d733 1
a733 1
  val->type = type;
d858 1
a858 1
      arg2->type = lookup_pointer_type (TYPE_TARGET_TYPE (type));
d914 1
a914 1
      arg2->type = TYPE_TARGET_TYPE (base_type);
d2628 1
a2628 1
  new_val->type = value_type (argp);
@


1.147
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (value_embedded_offset): Delete.
	(value_embedded_offset): Declare.
	* value.c (value_embedded_offset): Define.
	* valops.c, p-valprint.c, mi/mi-main.c, hpacc-abi.c: Update.
	* gnu-v3-abi.c, eval.c, c-valprint.c, cp-valprint.c: Update.
	* cp-abi.h: Update.
@
text
@d410 1
a410 1
      VALUE_POINTED_TO_OFFSET (arg2) = 0;	/* pai: chk_val */
d548 1
a548 1
      VALUE_POINTED_TO_OFFSET (val) = VALUE_POINTED_TO_OFFSET (fromval);
d736 1
a736 1
  VALUE_POINTED_TO_OFFSET (val) = VALUE_POINTED_TO_OFFSET (fromval);
d877 1
a877 1
  VALUE_POINTED_TO_OFFSET (arg2) = value_embedded_offset (arg1);
d912 1
a912 1
				       - VALUE_POINTED_TO_OFFSET (arg1)));
d917 1
a917 1
      set_value_embedded_offset (arg2, VALUE_POINTED_TO_OFFSET (arg1));
@


1.146
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_LAZY): Delete
	(set_value_lazy): Declare.
	* value.c (set_value_lazy): Define.
	* valops.c, valarith.c, jv-valprint.c, jv-lang.c: Update.
	* gnu-v2-abi.c, findvar.c, dwarf2loc.c, ada-lang.c: Update.
@
text
@d401 1
a401 1
                                + VALUE_EMBEDDED_OFFSET (v));
d547 1
a547 1
      VALUE_EMBEDDED_OFFSET (val) = VALUE_EMBEDDED_OFFSET (fromval);
d735 1
a735 1
  VALUE_EMBEDDED_OFFSET (val) = VALUE_EMBEDDED_OFFSET (fromval);
d871 1
a871 1
			      + VALUE_EMBEDDED_OFFSET (arg1)));
d877 1
a877 1
  VALUE_POINTED_TO_OFFSET (arg2) = VALUE_EMBEDDED_OFFSET (arg1);
d917 1
a917 1
      VALUE_EMBEDDED_OFFSET (arg2) = VALUE_POINTED_TO_OFFSET (arg1);
d1507 1
a1507 1
				    offset + VALUE_EMBEDDED_OFFSET (*arg1p),
d1741 1
a1741 1
				    offset + VALUE_EMBEDDED_OFFSET (*argp),
d2627 1
a2627 1
			   (using_enc ? 0 : VALUE_EMBEDDED_OFFSET (argp)));
d2629 3
a2631 1
  VALUE_EMBEDDED_OFFSET (new_val) = using_enc ? top + VALUE_EMBEDDED_OFFSET (argp) : top;
@


1.145
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d481 1
a481 1
  VALUE_LAZY (val) = 1;
d509 1
a509 1
  VALUE_LAZY (val) = 0;
d1314 1
a1314 1
		VALUE_LAZY (v2) = 1;
d2765 1
a2765 1
	VALUE_LAZY (slice) = 1;
@


1.144
log
@2005-02-02  Andrew Cagney  <cagney@@gnu.org>

	* value.h (value_lazy): Declare.
	* varobj.c, value.c, valops.c, valarith.c, printcmd.c: Update.
	* cp-valprint.c, breakpoint.c, ada-lang.c: Update.
@
text
@d309 1
a309 1
	      ptr = (unsigned int *) VALUE_CONTENTS (retvalp);
d329 1
a329 1
        longest = extract_unsigned_integer (VALUE_CONTENTS (arg2),
a431 2

  memset (VALUE_CONTENTS (val), 0, TYPE_LENGTH (check_typedef (type)));
d443 1
a443 1
   is tested in the VALUE_CONTENTS macro, which is used if and when
d486 1
a486 1
/* Called only from the VALUE_CONTENTS and value_contents_all()
d488 1
a488 1
   VALUE_CONTENTS(VAL).  Fetches the data from the user's process, and
d495 1
a495 1
   This function returns a value because it is used in the VALUE_CONTENTS
d561 1
a561 1
	char *dest_buffer;
d590 1
a590 1
	    dest_buffer = VALUE_CONTENTS (fromval);
d617 1
a617 1
			       type, VALUE_CONTENTS (fromval));
d664 1
a664 1
	      memcpy (buffer + byte_offset, VALUE_CONTENTS (fromval),
d731 1
a731 1
  memcpy (value_contents_raw (val), VALUE_CONTENTS (fromval),
d1285 1
a1285 1
				      VALUE_CONTENTS (arg1) + offset,
d1515 1
a1515 1
	      char *base_valaddr;
d1523 1
a1523 1
		  base_valaddr = (char *) alloca (TYPE_LENGTH (baseclass));
d1526 1
a1526 2
					  base_valaddr,
					  TYPE_LENGTH (baseclass)) != 0)
d1528 1
d1531 1
a1531 1
		base_valaddr = VALUE_CONTENTS (*arg1p) + offset;
d1752 1
a1752 1
				  VALUE_CONTENTS (*argp) + base_offset,
d2739 1
a2739 1
					 VALUE_CONTENTS (array),
d2767 2
a2768 1
	memcpy (VALUE_CONTENTS (slice), VALUE_CONTENTS (array) + offset,
d2798 1
a2798 1
	  VALUE_CONTENTS (arg1), TYPE_LENGTH (real_type));
d2800 1
a2800 1
	  VALUE_CONTENTS (arg2), TYPE_LENGTH (real_type));
d2817 1
a2817 1
	      VALUE_CONTENTS (val), TYPE_LENGTH (val_real_type));
d2819 1
a2819 1
	      VALUE_CONTENTS (val) + TYPE_LENGTH (val_real_type),
@


1.143
log
@2005-02-02  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_CONTENTS_ALL): Delete.
	(value_contents_all): Declare.
	* value.c (value_contents_all): New function.
	* hpacc-abi.c, cp-valprint.c, valops.c, c-valprint.c: Update.
	* m68k-tdep.c, i386-tdep.c, infcall.c, valops.c: Update.
@
text
@d1315 1
a1315 1
	      if (VALUE_LAZY (arg1))
d2766 1
a2766 1
      if (VALUE_LAZY (array))
@


1.142
log
@2005-02-02  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_enclosing_type): New function.
	* value.h (VALUE_ENCLOSING_TYPE): Delete.
	(value_enclosing_type): Declare.
	* xstormy16-tdep.c, vax-tdep.c, m68k-tdep.c, i386-tdep.c: Update.
	* gnu-v3-abi.c, hpacc-abi.c, infcall.c, valops.c: Update.
@
text
@d488 2
a489 2
/* Called only from the VALUE_CONTENTS and VALUE_CONTENTS_ALL macros,
   if the current data for a variable needs to be loaded into
d491 2
a492 1
   clears the lazy flag to indicate that the data in the buffer is valid.
d1027 1
a1027 1
		  VALUE_CONTENTS_ALL (elemvec[idx]),
d1041 2
a1042 1
      write_memory (addr + (idx * typelength), VALUE_CONTENTS_ALL (elemvec[idx]),
d1508 1
a1508 1
				    VALUE_CONTENTS_ALL (*arg1p),
d1742 1
a1742 1
				    VALUE_CONTENTS_ALL (*argp),
@


1.141
log
@2005-02-01  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents_all_raw)
	(value_contents_raw): New functions.
	* value.h (VALUE_CONTENTS_ALL_RAW, VALUE_CONTENTS_RAW): Delete.
	(value_contents_raw, value_contents_all_raw): Declare functions.
	(VALUE_CONTENTS, VALUE_CONTENTS_ALL): Update.
	* std-regs.c, valarith.c, valops.c, eval.c: Update.
	* tracepoint.c, findvar.c: Update.
@
text
@d504 1
a504 1
  int length = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (val));
d547 1
a547 1
      val = value_change_enclosing_type (val, VALUE_ENCLOSING_TYPE (fromval));
d735 1
a735 1
  val = value_change_enclosing_type (val, VALUE_ENCLOSING_TYPE (fromval));
d754 1
a754 1
  val = allocate_repeat_value (VALUE_ENCLOSING_TYPE (arg1), count);
d758 1
a758 1
	       TYPE_LENGTH (VALUE_ENCLOSING_TYPE (val)));
d876 1
a876 1
  arg2 = value_change_enclosing_type (arg2, lookup_pointer_type (VALUE_ENCLOSING_TYPE (arg1)));
d909 1
a909 1
      enc_type = check_typedef (VALUE_ENCLOSING_TYPE (arg1));
d1006 1
a1006 1
  typelength = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (elemvec[0]));
d1009 1
a1009 1
      if (TYPE_LENGTH (VALUE_ENCLOSING_TYPE (elemvec[idx])) != typelength)
d1018 1
a1018 1
			      VALUE_ENCLOSING_TYPE (elemvec[0]), rangetype);
d2603 1
a2603 1
  if (!real_type || real_type == VALUE_ENCLOSING_TYPE (argp))
@


1.140
log
@2005-01-28  Andrew Cagney  <cagney@@gnu.org>

	* value.h (value_bit_index, print_floating)
	(find_rt_vbase_offset): Make buffer a const bfd_byte.
	* valprint.c (print_floating): Update.
	* valarith.c (value_bit_index): Update.
	* valops.c (find_rt_vbase_offset): Update.
@
text
@d2 1
d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d461 1
a461 1
  read_memory (addr, VALUE_CONTENTS_ALL_RAW (val), TYPE_LENGTH (type));
d508 1
a508 1
    read_memory (addr, VALUE_CONTENTS_ALL_RAW (val), length);
d732 1
a732 1
  memcpy (VALUE_CONTENTS_RAW (val), VALUE_CONTENTS (fromval),
d757 1
a757 1
	       VALUE_CONTENTS_ALL_RAW (val),
d1025 1
a1025 1
	  memcpy (VALUE_CONTENTS_ALL_RAW (val) + (idx * typelength),
d1073 1
a1073 1
      memcpy (VALUE_CONTENTS_RAW (val), ptr, len);
d1097 1
a1097 1
  memcpy (VALUE_CONTENTS_RAW (val), ptr, TYPE_LENGTH (type));
d1301 1
a1301 1
	      if (target_read_memory (base_addr, VALUE_CONTENTS_RAW (v2),
d1316 2
a1317 2
		memcpy (VALUE_CONTENTS_RAW (v2),
			VALUE_CONTENTS_RAW (arg1) + boffset,
d2748 1
a2748 1
	      VALUE_CONTENTS_RAW (slice)[i / TARGET_CHAR_BIT] |= (1 << j);
d2796 1
a2796 1
  memcpy (VALUE_CONTENTS_RAW (val),
d2798 1
a2798 1
  memcpy (VALUE_CONTENTS_RAW (val) + TYPE_LENGTH (real_type),
d2815 1
a2815 1
      memcpy (VALUE_CONTENTS_RAW (re_val),
d2817 1
a2817 1
      memcpy (VALUE_CONTENTS_RAW (im_val),
@


1.139
log
@	* valarith.c (value_subscript): Copy VALUE_FRAME_ID.
	(value_subscripted_rvalue): Likewise.
	* valops.c (search_struct_field, value_slice): Likewise.
@
text
@d1357 3
a1359 2
find_rt_vbase_offset (struct type *type, struct type *basetype, char *valaddr,
		      int offset, int *boffset_p, int *skip_p)
@


1.138
log
@2004-11-15  Andrew Cagney  <cagney@@gnu.org>

	* findvar.c (value_of_register): Set the frame ID.
	* value.c (value_primitive_field): Copy the frame ID.
	* valops.c (value_assign): Simplify lval_register case, there's
	always a frame.
@
text
@d1310 1
d2772 1
@


1.137
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (enum lval_type): Delete lval_reg_frame_relative.
	* value.h (struct value): Update comment.
	* valops.c (value_assign): Fold lval_reg_fame_relative into
	lval_register.
	* findvar.c (value_from_register, locate_var_value): Ditto.
@
text
@d605 2
a606 10
	if (VALUE_LVAL (toval) == lval_register)
	  {
	    frame = get_current_frame ();
	    value_reg = VALUE_REGNUM (toval);
	  }
	else
	  {
	    frame = frame_find_by_id (VALUE_FRAME_ID (toval));
	    value_reg = VALUE_REGNUM (toval);
	  }
@


1.136
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	Merge VALUE_REGNO and VALUE_FRAME_REGNUM into VALUE_REGNUM.
	* value.h (VALUE_REGNO, VALUE_FRAME_REGNUM): Delete.
	(VALUE_REGNUM): Define.
	(struct value): Delete location.regnum, rename "regno" to
	"regnum".
	* value.c, valops.c, valarith.c, findvar.c: Update.
@
text
@a598 1
    case lval_reg_frame_relative:
d619 1
a619 1
	if (VALUE_LVAL (toval) == lval_reg_frame_relative
a700 1
    case lval_reg_frame_relative:
@


1.135
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_TYPE, VALUE_NEXT, VALUE_OFFSET, VALUE_BITSIZE)
	(VALUE_BITPOS): Delete.
	(value_type, value_offset, value_bitsize, value_bitpos): Declare.
	* value.c (value_type, value_offset, value_bitpos)
	(value_bitsize): New functions.  Update references.
	* arm-tdep.c, gnu-v3-abi.c, hpacc-abi.c, gnu-v2-abi.c: Update.
	* f-valprint.c, cp-valprint.c, c-valprint.c: Update.
	* ada-valprint.c, typeprint.c, scm-valprint.c, scm-exp.c: Update.
	* p-valprint.c, jv-valprint.c, jv-lang.c, varobj.c: Update.
	* objc-lang.c, ada-lang.c, std-regs.c, stack.c: Update.
	* infcall.c, linespec.c, printcmd.c, valarith.c: Update.
	* valops.c, eval.c, findvar.c, breakpoint.c: Update.
	* tracepoint.c, ax-gdb.c, mi/mi-main.c, cli/cli-dump.c:
	* rs6000-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d609 1
a609 1
	    value_reg = VALUE_REGNO (toval);
d614 1
a614 1
	    value_reg = VALUE_FRAME_REGNUM (toval);
d621 1
a621 1
	    && CONVERT_REGISTER_P (VALUE_FRAME_REGNUM (toval), type))
d625 1
a625 1
	    VALUE_TO_REGISTER (frame, VALUE_FRAME_REGNUM (toval),
@


1.134
log
@2004-11-10  Andrew Cagney  <cagney@@gnu.org>

	* value.h (COERCE_REF, COERCE_ARRAY, COERCE_NUMBER, COERCE_ENUM)
	(coerce_ref, coerce_array, coerce_number, coerce_enum): Replace
	macros with function declarations.
	* value.c (coerce_ref, coerce_array, coerce_number)
	(coerce_enum): New functions.
	(value_as_long, value_as_address): Update.
	* ada-lang.c (ada_coerce_ref, ada_value_binop)
	(ada_evaluate_subexp, ada_value_assign, ada_value_struct_elt): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* valarith.c (value_less, value_neg, value_complement)
	(value_binop, value_add, value_subscript, value_x_binop)
	(value_logical_not, value_sub): Update.
	* valops.c (check_field, value_struct_elt, value_ind)
	(value_find_oload_method_list, value_cast, value_assign): Update.
	* eval.c (evaluate_subexp_standard): Update.
@
text
@d210 1
a210 1
  if (VALUE_TYPE (arg2) == type)
d216 1
a216 1
  type2 = check_typedef (VALUE_TYPE (arg2));
d242 2
a243 2
	  VALUE_TYPE (arg2) = create_array_type ((struct type *) NULL,
						 element_type, range_type);
d255 1
a255 1
  type2 = check_typedef (VALUE_TYPE (arg2));
d284 1
a284 1
	  VALUE_TYPE (v) = type;
d382 1
a382 1
		      VALUE_TYPE (v) = type;
d399 1
a399 1
                                + VALUE_OFFSET (v)
d407 1
a407 1
      VALUE_TYPE (arg2) = type;
d413 1
a413 1
    return value_at_lazy (type, VALUE_ADDRESS (arg2) + VALUE_OFFSET (arg2));
d502 1
a502 1
  CORE_ADDR addr = VALUE_ADDRESS (val) + VALUE_OFFSET (val);
d505 1
a505 1
  struct type *type = VALUE_TYPE (val);
d529 1
a529 1
  type = VALUE_TYPE (toval);
d553 3
a555 3
				 VALUE_OFFSET (toval),
				 VALUE_BITPOS (toval),
				 VALUE_BITSIZE (toval),
d566 1
a566 1
	if (VALUE_BITSIZE (toval))
d570 2
a571 2
	    changed_len = (VALUE_BITPOS (toval)
			   + VALUE_BITSIZE (toval)
d579 1
a579 1
	    read_memory (VALUE_ADDRESS (toval) + VALUE_OFFSET (toval),
d582 2
a583 2
			  VALUE_BITPOS (toval), VALUE_BITSIZE (toval));
	    changed_addr = VALUE_ADDRESS (toval) + VALUE_OFFSET (toval);
d588 1
a588 1
	    changed_addr = VALUE_ADDRESS (toval) + VALUE_OFFSET (toval);
d646 1
a646 1
		   offset + register_size (current_gdbarch, reg_offset) <= VALUE_OFFSET (toval);
d648 1
a648 1
	      byte_offset = VALUE_OFFSET (toval) - offset;
d653 1
a653 1
	    if (VALUE_BITSIZE (toval))
d668 1
a668 1
	    if (VALUE_BITSIZE (toval))
d671 1
a671 1
			    VALUE_BITPOS (toval), VALUE_BITSIZE (toval));
d727 2
a728 2
  if ((VALUE_BITSIZE (toval) > 0)
      && (VALUE_BITSIZE (toval) < 8 * (int) sizeof (LONGEST)))
d731 1
a731 1
      LONGEST valmask = (((ULONGEST) 1) << VALUE_BITSIZE (toval)) - 1;
d743 1
a743 1
  VALUE_TYPE (val) = type;
d765 1
a765 1
  read_memory (VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1),
d769 1
a769 1
  VALUE_ADDRESS (val) = VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1);
d829 1
a829 1
  struct type *type = check_typedef (VALUE_TYPE (arg1));
d835 1
a835 1
			     (VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1)));
d849 2
a850 2
  retval = value_from_pointer (lookup_pointer_type (VALUE_TYPE (arg1)),
			       (VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1)));
d861 1
a861 1
  struct type *type = check_typedef (VALUE_TYPE (arg1));
d868 1
a868 1
      VALUE_TYPE (arg2) = lookup_pointer_type (TYPE_TARGET_TYPE (type));
d878 1
a878 1
  arg2 = value_from_pointer (lookup_pointer_type (VALUE_TYPE (arg1)),
d880 1
a880 1
			      + VALUE_OFFSET (arg1)
d901 1
a901 1
  base_type = check_typedef (VALUE_TYPE (arg1));
d924 1
a924 1
      VALUE_TYPE (arg2) = TYPE_TARGET_TYPE (base_type);
d1149 1
a1149 1
      tt2 = check_typedef (VALUE_TYPE (t2[i]));
d1186 1
a1186 1
      if (TYPE_CODE (t1[i].type) != TYPE_CODE (VALUE_TYPE (t2[i])))
d1296 1
a1296 1
				      + VALUE_OFFSET (arg1) + offset);
d1309 1
a1309 1
	      base_addr = VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1) + boffset;
d1320 1
a1320 1
	      VALUE_OFFSET (v2) = VALUE_OFFSET (arg1) + boffset;
d1532 1
a1532 1
					  + VALUE_OFFSET (*arg1p) + offset,
d1543 1
a1543 1
				  + VALUE_OFFSET (*arg1p) + offset);
d1594 1
a1594 1
  t = check_typedef (VALUE_TYPE (*argp));
d1602 1
a1602 1
      if (TYPE_CODE (VALUE_TYPE (*argp)) != TYPE_CODE_FUNC)
d1604 1
a1604 1
      t = check_typedef (VALUE_TYPE (*argp));
d1756 1
a1756 1
	      base_offset = VALUE_OFFSET (*argp) + offset;
d1794 1
a1794 1
  t = check_typedef (VALUE_TYPE (*argp));
d1801 1
a1801 1
      if (TYPE_CODE (VALUE_TYPE (*argp)) != TYPE_CODE_FUNC)
d1803 1
a1803 1
      t = check_typedef (VALUE_TYPE (*argp));
d1872 1
a1872 1
      obj_type_name = TYPE_NAME (VALUE_TYPE (obj));
d1876 2
a1877 2
	  (TYPE_CODE (VALUE_TYPE (obj)) == TYPE_CODE_PTR))
	obj_type_name = TYPE_NAME (TYPE_TARGET_TYPE (VALUE_TYPE (obj)));
d1964 2
a1965 2
      if (TYPE_CODE (VALUE_TYPE (temp)) != TYPE_CODE_PTR
	  && TYPE_CODE (VALUE_TYPE (*objp)) == TYPE_CODE_PTR)
d2325 1
a2325 1
  t = VALUE_TYPE (arg1);
d2635 1
a2635 1
  VALUE_TYPE (new_val) = VALUE_TYPE (argp);
d2721 1
a2721 1
  array_type = check_typedef (VALUE_TYPE (array));
d2781 1
a2781 1
      VALUE_OFFSET (slice) = VALUE_OFFSET (array) + offset;
d2815 1
a2815 1
  if (TYPE_CODE (VALUE_TYPE (val)) == TYPE_CODE_COMPLEX)
d2817 1
a2817 1
      struct type *val_real_type = TYPE_TARGET_TYPE (VALUE_TYPE (val));
d2829 2
a2830 2
  else if (TYPE_CODE (VALUE_TYPE (val)) == TYPE_CODE_FLT
	   || TYPE_CODE (VALUE_TYPE (val)) == TYPE_CODE_INT)
@


1.133
log
@2004-11-09  Andrew Cagney  <cagney@@gnu.org>

	* value.h (struct value): Delete field bfd_section.
	(VALUE_BFD_SECTION): Delete macro.
	(COERCE_REF): Update.
	(value_at, value_at_lazy): Delete asection parameter.
	* printcmd.c (print_formatted, x_command): Update.
	(do_examine): Delete asection parameter.
	(next_section): Delete variable.
	* valops.c (value_cast, value_at, value_at_lazy)
	(value_coerce_function, value_addr, value_ind, value_string)
	(find_rt_vbase_offset, value_full_object): Update.
	* hpacc-abi.c (hpacc_virtual_fn_field)
	(hpacc_value_rtti_type): Update.
	* gnu-v3-abi.c (gnuv3_rtti_type, gnuv3_virtual_fn_field)
	(gnuv3_baseclass_offset): Update.
	* f-valprint.c (f_val_print): Update.
	* c-valprint.c (c_val_print): Update.
	* p-valprint.c (pascal_val_print): Update.
	* jv-valprint.c (java_value_print): Update.
	* jv-lang.c (java_class_from_object, evaluate_subexp_java): Update.
	* ada-lang.c (ada_value_primitive_packed_val)
	(ada_evaluate_subexp): Update.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Update.
	* expprint.c (print_subexp_standard): Update.
	* infcall.c (call_function_by_hand): Update.
	* valarith.c (value_add): Update.
	* eval.c (evaluate_subexp_standard): Update.
	* values.c (allocate_value, value_copy, value_static_field): Update.
	* findvar.c (read_var_value, locate_var_value): Update.
@
text
@d215 1
a215 1
  COERCE_REF (arg2);
d527 1
a527 1
  COERCE_REF (toval);
d533 1
a533 1
    COERCE_ARRAY (fromval);
d899 1
a899 1
  COERCE_ARRAY (arg1);
d1592 1
a1592 1
  COERCE_ARRAY (*argp);
d1603 1
a1603 1
	COERCE_ARRAY (*argp);
d1802 1
a1802 1
	COERCE_ARRAY (*argp);
d2323 1
a2323 1
  COERCE_ARRAY (arg1);
@


1.132
log
@2004-11-02  Andrew Cagney  <cagney@@gnu.org>

	* value.h (COERCE_VARYING_ARRAY): Delete.
	* valops.c (value_cast, value_slice): Delete use.
	* valarith.c (value_subscript, value_concat): Delete use.
@
text
@d413 1
a413 4
    {
      return value_at_lazy (type, VALUE_ADDRESS (arg2) + VALUE_OFFSET (arg2),
			    VALUE_BFD_SECTION (arg2));
    }
d451 1
a451 1
value_at (struct type *type, CORE_ADDR addr, asection *sect)
a463 1
  VALUE_BFD_SECTION (val) = sect;
d471 1
a471 1
value_at_lazy (struct type *type, CORE_ADDR addr, asection *sect)
a482 1
  VALUE_BFD_SECTION (val) = sect;
a850 1
  VALUE_BFD_SECTION (retval) = VALUE_BFD_SECTION (arg1);
a887 1
  VALUE_BFD_SECTION (arg2) = VALUE_BFD_SECTION (arg1);
d912 1
a912 2
			  (CORE_ADDR) value_as_long (arg1),
			  VALUE_BFD_SECTION (arg1));
d921 2
a922 3
      arg2 = value_at_lazy (enc_type,
		   value_as_address (arg1) - VALUE_POINTED_TO_OFFSET (arg1),
			    VALUE_BFD_SECTION (arg1));
a1037 1
      VALUE_BFD_SECTION (val) = VALUE_BFD_SECTION (elemvec[0]);
d1055 1
a1055 1
  val = value_at_lazy (arraytype, addr, VALUE_BFD_SECTION (elemvec[0]));
d1093 1
a1093 1
  val = value_at_lazy (stringtype, addr, NULL);
d1427 1
a1427 1
  vp = value_at (builtin_type_int, vtbl + 4 * (-skip - index - HP_ACC_VBASE_START), NULL);
d2634 1
a2634 2
			   (using_enc ? 0 : VALUE_EMBEDDED_OFFSET (argp)),
			   VALUE_BFD_SECTION (argp));
@


1.131
log
@* valops.c (value_assign): 'use_buffer' is initialized to zero,
and never assigned to.   Delete it, and the 'if (use_buffer)'
clauses.  Delete 'raw_buffer', since it is now unused.
@
text
@a255 1
  COERCE_VARYING_ARRAY (arg2, type2);
a2732 1
  COERCE_VARYING_ARRAY (array, array_type);
@


1.130
log
@* valops.c (value_assign): Move 'buffer' to the enclosing block,
so that its storage isn't referenced after its lifetime ends.
@
text
@a527 2
  char raw_buffer[MAX_REGISTER_SIZE];
  int use_buffer = 0;
a591 6
	else if (use_buffer)
	  {
	    changed_addr = VALUE_ADDRESS (toval) + VALUE_OFFSET (toval);
	    changed_len = use_buffer;
	    dest_buffer = raw_buffer;
	  }
a677 2
	    else if (use_buffer)
	      memcpy (buffer + VALUE_OFFSET (toval), raw_buffer, use_buffer);
@


1.129
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@d572 1
a575 1
	    char buffer[sizeof (LONGEST)];
@


1.128
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d660 1
a660 1
		   offset + DEPRECATED_REGISTER_RAW_SIZE (reg_offset) <= VALUE_OFFSET (toval);
d678 1
a678 1
		 amount_copied += DEPRECATED_REGISTER_RAW_SIZE (regno), regno++)
d695 1
a695 1
		 amount_copied += DEPRECATED_REGISTER_RAW_SIZE (regno), regno++)
@


1.127
log
@2004-06-10  Andrew Cagney  <cagney@@gnu.org>

	* ns32k-tdep.c (ns32k_push_arguments): New function.
	(ns32k_gdbarch_init): Set deprecated_push_arguments.
	* infcall.c (call_function_by_hand): Call error instead of
	legacy_push_arguments.
	* value.h (legacy_push_arguments): Delete declaration.
	* valops.c (legacy_push_arguments): Delete function.
	(value_push): Delete function.
@
text
@d2863 1
a2863 1
  add_show_from_set
d2870 1
a2870 1
  add_show_from_set
@


1.126
log
@2004-05-05  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PARM_BOUNDARY): Delete.
	gdbarch.h, gdbarch.c: Re-generate.
	* valops.c (PARM_BOUNDARY): Delete macro.
	(value_push): Delete PARM_BOUNDARY code.
	* m68k-tdep.c (m68k_gdbarch_init): Do not set parm_boundary.
@
text
@a52 2
static CORE_ADDR value_push (CORE_ADDR, struct value *);

a1005 43
/* Push onto the stack the specified value VALUE.  Pad it correctly for
   it to be an argument to a function.  */

static CORE_ADDR
value_push (CORE_ADDR sp, struct value *arg)
{
  int len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (arg));
  int container_len = len;
  int offset;

  /* Are we going to put it at the high or low end of the container?  */
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    offset = container_len - len;
  else
    offset = 0;

  if (INNER_THAN (1, 2))
    {
      /* stack grows downward */
      sp -= container_len;
      write_memory (sp + offset, VALUE_CONTENTS_ALL (arg), len);
    }
  else
    {
      /* stack grows upward */
      write_memory (sp + offset, VALUE_CONTENTS_ALL (arg), len);
      sp += container_len;
    }

  return sp;
}

CORE_ADDR
legacy_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		       int struct_return, CORE_ADDR struct_addr)
{
  /* ASSERT ( !struct_return); */
  int i;
  for (i = nargs - 1; i >= 0; i--)
    sp = value_push (sp, args[i]);
  return sp;
}

@


1.125
log
@2004-04-30  Andrew Cagney  <cagney@@redhat.com>

	* gdb-events.sh (selected_thread_changed)
	(selected_frame_level_changed, target_changed): Delete.
	* gdb-events.h, gdb-events.c: Re-generate.
	* valops.c (value_assign): Update.
	* stack.c (select_frame_command, up_silently_base)
	(down_silently_base): Update.
@
text
@a1007 4
#ifndef PARM_BOUNDARY
#define PARM_BOUNDARY (0)
#endif

a1016 5

  /* How big is the container we're going to put this value in?  */
  if (PARM_BOUNDARY)
    container_len = ((len + PARM_BOUNDARY / TARGET_CHAR_BIT - 1)
		     & ~(PARM_BOUNDARY / TARGET_CHAR_BIT - 1));
@


1.124
log
@2004-04-26  Orjan Friberg <orjanf@@axis.com>

	* frame.c: Include "observer.h".
	(frame_observer_target_changed): New function.
	(_initialize_frame): Attach target_changed observer.
	* regcache.c: Include "observer.h".
	(regcache_observer_target_changed): New function.
	(_initialize_regcache): Attach target_changed observer.
	* valops.c: Include "observer.h".
	(value_assign): Notify target_changed event when modifying register.
	* Makefile.in (frame.o, regcache.o, valops.o): Add $(observer_h).
@
text
@a611 1
	target_changed_event ();
a702 1
	target_changed_event ();
@


1.123
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d45 1
d705 1
@


1.122
log
@2004-04-08  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.h (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Declare.
	* hppa-hpux-tdep.c (initialize_hp_cxx_exception_support)
	(initialize_hp_cxx_exception_support)
	(child_enable_exception_callback): Update.
	* breakpoint.c (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Rename
	deprecated_exception_catchpoints_are_fragile and
	deprecated_exception_support_initialized.
	(breakpoint_init_inferior, breakpoint_init_inferior): Update.

	* symtab.c (deprecated_hp_som_som_object_present): Rename
	hp_som_som_object_present.
	* symtab.h (deprecated_hp_som_som_object_present): Declare.
	* symfile.c (hp_som_som_object_present, RESET_HP_UX_GLOBALS):
	Update.  Delete extern declaration.
	* valops.c (hp_som_som_object_present): Ditto.
	* parse.c (deprecated_hp_som_som_object_present)
	(parse_nested_classes_for_hpacc): Ditto.
	* hpread.c (hp_som_som_object_present, hpread_expand_symtab): Ditto.
	* hppa-hpux-tdep.c (hp_som_som_object_present)
	(initialize_hp_cxx_exception_support): Ditto.
	* eval.c (hp_som_som_object_present, evaluate_subexp_standard): Ditto.
	* cp-valprint.c (hp_som_som_object_present)
	(cp_print_class_method): Ditto.
	* c-typeprint.c (hp_som_som_object_present):
	(c_type_print_base): Ditto.
	* c-exp.y (hp_som_som_object_present): Ditto.
@
text
@d609 2
a610 2
	if (memory_changed_hook)
	  memory_changed_hook (changed_addr, changed_len);
d701 2
a702 2
	if (register_changed_hook)
	  register_changed_hook (-1);
@


1.121
log
@2004-02-02  David Carlton  <carlton@@kealia.com>

	* valops.c (enum oload_classification): New.
	(find_overload_match): Break implementation into separate
	functions; delete #if 0'd code; look for symbols within
	namespaces.
	(find_oload_champ_namespace,find_oload_champ_namespace_loop)
	(find_oload_champ,oload_method_static,classify_oload_match): New.
	* cp-support.h: Add declaration for cp_func_name; update
	declaration for make_symbol_overload_list.
	* cp-support.c (cp_func_name): New.
	(overload_list_add_symbol): Fix comment, use
	SYMBOL_LINKAGE_NAME and SYMBOL_NATURAL_NAME.
	(make_symbol_overload_list): Take a function name and a namespace
	instead of a symbol; change implementation.
	(make_symbol_overload_list_using): New.
	(make_symbol_overload_list_qualified, read_in_psymtabs): New.

2004-02-02  David Carlton  <carlton@@kealia.com>

	* gdb.cp/overload.exp: Add overloadNamespace tests.
	* gdb.cp/overload.cc (dummyClass, dummyInstance): New.
	(overloadNamespace, XXX): New.
	(main): Call XXX::marker2.
@
text
@a45 4
/* Flag indicating HP compilers were used; needed to correctly handle some
   value operations with HP aCC code/runtime. */
extern int hp_som_som_object_present;

d298 2
a299 2
      if (hp_som_som_object_present &&	/* if target compiled by HP aCC */
	  (code2 == TYPE_CODE_PTR))
@


1.121.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d45 4
a48 1
#include "observer.h"
d56 2
d302 2
a303 2
      if (deprecated_hp_som_som_object_present	/* if target compiled by HP aCC */
	  && (code2 == TYPE_CODE_PTR))
d533 2
a576 1
        char buffer[sizeof (LONGEST)];
d580 1
d599 6
d613 3
a615 2
	if (deprecated_memory_changed_hook)
	  deprecated_memory_changed_hook (changed_addr, changed_len);
d666 1
a666 1
		   offset + register_size (current_gdbarch, reg_offset) <= VALUE_OFFSET (toval);
d684 1
a684 1
		 amount_copied += register_size (current_gdbarch, regno), regno++)
d692 2
d701 1
a701 1
		 amount_copied += register_size (current_gdbarch, regno), regno++)
d705 3
a707 3
	if (deprecated_register_changed_hook)
	  deprecated_register_changed_hook (-1);
	observer_notify_target_changed (&current_target);
d1012 52
d2921 1
a2921 1
  deprecated_add_show_from_set
d2928 1
a2928 1
  deprecated_add_show_from_set
@


1.120
log
@2004-01-14  David Carlton  <carlton@@kealia.com>

	Change symbols for C++ nested types to contain the fully qualified
	name, if possible.  (At least in the DWARF-2 case.)  Partial fix
	for PR's c++/57, c++/488, c++/539, c++/573, c++/609, c++/832,
	c++/895.
	* c-exp.y: Update copyright:
	(qualified_type): Handle types nested within classes.
	* cp-namespace.c: Update comments.
	(cp_set_block_scope): Delete #if 0.
	(cp_lookup_nested_type): Handle types nested within classes.
	* dwarf2read.c: (scan_partial_symbols): Call add_partial_structure
	when appropriate.
	(add_partial_symbol): Add the name of the enclosing namespace to
	types.
	(pdi_needs_namespace): New.
	(add_partial_namespace): Tweak comment.
	(add_partial_structure): New.
	(psymtab_to_symtab_1): Initialize processing_current_prefix
	here...
	(process_die): instead of here.
	(read_structure_scope): Try to figure out the name of the class or
	namespace that the structure might be defined within.
	(read_enumeration): Generate fully-qualified names, if possible.
	(read_namespace): Don't set name to NULL.
	(die_specification): New.
	(new_symbol): Generate fully-qualified names for types.
	(read_type_die): Determine appropriate prefix.
	(determine_prefix): New.
	(typename_concat): New.
	(class_name): New.
	* valops.c: Update copyright.
	(value_aggregate_elt): Pass NOSIDE to
	value_struct_elt_for_reference.
	(value_struct_elt_for_reference): Make static, add NOSIDE
	parameter, call value_maybe_namespace_elt as a last resort.
	(value_namespace_elt): Break out code into
	value_maybe_namespace_elt.
	(value_maybe_namespace_elt): New.

2004-01-14  David Carlton  <carlton@@kealia.com>

	* gdb.cp/namespace.exp: Add tests involving classes defined within
	namespaces.
	* gdb.cp/namespace.cc (C::CClass): New.
	* gdb.cp/namespace1.cc: Update copyright.
	(C::OtherFileClass): New.
@
text
@d65 32
a1927 3
  int nparms;
  struct type **parm_types;
  int champ_nparms = 0;
d1930 1
a1930 6
  short oload_champ = -1;	/* Index of best overloaded function */
  short oload_ambiguous = 0;	/* Current ambiguity state for overload resolution */
  /* 0 => no ambiguity, 1 => two good funcs, 2 => incomparable funcs */
  short oload_ambig_champ = -1;	/* 2nd contender for best match */
  short oload_non_standard = 0;	/* did we have to use non-standard conversions? */
  short oload_incompatible = 0;	/* are args supplied incompatible with any function? */
a1931 1
  struct badness_vector *bv;	/* A measure of how good an overloaded instance is */
a1939 1
  int jj;
d1942 1
a1942 1
  struct cleanup *cleanups = NULL;
d1944 1
a1944 1
  char *obj_type_name = NULL;
d1946 1
d1970 2
d1975 2
a1976 2
      int i = -1;
      func_name = cplus_demangle (DEPRECATED_SYMBOL_NAME (fsym), DMGL_NO_OPTS);
d1980 1
a1980 1
      if (!func_name)
d1986 75
a2060 6
      oload_syms = make_symbol_overload_list (fsym);
      cleanups = make_cleanup (xfree, oload_syms);
      while (oload_syms[++i])
	num_fns++;
      if (!num_fns)
	error ("Couldn't find function %s", func_name);
d2062 158
d2221 1
a2221 1
  oload_champ_bv = NULL;
d2226 5
a2230 1
      static_offset = 0;
a2232 2
	  if (TYPE_FN_FIELD_STATIC_P (fns_ptr, ix))
	    static_offset = 1;
d2253 1
a2253 1
      if (!oload_champ_bv)
d2255 1
a2255 1
	  oload_champ_bv = bv;
a2256 1
	  champ_nparms = nparms;
d2260 1
a2260 1
	switch (compare_badness (bv, oload_champ_bv))
a2263 1
	    oload_ambig_champ = ix;
a2266 1
	    oload_ambig_champ = ix;
d2269 1
a2269 1
	    oload_champ_bv = bv;	/* new champion, record details */
a2271 2
	    oload_ambig_champ = -1;
	    champ_nparms = nparms;
a2287 16
    }				/* end loop over all candidates */
  /* NOTE: dan/2000-03-10: Seems to be a better idea to just pick one
     if they have the exact same goodness. This is because there is no
     way to differentiate based on return type, which we need to in
     cases like overloads of .begin() <It's both const and non-const> */
#if 0
  if (oload_ambiguous)
    {
      if (method)
	error ("Cannot resolve overloaded method %s%s%s to unique instance; disambiguate by specifying function signature",
	       obj_type_name,
	       (obj_type_name && *obj_type_name) ? "::" : "",
	       name);
      else
	error ("Cannot resolve overloaded function %s to unique instance; disambiguate by specifying function signature",
	       func_name);
a2288 1
#endif
d2290 2
a2291 8
  /* Check how bad the best match is.  */
  static_offset = 0;
  if (method && TYPE_FN_FIELD_STATIC_P (fns_ptr, oload_champ))
    static_offset = 1;
  for (ix = 1; ix <= nargs - static_offset; ix++)
    {
      if (oload_champ_bv->rank[ix] >= 100)
	oload_incompatible = 1;	/* truly mismatched types */
d2293 2
a2294 25
      else if (oload_champ_bv->rank[ix] >= 10)
	oload_non_standard = 1;	/* non-standard type conversions needed */
    }
  if (oload_incompatible)
    {
      if (method)
	error ("Cannot resolve method %s%s%s to any overloaded instance",
	       obj_type_name,
	       (obj_type_name && *obj_type_name) ? "::" : "",
	       name);
      else
	error ("Cannot resolve function %s to any overloaded instance",
	       func_name);
    }
  else if (oload_non_standard)
    {
      if (method)
	warning ("Using non-standard conversion to match method %s%s%s to supplied arguments",
		 obj_type_name,
		 (obj_type_name && *obj_type_name) ? "::" : "",
		 name);
      else
	warning ("Using non-standard conversion to match function %s to supplied arguments",
		 func_name);
    }
d2296 5
a2300 11
  if (method)
    {
      if (staticp && TYPE_FN_FIELD_STATIC_P (fns_ptr, oload_champ))
	*staticp = 1;
      else if (staticp)
	*staticp = 0;
      if (TYPE_FN_FIELD_VIRTUAL_P (fns_ptr, oload_champ))
	*valp = value_virtual_fn_field (&temp, fns_ptr, oload_champ, basetype, boffset);
      else
	*valp = value_fn_field (&temp, fns_ptr, oload_champ, basetype, boffset);
    }
d2302 11
a2312 4
    {
      *symp = oload_syms[oload_champ];
      xfree (func_name);
    }
d2314 1
a2314 1
  if (objp)
d2316 4
a2319 6
      if (TYPE_CODE (VALUE_TYPE (temp)) != TYPE_CODE_PTR
	  && TYPE_CODE (VALUE_TYPE (*objp)) == TYPE_CODE_PTR)
	{
	  temp = value_addr (temp);
	}
      *objp = temp;
a2320 2
  if (cleanups != NULL)
    do_cleanups (cleanups);
d2322 1
a2322 1
  return oload_incompatible ? 100 : (oload_non_standard ? 10 : 0);
@


1.119
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@d3 1
a3 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
a66 1

d71 2
a72 1
						     struct type *intype);
d75 1
a75 1
					  const char *name,
d78 4
d2241 2
a2242 1
      return value_struct_elt_for_reference (curtype, 0, curtype, name, NULL);
d2258 1
a2258 1
struct value *
d2261 2
a2262 1
				struct type *intype)
d2385 2
a2386 1
					  intype);
d2390 6
a2395 1
  return 0;
d2403 1
a2403 1
		     const char *name,
d2406 21
a2428 1
  struct value *retval;
d2435 1
a2435 1
    retval = NULL;
d2438 1
a2438 1
    retval = allocate_value (SYMBOL_TYPE (sym));
d2440 1
a2440 7
    retval = value_of_variable (sym, get_selected_block (0));

  if (retval == NULL)
    error ("No symbol \"%s\" in namespace \"%s\".", name,
	   TYPE_TAG_NAME (curtype));

  return retval;
a2441 1

@


1.118
log
@2003-11-06  Andrew Cagney  <cagney@@redhat.com>

	* valops.c (destructor_name_p): Replace STREQN with strncmp.
	* top.c (command_line_input): Ditto.
	* objc-exp.y (yylex): Ditto.
	* minsyms.c (prim_record_minimal_symbol_and_info): Ditto.
	* jv-exp.y (yylex): Ditto.
	* f-exp.y (yylex): Ditto.
	* event-top.c (command_line_handler): Ditto.
	* environ.c (get_in_environ): Ditto.
	(set_in_environ): Ditto.
	* dwarfread.c (handle_producer): Ditto.
	* dbxread.c (process_one_symbol): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* c-exp.y (yylex): Ditto.

2003-11-06  Andrew Cagney  <cagney@@redhat.com>

	* mi-cmd-var.c (mi_cmd_var_set_format): Replace STREQN with
	strncmp.
@
text
@d2270 1
a2270 1
      if (t_field_name && STREQ (t_field_name, name))
d2317 1
a2317 1
      if (t_field_name && STREQ (t_field_name, name))
@


1.117
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d2140 1
a2140 1
      if (strlen (name + 1) != len || !STREQN (dname, name + 1, len))
@


1.116
log
@2003-09-25  David Carlton  <carlton@@kealia.com>

	* c-exp.y: Include cp-support.h.  Add qualified_type.
	(yylex): Delete nested type hack; add comments.
	* cp-namespace.c (cp_lookup_nested_type): New function.
	* cp-support.h: Declare cp_lookup_nested_type.
	* eval.c (evaluate_subexp_standard): Call value_aggregate_elt
	instead of value_struct_elt_for_reference.
	* valops.c: Include cp-support.h.
	(value_aggregate_elt): New function.
	(value_namespace_elt): Ditto.
	(value_struct_elt_for_reference): Make static.
	* value.h: Delete declaration of value_struct_elt_for_reference;
	add declaration for value_aggregate_elt.
	* Makefile.in (c-exp.tab.o): Depend on $(cp_support_h).
	(valops.o): Ditto.

2003-09-25  David Carlton  <carlton@@kealia.com>

	* gdb.cp/namespace.exp: Tweak comments.  Add non-quoted versions
	of some print tests, where appropriate.  Add tests for C::D::cd,
	E::ce, F::cXfX, G::XgX.
	* gdb.cp/namespace.cc: Add XgX, cXfX, ce.
@
text
@d630 1
a630 1
		   offset + REGISTER_RAW_SIZE (reg_offset) <= VALUE_OFFSET (toval);
d648 1
a648 1
		 amount_copied += REGISTER_RAW_SIZE (regno), regno++)
d665 1
a665 1
		 amount_copied += REGISTER_RAW_SIZE (regno), regno++)
@


1.115
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@d44 1
d67 11
d2223 24
d2384 31
@


1.114
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d972 1
a972 1
value_push (register CORE_ADDR sp, struct value *arg)
d1235 1
a1235 1
		     register struct type *type, int looking_for_baseclass)
d1475 1
a1475 1
		      int *static_memfuncp, register struct type *type)
d2141 1
a2141 1
check_field_in (register struct type *type, const char *name)
@


1.113
log
@2003-06-14  Andrew Cagney  <cagney@@redhat.com>
            Mark Kettenis  <kettenis@@gnu.org>

	* gdbarch.sh (CONVERT_REGISTER_P): Add "type" parameter.
	(REGISTER_TO_VALUE, VALUE_TO_REGISTER): Replace raw buffer
	parameter with "frame".
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.h (put_frame_register): Declare.
	* frame.c (put_frame_register): New function.
	* arch-utils.c (legacy_convert_register_p): Add "type" parameter.
	(legacy_register_to_value): Rewrite, use "frame" to get the
	register value.
	(legacy_value_to_register): Rewrite, use "frame" to find the
	register's location before storing.
	* arch-utils.h (legacy_convert_register_p): Update.
	(legacy_register_to_value, legacy_value_to_register): Update.
	* findvar.c (value_from_register): Rewrite, eliminate use of
	REGISTER_CONVERT_TO_TYPE, pass "type" to CONVERT_REGISTER_P, pass
	"frame" to REGISTER_TO_VALUE.
	* valops.c (value_assign): Move the CONVERT_REGISTER code to the
	lval_reg_frame_relative + lval_register branch of the switch.  Do
	not use REGISTER_CONVERT_FROM_TYPE.  Use put_frame_register.
	* i386-tdep.c (I386_EBX_REGNUM, I386_ECX_REGNUM, I386_ESI_REGNUM,
	I386_EDI_REGNUM): New defines.
	(i386_next_regnum, i386_convert_register_p,
	i386_register_to_value, i386_value_to_register): New functions.
	(i386_register_convertible, i386_register_convert_to_virtual,
	i386_convert_to_raw): Remove functions.
	(i386_gdbarch_init): Set convert_register_p, register_to_value and
	value_to_register instead of register_convertible,
	register_convert_to_virtual and register_convert_to_raw.
	* mips-tdep.c (mips_convert_register_p): New function.
	(mips_value_to_register): Replace mips_register_convert_from_type.
	(mips_register_to_value): Replace mips_register_convert_to_type.
	(mips_gdbarch_init): Set conver_register_p, value_to_register and
	register_to_value.
	* alpha-tdep.c (alpha_convert_register_p): Update.
	(alpha_value_to_register): Update, store the register.
	(alpha_register_to_value): Update, fetch the register.
@
text
@d91 1
a91 1
  register struct symbol *sym;
d160 3
a162 3
  register enum type_code code1;
  register enum type_code code2;
  register int scalar;
d483 1
a483 1
  register struct type *type;
d803 1
a803 1
  register struct type *type = check_typedef (VALUE_TYPE (arg1));
d923 1
a923 1
  register int len = DEPRECATED_REGISTER_SIZE;
d974 3
a976 3
  register int len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (arg));
  register int container_len = len;
  register int offset;
d1620 1
a1620 1
  register struct type *t;
d1901 2
a1902 2
  register int jj;
  register int ix;
d2143 1
a2143 1
  register int i;
d2184 1
a2184 1
  register struct type *t;
d2222 2
a2223 2
  register struct type *t = curtype;
  register int i;
@


1.112
log
@2003-06-12  David Carlton  <carlton@@bactrian.org>

	* symtab.h: Delete declaration of make_symbol_overload_list.
	Add declaration of lookup_partial_symbol.
	* symtab.c (remove_params): Move to cp-support.c.
	(overload_list_add_symbol, make_symbol_overload_list)
	(sym_return_val_size, sym_return_val_index): Ditto.
	(lookup_partial_symbol): Make extern.
	* cp-support.h: Add declaration of make_symbol_overload_list.
	* cp-support.c: Include dictionary.h, objfiles.h, frame.h,
	symtab.h, and block.h.
	(remove_params): Move here from symtab.c.
	(overload_list_add_symbol, make_symbol_overload_list)
	(sym_return_val_size, sym_return_val_index): Ditto.
	* valops.c: Include cp-support.h.
	* Makefile.in (cp-support.o): Depend on dictionary_h, objfiles_h,
	frame_h, and block_h.
	(valops.o): Depend on cp_support_h.
@
text
@a500 16
  /* If TOVAL is a special machine register requiring conversion
     of program values to a special raw format,
     convert FROMVAL's contents now, with result in `raw_buffer',
     and set USE_BUFFER to the number of bytes to write.  */

  if (VALUE_REGNO (toval) >= 0)
    {
      int regno = VALUE_REGNO (toval);
      if (CONVERT_REGISTER_P (regno))
	{
	  struct type *fromtype = check_typedef (VALUE_TYPE (fromval));
	  VALUE_TO_REGISTER (fromtype, regno, VALUE_CONTENTS (fromval), raw_buffer);
	  use_buffer = REGISTER_RAW_SIZE (regno);
	}
    }

d574 1
a574 6
	/* value is stored in a series of registers in the frame
	   specified by the structure.  Copy that value out, modify
	   it, and copy it back in.  */
	int amount_copied;
	int amount_to_copy;
	char *buffer;
a575 4
	int reg_offset;
	int byte_offset;
	int regno;
	struct frame_info *frame;
a590 29

	/* Locate the first register that falls in the value that
           needs to be transfered.  Compute the offset of the value in
           that register.  */
	{
	  int offset;
	  for (reg_offset = value_reg, offset = 0;
	       offset + REGISTER_RAW_SIZE (reg_offset) <= VALUE_OFFSET (toval);
	       reg_offset++);
	  byte_offset = VALUE_OFFSET (toval) - offset;
	}

	/* Compute the number of register aligned values that need to
           be copied.  */
	if (VALUE_BITSIZE (toval))
	  amount_to_copy = byte_offset + 1;
	else
	  amount_to_copy = byte_offset + TYPE_LENGTH (type);

	/* And a bounce buffer.  Be slightly over generous.  */
	buffer = (char *) alloca (amount_to_copy + MAX_REGISTER_SIZE);

	/* Copy it in.  */
	for (regno = reg_offset, amount_copied = 0;
	     amount_copied < amount_to_copy;
	     amount_copied += REGISTER_RAW_SIZE (regno), regno++)
	  {
	    frame_register_read (frame, regno, buffer + amount_copied);
	  }
d592 2
a593 8
	/* Modify what needs to be modified.  */
	if (VALUE_BITSIZE (toval))
	  {
	    modify_field (buffer + byte_offset,
			  value_as_long (fromval),
			  VALUE_BITPOS (toval), VALUE_BITSIZE (toval));
	  }
	else if (use_buffer)
d595 4
a598 1
	    memcpy (buffer + VALUE_OFFSET (toval), raw_buffer, use_buffer);
d602 27
a628 19
	    memcpy (buffer + byte_offset, VALUE_CONTENTS (fromval),
		    TYPE_LENGTH (type));
	    /* Do any conversion necessary when storing this type to
	       more than one register.  */
#ifdef REGISTER_CONVERT_FROM_TYPE
	    REGISTER_CONVERT_FROM_TYPE (value_reg, type,
					(buffer + byte_offset));
#endif
	  }

	/* Copy it out.  */
	for (regno = reg_offset, amount_copied = 0;
	     amount_copied < amount_to_copy;
	     amount_copied += REGISTER_RAW_SIZE (regno), regno++)
	  {
	    enum lval_type lval;
	    CORE_ADDR addr;
	    int optim;
	    int realnum;
d630 8
a637 3
	    /* Just find out where to put it.  */
	    frame_register (frame, regno, &optim, &lval, &addr, &realnum,
			    NULL);
d639 7
a645 8
	    if (optim)
	      error ("Attempt to assign to a value that was optimized out.");
	    if (lval == lval_memory)
	      write_memory (addr, buffer + amount_copied,
			    REGISTER_RAW_SIZE (regno));
	    else if (lval == lval_register)
	      regcache_cooked_write (current_regcache, realnum,
				     (buffer + amount_copied));
d647 9
a655 1
	      error ("Attempt to assign to an unmodifiable value.");
a656 1

d660 1
a660 1

a661 2
      break;
      
@


1.111
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* dictionary.h: New.
	* dictionary.c: New.
	* block.h: Add opaque declaration for struct dictionary.
	(struct block): Add 'dict' member; delete 'hashtable', 'nsyms',
	'sym' members.
	(BLOCK_DICT): New macro.
	Delete macros BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM,
	BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE,
	BLOCK_SHOULD_SORT.
	(ALL_BLOCK_SYMBOLS): Update definition.
	* Makefile.in (SFILES): Add dictionary.c.
	(dictionary_h): New.
	(COMMON_OBS): Add dictionary.o.
	(dictionary.o): New.
	(ada-lang.o): Depend on dictionary_h.
	(buildsym.o, coffread.o, jv-lang.o, mdebugread.o, objfiles.o)
	(stack.o, symmisc.o, symtab.o, tracepoint.o, valops.o)
	(mi-cmd-stack.o): Ditto.
	(gdbtk-cmds.o): Update dependencies.
	(gdbtk-stack.o): Ditto.
	* ada-lang.c: Include dictionary.h.
	(symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(fill_in_ada_prototype, debug_print_block): Ditto.
	(ada_add_block_symbols): Update uses of ALL_BLOCK_SYMBOLS; replace
	explicit iteration by use of ALL_BLOCK_SYMBOLS.  Delete variable
	'is_sorted'.
	* mdebugread.c: Include dictionary.h.
	(struct parse_stack): Delete 'maxsyms' member.
	(parse_symbol): Update calls to new_block.  Delete calls to
	shrink_block.  Use dictionary methods.
	(psymtab_to_symtab_1): Delete calls to sort_symtab_syms.
	Update calls to new_symtab.  Don't maintain maxsyms data.
	(mylookup_symbol): Update use of ALL_BLOCK_SYMBOLS.
	(add_symbol): Just call dict_add_symbol.
	(new_symtab): Delete 'maxsyms' argument.
	(new_symtab): Update calls to new_block.
	(new_block): Delete 'maxsyms' argument; add 'function' argument.
	(shrink_block): Delete function.
	(fixup_sigtramp): Update call to new_block.  Add symbol via
	dict_add_symbol.
	* jv-lang.c: Include dictionary.h.
	(get_java_class_symtab): Set the BLOCK_DICT of the blocks
	appropriately.  Set class_symtab->free_func.  Make sure the
	blockvector is big enough to hold two blocks.
	(add_class_symtab_symbol): Use dictionary methods.
	(free_class_block): New function.
	(type_from_class): Replace explicit iteration by
	ALL_BLOCK_SYMBOLS.
	* symtab.h (struct symtab): Replace 'free_ptr' method by
	'free_func'.
	* dwarf2read.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* dwarfread.c (psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Delete call to sort_symtab_syms.
	Include dictionary.h.
	(patch_opaque_types): Update use of ALL_BLOCK_SYMBOLS.
	* dbxread.c (dbx_psymtab_to_symtab_1): Delete call to
	sort_symtab_syms.
	* objfiles.c: Include dictionary.h.
	(objfile_relocate): Update use of ALL_BLOCK_SYMBOLS.
	* buildsym.c: Include dictionary.h.
	(finish_block): Use dictionary methods.
	(end_symtab): Set free_func to NULL, not free_ptr.
	* tracepoint.c: Include dictionary.h.
	(add_local_symbols): Update use of ALL_BLOCK_SYMBOLS.
	(scope_info): Ditto.
	* stack.c: Include dictionary.h.
	(print_block_frame_locals): Update use of ALL_BLOCK_SYMBOLS.
	(print_block_frame_labels, print_frame_arg_vars)
	(print_frame_args): Ditto.
	* symmisc.c (free_symtab_block): Use dictionary methods.
	(dump_symtab): Ditto.
	(free_symtab): Replace use of 'free_ptr' by 'free_func'.
	Include	dictionary.h.
	* symfile.h: Delete declarations of sort_block_syms,
	sort_symtab_syms.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Delete.
	* symtab.c: Include dictionary.h.
	(lookup_block_symbol): Use dictionary iterators.
	(find_pc_sect_symtab): Update use of ALL_BLOCK_SYMBOLS.
	(search_symbols, make_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* valops.c (value_of_local): Use dict_empty.
	Include dictionary.h.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* generic/gdbtk-stack.c: Include dictionary.h.
	(gdb_block_vars): Update use of ALL_BLOCK_SYMBOLS.
	(gdb_get_blocks, gdb_get_vars_command): Ditto.
	* generic/gdbtk-cmds.c: Include dictionary.h.
	(gdb_listfuncs): Update use of ALL_BLOCK_SYMBOLS.

2003-06-11  David Carlton  <carlton@@bactrian.org>

	* mi-cmd-stack.c: Include dictionary.h.
	(list_args_or_locals): Update use of ALL_BLOCK_SYMBOLS.
@
text
@d39 1
@


1.110
log
@2003-06-05  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (value_h): Add $(frame_h).
	* value.h: Include "frame.h".
	(struct value): Replace "frame_addr" with "frame_id".
	(VALUE_FRAME_ID): Replace VALUE_FRAME.
	* values.c (allocate_value): Use VALUE_FRAME_ID.
	(value_copy): Use VALUE_FRAME_ID.
	* findvar.c (value_from_register): Use VALUE_FRAME_ID.
	* valops.c (value_assign): Update.  Use frame_find_by_id.
@
text
@d38 1
a2478 1
  int i;
d2499 1
a2499 2
  i = BLOCK_NSYMS (b);
  if (i <= 0)
@


1.110.2.1
log
@2003-06-06  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (put_frame_register): Declare.
	* frame.c (put_frame_register): New function.

	* arch-utils.c: Include "gdbcore.h".
	(legacy_convert_register_p): Add "type" parameter.
	(legacy_register_to_value): Rewrite, use "frame" to get the
	register value.
	(legacy_value_to_register): Rewrite, use "frame" to find the
	register's location before storing.
	* arch-utils.h (legacy_convert_register_p): Update.
	(legacy_register_to_value, legacy_value_to_register): Update.

	* Makefile.in (arch-utils.o): Update dependencies.

	* findvar.c (value_from_register): Rewrite, eliminate use of
	REGISTER_CONVERT_TO_TYPE, pass "type" to CONVERT_REGISTER_P, pass
	"frame" to REGISTER_TO_VALUE.

	* gdbarch.sh (CONVERT_REGISTER_P): Add "type" parameter.
	(REGISTER_TO_VALUE, VALUE_TO_REGISTER): Replace "type", "from" and
	"to" parameters with "frame" and "value".
	* gdbarch.h, gdbarch.c: Re-generate.

	* mips-tdep.c (mips_convert_register_p): New function.
	(mips_value_to_register): Replace mips_register_convert_from_type.
	(mips_register_to_value): Replace mips_register_convert_to_type.
	(mips_gdbarch_init): Set conver_register_p, value_to_register and
	register_to_value.

	* valops.c (value_assign): Move the CONVERT_REGISTER code to the
	lval_reg_frame_relative + lval_register branch of the switch.  Do
	not use REGISTER_CONVERT_FROM_TYPE.  Use put_frame_register.
@
text
@d499 16
d588 10
a598 1
	int value_reg;
d614 29
d644 8
a651 1
	if (CONVERT_REGISTER_P (VALUE_REGNO (toval), VALUE_TYPE (toval)))
d653 1
a653 6
	    /* If TOVAL is a special machine register requiring
	       conversion of program values to a special raw format,
	       convert FROMVAL's contents now, with result in
	       `raw_buffer', and set USE_BUFFER to the number of bytes
	       to write.  Let VALUE_TO_REGISTER sort out the mess.  */
	    VALUE_TO_REGISTER (frame, fromval);
d657 19
a675 27
	    /* TOVAL is stored in a series of registers in the frame
	       specified by the structure.  Copy that value out,
	       modify it, and copy it back in.  */
	    int amount_copied;
	    int amount_to_copy;
	    char *buffer;
	    int reg_offset;
	    int byte_offset;
	    int regno;

	    /* Locate the first register that falls in the value that
	       needs to be transfered.  Compute the offset of the
	       value in that register.  */
	    {
	      int offset;
	      for (reg_offset = value_reg, offset = 0;
		   offset + REGISTER_RAW_SIZE (reg_offset) <= VALUE_OFFSET (toval);
		   reg_offset++);
	      byte_offset = VALUE_OFFSET (toval) - offset;
	    }

	    /* Compute the number of register aligned values that need
	       to be copied.  */
	    if (VALUE_BITSIZE (toval))
	      amount_to_copy = byte_offset + 1;
	    else
	      amount_to_copy = byte_offset + TYPE_LENGTH (type);
d677 3
a679 8
	    /* And a bounce buffer.  Be slightly over generous.  */
	    buffer = (char *) alloca (amount_to_copy + MAX_REGISTER_SIZE);

	    /* Copy it in.  */
	    for (regno = reg_offset, amount_copied = 0;
		 amount_copied < amount_to_copy;
		 amount_copied += REGISTER_RAW_SIZE (regno), regno++)
	      frame_register_read (frame, regno, buffer + amount_copied);
d681 8
a688 7
	    /* Modify what needs to be modified.  */
	    if (VALUE_BITSIZE (toval))
	      modify_field (buffer + byte_offset,
			    value_as_long (fromval),
			    VALUE_BITPOS (toval), VALUE_BITSIZE (toval));
	    else if (use_buffer)
	      memcpy (buffer + VALUE_OFFSET (toval), raw_buffer, use_buffer);
d690 2
a691 8
	      memcpy (buffer + byte_offset, VALUE_CONTENTS (fromval),
		      TYPE_LENGTH (type));

	    /* Copy it out.  */
	    for (regno = reg_offset, amount_copied = 0;
		 amount_copied < amount_to_copy;
		 amount_copied += REGISTER_RAW_SIZE (regno), regno++)
	      put_frame_register (frame, regno, buffer + amount_copied);
a692 1
	  }
d696 1
a696 1
	break;
d698 2
@


1.110.2.2
log
@2003-06-06  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (put_frame_register): Declare.
	* frame.c (put_frame_register): New function.

	* arch-utils.c: Include "gdbcore.h".
	(legacy_convert_register_p): Add "type" parameter.
	(legacy_register_to_value): Rewrite, use "frame" to get the
	register value.
	(legacy_value_to_register): Rewrite, use "frame" to find the
	register's location before storing.
	* arch-utils.h (legacy_convert_register_p): Update.
	(legacy_register_to_value, legacy_value_to_register): Update.

	* Makefile.in (arch-utils.o): Update dependencies.

	* findvar.c (value_from_register): Rewrite, eliminate use of
	REGISTER_CONVERT_TO_TYPE, pass "type" to CONVERT_REGISTER_P, pass
	"frame" to REGISTER_TO_VALUE.

	* gdbarch.sh (CONVERT_REGISTER_P): Add "type" parameter.
	(REGISTER_TO_VALUE, VALUE_TO_REGISTER): Replace raw buffer
	parameter with "frame".
	* gdbarch.h, gdbarch.c: Re-generate.

	* mips-tdep.c (mips_convert_register_p): New function.
	(mips_value_to_register): Replace mips_register_convert_from_type.
	(mips_register_to_value): Replace mips_register_convert_to_type.
	(mips_gdbarch_init): Set conver_register_p, value_to_register and
	register_to_value.

	* valops.c (value_assign): Move the CONVERT_REGISTER code to the
	lval_reg_frame_relative + lval_register branch of the switch.  Do
	not use REGISTER_CONVERT_FROM_TYPE.  Use put_frame_register.
@
text
@d590 1
a590 3
	if (VALUE_LVAL (toval) == lval_reg_frame_relative
	    && CONVERT_REGISTER_P (VALUE_FRAME_REGNUM (toval),
				   VALUE_TYPE (toval)))
d593 5
a597 3
	       conversion of program values to a special raw format.  */
	    VALUE_TO_REGISTER (frame, VALUE_FRAME_REGNUM (toval),
			       VALUE_TYPE (toval), VALUE_CONTENTS (toval));
@


1.110.2.3
log
@TOVAL.
@
text
@d591 2
a592 1
	    && CONVERT_REGISTER_P (VALUE_FRAME_REGNUM (toval), type))
d597 1
a597 1
			       type, VALUE_CONTENTS (fromval));
@


1.109
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@d608 1
a608 4
	    for (frame = get_current_frame ();
		 frame && get_frame_base (frame) != VALUE_FRAME (toval);
		 frame = get_prev_frame (frame))
	      ;
@


1.108
log
@2003-05-08  David Carlton  <carlton@@math.stanford.edu>

	* valops.c (push_word): Fix typo.
@
text
@d90 1
a90 1
  sym = lookup_symbol (name, 0, VAR_NAMESPACE, 0, NULL);
d2353 1
a2353 1
						0, VAR_NAMESPACE, 0, NULL);
d2513 1
a2513 1
  sym = lookup_block_symbol (b, name, NULL, VAR_NAMESPACE);
@


1.107
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@d965 1
a965 1
  char buffer[MAX_REGISTER_SIZE]);
@


1.106
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_SIZE): Rename REGISTER_SIZE.
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Rename
	SIZEOF_CALL_DUMMY_WORDS.
	(DEPRECATED_CALL_DUMMY_WORDS): Rename CALL_DUMMY_WORDS.
	(DEPRECATED_FIX_CALL_DUMMY): Rename FIX_CALL_DUMMY.
	(DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET): Rename
	CALL_DUMMY_BREAKPOINT_OFFSET.
	(DEPRECATED_CALL_DUMMY_START_OFFSET): Rename
	CALL_DUMMY_START_OFFSET.
	(DEPRECATED_CALL_DUMMY_LENGTH): Rename CALL_DUMMY_LENGTH.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-tdep.c, alphafbsd-tdep.c, arm-linux-tdep.c: Update.
	* arm-tdep.c, avr-tdep.c, breakpoint.c, cris-tdep.c: Update.
	* dummy-frame.c, dummy-frame.h, frv-tdep.c, gdbarch.c: Update.
	* gdbarch.h, gdbarch.sh, h8300-tdep.c, hppa-tdep.c: Update.
	* i386-tdep.c, ia64-tdep.c, infcall.c, inferior.h: Update.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Update.
	* mips-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* rs6000-tdep.c, s390-tdep.c, sh-tdep.c, sol-thread.c: Update.
	* sparc-tdep.c, target.c, v850-tdep.c, valops.c: Update.
	* vax-tdep.c, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/ia64/tm-ia64.h, config/m68k/tm-vx68.h: Update.
	* config/mips/tm-mips.h, config/pa/nm-hppah.h: Update.
	* config/pa/tm-hppa.h, config/pa/tm-hppa64.h: Update.
	* config/s390/tm-s390.h, config/sparc/tm-sp64.h: Update.
	* config/sparc/tm-sparc.h: Update.

Index: doc/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Make
	CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_LENGTH,
	FIX_CALL_DUMMY, CALL_DUMMY_BREAKPOINT_OFFSET and
	CALL_DUMMY_BREAKPOINT_OFFSET deprecated.

Index: mi/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Replace
	REGISTER_SIZE with DEPRECATED_REGISTER_SIZE.

Index: testsuite/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/watchpoint.exp: Rename CALL_DUMMY_BREAKPOINT_OFFSET to
	DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET in comments.
@
text
@d483 1
a483 1
  char *raw_buffer = (char*) alloca (MAX_REGISTER_RAW_SIZE);
d637 1
a637 2
	buffer = (char *) alloca (amount_to_copy
				  + MAX_REGISTER_RAW_SIZE);
d965 1
a965 1
  char *buffer = alloca (MAX_REGISTER_RAW_SIZE);
@


1.105
log
@2003-04-21  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c: New file.
	* infcall.h: New file.
	* valarith.c: Include "infcall.h".
	* scm-lang.c, objc-lang.cm, hppa-tdep.c, gcore.c: Ditto.
	* eval.c, ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (valarith.o, scm-lang.o): Update dependencies.
	(objc-lang.o, hppa-tdep.o, gcore.o): Update dependencies.
	(eval.o, ada-valprint.o, ada-lang.o): Update dependencies.
	(SFILES): Add "infcall.c"
	(COMMON_OBS): Add "infcall.o".
	(infcall.o): Specify dependencies.
	* value.h (call_function_by_hand): Delete declaration.
	* inferior.h (run_stack_dummy): Delete declaration.
	* infcmd.c (breakpoint_auto_delete_contents): Move to "infcall.c".
	(run_stack_dummy): Move to "infcall.c", merged into
	call_function_by_hand.
	* valops.c (call_function_by_hand): Moved to "infcall.c".
	(find_function_addr, value_arg_coerce): Ditto.
	(unwindonsignal_p, coerce_float_to_double): Ditto.
	(_initialize_valops): Move "set/show coerce-float-to-double", and
	"set/show unwindonsignal" commands to "infcall.c".
	* v850-tdep.c, target.h: Update comments.
	* sparc-tdep.c (sparc_fix_call_dummy): Update comments.
	* sh-tdep.c (sh_init_extra_frame_info): Update comments.
	(sh64_init_extra_frame_info): Update comments.
	* mn10300-tdep.c: Update comments.
	* mcore-tdep.c (mcore_init_extra_frame_info): Update comments.
	* config/sparc/tm-sparc.h: Update comments.
	* breakpoint.h: Update comments.
	* avr-tdep.c (avr_init_extra_frame_info): Update comments.
	* arm-tdep.c: Update comment.
@
text
@d965 1
a965 1
  register int len = REGISTER_SIZE;
@


1.104
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FIX_CALL_DUMMY): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Regenerate.
	* inferior.h (FIX_CALL_DUMMY): Delete macro.
	* valops.c (hand_function_call): Only call FIX_CALL_DUMMY when
	available.
	* frame.h (generic_fix_call_dummy): Delete declaration.
	* dummy-frame.h: Update comment.
	* dummy-frame.c (generic_fix_call_dummy): Delete function.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	fix_call_dummy.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@d37 1
a52 4
static CORE_ADDR find_function_addr (struct value *, struct type **);
static struct value *value_arg_coerce (struct value *, struct type *, int);


a83 31
/* This boolean tells what gdb should do if a signal is received while in
   a function called from gdb (call dummy).  If set, gdb unwinds the stack
   and restore the context to what as it was before the call.
   The default is to stop in the frame where the signal was received. */

int unwind_on_signal_p = 0;

/* How you should pass arguments to a function depends on whether it
   was defined in K&R style or prototype style.  If you define a
   function using the K&R syntax that takes a `float' argument, then
   callers must pass that argument as a `double'.  If you define the
   function using the prototype syntax, then you must pass the
   argument as a `float', with no promotion.

   Unfortunately, on certain older platforms, the debug info doesn't
   indicate reliably how each function was defined.  A function type's
   TYPE_FLAG_PROTOTYPED flag may be clear, even if the function was
   defined in prototype style.  When calling a function whose
   TYPE_FLAG_PROTOTYPED flag is clear, GDB consults this flag to decide
   what to do.

   For modern targets, it is proper to assume that, if the prototype
   flag is clear, that can be trusted: `float' arguments should be
   promoted to `double'.  For some older targets, if the prototype
   flag is clear, that doesn't tell us anything.  The default is to
   trust the debug information; the user can override this behavior
   with "set coerce-float-to-double 0".  */

static int coerce_float_to_double;


a1057 768
/* Perform the standard coercions that are specified
   for arguments to be passed to C functions.

   If PARAM_TYPE is non-NULL, it is the expected parameter type.
   IS_PROTOTYPED is non-zero if the function declaration is prototyped.  */

static struct value *
value_arg_coerce (struct value *arg, struct type *param_type,
		  int is_prototyped)
{
  register struct type *arg_type = check_typedef (VALUE_TYPE (arg));
  register struct type *type
    = param_type ? check_typedef (param_type) : arg_type;

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_REF:
      if (TYPE_CODE (arg_type) != TYPE_CODE_REF
	  && TYPE_CODE (arg_type) != TYPE_CODE_PTR)
	{
	  arg = value_addr (arg);
	  VALUE_TYPE (arg) = param_type;
	  return arg;
	}
      break;
    case TYPE_CODE_INT:
    case TYPE_CODE_CHAR:
    case TYPE_CODE_BOOL:
    case TYPE_CODE_ENUM:
      /* If we don't have a prototype, coerce to integer type if necessary.  */
      if (!is_prototyped)
	{
	  if (TYPE_LENGTH (type) < TYPE_LENGTH (builtin_type_int))
	    type = builtin_type_int;
	}
      /* Currently all target ABIs require at least the width of an integer
         type for an argument.  We may have to conditionalize the following
         type coercion for future targets.  */
      if (TYPE_LENGTH (type) < TYPE_LENGTH (builtin_type_int))
	type = builtin_type_int;
      break;
    case TYPE_CODE_FLT:
      if (!is_prototyped && coerce_float_to_double)
	{
	  if (TYPE_LENGTH (type) < TYPE_LENGTH (builtin_type_double))
	    type = builtin_type_double;
	  else if (TYPE_LENGTH (type) > TYPE_LENGTH (builtin_type_double))
	    type = builtin_type_long_double;
	}
      break;
    case TYPE_CODE_FUNC:
      type = lookup_pointer_type (type);
      break;
    case TYPE_CODE_ARRAY:
      /* Arrays are coerced to pointers to their first element, unless
         they are vectors, in which case we want to leave them alone,
         because they are passed by value.  */
      if (current_language->c_style_arrays)
	if (!TYPE_VECTOR (type))
	  type = lookup_pointer_type (TYPE_TARGET_TYPE (type));
      break;
    case TYPE_CODE_UNDEF:
    case TYPE_CODE_PTR:
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
    case TYPE_CODE_VOID:
    case TYPE_CODE_SET:
    case TYPE_CODE_RANGE:
    case TYPE_CODE_STRING:
    case TYPE_CODE_BITSTRING:
    case TYPE_CODE_ERROR:
    case TYPE_CODE_MEMBER:
    case TYPE_CODE_METHOD:
    case TYPE_CODE_COMPLEX:
    default:
      break;
    }

  return value_cast (type, arg);
}

/* Determine a function's address and its return type from its value.
   Calls error() if the function is not valid for calling.  */

static CORE_ADDR
find_function_addr (struct value *function, struct type **retval_type)
{
  register struct type *ftype = check_typedef (VALUE_TYPE (function));
  register enum type_code code = TYPE_CODE (ftype);
  struct type *value_type;
  CORE_ADDR funaddr;

  /* If it's a member function, just look at the function
     part of it.  */

  /* Determine address to call.  */
  if (code == TYPE_CODE_FUNC || code == TYPE_CODE_METHOD)
    {
      funaddr = VALUE_ADDRESS (function);
      value_type = TYPE_TARGET_TYPE (ftype);
    }
  else if (code == TYPE_CODE_PTR)
    {
      funaddr = value_as_address (function);
      ftype = check_typedef (TYPE_TARGET_TYPE (ftype));
      if (TYPE_CODE (ftype) == TYPE_CODE_FUNC
	  || TYPE_CODE (ftype) == TYPE_CODE_METHOD)
	{
	  funaddr = CONVERT_FROM_FUNC_PTR_ADDR (funaddr);
	  value_type = TYPE_TARGET_TYPE (ftype);
	}
      else
	value_type = builtin_type_int;
    }
  else if (code == TYPE_CODE_INT)
    {
      /* Handle the case of functions lacking debugging info.
         Their values are characters since their addresses are char */
      if (TYPE_LENGTH (ftype) == 1)
	funaddr = value_as_address (value_addr (function));
      else
	/* Handle integer used as address of a function.  */
	funaddr = (CORE_ADDR) value_as_long (function);

      value_type = builtin_type_int;
    }
  else
    error ("Invalid data type for function to be called.");

  *retval_type = value_type;
  return funaddr;
}

/* All this stuff with a dummy frame may seem unnecessarily complicated
   (why not just save registers in GDB?).  The purpose of pushing a dummy
   frame which looks just like a real frame is so that if you call a
   function and then hit a breakpoint (get a signal, etc), "backtrace"
   will look right.  Whether the backtrace needs to actually show the
   stack at the time the inferior function was called is debatable, but
   it certainly needs to not display garbage.  So if you are contemplating
   making dummy frames be different from normal frames, consider that.  */

/* Perform a function call in the inferior.
   ARGS is a vector of values of arguments (NARGS of them).
   FUNCTION is a value, the function to be called.
   Returns a value representing what the function returned.
   May fail to return, if a breakpoint or signal is hit
   during the execution of the function.

   ARGS is modified to contain coerced values. */

struct value *
call_function_by_hand (struct value *function, int nargs, struct value **args)
{
  register CORE_ADDR sp;
  register int i;
  int rc;
  CORE_ADDR start_sp;
  /* CALL_DUMMY is an array of words (REGISTER_SIZE), but each word
     is in host byte order.  Before calling FIX_CALL_DUMMY, we byteswap it
     and remove any extra bytes which might exist because ULONGEST is
     bigger than REGISTER_SIZE.

     NOTE: This is pretty wierd, as the call dummy is actually a
     sequence of instructions.  But CISC machines will have
     to pack the instructions into REGISTER_SIZE units (and
     so will RISC machines for which INSTRUCTION_SIZE is not
     REGISTER_SIZE).

     NOTE: This is pretty stupid.  CALL_DUMMY should be in strict
     target byte order. */

  static ULONGEST *dummy;
  int sizeof_dummy1;
  char *dummy1;
  CORE_ADDR dummy_addr;
  CORE_ADDR old_sp;
  struct type *value_type;
  unsigned char struct_return;
  CORE_ADDR struct_addr = 0;
  struct regcache *retbuf;
  struct cleanup *retbuf_cleanup;
  struct inferior_status *inf_status;
  struct cleanup *inf_status_cleanup;
  CORE_ADDR funaddr;
  int using_gcc;		/* Set to version of gcc in use, or zero if not gcc */
  CORE_ADDR real_pc;
  struct type *param_type = NULL;
  struct type *ftype = check_typedef (SYMBOL_TYPE (function));
  int n_method_args = 0;

  dummy = alloca (SIZEOF_CALL_DUMMY_WORDS);
  sizeof_dummy1 = REGISTER_SIZE * SIZEOF_CALL_DUMMY_WORDS / sizeof (ULONGEST);
  dummy1 = alloca (sizeof_dummy1);
  memcpy (dummy, CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS);

  if (!target_has_execution)
    noprocess ();

  /* Create a cleanup chain that contains the retbuf (buffer
     containing the register values).  This chain is create BEFORE the
     inf_status chain so that the inferior status can cleaned up
     (restored or discarded) without having the retbuf freed.  */
  retbuf = regcache_xmalloc (current_gdbarch);
  retbuf_cleanup = make_cleanup_regcache_xfree (retbuf);

  /* A cleanup for the inferior status.  Create this AFTER the retbuf
     so that this can be discarded or applied without interfering with
     the regbuf.  */
  inf_status = save_inferior_status (1);
  inf_status_cleanup = make_cleanup_restore_inferior_status (inf_status);

  if (DEPRECATED_PUSH_DUMMY_FRAME_P ())
    {
      /* DEPRECATED_PUSH_DUMMY_FRAME is responsible for saving the
	 inferior registers (and frame_pop() for restoring them).  (At
	 least on most machines) they are saved on the stack in the
	 inferior.  */
      DEPRECATED_PUSH_DUMMY_FRAME;
    }
  else
    {
      /* FIXME: cagney/2003-02-26: Step zero of this little tinker is
      to extract the generic dummy frame code from the architecture
      vector.  Hence this direct call.

      A follow-on change is to modify this interface so that it takes
      thread OR frame OR tpid as a parameter, and returns a dummy
      frame handle.  The handle can then be used further down as a
      parameter SAVE_DUMMY_FRAME_TOS.  Hmm, thinking about it, since
      everything is ment to be using generic dummy frames, why not
      even use some of the dummy frame code to here - do a regcache
      dup and then pass the duped regcache, along with all the other
      stuff, at one single point.

      In fact, you can even save the structure's return address in the
      dummy frame and fix one of those nasty lost struct return edge
      conditions.  */
      generic_push_dummy_frame ();
    }

  old_sp = read_sp ();

  /* Ensure that the initial SP is correctly aligned.  */
  if (gdbarch_frame_align_p (current_gdbarch))
    {
      /* NOTE: cagney/2002-09-18:

	 On a RISC architecture, a void parameterless generic dummy
	 frame (i.e., no parameters, no result) typically does not
	 need to push anything the stack and hence can leave SP and
	 FP.  Similarly, a framelss (possibly leaf) function does not
	 push anything on the stack and, hence, that too can leave FP
	 and SP unchanged.  As a consequence, a sequence of void
	 parameterless generic dummy frame calls to frameless
	 functions will create a sequence of effectively identical
	 frames (SP, FP and TOS and PC the same).  This, not
	 suprisingly, results in what appears to be a stack in an
	 infinite loop --- when GDB tries to find a generic dummy
	 frame on the internal dummy frame stack, it will always find
	 the first one.

	 To avoid this problem, the code below always grows the stack.
	 That way, two dummy frames can never be identical.  It does
	 burn a few bytes of stack but that is a small price to pay
	 :-).  */
      sp = gdbarch_frame_align (current_gdbarch, old_sp);
      if (sp == old_sp)
	{
	  if (INNER_THAN (1, 2))
	    /* Stack grows down.  */
	    sp = gdbarch_frame_align (current_gdbarch, old_sp - 1);
	  else
	    /* Stack grows up.  */
	    sp = gdbarch_frame_align (current_gdbarch, old_sp + 1);
	}
      gdb_assert ((INNER_THAN (1, 2) && sp <= old_sp)
		  || (INNER_THAN (2, 1) && sp >= old_sp));
    }
  else
    /* FIXME: cagney/2002-09-18: Hey, you loose!  Who knows how badly
       aligned the SP is!  Further, per comment above, if the generic
       dummy frame ends up empty (because nothing is pushed) GDB won't
       be able to correctly perform back traces.  If a target is
       having trouble with backtraces, first thing to do is add
       FRAME_ALIGN() to its architecture vector.  After that, try
       adding SAVE_DUMMY_FRAME_TOS() and modifying
       DEPRECATED_FRAME_CHAIN so that when the next outer frame is a
       generic dummy, it returns the current frame's base.  */
    sp = old_sp;

  if (INNER_THAN (1, 2))
    {
      /* Stack grows down */
      sp -= sizeof_dummy1;
      start_sp = sp;
    }
  else
    {
      /* Stack grows up */
      start_sp = sp;
      sp += sizeof_dummy1;
    }

  /* NOTE: cagney/2002-09-10: Don't bother re-adjusting the stack
     after allocating space for the call dummy.  A target can specify
     a SIZEOF_DUMMY1 (via SIZEOF_CALL_DUMMY_WORDS) such that all local
     alignment requirements are met.  */

  funaddr = find_function_addr (function, &value_type);
  CHECK_TYPEDEF (value_type);

  {
    struct block *b = block_for_pc (funaddr);
    /* If compiled without -g, assume GCC 2.  */
    using_gcc = (b == NULL ? 2 : BLOCK_GCC_COMPILED (b));
  }

  /* Are we returning a value using a structure return or a normal
     value return? */

  struct_return = using_struct_return (function, funaddr, value_type,
				       using_gcc);

  /* Create a call sequence customized for this function
     and the number of arguments for it.  */
  for (i = 0; i < (int) (SIZEOF_CALL_DUMMY_WORDS / sizeof (dummy[0])); i++)
    store_unsigned_integer (&dummy1[i * REGISTER_SIZE],
			    REGISTER_SIZE,
			    (ULONGEST) dummy[i]);

#ifdef GDB_TARGET_IS_HPPA
  real_pc = FIX_CALL_DUMMY (dummy1, start_sp, funaddr, nargs, args,
			    value_type, using_gcc);
#else
  if (FIX_CALL_DUMMY_P ())
    {
      /* gdb_assert (CALL_DUMMY_LOCATION == ON_STACK) true?  */
      FIX_CALL_DUMMY (dummy1, start_sp, funaddr, nargs, args, value_type,
		      using_gcc);
    }
  real_pc = start_sp;
#endif

  switch (CALL_DUMMY_LOCATION)
    {
    case ON_STACK:
      dummy_addr = start_sp;
      write_memory (start_sp, (char *) dummy1, sizeof_dummy1);
      if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES)
	generic_save_call_dummy_addr (start_sp, start_sp + sizeof_dummy1);
      break;
    case AT_ENTRY_POINT:
      real_pc = funaddr;
      dummy_addr = CALL_DUMMY_ADDRESS ();
      if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES)
	/* NOTE: cagney/2002-04-13: The entry point is going to be
           modified with a single breakpoint.  */
	generic_save_call_dummy_addr (CALL_DUMMY_ADDRESS (),
				      CALL_DUMMY_ADDRESS () + 1);
      break;
    default:
      internal_error (__FILE__, __LINE__, "bad switch");
    }

#ifdef lint
  sp = old_sp;			/* It really is used, for some ifdef's... */
#endif

  if (nargs < TYPE_NFIELDS (ftype))
    error ("too few arguments in function call");

  for (i = nargs - 1; i >= 0; i--)
    {
      int prototyped;

      /* FIXME drow/2002-05-31: Should just always mark methods as
	 prototyped.  Can we respect TYPE_VARARGS?  Probably not.  */
      if (TYPE_CODE (ftype) == TYPE_CODE_METHOD)
	prototyped = 1;
      else
	prototyped = TYPE_PROTOTYPED (ftype);

      if (i < TYPE_NFIELDS (ftype))
	args[i] = value_arg_coerce (args[i], TYPE_FIELD_TYPE (ftype, i),
				    prototyped);
      else
	args[i] = value_arg_coerce (args[i], NULL, 0);

      /*elz: this code is to handle the case in which the function to be called
         has a pointer to function as parameter and the corresponding actual argument
         is the address of a function and not a pointer to function variable.
         In aCC compiled code, the calls through pointers to functions (in the body
         of the function called by hand) are made via $$dyncall_external which
         requires some registers setting, this is taken care of if we call
         via a function pointer variable, but not via a function address.
         In cc this is not a problem. */

      if (using_gcc == 0)
	if (param_type && TYPE_CODE (ftype) != TYPE_CODE_METHOD)
	  /* if this parameter is a pointer to function */
	  if (TYPE_CODE (param_type) == TYPE_CODE_PTR)
	    if (TYPE_CODE (TYPE_TARGET_TYPE (param_type)) == TYPE_CODE_FUNC)
	      /* elz: FIXME here should go the test about the compiler used
	         to compile the target. We want to issue the error
	         message only if the compiler used was HP's aCC.
	         If we used HP's cc, then there is no problem and no need
	         to return at this point */
	      if (using_gcc == 0)	/* && compiler == aCC */
		/* go see if the actual parameter is a variable of type
		   pointer to function or just a function */
		if (args[i]->lval == not_lval)
		  {
		    char *arg_name;
		    if (find_pc_partial_function ((CORE_ADDR) args[i]->aligner.contents[0], &arg_name, NULL, NULL))
		      error ("\
You cannot use function <%s> as argument. \n\
You must use a pointer to function type variable. Command ignored.", arg_name);
		  }
    }

  if (REG_STRUCT_HAS_ADDR_P ())
    {
      /* This is a machine like the sparc, where we may need to pass a
	 pointer to the structure, not the structure itself.  */
      for (i = nargs - 1; i >= 0; i--)
	{
	  struct type *arg_type = check_typedef (VALUE_TYPE (args[i]));
	  if ((TYPE_CODE (arg_type) == TYPE_CODE_STRUCT
	       || TYPE_CODE (arg_type) == TYPE_CODE_UNION
	       || TYPE_CODE (arg_type) == TYPE_CODE_ARRAY
	       || TYPE_CODE (arg_type) == TYPE_CODE_STRING
	       || TYPE_CODE (arg_type) == TYPE_CODE_BITSTRING
	       || TYPE_CODE (arg_type) == TYPE_CODE_SET
	       || (TYPE_CODE (arg_type) == TYPE_CODE_FLT
		   && TYPE_LENGTH (arg_type) > 8)
	       )
	      && REG_STRUCT_HAS_ADDR (using_gcc, arg_type))
	    {
	      CORE_ADDR addr;
	      int len;		/*  = TYPE_LENGTH (arg_type); */
	      int aligned_len;
	      arg_type = check_typedef (VALUE_ENCLOSING_TYPE (args[i]));
	      len = TYPE_LENGTH (arg_type);

	      if (STACK_ALIGN_P ())
		/* MVS 11/22/96: I think at least some of this
		   stack_align code is really broken.  Better to let
		   PUSH_ARGUMENTS adjust the stack in a target-defined
		   manner.  */
		aligned_len = STACK_ALIGN (len);
	      else
		aligned_len = len;
	      if (INNER_THAN (1, 2))
		{
		  /* stack grows downward */
		  sp -= aligned_len;
		  /* ... so the address of the thing we push is the
		     stack pointer after we push it.  */
		  addr = sp;
		}
	      else
		{
		  /* The stack grows up, so the address of the thing
		     we push is the stack pointer before we push it.  */
		  addr = sp;
		  sp += aligned_len;
		}
	      /* Push the structure.  */
	      write_memory (addr, VALUE_CONTENTS_ALL (args[i]), len);
	      /* The value we're going to pass is the address of the
		 thing we just pushed.  */
	      /*args[i] = value_from_longest (lookup_pointer_type (value_type),
		(LONGEST) addr); */
	      args[i] = value_from_pointer (lookup_pointer_type (arg_type),
					    addr);
	    }
	}
    }


  /* Reserve space for the return structure to be written on the
     stack, if necessary.  Make certain that the value is correctly
     aligned. */

  if (struct_return)
    {
      int len = TYPE_LENGTH (value_type);
      if (STACK_ALIGN_P ())
	/* NOTE: cagney/2003-03-22: Should rely on frame align, rather
           than stack align to force the alignment of the stack.  */
	len = STACK_ALIGN (len);
      if (INNER_THAN (1, 2))
	{
	  /* Stack grows downward.  Align STRUCT_ADDR and SP after
             making space for the return value.  */
	  sp -= len;
	  if (gdbarch_frame_align_p (current_gdbarch))
	    sp = gdbarch_frame_align (current_gdbarch, sp);
	  struct_addr = sp;
	}
      else
	{
	  /* Stack grows upward.  Align the frame, allocate space, and
             then again, re-align the frame??? */
	  if (gdbarch_frame_align_p (current_gdbarch))
	    sp = gdbarch_frame_align (current_gdbarch, sp);
	  struct_addr = sp;
	  sp += len;
	  if (gdbarch_frame_align_p (current_gdbarch))
	    sp = gdbarch_frame_align (current_gdbarch, sp);
	}
    }

  /* elz: on HPPA no need for this extra alignment, maybe it is needed
     on other architectures. This is because all the alignment is
     taken care of in the above code (ifdef REG_STRUCT_HAS_ADDR) and
     in hppa_push_arguments */
  /* NOTE: cagney/2003-03-24: The below code is very broken.  Given an
     odd sized parameter the below will mis-align the stack.  As was
     suggested back in '96, better to let PUSH_ARGUMENTS handle it.  */
  if (DEPRECATED_EXTRA_STACK_ALIGNMENT_NEEDED)
    {
      /* MVS 11/22/96: I think at least some of this stack_align code
	 is really broken.  Better to let push_dummy_call() adjust the
	 stack in a target-defined manner.  */
      if (STACK_ALIGN_P () && INNER_THAN (1, 2))
	{
	  /* If stack grows down, we must leave a hole at the top. */
	  int len = 0;

	  for (i = nargs - 1; i >= 0; i--)
	    len += TYPE_LENGTH (VALUE_ENCLOSING_TYPE (args[i]));
	  if (DEPRECATED_CALL_DUMMY_STACK_ADJUST_P ())
	    len += DEPRECATED_CALL_DUMMY_STACK_ADJUST;
	  sp -= STACK_ALIGN (len) - len;
	}
    }

  /* Create the dummy stack frame.  Pass in the call dummy address as,
     presumably, the ABI code knows where, in the call dummy, the
     return address should be pointed.  */
  if (gdbarch_push_dummy_call_p (current_gdbarch))
    /* When there is no push_dummy_call method, should this code
       simply error out.  That would the implementation of this method
       for all ABIs (which is probably a good thing).  */
    sp = gdbarch_push_dummy_call (current_gdbarch, current_regcache,
				  dummy_addr, nargs, args, sp, struct_return,
				  struct_addr);
  else  if (DEPRECATED_PUSH_ARGUMENTS_P ())
    /* Keep old targets working.  */
    sp = DEPRECATED_PUSH_ARGUMENTS (nargs, args, sp, struct_return,
				    struct_addr);
  else
    sp = legacy_push_arguments (nargs, args, sp, struct_return, struct_addr);

  if (DEPRECATED_PUSH_RETURN_ADDRESS_P ())
    /* for targets that use no CALL_DUMMY */
    /* There are a number of targets now which actually don't write
       any CALL_DUMMY instructions into the target, but instead just
       save the machine state, push the arguments, and jump directly
       to the callee function.  Since this doesn't actually involve
       executing a JSR/BSR instruction, the return address must be set
       up by hand, either by pushing onto the stack or copying into a
       return-address register as appropriate.  Formerly this has been
       done in PUSH_ARGUMENTS, but that's overloading its
       functionality a bit, so I'm making it explicit to do it here.  */
    sp = DEPRECATED_PUSH_RETURN_ADDRESS (real_pc, sp);

  /* NOTE: cagney/2003-03-23: Diable this code when there is a
     push_dummy_call() method.  Since that method will have already
     handled any alignment issues, the code below is entirely
     redundant.  */
  if (!gdbarch_push_dummy_call_p (current_gdbarch)
      && STACK_ALIGN_P () && !INNER_THAN (1, 2))
    {
      /* If stack grows up, we must leave a hole at the bottom, note
         that sp already has been advanced for the arguments!  */
      if (DEPRECATED_CALL_DUMMY_STACK_ADJUST_P ())
	sp += DEPRECATED_CALL_DUMMY_STACK_ADJUST;
      sp = STACK_ALIGN (sp);
    }

/* XXX This seems wrong.  For stacks that grow down we shouldn't do
   anything here!  */
  /* MVS 11/22/96: I think at least some of this stack_align code is
     really broken.  Better to let PUSH_ARGUMENTS adjust the stack in
     a target-defined manner.  */
  if (DEPRECATED_CALL_DUMMY_STACK_ADJUST_P ())
    if (INNER_THAN (1, 2))
      {
	/* stack grows downward */
	sp -= DEPRECATED_CALL_DUMMY_STACK_ADJUST;
      }

  /* Store the address at which the structure is supposed to be
     written.  */
  /* NOTE: 2003-03-24: Since PUSH_ARGUMENTS can (and typically does)
     store the struct return address, this call is entirely redundant.  */
  if (struct_return && DEPRECATED_STORE_STRUCT_RETURN_P ())
    DEPRECATED_STORE_STRUCT_RETURN (struct_addr, sp);

  /* Write the stack pointer.  This is here because the statements above
     might fool with it.  On SPARC, this write also stores the register
     window into the right place in the new stack frame, which otherwise
     wouldn't happen.  (See store_inferior_registers in sparc-nat.c.)  */
  /* NOTE: cagney/2003-03-23: Disable this code when there is a
     push_dummy_call() method.  Since that method will have already
     stored the stack pointer (as part of creating the fake call
     frame), and none of the code following that code adjusts the
     stack-pointer value, the below call is entirely redundant.  */
  if (DEPRECATED_DUMMY_WRITE_SP_P ())
    DEPRECATED_DUMMY_WRITE_SP (sp);

  if (SAVE_DUMMY_FRAME_TOS_P ())
    SAVE_DUMMY_FRAME_TOS (sp);

  {
    char *name;
    struct symbol *symbol;

    name = NULL;
    symbol = find_pc_function (funaddr);
    if (symbol)
      {
	name = SYMBOL_PRINT_NAME (symbol);
      }
    else
      {
	/* Try the minimal symbols.  */
	struct minimal_symbol *msymbol = lookup_minimal_symbol_by_pc (funaddr);

	if (msymbol)
	  {
	    name = SYMBOL_PRINT_NAME (msymbol);
	  }
      }
    if (name == NULL)
      {
	char format[80];
	sprintf (format, "at %s", local_hex_format ());
	name = alloca (80);
	/* FIXME-32x64: assumes funaddr fits in a long.  */
	sprintf (name, format, (unsigned long) funaddr);
      }

    /* Execute the stack dummy routine, calling FUNCTION.
       When it is done, discard the empty frame
       after storing the contents of all regs into retbuf.  */
    rc = run_stack_dummy (real_pc + CALL_DUMMY_START_OFFSET, retbuf);

    if (rc == 1)
      {
	/* We stopped inside the FUNCTION because of a random signal.
	   Further execution of the FUNCTION is not allowed. */

        if (unwind_on_signal_p)
	  {
	    /* The user wants the context restored. */

            /* We must get back to the frame we were before the dummy
               call. */
	    frame_pop (get_current_frame ());

	    /* FIXME: Insert a bunch of wrap_here; name can be very long if it's
	       a C++ name with arguments and stuff.  */
	    error ("\
The program being debugged was signaled while in a function called from GDB.\n\
GDB has restored the context to what it was before the call.\n\
To change this behavior use \"set unwindonsignal off\"\n\
Evaluation of the expression containing the function (%s) will be abandoned.",
		   name);
	  }
	else
	  {
	    /* The user wants to stay in the frame where we stopped (default).*/

	    /* If we restored the inferior status (via the cleanup),
	       we would print a spurious error message (Unable to
	       restore previously selected frame), would write the
	       registers from the inf_status (which is wrong), and
	       would do other wrong things.  */
	    discard_cleanups (inf_status_cleanup);
	    discard_inferior_status (inf_status);

	    /* FIXME: Insert a bunch of wrap_here; name can be very long if it's
	       a C++ name with arguments and stuff.  */
	    error ("\
The program being debugged was signaled while in a function called from GDB.\n\
GDB remains in the frame where the signal was received.\n\
To change this behavior use \"set unwindonsignal on\"\n\
Evaluation of the expression containing the function (%s) will be abandoned.",
		   name);
	  }
      }

    if (rc == 2)
      {
	/* We hit a breakpoint inside the FUNCTION. */

	/* If we restored the inferior status (via the cleanup), we
	   would print a spurious error message (Unable to restore
	   previously selected frame), would write the registers from
	   the inf_status (which is wrong), and would do other wrong
	   things.  */
	discard_cleanups (inf_status_cleanup);
	discard_inferior_status (inf_status);

	/* The following error message used to say "The expression
	   which contained the function call has been discarded."  It
	   is a hard concept to explain in a few words.  Ideally, GDB
	   would be able to resume evaluation of the expression when
	   the function finally is done executing.  Perhaps someday
	   this will be implemented (it would not be easy).  */

	/* FIXME: Insert a bunch of wrap_here; name can be very long if it's
	   a C++ name with arguments and stuff.  */
	error ("\
The program being debugged stopped while in a function called from GDB.\n\
When the function (%s) is done executing, GDB will silently\n\
stop (instead of continuing to evaluate the expression containing\n\
the function call).", name);
      }

    /* If we get here the called FUNCTION run to completion. */

    /* Restore the inferior status, via its cleanup.  At this stage,
       leave the RETBUF alone.  */
    do_cleanups (inf_status_cleanup);

    /* Figure out the value returned by the function.  */
    /* elz: I defined this new macro for the hppa architecture only.
       this gives us a way to get the value returned by the function
       from the stack, at the same address we told the function to put
       it.  We cannot assume on the pa that r28 still contains the
       address of the returned structure. Usually this will be
       overwritten by the callee.  I don't know about other
       architectures, so I defined this macro */
#ifdef VALUE_RETURNED_FROM_STACK
    if (struct_return)
      {
	do_cleanups (retbuf_cleanup);
	return VALUE_RETURNED_FROM_STACK (value_type, struct_addr);
      }
#endif
    /* NOTE: cagney/2002-09-10: Only when the stack has been correctly
       aligned (using frame_align()) do we can trust STRUCT_ADDR and
       fetch the return value direct from the stack.  This lack of
       trust comes about because legacy targets have a nasty habit of
       silently, and local to PUSH_ARGUMENTS(), moving STRUCT_ADDR.
       For such targets, just hope that value_being_returned() can
       find the adjusted value.  */
    if (struct_return && gdbarch_frame_align_p (current_gdbarch))
      {
        struct value *retval = value_at (value_type, struct_addr, NULL);
        do_cleanups (retbuf_cleanup);
        return retval;
      }
    else
      {
	struct value *retval = value_being_returned (value_type, retbuf,
						     struct_return);
	do_cleanups (retbuf_cleanup);
	return retval;
      }
  }
}

a2685 25

  add_show_from_set (
  add_set_cmd ("unwindonsignal", no_class, var_boolean,
	       (char *) &unwind_on_signal_p,
"Set unwinding of stack if a signal is received while in a call dummy.\n\
The unwindonsignal lets the user determine what gdb should do if a signal\n\
is received while in a function called from gdb (call dummy).  If set, gdb\n\
unwinds the stack and restore the context to what as it was before the call.\n\
The default is to stop in the frame where the signal was received.", &setlist),
		     &showlist);

  add_show_from_set
    (add_set_cmd ("coerce-float-to-double", class_obscure, var_boolean,
		  (char *) &coerce_float_to_double,
		  "Set coercion of floats to doubles when calling functions\n"
 "Variables of type float should generally be converted to doubles before\n"
 "calling an unprototyped function, and left alone when calling a prototyped\n"
 "function.  However, some older debug info formats do not provide enough\n"
 "information to determine that a function is prototyped.  If this flag is\n"
 "set, GDB will perform the conversion for a function it considers\n"
 "unprototyped.\n"
 "The default is to perform the conversion.\n",
		  &setlist),
     &showlist);
  coerce_float_to_double = 1;
@


1.104.6.1
log
@Merge from mainline.
@
text
@a36 1
#include "infcall.h"
d52 4
d87 31
d1092 768
d3488 25
@


1.104.6.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d90 1
a90 1
  sym = lookup_symbol (name, 0, VAR_DOMAIN, 0, NULL);
d483 1
a483 1
  char raw_buffer[MAX_REGISTER_SIZE];
d637 2
a638 1
	buffer = (char *) alloca (amount_to_copy + MAX_REGISTER_SIZE);
d965 2
a966 2
  register int len = DEPRECATED_REGISTER_SIZE;
  char buffer[MAX_REGISTER_SIZE];
d2354 1
a2354 1
						0, VAR_DOMAIN, 0, NULL);
d2514 1
a2514 1
  sym = lookup_block_symbol (b, name, NULL, VAR_DOMAIN);
@


1.103
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_P): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* dummy-frame.c (dummy_frame_this_id): Update comments.
	* rs6000-tdep.c (rs6000_extract_struct_value_address): Ditto.
	* frame.c (legacy_get_prev_frame): Ditto.
	* valops.c (call_function_by_hand): Delete function.
	(hand_function_call): Rename to call_function_by_hand

2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to CALL_DUMMY_P.
@
text
@d1427 6
a1432 2
  FIX_CALL_DUMMY (dummy1, start_sp, funaddr, nargs, args,
		  value_type, using_gcc);
@


1.102
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_DUMMY_WRITE_SP): Replace TARGET_WRITE_SP.
	* gdbarch.h, gdbarch.c: Regenerate.
	* v850-tdep.c (v850_gdbarch_init): Set deprecated_dummy_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_push_dummy_frame, sparc_pop_frame): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_DUMMY_WRITE_SP): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Define.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* valops.c (hand_function_call): Replace TARGET_WRITE_SP with
	DEPRECATED_DUMMY_WRITE_SP.  Call when the method is available,
	instead of when push_dummy_call is not available.

2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Remove
	reference to TARGET_WRITE_SP.
@
text
@d1243 2
a1244 2
static struct value *
hand_function_call (struct value *function, int nargs, struct value **args)
a1854 15

struct value *
call_function_by_hand (struct value *function, int nargs, struct value **args)
{
  if (CALL_DUMMY_P)
    {
      return hand_function_call (function, nargs, args);
    }
  else
    {
      error ("Cannot invoke functions on this machine.");
    }
}


@


1.101
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_RETURN_ADDRESS): Replace
	PUSH_RETURN_ADDRESS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* valops.c (hand_function_call): Update.
@
text
@d1699 2
a1700 2
  if (!gdbarch_push_dummy_call_p (current_gdbarch))
    TARGET_WRITE_SP (sp);
@


1.100
log
@2003-03-27  Andrew Cagney  <cagney@@redhat.com>

	* regcache.c (write_sp): Delete function and references.
	* inferior.h (write_sp): Delete declaration.
	* valops.c (hand_function_call): Replace write_sp with
	TARGET_WRITE_SP.
	* sparc-tdep.c (sparc_push_dummy_frame): Ditto.
	(sparc_pop_frame): Ditto.

Index: doc/ChangeLog
2003-03-27  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Remove
	references to write_sp.
@
text
@d1644 1
a1644 1
  if (PUSH_RETURN_ADDRESS_P ())
d1655 1
a1655 1
    sp = PUSH_RETURN_ADDRESS (real_pc, sp);
@


1.99
log
@2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_ARGUMENTS): Rename PUSH_ARGUMENTS.
	(push_dummy_call): New pure multi-arch replacement with gdbarch,
	regcache and dummy_addr parameters.
	* gdbarch.h, gdbarch.c: Re-generate.
	* valops.c (hand_function_call): Use gdbarch_push_dummy_call when
	available; assume it will handle stack alignment and return
	address issues.  Fall back to DEPRECATED_PUSH_ARGUMENTS and
	legacy_push_arguments.
	(legacy_push_arguments): Rename default_push_arguments.
	* value.h (legacy_push_arguments): Rename default_push_arguments.
	* i386-tdep.c (i386_push_arguments): Call legacy_push_arguments.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/i386/tm-symmetry.h: Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* arm-linux-tdep.c (arm_linux_init_abi): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	PUSH_ARGUMENTS with push_dummy_call, add gdbarch, regcache and
	dummy_addr parameters.
@
text
@d1700 1
a1700 1
    write_sp (sp);
@


1.98
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_EXTRA_STACK_ALIGNMENT_NEEDED): Replace
	EXTRA_STACK_ALIGNMENT_NEEDED.  Default to 0 not 1.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h
	(DEPRECATED_EXTRA_STACK_ALIGNMENT_NEEDED): Define.
	* sparc-tdep.c (sparc_gdbarch_init): Set
	deprecated_extra_stack_alignment_needed.
	* config/pa/tm-hppa.h (EXTRA_STACK_ALIGNMENT_NEEDED): Delete.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not clear
	extra_stack_alignment_needed.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
@
text
@d1082 2
a1083 2
default_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
			int struct_return, CORE_ADDR struct_addr)
d1267 1
d1432 1
a1432 1
  if (CALL_DUMMY_LOCATION == ON_STACK)
d1434 2
d1439 2
a1440 4
    }

  if (CALL_DUMMY_LOCATION == AT_ENTRY_POINT)
    {
d1442 1
d1448 3
d1577 2
a1578 3
	/* MVS 11/22/96: I think at least some of this stack_align
	   code is really broken.  Better to let PUSH_ARGUMENTS adjust
	   the stack in a target-defined manner.  */
d1612 1
a1612 1
	 is really broken.  Better to let PUSH_ARGUMENTS adjust the
d1627 16
a1642 1
  sp = PUSH_ARGUMENTS (nargs, args, sp, struct_return, struct_addr);
d1657 6
a1662 1
  if (STACK_ALIGN_P () && !INNER_THAN (1, 2))
d1694 7
a1700 1
  write_sp (sp);
@


1.98.2.1
log
@Merge with mainline.
@
text
@d1082 2
a1083 2
legacy_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		       int struct_return, CORE_ADDR struct_addr)
a1266 1
  CORE_ADDR dummy_addr;
d1431 1
a1431 1
  switch (CALL_DUMMY_LOCATION)
a1432 2
    case ON_STACK:
      dummy_addr = start_sp;
d1436 4
a1439 2
      break;
    case AT_ENTRY_POINT:
a1440 1
      dummy_addr = CALL_DUMMY_ADDRESS ();
a1445 3
      break;
    default:
      internal_error (__FILE__, __LINE__, "bad switch");
d1572 3
a1574 2
	/* NOTE: cagney/2003-03-22: Should rely on frame align, rather
           than stack align to force the alignment of the stack.  */
d1608 1
a1608 1
	 is really broken.  Better to let push_dummy_call() adjust the
d1623 1
a1623 16
  /* Create the dummy stack frame.  Pass in the call dummy address as,
     presumably, the ABI code knows where, in the call dummy, the
     return address should be pointed.  */
  if (gdbarch_push_dummy_call_p (current_gdbarch))
    /* When there is no push_dummy_call method, should this code
       simply error out.  That would the implementation of this method
       for all ABIs (which is probably a good thing).  */
    sp = gdbarch_push_dummy_call (current_gdbarch, current_regcache,
				  dummy_addr, nargs, args, sp, struct_return,
				  struct_addr);
  else  if (DEPRECATED_PUSH_ARGUMENTS_P ())
    /* Keep old targets working.  */
    sp = DEPRECATED_PUSH_ARGUMENTS (nargs, args, sp, struct_return,
				    struct_addr);
  else
    sp = legacy_push_arguments (nargs, args, sp, struct_return, struct_addr);
d1625 1
a1625 1
  if (DEPRECATED_PUSH_RETURN_ADDRESS_P ())
d1636 1
a1636 1
    sp = DEPRECATED_PUSH_RETURN_ADDRESS (real_pc, sp);
d1638 1
a1638 6
  /* NOTE: cagney/2003-03-23: Diable this code when there is a
     push_dummy_call() method.  Since that method will have already
     handled any alignment issues, the code below is entirely
     redundant.  */
  if (!gdbarch_push_dummy_call_p (current_gdbarch)
      && STACK_ALIGN_P () && !INNER_THAN (1, 2))
d1670 1
a1670 7
  /* NOTE: cagney/2003-03-23: Disable this code when there is a
     push_dummy_call() method.  Since that method will have already
     stored the stack pointer (as part of creating the fake call
     frame), and none of the code following that code adjusts the
     stack-pointer value, the below call is entirely redundant.  */
  if (DEPRECATED_DUMMY_WRITE_SP_P ())
    DEPRECATED_DUMMY_WRITE_SP (sp);
@


1.97
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_STORE_STRUCT_RETURN): Replace
	STORE_STRUCT_RETURN.
	* gdbarch.h, gdbarch.c: Regenerate.
	* d10v-tdep.c (d10v_store_struct_return): Delete function.
	(d10v_push_arguments): Set the struct return register.
	(d10v_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d1602 4
a1605 1
  if (EXTRA_STACK_ALIGNMENT_NEEDED)
@


1.96
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_STACK_ADJUST_P): Delete.
	(DEPRECATED_CALL_DUMMY_STACK_ADJUST): Replace
	CALL_DUMMY_STACK_ADJUST with a predicate variable.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_stack_adjust_p.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sparc.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.  Do not set
	call_dummy_stack_adjust_p.
	* inferior.h (CALL_DUMMY_STACK_ADJUST_P): Delete macro.
	(CALL_DUMMY_STACK_ADJUST): Delete macro.
	* sparc-tdep.c (sparc32_push_arguments): Update.
	* valops.c (hand_function_call): Update.

2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	reference to CALL_DUMMY_STACK_ADJUST_P.  Rename
	CALL_DUMMY_STACK_ADJUST to DEPRECATED_CALL_DUMMY_STACK_ADJUST.
	Add reference to PUSH_ARGUMENTS.
@
text
@d1657 5
a1661 10
     written.  Note that this (and the code which reserved the space
     above) assumes that gcc was used to compile this function.  Since
     it doesn't cost us anything but space and if the function is pcc
     it will ignore this value, we will make that assumption.

     Also note that on some machines (like the sparc) pcc uses a
     convention like gcc's.  */

  if (struct_return)
    STORE_STRUCT_RETURN (struct_addr, sp);
@


1.95
log
@Index: ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_CHAIN): Replace FRAME_CHAIN.
	(DEPRECATED_FRAME_CHAIN_VALID): Replace FRAME_CHAIN_VALID.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update.
	* objfiles.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* frame.c (legacy_saved_regs_this_id): Update.
	(legacy_get_prev_frame, get_prev_frame, legacy_frame_p): Update.
	* dummy-frame.h: Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* config/m68k/tm-vx68.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-os68k.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-sun3.h: Update.
	* blockframe.c (inside_main_func, frame_chain_valid): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_frame_chain, sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	(rs6000_gdbarch_init, rs6000_frame_saved_pc): Update.
	(frame_get_saved_regs): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_frame_num_args, i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	(i386_interix_back_one_frame): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	(hppa_init_extra_frame_info): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Algorithms, Target Architecture Definition):
	Deprecate FRAME_CHAIN and FRAME_CHAIN_VALID.
@
text
@d1614 2
a1615 2
	  if (CALL_DUMMY_STACK_ADJUST_P)
	    len += CALL_DUMMY_STACK_ADJUST;
d1639 2
a1640 2
      if (CALL_DUMMY_STACK_ADJUST_P)
	sp += CALL_DUMMY_STACK_ADJUST;
d1649 1
a1649 1
  if (CALL_DUMMY_STACK_ADJUST_P)
d1653 1
a1653 1
	sp -= CALL_DUMMY_STACK_ADJUST;
@


1.94
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_POP_FRAME): Replace POP_FRAME.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update comment.
	* stack.c (return_command): Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_POP_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_POP_FRAME): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	POP_FRAME with DEPRECATED_POP_FRAME.  Update description.
@
text
@d1377 3
a1379 3
       adding SAVE_DUMMY_FRAME_TOS() and modifying FRAME_CHAIN so that
       when the next outer frame is a generic dummy, it returns the
       current frame's base.  */
@


1.93
log
@2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_DUMMY_FRAME): Procedure with
	predicate.  Replaces PUSH_DUMMY_FRAME.
	* gdbarch.h, gdbarch.c: Regnerate.
	* valops.c (hand_function_call): Update.  Call
	generic_push_dummy_frame directly.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* inferior.h (PUSH_DUMMY_FRAME): Delete definition.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Don't set
	push_dummy_frame to generic_push_dummy_frame.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@d1306 1
a1306 1
	 inferior registers (and POP_FRAME for restoring them).  (At
@


1.93.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d1306 1
a1306 1
	 inferior registers (and frame_pop() for restoring them).  (At
@


1.92
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d1303 28
a1330 4
  /* PUSH_DUMMY_FRAME is responsible for saving the inferior registers
     (and POP_FRAME for restoring them).  (At least on most machines)
     they are saved on the stack in the inferior.  */
  PUSH_DUMMY_FRAME;
@


1.91
log
@2003-02-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME;
	expand comment.
	* ada-lang.c (user_select_syms, ada_finish_decode_line_1): Replace
	SYMBOL_PRINT_NAME with SYMBOL_SOURCE_NAME.
	* ada-typeprint.c (ada_typedef_print): Ditto.
	* ax-gdb.c (gen_var_ref): Ditto.
	* breakpoint.c (print_one_breakpoint): Ditto.
	* buildsym.c (finish_block): Ditto.
	* c-valprint.c (c_val_print): Ditto.
	* expprint.c (print_subexp): Ditto.
	* findvar.c (locate_var_value): Ditto.
	* infcmd.c (jump_command): Ditto.
	* linespec.c (decode_line_2, decode_compound): Ditto.
	* maint.c (maintenance_translate_address): Ditto.
	* objc-lang.c (compare_selectors, compare_classes): Ditto.
	* printcmd.c (build_address_symbolic, sym_info, print_frame_args):
	Ditto.
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* stack.c (print_frame, frame_info, print_block_frame_locals)
	(print_frame_arg_vars, return_command): Ditto.
	* symfile.c (compare_symbols, compare_psymbols): Ditto.
	* symmisc.c (print_symbol): Ditto.
	* symtab.c (lookup_partial_symbol, lookup_block_symbol)
	(compare_search_syms, print_symbol_info, print_msymbol_info)
	(rbreak_command): Ditto.
	* tracepoint.c (tracepoints_info): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* valops.c (value_of_variable, hand_function_call): Ditto.
	* cli/cli-cmds.c (edit_command, list_command): Ditto.
	* ada-typeprint.c: Update Copyright.
	* infcmd.c, objc-lang.c, p-valprint.c, symmisc.c: Ditto.
	* tracepoint.c, cli/cli-cmds.c: Ditto.
@
text
@d2738 1
a2738 1
      func_name = cplus_demangle (SYMBOL_NAME (fsym), DMGL_NO_OPTS);
@


1.90
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d838 1
a838 1
	      && SYMBOL_SOURCE_NAME (BLOCK_FUNCTION (b)))
d840 1
a840 1
		   SYMBOL_SOURCE_NAME (BLOCK_FUNCTION (b)));
d848 1
a848 1
    error ("Address of symbol \"%s\" is unknown.", SYMBOL_SOURCE_NAME (var));
d1661 1
a1661 1
	name = SYMBOL_SOURCE_NAME (symbol);
d1670 1
a1670 1
	    name = SYMBOL_SOURCE_NAME (msymbol);
@


1.89
log
@	* valops.c (value_assign): Flush frame cache after stores to memory
	also.
@
text
@d36 1
@


1.89.2.1
log
@Merge kseitz_interps-20020528-branch.
@
text
@a729 2
	if (regno > VALUE_FRAME_REGNUM (toval) + reg_offset)
	  regno = -1;
@


1.89.2.2
log
@Kill off anything not directly related to the CLI command.
@
text
@d730 2
@


1.88
log
@2003-01-21  Andrew Cagney  <ac131313@@redhat.com>

	* exec.c (text_start): Delete global variable.
	(exec_file_attach): Make text_start local to the function.
	* inferior.h (BEFORE_TEXT_END, AFTER_TEXT_END): Delete macros.
	* valops.c (hand_function_call): Delete code that handles
	BEFORE_TEXT_END and AFTER_TEXT_END.
	* gdbarch.sh (CALL_DUMMY_LENGTH): Test call_dummy_length instead
	of CALL_DUMMY_LOCATION.
	* gdbarch.c: Regenerate.
	* inferior.h (deprecated_pc_in_call_dummy_before_text_end)
	(deprecated_pc_in_call_dummy_after_text_end): Delete declaration.
	* blockframe.c (deprecated_pc_in_call_dummy_before_text_end)
	(deprecated_pc_in_call_dummy_after_text_end): Delete functions.
	(text_end): Delete extern declaration.
@
text
@d518 1
d548 5
a620 1
	struct frame_id old_frame;
a632 5
	/* Since modifying a register can trash the frame chain, we
           save the old frame and then restore the new frame
           afterwards.  */
	old_frame = get_frame_id (deprecated_selected_frame);

a733 20
	/* Assigning to the stack pointer, frame pointer, and other
	   (architecture and calling convention specific) registers
	   may cause the frame cache to be out of date.  We just do
	   this on all assignments to registers for simplicity; I
	   doubt the slowdown matters.  */
	reinit_frame_cache ();

	/* Having destoroyed the frame cache, restore the selected
           frame.  */
	/* FIXME: cagney/2002-11-02: There has to be a better way of
           doing this.  Instead of constantly saving/restoring the
           frame.  Why not create a get_selected_frame() function
           that, having saved the selected frame's ID can
           automatically re-find the previously selected frame
           automatically.  */
	{
	  struct frame_info *fi = frame_find_by_id (old_frame);
	  if (fi != NULL)
	    select_frame (fi);
	}
d742 32
@


1.87
log
@2003-01-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame-unwind.h (frame_unwind_pop_ftype): Declare.
	(struct frame_unwind): Add field pop.
	* frame.h (frame_pop): Declare.
	* frame.c (frame_saved_regs_pop): New function.
	(trad_frame_unwinder): Add frame_saved_regs_pop.
	(frame_pop): New function.
	* dummy-frame.c (dummy_frame_pop): New function.
	(discard_innermost_dummy): New function.
	(generic_pop_dummy_frame): Use discard_innermost_dummy.
	(dummy_frame_unwind): Add dummy_frame_pop.
	* infrun.c (normal_stop): Call frame_pop instead of POP_FRAME.
	* valops.c (hand_function_call): Ditto.
	* stack.c (return_command): Ditto.
@
text
@a1400 31
  if (CALL_DUMMY_LOCATION == BEFORE_TEXT_END)
    {
      /* Convex Unix prohibits executing in the stack segment. */
      /* Hope there is empty room at the top of the text segment. */
      extern CORE_ADDR text_end;
      static int checked = 0;
      if (!checked)
	for (start_sp = text_end - sizeof_dummy1; start_sp < text_end; ++start_sp)
	  if (read_memory_integer (start_sp, 1) != 0)
	    error ("text segment full -- no place to put call");
      checked = 1;
      sp = old_sp;
      real_pc = text_end - sizeof_dummy1;
      write_memory (real_pc, (char *) dummy1, sizeof_dummy1);
      if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES)
	generic_save_call_dummy_addr (real_pc, real_pc + sizeof_dummy1);
    }

  if (CALL_DUMMY_LOCATION == AFTER_TEXT_END)
    {
      extern CORE_ADDR text_end;
      int errcode;
      sp = old_sp;
      real_pc = text_end;
      errcode = target_write_memory (real_pc, (char *) dummy1, sizeof_dummy1);
      if (errcode != 0)
	error ("Cannot write text segment -- call_function failed");
      if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES)
	generic_save_call_dummy_addr (real_pc, real_pc + sizeof_dummy1);
    }

@


1.86
log
@gdb/
	* buildsym.h (processing_hp_compilation): Remove obsolete variable.
	* gdbarch.sh Remove include of "value.h" in gdbarch.h.
	(COERCE_FLOAT_TO_DOUBLE): Remove.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* Makefile.in: Remove value_h from gdbarch_h.
	* valops.c (coerce_float_to_double): New variable.
	(default_coerce_float_to_double): Remove.
	(standard_coerce_float_to_double): Remove.
	(value_arg_coerce): Use coerce_float_to_double.
	(_initialize_valops): Add "set coerce-float-to-double".
	* value.h (default_coerce_float_to_double): Remove prototype.
	(standard_coerce_float_to_double): Remove prototype.

	* hpread.c (hpread_process_one_debug_symbol): Mark C++ functions as
	prototyped.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Mark all functions as prototyped.

	* hppa-tdep.c (hppa_coerce_float_to_double): Remove.
	* alpha-tdep.c (alpha_gdbarch_init): Remove call to
	set_gdbarch_coerce_float_to_double.
	* arm-tdep.c (arm_gdbarch_init): Likewise.
	* frv-tdep.c (frv_gdbarch_init): Likewise.
	* h8300-tdep.c (h8300_gdbarch_init): Likewise (commented out).
	* i386-sol2-tdep.c (i386_sol2_init_abi): Likewise.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	(mips_coerce_float_to_double): Remove.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	(rs6000_coerce_float_to_double): Remove.
	* s390-tdep.c (s390_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	(sh_coerce_float_to_double): Remove.
	* sparc-tdep.c (sparc_gdbarch_init): Likewise.
	(sparc_coerce_float_to_double): Remove.
	* v850-tdep.c (v850_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.
	* config/m32r/tm-m32r.h (COERCE_FLOAT_TO_DOUBLE): Remove.
	* config/pa/tm-hppa.h: (COERCE_FLOAT_TO_DOUBLE): Remove.
	(hppa_coerce_float_to_double): Remove prototype.
	* config/sparc/tm-sparc.h (COERCE_FLOAT_TO_DOUBLE): Remove.
doc/
	* gdb.texinfo (Controlling GDB): Add ABI section.  Document
	"set coerce-float-to-double".
	* gdbint.texinfo (COERCE_FLOAT_TO_DOUBLE): Remove documentation.
testsuite/
	* gdb.base/callfuncs.exp: Don't XFAIL unprototyped functions for
	stabs.
	* gdb.base/completion.exp: Allow marker1(void) as well as marker1().
	* gdb.base/whatis.exp: Always allow (void) after function names.
@
text
@d1714 3
a1716 2
            /* We must get back to the frame we were before the dummy call. */
            POP_FRAME;
@


1.86.2.1
log
@Merge branch with mainline:
POP_FRAME_P;
frame-unwind.h.
@
text
@d1714 2
a1715 3
            /* We must get back to the frame we were before the dummy
               call. */
	    frame_pop (get_current_frame ());
@


1.85
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* valarith.c (value_binop): Delete obsolete code and comments.
	* configure.host: Ditto.
	* buildsym.h (make_blockvector): Ditto.
	* buildsym.c (make_blockvector): Ditto.
	* defs.h (enum language): Ditto.
	(chill_demangle): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* dwarfread.c (CHILL_PRODUCER): Ditto.
	(set_cu_language): Ditto.
	(handle_producer): Ditto.
	* expprint.c (print_subexp): Ditto.
	* gdbtypes.c (chill_varying_type): Ditto.
	* gdbtypes.h (builtin_type_chill_bool): Ditto.
	(builtin_type_chill_char, builtin_type_chill_long): Ditto.
	(builtin_type_chill_ulong, builtin_type_chill_real): Ditto.
	(chill_varying_type): Ditto.
	* language.h (_LANG_chill): Ditto.
	* language.c (binop_result_type, integral_type): Ditto.
	(character_type, string_type, structured_type): Ditto.
	(lang_bool_type, binop_type_check): Ditto.
	* stabsread.h (os9k_stabs): Ditto.
	* stabsread.c (os9k_type_vector, dbx_lookup_type): Ditto.
	(define_symbol, read_type, read_struct_fields): Ditto.
	(read_array_type, read_enum_type, read_huge_number): Ditto.
	(read_range_type, start_stabs): Ditto.
	* symfile.c (init_filename_language_table): Ditto.
	(add_psymbol_with_dem_name_to_list): Ditto.
	* symtab.c (symbol_init_language_specific): Ditto.
	(symbol_init_demangled_name, symbol_demangled_name): Ditto.
	* symtab.h (struct general_symbol_info): Ditto.
	(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* valops.c (value_cast, search_struct_field, value_slice): Delete
	obsolete code.
	(varying_to_slice): Delete function.
	* value.h (COERCE_VARYING_ARRAY): Delete obsolete macro contents.
	(varying_to_slice): Delete declaration.
	* MAINTAINERS: Update.
@
text
@d3 1
a3 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d92 23
a116 1

a1078 43

/* Functions to use for the COERCE_FLOAT_TO_DOUBLE gdbarch method.

   How you should pass arguments to a function depends on whether it
   was defined in K&R style or prototype style.  If you define a
   function using the K&R syntax that takes a `float' argument, then
   callers must pass that argument as a `double'.  If you define the
   function using the prototype syntax, then you must pass the
   argument as a `float', with no promotion.

   Unfortunately, on certain older platforms, the debug info doesn't
   indicate reliably how each function was defined.  A function type's
   TYPE_FLAG_PROTOTYPED flag may be clear, even if the function was
   defined in prototype style.  When calling a function whose
   TYPE_FLAG_PROTOTYPED flag is clear, GDB consults the
   COERCE_FLOAT_TO_DOUBLE gdbarch method to decide what to do.

   For modern targets, it is proper to assume that, if the prototype
   flag is clear, that can be trusted: `float' arguments should be
   promoted to `double'.  You should register the function
   `standard_coerce_float_to_double' to get this behavior.

   For some older targets, if the prototype flag is clear, that
   doesn't tell us anything.  So we guess that, if we don't have a
   type for the formal parameter (i.e., the first argument to
   COERCE_FLOAT_TO_DOUBLE is null), then we should promote it;
   otherwise, we should leave it alone.  The function
   `default_coerce_float_to_double' provides this behavior; it is the
   default value, for compatibility with older configurations.  */
int
default_coerce_float_to_double (struct type *formal, struct type *actual)
{
  return formal == NULL;
}


int
standard_coerce_float_to_double (struct type *formal, struct type *actual)
{
  return 1;
}


d1121 1
a1121 5
      /* FIXME: We should always convert floats to doubles in the
         non-prototyped case.  As many debugging formats include
         no information about prototyping, we have to live with
         COERCE_FLOAT_TO_DOUBLE for now.  */
      if (!is_prototyped && COERCE_FLOAT_TO_DOUBLE (param_type, arg_type))
d3474 15
@


1.84
log
@2002-12-03  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (get_frame_id): Convert to a function.
	(null_frame_id, frame_id_p): Declare.
	(frame_id_eq, frame_id_inner): Declare.
	(frame_id_build): New function.
	* frame.c (get_frame_id): Update.  Use null_frame_id.
	(frame_find_by_id): Rewrite using frame_id_p, frame_id_eq and
	frame_id_inner.
	(null_frame_id, frame_id_p): Define.
	(frame_id_eq, frame_id_inner): Define.
	(frame_id_build): New function.
	* varobj.c (varobj_create): Update.
	(varobj_update): Update.
	* valops.c (value_assign): Update.
	(new_root_variable): Update.
	* infrun.c (save_inferior_status): Update.
	* breakpoint.c (watch_command_1): Update.
@
text
@a378 43
  /* OBSOLETE else if (chill_varying_type (type)) */
  /* OBSOLETE   { */
  /* OBSOLETE     struct type *range1, *range2, *eltype1, *eltype2; */
  /* OBSOLETE     struct value *val; */
  /* OBSOLETE     int count1, count2; */
  /* OBSOLETE     LONGEST low_bound, high_bound; */
  /* OBSOLETE     char *valaddr, *valaddr_data; */
  /* OBSOLETE     *//* For lint warning about eltype2 possibly uninitialized: */
  /* OBSOLETE     eltype2 = NULL; */
  /* OBSOLETE     if (code2 == TYPE_CODE_BITSTRING) */
  /* OBSOLETE       error ("not implemented: converting bitstring to varying type"); */
  /* OBSOLETE     if ((code2 != TYPE_CODE_ARRAY && code2 != TYPE_CODE_STRING) */
  /* OBSOLETE         || (eltype1 = check_typedef (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 1))), */
  /* OBSOLETE       eltype2 = check_typedef (TYPE_TARGET_TYPE (type2)), */
  /* OBSOLETE                                (TYPE_LENGTH (eltype1) != TYPE_LENGTH (eltype2) */
  /* OBSOLETE     *//*|| TYPE_CODE (eltype1) != TYPE_CODE (eltype2) *//* ))) */
  /* OBSOLETE      error ("Invalid conversion to varying type"); */
  /* OBSOLETE     range1 = TYPE_FIELD_TYPE (TYPE_FIELD_TYPE (type, 1), 0); */
  /* OBSOLETE     range2 = TYPE_FIELD_TYPE (type2, 0); */
  /* OBSOLETE     if (get_discrete_bounds (range1, &low_bound, &high_bound) < 0) */
  /* OBSOLETE       count1 = -1; */
  /* OBSOLETE     else */
  /* OBSOLETE       count1 = high_bound - low_bound + 1; */
  /* OBSOLETE     if (get_discrete_bounds (range2, &low_bound, &high_bound) < 0) */
  /* OBSOLETE       count1 = -1, count2 = 0;	*//* To force error before */
  /* OBSOLETE     else */
  /* OBSOLETE       count2 = high_bound - low_bound + 1; */
  /* OBSOLETE     if (count2 > count1) */
  /* OBSOLETE       error ("target varying type is too small"); */
  /* OBSOLETE     val = allocate_value (type); */
  /* OBSOLETE     valaddr = VALUE_CONTENTS_RAW (val); */
  /* OBSOLETE     valaddr_data = valaddr + TYPE_FIELD_BITPOS (type, 1) / 8; */
  /* OBSOLETE     *//* Set val's __var_length field to count2. */
  /* OBSOLETE     store_signed_integer (valaddr, TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)), */
  /* OBSOLETE 	    count2); */
  /* OBSOLETE     *//* Set the __var_data field to count2 elements copied from arg2. */
  /* OBSOLETE     memcpy (valaddr_data, VALUE_CONTENTS (arg2), */
  /* OBSOLETE      count2 * TYPE_LENGTH (eltype2)); */
  /* OBSOLETE     *//* Zero the rest of the __var_data field of val. */
  /* OBSOLETE     memset (valaddr_data + count2 * TYPE_LENGTH (eltype2), '\0', */
  /* OBSOLETE      (count1 - count2) * TYPE_LENGTH (eltype2)); */
  /* OBSOLETE     return val; */
  /* OBSOLETE   } */
d2123 7
a2129 6
		   In the GNU Chill (OBSOLETE) implementation of
		   variant record types, each <alternative field> has
		   an (anonymous) union type, each member of the union
		   represents a <variant alternative>.  Each <variant
		   alternative> is represented as a struct, with a
		   member for each <variant field>.  */
d2136 4
a2139 4
		   enclosing struct.  In the GNU Chill (OBSOLETE)
		   implementation of variant records, the bitpos is
		   zero in an anonymous union field, so we have to add
		   the offset of the union here. */
a3366 3
    /* OBSOLETE Chill allows zero-length strings but not arrays. */
    /* OBSOLETE || (current_language->la_language == language_chill */
    /* OBSOLETE && length == 0 && TYPE_CODE (array_type) == TYPE_CODE_ARRAY)) */
a3419 13
}

/* Assuming OBSOLETE chill_varying_type (VARRAY) is true, return an
   equivalent value as a fixed-length array. */

struct value *
varying_to_slice (struct value *varray)
{
  struct type *vtype = check_typedef (VALUE_TYPE (varray));
  LONGEST length = unpack_long (TYPE_FIELD_TYPE (vtype, 0),
				VALUE_CONTENTS (varray)
				+ TYPE_FIELD_BITPOS (vtype, 0) / 8);
  return value_slice (value_primitive_field (varray, 0, 1, vtype), 0, length);
@


1.83
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d652 1
a652 1
	get_frame_id (deprecated_selected_frame, &old_frame);
@


1.82
log
@2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_USE_GENERIC_DUMMY_FRAMES): Rename
	USE_GENERIC_DUMMY_FRAMES.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c, frame.c: Update.
	* config/z8k/tm-z8k.h, config/mn10200/tm-mn10200.h: Update.
	* config/m32r/tm-m32r.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, blockframe.c: Update.
	* vax-tdep.c, sparc-tdep.c, ns32k-tdep.c: Ditto.
	* m68k-tdep.c, alpha-tdep.c: Ditto.

	* arm-tdep.c: Eliminate USE_GENERIC_DUMMY_FRAMES as always 1.
	* mips-tdep.c: Ditto.

Index: doc/ChangeLog
2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Host Definition): Delete documentation on
	USE_GENERIC_DUMMY_FRAMES.
@
text
@d652 1
a652 1
	get_frame_id (selected_frame, &old_frame);
d3330 1
a3330 1
  if (selected_frame == 0)
d3338 1
a3338 1
  func = get_frame_function (selected_frame);
d3368 1
a3368 1
  ret = read_var_value (sym, selected_frame);
@


1.81
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_FP): Delete macro.
	(get_frame_base): New function declaration.
	* frame.c (get_frame_base): New function.
	(get_frame_id): Use ->frame.
	(frame_find_by_id): Rewrite to use get_frame_id.
	* blockframe.c: Use get_frame_base instead of FRAME_FP.
	* cris-tdep.c, d10v-tdep.c, findvar.c, h8500-tdep.c: Ditto.
	* hppa-tdep.c, i386-tdep.c, infcmd.c, infrun.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, rs6000-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, stack.c, tracepoint.c: Ditto.
	* v850-tdep.c, valops.c, z8k-tdep.c: Ditto.
@
text
@d1465 1
a1465 1
      if (USE_GENERIC_DUMMY_FRAMES)
d1483 1
a1483 1
      if (USE_GENERIC_DUMMY_FRAMES)
d1496 1
a1496 1
      if (USE_GENERIC_DUMMY_FRAMES)
d1503 1
a1503 1
      if (USE_GENERIC_DUMMY_FRAMES)
@


1.80
log
@	* valops.c (value_slice): Move declaration of `offset' to avoid
	warning.
@
text
@d663 1
a663 1
		 frame && FRAME_FP (frame) != VALUE_FRAME (toval);
@


1.79
log
@2002-11-06  Andrew Cagney  <ac131313@@redhat.com>

	* valops.c (value_assign): Merge lval_register case into
	lval_reg_frame_relative.  Use frame_register and
	regcache_cooked_write instead of get_saved_register and
	write_register_bytes.  After flushing the register cache, try to
	re-select the selected frame.
@
text
@d3395 1
a3395 1
  LONGEST lowerbound, upperbound, offset;
d3446 1
a3446 1
      offset
@


1.78
log
@2002-10-23  Michael Snyder  <msnyder@@redhat.com>

	* printcmd.c (address_info): Restore quotes in output.
	* valops.c (value_of_local): Restore quotes in error message.
@
text
@d633 1
a634 53
      if (VALUE_BITSIZE (toval))
	{
	  char buffer[sizeof (LONGEST)];
	  int len =
		REGISTER_RAW_SIZE (VALUE_REGNO (toval)) - VALUE_OFFSET (toval);

	  if (len > (int) sizeof (LONGEST))
	    error ("Can't handle bitfields in registers larger than %d bits.",
		   (int) sizeof (LONGEST) * HOST_CHAR_BIT);

	  if (VALUE_BITPOS (toval) + VALUE_BITSIZE (toval)
	      > len * HOST_CHAR_BIT)
	    /* Getting this right would involve being very careful about
	       byte order.  */
	    error ("Can't assign to bitfields that cross register "
		   "boundaries.");

	  read_register_bytes (VALUE_ADDRESS (toval) + VALUE_OFFSET (toval),
			       buffer, len);
	  modify_field (buffer, value_as_long (fromval),
			VALUE_BITPOS (toval), VALUE_BITSIZE (toval));
	  write_register_bytes (VALUE_ADDRESS (toval) + VALUE_OFFSET (toval),
				buffer, len);
	}
      else if (use_buffer)
	write_register_bytes (VALUE_ADDRESS (toval) + VALUE_OFFSET (toval),
			      raw_buffer, use_buffer);
      else
	{
	  /* Do any conversion necessary when storing this type to more
	     than one register.  */
#ifdef REGISTER_CONVERT_FROM_TYPE
	  memcpy (raw_buffer, VALUE_CONTENTS (fromval), TYPE_LENGTH (type));
	  REGISTER_CONVERT_FROM_TYPE (VALUE_REGNO (toval), type, raw_buffer);
	  write_register_bytes (VALUE_ADDRESS (toval) + VALUE_OFFSET (toval),
				raw_buffer, TYPE_LENGTH (type));
#else
	  write_register_bytes (VALUE_ADDRESS (toval) + VALUE_OFFSET (toval),
			      VALUE_CONTENTS (fromval), TYPE_LENGTH (type));
#endif
	}

      target_changed_event ();

      /* Assigning to the stack pointer, frame pointer, and other
         (architecture and calling convention specific) registers may
         cause the frame cache to be out of date.  We just do this
         on all assignments to registers for simplicity; I doubt the slowdown
         matters.  */
      reinit_frame_cache ();
      break;

    case lval_reg_frame_relative:
d636 1
a639 4
	int amount_to_copy = (VALUE_BITSIZE (toval) ? 1 : TYPE_LENGTH (type));
	int reg_size = REGISTER_RAW_SIZE (VALUE_FRAME_REGNUM (toval));
	int byte_offset = VALUE_OFFSET (toval) % reg_size;
	int reg_offset = VALUE_OFFSET (toval) / reg_size;
d641 5
a645 7

	/* Make the buffer large enough in all cases.  */
	/* FIXME (alloca): Not safe for very large data types. */
	char *buffer = (char *) alloca (amount_to_copy
					+ sizeof (LONGEST)
					+ MAX_REGISTER_RAW_SIZE);

d649 5
d655 13
a667 4
	for (frame = get_current_frame ();
	     frame && FRAME_FP (frame) != VALUE_FRAME (toval);
	     frame = get_prev_frame (frame))
	  ;
d672 21
a692 1
	amount_to_copy += (reg_size - amount_to_copy % reg_size);
d694 2
a695 3
	/* Copy it out.  */
	for ((regno = VALUE_FRAME_REGNUM (toval) + reg_offset,
	      amount_copied = 0);
d697 1
a697 1
	     amount_copied += reg_size, regno++)
d699 1
a699 3
	    get_saved_register (buffer + amount_copied,
				(int *) NULL, (CORE_ADDR *) NULL,
				frame, regno, (enum lval_type *) NULL);
d701 1
a701 1

d704 5
a708 3
	  modify_field (buffer + byte_offset,
			value_as_long (fromval),
			VALUE_BITPOS (toval), VALUE_BITSIZE (toval));
d710 3
a712 1
	  memcpy (buffer + byte_offset, raw_buffer, use_buffer);
d714 10
a723 2
	  memcpy (buffer + byte_offset, VALUE_CONTENTS (fromval),
		  TYPE_LENGTH (type));
d725 2
a726 3
	/* Copy it back.  */
	for ((regno = VALUE_FRAME_REGNUM (toval) + reg_offset,
	      amount_copied = 0);
d728 1
a728 1
	     amount_copied += reg_size, regno++)
d733 2
a734 1

d736 3
a738 3
	    get_saved_register ((char *) NULL,
				&optim, &addr, frame, regno, &lval);

d742 2
a743 1
	      write_memory (addr, buffer + amount_copied, reg_size);
d745 2
a746 1
	      write_register_bytes (addr, buffer + amount_copied, reg_size);
d754 21
d777 2
a778 2


@


1.77
log
@2002-10-23  Michael Snyder  <msnyder@@redhat.com>

	* valops.c (value_of_local): Restore quotes in error message.
@
text
@d3333 1
a3333 1
	error ("no %s in nameless context", name);
d3343 1
a3343 1
	error ("no args, no '%s'", name);
d3354 1
a3354 1
	error ("current stack frame does not contain a variable named \"%s\"", name);
d3361 1
a3361 1
    error ("%s argument unreadable", name);
@


1.76
log
@valops.c (value_of_local): New function.
(value_of_this): Use it.
value.h (value_of_local): Declared.
@
text
@d3343 1
a3343 1
	error ("no args, no %s", name);
@


1.75
log
@Revert previous change.  Not obvious.
@
text
@d3309 1
a3309 1
/* C++: return the value of the class instance variable, if one exists.
d3314 1
a3314 1
value_of_this (int complain)
d3319 1
a3319 2
  static const char funny_this[] = "this";
  struct value *this;
d3333 1
a3333 1
	error ("no `this' in nameless context");
d3343 1
a3343 1
	error ("no args, no `this'");
d3350 1
a3350 1
  sym = lookup_block_symbol (b, funny_this, NULL, VAR_NAMESPACE);
d3354 1
a3354 1
	error ("current stack frame not in method");
d3359 17
a3375 4
  this = read_var_value (sym, selected_frame);
  if (this == 0 && complain)
    error ("`this' argument at unknown address");
  return this;
@


1.75.4.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d3309 1
a3309 1
/* Return the value of the local variable, if one exists.
d3314 1
a3314 1
value_of_local (const char *name, int complain)
d3319 2
a3320 1
  struct value * ret;
d3334 1
a3334 1
	error ("no `%s' in nameless context", name);
d3344 1
a3344 1
	error ("no args, no `%s'", name);
d3351 1
a3351 1
  sym = lookup_block_symbol (b, name, NULL, VAR_NAMESPACE);
d3355 1
a3355 1
	error ("current stack frame does not contain a variable named `%s'", name);
d3360 4
a3363 17
  ret = read_var_value (sym, selected_frame);
  if (ret == 0 && complain)
    error ("`%s' argument unreadable", name);
  return ret;
}

/* C++/Objective-C: return the value of the class instance variable,
   if one exists.  Flag COMPLAIN signals an error if the request is
   made in an inappropriate context.  */

struct value *
value_of_this (int complain)
{
  if (current_language->la_language == language_objc)
    return value_of_local ("self", complain);
  else
    return value_of_local ("this", complain);
@


1.75.4.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
a35 4
#include "block.h"
#include "infcall.h"
#include "dictionary.h"
#include "cp-support.h"
a39 1
#include "cp-support.h"
d51 4
a65 11

static struct value *value_struct_elt_for_reference (struct type *domain,
						     int offset,
						     struct type *curtype,
						     char *name,
						     struct type *intype);

static struct value *value_namespace_elt (const struct type *curtype,
					  const char *name,
					  enum noside noside);

d86 9
d100 2
a101 2
  struct symbol *sym;
  sym = lookup_symbol (name, 0, VAR_DOMAIN, 0, NULL);
d169 3
a171 3
  enum type_code code1;
  enum type_code code2;
  int scalar;
d379 43
d535 1
a535 1
  struct type *type;
d537 1
a537 1
  char raw_buffer[MAX_REGISTER_SIZE];
a538 1
  struct frame_id old_frame;
d552 15
a566 4
  /* Since modifying a register can trash the frame chain, and modifying memory
     can trash the frame cache, we save the old frame and then restore the new
     frame afterwards.  */
  old_frame = get_frame_id (deprecated_selected_frame);
d633 53
a686 1
    case lval_register:
d688 16
a704 1
	int value_reg;
d707 4
a710 10
	if (VALUE_LVAL (toval) == lval_register)
	  {
	    frame = get_current_frame ();
	    value_reg = VALUE_REGNO (toval);
	  }
	else
	  {
	    frame = frame_find_by_id (VALUE_FRAME_ID (toval));
	    value_reg = VALUE_FRAME_REGNUM (toval);
	  }
d714 8
a721 3
	
	if (VALUE_LVAL (toval) == lval_reg_frame_relative
	    && CONVERT_REGISTER_P (VALUE_FRAME_REGNUM (toval), type))
d723 3
a725 4
	    /* If TOVAL is a special machine register requiring
	       conversion of program values to a special raw format.  */
	    VALUE_TO_REGISTER (frame, VALUE_FRAME_REGNUM (toval),
			       type, VALUE_CONTENTS (fromval));
d727 8
d736 8
d745 14
a758 25
	    /* TOVAL is stored in a series of registers in the frame
	       specified by the structure.  Copy that value out,
	       modify it, and copy it back in.  */
	    int amount_copied;
	    int amount_to_copy;
	    char *buffer;
	    int reg_offset;
	    int byte_offset;
	    int regno;

	    /* Locate the first register that falls in the value that
	       needs to be transfered.  Compute the offset of the
	       value in that register.  */
	    {
	      int offset;
	      for (reg_offset = value_reg, offset = 0;
		   offset + DEPRECATED_REGISTER_RAW_SIZE (reg_offset) <= VALUE_OFFSET (toval);
		   reg_offset++);
	      byte_offset = VALUE_OFFSET (toval) - offset;
	    }

	    /* Compute the number of register aligned values that need
	       to be copied.  */
	    if (VALUE_BITSIZE (toval))
	      amount_to_copy = byte_offset + 1;
d760 2
a761 21
	      amount_to_copy = byte_offset + TYPE_LENGTH (type);
	    
	    /* And a bounce buffer.  Be slightly over generous.  */
	    buffer = (char *) alloca (amount_to_copy + MAX_REGISTER_SIZE);

	    /* Copy it in.  */
	    for (regno = reg_offset, amount_copied = 0;
		 amount_copied < amount_to_copy;
		 amount_copied += DEPRECATED_REGISTER_RAW_SIZE (regno), regno++)
	      frame_register_read (frame, regno, buffer + amount_copied);
	    
	    /* Modify what needs to be modified.  */
	    if (VALUE_BITSIZE (toval))
	      modify_field (buffer + byte_offset,
			    value_as_long (fromval),
			    VALUE_BITPOS (toval), VALUE_BITSIZE (toval));
	    else if (use_buffer)
	      memcpy (buffer + VALUE_OFFSET (toval), raw_buffer, use_buffer);
	    else
	      memcpy (buffer + byte_offset, VALUE_CONTENTS (fromval),
		      TYPE_LENGTH (type));
a762 7
	    /* Copy it out.  */
	    for (regno = reg_offset, amount_copied = 0;
		 amount_copied < amount_to_copy;
		 amount_copied += DEPRECATED_REGISTER_RAW_SIZE (regno), regno++)
	      put_frame_register (frame, regno, buffer + amount_copied);

	  }
a765 1
	break;
d767 3
a769 1
      
a773 32
  /* Assigning to the stack pointer, frame pointer, and other
     (architecture and calling convention specific) registers may
     cause the frame cache to be out of date.  Assigning to memory
     also can.  We just do this on all assignments to registers or
     memory, for simplicity's sake; I doubt the slowdown matters.  */
  switch (VALUE_LVAL (toval))
    {
    case lval_memory:
    case lval_register:
    case lval_reg_frame_relative:

      reinit_frame_cache ();

      /* Having destoroyed the frame cache, restore the selected frame.  */

      /* FIXME: cagney/2002-11-02: There has to be a better way of
	 doing this.  Instead of constantly saving/restoring the
	 frame.  Why not create a get_selected_frame() function that,
	 having saved the selected frame's ID can automatically
	 re-find the previously selected frame automatically.  */

      {
	struct frame_info *fi = frame_find_by_id (old_frame);
	if (fi != NULL)
	  select_frame (fi);
      }

      break;
    default:
      break;
    }
  
d837 1
a837 1
	      && SYMBOL_PRINT_NAME (BLOCK_FUNCTION (b)))
d839 1
a839 1
		   SYMBOL_PRINT_NAME (BLOCK_FUNCTION (b)));
d847 1
a847 1
    error ("Address of symbol \"%s\" is unknown.", SYMBOL_PRINT_NAME (var));
d878 1
a878 1
  struct type *type = check_typedef (VALUE_TYPE (arg1));
d998 2
a999 2
  int len = DEPRECATED_REGISTER_SIZE;
  char buffer[MAX_REGISTER_SIZE];
d1047 1
a1047 1
value_push (CORE_ADDR sp, struct value *arg)
d1049 3
a1051 3
  int len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (arg));
  int container_len = len;
  int offset;
d1081 2
a1082 2
legacy_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		       int struct_return, CORE_ADDR struct_addr)
d1091 804
d2114 1
a2114 1
		     struct type *type, int looking_for_baseclass)
d2157 6
a2162 7
		   In the GNU Chill (now deleted from GDB)
		   implementation of variant record types, each
		   <alternative field> has an (anonymous) union type,
		   each member of the union represents a <variant
		   alternative>.  Each <variant alternative> is
		   represented as a struct, with a member for each
		   <variant field>.  */
d2169 4
a2172 4
		   enclosing struct.  In the GNU Chill (now deleted
		   from GDB) implementation of variant records, the
		   bitpos is zero in an anonymous union field, so we
		   have to add the offset of the union here. */
d2353 1
a2353 1
		      int *static_memfuncp, struct type *type)
d2498 1
a2498 1
  struct type *t;
d2779 2
a2780 2
  int jj;
  int ix;
d2813 1
a2813 1
      func_name = cplus_demangle (DEPRECATED_SYMBOL_NAME (fsym), DMGL_NO_OPTS);
d3006 1
a3006 1
      if (strlen (name + 1) != len || strncmp (dname, name + 1, len) != 0)
d3019 1
a3019 1
check_field_in (struct type *type, const char *name)
d3021 1
a3021 1
  int i;
d3062 1
a3062 1
  struct type *t;
a3088 24
   return the appropriate member.  This function is used to resolve
   user expressions of the form "DOMAIN::NAME".  For more details on
   what happens, see the comment before
   value_struct_elt_for_reference.  */

struct value *
value_aggregate_elt (struct type *curtype,
		     char *name,
		     enum noside noside)
{
  switch (TYPE_CODE (curtype))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      return value_struct_elt_for_reference (curtype, 0, curtype, name, NULL);
    case TYPE_CODE_NAMESPACE:
      return value_namespace_elt (curtype, name, noside);
    default:
      internal_error (__FILE__, __LINE__,
		      "non-aggregate type in value_aggregate_elt");
    }
}

/* C++: Given an aggregate type CURTYPE, and a member name NAME,
d3100 2
a3101 2
  struct type *t = curtype;
  int i;
d3112 1
a3112 1
      if (t_field_name && strcmp (t_field_name, name) == 0)
d3159 1
a3159 1
      if (t_field_name && strcmp (t_field_name, name) == 0)
d3190 1
a3190 1
						0, VAR_DOMAIN, 0, NULL);
a3227 31
/* C++: Return the member NAME of the namespace given by the type
   CURTYPE.  */

static struct value *
value_namespace_elt (const struct type *curtype,
		     const char *name,
		     enum noside noside)
{
  const char *namespace_name = TYPE_TAG_NAME (curtype);
  struct symbol *sym;
  struct value *retval;

  sym = cp_lookup_symbol_namespace (namespace_name, name, NULL,
				    get_selected_block (0), VAR_DOMAIN,
				    NULL);

  if (sym == NULL)
    retval = NULL;
  else if ((noside == EVAL_AVOID_SIDE_EFFECTS)
	   && (SYMBOL_CLASS (sym) == LOC_TYPEDEF))
    retval = allocate_value (SYMBOL_TYPE (sym));
  else
    retval = value_of_variable (sym, get_selected_block (0));

  if (retval == NULL)
    error ("No symbol \"%s\" in namespace \"%s\".", name,
	   TYPE_TAG_NAME (curtype));

  return retval;
}

d3318 1
d3321 1
a3321 1
  if (deprecated_selected_frame == 0)
d3329 1
a3329 1
  func = get_frame_function (deprecated_selected_frame);
d3339 2
a3340 1
  if (dict_empty (BLOCK_DICT (b)))
d3350 1
a3350 1
  sym = lookup_block_symbol (b, name, NULL, VAR_DOMAIN);
d3359 1
a3359 1
  ret = read_var_value (sym, deprecated_selected_frame);
d3386 1
a3386 1
  LONGEST lowerbound, upperbound;
d3400 3
d3437 1
a3437 1
      LONGEST offset
d3458 13
d3538 10
@


1.75.4.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d3 1
a3 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d65 1
a65 31
static int find_oload_champ_namespace (struct type **arg_types, int nargs,
				       const char *func_name,
				       const char *qualified_name,
				       struct symbol ***oload_syms,
				       struct badness_vector **oload_champ_bv);

static
int find_oload_champ_namespace_loop (struct type **arg_types, int nargs,
				     const char *func_name,
				     const char *qualified_name,
				     int namespace_len,
				     struct symbol ***oload_syms,
				     struct badness_vector **oload_champ_bv,
				     int *oload_champ);

static int find_oload_champ (struct type **arg_types, int nargs, int method,
			     int num_fns,
			     struct fn_field *fns_ptr,
			     struct symbol **oload_syms,
			     struct badness_vector **oload_champ_bv);

static int oload_method_static (int method, struct fn_field *fns_ptr,
				int index);

enum oload_classification { STANDARD, NON_STANDARD, INCOMPATIBLE };

static enum
oload_classification classify_oload_match (struct badness_vector
					   * oload_champ_bv,
					   int nargs,
					   int static_offset);
a66 1
static int check_field_in (struct type *, const char *);
d72 1
a72 2
						     struct type *intype,
						     enum noside noside);
d75 1
a75 1
					  char *name,
a77 4
static struct value *value_maybe_namespace_elt (const struct type *curtype,
						char *name,
						enum noside noside);

d1892 3
d1897 6
a1902 1
  int oload_champ;		/* Index of best overloaded function */
d1904 1
d1913 1
d1916 1
a1916 1
  struct cleanup *old_cleanups = NULL;
d1918 1
a1918 1
  const char *obj_type_name = NULL;
a1919 1
  enum oload_classification match_quality;
a1942 2
      oload_champ = find_oload_champ (arg_types, nargs, method, num_fns,
				      fns_ptr, oload_syms, &oload_champ_bv);
d1946 2
a1947 2
      const char *qualified_name = SYMBOL_CPLUS_DEMANGLED_NAME (fsym);
      func_name	= cp_func_name (qualified_name);
d1951 1
a1951 1
      if (func_name == NULL)
d1957 6
a1962 75
      old_cleanups = make_cleanup (xfree, func_name);
      make_cleanup (xfree, oload_syms);
      make_cleanup (xfree, oload_champ_bv);

      oload_champ = find_oload_champ_namespace (arg_types, nargs,
						func_name,
						qualified_name,
						&oload_syms,
						&oload_champ_bv);
    }

  /* Check how bad the best match is.  */

  match_quality
    = classify_oload_match (oload_champ_bv, nargs,
			    oload_method_static (method, fns_ptr,
						 oload_champ));

  if (match_quality == INCOMPATIBLE)
    {
      if (method)
	error ("Cannot resolve method %s%s%s to any overloaded instance",
	       obj_type_name,
	       (obj_type_name && *obj_type_name) ? "::" : "",
	       name);
      else
	error ("Cannot resolve function %s to any overloaded instance",
	       func_name);
    }
  else if (match_quality == NON_STANDARD)
    {
      if (method)
	warning ("Using non-standard conversion to match method %s%s%s to supplied arguments",
		 obj_type_name,
		 (obj_type_name && *obj_type_name) ? "::" : "",
		 name);
      else
	warning ("Using non-standard conversion to match function %s to supplied arguments",
		 func_name);
    }

  if (method)
    {
      if (staticp != NULL)
	*staticp = oload_method_static (method, fns_ptr, oload_champ);
      if (TYPE_FN_FIELD_VIRTUAL_P (fns_ptr, oload_champ))
	*valp = value_virtual_fn_field (&temp, fns_ptr, oload_champ, basetype, boffset);
      else
	*valp = value_fn_field (&temp, fns_ptr, oload_champ, basetype, boffset);
    }
  else
    {
      *symp = oload_syms[oload_champ];
    }

  if (objp)
    {
      if (TYPE_CODE (VALUE_TYPE (temp)) != TYPE_CODE_PTR
	  && TYPE_CODE (VALUE_TYPE (*objp)) == TYPE_CODE_PTR)
	{
	  temp = value_addr (temp);
	}
      *objp = temp;
    }
  if (old_cleanups != NULL)
    do_cleanups (old_cleanups);

  switch (match_quality)
    {
    case INCOMPATIBLE:
      return 100;
    case NON_STANDARD:
      return 10;
    default:				/* STANDARD */
      return 0;
a1963 8
}

/* Find the best overload match, searching for FUNC_NAME in namespaces
   contained in QUALIFIED_NAME until it either finds a good match or
   runs out of namespaces.  It stores the overloaded functions in
   *OLOAD_SYMS, and the badness vector in *OLOAD_CHAMP_BV.  The
   calling function is responsible for freeing *OLOAD_SYMS and
   *OLOAD_CHAMP_BV.  */
d1965 1
a1965 151
static int
find_oload_champ_namespace (struct type **arg_types, int nargs,
			    const char *func_name,
			    const char *qualified_name,
			    struct symbol ***oload_syms,
			    struct badness_vector **oload_champ_bv)
{
  int oload_champ;

  find_oload_champ_namespace_loop (arg_types, nargs,
				   func_name,
				   qualified_name, 0,
				   oload_syms, oload_champ_bv,
				   &oload_champ);

  return oload_champ;
}

/* Helper function for find_oload_champ_namespace; NAMESPACE_LEN is
   how deep we've looked for namespaces, and the champ is stored in
   OLOAD_CHAMP.  The return value is 1 if the champ is a good one, 0
   if it isn't.

   It is the caller's responsibility to free *OLOAD_SYMS and
   *OLOAD_CHAMP_BV.  */

static int
find_oload_champ_namespace_loop (struct type **arg_types, int nargs,
				 const char *func_name,
				 const char *qualified_name,
				 int namespace_len,
				 struct symbol ***oload_syms,
				 struct badness_vector **oload_champ_bv,
				 int *oload_champ)
{
  int next_namespace_len = namespace_len;
  int searched_deeper = 0;
  int num_fns = 0;
  struct cleanup *old_cleanups;
  int new_oload_champ;
  struct symbol **new_oload_syms;
  struct badness_vector *new_oload_champ_bv;
  char *new_namespace;

  if (next_namespace_len != 0)
    {
      gdb_assert (qualified_name[next_namespace_len] == ':');
      next_namespace_len +=  2;
    }
  next_namespace_len
    += cp_find_first_component (qualified_name + next_namespace_len);

  /* Initialize these to values that can safely be xfree'd.  */
  *oload_syms = NULL;
  *oload_champ_bv = NULL;

  /* First, see if we have a deeper namespace we can search in.  If we
     get a good match there, use it.  */

  if (qualified_name[next_namespace_len] == ':')
    {
      searched_deeper = 1;

      if (find_oload_champ_namespace_loop (arg_types, nargs,
					   func_name, qualified_name,
					   next_namespace_len,
					   oload_syms, oload_champ_bv,
					   oload_champ))
	{
	  return 1;
	}
    };

  /* If we reach here, either we're in the deepest namespace or we
     didn't find a good match in a deeper namespace.  But, in the
     latter case, we still have a bad match in a deeper namespace;
     note that we might not find any match at all in the current
     namespace.  (There's always a match in the deepest namespace,
     because this overload mechanism only gets called if there's a
     function symbol to start off with.)  */

  old_cleanups = make_cleanup (xfree, *oload_syms);
  old_cleanups = make_cleanup (xfree, *oload_champ_bv);
  new_namespace = alloca (namespace_len + 1);
  strncpy (new_namespace, qualified_name, namespace_len);
  new_namespace[namespace_len] = '\0';
  new_oload_syms = make_symbol_overload_list (func_name,
					      new_namespace);
  while (new_oload_syms[num_fns])
    ++num_fns;

  new_oload_champ = find_oload_champ (arg_types, nargs, 0, num_fns,
				      NULL, new_oload_syms,
				      &new_oload_champ_bv);

  /* Case 1: We found a good match.  Free earlier matches (if any),
     and return it.  Case 2: We didn't find a good match, but we're
     not the deepest function.  Then go with the bad match that the
     deeper function found.  Case 3: We found a bad match, and we're
     the deepest function.  Then return what we found, even though
     it's a bad match.  */

  if (new_oload_champ != -1
      && classify_oload_match (new_oload_champ_bv, nargs, 0) == STANDARD)
    {
      *oload_syms = new_oload_syms;
      *oload_champ = new_oload_champ;
      *oload_champ_bv = new_oload_champ_bv;
      do_cleanups (old_cleanups);
      return 1;
    }
  else if (searched_deeper)
    {
      xfree (new_oload_syms);
      xfree (new_oload_champ_bv);
      discard_cleanups (old_cleanups);
      return 0;
    }
  else
    {
      gdb_assert (new_oload_champ != -1);
      *oload_syms = new_oload_syms;
      *oload_champ = new_oload_champ;
      *oload_champ_bv = new_oload_champ_bv;
      discard_cleanups (old_cleanups);
      return 0;
    }
}

/* Look for a function to take NARGS args of types ARG_TYPES.  Find
   the best match from among the overloaded methods or functions
   (depending on METHOD) given by FNS_PTR or OLOAD_SYMS, respectively.
   The number of methods/functions in the list is given by NUM_FNS.
   Return the index of the best match; store an indication of the
   quality of the match in OLOAD_CHAMP_BV.

   It is the caller's responsibility to free *OLOAD_CHAMP_BV.  */

static int
find_oload_champ (struct type **arg_types, int nargs, int method,
		  int num_fns, struct fn_field *fns_ptr,
		  struct symbol **oload_syms,
		  struct badness_vector **oload_champ_bv)
{
  int ix;
  struct badness_vector *bv;	/* A measure of how good an overloaded instance is */
  int oload_champ = -1;		/* Index of best overloaded function */
  int oload_ambiguous = 0;	/* Current ambiguity state for overload resolution */
  /* 0 => no ambiguity, 1 => two good funcs, 2 => incomparable funcs */

  *oload_champ_bv = NULL;
d1970 1
a1970 5
      int jj;
      int static_offset = oload_method_static (method, fns_ptr, ix);
      int nparms;
      struct type **parm_types;

d1973 2
d1995 1
a1995 1
      if (!*oload_champ_bv)
d1997 1
a1997 1
	  *oload_champ_bv = bv;
d1999 1
d2003 1
a2003 1
	switch (compare_badness (bv, *oload_champ_bv))
d2007 1
d2011 1
d2014 1
a2014 1
	    *oload_champ_bv = bv;	/* new champion, record details */
d2017 2
d2035 16
d2052 1
d2054 8
a2061 2
  return oload_champ;
}
d2063 25
a2087 2
/* Return 1 if we're looking at a static method, 0 if we're looking at
   a non-static method or a function that isn't a method.  */
d2089 11
a2099 5
static int
oload_method_static (int method, struct fn_field *fns_ptr, int index)
{
  if (method && TYPE_FN_FIELD_STATIC_P (fns_ptr, index))
    return 1;
d2101 4
a2104 2
    return 0;
}
d2106 1
a2106 10
/* Check how good an overload match OLOAD_CHAMP_BV represents.  */

static enum oload_classification
classify_oload_match (struct badness_vector *oload_champ_bv,
		      int nargs,
		      int static_offset)
{
  int ix;

  for (ix = 1; ix <= nargs - static_offset; ix++)
d2108 6
a2113 4
      if (oload_champ_bv->rank[ix] >= 100)
	return INCOMPATIBLE;	/* truly mismatched types */
      else if (oload_champ_bv->rank[ix] >= 10)
	return NON_STANDARD;	/* non-standard type conversions needed */
d2115 2
d2118 1
a2118 1
  return STANDARD;		/* Only standard conversions needed.  */
d2237 1
a2237 2
      return value_struct_elt_for_reference (curtype, 0, curtype, name, NULL,
					     noside);
d2253 1
a2253 1
static struct value *
d2256 1
a2256 2
				struct type *intype,
				enum noside noside)
d2379 1
a2379 2
					  intype,
					  noside);
d2383 1
a2383 6

  /* As a last chance, pretend that CURTYPE is a namespace, and look
     it up that way; this (frequently) works for types nested inside
     classes.  */

  return value_maybe_namespace_elt (curtype, name, noside);
d2391 1
a2391 1
		     char *name,
a2393 21
  struct value *retval = value_maybe_namespace_elt (curtype, name,
						    noside);

  if (retval == NULL)
    error ("No symbol \"%s\" in namespace \"%s\".", name,
	   TYPE_TAG_NAME (curtype));

  return retval;
}

/* A helper function used by value_namespace_elt and
   value_struct_elt_for_reference.  It looks up NAME inside the
   context CURTYPE; this works if CURTYPE is a namespace or if CURTYPE
   is a class and NAME refers to a type in CURTYPE itself (as opposed
   to, say, some base class of CURTYPE).  */

static struct value *
value_maybe_namespace_elt (const struct type *curtype,
			   char *name,
			   enum noside noside)
{
d2396 1
d2403 1
a2403 1
    return NULL;
d2406 1
a2406 1
    return allocate_value (SYMBOL_TYPE (sym));
d2408 7
a2414 1
    return value_of_variable (sym, get_selected_block (0));
d2416 1
@


1.75.2.1
log
@2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* dictionary.c (struct dict_vtbl): 'add_symbol' field.
	(add_symbol_generic): New function.
	(free_obstack): New function.
	(dict_create_hashed): New function.
	(lookup_hashed): New function.
	(iterator_first_hashed): New function.
	(iterator_hashed_advance): New function.
	(iterator_next_hashed): New function.
	* dictionary.h: A few more declarations.
	* mdebugread.c (parse_symbol): Use dict_iterator when finding
	parameters.
	* Makefile.in (valops.o): Depend on dictionary_h.
	* valops.c (value_of_this): Check empty block via dict_empty.
	#include "dictionary.h"
	* symfile.c (free_named_symtabs): Check empty block via dict_empty.
	* dictionary.h: Declare dict_empty.
	* symmisc.c (dump_symtab): Don't print out number of
	symbols/buckets.
	* printcmd.c (print_frame_args): Delete assertion that block isn't
	a hashtable.
	* symmisc.c (free_symtab_block): Update to use dictionary
	methods.
	* symtab.h (struct symtab): Comment on free_contents.
	* jv-lang.c (get_java_class_symtab): Set class_symtab->free_code.
	* mdebugread.c (add_symbol): Delete 'nsyms' variable.
	(fixup_sigtramp): Add symbol via dict_add_symbol_block.
	* Makefile.in (mi-cmd-stack.o): Depend on dictionary_h.
	* ada-lang.c (symtab_for_sym): Update uses of ALL_BLOCK_SYMBOLS.
	(ada_add_block_symbols): Ditto.
	(debug_print_block): Ditto.
	(fill_in_ada_prototype): Ditto.
	* breakpoint.c (get_catch_sals): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	(scope_info): Ditto.
	* symtab.c (find_pc_sect_symtab): Ditto.
	(search_symbols): Ditto.
	(make_symbol_completion_list): Ditto.
	(find_addr_symbol): Ditto.
	(make_file_symbol_completion_list): Ditto.
	(make_symbol_overload_list): Ditto.
	* symmisc.c (dump_symtab): Ditto.
	* stack.c (print_block_frame_locals): Ditto.
	(print_block_frame_labels): Ditto.
	(print_frame_arg_vars): Ditto.
	* printcmd.c (print_frame_args): Ditto.
	* objfiles.c (objfile_relocate): Ditto.
	* mdebugread.c (mylookup_symbol): Ditto.
	* Makefile.in (ada-lang.o): Depend on dictionary_h.
	* Makefile.in (tracepoint.o): Ditto.
	* Makefile.in (symmisc.o): Ditto.
	* Makefile.in (stack.o): Ditto.
	* Makefile.in (printcmd.o): Ditto.
	* Makefile.in (objfiles.o): Ditto.
	* Makefile.in (coffread.o): Ditto.
	* Makefile.in (breakpoint.o): Ditto.
	* ada-lang.c: #include "dictionary.h"
	* tracepoint.c: Ditto.
	* symmisc.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* coffread.c: Ditto.
	* breakpoint.c: Ditto.
	* symtab.h: Comment out ALL_BLOCK_SYMBOLS.  (Moved to
	dictionary.h.)
	* dictionary.c: Dict_iterator accessor macros.
	(struct dict_vtbl): Add iterator_first, iterator_next.
	(dict_iterator_first): New function.
	(dict_iterator_next): New function.
	(iterator_first_block): New function.
	(iterator_next_block): New function.
	(iterator_block_hashed_advance): New function.
	* dictionary.h: Add dict_iterator stuff.
	* Makefile.in (symtab.o): Depend on dictionary_h.
	* symtab.c: #include "dictionary.h"
	* dictionary.c: Move down #include "dictionary.h", for now...
	(free_block): Rename from dict_free_block.
	(struct dict_vtbl): Add LOOKUP member.
	(dict_lookup): New function.
	(lookup_block): New function.
	* dictionary.h: Declare dict_lookup.
	* symtab.c (lookup_block_symbol): Use dict_lookup.

2002-09-23  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c (list_args_or_locals): Update use of
	ALL_BLOCK_SYMBOLS.
	#include "dictionary.h"
@
text
@a35 1
#include "dictionary.h"
d3340 2
a3341 1
  if (dict_empty (BLOCK_DICT (b)))
@


1.75.2.2
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a24 1
#include "block.h"
@


1.75.2.3
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d3311 1
a3311 1
/* Return the value of the local variable, if one exists.
d3316 1
a3316 1
value_of_local (const char *name, int complain)
d3321 2
a3322 1
  struct value * ret;
d3336 1
a3336 1
	error ("no `%s' in nameless context", name);
d3345 1
a3345 1
	error ("no args, no `%s'", name);
d3352 1
a3352 1
  sym = lookup_block_symbol (b, name, NULL, VAR_NAMESPACE);
d3356 1
a3356 1
	error ("current stack frame does not contain a variable named `%s'", name);
d3361 4
a3364 17
  ret = read_var_value (sym, selected_frame);
  if (ret == 0 && complain)
    error ("`%s' argument unreadable", name);
  return ret;
}

/* C++/Objective-C: return the value of the class instance variable,
   if one exists.  Flag COMPLAIN signals an error if the request is
   made in an inappropriate context.  */

struct value *
value_of_this (int complain)
{
  if (current_language->la_language == language_objc)
    return value_of_local ("self", complain);
  else
    return value_of_local ("this", complain);
@


1.75.2.4
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d635 53
a688 1
    case lval_register:
a689 1
	struct frame_id old_frame;
d693 4
d698 7
a704 5
	int amount_to_copy;
	char *buffer;
	int value_reg;
	int reg_offset;
	int byte_offset;
a707 5
	/* Since modifying a register can trash the frame chain, we
           save the old frame and then restore the new frame
           afterwards.  */
	get_frame_id (selected_frame, &old_frame);

d709 4
a712 13
	if (VALUE_LVAL (toval) == lval_register)
	  {
	    frame = get_current_frame ();
	    value_reg = VALUE_REGNO (toval);
	  }
	else
	  {
	    for (frame = get_current_frame ();
		 frame && FRAME_FP (frame) != VALUE_FRAME (toval);
		 frame = get_prev_frame (frame))
	      ;
	    value_reg = VALUE_FRAME_REGNUM (toval);
	  }
d717 1
a717 21
	/* Locate the first register that falls in the value that
           needs to be transfered.  Compute the offset of the value in
           that register.  */
	{
	  int offset;
	  for (reg_offset = value_reg, offset = 0;
	       offset + REGISTER_RAW_SIZE (reg_offset) <= VALUE_OFFSET (toval);
	       reg_offset++);
	  byte_offset = VALUE_OFFSET (toval) - offset;
	}

	/* Compute the number of register aligned values that need to
           be copied.  */
	if (VALUE_BITSIZE (toval))
	  amount_to_copy = byte_offset + 1;
	else
	  amount_to_copy = byte_offset + TYPE_LENGTH (type);

	/* And a bounce buffer.  Be slightly over generous.  */
	buffer = (char *) alloca (amount_to_copy
				  + MAX_REGISTER_RAW_SIZE);
d719 3
a721 2
	/* Copy it in.  */
	for (regno = reg_offset, amount_copied = 0;
d723 1
a723 1
	     amount_copied += REGISTER_RAW_SIZE (regno), regno++)
d725 3
a727 1
	    frame_register_read (frame, regno, buffer + amount_copied);
d729 1
a729 1
	
d732 3
a734 5
	  {
	    modify_field (buffer + byte_offset,
			  value_as_long (fromval),
			  VALUE_BITPOS (toval), VALUE_BITSIZE (toval));
	  }
d736 1
a736 3
	  {
	    memcpy (buffer + VALUE_OFFSET (toval), raw_buffer, use_buffer);
	  }
d738 2
a739 10
	  {
	    memcpy (buffer + byte_offset, VALUE_CONTENTS (fromval),
		    TYPE_LENGTH (type));
	    /* Do any conversion necessary when storing this type to
	       more than one register.  */
#ifdef REGISTER_CONVERT_FROM_TYPE
	    REGISTER_CONVERT_FROM_TYPE (value_reg, type,
					(buffer + byte_offset));
#endif
	  }
d741 3
a743 2
	/* Copy it out.  */
	for (regno = reg_offset, amount_copied = 0;
d745 1
a745 1
	     amount_copied += REGISTER_RAW_SIZE (regno), regno++)
d750 1
a750 2
	    int realnum;
	    
d752 3
a754 3
	    frame_register (frame, regno, &optim, &lval, &addr, &realnum,
			    NULL);
	    
d758 1
a758 2
	      write_memory (addr, buffer + amount_copied,
			    REGISTER_RAW_SIZE (regno));
d760 1
a760 2
	      regcache_cooked_write (current_regcache, realnum,
				     (buffer + amount_copied));
a767 21

	/* Assigning to the stack pointer, frame pointer, and other
	   (architecture and calling convention specific) registers
	   may cause the frame cache to be out of date.  We just do
	   this on all assignments to registers for simplicity; I
	   doubt the slowdown matters.  */
	reinit_frame_cache ();

	/* Having destoroyed the frame cache, restore the selected
           frame.  */
	/* FIXME: cagney/2002-11-02: There has to be a better way of
           doing this.  Instead of constantly saving/restoring the
           frame.  Why not create a get_selected_frame() function
           that, having saved the selected frame's ID can
           automatically re-find the previously selected frame
           automatically.  */
	{
	  struct frame_info *fi = frame_find_by_id (old_frame);
	  if (fi != NULL)
	    select_frame (fi);
	}
d770 2
a771 2
      
      
@


1.75.2.5
log
@2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (examine_compound_token): Rewrite as switch
	statement, and add FIXME comment.
	* frame.h: Make arg of block_innermost_frame const.
	* blockframe.c (block_innermost_frame): Make arg const.
	* block.h: Make args to block_function, contained_in const.
	* block.c (block_function): Make arg const.
	(contained_in): Ditto.
	* value.h: Make arg of symbol_read_needs_frame const.
	* findvar.c (symbol_read_needs_frame): Make arg const.
	* symtab.h: Make first arg of symbol_demangled_name const.
	* symtab.c (symbol_demangled_name): Make arg const.
	* value.h: Make first arg of read_var_value const.
	* findvar.c (read_var_value): Make first arg const.
	* Makefile.in (valops.o): Depend on cp_support_h.
	* valops.c: #include "cp-support.h"
	* symtab.h: Add FIXME about name of namespace_enum.
	Add opaque declaration of struct using_direct_node.
	* symtab.c (lookup_symbol_namespace): Make extern; rename args.
	* symtab.h: Declare lookup_symbol_namespace.
	* valops.c (value_struct_elt_for_reference): Make 'name' a const
	char *.
	(value_namespace_elt): New function.
	* expprint.c (print_subexp): Ditto.
	(dump_subexp): Ditto.
	* parse.c (length_of_subexp): Ditto.
	(prefixify_subexp): Ditto.
	* expression.h: Update comment to reflect the block in OP_SCOPE.
	* c-exp.y: Set block in OP_SCOPE expression.
	* jv-exp.y (push_qualified_expression_name): Put a NULL block in
	OP_SCOPE expression.
	* objc-exp.y: Ditto.
	* p-exp.y: Ditto.
	* eval.c (evaluate_subexp_standard): Handle OP_SCOPE via
	value_aggregate_elt.
	* value.h: Add declaration for value_aggregate_elt; delete
	declaration for value_struct_elt_for_reference.
	* valops.c (value_aggregate_elt): New function.
	(value_struct_elt_for_reference): Make static.  Don't check type
	of curtype.
	* c-exp.y: Accept TYPE_CODE_NAMESPACE in qualified_name.
	* cp-support.c (cp_check_namespace_symbol): Set TYPE_NAME (type).

2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change a couple of tests to not use
	single quotes.
@
text
@a41 1
#include "cp-support.h"
a67 10
static struct value *value_struct_elt_for_reference (struct type *domain,
						     int offset,
						     struct type *curtype,
						     const char *name,
						     struct type *intype);

static struct value *value_namespace_elt (const struct type *curtype,
					  const struct block *block,
					  const char *name);

d835 1
a835 1
value_of_variable (const struct symbol *var, const struct block *b)
a3099 23
   return the appropriate member.  BLOCK is the current block; it is
   used if TYPE is a namespace.  This function is used to resolve user
   expressions of the form "DOMAIN::NAME".  For more details on what
   happens, see the comment before value_struct_elt_for_reference.  */

struct value *
value_aggregate_elt (struct type *curtype,
		     const struct block *block,
		     const char *name)
{
  switch (TYPE_CODE (curtype))
    {
    case TYPE_CODE_STRUCT:
    case TYPE_CODE_UNION:
      return value_struct_elt_for_reference (curtype, 0, curtype, name, NULL);
    case TYPE_CODE_NAMESPACE:
      return value_namespace_elt (curtype, block, name);
    default:
      error ("Internal error: non-aggregate type to value_aggregate_elt");
    }
}

/* C++: Given an aggregate type CURTYPE, and a member name NAME,
d3106 1
a3106 1
static struct value *
d3108 1
a3108 1
				struct type *curtype, const char *name,
d3115 4
a3238 20
/* C++: Return the member NAME of the namespace given by the type
   CURTYPE.  Look this up within BLOCK: in particular, apply the using
   directives from within BLOCK.  */

static struct value *
value_namespace_elt (const struct type *curtype,
		     const struct block *block,
		     const char *name)
{
  const char *namespace_name = TYPE_TAG_NAME (curtype);
  struct using_direct_node *usings = block_all_usings (block);
  const struct symbol *sym;

  sym = lookup_symbol_namespace (namespace_name, strlen (namespace_name),
				 name, usings, NULL, VAR_NAMESPACE, NULL);

  cp_free_usings (usings);

  return value_of_variable (sym, block);
}
@


1.75.2.6
log
@2002-11-24  David Carlton  <carlton@@bactrian.org>

	* Makefile.in (c-typeprint.o): Depend on gdb_assert_h.
	* c-typeprint.c: #include "gdb_assert.h"
	* gdbtypes.c (recursive_dump_type): Handle TYPE_CODE_NAMESPACE.
	* c-typeprint.c (c_type_print_varspec_prefix): Ditto.
	(c_type_print_varspec_suffix): Ditto.
	(c_type_print_base): Ditto.
	* typeprint.c (print_type_scalar): Ditto.
	* printcmd.c (print_formatted): Ditto.
	* language.c (structured_type): Ditto.
	* cp-support.c (cp_check_namespace_symbol): Allocate type via
	init_type.
	* gdbtypes.c (init_type): Handle TYPE_CODE_NAMESPACE.
	* valops.c (value_namespace_elt): Handle sym == NULL.

2002-11-24  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/namespace.exp: Eliminate some of the single quotes, and
	duplicate some of the single quote tests without the quotes.
	Change "print E::ce" test.
	Add some ptype <namespace> tests.
	* carlton_runnamespace: Use different files for compiler with and
	without debug info.
@
text
@a3286 6
  /* FIXME: carlton/2002-11-24: Should this really be here, or should
     it be in c-exp.y like the other similar messages?  Hmm...  */
  
  if (sym == NULL)
    error ("No symbol \"%s\" in namespace \"%s\".", name, namespace_name);

@


1.75.2.7
log
@2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (add_partial_enumeration): New function.
	(scan_partial_symbols): Call add_partial_enumeration.
	(locate_pdi_sibling): New function.
	(scan_partial_symbols): Call locate_pdi_sibling.  Get rid of
	nesting_level.
	(pdi_needs_namespace): New function.
	(add_partial_symbol): Add 'namespace' arg; calculate full name
	when appropriate.
	(scan_partial_symbols): Update calls to add_partial_symbol.
	(add_partial_enumeration): Ditto.
	(read_enumeration): Add processing_current_prefix to name when
	appropriate.
	(new_symbol): Set names of enumerators and typedefs appropriately
	if processing_has_namespace_info.
	* symtab.c (lookup_symbol_namespace): Rename 'namespace' argument
	to 'namespace_name'.
	* symtab.h: Ditto.
	* symtab.c (lookup_symbol_namespace): Delete FIXME comments; add a
	new one.
	(lookup_symbol_aux_file): New function.
	(lookup_symbol_aux): Delete FIXME comment.
	(lookup_symbol_aux): Don't search static block explicitly; delete
	FIXME comments.
	* valops.c (value_namespace_elt): Update call to
	lookup_symbol_namespace.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* symtab.c (lookup_symbol_namespace): Delete 'using' argument and
	add 'block' argument; get using directives via iterators.
	(lookup_symbol_aux_using_loop): Delete 'using' argument and add
	'block' argument.
	(lookup_symbol_aux_using): Don't calculate using directives.
	* block.c (block_using_iterator_first): New function.
	(block_using_iterator_next): Ditto.
	* block.h: Add comment.
	(struct block_using_iterator): New struct.
	Declare block_using_iterator_first, block_using_iterator_next.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (read_structure_scope): Set type name and
	processing_current_prefix appropriately.
	(new_symbol): Make sure that, in symbols associated to class
	types, the name includes appropriate namespaces.
	* buildsym.h: Rename processing_current_namespace to
	processing_current_prefix.
	* buildsym.c (finish_block): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	(read_namespace): Ditto.  Also rename previous_namespace to
	previous_prefix.

	Now come a thousand and one const correctness fixes:
	* p-typeprint.c (pascal_print_type): Const.
	(pascal_type_print_method_args): Const.
	* p-lang.h: Const.
	* m2-typeprint.c (m2_print_type): Const.
	* valops.c (hand_function_call): Const.
	* jv-lang.c (java_primitive_type_from_name): Const.
	* jv-lang.h: Const.
	* jv-typeprint.c (java_print_type): Const.
	* language.c: (unk_lang_print_type): Const.
	* stack.c (frame_info): Const.
	* linespec.c (find_methods): Const.
	(find_method_name): Const
	* f-lang.h: Const.
	* f-typeprint.c (f_print_type): Const.
	* c-typeprint.c (c_print_type): Const.
	* c-lang.h: Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (lookup_primitive_typename): Const.
	* stack.c (print_frame): Const.
	(func_command): Delete pointless cast.
	* linespec.c (find_method_name): Const.
	* language.h: Const.
	* symfile.c (compare_psymbols): Const.
	* symtab.c (completion_list_add_name): Const.
	* breakpoint.c (break_at_finish_at_depth_command_1): Remove
	useless cast.
	(break_at_finish_command_1): Ditto.
	* typeprint.c (type_print): Const.
	* symtab.h: Const.
	* symtab.c (gdb_mangle_name): Const.
	(symbol_init_demangled_name): Const.
	(symbol_demangled_name): Const.
	* defs.h: Const.
	* printcmd.c (build_address_symbolic): Const.
	* valops.c (search_struct_method): Const.
	* cp-valprint.c (cp_is_vtbl_ptr_type): Const.
	(cp_print_value): Const.
	(cp_print_class_member): Const.
	* c-typeprint.c (cp_type_print_derivation_info): Const.
	(c_type_print_varspec_prefix): Const.
	(c_type_print_base): Const.
	* p-valprint.c (pascal_object_is_vtbl_ptr_type): Const.
	(pascal_object_print_value): Const.
	(pascal_object_print_class_member): Const.
	* p-typeprint.c (pascal_type_print_derivation_info): Const.
	(pascal_type_print_varspec_prefix): Const.
	(pascal_type_print_base): Const.
	* jv-typeprint.c (java_type_print_base): Const.
	* jv-lang.h (java_demangle_type_signature): Const.
	* jv-lang.c (java_demangle_type_signature): Const.
	(java_demangled_signature_length): Const.
	(java_demangled_signature_copy): Const.
	* jv-typeprint.c (java_type_print_derivation_info): Const.
	* jv-valprint.c (java_value_print): Const.
	(java_print_value_fields): Const.
	* jv-lang.c (is_object_type): Const.
	(evaluate_subexp_java): Const.
	* stabsread.c (read_cpp_abbrev): Const.
	(complain_about_struct_wipeout): Const.
	(cleanup_undefined_types): Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (add_name): Second arg const.
	(lookup_typename): Const.
	(lookup_unsigned_typename): Const.
	(lookup_signed_typename): Const.
	* linespec.c (find_methods): const char *class_name.
	* symtab.c (gdb_mangle_name): const char *newname.
	* valops.c (destructor_name_p): const char *dname.
	(search_struct_field): First arg const.
	* gdbtypes.c (check_typedef): const char *name (multiple places).
	(cfront_mangle_name): const char *newname.
	* gdbtypes.c (add_mangled_type): const char *tname.
	* valops.c (find_overload_match): const char *obj_type_name.
	* utils.c (gdb_print_host_address): Make first arg const.
	* defs.h: Declare first arg of gdb_print_host_address to be
	const.
	* valarith.c (find_size_for_pointer_math): const char *name.

2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/m-data.cc (main): Add marker comment.
	* gdb.c++/m-data.exp: Use marker comment instead of line numbers.
	* gdb.c++/m-data.cc: Delete superfluous namespace.
	* gdb.c++/m-static.cc: Ditto.
	* gdb.c++/m-static1.cc: Ditto.
	* carlton_runtest: Compare based on gdb.sum, not based on output.
	* carlton_runnamespace: Ditto.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Put tests for CClass.
	* gdb.c++/namespace.cc (C): Add CClass.
@
text
@d60 1
a60 1
static struct value *search_struct_field (const char *, struct value *, int,
d1753 1
a1753 1
    const char *name;
a1774 1
	char *temp_name;
d1776 1
a1776 1
	temp_name = alloca (80);
d1778 1
a1778 2
	sprintf (temp_name, format, (unsigned long) funaddr);
	name = temp_name;
d2135 1
a2135 1
search_struct_field (const char *name, struct value *arg1, int offset,
d2385 1
a2385 1
      const char *t_field_name = TYPE_FN_FIELDLIST_NAME (type, i);
d2649 1
a2649 1
      const char *fn_field_name = TYPE_FN_FIELDLIST_NAME (type, i);
d2806 1
a2806 1
  const char *obj_type_name = NULL;
d3019 1
a3019 1
      const char *dname = type_name_no_tag (type);
d3188 1
a3188 1
      const char *t_field_name = TYPE_FN_FIELDLIST_NAME (t, i);
d3279 1
d3283 3
a3285 1
				 name, NULL, block, VAR_NAMESPACE, NULL);
@


1.75.2.8
log
@2002-12-20  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_minsyms): Don't call
	lookup_symbol_aux from within this.
	* values.c (value_static_field): lookup_symbol_linkage.
	(value_fn_field): lookup_symbol_linkage.
	* valops.c (value_struct_elt_for_reference): lookup_symbol_linkage.
	* blockframe.c (inside_main_func): lookup_symbol_linkage.
	* source.c (select_source_symtab): lookup_symbol_linkage.
	* nlmread.c (nlm_symfile_read): Call lookup_symbol_linkage.
	* nindy-tdep.c (nindy_frame_chain_valid): Call
	lookup_symbol_linkage.
	* linespec.c (count_methods): Call lookup_symbol_linkage.
	(add_matching_methods): Ditto.
	(add_constructors): Ditto.
	* hppa-tdep.c (find_stub_with_shl_get): Call
	lookup_symbol_linkage.  Delete symbol2.
	(initialize_hp_cxx_exception_support): Call lookup_symbol_linkage.
	* cli/cli-cmds.c (edit_command): SYMBOL_PRINT_NAME.
	(list_command): SYMBOL_PRINT_NAME.
	* valops.c (value_of_variable): SYMBOL_PRINT_NAME
	(hand_function_call): SYMBOL_PRINT_NAME.
	* typeprint.c (typedef_print): SYMBOL_PRINT_NAME.
	* tracepoint.c (tracepoints_info): SYMBOL_PRINT_NAME.
	* symtab.c (lookup_partial_symbol): SYMBOL_BEST_NAME.
	(compare_search_syms): SYMBOL_BEST_NAME.
	(print_symbol_info): SYMBOL_PRINT_NAME.
	(print_msymbol_info): SYMBOL_PRINT_NAME.
	(rbreak_command): SYMBOL_PRINT_NAME.
	* symmisc.c (print_symbol): SYMBOL_PRINT_NAME.
	* stack.c (print_frame): SYMBOL_PRINT_NAME.
	(frame_info): SYMBOL_PRINT_NAME.
	(print_block_frame_locals): SYMBOL_PRINT_NAME.
	(print_block_frame_labels): SYMBOL_PRINT_NAME.
	(print_frame_arg_vars): SYMBOL_PRINT_NAME.
	(return_command): SYMBOL_PRINT_NAME.
	* stabsread.c (define_symbol): SYMBOL_PRINT_NAME.
	* p-valprint.c (pascal_val_print): SYMBOL_PRINT_NAME.
	* printcmd.c (build_address_symbolic): SYMBOL_PRINT_NAME.
	(sym_info): SYMBOL_PRINT_NAME.
	(print_frame_args): SYMBOL_PRINT_NAME.
	* objc-lang.c (compare_selectors): SYMBOL_BEST_NAME.
	(compare_classes): SYMBOL_BEST_NAME.
	* maint.c (maintenance_translate_address): SYMBOL_PRINT_NAME.
	* linespec.c (find_method): SYMBOL_PRINT_NAME.
	(select_symbols): SYMBOL_PRINT_NAME.
	* infcmd.c (jump_command): SYMBOL_PRINT_NAME.
	* findvar.c (locate_var_value): SYMBOL_PRINT_NAME.
	* expprint.c (print_subexp): SYMBOL_PRINT_NAME.
	* c-valprint.c (c_val_print): SYMBOL_PRINT_NAME.
	* buildsym.c (finish_block): SYMBOL_PRINT_NAME.
	* breakpoint.c (print_one_breakpoint): SYMBOL_PRINT_NAME.
	* ax-gdb.c (gen_var_ref): SYMBOL_PRINT_NAME.
	* ada-typeprint.c (ada_typedef_print): SYMBOL_PRINT_NAME.
	* ada-lang.c (user_select_syms): Use SYMBOL_PRINT_NAME instead of
	SYMBOL_SOURCE_NAME.
	(user_select_syms):
	(ada_finish_decode_line_1): Use SYMBOL_BEST_NAME instead of
	SYMBOL_SOURCE_NAME.
	* symtab.h (SYMBOL_PRINT_NAME): Rename from SYMBOL_SOURCE_NAME.
	* symfile.c (compare_symbols): Use SYMBOL_BEST_NAME, not
	SYMBOL_SOURCE_NAME.
	(compare_psymbols): Ditto.
	* symtab.c (lookup_symbol_linkage): New function.
	* symtab.h: Declare lookup_symbol_linkage.
	* c-valprint.c (c_val_print): Call lookup_symbol_minsym.
	* symtab.c (lookup_symbol_aux_minsyms): Call minsym_static.
	* minsyms.c (minsym_static): New function.
	* symtab.h: Declare minsym_static.
	* symtab.c (lookup_symbol_minsym): New function.
	(search_symbols): Call lookup_symbol_minsym instead of
	lookup_symbol.
	(lookup_symbol_namespace): Don't take apart NAME.
	* symtab.h: Declare lookup_symbol_minsym.
	* printcmd.c (build_address_symbolic): Don't use old version of
	SYMBOL_LINKAGE_NAME.
	* symtab.c (lookup_block_symbol): Change mangled names to linkage
	name, and use SYMBOL_LINKAGE_NAME as appropriate.
	* symtab.h (SYMBOL_LINKAGE_NAME): New macro, with a different
	meaning from the old macro of the same name.  Also, add comments
	about proper uses of names.
@
text
@d859 1
a859 1
	      && SYMBOL_PRINT_NAME (BLOCK_FUNCTION (b)))
d861 1
a861 1
		   SYMBOL_PRINT_NAME (BLOCK_FUNCTION (b)));
d869 1
a869 1
    error ("Address of symbol \"%s\" is unknown.", SYMBOL_PRINT_NAME (var));
d1760 1
a1760 1
	name = SYMBOL_PRINT_NAME (symbol);
d1769 1
a1769 1
	    name = SYMBOL_PRINT_NAME (msymbol);
d3232 2
a3233 2
	      struct symbol *s
		= lookup_symbol_linkage (TYPE_FN_FIELD_PHYSNAME (f, j));
@


1.75.2.9
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d665 1
a665 1
	old_frame = get_frame_id (deprecated_selected_frame);
d676 1
a676 1
		 frame && get_frame_base (frame) != VALUE_FRAME (toval);
d1478 1
a1478 1
      if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES)
d1496 1
a1496 1
      if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES)
d1509 1
a1509 1
      if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES)
d1516 1
a1516 1
      if (DEPRECATED_USE_GENERIC_DUMMY_FRAMES)
d3387 1
a3387 1
  if (deprecated_selected_frame == 0)
d3395 1
a3395 1
  func = get_frame_function (deprecated_selected_frame);
d3424 1
a3424 1
  ret = read_var_value (sym, deprecated_selected_frame);
d3451 1
a3451 1
  LONGEST lowerbound, upperbound;
d3502 1
a3502 1
      LONGEST offset
@


1.75.2.10
log
@2003-01-24  David Carlton  <carlton@@math.stanford.edu>

	* valops.c (find_oload_champ): New function.
	(find_overload_match): Separate code into find_oload_champ and
	oload_method_static.
	(find_oload_champ): Call oload_method_static.
	(oload_method_static): New function.
	(find_overload_match): Call classify_oload_match.
	(classify_oload_match): New function.
	* value.h: Update declaration of find_overload_match.
	* eval.c (evaluate_subexp_standard): Pass current block to
	find_overload_match.
	* valops.c (find_overload_match): Add CURRENT_BLOCK arg.

2003-01-24  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/overload.exp: Add tests involving overloadNamespace.
	Delete comment about GDB crashing.
	* gdb.c++/overload.cc: Add dummyClass, dummyInstance,
	overloadNamespace, and XXX.
@
text
@a66 17
enum oload_classification { STANDARD, NON_STANDARD, INCOMPATIBLE };

static int find_oload_champ (struct type **arg_types, int nargs, int method,
			     int num_fns,
			     struct fn_field *fns_ptr,
			     struct symbol **oload_syms,
			     struct badness_vector **oload_champ_bv);

static int oload_method_static (int method, struct fn_field *fns_ptr,
				int index);

static enum
oload_classification classify_oload_match (struct badness_vector
					   * oload_champ_bv,
					   int nargs,
					   int static_offset);

d2751 1
a2751 1
   arguments NARGS, the NAME of a function, whether it's a method or
a2756 3
   CURRENT_BLOCK is the context in which the evaluation is occurring;
   this is used to get namespace info.

a2779 1
		     const struct block *current_block,
d2782 3
d2787 1
a2787 2
  int oload_champ;		/* Index of best overloaded function */
#if 0
d2790 3
a2792 1
#endif
d2794 1
d2803 1
a2809 1
  enum oload_classification match_quality;
d2855 29
a2883 2
  oload_champ = find_oload_champ(arg_types, nargs, method, num_fns, fns_ptr,
				 oload_syms, &oload_champ_bv);
d2885 41
d2945 7
d2953 4
a2956 6
  match_quality
    = classify_oload_match (oload_champ_bv, nargs,
			    oload_method_static (method, fns_ptr,
						 oload_champ));

  if (match_quality == INCOMPATIBLE)
d2967 1
a2967 1
  else if (match_quality == NON_STANDARD)
d2981 4
a2984 2
      if (staticp != NULL)
	*staticp = oload_method_static (method, fns_ptr, oload_champ);
d3008 1
a3008 132
  switch (match_quality)
    {
    case INCOMPATIBLE:
      return 100;
    case NON_STANDARD:
      return 10;
    default:				/* STANDARD */
      return 0;
    }
}

/* Look for a function to take NARGS args of types ARG_TYPES.  Find
   the best match from among the overloaded methods or functions
   (depending on METHOD) given by FNS_PTR or OLOAD_SYMS, respectively.
   The number of methods/functions in the list is given by NUM_FNS.
   Return the index of the best match; store an indication of the
   quality of the match in OLOAD_CHAMP_BV.  */

static int
find_oload_champ (struct type **arg_types, int nargs, int method,
		  int num_fns, struct fn_field *fns_ptr,
		  struct symbol **oload_syms,
		  struct badness_vector **oload_champ_bv)
{
  int ix;
  struct badness_vector *bv;	/* A measure of how good an overloaded instance is */
  int oload_champ = -1;		/* Index of best overloaded function */
  int oload_ambiguous = 0;	/* Current ambiguity state for overload resolution */
  /* 0 => no ambiguity, 1 => two good funcs, 2 => incomparable funcs */

  *oload_champ_bv = NULL;

  /* Consider each candidate in turn */
  for (ix = 0; ix < num_fns; ix++)
    {
      int jj;
      int static_offset = oload_method_static (method, fns_ptr, ix);
      int nparms;
      struct type **parm_types;

      if (method)
	{
	  nparms = TYPE_NFIELDS (TYPE_FN_FIELD_TYPE (fns_ptr, ix));
	}
      else
	{
	  /* If it's not a method, this is the proper place */
	  nparms=TYPE_NFIELDS(SYMBOL_TYPE(oload_syms[ix]));
	}

      /* Prepare array of parameter types */
      parm_types = (struct type **) xmalloc (nparms * (sizeof (struct type *)));
      for (jj = 0; jj < nparms; jj++)
	parm_types[jj] = (method
			  ? (TYPE_FN_FIELD_ARGS (fns_ptr, ix)[jj].type)
			  : TYPE_FIELD_TYPE (SYMBOL_TYPE (oload_syms[ix]), jj));

      /* Compare parameter types to supplied argument types.  Skip THIS for
         static methods.  */
      bv = rank_function (parm_types, nparms, arg_types + static_offset,
			  nargs - static_offset);

      if (!*oload_champ_bv)
	{
	  *oload_champ_bv = bv;
	  oload_champ = 0;
	}
      else
	/* See whether current candidate is better or worse than previous best */
	switch (compare_badness (bv, *oload_champ_bv))
	  {
	  case 0:
	    oload_ambiguous = 1;	/* top two contenders are equally good */
	    break;
	  case 1:
	    oload_ambiguous = 2;	/* incomparable top contenders */
	    break;
	  case 2:
	    *oload_champ_bv = bv;	/* new champion, record details */
	    oload_ambiguous = 0;
	    oload_champ = ix;
	    break;
	  case 3:
	  default:
	    break;
	  }
      xfree (parm_types);
      if (overload_debug)
	{
	  if (method)
	    fprintf_filtered (gdb_stderr,"Overloaded method instance %s, # of parms %d\n", fns_ptr[ix].physname, nparms);
	  else
	    fprintf_filtered (gdb_stderr,"Overloaded function instance %s # of parms %d\n", SYMBOL_DEMANGLED_NAME (oload_syms[ix]), nparms);
	  for (jj = 0; jj < nargs - static_offset; jj++)
	    fprintf_filtered (gdb_stderr,"...Badness @@ %d : %d\n", jj, bv->rank[jj]);
	  fprintf_filtered (gdb_stderr,"Overload resolution champion is %d, ambiguous? %d\n", oload_champ, oload_ambiguous);
	}
    }

  return oload_champ;
}

/* Return 1 if we're looking at a static method, 0 if we're looking at
   a non-static method or a function that isn't a method.  */

static int
oload_method_static (int method, struct fn_field *fns_ptr, int index)
{
  if (method && TYPE_FN_FIELD_STATIC_P (fns_ptr, index))
    return 1;
  else
    return 0;
}

/* Check how good an overload match OLOAD_CHAMP_BV represents.  */

static enum oload_classification
classify_oload_match (struct badness_vector *oload_champ_bv,
		      int nargs,
		      int static_offset)
{
  int ix;

  for (ix = 1; ix <= nargs - static_offset; ix++)
    {
      if (oload_champ_bv->rank[ix] >= 100)
	return INCOMPATIBLE;	/* truly mismatched types */
      else if (oload_champ_bv->rank[ix] >= 10)
	return NON_STANDARD;	/* non-standard type conversions needed */
    }

  return STANDARD;		/* Only standard conversions needed.  */
@


1.75.2.11
log
@2003-01-28  David Carlton  <carlton@@math.stanford.edu>

	* valops.c (find_overload_match): Calculate func_name via
	SYMBOL_CPLUS_DEMANGLED_NAME + remove_params.
	* symtab.c (remove_params): Make extern.
	* symtab.h: Add declaration for remove_params.
	* symtab.c (overload_list_add_symbol): Change second arg to const
	char *.
	* valops.c (find_overload_match) Update call to
	make_symbol_overload_list.
	* symtab.h: Update declaration for make_symbol_overload_list.
	* symtab.c (make_symbol_overload_list): Change arguments.
	* valops.c (find_overload_match): Rename cleanups to old_cleanups;
	handle freeing func_name via cleanups.
@
text
@d2821 1
a2821 1
  struct cleanup *old_cleanups = NULL;
d2853 1
a2853 1
      func_name	= remove_params (SYMBOL_CPLUS_DEMANGLED_NAME (fsym));
d2857 1
a2857 1
      if (func_name == NULL)
d2863 2
a2864 3
      old_cleanups = make_cleanup (xfree, func_name);
      oload_syms = make_symbol_overload_list (func_name, "", 0, current_block);
      make_cleanup (xfree, oload_syms);
d2871 2
a2872 2
  oload_champ = find_oload_champ (arg_types, nargs, method, num_fns, fns_ptr,
				  oload_syms, &oload_champ_bv);
d2934 1
d2946 2
a2947 2
  if (old_cleanups != NULL)
    do_cleanups (old_cleanups);
@


1.75.2.12
log
@2003-01-31  David Carlton  <carlton@@math.stanford.edu>

	From Jim Blandy  <jimb@@redhat.com>:

	Use a single, consistent representation for an empty minimal
	symbol table in an objfile.
	* objfiles.c (terminate_minimal_symbol_table): New function.
	(allocate_objfile): Call it.
	* objfiles.h (terminate_minimal_symbol_table): New declaration.
	(ALL_MSYMBOLS): No need to test whether (objfile)->msymbols is
	non-NULL.
	* minsyms.c (lookup_minimal_symbol_by_pc_section): To see whether
	objfile has minimal symbols, compare minimal_symbol_count to zero,
	instead of comparing msymbols with NULL.
	* objfiles.c (have_minimal_symbols): Same.
	* solib-sunos.c (solib_add_common_symbols): Call
	terminate_minimal_symbol_table.
	* symfile.c (reread_symbols): Same.

	* objfiles.h: Revert patch from 2003-01-27, to be replaced by
	similar patch from Jim Blandy.
	* objfiles.c (objfile_relocate): Ditto.
	* i386-linux-tdep.c (find_minsym_and_objfile): Ditto.
	* arm-linux-tdep.c (find_minsym_and_objfile): Ditto.
	* gdbtypes.h: Delete INTEGER_COERCION_BADNESS,
	FLOAT_COERCION_BADNESS.
	* gdbtypes.c (rank_one_type): Replace all uses of
	INTEGER_COERCION_BADNESS by INTEGER_CONVERSION_BADNESS.
	* valops.c (find_overload_match): Call cp_func_name.
	* cp-support.h: Declare cp_func_name.
	* cp-support.c (cp_func_name): New function.

2003-01-30  David Carlton  <carlton@@math.stanford.edu>

	* valops.c (find_overload_match): Move code into
	find_oload_champ_namespace.
	(find_oload_champ_namespace): New function, which immediately gets
	eviscerated and turned into a call to
	find_oload_champ_namespace_loop.
	(find_oload_champ_namespace_loop): New function.
	* symtab.c (make_symbol_overload_list): Move entire body into
	make_symbol_overload_list_qualified.
	(make_symbol_overload_list_qualified): New.
	(read_in_psymtabs): New.
	(make_symbol_overload_list_qualified): Rewrite.
	(make_symbol_overload_list_using): New.
	(lookup_symbol_namespace): Use alloca, not xmalloc.
	(make_symbol_overload_list): Put some memory management stuff back
	in.
@
text
@d67 1
a67 16
static int find_oload_champ_namespace (struct type **arg_types, int nargs,
				       const struct block *current_block,
				       const char *func_name,
				       const char *qualified_name,
				       struct symbol ***oload_syms,
				       struct badness_vector **oload_champ_bv);

static
int find_oload_champ_namespace_loop (struct type **arg_types, int nargs,
				     const struct block *current_block,
				     const char *func_name,
				     const char *qualified_name,
				     int namespace_len,
				     struct symbol ***oload_syms,
				     struct badness_vector **oload_champ_bv,
				     int *oload_champ);
a77 2
enum oload_classification { STANDARD, NON_STANDARD, INCOMPATIBLE };

a2848 2
      oload_champ = find_oload_champ (arg_types, nargs, method, num_fns,
				      fns_ptr, oload_syms, &oload_champ_bv);
d2852 2
a2853 2
      const char *qualified_name = SYMBOL_CPLUS_DEMANGLED_NAME (fsym);
      func_name	= cp_func_name (qualified_name);
d2864 7
d2872 2
a2873 7
      oload_champ = find_oload_champ_namespace (arg_types, nargs,
						current_block,
						func_name,
						qualified_name,
						&oload_syms,
						&oload_champ_bv);
    }
a2955 137
      return 0;
    }
}

/* This finds the best overload, searching for FUNC_NAME in namespaces
   contained in QUALIFIED_NAME until it either finds a good match or
   runs out of namespaces.  It stores the overloaded functions in
   *OLOAD_SYMS, and the badness vector in *OLOAD_CHAMP_BV.  The
   calling function is responsible for freeing *OLOAD_SYMS.  */

static int
find_oload_champ_namespace (struct type **arg_types, int nargs,
			    const struct block *current_block,
			    const char *func_name,
			    const char *qualified_name,
			    struct symbol ***oload_syms,
			    struct badness_vector **oload_champ_bv)
{
  int oload_champ;

  find_oload_champ_namespace_loop (arg_types, nargs,
				   current_block, func_name,
				   qualified_name, 0,
				   oload_syms, oload_champ_bv,
				   &oload_champ);

  return oload_champ;
}

/* Helper function for find_oload_champ_namespace; NAMESPACE_LEN is
   how deep we've looked for namespaces, and the champ is stored in
   OLOAD_CHAMP.  The return value is 1 if the champ is a good one, 0
   if it isn't.  */

/* FIXME: carlton/2003-01-30: This isn't the cleanest function I've
   ever written, to put it mildly.  All this overloading stuff could
   use some refactoring.  */

static int
find_oload_champ_namespace_loop (struct type **arg_types, int nargs,
				 const struct block *current_block,
				 const char *func_name,
				 const char *qualified_name,
				 int namespace_len,
				 struct symbol ***oload_syms,
				 struct badness_vector **oload_champ_bv,
				 int *oload_champ)
{
  int modified_namespace_len = namespace_len;
  int next_namespace_len;
  int searched_deeper = 0;
  int num_fns = 0;
  struct cleanup *old_cleanups;
  int new_oload_champ;
  struct symbol **new_oload_syms;
  struct badness_vector *new_oload_champ_bv;

  if (modified_namespace_len != 0)
    {
      gdb_assert (qualified_name[modified_namespace_len] == ':');
      modified_namespace_len +=  2;
    }
  next_namespace_len
    = (cp_find_first_component (qualified_name + modified_namespace_len)
       - qualified_name);

  /* First, see if we have a deeper namespace we can search in.  If we
     get a good match there, use it.  */

  if (qualified_name[next_namespace_len] == ':')
    {
      searched_deeper = 1;

      if (find_oload_champ_namespace_loop (arg_types, nargs, current_block,
					   func_name, qualified_name,
					   next_namespace_len,
					   oload_syms, oload_champ_bv,
					   oload_champ))
	{
	  return 1;
	}
    };

  /* If we reach here, either we're in the deepest namespace or we
     didn't find a good match in a deeper namespace.  But, in the
     latter case, we still have a bad match in a deeper namespace;
     note that we might not find any match at all in the current
     namespace.  (There's always a match in the deepest namespace,
     because this overload mechanism only gets called if there's a
     function symbol to start off with.)  */

  old_cleanups = make_cleanup (xfree, *oload_syms);
  new_oload_syms = make_symbol_overload_list (func_name,
					      qualified_name,
					      namespace_len,
					      current_block);
  old_cleanups = make_cleanup (xfree, new_oload_syms);
  while (new_oload_syms[num_fns])
    ++num_fns;
  if (!num_fns)
    error ("Couldn't find function %s", func_name);

  new_oload_champ = find_oload_champ (arg_types, nargs, 0, num_fns,
				       NULL, new_oload_syms,
				      &new_oload_champ_bv);

  /* Case 1: We found a good match.  Free earlier matches (if any),
     and return it.  Case 2: We didn't find a good match, but we're
     not the deepest function.  Then go with the bad match that the
     deeper function found.  Case 3: We found a bad match, and we're
     the deepest function.  Then return what we found, even though
     it's a bad match.  */

  if (new_oload_champ != -1
      && classify_oload_match (new_oload_champ_bv, nargs, 0) == STANDARD)
    {
      if (searched_deeper)
	xfree (*oload_syms);
      *oload_syms = new_oload_syms;
      *oload_champ = new_oload_champ;
      *oload_champ_bv = new_oload_champ_bv;
      discard_cleanups (old_cleanups);
      return 1;
    }
  else if (searched_deeper)
    {
      xfree (new_oload_syms);
      discard_cleanups (old_cleanups);
      return 0;
    }
  else
    {
      gdb_assert (new_oload_champ != -1);
      *oload_syms = new_oload_syms;
      *oload_champ = new_oload_champ;
      *oload_champ_bv = new_oload_champ_bv;
      discard_cleanups (old_cleanups);
@


1.75.2.13
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d139 1
a140 23
/* How you should pass arguments to a function depends on whether it
   was defined in K&R style or prototype style.  If you define a
   function using the K&R syntax that takes a `float' argument, then
   callers must pass that argument as a `double'.  If you define the
   function using the prototype syntax, then you must pass the
   argument as a `float', with no promotion.

   Unfortunately, on certain older platforms, the debug info doesn't
   indicate reliably how each function was defined.  A function type's
   TYPE_FLAG_PROTOTYPED flag may be clear, even if the function was
   defined in prototype style.  When calling a function whose
   TYPE_FLAG_PROTOTYPED flag is clear, GDB consults this flag to decide
   what to do.

   For modern targets, it is proper to assume that, if the prototype
   flag is clear, that can be trusted: `float' arguments should be
   promoted to `double'.  For some older targets, if the prototype
   flag is clear, that doesn't tell us anything.  The default is to
   trust the debug information; the user can override this behavior
   with "set coerce-float-to-double 0".  */

static int coerce_float_to_double;

d426 43
a585 1
  struct frame_id old_frame;
a614 5
  /* Since modifying a register can trash the frame chain, and modifying memory
     can trash the frame cache, we save the old frame and then restore the new
     frame afterwards.  */
  old_frame = get_frame_id (deprecated_selected_frame);

d683 1
d696 5
d802 20
a829 32
  /* Assigning to the stack pointer, frame pointer, and other
     (architecture and calling convention specific) registers may
     cause the frame cache to be out of date.  Assigning to memory
     also can.  We just do this on all assignments to registers or
     memory, for simplicity's sake; I doubt the slowdown matters.  */
  switch (VALUE_LVAL (toval))
    {
    case lval_memory:
    case lval_register:
    case lval_reg_frame_relative:

      reinit_frame_cache ();

      /* Having destoroyed the frame cache, restore the selected frame.  */

      /* FIXME: cagney/2002-11-02: There has to be a better way of
	 doing this.  Instead of constantly saving/restoring the
	 frame.  Why not create a get_selected_frame() function that,
	 having saved the selected frame's ID can automatically
	 re-find the previously selected frame automatically.  */

      {
	struct frame_info *fi = frame_find_by_id (old_frame);
	if (fi != NULL)
	  select_frame (fi);
      }

      break;
    default:
      break;
    }
  
d1147 43
d1232 5
a1236 1
      if (!is_prototyped && coerce_float_to_double)
d1516 31
d1831 2
a1832 3
            /* We must get back to the frame we were before the dummy
               call. */
	    frame_pop (get_current_frame ());
d2215 6
a2220 7
		   In the GNU Chill (now deleted from GDB)
		   implementation of variant record types, each
		   <alternative field> has an (anonymous) union type,
		   each member of the union represents a <variant
		   alternative>.  Each <variant alternative> is
		   represented as a struct, with a member for each
		   <variant field>.  */
d2227 4
a2230 4
		   enclosing struct.  In the GNU Chill (now deleted
		   from GDB) implementation of variant records, the
		   bitpos is zero in an anonymous union field, so we
		   have to add the offset of the union here. */
d3691 3
d3749 13
a3838 15

  add_show_from_set
    (add_set_cmd ("coerce-float-to-double", class_obscure, var_boolean,
		  (char *) &coerce_float_to_double,
		  "Set coercion of floats to doubles when calling functions\n"
 "Variables of type float should generally be converted to doubles before\n"
 "calling an unprototyped function, and left alone when calling a prototyped\n"
 "function.  However, some older debug info formats do not provide enough\n"
 "information to determine that a function is prototyped.  If this flag is\n"
 "set, GDB will perform the conversion for a function it considers\n"
 "unprototyped.\n"
 "The default is to perform the conversion.\n",
		  &setlist),
     &showlist);
  coerce_float_to_double = 1;
@


1.75.2.14
log
@2003-02-11  David Carlton  <carlton@@math.stanford.edu>

	* valops.c (find_oload_champ): Add comment.
	(find_oload_champ_namespace_loop): Fix memory management.
	(find_oload_champ_namespace): Add comment.
	(find_overload_match): Free oload_syms, oload_champ_bv.
	* gdbtypes.c (rank_function): Add comment.
	* valops.c (find_oload_champ_namespace_loop): Allow num_fns to be
	zero.
	* symtab.c (lookup_partial_symbol): Use strcmp_iw_ordered.
	(lookup_block_symbol): Delete comment.
	* symfile.c (compare_psymbols): Use strcmp_iw_ordered.
	* defs.h: Declare strcmp_iw_ordered.
	* utils.c (strcmp_iw_ordered): New function.
@
text
@a2797 2
      make_cleanup (xfree, oload_syms);
      make_cleanup (xfree, oload_champ_bv);
d2896 1
a2896 2
   calling function is responsible for freeing *OLOAD_SYMS and
   *OLOAD_CHAMP_BV.  */
d2920 1
a2920 4
   if it isn't.

   It is the caller's responsibility to free *OLOAD_SYMS and
   *OLOAD_CHAMP_BV.  */
a2953 4
  /* Initialize these to values that can safely be xfree'd.  */
  *oload_syms = NULL;
  *oload_champ_bv = NULL;

a2979 1
  old_cleanups = make_cleanup (xfree, *oload_champ_bv);
d2984 1
d2987 2
d2991 1
a2991 1
				      NULL, new_oload_syms,
d3004 2
d3009 1
a3009 1
      do_cleanups (old_cleanups);
a3014 1
      xfree (new_oload_champ_bv);
d3034 1
a3034 3
   quality of the match in OLOAD_CHAMP_BV.

   It is the caller's responsibility to free *OLOAD_CHAMP_BV.  */
@


1.75.2.15
log
@2003-02-12  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (examine_compound_token): Call decode_namespace.
	(decode_namespace): New function.
	* cp-support.c (cp_find_first_component): Return the offset, not a
	pointer.
	(check_possible_namespace_symbols_loop): Update call to
	cp_find_first_component.
	(cp_check_possible_namespace_symbols): Ditto.
	(cp_func_name): Ditto.
	* buildsym.c (scan_for_anonymous_namespaces): Ditto.
	(finish_block): Ditto.
	* linespec.c (examine_compound_token): Ditto.
	* symtab.c (lookup_symbol_aux_using_loop): Ditto.
	* valops.c (find_oload_champ_namespace_loop): Ditto.
	* cp-support.h: Declare cp_find_first_component to return an int.
	* Makefile.in (linespec.o): cp_support_h.
	* linespec.c (symtab_from_filename): Rename from handle_filename.
	(decode_line_1): Call symtab_from_filename instead of
	handle_filename.
	(locate_compound_sym): Rename from locate_class_sym.  Search in
	such a way that we find namespace symbols, too.
	(examine_compound_token): Call locate_class_sym instead of
	locate_compound_sym.
	(locate_compound_sym): Add NAMESPACE arg.
	(examine_compound_token): New arg to locate_compound_sym.
	Handle TYPE_CODE_NAMESPACE.
	#include "cp-support.hp"
@
text
@d2942 2
a2943 1
  int next_namespace_len = namespace_len;
d2951 1
a2951 1
  if (next_namespace_len != 0)
d2953 2
a2954 2
      gdb_assert (qualified_name[next_namespace_len] == ':');
      next_namespace_len +=  2;
d2957 2
a2958 1
    += cp_find_first_component (qualified_name + next_namespace_len);
@


1.75.2.16
log
@2003-02-21  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (locate_compound_sym): Update call to
	lookup_symbol_namespace.
	* symtab.c (make_symbol_overload_list): Delete namespace_len
	argument.
	* symtab.h: Update declaration for make_symbol_overload_list.
	* valops.c (find_oload_champ_namespace_loop): New format for
	make_symbol_overload_list.
	* symtab.c (lookup_symbol_namespace): Delete namespace_len
	argument.
	(lookup_symbol_aux_using_loop): Update call to
	lookup_symbol_namespace.
	(make_symbol_overload_list_using): Delete namespace_len argument.
	* linespec.c (decode_namespace): Update call to
	lookup_symbol_namespace.
	* valops.c (value_namespace_elt): Ditto.
	* symtab.c (lookup_nested_type): Ditto.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* block.c (block_all_usings): Delete.
	(block_using): Make static.
	(block_using_iterator_next): New using_direct format.
	(block_using_iterator_first): Ditto.
	* buildsym.c (scan_for_anonymous_namespaces): Rename variables.
	(add_using_directive): New using functions.
	(end_symtab): Use cp_copy_usings.
	(copy_usings_to_obstack): Delete.
	* block.c: Tweak initial comment.
	(struct namespace_info): Move here.
	(block_initialize_namespace): Set scope to NULL!
	* block.h: Add compilation guards.
	Reorder and update declarations.
	* cp-support.c (cp_find_first_component): Return unsigned int.
	(cp_entire_prefix_len): New.
	(cp_add_using_obstack): Delete.
	(cp_add_using_xmalloc): Delete.
	(cp_copy_usings): Rewrite.
	(cp_free_usings): Delete.
	(cp_add_using): New.
	(cp_is_anonymous): Delete second argument.
	(xstrndup): New.
	* cp-support.h: Add compilation guards.
	Update declarations.
	* coffread.c: New variable coff_source_file.
	(coff_start_symtab): Use coff_source_file.
	(complete_symtab): Ditto.
	(coff_end_symtab): Ditto.
	(coff_symtab_read): Ditto.
	* dbxread.c (find_stab_function_addr): Const fix.
	* buildsym.h: Const fix.
	* buildsym.c (start_symtab): Const fix.
	(start_subfile): Ditto.
	* cp-support.c (cp_add_using_xmalloc): Copy name.
	* dwarf2read.c (read_namespace): Loop through extensions
	correctly.
	(read_file_scope): Const fix.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(read_typedef): Ditto.
	* buildsym.c (finish_block): Update comments and simplify code
	when setting scope.
	* buildsym.h: Add opaque declaration of 'struct block'.
	Change comment before processing_current_prefix.
	* arm-tdep.c (arm_gdbarch_init): Add break; after default:.
@
text
@a2948 1
  char *new_namespace;
a2988 3
  new_namespace = alloca (namespace_len + 1);
  strncpy (new_namespace, qualified_name, namespace_len);
  new_namespace[namespace_len] = '\0';
d2990 2
a2991 1
					      new_namespace,
d3431 2
a3432 2
  sym = lookup_symbol_namespace (namespace_name, name, NULL,
				 block, VAR_NAMESPACE, NULL);
@


1.75.2.17
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d25 1
a36 1
#include "block.h"
d1349 4
a1352 28
  if (DEPRECATED_PUSH_DUMMY_FRAME_P ())
    {
      /* DEPRECATED_PUSH_DUMMY_FRAME is responsible for saving the
	 inferior registers (and POP_FRAME for restoring them).  (At
	 least on most machines) they are saved on the stack in the
	 inferior.  */
      DEPRECATED_PUSH_DUMMY_FRAME;
    }
  else
    {
      /* FIXME: cagney/2003-02-26: Step zero of this little tinker is
      to extract the generic dummy frame code from the architecture
      vector.  Hence this direct call.

      A follow-on change is to modify this interface so that it takes
      thread OR frame OR tpid as a parameter, and returns a dummy
      frame handle.  The handle can then be used further down as a
      parameter SAVE_DUMMY_FRAME_TOS.  Hmm, thinking about it, since
      everything is ment to be using generic dummy frames, why not
      even use some of the dummy frame code to here - do a regcache
      dup and then pass the duped regcache, along with all the other
      stuff, at one single point.

      In fact, you can even save the structure's return address in the
      dummy frame and fix one of those nasty lost struct return edge
      conditions.  */
      generic_push_dummy_frame ();
    }
@


1.75.2.18
log
@2003-03-07  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Replace uses of
	SYMBOL_MATCHES_NATURAL_NAME by equivalent uses of
	SYMBOL_NATURAL_NAME, strcmp_iw.
	* symtab.h (SYMBOL_MATCHES_NATURAL_NAME): Delete.
	* minsyms.c (lookup_minimal_symbol_linkage): Make static.
	(lookup_minimal_symbol_natural): Ditto.
	(lookup_minimal_symbol): Only search on linkage names; rename
	first argument to 'linkage_name'.
	(lookup_minimal_symbol_linkage): Delete.
	(lookup_minimal_symbol_natural): Delete.
	(add_minsym_to_demangled_hash_table): Go back to using
	SYMBOL_DEMANGLED_NAME instead of SYMBOL_NATURAL_NAME.
	(lookup_minimal_symbol_aux): Don't use
	SYMBOL_MATCHES_NATURAL_NAME: do a strcmp_iw on
	SYMBOL_DEMANGLED_NAME instead.  Add comment.
	(build_minimal_symbol_hash_tables): Go back to only adding to
	demangled has table if SYMBOL_DEMANGLED_NAME is non-NULL.
	* symtab.h: Delete declarations for lookup_minimal_symbol_linkage
	and lookup_minimal_symbol_natural.
	* valops.c (find_function_in_inferior): Use lookup_symbol_linkage
	instead of lookup_symbol.  Change comment.
	* remote.c (remote_check_symbols): Use
	lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol, but add FIXME comment as well.
	* objc-lang.c: Ditto.
	* c-exp.y: Use lookup_minimal_symbol_linkage_or_natural instead of
	lookup_minimal_symbol.
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y (push_expression_name): Ditto.
	* f-exp.y: Ditto.
	* printcmd.c (address_info): Ditto.
	* symtab.h: Declare lookup_minimal_symbol_linkage_or_natural.
	* minsyms.c (lookup_minimal_symbol_linkage_or_natural): New.
	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME instead of
	DEPRECATED_SYMBOL_NAME.
	* tracepoint.c (scope_info): Ditto.
	* symtab.c (find_pc_sect_line): Ditto.
	* stabsread.c (define_symbol): Ditto.
	* sol-thread.c (info_cb): Ditto.
	* printcmd.c (address_info): Ditto.
	* hppa-tdep.c (hppa_fix_call_dummy): Ditto.
	(hppa_in_solib_call_trampoline): Ditto.
	* findvar.c (read_var_value): Ditto.
@
text
@d164 1
a164 2
/* Find the address of function whose linkage name is NAME in the
   inferior.  */
d170 1
a170 1
  sym = lookup_symbol_linkage (name);
@


1.75.2.19
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d1129 2
a1130 2
legacy_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		       int struct_return, CORE_ADDR struct_addr)
d1290 2
a1291 2
struct value *
call_function_by_hand (struct value *function, int nargs, struct value **args)
a1313 1
  CORE_ADDR dummy_addr;
d1353 1
a1353 1
	 inferior registers (and frame_pop() for restoring them).  (At
d1424 3
a1426 3
       adding SAVE_DUMMY_FRAME_TOS() and modifying
       DEPRECATED_FRAME_CHAIN so that when the next outer frame is a
       generic dummy, it returns the current frame's base.  */
d1473 2
a1474 6
  if (FIX_CALL_DUMMY_P ())
    {
      /* gdb_assert (CALL_DUMMY_LOCATION == ON_STACK) true?  */
      FIX_CALL_DUMMY (dummy1, start_sp, funaddr, nargs, args, value_type,
		      using_gcc);
    }
d1478 1
a1478 1
  switch (CALL_DUMMY_LOCATION)
a1479 2
    case ON_STACK:
      dummy_addr = start_sp;
d1483 4
a1486 2
      break;
    case AT_ENTRY_POINT:
a1487 1
      dummy_addr = CALL_DUMMY_ADDRESS ();
a1492 3
      break;
    default:
      internal_error (__FILE__, __LINE__, "bad switch");
d1619 3
a1621 2
	/* NOTE: cagney/2003-03-22: Should rely on frame align, rather
           than stack align to force the alignment of the stack.  */
d1649 1
a1649 4
  /* NOTE: cagney/2003-03-24: The below code is very broken.  Given an
     odd sized parameter the below will mis-align the stack.  As was
     suggested back in '96, better to let PUSH_ARGUMENTS handle it.  */
  if (DEPRECATED_EXTRA_STACK_ALIGNMENT_NEEDED)
d1652 1
a1652 1
	 is really broken.  Better to let push_dummy_call() adjust the
d1661 2
a1662 2
	  if (DEPRECATED_CALL_DUMMY_STACK_ADJUST_P ())
	    len += DEPRECATED_CALL_DUMMY_STACK_ADJUST;
d1667 1
a1667 16
  /* Create the dummy stack frame.  Pass in the call dummy address as,
     presumably, the ABI code knows where, in the call dummy, the
     return address should be pointed.  */
  if (gdbarch_push_dummy_call_p (current_gdbarch))
    /* When there is no push_dummy_call method, should this code
       simply error out.  That would the implementation of this method
       for all ABIs (which is probably a good thing).  */
    sp = gdbarch_push_dummy_call (current_gdbarch, current_regcache,
				  dummy_addr, nargs, args, sp, struct_return,
				  struct_addr);
  else  if (DEPRECATED_PUSH_ARGUMENTS_P ())
    /* Keep old targets working.  */
    sp = DEPRECATED_PUSH_ARGUMENTS (nargs, args, sp, struct_return,
				    struct_addr);
  else
    sp = legacy_push_arguments (nargs, args, sp, struct_return, struct_addr);
d1669 1
a1669 1
  if (DEPRECATED_PUSH_RETURN_ADDRESS_P ())
d1680 1
a1680 1
    sp = DEPRECATED_PUSH_RETURN_ADDRESS (real_pc, sp);
d1682 1
a1682 6
  /* NOTE: cagney/2003-03-23: Diable this code when there is a
     push_dummy_call() method.  Since that method will have already
     handled any alignment issues, the code below is entirely
     redundant.  */
  if (!gdbarch_push_dummy_call_p (current_gdbarch)
      && STACK_ALIGN_P () && !INNER_THAN (1, 2))
d1686 2
a1687 2
      if (DEPRECATED_CALL_DUMMY_STACK_ADJUST_P ())
	sp += DEPRECATED_CALL_DUMMY_STACK_ADJUST;
d1696 1
a1696 1
  if (DEPRECATED_CALL_DUMMY_STACK_ADJUST_P ())
d1700 1
a1700 1
	sp -= DEPRECATED_CALL_DUMMY_STACK_ADJUST;
d1704 10
a1713 5
     written.  */
  /* NOTE: 2003-03-24: Since PUSH_ARGUMENTS can (and typically does)
     store the struct return address, this call is entirely redundant.  */
  if (struct_return && DEPRECATED_STORE_STRUCT_RETURN_P ())
    DEPRECATED_STORE_STRUCT_RETURN (struct_addr, sp);
d1719 1
a1719 7
  /* NOTE: cagney/2003-03-23: Disable this code when there is a
     push_dummy_call() method.  Since that method will have already
     stored the stack pointer (as part of creating the fake call
     frame), and none of the code following that code adjusts the
     stack-pointer value, the below call is entirely redundant.  */
  if (DEPRECATED_DUMMY_WRITE_SP_P ())
    DEPRECATED_DUMMY_WRITE_SP (sp);
d1876 15
@


1.75.2.20
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@a36 1
#include "infcall.h"
d54 4
d133 31
d1139 770
d3780 25
@


1.75.2.21
log
@2003-05-07  David Carlton  <carlton@@bactrian.org>

	* valops.c (value_aggregate_elt): Add 'noside' argument.
	(value_struct_elt_for_reference): Add 'block', 'noside'
	arguments.  Call value_maybe_namespace_elt.
	(value_namespace_elt): Add 'noside' argument.  Break out code into
	value_maybe_namespace_elt.
	(value_maybe_namespace_elt): New.  Handle types.
	* value.h: Update declaration for value_aggregate_elt.
	* eval.c (evaluate_subexp_standard): Pass 'noside' to
	value_aggregate_elt.
	* c-exp.y: Added 'qualified_type'.
	(yylex): Comment out nested type stuff.

2003-05-07  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/namespace.exp: Update messages to match new parser
	changes.
@
text
@d104 1
a104 4
						     struct type *intype,
						     const struct block *
						     block,
						     enum noside noside);
d108 1
a108 7
					  const char *name,
					  enum noside noside);

static struct value *value_maybe_namespace_elt (const struct type *curtype,
						const struct block *block,
						const char *name,
						enum noside noside);
d2510 1
a2510 2
		     const char *name,
		     enum noside noside)
d2516 1
a2516 2
      return value_struct_elt_for_reference (curtype, 0, curtype, name, NULL,
					     block, noside);
d2518 1
a2518 1
      return value_namespace_elt (curtype, block, name, noside);
d2534 1
a2534 3
				struct type *intype,
				const struct block *block,
				enum noside noside)
d2653 1
a2653 3
					  intype,
					  block,
					  noside);
d2657 1
a2657 5

  /* As a last chance, look it up using lookup_symbol_namespace: this
     works for types.  */

  return value_maybe_namespace_elt (curtype, block, name, noside);
d2667 1
a2667 21
		     const char *name,
		     enum noside noside)
{
  struct value *retval = value_maybe_namespace_elt (curtype, block, name,
						    noside);

  if (retval == NULL)
    error ("No symbol \"%s\" in namespace \"%s\".", name,
	   TYPE_TAG_NAME (curtype));

  return retval;
}

/* A helper function used by value_namespace_elt and
   value_struct_elt_for_reference.  */

static struct value *
value_maybe_namespace_elt (const struct type *curtype,
			   const struct block *block,
			   const char *name,
			   enum noside noside)
d2675 3
d2679 3
a2681 6
    return NULL;
  else if ((noside == EVAL_AVOID_SIDE_EFFECTS)
	   && (SYMBOL_CLASS (sym) == LOC_TYPEDEF))
    return allocate_value (SYMBOL_TYPE (sym));
  else
    return value_of_variable (sym, block);
@


1.75.2.22
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d539 1
a539 1
  char raw_buffer[MAX_REGISTER_SIZE];
d693 2
a694 1
	buffer = (char *) alloca (amount_to_copy + MAX_REGISTER_SIZE);
d1021 2
a1022 2
  register int len = DEPRECATED_REGISTER_SIZE;
  char buffer[MAX_REGISTER_SIZE];
d2711 2
a2712 2
  sym = cp_lookup_symbol_namespace (namespace_name, name, NULL,
				    block, VAR_DOMAIN, NULL);
d2843 1
a2843 1
  sym = lookup_block_symbol (b, name, NULL, VAR_DOMAIN);
@


1.75.2.23
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a38 1
#include "cp-support.h"
d555 16
d644 10
a654 1
	int value_reg;
d664 4
a667 1
	    frame = frame_find_by_id (VALUE_FRAME_ID (toval));
d673 29
d703 2
a704 2
	if (VALUE_LVAL (toval) == lval_reg_frame_relative
	    && CONVERT_REGISTER_P (VALUE_FRAME_REGNUM (toval), type))
d706 7
a712 4
	    /* If TOVAL is a special machine register requiring
	       conversion of program values to a special raw format.  */
	    VALUE_TO_REGISTER (frame, VALUE_FRAME_REGNUM (toval),
			       type, VALUE_CONTENTS (fromval));
d716 9
a724 20
	    /* TOVAL is stored in a series of registers in the frame
	       specified by the structure.  Copy that value out,
	       modify it, and copy it back in.  */
	    int amount_copied;
	    int amount_to_copy;
	    char *buffer;
	    int reg_offset;
	    int byte_offset;
	    int regno;

	    /* Locate the first register that falls in the value that
	       needs to be transfered.  Compute the offset of the
	       value in that register.  */
	    {
	      int offset;
	      for (reg_offset = value_reg, offset = 0;
		   offset + REGISTER_RAW_SIZE (reg_offset) <= VALUE_OFFSET (toval);
		   reg_offset++);
	      byte_offset = VALUE_OFFSET (toval) - offset;
	    }
d726 9
a734 6
	    /* Compute the number of register aligned values that need
	       to be copied.  */
	    if (VALUE_BITSIZE (toval))
	      amount_to_copy = byte_offset + 1;
	    else
	      amount_to_copy = byte_offset + TYPE_LENGTH (type);
d736 3
a738 8
	    /* And a bounce buffer.  Be slightly over generous.  */
	    buffer = (char *) alloca (amount_to_copy + MAX_REGISTER_SIZE);

	    /* Copy it in.  */
	    for (regno = reg_offset, amount_copied = 0;
		 amount_copied < amount_to_copy;
		 amount_copied += REGISTER_RAW_SIZE (regno), regno++)
	      frame_register_read (frame, regno, buffer + amount_copied);
d740 8
a747 7
	    /* Modify what needs to be modified.  */
	    if (VALUE_BITSIZE (toval))
	      modify_field (buffer + byte_offset,
			    value_as_long (fromval),
			    VALUE_BITPOS (toval), VALUE_BITSIZE (toval));
	    else if (use_buffer)
	      memcpy (buffer + VALUE_OFFSET (toval), raw_buffer, use_buffer);
d749 2
a750 8
	      memcpy (buffer + byte_offset, VALUE_CONTENTS (fromval),
		      TYPE_LENGTH (type));

	    /* Copy it out.  */
	    for (regno = reg_offset, amount_copied = 0;
		 amount_copied < amount_to_copy;
		 amount_copied += REGISTER_RAW_SIZE (regno), regno++)
	      put_frame_register (frame, regno, buffer + amount_copied);
a751 1
	  }
d755 1
a755 1
	break;
d757 2
d2811 1
@


1.75.2.24
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d146 1
a146 1
  struct symbol *sym;
d215 3
a217 3
  enum type_code code1;
  enum type_code code2;
  int scalar;
d538 1
a538 1
  struct type *type;
d858 1
a858 1
  struct type *type = check_typedef (VALUE_TYPE (arg1));
d978 1
a978 1
  int len = DEPRECATED_REGISTER_SIZE;
d1027 1
a1027 1
value_push (CORE_ADDR sp, struct value *arg)
d1029 3
a1031 3
  int len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (arg));
  int container_len = len;
  int offset;
d1290 1
a1290 1
		     struct type *type, int looking_for_baseclass)
d1530 1
a1530 1
		      int *static_memfuncp, struct type *type)
d1675 1
a1675 1
  struct type *t;
d1955 1
a1955 1
  int ix;
d2398 1
a2398 1
check_field_in (struct type *type, const char *name)
d2400 1
a2400 1
  int i;
d2441 1
a2441 1
  struct type *t;
d2506 2
a2507 2
  struct type *t = curtype;
  int i;
@


1.75.2.25
log
@2003-09-19  David Carlton  <carlton@@kealia.com>

	* expression.h (enum exp_opcode): Revert to mainline's OP_FUNCALL,
	OP_SCOPE.
	* ada-exp.y, m2-exp.y, objc-exp.y, p-exp.y: Ditto.
	* jv-exp.y (push_qualified_expression_name): Ditto.
	* ada-lang.c (ada_resolve_subexp, replace_operator_with_call)
	(ada_evaluate_subexp): Ditto.
	* eval.c (evaluate_subexp_standard): Ditto.
	* expprint.c (print_subexp, dump_subexp): Ditto.
	* parse.c (length_of_subexp, prefixify_subexp): Ditto.
	* c-exp.y: Ditto, and add comment.
	* cp-support.c (make_symbol_overload_list): Delete 'block'
	argument; change calls to make_symbol_overload_list_using
	appropriately.
	(make_symbol_overload_list_using): Delete 'block' argument;
	replace it by get_selected_block (0).
	* cp-support.h: Delete 'block' argument from
	make_symbol_overload_list.
	* valops.c (find_overload_match): Delete 'block' argument, and
	update calls using it.
	(find_oload_champ_namespace, find_oload_champ_namespace_loop)
	(value_aggregate_elt, value_struct_elt_for_reference)
	(value_namespace_elt): Ditto.
	(value_maybe_namespace_elt): Delete 'block' argument, and use
	get_selected_block (0) instead.
	* value.h: Delete 'block' argument from value_struct_elt,
	value_find_oload.
@
text
@d66 1
d74 1
d106 2
d111 1
d116 1
d1936 1
d2006 1
d2107 1
d2116 1
a2116 1
				   func_name,
d2138 1
d2174 1
a2174 1
      if (find_oload_champ_namespace_loop (arg_types, nargs,
d2198 2
a2199 1
					      new_namespace);
d2468 4
a2471 4
   return the appropriate member.  This function is used to resolve
   user expressions of the form "DOMAIN::NAME".  For more details on
   what happens, see the comment before
   value_struct_elt_for_reference.  */
d2475 1
d2484 1
a2484 1
					     noside);
d2486 1
a2486 1
      return value_namespace_elt (curtype, name, noside);
d2503 1
d2624 1
d2633 1
a2633 1
  return value_maybe_namespace_elt (curtype, name, noside);
d2637 2
a2638 1
   CURTYPE.  */
d2642 1
d2646 1
a2646 1
  struct value *retval = value_maybe_namespace_elt (curtype, name,
d2661 1
d2669 1
a2669 2
				    get_selected_block (0), VAR_DOMAIN,
				    NULL);
d2677 1
a2677 1
    return value_of_variable (sym, get_selected_block (0));
@


1.75.2.26
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d667 1
a667 1
		   offset + DEPRECATED_REGISTER_RAW_SIZE (reg_offset) <= VALUE_OFFSET (toval);
d685 1
a685 1
		 amount_copied += DEPRECATED_REGISTER_RAW_SIZE (regno), regno++)
d702 1
a702 1
		 amount_copied += DEPRECATED_REGISTER_RAW_SIZE (regno), regno++)
d2374 1
a2374 1
      if (strlen (name + 1) != len || strncmp (dname, name + 1, len) != 0)
d2501 1
a2501 1
      if (t_field_name && strcmp (t_field_name, name) == 0)
d2548 1
a2548 1
      if (t_field_name && strcmp (t_field_name, name) == 0)
@


1.75.2.27
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* valops.c: Tweak comments to match proposed patch.
	(value_aggregate_elt): Use internal_error instead of error.
	* dwarf2read.c: Tweak comments to match proposed patch.
	(new_symbol): Use SYMBOL_LINKAGE_NAME or SYMBOL_NATURAL_NAME
	instead of DEPRECATED_SYMBOL_NAME.
	* cp-namespace.c: Tweak comments to match proposed patch.
	(cp_set_block_scope): Remove #if 0.
	(cp_lookup_nested_type): Use internal_error instead of error.

2003-11-11  David Carlton  <carlton@@kealia.com>

	* gdb.cp/namespace.exp: Remove doubled comment.
@
text
@d2476 1
a2476 2
      internal_error (__FILE__, __LINE__,
		      "non-aggregate type in value_aggregate_elt");
d2616 2
a2617 3
  /* As a last chance, pretend that CURTYPE is a namespace, and look
     it up that way; this (frequently) works for types nested inside
     classes.  */
d2641 1
a2641 4
   value_struct_elt_for_reference.  It looks up NAME inside the
   context CURTYPE; this works if CURTYPE is a namespace or if CURTYPE
   is a class and NAME refers to a type in CURTYPE itself (as opposed
   to, say, some base class of CURTYPE).  */
@


1.75.2.28
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d3 1
a3 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
a2652 1

@


1.74
log
@2002-09-18  Michael Snyder  <msnyder@@redhat.com>

	Preliminary support for Objective-C:
	* defs.h (language_objc): New enum value.
	(puts_filtered_tabular): Declaration only, exported from utils.c.
	(skip_quoted): Delete, declared in completer.h.
	* c-exp.y: Include completer.h.
	* p-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* expression.h (OP_MSGCALL, OP_SELECTOR, OP_SELF, OP_NSSTRING):
	New operator enum values.
	* language.h (CAST_IS_CONVERSION): Test for language_objc.
	* language.c (binop_result_type): Handle language_objc case.
	(integral_type, character_type, string_type, boolean_type,
	structured_type, binop_type_check): Ditto.
	* symtab.h (SYMBOL_OBJC_DEMANGLED_NAME): Define.
	(struct objc_specific): Add to general_symbol_info.
	(SYMBOL_INIT_LANGUAGE_SPECIFIC): Add objc initialization.
	(SYMBOL_DEMANGLED_NAME): Handle objc case.
	* parser-defs.h (struct objc_class_str): New struct type.
	(start_msglist, end_msglist, add_msglist): Declaration only,
	exported from objc-lang.c.
	* value.h (value_of_local, value_nsstring,
	call_function_by_hand_expecting_type): Exported from valops.c.
	* valops.c (find_function_addr): Export.
	(call_function_by_hand_expecting_type): New function.
	(value_of_local): New function.
	* symfile.c (init_filename_language_table): Add ".m" extension
	for Objective-C.
	* utils.c (puts_filtered_tabular): New function.
	(fprintf_symbol_filtered): Add objc demangling support (disabled).
	(set/show demangle): Extend help-string to refer to ObjC.
	* elfread.c (elf_symtab_read): Skip Objective-C special symbols.
	* stabsread.c (symbol_reference_defined): Objective-C symbols
	may contain colons: make allowances when scanning stabs strings
	for colons.
	(objc_find_colon): New function.
	* printcmd.c (address_info): If language == objc then print
	"self" instead of "this".
	* parse.c (length_of_subexp): Handle new operators OP_MSGCALL,
	OP_NSSTRING, and OP_SELF.
	(prefixify_subexp): Ditto.
	* source.c (print_source_lines): Mention objc in comment.
	* breakpoint.c (parse_breakpoint_sals): Recognize Objective-C
	method names.
@
text
@d51 1
d54 1
d94 1
d1222 1
a1222 1
CORE_ADDR
a1891 17

struct value *
call_function_by_hand_expecting_type (struct value *function, 
				      struct type *expect_type,
                                      int nargs, struct value **args, 
				      int restore_frame)
{
  if (CALL_DUMMY_P)
    {
      /* FIXME: Changes to func not implemented yet */
      return hand_function_call (function, nargs, args);
    }
  else
    {
      error ("Cannot invoke functions on this machine.");
    }
}
d3306 4
a3309 1
/* Return the value of the local variable, if one exists.
d3314 1
a3314 1
value_of_local (const char *name, int complain)
d3319 2
a3320 1
  struct value * ret;
d3334 1
a3334 1
	error ("no %s in nameless context", name);
d3344 1
a3344 1
	error ("no args, no %s", name);
d3351 1
a3351 1
  sym = lookup_block_symbol (b, name, NULL, VAR_NAMESPACE);
d3355 1
a3355 1
	error ("current stack frame does not contain a variable named \"%s\"", name);
d3360 4
a3363 17
  ret = read_var_value (sym, selected_frame);
  if (ret == 0 && complain)
    error ("%s argument unreadable", name);
  return ret;
}

/* C++/Objective-C: return the value of the class instance variable,
   if one exists.  Flag COMPLAIN signals an error if the request is
   made in an inappropriate context.  */

struct value *
value_of_this (int complain)
{
  if (current_language->la_language == language_objc)
    return value_of_local ("self", complain);
  else
    return value_of_local ("this", complain);
@


1.73
log
@2002-09-18  Andrew Cagney  <ac131313@@redhat.com>

	* valops.c (hand_function_call): Align the initial stack pointer
	and STRUCT_ADDR using frame_align.  When STRUCT_RETURN and
	FRAME_ALIGN_P, use STRUCT_ADDR to obtain the called function's
	return value.
	* mips-tdep.c (mips_frame_align): New function.
	(mips_gdbarch_init): Set frame_align.
	* gdbarch.sh (FRAME_ALIGN): New method.
	* gdbarch.h, gdbarch.c: Re-generate.
@
text
@a50 1
static CORE_ADDR find_function_addr (struct value *, struct type **);
a52 1

a91 1

d1219 1
a1219 1
static CORE_ADDR
d1889 17
d3320 1
a3320 4



/* C++: return the value of the class instance variable, if one exists.
d3325 1
a3325 1
value_of_this (int complain)
d3330 1
a3330 2
  static const char funny_this[] = "this";
  struct value *this;
d3344 1
a3344 1
	error ("no `this' in nameless context");
d3354 1
a3354 1
	error ("no args, no `this'");
d3361 1
a3361 1
  sym = lookup_block_symbol (b, funny_this, NULL, VAR_NAMESPACE);
d3365 1
a3365 1
	error ("current stack frame not in method");
d3370 17
a3386 4
  this = read_var_value (sym, selected_frame);
  if (this == 0 && complain)
    error ("`this' argument at unknown address");
  return this;
@


1.72
log
@        * gdbtypes.c (check_stub_method): Make static.
        (check_stub_method_group): New function.
        * gdbtypes.h: Update prototypes.
        * cp-support.c: New file.
        * cp-support.h: New file.

        * stabsread.c: Include "cp-abi.h" and "cp-support.h".
        (update_method_name_from_physname): New function.
        (read_member_functions): Correct method names for operators
        and v3 constructors/destructors.  Separate v2 constructors and
        destructors.
        * Makefile.in (stabsread.o): Update dependencies.
        (SFILES): Add cp-support.c.
        (COMMON_OBS): Add cp-support.o.
        (cp_support_h, cp-support.o): Add.

        * cp-valprint.c (cp_print_class_method): Call
        check_stub_method_group instead of check_stub_method.  Remove
        extraneous QUITs.
        * p-valprint.c (pascal_object_print_class_method): Likewise.
        * valops.c (search_struct_method): Likewise.
        (find_method_list, value_struct_elt_for_reference): Likewise.
@
text
@d1354 49
a1402 1
  old_sp = sp = read_sp ();
d1417 5
d1618 2
a1619 1
     stack, if necessary */
d1631 2
a1632 1
	  /* stack grows downward */
d1634 2
d1640 4
a1643 1
	  /* stack grows upward */
d1646 2
d1843 7
a1849 8
/* elz: I defined this new macro for the hppa architecture only.
   this gives us a way to get the value returned by the function from the stack,
   at the same address we told the function to put it.
   We cannot assume on the pa that r28 still contains the address of the returned
   structure. Usually this will be overwritten by the callee.
   I don't know about other architectures, so I defined this macro
 */

d1857 20
a1876 6

    {
      struct value *retval = value_being_returned (value_type, retbuf, struct_return);
      do_cleanups (retbuf_cleanup);
      return retval;
    }
@


1.71
log
@       * gdbarch.sh (NAME_OF_MALLOC): New variable in the architecture
       vector. Will be useful for Interix.
       * gdbarch.h, gdbarch.c: Regenerate.

       * valops.c (value_allocate_space_in_inferior): Replace hard-coded
       name of the malloc function by NAME_OF_MALLOC.
@
text
@d2305 1
a2309 2
	      if (TYPE_FN_FIELD_STUB (f, j))
		check_stub_method (type, i, j);
a2316 2
		if (TYPE_FN_FIELD_STUB (f, j))
		  check_stub_method (type, i, j);
a2554 1
	  /* Resolve any stub methods.  */
a2556 1
	  int j;
d2562 2
a2563 5
	  for (j = 0; j < len; j++)
	    {
	      if (TYPE_FN_FIELD_STUB (f, j))
		check_stub_method (type, i, j);
	    }
d3089 2
a3103 2
	  if (TYPE_FN_FIELD_STUB (f, j))
	    check_stub_method (t, i, j);
@


1.70
log
@       * value.h (find_function_in_inferior): Add const keyword to
       one of the parameters. Allows us to invoke this function with
       a const char *.
       * valops.c (find_function_in_inferior): Likewise.
@
text
@d141 1
a141 1
  struct value *val = find_function_in_inferior ("malloc");
@


1.69
log
@* valops.c (value_cast): Simplify and correct logic for doing a
static cast from a pointer to a base class to a pointer to a
derived class.
@
text
@d98 1
a98 1
find_function_in_inferior (char *name)
@


1.68
log
@        * gdb-events.sh: Add target-changed event.
        * gdb-events.c: Regenerated.
        * gdb-events.c: Regenerated.
        * valops.c (value_assign): Add target-changed event notification
        to inlval_register, lval_memory, and lval_reg_frame_relative.
@
text
@d364 5
a368 12
		      struct value *v2 = value_ind (arg2);
		      VALUE_ADDRESS (v2) -= VALUE_ADDRESS (v)
			+ VALUE_OFFSET (v);

                      /* JYG: adjust the new pointer value and
			 embedded offset. */
                      v2->aligner.contents[0] -=  VALUE_EMBEDDED_OFFSET (v);
                      VALUE_EMBEDDED_OFFSET (v2) = 0;

		      v2 = value_addr (v2);
		      VALUE_TYPE (v2) = type;
		      return v2;
@


1.67
log
@2002-08-19  David Carlton  <carlton@@math.stanford.edu>

	* valops.c (search_struct_field): Change error message to treat
	return value of 0 from value_static_field as meaning that field is
	optimized out.
	(value_struct_elt_for_reference): Ditto.
	* values.c (value_static_field): Treat an unresolved location the
	same as a nonexistent symbol.  Fix PR gdb/635.
@
text
@d636 1
d682 3
d772 1
@


1.66
log
@2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* NEWS: Menion that CHILL has been made obsolete.

* gdbtypes.c (chill_varying_type): Make chill references obsolete.
* gdbserver/Makefile.in: Ditto.
* stabsread.c (read_range_type): Ditto.
* gdbtypes.h: Ditto.
* language.c (binop_type_check): Ditto.
(binop_result_type): Ditto.
(integral_type): Ditto.
(character_type): Ditto.
(string_type): Ditto.
(boolean_type): Ditto.
(structured_type): Ditto.
(lang_bool_type): Ditto.
(binop_type_check): Ditto.
* language.h (_LANG_chill): Ditto.
* dwarfread.c (set_cu_language): Ditto.
* dwarfread.c (CHILL_PRODUCER): Ditto.
* dwarfread.c (handle_producer): Ditto.
* expression.h (enum exp_opcode): Ditto.
* eval.c: Ditto for comments.
* typeprint.c (typedef_print) [_LANG_chill]: Ditto.
* expprint.c (print_subexp): Ditto.
(print_subexp): Ditto.
* valops.c (value_cast): Ditto.
(search_struct_field): Ditto.
* value.h (COERCE_VARYING_ARRAY): Ditto.
* symfile.c (init_filename_language_table): Ditto.
(add_psymbol_with_dem_name_to_list): Ditto.
* valarith.c (value_binop): Ditto.
(value_neg): Ditto.
* valops.c (value_slice): Ditto.
* symtab.h (union language_specific): Ditto.
(SYMBOL_INIT_LANGUAGE_SPECIFIC): Ditto.
(SYMBOL_DEMANGLED_NAME): Ditto.
(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
* defs.h (enum language): Ditto.
* symtab.c (got_symtab): Ditto.
* utils.c (fprintf_symbol_filtered): Ditto.

* ch-typeprint.c: Make file obsolete.
* ch-valprint.c: Make file obsolete.
* ch-lang.h: Make file obsolete.
* ch-exp.c: Make file obsolete.
* ch-lang.c: Make file obsolete.

* Makefile.in (FLAGS_TO_PASS): Do not pass CHILL or CHILLFLAGS or
CHILL_LIB.
(TARGET_FLAGS_TO_PASS): Ditto.
(CHILLFLAGS): Obsolete.
(CHILL): Obsolete.
(CHILL_FOR_TARGET): Obsolete.
(CHILL_LIB): Obsolete.
(SFILES): Remove ch-exp.c, ch-lang.c, ch-typeprint.c and
ch-valprint.c.
(HFILES_NO_SRCDIR): Remove ch-lang.h.
(COMMON_OBS): Remove ch-valprint.o, ch-typeprint.o, ch-exp.o and
ch-lang.o.
(ch-exp.o, ch-lang.o, ch-typeprint.o, ch-valprint.o): Delete
targets.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* stabs.texinfo, gdb.texinfo, gdbint.texinfo: Obsolete references
to CHILL.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* Makefile.in (TARGET_FLAGS_TO_PASS): Remove CHILLFLAGS, CHILL,
CHILL_FOR_TARGET and CHILL_LIB.
* configure.in (configdirs): Remove gdb.chill.
* configure: Regenerate.
* lib/gdb.exp: Obsolete references to chill.
* gdb.fortran/types.exp: Ditto.
* gdb.fortran/exprs.exp: Ditto.
@
text
@d2057 6
a2062 1
	      v = value_static_field (type, i);
d2064 5
a2068 3
	      v = value_primitive_field (arg1, offset, i, type);
	    if (v == 0)
	      error ("there is no field named %s", name);
d3053 1
a3053 1
		error ("Internal error: could not find static variable %s",
@


1.65
log
@2002-07-12  Peter Schauer  <Peter.Schauer@@Regent.E-Technik.TU-Muenchen.DE>

        * valops.c (find_method_list): Remove comment about
        removed STATIC_MEMFUNCP argument.
        (value_find_oload_method_list): Likewise.
@
text
@d386 43
a428 43
  else if (chill_varying_type (type))
    {
      struct type *range1, *range2, *eltype1, *eltype2;
      struct value *val;
      int count1, count2;
      LONGEST low_bound, high_bound;
      char *valaddr, *valaddr_data;
      /* For lint warning about eltype2 possibly uninitialized: */
      eltype2 = NULL;
      if (code2 == TYPE_CODE_BITSTRING)
	error ("not implemented: converting bitstring to varying type");
      if ((code2 != TYPE_CODE_ARRAY && code2 != TYPE_CODE_STRING)
	  || (eltype1 = check_typedef (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 1))),
	      eltype2 = check_typedef (TYPE_TARGET_TYPE (type2)),
	      (TYPE_LENGTH (eltype1) != TYPE_LENGTH (eltype2)
      /* || TYPE_CODE (eltype1) != TYPE_CODE (eltype2) */ )))
	error ("Invalid conversion to varying type");
      range1 = TYPE_FIELD_TYPE (TYPE_FIELD_TYPE (type, 1), 0);
      range2 = TYPE_FIELD_TYPE (type2, 0);
      if (get_discrete_bounds (range1, &low_bound, &high_bound) < 0)
	count1 = -1;
      else
	count1 = high_bound - low_bound + 1;
      if (get_discrete_bounds (range2, &low_bound, &high_bound) < 0)
	count1 = -1, count2 = 0;	/* To force error before */
      else
	count2 = high_bound - low_bound + 1;
      if (count2 > count1)
	error ("target varying type is too small");
      val = allocate_value (type);
      valaddr = VALUE_CONTENTS_RAW (val);
      valaddr_data = valaddr + TYPE_FIELD_BITPOS (type, 1) / 8;
      /* Set val's __var_length field to count2. */
      store_signed_integer (valaddr, TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)),
			    count2);
      /* Set the __var_data field to count2 elements copied from arg2. */
      memcpy (valaddr_data, VALUE_CONTENTS (arg2),
	      count2 * TYPE_LENGTH (eltype2));
      /* Zero the rest of the __var_data field of val. */
      memset (valaddr_data + count2 * TYPE_LENGTH (eltype2), '\0',
	      (count1 - count2) * TYPE_LENGTH (eltype2));
      return val;
    }
d2077 6
a2082 5
		   In the GNU Chill implementation of variant record types,
		   each <alternative field> has an (anonymous) union type,
		   each member of the union represents a <variant alternative>.
		   Each <variant alternative> is represented as a struct,
		   with a member for each <variant field>.  */
d2087 6
a2092 5
		/* This is pretty gross.  In G++, the offset in an anonymous
		   union is relative to the beginning of the enclosing struct.
		   In the GNU Chill implementation of variant records,
		   the bitpos is zero in an anonymous union field, so we
		   have to add the offset of the union here. */
d3315 4
a3318 4
      || lowbound + length - 1 > upperbound
  /* Chill allows zero-length strings but not arrays. */
      || (current_language->la_language == language_chill
	  && length == 0 && TYPE_CODE (array_type) == TYPE_CODE_ARRAY))
d3374 2
a3375 2
/* Assuming chill_varying_type (VARRAY) is true, return an equivalent
   value as a fixed-length array. */
@


1.64
log
@2002-07-10  Daniel Jacobowitz  <drow@@mvista.com>

        * valops.c (find_overload_match): Free oload_syms.
@
text
@a2527 1
 * STATIC_MEMFUNCP is set if the method is static
a2617 1
 * STATIC_MEMFUNCP is set if the method is static
@


1.63
log
@* infcmd.c (print_return_value): Remove compatibility code calling
deprecated_grub_regcache_for_registers.

* values.c: Include "regcache.h".
(value_being_returned): Update.  Use
deprecated_grub_regcache_for_registers to extract the register
buffer address.
* value.h (value_being_returned): Change ``retbuf'' parameter to a
``struct regcache''.
* Makefile.in (values.o): Add dependency on $(regcache_h).

* inferior.h (run_stack_dummy): Change type of second parameter to
a ``struct regcache''.
* valops.c (hand_function_call): Change type of retbuf to ``struct
regcache''.  Allocate using regcache_xmalloc, clean using
make_cleanup_regcache_xfree.
* infcmd.c (run_stack_dummy): Update.  Use
regcache_cpu_no_passthrough instead of memcpy to copy the buffer.

* regcache.c (do_regcache_xfree): New function.
(make_cleanup_regcache_xfree): New function.
* regcache.h (make_cleanup_regcache_xfree): Declare.
@
text
@d2710 1
d2752 1
d2909 3
@


1.62
log
@* valops.c (hand_function_call): Move declaration of retbuf to
start of function, allocate using malloc, add a cleanup but before
the inf_status cleanup, cleanup the buffer.  Rename local variable
old_chain to inf_status_cleanup.
@
text
@d1319 1
a1319 1
  char *retbuf;
d1342 2
a1343 2
  retbuf = xmalloc (REGISTER_BYTES);
  retbuf_cleanup = make_cleanup (xfree, retbuf);
@


1.61
log
@2002-06-18  Don Howard  <dhoward@@redhat.com>

        * valops.c (value_ind): Use value_at_lazy() when dereferencing
        type int expressions.  Thanks to Jim Blandy <jimb@@redhat.com> for
        suggesting this solution.
@
text
@d1319 2
d1322 1
a1322 1
  struct cleanup *old_chain;
d1338 10
d1349 1
a1349 1
  old_chain = make_cleanup_restore_inferior_status (inf_status);
a1670 1
    char *retbuf = (char*) alloca (REGISTER_BYTES);
d1729 6
a1734 5
	    /* If we did the cleanups, we would print a spurious error
	       message (Unable to restore previously selected frame),
	       would write the registers from the inf_status (which is
	       wrong), and would do other wrong things.  */
	    discard_cleanups (old_chain);
d1752 6
a1757 5
	/* If we did the cleanups, we would print a spurious error
	   message (Unable to restore previously selected frame),
	   would write the registers from the inf_status (which is
	   wrong), and would do other wrong things.  */
	discard_cleanups (old_chain);
d1777 4
a1780 1
    do_cleanups (old_chain);
d1793 4
a1796 1
      return (struct value *) VALUE_RETURNED_FROM_STACK (value_type, struct_addr);
d1799 5
a1803 1
    return value_being_returned (value_type, retbuf, struct_return);
@


1.60
log
@2002-06-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbtypes.h (TYPE_FLAG_VARARGS): Update comment.
        (struct main_type): Remove arg_types member.  Update comments for
        struct field.
        (TYPE_ARG_TYPES): Remove.
        (TYPE_FN_FIELD_ARGS): Update.
        (smash_to_method_type): Update prototype.

        * c-typeprint.c (cp_type_print_method_args): Take method type
        instead of argument list.  Use new argument layout.  Simplify.
        (c_type_print_args): Use new argument layout.  Simplify.
        (c_type_print_base): Update call to cp_type_print_method_args.
        * dwarf2read.c (dwarf2_add_member_fn): Remove unneeded type
        argument; use die->type instead.  Update call to
        smash_to_method_type.
        (read_structure_scope): Update call to dwarf2_add_member_fn.
        * gdbtypes.c (allocate_stub_method): Update comment.
        (smash_to_method_type): Take new NARGS and VARARGS arguments.
        Use new argument layout.
        (check_stub_method): Use new argument layout.  Don't count
        void as an argument.
        (print_arg_types): Update comments.  Use new argument layout.
        (recursive_dump_type): Don't print arg_types member.
        * hpread.c (hpread_read_struct_type): Use new argument layout.
        (fixup_class_method_type): Likewise.
        (hpread_type_lookup): Likewise.
        * stabsread.c (read_type): Update calls to read_args and
        smash_to_method_type.
        (read_args): Use new argument layout.  Simplify.
        * valops.c (typecmp): Use new argument layout.  Update parameters
        and comments.  Simplify.
        (hand_function_call): Use new argument layout.
        (search_struct_method): Update call to typecmp.
        (find_overload_match): Use new argument layout.
@
text
@d964 3
a966 3
    return value_at (builtin_type_int,
		     (CORE_ADDR) value_as_long (arg1),
		     VALUE_BFD_SECTION (arg1));
@


1.59
log
@2002-05-13  Daniel Jacobowitz  <drow@@mvista.com>

        * ax-gdb.c (gen_sign_extend, gen_fetch, gen_usual_unary)
        (gen_cast, gen_scale, gen_add, gen_sub, gen_binop, gen_deref)
        (gen_address_of, gen_struct_ref, gen_repeat): Use type
        access macros.
        * c-typeprint.c (cp_type_print_method_args): Likewise.
        (c_type_print_args): Likewise.
        * d10v-tdep.c (d10v_push_arguments): Likewise.
        (d10v_extract_return_value): Likewise.
        * expprint.c (print_subexp): Likewise.
        * gdbtypes.c (lookup_primitive_typename): Likewise.
        (lookup_template_type, add_mangled_type, print_arg_types): Likewise.
        * gdbtypes.h (TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB)
        (TYPE_TARGET_STUB, TYPE_STATIC, TYPE_CONST, TYPE_VOLATILE)
        (TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_CODE_SPACE, TYPE_VARARGS)
        (TYPE_VECTOR): Likewise.
        * hpread.c (hpread_read_struct_type)
        (fix_static_member_physnames, fixup_class_method_type)
        (hpread_type_lookup): Likewise.
        * mdebugread.c (parse_symbol, parse_type): Likewise.
        * p-lang.c (is_pascal_string_type): Likewise.
        * valops.c (hand_function_call): Likewise.
        * x86-64-tdep.c (classify_argument): Likewise.

        * hpread.c (hpread_read_function_type)
        (hpread_read_doc_function_type): Call replace_type.
        * dstread.c (create_new_type): Delete.
        (decode_dst_structure, process_dst_function): Call alloc_type.
        Use type access macros.
@
text
@d48 2
a49 1
static int typecmp (int staticp, struct type *t1[], struct value *t2[]);
d1442 1
a1442 10
  if (TYPE_CODE (ftype) == TYPE_CODE_METHOD)
    {
      i = 0;
      while (TYPE_CODE (TYPE_ARG_TYPES (ftype)[i]) != TYPE_CODE_VOID)
	i++;
      n_method_args = i;
      if (nargs < i)
	error ("too few arguments in method call");
    }
  else if (nargs < TYPE_NFIELDS (ftype))
d1447 4
a1450 3
      /* Assume that methods are always prototyped, unless they are off the
	 end (which we should only be allowing if there is a ``...'').  
         FIXME.  */
d1452 3
a1454 6
	{
	  if (i < n_method_args)
	    args[i] = value_arg_coerce (args[i], TYPE_ARG_TYPES (ftype)[i], 1);
	  else
	    args[i] = value_arg_coerce (args[i], NULL, 0);
	}
d1456 4
a1459 4
      /* If we're off the end of the known arguments, do the standard
         promotions.  FIXME: if we had a prototype, this should only
         be allowed if ... were present.  */
      if (i >= TYPE_NFIELDS (ftype))
a1461 6
      else
	{
	  param_type = TYPE_FIELD_TYPE (ftype, i);
	  args[i] = value_arg_coerce (args[i], param_type, TYPE_PROTOTYPED (ftype));
	}

d1472 1
a1472 1
	if (param_type)
d1925 4
a1928 4
   of types T1.  Both t1 and t2 are NULL-terminated vectors.  If some
   arguments need coercion of some sort, then the coerced values are written
   into T2.  Return value is 0 if the arguments could be matched, or the
   position at which they differ if not.
d1931 2
a1932 1
   static member function.
d1941 2
a1942 1
typecmp (int staticp, struct type *t1[], struct value *t2[])
d1947 2
a1948 9
    return 1;
  if (staticp && t1 == 0)
    return t2[1] != 0;
  if (t1 == 0)
    return 1;
  if (t1[!staticp] == 0)
    return 0;
  if (TYPE_CODE (t1[0]) == TYPE_CODE_VOID)
    return 0;
d1951 5
a1955 2
    t2++;
  for (i = !staticp; t1[i] && TYPE_CODE (t1[i]) != TYPE_CODE_VOID; i++)
d1958 1
d1961 2
a1962 1
      tt1 = check_typedef (t1[i]);
d1964 1
d2000 1
a2000 1
      if (TYPE_CODE (t1[i]) != TYPE_CODE (VALUE_TYPE (t2[i])))
d2003 1
a2003 1
  if (!t1[i])
d2005 1
a2005 1
  return t2[i] ? i + 1 : 0;
d2291 2
d2744 1
a2744 7
	  nparms=0;

	  if (TYPE_FN_FIELD_ARGS(fns_ptr,ix))
	    {
	      while (TYPE_CODE(TYPE_FN_FIELD_ARGS(fns_ptr,ix)[nparms]) != TYPE_CODE_VOID)
		nparms++;
	    }
d2756 1
a2756 1
			  ? (TYPE_FN_FIELD_ARGS (fns_ptr, ix)[jj])
@


1.59.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d48 1
a48 2
static int typecmp (int staticp, int varargs, int nargs,
		    struct field t1[], struct value *t2[]);
d963 3
a965 3
    return value_at_lazy (builtin_type_int,
			  (CORE_ADDR) value_as_long (arg1),
			  VALUE_BFD_SECTION (arg1));
d1441 10
a1450 1
  if (nargs < TYPE_NFIELDS (ftype))
d1455 10
a1464 1
      int prototyped;
d1466 5
a1470 6
      /* FIXME drow/2002-05-31: Should just always mark methods as
	 prototyped.  Can we respect TYPE_VARARGS?  Probably not.  */
      if (TYPE_CODE (ftype) == TYPE_CODE_METHOD)
	prototyped = 1;
      else
	prototyped = TYPE_PROTOTYPED (ftype);
a1471 3
      if (i < TYPE_NFIELDS (ftype))
	args[i] = value_arg_coerce (args[i], TYPE_FIELD_TYPE (ftype, i),
				    prototyped);
d1473 4
a1476 1
	args[i] = value_arg_coerce (args[i], NULL, 0);
d1488 1
a1488 1
	if (param_type && TYPE_CODE (ftype) != TYPE_CODE_METHOD)
d1941 4
a1944 4
   of types T1.  T1 is a list of NARGS arguments, and T2 is a NULL-terminated
   vector.  If some arguments need coercion of some sort, then the coerced
   values are written into T2.  Return value is 0 if the arguments could be
   matched, or the position at which they differ if not.
d1947 1
a1947 2
   static member function.  T2 will still include the ``this'' pointer,
   but it will be skipped.
d1956 1
a1956 2
typecmp (int staticp, int varargs, int nargs,
	 struct field t1[], struct value *t2[])
d1961 9
a1969 2
    internal_error (__FILE__, __LINE__, "typecmp: no argument list");

d1972 2
a1973 5
    t2 ++;

  for (i = 0;
       (i < nargs) && TYPE_CODE (t1[i].type) != TYPE_CODE_VOID;
       i++)
a1975 1

d1978 1
a1978 2

      tt1 = check_typedef (t1[i].type);
a1979 1

d2015 1
a2015 1
      if (TYPE_CODE (t1[i].type) != TYPE_CODE (VALUE_TYPE (t2[i])))
d2018 1
a2018 1
  if (varargs || t2[i] == NULL)
d2020 1
a2020 1
  return i + 1;
a2305 2
			      TYPE_VARARGS (TYPE_FN_FIELD_TYPE (f, j)),
			      TYPE_NFIELDS (TYPE_FN_FIELD_TYPE (f, j)),
d2757 7
a2763 1
	  nparms = TYPE_NFIELDS (TYPE_FN_FIELD_TYPE (fns_ptr, ix));
d2775 1
a2775 1
			  ? (TYPE_FN_FIELD_ARGS (fns_ptr, ix)[jj].type)
@


1.59.4.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a1318 2
  struct regcache *retbuf;
  struct cleanup *retbuf_cleanup;
d1320 1
a1320 1
  struct cleanup *inf_status_cleanup;
a1335 10
  /* Create a cleanup chain that contains the retbuf (buffer
     containing the register values).  This chain is create BEFORE the
     inf_status chain so that the inferior status can cleaned up
     (restored or discarded) without having the retbuf freed.  */
  retbuf = regcache_xmalloc (current_gdbarch);
  retbuf_cleanup = make_cleanup_regcache_xfree (retbuf);

  /* A cleanup for the inferior status.  Create this AFTER the retbuf
     so that this can be discarded or applied without interfering with
     the regbuf.  */
d1337 1
a1337 1
  inf_status_cleanup = make_cleanup_restore_inferior_status (inf_status);
d1659 1
d1718 5
a1722 6
	    /* If we restored the inferior status (via the cleanup),
	       we would print a spurious error message (Unable to
	       restore previously selected frame), would write the
	       registers from the inf_status (which is wrong), and
	       would do other wrong things.  */
	    discard_cleanups (inf_status_cleanup);
d1740 5
a1744 6
	/* If we restored the inferior status (via the cleanup), we
	   would print a spurious error message (Unable to restore
	   previously selected frame), would write the registers from
	   the inf_status (which is wrong), and would do other wrong
	   things.  */
	discard_cleanups (inf_status_cleanup);
d1764 1
a1764 4

    /* Restore the inferior status, via its cleanup.  At this stage,
       leave the RETBUF alone.  */
    do_cleanups (inf_status_cleanup);
d1777 1
a1777 4
      {
	do_cleanups (retbuf_cleanup);
	return VALUE_RETURNED_FROM_STACK (value_type, struct_addr);
      }
d1780 1
a1780 5
    {
      struct value *retval = value_being_returned (value_type, retbuf, struct_return);
      do_cleanups (retbuf_cleanup);
      return retval;
    }
d2505 1
d2596 1
a2686 1
  struct cleanup *cleanups = NULL;
a2727 1
      cleanups = make_cleanup (xfree, oload_syms);
a2883 3
  if (cleanups != NULL)
    do_cleanups (cleanups);

@


1.59.4.3
log
@        * valops.c (value_assign): Add register_update event notification
        for lval_register and lval_reg_frame_relative.
@
text
@a680 3

      register_update_event (VALUE_REGNO (toval));

a765 2
	if (regno > VALUE_FRAME_REGNUM (toval) + reg_offset)
	  regno = -1;
d767 1
a767 2
	  register_changed_hook (regno);
	register_update_event (regno);
@


1.59.4.4
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d386 43
a428 43
  /* OBSOLETE else if (chill_varying_type (type)) */
  /* OBSOLETE   { */
  /* OBSOLETE     struct type *range1, *range2, *eltype1, *eltype2; */
  /* OBSOLETE     struct value *val; */
  /* OBSOLETE     int count1, count2; */
  /* OBSOLETE     LONGEST low_bound, high_bound; */
  /* OBSOLETE     char *valaddr, *valaddr_data; */
  /* OBSOLETE     *//* For lint warning about eltype2 possibly uninitialized: */
  /* OBSOLETE     eltype2 = NULL; */
  /* OBSOLETE     if (code2 == TYPE_CODE_BITSTRING) */
  /* OBSOLETE       error ("not implemented: converting bitstring to varying type"); */
  /* OBSOLETE     if ((code2 != TYPE_CODE_ARRAY && code2 != TYPE_CODE_STRING) */
  /* OBSOLETE         || (eltype1 = check_typedef (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 1))), */
  /* OBSOLETE       eltype2 = check_typedef (TYPE_TARGET_TYPE (type2)), */
  /* OBSOLETE                                (TYPE_LENGTH (eltype1) != TYPE_LENGTH (eltype2) */
  /* OBSOLETE     *//*|| TYPE_CODE (eltype1) != TYPE_CODE (eltype2) *//* ))) */
  /* OBSOLETE      error ("Invalid conversion to varying type"); */
  /* OBSOLETE     range1 = TYPE_FIELD_TYPE (TYPE_FIELD_TYPE (type, 1), 0); */
  /* OBSOLETE     range2 = TYPE_FIELD_TYPE (type2, 0); */
  /* OBSOLETE     if (get_discrete_bounds (range1, &low_bound, &high_bound) < 0) */
  /* OBSOLETE       count1 = -1; */
  /* OBSOLETE     else */
  /* OBSOLETE       count1 = high_bound - low_bound + 1; */
  /* OBSOLETE     if (get_discrete_bounds (range2, &low_bound, &high_bound) < 0) */
  /* OBSOLETE       count1 = -1, count2 = 0;	*//* To force error before */
  /* OBSOLETE     else */
  /* OBSOLETE       count2 = high_bound - low_bound + 1; */
  /* OBSOLETE     if (count2 > count1) */
  /* OBSOLETE       error ("target varying type is too small"); */
  /* OBSOLETE     val = allocate_value (type); */
  /* OBSOLETE     valaddr = VALUE_CONTENTS_RAW (val); */
  /* OBSOLETE     valaddr_data = valaddr + TYPE_FIELD_BITPOS (type, 1) / 8; */
  /* OBSOLETE     *//* Set val's __var_length field to count2. */
  /* OBSOLETE     store_signed_integer (valaddr, TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)), */
  /* OBSOLETE 	    count2); */
  /* OBSOLETE     *//* Set the __var_data field to count2 elements copied from arg2. */
  /* OBSOLETE     memcpy (valaddr_data, VALUE_CONTENTS (arg2), */
  /* OBSOLETE      count2 * TYPE_LENGTH (eltype2)); */
  /* OBSOLETE     *//* Zero the rest of the __var_data field of val. */
  /* OBSOLETE     memset (valaddr_data + count2 * TYPE_LENGTH (eltype2), '\0', */
  /* OBSOLETE      (count1 - count2) * TYPE_LENGTH (eltype2)); */
  /* OBSOLETE     return val; */
  /* OBSOLETE   } */
d2083 5
a2087 6
		   In the GNU Chill (OBSOLETE) implementation of
		   variant record types, each <alternative field> has
		   an (anonymous) union type, each member of the union
		   represents a <variant alternative>.  Each <variant
		   alternative> is represented as a struct, with a
		   member for each <variant field>.  */
d2092 5
a2096 6
		/* This is pretty gross.  In G++, the offset in an
		   anonymous union is relative to the beginning of the
		   enclosing struct.  In the GNU Chill (OBSOLETE)
		   implementation of variant records, the bitpos is
		   zero in an anonymous union field, so we have to add
		   the offset of the union here. */
d3319 4
a3322 4
      || lowbound + length - 1 > upperbound)
    /* OBSOLETE Chill allows zero-length strings but not arrays. */
    /* OBSOLETE || (current_language->la_language == language_chill */
    /* OBSOLETE && length == 0 && TYPE_CODE (array_type) == TYPE_CODE_ARRAY)) */
d3378 2
a3379 2
/* Assuming OBSOLETE chill_varying_type (VARRAY) is true, return an
   equivalent value as a fixed-length array. */
@


1.59.4.5
log
@Make same as CVS HEAD.
        * gdb-events.sh: Replace register_update with target-changed event.
        * gdb-events.c: Regenerated.
        * gdb-events.c: Regenerated.
        * valops.c (value_assign): Use target_changed_event instead
        of register_update_event and memory_changed.
@
text
@a635 1
	target_changed_event ();
d682 1
a682 1
      target_changed_event ();
d773 1
a773 1
	target_changed_event ();
@


1.59.4.6
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d364 12
a375 5
                      CORE_ADDR addr2 = value_as_address (arg2);
                      addr2 -= (VALUE_ADDRESS (v)
                                + VALUE_OFFSET (v)
                                + VALUE_EMBEDDED_OFFSET (v));
                      return value_from_pointer (type, addr2);
d773 1
a773 1
	  register_changed_hook (-1);
d2064 1
a2064 6
	      {
		v = value_static_field (type, i);
		if (v == 0)
		  error ("field %s is nonexistent or has been optimised out",
			 name);
	      }
d2066 3
a2068 5
	      {
		v = value_primitive_field (arg1, offset, i, type);
		if (v == 0)
		  error ("there is no field named %s", name);
	      }
d3053 1
a3053 1
		error ("static field %s has been optimized out",
@


1.59.4.7
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d98 1
a98 1
find_function_in_inferior (const char *name)
d141 1
a141 1
  struct value *val = find_function_in_inferior (NAME_OF_MALLOC);
d1356 1
a1356 49
  old_sp = read_sp ();

  /* Ensure that the initial SP is correctly aligned.  */
  if (gdbarch_frame_align_p (current_gdbarch))
    {
      /* NOTE: cagney/2002-09-18:

	 On a RISC architecture, a void parameterless generic dummy
	 frame (i.e., no parameters, no result) typically does not
	 need to push anything the stack and hence can leave SP and
	 FP.  Similarly, a framelss (possibly leaf) function does not
	 push anything on the stack and, hence, that too can leave FP
	 and SP unchanged.  As a consequence, a sequence of void
	 parameterless generic dummy frame calls to frameless
	 functions will create a sequence of effectively identical
	 frames (SP, FP and TOS and PC the same).  This, not
	 suprisingly, results in what appears to be a stack in an
	 infinite loop --- when GDB tries to find a generic dummy
	 frame on the internal dummy frame stack, it will always find
	 the first one.

	 To avoid this problem, the code below always grows the stack.
	 That way, two dummy frames can never be identical.  It does
	 burn a few bytes of stack but that is a small price to pay
	 :-).  */
      sp = gdbarch_frame_align (current_gdbarch, old_sp);
      if (sp == old_sp)
	{
	  if (INNER_THAN (1, 2))
	    /* Stack grows down.  */
	    sp = gdbarch_frame_align (current_gdbarch, old_sp - 1);
	  else
	    /* Stack grows up.  */
	    sp = gdbarch_frame_align (current_gdbarch, old_sp + 1);
	}
      gdb_assert ((INNER_THAN (1, 2) && sp <= old_sp)
		  || (INNER_THAN (2, 1) && sp >= old_sp));
    }
  else
    /* FIXME: cagney/2002-09-18: Hey, you loose!  Who knows how badly
       aligned the SP is!  Further, per comment above, if the generic
       dummy frame ends up empty (because nothing is pushed) GDB won't
       be able to correctly perform back traces.  If a target is
       having trouble with backtraces, first thing to do is add
       FRAME_ALIGN() to its architecture vector.  After that, try
       adding SAVE_DUMMY_FRAME_TOS() and modifying FRAME_CHAIN so that
       when the next outer frame is a generic dummy, it returns the
       current frame's base.  */
    sp = old_sp;
a1370 5
  /* NOTE: cagney/2002-09-10: Don't bother re-adjusting the stack
     after allocating space for the call dummy.  A target can specify
     a SIZEOF_DUMMY1 (via SIZEOF_CALL_DUMMY_WORDS) such that all local
     alignment requirements are met.  */

d1567 1
a1567 2
     stack, if necessary.  Make certain that the value is correctly
     aligned. */
d1579 1
a1579 2
	  /* Stack grows downward.  Align STRUCT_ADDR and SP after
             making space for the return value.  */
a1580 2
	  if (gdbarch_frame_align_p (current_gdbarch))
	    sp = gdbarch_frame_align (current_gdbarch, sp);
d1585 1
a1585 4
	  /* Stack grows upward.  Align the frame, allocate space, and
             then again, re-align the frame??? */
	  if (gdbarch_frame_align_p (current_gdbarch))
	    sp = gdbarch_frame_align (current_gdbarch, sp);
a1587 2
	  if (gdbarch_frame_align_p (current_gdbarch))
	    sp = gdbarch_frame_align (current_gdbarch, sp);
d1783 8
a1790 7
    /* elz: I defined this new macro for the hppa architecture only.
       this gives us a way to get the value returned by the function
       from the stack, at the same address we told the function to put
       it.  We cannot assume on the pa that r28 still contains the
       address of the returned structure. Usually this will be
       overwritten by the callee.  I don't know about other
       architectures, so I defined this macro */
d1798 6
a1803 20
    /* NOTE: cagney/2002-09-10: Only when the stack has been correctly
       aligned (using frame_align()) do we can trust STRUCT_ADDR and
       fetch the return value direct from the stack.  This lack of
       trust comes about because legacy targets have a nasty habit of
       silently, and local to PUSH_ARGUMENTS(), moving STRUCT_ADDR.
       For such targets, just hope that value_being_returned() can
       find the adjusted value.  */
    if (struct_return && gdbarch_frame_align_p (current_gdbarch))
      {
        struct value *retval = value_at (value_type, struct_addr, NULL);
        do_cleanups (retbuf_cleanup);
        return retval;
      }
    else
      {
	struct value *retval = value_being_returned (value_type, retbuf,
						     struct_return);
	do_cleanups (retbuf_cleanup);
	return retval;
      }
a2306 1
	  check_stub_method_group (type, i);
d2311 2
d2320 2
d2560 1
d2563 1
d2569 5
a2573 2
	  /* Resolve any stub methods.  */
	  check_stub_method_group (type, i);
a3098 2
	  check_stub_method_group (t, i);

d3112 2
@


1.59.4.8
log
@merge from mainline
@
text
@d3311 1
a3311 1
/* Return the value of the local variable, if one exists.
d3316 1
a3316 1
value_of_local (const char *name, int complain)
d3321 2
a3322 1
  struct value * ret;
d3336 1
a3336 1
	error ("no `%s' in nameless context", name);
d3346 1
a3346 1
	error ("no args, no `%s'", name);
d3353 1
a3353 1
  sym = lookup_block_symbol (b, name, NULL, VAR_NAMESPACE);
d3357 1
a3357 1
	error ("current stack frame does not contain a variable named `%s'", name);
d3362 4
a3365 17
  ret = read_var_value (sym, selected_frame);
  if (ret == 0 && complain)
    error ("`%s' argument unreadable", name);
  return ret;
}

/* C++/Objective-C: return the value of the class instance variable,
   if one exists.  Flag COMPLAIN signals an error if the request is
   made in an inappropriate context.  */

struct value *
value_of_this (int complain)
{
  if (current_language->la_language == language_objc)
    return value_of_local ("self", complain);
  else
    return value_of_local ("this", complain);
@


1.59.2.1
log
@regbuf
@
text
@d1675 1
a1675 1
    struct regbuf *retbuf = NULL;
d1707 1
a1707 1
    rc = run_stack_dummy (real_pc + CALL_DUMMY_START_OFFSET, &retbuf);
@


1.59.2.2
log
@regbuf->regcache
@
text
@d1675 1
a1675 1
    struct regcache *retbuf = NULL;
@


1.59.2.3
log
@merge from trunk
@
text
@d48 1
a48 2
static int typecmp (int staticp, int varargs, int nargs,
		    struct field t1[], struct value *t2[]);
d1441 10
a1450 1
  if (nargs < TYPE_NFIELDS (ftype))
d1455 10
a1464 1
      int prototyped;
d1466 5
a1470 6
      /* FIXME drow/2002-05-31: Should just always mark methods as
	 prototyped.  Can we respect TYPE_VARARGS?  Probably not.  */
      if (TYPE_CODE (ftype) == TYPE_CODE_METHOD)
	prototyped = 1;
      else
	prototyped = TYPE_PROTOTYPED (ftype);
a1471 3
      if (i < TYPE_NFIELDS (ftype))
	args[i] = value_arg_coerce (args[i], TYPE_FIELD_TYPE (ftype, i),
				    prototyped);
d1473 4
a1476 1
	args[i] = value_arg_coerce (args[i], NULL, 0);
d1488 1
a1488 1
	if (param_type && TYPE_CODE (ftype) != TYPE_CODE_METHOD)
d1941 4
a1944 4
   of types T1.  T1 is a list of NARGS arguments, and T2 is a NULL-terminated
   vector.  If some arguments need coercion of some sort, then the coerced
   values are written into T2.  Return value is 0 if the arguments could be
   matched, or the position at which they differ if not.
d1947 1
a1947 2
   static member function.  T2 will still include the ``this'' pointer,
   but it will be skipped.
d1956 1
a1956 2
typecmp (int staticp, int varargs, int nargs,
	 struct field t1[], struct value *t2[])
d1961 9
a1969 2
    internal_error (__FILE__, __LINE__, "typecmp: no argument list");

d1972 2
a1973 5
    t2 ++;

  for (i = 0;
       (i < nargs) && TYPE_CODE (t1[i].type) != TYPE_CODE_VOID;
       i++)
a1975 1

d1978 1
a1978 2

      tt1 = check_typedef (t1[i].type);
a1979 1

d2015 1
a2015 1
      if (TYPE_CODE (t1[i].type) != TYPE_CODE (VALUE_TYPE (t2[i])))
d2018 1
a2018 1
  if (varargs || t2[i] == NULL)
d2020 1
a2020 1
  return i + 1;
a2305 2
			      TYPE_VARARGS (TYPE_FN_FIELD_TYPE (f, j)),
			      TYPE_NFIELDS (TYPE_FN_FIELD_TYPE (f, j)),
d2757 7
a2763 1
	  nparms = TYPE_NFIELDS (TYPE_FN_FIELD_TYPE (fns_ptr, ix));
d2775 1
a2775 1
			  ? (TYPE_FN_FIELD_ARGS (fns_ptr, ix)[jj].type)
@


1.59.2.4
log
@Merge with trunk.
@
text
@d964 3
a966 3
    return value_at_lazy (builtin_type_int,
			  (CORE_ADDR) value_as_long (arg1),
			  VALUE_BFD_SECTION (arg1));
@


1.59.2.5
log
@merge with trunk.
@
text
@a1318 2
  char *retbuf;
  struct cleanup *retbuf_cleanup;
d1320 1
a1320 1
  struct cleanup *inf_status_cleanup;
a1335 10
  /* Create a cleanup chain that contains the retbuf (buffer
     containing the register values).  This chain is create BEFORE the
     inf_status chain so that the inferior status can cleaned up
     (restored or discarded) without having the retbuf freed.  */
  retbuf = xmalloc (REGISTER_BYTES);
  retbuf_cleanup = make_cleanup (xfree, retbuf);

  /* A cleanup for the inferior status.  Create this AFTER the retbuf
     so that this can be discarded or applied without interfering with
     the regbuf.  */
d1337 1
a1337 1
  inf_status_cleanup = make_cleanup_restore_inferior_status (inf_status);
d1659 1
d1691 1
a1691 1
    rc = run_stack_dummy (real_pc + CALL_DUMMY_START_OFFSET, retbuf);
d1718 5
a1722 6
	    /* If we restored the inferior status (via the cleanup),
	       we would print a spurious error message (Unable to
	       restore previously selected frame), would write the
	       registers from the inf_status (which is wrong), and
	       would do other wrong things.  */
	    discard_cleanups (inf_status_cleanup);
d1740 5
a1744 6
	/* If we restored the inferior status (via the cleanup), we
	   would print a spurious error message (Unable to restore
	   previously selected frame), would write the registers from
	   the inf_status (which is wrong), and would do other wrong
	   things.  */
	discard_cleanups (inf_status_cleanup);
d1764 1
a1764 4

    /* Restore the inferior status, via its cleanup.  At this stage,
       leave the RETBUF alone.  */
    do_cleanups (inf_status_cleanup);
d1777 1
a1777 4
      {
	do_cleanups (retbuf_cleanup);
	return VALUE_RETURNED_FROM_STACK (value_type, struct_addr);
      }
d1780 1
a1780 5
    {
      struct value *retval = value_being_returned (value_type, retbuf, struct_return);
      do_cleanups (retbuf_cleanup);
      return retval;
    }
@


1.58
log
@* arch-utils.h (legacy_register_to_value): Declare.
(legacy_value_to_register): Declare.
(legacy_convert_register_p): Declare.
* arch-utils.c (legacy_register_to_value): New function.
(legacy_value_to_register): New function.
(legacy_convert_register_p): New function.

* gdbarch.sh (REGISTER_TO_VALUE): Define.
(VALUE_TO_REGISTER): Define.
(CONVERT_REGISTER_P): Define.
* gdbarch.h, gdbarch.c: Regenerate.

* valops.c (value_assign): Use CONVERT_REGISTER_P and
VALUE_TO_REGISTER.
* findvar.c (value_from_register): Use REGISTER_TO_VALUE and
CONVERT_REGISTER_P.

* gdbint.texinfo (Target Architecture Definition): Document
REGISTER_TO_VALUE and VALUE_TO_REGISTER and CONVERT_REGISTER_P.
(Target Architecture Definition): Revise section `Using Different
Register and Memory Data Representations'.  Add section `Raw and
Virtual Register Representations'.
@
text
@d1491 1
a1491 1
	    if (TYPE_CODE (param_type->target_type) == TYPE_CODE_FUNC)
@


1.57
log
@2005-05-11  Daniel Jacobowitz  <drow@@mvista.com>
            Peter Schauer  <pes@@regent.e-technik.tu-muenchen.de>

        * Makefile.in: Update dependencies for valops.c.
        * valops.c: Include "gdb_assert.h".
        (typecmp): Skip THIS parameter to methods.
        (find_method_list): Remove static_memfuncp argument,
        update callers.  Check for stub methods.
        (find_value_oload_method_list): Don't set *static_memfuncp.
        (find_overload_match): Don't check for stub methods.  Assert
        that methods are not stubbed.  Handle static methods.
        (value_find_oload_method_list): Remove static_memfuncp argument.
        * gdbtypes.c (check_stub_method): Do not add THIS pointer
        to the argument list for static stub methods.
        * value.h (value_find_oload_method_list): Update prototype.
@
text
@d566 1
a566 1
      if (REGISTER_CONVERTIBLE (regno))
d569 1
a569 2
	  REGISTER_CONVERT_TO_RAW (fromtype, regno,
				   VALUE_CONTENTS (fromval), raw_buffer);
@


1.56
log
@2002-05-02  Elena Zannoni  <ezannoni@@redhat.com>

	* valops.c (value_arg_coerce): Don't coerce arrays to pointers if
	we are dealing with vectors.
@
text
@d39 1
d70 1
a70 1
					  int offset, int *static_memfuncp,
d1967 2
d1971 3
a1973 2
  if (t1[!staticp] == 0)
    return 0;
d2527 1
a2527 1
		  int *static_memfuncp, struct type *type, int *num_fns,
d2543 6
a2548 1
	  *num_fns = TYPE_FN_FIELDLIST_LENGTH (type, i);
d2551 8
a2558 1
	  return TYPE_FN_FIELDLIST1 (type, i);
d2598 2
a2599 1
      static_memfuncp, TYPE_BASECLASS (type, i), num_fns, basetype, boffset);
d2617 2
a2618 2
			      int *static_memfuncp, int *num_fns,
			      struct type **basetype, int *boffset)
d2641 1
a2641 6
  /* Assume it's not static, unless we see that it is.  */
  if (static_memfuncp)
    *static_memfuncp = 0;

  return find_method_list (argp, method, 0, static_memfuncp, t, num_fns, basetype, boffset);

d2700 1
a2707 3
      int i;
      int len;
      struct type *domain;
a2715 1
					      staticp,
d2723 4
a2726 20
      domain = TYPE_DOMAIN_TYPE (fns_ptr[0].type);
      len = TYPE_NFN_FIELDS (domain);
      /* NOTE: dan/2000-03-10: This stuff is for STABS, which won't
         give us the info we need directly in the types. We have to
         use the method stub conversion to get it. Be aware that this
         is by no means perfect, and if you use STABS, please move to
         DWARF-2, or something like it, because trying to improve
         overloading using STABS is really a waste of time. */
      for (i = 0; i < len; i++)
	{
	  int j;
	  struct fn_field *f = TYPE_FN_FIELDLIST1 (domain, i);
	  int len2 = TYPE_FN_FIELDLIST_LENGTH (domain, i);

	  for (j = 0; j < len2; j++)
	    {
	      if (TYPE_FN_FIELD_STUB (f, j) && (!strcmp_iw (TYPE_FN_FIELDLIST_NAME (domain,i),name)))
		check_stub_method (domain, i, j);
	    }
	}
d2753 1
d2756 2
a2757 2
	  /* For static member functions, we won't have a this pointer, but nothing
	     else seems to handle them right now, so we just pretend ourselves */
d2779 4
a2782 2
      /* Compare parameter types to supplied argument types */
      bv = rank_function (parm_types, nparms, arg_types, nargs);
d2820 1
a2820 1
	  for (jj = 0; jj < nargs; jj++)
d2843 5
a2847 2
  /* Check how bad the best match is */
  for (ix = 1; ix <= nargs; ix++)
d2880 4
@


1.55
log
@* valops.c (hand_function_call): Call
generic_save_call_dummy_addr.
* frame.h (generic_save_call_dummy_addr): Declare.
* blockframe.c (struct dummy_frame): Add fields call_lo and
call_hi.
(generic_find_dummy_frame): Check for PC in range call_lo to
call_hi instead of entry_point_address.
(generic_pc_in_call_dummy): Search the dummy frames for a PC in
the call_lo to call_hi range.  Allow for DECR_PC_AFTER_BREAK.
(generic_save_call_dummy_addr): New function.
@
text
@d1193 3
d1197 2
a1198 1
	type = lookup_pointer_type (TYPE_TARGET_TYPE (type));
@


1.54
log
@* findvar.c (extract_signed_integer): Cast printf argument
to suppress format warning.
(extract_unsigned_integer): Likewise.
* infcmd.c (registers_info): Likewise.
* top.c (get_prompt_1): Likewise.
* valops.c (value_assign): Likewise.
* valprint.c (print_decimal): Likewise.
@
text
@d1388 2
d1406 2
d1419 2
d1426 5
@


1.53
log
@2002-03-22  Daniel Jacobowitz  <drow@@mvista.com>

        * symtab.h (lookup_block_symbol): Add mangled_name argument
        to prototype.

        * symmisc.c (maintenance_check_symtabs): Call lookup_block_symbol
        with new mangled_name argument.
        * linespec.c (decode_line_1): Likewise.
        * valops (value_of_this): Likewise.
        * symtab.c (lookup_transparent_type): Likewise.
        (lookup_symbol_aux): Likewise.  Accept new mangled_name argument.
        (lookup_symbol): If we are given a mangled name, pass it down
        to lookup_symbol_aux.
        (lookup_block_symbol): If we are given a mangled name to check
        against, only return symbols which match it.
@
text
@d610 1
a610 1
		     sizeof (LONGEST) * HOST_CHAR_BIT);
d647 1
a647 1
		   sizeof (LONGEST) * HOST_CHAR_BIT);
@


1.52
log
@2002-02-16  Daniel Jacobowitz  <drow@@mvista.com>

        * valarith.c (value_x_unop): Fix decrement; support post-decrement.

2002-02-16  Daniel Jacobowitz  <drow@@mvista.com>

        From Peter Schauer <Peter.Schauer@@Regent.E-Technik.TU-Muenchen.DE>:
        * valops.c (value_arg_coerce): Don't take the address of a reference
        to convert an argument to a reference.
@
text
@d3253 1
a3253 1
  sym = lookup_block_symbol (b, funny_this, VAR_NAMESPACE);
@


1.51
log
@* valops.c (PUSH_ARGUMENTS): Delete definition.
* gdbarch.sh (PUSH_ARGUMENTS): Don't require when multi-arch
partial.  Default to default_push_arguments.
* gdbarch.h, gdbarch.c: Regenerate.
@
text
@d1152 2
a1153 1
      if (TYPE_CODE (arg_type) != TYPE_CODE_REF)
@


1.50
log
@2002-02-03  Daniel Jacobowitz  <drow@@mvista.com>

        * c-valprint.c (c_val_print): Pass a proper valaddr to
        cp_print_class_method.
        * valops.c (search_struct_method): If there is only one method
        and args is NULL, return that method.
@
text
@a1080 4
#ifndef PUSH_ARGUMENTS
#define PUSH_ARGUMENTS default_push_arguments
#endif

@


1.49
log
@2002-01-07  Michael Snyder  <msnyder@@redhat.com>

	* cp-valprint.c (cp_print_value): FIXME comment, alloca size.
	* p-valprint.c (pascal_object_print_value): Ditto.
	* somread.c (som_symtab_read): Ditto.
	* symfile.c (simple_free_overlay_region_table): Ditto.
	* valops.c (value_assign): Ditto.
@
text
@d2277 1
a2277 1
	  while (j >= 0)
d2281 3
a2283 12
	      if (!typecmp (TYPE_FN_FIELD_STATIC_P (f, j),
			    TYPE_FN_FIELD_ARGS (f, j), args))
		{
		  if (TYPE_FN_FIELD_VIRTUAL_P (f, j))
		    return value_virtual_fn_field (arg1p, f, j, type, offset);
		  if (TYPE_FN_FIELD_STATIC_P (f, j) && static_memfuncp)
		    *static_memfuncp = 1;
		  v = value_fn_field (arg1p, f, j, type, offset);
		  if (v != NULL)
		    return v;       
		}
	      j--;
d2285 18
@


1.48
log
@* valops.c (value_arg_coerce): Fix formatting.
@
text
@d700 1
@


1.47
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@d1145 2
a1146 1
value_arg_coerce (struct value *arg, struct type *param_type, int is_prototyped)
d1150 1
a1150 1
  = param_type ? check_typedef (param_type) : arg_type;
@


1.46
log
@2002-01-04  Daniel Jacobowitz  <drow@@mvista.com>

        * valops.c (find_overload_match): Accept obj as a
        reference parameter.  Update it before returning.
        * value.h (find_overload_match): Update prototype.
        * eval.c (evaluate_subexp_standard): Pass object to
        find_overload_match by reference.
@
text
@d1059 1
a1059 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
@


1.45
log
@s/value_ptr/struct value */
@
text
@d2639 1
a2639 1
		     int lax, struct value *obj, struct symbol *fsym,
d2645 1
d2869 9
@


1.44
log
@Approved by Jim Blandy:

	2001-12-11  Fred Fish  <fnf@@redhat.com>
	* c-typeprint.c (c_type_print_base): Use type flags access macros
	to test bits.
	* ch-typeprint.c (chill_type_print_base): Ditto.
	* ch-valprint.c (chill_val_print): Ditto.
	* d10v-tdep.c (d10v_pointer_to_address): Ditto.
	* dwarf2read.c (dwarf2_add_member_fn): Ditto.
	* dwarfread.c (read_structure_scope): Ditto.
	* gdbtypes.c (create_range_type): Dittol
	(create_set_type): Ditto.
	(check_typedef): Ditto.
	* jv-typeprint.c (java_type_print_base): Ditto.
	* p-typeprint.c (pascal_type_print_base): Ditto
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (read_cfront_member_functions): Ditto.
	(read_member_functions): Ditto.
	(cleanup_undefined_types): Ditto.
	* valprint.c (val_print): Ditto.
	* valops.c (hand_function_call): Remove is_prototyped
	variable and just use type flag test macro directly.
@
text
@d2 3
a4 2
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d47 1
a47 1
static int typecmp (int staticp, struct type *t1[], value_ptr t2[]);
d49 2
a50 2
static CORE_ADDR find_function_addr (value_ptr, struct type **);
static value_ptr value_arg_coerce (value_ptr, struct type *, int);
d53 1
a53 1
static CORE_ADDR value_push (CORE_ADDR, value_ptr);
d55 1
a55 1
static value_ptr search_struct_field (char *, value_ptr, int,
d58 2
a59 2
static value_ptr search_struct_method (char *, value_ptr *,
				       value_ptr *,
d66 1
a66 1
static value_ptr cast_into_complex (struct type *, value_ptr);
d68 1
a68 1
static struct fn_field *find_method_list (value_ptr * argp, char *method,
d95 1
a95 1
value_ptr
d135 1
a135 1
value_ptr
d138 2
a139 2
  value_ptr blocklen;
  register value_ptr val = find_function_in_inferior ("malloc");
d164 2
a165 2
value_ptr
value_cast (struct type *type, register value_ptr arg2)
d245 1
a245 1
      value_ptr v = search_struct_field (type_name_no_tag (type),
d265 1
a265 1
	  value_ptr retvalp;
d335 1
a335 1
	      value_ptr v;
d362 1
a362 1
		      value_ptr v2 = value_ind (arg2);
d387 1
a387 1
      value_ptr val;
d445 1
a445 1
value_ptr
d448 1
a448 1
  register value_ptr val = allocate_value (type);
d468 1
a468 1
value_ptr
d471 1
a471 1
  register value_ptr val;
d489 1
a489 1
value_ptr
d492 1
a492 1
  register value_ptr val;
d520 1
a520 1
value_fetch_lazy (register value_ptr val)
d537 2
a538 2
value_ptr
value_assign (register value_ptr toval, register value_ptr fromval)
d541 1
a541 1
  register value_ptr val;
d802 2
a803 2
value_ptr
value_repeat (value_ptr arg1, int count)
d805 1
a805 1
  register value_ptr val;
d823 1
a823 1
value_ptr
d826 1
a826 1
  value_ptr val;
d875 2
a876 2
value_ptr
value_coerce_array (value_ptr arg1)
d890 2
a891 2
value_ptr
value_coerce_function (value_ptr arg1)
d893 1
a893 1
  value_ptr retval;
d906 2
a907 2
value_ptr
value_addr (value_ptr arg1)
d909 1
a909 1
  value_ptr arg2;
d944 2
a945 2
value_ptr
value_ind (value_ptr arg1)
d948 1
a948 1
  value_ptr arg2;
d1047 1
a1047 1
value_push (register CORE_ADDR sp, value_ptr arg)
d1085 1
a1085 1
default_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
d1144 2
a1145 2
static value_ptr
value_arg_coerce (value_ptr arg, struct type *param_type, int is_prototyped)
d1221 1
a1221 1
find_function_addr (value_ptr function, struct type **retval_type)
d1287 2
a1288 4
static value_ptr hand_function_call (value_ptr function, int nargs,
				     value_ptr * args);
static value_ptr
hand_function_call (value_ptr function, int nargs, value_ptr *args)
d1779 1
a1779 1
      return (value_ptr) VALUE_RETURNED_FROM_STACK (value_type, struct_addr);
d1786 2
a1787 2
value_ptr
call_function_by_hand (value_ptr function, int nargs, value_ptr *args)
d1811 2
a1812 2
value_ptr
value_array (int lowbound, int highbound, value_ptr *elemvec)
d1817 1
a1817 1
  value_ptr val;
d1883 1
a1883 1
value_ptr
d1886 1
a1886 1
  value_ptr val;
d1913 1
a1913 1
value_ptr
d1916 1
a1916 1
  value_ptr val;
d1942 1
a1942 1
typecmp (int staticp, struct type *t1[], value_ptr t2[])
d2014 2
a2015 2
static value_ptr
search_struct_field (char *name, register value_ptr arg1, int offset,
d2030 1
a2030 1
	    value_ptr v;
d2058 1
a2058 1
		value_ptr v;
d2081 1
a2081 1
      value_ptr v;
d2093 1
a2093 1
	  value_ptr v2 = allocate_value (basetype);
d2175 1
a2175 1
  value_ptr vp;
d2243 3
a2245 3
static value_ptr
search_struct_method (char *name, register value_ptr *arg1p,
		      register value_ptr *args, int offset,
d2249 1
a2249 1
  value_ptr v;
d2348 1
a2348 1
      if (v == (value_ptr) - 1)
d2360 1
a2360 1
    return (value_ptr) - 1;
d2379 2
a2380 2
value_ptr
value_struct_elt (register value_ptr *argp, register value_ptr *args,
d2384 1
a2384 1
  value_ptr v;
d2430 1
a2430 1
      if (v == (value_ptr) - 1)
d2468 1
a2468 1
  if (v == (value_ptr) - 1)
d2499 1
a2499 1
find_method_list (value_ptr *argp, char *method, int offset,
d2576 1
a2576 1
value_find_oload_method_list (value_ptr *argp, char *method, int offset,
d2639 2
a2640 2
		     int lax, value_ptr obj, struct symbol *fsym,
		     value_ptr *valp, struct symbol **symp, int *staticp)
d2656 1
a2656 1
  value_ptr temp = obj;
d2944 1
a2944 1
check_field (register value_ptr arg1, const char *name)
d2979 1
a2979 1
value_ptr
d2986 1
a2986 1
  value_ptr v;
d3094 1
a3094 1
      value_ptr v;
d3119 1
a3119 1
value_rtti_target_type (value_ptr v, int *full, int *top, int *using_enc)
d3121 1
a3121 1
  value_ptr target;
d3138 2
a3139 2
value_ptr
value_full_object (value_ptr argp, struct type *rtype, int xfull, int xtop,
d3146 1
a3146 1
  value_ptr new_val;
d3197 1
a3197 1
value_ptr
d3204 1
a3204 1
  value_ptr this;
d3254 2
a3255 2
value_ptr
value_slice (value_ptr array, int lowbound, int length)
d3259 1
a3259 1
  value_ptr slice;
d3333 2
a3334 2
value_ptr
varying_to_slice (value_ptr varray)
d3349 2
a3350 2
value_ptr
value_literal_complex (value_ptr arg1, value_ptr arg2, struct type *type)
d3352 1
a3352 1
  register value_ptr val;
d3368 2
a3369 2
static value_ptr
cast_into_complex (struct type *type, register value_ptr val)
d3375 2
a3376 2
      value_ptr re_val = allocate_value (val_real_type);
      value_ptr im_val = allocate_value (val_real_type);
@


1.43
log
@Undo accidental commit of a separate patch.
@
text
@a1460 1
	  int is_prototyped = TYPE_FLAGS (ftype) & TYPE_FLAG_PROTOTYPED;
d1462 1
a1462 2

	  args[i] = value_arg_coerce (args[i], param_type, is_prototyped);
@


1.42
log
@        * valops.c (hand_function_call): Check for method arguments in
        TYPE_ARG_TYPES(), not in TYPE_FIELD ().
@
text
@d2642 1
a2642 1
		     int lax, value_ptr *objp, struct symbol *fsym,
a2647 1
  struct value *obj = (objp ? *objp : NULL);
a2870 9
  if (objp)
    {
      if (TYPE_CODE (VALUE_TYPE (temp)) != TYPE_CODE_PTR
	  && TYPE_CODE (VALUE_TYPE (*objp)) == TYPE_CODE_PTR)
	{
	  temp = value_addr (temp);
	}
      *objp = temp;
    }
@


1.41
log
@* valops.c (default_coerce_float_to_double,
standard_coerce_float_to_double): Doc fixes.
@
text
@d1323 1
d1428 10
a1437 1
  if (nargs < TYPE_NFIELDS (ftype))
d1442 11
d2642 1
a2642 1
		     int lax, value_ptr obj, struct symbol *fsym,
d2648 1
d2872 9
@


1.40
log
@Add predicate for PUSH_RETURN_ADDRESS.
@
text
@d1095 28
a1122 10
/* A default function for COERCE_FLOAT_TO_DOUBLE: do the coercion only
   when we don't have any type for the argument at hand.  This occurs
   when we have no debug info, or when passing varargs.

   This is an annoying default: the rule the compiler follows is to do
   the standard promotions whenever there is no prototype in scope,
   and almost all targets want this behavior.  But there are some old
   architectures which want this odd behavior.  If you want to go
   through them all and fix them, please do.  Modern gdbarch-style
   targets may find it convenient to use standard_coerce_float_to_double.  */
a1129 4
/* Always coerce floats to doubles when there is no prototype in scope.
   If your architecture follows the standard type promotion rules for
   calling unprototyped functions, your gdbarch init function can pass
   this function to set_gdbarch_coerce_float_to_double to use its logic.  */
@


1.39
log
@* value.h (value_as_address): Rename value_as_pointer.
* eval.c, findvar.c, gnu-v2-abi.c, gnu-v3-abi.c, jv-lang.c,
jv-valprint.c, printcmd.c, stack.c, top.c, valarith.c, valops.c,
values.c: Update.
@
text
@d1573 12
a1584 12
#ifdef PUSH_RETURN_ADDRESS	/* for targets that use no CALL_DUMMY */
  /* There are a number of targets now which actually don't write any
     CALL_DUMMY instructions into the target, but instead just save the
     machine state, push the arguments, and jump directly to the callee
     function.  Since this doesn't actually involve executing a JSR/BSR
     instruction, the return address must be set up by hand, either by
     pushing onto the stack or copying into a return-address register
     as appropriate.  Formerly this has been done in PUSH_ARGUMENTS,
     but that's overloading its functionality a bit, so I'm making it
     explicit to do it here.  */
  sp = PUSH_RETURN_ADDRESS (real_pc, sp);
#endif /* PUSH_RETURN_ADDRESS */
@


1.38
log
@Clean up the D10V port so that GDB and the target program no
longer disagree on how big pointers are.
* findvar.c (value_from_register): Remove special case code for D10V.
* printcmd.c (print_frame_args): Same.
* valops.c (value_at, value_fetch_lazy): Same.
* values.c (unpack_long): Same.
* gdbarch.sh: Changes to effect the following:
* gdbarch.h (GDB_TARGET_IS_D10V, D10V_MAKE_DADDR,
gdbarch_d10v_make_daddr_ftype, gdbarch_d10v_make_daddr,
set_gdbarch_d10v_make_daddr, D10V_MAKE_IADDR,
gdbarch_d10v_make_iaddr_ftype, gdbarch_d10v_make_iaddr,
set_gdbarch_d10v_make_iaddr, D10V_DADDR_P,
gdbarch_d10v_daddr_p_ftype, gdbarch_d10v_daddr_p,
set_gdbarch_d10v_daddr_p, D10V_IADDR_P,
gdbarch_d10v_iaddr_p_ftype, gdbarch_d10v_iaddr_p,
set_gdbarch_d10v_iaddr_p, D10V_CONVERT_DADDR_TO_RAW,
gdbarch_d10v_convert_daddr_to_raw_ftype,
gdbarch_d10v_convert_daddr_to_raw,
set_gdbarch_d10v_convert_daddr_to_raw, D10V_CONVERT_IADDR_TO_RAW,
gdbarch_d10v_convert_iaddr_to_raw_ftype,
gdbarch_d10v_convert_iaddr_to_raw,
set_gdbarch_d10v_convert_iaddr_to_raw): Delete declarations.
* gdbarch.c: Delete the corresponding definitions.
(struct gdbarch): Delete members d10v_make_daddr,
d10v_make_iaddr, d10v_daddr_p, d10v_iaddr_p,
d10v_convert_daddr_to_raw, and d10v_convert_iaddr_to_raw.
(startup_gdbarch): Remove initializers for the above.
(verify_gdbarch, gdbarch_dump): Don't verify or dump them any
more.
* d10v-tdep.c (d10v_register_virtual_type): Rather that
claiming the stack pointer and PC are 32 bits long (which they
aren't), say that the stack pointer is an int16_t, and the
program counter is a function pointer.  This allows the rest
of GDB to make the appropriate conversions between the code
pointer format and real addresses.
(d10v_register_convertible, d10v_register_convert_to_virtual,
d10v_register_convert_to_raw): Delete function; no registers
are convertible now, so we use
generic_register_convertible_not instead.
(d10v_address_to_pointer, d10v_pointer_to_address): New gdbarch
methods.
(d10v_push_arguments, d10v_extract_return_value): Remove special
cases for code and data pointers.
(d10v_gdbarch_init): Set gdbarch_ptr_bit to 16, so that GDB and
the target agree on how large pointers are.  Say that addresses
are 32 bits long.  Register the address_to_pointer and
pointer_to_address conversion functions.  Since no registers are
convertible now, register generic_register_convertible_not as the
gdbarch_register_convertible method instead of
d10v_register_convertible.  Remove registrations for
d10v_register_convert_to_virtual,
d10v_register_convert_to_raw, gdbarch_d10v_make_daddr,
gdbarch_d10v_make_iaddr, gdbarch_d10v_daddr_p,
gdbarch_d10v_iaddr_p, gdbarch_d10v_convert_daddr_to_raw, and
gdbarch_d10v_convert_iaddr_to_raw.
@
text
@d973 1
a973 1
		   value_as_pointer (arg1) - VALUE_POINTED_TO_OFFSET (arg1),
d1224 1
a1224 1
      funaddr = value_as_pointer (function);
d1240 1
a1240 1
	funaddr = value_as_pointer (value_addr (function));
@


1.37
log
@* valops.c (value_cast): When casting a pointer to an integer,
don't convert it to an address.
@
text
@d477 1
a477 24
  if (GDB_TARGET_IS_D10V
      && TYPE_CODE (type) == TYPE_CODE_PTR
      && TYPE_TARGET_TYPE (type)
      && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC))
    {
      /* pointer to function */
      unsigned long num;
      unsigned short snum;
      snum = read_memory_unsigned_integer (addr, 2);
      num = D10V_MAKE_IADDR (snum);
      store_address (VALUE_CONTENTS_RAW (val), 4, num);
    }
  else if (GDB_TARGET_IS_D10V
	   && TYPE_CODE (type) == TYPE_CODE_PTR)
    {
      /* pointer to data */
      unsigned long num;
      unsigned short snum;
      snum = read_memory_unsigned_integer (addr, 2);
      num = D10V_MAKE_DADDR (snum);
      store_address (VALUE_CONTENTS_RAW (val), 4, num);
    }
  else
    read_memory (addr, VALUE_CONTENTS_ALL_RAW (val), TYPE_LENGTH (type));
d525 1
a525 23
  if (GDB_TARGET_IS_D10V
      && TYPE_CODE (type) == TYPE_CODE_PTR
      && TYPE_TARGET_TYPE (type)
      && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_FUNC))
    {
      /* pointer to function */
      unsigned long num;
      unsigned short snum;
      snum = read_memory_unsigned_integer (addr, 2);
      num = D10V_MAKE_IADDR (snum);
      store_address (VALUE_CONTENTS_RAW (val), 4, num);
    }
  else if (GDB_TARGET_IS_D10V
	   && TYPE_CODE (type) == TYPE_CODE_PTR)
    {
      /* pointer to data */
      unsigned long num;
      unsigned short snum;
      snum = read_memory_unsigned_integer (addr, 2);
      num = D10V_MAKE_DADDR (snum);
      store_address (VALUE_CONTENTS_RAW (val), 4, num);
    }
  else if (length)
@


1.36
log
@2001-05-07  Daniel Berlin  <dan@@cgsoftware.com>

	Changes by Jim Ingham:

	* values.c (value_change_enclosing_type): New function.  If the
	new enclosing type is larger than the old one, we need to allocate
	more space.
	* value.h: Add value_change_enclosing_type prototype.
	* valops.c (value_cast): Use it.
	(value_assign): Use it.
	(value_addr): Use it.
	(value_ind): Use it.
	(value_full_object): Use it.

2001-05-07  Daniel Berlin  <dan@@cgsoftware.com>

	* values.c (value_static_field): Handle static fields that have a constant value.
@
text
@d284 12
a295 1
      longest = value_as_long (arg2);
@


1.36.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@a32 1
#include "cp-abi.h"
a45 6
enum looking_for_baseclass_type
  {
    no_baseclass,
    only_baseclass,
    struct_or_baseclass
  };
d53 5
a57 8
static value_ptr
search_struct_field (const char *, value_ptr, int, struct type *,
		     enum looking_for_baseclass_type, char *);
static value_ptr
search_struct_field_aux (const char *, value_ptr, int, struct type *,
			 enum looking_for_baseclass_type,
			 int *, char *, struct type **, char *);
static value_ptr search_struct_method (const char *, value_ptr *,
d116 1
a116 1
	  type = (struct type *)make_function_type (NULL, type, 0, NULL, 0);
d186 1
a186 1
      struct type *element_type = ARRAY_ELEMENT_TYPE (type);
d188 2
a189 3
#if TYPEFIX
      if (current_language->la_language == language_fortran && element_length > 0
	&& TYPE_ARRAY_UPPER_BOUND_TYPE (type) == BT_cannot_be_determined)
d199 1
a199 1
	  /* TYPEFIX-type-allocation: need a way to free this type when we are
a208 1
#endif
d245 1
a245 1
					 arg2, 0, type2, only_baseclass, 0);
d266 1
a266 1
	  switch (TYPE_CODE (POINTER_TARGET_TYPE (type2)))
d317 2
a318 2
	  struct type *t1 = check_typedef (POINTER_TARGET_TYPE (type));
	  struct type *t2 = check_typedef (POINTER_TARGET_TYPE (type2));
d331 1
a331 1
					   value_ind (arg2), 0, t2, only_baseclass, 0);
d347 1
a347 1
				       value_zero (t1, not_lval), 0, t1, only_baseclass, 0);
a371 1
#if TYPEFIX
a414 1
#endif
d468 2
a469 2
      && POINTER_TARGET_TYPE (type)
      && (TYPE_CODE (POINTER_TARGET_TYPE (type)) == TYPE_CODE_FUNC))
d539 2
a540 2
      && POINTER_TARGET_TYPE (type)
      && (TYPE_CODE (POINTER_TARGET_TYPE (type)) == TYPE_CODE_FUNC))
d1004 1
a1004 1
      enc_type = POINTER_TARGET_TYPE (enc_type);
d1010 1
a1010 1
      VALUE_TYPE (arg2) = POINTER_TARGET_TYPE (base_type);
d1214 1
a1214 1
	type = lookup_pointer_type (ARRAY_ELEMENT_TYPE (type));
d1251 1
a1251 6
  if (code == TYPE_CODE_FUNC)
    {
      funaddr = VALUE_ADDRESS (function);
      value_type = FUNCTION_RETURN_VALUE (ftype);
    }
  else if (code == TYPE_CODE_METHOD)
d1259 3
a1261 7
      ftype = check_typedef (POINTER_TARGET_TYPE (ftype));
      if (TYPE_CODE (ftype) == TYPE_CODE_FUNC)
	{
	  funaddr =CONVERT_FROM_FUNC_PTR_ADDR (funaddr);
	  value_type = FUNCTION_RETURN_VALUE (ftype);
	}
      else if (TYPE_CODE (ftype) == TYPE_CODE_METHOD)
d1479 1
a1479 1
	    if (TYPE_CODE (POINTER_TARGET_TYPE(param_type)) == TYPE_CODE_FUNC)
d1820 1
a1820 1
  struct range_type *rangetype;
d1841 1
a1841 1
  rangetype = make_range_type (NULL, builtin_type_int,
d1843 1
a1843 1
  arraytype = (struct type *)make_array_type (NULL,  
d1890 5
a1894 3
  struct range_type *rangetype = make_range_type (NULL, builtin_type_int,
						  lowbound, len + lowbound - 1);
  struct type *stringtype = (struct type *)make_string_type (NULL, rangetype);
d1919 3
a1921 2
  struct range_type *domain_type = make_range_type (NULL, builtin_type_int, 0, len - 1);
  struct type *type = (struct type *)make_set_type (NULL, domain_type);
d1985 1
a1985 1
	  tt1 = check_typedef( POINTER_TARGET_TYPE(tt1) );
d1991 1
a1991 4
	  while (TYPE_CODE (tt2) == TYPE_CODE_REF || TYPE_CODE (tt2) == TYPE_CODE_PTR)
	    tt2 = check_typedef (POINTER_TARGET_TYPE (tt2));
	  while (TYPE_CODE (tt2) == TYPE_CODE_ARRAY)
	    tt2 = check_typedef (ARRAY_ELEMENT_TYPE (tt2));
d2013 2
a2014 8
   looking_for_baseclass has three possible values :
   1) no_baseclass : look for structure field. 
   2) only_baseclass : look for baseclass named NAME.
   3) struct_or_baseclass : look for structure field first, and then
   the baseclass named NAME. Return the first
   structure field if it is found.
   The value is used when hp_som_som_object_present
   is true. */
d2017 2
a2018 39
search_struct_field (name, arg1, offset, type, looking_for_baseclass,
                     domain_name)
     const char *name;
     register value_ptr arg1;
     int offset;
     register struct type *type;
     enum looking_for_baseclass_type looking_for_baseclass;
     char *domain_name;
{
  int found = 0;
  char found_class[1024];
  value_ptr v;
  struct type *vbase = NULL;

  found_class[0] = '\000';

  v = search_struct_field_aux (name, arg1, offset, type,
			       looking_for_baseclass, &found,
			       found_class, &vbase, domain_name);
  if (found > 1)
    warning ("%s ambiguous; using %s::%s. Use a cast to disambiguate.",
             name, found_class, name);

  return v;
}

static value_ptr
search_struct_field_aux (name, arg1, offset, type,
			 looking_for_baseclass, found,
			 found_class_name, vbase, domain_name)
     const char *name;
     value_ptr arg1;
     int offset;
     register struct type *type;
     enum looking_for_baseclass_type looking_for_baseclass;
     int *found;
     char *found_class_name;
     struct type **vbase;
     char *domain_name;
a2020 4
  value_ptr retval = NULL;
  char tmp_class_name[1024];
  int tmp_found = 0;
  int assigned = 0;
a2022 2
  tmp_class_name[0] = '\000';

d2025 1
a2025 2
  if (looking_for_baseclass == no_baseclass ||
       looking_for_baseclass == struct_or_baseclass)
d2032 1
a2032 1
	    value_ptr v = NULL;
a2034 15
            if (v != NULL)
              {
                if (!*found)
                  {
                    /* Record return value and class name, and continue
                       looking for possible ambiguous members */
                    char *class_name = TYPE_TAG_NAME (type);
                    retval = v;
                    if (class_name)
                      strcpy (found_class_name, class_name);
                    else
                      found_class_name = NULL;
                  }
                (*found)++;
              }
d2036 5
a2040 29
	      {
		char *fullname = (domain_name ?
				  (strncmp (domain_name, "data member of", 14) ?
				   NULL : &domain_name[15])
				  : NULL );
		if (!fullname || !strcmp(TYPE_TAG_NAME(type), fullname))
		  {
		    v = value_primitive_field (arg1, offset, i, type);
                    if (v != NULL)
                      {
                        if (!*found)
                          {
                            /* Record return value and class name, and continue
                               looking for possible ambiguous members */
                            char *class_name = TYPE_TAG_NAME (type);
                            retval = v;
                            if (class_name)
                              strcpy (found_class_name, class_name);
                            else
                              found_class_name = NULL;
                          }
                        (*found)++;
                      }
                  }
              }

            if (v == 0 && looking_for_baseclass != struct_or_baseclass)
              error ("Couldn't retrieve field named %s", name);
          }
d2073 6
a2078 22
		v = search_struct_field_aux (name, arg1, new_offset,
					     field_type,
					     looking_for_baseclass,
					     &tmp_found, tmp_class_name,
					     vbase, domain_name);
                if (!*found && v)
                  {
                    /* Record return value and class name, and continue
                       looking for possible ambiguous members */
                    retval = v;
                    /* TYPE_TAG_NAME can be null in case of an anonymous union */
                    if (TYPE_TAG_NAME (type))
                      strcpy (found_class_name, TYPE_TAG_NAME (type));
                    else
                      strcpy (found_class_name, " ");
                    strcat (found_class_name, "::");
                    strcat (found_class_name, tmp_class_name);
                  }
                *found += tmp_found;
                tmp_found = 0;
              }
          }
a2080 10
  /* Return the structure field if it is found. */
  if (*found > 0 && looking_for_baseclass == struct_or_baseclass)
    return retval;

  /* RM: If we are looking for a structure field, and we have found
     one, don't look through the baseclasses -- names there are
     hidden. ANSI C++ standard, section 10.2 */
  if (*found > 0 && looking_for_baseclass == no_baseclass)
    return retval;

d2095 1
a2095 1
	  value_ptr v2 = allocate_value (VALUE_ENCLOSING_TYPE (arg1));
d2098 1
a2098 1
				      &arg1, VALUE_CONTENTS (arg1) + offset,
d2100 1
a2100 1
				      + VALUE_OFFSET (arg1) + offset, offset);
d2113 1
a2113 1
	      base_addr = VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1)  + boffset;
a2118 1
	      assigned = 1;
d2132 6
a2137 81
#if 0
          if (!assigned)
            {
              VALUE_LVAL (v2) = VALUE_LVAL (arg1);
              VALUE_ADDRESS (v2) = VALUE_ADDRESS (arg1);
            }
          /* Earlier, this code used to allocate a value of type
             basetype and copy the contents of arg1 at the
             appropriate offset into the new value.  This doesn't
             work because there is important stuff (virtual bases,
             for example) that could be anywhere in the contents
             of arg1, and not just within the length of a basetype
             object.  In particular the boffset below could be
             negative, with the HP/Taligent C++ runtime system.
             So, the only way to ensure that required information
             is not lost is to always allocate a value of the same
             type as arg1 and to fill it with the _entire_
             contents of arg1.  It sounds wasteful, but there is
             really no way around it if later member lookup,
             casts, etc. have to work correctly with the returned
             value.  */


          VALUE_TYPE (v2) = basetype;
          VALUE_OFFSET (v2) = VALUE_OFFSET (arg1);
          VALUE_EMBEDDED_OFFSET (v2)
            = VALUE_EMBEDDED_OFFSET (arg1) + offset + boffset;
          if (VALUE_LAZY (arg1))
            VALUE_LAZY (v2) = 1;
          else
            memcpy ((char *) (v2)->aligner.contents,
                    (char *) (arg1)->aligner.contents,
                    TYPE_LENGTH (VALUE_ENCLOSING_TYPE (arg1)));
#endif
          if (found_baseclass)
            {
              /*return v2; */

              if (!*found)      /* not yet found anything */
                {
                  /* Record return value and class name, and continue
                     looking for possible ambiguous members */
                  retval = v2;
                  strcpy (found_class_name, TYPE_TAG_NAME (type));
                }
              /* Don't count virtual bases twice when deciding ambiguity */
              if (*vbase != basetype)   /* works for null *vbase */
                (*found)++;
              /* Is this the first virtual base where we "found" something? */
              if (!*vbase)
                *vbase = basetype;
            }
          else
            /* base not found, or looking for member */
            {
              v = search_struct_field_aux (name, /*arg1*/v2, 0/*offset + boffset*/,
                                           TYPE_BASECLASS (type, i),
                                           looking_for_baseclass, &tmp_found,
                                        tmp_class_name, vbase, domain_name);
              if (!*found && v)
                {
                  /* Record return value and class name, and continue
                     looking for possible ambiguous members */
                  retval = v;
                  /* TYPE_TAG_NAME can be null in case of an anonymous union */
                  if (TYPE_TAG_NAME (type))
                    strcpy (found_class_name, TYPE_TAG_NAME (type));
                  else
                    strcpy (found_class_name, " ");
                  strcat (found_class_name, "::");
                  strcat (found_class_name, tmp_class_name);
                }
              /* Don't count virtual bases twice when deciding ambiguity */
              if (*vbase != basetype)   /* works for null *vbase */
                *found += tmp_found;
              /* Is this the first virtual base where we "found" something? */
              if (!*vbase)
                *vbase = basetype;
              tmp_found = 0;
            }
        }
d2139 1
a2139 11
        {
          v = value_primitive_field (arg1, offset, i, type);
          if (!*found)
            {
              /* Record return value and class name, and continue
                 looking for possible ambiguous members */
              retval = v;
              strcpy (found_class_name, TYPE_TAG_NAME (type));
            }
          (*found)++;
        }
d2141 69
a2209 21
        {
          v = search_struct_field_aux (name, arg1,
                               offset + TYPE_BASECLASS_BITPOS (type, i) / 8,
                                basetype, looking_for_baseclass, &tmp_found,
                                       tmp_class_name, vbase, domain_name);
          if (!*found && v)
            {
              /* Record return value and class name, and continue
                 looking for possible ambiguous members */
              retval = v;
              /* TYPE_TAG_NAME can be null in case of an anonymous union */
              if (TYPE_TAG_NAME (type))
                strcpy (found_class_name, TYPE_TAG_NAME (type));
              else
                strcpy (found_class_name, " ");
              strcat (found_class_name, "::");
              strcat (found_class_name, tmp_class_name);
            }
          *found += tmp_found;
          tmp_found = 0;
        }
d2211 25
a2235 1
  return retval;
d2238 1
d2246 1
a2246 1
search_struct_method (const char *name, register value_ptr *arg1p,
d2303 13
a2315 8
	  struct type *baseclass = check_typedef (TYPE_BASECLASS (type, i));
	  char *base_valaddr;
	  
	  /* The virtual base class pointer might have been clobbered by the
	     user program. Make sure that it still points to a valid memory
	     location.  */
	  
	  if (offset < 0 || offset >= TYPE_LENGTH (type))
d2317 24
a2340 5
	      base_valaddr = (char *) alloca (TYPE_LENGTH (baseclass));
	      if (target_read_memory (VALUE_ADDRESS (*arg1p)
				      + VALUE_OFFSET (*arg1p) + offset,
				      base_valaddr,
				      TYPE_LENGTH (baseclass)) != 0)
a2342 9
	  else
	    base_valaddr = VALUE_CONTENTS (*arg1p) + offset;
	  
	  base_offset =
	    baseclass_offset (type, i, arg1p,  base_valaddr,
			      VALUE_ADDRESS (*arg1p)
			      + VALUE_OFFSET (*arg1p) + offset, offset);
	  if (base_offset == -1)
	    error ("virtual baseclass botch");
d2417 1
a2417 1
      
d2420 1
a2420 8
      if (strncmp (err, "data member", 11))
	{
	  v = search_struct_field (name, *argp, VALUE_EMBEDDED_OFFSET (*argp), t, no_baseclass, NULL);
	}
      else
	{
	  v = search_struct_field (name, *argp, VALUE_EMBEDDED_OFFSET (*argp), t, struct_or_baseclass, err);
	}
d2423 1
a2423 1
      
d2479 1
a2479 1
      v = search_struct_field (name, *argp, 0, t, no_baseclass, NULL);
d2531 23
a2553 7
	  base_offset = VALUE_OFFSET (*argp) + offset;
	  base_offset =
	    baseclass_offset (type, i, argp, 
			      VALUE_CONTENTS (*argp) + base_offset,
			      VALUE_ADDRESS (*argp) + base_offset, offset);
	  if (base_offset == -1)
	    error ("virtual baseclass botch");
d2667 1
a2667 1
  const char *obj_type_name = NULL;
d2681 1
a2681 1
	obj_type_name = TYPE_NAME (POINTER_TARGET_TYPE (VALUE_TYPE (obj)));
d2883 1
a2883 1
      const char *dname = type_name_no_tag (type);
d2961 1
a2961 1
      t = POINTER_TARGET_TYPE (t);
d2984 1
a2984 1
				struct type *intype, int look_for_this)
d2989 1
a2989 1
  
a2999 1
		value_ptr argp;
d3010 1
a3010 15
	  if (look_for_this)
	    {
	      /* It can be a class data member. */
	      argp = value_of_this (1);
	      if (argp != 0)
		{
		  char *class_name;
		  class_name = alloca (strlen (TYPE_TAG_NAME(domain)) +strlen ("data member of ")+1);
		  strcat (class_name, "data member of ");
		  strcat (class_name, TYPE_TAG_NAME(domain));
		  v = value_struct_elt (&argp, NULL, name, NULL, class_name);
		  if (v != 0)
		    return v;
		}
	    }
d3017 1
a3017 1
  
d3029 1
a3029 1
    intype = POINTER_TARGET_TYPE (intype);
d3107 1
a3107 1
					  intype, look_for_this);
d3259 1
a3259 2
  struct type *slice_type;
  struct range_type *slice_range_type, *range_type;
d3269 3
a3271 3
  range_type = ARRAY_RANGE_TYPE (array_type);
  lowerbound = RANGE_LOWER_BOUND (range_type);
  upperbound = RANGE_UPPER_BOUND (range_type);
d3278 1
a3278 1
  /* TYPEFIX-type-allocation: need a way to free this type when we are
d3280 2
a3281 2
  slice_range_type = make_range_type (NULL, 
					RANGE_INDEX_TYPE (range_type),
d3286 1
a3286 1
      slice_type = (struct type *)make_set_type (NULL, slice_range_type);
d3310 1
a3310 1
      struct type *element_type = ARRAY_ELEMENT_TYPE (array_type);
d3313 1
a3313 1
      slice_type = (struct type *)make_array_type (NULL,  element_type,
@


1.35
log
@(Changes from Daniel Berlin, with revisions by Jim Blandy.)

Abstract out operations specific to particular C++ ABI's, and
invoke them through a function table.  This removes the C++ ABI
dependencies scattered throughout the code, and allows us to
cleanly add support for new C++ ABI's.
* cp-abi.h, cp-abi.h, gnu-v2-abi.c, hpacc-abi.c: New files.
* c-typeprint.c, c-valprint.c, dbxread.c, eval.c, gdbtypes.c,
jv-typeprint.c, linespec.c, symtab.c, typeprint.c, valops.c:
#include "cp-abi.h".  These files all use functions now declared
there.
* symtab.h (OPNAME_PREFIX_P, VTBL_PREFIX_P, DESTRUCTOR_PREFIX_P):
Deleted.  These services are now provided by functions declared in
cp-abi.h.
* value.h (value_rtti_type, value_virtual_fn_field): Same.
* values.c (value_virtual_fn_field): Same, for this definition.
* valops.c (value_rtti_type): Same.
* c-typeprint.c (c_type_print_base): Use the functions from
"cp-abi.h", instead of the old macros, or hard-coded ABI-specific
tests.
* dbxread.c (record_minimal_symbol): Same.
* gdbtypes.c (get_destructor_fn_field, virtual_base_index,
virtual_base_index_skip_primaries): Same.
* jv-typeprint.c (java_type_print_base): Same.
* linespec.c (find_methods, decode_line_1): Same.
* symtab.c (gdb_mangle_name): Same.
* Makefile.in (SFILES): Add the new .c files mentioned above.
(cp_abi_h): New variable.
(COMMON_OBS): Add gnu-v2-abi.o, hpacc-abi.o, and cp-abi.o.
(cp-abi.o, gnu-v2-abi.o, hpacc-abi.o): New targets.
(c-typeprint.o, c-valprint.o, dbxread.o, eval.o, gdbtypes.o,
jv-typeprint.o, symtab.o, linespec.o, typeprint.o, valops.o): Add
dependency on $(cp_abi_h).
@
text
@d368 1
a368 1
      VALUE_ENCLOSING_TYPE (arg2) = type;	/* pai: chk_val */
d612 1
a612 1
      VALUE_ENCLOSING_TYPE (val) = VALUE_ENCLOSING_TYPE (fromval);
d826 1
a826 1
  VALUE_ENCLOSING_TYPE (val) = VALUE_ENCLOSING_TYPE (fromval);
d968 1
a968 1
  VALUE_ENCLOSING_TYPE (arg2) = lookup_pointer_type (VALUE_ENCLOSING_TYPE (arg1));
d1012 1
a1012 1
      VALUE_ENCLOSING_TYPE (arg2) = enc_type;
d3168 1
a3168 1
      VALUE_ENCLOSING_TYPE (argp) = real_type;
@


1.34
log
@* valops.c (hand_function_call): Simplify computation of the
address of the pushed argument.
@
text
@d34 1
a3113 220

/* Find the real run-time type of a value using RTTI.
 * V is a pointer to the value.
 * A pointer to the struct type entry of the run-time type
 * is returneed.
 * FULL is a flag that is set only if the value V includes
 * the entire contents of an object of the RTTI type.
 * TOP is the offset to the top of the enclosing object of
 * the real run-time type.  This offset may be for the embedded
 * object, or for the enclosing object of V.
 * USING_ENC is the flag that distinguishes the two cases.
 * If it is 1, then the offset is for the enclosing object,
 * otherwise for the embedded object.
 *
 */

struct type *
value_rtti_type (value_ptr v, int *full, int *top, int *using_enc)
{
  struct type *known_type;
  struct type *rtti_type;
  CORE_ADDR coreptr;
  value_ptr vp;
  int using_enclosing = 0;
  long top_offset = 0;
  char rtti_type_name[256];

  if (full)
    *full = 0;
  if (top)
    *top = -1;
  if (using_enc)
    *using_enc = 0;

  /* Get declared type */
  known_type = VALUE_TYPE (v);
  CHECK_TYPEDEF (known_type);
  /* RTTI works only or class objects */
  if (TYPE_CODE (known_type) != TYPE_CODE_CLASS)
    return NULL;
  if (TYPE_HAS_VTABLE(known_type))
    {
      /* If neither the declared type nor the enclosing type of the
       * value structure has a HP ANSI C++ style virtual table,
       * we can't do anything. */
      if (!TYPE_HAS_VTABLE (known_type))
	{
	  known_type = VALUE_ENCLOSING_TYPE (v);
	  CHECK_TYPEDEF (known_type);
	  if ((TYPE_CODE (known_type) != TYPE_CODE_CLASS) ||
	      !TYPE_HAS_VTABLE (known_type))
	    return NULL;		/* No RTTI, or not HP-compiled types */
	  CHECK_TYPEDEF (known_type);
	  using_enclosing = 1;
	}

      if (using_enclosing && using_enc)
	*using_enc = 1;

      /* First get the virtual table address */
      coreptr = *(CORE_ADDR *) ((VALUE_CONTENTS_ALL (v))
				+ VALUE_OFFSET (v)
				+ (using_enclosing ? 0 : VALUE_EMBEDDED_OFFSET (v)));
      if (coreptr == 0)
	return NULL;		/* return silently -- maybe called on gdb-generated value */

      /* Fetch the top offset of the object */
      /* FIXME possible 32x64 problem with pointer size & arithmetic */
      vp = value_at (builtin_type_int,
		     coreptr + 4 * HP_ACC_TOP_OFFSET_OFFSET,
		     VALUE_BFD_SECTION (v));
      top_offset = value_as_long (vp);
      if (top)
	*top = top_offset;

      /* Fetch the typeinfo pointer */
      /* FIXME possible 32x64 problem with pointer size & arithmetic */
      vp = value_at (builtin_type_int, coreptr + 4 * HP_ACC_TYPEINFO_OFFSET, VALUE_BFD_SECTION (v));
      /* Indirect through the typeinfo pointer and retrieve the pointer
       * to the string name */
      coreptr = *(CORE_ADDR *) (VALUE_CONTENTS (vp));
      if (!coreptr)
	error ("Retrieved null typeinfo pointer in trying to determine run-time type");
      vp = value_at (builtin_type_int, coreptr + 4, VALUE_BFD_SECTION (v));		/* 4 -> offset of name field */
      /* FIXME possible 32x64 problem */

      coreptr = *(CORE_ADDR *) (VALUE_CONTENTS (vp));

      read_memory_string (coreptr, rtti_type_name, 256);

      if (strlen (rtti_type_name) == 0)
	error ("Retrieved null type name from typeinfo");

      /* search for type */
      rtti_type = lookup_typename (rtti_type_name, (struct block *) 0, 1);

      if (!rtti_type)
	error ("Could not find run-time type: invalid type name %s in typeinfo??", rtti_type_name);
      CHECK_TYPEDEF (rtti_type);
#if 0
      printf ("RTTI type name %s, tag %s, full? %d\n", TYPE_NAME (rtti_type), TYPE_TAG_NAME (rtti_type), full ? *full : -1);
#endif
      /* Check whether we have the entire object */
      if (full			/* Non-null pointer passed */
	  &&
	  /* Either we checked on the whole object in hand and found the
	     top offset to be zero */
	  (((top_offset == 0) &&
	    using_enclosing &&
	    TYPE_LENGTH (known_type) == TYPE_LENGTH (rtti_type))
	   ||
	   /* Or we checked on the embedded object and top offset was the
	      same as the embedded offset */
	   ((top_offset == VALUE_EMBEDDED_OFFSET (v)) &&
	    !using_enclosing &&
	    TYPE_LENGTH (VALUE_ENCLOSING_TYPE (v)) == TYPE_LENGTH (rtti_type))))

	*full = 1;
    }
  else
    /*
      Right now this is G++ RTTI. Plan on this changing in the
      future as i get around to setting the vtables properly for G++
      compiled stuff. Also, i'll be using the type info functions,
      which are always right. Deal with it until then.
    */
    {
      CORE_ADDR vtbl;
      struct minimal_symbol *minsym;
      struct symbol *sym;
      char *demangled_name;
      struct type *btype;
      /* If the type has no vptr fieldno, try to get it filled in */
      if (TYPE_VPTR_FIELDNO(known_type) < 0)
	fill_in_vptr_fieldno(known_type);

      /* If we still can't find one, give up */
      if (TYPE_VPTR_FIELDNO(known_type) < 0)
	return NULL;

      /* Make sure our basetype and known type match, otherwise, cast
	 so we can get at the vtable properly.
      */
      btype = TYPE_VPTR_BASETYPE (known_type);
      CHECK_TYPEDEF (btype);
      if (btype != known_type )
	{
	  v = value_cast (btype, v);
	  if (using_enc)
	    *using_enc=1;
	}
      /*
	We can't use value_ind here, because it would want to use RTTI, and
	we'd waste a bunch of time figuring out we already know the type.
        Besides, we don't care about the type, just the actual pointer
      */
      if (VALUE_ADDRESS (value_field (v, TYPE_VPTR_FIELDNO (known_type))) == 0)
	return NULL;

      /*
	 If we are enclosed by something that isn't us, adjust the
	 address properly and set using_enclosing.
      */
      if (VALUE_ENCLOSING_TYPE(v) != VALUE_TYPE(v))
	{
	  value_ptr tempval;
	  tempval=value_field(v,TYPE_VPTR_FIELDNO(known_type));
	  VALUE_ADDRESS(tempval)+=(TYPE_BASECLASS_BITPOS(known_type,TYPE_VPTR_FIELDNO(known_type))/8);
	  vtbl=value_as_pointer(tempval);
	  using_enclosing=1;
	}
      else
	{
	  vtbl=value_as_pointer(value_field(v,TYPE_VPTR_FIELDNO(known_type)));
	  using_enclosing=0;
	}

      /* Try to find a symbol that is the vtable */
      minsym=lookup_minimal_symbol_by_pc(vtbl);
      if (minsym==NULL || (demangled_name=SYMBOL_NAME(minsym))==NULL || !VTBL_PREFIX_P(demangled_name))
	return NULL;

      /* If we just skip the prefix, we get screwed by namespaces */
      demangled_name=cplus_demangle(demangled_name,DMGL_PARAMS|DMGL_ANSI);
      *(strchr(demangled_name,' '))=0;

      /* Lookup the type for the name */
      rtti_type=lookup_typename(demangled_name, (struct block *)0,1);

      if (rtti_type==NULL)
	return NULL;

      if (TYPE_N_BASECLASSES(rtti_type) > 1 &&  full && (*full) != 1)
	{
	  if (top)
	    *top=TYPE_BASECLASS_BITPOS(rtti_type,TYPE_VPTR_FIELDNO(rtti_type))/8;
	  if (top && ((*top) >0))
	    {
	      if (TYPE_LENGTH(rtti_type) > TYPE_LENGTH(known_type))
		{
		  if (full)
		    *full=0;
		}
	      else
		{
		  if (full)
		    *full=1;
		}
	    }
	}
      else
	{
	  if (full)
	    *full=1;
	}
      if (using_enc)
	*using_enc=using_enclosing;
    }
  return rtti_type;
}
@


1.33
log
@Update/correct copyright notices.
@
text
@d1533 3
d1542 1
d1545 1
a1545 12
	      write_memory (sp, VALUE_CONTENTS_ALL (args[i]), len);
	      if (INNER_THAN (1, 2))
		{
		  /* The stack grows down, so the address of the thing
		     we push is the stack pointer after we push it.  */
		  addr = sp;
		}
	      else
		{
		  /* stack grows upward */
		  sp += aligned_len;
		}
@


1.32
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1986, 87, 89, 91, 92, 93, 94, 95, 96, 97, 1998, 2001 Free
   Software Foundation, Inc.
@


1.31
log
@2001-02-06  Michael Snyder  <msnyder@@makita.cygnus.com>
	Submitted by Paul Hilfinger (hilfingr@@gnat.com)
	and Andrei Petrov (and@@genesyslab.com).
	* findvar.c: Buffers of size MAX_REGISTER_RAW_SIZE or REGISTER_BYTES
	must be allocated dynamically, since these are no longer constants.
	* infcmd.c: Ditto.
	* regcache.c: Ditto.
	* remote.c: Ditto.
	* sol-thread.c: Ditto.
	* valops.c: Ditto.
	* config/sparc/sun4sol2.mh (MH_CFLAGS): Add -I/usr/include/v9, as a
	work-around for a missing Sun header file in solaris for sparc64.
@
text
@d2 2
a3 2
   Copyright 1986, 87, 89, 91, 92, 93, 94, 95, 96, 97, 1998
   Free Software Foundation, Inc.
d33 1
@


1.30
log
@	* valops.c (value_cast): If casting a scalar to a pointer, do not
 	issue a message about truncation unless it exceeds the length of
 	an address, not the length of a pointer.  This is because what the
 	user gives us is an address, not a pointer, and we will ultimately
 	convert it (via ADDRESS_TO_POINTER) to a pointer, not truncate it
 	to a pointer.  This allows things like "print *(int *)0x01000234"
 	to work without generating a misleading message on a target having
 	two byte pointers and four byte addresses.
@
text
@d573 1
a573 1
  char raw_buffer[MAX_REGISTER_RAW_SIZE];
d1030 1
a1030 1
  char buffer[MAX_REGISTER_RAW_SIZE];
d1668 1
a1668 1
    char retbuf[REGISTER_BYTES];
@


1.29
log
@	* valops.c (VALUE_SUBSTRING_START): Delete.
@
text
@d290 12
a301 1
      int ptr_bit = HOST_CHAR_BIT * TYPE_LENGTH (type);
d303 1
a303 1
      if (ptr_bit < sizeof (LONGEST) * HOST_CHAR_BIT)
d305 2
a306 2
	  if (longest >= ((LONGEST) 1 << ptr_bit)
	      || longest <= -((LONGEST) 1 << ptr_bit))
@


1.28
log
@Replace free() with xfree().
@
text
@a72 2
#define VALUE_SUBSTRING_START(VAL) VALUE_FRAME(VAL)

@


1.27
log
@Protoization.
@
text
@d2791 1
a2791 1
      free (parm_types);
d2863 1
a2863 1
      free (func_name);
@


1.26
log
@	* arch-utils.c, arch-utils.h (default_convert_from_func_ptr_addr):
	New function.
	* gdbarch.sh (CONVERT_FROM_FUNC_PTR_ADDR):  Add.
	* gdbarch.c, gdbarch.h:  Regenerate.
	* valops.c (find_function_addr):  Use CONVERT_FROM_FUNC_PTR_ADDR
	unconditionally.

	* config/rs6000/tm-rs6000.h (CONVERT_FROM_FUNC_PTR_ADDR):  Delete
	definition.
	* config/powerpc/tm-linux.h (CONVERT_FROM_FUNC_PTR_ADDR):  Remove
	undef.
	* rs6000-tdep.c (rs6000_convert_from_func_ptr_addr):  Fix comment.
	(rs6000_gdbarch_init):  Register rs6000_convert_from_func_ptr_addr
	if not ELFOSABI_LINUX.
@
text
@d1940 1
a1940 4
typecmp (staticp, t1, t2)
     int staticp;
     struct type *t1[];
     value_ptr t2[];
@


1.25
log
@2000-08-29  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * valops.c (value_cast): Indentation fix-up.
        * acconfig.h (HAVE_PRGREGSET32_T, HAVE_PRFPREGSET32_T,
        HAVE_STRUCT_LINK_MAP32): New configure macros.
        * config.in: Ditto.
        * configure.in: Test for the above new macros.
        * breakpoint.c: Update copyright date.
        * core-sol2.c: Include v9/sys/privregs.h directly to
        work around a bug in Sun's Solaris 8 header files.
        (fetch_core_registers): Use the above new configure macros to
        handle cross-debugging of 32-bit core files on a 64-bit host.
        * sol-thread.c (ps_pdmodel) New function.
        (rw_common): For debugging of 32-bit apps on a 64-bit host,
        truncate addresses to 32 bits.
        * solib.c (solib_extract_address): Functionize.  Make 32/64 aware.
        (LM_ADDR, LM_NEXT, LM_NAME): Ditto.
        (IGNORE_FIRST_LINK_MAP): Ditto.
        (first_link_map_member): Make 32/64 aware.
        (open_symbol_file_object): Ditto.
        (current_sos): Ditto.
@
text
@a1251 4
#ifdef CONVERT_FROM_FUNC_PTR_ADDR
	  /* FIXME: This is a workaround for the unusual function
	     pointer representation on the RS/6000, see comment
	     in config/rs6000/tm-rs6000.h  */
a1252 1
#endif
@


1.24
log
@Multi-arch EXTRA_STACK_ALIGNMENT_NEEDED (nee NO_EXTRA_ALIGNMENT_NEEDED).
@
text
@d289 2
a290 2
                                    code2 == TYPE_CODE_ENUM ||
                                    code2 == TYPE_CODE_RANGE))
@


1.23
log
@Protoization.
@
text
@d1584 5
a1588 10
/* elz: on HPPA no need for this extra alignment, maybe it is needed
   on other architectures. This is because all the alignment is taken care
   of in the above code (ifdef REG_STRUCT_HAS_ADDR) and in
   hppa_push_arguments */
#ifndef NO_EXTRA_ALIGNMENT_NEEDED

  /* MVS 11/22/96: I think at least some of this stack_align code is
     really broken.  Better to let PUSH_ARGUMENTS adjust the stack in
     a target-defined manner.  */
  if (STACK_ALIGN_P () && INNER_THAN (1, 2))
d1590 7
a1596 2
      /* If stack grows down, we must leave a hole at the top. */
      int len = 0;
d1598 6
a1603 5
      for (i = nargs - 1; i >= 0; i--)
	len += TYPE_LENGTH (VALUE_ENCLOSING_TYPE (args[i]));
      if (CALL_DUMMY_STACK_ADJUST_P)
	len += CALL_DUMMY_STACK_ADJUST;
      sp -= STACK_ALIGN (len) - len;
a1604 1
#endif /* NO_EXTRA_ALIGNMENT_NEEDED */
@


1.22
log
@modify error message
@
text
@d95 1
a95 2
find_function_in_inferior (name)
     char *name;
d135 1
a135 2
value_allocate_space_in_inferior (len)
     int len;
d153 1
a153 2
allocate_space_in_inferior (len)
     int len;
d164 1
a164 3
value_cast (type, arg2)
     struct type *type;
     register value_ptr arg2;
d423 1
a423 3
value_zero (type, lv)
     struct type *type;
     enum lval_type lv;
d446 1
a446 4
value_at (type, addr, sect)
     struct type *type;
     CORE_ADDR addr;
     asection *sect;
d490 1
a490 4
value_at_lazy (type, addr, sect)
     struct type *type;
     CORE_ADDR addr;
     asection *sect;
d520 1
a520 2
value_fetch_lazy (val)
     register value_ptr val;
d560 1
a560 2
value_assign (toval, fromval)
     register value_ptr toval, fromval;
d825 1
a825 3
value_repeat (arg1, count)
     value_ptr arg1;
     int count;
d846 1
a846 3
value_of_variable (var, b)
     struct symbol *var;
     struct block *b;
d898 1
a898 2
value_coerce_array (arg1)
     value_ptr arg1;
d913 1
a913 2
value_coerce_function (arg1)
     value_ptr arg1;
d929 1
a929 2
value_addr (arg1)
     value_ptr arg1;
d967 1
a967 2
value_ind (arg1)
     value_ptr arg1;
d1018 1
a1018 3
push_word (sp, word)
     CORE_ADDR sp;
     ULONGEST word;
d1043 1
a1043 4
push_bytes (sp, buffer, len)
     CORE_ADDR sp;
     char *buffer;
     int len;
d1069 1
a1069 3
value_push (sp, arg)
     register CORE_ADDR sp;
     value_ptr arg;
d1107 2
a1108 6
default_push_arguments (nargs, args, sp, struct_return, struct_addr)
     int nargs;
     value_ptr *args;
     CORE_ADDR sp;
     int struct_return;
     CORE_ADDR struct_addr;
d1153 1
a1153 4
value_arg_coerce (arg, param_type, is_prototyped)
     value_ptr arg;
     struct type *param_type;
     int is_prototyped;
d1229 1
a1229 3
find_function_addr (function, retval_type)
     value_ptr function;
     struct type **retval_type;
d1303 1
a1303 4
hand_function_call (function, nargs, args)
     value_ptr function;
     int nargs;
     value_ptr *args;
d1790 1
a1790 4
call_function_by_hand (function, nargs, args)
     value_ptr function;
     int nargs;
     value_ptr *args;
d1815 1
a1815 4
value_array (lowbound, highbound, elemvec)
     int lowbound;
     int highbound;
     value_ptr *elemvec;
d1887 1
a1887 3
value_string (ptr, len)
     char *ptr;
     int len;
d1917 1
a1917 3
value_bitstring (ptr, len)
     char *ptr;
     int len;
d2021 2
a2022 6
search_struct_field (name, arg1, offset, type, looking_for_baseclass)
     char *name;
     register value_ptr arg1;
     int offset;
     register struct type *type;
     int looking_for_baseclass;
d2174 2
a2175 7
find_rt_vbase_offset (type, basetype, valaddr, offset, boffset_p, skip_p)
     struct type *type;
     struct type *basetype;
     char *valaddr;
     int offset;
     int *boffset_p;
     int *skip_p;
d2250 3
a2252 5
search_struct_method (name, arg1p, args, offset, static_memfuncp, type)
     char *name;
     register value_ptr *arg1p, *args;
     int offset, *static_memfuncp;
     register struct type *type;
d2386 2
a2387 5
value_struct_elt (argp, args, name, static_memfuncp, err)
     register value_ptr *argp, *args;
     char *name;
     int *static_memfuncp;
     char *err;
d2505 3
a2507 9
find_method_list (argp, method, offset, static_memfuncp, type, num_fns, basetype, boffset)
     value_ptr *argp;
     char *method;
     int offset;
     int *static_memfuncp;
     struct type *type;
     int *num_fns;
     struct type **basetype;
     int *boffset;
d2582 3
a2584 8
value_find_oload_method_list (argp, method, offset, static_memfuncp, num_fns, basetype, boffset)
     value_ptr *argp;
     char *method;
     int offset;
     int *static_memfuncp;
     int *num_fns;
     struct type **basetype;
     int *boffset;
d2644 3
a2646 11
find_overload_match (arg_types, nargs, name, method, lax, obj, fsym, valp, symp, staticp)
     struct type **arg_types;
     int nargs;
     char *name;
     int method;
     int lax;
     value_ptr obj;
     struct symbol *fsym;
     value_ptr *valp;
     struct symbol **symp;
     int *staticp;
d2881 1
a2881 3
destructor_name_p (name, type)
     const char *name;
     const struct type *type;
d2909 1
a2909 3
check_field_in (type, name)
     register struct type *type;
     const char *name;
d2950 1
a2950 3
check_field (arg1, name)
     register value_ptr arg1;
     const char *name;
d2986 3
a2988 4
value_struct_elt_for_reference (domain, offset, curtype, name, intype)
     struct type *domain, *curtype, *intype;
     int offset;
     char *name;
d3135 1
a3135 5
value_rtti_type (v, full, top, using_enc)
     value_ptr v;
     int *full;
     int *top;
     int *using_enc;
d3345 1
a3345 5
value_rtti_target_type (v, full, top, using_enc)
     value_ptr v;
     int *full;
     int *top;
     int *using_enc;
d3365 2
a3366 7
value_full_object (argp, rtype, xfull, xtop, xusing_enc)
     value_ptr argp;
     struct type *rtype;
     int xfull;
     int xtop;
     int xusing_enc;

d3424 1
a3424 2
value_of_this (complain)
     int complain;
d3481 1
a3481 3
value_slice (array, lowbound, length)
     value_ptr array;
     int lowbound, length;
d3560 1
a3560 2
varying_to_slice (varray)
     value_ptr varray;
d3576 1
a3576 4
value_literal_complex (arg1, arg2, type)
     value_ptr arg1;
     value_ptr arg2;
     struct type *type;
d3595 1
a3595 3
cast_into_complex (type, val)
     struct type *type;
     register value_ptr val;
d3620 1
a3620 1
_initialize_valops ()
@


1.21
log
@Properly handle references
@
text
@d2037 1
a2037 1
	 and the arrgument will be a pointer to a char.      */
d2357 1
a2357 1
		    return v;
d2539 1
a2539 1

d2542 1
a2542 1
      error ("Argument list of %s mismatch with component in the structure.", name);
@


1.20
log
@* valops.c (value_cast): Allow cast from INT, ENUM or RANGE to
POINTER.
@
text
@d277 1
a277 1
	      ptr = (unsigned int *) VALUE_CONTENTS (retvalp);	
d290 1
a290 1
      return value_from_longest (type, convert_to_boolean ? 
d293 1
a293 1
  else if (code1 == TYPE_CODE_PTR && (code2 == TYPE_CODE_INT  || 
d564 1
a564 1
  
d679 1
a679 1
	  int len = 
d2032 14
a2045 3
      while (TYPE_CODE (tt1) == TYPE_CODE_PTR
	     && (TYPE_CODE (tt2) == TYPE_CODE_ARRAY
		 || TYPE_CODE (tt2) == TYPE_CODE_PTR))
d2047 1
a2047 2
	  tt1 = check_typedef (TYPE_TARGET_TYPE (tt1));
	  tt2 = check_typedef (TYPE_TARGET_TYPE (tt2));
d3337 1
a3337 1
      compiled stuff. Also, i'll be using the type info functions, 
d3366 1
a3366 1
	We can't use value_ind here, because it would want to use RTTI, and 
@


1.19
log
@	* gdbtypes.c (is_ancestor): Infer type equivalence from name
	equivalence.
	(rank_one_type): Use strcmp instead of == to compare type names.
	Don't swap parm with arg when checking TYPE_CODE_REF types.
	* valops.c (find_overload_match): Fix indentation.  Compare
	parameter rankings to 0..9, 10..99, and 100+ instead of 0, 10,
	and 100.
@
text
@d293 14
@


1.18
log
@2000-06-15  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * valops.c (value_cast): Break up long lines.
@
text
@d2861 10
a2870 10
if (overload_debug)
{
      if (method)
	fprintf_filtered (gdb_stderr,"Overloaded method instance %s, # of parms %d\n", fns_ptr[ix].physname, nparms);
      else
	fprintf_filtered (gdb_stderr,"Overloaded function instance %s # of parms %d\n", SYMBOL_DEMANGLED_NAME (oload_syms[ix]), nparms);
      for (jj = 0; jj < nargs; jj++)
	fprintf_filtered (gdb_stderr,"...Badness @@ %d : %d\n", jj, bv->rank[jj]);
      fprintf_filtered (gdb_stderr,"Overload resolution champion is %d, ambiguous? %d\n", oload_champ, oload_ambiguous);
}
d2893 5
a2897 9
      switch (oload_champ_bv->rank[ix])
	{
	case 10:
	  oload_non_standard = 1;	/* non-standard type conversions needed */
	  break;
	case 100:
	  oload_incompatible = 1;	/* truly mismatched types */
	  break;
	}
@


1.17
log
@2000-06-12  Fernando Nasser  <fnasser@@cygnus.com>

        * valops.c (value_assign): Adjust the length to take into
        consideration that we are not starting from the beginning.
@
text
@d276 2
a277 1
	      ptr = (unsigned int *) VALUE_CONTENTS (retvalp);	/* force evaluation */
d290 2
a291 1
      return value_from_longest (type, convert_to_boolean ? (LONGEST) (longest ? 1 : 0) : longest);
@


1.16
log
@PARAMS removal.
@
text
@d663 2
a664 1
	  int len = REGISTER_RAW_SIZE (VALUE_REGNO (toval));
@


1.15
log
@Purge (almost) make_cleanup_func.
@
text
@d44 1
a44 1
static int typecmp PARAMS ((int staticp, struct type * t1[], value_ptr t2[]));
d46 2
a47 2
static CORE_ADDR find_function_addr PARAMS ((value_ptr, struct type **));
static value_ptr value_arg_coerce PARAMS ((value_ptr, struct type *, int));
d50 1
a50 1
static CORE_ADDR value_push PARAMS ((CORE_ADDR, value_ptr));
d52 2
a53 2
static value_ptr search_struct_field PARAMS ((char *, value_ptr, int,
					      struct type *, int));
d55 3
a57 3
static value_ptr search_struct_method PARAMS ((char *, value_ptr *,
					       value_ptr *,
					       int, int *, struct type *));
d59 1
a59 1
static int check_field_in PARAMS ((struct type *, const char *));
d61 1
a61 1
static CORE_ADDR allocate_space_in_inferior PARAMS ((int));
d63 1
a63 1
static value_ptr cast_into_complex PARAMS ((struct type *, value_ptr));
d65 5
a69 1
static struct fn_field *find_method_list PARAMS ((value_ptr * argp, char *method, int offset, int *static_memfuncp, struct type * type, int *num_fns, struct type ** basetype, int *boffset));
d71 1
a71 1
void _initialize_valops PARAMS ((void));
d1322 2
a1323 1
static value_ptr hand_function_call PARAMS ((value_ptr function, int nargs, value_ptr * args));
@


1.14
log
@* target.h (target_memory_bfd_section): Removed declaration.
* target.c (target_memory_bfd_section): Removed.
* exec.c (xfer_memory): Removed #if'ed-out code which referenced
target_memory_bfd_section.

* target.h (target_read_memory_section): Removed declaration.
* target.c (target_read_memory_section): Removed.
(target_xfer_memory): Update, removed bfd_section argument.
(target_read_string, target_read_memory, target_write_memory):
Update for above change.

* gdbcore.h (read_memory_section): Removed declaration.
* corefile.c (read_memory_section): Removed.
* jv-lang.c (get_java_utf8_name): Changed calls to
read_memory_section to read_memory.
* printcmd.c (printf_command): Likewise.
* valops.c (value_at, value_fetch_lazy): Likewise.
@
text
@d1367 1
a1367 2
  old_chain = make_cleanup ((make_cleanup_func) restore_inferior_status,
			    inf_status);
@


1.13
log
@Convert SAVE_DUMMY_FRAME_TOS to multi-arch.
@
text
@d468 1
a468 1
    read_memory_section (addr, VALUE_CONTENTS_ALL_RAW (val), TYPE_LENGTH (type), sect);
d543 2
a544 2
    read_memory_section (addr, VALUE_CONTENTS_ALL_RAW (val), length,
			 VALUE_BFD_SECTION (val));
@


1.12
log
@Convert REG_STRUCT_HAS_ADDR to multi-arch.  Use REG_STRUCT_HAS_ADDR_P
in conversion.
@
text
@d1681 2
a1682 3
#ifdef SAVE_DUMMY_FRAME_TOS
  SAVE_DUMMY_FRAME_TOS (sp);
#endif
@


1.11
log
@* valops.c (hand_function_call): Replace #ifdef STACK_ALIGN with
run-time test for STACK_ALIGN_P.
* gdbarch.sh: Add support for function and variable predicates.
(STACK_ALIGN): Add.  Implement with predicate - STACK_ALIGN_P.
* gdbarch.h, gdbarch.c: Re-generate.
@
text
@d1513 65
a1577 23
#if defined (REG_STRUCT_HAS_ADDR)
  {
    /* This is a machine like the sparc, where we may need to pass a pointer
       to the structure, not the structure itself.  */
    for (i = nargs - 1; i >= 0; i--)
      {
	struct type *arg_type = check_typedef (VALUE_TYPE (args[i]));
	if ((TYPE_CODE (arg_type) == TYPE_CODE_STRUCT
	     || TYPE_CODE (arg_type) == TYPE_CODE_UNION
	     || TYPE_CODE (arg_type) == TYPE_CODE_ARRAY
	     || TYPE_CODE (arg_type) == TYPE_CODE_STRING
	     || TYPE_CODE (arg_type) == TYPE_CODE_BITSTRING
	     || TYPE_CODE (arg_type) == TYPE_CODE_SET
	     || (TYPE_CODE (arg_type) == TYPE_CODE_FLT
		 && TYPE_LENGTH (arg_type) > 8)
	    )
	    && REG_STRUCT_HAS_ADDR (using_gcc, arg_type))
	  {
	    CORE_ADDR addr;
	    int len;		/*  = TYPE_LENGTH (arg_type); */
	    int aligned_len;
	    arg_type = check_typedef (VALUE_ENCLOSING_TYPE (args[i]));
	    len = TYPE_LENGTH (arg_type);
a1578 42
	    if (STACK_ALIGN_P ())
	      /* MVS 11/22/96: I think at least some of this
		 stack_align code is really broken.  Better to let
		 PUSH_ARGUMENTS adjust the stack in a target-defined
		 manner.  */
	      aligned_len = STACK_ALIGN (len);
	    else
	      aligned_len = len;
	    if (INNER_THAN (1, 2))
	      {
		/* stack grows downward */
		sp -= aligned_len;
	      }
	    else
	      {
		/* The stack grows up, so the address of the thing we push
		   is the stack pointer before we push it.  */
		addr = sp;
	      }
	    /* Push the structure.  */
	    write_memory (sp, VALUE_CONTENTS_ALL (args[i]), len);
	    if (INNER_THAN (1, 2))
	      {
		/* The stack grows down, so the address of the thing we push
		   is the stack pointer after we push it.  */
		addr = sp;
	      }
	    else
	      {
		/* stack grows upward */
		sp += aligned_len;
	      }
	    /* The value we're going to pass is the address of the thing
	       we just pushed.  */
	    /*args[i] = value_from_longest (lookup_pointer_type (value_type),
	       (LONGEST) addr); */
	    args[i] = value_from_pointer (lookup_pointer_type (arg_type),
					  addr);
	  }
      }
  }
#endif /* REG_STRUCT_HAS_ADDR.  */
@


1.10
log
@* remote.c (REMOTE_TRANSLATE_XFER_ADDRESS), mem-break.c
(MEMORY_INSERT_BREAKPOINT, MEMORY_REMOVE_BREAKPOINT), target.h
(BREAKPOINT_FROM_PC), valops.c (COERCE_FLOAT_TO_DOUBLE),
gdbarch.sh (D10V_MAKE_DADDR, D10V_MAKE_IADDR,
FRAMELESS_FUNCTION_INVOCATION, REGISTER_CONVERTIBLE,
REGISTER_CONVERT_TO_VIRTUAL, REGISTER_CONVERT_TO_RAW,
REGISTER_NAME), findvar.c (POINTER_TO_ADDRESS,
ADDRESS_TO_POINTER): Delete default definition.  Handled by
gdbarch.

* gdbarch.sh: Make multi-arch defaults, defaults for non-
multi-arch targets.
(REGISTER_NAME, COERCE_FLOAT_TO_DOUBLE, REGISTER_CONVERTIBLE,
REGISTER_CONVERT_TO_VIRTUAL, REGISTER_CONVERT_TO_RAW,
D10V_MAKE_DADDR, D10V_MAKE_IADDR, BREAKPOINT_FROM_PC,
MEMORY_INSERT_BREAKPOINT, MEMORY_REMOVE_BREAKPOINT,
REMOTE_TRANSLATE_XFER_ADDRESS, FRAMELESS_FUNCTION_INVOCATION):
Provide default/legacy implementation.
(REGISTER_NAMES, CALL_DUMMY): Allow legacy definition.
* gdbarch.h, gdbarch.c: Re-generate.
@
text
@d1537 8
a1544 8
#ifdef STACK_ALIGN
	    /* MVS 11/22/96: I think at least some of this stack_align code is
	       really broken.  Better to let PUSH_ARGUMENTS adjust the stack in
	       a target-defined manner.  */
	    aligned_len = STACK_ALIGN (len);
#else
	    aligned_len = len;
#endif
d1586 5
a1590 6
#ifdef STACK_ALIGN
      /* MVS 11/22/96: I think at least some of this stack_align code is
         really broken.  Better to let PUSH_ARGUMENTS adjust the stack in
         a target-defined manner.  */
      len = STACK_ALIGN (len);
#endif
a1610 1
#if defined(STACK_ALIGN)
d1614 1
a1614 1
  if (INNER_THAN (1, 2))
a1624 1
#endif /* STACK_ALIGN */
d1642 1
a1642 2
#if defined(STACK_ALIGN)
  if (!INNER_THAN (1, 2))
a1649 1
#endif /* STACK_ALIGN */
@


1.9
log
@* gdbarch.sh (POINTER_TO_ADDRESS, ADDRESS_TO_POINTER): Two new
functions which architectures can redefine, defaulting to
generic_pointer_to_address and generic_address_to_pointer.
* findvar.c (extract_typed_address, store_typed_address,
generic_pointer_to_address, generic_address_to_pointer): New
functions.
(POINTER_TO_ADDRESS, ADDRESS_TO_POINTER): Provide default
definitions.
(extract_address, store_address): Doc fixes.
* values.c (value_as_pointer): Doc fix.
(value_from_pointer): New function.
* defs.h (extract_typed_address, store_typed_address): New
declarations.
* inferior.h (generic_address_to_pointer,
generic_pointer_to_address): New declarations.
* value.h (value_from_pointer): New declaration.

* ax-gdb.c (const_var_ref): Use value_from_pointer, not
value_from_longest.
* blockframe.c (generic_push_dummy_frame): Use read_pc and
read_sp, not read_register.
* c-valprint.c (c_val_print): Use extract_typed_address instead of
extract_address to extract vtable entries and references.
* cp-valprint.c (cp_print_value_fields): Use value_from_pointer
instead of value_from_longest to extract the vtable's address.
* eval.c (evaluate_subexp_standard): Use value_from_pointer
instead of value_from_longest to compute `this', and for doing
pointer-to-member dereferencing.
* findvar.c (read_register): Use extract_unsigned_integer, not
extract_address.
(read_var_value): Use store_typed_address instead of store_address
for building label values.
(locate_var_value): Use value_from_pointer instead of
value_from_longest.
* hppa-tdep.c (find_stub_with_shl_get): Use value_from_pointer,
instead of value_from_longest, to build arguments to __d_shl_get.
* printcmd.c (set_next_address): Use value_from_pointer, not
value_from_longest.
(x_command): Use value_from_pointer, not value_from_longest.
* tracepoint.c (set_traceframe_context): Use value_from_pointer,
not value_from_longest.
* valarith.c (value_add, value_sub): Use value_from_pointer, not
value_from_longest.
* valops.c (find_function_in_inferior, value_coerce_array,
value_coerce_function, value_addr, hand_function_call): Same.
* value.h (COERCE_REF): Use unpack_pointer, not unpack_long.
* values.c (unpack_long): Use extract_typed_address to produce
addresses from pointers and references, not extract_address.
(value_from_longest): Use store_typed_address instead of
store_address to produce pointer and reference values.
@
text
@a1130 12
/* If we're calling a function declared without a prototype, should we
   promote floats to doubles?  FORMAL and ACTUAL are the types of the
   arguments; FORMAL may be NULL.

   If we have no definition for this macro, either from the target or
   from gdbarch, provide a default.  */
#ifndef COERCE_FLOAT_TO_DOUBLE
#define COERCE_FLOAT_TO_DOUBLE(formal, actual) \
  (default_coerce_float_to_double ((formal), (actual)))
#endif


@


1.8
log
@Compare VALUE_ADDRESS() return value with ZERO not NULL.
@
text
@d111 1
a111 1
	  LONGEST maddr;
d115 2
a116 2
	  maddr = (LONGEST) SYMBOL_VALUE_ADDRESS (msymbol);
	  return value_from_longest (type, maddr);
d904 2
a905 2
  return value_from_longest (lookup_pointer_type (TYPE_TARGET_TYPE (type)),
		    (LONGEST) (VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1)));
d920 2
a921 2
  retval = value_from_longest (lookup_pointer_type (VALUE_TYPE (arg1)),
		    (LONGEST) (VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1)));
d951 4
a954 4
  arg2 = value_from_longest (lookup_pointer_type (VALUE_TYPE (arg1)),
			     (LONGEST) (VALUE_ADDRESS (arg1)
					+ VALUE_OFFSET (arg1)
					+ VALUE_EMBEDDED_OFFSET (arg1)));
d1585 2
a1586 2
	    args[i] = value_from_longest (lookup_pointer_type (arg_type),
					  (LONGEST) addr);
@


1.7
log
@C++ changes for 5.0, finally committed.
@
text
@d3361 1
a3361 1
      if (VALUE_ADDRESS(value_field(v,TYPE_VPTR_FIELDNO(known_type))) == NULL)
@


1.6
log
@From Daniel Berlin:
Fix C++ overloading, add support for seeing through references.
@
text
@d41 1
a41 1

d327 6
d420 1
a420 1
/* Return a value with type TYPE located at ADDR.  
d425 3
a427 3
   the data and sets the lazy-evaluation-required flag.  The lazy flag 
   is tested in the VALUE_CONTENTS macro, which is used if and when 
   the contents are actually required. 
d500 3
a502 3
/* Called only from the VALUE_CONTENTS and VALUE_CONTENTS_ALL macros, 
   if the current data for a variable needs to be loaded into 
   VALUE_CONTENTS(VAL).  Fetches the data from the user's process, and 
d1140 1
a1140 1
#endif   
d1253 1
a1253 1
/* Determine a function's address and its return type from its value. 
d1344 1
a1344 1
     bigger than REGISTER_SIZE.  
d1493 2
a1494 2
      /*elz: this code is to handle the case in which the function to be called 
         has a pointer to function as parameter and the corresponding actual argument 
d1498 2
a1499 2
         requires some registers setting, this is taken care of if we call 
         via a function pointer variable, but not via a function address. 
d1507 1
a1507 1
	      /* elz: FIXME here should go the test about the compiler used 
d1509 2
a1510 2
	         message only if the compiler used was HP's aCC. 
	         If we used HP's cc, then there is no problem and no need 
d1620 1
a1620 1
   of in the above code (ifdef REG_STRUCT_HAS_ADDR) and in 
d1651 1
a1651 1
     as appropriate.  Formerly this has been done in PUSH_ARGUMENTS, 
d1686 1
a1686 1
     Also note that on some machines (like the sparc) pcc uses a 
d2279 1
a2279 1
  /* pai: FIXME -- 32x64 problem, if word = 8 bytes, change multiplier 
d2784 1
a2784 1
	      if (TYPE_FN_FIELD_STUB (f, j))
d2872 2
a2873 3
#ifdef DEBUG_OLOAD
      /* FIXME: cagney/2000-03-12: Send the output to gdb_stderr.  See
         comments above about adding a ``set debug'' command. */
d2875 1
a2875 1
	printf ("Overloaded method instance %s, # of parms %d\n", fns_ptr[ix].physname, nparms);
d2877 1
a2877 1
	printf ("Overloaded function instance %s # of parms %d\n", SYMBOL_DEMANGLED_NAME (oload_syms[ix]), nparms);
d2879 3
a2881 3
	printf ("...Badness @@ %d : %d\n", jj, bv->rank[jj]);
      printf ("Overload resolution champion is %d, ambiguous? %d\n", oload_champ, oload_ambiguous);
#endif
a2882 1

d3214 2
a3215 5
 * 
 * This currently works only for RTTI information generated
 * by the HP ANSI C++ compiler (aCC).  g++ today (1997-06-10)
 * does not appear to support RTTI. This function returns a
 * NULL value for objects in the g++ runtime model. */
d3245 99
d3345 18
a3362 32
  /* If neither the declared type nor the enclosing type of the
   * value structure has a HP ANSI C++ style virtual table,
   * we can't do anything. */
  if (!TYPE_HAS_VTABLE (known_type))
    {
      known_type = VALUE_ENCLOSING_TYPE (v);
      CHECK_TYPEDEF (known_type);
      if ((TYPE_CODE (known_type) != TYPE_CODE_CLASS) ||
	  !TYPE_HAS_VTABLE (known_type))
	return NULL;		/* No RTTI, or not HP-compiled types */
      CHECK_TYPEDEF (known_type);
      using_enclosing = 1;
    }

  if (using_enclosing && using_enc)
    *using_enc = 1;

  /* First get the virtual table address */
  coreptr = *(CORE_ADDR *) ((VALUE_CONTENTS_ALL (v))
			    + VALUE_OFFSET (v)
		       + (using_enclosing ? 0 : VALUE_EMBEDDED_OFFSET (v)));
  if (coreptr == 0)
    return NULL;		/* return silently -- maybe called on gdb-generated value */

  /* Fetch the top offset of the object */
  /* FIXME possible 32x64 problem with pointer size & arithmetic */
  vp = value_at (builtin_type_int,
		 coreptr + 4 * HP_ACC_TOP_OFFSET_OFFSET,
		 VALUE_BFD_SECTION (v));
  top_offset = value_as_long (vp);
  if (top)
    *top = top_offset;
d3364 17
a3380 24
  /* Fetch the typeinfo pointer */
  /* FIXME possible 32x64 problem with pointer size & arithmetic */
  vp = value_at (builtin_type_int, coreptr + 4 * HP_ACC_TYPEINFO_OFFSET, VALUE_BFD_SECTION (v));
  /* Indirect through the typeinfo pointer and retrieve the pointer
   * to the string name */
  coreptr = *(CORE_ADDR *) (VALUE_CONTENTS (vp));
  if (!coreptr)
    error ("Retrieved null typeinfo pointer in trying to determine run-time type");
  vp = value_at (builtin_type_int, coreptr + 4, VALUE_BFD_SECTION (v));		/* 4 -> offset of name field */
  /* FIXME possible 32x64 problem */

  coreptr = *(CORE_ADDR *) (VALUE_CONTENTS (vp));

  read_memory_string (coreptr, rtti_type_name, 256);

  if (strlen (rtti_type_name) == 0)
    error ("Retrieved null type name from typeinfo");

  /* search for type */
  rtti_type = lookup_typename (rtti_type_name, (struct block *) 0, 1);

  if (!rtti_type)
    error ("Could not find run-time type: invalid type name %s in typeinfo??", rtti_type_name);
  CHECK_TYPEDEF (rtti_type);
d3382 4
a3385 3
#if 0				/* debugging */
  printf ("RTTI type name %s, tag %s, full? %d\n", TYPE_NAME (rtti_type), TYPE_TAG_NAME (rtti_type), full ? *full : -1);
#endif
d3387 3
a3389 2
  /* Check whether we have the entire object */
  if (full			/* Non-null pointer passed */
d3391 2
a3392 12
      &&
  /* Either we checked on the whole object in hand and found the
     top offset to be zero */
      (((top_offset == 0) &&
	using_enclosing &&
	TYPE_LENGTH (known_type) == TYPE_LENGTH (rtti_type))
       ||
  /* Or we checked on the embedded object and top offset was the
     same as the embedded offset */
       ((top_offset == VALUE_EMBEDDED_OFFSET (v)) &&
	!using_enclosing &&
	TYPE_LENGTH (VALUE_ENCLOSING_TYPE (v)) == TYPE_LENGTH (rtti_type))))
d3394 2
a3395 1
    *full = 1;
d3397 26
d3669 4
a3672 4
/* Create a value for a FORTRAN complex number.  Currently most of 
   the time values are coerced to COMPLEX*16 (i.e. a complex number 
   composed of 2 doubles.  This really should be a smarter routine 
   that figures out precision inteligently as opposed to assuming 
@


1.5
log
@Revert: ``Fix C++ overload support, see through references''.
Change also contained numerous white-space changes.
@
text
@d2071 1
a2071 1
	if (t_field_name && STREQ (t_field_name, name))
d2086 1
a2086 1
		    && STREQ (t_field_name, "else"))))
d2131 1
a2131 1
			     && STREQ (name, TYPE_BASECLASS_NAME (type, i)));
d2317 1
a2317 1
      if (t_field_name && STREQ (t_field_name, name))
d2573 1
a2573 1
      if (fn_field_name && STREQ (fn_field_name, method))
d2743 3
d2762 20
d2808 17
a2824 3
      /* Number of parameters for current candidate */
      nparms = method ? TYPE_NFIELDS (fns_ptr[ix].type)
	: TYPE_NFIELDS (SYMBOL_TYPE (oload_syms[ix]));
d2829 3
a2831 2
	parm_types[jj] = method ? TYPE_FIELD_TYPE (fns_ptr[ix].type, jj)
	  : TYPE_FIELD_TYPE (SYMBOL_TYPE (oload_syms[ix]), jj);
d2867 2
d2873 1
a2873 1
      for (jj = 0; jj <= nargs; jj++)
d2879 5
d2895 1
d2992 1
a2992 1
      if (t_field_name && STREQ (t_field_name, name))
d3009 1
a3009 1
      if (STREQ (TYPE_FN_FIELDLIST_NAME (type, i), name))
@


1.4
log
@Fix C++ overload support, see through references
@
text
@d243 2
a244 2
	 type of the target as a superclass.  If so, we'll need to
	 offset the object in addition to changing its type.  */
d300 2
a301 2
		 type of the target as a superclass.  If so, we'll need to
		 offset the pointer rather than just change its type.  */
d315 3
a317 3
		 type of the source as a superclass.  If so, we'll need to
		 offset the pointer rather than just change its type.
		 FIXME: This fails silently with virtual inheritance.  */
d414 1
a414 1
/* Return a value with type TYPE located at ADDR.
d419 3
a421 3
   the data and sets the lazy-evaluation-required flag.  The lazy flag
   is tested in the VALUE_CONTENTS macro, which is used if and when
   the contents are actually required.
d494 3
a496 3
/* Called only from the VALUE_CONTENTS and VALUE_CONTENTS_ALL macros,
   if the current data for a variable needs to be loaded into
   VALUE_CONTENTS(VAL).  Fetches the data from the user's process, and
d691 4
a694 4
	 (architecture and calling convention specific) registers may
	 cause the frame cache to be out of date.  We just do this
	 on all assignments to registers for simplicity; I doubt the slowdown
	 matters.  */
d932 2
a933 2
	 We keep the same location information, which is efficient,
	 and allows &(&X) to get the location containing the reference. */
d1134 1
a1134 1
#endif
d1202 2
a1203 2
	 type for an argument.  We may have to conditionalize the following
	 type coercion for future targets.  */
d1209 3
a1211 3
	 non-prototyped case.  As many debugging formats include
	 no information about prototyping, we have to live with
	 COERCE_FLOAT_TO_DOUBLE for now.  */
d1247 1
a1247 1
/* Determine a function's address and its return type from its value.
d1290 1
a1290 1
	 Their values are characters since their addresses are char */
d1338 1
a1338 1
     bigger than REGISTER_SIZE.
d1474 2
a1475 2
	 promotions.  FIXME: if we had a prototype, this should only
	 be allowed if ... were present.  */
d1487 8
a1494 8
      /*elz: this code is to handle the case in which the function to be called
	 has a pointer to function as parameter and the corresponding actual argument
	 is the address of a function and not a pointer to function variable.
	 In aCC compiled code, the calls through pointers to functions (in the body
	 of the function called by hand) are made via $$dyncall_external which
	 requires some registers setting, this is taken care of if we call
	 via a function pointer variable, but not via a function address.
	 In cc this is not a problem. */
d1501 5
a1505 5
	      /* elz: FIXME here should go the test about the compiler used
		 to compile the target. We want to issue the error
		 message only if the compiler used was HP's aCC.
		 If we used HP's cc, then there is no problem and no need
		 to return at this point */
d1594 2
a1595 2
	 really broken.  Better to let PUSH_ARGUMENTS adjust the stack in
	 a target-defined manner.  */
d1614 1
a1614 1
   of in the above code (ifdef REG_STRUCT_HAS_ADDR) and in
d1645 1
a1645 1
     as appropriate.  Formerly this has been done in PUSH_ARGUMENTS,
d1655 1
a1655 1
	 that sp already has been advanced for the arguments!  */
d1680 1
a1680 1
     Also note that on some machines (like the sparc) pcc uses a
d1736 1
a1736 1
	if (unwind_on_signal_p)
d1740 2
a1741 2
	    /* We must get back to the frame we were before the dummy call. */
	    POP_FRAME;
d2035 2
a2036 2
	 of the ARM), but as a quick kludge, just check for the same type
	 code.  */
d2071 1
a2071 1
	if (t_field_name && STREQ_IW (t_field_name, name))
d2086 1
a2086 1
		    && STREQ_IW (t_field_name, "else"))))
d2127 2
a2128 2
	 hit them.  But it could happen that the base part's member name
	 is not yet filled in.  */
d2131 1
a2131 1
			     && STREQ_IW (name, TYPE_BASECLASS_NAME (type, i)));
d2273 1
a2273 1
  /* pai: FIXME -- 32x64 problem, if word = 8 bytes, change multiplier
d2317 1
a2317 1
      if (t_field_name && !strcmp_iw (t_field_name, name))
d2354 1
a2354 1
		 according to HP/Taligent runtime spec.  */
d2369 2
a2370 2
		 user program. Make sure that it still points to a valid memory
		 location.  */
d2470 1
a2470 1
	 is less work to be done.  */
d2476 1
a2476 1
	 return it as a pointer to a method.  */
d2528 2
a2529 2
	 hand it back.  If it's not callable (i.e., a pointer to function),
	 gdb should give an error.  */
d2573 1
a2573 1
      if (fn_field_name && STREQ_IW (fn_field_name, method))
a2738 3
  int i,j,len,len2;
  struct type *domain;
  struct fn_field *f;
d2745 1
a2745 1
	 value rather than the object itself, so try again */
a2758 20
      domain=TYPE_DOMAIN_TYPE(fns_ptr[0].type);
      len = TYPE_NFN_FIELDS (domain);
      /*This stuff is for STABS, which won't give us the info we need directly in the types.
       * We have to use the method stub conversion to get it.
       * Be aware that this is by no means perfect, and if you use
       * STABS, please move to DWARF-2, or something like it, because
       * trying to improve overloading using STABS is really a waste
       * of time.
       */
      for (i = 0; i < len; i++)
	{
	  f = TYPE_FN_FIELDLIST1 (domain, i);
	  len2 = TYPE_FN_FIELDLIST_LENGTH (domain, i);

	  for (j = 0; j < len2; j++)
	    {
	      if (TYPE_FN_FIELD_STUB (f, j))
		check_stub_method (domain, i, j);
	    }
	}
d2766 1
a2766 1
	 Just return the same symbol. */
d2768 1
a2768 1
	{
d2770 2
a2771 2
	  return 0;
	}
d2785 3
a2787 17
      if (method)
	{
	  /* For static member functions, we won't have a this pointer, but nothing
	     else seems to handle them right now, so we just pretend ourselves */
	  nparms=0;

	  if (TYPE_FN_FIELD_ARGS(fns_ptr,ix))
	    {
	      while (TYPE_CODE(TYPE_FN_FIELD_ARGS(fns_ptr,ix)[nparms]) != TYPE_CODE_VOID)
		nparms++;
	    }
	}
      else
	{
	  /* If it's not a method, this is the proper place */
	  nparms=TYPE_NFIELDS(SYMBOL_TYPE(oload_syms[ix]));
	}
d2792 1
a2792 1
	parm_types[jj] = method ? (TYPE_FN_FIELD_ARGS(fns_ptr,ix)[jj])
d2833 1
a2833 1
      for (jj = 0; jj < nargs; jj++)
a2838 4
/* Seems to be a better idea to just pick one if they have the exact same goodness.
 * This is because there is no way to differentiate based on return type, which we need
 * to in cases like overloads of .begin() <It's both const and non-const> */
#if 0
a2849 1
#endif
d2946 1
a2946 1
      if (t_field_name && STREQ_IW (t_field_name, name))
d2963 1
a2963 1
      if (STREQ_IW (TYPE_FN_FIELDLIST_NAME (type, i), name))
d3164 1
a3164 1
 *
d3484 2
a3485 2
	 can be used on the LHS, but that may require extensions to
	 value_assign.  For now, just leave as a non_lval.  FIXME.  */
d3525 4
a3528 4
/* Create a value for a FORTRAN complex number.  Currently most of
   the time values are coerced to COMPLEX*16 (i.e. a complex number
   composed of 2 doubles.  This really should be a smarter routine
   that figures out precision inteligently as opposed to assuming
@


1.3
log
@2000-02-23  Fernando Nasser  <fnasser@@cygnus.com>

        * infcmd.c (run_stack_dummy): Do not pop frame on random signal.
        * valops.c (_initialize_valops): Add command "set unwindonsignal".
        (hand_function_call): Test for unwind_on_signal and act accordingly.
@
text
@d243 2
a244 2
         type of the target as a superclass.  If so, we'll need to
         offset the object in addition to changing its type.  */
d300 2
a301 2
	         type of the target as a superclass.  If so, we'll need to
	         offset the pointer rather than just change its type.  */
d315 3
a317 3
	         type of the source as a superclass.  If so, we'll need to
	         offset the pointer rather than just change its type.
	         FIXME: This fails silently with virtual inheritance.  */
d414 1
a414 1
/* Return a value with type TYPE located at ADDR.  
d419 3
a421 3
   the data and sets the lazy-evaluation-required flag.  The lazy flag 
   is tested in the VALUE_CONTENTS macro, which is used if and when 
   the contents are actually required. 
d494 3
a496 3
/* Called only from the VALUE_CONTENTS and VALUE_CONTENTS_ALL macros, 
   if the current data for a variable needs to be loaded into 
   VALUE_CONTENTS(VAL).  Fetches the data from the user's process, and 
d691 4
a694 4
         (architecture and calling convention specific) registers may
         cause the frame cache to be out of date.  We just do this
         on all assignments to registers for simplicity; I doubt the slowdown
         matters.  */
d932 2
a933 2
         We keep the same location information, which is efficient,
         and allows &(&X) to get the location containing the reference. */
d1134 1
a1134 1
#endif   
d1202 2
a1203 2
         type for an argument.  We may have to conditionalize the following
         type coercion for future targets.  */
d1209 3
a1211 3
         non-prototyped case.  As many debugging formats include
         no information about prototyping, we have to live with
         COERCE_FLOAT_TO_DOUBLE for now.  */
d1247 1
a1247 1
/* Determine a function's address and its return type from its value. 
d1290 1
a1290 1
         Their values are characters since their addresses are char */
d1338 1
a1338 1
     bigger than REGISTER_SIZE.  
d1474 2
a1475 2
         promotions.  FIXME: if we had a prototype, this should only
         be allowed if ... were present.  */
d1487 8
a1494 8
      /*elz: this code is to handle the case in which the function to be called 
         has a pointer to function as parameter and the corresponding actual argument 
         is the address of a function and not a pointer to function variable.
         In aCC compiled code, the calls through pointers to functions (in the body
         of the function called by hand) are made via $$dyncall_external which
         requires some registers setting, this is taken care of if we call 
         via a function pointer variable, but not via a function address. 
         In cc this is not a problem. */
d1501 5
a1505 5
	      /* elz: FIXME here should go the test about the compiler used 
	         to compile the target. We want to issue the error
	         message only if the compiler used was HP's aCC. 
	         If we used HP's cc, then there is no problem and no need 
	         to return at this point */
d1594 2
a1595 2
         really broken.  Better to let PUSH_ARGUMENTS adjust the stack in
         a target-defined manner.  */
d1614 1
a1614 1
   of in the above code (ifdef REG_STRUCT_HAS_ADDR) and in 
d1645 1
a1645 1
     as appropriate.  Formerly this has been done in PUSH_ARGUMENTS, 
d1655 1
a1655 1
         that sp already has been advanced for the arguments!  */
d1680 1
a1680 1
     Also note that on some machines (like the sparc) pcc uses a 
d1736 1
a1736 1
        if (unwind_on_signal_p)
d1740 2
a1741 2
            /* We must get back to the frame we were before the dummy call. */
            POP_FRAME;
d2035 2
a2036 2
         of the ARM), but as a quick kludge, just check for the same type
         code.  */
d2071 1
a2071 1
	if (t_field_name && STREQ (t_field_name, name))
d2086 1
a2086 1
		    && STREQ (t_field_name, "else"))))
d2127 2
a2128 2
         hit them.  But it could happen that the base part's member name
         is not yet filled in.  */
d2131 1
a2131 1
			     && STREQ (name, TYPE_BASECLASS_NAME (type, i)));
d2273 1
a2273 1
  /* pai: FIXME -- 32x64 problem, if word = 8 bytes, change multiplier 
d2317 1
a2317 1
      if (t_field_name && STREQ (t_field_name, name))
d2354 1
a2354 1
	         according to HP/Taligent runtime spec.  */
d2369 2
a2370 2
	         user program. Make sure that it still points to a valid memory
	         location.  */
d2470 1
a2470 1
         is less work to be done.  */
d2476 1
a2476 1
         return it as a pointer to a method.  */
d2528 2
a2529 2
         hand it back.  If it's not callable (i.e., a pointer to function),
         gdb should give an error.  */
d2573 1
a2573 1
      if (fn_field_name && STREQ (fn_field_name, method))
d2739 3
d2748 1
a2748 1
         value rather than the object itself, so try again */
d2762 20
d2789 1
a2789 1
         Just return the same symbol. */
d2791 1
a2791 1
        {
d2793 2
a2794 2
          return 0;
        }
d2808 17
a2824 3
      /* Number of parameters for current candidate */
      nparms = method ? TYPE_NFIELDS (fns_ptr[ix].type)
	: TYPE_NFIELDS (SYMBOL_TYPE (oload_syms[ix]));
d2829 1
a2829 1
	parm_types[jj] = method ? TYPE_FIELD_TYPE (fns_ptr[ix].type, jj)
d2870 1
a2870 1
      for (jj = 0; jj <= nargs; jj++)
d2876 4
d2891 1
d2988 1
a2988 1
      if (t_field_name && STREQ (t_field_name, name))
d3005 1
a3005 1
      if (STREQ (TYPE_FN_FIELDLIST_NAME (type, i), name))
d3206 1
a3206 1
 * 
d3526 2
a3527 2
         can be used on the LHS, but that may require extensions to
         value_assign.  For now, just leave as a non_lval.  FIXME.  */
d3567 4
a3570 4
/* Create a value for a FORTRAN complex number.  Currently most of 
   the time values are coerced to COMPLEX*16 (i.e. a complex number 
   composed of 2 doubles.  This really should be a smarter routine 
   that figures out precision inteligently as opposed to assuming 
@


1.2
log
@Bring COERCE_FLOAT_TO_DOUBLE under gdbarch's control.
* valops.c (COERCE_FLOAT_TO_DOUBLE): Rework definition to be
more function-like.
(default_coerce_float_to_double, standard_coerce_float_to_double):
New functions.
(value_arg_coerce): Adjust for new definition.
* value.h (default_coerce_float_to_double,
standard_coerce_float_to_double): New declarations for the above.
* gdbarch.sh (coerce_float_to_double): New entry, replacing macro.
* gdbarch.c, gdbarch.h: Regenerated.
* tm-alpha.h, tm-fr30.h, tm-m32r.h, tm-mips.h, tm-hppa.h,
tm-rs6000.h, tm-sh.h, tm-sparc.h (COERCE_FLOAT_TO_DOUBLE): Change
definitions.
* mips-tdep.c (mips_coerce_float_to_double): Supply our own custom
function here.
(mips_gdbarch_init): Install that as our coerce_float_to_double
function.
@
text
@d78 7
d1736 6
a1741 3
	/* In this case, we must do the cleanups because we don't
	   want the dummy anymore (the dummy frame has been poped already. */
	do_cleanups (old_chain);
d1743 26
a1768 4
	/* FIXME: Insert a bunch of wrap_here; name can be very long if it's
	   a C++ name with arguments and stuff.  */
	error ("\
The program being debugged stopped while in a function called from GDB.\n\
d1770 2
a1771 1
	       name);
d3598 9
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a36 9
/* Default to coercing float to double in function calls only when there is
   no prototype.  Otherwise on targets where the debug information is incorrect
   for either the prototype or non-prototype case, we can force it by defining
   COERCE_FLOAT_TO_DOUBLE in the target configuration file. */

#ifndef COERCE_FLOAT_TO_DOUBLE
#define COERCE_FLOAT_TO_DOUBLE (param_type == NULL)
#endif

d44 1
a44 1
static int typecmp PARAMS ((int staticp, struct type *t1[], value_ptr t2[]));
a45 1
#ifdef CALL_DUMMY
a47 1
#endif
a49 1
#ifndef PUSH_ARGUMENTS
a50 1
#endif
a54 4
static value_ptr search_struct_field_aux PARAMS ((char *, value_ptr, int,
                                                  struct type *, int, int *, char *,
                                                  struct type **));

d65 2
d78 1
a80 1

d100 1
a100 1
      struct minimal_symbol *msymbol = lookup_minimal_symbol(name, NULL, NULL);
d113 1
a113 1
          if (!target_has_execution)
d115 1
a115 1
          else
d136 3
a138 3
        error ("No memory available to program now: you need to start the target first");
      else 
        error ("No memory available to program: call to malloc failed");
d166 1
a166 1
  
d172 1
a172 1
  COERCE_REF(arg2);
d183 1
a183 1
	  && TYPE_ARRAY_UPPER_BOUND_TYPE (type) == BOUND_CANNOT_BE_DETERMINED)
d192 1
a192 1
	    warning("array element type size does not divide object size in cast");
d231 1
a231 1
  if (   code1 == TYPE_CODE_STRUCT
d236 2
a237 2
	 type of the target as a superclass.  If so, we'll need to
	 offset the object in addition to changing its type.  */
d253 24
a276 24
      
      if (hp_som_som_object_present &&  /* if target compiled by HP aCC */ 
          (code2 == TYPE_CODE_PTR))
        {
          unsigned int * ptr;
          value_ptr retvalp;
          
          switch (TYPE_CODE (TYPE_TARGET_TYPE (type2)))
            {
              /* With HP aCC, pointers to data members have a bias */ 
              case TYPE_CODE_MEMBER:
                retvalp = value_from_longest (type, value_as_long (arg2));
                ptr = (unsigned int *) VALUE_CONTENTS (retvalp); /* force evaluation */
                *ptr &= ~0x20000000; /* zap 29th bit to remove bias */ 
                return retvalp;

              /* While pointers to methods don't really point to a function */ 
              case TYPE_CODE_METHOD:
                error ("Pointers to methods not supported with HP aCC");

              default:
                break; /* fall out and go to normal handling */ 
            }
        }
d286 1
a286 1
	  if (   TYPE_CODE (t1) == TYPE_CODE_STRUCT
d293 2
a294 2
		 type of the target as a superclass.  If so, we'll need to
		 offset the pointer rather than just change its type.  */
d308 3
a310 3
		 type of the source as a superclass.  If so, we'll need to
		 offset the pointer rather than just change its type.
		 FIXME: This fails silently with virtual inheritance.  */
d314 1
a314 1
					   value_zero (t1, not_lval), 0, t1, 1);
d319 1
a319 1
					    + VALUE_OFFSET (v);
d329 2
a330 2
      VALUE_ENCLOSING_TYPE (arg2) = type;  /* pai: chk_val */
      VALUE_POINTED_TO_OFFSET (arg2) = 0;  /* pai: chk_val */
d348 1
a348 1
	       /* || TYPE_CODE (eltype1) != TYPE_CODE (eltype2) */ )))
d357 1
a357 1
	count1 = -1, count2 = 0;  /* To force error before */
d432 2
a433 2
#ifdef GDB_TARGET_IS_D10V
  if (TYPE_CODE (type) == TYPE_CODE_PTR
d441 2
a442 2
      num = D10V_MAKE_IADDR(snum);
      store_address ( VALUE_CONTENTS_RAW (val), 4, num);
d444 2
a445 1
  else if (TYPE_CODE(type) == TYPE_CODE_PTR)
d451 2
a452 2
      num = D10V_MAKE_DADDR(snum);
      store_address ( VALUE_CONTENTS_RAW (val), 4, num); 
a454 1
#endif
d506 3
a508 3
#ifdef GDB_TARGET_IS_D10V
  struct type *type = VALUE_TYPE(val);
  if (TYPE_CODE (type) == TYPE_CODE_PTR
d516 2
a517 2
      num = D10V_MAKE_IADDR(snum);
      store_address ( VALUE_CONTENTS_RAW (val), 4, num);
d519 2
a520 1
  else if (TYPE_CODE(type) == TYPE_CODE_PTR)
d526 2
a527 2
      num = D10V_MAKE_DADDR(snum);
      store_address ( VALUE_CONTENTS_RAW (val), 4, num); 
d529 1
a529 4
  else
#endif

  if (length)
d566 1
a566 3
#ifdef REGISTER_CONVERTIBLE
  if (VALUE_REGNO (toval) >= 0
      && REGISTER_CONVERTIBLE (VALUE_REGNO (toval)))
a576 1
#endif
d599 2
a600 2
        CORE_ADDR changed_addr;
        int changed_len;
d602 2
a603 2
        if (VALUE_BITSIZE (toval))
          {
d608 3
a610 3
		     + VALUE_BITSIZE (toval)
		     + HOST_CHAR_BIT - 1)
		    / HOST_CHAR_BIT;
d646 1
a646 1
          int len = REGISTER_RAW_SIZE (VALUE_REGNO (toval));
d656 2
a657 2
	    error ("\
Can't handle bitfield which doesn't fit in a single register.");
d659 6
a664 6
          read_register_bytes (VALUE_ADDRESS (toval) + VALUE_OFFSET (toval),
                               buffer, len);
          modify_field (buffer, value_as_long (fromval),
                        VALUE_BITPOS (toval), VALUE_BITSIZE (toval));
          write_register_bytes (VALUE_ADDRESS (toval) + VALUE_OFFSET (toval),
                                buffer, len);
d670 1
a670 1
        {
d675 1
a675 1
	  REGISTER_CONVERT_FROM_TYPE(VALUE_REGNO (toval), type, raw_buffer);
d680 1
a680 1
			        VALUE_CONTENTS (fromval), TYPE_LENGTH (type));
d684 4
a687 4
	 (architecture and calling convention specific) registers may
	 cause the frame cache to be out of date.  We just do this
	 on all assignments to registers for simplicity; I doubt the slowdown
	 matters.  */
d728 2
a729 2
				(int *)NULL, (CORE_ADDR *)NULL,
				frame, regno, (enum lval_type *)NULL);
d754 3
a756 3
	    get_saved_register ((char *)NULL,
			        &optim, &addr, frame, regno, &lval);
	    
d771 1
a771 1
	
d799 1
a799 1
  
d842 1
a842 1
        {
d849 1
a849 1
        }
d880 1
a880 1
   */
d892 1
a892 1
		       (LONGEST) (VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1)));
d908 1
a908 1
			       (LONGEST) (VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1)));
d911 1
a911 1
}  
d925 2
a926 2
	 We keep the same location information, which is efficient,
	 and allows &(&X) to get the location containing the reference. */
d937 1
a937 1
  /* Get target memory address */  
d939 3
a941 3
			       (LONGEST) (VALUE_ADDRESS (arg1) 
					  + VALUE_OFFSET (arg1)
					  + VALUE_EMBEDDED_OFFSET (arg1)));
d944 1
a944 1
     full derived object's type ... */ 
d946 2
a947 2
  /* ... and also the relative position of the subobject in the full object */ 
  VALUE_POINTED_TO_OFFSET (arg2) = VALUE_EMBEDDED_OFFSET (arg1);  
a959 1
  value_ptr real_val;
d980 1
a980 1
      /* Get the real type of the enclosing object */ 
d983 5
a987 5
      /* Retrieve the enclosing object pointed to */ 
      arg2 =  value_at_lazy (enc_type, 
			     value_as_pointer (arg1) - VALUE_POINTED_TO_OFFSET (arg1),
                             VALUE_BFD_SECTION (arg1));
      /* Re-adjust type */ 
d999 1
a999 1
  return 0;  /* For lint -- never reached */
d1055 3
a1057 1
/* Push onto the stack the specified value VALUE.  */
d1059 2
a1060 1
#ifndef PUSH_ARGUMENTS
d1068 13
d1085 2
a1086 2
      sp -= len;
      write_memory (sp, VALUE_CONTENTS_ALL (arg), len);
d1091 2
a1092 2
      write_memory (sp, VALUE_CONTENTS_ALL (arg), len);
      sp += len;
d1098 59
a1156 1
#endif	/* !PUSH_ARGUMENTS */
a1157 1
#ifdef CALL_DUMMY
d1172 1
a1172 1
    = param_type ? check_typedef (param_type) : arg_type;
d1195 2
a1196 2
	 type for an argument.  We may have to conditionalize the following
	 type coercion for future targets.  */
d1202 4
a1205 4
	 non-prototyped case.  As many debugging formats include
	 no information about prototyping, we have to live with
	 COERCE_FLOAT_TO_DOUBLE for now.  */
      if (!is_prototyped && COERCE_FLOAT_TO_DOUBLE)
d1283 1
a1283 1
	 Their values are characters since their addresses are char */
d1317 3
a1319 2
value_ptr
call_function_by_hand (function, nargs, args)
d1326 1
d1334 11
a1344 7
           sequence of instructions.  But CISC machines will have
           to pack the instructions into REGISTER_SIZE units (and
           so will RISC machines for which INSTRUCTION_SIZE is not
           REGISTER_SIZE). */

  static ULONGEST dummy[] = CALL_DUMMY;
  char dummy1[REGISTER_SIZE * sizeof dummy / sizeof (ULONGEST)];
d1349 1
a1349 1
  struct inferior_status inf_status;
d1352 1
a1352 1
  int using_gcc;	/* Set to version of gcc in use, or zero if not gcc */
d1357 5
d1363 1
a1363 1
    noprocess();
d1365 3
a1367 3
  save_inferior_status (&inf_status, 1);
  old_chain = make_cleanup ((make_cleanup_func) restore_inferior_status, 
                            &inf_status);
d1379 1
a1379 1
      sp -= sizeof dummy1;
d1386 1
a1386 1
      sp += sizeof dummy1;
d1406 1
a1406 1
  for (i = 0; i < (int) (sizeof (dummy) / sizeof (dummy[0])); i++)
d1409 1
a1409 1
			    (ULONGEST)dummy[i]);
d1420 20
a1439 20
#if CALL_DUMMY_LOCATION == ON_STACK
  write_memory (start_sp, (char *)dummy1, sizeof dummy1);
#endif /* On stack.  */

#if CALL_DUMMY_LOCATION == BEFORE_TEXT_END
  /* Convex Unix prohibits executing in the stack segment. */
  /* Hope there is empty room at the top of the text segment. */
  {
    extern CORE_ADDR text_end;
    static checked = 0;
    if (!checked)
      for (start_sp = text_end - sizeof dummy1; start_sp < text_end; ++start_sp)
	if (read_memory_integer (start_sp, 1) != 0)
	  error ("text segment full -- no place to put call");
    checked = 1;
    sp = old_sp;
    real_pc = text_end - sizeof dummy1;
    write_memory (real_pc, (char *)dummy1, sizeof dummy1);
  }
#endif /* Before text_end.  */
d1441 10
a1450 11
#if CALL_DUMMY_LOCATION == AFTER_TEXT_END
  {
    extern CORE_ADDR text_end;
    int errcode;
    sp = old_sp;
    real_pc = text_end;
    errcode = target_write_memory (real_pc, (char *)dummy1, sizeof dummy1);
    if (errcode != 0)
      error ("Cannot write text segment -- call_function failed");
  }
#endif /* After text_end.  */
d1452 4
a1455 3
#if CALL_DUMMY_LOCATION == AT_ENTRY_POINT
  real_pc = funaddr;
#endif /* At entry point.  */
d1458 1
a1458 1
  sp = old_sp;		/* It really is used, for some ifdef's... */
d1467 2
a1468 2
	 promotions.  FIXME: if we had a prototype, this should only
	 be allowed if ... were present.  */
d1472 1
a1472 1
      else 
d1481 7
a1487 7
	has a pointer to function as parameter and the corresponding actual argument 
	is the address of a function and not a pointer to function variable.
	In aCC compiled code, the calls through pointers to functions (in the body
	of the function called by hand) are made via $$dyncall_external which
	requires some registers setting, this is taken care of if we call 
	via a function pointer variable, but not via a function address. 
	In cc this is not a problem. */
d1491 1
a1491 1
	  /* if this parameter is a pointer to function*/
d1495 5
a1499 5
                    to compile the target. We want to issue the error
                    message only if the compiler used was HP's aCC. 
                    If we used HP's cc, then there is no problem and no need 
                    to return at this point */
	      if (using_gcc == 0) /* && compiler == aCC*/
d1501 1
a1501 1
                pointer to function or just a function */
d1505 2
a1506 2
		    if (find_pc_partial_function((CORE_ADDR)args[i]->aligner.contents[0], &arg_name, NULL, NULL))
		      error("\
d1509 1
a1509 1
		  }   
d1527 2
a1528 2
	     )
	  && REG_STRUCT_HAS_ADDR (using_gcc, arg_type))
d1531 4
a1534 4
	    int len; /*  = TYPE_LENGTH (arg_type); */ 
            int aligned_len;
            arg_type = check_typedef (VALUE_ENCLOSING_TYPE (args[i])); 
            len = TYPE_LENGTH (arg_type);
d1537 3
a1539 3
  /* MVS 11/22/96: I think at least some of this stack_align code is
     really broken.  Better to let PUSH_ARGUMENTS adjust the stack in
     a target-defined manner.  */
d1571 2
a1572 2
					  (LONGEST) addr);*/
	    args[i] = value_from_longest (lookup_pointer_type (arg_type), 
d1586 3
a1588 3
  /* MVS 11/22/96: I think at least some of this stack_align code is
     really broken.  Better to let PUSH_ARGUMENTS adjust the stack in
     a target-defined manner.  */
d1608 1
a1608 1
   hppa_push_arguments*/
d1622 2
a1623 3
#ifdef CALL_DUMMY_STACK_ADJUST
      len += CALL_DUMMY_STACK_ADJUST;
#endif
d1629 1
a1629 6
#ifdef PUSH_ARGUMENTS
  PUSH_ARGUMENTS(nargs, args, sp, struct_return, struct_addr);
#else /* !PUSH_ARGUMENTS */
  for (i = nargs - 1; i >= 0; i--)
    sp = value_push (sp, args[i]);
#endif /* !PUSH_ARGUMENTS */
d1641 2
a1642 2
  sp = PUSH_RETURN_ADDRESS(real_pc, sp);
#endif	/* PUSH_RETURN_ADDRESS */
d1645 1
a1645 1
  if (! INNER_THAN (1, 2))
d1648 3
a1650 4
	 that sp already has been advanced for the arguments!  */
#ifdef CALL_DUMMY_STACK_ADJUST
      sp += CALL_DUMMY_STACK_ADJUST;
#endif
d1660 6
a1665 7
#ifdef CALL_DUMMY_STACK_ADJUST
  if (INNER_THAN (1, 2))
    {
      /* stack grows downward */
      sp -= CALL_DUMMY_STACK_ADJUST;
    }
#endif /* CALL_DUMMY_STACK_ADJUST */
d1685 4
d1722 3
a1724 1
    if (run_stack_dummy (real_pc + CALL_DUMMY_START_OFFSET, retbuf))
d1726 14
a1739 1
	/* We stopped somewhere besides the call dummy.  */
d1741 8
a1748 4
	/* If we did the cleanups, we would print a spurious error message
	   (Unable to restore previously selected frame), would write the
	   registers from the inf_status (which is wrong), and would do other
	   wrong things (like set stop_bpstat to the wrong thing).  */
d1750 1
a1750 2
	/* Prevent memory leak.  */
	bpstat_clear (&inf_status.stop_bpstat);
d1768 1
d1778 1
a1778 1
*/
d1788 1
a1788 1
#else /* no CALL_DUMMY.  */
d1795 8
a1802 1
  error ("Cannot invoke functions on this machine.");
d1804 2
a1805 1
#endif /* no CALL_DUMMY.  */
a1806 1

d1850 2
a1851 2
  arraytype = create_array_type ((struct type *) NULL, 
				 VALUE_ENCLOSING_TYPE (elemvec[0]), rangetype);
d1903 1
a1903 1
    = create_string_type ((struct type *) NULL, rangetype);
d1932 1
a1932 1
  struct type *type = create_set_type ((struct type*) NULL, domain_type);
d1968 4
a1971 2
  if (TYPE_CODE (t1[0]) == TYPE_CODE_VOID) return 0;
  if (t1[!staticp] == 0) return 0;
d1974 3
a1976 3
    struct type *tt1, *tt2;
      if (! t2[i])
	return i+1;
d1978 1
a1978 1
      tt2 = check_typedef (VALUE_TYPE(t2[i]));
d1980 1
a1980 1
	  /* We should be doing hairy argument matching, as below.  */
d1991 2
a1992 2
	  && (   TYPE_CODE (tt2) == TYPE_CODE_ARRAY
	      || TYPE_CODE (tt2) == TYPE_CODE_PTR))
d1994 2
a1995 2
	   tt1 = check_typedef (TYPE_TARGET_TYPE(tt1)); 
	   tt2 = check_typedef (TYPE_TARGET_TYPE(tt2));
d1997 2
a1998 1
      if (TYPE_CODE(tt1) == TYPE_CODE(tt2)) continue;
d2002 2
a2003 2
	 of the ARM), but as a quick kludge, just check for the same type
	 code.  */
d2005 1
a2005 1
	return i+1;
d2007 3
a2009 2
  if (!t1[i]) return 0;
  return t2[i] ? i+1 : 0;
d2033 1
a2033 1
  if (! looking_for_baseclass)
d2046 1
a2046 1
	      error("there is no field named %s", name);
d2067 1
a2067 1
		   
d2089 1
a2089 1
  for (i = 0;  i < nbases;  i++)
d2094 2
a2095 2
	 hit them.  But it could happen that the base part's member name
	 is not yet filled in.  */
d2108 1
a2108 1
					+ VALUE_OFFSET (arg1) + offset);
d2120 1
a2120 1
	
d2150 1
a2150 1
				 offset + TYPE_BASECLASS_BITPOS (type, i) / 8,
d2152 2
a2153 1
      if (v) return v;
d2178 7
a2184 7
find_rt_vbase_offset(type, basetype, valaddr, offset, boffset_p, skip_p)
  struct type * type;
  struct type * basetype;
  char * valaddr;
  int offset;
  int * boffset_p;
  int * skip_p;
d2186 2
a2187 2
  int boffset;           /* offset of virtual base */
  int index;             /* displacement to use in virtual table */
d2189 4
a2192 4
  
  value_ptr vp;      
  CORE_ADDR vtbl;      /* the virtual table pointer */
  struct type * pbc;   /* the primary base class */
d2197 1
a2197 1
  
d2199 1
a2199 1
  pbc = TYPE_PRIMARY_BASE(type);
d2204 5
a2208 5
        {
          *boffset_p = boffset;
          *skip_p = -1;
          return;
        }
d2218 6
a2223 5
  if (index < 0) {
    *skip_p = skip + virtual_base_list_length_skip_primaries (type);
    *boffset_p = 0;
    return;
  }
d2225 1
a2225 1
  /* pai: FIXME -- 32x64 possible problem */ 
d2227 1
a2227 1
  vtbl = * (CORE_ADDR *) (valaddr + offset);
d2229 1
a2229 1
  /* Before the constructor is invoked, things are usually zero'd out. */ 
d2239 1
a2239 1
  
d2241 1
a2241 1
     & use long type */ 
d2244 1
a2244 1
   vp = value_at (builtin_type_int, vtbl + 4 * (- skip - index - HP_ACC_VBASE_START), NULL);
d2275 3
a2277 3
      if (strncmp(t_field_name, "__", 2)==0 ||
	strncmp(t_field_name, "op", 2)==0 ||
	strncmp(t_field_name, "type", 4)==0 )
d2279 3
a2281 1
	  if (cplus_demangle_opname(t_field_name, dem_opname, DMGL_ANSI))
a2282 2
	  else if (cplus_demangle_opname(t_field_name, dem_opname, 0))
	    t_field_name = dem_opname; 
d2288 1
a2288 1
 	  name_matched = 1; 
d2304 2
a2305 1
		  if (v != NULL) return v;
d2318 32
a2349 32
         if (TYPE_HAS_VTABLE (type))
            {
              /* HP aCC compiled type, search for virtual base offset
                 according to HP/Taligent runtime spec.  */
              int skip;
              find_rt_vbase_offset (type, TYPE_BASECLASS (type, i),
                                    VALUE_CONTENTS_ALL (*arg1p),
                                    offset + VALUE_EMBEDDED_OFFSET (*arg1p),
                                    &base_offset, &skip);
              if (skip >= 0)
                error ("Virtual base class offset not found in vtable");
            }
         else
           {
             struct type *baseclass = check_typedef (TYPE_BASECLASS (type, i));
	     char *base_valaddr;

	     /* The virtual base class pointer might have been clobbered by the
	        user program. Make sure that it still points to a valid memory
	        location.  */

	     if (offset < 0 || offset >= TYPE_LENGTH (type))
	       {
	         base_valaddr = (char *) alloca (TYPE_LENGTH (baseclass));
	         if (target_read_memory (VALUE_ADDRESS (*arg1p)
			 		 + VALUE_OFFSET (*arg1p) + offset,
				         base_valaddr,
				         TYPE_LENGTH (baseclass)) != 0)
		   error ("virtual baseclass botch");
	       }
	    else
	       base_valaddr = VALUE_CONTENTS (*arg1p) + offset;
d2351 8
a2358 8
	    base_offset =
	       baseclass_offset (type, i, base_valaddr,
			         VALUE_ADDRESS (*arg1p)
				   + VALUE_OFFSET (*arg1p) + offset);
	    if (base_offset == -1)
	       error ("virtual baseclass botch");
	   }
        }
d2362 1
a2362 1
        }
d2365 1
a2365 1
      if (v == (value_ptr) -1)
d2372 1
a2372 1
/*	  *arg1p = arg1_tmp;*/
d2374 1
a2374 1
        }
d2376 4
a2379 2
  if (name_matched) return (value_ptr) -1;
  else return NULL;
d2424 1
a2424 1
  if (   TYPE_CODE (t) != TYPE_CODE_STRUCT
d2430 1
a2430 1
    *static_memfuncp =0;
d2437 1
a2437 1
	 is less work to be done.  */
d2450 1
a2450 1
      if (v == (value_ptr) -1)
d2488 1
a2488 1
  if (v == (value_ptr) -1)
d2490 1
a2490 1
	error("Argument list of %s mismatch with component in the structure.", name);
d2495 2
a2496 2
	 hand it back.  If it's not callable (i.e., a pointer to function),
	 gdb should give an error.  */
d2518 1
a2518 1
struct fn_field *
d2520 8
a2527 8
  value_ptr *argp;
  char * method;
  int offset;
  int * static_memfuncp;
  struct type * type;
  int * num_fns;
  struct type ** basetype;
  int * boffset;
d2530 1
a2530 1
  struct fn_field * f;
d2535 2
a2536 2
  /* First check in object itself */ 
  for (i = TYPE_NFN_FIELDS (type) -1; i >= 0; i--)
d2539 1
a2539 1
      char * fn_field_name = TYPE_FN_FIELDLIST_NAME (type, i);
d2541 6
a2546 6
        {
          *num_fns = TYPE_FN_FIELDLIST_LENGTH (type, i);
          *basetype = type;
          *boffset = offset;
          return TYPE_FN_FIELDLIST1 (type, i);
        }
d2548 1
a2548 1
  
d2555 26
a2580 25
          if (TYPE_HAS_VTABLE (type))
            {
              /* HP aCC compiled type, search for virtual base offset
               * according to HP/Taligent runtime spec.  */
              int skip;
              find_rt_vbase_offset (type, TYPE_BASECLASS (type, i),
                                    VALUE_CONTENTS_ALL (*argp),
                                    offset + VALUE_EMBEDDED_OFFSET (*argp),
                                    &base_offset, &skip);
              if (skip >= 0)
                error ("Virtual base class offset not found in vtable");
            }
          else
            {
              /* probably g++ runtime model */ 
              base_offset = VALUE_OFFSET (*argp) + offset;
              base_offset =
                baseclass_offset (type, i,
                                  VALUE_CONTENTS (*argp) + base_offset,
                                  VALUE_ADDRESS (*argp) + base_offset);
              if (base_offset == -1)
                error ("virtual baseclass botch");
            }
        }
      else /* non-virtual base, simply use bit position from debug info */
d2583 1
a2583 1
        }
d2585 1
a2585 1
                            static_memfuncp, TYPE_BASECLASS (type, i), num_fns, basetype, boffset);
d2587 1
a2587 1
        return f;
d2589 1
a2589 1
  return NULL;  
d2603 7
a2609 7
  value_ptr *argp;
  char * method;
  int offset;
  int * static_memfuncp;
  int * num_fns;
  struct type ** basetype;
  int * boffset;
d2611 1
a2611 2
  struct type * t;
  value_ptr v;
d2615 1
a2615 1
  /* code snarfed from value_struct_elt */ 
d2624 1
a2624 1
  
d2627 3
a2629 3
  
  if (   TYPE_CODE (t) != TYPE_CODE_STRUCT
         && TYPE_CODE (t) != TYPE_CODE_UNION)
d2631 1
a2631 1
  
d2634 1
a2634 1
    *static_memfuncp =0;
d2637 1
a2637 1
  
d2666 1
a2666 1
   */
d2670 10
a2679 10
  struct type ** arg_types;
  int nargs;
  char * name;
  int method;
  int lax;
  value_ptr obj;
  struct symbol * fsym;
  value_ptr * valp;
  struct symbol ** symp;
  int * staticp;
d2682 1
a2682 1
  struct type ** parm_types;
d2684 11
a2694 11
  
  short oload_champ = -1;          /* Index of best overloaded function */
  short oload_ambiguous = 0;       /* Current ambiguity state for overload resolution */
                                   /* 0 => no ambiguity, 1 => two good funcs, 2 => incomparable funcs */
  short oload_ambig_champ = -1;    /* 2nd contender for best match */ 
  short oload_non_standard = 0;    /* did we have to use non-standard conversions? */ 
  short oload_incompatible = 0;    /* are args supplied incompatible with any function? */
  
  struct badness_vector * bv;      /* A measure of how good an overloaded instance is */ 
  struct badness_vector * oload_champ_bv = NULL; /* The measure for the current best match */ 
  
d2696 4
a2699 4
  struct fn_field * fns_ptr = NULL;   /* For methods, the list of overloaded methods */ 
  struct symbol ** oload_syms = NULL; /* For non-methods, the list of overloaded function symbols */
  int num_fns = 0;                    /* Number of overloaded instances being considered */ 
  struct type * basetype = NULL;   
d2704 2
a2705 2
  char * obj_type_name = NULL;
  char * func_name = NULL;
d2714 2
a2715 2
          (TYPE_CODE (VALUE_TYPE (obj)) == TYPE_CODE_PTR))
        obj_type_name = TYPE_NAME (TYPE_TARGET_TYPE (VALUE_TYPE (obj)));
d2718 3
a2720 3
                                              staticp,
                                              &num_fns,
                                              &basetype, &boffset);
d2722 4
a2725 4
        error ("Couldn't find method %s%s%s",
               obj_type_name,
               (obj_type_name && *obj_type_name) ? "::" : "",
               name);
d2732 8
d2742 1
a2742 1
        num_fns++;
d2744 1
a2744 1
        error ("Couldn't find function %s", func_name);
d2746 1
a2746 1
  
d2749 1
a2749 1
  /* Consider each candidate in turn */ 
d2752 1
a2752 3
      int jj;

      /* Number of parameters for current candidate */ 
d2754 1
a2754 1
                      : TYPE_NFIELDS (SYMBOL_TYPE (oload_syms[ix]));
d2756 1
a2756 1
      /* Prepare array of parameter types */ 
d2759 2
a2760 2
        parm_types[jj] = method ? TYPE_FIELD_TYPE (fns_ptr[ix].type, jj)
                                : TYPE_FIELD_TYPE (SYMBOL_TYPE (oload_syms[ix]), jj);
d2764 1
a2764 1
      
d2766 5
a2770 5
        {
          oload_champ_bv = bv;
          oload_champ = 0;
          champ_nparms = nparms;
        }
d2772 22
a2793 22
        /* See whether current candidate is better or worse than previous best */ 
        switch (compare_badness (bv, oload_champ_bv))
          {
            case 0:
              oload_ambiguous = 1;    /* top two contenders are equally good */ 
              oload_ambig_champ = ix;
              break;
            case 1:
              oload_ambiguous = 2;    /* incomparable top contenders */ 
              oload_ambig_champ = ix;
              break;
            case 2:
              oload_champ_bv = bv;    /* new champion, record details */ 
              oload_ambiguous = 0;
              oload_champ = ix;
              oload_ambig_champ = -1;
              champ_nparms = nparms;
              break;
            case 3:
            default:
              break;
          }
d2797 1
a2797 1
        printf("Overloaded method instance %s, # of parms %d\n", fns_ptr[ix].physname, nparms);
d2799 1
a2799 1
        printf("Overloaded function instance %s # of parms %d\n", SYMBOL_DEMANGLED_NAME(oload_syms[ix]),nparms); 
d2801 2
a2802 2
        printf("...Badness @@ %d : %d\n", jj, bv->rank[jj]);
      printf("Overload resolution champion is %d, ambiguous? %d\n", oload_champ, oload_ambiguous);
d2804 1
a2804 1
    } /* end loop over all candidates */ 
d2809 4
a2812 4
        error ("Cannot resolve overloaded method %s%s%s to unique instance; disambiguate by specifying function signature",
               obj_type_name,
               (obj_type_name && *obj_type_name) ? "::" : "",
               name);
d2814 2
a2815 2
        error ("Cannot resolve overloaded function %s to unique instance; disambiguate by specifying function signature",
               func_name);
d2818 1
a2818 1
  /* Check how bad the best match is */ 
d2822 8
a2829 8
        {
          case 10:
            oload_non_standard = 1;  /* non-standard type conversions needed */ 
            break;
          case 100:
            oload_incompatible = 1;  /* truly mismatched types */ 
            break;
        }
d2834 4
a2837 4
        error ("Cannot resolve method %s%s%s to any overloaded instance",
               obj_type_name,
               (obj_type_name && *obj_type_name) ? "::" : "",
               name);
d2839 2
a2840 2
        error ("Cannot resolve function %s to any overloaded instance",
               func_name);
d2845 4
a2848 4
        warning ("Using non-standard conversion to match method %s%s%s to supplied arguments",
                 obj_type_name,
                 (obj_type_name && *obj_type_name) ? "::" : "",
                 name);
d2850 2
a2851 2
        warning ("Using non-standard conversion to match function %s to supplied arguments",
                 func_name);
d2857 1
a2857 1
        *valp = value_virtual_fn_field (&temp, fns_ptr, oload_champ, basetype, boffset);
d2859 1
a2859 1
        *valp = value_fn_field (&temp, fns_ptr, oload_champ, basetype, boffset);
d2937 1
a2937 1
      
d2970 1
a2970 1
  if (   TYPE_CODE (t) != TYPE_CODE_STRUCT
d2994 1
a2994 1
  if (   TYPE_CODE (t) != TYPE_CODE_STRUCT
d3001 1
a3001 1
      
d3014 1
a3014 1
	  
d3040 3
a3042 3
      if (strncmp(t_field_name, "__", 2)==0 ||
	strncmp(t_field_name, "op", 2)==0 ||
	strncmp(t_field_name, "type", 4)==0 )
d3044 3
a3046 1
	  if (cplus_demangle_opname(t_field_name, dem_opname, DMGL_ANSI))
a3047 2
	  else if (cplus_demangle_opname(t_field_name, dem_opname, 0))
	    t_field_name = dem_opname; 
d3053 1
a3053 1
	  
d3066 1
a3066 1
	  
d3139 4
a3142 4
  value_ptr v;
  int * full;
  int * top;
  int * using_enc;
d3144 2
a3145 2
  struct type * known_type;
  struct type * rtti_type;
d3159 1
a3159 1
  /* Get declared type */ 
d3162 1
a3162 1
  /* RTTI works only or class objects */ 
d3174 2
a3175 2
          !TYPE_HAS_VTABLE (known_type))
        return NULL; /* No RTTI, or not HP-compiled types */
d3184 3
a3186 3
  coreptr = * (CORE_ADDR *) ((VALUE_CONTENTS_ALL (v))
                             + VALUE_OFFSET (v) 
                             + (using_enclosing ? 0 : VALUE_EMBEDDED_OFFSET (v)));
d3188 1
a3188 1
    return NULL; /* return silently -- maybe called on gdb-generated value */
d3190 1
a3190 1
  /* Fetch the top offset of the object */ 
d3192 3
a3194 3
  vp = value_at (builtin_type_int, 
                 coreptr + 4 * HP_ACC_TOP_OFFSET_OFFSET, 
                 VALUE_BFD_SECTION (v));
d3204 1
a3204 1
  coreptr = * (CORE_ADDR *) (VALUE_CONTENTS (vp));
d3207 2
a3208 2
  vp = value_at (builtin_type_int, coreptr + 4, VALUE_BFD_SECTION (v));  /* 4 -> offset of name field */
                                                  /* FIXME possible 32x64 problem */
d3210 1
a3210 1
  coreptr = * (CORE_ADDR *) (VALUE_CONTENTS (vp));
d3216 1
a3216 1
  
d3219 1
a3219 1
  
d3224 2
a3225 2
#if 0 /* debugging*/
  printf("RTTI type name %s, tag %s, full? %d\n", TYPE_NAME (rtti_type), TYPE_TAG_NAME (rtti_type), full ? *full : -1); 
d3229 1
a3229 1
  if (full /* Non-null pointer passed */ 
d3232 12
a3243 12
           /* Either we checked on the whole object in hand and found the
              top offset to be zero */
      (((top_offset == 0) &&         
       using_enclosing &&     
       TYPE_LENGTH (known_type) == TYPE_LENGTH (rtti_type))
      ||
           /* Or we checked on the embedded object and top offset was the
              same as the embedded offset */
      ((top_offset == VALUE_EMBEDDED_OFFSET (v)) &&
       !using_enclosing &&
       TYPE_LENGTH (VALUE_ENCLOSING_TYPE (v)) == TYPE_LENGTH (rtti_type))))
    
d3245 1
a3245 1
  
d3256 4
a3259 4
  value_ptr v;
  int * full;
  int * top;
  int * using_enc;
d3280 6
a3285 6
  value_ptr argp;
  struct type * rtype;
  int xfull;
  int xtop;
  int xusing_enc;
  
d3287 1
a3287 1
  struct type * real_type;
d3308 1
a3308 1
     type is wrong, set it */ /* pai: FIXME -- sounds iffy */
d3319 1
a3319 1
      
d3322 1
a3322 1
  
d3328 2
a3329 2
                           (using_enc ? 0 : VALUE_EMBEDDED_OFFSET (argp)), 
                           VALUE_BFD_SECTION (argp));
d3355 3
a3357 2
        error ("no frame selected");
      else return 0;
d3365 2
a3366 1
      else return 0;
d3374 3
a3376 2
        error ("no args, no `this'");
      else return 0;
d3420 1
a3420 1
      /* Chill allows zero-length strings but not arrays. */
d3426 1
a3426 1
  slice_range_type = create_range_type ((struct type*) NULL,
d3432 1
a3432 1
      slice_type = create_set_type ((struct type*) NULL, slice_range_type);
d3451 2
a3452 2
	 can be used on the LHS, but that may require extensions to
	 value_assign.  For now, just leave as a non_lval.  FIXME.  */
d3459 1
a3459 1
      slice_type = create_array_type ((struct type*) NULL, element_type,
d3496 1
a3496 1
   doubles. FIXME: fmb */ 
d3536 1
a3536 1
	       TYPE_LENGTH (val_real_type));
d3552 1
a3552 1
    (add_set_cmd ("abandon", class_support, var_boolean, (char *)&auto_abandon,
d3559 1
a3559 1
    (add_set_cmd ("overload-resolution", class_support, var_boolean, (char *)&overload_resolution,
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d54 1
d57 1
a80 2
static struct fn_field *find_method_list PARAMS ((value_ptr *argp, char * method, int offset, int * static_memfuncp, struct type * type, int * num_fns, struct type ** basetype, int * boffset));

d446 2
a447 2
  if (GDB_TARGET_IS_D10V
      && TYPE_CODE (type) == TYPE_CODE_PTR
d455 2
a456 2
      num = D10V_MAKE_IADDR (snum);
      store_address (VALUE_CONTENTS_RAW (val), 4, num);
d458 1
a458 2
  else if (GDB_TARGET_IS_D10V
	   && TYPE_CODE(type) == TYPE_CODE_PTR)
d464 2
a465 2
      num = D10V_MAKE_DADDR (snum);
      store_address (VALUE_CONTENTS_RAW (val), 4, num); 
d468 1
d520 1
d522 1
a522 2
  if (GDB_TARGET_IS_D10V
      && TYPE_CODE (type) == TYPE_CODE_PTR
d533 1
a533 2
  else if (GDB_TARGET_IS_D10V
	   && TYPE_CODE(type) == TYPE_CODE_PTR)
d542 4
a545 1
  else if (length)
d1104 1
d1264 2
a1265 3
static value_ptr hand_function_call PARAMS ((value_ptr function, int nargs, value_ptr *args));
static value_ptr
hand_function_call (function, nargs, args)
d1282 1
a1282 4
           REGISTER_SIZE).

     NOTE: This is pretty stupid.  CALL_DUMMY should be in strict
           target byte order. */
d1284 2
a1285 3
  static ULONGEST *dummy;
  int sizeof_dummy1;
  char *dummy1;
d1290 1
a1290 1
  struct inferior_status *inf_status;
a1297 5
  dummy = alloca (SIZEOF_CALL_DUMMY_WORDS);
  sizeof_dummy1 = REGISTER_SIZE * SIZEOF_CALL_DUMMY_WORDS / sizeof (ULONGEST);
  dummy1 = alloca (sizeof_dummy1);
  memcpy (dummy, CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS);

d1301 1
a1301 1
  inf_status = save_inferior_status (1);
d1303 1
a1303 1
                            inf_status);
d1315 1
a1315 1
      sp -= sizeof_dummy1;
d1322 1
a1322 1
      sp += sizeof_dummy1;
d1342 1
a1342 1
  for (i = 0; i < (int) (SIZEOF_CALL_DUMMY_WORDS / sizeof (dummy[0])); i++)
d1356 20
a1375 4
  if (CALL_DUMMY_LOCATION == ON_STACK)
    {
      write_memory (start_sp, (char *)dummy1, sizeof_dummy1);
    }
d1377 11
a1387 26
  if (CALL_DUMMY_LOCATION == BEFORE_TEXT_END)
    {
      /* Convex Unix prohibits executing in the stack segment. */
      /* Hope there is empty room at the top of the text segment. */
      extern CORE_ADDR text_end;
      static checked = 0;
      if (!checked)
	for (start_sp = text_end - sizeof_dummy1; start_sp < text_end; ++start_sp)
	  if (read_memory_integer (start_sp, 1) != 0)
	    error ("text segment full -- no place to put call");
      checked = 1;
      sp = old_sp;
      real_pc = text_end - sizeof_dummy1;
      write_memory (real_pc, (char *)dummy1, sizeof_dummy1);
    }
  
  if (CALL_DUMMY_LOCATION == AFTER_TEXT_END)
    {
      extern CORE_ADDR text_end;
      int errcode;
      sp = old_sp;
      real_pc = text_end;
      errcode = target_write_memory (real_pc, (char *)dummy1, sizeof_dummy1);
      if (errcode != 0)
	error ("Cannot write text segment -- call_function failed");
    }
d1389 3
a1391 4
  if (CALL_DUMMY_LOCATION == AT_ENTRY_POINT)
    {
      real_pc = funaddr;
    }
d1558 3
a1560 2
      if (CALL_DUMMY_STACK_ADJUST_P)
	len += CALL_DUMMY_STACK_ADJUST;
d1591 3
a1593 2
      if (CALL_DUMMY_STACK_ADJUST_P)
	sp += CALL_DUMMY_STACK_ADJUST;
d1603 7
a1609 6
  if (CALL_DUMMY_STACK_ADJUST_P)
    if (INNER_THAN (1, 2))
      {
	/* stack grows downward */
	sp -= CALL_DUMMY_STACK_ADJUST;
      }
d1666 4
a1669 4
	/* If we did the cleanups, we would print a spurious error
	   message (Unable to restore previously selected frame),
	   would write the registers from the inf_status (which is
	   wrong), and would do other wrong things.  */
d1671 2
a1672 1
	discard_inferior_status (inf_status);
d1709 1
a1709 1

d1716 1
a1716 8
  if (CALL_DUMMY_P)
    {
      return hand_function_call (function, nargs, args);
    }
  else
    {
      error ("Cannot invoke functions on this machine.");
    }
d1718 1
a1718 1

d2423 1
a2423 1
static struct fn_field *
d2425 8
a2432 8
     value_ptr *argp;
     char * method;
     int offset;
     int * static_memfuncp;
     struct type * type;
     int * num_fns;
     struct type ** basetype;
     int * boffset;
@


1.1.1.3
log
@import gdb-1999-05-25 snapshot
@
text
@d58 1
d60 1
d580 1
d593 1
d1075 2
d1100 1
a1100 19
#ifndef PUSH_ARGUMENTS
#define PUSH_ARGUMENTS default_push_arguments
#endif

CORE_ADDR
default_push_arguments (nargs, args, struct_return, sp, struct_addr)
     int nargs;
     value_ptr *args;
     int struct_return;
     CORE_ADDR sp;
     CORE_ADDR struct_addr;
{
  /* ASSERT ( !struct_return); */
  int i;
  for (i = nargs - 1; i >= 0; i--)
    sp = value_push (sp, args[i]);
  return sp;
}

d1373 1
a1373 1
      static int checked = 0;
d1572 6
a1577 1
  sp = PUSH_ARGUMENTS (nargs, args, sp, struct_return, struct_addr);
@


1.1.1.4
log
@import gdb-1999-06-01 snapshot
@
text
@d578 2
a579 1
  if (VALUE_REGNO (toval) >= 0)
d1099 1
a1099 1
default_push_arguments (nargs, args, sp, struct_return, struct_addr)
d1102 1
a1103 1
     int struct_return;
@


1.1.1.5
log
@import gdb-1999-07-05 snapshot
@
text
@a1638 4
#ifdef SAVE_DUMMY_FRAME_TOS
  SAVE_DUMMY_FRAME_TOS (sp);
#endif

@


1.1.1.6
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d52 1
a52 1
static int typecmp PARAMS ((int staticp, struct type * t1[], value_ptr t2[]));
d64 2
a65 2
					  struct type *, int, int *, char *,
						  struct type **));
d77 1
a77 1
static struct fn_field *find_method_list PARAMS ((value_ptr * argp, char *method, int offset, int *static_memfuncp, struct type * type, int *num_fns, struct type ** basetype, int *boffset));
a89 1

d92 1
d112 1
a112 1
      struct minimal_symbol *msymbol = lookup_minimal_symbol (name, NULL, NULL);
d125 1
a125 1
	  if (!target_has_execution)
d127 1
a127 1
	  else
d148 3
a150 3
	error ("No memory available to program now: you need to start the target first");
      else
	error ("No memory available to program: call to malloc failed");
d178 1
a178 1

d184 1
a184 1
  COERCE_REF (arg2);
d195 1
a195 1
	&& TYPE_ARRAY_UPPER_BOUND_TYPE (type) == BOUND_CANNOT_BE_DETERMINED)
d204 1
a204 1
	    warning ("array element type size does not divide object size in cast");
d243 1
a243 1
  if (code1 == TYPE_CODE_STRUCT
d248 2
a249 2
         type of the target as a superclass.  If so, we'll need to
         offset the object in addition to changing its type.  */
d265 24
a288 24

      if (hp_som_som_object_present &&	/* if target compiled by HP aCC */
	  (code2 == TYPE_CODE_PTR))
	{
	  unsigned int *ptr;
	  value_ptr retvalp;

	  switch (TYPE_CODE (TYPE_TARGET_TYPE (type2)))
	    {
	      /* With HP aCC, pointers to data members have a bias */
	    case TYPE_CODE_MEMBER:
	      retvalp = value_from_longest (type, value_as_long (arg2));
	      ptr = (unsigned int *) VALUE_CONTENTS (retvalp);	/* force evaluation */
	      *ptr &= ~0x20000000;	/* zap 29th bit to remove bias */
	      return retvalp;

	      /* While pointers to methods don't really point to a function */
	    case TYPE_CODE_METHOD:
	      error ("Pointers to methods not supported with HP aCC");

	    default:
	      break;		/* fall out and go to normal handling */
	    }
	}
d298 1
a298 1
	  if (TYPE_CODE (t1) == TYPE_CODE_STRUCT
d305 2
a306 2
	         type of the target as a superclass.  If so, we'll need to
	         offset the pointer rather than just change its type.  */
d320 3
a322 3
	         type of the source as a superclass.  If so, we'll need to
	         offset the pointer rather than just change its type.
	         FIXME: This fails silently with virtual inheritance.  */
d326 1
a326 1
				       value_zero (t1, not_lval), 0, t1, 1);
d331 1
a331 1
			+ VALUE_OFFSET (v);
d341 2
a342 2
      VALUE_ENCLOSING_TYPE (arg2) = type;	/* pai: chk_val */
      VALUE_POINTED_TO_OFFSET (arg2) = 0;	/* pai: chk_val */
d360 1
a360 1
      /* || TYPE_CODE (eltype1) != TYPE_CODE (eltype2) */ )))
d369 1
a369 1
	count1 = -1, count2 = 0;	/* To force error before */
d457 1
a457 1
	   && TYPE_CODE (type) == TYPE_CODE_PTR)
d464 1
a464 1
      store_address (VALUE_CONTENTS_RAW (val), 4, num);
d518 1
a518 1
  struct type *type = VALUE_TYPE (val);
d528 2
a529 2
      num = D10V_MAKE_IADDR (snum);
      store_address (VALUE_CONTENTS_RAW (val), 4, num);
d532 1
a532 1
	   && TYPE_CODE (type) == TYPE_CODE_PTR)
d538 2
a539 2
      num = D10V_MAKE_DADDR (snum);
      store_address (VALUE_CONTENTS_RAW (val), 4, num);
d611 2
a612 2
	CORE_ADDR changed_addr;
	int changed_len;
d614 2
a615 2
	if (VALUE_BITSIZE (toval))
	  {
d620 3
a622 3
			   + VALUE_BITSIZE (toval)
			   + HOST_CHAR_BIT - 1)
	      / HOST_CHAR_BIT;
d658 1
a658 1
	  int len = REGISTER_RAW_SIZE (VALUE_REGNO (toval));
d671 6
a676 6
	  read_register_bytes (VALUE_ADDRESS (toval) + VALUE_OFFSET (toval),
			       buffer, len);
	  modify_field (buffer, value_as_long (fromval),
			VALUE_BITPOS (toval), VALUE_BITSIZE (toval));
	  write_register_bytes (VALUE_ADDRESS (toval) + VALUE_OFFSET (toval),
				buffer, len);
d682 1
a682 1
	{
d687 1
a687 1
	  REGISTER_CONVERT_FROM_TYPE (VALUE_REGNO (toval), type, raw_buffer);
d692 1
a692 1
			      VALUE_CONTENTS (fromval), TYPE_LENGTH (type));
d696 4
a699 4
         (architecture and calling convention specific) registers may
         cause the frame cache to be out of date.  We just do this
         on all assignments to registers for simplicity; I doubt the slowdown
         matters.  */
d740 2
a741 2
				(int *) NULL, (CORE_ADDR *) NULL,
				frame, regno, (enum lval_type *) NULL);
d766 3
a768 3
	    get_saved_register ((char *) NULL,
				&optim, &addr, frame, regno, &lval);

d783 1
a783 1

d811 1
a811 1

d854 1
a854 1
	{
d861 1
a861 1
	}
d892 1
a892 1
 */
d904 1
a904 1
		    (LONGEST) (VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1)));
d920 1
a920 1
		    (LONGEST) (VALUE_ADDRESS (arg1) + VALUE_OFFSET (arg1)));
d923 1
a923 1
}
d937 2
a938 2
         We keep the same location information, which is efficient,
         and allows &(&X) to get the location containing the reference. */
d949 1
a949 1
  /* Get target memory address */
d951 3
a953 3
			     (LONGEST) (VALUE_ADDRESS (arg1)
					+ VALUE_OFFSET (arg1)
					+ VALUE_EMBEDDED_OFFSET (arg1)));
d956 1
a956 1
     full derived object's type ... */
d958 2
a959 2
  /* ... and also the relative position of the subobject in the full object */
  VALUE_POINTED_TO_OFFSET (arg2) = VALUE_EMBEDDED_OFFSET (arg1);
d993 1
a993 1
      /* Get the real type of the enclosing object */
d996 5
a1000 5
      /* Retrieve the enclosing object pointed to */
      arg2 = value_at_lazy (enc_type,
		   value_as_pointer (arg1) - VALUE_POINTED_TO_OFFSET (arg1),
			    VALUE_BFD_SECTION (arg1));
      /* Re-adjust type */
d1012 1
a1012 1
  return 0;			/* For lint -- never reached */
d1127 1
a1127 1
  = param_type ? check_typedef (param_type) : arg_type;
d1150 2
a1151 2
         type for an argument.  We may have to conditionalize the following
         type coercion for future targets.  */
d1157 3
a1159 3
         non-prototyped case.  As many debugging formats include
         no information about prototyping, we have to live with
         COERCE_FLOAT_TO_DOUBLE for now.  */
d1238 1
a1238 1
         Their values are characters since their addresses are char */
d1272 1
a1272 1
static value_ptr hand_function_call PARAMS ((value_ptr function, int nargs, value_ptr * args));
d1288 4
a1291 4
     sequence of instructions.  But CISC machines will have
     to pack the instructions into REGISTER_SIZE units (and
     so will RISC machines for which INSTRUCTION_SIZE is not
     REGISTER_SIZE).
d1294 1
a1294 1
     target byte order. */
d1306 1
a1306 1
  int using_gcc;		/* Set to version of gcc in use, or zero if not gcc */
d1317 1
a1317 1
    noprocess ();
d1320 2
a1321 2
  old_chain = make_cleanup ((make_cleanup_func) restore_inferior_status,
			    inf_status);
d1363 1
a1363 1
			    (ULONGEST) dummy[i]);
d1376 1
a1376 1
      write_memory (start_sp, (char *) dummy1, sizeof_dummy1);
d1392 1
a1392 1
      write_memory (real_pc, (char *) dummy1, sizeof_dummy1);
d1394 1
a1394 1

d1401 1
a1401 1
      errcode = target_write_memory (real_pc, (char *) dummy1, sizeof_dummy1);
d1412 1
a1412 1
  sp = old_sp;			/* It really is used, for some ifdef's... */
d1421 2
a1422 2
         promotions.  FIXME: if we had a prototype, this should only
         be allowed if ... were present.  */
d1426 1
a1426 1
      else
d1435 7
a1441 7
         has a pointer to function as parameter and the corresponding actual argument 
         is the address of a function and not a pointer to function variable.
         In aCC compiled code, the calls through pointers to functions (in the body
         of the function called by hand) are made via $$dyncall_external which
         requires some registers setting, this is taken care of if we call 
         via a function pointer variable, but not via a function address. 
         In cc this is not a problem. */
d1445 1
a1445 1
	  /* if this parameter is a pointer to function */
d1449 5
a1453 5
	         to compile the target. We want to issue the error
	         message only if the compiler used was HP's aCC. 
	         If we used HP's cc, then there is no problem and no need 
	         to return at this point */
	      if (using_gcc == 0)	/* && compiler == aCC */
d1455 1
a1455 1
		   pointer to function or just a function */
d1459 2
a1460 2
		    if (find_pc_partial_function ((CORE_ADDR) args[i]->aligner.contents[0], &arg_name, NULL, NULL))
		      error ("\
d1463 1
a1463 1
		  }
d1481 2
a1482 2
	    )
	    && REG_STRUCT_HAS_ADDR (using_gcc, arg_type))
d1485 4
a1488 4
	    int len;		/*  = TYPE_LENGTH (arg_type); */
	    int aligned_len;
	    arg_type = check_typedef (VALUE_ENCLOSING_TYPE (args[i]));
	    len = TYPE_LENGTH (arg_type);
d1491 3
a1493 3
	    /* MVS 11/22/96: I think at least some of this stack_align code is
	       really broken.  Better to let PUSH_ARGUMENTS adjust the stack in
	       a target-defined manner.  */
d1525 2
a1526 2
	       (LONGEST) addr); */
	    args[i] = value_from_longest (lookup_pointer_type (arg_type),
d1540 3
a1542 3
      /* MVS 11/22/96: I think at least some of this stack_align code is
         really broken.  Better to let PUSH_ARGUMENTS adjust the stack in
         a target-defined manner.  */
d1562 1
a1562 1
   hppa_push_arguments */
d1595 2
a1596 2
  sp = PUSH_RETURN_ADDRESS (real_pc, sp);
#endif /* PUSH_RETURN_ADDRESS */
d1599 1
a1599 1
  if (!INNER_THAN (1, 2))
d1602 1
a1602 1
         that sp already has been advanced for the arguments!  */
d1712 1
a1712 1
 */
a1737 1

d1740 1
d1784 2
a1785 2
  arraytype = create_array_type ((struct type *) NULL,
			      VALUE_ENCLOSING_TYPE (elemvec[0]), rangetype);
d1837 1
a1837 1
  = create_string_type ((struct type *) NULL, rangetype);
d1866 1
a1866 1
  struct type *type = create_set_type ((struct type *) NULL, domain_type);
d1902 2
a1903 4
  if (TYPE_CODE (t1[0]) == TYPE_CODE_VOID)
    return 0;
  if (t1[!staticp] == 0)
    return 0;
d1906 3
a1908 3
      struct type *tt1, *tt2;
      if (!t2[i])
	return i + 1;
d1910 1
a1910 1
      tt2 = check_typedef (VALUE_TYPE (t2[i]));
d1912 1
a1912 1
      /* We should be doing hairy argument matching, as below.  */
d1923 2
a1924 2
	     && (TYPE_CODE (tt2) == TYPE_CODE_ARRAY
		 || TYPE_CODE (tt2) == TYPE_CODE_PTR))
d1926 2
a1927 2
	  tt1 = check_typedef (TYPE_TARGET_TYPE (tt1));
	  tt2 = check_typedef (TYPE_TARGET_TYPE (tt2));
d1929 1
a1929 2
      if (TYPE_CODE (tt1) == TYPE_CODE (tt2))
	continue;
d1933 2
a1934 2
         of the ARM), but as a quick kludge, just check for the same type
         code.  */
d1936 1
a1936 1
	return i + 1;
d1938 2
a1939 3
  if (!t1[i])
    return 0;
  return t2[i] ? i + 1 : 0;
d1963 1
a1963 1
  if (!looking_for_baseclass)
d1976 1
a1976 1
	      error ("there is no field named %s", name);
d1997 1
a1997 1

d2019 1
a2019 1
  for (i = 0; i < nbases; i++)
d2024 2
a2025 2
         hit them.  But it could happen that the base part's member name
         is not yet filled in.  */
d2038 1
a2038 1
				      + VALUE_OFFSET (arg1) + offset);
d2050 1
a2050 1

d2080 1
a2080 1
			       offset + TYPE_BASECLASS_BITPOS (type, i) / 8,
d2082 1
a2082 2
      if (v)
	return v;
d2107 7
a2113 7
find_rt_vbase_offset (type, basetype, valaddr, offset, boffset_p, skip_p)
     struct type *type;
     struct type *basetype;
     char *valaddr;
     int offset;
     int *boffset_p;
     int *skip_p;
d2115 2
a2116 2
  int boffset;			/* offset of virtual base */
  int index;			/* displacement to use in virtual table */
d2118 4
a2121 4

  value_ptr vp;
  CORE_ADDR vtbl;		/* the virtual table pointer */
  struct type *pbc;		/* the primary base class */
d2126 1
a2126 1

d2128 1
a2128 1
  pbc = TYPE_PRIMARY_BASE (type);
d2133 5
a2137 5
	{
	  *boffset_p = boffset;
	  *skip_p = -1;
	  return;
	}
d2147 5
a2151 6
  if (index < 0)
    {
      *skip_p = skip + virtual_base_list_length_skip_primaries (type);
      *boffset_p = 0;
      return;
    }
d2153 1
a2153 1
  /* pai: FIXME -- 32x64 possible problem */
d2155 1
a2155 1
  vtbl = *(CORE_ADDR *) (valaddr + offset);
d2157 1
a2157 1
  /* Before the constructor is invoked, things are usually zero'd out. */
d2167 1
a2167 1

d2169 1
a2169 1
     & use long type */
d2172 1
a2172 1
  vp = value_at (builtin_type_int, vtbl + 4 * (-skip - index - HP_ACC_VBASE_START), NULL);
d2203 3
a2205 3
      if (strncmp (t_field_name, "__", 2) == 0 ||
	  strncmp (t_field_name, "op", 2) == 0 ||
	  strncmp (t_field_name, "type", 4) == 0)
d2207 1
a2207 3
	  if (cplus_demangle_opname (t_field_name, dem_opname, DMGL_ANSI))
	    t_field_name = dem_opname;
	  else if (cplus_demangle_opname (t_field_name, dem_opname, 0))
d2209 2
d2216 1
a2216 1
	  name_matched = 1;
d2232 1
a2232 2
		  if (v != NULL)
		    return v;
d2245 32
a2276 32
	  if (TYPE_HAS_VTABLE (type))
	    {
	      /* HP aCC compiled type, search for virtual base offset
	         according to HP/Taligent runtime spec.  */
	      int skip;
	      find_rt_vbase_offset (type, TYPE_BASECLASS (type, i),
				    VALUE_CONTENTS_ALL (*arg1p),
				    offset + VALUE_EMBEDDED_OFFSET (*arg1p),
				    &base_offset, &skip);
	      if (skip >= 0)
		error ("Virtual base class offset not found in vtable");
	    }
	  else
	    {
	      struct type *baseclass = check_typedef (TYPE_BASECLASS (type, i));
	      char *base_valaddr;

	      /* The virtual base class pointer might have been clobbered by the
	         user program. Make sure that it still points to a valid memory
	         location.  */

	      if (offset < 0 || offset >= TYPE_LENGTH (type))
		{
		  base_valaddr = (char *) alloca (TYPE_LENGTH (baseclass));
		  if (target_read_memory (VALUE_ADDRESS (*arg1p)
					  + VALUE_OFFSET (*arg1p) + offset,
					  base_valaddr,
					  TYPE_LENGTH (baseclass)) != 0)
		    error ("virtual baseclass botch");
		}
	      else
		base_valaddr = VALUE_CONTENTS (*arg1p) + offset;
d2278 8
a2285 8
	      base_offset =
		baseclass_offset (type, i, base_valaddr,
				  VALUE_ADDRESS (*arg1p)
				  + VALUE_OFFSET (*arg1p) + offset);
	      if (base_offset == -1)
		error ("virtual baseclass botch");
	    }
	}
d2289 1
a2289 1
	}
d2292 1
a2292 1
      if (v == (value_ptr) - 1)
d2299 1
a2299 1
/*        *arg1p = arg1_tmp; */
d2301 1
a2301 1
	}
d2303 2
a2304 4
  if (name_matched)
    return (value_ptr) - 1;
  else
    return NULL;
d2349 1
a2349 1
  if (TYPE_CODE (t) != TYPE_CODE_STRUCT
d2355 1
a2355 1
    *static_memfuncp = 0;
d2362 1
a2362 1
         is less work to be done.  */
d2375 1
a2375 1
      if (v == (value_ptr) - 1)
d2413 1
a2413 1
  if (v == (value_ptr) - 1)
d2415 1
a2415 1
      error ("Argument list of %s mismatch with component in the structure.", name);
d2420 2
a2421 2
         hand it back.  If it's not callable (i.e., a pointer to function),
         gdb should give an error.  */
d2446 1
a2446 1
     char *method;
d2448 5
a2452 5
     int *static_memfuncp;
     struct type *type;
     int *num_fns;
     struct type **basetype;
     int *boffset;
d2455 1
a2455 1
  struct fn_field *f;
d2460 2
a2461 2
  /* First check in object itself */
  for (i = TYPE_NFN_FIELDS (type) - 1; i >= 0; i--)
d2464 1
a2464 1
      char *fn_field_name = TYPE_FN_FIELDLIST_NAME (type, i);
d2466 6
a2471 6
	{
	  *num_fns = TYPE_FN_FIELDLIST_LENGTH (type, i);
	  *basetype = type;
	  *boffset = offset;
	  return TYPE_FN_FIELDLIST1 (type, i);
	}
d2473 1
a2473 1

d2480 25
a2504 26
	  if (TYPE_HAS_VTABLE (type))
	    {
	      /* HP aCC compiled type, search for virtual base offset
	       * according to HP/Taligent runtime spec.  */
	      int skip;
	      find_rt_vbase_offset (type, TYPE_BASECLASS (type, i),
				    VALUE_CONTENTS_ALL (*argp),
				    offset + VALUE_EMBEDDED_OFFSET (*argp),
				    &base_offset, &skip);
	      if (skip >= 0)
		error ("Virtual base class offset not found in vtable");
	    }
	  else
	    {
	      /* probably g++ runtime model */
	      base_offset = VALUE_OFFSET (*argp) + offset;
	      base_offset =
		baseclass_offset (type, i,
				  VALUE_CONTENTS (*argp) + base_offset,
				  VALUE_ADDRESS (*argp) + base_offset);
	      if (base_offset == -1)
		error ("virtual baseclass botch");
	    }
	}
      else
	/* non-virtual base, simply use bit position from debug info */
d2507 1
a2507 1
	}
d2509 1
a2509 1
      static_memfuncp, TYPE_BASECLASS (type, i), num_fns, basetype, boffset);
d2511 1
a2511 1
	return f;
d2513 1
a2513 1
  return NULL;
d2527 7
a2533 7
     value_ptr *argp;
     char *method;
     int offset;
     int *static_memfuncp;
     int *num_fns;
     struct type **basetype;
     int *boffset;
d2535 1
a2535 1
  struct type *t;
d2540 1
a2540 1
  /* code snarfed from value_struct_elt */
d2549 1
a2549 1

d2552 3
a2554 3

  if (TYPE_CODE (t) != TYPE_CODE_STRUCT
      && TYPE_CODE (t) != TYPE_CODE_UNION)
d2556 1
a2556 1

d2559 1
a2559 1
    *static_memfuncp = 0;
d2562 1
a2562 1

d2591 1
a2591 1
 */
d2595 10
a2604 10
     struct type **arg_types;
     int nargs;
     char *name;
     int method;
     int lax;
     value_ptr obj;
     struct symbol *fsym;
     value_ptr *valp;
     struct symbol **symp;
     int *staticp;
d2607 1
a2607 1
  struct type **parm_types;
d2609 11
a2619 11

  short oload_champ = -1;	/* Index of best overloaded function */
  short oload_ambiguous = 0;	/* Current ambiguity state for overload resolution */
  /* 0 => no ambiguity, 1 => two good funcs, 2 => incomparable funcs */
  short oload_ambig_champ = -1;	/* 2nd contender for best match */
  short oload_non_standard = 0;	/* did we have to use non-standard conversions? */
  short oload_incompatible = 0;	/* are args supplied incompatible with any function? */

  struct badness_vector *bv;	/* A measure of how good an overloaded instance is */
  struct badness_vector *oload_champ_bv = NULL;		/* The measure for the current best match */

d2621 4
a2624 4
  struct fn_field *fns_ptr = NULL;	/* For methods, the list of overloaded methods */
  struct symbol **oload_syms = NULL;	/* For non-methods, the list of overloaded function symbols */
  int num_fns = 0;		/* Number of overloaded instances being considered */
  struct type *basetype = NULL;
d2629 2
a2630 2
  char *obj_type_name = NULL;
  char *func_name = NULL;
d2639 2
a2640 2
	  (TYPE_CODE (VALUE_TYPE (obj)) == TYPE_CODE_PTR))
	obj_type_name = TYPE_NAME (TYPE_TARGET_TYPE (VALUE_TYPE (obj)));
d2643 3
a2645 3
					      staticp,
					      &num_fns,
					      &basetype, &boffset);
d2647 4
a2650 4
	error ("Couldn't find method %s%s%s",
	       obj_type_name,
	       (obj_type_name && *obj_type_name) ? "::" : "",
	       name);
d2659 1
a2659 1
	num_fns++;
d2661 1
a2661 1
	error ("Couldn't find function %s", func_name);
d2663 1
a2663 1

d2666 1
a2666 1
  /* Consider each candidate in turn */
d2671 1
a2671 1
      /* Number of parameters for current candidate */
d2673 1
a2673 1
	: TYPE_NFIELDS (SYMBOL_TYPE (oload_syms[ix]));
d2675 1
a2675 1
      /* Prepare array of parameter types */
d2678 2
a2679 2
	parm_types[jj] = method ? TYPE_FIELD_TYPE (fns_ptr[ix].type, jj)
	  : TYPE_FIELD_TYPE (SYMBOL_TYPE (oload_syms[ix]), jj);
d2683 1
a2683 1

d2685 28
a2712 28
	{
	  oload_champ_bv = bv;
	  oload_champ = 0;
	  champ_nparms = nparms;
	}
      else
	/* See whether current candidate is better or worse than previous best */
	switch (compare_badness (bv, oload_champ_bv))
	  {
	  case 0:
	    oload_ambiguous = 1;	/* top two contenders are equally good */
	    oload_ambig_champ = ix;
	    break;
	  case 1:
	    oload_ambiguous = 2;	/* incomparable top contenders */
	    oload_ambig_champ = ix;
	    break;
	  case 2:
	    oload_champ_bv = bv;	/* new champion, record details */
	    oload_ambiguous = 0;
	    oload_champ = ix;
	    oload_ambig_champ = -1;
	    champ_nparms = nparms;
	    break;
	  case 3:
	  default:
	    break;
	  }
d2716 1
a2716 1
	printf ("Overloaded method instance %s, # of parms %d\n", fns_ptr[ix].physname, nparms);
d2718 1
a2718 1
	printf ("Overloaded function instance %s # of parms %d\n", SYMBOL_DEMANGLED_NAME (oload_syms[ix]), nparms);
d2720 2
a2721 2
	printf ("...Badness @@ %d : %d\n", jj, bv->rank[jj]);
      printf ("Overload resolution champion is %d, ambiguous? %d\n", oload_champ, oload_ambiguous);
d2723 1
a2723 1
    }				/* end loop over all candidates */
d2728 4
a2731 4
	error ("Cannot resolve overloaded method %s%s%s to unique instance; disambiguate by specifying function signature",
	       obj_type_name,
	       (obj_type_name && *obj_type_name) ? "::" : "",
	       name);
d2733 2
a2734 2
	error ("Cannot resolve overloaded function %s to unique instance; disambiguate by specifying function signature",
	       func_name);
d2737 1
a2737 1
  /* Check how bad the best match is */
d2741 8
a2748 8
	{
	case 10:
	  oload_non_standard = 1;	/* non-standard type conversions needed */
	  break;
	case 100:
	  oload_incompatible = 1;	/* truly mismatched types */
	  break;
	}
d2753 4
a2756 4
	error ("Cannot resolve method %s%s%s to any overloaded instance",
	       obj_type_name,
	       (obj_type_name && *obj_type_name) ? "::" : "",
	       name);
d2758 2
a2759 2
	error ("Cannot resolve function %s to any overloaded instance",
	       func_name);
d2764 4
a2767 4
	warning ("Using non-standard conversion to match method %s%s%s to supplied arguments",
		 obj_type_name,
		 (obj_type_name && *obj_type_name) ? "::" : "",
		 name);
d2769 2
a2770 2
	warning ("Using non-standard conversion to match function %s to supplied arguments",
		 func_name);
d2776 1
a2776 1
	*valp = value_virtual_fn_field (&temp, fns_ptr, oload_champ, basetype, boffset);
d2778 1
a2778 1
	*valp = value_fn_field (&temp, fns_ptr, oload_champ, basetype, boffset);
d2856 1
a2856 1

d2889 1
a2889 1
  if (TYPE_CODE (t) != TYPE_CODE_STRUCT
d2913 1
a2913 1
  if (TYPE_CODE (t) != TYPE_CODE_STRUCT
d2920 1
a2920 1

d2933 1
a2933 1

d2959 3
a2961 3
      if (strncmp (t_field_name, "__", 2) == 0 ||
	  strncmp (t_field_name, "op", 2) == 0 ||
	  strncmp (t_field_name, "type", 4) == 0)
d2963 1
a2963 3
	  if (cplus_demangle_opname (t_field_name, dem_opname, DMGL_ANSI))
	    t_field_name = dem_opname;
	  else if (cplus_demangle_opname (t_field_name, dem_opname, 0))
d2965 2
d2972 1
a2972 1

d2985 1
a2985 1

d3058 4
a3061 4
     value_ptr v;
     int *full;
     int *top;
     int *using_enc;
d3063 2
a3064 2
  struct type *known_type;
  struct type *rtti_type;
d3078 1
a3078 1
  /* Get declared type */
d3081 1
a3081 1
  /* RTTI works only or class objects */
d3093 2
a3094 2
	  !TYPE_HAS_VTABLE (known_type))
	return NULL;		/* No RTTI, or not HP-compiled types */
d3103 3
a3105 3
  coreptr = *(CORE_ADDR *) ((VALUE_CONTENTS_ALL (v))
			    + VALUE_OFFSET (v)
		       + (using_enclosing ? 0 : VALUE_EMBEDDED_OFFSET (v)));
d3107 1
a3107 1
    return NULL;		/* return silently -- maybe called on gdb-generated value */
d3109 1
a3109 1
  /* Fetch the top offset of the object */
d3111 3
a3113 3
  vp = value_at (builtin_type_int,
		 coreptr + 4 * HP_ACC_TOP_OFFSET_OFFSET,
		 VALUE_BFD_SECTION (v));
d3123 1
a3123 1
  coreptr = *(CORE_ADDR *) (VALUE_CONTENTS (vp));
d3126 2
a3127 2
  vp = value_at (builtin_type_int, coreptr + 4, VALUE_BFD_SECTION (v));		/* 4 -> offset of name field */
  /* FIXME possible 32x64 problem */
d3129 1
a3129 1
  coreptr = *(CORE_ADDR *) (VALUE_CONTENTS (vp));
d3135 1
a3135 1

d3138 1
a3138 1

d3143 2
a3144 2
#if 0				/* debugging */
  printf ("RTTI type name %s, tag %s, full? %d\n", TYPE_NAME (rtti_type), TYPE_TAG_NAME (rtti_type), full ? *full : -1);
d3148 1
a3148 1
  if (full			/* Non-null pointer passed */
d3151 12
a3162 12
  /* Either we checked on the whole object in hand and found the
     top offset to be zero */
      (((top_offset == 0) &&
	using_enclosing &&
	TYPE_LENGTH (known_type) == TYPE_LENGTH (rtti_type))
       ||
  /* Or we checked on the embedded object and top offset was the
     same as the embedded offset */
       ((top_offset == VALUE_EMBEDDED_OFFSET (v)) &&
	!using_enclosing &&
	TYPE_LENGTH (VALUE_ENCLOSING_TYPE (v)) == TYPE_LENGTH (rtti_type))))

d3164 1
a3164 1

d3175 4
a3178 4
     value_ptr v;
     int *full;
     int *top;
     int *using_enc;
d3199 6
a3204 6
     value_ptr argp;
     struct type *rtype;
     int xfull;
     int xtop;
     int xusing_enc;

d3206 1
a3206 1
  struct type *real_type;
d3227 1
a3227 1
     type is wrong, set it *//* pai: FIXME -- sounds iffy */
d3238 1
a3238 1

d3241 1
a3241 1

d3247 2
a3248 2
			   (using_enc ? 0 : VALUE_EMBEDDED_OFFSET (argp)),
			   VALUE_BFD_SECTION (argp));
d3274 2
a3275 3
	error ("no frame selected");
      else
	return 0;
d3283 1
a3283 2
      else
	return 0;
d3291 2
a3292 3
	error ("no args, no `this'");
      else
	return 0;
d3336 1
a3336 1
  /* Chill allows zero-length strings but not arrays. */
d3342 1
a3342 1
  slice_range_type = create_range_type ((struct type *) NULL,
d3348 1
a3348 1
      slice_type = create_set_type ((struct type *) NULL, slice_range_type);
d3367 2
a3368 2
         can be used on the LHS, but that may require extensions to
         value_assign.  For now, just leave as a non_lval.  FIXME.  */
d3375 1
a3375 1
      slice_type = create_array_type ((struct type *) NULL, element_type,
d3412 1
a3412 1
   doubles. FIXME: fmb */
d3452 1
a3452 1
	      TYPE_LENGTH (val_real_type));
d3468 1
a3468 1
    (add_set_cmd ("abandon", class_support, var_boolean, (char *) &auto_abandon,
d3475 1
a3475 1
    (add_set_cmd ("overload-resolution", class_support, var_boolean, (char *) &overload_resolution,
@


1.1.1.7
log
@import gdb-1999-09-21
@
text
@d64 4
d973 1
d2547 1
d2680 2
@


1.1.1.8
log
@import gdb-1999-10-11 snapshot
@
text
@d1064 1
a1064 6
#ifndef PARM_BOUNDARY
#define PARM_BOUNDARY (0)
#endif

/* Push onto the stack the specified value VALUE.  Pad it correctly for
   it to be an argument to a function.  */
a1071 13
  register int container_len;
  register int offset;

  /* How big is the container we're going to put this value in?  */
  if (PARM_BOUNDARY)
    container_len = ((len + PARM_BOUNDARY / TARGET_CHAR_BIT - 1)
		     & ~(PARM_BOUNDARY / TARGET_CHAR_BIT - 1));

  /* Are we going to put it at the high or low end of the container?  */
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
    offset = container_len - len;
  else
    offset = 0;
d1076 2
a1077 2
      sp -= container_len;
      write_memory (sp + offset, VALUE_CONTENTS_ALL (arg), len);
d1082 2
a1083 2
      write_memory (sp + offset, VALUE_CONTENTS_ALL (arg), len);
      sp += container_len;
@


1.1.1.9
log
@import gdb-1999-10-18 snapshot
@
text
@d1077 1
a1077 1
  register int container_len = len;
a2678 8

      /* If the name is NULL this must be a C-style function.
         Just return the same symbol. */
      if (!func_name)
        {
	  *symp = fsym;
          return 0;
        }
@


1.1.1.10
log
@import gdb-1999-12-06 snapshot
@
text
@d665 2
a666 2
	    error ("Can't assign to bitfields that cross register "
		   "boundaries.");
@


1.1.1.11
log
@import gdb-2000-01-31 snapshot
@
text
@a1294 1
  int rc;
d1690 1
a1690 20
    rc = run_stack_dummy (real_pc + CALL_DUMMY_START_OFFSET, retbuf);

    if (rc == 1)
      {
	/* We stopped inside the FUNCTION because of a random signal.
	   Further execution of the FUNCTION is not allowed. */

	/* In this case, we must do the cleanups because we don't
	   want the dummy anymore (the dummy frame has been poped already. */
	do_cleanups (old_chain);

	/* FIXME: Insert a bunch of wrap_here; name can be very long if it's
	   a C++ name with arguments and stuff.  */
	error ("\
The program being debugged stopped while in a function called from GDB.\n\
Evaluation of the expression containing the function (%s) will be abandoned.",
	       name);
      }

    if (rc == 2)
d1692 1
a1692 1
	/* We hit a breakpoint inside the FUNCTION. */
a1716 1
    /* If we get here the called FUNCTION run to completion. */
@


