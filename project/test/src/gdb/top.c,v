head	1.245;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.226.2.1
	gdb_7_6-2013-04-26-release:1.226.2.1
	gdb_7_6-branch:1.226.0.2
	gdb_7_6-2013-03-12-branchpoint:1.226
	gdb_7_5_1-2012-11-29-release:1.216
	gdb_7_5-2012-08-17-release:1.216
	gdb_7_5-branch:1.216.0.2
	gdb_7_5-2012-07-18-branchpoint:1.216
	gdb_7_4_1-2012-04-26-release:1.208.2.2
	gdb_7_4-2012-01-24-release:1.208.2.2
	gdb_7_4-branch:1.208.0.2
	gdb_7_4-2011-12-13-branchpoint:1.208
	gdb_7_3_1-2011-09-04-release:1.195
	gdb_7_3-2011-07-26-release:1.195
	gdb_7_3-branch:1.195.0.2
	gdb_7_3-2011-04-01-branchpoint:1.195
	gdb_7_2-2010-09-02-release:1.181.2.2
	gdb_7_2-branch:1.181.0.2
	gdb_7_2-2010-07-07-branchpoint:1.181
	gdb_7_1-2010-03-18-release:1.177
	gdb_7_1-branch:1.177.0.2
	gdb_7_1-2010-02-18-branchpoint:1.177
	gdb_7_0_1-2009-12-22-release:1.171
	gdb_7_0-2009-10-06-release:1.171
	gdb_7_0-branch:1.171.0.2
	gdb_7_0-2009-09-16-branchpoint:1.171
	arc-sim-20090309:1.129
	msnyder-checkpoint-072509-branch:1.167.0.2
	msnyder-checkpoint-072509-branchpoint:1.167
	arc-insight_6_8-branch:1.129.0.6
	arc-insight_6_8-branchpoint:1.129
	insight_6_8-branch:1.129.0.4
	insight_6_8-branchpoint:1.129
	reverse-20081226-branch:1.154.0.6
	reverse-20081226-branchpoint:1.154
	multiprocess-20081120-branch:1.154.0.4
	multiprocess-20081120-branchpoint:1.154
	reverse-20080930-branch:1.154.0.2
	reverse-20080930-branchpoint:1.154
	reverse-20080717-branch:1.148.0.2
	reverse-20080717-branchpoint:1.148
	msnyder-reverse-20080609-branch:1.142.0.2
	msnyder-reverse-20080609-branchpoint:1.142
	drow-reverse-20070409-branch:1.120.0.2
	drow-reverse-20070409-branchpoint:1.120
	gdb_6_8-2008-03-27-release:1.129
	gdb_6_8-branch:1.129.0.2
	gdb_6_8-2008-02-26-branchpoint:1.129
	gdb_6_7_1-2007-10-29-release:1.125
	gdb_6_7-2007-10-10-release:1.125
	gdb_6_7-branch:1.125.0.2
	gdb_6_7-2007-09-07-branchpoint:1.125
	insight_6_6-20070208-release:1.115
	gdb_6_6-2006-12-18-release:1.115
	gdb_6_6-branch:1.115.0.2
	gdb_6_6-2006-11-15-branchpoint:1.115
	insight_6_5-20061003-release:1.114
	gdb-csl-symbian-6_4_50_20060226-12:1.113
	gdb-csl-sourcerygxx-3_4_4-25:1.107
	nickrob-async-20060828-mergepoint:1.115
	gdb-csl-symbian-6_4_50_20060226-11:1.113
	gdb-csl-sourcerygxx-4_1-17:1.113.2.1
	gdb-csl-20060226-branch-local-2:1.113.2.1
	gdb-csl-sourcerygxx-4_1-14:1.113
	gdb-csl-sourcerygxx-4_1-13:1.113
	gdb-csl-sourcerygxx-4_1-12:1.113
	gdb-csl-sourcerygxx-3_4_4-21:1.113
	gdb_6_5-20060621-release:1.114
	gdb-csl-sourcerygxx-4_1-9:1.113
	gdb-csl-sourcerygxx-4_1-8:1.113
	gdb-csl-sourcerygxx-4_1-7:1.113
	gdb-csl-arm-2006q1-6:1.113
	gdb-csl-sourcerygxx-4_1-6:1.113
	gdb-csl-symbian-6_4_50_20060226-10:1.113
	gdb-csl-symbian-6_4_50_20060226-9:1.113
	gdb-csl-symbian-6_4_50_20060226-8:1.113
	gdb-csl-coldfire-4_1-11:1.113
	gdb-csl-sourcerygxx-3_4_4-19:1.113
	gdb-csl-coldfire-4_1-10:1.113
	gdb_6_5-branch:1.114.0.10
	gdb_6_5-2006-05-14-branchpoint:1.114
	gdb-csl-sourcerygxx-4_1-5:1.113
	nickrob-async-20060513-branch:1.114.0.8
	nickrob-async-20060513-branchpoint:1.114
	gdb-csl-sourcerygxx-4_1-4:1.113
	msnyder-reverse-20060502-branch:1.114.0.6
	msnyder-reverse-20060502-branchpoint:1.114
	gdb-csl-morpho-4_1-4:1.113
	gdb-csl-sourcerygxx-3_4_4-17:1.113
	readline_5_1-import-branch:1.114.0.4
	readline_5_1-import-branchpoint:1.114
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.113
	gdb-csl-symbian-20060226-branch:1.113.0.6
	gdb-csl-symbian-20060226-branchpoint:1.113
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.113
	msnyder-reverse-20060331-branch:1.114.0.2
	msnyder-reverse-20060331-branchpoint:1.114
	gdb-csl-available-20060303-branch:1.113.0.4
	gdb-csl-available-20060303-branchpoint:1.113
	gdb-csl-20060226-branch:1.113.0.2
	gdb-csl-20060226-branchpoint:1.113
	gdb_6_4-20051202-release:1.105.4.2
	msnyder-fork-checkpoint-branch:1.107.0.4
	msnyder-fork-checkpoint-branchpoint:1.107
	gdb-csl-gxxpro-6_3-branch:1.107.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.107
	gdb_6_4-branch:1.105.0.4
	gdb_6_4-2005-11-01-branchpoint:1.105
	gdb-csl-arm-20051020-branch:1.105.0.2
	gdb-csl-arm-20051020-branchpoint:1.105
	msnyder-tracepoint-checkpoint-branch:1.104.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.104
	gdb-csl-arm-20050325-2005-q1b:1.103
	gdb-csl-arm-20050325-2005-q1a:1.103
	csl-arm-20050325-branch:1.103.0.2
	csl-arm-20050325-branchpoint:1.103
	gdb-post-i18n-errorwarning-20050211:1.97
	gdb-pre-i18n-errorwarning-20050211:1.96
	gdb_6_3-20041109-release:1.94
	gdb_6_3-branch:1.94.0.2
	gdb_6_3-20041019-branchpoint:1.94
	drow_intercu-merge-20040921:1.93
	drow_intercu-merge-20040915:1.93
	jimb-gdb_6_2-e500-branch:1.90.0.6
	jimb-gdb_6_2-e500-branchpoint:1.90
	gdb_6_2-20040730-release:1.90
	gdb_6_2-branch:1.90.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.90
	gdb_6_1_1-20040616-release:1.88
	gdb_6_1-2004-04-05-release:1.88
	drow_intercu-merge-20040402:1.88
	drow_intercu-merge-20040327:1.88
	ezannoni_pie-20040323-branch:1.88.0.6
	ezannoni_pie-20040323-branchpoint:1.88
	cagney_tramp-20040321-mergepoint:1.88
	cagney_tramp-20040309-branch:1.88.0.4
	cagney_tramp-20040309-branchpoint:1.88
	gdb_6_1-branch:1.88.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.88
	drow_intercu-20040221-branch:1.87.0.6
	drow_intercu-20040221-branchpoint:1.87
	cagney_bfdfile-20040213-branch:1.87.0.4
	cagney_bfdfile-20040213-branchpoint:1.87
	drow-cplus-merge-20040208:1.87
	carlton_dictionary-20040126-merge:1.87
	cagney_bigcore-20040122-branch:1.87.0.2
	cagney_bigcore-20040122-branchpoint:1.87
	drow-cplus-merge-20040113:1.86
	drow-cplus-merge-20031224:1.85
	drow-cplus-merge-20031220:1.85
	carlton_dictionary-20031215-merge:1.85
	drow-cplus-merge-20031214:1.85
	carlton-dictionary-20031111-merge:1.85
	gdb_6_0-2003-10-04-release:1.73.4.2
	kettenis_sparc-20030918-branch:1.77.0.4
	kettenis_sparc-20030918-branchpoint:1.77
	carlton_dictionary-20030917-merge:1.77
	ezannoni_pie-20030916-branchpoint:1.77
	ezannoni_pie-20030916-branch:1.77.0.2
	cagney_x86i386-20030821-branch:1.75.0.2
	cagney_x86i386-20030821-branchpoint:1.75
	carlton_dictionary-20030805-merge:1.74
	carlton_dictionary-20030627-merge:1.73
	gdb_6_0-branch:1.73.0.4
	gdb_6_0-2003-06-23-branchpoint:1.73
	jimb-ppc64-linux-20030613-branch:1.73.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.73
	cagney_convert-20030606-branch:1.72.0.2
	cagney_convert-20030606-branchpoint:1.72
	cagney_writestrings-20030508-branch:1.71.0.24
	cagney_writestrings-20030508-branchpoint:1.71
	jimb-ppc64-linux-20030528-branch:1.71.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.71
	carlton_dictionary-20030523-merge:1.71
	cagney_fileio-20030521-branch:1.71.0.20
	cagney_fileio-20030521-branchpoint:1.71
	kettenis_i386newframe-20030517-mergepoint:1.71
	jimb-ppc64-linux-20030509-branch:1.71.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.71
	kettenis_i386newframe-20030504-mergepoint:1.71
	carlton_dictionary-20030430-merge:1.71
	kettenis_i386newframe-20030419-branch:1.71.0.16
	kettenis_i386newframe-20030419-branchpoint:1.71
	carlton_dictionary-20030416-merge:1.71
	cagney_frameaddr-20030409-mergepoint:1.71
	kettenis_i386newframe-20030406-branch:1.71.0.14
	kettenis_i386newframe-20030406-branchpoint:1.71
	cagney_frameaddr-20030403-branchpoint:1.71
	cagney_frameaddr-20030403-branch:1.71.0.12
	cagney_framebase-20030330-mergepoint:1.71
	cagney_framebase-20030326-branch:1.71.0.10
	cagney_framebase-20030326-branchpoint:1.71
	cagney_lazyid-20030317-branch:1.71.0.8
	cagney_lazyid-20030317-branchpoint:1.71
	kettenis-i386newframe-20030316-mergepoint:1.71
	offbyone-20030313-branch:1.71.0.6
	offbyone-20030313-branchpoint:1.71
	kettenis-i386newframe-20030308-branch:1.71.0.4
	kettenis-i386newframe-20030308-branchpoint:1.71
	carlton_dictionary-20030305-merge:1.71
	cagney_offbyone-20030303-branch:1.71.0.2
	cagney_offbyone-20030303-branchpoint:1.71
	carlton_dictionary-20030207-merge:1.71
	interps-20030203-mergepoint:1.70
	interps-20030202-branch:1.70.0.2
	interps-20030202-branchpoint:1.70
	cagney-unwind-20030108-branch:1.69.0.2
	cagney-unwind-20030108-branchpoint:1.69
	carlton_dictionary-20021223-merge:1.69
	gdb_5_3-2002-12-12-release:1.66.6.2
	carlton_dictionary-20021115-merge:1.68
	kseitz_interps-20021105-merge:1.68
	kseitz_interps-20021103-merge:1.68
	drow-cplus-merge-20021020:1.68
	drow-cplus-merge-20021025:1.68
	carlton_dictionary-20021025-merge:1.68
	carlton_dictionary-20021011-merge:1.68
	drow-cplus-branch:1.68.0.2
	drow-cplus-branchpoint:1.68
	kseitz_interps-20020930-merge:1.68
	carlton_dictionary-20020927-merge:1.68
	carlton_dictionary-branch:1.67.0.2
	carlton_dictionary-20020920-branchpoint:1.67
	gdb_5_3-branch:1.66.0.6
	gdb_5_3-2002-09-04-branchpoint:1.66
	kseitz_interps-20020829-merge:1.66
	cagney_sysregs-20020825-branch:1.66.0.4
	cagney_sysregs-20020825-branchpoint:1.66
	readline_4_3-import-branch:1.66.0.2
	readline_4_3-import-branchpoint:1.66
	gdb_5_2_1-2002-07-23-release:1.57
	kseitz_interps-20020528-branch:1.62.0.6
	kseitz_interps-20020528-branchpoint:1.62
	cagney_regbuf-20020515-branch:1.62.0.4
	cagney_regbuf-20020515-branchpoint:1.62
	jimb-macro-020506-branch:1.62.0.2
	jimb-macro-020506-branchpoint:1.62
	gdb_5_2-2002-04-29-release:1.57
	gdb_5_2-branch:1.57.0.2
	gdb_5_2-2002-03-03-branchpoint:1.57
	gdb_5_1_1-2002-01-24-release:1.41.2.3
	gdb_5_1_0_1-2002-01-03-release:1.41.2.2
	cygnus_cvs_20020108_pre:1.51
	gdb_5_1_0_1-2002-01-03-branchpoint:1.41.2.2
	gdb_5_1_0_1-2002-01-03-branch:1.41.2.2.0.2
	gdb_5_1-2001-11-21-release:1.41.2.2
	gdb_s390-2001-09-26-branch:1.41.2.1.0.2
	gdb_s390-2001-09-26-branchpoint:1.41.2.1
	gdb_5_1-2001-07-29-branch:1.41.0.2
	gdb_5_1-2001-07-29-branchpoint:1.41
	dberlin-typesystem-branch:1.35.0.2
	dberlin-typesystem-branchpoint:1.35
	gdb-post-ptid_t-2001-05-03:1.34
	gdb-pre-ptid_t-2001-05-03:1.33
	insight-precleanup-2001-01-01:1.26
	gdb-post-protoization-2000-07-29:1.16
	gdb-pre-protoization-2000-07-29:1.15
	gdb-premipsmulti-2000-06-06-branch:1.14.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.14
	gdb-post-params-removal-2000-06-04:1.14
	gdb-pre-params-removal-2000-06-04:1.13
	gdb-post-params-removal-2000-05-28:1.13
	gdb-pre-params-removal-2000-05-28:1.12
	gdb_5_0-2000-05-19-release:1.9.2.1
	gdb_4_18_2-2000-05-18-release:1.9.2.1
	gdb_4_95_1-2000-05-11-snapshot:1.9.2.1
	gdb_4_95_0-2000-04-27-snapshot:1.9.2.1
	gdb_5_0-2000-04-10-branch:1.9.0.2
	gdb_5_0-2000-04-10-branchpoint:1.9
	repo-unification-2000-02-06:1.1.1.26
	insight-2000-02-04:1.1.1.26
	gdb-2000-02-04:1.1.1.26
	gdb-2000-02-02:1.1.1.26
	gdb-2000-02-01:1.1.1.25
	gdb-2000-01-31:1.1.1.24
	gdb-2000-01-26:1.1.1.23
	gdb-2000-01-24:1.1.1.23
	gdb-2000-01-17:1.1.1.23
	gdb-2000-01-10:1.1.1.23
	gdb-2000-01-05:1.1.1.23
	gdb-1999-12-21:1.1.1.23
	gdb-1999-12-13:1.1.1.23
	gdb-1999-12-07:1.1.1.22
	gdb-1999-12-06:1.1.1.22
	gdb-1999-11-16:1.1.1.21
	gdb-1999-11-08:1.1.1.21
	gdb-1999-11-01:1.1.1.20
	gdb-1999-10-25:1.1.1.20
	gdb-1999-10-18:1.1.1.19
	gdb-1999-10-11:1.1.1.18
	gdb-1999-10-04:1.1.1.18
	gdb-1999-09-28:1.1.1.17
	gdb-1999-09-21:1.1.1.16
	gdb-1999-09-13:1.1.1.15
	gdb-1999-09-08:1.1.1.15
	gdb-1999-08-30:1.1.1.14
	gdb-1999-08-23:1.1.1.13
	gdb-1999-08-16:1.1.1.13
	gdb-1999-08-09:1.1.1.12
	gdb-1999-08-02:1.1.1.11
	gdb-1999-07-26:1.1.1.10
	gdb-1999-07-19:1.1.1.10
	gdb-1999-07-12:1.1.1.10
	gdb-post-reformat-19990707:1.1.1.10
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.10
	gdb-pre-reformat-19990707:1.1.1.9
	gdb-1999-07-07:1.1.1.9
	gdb-1999-07-05:1.1.1.9
	gdb-1999-06-28:1.1.1.8
	gdb-1999-06-21:1.1.1.7
	gdb-1999-06-14:1.1.1.6
	gdb-1999-06-07:1.1.1.5
	gdb-1999-06-01:1.1.1.5
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.5
	gdb-1999-05-19:1.1.1.4
	gdb-1999-05-10:1.1.1.3
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.245
date	2013.10.10.05.50.20;	author brobecke;	state Exp;
branches;
next	1.244;

1.244
date	2013.09.09.12.13.58;	author aburgess;	state Exp;
branches;
next	1.243;

1.243
date	2013.09.05.16.46.56;	author aburgess;	state Exp;
branches;
next	1.242;

1.242
date	2013.08.29.09.09.22;	author pmuldoon;	state Exp;
branches;
next	1.241;

1.241
date	2013.08.15.08.18.31;	author mbilal;	state Exp;
branches;
next	1.240;

1.240
date	2013.07.30.12.06.04;	author mbilal;	state Exp;
branches;
next	1.239;

1.239
date	2013.07.22.11.42.31;	author pmuldoon;	state Exp;
branches;
next	1.238;

1.238
date	2013.07.06.07.34.48;	author eliz;	state Exp;
branches;
next	1.237;

1.237
date	2013.07.01.11.24.16;	author palves;	state Exp;
branches;
next	1.236;

1.236
date	2013.05.30.17.27.44;	author tromey;	state Exp;
branches;
next	1.235;

1.235
date	2013.04.17.01.02.02;	author qiyao;	state Exp;
branches;
next	1.234;

1.234
date	2013.04.12.08.57.06;	author eliz;	state Exp;
branches;
next	1.233;

1.233
date	2013.04.10.15.11.11;	author palves;	state Exp;
branches;
next	1.232;

1.232
date	2013.04.10.14.10.35;	author palves;	state Exp;
branches;
next	1.231;

1.231
date	2013.03.27.12.14.09;	author palves;	state Exp;
branches;
next	1.230;

1.230
date	2013.03.26.16.47.02;	author palves;	state Exp;
branches;
next	1.229;

1.229
date	2013.03.21.17.37.29;	author devans;	state Exp;
branches;
next	1.228;

1.228
date	2013.03.20.15.46.24;	author jkratoch;	state Exp;
branches;
next	1.227;

1.227
date	2013.03.13.18.34.54;	author palves;	state Exp;
branches;
next	1.226;

1.226
date	2013.01.25.14.17.10;	author qiyao;	state Exp;
branches
	1.226.2.1;
next	1.225;

1.225
date	2013.01.07.16.40.36;	author tromey;	state Exp;
branches;
next	1.224;

1.224
date	2013.01.01.06.41.29;	author brobecke;	state Exp;
branches;
next	1.223;

1.223
date	2013.01.01.05.45.21;	author brobecke;	state Exp;
branches;
next	1.222;

1.222
date	2012.12.18.19.26.29;	author tromey;	state Exp;
branches;
next	1.221;

1.221
date	2012.12.17.15.11.56;	author tromey;	state Exp;
branches;
next	1.220;

1.220
date	2012.08.28.14.08.41;	author qiyao;	state Exp;
branches;
next	1.219;

1.219
date	2012.08.22.17.48.54;	author tromey;	state Exp;
branches;
next	1.218;

1.218
date	2012.08.09.12.53.43;	author qiyao;	state Exp;
branches;
next	1.217;

1.217
date	2012.07.31.06.16.09;	author qiyao;	state Exp;
branches;
next	1.216;

1.216
date	2012.05.11.18.13.24;	author jkratoch;	state Exp;
branches;
next	1.215;

1.215
date	2012.04.19.20.18.26;	author tromey;	state Exp;
branches;
next	1.214;

1.214
date	2012.03.01.19.30.20;	author devans;	state Exp;
branches;
next	1.213;

1.213
date	2012.01.23.17.12.30;	author palves;	state Exp;
branches;
next	1.212;

1.212
date	2012.01.23.17.11.48;	author palves;	state Exp;
branches;
next	1.211;

1.211
date	2012.01.04.08.27.57;	author brobecke;	state Exp;
branches;
next	1.210;

1.210
date	2012.01.02.08.59.35;	author brobecke;	state Exp;
branches;
next	1.209;

1.209
date	2011.12.16.20.29.28;	author palves;	state Exp;
branches;
next	1.208;

1.208
date	2011.09.21.15.21.28;	author jsm28;	state Exp;
branches
	1.208.2.1;
next	1.207;

1.207
date	2011.09.06.14.48.59;	author palves;	state Exp;
branches;
next	1.206;

1.206
date	2011.09.05.14.53.13;	author palves;	state Exp;
branches;
next	1.205;

1.205
date	2011.09.02.16.56.29;	author palves;	state Exp;
branches;
next	1.204;

1.204
date	2011.08.26.21.45.23;	author jkratoch;	state Exp;
branches;
next	1.203;

1.203
date	2011.08.04.20.09.43;	author palves;	state Exp;
branches;
next	1.202;

1.202
date	2011.08.04.19.10.13;	author palves;	state Exp;
branches;
next	1.201;

1.201
date	2011.07.22.09.22.50;	author pmuldoon;	state Exp;
branches;
next	1.200;

1.200
date	2011.07.21.11.03.45;	author pmuldoon;	state Exp;
branches;
next	1.199;

1.199
date	2011.06.27.19.21.50;	author tromey;	state Exp;
branches;
next	1.198;

1.198
date	2011.06.13.10.55.27;	author palves;	state Exp;
branches;
next	1.197;

1.197
date	2011.05.13.04.34.19;	author bauermann;	state Exp;
branches;
next	1.196;

1.196
date	2011.04.19.18.04.07;	author tromey;	state Exp;
branches;
next	1.195;

1.195
date	2011.03.12.22.59.24;	author msnyder;	state Exp;
branches;
next	1.194;

1.194
date	2011.03.11.20.38.57;	author msnyder;	state Exp;
branches;
next	1.193;

1.193
date	2011.01.31.16.52.34;	author tromey;	state Exp;
branches;
next	1.192;

1.192
date	2011.01.21.18.56.41;	author brobecke;	state Exp;
branches;
next	1.191;

1.191
date	2011.01.13.23.01.07;	author brobecke;	state Exp;
branches;
next	1.190;

1.190
date	2011.01.11.21.53.25;	author msnyder;	state Exp;
branches;
next	1.189;

1.189
date	2011.01.05.22.22.53;	author msnyder;	state Exp;
branches;
next	1.188;

1.188
date	2011.01.01.15.33.18;	author brobecke;	state Exp;
branches;
next	1.187;

1.187
date	2011.01.01.14.14.46;	author brobecke;	state Exp;
branches;
next	1.186;

1.186
date	2010.12.29.00.58.14;	author msnyder;	state Exp;
branches;
next	1.185;

1.185
date	2010.11.02.16.48.41;	author devans;	state Exp;
branches;
next	1.184;

1.184
date	2010.09.11.16.00.25;	author jkratoch;	state Exp;
branches;
next	1.183;

1.183
date	2010.08.07.15.00.37;	author jkratoch;	state Exp;
branches;
next	1.182;

1.182
date	2010.07.27.19.11.51;	author jkratoch;	state Exp;
branches;
next	1.181;

1.181
date	2010.06.26.06.44.47;	author hilfingr;	state Exp;
branches
	1.181.2.1;
next	1.180;

1.180
date	2010.05.17.01.15.20;	author msnyder;	state Exp;
branches;
next	1.179;

1.179
date	2010.05.07.00.47.36;	author msnyder;	state Exp;
branches;
next	1.178;

1.178
date	2010.04.07.16.54.39;	author devans;	state Exp;
branches;
next	1.177;

1.177
date	2010.01.19.22.23.53;	author tromey;	state Exp;
branches;
next	1.176;

1.176
date	2010.01.01.07.31.42;	author brobecke;	state Exp;
branches;
next	1.175;

1.175
date	2010.01.01.06.56.04;	author brobecke;	state Exp;
branches;
next	1.174;

1.174
date	2009.12.02.19.29.42;	author ppluzhnikov;	state Exp;
branches;
next	1.173;

1.173
date	2009.11.05.20.43.52;	author drow;	state Exp;
branches;
next	1.172;

1.172
date	2009.10.19.09.51.42;	author palves;	state Exp;
branches;
next	1.171;

1.171
date	2009.09.10.18.56.45;	author brobecke;	state Exp;
branches;
next	1.170;

1.170
date	2009.08.31.20.18.45;	author devans;	state Exp;
branches;
next	1.169;

1.169
date	2009.08.28.23.26.54;	author devans;	state Exp;
branches;
next	1.168;

1.168
date	2009.08.14.14.28.14;	author palves;	state Exp;
branches;
next	1.167;

1.167
date	2009.06.07.16.46.48;	author palves;	state Exp;
branches;
next	1.166;

1.166
date	2009.05.23.16.17.18;	author jkratoch;	state Exp;
branches;
next	1.165;

1.165
date	2009.05.21.15.48.41;	author palves;	state Exp;
branches;
next	1.164;

1.164
date	2009.04.23.21.28.19;	author tromey;	state Exp;
branches;
next	1.163;

1.163
date	2009.03.25.21.42.34;	author palves;	state Exp;
branches;
next	1.162;

1.162
date	2009.03.25.10.50.56;	author muller;	state Exp;
branches;
next	1.161;

1.161
date	2009.03.03.13.35.24;	author palves;	state Exp;
branches;
next	1.160;

1.160
date	2009.02.25.02.14.23;	author teawater;	state Exp;
branches;
next	1.159;

1.159
date	2009.01.09.17.29.52;	author palves;	state Exp;
branches;
next	1.158;

1.158
date	2009.01.07.22.04.47;	author devans;	state Exp;
branches;
next	1.157;

1.157
date	2009.01.06.18.28.04;	author jimb;	state Exp;
branches;
next	1.156;

1.156
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.155;

1.155
date	2009.01.03.05.18.00;	author brobecke;	state Exp;
branches;
next	1.154;

1.154
date	2008.09.22.15.24.51;	author palves;	state Exp;
branches
	1.154.4.1;
next	1.153;

1.153
date	2008.09.22.15.21.30;	author palves;	state Exp;
branches;
next	1.152;

1.152
date	2008.09.08.21.46.21;	author palves;	state Exp;
branches;
next	1.151;

1.151
date	2008.08.16.23.51.14;	author palves;	state Exp;
branches;
next	1.150;

1.150
date	2008.08.16.22.12.18;	author palves;	state Exp;
branches;
next	1.149;

1.149
date	2008.07.28.17.53.52;	author tromey;	state Exp;
branches;
next	1.148;

1.148
date	2008.07.13.04.09.47;	author vprus;	state Exp;
branches;
next	1.147;

1.147
date	2008.07.12.19.07.38;	author palves;	state Exp;
branches;
next	1.146;

1.146
date	2008.07.11.11.07.39;	author palves;	state Exp;
branches;
next	1.145;

1.145
date	2008.07.09.22.30.46;	author palves;	state Exp;
branches;
next	1.144;

1.144
date	2008.07.09.22.16.15;	author palves;	state Exp;
branches;
next	1.143;

1.143
date	2008.06.10.11.57.28;	author schwab;	state Exp;
branches;
next	1.142;

1.142
date	2008.06.05.22.36.56;	author jsm28;	state Exp;
branches;
next	1.141;

1.141
date	2008.05.05.09.47.46;	author vprus;	state Exp;
branches;
next	1.140;

1.140
date	2008.05.05.09.02.59;	author vprus;	state Exp;
branches;
next	1.139;

1.139
date	2008.04.24.11.13.44;	author vprus;	state Exp;
branches;
next	1.138;

1.138
date	2008.04.17.00.25.01;	author tromey;	state Exp;
branches;
next	1.137;

1.137
date	2008.03.23.17.29.34;	author drow;	state Exp;
branches;
next	1.136;

1.136
date	2008.03.21.21.44.30;	author drow;	state Exp;
branches;
next	1.135;

1.135
date	2008.03.21.14.39.22;	author drow;	state Exp;
branches;
next	1.134;

1.134
date	2008.03.17.14.06.11;	author uweigand;	state Exp;
branches;
next	1.133;

1.133
date	2008.03.14.18.57.43;	author vprus;	state Exp;
branches;
next	1.132;

1.132
date	2008.03.14.17.46.54;	author vprus;	state Exp;
branches;
next	1.131;

1.131
date	2008.03.14.15.46.32;	author palves;	state Exp;
branches;
next	1.130;

1.130
date	2008.03.14.07.59.32;	author palves;	state Exp;
branches;
next	1.129;

1.129
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.128;

1.128
date	2008.01.01.04.27.42;	author brobecke;	state Exp;
branches;
next	1.127;

1.127
date	2007.12.07.15.02.12;	author macro;	state Exp;
branches;
next	1.126;

1.126
date	2007.10.22.16.11.13;	author drow;	state Exp;
branches;
next	1.125;

1.125
date	2007.09.02.21.13.56;	author jkratoch;	state Exp;
branches;
next	1.124;

1.124
date	2007.09.02.20.02.12;	author drow;	state Exp;
branches;
next	1.123;

1.123
date	2007.08.23.18.08.46;	author brobecke;	state Exp;
branches;
next	1.122;

1.122
date	2007.08.08.18.34.28;	author msnyder;	state Exp;
branches;
next	1.121;

1.121
date	2007.07.01.22.37.52;	author drow;	state Exp;
branches;
next	1.120;

1.120
date	2007.03.29.18.55.01;	author drow;	state Exp;
branches;
next	1.119;

1.119
date	2007.02.28.15.55.54;	author drow;	state Exp;
branches;
next	1.118;

1.118
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.117;

1.117
date	2007.01.03.21.46.11;	author drow;	state Exp;
branches;
next	1.116;

1.116
date	2007.01.01.05.57.49;	author brobecke;	state Exp;
branches;
next	1.115;

1.115
date	2006.07.21.14.46.53;	author ams;	state Exp;
branches;
next	1.114;

1.114
date	2006.03.29.22.53.33;	author drow;	state Exp;
branches
	1.114.8.1;
next	1.113;

1.113
date	2006.02.10.22.01.43;	author drow;	state Exp;
branches
	1.113.2.1;
next	1.112;

1.112
date	2006.01.07.10.22.21;	author eliz;	state Exp;
branches;
next	1.111;

1.111
date	2006.01.02.05.50.11;	author brobecke;	state Exp;
branches;
next	1.110;

1.110
date	2006.01.02.05.45.54;	author brobecke;	state Exp;
branches;
next	1.109;

1.109
date	2005.12.17.22.34.03;	author eliz;	state Exp;
branches;
next	1.108;

1.108
date	2005.11.22.19.24.03;	author brobecke;	state Exp;
branches;
next	1.107;

1.107
date	2005.11.07.15.27.07;	author ams;	state Exp;
branches;
next	1.106;

1.106
date	2005.11.04.11.49.11;	author ams;	state Exp;
branches;
next	1.105;

1.105
date	2005.07.04.13.29.12;	author kettenis;	state Exp;
branches
	1.105.4.1;
next	1.104;

1.104
date	2005.05.12.21.23.17;	author eliz;	state Exp;
branches;
next	1.103;

1.103
date	2005.02.24.13.51.35;	author cagney;	state Exp;
branches;
next	1.102;

1.102
date	2005.02.21.06.21.08;	author cagney;	state Exp;
branches;
next	1.101;

1.101
date	2005.02.18.18.58.56;	author cagney;	state Exp;
branches;
next	1.100;

1.100
date	2005.02.18.15.25.29;	author cagney;	state Exp;
branches;
next	1.99;

1.99
date	2005.02.15.15.49.22;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2005.02.12.00.39.21;	author cagney;	state Exp;
branches;
next	1.97;

1.97
date	2005.02.11.04.06.07;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2005.01.17.16.17.33;	author cagney;	state Exp;
branches;
next	1.95;

1.95
date	2005.01.12.18.31.33;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2004.10.14.12.44.23;	author kettenis;	state Exp;
branches;
next	1.93;

1.93
date	2004.09.13.18.26.30;	author cagney;	state Exp;
branches;
next	1.92;

1.92
date	2004.08.14.13.37.51;	author kettenis;	state Exp;
branches;
next	1.91;

1.91
date	2004.07.26.14.53.05;	author cagney;	state Exp;
branches;
next	1.90;

1.90
date	2004.06.25.19.46.08;	author cagney;	state Exp;
branches;
next	1.89;

1.89
date	2004.04.21.23.52.21;	author cagney;	state Exp;
branches;
next	1.88;

1.88
date	2004.02.28.18.04.37;	author cagney;	state Exp;
branches;
next	1.87;

1.87
date	2004.01.20.02.04.19;	author jjohnstn;	state Exp;
branches
	1.87.6.1;
next	1.86;

1.86
date	2004.01.02.20.53.11;	author chastain;	state Exp;
branches;
next	1.85;

1.85
date	2003.11.08.00.13.03;	author cagney;	state Exp;
branches;
next	1.84;

1.84
date	2003.11.06.22.54.01;	author cagney;	state Exp;
branches;
next	1.83;

1.83
date	2003.11.05.23.50.12;	author ezannoni;	state Exp;
branches;
next	1.82;

1.82
date	2003.10.22.21.39.09;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2003.10.10.07.13.11;	author ksakamot;	state Exp;
branches;
next	1.80;

1.80
date	2003.10.06.22.41.17;	author brobecke;	state Exp;
branches;
next	1.79;

1.79
date	2003.09.22.17.46.28;	author jjohnstn;	state Exp;
branches;
next	1.78;

1.78
date	2003.09.21.01.26.45;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2003.09.14.16.32.14;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2003.09.12.15.24.24;	author jjohnstn;	state Exp;
branches;
next	1.75;

1.75
date	2003.08.16.18.38.46;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2003.08.04.17.08.23;	author carlton;	state Exp;
branches;
next	1.73;

1.73
date	2003.06.08.18.27.14;	author cagney;	state Exp;
branches
	1.73.4.1;
next	1.72;

1.72
date	2003.06.02.16.02.58;	author rth;	state Exp;
branches;
next	1.71;

1.71
date	2003.02.06.01.19.12;	author cagney;	state Exp;
branches
	1.71.24.1;
next	1.70;

1.70
date	2003.01.12.21.38.16;	author chastain;	state Exp;
branches
	1.70.2.1;
next	1.69;

1.69
date	2002.12.09.00.59.26;	author ezannoni;	state Exp;
branches;
next	1.68;

1.68
date	2002.09.26.17.46.04;	author cagney;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2002.09.09.21.03.26;	author ezannoni;	state Exp;
branches
	1.67.2.1;
next	1.66;

1.66
date	2002.08.18.12.39.03;	author kettenis;	state Exp;
branches
	1.66.6.1;
next	1.65;

1.65
date	2002.07.24.17.58.46;	author tromey;	state Exp;
branches;
next	1.64;

1.64
date	2002.07.11.13.50.49;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2002.07.03.17.35.19;	author hunt;	state Exp;
branches;
next	1.62;

1.62
date	2002.04.23.03.00.57;	author thorpej;	state Exp;
branches
	1.62.4.1
	1.62.6.1;
next	1.61;

1.61
date	2002.03.28.01.35.55;	author msnyder;	state Exp;
branches;
next	1.60;

1.60
date	2002.03.24.00.40.35;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2002.03.17.19.53.39;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2002.03.06.06.28.34;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2002.02.23.20.12.13;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2002.02.10.04.08.42;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2002.02.05.04.37.22;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2002.02.02.00.56.34;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2002.01.20.22.05.15;	author chastain;	state Exp;
branches;
next	1.52;

1.52
date	2002.01.17.22.15.17;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2002.01.05.05.54.29;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2001.11.27.04.15.09;	author tromey;	state Exp;
branches;
next	1.49;

1.49
date	2001.11.20.16.54.39;	author kseitz;	state Exp;
branches;
next	1.48;

1.48
date	2001.11.10.21.34.56;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2001.10.21.19.43.41;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2001.10.16.01.58.07;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2001.09.07.21.33.08;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2001.08.27.22.39.55;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2001.08.14.20.05.48;	author cgf;	state Exp;
branches;
next	1.42;

1.42
date	2001.08.01.18.39.23;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2001.07.17.17.25.14;	author ezannoni;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2001.07.16.15.50.51;	author ezannoni;	state Exp;
branches;
next	1.39;

1.39
date	2001.07.16.14.46.34;	author ezannoni;	state Exp;
branches;
next	1.38;

1.38
date	2001.07.15.20.45.32;	author ezannoni;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.15.18.57.06;	author ezannoni;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.14.18.59.06;	author ciceron;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.17.15.05.32;	author eliz;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2001.05.04.04.15.28;	author kevinb;	state Exp;
branches;
next	1.33;

1.33
date	2001.04.19.23.56.13;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2001.04.19.05.28.12;	author hunt;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.05.15.19.42;	author ezannoni;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.07.07.21.13;	author eliz;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.06.08.21.17;	author kevinb;	state Exp;
branches;
next	1.28;

1.28
date	2001.02.06.04.17.03;	author jtc;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.25.15.19.30;	author fnasser;	state Exp;
branches;
next	1.26;

1.26
date	2000.12.20.21.24.26;	author fnasser;	state Exp;
branches;
next	1.25;

1.25
date	2000.12.15.01.01.50;	author kevinb;	state Exp;
branches;
next	1.24;

1.24
date	2000.12.01.18.01.38;	author fnasser;	state Exp;
branches;
next	1.23;

1.23
date	2000.12.01.00.43.47;	author fnasser;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.27.02.18.44;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.16.14.51.50;	author taylor;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.06.22.44.34;	author fnasser;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.31.05.49.55;	author kevinb;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.23.22.49.28;	author davea;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.01.05.06.03;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.05.10.36.41;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.04.00.41.09;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.28.01.12.32;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.22.05.43.39;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.26.12.41.48;	author phdm;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.12.16.43.27;	author eliz;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.06.15.24.36;	author eliz;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.04.03.05.30.13;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.28.02.25.14;	author dberlin;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.28.02.03.53;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.23.23.43.19;	author fnasser;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.24.00.04.03;	author nsd;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.23.00.25.42;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.03.28.18;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.226.2.1
date	2013.03.27.12.22.24;	author palves;	state Exp;
branches;
next	;

1.208.2.1
date	2012.01.06.04.16.14;	author brobecke;	state Exp;
branches;
next	1.208.2.2;

1.208.2.2
date	2012.01.06.04.54.31;	author brobecke;	state Exp;
branches;
next	;

1.181.2.1
date	2010.07.27.19.13.11;	author jkratoch;	state Exp;
branches;
next	1.181.2.2;

1.181.2.2
date	2010.08.09.19.22.58;	author jkratoch;	state Exp;
branches;
next	;

1.154.4.1
date	2008.11.21.02.31.58;	author shebs;	state Exp;
branches;
next	1.154.4.2;

1.154.4.2
date	2008.11.25.20.45.09;	author palves;	state Exp;
branches;
next	;

1.114.8.1
date	2006.05.12.07.40.19;	author nickrob;	state Exp;
branches;
next	1.114.8.2;

1.114.8.2
date	2006.08.28.07.48.47;	author nickrob;	state Exp;
branches;
next	;

1.113.2.1
date	2006.07.15.09.44.51;	author vprus;	state Exp;
branches;
next	;

1.105.4.1
date	2005.11.14.15.35.16;	author ams;	state Exp;
branches;
next	1.105.4.2;

1.105.4.2
date	2005.11.22.19.26.41;	author brobecke;	state Exp;
branches;
next	;

1.87.6.1
date	2004.03.27.17.37.54;	author drow;	state Exp;
branches;
next	1.87.6.2;

1.87.6.2
date	2004.09.16.17.01.24;	author drow;	state Exp;
branches;
next	;

1.73.4.1
date	2003.09.12.15.37.03;	author jjohnstn;	state Exp;
branches;
next	1.73.4.2;

1.73.4.2
date	2003.09.22.17.50.32;	author jjohnstn;	state Exp;
branches;
next	;

1.71.24.1
date	2003.06.03.20.54.40;	author cagney;	state Exp;
branches;
next	;

1.70.2.1
date	2003.02.03.06.02.45;	author cagney;	state Exp;
branches;
next	1.70.2.2;

1.70.2.2
date	2003.02.03.21.13.29;	author cagney;	state Exp;
branches;
next	1.70.2.3;

1.70.2.3
date	2003.02.04.19.59.02;	author cagney;	state Exp;
branches;
next	;

1.68.2.1
date	2003.12.14.20.27.33;	author drow;	state Exp;
branches;
next	1.68.2.2;

1.68.2.2
date	2004.01.13.16.12.02;	author drow;	state Exp;
branches;
next	1.68.2.3;

1.68.2.3
date	2004.02.09.19.43.48;	author drow;	state Exp;
branches;
next	;

1.67.2.1
date	2002.09.27.20.03.09;	author carlton;	state Exp;
branches;
next	1.67.2.2;

1.67.2.2
date	2002.12.23.19.38.47;	author carlton;	state Exp;
branches;
next	1.67.2.3;

1.67.2.3
date	2003.02.07.19.17.53;	author carlton;	state Exp;
branches;
next	1.67.2.4;

1.67.2.4
date	2003.06.27.21.50.12;	author carlton;	state Exp;
branches;
next	1.67.2.5;

1.67.2.5
date	2003.08.05.17.13.15;	author carlton;	state Exp;
branches;
next	1.67.2.6;

1.67.2.6
date	2003.09.17.21.28.33;	author carlton;	state Exp;
branches;
next	1.67.2.7;

1.67.2.7
date	2003.11.11.23.50.58;	author carlton;	state Exp;
branches;
next	1.67.2.8;

1.67.2.8
date	2004.01.26.19.11.34;	author carlton;	state Exp;
branches;
next	;

1.66.6.1
date	2002.09.14.23.32.00;	author ezannoni;	state Exp;
branches;
next	1.66.6.2;

1.66.6.2
date	2002.09.28.15.10.32;	author cagney;	state Exp;
branches;
next	;

1.62.4.1
date	2002.07.03.18.43.58;	author cagney;	state Exp;
branches;
next	;

1.62.6.1
date	2002.05.28.23.47.01;	author kseitz;	state Exp;
branches;
next	1.62.6.2;

1.62.6.2
date	2002.07.22.21.47.03;	author kseitz;	state Exp;
branches;
next	1.62.6.3;

1.62.6.3
date	2002.08.09.18.34.27;	author kseitz;	state Exp;
branches;
next	1.62.6.4;

1.62.6.4
date	2002.08.13.16.49.06;	author kseitz;	state Exp;
branches;
next	1.62.6.5;

1.62.6.5
date	2002.08.30.22.52.45;	author kseitz;	state Exp;
branches;
next	1.62.6.6;

1.62.6.6
date	2002.10.01.00.46.14;	author kseitz;	state Exp;
branches;
next	1.62.6.7;

1.62.6.7
date	2002.11.04.23.27.31;	author ezannoni;	state Exp;
branches;
next	;

1.41.2.1
date	2001.08.14.20.24.39;	author cgf;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2001.10.21.19.41.19;	author cagney;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2002.01.20.22.09.04;	author chastain;	state Exp;
branches;
next	;

1.35.2.1
date	2001.07.06.19.17.03;	author dberlin;	state Exp;
branches;
next	;

1.9.2.1
date	2000.04.12.16.46.03;	author eliz;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.06;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.38;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.11.13.29.35;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.05.19.19.53.09;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.05.25.18.03.39;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.06.14.18.08.04;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.06.21.13.26.20;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.06.28.16.01.04;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.07.05.17.54.10;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.07.07.20.10.44;	author jsm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.08.02.23.46.12;	author jsm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	99.08.09.21.33.58;	author jsm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.08.16.19.54.11;	author jsm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.08.31.01.06.12;	author jsm;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.09.08.23.59.36;	author shebs;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	99.09.22.03.25.09;	author jsm;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	99.09.28.21.52.36;	author jsm;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	99.10.05.23.08.58;	author jsm;	state Exp;
branches;
next	1.1.1.19;

1.1.1.19
date	99.10.19.02.46.40;	author jsm;	state Exp;
branches;
next	1.1.1.20;

1.1.1.20
date	99.10.26.03.43.16;	author jsm;	state Exp;
branches;
next	1.1.1.21;

1.1.1.21
date	99.11.09.01.23.08;	author jsm;	state Exp;
branches;
next	1.1.1.22;

1.1.1.22
date	99.12.07.03.56.06;	author jsm;	state Exp;
branches;
next	1.1.1.23;

1.1.1.23
date	99.12.14.01.05.38;	author jsm;	state Exp;
branches;
next	1.1.1.24;

1.1.1.24
date	2000.02.01.03.19.07;	author jsm;	state Exp;
branches;
next	1.1.1.25;

1.1.1.25
date	2000.02.02.00.21.07;	author jsm;	state Exp;
branches;
next	1.1.1.26;

1.1.1.26
date	2000.02.03.04.14.30;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.245
log
@Rename "set/show remotebaud" command into "set/show serial baud"

This patch renames the "set/show remotebaud" commands into
"set/show serial baud", and moves its implementation into serial.c.
It also moves the "baud_rate" global from top.c to serial.c, where
the new code is being added (the alternative was to add an include
of target.h).

And to facilitate the transition to the new setting name, this
patch also preserves the old commands, and marks them as deprecated
to alert the users of the change.

gdb/ChangeLog:

        * cli/cli-cmds.c (show_baud_rate): Moved to serial.c as
        serial_baud_show_cmd.
        (_initialize_cli_cmds): Delete the code creating the
        "set/show remotebaud" commands.
        * serial.c (baud_rate): Move here from top.c.
        (serial_baud_show_cmd): Move here from cli/cli-cmds.c.
        (_initialize_serial): Create "set/show serial baud" commands.
        Add "set/show remotebaud" command aliases.
        * top.c (baud_rate): Moved to serial.c.
        * NEWS: Document the new "set/show serial baud" commands,
        replacing "set/show remotebaud".

gdb/doc/ChangeLog:

        * gdb.texinfo: Replace "set remotebaud" and "show remotebaud"
        by "set serial baud" and "show serial baud" (resp) throughout.
@
text
@/* Top level stuff for GDB, the GNU debugger.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdbcmd.h"
#include "cli/cli-cmds.h"
#include "cli/cli-script.h"
#include "cli/cli-setshow.h"
#include "cli/cli-decode.h"
#include "symtab.h"
#include "inferior.h"
#include "exceptions.h"
#include <signal.h>
#include "target.h"
#include "breakpoint.h"
#include "gdbtypes.h"
#include "expression.h"
#include "value.h"
#include "language.h"
#include "terminal.h"		/* For job_control.  */
#include "annotate.h"
#include "completer.h"
#include "top.h"
#include "version.h"
#include "serial.h"
#include "doublest.h"
#include "gdb_assert.h"
#include "main.h"
#include "event-loop.h"
#include "gdbthread.h"
#include "python/python.h"
#include "interps.h"
#include "observer.h"
#include "maint.h"
#include "filenames.h"

/* readline include files.  */
#include "readline/readline.h"
#include "readline/history.h"

/* readline defines this.  */
#undef savestring

#include <sys/types.h>

#include "event-top.h"
#include "gdb_string.h"
#include "gdb_stat.h"
#include <ctype.h>
#include "ui-out.h"
#include "cli-out.h"
#include "tracepoint.h"

extern void initialize_all_files (void);

#define PROMPT(X) the_prompts.prompt_stack[the_prompts.top + X].prompt
#define PREFIX(X) the_prompts.prompt_stack[the_prompts.top + X].prefix
#define SUFFIX(X) the_prompts.prompt_stack[the_prompts.top + X].suffix

/* Default command line prompt.  This is overriden in some configs.  */

#ifndef DEFAULT_PROMPT
#define DEFAULT_PROMPT	"(gdb) "
#endif

/* Initialization file name for gdb.  This is host-dependent.  */

const char gdbinit[] = GDBINIT;

int inhibit_gdbinit = 0;

/* If nonzero, and GDB has been configured to be able to use windows,
   attempt to open them upon startup.  */

int use_windows = 0;

extern char lang_frame_mismatch_warn[];		/* language.c */

/* Flag for whether we want to confirm potentially dangerous
   operations.  Default is yes.  */

int confirm = 1;

static void
show_confirm (struct ui_file *file, int from_tty,
	      struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Whether to confirm potentially "
			    "dangerous operations is %s.\n"),
		    value);
}

/* stdio stream that command input is being read from.  Set to stdin
   normally.  Set by source_command to the file we are sourcing.  Set
   to NULL if we are executing a user-defined command or interacting
   via a GUI.  */

FILE *instream;

/* Flag to indicate whether a user defined command is currently running.  */

int in_user_command;

/* Current working directory.  */

char *current_directory;

/* The directory name is actually stored here (usually).  */
char gdb_dirbuf[1024];

/* Function to call before reading a command, if nonzero.
   The function receives two args: an input stream,
   and a prompt string.  */

void (*window_hook) (FILE *, char *);

/* Buffer used for reading command lines, and the size
   allocated for it so far.  */

char *saved_command_line;
int saved_command_line_size = 100;

/* Nonzero if the current command is modified by "server ".  This
   affects things like recording into the command history, commands
   repeating on RETURN, etc.  This is so a user interface (emacs, GUI,
   whatever) can issue its own commands and also send along commands
   from the user, and have the user not notice that the user interface
   is issuing commands too.  */
int server_command;

/* Timeout limit for response from target.  */

/* The default value has been changed many times over the years.  It 
   was originally 5 seconds.  But that was thought to be a long time 
   to sit and wait, so it was changed to 2 seconds.  That was thought
   to be plenty unless the connection was going through some terminal 
   server or multiplexer or other form of hairy serial connection.

   In mid-1996, remote_timeout was moved from remote.c to top.c and 
   it began being used in other remote-* targets.  It appears that the
   default was changed to 20 seconds at that time, perhaps because the
   Renesas E7000 ICE didn't always respond in a timely manner.

   But if 5 seconds is a long time to sit and wait for retransmissions,
   20 seconds is far worse.  This demonstrates the difficulty of using 
   a single variable for all protocol timeouts.

   As remote.c is used much more than remote-e7000.c, it was changed 
   back to 2 seconds in 1999.  */

int remote_timeout = 2;

/* Non-zero tells remote* modules to output debugging info.  */

int remote_debug = 0;

/* Sbrk location on entry to main.  Used for statistics only.  */
#ifdef HAVE_SBRK
char *lim_at_start;
#endif

/* Hooks for alternate command interfaces.  */

/* Called after most modules have been initialized, but before taking
   users command file.

   If the UI fails to initialize and it wants GDB to continue using
   the default UI, then it should clear this hook before returning.  */

void (*deprecated_init_ui_hook) (char *argv0);

/* This hook is called from within gdb's many mini-event loops which
   could steal control from a real user interface's event loop.  It
   returns non-zero if the user is requesting a detach, zero
   otherwise.  */

int (*deprecated_ui_loop_hook) (int);


/* Called from print_frame_info to list the line we stopped in.  */

void (*deprecated_print_frame_info_listing_hook) (struct symtab * s, 
						  int line,
						  int stopline, 
						  int noerror);
/* Replaces most of query.  */

int (*deprecated_query_hook) (const char *, va_list);

/* Replaces most of warning.  */

void (*deprecated_warning_hook) (const char *, va_list);

/* These three functions support getting lines of text from the user.
   They are used in sequence.  First deprecated_readline_begin_hook is
   called with a text string that might be (for example) a message for
   the user to type in a sequence of commands to be executed at a
   breakpoint.  If this function calls back to a GUI, it might take
   this opportunity to pop up a text interaction window with this
   message.  Next, deprecated_readline_hook is called with a prompt
   that is emitted prior to collecting the user input.  It can be
   called multiple times.  Finally, deprecated_readline_end_hook is
   called to notify the GUI that we are done with the interaction
   window and it can close it.  */

void (*deprecated_readline_begin_hook) (char *, ...);
char *(*deprecated_readline_hook) (char *);
void (*deprecated_readline_end_hook) (void);

/* Called as appropriate to notify the interface that we have attached
   to or detached from an already running process.  */

void (*deprecated_attach_hook) (void);
void (*deprecated_detach_hook) (void);

/* Called during long calculations to allow GUI to repair window
   damage, and to check for stop buttons, etc...  */

void (*deprecated_interactive_hook) (void);

/* Tell the GUI someone changed the register REGNO.  -1 means
   that the caller does not know which register changed or
   that several registers have changed (see value_assign).  */
void (*deprecated_register_changed_hook) (int regno);

/* Called when going to wait for the target.  Usually allows the GUI
   to run while waiting for target events.  */

ptid_t (*deprecated_target_wait_hook) (ptid_t ptid,
				       struct target_waitstatus *status,
				       int options);

/* Used by UI as a wrapper around command execution.  May do various
   things like enabling/disabling buttons, etc...  */

void (*deprecated_call_command_hook) (struct cmd_list_element * c, 
				      char *cmd, int from_tty);

/* Called after a `set' command has finished.  Is only run if the
   `set' command succeeded.  */

void (*deprecated_set_hook) (struct cmd_list_element * c);

/* Called when the current thread changes.  Argument is thread id.  */

void (*deprecated_context_hook) (int id);

/* Handler for SIGHUP.  */

#ifdef SIGHUP
/* NOTE 1999-04-29: This function will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c.  */
/* static */ void
quit_cover (void)
{
  /* Stop asking user for confirmation --- we're exiting.  This
     prevents asking the user dumb questions.  */
  confirm = 0;
  quit_command ((char *) 0, 0);
}
#endif /* defined SIGHUP */

/* Line number we are currently in, in a file which is being sourced.  */
/* NOTE 1999-04-29: This variable will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c.  */
/* static */ int source_line_number;

/* Name of the file we are sourcing.  */
/* NOTE 1999-04-29: This variable will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c.  */
/* static */ const char *source_file_name;

/* Clean up on error during a "source" command (or execution of a
   user-defined command).  */

void
do_restore_instream_cleanup (void *stream)
{
  /* Restore the previous input stream.  */
  instream = stream;
}

/* Read commands from STREAM.  */
void
read_command_file (FILE *stream)
{
  struct cleanup *cleanups;

  cleanups = make_cleanup (do_restore_instream_cleanup, instream);
  instream = stream;
  command_loop ();
  do_cleanups (cleanups);
}

void (*pre_init_ui_hook) (void);

#ifdef __MSDOS__
static void
do_chdir_cleanup (void *old_dir)
{
  chdir (old_dir);
  xfree (old_dir);
}
#endif

struct cleanup *
prepare_execute_command (void)
{
  struct value *mark;
  struct cleanup *cleanup;

  mark = value_mark ();
  cleanup = make_cleanup_value_free_to_mark (mark);

  /* With multiple threads running while the one we're examining is
     stopped, the dcache can get stale without us being able to detect
     it.  For the duration of the command, though, use the dcache to
     help things like backtrace.  */
  if (non_stop)
    target_dcache_invalidate ();

  return cleanup;
}

/* Tell the user if the language has changed (except first time) after
   executing a command.  */

void
check_frame_language_change (void)
{
  static int warned = 0;

  /* First make sure that a new frame has been selected, in case the
     command or the hooks changed the program state.  */
  deprecated_safe_get_selected_frame ();
  if (current_language != expected_language)
    {
      if (language_mode == language_mode_auto && info_verbose)
	{
	  language_info (1);	/* Print what changed.  */
	}
      warned = 0;
    }

  /* Warn the user if the working language does not match the language
     of the current frame.  Only warn the user if we are actually
     running the program, i.e. there is a stack.  */
  /* FIXME: This should be cacheing the frame and only running when
     the frame changes.  */

  if (has_stack_frames ())
    {
      enum language flang;

      flang = get_frame_language ();
      if (!warned
	  && flang != language_unknown
	  && flang != current_language->la_language)
	{
	  printf_filtered ("%s\n", lang_frame_mismatch_warn);
	  warned = 1;
	}
    }
}

/* Execute the line P as a command, in the current user context.
   Pass FROM_TTY as second argument to the defining function.  */

void
execute_command (char *p, int from_tty)
{
  struct cleanup *cleanup_if_error, *cleanup;
  struct cmd_list_element *c;
  char *line;

  cleanup_if_error = make_bpstat_clear_actions_cleanup ();
  cleanup = prepare_execute_command ();

  /* Force cleanup of any alloca areas if using C alloca instead of
     a builtin alloca.  */
  alloca (0);

  /* This can happen when command_line_input hits end of file.  */
  if (p == NULL)
    {
      do_cleanups (cleanup);
      discard_cleanups (cleanup_if_error);
      return;
    }

  target_log_command (p);

  while (*p == ' ' || *p == '\t')
    p++;
  if (*p)
    {
      const char *cmd = p;
      char *arg;
      line = p;

      /* If trace-commands is set then this will print this command.  */
      print_command_trace (p);

      c = lookup_cmd (&cmd, cmdlist, "", 0, 1);
      p = (char *) cmd;

      /* Pass null arg rather than an empty one.  */
      arg = *p ? p : 0;

      /* FIXME: cagney/2002-02-02: The c->type test is pretty dodgy
         while the is_complete_command(cfunc) test is just plain
         bogus.  They should both be replaced by a test of the form
         c->strip_trailing_white_space_p.  */
      /* NOTE: cagney/2002-02-02: The function.cfunc in the below
         can't be replaced with func.  This is because it is the
         cfunc, and not the func, that has the value that the
         is_complete_command hack is testing for.  */
      /* Clear off trailing whitespace, except for set and complete
         command.  */
      if (arg
	  && c->type != set_cmd
	  && !is_complete_command (c))
	{
	  p = arg + strlen (arg) - 1;
	  while (p >= arg && (*p == ' ' || *p == '\t'))
	    p--;
	  *(p + 1) = '\0';
	}

      /* If this command has been pre-hooked, run the hook first.  */
      execute_cmd_pre_hook (c);

      if (c->flags & DEPRECATED_WARN_USER)
	deprecated_cmd_warning (line);

      /* c->user_commands would be NULL in the case of a python command.  */
      if (c->class == class_user && c->user_commands)
	execute_user_command (c, arg);
      else if (c->type == set_cmd)
	do_set_command (arg, from_tty, c);
      else if (c->type == show_cmd)
	do_show_command (arg, from_tty, c);
      else if (!cmd_func_p (c))
	error (_("That is not a command, just a help topic."));
      else if (deprecated_call_command_hook)
	deprecated_call_command_hook (c, arg, from_tty);
      else
	cmd_func (c, arg, from_tty);

      /* If the interpreter is in sync mode (we're running a user
	 command's list, running command hooks or similars), and we
	 just ran a synchronous command that started the target, wait
	 for that command to end.  */
      if (!interpreter_async && sync_execution)
	{
	  while (gdb_do_one_event () >= 0)
	    if (!sync_execution)
	      break;
	}

      /* If this command has been post-hooked, run the hook last.  */
      execute_cmd_post_hook (c);

    }

  check_frame_language_change ();

  do_cleanups (cleanup);
  discard_cleanups (cleanup_if_error);
}

/* Run execute_command for P and FROM_TTY.  Capture its output into the
   returned string, do not display it to the screen.  BATCH_FLAG will be
   temporarily set to true.  */

char *
execute_command_to_string (char *p, int from_tty)
{
  struct ui_file *str_file;
  struct cleanup *cleanup;
  char *retval;

  /* GDB_STDOUT should be better already restored during these
     restoration callbacks.  */
  cleanup = set_batch_flag_and_make_cleanup_restore_page_info ();

  make_cleanup_restore_integer (&interpreter_async);
  interpreter_async = 0;

  str_file = mem_fileopen ();

  make_cleanup_ui_file_delete (str_file);
  make_cleanup_restore_ui_file (&gdb_stdout);
  make_cleanup_restore_ui_file (&gdb_stderr);
  make_cleanup_restore_ui_file (&gdb_stdlog);
  make_cleanup_restore_ui_file (&gdb_stdtarg);
  make_cleanup_restore_ui_file (&gdb_stdtargerr);

  if (ui_out_redirect (current_uiout, str_file) < 0)
    warning (_("Current output protocol does not support redirection"));
  else
    make_cleanup_ui_out_redirect_pop (current_uiout);

  gdb_stdout = str_file;
  gdb_stderr = str_file;
  gdb_stdlog = str_file;
  gdb_stdtarg = str_file;
  gdb_stdtargerr = str_file;

  execute_command (p, from_tty);

  retval = ui_file_xstrdup (str_file, NULL);

  do_cleanups (cleanup);

  return retval;
}

/* Read commands from `instream' and execute them
   until end of file or error reading instream.  */

void
command_loop (void)
{
  struct cleanup *old_chain;
  char *command;
  int stdin_is_tty = ISATTY (stdin);

  while (instream && !feof (instream))
    {
      if (window_hook && instream == stdin)
	(*window_hook) (instream, get_prompt ());

      clear_quit_flag ();
      if (instream == stdin && stdin_is_tty)
	reinitialize_more_filter ();
      old_chain = make_cleanup (null_cleanup, 0);

      /* Get a command-line.  This calls the readline package.  */
      command = command_line_input (instream == stdin ?
				    get_prompt () : (char *) NULL,
				    instream == stdin, "prompt");
      if (command == 0)
	{
	  do_cleanups (old_chain);
	  return;
	}

      make_command_stats_cleanup (1);

      execute_command (command, instream == stdin);

      /* Do any commands attached to breakpoint we are stopped at.  */
      bpstat_do_actions ();

      do_cleanups (old_chain);
    }
}

/* When nonzero, cause dont_repeat to do nothing.  This should only be
   set via prevent_dont_repeat.  */

static int suppress_dont_repeat = 0;

/* Commands call this if they do not want to be repeated by null lines.  */

void
dont_repeat (void)
{
  if (suppress_dont_repeat || server_command)
    return;

  /* If we aren't reading from standard input, we are saving the last
     thing read from stdin in line and don't want to delete it.  Null
     lines won't repeat here in any case.  */
  if (instream == stdin)
    *saved_command_line = 0;
}

/* Prevent dont_repeat from working, and return a cleanup that
   restores the previous state.  */

struct cleanup *
prevent_dont_repeat (void)
{
  struct cleanup *result = make_cleanup_restore_integer (&suppress_dont_repeat);

  suppress_dont_repeat = 1;
  return result;
}


/* Read a line from the stream "instream" without command line editing.

   It prints PROMPT_ARG once at the start.
   Action is compatible with "readline", e.g. space for the result is
   malloc'd and should be freed by the caller.

   A NULL return means end of file.  */
char *
gdb_readline (char *prompt_arg)
{
  int c;
  char *result;
  int input_index = 0;
  int result_size = 80;

  if (prompt_arg)
    {
      /* Don't use a _filtered function here.  It causes the assumed
         character position to be off, since the newline we read from
         the user is not accounted for.  */
      fputs_unfiltered (prompt_arg, gdb_stdout);
      gdb_flush (gdb_stdout);
    }

  result = (char *) xmalloc (result_size);

  while (1)
    {
      /* Read from stdin if we are executing a user defined command.
         This is the right thing for prompt_for_continue, at least.  */
      c = fgetc (instream ? instream : stdin);

      if (c == EOF)
	{
	  if (input_index > 0)
	    /* The last line does not end with a newline.  Return it, and
	       if we are called again fgetc will still return EOF and
	       we'll return NULL then.  */
	    break;
	  xfree (result);
	  return NULL;
	}

      if (c == '\n')
	{
	  if (input_index > 0 && result[input_index - 1] == '\r')
	    input_index--;
	  break;
	}

      result[input_index++] = c;
      while (input_index >= result_size)
	{
	  result_size *= 2;
	  result = (char *) xrealloc (result, result_size);
	}
    }

  result[input_index++] = '\0';
  return result;
}

/* Variables which control command line editing and history
   substitution.  These variables are given default values at the end
   of this file.  */
static int command_editing_p;

/* NOTE 1999-04-29: This variable will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c.  */

/* static */ int history_expansion_p;

static int write_history_p;
static void
show_write_history_p (struct ui_file *file, int from_tty,
		      struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Saving of the history record on exit is %s.\n"),
		    value);
}

/* The variable associated with the "set/show history size"
   command.  */
static unsigned int history_size_setshow_var;

static void
show_history_size (struct ui_file *file, int from_tty,
		   struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("The size of the command history is %s.\n"),
		    value);
}

static char *history_filename;
static void
show_history_filename (struct ui_file *file, int from_tty,
		       struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("The filename in which to record "
			    "the command history is \"%s\".\n"),
		    value);
}

/* This is like readline(), but it has some gdb-specific behavior.
   gdb may want readline in both the synchronous and async modes during
   a single gdb invocation.  At the ordinary top-level prompt we might
   be using the async readline.  That means we can't use
   rl_pre_input_hook, since it doesn't work properly in async mode.
   However, for a secondary prompt (" >", such as occurs during a
   `define'), gdb wants a synchronous response.

   We used to call readline() directly, running it in synchronous
   mode.  But mixing modes this way is not supported, and as of
   readline 5.x it no longer works; the arrow keys come unbound during
   the synchronous call.  So we make a nested call into the event
   loop.  That's what gdb_readline_wrapper is for.  */

/* A flag set as soon as gdb_readline_wrapper_line is called; we can't
   rely on gdb_readline_wrapper_result, which might still be NULL if
   the user types Control-D for EOF.  */
static int gdb_readline_wrapper_done;

/* The result of the current call to gdb_readline_wrapper, once a newline
   is seen.  */
static char *gdb_readline_wrapper_result;

/* Any intercepted hook.  Operate-and-get-next sets this, expecting it
   to be called after the newline is processed (which will redisplay
   the prompt).  But in gdb_readline_wrapper we will not get a new
   prompt until the next call, or until we return to the event loop.
   So we disable this hook around the newline and restore it before we
   return.  */
static void (*saved_after_char_processing_hook) (void);

/* This function is called when readline has seen a complete line of
   text.  */

static void
gdb_readline_wrapper_line (char *line)
{
  gdb_assert (!gdb_readline_wrapper_done);
  gdb_readline_wrapper_result = line;
  gdb_readline_wrapper_done = 1;

  /* Prevent operate-and-get-next from acting too early.  */
  saved_after_char_processing_hook = after_char_processing_hook;
  after_char_processing_hook = NULL;

  /* Prevent parts of the prompt from being redisplayed if annotations
     are enabled, and readline's state getting out of sync.  */
  if (async_command_editing_p)
    rl_callback_handler_remove ();
}

struct gdb_readline_wrapper_cleanup
  {
    void (*handler_orig) (char *);
    int already_prompted_orig;
  };

static void
gdb_readline_wrapper_cleanup (void *arg)
{
  struct gdb_readline_wrapper_cleanup *cleanup = arg;

  rl_already_prompted = cleanup->already_prompted_orig;

  gdb_assert (input_handler == gdb_readline_wrapper_line);
  input_handler = cleanup->handler_orig;
  gdb_readline_wrapper_result = NULL;
  gdb_readline_wrapper_done = 0;

  after_char_processing_hook = saved_after_char_processing_hook;
  saved_after_char_processing_hook = NULL;

  xfree (cleanup);
}

char *
gdb_readline_wrapper (char *prompt)
{
  struct cleanup *back_to;
  struct gdb_readline_wrapper_cleanup *cleanup;
  char *retval;

  cleanup = xmalloc (sizeof (*cleanup));
  cleanup->handler_orig = input_handler;
  input_handler = gdb_readline_wrapper_line;

  cleanup->already_prompted_orig = rl_already_prompted;

  back_to = make_cleanup (gdb_readline_wrapper_cleanup, cleanup);

  /* Display our prompt and prevent double prompt display.  */
  display_gdb_prompt (prompt);
  rl_already_prompted = 1;

  if (after_char_processing_hook)
    (*after_char_processing_hook) ();
  gdb_assert (after_char_processing_hook == NULL);

  while (gdb_do_one_event () >= 0)
    if (gdb_readline_wrapper_done)
      break;

  retval = gdb_readline_wrapper_result;
  do_cleanups (back_to);
  return retval;
}


/* The current saved history number from operate-and-get-next.
   This is -1 if not valid.  */
static int operate_saved_history = -1;

/* This is put on the appropriate hook and helps operate-and-get-next
   do its work.  */
static void
gdb_rl_operate_and_get_next_completion (void)
{
  int delta = where_history () - operate_saved_history;

  /* The `key' argument to rl_get_previous_history is ignored.  */
  rl_get_previous_history (delta, 0);
  operate_saved_history = -1;

  /* readline doesn't automatically update the display for us.  */
  rl_redisplay ();

  after_char_processing_hook = NULL;
  rl_pre_input_hook = NULL;
}

/* This is a gdb-local readline command handler.  It accepts the
   current command line (like RET does) and, if this command was taken
   from the history, arranges for the next command in the history to
   appear on the command line when the prompt returns.
   We ignore the arguments.  */
static int
gdb_rl_operate_and_get_next (int count, int key)
{
  int where;

  /* Use the async hook.  */
  after_char_processing_hook = gdb_rl_operate_and_get_next_completion;

  /* Find the current line, and find the next line to use.  */
  where = where_history();

  if ((history_is_stifled () && (history_length >= history_max_entries))
      || (where >= history_length - 1))
    operate_saved_history = where;
  else
    operate_saved_history = where + 1;

  return rl_newline (1, key);
}

/* Read one line from the command input stream `instream'
   into the local static buffer `linebuffer' (whose current length
   is `linelength').
   The buffer is made bigger as necessary.
   Returns the address of the start of the line.

   NULL is returned for end of file.

   *If* the instream == stdin & stdin is a terminal, the line read
   is copied into the file line saver (global var char *line,
   length linesize) so that it can be duplicated.

   This routine either uses fancy command line editing or
   simple input as the user has requested.  */

char *
command_line_input (char *prompt_arg, int repeat, char *annotation_suffix)
{
  static char *linebuffer = 0;
  static unsigned linelength = 0;
  char *p;
  char *p1;
  char *rl;
  char *local_prompt = prompt_arg;
  char *nline;
  char got_eof = 0;

  /* The annotation suffix must be non-NULL.  */
  if (annotation_suffix == NULL)
    annotation_suffix = "";

  if (annotation_level > 1 && instream == stdin)
    {
      local_prompt = alloca ((prompt_arg == NULL ? 0 : strlen (prompt_arg))
			     + strlen (annotation_suffix) + 40);
      if (prompt_arg == NULL)
	local_prompt[0] = '\0';
      else
	strcpy (local_prompt, prompt_arg);
      strcat (local_prompt, "\n\032\032");
      strcat (local_prompt, annotation_suffix);
      strcat (local_prompt, "\n");
    }

  if (linebuffer == 0)
    {
      linelength = 80;
      linebuffer = (char *) xmalloc (linelength);
    }

  p = linebuffer;

  /* Control-C quits instantly if typed while in this loop
     since it should not wait until the user types a newline.  */
  immediate_quit++;
  QUIT;
#ifdef STOP_SIGNAL
  if (job_control)
    signal (STOP_SIGNAL, handle_stop_sig);
#endif

  while (1)
    {
      /* Make sure that all output has been output.  Some machines may
         let you get away with leaving out some of the gdb_flush, but
         not all.  */
      wrap_here ("");
      gdb_flush (gdb_stdout);
      gdb_flush (gdb_stderr);

      if (source_file_name != NULL)
	++source_line_number;

      if (annotation_level > 1 && instream == stdin)
	{
	  puts_unfiltered ("\n\032\032pre-");
	  puts_unfiltered (annotation_suffix);
	  puts_unfiltered ("\n");
	}

      /* Don't use fancy stuff if not talking to stdin.  */
      if (deprecated_readline_hook && input_from_terminal_p ())
	{
	  rl = (*deprecated_readline_hook) (local_prompt);
	}
      else if (command_editing_p && input_from_terminal_p ())
	{
	  rl = gdb_readline_wrapper (local_prompt);
	}
      else
	{
	  rl = gdb_readline (local_prompt);
	}

      if (annotation_level > 1 && instream == stdin)
	{
	  puts_unfiltered ("\n\032\032post-");
	  puts_unfiltered (annotation_suffix);
	  puts_unfiltered ("\n");
	}

      if (!rl || rl == (char *) EOF)
	{
	  got_eof = 1;
	  break;
	}
      if (strlen (rl) + 1 + (p - linebuffer) > linelength)
	{
	  linelength = strlen (rl) + 1 + (p - linebuffer);
	  nline = (char *) xrealloc (linebuffer, linelength);
	  p += nline - linebuffer;
	  linebuffer = nline;
	}
      p1 = rl;
      /* Copy line.  Don't copy null at end.  (Leaves line alone
         if this was just a newline).  */
      while (*p1)
	*p++ = *p1++;

      xfree (rl);		/* Allocated in readline.  */

      if (p == linebuffer || *(p - 1) != '\\')
	break;

      p--;			/* Put on top of '\'.  */
      local_prompt = (char *) 0;
    }

#ifdef STOP_SIGNAL
  if (job_control)
    signal (STOP_SIGNAL, SIG_DFL);
#endif
  immediate_quit--;

  if (got_eof)
    return NULL;

#define SERVER_COMMAND_LENGTH 7
  server_command =
    (p - linebuffer > SERVER_COMMAND_LENGTH)
    && strncmp (linebuffer, "server ", SERVER_COMMAND_LENGTH) == 0;
  if (server_command)
    {
      /* Note that we don't set `line'.  Between this and the check in
         dont_repeat, this insures that repeating will still do the
         right thing.  */
      *p = '\0';
      return linebuffer + SERVER_COMMAND_LENGTH;
    }

  /* Do history expansion if that is wished.  */
  if (history_expansion_p && instream == stdin
      && ISATTY (instream))
    {
      char *history_value;
      int expanded;

      *p = '\0';		/* Insert null now.  */
      expanded = history_expand (linebuffer, &history_value);
      if (expanded)
	{
	  /* Print the changes.  */
	  printf_unfiltered ("%s\n", history_value);

	  /* If there was an error, call this function again.  */
	  if (expanded < 0)
	    {
	      xfree (history_value);
	      return command_line_input (prompt_arg, repeat,
					 annotation_suffix);
	    }
	  if (strlen (history_value) > linelength)
	    {
	      linelength = strlen (history_value) + 1;
	      linebuffer = (char *) xrealloc (linebuffer, linelength);
	    }
	  strcpy (linebuffer, history_value);
	  p = linebuffer + strlen (linebuffer);
	}
      xfree (history_value);
    }

  /* If we just got an empty line, and that is supposed to repeat the
     previous command, return the value in the global buffer.  */
  if (repeat && p == linebuffer)
    return saved_command_line;
  for (p1 = linebuffer; *p1 == ' ' || *p1 == '\t'; p1++);
  if (repeat && !*p1)
    return saved_command_line;

  *p = 0;

  /* Add line to history if appropriate.  */
  if (instream == stdin
      && ISATTY (stdin) && *linebuffer)
    add_history (linebuffer);

  /* Note: lines consisting solely of comments are added to the command
     history.  This is useful when you type a command, and then
     realize you don't want to execute it quite yet.  You can comment
     out the command and then later fetch it from the value history
     and remove the '#'.  The kill ring is probably better, but some
     people are in the habit of commenting things out.  */
  if (*p1 == '#')
    *p1 = '\0';			/* Found a comment.  */

  /* Save into global buffer if appropriate.  */
  if (repeat)
    {
      if (linelength > saved_command_line_size)
	{
	  saved_command_line = xrealloc (saved_command_line, linelength);
	  saved_command_line_size = linelength;
	}
      strcpy (saved_command_line, linebuffer);
      return saved_command_line;
    }

  return linebuffer;
}

/* Print the GDB banner.  */
void
print_gdb_version (struct ui_file *stream)
{
  /* From GNU coding standards, first line is meant to be easy for a
     program to parse, and is just canonical program name and version
     number, which starts after last space.  */

  fprintf_filtered (stream, "GNU gdb %s%s\n", PKGVERSION, version);

  /* Second line is a copyright notice.  */

  fprintf_filtered (stream,
		    "Copyright (C) 2013 Free Software Foundation, Inc.\n");

  /* Following the copyright is a brief statement that the program is
     free software, that users are free to copy and change it on
     certain conditions, that it is covered by the GNU GPL, and that
     there is no warranty.  */

  fprintf_filtered (stream, "\
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\
\nThis is free software: you are free to change and redistribute it.\n\
There is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\n\
and \"show warranty\" for details.\n");

  /* After the required info we print the configuration information.  */

  fprintf_filtered (stream, "This GDB was configured as \"");
  if (strcmp (host_name, target_name) != 0)
    {
      fprintf_filtered (stream, "--host=%s --target=%s",
			host_name, target_name);
    }
  else
    {
      fprintf_filtered (stream, "%s", host_name);
    }
  fprintf_filtered (stream, "\".\n\
Type \"show configuration\" for configuration details.");

  if (REPORT_BUGS_TO[0])
    {
      fprintf_filtered (stream,
			_("\nFor bug reporting instructions, please see:\n"));
      fprintf_filtered (stream, "%s.\n", REPORT_BUGS_TO);
    }
  fprintf_filtered (stream,
		    _("Find the GDB manual and other documentation \
resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\n"));
  fprintf_filtered (stream, _("For help, type \"help\".\n"));
  fprintf_filtered (stream, _("Type \"apropos word\" to search for \
commands related to \"word\"."));
}

/* Print the details of GDB build-time configuration.  */
void
print_gdb_configuration (struct ui_file *stream)
{
  fprintf_filtered (stream, _("\
This GDB was configured as follows:\n\
   configure --host=%s --target=%s\n\
"), host_name, target_name);
  fprintf_filtered (stream, _("\
             --with-auto-load-dir=%s\n\
             --with-auto-load-safe-path=%s\n\
"), AUTO_LOAD_DIR, AUTO_LOAD_SAFE_PATH);
#if HAVE_LIBEXPAT
  fprintf_filtered (stream, _("\
             --with-expat\n\
"));
#else
  fprintf_filtered (stream, _("\
             --without-expat\n\
"));
#endif
  if (GDB_DATADIR[0])
    fprintf_filtered (stream, _("\
             --with-gdb-datadir=%s%s\n\
"), GDB_DATADIR, GDB_DATADIR_RELOCATABLE ? " (relocatable)" : "");
#ifdef ICONV_BIN
  fprintf_filtered (stream, _("\
             --with-iconv-bin=%s%s\n\
"), ICONV_BIN, ICONV_BIN_RELOCATABLE ? " (relocatable)" : "");
#endif
  if (JIT_READER_DIR[0])
    fprintf_filtered (stream, _("\
             --with-jit-reader-dir=%s%s\n\
"), JIT_READER_DIR, JIT_READER_DIR_RELOCATABLE ? " (relocatable)" : "");
#if HAVE_LIBUNWIND_IA64_H
  fprintf_filtered (stream, _("\
             --with-libunwind-ia64\n\
"));
#else
  fprintf_filtered (stream, _("\
             --without-libunwind-ia64\n\
"));
#endif
#if HAVE_LIBLZMA
  fprintf_filtered (stream, _("\
             --with-lzma\n\
"));
#else
  fprintf_filtered (stream, _("\
             --without-lzma\n\
"));
#endif
#ifdef WITH_PYTHON_PATH
  fprintf_filtered (stream, _("\
             --with-python=%s%s\n\
"), WITH_PYTHON_PATH, PYTHON_PATH_RELOCATABLE ? " (relocatable)" : "");
#endif
#ifdef RELOC_SRCDIR
  fprintf_filtered (stream, _("\
             --with-relocated-sources=%s\n\
"), RELOC_SRCDIR);
#endif
  if (DEBUGDIR[0])
    fprintf_filtered (stream, _("\
             --with-separate-debug-dir=%s%s\n\
"), DEBUGDIR, DEBUGDIR_RELOCATABLE ? " (relocatable)" : "");
  if (TARGET_SYSTEM_ROOT[0])
    fprintf_filtered (stream, _("\
             --with-sysroot=%s%s\n\
"), TARGET_SYSTEM_ROOT, TARGET_SYSTEM_ROOT_RELOCATABLE ? " (relocatable)" : "");
  if (SYSTEM_GDBINIT[0])
    fprintf_filtered (stream, _("\
             --with-system-gdbinit=%s%s\n\
"), SYSTEM_GDBINIT, SYSTEM_GDBINIT_RELOCATABLE ? " (relocatable)" : "");
#if HAVE_ZLIB_H
  fprintf_filtered (stream, _("\
             --with-zlib\n\
"));
#else
  fprintf_filtered (stream, _("\
             --without-zlib\n\
"));
#endif
#if HAVE_LIBBABELTRACE
    fprintf_filtered (stream, _("\
             --with-babeltrace\n\
"));
#else
    fprintf_filtered (stream, _("\
             --without-babeltrace\n\
"));
#endif
    /* We assume "relocatable" will be printed at least once, thus we always
       print this text.  It's a reasonably safe assumption for now.  */
    fprintf_filtered (stream, _("\n\
(\"Relocatable\" means the directory can be moved with the GDB installation\n\
tree, and GDB will still find it.)\n\
"));
}


/* The current top level prompt, settable with "set prompt", and/or
   with the python `gdb.prompt_hook' hook.  */
static char *top_prompt;

/* Access method for the GDB prompt string.  */

char *
get_prompt (void)
{
  return top_prompt;
}

/* Set method for the GDB prompt string.  */

void
set_prompt (const char *s)
{
  char *p = xstrdup (s);

  xfree (top_prompt);
  top_prompt = p;
}


struct qt_args
{
  char *args;
  int from_tty;
};

/* Callback for iterate_over_inferiors.  Kills or detaches the given
   inferior, depending on how we originally gained control of it.  */

static int
kill_or_detach (struct inferior *inf, void *args)
{
  struct qt_args *qt = args;
  struct thread_info *thread;

  if (inf->pid == 0)
    return 0;

  thread = any_thread_of_process (inf->pid);
  if (thread != NULL)
    {
      switch_to_thread (thread->ptid);

      /* Leave core files alone.  */
      if (target_has_execution)
	{
	  if (inf->attach_flag)
	    target_detach (qt->args, qt->from_tty);
	  else
	    target_kill ();
	}
    }

  return 0;
}

/* Callback for iterate_over_inferiors.  Prints info about what GDB
   will do to each inferior on a "quit".  ARG points to a struct
   ui_out where output is to be collected.  */

static int
print_inferior_quit_action (struct inferior *inf, void *arg)
{
  struct ui_file *stb = arg;

  if (inf->pid == 0)
    return 0;

  if (inf->attach_flag)
    fprintf_filtered (stb,
		      _("\tInferior %d [%s] will be detached.\n"), inf->num,
		      target_pid_to_str (pid_to_ptid (inf->pid)));
  else
    fprintf_filtered (stb,
		      _("\tInferior %d [%s] will be killed.\n"), inf->num,
		      target_pid_to_str (pid_to_ptid (inf->pid)));

  return 0;
}

/* If necessary, make the user confirm that we should quit.  Return
   non-zero if we should quit, zero if we shouldn't.  */

int
quit_confirm (void)
{
  struct ui_file *stb;
  struct cleanup *old_chain;
  char *str;
  int qr;

  /* Don't even ask if we're only debugging a core file inferior.  */
  if (!have_live_inferiors ())
    return 1;

  /* Build the query string as a single string.  */
  stb = mem_fileopen ();
  old_chain = make_cleanup_ui_file_delete (stb);

  fprintf_filtered (stb, _("A debugging session is active.\n\n"));
  iterate_over_inferiors (print_inferior_quit_action, stb);
  fprintf_filtered (stb, _("\nQuit anyway? "));

  str = ui_file_xstrdup (stb, NULL);
  make_cleanup (xfree, str);

  qr = query ("%s", str);
  do_cleanups (old_chain);
  return qr;
}

/* Quit without asking for confirmation.  */

void
quit_force (char *args, int from_tty)
{
  int exit_code = 0;
  struct qt_args qt;
  volatile struct gdb_exception ex;

  /* An optional expression may be used to cause gdb to terminate with the 
     value of that expression.  */
  if (args)
    {
      struct value *val = parse_and_eval (args);

      exit_code = (int) value_as_long (val);
    }
  else if (return_child_result)
    exit_code = return_child_result_value;

  qt.args = args;
  qt.from_tty = from_tty;

  /* Wrappers to make the code below a bit more readable.  */
#define DO_TRY \
  TRY_CATCH (ex, RETURN_MASK_ALL)

#define DO_PRINT_EX \
  if (ex.reason < 0) \
    exception_print (gdb_stderr, ex)

  /* We want to handle any quit errors and exit regardless.  */

  /* Get out of tfind mode, and kill or detach all inferiors.  */
  DO_TRY
    {
      disconnect_tracing ();
      iterate_over_inferiors (kill_or_detach, &qt);
    }
  DO_PRINT_EX;

  /* Give all pushed targets a chance to do minimal cleanup, and pop
     them all out.  */
  DO_TRY
    {
      pop_all_targets ();
    }
  DO_PRINT_EX;

  /* Save the history information if it is appropriate to do so.  */
  DO_TRY
    {
      if (write_history_p && history_filename
	  && input_from_terminal_p ())
	write_history (history_filename);
    }
  DO_PRINT_EX;

  /* Do any final cleanups before exiting.  */
  DO_TRY
    {
      do_final_cleanups (all_cleanups ());
    }
  DO_PRINT_EX;

  exit (exit_code);
}

/* Returns whether GDB is running on a terminal and input is
   currently coming from that terminal.  */

int
input_from_terminal_p (void)
{
  if (batch_flag)
    return 0;

  if (gdb_has_a_terminal () && instream == stdin)
    return 1;

  /* If INSTREAM is unset, and we are not in a user command, we
     must be in Insight.  That's like having a terminal, for our
     purposes.  */
  if (instream == NULL && !in_user_command)
    return 1;

  return 0;
}

static void
dont_repeat_command (char *ignored, int from_tty)
{
  /* Can't call dont_repeat here because we're not necessarily reading
     from stdin.  */
  *saved_command_line = 0;
}

/* Functions to manipulate command line editing control variables.  */

/* Number of commands to print in each call to show_commands.  */
#define Hist_print 10
void
show_commands (char *args, int from_tty)
{
  /* Index for history commands.  Relative to history_base.  */
  int offset;

  /* Number of the history entry which we are planning to display next.
     Relative to history_base.  */
  static int num = 0;

  /* Print out some of the commands from the command history.  */

  if (args)
    {
      if (args[0] == '+' && args[1] == '\0')
	/* "info editing +" should print from the stored position.  */
	;
      else
	/* "info editing <exp>" should print around command number <exp>.  */
	num = (parse_and_eval_long (args) - history_base) - Hist_print / 2;
    }
  /* "show commands" means print the last Hist_print commands.  */
  else
    {
      num = history_length - Hist_print;
    }

  if (num < 0)
    num = 0;

  /* If there are at least Hist_print commands, we want to display the last
     Hist_print rather than, say, the last 6.  */
  if (history_length - num < Hist_print)
    {
      num = history_length - Hist_print;
      if (num < 0)
	num = 0;
    }

  for (offset = num;
       offset < num + Hist_print && offset < history_length;
       offset++)
    {
      printf_filtered ("%5d  %s\n", history_base + offset,
		       (history_get (history_base + offset))->line);
    }

  /* The next command we want to display is the next one that we haven't
     displayed yet.  */
  num += Hist_print;

  /* If the user repeats this command with return, it should do what
     "show commands +" does.  This is unnecessary if arg is null,
     because "show commands +" is not useful after "show commands".  */
  if (from_tty && args)
    {
      args[0] = '+';
      args[1] = '\0';
    }
}

/* Called by do_setshow_command.  */
static void
set_history_size_command (char *args, int from_tty, struct cmd_list_element *c)
{
  /* Readline's history interface works with 'int', so it can only
     handle history sizes up to INT_MAX.  The command itself is
     uinteger, so UINT_MAX means "unlimited", but we only get that if
     the user does "set history size 0" -- "set history size <UINT_MAX>"
     throws out-of-range.  */
  if (history_size_setshow_var > INT_MAX
      && history_size_setshow_var != UINT_MAX)
    {
      unsigned int new_value = history_size_setshow_var;

      /* Restore previous value before throwing.  */
      if (history_is_stifled ())
	history_size_setshow_var = history_max_entries;
      else
	history_size_setshow_var = UINT_MAX;

      error (_("integer %u out of range"), new_value);
    }

  /* Commit the new value to readline's history.  */
  if (history_size_setshow_var == UINT_MAX)
    unstifle_history ();
  else
    stifle_history (history_size_setshow_var);
}

void
set_history (char *args, int from_tty)
{
  printf_unfiltered (_("\"set history\" must be followed "
		       "by the name of a history subcommand.\n"));
  help_list (sethistlist, "set history ", -1, gdb_stdout);
}

void
show_history (char *args, int from_tty)
{
  cmd_show_list (showhistlist, from_tty, "");
}

int info_verbose = 0;		/* Default verbose msgs off.  */

/* Called by do_setshow_command.  An elaborate joke.  */
void
set_verbose (char *args, int from_tty, struct cmd_list_element *c)
{
  const char *cmdname = "verbose";
  struct cmd_list_element *showcmd;

  showcmd = lookup_cmd_1 (&cmdname, showlist, NULL, 1);
  gdb_assert (showcmd != NULL && showcmd != CMD_LIST_AMBIGUOUS);

  if (info_verbose)
    {
      c->doc = "Set verbose printing of informational messages.";
      showcmd->doc = "Show verbose printing of informational messages.";
    }
  else
    {
      c->doc = "Set verbosity.";
      showcmd->doc = "Show verbosity.";
    }
}

/* Init the history buffer.  Note that we are called after the init file(s)
   have been read so that the user can change the history file via his
   .gdbinit file (for instance).  The GDBHISTFILE environment variable
   overrides all of this.  */

void
init_history (void)
{
  char *tmpenv;

  tmpenv = getenv ("HISTSIZE");
  if (tmpenv)
    {
      int var;

      var = atoi (tmpenv);
      if (var < 0)
	{
	  /* Prefer ending up with no history rather than overflowing
	     readline's history interface, which uses signed 'int'
	     everywhere.  */
	  var = 0;
	}

      history_size_setshow_var = var;
    }
  /* If the init file hasn't set a size yet, pick the default.  */
  else if (history_size_setshow_var == 0)
    history_size_setshow_var = 256;

  /* Note that unlike "set history size 0", "HISTSIZE=0" really sets
     the history size to 0...  */
  stifle_history (history_size_setshow_var);

  tmpenv = getenv ("GDBHISTFILE");
  if (tmpenv)
    history_filename = xstrdup (tmpenv);
  else if (!history_filename)
    {
      /* We include the current directory so that if the user changes
         directories the file written will be the same as the one
         that was read.  */
#ifdef __MSDOS__
      /* No leading dots in file names are allowed on MSDOS.  */
      history_filename = concat (current_directory, "/_gdb_history",
				 (char *)NULL);
#else
      history_filename = concat (current_directory, "/.gdb_history",
				 (char *)NULL);
#endif
    }
  read_history (history_filename);
}

static void
show_prompt (struct ui_file *file, int from_tty,
	     struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Gdb's prompt is \"%s\".\n"), value);
}

static void
show_async_command_editing_p (struct ui_file *file, int from_tty,
			      struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Editing of command lines as "
			    "they are typed is %s.\n"),
		    value);
}

static void
show_annotation_level (struct ui_file *file, int from_tty,
		       struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Annotation_level is %s.\n"), value);
}

static void
show_exec_done_display_p (struct ui_file *file, int from_tty,
			  struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Notification of completion for "
			    "asynchronous execution commands is %s.\n"),
		    value);
}

/* "set" command for the gdb_datadir configuration variable.  */

static void
set_gdb_datadir (char *args, int from_tty, struct cmd_list_element *c)
{
  observer_notify_gdb_datadir_changed ();
}

static void
set_history_filename (char *args, int from_tty, struct cmd_list_element *c)
{
  /* We include the current directory so that if the user changes
     directories the file written will be the same as the one
     that was read.  */
  if (!IS_ABSOLUTE_PATH (history_filename))
    history_filename = reconcat (history_filename, current_directory, "/", 
				 history_filename, (char *) NULL);
}

static void
init_main (void)
{
  /* Initialize the prompt to a simple "(gdb) " prompt or to whatever
     the DEFAULT_PROMPT is.  */
  set_prompt (DEFAULT_PROMPT);

  /* Set things up for annotation_level > 1, if the user ever decides
     to use it.  */
  async_annotation_suffix = "prompt";

  /* Set the important stuff up for command editing.  */
  command_editing_p = 1;
  history_expansion_p = 0;
  write_history_p = 0;

  /* Setup important stuff for command line editing.  */
  rl_completion_word_break_hook = gdb_completion_word_break_characters;
  rl_completion_entry_function = readline_line_completion_function;
  rl_completer_word_break_characters = default_word_break_characters ();
  rl_completer_quote_characters = get_gdb_completer_quote_characters ();
  rl_readline_name = "gdb";
  rl_terminal_name = getenv ("TERM");

  /* The name for this defun comes from Bash, where it originated.
     15 is Control-o, the same binding this function has in Bash.  */
  rl_add_defun ("operate-and-get-next", gdb_rl_operate_and_get_next, 15);

  add_setshow_string_cmd ("prompt", class_support,
			  &top_prompt,
			  _("Set gdb's prompt"),
			  _("Show gdb's prompt"),
			  NULL, NULL,
			  show_prompt,
			  &setlist, &showlist);

  add_com ("dont-repeat", class_support, dont_repeat_command, _("\
Don't repeat this command.\nPrimarily \
used inside of user-defined commands that should not be repeated when\n\
hitting return."));

  add_setshow_boolean_cmd ("editing", class_support,
			   &async_command_editing_p, _("\
Set editing of command lines as they are typed."), _("\
Show editing of command lines as they are typed."), _("\
Use \"on\" to enable the editing, and \"off\" to disable it.\n\
Without an argument, command line editing is enabled.  To edit, use\n\
EMACS-like or VI-like commands like control-P or ESC."),
			   set_async_editing_command,
			   show_async_command_editing_p,
			   &setlist, &showlist);

  add_setshow_boolean_cmd ("save", no_class, &write_history_p, _("\
Set saving of the history record on exit."), _("\
Show saving of the history record on exit."), _("\
Use \"on\" to enable the saving, and \"off\" to disable it.\n\
Without an argument, saving is enabled."),
			   NULL,
			   show_write_history_p,
			   &sethistlist, &showhistlist);

  add_setshow_uinteger_cmd ("size", no_class, &history_size_setshow_var, _("\
Set the size of the command history,"), _("\
Show the size of the command history,"), _("\
ie. the number of previous commands to keep a record of.\n\
If set to \"unlimited\", the number of commands kept in the history\n\
list is unlimited.  This defaults to the value of the environment\n\
variable \"HISTSIZE\", or to 256 if this variable is not set."),
			    set_history_size_command,
			    show_history_size,
			    &sethistlist, &showhistlist);

  add_setshow_filename_cmd ("filename", no_class, &history_filename, _("\
Set the filename in which to record the command history"), _("\
Show the filename in which to record the command history"), _("\
(the list of previous commands of which a record is kept)."),
			    set_history_filename,
			    show_history_filename,
			    &sethistlist, &showhistlist);

  add_setshow_boolean_cmd ("confirm", class_support, &confirm, _("\
Set whether to confirm potentially dangerous operations."), _("\
Show whether to confirm potentially dangerous operations."), NULL,
			   NULL,
			   show_confirm,
			   &setlist, &showlist);

  add_setshow_zinteger_cmd ("annotate", class_obscure, &annotation_level, _("\
Set annotation_level."), _("\
Show annotation_level."), _("\
0 == normal;     1 == fullname (for use when running under emacs)\n\
2 == output annotated suitably for use by programs that control GDB."),
			    NULL,
			    show_annotation_level,
			    &setlist, &showlist);

  add_setshow_boolean_cmd ("exec-done-display", class_support,
			   &exec_done_display_p, _("\
Set notification of completion for asynchronous execution commands."), _("\
Show notification of completion for asynchronous execution commands."), _("\
Use \"on\" to enable the notification, and \"off\" to disable it."),
			   NULL,
			   show_exec_done_display_p,
			   &setlist, &showlist);

  add_setshow_filename_cmd ("data-directory", class_maintenance,
                           &gdb_datadir, _("Set GDB's data directory."),
                           _("Show GDB's data directory."),
                           _("\
When set, GDB uses the specified path to search for data files."),
                           set_gdb_datadir, NULL,
                           &setlist,
                           &showlist);
}

void
gdb_init (char *argv0)
{
  if (pre_init_ui_hook)
    pre_init_ui_hook ();

  /* Run the init function of each source file.  */

#ifdef __MSDOS__
  /* Make sure we return to the original directory upon exit, come
     what may, since the OS doesn't do that for us.  */
  make_final_cleanup (do_chdir_cleanup, xstrdup (current_directory));
#endif

  init_cmd_lists ();	    /* This needs to be done first.  */
  initialize_targets ();    /* Setup target_terminal macros for utils.c.  */
  initialize_utils ();	    /* Make errors and warnings possible.  */

  /* Here is where we call all the _initialize_foo routines.  */
  initialize_all_files ();

  /* This creates the current_program_space.  Do this after all the
     _initialize_foo routines have had a chance to install their
     per-sspace data keys.  Also do this before
     initialize_current_architecture is called, because it accesses
     exec_bfd of the current program space.  */
  initialize_progspace ();
  initialize_inferiors ();
  initialize_current_architecture ();
  init_cli_cmds();
  initialize_event_loop ();
  init_main ();			/* But that omits this file!  Do it now.  */

  initialize_stdin_serial ();

  async_init_signals ();

  /* We need a default language for parsing expressions, so simple
     things like "set width 0" won't fail if no language is explicitly
     set in a config file or implicitly set by reading an executable
     during startup.  */
  set_language (language_c);
  expected_language = current_language;	/* Don't warn about the change.  */

  /* Allow another UI to initialize.  If the UI fails to initialize,
     and it wants GDB to revert to the CLI, it should clear
     deprecated_init_ui_hook.  */
  if (deprecated_init_ui_hook)
    deprecated_init_ui_hook (argv0);

#ifdef HAVE_PYTHON
  /* Python initialization can require various commands to be
     installed.  For example "info pretty-printer" needs the "info"
     prefix to be installed.  Keep things simple and just do final
     python initialization here.  */
  finish_python_initialization ();
#endif
}
@


1.244
log
@Remove use of deprecated_init_ui_hook from quit_confirm.

  https://sourceware.org/ml/gdb-patches/2013-09/msg00224.html

gdb/ChangeLog

        * top.c (quit_confirm): Remove use of deprecated_init_ui_hook.
@
text
@a146 7
/* Baud rate specified for talking to serial target systems.  Default
   is left as -1, so targets can choose their own defaults.  */
/* FIXME: This means that "show remotebaud" and gr_files_info can
   print -1 or (unsigned int)-1.  This is a Bad User Interface.  */

int baud_rate = -1;

@


1.243
log
@Remove deprecated_command_loop_hook.

  https://sourceware.org/ml/gdb-patches/2013-09/msg00174.html

gdb/ChangeLog

        * gdb/defs.h (deprecated_command_loop_hook): Remove, including
        references in comments.
        * gdb/interps.c (current_interp_command_loop): No longer use
        deprecated_command_loop_hook.
        (clear_interpreter_hooks): Remove deprecated_command_loop_hook
        setup.
        * gdb/top.c (deprecated_command_loop_hook): Remove.
@
text
@d1358 3
a1360 12
  /* This is something of a hack.  But there's no reliable way to see
     if a GUI is running.  The `use_windows' variable doesn't cut
     it.  */
  if (deprecated_init_ui_hook)
    fprintf_filtered (stb, _("A debugging session is active.\n"
			     "Do you still want to close the debugger?"));
  else
    {
      fprintf_filtered (stb, _("A debugging session is active.\n\n"));
      iterate_over_inferiors (print_inferior_quit_action, stb);
      fprintf_filtered (stb, _("\nQuit anyway? "));
    }
@


1.242
log
@2013-08-29  Phil Muldoon  <pmuldoon@@redhat.com>

	PR cli/15842

	* top.c (print_gdb_version): Remove erroneous newline after help
	text.
@
text
@a201 5
/* Called instead of command_loop at top level.  Can be invoked via
   throw_exception().  */

void (*deprecated_command_loop_hook) (void);

@


1.241
log
@2013-08-15  Muhammad Bilal  <mbilal@@codesourcery.com>

	PR cli/15841
	* top.c (quit_force): Skip writing history file
	if input is not from terminal.
@
text
@d1156 1
a1156 1
commands related to \"word\".\n"));
@


1.240
log
@2013-07-30  Muhammad Bilal  <mbilal@@codesorcery.com>

        PR gdb/15715
        * top.c: Include "filenames.h".
        (set_history_filename): New function.
        (init_main): Install it as set hook of the "set history filename"
        command.
2013-07-30  Muhammad Bilal  <mbilal@@codesourcery.com>

        PR gdb/15715
        * gdb.base/setshow.exp: Test that relative paths passed to
        'set history filename' are converted to absolute paths.
@
text
@d1436 2
a1437 1
      if (write_history_p && history_filename)
@


1.239
log
@2013-07-22  Phil Muldoon  <pmuldoon@@redhat.com>

	* top.c (print_gdb_version): Add help, apropos description and
	url to online documentation.
@
text
@d51 1
d1708 11
d1794 1
a1794 1
			    NULL,
@


1.238
log
@ top.c (print_gdb_configuration): Explain in output of --configuration
 what does "relocatable" mean.
@
text
@d1148 1
a1148 1
      fprintf_filtered (stream, "%s.", REPORT_BUGS_TO);
d1150 6
@


1.237
log
@Reimplement DJGPP's .gdbinit -> gdb.ini renaming.

This simplifies the .gdbinit filename selection logic.

We have a GDBINIT_FILENAME define that supposedly configurations would
override, but none do so.  Instead, the only configuration that wants
a different file name instead of ".gdbinit", djgpp, does a strcpy over
the gdbinit global array.  This means the array needs to be sized, and
the code that does that is doing the usual
'PATH_MAX/FILENAME_MAX/fallback constant/etc.' mess.

Instead of all that, it's much simpler to have configure specificy the
.gdbinit filename.  As bonus, we can then make the "gdbinit" global
array const.

gdb/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* configure.ac (GDBINIT): Define, depending on host.
	* go32-nat.c (init_go32_ops): Don't override gdbinit here.
	* top.c (PATH_MAX): Delete fallback definition.
	(GDBINIT_FILENAME): Delete.
	(gdbinit): Reimplement as const char array set to the GDBINIT
	string constant.
	* top.h (gdbinit): Make const.
@
text
@d1244 6
@


1.236
log
@fix top.c

execute_command can leak a cleanup along one return path.

	* top.c (execute_command): Discard 'cleanup_if_error' cleanups.
@
text
@d81 1
a81 1
/* Initialization file name for gdb.  This is overridden in some configs.  */
d83 1
a83 12
#ifndef PATH_MAX
# ifdef FILENAME_MAX
#  define PATH_MAX FILENAME_MAX
# else
#  define PATH_MAX 512
# endif
#endif

#ifndef	GDBINIT_FILENAME
#define	GDBINIT_FILENAME	".gdbinit"
#endif
char gdbinit[PATH_MAX + 1] = GDBINIT_FILENAME;
@


1.235
log
@gdb/
	* top.c (print_gdb_configuration): Print configure-time
	parameter on using libbabeltrace or not.
@
text
@d428 1
@


1.234
log
@Implement a new command to show GDB build-time configuration parameters.

	* top.c (print_gdb_configuration): New function, displays the
	details about GDB configure-time parameters.
	(print_gdb_version): Mention "show configuration".

	* cli/cli-cmds.c (show_configuration): New function.
	(_initialize_cli_cmds): Add the "show configuration" command.

	* main.c (captured_main) <print_configuration>: New static var.
	<long_options>: Use it.
	If --configuration was given, call print_gdb_configuration.

	* doc/gdb.texinfo (Mode Options): Document '-configuration'.
	(Help): Document "show configuration".
	(Bug Reporting): Add requirements to include the configuration
	details in bug reports.
@
text
@d1245 9
@


1.233
log
@Accept "set foo unlimited" in integer/uinteger/zuinteger_unlimited commands.

Currently, several commands take "0" or "-1" to mean "unlimited".

"show" knows when to print "unlimited":

 (gdb) show height
 Number of lines gdb thinks are in a page is 45.
 (gdb) set height 0
 (gdb) show height
 Number of lines gdb thinks are in a page is unlimited.

However, the user can't herself specify "unlimited" directly:

 (gdb) set height unlimited
 No symbol table is loaded.  Use the "file" command.
 (gdb)

This patch addresses that, by adjusting the set handler for all
integer/uinteger/zuinteger_unlimited commands to accept literal
"unlimited".  It also installs a completer.  Presently, we complete on
symbols by default, and at
<http://sourceware.org/ml/gdb-patches/2013-03/msg00864.html> I've
shown a WIP prototype that tried to keep that half working in these
commands.  In the end, it turned out to be more complicated than
justifiable, IMO.  It's super rare to want to pass the value of a
variable/symbol in the program to a GDB set/show knob.  That'll still
work, it's just that we won't assist with completion anymore.  This
patch just sticks with the simple, and completes on "unlimited", and
nothing else.  This simplification means that

  "set he<tab><tab>"

is all it takes to get to:

  "set height unlimited"

The patch then goes through all integer/uinteger/zuinteger_unlimited
commands in the tree, and updates both the online help and the manual
to mention that "unlimited" is accepted in addition to 0/-1.  In the
cases where the command had no online help text at all, this adds it.
I've tried to make the texts read in a way that "unlimited" is
suggested before "0" or "-1" is.

Tested on x86_64 Fedora 17.

gdb/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* cli/cli-decode.c (integer_unlimited_completer): New function.
	(add_setshow_integer_cmd, add_setshow_uinteger_cmd)
	(add_setshow_zuinteger_unlimited_cmd): Install the "unlimited"
	completer.
	* cli/cli-setshow.c: Include "cli/cli-utils.h".
	(is_unlimited_literal): New function.
	(do_set_command): Handle literal "unlimited" arguments.
	* frame.c (_initialize_frame) <set backtrace limit>: Document
	"unlimited".
	* printcmd.c (_initialize_printcmd) <set print
	max-symbolic-offset>: Add help text.
	* record-full.c (_initialize_record_full) <set record full
	insn-number-max>: Likewise.
	* record.c (_initialize_record) <set record
	instruction-history-size, set record function-call-history-size>:
	Add help text.
	* ser-tcp.c (_initialize_ser_tcp) <set tcp connect-timeout>: Add
	help text.
	* tracepoint.c (_initialize_tracepoint) <set trace-buffer-size>:
	Likewise.
	* source.c (_initialize_source) <set listsize>: Add help text.
	* utils.c (initialize_utils) <set height, set width>: Likewise.
	<set pagination>: Mention "set height unlimited".
	* valprint.c (_initialize_valprint) <set print elements, set print
	repeats>: Document "unlimited".

gdb/doc/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* gdb.texinfo (Process Record and Replay): Document that "set
	record full insn-number-max", "set record
	instruction-history-size" and "set record
	function-call-history-size" accept "unlimited".
	(Backtrace): Document that "set backtrace limit" accepts
	"unlimited".
	(List): Document that "set listsize" accepts "unlimited".
	(Print Settings)" Document that "set print max-symbolic-offset",
	"set print elements" and "set print repeats" accept "unlimited".
	(Starting and Stopping Trace Experiments): Document that "set
	trace-buffer-size" accepts "unlimited".
	(Remote Configuration): Document that "set tcp connect-timeout"
	accepts "unlimited".
	(Command History): Document that "set history size" accepts
	"unlimited".
	(Screen Size): Document that "set height" and "set width" accepts
	"unlimited".  Adjust "set pagination"'s description to suggest
	"set height unlimited" instead of "set height 0".

gdb/testsuite/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* gdb.base/completion.exp: Test "set height", "set listsize" and
	"set trace-buffer-size" completion.
	* gdb.base/setshow.exp: Test "set height unlimited".
	* gdb.trace/trace-buffer-size.exp: Test "set trace-buffer-size
	unlimited".
@
text
@d1151 2
a1152 1
  fprintf_filtered (stream, "\".");
d1156 1
a1156 1
      fprintf_filtered (stream, 
d1161 85
@


1.232
log
@make -gdb-exit call disconnect_tracing too, and don't lose history if the target errors on "quit"

Gareth mentions in PR gdb/15275:

 "The MI '-gdb-exit' command mi_cmd_gdb_exit() never calls disconnect_tracing()
 and therefore exits correctly."

It should, so to get out of tfind mode, as quit may detach instead of
kill, and we don't want to confuse the memory/register accesses
etc. of the detach process.  So we should push down the disconnect
tracing bits at least to quit_force.  But we can't as is, as that
would swallow the error thrown by answering "no" to:

  Trace is running but will stop on detach; detach anyway? (y or n)

So to address that, we split disconnect_tracing in two.  One part that
does the query, and another part that does the rest, and we make
quit_force call the latter.

Looking at quit_force, it does several things, some of which are a bit
independent of the others.  It first kills/detaches, and then writes
history, and then runs the final cleanups.  It seems better to me to
do each of these things even if the previous thing throws.  E.g., as
is, if something throws while detaching, then we skip writing history.

Tested on x86_64 Fedora 17.

gdb/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* cli/cli-cmds.c (quit_command): Call query_if_trace_running
	instead of disconnect_tracing.
	* infcmd.c (detach_command, disconnect_command): Call
	query_if_trace_running.  Adjust.
	* top.c: Include "tracepoint.h".
	(quit_target): Delete.  Contents moved ...
	(quit_force): ... here.  Wrap each stage of teardown in
	TRY_CATCH.  Call disconnect_tracing before detaching.
@
text
@d1673 4
a1676 1
ie. the number of previous commands to keep a record of."),
@


1.231
log
@Forbid "set history size (INT_MAX..UINT_MAX)"

The whole readline interface is signed, and works with the 0..INT_MAX
range.

We don't allow setting the size to UINT_MAX directly.  The documented
user visible interface is "use 0 for unlimited".  The UINT_MAX
representation is an implementation detail we could change, e.g., by
keeping a separate flag for "unlimited", which is actually what the
readline interface does (stifled vs non stifled).  Generically
speaking, exposing this detail to clients of the interface may make
our lives complicated when we find the need to extend the range of
some command in the future, and it's better if users
(frontends/scripts) aren't relying on anything but what we tell them
to use for "unlimited".  Making values other than 0 error out is the
way to prevent users from using those ranges inappropriately.  Quite
related, note:

    (gdb) set history size 0xffffffff
    integer 4294967295 out of range

  But,

    (gdb) set history size 0xfffffffe
    (gdb) show history size
    The size of the command history is unlimited.

    (gdb) set history size 0x100000000
    integer 4294967296 out of range

If values over INT_MAX are accepted as unlimited, then there's no good
argument for only accepting [INT_MAX..UINT_MAX) as valid "unlimited"
magic numbers, while not accepting [UINT_MAX..inf).

Making the setting's control variable of different type (unsigned int)
of the rest of the related code (int) adds the need to recall that one
variable among all these is unsigned, and that one need to think about
whether these comparisons are signed or unsigned, along with the
promotion/conversion rules.  Since this is an easy to forget detail,
this patch renames the variable to at least make it more obvious that
this variable is not one of GNU history's public int variables, which
are all signed.  We don't actually need the only code that presently
is affected by this, though, the code that is computing the current
history's length.  We can just use GNU history's history_length
instead:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Variable: int history_length
    The number of entries currently stored in the history list.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/* Return the history entry which is logically at OFFSET in the history array.
   OFFSET is relative to history_base. */
HIST_ENTRY *
history_get (offset)
     int offset;
{
  int local_index;

  local_index = offset - history_base;
  return (local_index >= history_length || local_index < 0 || the_history == 0)
		? (HIST_ENTRY *)NULL
		: the_history[local_index];
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

At the time this code was added (gdb 4.13 ~1994), 'history_length' was
extern, but not documented in readline's GNU history documents, so I
guess it wasn't considered public then and the loop was the
workaround.

One of the warts of GDB choosing 0 to mean unlimited is that "set
history size 0" behaves differently from 'HISTSIZE=0 gdb'.  The latter
leaves GDB with no history, while the former means "unlimited"...

 $ HISTSIZE=0 ./gdb
 ...
 (gdb) show history size
 The size of the command history is 0.

We shouldn't really change what HISTSIZE=0 means, as bash, etc. also
handle 0 as real zero, and zero it's what really makes sense.

gdb/
2013-03-27  Pedro Alves  <palves@@redhat.com>

	* top.c (history_size): Rename to ...
	(history_size_setshow_var): ... this.  Add comment.
	(show_commands): Use readline's 'history_length' instead of
	computing the history length by calling history_get in a loop.
	(set_history_size_command): Error out for sizes over INT_MAX.
	Restore previous history size on invalid size.
	(init_history): If HISTSIZE is negative, leave the history size as
	zero.  Add comments.
	(init_main): Adjust.
@
text
@d67 1
a1285 23
/* Helper routine for quit_force that requires error handling.  */

static int
quit_target (void *arg)
{
  struct qt_args *qt = (struct qt_args *)arg;

  /* Kill or detach all inferiors.  */
  iterate_over_inferiors (kill_or_detach, qt);

  /* Give all pushed targets a chance to do minimal cleanup, and pop
     them all out.  */
  pop_all_targets ();

  /* Save the history information if it is appropriate to do so.  */
  if (write_history_p && history_filename)
    write_history (history_filename);

  do_final_cleanups (all_cleanups ());    /* Do any final cleanups before
					     exiting.  */
  return 0;
}

d1293 1
d1309 8
d1318 31
a1348 2
  catch_errors (quit_target, &qt,
	        "Quitting: ", RETURN_MASK_ALL);
@


1.230
log
@Use readline's 'history_max_entries' instead of the old 'max_input_history'.

Ref: http://www.sourceware.org/ml/gdb-patches/2002-08/msg00486.html

We've long since imported a newer readline, no need to use the old
compatibility variable anymore.

Tested on x86_64 Fedora 17.

gdb/
2013-03-26  Pedro Alves  <palves@@redhat.com>

	* top.c (gdb_rl_operate_and_get_next): Replace max_input_history
	use with history_max_entries use.  Remove FIXME note.
@
text
@d714 4
a717 1
static unsigned int history_size;
a1379 4
  /* The first command in the history which doesn't exist (i.e. one more
     than the number of the last command).  Relative to history_base.  */
  unsigned int hist_len;

a1380 10
  /* First determine the length of the history list.  */
  hist_len = history_size;
  for (offset = 0; offset < history_size; offset++)
    {
      if (!history_get (history_base + offset))
	{
	  hist_len = offset;
	  break;
	}
    }
d1394 1
a1394 1
      num = hist_len - Hist_print;
d1402 1
a1402 1
  if (hist_len - num < Hist_print)
d1404 1
a1404 1
      num = hist_len - Hist_print;
d1409 3
a1411 1
  for (offset = num; offset < num + Hist_print && offset < hist_len; offset++)
d1435 17
a1451 7
  /* The type of parameter in stifle_history is int, so values from INT_MAX up
     mean 'unlimited'.  */
  if (history_size >= INT_MAX)
    {
      /* Ensure that 'show history size' prints 'unlimited'.  */
      history_size = UINT_MAX;
      unstifle_history ();
d1453 4
d1458 1
a1458 1
    stifle_history (history_size);
d1511 2
a1512 3
    history_size = atoi (tmpenv);
  else if (!history_size)
    history_size = 256;
d1514 18
a1531 1
  stifle_history (history_size);
d1654 1
a1654 1
  add_setshow_uinteger_cmd ("size", no_class, &history_size, _("\
@


1.229
log
@	New commands "mt set per-command {space,time,symtab} {on,off}".
	* NEWS: Add entry.
	* event-top.c: #include "maint.h".
	* main.c: #include "maint.h".
	* maint.c: #include <sys/time.h>, <time.h>, block.h, top.h,
	timeval-utils.h, maint.h, cli/cli-setshow.h.
	(per_command_time, per_command_space): New static globals.
	(per_command_symtab): New static global.
	(per_command_setlist, per_command_showlist): New static globals.
	(struct cmd_stats): Move here from utils.c.
	(set_per_command_time): Renamed from set_display_time in utils.c
	and moved here.  All callers updated.
	(set_per_command_space): Renamed from set_display_space in utils.c
	and moved here.  All callers updated.
	(count_symtabs_and_blocks): New function.
	(report_command_stats): Moved here from utils.c.  Add support for
	printing symtab stats.  Only print data if enabled before command
	executed.
	(make_command_stats_cleanup): Ditto.
	(sert_per_command_cmd, show_per_command_cmd): New functions.
	(_initialize_maint_cmds): Add new commands
	mt set per-command {space,time,symtab} {on,off}.
	* maint.h: New file.
	* top.c: #include "maint.h".
	* utils.c (reset_prompt_for_continue_wait_time): New function.
	(get_prompt_for_continue_wait_time): New function.
	* utils.h (reset_prompt_for_continue_wait_time): Declare
	(get_prompt_for_continue_wait_time): Declare.
	(make_command_stats_cleanup): Moved to maint.h.
	(set_display_time, set_display_space): Moved to maint.h and renamed
	to set_per_command_time, set_per_command_space.
	* cli/cli-setshow.c (parse_cli_boolean_value): Renamed from
	parse_binary_operation and made non-static.  Don't call error,
	just return an error marker.  All callers updated.
	* cli/cli-setshow.h (parse_cli_boolean_value): Declare.

	doc/
	* gdb.texinfo (Maintenance Commands): Add docs for
	"mt set per-command {space,time,symtab} {on,off}".

	testsuite/
	* gdb.base/maint.exp: Update tests for per-command stats.
@
text
@d879 2
a880 7
  /* FIXME: kettenis/20020817: max_input_history is renamed into
     history_max_entries in readline-4.2.  When we do a new readline
     import, we should probably change it here too, even though
     readline maintains backwards compatibility for now by still
     defining max_input_history.  */
  if ((history_is_stifled () && (history_length >= max_input_history)) ||
      (where >= history_length - 1))
@


1.228
log
@gdb/
	Code cleanup.
	* bfd-target.c (target_bfd_xclose): Remove parameter quitting.
	* bsd-kvm.c (bsd_kvm_close): Likewise.
	* bsd-uthread.c (bsd_uthread_close): Likewise.
	* corelow.c (core_close): Likewise.
	(core_close_cleanup): Remove parameter quitting from a caller.
	* event-top.c (async_disconnect): Likewise.
	* exec.c (exec_close_1): Remove parameter quitting.
	* go32-nat.c (go32_close): Likewise.
	* linux-nat.c (linux_nat_close): Remove parameter quitting.  Remove
	parameter quitting from a caller.
	* mips-linux-nat.c (super_close): Remove parameter quitting from the
	variable.
	(mips_linux_close): Remove parameter quitting.  Remove parameter
	quitting from a caller.
	* monitor.c (monitor_close): Remove parameter quitting.
	* monitor.h (monitor_close): Likewise.
	* record-btrace.c (record_btrace_close): Likewise.
	* record-full.c (record_full_close): Likewise.
	* remote-m32r-sdi.c (m32r_close): Remove parameter quitting and remove
	it also from fprintf_unfiltered.
	* remote-mips.c (mips_close): Remove parameter quitting.
	(mips_detach): Remove parameter quitting from a caller.
	* remote-sim.c (gdbsim_close): Remove parameter quitting.
	(gdbsim_close): Remove duplicate function comment.  Remove parameter
	quitting and remove it also from printf_filtered.
	* remote.c (remote_close): Remove parameter quitting.
	* solib-svr4.c (enable_break): Remove parameter quitting from a caller.
	* target.c (update_current_target): Remove parameter int from to_close
	de_fault.
	(push_target, unpush_target, pop_target): Remove parameter quitting from
	a caller.
	(pop_all_targets_above, pop_all_targets): Remove parameter quitting.
	Remove parameter quitting from a caller.
	(target_preopen): Remove parameter quitting from a caller.
	(target_close): Remove parameter quitting.  Remove parameter quitting
	from a caller two times.  Remove parameter quitting also from
	fprintf_unfiltered.
	* target.h (struct target_ops): Remove parameter quitting and as int
	from fields to_xclose and to_close.
	(extern struct target_ops current_target):
	(target_close, pop_all_targets): Remove parameter quitting.  Update the
	comment.
	(pop_all_targets_above): Remove parameter quitting.
	* top.c (quit_target): Remove parameter quitting from a caller.
	* tracepoint.c (tfile_close): Remove parameter quitting.
	* windows-nat.c (windows_close): Remove parameter quitting.
@
text
@d50 1
@


1.227
log
@Constify strings in tracepoint.c, lookup_cmd and the completers.

This is sort of a continuation of Keith's parse_exp_1 constification
patch.  It started out by undoing these bits:

  @@@@ -754,9 +754,12 @@@@ validate_actionline (char **line, struct
   	  tmp_p = p;
   	  for (loc = t->base.loc; loc; loc = loc->next)
   	    {
  -	      p = tmp_p;
  -	      exp = parse_exp_1 (&p, loc->address,
  +	      const char *q;
  +
  +	      q = tmp_p;
  +	      exp = parse_exp_1 (&q, loc->address,
   				 block_for_pc (loc->address), 1);
  +	      p = (char *) q;

and progressively making more things const upwards, fixing fallout,
rinse repeat, until GDB built again (--enable-targets=all).

That ended up constifying lookup_cmd/add_cmd and (lots of) friends,
and the completers.

I didn't try to constify the command hooks themselves, because I know
upfront there are commands that write to the command string argument,
and I think I managed to stop at a nice non-hacky split point already.

I think the only non-really-super-obvious changes are
tracepoint.c:validate_actionline, and tracepoint.c:trace_dump_actions.

The rest is just mostly about 'char *' => 'const char *', 'char **'=>
'const char **', and the occasional (e.g., deprecated_cmd_warning)
case of 'char **'=> 'const char *', where/when I noticed that nothing
actually cares about the pointer to pointer output.

Tested on x86_64 Fedora 17, native and gdbserver.

gdb/
2013-03-13  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (struct add_partial_datum) <text, text0, word>: Make
	fields const.
	(ada_make_symbol_completion_list): Make "text0" parameter const.
	* ax-gdb.c (agent_eval_command_one): Make "exp" parameter const.
	* breakpoint.c (condition_completer): Make "text" and "word"
	parameters const.  Adjust.
	(check_tracepoint_command): Adjust to validate_actionline
	prototype change.
	(catch_syscall_completer): Make "text" and "word" parameters
	const.
	* cli/cli-cmds.c (show_user): Make "comname" local const.
	(valid_command_p): Make "command" parameter const.
	(alias_command): Make "alias_prefix" and "command_prefix" locals
	const.
	* cli/cli-decode.c (add_cmd): Make "name" parameter const.
	(add_alias_cmd): Make "name" and "oldname" parameters const.
	Adjust.  No longer make copy of OLDNAME.
	(add_prefix_cmd, add_abbrev_prefix_cmd, add_set_or_show_cmd)
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_unlimited_cmd, add_setshow_zuinteger_cmd)
	(delete_cmd, add_info, add_info_alias, add_com, add_com_alias):
	Make "name" parameter const.
	(help_cmd): Rename "command" parameter to "arg".  New const local
	"command".
	(find_cmd): Make "command" parameter const.
	(lookup_cmd_1): Make "text" parameter pointer to const.  Adjust to
	deprecated_cmd_warning prototype change.
	(undef_cmd_error): Make "cmdtype" parameter const.
	(lookup_cmd): Make "line" parameter const.
	(deprecated_cmd_warning): Change type of "text" parameter to
	pointer to const char, from pointer to pointer to char.  Adjust.
	(lookup_cmd_composition): Make "text" parameter const.
	(complete_on_cmdlist, complete_on_enum): Make "text" and "word"
	parameters const.
	* cli/cli-decode.h (struct cmd_list_element) <name>: Make field
	const.
	* cli/cli-script.c (validate_comname): Make "tem" local const.
	(define_command): New const local "tem_c".  Use it in calls to
	lookup_cmd.
	(document_command): Make "tem" and "comfull" locals const.
	(show_user_1): Make "prefix" and "name" parameters const.
	* cli-script.h (show_user_1): Make "prefix" and "name" parameters
	const.
	* command.h (add_cmd, add_alias_cmd, add_prefix_cmd)
	(add_abbrev_prefix_cmd, completer_ftype, lookup_cmd, lookup_cmd_1)
	(deprecated_cmd_warning, lookup_cmd_composition, add_com)
	(add_com_alias, add_info, add_info_alias, complete_on_cmdlist)
	(complete_on_enum, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_cmd, add_setshow_zuinteger_unlimited_cmd):
	Change prototypes, constifying strings.
	* completer.c (noop_completer, filename_completer): Make "text"
	and "prefix" parameters const.
	(location_completer, expression_completer)
	(complete_line_internal): Make "text" and "prefix" parameters
	const and adjust.
	(command_completer, signal_completer): Make "text" and "prefix"
	parameters const.
	* completer.h (noop_completer, filename_completer)
	(expression_completer, location_completer, command_completer)
	(signal_completer): Change prototypes.
	* corefile.c (complete_set_gnutarget): Make "text" and "word"
	parameters const.
	* cp-abi.c (cp_abi_completer): Likewise.
	* expression.h (parse_expression_for_completion): Change
	prototype.
	* f-lang.c (f_make_symbol_completion_list): Make "text" and "word"
	parameters const.
	* infcmd.c (_initialize_infcmd): Make "cmd_name" local const.
	* infrun.c (handle_completer): Make "text" and "word" parameters
	const.
	* interps.c (interpreter_completer): Make "text" and "word"
	parameters const.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Make "text" and "word"
	parameters const.
	* parse.c (parse_exp_1): Move const hack to parse_exp_in_context.
	(parse_exp_in_context): Rename to ...
	(parse_exp_in_context_1): ... this.
	(parse_exp_in_context): Reimplement, with const hack from
	parse_exp_1.
	(parse_expression_for_completion): Make "string" parameter const.
	* printcmd.c (decode_format): Make "string_ptr" parameter pointer
	to pointer to const char.  Adjust.
	(print_command_1): Make "exp" parameter const.
	(output_command): Rename to ...
	(output_command_const): ... this.  Make "exp" parameter const.
	(output_command): Reimplement.
	(x_command): Adjust.
	(display_command): Rename "exp" parameter to "arg".  New "exp"
	local, const version of "arg".
	* python/py-auto-load.c (gdbpy_initialize_auto_load): Make
	"cmd_name" local const.
	* python/py-cmd.c (cmdpy_destroyer): Cast const away in xfree
	call.
	(cmdpy_completer): Make "text" and "word" parameters const.
	(gdbpy_parse_command_name): Make "prefix_text2" local const.
	* python/py-param.c (add_setshow_generic): Make "tmp_name" local
	const.
	* remote.c (_initialize_remote): Make "cmd_name" local const.
	* symtab.c (language_search_unquoted_string): Make "text" and "p"
	parameters const.  Adjust.
	(completion_list_add_fields): Make "sym_text", "text" and "word"
	parameters const.
	(struct add_name_data) <sym_text, text, word>: Make fields const.
	(default_make_symbol_completion_list_break_on): Make "text" and
	"word" parameters const.  Adjust locals.
	(default_make_symbol_completion_list)
	(make_symbol_completion_list, make_symbol_completion_type)
	(make_symbol_completion_list_fn): Make "text" and "word"
	parameters const.
	(make_file_symbol_completion_list): Make "text", "word" and
	"srcfile" parameters const.  Adjust locals.
	(add_filename_to_list): Make "text" and "word" parameters const.
	(struct add_partial_filename_data) <text, word>: Make fields
	const.
	(make_source_files_completion_list): Make "text" and "word"
	parameters const.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_type enum type_code)
	(make_symbol_completion_list_fn make_file_symbol_completion_list)
	(make_source_files_completion_list): Change prototype.
	* top.c (execute_command): Adjust to pass pointer to pointer to
	const char to lookup_cmd, and to deprecated_cmd_warning prototype
	change.
	(set_verbose): Make "cmdname" local const.
	* tracepoint.c (decode_agent_options): Make "exp" parameter const,
	and adjust.
	(validate_actionline): Make "line" parameter a pointer to const
	char, and adjust.
	(encode_actions_1): Make "action_exp" local const, and adjust.
	(encode_actions): Adjust.
	(replace_comma): Delete.
	(trace_dump_actions): Make "action_exp" and "next_comma" locals
	const, and adjust.  Don't frob the action string while splitting
	it at commas.  Instead, make a copy of each split substring in
	turn.
	(trace_dump_command): Adjust to validate_actionline prototype
	change.
	* tracepoint.h (decode_agent_options, decode_agent_options)
	(encode_actions, validate_actionline): Change prototypes.
	* valprint.h (output_command): Delete declaration.
	(output_command_const): Declare.
	* value.c (function_destroyer): Cast const away in xfree call.
@
text
@d1298 1
a1298 1
  pop_all_targets (1);
@


1.226
log
@gdb/
	* event-loop.c: Include "queue.h".
	(gdb_event_p): New typedef.
	(DECLARE_QUEUE_P): Use.
	(DEFINE_QUEUE_P): Use.
	(async_queue_event): Remove.
	(gdb_event_xfree): New.
	(initialize_event_loop): New.
	(process_event): Use QUEUE macros.
	(event_queue): Remove.
	(gdb_wait_for_event): Caller update.
	(check_async_event_handlers): Likewise.
	(poll_timers): Likewise.
	* event-loop.h (initialize_event_loop): Declare.
	* event-loop.c (gdb_event_xfree): New.
	* top.c (gdb_init): Call initialize_event_loop.
@
text
@d435 1
d442 2
a443 1
      c = lookup_cmd (&p, cmdlist, "", 0, 1);
d472 1
a472 1
	deprecated_cmd_warning (&line);
d1480 1
a1480 1
  char *cmdname = "verbose";
@


1.226.2.1
log
@Forbid set history size (INT_MAX..UINT_MAX)

The whole readline interface is signed, and works with the 0..INT_MAX
range.

We don't allow setting the size to UINT_MAX directly.  The documented
user visible interface is "use 0 for unlimited".  The UINT_MAX
representation is an implementation detail we could change, e.g., by
keeping a separate flag for "unlimited", which is actually what the
readline interface does (stifled vs non stifled).  Generically
speaking, exposing this detail to clients of the interface may make
our lives complicated when we find the need to extend the range of
some command in the future, and it's better if users
(frontends/scripts) aren't relying on anything but what we tell them
to use for "unlimited".  Making values other than 0 error out is the
way to prevent users from using those ranges inappropriately.  Quite
related, note:

    (gdb) set history size 0xffffffff
    integer 4294967295 out of range

  But,

    (gdb) set history size 0xfffffffe
    (gdb) show history size
    The size of the command history is unlimited.

    (gdb) set history size 0x100000000
    integer 4294967296 out of range

If values over INT_MAX are accepted as unlimited, then there's no good
argument for only accepting [INT_MAX..UINT_MAX) as valid "unlimited"
magic numbers, while not accepting [UINT_MAX..inf).

Making the setting's control variable of different type (unsigned int)
of the rest of the related code (int) adds the need to recall that one
variable among all these is unsigned, and that one need to think about
whether these comparisons are signed or unsigned, along with the
promotion/conversion rules.  Since this is an easy to forget detail,
this patch renames the variable to at least make it more obvious that
this variable is not one of GNU history's public int variables, which
are all signed.  We don't actually need the only code that presently
is affected by this, though, the code that is computing the current
history's length.  We can just use GNU history's history_length
instead:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Variable: int history_length
    The number of entries currently stored in the history list.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/* Return the history entry which is logically at OFFSET in the history array.
   OFFSET is relative to history_base. */
HIST_ENTRY *
history_get (offset)
     int offset;
{
  int local_index;

  local_index = offset - history_base;
  return (local_index >= history_length || local_index < 0 || the_history == 0)
		? (HIST_ENTRY *)NULL
		: the_history[local_index];
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

At the time this code was added (gdb 4.13 ~1994), 'history_length' was
extern, but not documented in readline's GNU history documents, so I
guess it wasn't considered public then and the loop was the
workaround.

One of the warts of GDB choosing 0 to mean unlimited is that "set
history size 0" behaves differently from 'HISTSIZE=0 gdb'.  The latter
leaves GDB with no history, while the former means "unlimited"...

 $ HISTSIZE=0 ./gdb
 ...
 (gdb) show history size
 The size of the command history is 0.

We shouldn't really change what HISTSIZE=0 means, as bash, etc. also
handle 0 as real zero, and zero it's what really makes sense.

gdb/
2013-03-27  Pedro Alves  <palves@@redhat.com>

	* top.c (history_size): Rename to ...
	(history_size_setshow_var): ... this.  Add comment.
	(show_commands): Use readline's 'history_length' instead of
	computing the history length by calling history_get in a loop.
	(set_history_size_command): Error out for sizes over INT_MAX.
	Restore previous history size on invalid size.
	(init_history): If HISTSIZE is negative, leave the history size as
	zero.  Add comments.
	(init_main): Adjust.
@
text
@d711 1
a711 4
/* The variable associated with the "set/show history size"
   command.  */
static unsigned int history_size_setshow_var;

d1379 4
d1384 10
d1407 1
a1407 1
      num = history_length - Hist_print;
d1415 1
a1415 1
  if (history_length - num < Hist_print)
d1417 1
a1417 1
      num = history_length - Hist_print;
d1422 1
a1422 3
  for (offset = num;
       offset < num + Hist_print && offset < history_length;
       offset++)
d1446 7
a1452 17
  /* Readline's history interface works with 'int', so it can only
     handle history sizes up to INT_MAX.  The command itself is
     uinteger, so UINT_MAX means "unlimited", but we only get that if
     the user does "set history size 0" -- "set history size <UINT_MAX>"
     throws out-of-range.  */
  if (history_size_setshow_var > INT_MAX
      && history_size_setshow_var != UINT_MAX)
    {
      unsigned int new_value = history_size_setshow_var;

      /* Restore previous value before throwing.  */
      if (history_is_stifled ())
	history_size_setshow_var = history_max_entries;
      else
	history_size_setshow_var = UINT_MAX;

      error (_("integer %u out of range"), new_value);
a1453 4

  /* Commit the new value to readline's history.  */
  if (history_size_setshow_var == UINT_MAX)
    unstifle_history ();
d1455 1
a1455 1
    stifle_history (history_size_setshow_var);
d1508 3
a1510 2
    {
      int var;
d1512 1
a1512 18
      var = atoi (tmpenv);
      if (var < 0)
	{
	  /* Prefer ending up with no history rather than overflowing
	     readline's history interface, which uses signed 'int'
	     everywhere.  */
	  var = 0;
	}

      history_size_setshow_var = var;
    }
  /* If the init file hasn't set a size yet, pick the default.  */
  else if (history_size_setshow_var == 0)
    history_size_setshow_var = 256;

  /* Note that unlike "set history size 0", "HISTSIZE=0" really sets
     the history size to 0...  */
  stifle_history (history_size_setshow_var);
d1635 1
a1635 1
  add_setshow_uinteger_cmd ("size", no_class, &history_size_setshow_var, _("\
@


1.225
log
@	PR cli/7719:
	* NEWS: Update.
	* ada-valprint.c (printstr, print_field_values): Remove
	"inspect_it" code.
	* cp-valprint.c (cp_print_value_fields): Remove "inspect_it"
	code.
	* jv-valprint.c (java_print_value_fields): Remove "inspect_it"
	code.
	* m2-lang.c (m2_printstr): Remove "inspect_it" code.
	* main.c (captured_main): Remove "epoch" argument.
	* objc-lang.c (objc_printstr): Remove "inspect_it" code.
	* p-lang.c (pascal_printstr): Remove "inspect_it" code.
	* p-valprint.c (pascal_object_print_value_fields): Remove
	"inspect_it" code.
	* printcmd.c (print_command_1): Remove 'inspect' argument.
	(print_command, call_command): Update.
	(inspect_command): Remove.
	(_initialize_printcmd): Make "inspect" an alias for "print".
	* top.c (epoch_interface): Remove.
	* top.h (epoch_interface): Remove.
	* valprint.c (user_print_options): Update.
	(print_converted_chars_to_obstack): Remove "inspect_it" code.
	* valprint.h (struct value_print_options) <inspect_it>: Remove
	field.
doc
	* gdb.texinfo (Mode Options): Don't mention -epoch.
	(Data, Emacs): Remove obsolete comments.
@
text
@d1716 1
@


1.224
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a140 2
int epoch_interface;

@


1.223
log
@Update copyright year in gdb/gdbserver/gdbreplay version output.

gdb/ChangeLog:

        * top.c (print_gdb_version): Update copyright year.

gdb/gdbserver/ChangeLog:

        * gdbreplay.c (gdbreplay_version): Update copyright year.
        * server.c (gdbserver_version): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 1986-2012 Free Software Foundation, Inc.
@


1.222
log
@	* Makefile.in (init.c): Declare initialize_all_files;
	don't include call-cmds.h.
	* call-cmds.h: Remove.
	* symtab.c: Don't include call-cmds.h.
	* top.c: Don't include call-cmds.h.  Declare
	initialize_all_files.
@
text
@d1126 1
a1126 1
		    "Copyright (C) 2012 Free Software Foundation, Inc.\n");
@


1.221
log
@	* top.c (xgdb_verbose): Remove.
@
text
@a21 1
#include "call-cmds.h"
d67 2
@


1.220
log
@gdb/
	* cli/cli-cmds.c (max_user_call_depth): Add 'unsigned'.
	(init_cmds): Call add_setshow_uinteger_cmd for command
	'max-user-call-depth'.
	* cli/cli-script.c (execute_user_command): Add 'unsigned' to the
	declaration of 'max_user_call_depth'.
	* frame.c (backtrace_limit): Add 'unsigned'.
	(_initialize_frame): Call add_setshow_uinteger_cmd for command
	'limit'.
	* remote.c (remoteaddresssize): Add 'unsigned'.
	(remote_address_masked): Change local var 'address_size' to
	'unsigned'.
	(_initialize_remote): Call add_setshow_uinteger_cmd for
	'remoteaddresssize'.
	* top.c (history_size): Add 'unsigned'.
	(show_commands): Change local variables to 'unsigned'.
	(set_history_size_command): Don't check history_size is negative.
	Adjust the condition to call unstifle_history and set history_size
	to UNIT_MAX.
@
text
@a140 1
int xgdb_verbose;
@


1.219
log
@	* defs.h (quit_flag): Don't declare.
	(clear_quit_flag, check_quit_flag, set_quit_flag): Declare.
	(QUIT): Use new functions.
	* event-top.c (command_handler): Use clear_quit_flag.
	(handle_sigint): Use set_quit_flag.
	(async_request_quit): Use check_quit_flag.  Don't check
	immediate_quit.
	* exceptions.c (throw_exception): Use clear_quit_flag.
	* main.c (captured_main): Use clear_quit_flag.
	* python/python.c (clear_quit_flag, set_quit_flag)
	(check_quit_flag): New functions.
	* remote-sim.c (gdb_os_poll_quit): Use check_quit_flag,
	clear_quit_flag.
	* remote.c (remote_wait_as): Use check_quit_flag,
	clear_quit_flag.
	(remote_start_remote): Call QUIT.
	* symfile.c (load_progress): Use check_quit_flag.
	* top.c (command_loop): Use clear_quit_flag.
	(command_line_input): Call QUIT.
	* utils.c (quit_flag): Conditionally define.
	(clear_quit_flag, check_quit_flag, set_quit_flag): New
	functions.
	(prompt_for_continue): Call QUIT.  Use quit, not
	async_request_quit.
	* remote-mips.c (mips_expect_timeout): Call QUIT.
	* monitor.c (monitor_expect): Call QUIT.
@
text
@d713 1
a713 1
static int history_size;
d1383 1
a1383 1
  int hist_len;
d1448 9
a1456 3
  if (history_size == INT_MAX)
    unstifle_history ();
  else if (history_size >= 0)
a1457 5
  else
    {
      history_size = INT_MAX;
      error (_("History size must be non-negative"));
    }
d1637 1
a1637 1
  add_setshow_integer_cmd ("size", no_class, &history_size, _("\
d1641 3
a1643 3
			   set_history_size_command,
			   show_history_size,
			   &sethistlist, &showhistlist);
@


1.218
log
@gdb/

	* cli/cli-decode.c (set_cmd_prefix): New.
	(lookup_cmd_for_prefixlist): New.
	(add_prefix_cmd): Call set_cmd_prefix and update field 'prefix'
	of each cmd_list_element in *prefixlist.
	(add_setshow_cmd_full): set_cmd_prefix.
	(add_alias_cmd): Likewise.
	* cli/cli-decode.h (struct cmd_list_element) <prefix>: New field.
	Declare 'auto_boolean_enums'.
	* cli/cli-setshow.c: Include "observer.h".
	(notify_command_param_changed_p): New.
	(add_setshow_auto_boolean_cmd): Move auto_boolean_enums out.
	Remove 'static'.
	(do_setshow_command): Split it to ...
	(do_set_command, do_show_command): ... them.  New.
	(do_set_command): Call observer_notify_command_param_changed if
	notify_command_param_changed_p returns true.
	(cmd_show_list): Caller update.
	* auto-load.c (set_auto_load_cmd): Likewise.
	* remote.c (show_remote_cmd): Likewise.
	* cli/cli-setshow.h: Update declarations.
	* top.c (execute_command): Call do_set_command and do_show_command.

	* NEWS: Mention new MI notification.
	* mi/mi-interp.c: Declare mi_command_param_changed.
	(mi_interpreter_init): Attach mi_command_param_changed to
	observer command_param_changed.
	(mi_command_param_changed): New.
	Remove mi_suppress_breakpoint_notifications.
	Define global variable mi_suppress_notification.
	(mi_breakpoint_created): Update.
	(mi_breakpoint_deleted): Likewise.
	(mi_breakpoint_modified): Likewise.
	* mi/mi-main.c (mi_cmd_execute): Likewise.  Check command
	'gdb-set' and set mi_suppress_notification.
	* mi/mi-main.h: (mi_suppress_notification): New struct.

gdb/doc/

	* observer.texi: New observer command_param_changed.
	* gdb.texinfo (GDB/MI Async Records): Doc for '=cmd-param-changed'.

gdb/testsuite/

	* gdb.mi/mi-cmd-param-changed.exp: New.
	* gdb.mi/mi-cli.exp: Update for MI notification "=cmd-param-changed".
	* gdb.mi/mi-var-rtti.exp, gdb.mi/mi2-cli.exp: Likewise.
	* gdb.mi/mi2-prompt.exp: Likewise.
@
text
@d572 1
a572 1
      quit_flag = 0;
d947 1
@


1.217
log
@gdb/
	* go32-nat.c: Declare _initialize_go32_nat.
	* ser-go32.c: Declare _initialize_ser_dos.
	* top.c (do_chdir_cleanup): Add 'static'.
@
text
@d477 4
a480 2
      else if (c->type == set_cmd || c->type == show_cmd)
	do_setshow_command (arg, from_tty, c);
@


1.216
log
@gdb/
	Provide $ddir substitution for --with-auto-load-safe-path.
	* NEWS (--with-auto-load-safe-path, --without-auto-load-safe-path): New
	entries.
	* auto-load.c: Include observer.h.
	(auto_load_safe_path_vec_update): Call substitute_path_component for
	each component.  New variable ddir_subst.
	(auto_load_gdb_datadir_changed): New function.
	(set_auto_load_safe_path): Rename DEFAULT_AUTO_LOAD_SAFE_PATH to
	AUTO_LOAD_SAFE_PATH.  New comment.
	(_initialize_auto_load): Rename DEFAULT_AUTO_LOAD_SAFE_PATH to
	AUTO_LOAD_SAFE_PATH.  Install auto_load_gdb_datadir_changed.
	* config.in: Regenerate.
	* configure: Regenerate.
	* configure.ac (--auto-load-safe-path): Rename
	DEFAULT_AUTO_LOAD_SAFE_PATH to AUTO_LOAD_SAFE_PATH.  Default to
	GDB_DATADIR/auto-load.
	* defs.h (substitute_path_component): New declaration.
	* top.c: Include observer.h.
	(set_gdb_datadir): New function.
	(init_main): Install it for "set data-directory".
	* utils.c (substitute_path_component): New function.

gdb/doc/
	Provide $ddir substitution for --with-auto-load-safe-path.
	* gdb.texinfo (Auto-loading): Replace /usr/local by $ddir/auto-load.
	(Auto-loading safe path): Likewise.  Mention the default value,
	$ddir substitution, --with-auto-load-safe-path and
	--without-auto-load-safe-path.
	* observer.texi (gdb_datadir_changed): New.
@
text
@d339 1
a339 1
void
@


1.215
log
@	* top.c (quit_target): Use all_cleanups.
	* main.c (captured_command_loop): Use all_cleanups.
	* exceptions.c (throw_exception): Use all_cleanups.
@
text
@d50 1
d1563 9
d1679 1
a1679 1
                           NULL, NULL,
@


1.214
log
@	* NEWS: Mention new python command class gdb.COMMAND_USER.
	* cli/cli-cmds.c (show_user): Print error when used on a python
	command.
	(init_cli_cmds): Update documentation strings for "show user" and
	"set/show max-user-call-depth" to clarify that it does not apply to
	python commands.
	* python/py-cmd.c (cmdpy_init): Treat class_user as a valid class in
	error check.
	(gdbpy_initialize_commands): Add COMMAND_USER as a constant in
	gdb python api.
	* top.c (execute_command): Only execute a user-defined command as a
	legacy macro if c->user_commands is set.

	doc/
	* gdb.texinfo (Commands In Python): Put example python macro in
	COMMAND_USER category rather than COMMAND_OBSCURE.
	Document gdb.COMMAND_USER.
	(User-defined Commands): Update documentation to clarify
	"set/show max-user-call-depth" and "show user" don't apply to python
	commands.  Update documentation to clarify "help user-defined" may
	also include python commands defined as COMMAND_USER.

	testsuite/
	* gdb.python/py-cmd.exp: Add test to verify that python commands can
	be put in the user-defined category and that the commands appear in
	"help user-defined".
@
text
@d1300 2
a1301 2
  do_final_cleanups (ALL_CLEANUPS);    /* Do any final cleanups before
					  exiting.  */
@


1.213
log
@2012-01-23  Pedro Alves  <palves@@redhat.com>

	* top.c (caution): Rename to ...
	(confirm): ... this.
	(show_caution): Rename to ...
	(show_confirm): ... this.
	(quit_cover): Adjust.
	(init_main): Adjust.
	* top.h (caution): Rename to ...
	(confirm): ... this.
	* utils.c (internal_vproblem, defaulted_query): Adjust.
@
text
@d473 2
a474 1
      if (c->class == class_user)
@


1.212
log
@gdb/
2012-01-23  Pedro Alves  <palves@@redhat.com>

	* top.c (caution): Update comment.
	(execute_command): Don't consider the current value of `caution'.

gdb/testsuite/
2012-01-23  Pedro Alves  <palves@@redhat.com>

	* gdb.base/call-signal-resume.exp: Allow output after "return".
@
text
@d104 1
a104 1
int caution = 1;
d107 1
a107 1
show_caution (struct ui_file *file, int from_tty,
d294 3
a296 3
  caution = 0;			/* Throw caution to the wind -- we're exiting.
				   This prevents asking the user dumb 
				   questions.  */
d1638 1
a1638 1
  add_setshow_boolean_cmd ("confirm", class_support, &caution, _("\
d1642 1
a1642 1
			   show_caution,
@


1.211
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d101 4
a104 1
/* Flag for whether we want all the "from_tty" gubbish printed.  */
a105 1
int caution = 1;		/* Default is yes, sigh.  */
d476 1
a476 1
	do_setshow_command (arg, from_tty & caution, c);
d480 1
a480 1
	deprecated_call_command_hook (c, arg, from_tty & caution);
d482 1
a482 1
	cmd_func (c, arg, from_tty & caution);
@


1.210
log
@gdb/gdbserver/gdbreplay: Update copyright year in version out

gdb/ChangeLog:

	* top.c (print_gdb_version): Update copyright year.

gdb/gdbserver/ChangeLog:

	* server.c (gdbserver_version): Update copyright year.
	* gdbreplay.c (gdbreplay_version): Likewise.
@
text
@d3 1
a3 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.209
log
@2011-12-16  Pedro Alves  <pedro@@codesourcery.com>

	* inf-loop.c: Include top.h.
	(inferior_event_handler): Call check_frame_language.
	* top.c (check_frame_language_change): New, factored out from ...
	(execute_command): ... this.  Use check_frame_language_change.
	* top.h (check_frame_language_change): Declare.
@
text
@d1121 1
a1121 1
		    "Copyright (C) 2011 Free Software Foundation, Inc.\n");
@


1.208
log
@	* event-top.c (async_disconnect): If an exception is thrown from
	quit_cover, call pop_all_targets.  Use TRY_CATCH instead of
	catch_errors.
	* top.c (quit_cover): Return void and take no arguments.
	* top.h (quit_cover): Update prototype.
@
text
@d365 41
a413 2
  enum language flang;
  static int warned = 0;
d500 1
a500 30
  /* Tell the user if the language has changed (except first time).
     First make sure that a new frame has been selected, in case this
     command or the hooks changed the program state.  */
  deprecated_safe_get_selected_frame ();
  if (current_language != expected_language)
    {
      if (language_mode == language_mode_auto && info_verbose)
	{
	  language_info (1);	/* Print what changed.  */
	}
      warned = 0;
    }

  /* Warn the user if the working language does not match the
     language of the current frame.  Only warn the user if we are
     actually running the program, i.e. there is a stack.  */
  /* FIXME:  This should be cacheing the frame and only running when
     the frame changes.  */

  if (has_stack_frames ())
    {
      flang = get_frame_language ();
      if (!warned
	  && flang != language_unknown
	  && flang != current_language->la_language)
	{
	  printf_filtered ("%s\n", lang_frame_mismatch_warn);
	  warned = 1;
	}
    }
@


1.208.2.1
log
@gdb/gdbserver/gdbreplay: Update copyright year in version out

gdb/ChangeLog:

	* top.c (print_gdb_version): Update copyright year.

gdb/gdbserver/ChangeLog:

	* server.c (gdbserver_version): Update copyright year.
	* gdbreplay.c (gdbreplay_version): Likewise.
@
text
@d1111 1
a1111 1
		    "Copyright (C) 2012 Free Software Foundation, Inc.\n");
@


1.208.2.2
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1986-2012 Free Software Foundation, Inc.
@


1.207
log
@2011-09-06  Pedro Alves  <pedro@@codesourcery.com>

	* event-top.h (MAXPROMPTS, struct prompts): Delete.
	(set_async_annotation_level, set_async_prompt, pop_prompt)
	(push_prompt, new_async_prompt): Delete declarations.
	* top.h (get_prompt, set_prompt): Change prototype.
	(get_prefix, set_prefix, get_suffix, set_suffix): Delete
	declarations.
	* top.c (command_loop):
	(top_prompt): New global.
	(get_prefix, set_prefix, get_suffix, ): Delete.
	(get_prompt, set_prompt): Rewrite.
	(show_new_async_prompt): Rename to ...
	(show_prompt): ... this.
	(init_main): Adjust.  Don't handle --annotate=2 here.
	* event-top.c (new_async_prompt): Delete.
	(the_prompts): Delete.
	(more_to_come): Make static.
	(display_gdb_prompt): Use top_level_prompt() to compute the top
	level prompt, and don't notify the before_prompt observers
	directly here.  Always trick readline into not trying to display
	the prompt if sync_execution and displaying the primary prompt.
	If displaying a local/secondary prompt, always show it, even if
	sync_execution is set.
	(change_annotation_level): Delete.
	(top_level_prompt): New, based on change_annotation_level.
	(push_prompt, pop_prompt): Delete.
	(async_disable_stdin): No longer pushes prompt.
	(command_line_handler): No longer pushes or pops prompt.  If more
	input is expected, call display_gdb_prompt with an explicit empty
	prompt.
	(async_stop_sig): Adjust.
	(set_async_annotation_level, set_async_prompt): Delete.
	* python/python.c (before_prompt_hook): Adjust.
@
text
@d291 2
a292 2
/* static */ int
quit_cover (void *s)
a297 1
  return 0;
@


1.206
log
@2011-09-05  Pedro Alves  <pedro@@codesourcery.com>

	* inf-loop.c (execute_command): Don't check if the current thread
	if running before synchronously waiting for command completion.
	* infrun.c (fetch_inferior_event): Handle "set exec-done-display"
	here.
	(normal_stop): Call async_enable_stdin here.
	* inf-loop.c (inferior_event_handler): Don't call
	async_enable_stdin, nor handle "set exec-done-display" here.
@
text
@d557 1
a557 1
	(*window_hook) (instream, get_prompt (0));
d566 1
a566 1
				    get_prompt (0) : (char *) NULL,
d1148 3
a1150 1
/* get_prefix: access method for the GDB prefix string.  */
d1152 1
a1152 28
char *
get_prefix (int level)
{
  return PREFIX (level);
}

/* set_prefix: set method for the GDB prefix string.  */

void
set_prefix (const char *s, int level)
{
  /* If S is NULL, just free the PREFIX at level LEVEL and set to
     NULL.  */
  if (s == NULL)
    {
      xfree (PREFIX (level));
      PREFIX (level) = NULL;
    }
  else
    {
      char *p = xstrdup (s);

      xfree (PREFIX (level));
      PREFIX (level) =  p;
    }
}

/* get_suffix: access method for the GDB suffix string.  */
d1155 1
a1155 9
get_suffix (int level)
{
  return SUFFIX (level);
}

/* set_suffix: set method for the GDB suffix string.  */

void
set_suffix (const char *s, int level)
d1157 1
a1157 14
  /* If S is NULL, just free the SUFFIX at level LEVEL and set to
     NULL.  */
  if (s == NULL)
    {
      xfree (SUFFIX (level));
      SUFFIX (level) = NULL;
    }
  else
    {
      char *p = xstrdup (s);

      xfree (SUFFIX (level));
      SUFFIX (level) =  p;
    }
d1160 1
a1160 7
 /* get_prompt: access method for the GDB prompt string.  */

char *
get_prompt (int level)
{
  return PROMPT (level);
}
d1163 1
a1163 1
set_prompt (const char *s, int level)
d1165 1
a1165 13
  /* If S is NULL, just free the PROMPT at level LEVEL and set to
     NULL.  */
  if (s == NULL)
    {
      xfree (PROMPT (level));
      PROMPT (level) = NULL;
    }
  else
    {
      char *p = xstrdup (s);

      xfree (PROMPT (0));
      PROMPT (0) = p;
d1167 2
a1168 8
      if (level == 0)
	{
	  /* Also, free and set new_async_prompt so prompt changes sync up
	     with set/show prompt.  */
	    xfree (new_async_prompt);
	    new_async_prompt = xstrdup (PROMPT (0));
	  }
      }
d1522 2
a1523 2
show_new_async_prompt (struct ui_file *file, int from_tty,
		       struct cmd_list_element *c, const char *value)
d1555 4
a1558 6
  /* initialize the prompt stack to a simple "(gdb) " prompt or to
     whatever the DEFAULT_PROMPT is.  */
  the_prompts.top = 0;
  PREFIX (0) = "";
  set_prompt (DEFAULT_PROMPT, 0);
  SUFFIX (0) = "";
a1562 6
  /* If gdb was started with --annotate=2, this is equivalent to the
     user entering the command 'set annotate 2' at the gdb prompt, so
     we need to do extra processing.  */
  if (annotation_level > 1)
    set_async_annotation_level (NULL, 0, NULL);

d1581 1
a1581 1
			  &new_async_prompt,
d1584 2
a1585 2
			  NULL, set_async_prompt,
			  show_new_async_prompt,
d1641 1
a1641 1
			    set_async_annotation_level,
@


1.205
log
@2011-09-02  Pedro Alves  <pedro@@codesourcery.com>

	* top.c: Include interps.h.
	(execute_command): If the target can async, but the interpreter is
	in sync mode, synchronously wait for the command to finish before
	returning.
	(execute_command_to_string): Force the interpreter to sync mode.
	* infrun.c: Include interps.h.
	(fetch_inferior_event): Don't restore the prompt yet if the
	interpreter is in sync mode.
	* interps.c (interpreter_async): New global.
	* interps.h (interpreter_async): Declare.
	* inf-loop.c: Include interps.h.
	(inferior_event_handler): Don't print the language change or run
	breakpoint commands yet if the interpreter in is sync mode.
	* main.c (captured_command_loop): Flip the interpreter to async
	mode.
	* cli/cli-script.c: Include interps.h.
	(execute_user_command, while_command, if_command): Force the
	interpreter to sync mode.
	* python/python.c: Include interps.h.
	(python_command, execute_gdb_command): Force the interpreter to
	sync mode.
@
text
@d450 1
a450 1
      if (!interpreter_async && sync_execution && is_running (inferior_ptid))
@


1.204
log
@gdb/
	* breakpoint.c (bpstat_do_actions): New variable cleanup_if_error, call
	make_bpstat_clear_actions_cleanup and discard_cleanups for it.
	* defs.h (make_bpstat_clear_actions_cleanup): New declaration.
	* exceptions.c (throw_exception): Remove the bpstat_clear_actions call.
	* inf-loop.c (inferior_event_handler): New variable cleanup_if_error,
	call make_bpstat_clear_actions_cleanup and discard_cleanups for it.
	Call bpstat_clear_actions for failed fetch_inferior_event_wrapper.
	* infrun.c (fetch_inferior_event): Call
	make_bpstat_clear_actions_cleanup.
	* top.c (execute_command): New variable cleanup_if_error, call
	make_bpstat_clear_actions_cleanup and discard_cleanups for it.
	* utils.c (do_bpstat_clear_actions_cleanup)
	(make_bpstat_clear_actions_cleanup): New functions.

gdb/testsuite/
	* gdb.base/commands.exp (error_clears_commands_left): New function.
	(): Call it.
@
text
@d51 1
d445 12
a456 1
       
d512 3
@


1.203
log
@2011-08-04  Pedro Alves  <pedro@@codesourcery.com>

	* event-loop.c (gdb_do_one_event): Remove `data' parameter.
	(start_event_loop): Use TRY_CATCH instead of catch_errors.
	* event-loop.h (gdb_do_one_event): Remove `data' parameter.
	* top.c (gdb_readline_wrapper): Adjust.
	* tui/tui-interp.c (tui_command_loop):
	(_initialize_tui_interp): Don't install it.
@
text
@d371 1
a371 1
  struct cleanup *cleanup;
d377 1
d481 2
a482 1
    do_cleanups (cleanup);
@


1.202
log
@2011-08-04  Pedro Alves  <pedro@@codesourcery.com>

	* ui-out.h (uiout): Rename to ...
	(current_uiout): ... this.
	* ui-out.c (uiout): Rename to ...
	(current_uiout): ... this.
	* ada-lang.c (print_it_exception, print_one_exception)
	(print_mention_exception): Adjust.
	* breakpoint.c (watchpoint_check): Adjust.
	(print_breakpoint_location, print_one_breakpoint, breakpoint_1)
	(default_collect_info, watchpoints_info, print_one_catch_fork)
	(print_one_catch_vfork, print_one_catch_syscall)
	(print_one_catch_exec, mention, print_it_ranged_breakpoint)
	(print_one_ranged_breakpoint, print_mention_ranged_breakpoint)
	(print_it_watchpoint, print_mention_watchpoint)
	(print_it_masked_watchpoint, print_mention_masked_watchpoint)
	(print_it_exception_catchpoint, print_one_exception_catchpoint)
	(print_mention_exception_catchpoint, say_where, bkpt_print_it)
	(bkpt_print_mention, momentary_bkpt_print_it)
	(tracepoint_print_mention, update_static_tracepoint)
	(tracepoints_info, save_breakpoints): Adjust.
	* cli-out.c (field_separator): Adjust.
	* cp-abi.c (list_cp_abis, show_cp_abi_cmd): Adjust.
	* exceptions.c (catch_exceptions_with_msg, catch_errors): Adjust.
	* frame.c (get_current_frame): Adjust.
	* infcmd.c (run_command_1, print_return_value): Adjust.
	* inferior.c (inferior_command, info_inferiors_command): Adjust.
	* infrun.c (print_end_stepping_range_reason): Adjust.
	(print_signal_exited_reason, print_exited_reason): Adjust.
	(print_signal_received_reason, print_no_history_reason): Adjust.
	* interps.c (interp_set): Adjust.
	* osdata.c (info_osdata_command): Adjust.
	* progspace.c (maintenance_info_program_spaces_command): Adjust.
	* remote-fileio.c (remote_fileio_request): Adjust.
	* remote.c (show_remote_cmd): Adjust.
	* solib.c (info_sharedlibrary_command): Adjust.
	* source.c (print_source_lines_base): Adjust.
	* stack.c (print_stack_frame): Adjust.
	(do_gdb_disassembly, print_frame_info, print_frame): Adjust.
	* symfile-mem.c (add_vsyscall_page): Adjust.
	* symfile.c (load_progress, generic_load)
	(print_transfer_performance): Adjust.
	* thread.c (info_threads_command, restore_selected_frame)
	(thread_command): Adjust.
	* top.c (make_cleanup_restore_ui_file): Adjust.
	* tracepoint.c (tvariables_info_1, trace_status_mi, tfind_1)
	(print_one_static_tracepoint_marker): Adjust.
	* cli/cli-cmds.c (print_disassembly): Adjust.
	* cli/cli-decode.c (print_doc_line): Adjust.
	* cli/cli-interp.c (safe_execute_command): Adjust.
	* cli/cli-logging.c (set_logging_redirect, pop_output_files)
	(handle_redirections): Adjust.
	* cli/cli-script.c (show_user_1): Adjust.
	* cli/cli-setshow.c (do_setshow_command, cmd_show_list): Adjust.
	* mi/mi-cmd-break.c (breakpoint_notify): Adjust.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Adjust.
	* mi/mi-cmd-env.c (mi_cmd_env_pwd, mi_cmd_env_path)
	(mi_cmd_env_dir): Adjust.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(print_partial_file_name, mi_cmd_file_list_exec_source_files): Adjust.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_depth, mi_cmd_stack_list_args)
	(list_args_or_locals): Adjust.
	* mi/mi-cmd-var.c (print_varobj, mi_cmd_var_create)
	(mi_cmd_var_delete, mi_cmd_var_set_format, mi_cmd_var_set_frozen)
	(mi_cmd_var_show_format, mi_cmd_var_info_num_children)
	(mi_cmd_var_list_children, mi_cmd_var_info_type)
	(mi_cmd_var_info_path_expression, mi_cmd_var_info_expression)
	(mi_cmd_var_show_attributes, mi_cmd_var_evaluate_expression)
	(mi_cmd_var_assign, mi_cmd_var_update, varobj_update_one): Adjust.
	* mi/mi-interp.c (mi_on_normal_stop): Adjust.
	* mi/mi-main.c (mi_cmd_gdb_exit, mi_cmd_thread_select)
	(mi_cmd_thread_list_ids, mi_cmd_thread_info, print_one_inferior)
	(list_available_thread_groups, mi_cmd_list_thread_groups)
	(mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers)
	(mi_cmd_data_list_register_values, get_register)
	(mi_cmd_data_evaluate_expression, mi_cmd_data_read_memory)
	(mi_cmd_data_read_memory_bytes, mi_cmd_list_features)
	(mi_cmd_list_target_features, mi_cmd_add_inferior)
	(mi_execute_command, mi_load_progress): Adjust.
	* mi/mi-symbol-cmds.c (mi_cmd_symbol_list_lines): Adjust.
	* python/py-auto-load.c (print_script, info_auto_load_scripts):
	Adjust.
	* python/py-breakpoint.c (bppy_get_commands): Adjust.
	* tui/tui-interp.c (tui_command_loop): Adjust.
	* tui/tui-io.c (tui_setup_io, tui_initialize_io): Adjust.
@
text
@d800 1
a800 2
  /* gdb_do_one_event argument is unused.  */
  while (gdb_do_one_event (NULL) >= 0)
@


1.201
log
@2011-07-22  Phil Muldoon  <pmuldoon@@redhat.com>

	* event-top.c (cli_command_loop): Use get_prompt, get_suffix,
	get_prefix.
	(display_gdb_prompt): Likewise.
	(change_annotation_level): Likewise.
	(push_prompt): Likewise.
	(pop_prompt): Likewise.
	(handle_stop_sig): Use get_prompt with a level.
	* top.c (command_loop): Use get_prompt with a level.
	(set_async_annotation_level): Use set_prompt with a level.
	(get_prefix): New function.
	(set_prefix): Ditto.
	(set_suffix): Ditto.
	(get_suffix): Ditto.
	(get_prompt): Accept a level argument.
	(set_prompt): Accept a level argument.  Free old prompts.  Set
	new_async_prompt if level is 0.
	(init_main): Use set_prompt with a level.  Do not set
	new_async_prompt.
	* event-top.h (PROMPT, SUFFIX, PREFIX): Move to top.c
	* top.h: Declare set_suffix, get_suffix, set_prefix, get_prefix.
	Modify set_prompt, get_prompt to account for levels.
	* tui/tui-interp.c (tui_command_loop): Use get_prompt with a
	level
	* python/python.c (before_prompt_hook): Use set_prompt.
@
text
@d507 1
a507 1
  if (ui_out_redirect (uiout, str_file) < 0)
d510 1
a510 1
    make_cleanup_ui_out_redirect_pop (uiout);
@


1.200
log
@2011-07-21  Phil Muldoon  <pmuldoon@@redhat.com>
            Tom Tromey  <tromey@@redhat.com>

	* top.c (set_prompt): Rewrite to free previous prompt, free
	asynch_new_prompt and set both on new prompts.
	* event-top.c (display_gdb_prompt): Add prompt substitution
	logic.
	* python/python.c (before_prompt_hook): New function.

2011-07-21  Phil Muldoon  <pmuldoon@@redhat.com>

	* gdb.python/python.exp: Add prompt substitution tests.

2011-07-21  Phil Muldoon  <pmuldoon@@redhat.com>

	* observer.texi (GDB Observers): Add before_prompt observer.
	* gdb.texinfo (Basic Python): Add documentation for prompt
	substitution.
@
text
@d68 4
d540 1
a540 1
	(*window_hook) (instream, get_prompt ());
d549 1
a549 1
				    get_prompt () : (char *) NULL,
d1131 2
a1132 1
/* get_prompt: access method for the GDB prompt string.  */
d1135 1
a1135 1
get_prompt (void)
d1137 1
a1137 1
  return PROMPT (0);
d1140 2
d1143 22
a1164 1
set_prompt (const char *s)
d1166 2
a1167 1
  char *p = xstrdup (s);
d1169 1
a1169 2
  xfree (PROMPT (0));
  PROMPT (0) = p;
d1171 52
a1222 4
  /* Also, free and set new_async_prompt so prompt changes sync up
     with set/show prompt.  */
  xfree (new_async_prompt);
  new_async_prompt = xstrdup (PROMPT (0));
d1613 1
a1613 1
  PROMPT (0) = xstrdup (DEFAULT_PROMPT);
a1617 2
  /* Set the variable associated with the setshow prompt command.  */
  new_async_prompt = xstrdup (PROMPT (0));
@


1.199
log
@	* valops.c (find_overload_match): Call do_cleanups before early
	return.
	* top.c (execute_command): Call do_cleanups before early return.
	(command_loop): Likewise.
	* stack.c (backtrace_command): Make a null cleanup early.  Don't
	conditionally call do_cleanups.
	* python/py-value.c (TRY_CATCH): Move cleanup handling into
	TRY_CATCH.
	* python/py-breakpoint.c (gdbpy_breakpoint_has_py_cond): Rearrange
	so cleanups are always run.
	* mi/mi-cmd-var.c (mi_cmd_var_delete): Reset old_cleanups.
	* findcmd.c (parse_find_args): Call do_cleanups on early return
	path.
	* dbxread.c (elfstab_build_psymtabs): Make a null cleanup early.
	Don't conditionally call do_cleanups.
	* cli/cli-script.c (execute_user_command): Initialize 'old_chain'
	later.
@
text
@d1136 1
a1136 1
set_prompt (char *s)
d1138 9
a1146 6
/* ??rehrauer: I don't know why this fails, since it looks as though
   assignments to prompt are wrapped in calls to xstrdup...
   if (prompt != NULL)
     xfree (prompt);
 */
  PROMPT (0) = xstrdup (s);
@


1.198
log
@2011-06-13  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* top.h (line): Rename to ...
	(saved_command_line): ... this.
	(linesize): Rename to ...
	(saved_command_line_size): ... this.
	* top.c (line): Rename to ...
	(saved_command_line): ... this.
	(linesize): Rename to ...
	(saved_command_line_size): ... this.
	(dont_repeat, command_line_input, dont_repeat_command): Adjust.
	* event-top.c (command_line_handler): Adjust.
	* main.c (captured_main): Adjust.
@
text
@d381 4
a384 1
    return;
d548 4
a551 1
	return;
@


1.197
log
@gdb/
	* mi/mi-main.c (mi_cmd_execute): Use cleanup from
	prepare_execute_command.
	* top.c (prepare_execute_command): Return cleanup.
	(execute_command): Use cleanup from prepare_execute_command.
	* top.h (prepare_execute_command): Change prototype to return
	cleanup.
	* defs.h (struct value): Add opaque declaration.
	(make_cleanup_value_free_to_mark): Add prototype.
	* utils.c (do_value_free_to_mark): New function.
	(make_cleanup_value_free_to_mark): Likewise.

gdb/testsuite/
	* gdb.python/py-function.exp: Test setting a value from a function
	which executes a command.
@
text
@d140 2
a141 2
char *line;
int linesize = 100;
d575 1
a575 1
    *line = 0;
d1037 1
a1037 1
    return line;
d1040 1
a1040 1
    return line;
d1061 1
a1061 1
      if (linelength > linesize)
d1063 2
a1064 2
	  line = xrealloc (line, linelength);
	  linesize = linelength;
d1066 2
a1067 2
      strcpy (line, linebuffer);
      return line;
d1317 3
a1319 2
  *line = 0;			/* Can't call dont_repeat here because we're 
				   not necessarily reading from stdin.  */
@


1.196
log
@gdb
	* windows-tdep.c (windows_xfer_shared_library):
	* windows-nat.c (get_module_name, windows_make_so):
	* v850-tdep.c (v850_handle_pushm):
	* utils.c (null_cleanup, gdb_realpath):
	* ui-out.c (get_next_header):
	* tracepoint.c (clear_traceframe_info):
	* symtab.c (lookup_symtab):
	* serial.h (struct serial_ops):
	* mipsread.c (read_alphacoff_dynamic_symtab):
	* infcmd.c (print_return_value):
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address):
	* f-exp.y (parse_number):
	* exceptions.c (catch_exceptions):
	* dummy-frame.c (dummy_frame_this_id):
	* defs.h (struct cleanup):
	* breakpoint.c (disable_breakpoints_in_unloaded_shlib):
	* arm-tdep.c (arm_push_dummy_call):
	* amd64-tdep.h (amd64_collect_xsave):
	* amd64-tdep.c (amd64_collect_xsave):
	* alpha-tdep.c (alpha_heuristic_frame_unwind_cache):
	* README (typing): Remove duplicate words.
	* cli/cli-decode.c (lookup_cmd_composition): Add comma.
	* infrun.c (siginfo_value_read): Fix typo.
	* solib-frv.c (frv_fdpic_find_global_pointer): Likewise.
	* top.c (source_line_number): Add comma.
gdb/doc
	* gdbint.texinfo (Register Information Functions): Remove
	duplicate "the".
	* gdb.texinfo (Emacs): Remove duplicate "to".
	(GDB/MI Variable Objects): Remove duplicate "the".
	(General Query Packets): Likewise.
gdb/testsuite
	* gdb.mi/mi-nsmoribund.exp:
	* gdb.hp/gdb.objdbg/objdbg01.exp:
	* gdb.base/structs.exp (test_struct_returns):
	* gdb.base/call-sc.exp (test_scalar_returns):
	* gdb.base/bigcore.exp: Remove duplicate words.
gdb/gdbserver
	* win32-low.c (handle_load_dll): Remove duplicate "the".
@
text
@d342 1
a342 1
void
d345 5
a349 1
  free_all_values ();
d357 2
d367 1
d373 1
a373 1
  prepare_execute_command ();
d472 2
@


1.195
log
@2011-03-11  Michael Snyder  <msnyder@@vmware.com>

	* cli/cli-decode.h (CMD_LIST_AMBIGUOUS): Define.
	* cli/cli-decode.c (lookup_cmd_1): Use CMD_LIST_AMBIGUOUS.
	(lookup_cmd): Test for CMD_LIST_AMBIGUOUS.
	* completer.c (complete_line_internal): Use CMD_LIST_AMBIGUOUS.
	* top.c (set_verbose): Use CMD_LIST_AMBIGUOUS.
@
text
@d297 1
a297 1
/* Line number we are currently in in a file which is being sourced.  */
@


1.194
log
@2011-03-11  Michael Snyder  <msnyder@@vmware.com>

	* top.c (set_verbose): Assert showcmd was found.
@
text
@d1428 1
a1428 2
  gdb_assert (showcmd != NULL
	      && showcmd != (struct cmd_list_element *) -1);
@


1.193
log
@	PR python/12216:
	* python/python.c (execute_gdb_command): Call
	prevent_dont_repeat.
	* top.c (suppress_dont_repeat): New global.
	(dont_repeat): Use it.
	(prevent_dont_repeat): New function.
	* command.h (prevent_dont_repeat): Declare.
@
text
@d1428 2
@


1.192
log
@move handing of "set interactive-mode" to gdb_has_a_terminal

The real purpose of this setting is really to override what the debugger
would otherwise guess from checking the stdin settings.  So it seems
more natural to see this setting being handled inside gdb_has_a_terminal
rather than input_is_terminal (which checks for other things, such as
whether the input is stdin, for instance).

This patch also adjust the command help and the associated section in
the GDB Manual to be a little clearer about that.

gdb/ChangeLog:

        * inflow.c: Include "gdbcmd.h".
        (interactive_mode): New static global, moved here from top.c.
        (show_interactive_mode): New function, moved here from top.c.
        use gdb_has_a_terminal instead of input_from_terminal_p to
        determine the current mode.
        (gdb_has_a_terminal): Add handling of the "iteractive-mode"
        setting.
        (_initialize_inflow): Add the "set/show interactive-mode"
        commands.  Moved here from top.c, after having adjusted slightly
        the help text.
        * top.c (interactive_mode, show_interactive_mode): Delete, moved
        to inflow.c.
        (input_from_terminal_p): Remove handling of "interactive-mode"
        setting, moved to infow.c.
        (init_main): Remove creation of the "set/show interactive-mode"
        commands, moved to inflow.c.

gdb/doc/ChangeLog:

        * gdb.texinfo (Other Misc Settings): Rework part of the
        documentation of the "set interactive mode" command.
@
text
@d549 5
d559 1
a559 1
  if (server_command)
d568 13
@


1.191
log
@problem sourcing GDB script in interactive-mode on

When interactive-mode is not auto, GDB always uses that setting to
determine whether to act as if the input stream is a terminal or not.
However, this setting should only be honored if the input stream is
the standard input stream.  Otherwise, we run into trouble while
source-ing a GDB script, as shown below (on x86_64-linux):

        % cat script
        print 1
        print 2
        % gdb  -q
        (gdb) set interactive-mode on
        (gdb) source script
        (gdb) print 3
        $1 = 3

The lack of output and the fact that the "print 3" command returned
a value saved in $1 (as opposed to $3) indicates that the script was
not even evaluated at all.

gdb/ChangeLog:

        * top.c (input_from_terminal_p): Restrict the use of interactive_mode
        to the case where instream is stdin.

gdb/testsuite/ChangeLog:

        * gdb.base/interact.exp: New testcase.
@
text
@a1265 23
/* If OFF, the debugger will run in non-interactive mode, which means
   that it will automatically select the default answer to all the
   queries made to the user.  If ON, gdb will wait for the user to
   answer all queries.  If AUTO, gdb will determine whether to run
   in interactive mode or not depending on whether stdin is a terminal
   or not.  */
static enum auto_boolean interactive_mode = AUTO_BOOLEAN_AUTO;

/* Implement the "show interactive-mode" option.  */

static void
show_interactive_mode (struct ui_file *file, int from_tty,
                       struct cmd_list_element *c,
                       const char *value)
{
  if (interactive_mode == AUTO_BOOLEAN_AUTO)
    fprintf_filtered (file, "Debugger's interactive mode "
		      "is %s (currently %s).\n",
                      value, input_from_terminal_p () ? "on" : "off");
  else
    fprintf_filtered (file, "Debugger's interactive mode is %s.\n", value);
}

a1271 3
  if (interactive_mode != AUTO_BOOLEAN_AUTO && instream == stdin)
    return interactive_mode == AUTO_BOOLEAN_TRUE;

a1603 12
  add_setshow_auto_boolean_cmd ("interactive-mode", class_support,
                                &interactive_mode, _("\
Set whether GDB should run in interactive mode or not"), _("\
Show whether GDB runs in interactive mode"), _("\
If on, run in interactive mode and wait for the user to answer\n\
all queries.  If off, run in non-interactive mode and automatically\n\
assume the default answer to all queries.  If auto (the default),\n\
determine which mode to use based on the standard input settings"),
                        NULL,
                        show_interactive_mode,
                        &setlist, &showlist);

@


1.190
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d1295 1
a1295 1
  if (interactive_mode != AUTO_BOOLEAN_AUTO)
@


1.189
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d253 1
a253 1
/* Tell the GUI someone changed the register REGNO. -1 means
d285 1
a285 1
   event-top.c into this file, top.c */
d300 1
a300 1
   event-top.c into this file, top.c */
d306 1
a306 1
   event-top.c into this file, top.c */
d531 1
a531 1
      /* Get a command-line. This calls the readline package.  */
d633 1
a633 1
   event-top.c into this file, top.c */
d1695 1
a1695 1
  /* Allow another UI to initialize. If the UI fails to initialize,
@


1.188
log
@run copyright.sh for 2011.
@
text
@d105 2
a106 2
  fprintf_filtered (file, _("\
Whether to confirm potentially dangerous operations is %s.\n"),
d660 2
a661 2
  fprintf_filtered (file, _("\
The filename in which to record the command history is \"%s\".\n"),
d993 2
a994 1
	      return command_line_input (prompt_arg, repeat, annotation_suffix);
d1058 2
a1059 1
  fprintf_filtered (stream, "Copyright (C) 2011 Free Software Foundation, Inc.\n");
d1067 2
a1068 2
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n\
This is free software: you are free to change and redistribute it.\n\
d1077 2
a1078 1
      fprintf_filtered (stream, "--host=%s --target=%s", host_name, target_name);
d1282 2
a1283 2
    fprintf_filtered (file, "\
Debugger's interactive mode is %s (currently %s).\n",
d1415 2
a1416 1
  printf_unfiltered (_("\"set history\" must be followed by the name of a history subcommand.\n"));
d1498 2
a1499 2
  fprintf_filtered (file, _("\
Editing of command lines as they are typed is %s.\n"),
d1514 2
a1515 2
  fprintf_filtered (file, _("\
Notification of completion for asynchronous execution commands is %s.\n"),
d1557 4
a1560 4
			  &new_async_prompt, _("\
Set gdb's prompt"), _("\
Show gdb's prompt"), NULL,
			  set_async_prompt,
d1565 2
a1566 2
Don't repeat this command.\n\
Primarily used inside of user-defined commands that should not be repeated when\n\
@


1.187
log
@Update copyright year in version of output (gdb/gdbserver/gdbreplay)

gdb/ChangeLog:

       * top.c (print_gdb_version): Update copyright year in version output.

gdb/gdbserverChangeLog:

       * server.c (gdbserver_version): Update copyright year in version
       output.
       * gdbreplay.c (gdbreplay_version): Ditto.
@
text
@d5 1
a5 1
   2008, 2009, 2010 Free Software Foundation, Inc.
@


1.186
log
@2010-12-28  Michael Snyder  <msnyder@@vmware.com>

	* event-loop.c: Comment clean-up.
	* event-loop.h: Ditto.
	* event-top.c: Ditto.
	* gdb.c: Ditto.
	* gdb.h: Ditto.
	* main.c: Ditto.
	* top.c: Ditto.
	* top.h: Ditto.
@
text
@d1057 1
a1057 1
  fprintf_filtered (stream, "Copyright (C) 2010 Free Software Foundation, Inc.\n");
@


1.185
log
@	* top.c: #include "python/python.h".
	(gdb_init): Add a comment regarding initialize_all_files.
	Call finish_python_initialization at the end.
	* python/python.h (finish_python_initialization): Declare.
	* python/python.c (finish_python_initialization): New function.
	(_initialize_python): Move python-implemented initialization there
	and call it.
	(GdbMethods): Use #ifdef HAVE_PYTHON for consistency.
@
text
@d52 1
a52 1
/* readline include files */
d68 1
a68 1
/* Default command line prompt.  This is overriden in some configs. */
d100 1
a100 1
int caution = 1;		/* Default is yes, sigh. */
d110 4
a113 3
/* stdio stream that command input is being read from.  Set to stdin normally.
   Set by source_command to the file we are sourcing.  Set to NULL if we are
   executing a user-defined command or interacting via a GUI.  */
d153 2
a154 2
/* FIXME: This means that "show remotebaud" and gr_files_info can print -1
   or (unsigned int)-1.  This is a Bad User Interface.  */
d158 1
a158 1
/* Timeout limit for response from target. */
d176 1
a176 1
   back to 2 seconds in 1999. */
d191 2
a192 2
/* Called after most modules have been initialized, but before taking users
   command file.
d194 2
a195 2
   If the UI fails to initialize and it wants GDB to continue
   using the default UI, then it should clear this hook before returning. */
d199 4
a202 3
/* This hook is called from within gdb's many mini-event loops which could
   steal control from a real user interface's event loop. It returns
   non-zero if the user is requesting a detach, zero otherwise. */
d214 4
a217 2
void (*deprecated_print_frame_info_listing_hook) (struct symtab * s, int line,
						  int stopline, int noerror);
d243 1
a243 1
   to or detached from an already running process. */
d248 2
a249 2
/* Called during long calculations to allow GUI to repair window damage, and to
   check for stop buttons, etc... */
d255 1
a255 1
   that several registers have changed (see value_assign). */
d258 2
a259 2
/* Called when going to wait for the target.  Usually allows the GUI to run
   while waiting for target events.  */
d265 2
a266 2
/* Used by UI as a wrapper around command execution.  May do various things
   like enabling/disabling buttons, etc...  */
d268 2
a269 2
void (*deprecated_call_command_hook) (struct cmd_list_element * c, char *cmd,
				      int from_tty);
d290 2
a291 1
				   This prevents asking the user dumb questions.  */
d347 4
a350 4
  /* With multiple threads running while the one we're examining is stopped,
     the dcache can get stale without us being able to detect it.
     For the duration of the command, though, use the dcache to help
     things like backtrace.  */
d413 1
a413 1
      /* If this command has been pre-hooked, run the hook first. */
d430 1
a430 1
      /* If this command has been post-hooked, run the hook last. */
d450 1
a450 1
     actually running the program, i.e. there is a stack. */
d531 1
a531 1
      /* Get a command-line. This calls the readline package. */
d558 2
a559 2
     thing read from stdin in line and don't want to delete it.  Null lines
     won't repeat here in any case.  */
d888 3
a890 2
      /* Make sure that all output has been output.  Some machines may let
         you get away with leaving out some of the gdb_flush, but not all.  */
d940 1
a940 1
         if this was just a newline)  */
d1006 2
a1007 3
  /* If we just got an empty line, and that is supposed
     to repeat the previous command, return the value in the
     global buffer.  */
d1028 1
a1028 1
    *p1 = '\0';			/* Found a comment. */
d1045 1
a1045 1
/* Print the GDB banner. */
d1051 1
a1051 1
     number, which starts after last space. */
d1055 1
a1055 1
  /* Second line is a copyright notice. */
d1062 1
a1062 1
     there is no warranty. */
d1070 1
a1070 1
  /* After the required info we print the configuration information. */
d1105 1
a1105 1
   xfree (prompt);
d1229 2
a1230 2
  do_final_cleanups (ALL_CLEANUPS);	/* Do any final cleanups before exiting */

d1243 1
a1243 1
     value of that expression. */
d1313 2
a1314 2
  *line = 0;			/* Can't call dont_repeat here because we're not
				   necessarily reading from stdin.  */
d1422 1
a1422 1
int info_verbose = 0;		/* Default verbose msgs off */
d1446 3
a1448 4
 * have been read so that the user can change the history file via his
 * .gdbinit file (for instance).  The GDBHISTFILE environment variable
 * overrides all of this.
 */
d1654 1
a1654 1
  /* Run the init function of each source file */
d1662 3
a1664 3
  init_cmd_lists ();		/* This needs to be done first */
  initialize_targets ();	/* Setup target_terminal macros for utils.c */
  initialize_utils ();		/* Make errors and warnings possible */
d1678 1
a1678 1
  init_main ();			/* But that omits this file!  Do it now */
d1684 4
a1687 3
  /* We need a default language for parsing expressions, so simple things like
     "set width 0" won't fail if no language is explicitly set in a config file
     or implicitly set by reading an executable during startup. */
d1689 1
a1689 1
  expected_language = current_language;		/* don't warn about the change.  */
d1698 4
a1701 4
  /* Python initialization can require various commands to be installed.
     For example "info pretty-printer" needs the "info" prefix to be
     installed.  Keep things simple and just do final python initialization
     here.  */
@


1.184
log
@gdb/
	Redirect also uiout and stdtarg{,err} in execute_command_to_string.
	* cli-logging.c (struct saved_output_files) <targerr>: New.
	(set_logging_redirect, pop_output_files, handle_redirections):
	Redirect also gdb_stdtargerr.
	* defs.h (struct ui_out, make_cleanup_ui_out_redirect_pop): New
	declarations.
	* event-top.c (gdb_setup_readline, gdb_disable_readline): Redirect
	also gdb_stdtargerr.
	* top.c (execute_command_to_string): Move make_cleanup_ui_file_delete
	to the top.  Redirect also gdb_stdlog, gdb_stdtarg and gdb_stdtargerr.
	Use ui_out_redirect, register make_cleanup_ui_out_redirect_pop.
	* tui/tui-io.c (tui_setup_io): Redirect also gdb_stdtargerr.
	* utils.c (do_ui_out_redirect_pop, make_cleanup_ui_out_redirect_pop):
	New functions.

gdb/testsuite/
	* gdb.python/python.exp (set height 0, collect help from uiout)
	(verify help to uiout): New tests.
@
text
@d50 1
d1661 2
d1664 1
d1691 8
@


1.183
log
@gdb/
	* defs.h (make_cleanup_restore_uinteger, make_cleanup_restore_ui_file)
	(make_cleanup_restore_page_info)
	(set_batch_flag_and_make_cleanup_restore_page_info): New declarations.
	* gdbcmd.h (execute_command_to_string): New declaration.
	* python/python.c (struct restore_ui_file_closure, restore_ui_file)
	(make_cleanup_restore_ui_file): Move to utils.c
	(execute_gdb_command) <to_string>: Move ...
	* top.c (execute_command_to_string): ... here.  Call
	set_batch_flag_and_make_cleanup_restore_page_info.
	* utils.c (make_cleanup_restore_integer): New source file blank line.
	(make_cleanup_restore_uinteger): New.
	(struct restore_ui_file_closure, do_restore_ui_file)
	(make_cleanup_restore_ui_file): Move here from python/python.c.
	(init_page_info) <batch_flag>
	(do_restore_page_info_cleanup, make_cleanup_restore_page_info)
	(set_batch_flag_and_make_cleanup_restore_page_info): New.

gdb/testsuite/
	* gdb.python/python.exp (show height, set height 10)
	(verify pagination beforehand, verify pagination beforehand: q)
	(gdb.execute does not page, verify pagination afterwards)
	(verify pagination afterwards: q): New.

gdb/doc/
	* gdb.texinfo (Mode Options) <-batch>
	(Basic Python) <gdb.execute>: Describe setting width and height.
@
text
@d478 1
d481 8
a488 1
  make_cleanup_ui_file_delete (str_file);
d492 3
@


1.182
log
@gdb/
	* top.c (input_from_terminal_p): Return 0 on BATCH_FLAG.
	* utils.c (defaulted_query): Do not explicitly check for BATCH_FLAG.
	(fputs_maybe_filtered): Do not do filtering also on
	! INPUT_FROM_TERMINAL_P.
@
text
@d461 33
@


1.181
log
@Refactor 'maint time' command statistics.

Consolidate code for displaying per-command time and space statistics to avoid
duplication.  Piggyback on cleanups so that statistics get printed even when
commands terminate as a result of an error.

Changelog

    * gdb/defs.h (make_command_stats_cleanup): Declare.
    (set_display_time): Declare.
    (set_display_space): Declare.
    * gdb/event-top.c (command_handler): Use make_command_stats_cleanup.
    * gdb/main.c (display_time, display_space): Move definitions to utils.c.
    (captured_main): Use make_command_stats_cleanup to get start-up
    statistics.
    Use set_display_time and set_display_space for processing OPT_STATISTICS
    case.
    * gdb/maint.c (maintenance_time_display): Use set_display_time.
    (maintenance_space_display): Use set_display_space.
    * gdb/top.c (execute_command): Remove obsolete 'maint time' code.
    (command_loop): Use make_command_stats_cleanup.
    * gdb/utils.c (struct cmd_stats): Structure for storing initial time
    and space usage.
    (display_time, display_space): Move definitions here from utils.c.
    (set_display_time): New function.
    (set_display_space): New function.
    (make_command_stats_cleanup): New function.
    (report_command_stats): New auxiliary function for
    make_command_stats_cleanup.
    * gdb/testsuite/gdb.gdb/selftest.exp: Adjust expected message for
    capturing start-up runtime.
@
text
@d1245 3
@


1.181.2.1
log
@gdb/
	* top.c (input_from_terminal_p): Return 0 on BATCH_FLAG.
	* utils.c (defaulted_query): Do not explicitly check for BATCH_FLAG.
	(fputs_maybe_filtered): Do not do filtering also on
	! INPUT_FROM_TERMINAL_P.
@
text
@a1244 3
  if (batch_flag)
    return 0;

@


1.181.2.2
log
@gdb/
	* defs.h (make_cleanup_restore_uinteger, make_cleanup_restore_ui_file)
	(make_cleanup_restore_page_info)
	(set_batch_flag_and_make_cleanup_restore_page_info): New declarations.
	* gdbcmd.h (execute_command_to_string): New declaration.
	* python/python.c (struct restore_ui_file_closure, restore_ui_file)
	(make_cleanup_restore_ui_file): Move to utils.c
	(execute_gdb_command) <to_string>: Move ...
	* top.c (execute_command_to_string): ... here.  Call
	set_batch_flag_and_make_cleanup_restore_page_info.
	* utils.c (make_cleanup_restore_integer): New source file blank line.
	(make_cleanup_restore_uinteger): New.
	(struct restore_ui_file_closure, do_restore_ui_file)
	(make_cleanup_restore_ui_file): Move here from python/python.c.
	(init_page_info) <batch_flag>
	(do_restore_page_info_cleanup, make_cleanup_restore_page_info)
	(set_batch_flag_and_make_cleanup_restore_page_info): New.

gdb/testsuite/
	* gdb.python/python.exp (show height, set height 10)
	(verify pagination beforehand, verify pagination beforehand: q)
	(gdb.execute does not page, verify pagination afterwards)
	(verify pagination afterwards: q): New.

gdb/doc/
	* gdb.texinfo (Mode Options) <-batch>
	(Basic Python) <gdb.execute>: Describe setting width and height.
@
text
@a460 33
/* Run execute_command for P and FROM_TTY.  Capture its output into the
   returned string, do not display it to the screen.  BATCH_FLAG will be
   temporarily set to true.  */

char *
execute_command_to_string (char *p, int from_tty)
{
  struct ui_file *str_file;
  struct cleanup *cleanup;
  char *retval;

  /* GDB_STDOUT should be better already restored during these
     restoration callbacks.  */
  cleanup = set_batch_flag_and_make_cleanup_restore_page_info ();

  str_file = mem_fileopen ();

  make_cleanup_restore_ui_file (&gdb_stdout);
  make_cleanup_restore_ui_file (&gdb_stderr);
  make_cleanup_ui_file_delete (str_file);

  gdb_stdout = str_file;
  gdb_stderr = str_file;

  execute_command (p, from_tty);

  retval = ui_file_xstrdup (str_file, NULL);

  do_cleanups (cleanup);

  return retval;
}

@


1.180
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* target.c: White space.
	* target-descriptions.c: White space.
	* target-memory.c: White space.
	* thread.c: White space.
	* top.c: White space.
	* tracepoint.c: White space.
	* trad-frame.c: White space.
	* tramp-frame.c: White space.
	* ui-file.c: White space.
	* ui-out.c: White space.
	* user-regs.c: White space.
	* utils.c: White space.
@
text
@a358 19
  long time_at_cmd_start = 0;
#ifdef HAVE_SBRK
  long space_at_cmd_start = 0;
#endif
  extern int display_space;

  if (target_can_async_p ())
    {
      time_at_cmd_start = get_run_time ();

      if (display_space)
	{
#ifdef HAVE_SBRK
	  char *lim = (char *) sbrk (0);

	  space_at_cmd_start = lim - lim_at_start;
#endif
	}
    }
a469 6
  long time_at_cmd_start;
#ifdef HAVE_SBRK
  long space_at_cmd_start = 0;
#endif
  extern int display_time;
  extern int display_space;
d488 1
a488 10
      time_at_cmd_start = get_run_time ();

      if (display_space)
	{
#ifdef HAVE_SBRK
	  char *lim = (char *) sbrk (0);

	  space_at_cmd_start = lim - lim_at_start;
#endif
	}
a495 23

      if (display_time)
	{
	  long cmd_time = get_run_time () - time_at_cmd_start;

	  printf_unfiltered (_("Command execution time: %ld.%06ld\n"),
			     cmd_time / 1000000, cmd_time % 1000000);
	}

      if (display_space)
	{
#ifdef HAVE_SBRK
	  char *lim = (char *) sbrk (0);

	  long space_now = lim - lim_at_start;
	  long space_diff = space_now - space_at_cmd_start;

	  printf_unfiltered (_("Space used: %ld (%s%ld for this command)\n"),
			     space_now,
			     (space_diff >= 0 ? "+" : ""),
			     space_diff);
#endif
	}
@


1.179
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* serial.c (serial_for_fd): Delete unused variable.
	* mdebugread.c (psymtab_to_symtab_1): Delete unused variable.
	* top.c (execute_command): Delete unused variable.
	(init_main): Delete unused variable.
	* utils.c (do_fclose_cleanup): Delete unused variable.
	(do_all_inferior_continuations): Delete unused variable.
	(initialize_utils): Delete unused variable.
	(internal_problem_mode): Delete unused global.
	* frame.c (get_prev_frame): Delete unused global.
	(get_frame_locals_address): Delete unused global.
	(get_frame_args_address): Delete unused global.
@
text
@d373 1
d519 1
d543 1
d791 1
@


1.178
log
@	* top.c (source_file_name): Make const char *.
	* top.h (source_file_name): Update.
	* cli/cli-script.c (source_cleanup_lines_args): Make old_file
	const char *.
	(script_from_file): Change `file' arg to const char *.
	* cli/cli-script.h (script_from_file): Update.
@
text
@a362 1
  extern int display_time;
a1517 2
  struct cmd_list_element *c;

@


1.177
log
@	* top.c (stop_sig, float_handler, do_nothing): Remove.
@
text
@d301 1
a301 1
/* static */ char *source_file_name;
@


1.176
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a186 9
/* Signal to catch ^Z typed while reading a command: SIGTSTP or SIGCONT.  */

#ifndef STOP_SIGNAL
#ifdef SIGTSTP
#define STOP_SIGNAL SIGTSTP
static void stop_sig (int);
#endif
#endif

a778 51
#ifdef STOP_SIGNAL
static void
stop_sig (int signo)
{
#if STOP_SIGNAL == SIGTSTP
  signal (SIGTSTP, SIG_DFL);
#if HAVE_SIGPROCMASK
  {
    sigset_t zero;

    sigemptyset (&zero);
    sigprocmask (SIG_SETMASK, &zero, 0);
  }
#elif HAVE_SIGSETMASK
  sigsetmask (0);
#endif
  kill (getpid (), SIGTSTP);
  signal (SIGTSTP, stop_sig);
#else
  signal (STOP_SIGNAL, stop_sig);
#endif
  printf_unfiltered ("%s", get_prompt ());
  gdb_flush (gdb_stdout);

  /* Forget about any previous command -- null line now will do nothing.  */
  dont_repeat ();
}
#endif /* STOP_SIGNAL */

/* Initialize signal handlers. */
static void
float_handler (int signo)
{
  /* This message is based on ANSI C, section 4.7.  Note that integer
     divide by zero causes this, so "float" is a misnomer.  */
  signal (SIGFPE, float_handler);
  error (_("Erroneous arithmetic operation."));
}

static void
do_nothing (int signo)
{
  /* Under System V the default disposition of a signal is reinstated after
     the signal is caught and delivered to an application process.  On such
     systems one must restore the replacement signal handler if one wishes
     to continue handling the signal in one's program.  On BSD systems this
     is not needed but it is harmless, and it simplifies the code to just do
     it unconditionally. */
  signal (signo, do_nothing);
}

@


1.175
log
@        * top.c (print_gdb_version): Update copyright year.
@
text
@d5 1
a5 1
   2008, 2009 Free Software Foundation, Inc.
@


1.174
log
@gdb/ChangeLog:

2009-12-02  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* ada-lang.c (ada_value_assign): Use observer_notify_memory_changed.
	* valops.c (value_assign): Likewise.
	* defs.h (deprecated_memory_changed_hook): Remove.
	* top.c (deprecated_memory_changed_hook): Likewise.
	* interps.c (clear_interpreter_hooks): Adjust.

gdb/gdbtk/ChangeLog:

2009-12-02  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* generic/gdbtk-hooks.c (gdbtk_memory_changed): Adjust.
	(gdbtk_add_hooks): Adjust.

gdb/doc/ChangeLog:

2009-12-02  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* observer.texi: New memory_changed observer.
@
text
@d1121 1
a1121 1
  fprintf_filtered (stream, "Copyright (C) 2009 Free Software Foundation, Inc.\n");
@


1.173
log
@	* top.c (execute_command): Select a frame before checking the current
	language.  Only output a message if verbose.
@
text
@a261 3
/* Tell the GUI someone changed LEN bytes of memory at ADDR */
void (*deprecated_memory_changed_hook) (CORE_ADDR addr, int len);

@


1.172
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d460 4
a463 1
  /* Tell the user if the language has changed (except first time).  */
d466 1
a466 1
      if (language_mode == language_mode_auto)
@


1.171
log
@        * top.c (interactive_mode): New static variable.
        (show_interactive_mode): New function.
        (input_from_terminal_p): If interactive_mode is not auto, then
        use that rather than checking the stdin settings.
        (init_main): Add "set/show interactive-mode" command.
        * NEWS: Add entry for new "set/show interactive-mode" command.
@
text
@d1190 3
d1220 3
d1730 7
@


1.170
log
@	Implement TARGET_OBJECT_STACK_MEMORY.
	* NEWS: Add note on new "set stack-cache" option.
	* corefile.c (read_stack): New function.
	* dcache.c (dcache_struct): New member ptid.
	(dcache_enable_p): Mark as obsolete.
	(show_dcache_enabled_p): Flag option as deprecated.
	(dcache_invalidate): Update ptid.
	(dcache_invalidate_line): New function.
	(dcache_read_line): No longer check cacheable attribute, stack
	accesses get cached despite attribute.
	(dcache_init): Set ptid.
	(dcache_xfer_memory): Flush cache if from different ptid than before.
	Update cache after write.
	(dcache_update): New function.
	(dcache_info): Report ptid.
	(_initialize_dcache): Update text for `remotecache' to indicate it
	is obsolete.
	* dcache.h (dcache_update): Declare.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Mark values on stack with
	set_value_stack.
	* frame-unwind.c (frame_unwind_got_memory): Ditto.
	* gdbcore.h (read_stack): Declare.
	* memattr.c (mem_enable_command): Call target_dcache_invalidate
	instead of dcache_invalidate.
	(mem_disable_command, mem_delete_command): Ditto.
	* target.c (stack_cache_enabled_p_1): New static global.
	(stack_cache_enabled_p): New static global.
	(set_stack_cache_enabled_p): New function.
	(show_stack_cache_enabled_p): New function.
	(target_dcache): Make static.
	(target_dcache_invalidate): New function.
	(target_load, target_resume): Call target_dcache_invalidate
	instead of dcache_invalidate.
	(memory_xfer_partial): New arg object, all callers updated.
	Check for existing inferior before calling dcache routines.
	When writing non-TARGET_OBJECT_STACK_MEMORY, notify dcache.
	(target_xfer_partial): Call memory_xfer_partial for
	TARGET_OBJECT_STACK_MEMORY.
	(target_read_stack): New function.
	(initialize_targets): Install new option `stack-cache'.
	* target.h: Remove #include of dcache.h.
	(enum target_object): New value TARGET_OBJECT_STACK_MEMORY.
	(target_dcache): Delete.
	(target_dcache_invalidate): Declare.
	(target_read_stack): Declare.
	* top.c (prepare_execute_command): New function.
	(execute_command): Call prepare_execute_command
	instead of free_all_values.
	* top.h (prepare_execute_command): Declare.
	* valops.c (get_value_at): New function.
	(value_at): Guts moved to get_value_at.
	(value_at_lazy): Similarly.
	(value_fetch_lazy): Call read_stack for stack values.
	* value.c (struct value): New member `stack'.
	(value_stack, set_value_stack): New functions.
	* value.h (value_stack, set_value_stack): Declare.
	* mi/mi-main.c (mi_cmd_execute): Call prepare_execute_command
	instead of free_all_values.

	doc/
	* gdb.texinfo (Caching Data of Remote Targets): Update text.
	Mark `set/show remotecache' options as obsolete.
	Document new `set/show stack-cache' option.
	Update text for `info dcache'.
@
text
@d1321 23
d1350 3
d1684 12
@


1.169
log
@	* top.c (execute_command): Remove redundant comment.
@
text
@d348 13
d390 2
a391 2
  
  free_all_values ();
@


1.168
log
@2009-08-14  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* top.c (any_thread_of): Delete.
	(kill_or_detach): Use any_thread_of_process.
	* top.c (print_inferior_quit_action): New.
	(quit_confirm): Rewrite to print info about all inferiors.
	* target.c (dispose_inferior): New.
	(target_preopen): Use it.

2009-08-14  Pedro Alves  <pedro@@codesourcery.com>

	gdb/testsuite/
	* gdb.threads/killed.exp, gdb.threads/manythreads.exp,
	gdb.threads/staticthreads.exp: Adjust to "quit" output changes.
@
text
@d348 1
a348 1
/* Execute the line P as a command.
a350 2
/* Execute command P, in the current user context.  */

@


1.167
log
@	* target.h (struct target_ops): Make to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	methods instead of variables.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1)
	(target_has_registers_1, target_has_execution_1): Declare
	functions.
	(target_has_all_memory): Rewrite to call target_has_all_memory_1.
	(target_has_memory): Rewrite to call target_has_memory_1.
	(target_has_stack): Rewrite to call target_has_all_stack_1.
	(target_has_registers): Rewrite to call target_has_registers_1.
	(target_has_execution): Rewrite to call target_has_execution_1.
	(default_child_has_all_memory, default_child_has_memory)
	(default_child_has_stack, default_child_has_registers)
	(default_child_has_execution): Declare.
	(target_mark_running, target_mark_exited): Delete declarations.
	* target.c (default_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution): New.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1,
	target_has_registers_1, target_has_execution_1): New.
	(add_target): Default the to_has_all_memory, to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	callbacks to return 0.
	(update_current_target): Do not inherit to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers or to_has_execution.
	(target_mark_running, target_mark_exited): Delete.
	(memory_xfer_partial): Adjust.
	(target_read_memory, target_write_memory, target_search_memory):
	Dispatch to the the top-most target, not the flattened
	current_target.
	(target_info): Adjust.
	(init_dummy_target): Install return_zero as callback for
	to_has_all_memory, to_has_memory, to_has_stack, to_has_registers,
	to_has_execution.
	(set_maintenance_target_async_permitted): Use have_live_inferiors
	instead of target_has_execution.
	* target-memory.c (target_write_memory_blocks): Dispatch memory
	writes to the the top-most target, not the flattened
	current_target.

	* breakpoint.c (insert_breakpoints): Don't check for
	target_has_execution here.
	(update_global_location_list): Check if there are live inferiors
	to debug instead of target_has_execution.
	* infcmd.c (kill_command, detach_command): Check if there are
	inferiors instead of target_has_execution.
	* inferior.h (have_live_inferiors): Declare.
	* inferior.c (have_live_inferiors): New.
	* infrun.c (normal_stop): Don't check for target_has_execution to
	finish the thread states.
	* thread.c (is_thread_state, is_stopped, is_exited, is_running)
	(any_running, is_executing): Remove checks for
	target_has_execution.
	* top.c (kill_or_detach): Don't try to kill core inferiors.
	(quit_target): Don't check for target_has_execution.

	* corelow.c (core_has_memory, core_has_stack, core_has_registers):
	New.
	(init_core_ops): Install core_has_memory, core_has_stack and
	core_has_registers.
	* exec.c (exec_has_memory): New.
	(init_exec_ops): Install exec_has_memory.
	* remote.c (remote_add_inferior): Don't call target_mark_running.
	(remote_start_remote): Don't call target_mark_exited or call
	target_mark_running.
	(remote_open_1): Use have_inferiors instead of
	target_has_execution.  Don't use target_mark_exited.
	(init_remote_ops): Install deafult_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution.
	* bsd-kvm.c (bsd_kvm_return_one): New.
	(bsd_kvm_add_target): Register bsd_kvm_return_one as
	to_has_memory, to_has_stack and to_has_registers callbacks.
	* remote-m32r-sdi.c (m32r_return_one): New.
	(init_m32r_ops): Register it.
	* inf-child.c (inf_child_target): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.
	* gnu-nat.c (init_gnu_ops): Likewise.
	* go32-nat.c (init_go32_ops): Likewise.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* monitor.c (init_base_monitor_ops): Likewise.
	* nto-procfs.c (init_procfs_ops): Likewise.
	* remote-mips.c (_initialize_remote_mips): Likewise.
	* windows-nat.c (init_windows_ops): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Don't use
	target_mark_running or target_mark_exited.
	(gdbsim_mourn_inferior): Don't call target_mark_exited.
	(init_gdbsim_ops): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.

	* linux-nat.c (linux_nat_xfer_partial): If reading memory, and
	there's no inferior selected, defer to a lower stratum.
@
text
@a1163 28
/* If necessary, make the user confirm that we should quit.  Return
   non-zero if we should quit, zero if we shouldn't.  */

int
quit_confirm (void)
{
  if (! ptid_equal (inferior_ptid, null_ptid) && target_has_execution)
    {
      char *s;
      struct inferior *inf = current_inferior ();

      /* This is something of a hack.  But there's no reliable way to
         see if a GUI is running.  The `use_windows' variable doesn't
         cut it.  */
      if (deprecated_init_ui_hook)
	s = _("A debugging session is active.\nDo you still want to close the debugger?");
      else if (inf->attach_flag)
	s = _("The program is running.  Quit anyway (and detach it)? ");
      else
	s = _("The program is running.  Quit anyway (and kill it)? ");

      if (!query ("%s", s))
	return 0;
    }

  return 1;
}

a1169 14
/* Callback for iterate_over_threads.  Finds any thread of inferior
   given by ARG (really an int*).  */

static int
any_thread_of (struct thread_info *thread, void *arg)
{
  int pid = * (int *)arg;

  if (PIDGET (thread->ptid) == pid)
    return 1;

  return 0;
}

d1179 2
a1180 2
  thread = iterate_over_threads (any_thread_of, &inf->pid);
  if (thread)
d1197 61
@


1.166
log
@gdb/
	Replace the savestring calls by xstrdup calls where possible.
	* breakpoint.c (condition_command, set_raw_breakpoint)
	(create_catchpoint, update_breakpoint_locations): Replace the
	savestring calls by xstrdup calls where possible.
	* buildsym.c (start_subfile, patch_subfile_names, record_debugformat)
	(record_producer): Likewise.
	* coffread.c (coff_start_symtab, complete_symtab): Likewise.
	* corefile.c (set_gnutarget): Likewise.
	* dbxread.c (add_new_header_file): Likewise.
	* demangle.c (set_demangling_command, set_demangling_style): Likewise.
	* event-top.c (push_prompt, pop_prompt, command_line_handler)
	(set_async_prompt): Likewise.
	* infcmd.c (set_inferior_io_terminal, attach_command_post_wait):
	Likewise.
	* language.c (set_language_command, _initialize_language): Likewise.
	* linespec.c (decode_line_2): Likewise.
	* rs6000-nat.c (add_vmap): Likewise.
	* top.c (set_prompt, init_history, init_main): Likewise.
	* tracepoint.c (stringify_collection_list): Likewise.
	* varobj.c (varobj_create): Remove variable expr_len.  Replace the
	savestring calls by xstrdup calls where possible.
	(value_of_root, c_name_of_variable, c_describe_child): Replace the
	savestring calls by xstrdup calls where possible.
	* xcoffread.c (complete_symtab): Likewise.
	* cli/cli-script.c (build_command_line, define_command): Likewise.
	* cli/cli-setshow.c (do_setshow_command): Likewise.
@
text
@d1225 9
a1233 4
      if (inf->attach_flag)
	target_detach (qt->args, qt->from_tty);
      else
	target_kill ();
d1247 1
a1247 2
  if (target_has_execution)
    iterate_over_inferiors (kill_or_detach, qt);
@


1.165
log
@	* target.h (TARGET_WNOHANG): New.
	* target.c (target_wait): Add `options' argument.  Adjust.
	(struct target_ops) <to_wait>: Add `options' argument.
	(target_wait): Add `options' argument.
	* infrun.c (wait_for_inferior): Pass 0 as options to
	target_wait (blocking wait).
	(fetch_inferior_event): Pass TARGET_WNOHANG as options to
	target_wait.
	* fork-child.c (startup_inferior): Pass 0 as options to
	target_wait (blocking wait).
	* linux-nat.c (linux_nat_create_inferior): Remove async masking.
	(linux_nat_wait_1): Add `target_options' argument.  Use it instead
	of checking on target_can_async_p.
	(linux_nat_wait): Add `target_options' argument.  Adjust.
	* remote.c (remote_wait_ns): Add `options' argument.  Adjust to
	check on TARGET_WNOWAIT instead of checking on remote_is_async_p.
	(remote_wait_as): Add `options' argument.  Adjust to check on
	TARGET_WNOWAIT instead of checking on remote_is_async_p.  If doing
	a blocking wait, keep waiting until an interesting event comes
	out.
	(remote_wait): Add `options' argument.  Don't loop here if the
	target is in async mode, and a blocking wait has been requested.

	* top.c (deprecated_target_wait_hook): Add `options' argument.
	* linux-thread-db.c (thread_db_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ptrace.c (inf_ptrace_wait): Add `options' argument.
	* record.c (record_beneath_to_wait): Add `options' argument.
	(record_wait): Add `options' argument, and pass it down to the
	layer beneath.
	* bsd-uthread.c (bsd_uthread_wait): Add `options' argument.
	* darwin-nat.c (darwin_wait): Likewise.
	* defs.h (deprecated_target_wait_hook): Likewise.
	* gnu-nat.c (gnu_wait): Add `options' argument.
	* go32-nat.c (go32_wait): Likewise.
	* hpux-thread.c (hpux_thread_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ttrace.c (inf_ttrace_wait): Add `options' argument.
	* monitor.c (monitor_wait): Likewise.
	* nto-procfs.c (procfs_wait): Likewise.
	* remote-mips.c (mips_wait): Add `options' argument.
	* remote-sim.c (gdbsim_wait): Likewise.
	* rs6000-nat.c (rs6000_wait): Add `options' argument.
	* sol-thread.c (sol_thread_wait): Add `options' argument, and pass
	it down to the layer beneath.
	* spu-linux-nat.c (spu_child_wait): Add `options' argument.
	* windows-nat.c (windows_wait): Likewise.
	* tui/tui-hooks.c (tui_target_wait_hook): Likewise.  Adjust.
@
text
@d1156 1
a1156 1
   assignments to prompt are wrapped in calls to savestring...
d1160 1
a1160 1
  PROMPT (0) = savestring (s, strlen (s));
d1461 1
a1461 1
    history_filename = savestring (tmpenv, strlen (tmpenv));
d1519 1
a1519 1
  PROMPT (0) = savestring (DEFAULT_PROMPT, strlen (DEFAULT_PROMPT));
d1525 1
a1525 1
  new_async_prompt = savestring (PROMPT (0), strlen (PROMPT (0)));
@


1.164
log
@gdb
2009-04-23  Sergio Durigan Junior <sergiodj@@linux.vnet.ibm.com>
	    Tom Tromey  <tromey@@redhat.com>

	* configure, config.in: Regenerate.
	* configure.ac: Support for relocatable GDB datadir.  Use
	GDB_AC_WITH_DIR.  Always define TARGET_SYSTEM_ROOT_RELOCATABLE.
	* acinclude.m4 (GDB_AC_WITH_DIR): New defun.
	* top.c (init_main): Add "set data-directory".
	* defs.h (gdb_datadir): Declare.
	* main.c (gdb_datadir): New global.
	(captured_main): Initialize gdb_datadir.  Use relocate_directory.
	(relocate_path): New function.
	(relocate_directory): Likewise.
	(get_init_files): Use relocate_path.
	(README): Mention --with-gdb-datadir.
gdb/doc
2009-04-23  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Data Files): New node.
	(GDB Files): Update menu.
@
text
@d269 2
a270 1
				       struct target_waitstatus * status);
@


1.163
log
@	* infrun.c (normal_stop): Use has_stack_frames instead of
	target_has_stack.
	* mi/mi-main.c (mi_execute_command): Avoid calling inferior_thread
	when there is no thread selected.
	(mi_cmd_execute): Don't special case commands that can run without
	a valid selected thread.
	* top.c (execute_command): Don't special case commands that can
	run without a valid selected thread.  Use has_stack_frames.
	* infcmd.c (ensure_valid_thread): New.
	(continue_1, step_1, jump_command, signal_command): Use it.
	(detach_command): Error out if there's no selected thread/inferior.
	* thread.c (print_thread_info): Allow having no thread selected.
	(switch_to_thread): Don't read the PC if there is no current thread.
	(do_restore_current_thread_cleanup): Don't record the current
	frame if there is no current thread.
	(make_cleanup_restore_current_thread): Don't read frame info if
	there is no selected thread.
	(_initialize_thread): Don't mark commands as
	"no_selected_thread_ok".
	* frame.c (get_current_frame): Error out if there is no valid
	selected thread.
	(has_stack_frames): Return false if there is no valid
	selected thread.
	* cli/cli-cmds.c (init_cli_cmds): Don't mark commands as
	"no_selected_thread_ok".
	* cli/cli-decode.c (set_cmd_no_selected_thread_ok)
	(get_cmd_no_selected_thread_ok): Delete.
	* cli/cli-decode.h (CMD_NO_SELECTED_THREAD_OK): Delete.
	(set_cmd_no_selected_thread_ok, get_cmd_no_selected_thread_ok):
	Delete declaration.
	* stack.c (get_selected_block): Use has_stack_frames.
@
text
@d1622 9
@


1.162
log
@	Fix completer problem for filename completion on the first try.

	* gdb/completer.h (gdb_completion_word_break_characters): New function.
	* gdb/completer.c: Include gdb_assert.h.
	(complete_line_internal_reason): New enum.
	(complete_line_internal): Change last argument type to
	complete_line_internal_reason.
	Modify function to handle the different complete_line_internal_reason
	argument values.
	(complete_line): Adapt to change in complete_line_internal.
	(command_completer): Ditto.
	(gdb_completion_word_break_characters): Implement new function.
	* top.c (init_main): Set  rl_completion_word_break_hook to
	gdb_completion_word_break_characters.
@
text
@a402 8
      /* If the selected thread has terminated, we allow only a
	 limited set of commands.  */
      if (target_can_async_p ()
	  && is_exited (inferior_ptid)
	  && !get_cmd_no_selected_thread_ok (c))
	error (_("\
Cannot execute this command without a live selected thread.  See `help thread'."));

d464 1
a464 1
  if (target_has_stack && is_stopped (inferior_ptid))
@


1.161
log
@	* top.c (quit_target): Check for target_has_execution before
	killing or detaching from inferiors.
@
text
@d1546 1
@


1.160
log
@2009-02-25  Hui Zhu  <teawater@@gmail.com>

	* cli/cli-script.c (define_command): Add _() to query.
	* gnu-nat.c (inf_validate_task_sc): Ditto.
	* infcmd.c (kill_if_already_running): Ditto.
	(jump_command): Ditto.
	(attach_command): Ditto.
	* inflow.c (kill_command): Ditto.
	* infrun.c (handle_command): Ditto.
	* maint.c (maintenance_dump_me): Ditto.
	* memattr.c (mem_delete_command): Ditto.
	* monitor.c (monitor_interrupt_query): Ditto.
	* nto-procfs.c (interrupt_query): Ditto.
	* printcmd.c (undisplay_command): Ditto.
	* remote-mips.c (mips_kill): Ditto.
	* remote.c (interrupt_query): Ditto.
	* solib-irix.c (irix_open_symbol_file_object): Ditto.
	* solib-osf.c (osf_open_symbol_file_object): Ditto.
	* solib-pa64.c (pa64_open_symbol_file_object): Ditto.
	* solib-som.c (som_open_symbol_file_object): Ditto.
	* solib-svr4.c (open_symbol_file_object): Ditto.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Ditto.
	* target.c (kill_or_be_killed): Ditto.
	* tracepoint.c (delete_trace_command): Ditto.
	* top.c (quit_confirm): Add _() to s that will be used
	in query.
@
text
@d1249 2
a1250 1
  iterate_over_inferiors (kill_or_detach, qt);
@


1.159
log
@	* defs.h (deprecated_error_hook): Delete declaration.
	* interps.c (clear_interpreter_hooks): Adjust.
	* remote-sim.c (gdb_os_error): Don't try to call
	deprecated_error_hook.  No need to call exit anymore.
	* top.c (deprecated_error_hook): Delete.
@
text
@d1186 1
a1186 1
	s = "A debugging session is active.\nDo you still want to close the debugger?";
d1188 1
a1188 1
	s = "The program is running.  Quit anyway (and detach it)? ";
d1190 1
a1190 1
	s = "The program is running.  Quit anyway (and kill it)? ";
@


1.158
log
@	* top.c (gdb_prompt_string): Delete, unused.
@
text
@a285 5
/* Takes control from error ().  Typically used to prevent longjmps out of the
   middle of the GUI.  Usually used in conjunction with a catch routine.  */

void (*deprecated_error_hook) (void);

@


1.157
log
@* top.c (gdb_init): Don't set the current directory here; that's
already been done in captured_main.
@
text
@a134 3
/* gdb prints this when reading a command interactively */
static char *gdb_prompt_string;	/* the global prompt string */

@


1.156
log
@        Updated copyright notices for most files.
@
text
@a1645 3
  getcwd (gdb_dirbuf, sizeof (gdb_dirbuf));
  current_directory = gdb_dirbuf;

@


1.155
log
@        * top.c (print_gdb_version): Update copyright year.
@
text
@d5 1
a5 1
   2008 Free Software Foundation, Inc.
@


1.154
log
@	* top.c (any_thread_of, kill_or_detach): New functions.
	(quit_target): Iterate over all inferiors, killing or detaching
	accordingly.
@
text
@d1125 1
a1125 1
  fprintf_filtered (stream, "Copyright (C) 2008 Free Software Foundation, Inc.\n");
@


1.154.4.1
log
@2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	Multi-process (primarily multi-exec) support.

	2008-10-14  Stan Shebs  <stan@@codesourcery.com>

	* blockframe.c (get_frame_block): Get inferior from frame.
	* block.c (block_for_pc_inf): New function.
	* block.h (block_for_pc_inf): Declare.
	* symfile.c (find_pc_inf_sect): New function.
	* symfile.h (find_pc_inf_sect): Declare.
	* symtab.c (find_pc_inf_line): New function.
	* symtab.h (find_pc_inf_line): Declare.
	* frame.c (struct frame_info) New field inferior.
	(fprint_frame_id): Display inferior.
	(get_frame_id): Set inferior_num from inferior.
	(frame_id_eq): Compare inferiors.
	(create_sentinel_frame): Set inferior.
	(create_new_frame): Copy inferior from sentinel.
	(get_prev_frame_raw): Copy inferior from next frame.
	(find_frame_sal): Use find_pc_inf_line.
	(get_frame_inferior): New function.
	* frame.h (struct frame_id): New field inferior_num.

	* breakpoint.c (expand_sals_by_inferiors): Copy section from input
	sal to expanded sals.
	* symtab.c (expand_line_sal): Ditto.

	2008-10-10  Stan Shebs  <stan@@codesourcery.com>

	* remote.c (discard_pending_stop_replies): Initialize prev.
	* infrun.c (infrun_thread_stop_requested): Ditto.

	2008-10-08  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (struct inferior): Rename environ field to inf_environ.
	* inferior.c (print_inferior): Ditto.

	2008-10-01  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (detach_fork): Declare here...
	* linux-fork.h (detach_fork): ...instead of here.
	* linux-fork.c (detach_fork): Move to...
	* infrun.c (detach_fork): ...here.
	* remote.c (detach_fork): Remove decl.

	2008-09-30  Stan Shebs  <stan@@codesourcery.com>

	* linespec.c (decode_line_1): Better default for one-exec case.
	* remote (remote_start_remote): Use the exec in the one-exec case.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* infcmd.c (attach_command): If only one exec, assume it is the
	attached inferior's exec.
	(attach_command_post_wait): Set inferior's exec from
	the one that was found.
	* inf-ptrace.c (inf_ptrace_attach): Only report exec file if
	if there is just one present.
	(inf_ptrace_detach): Use inferior to get correct exec name.

	2008-09-29  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (print_inferior): Use exec short names, and drop
	unused address space display.

	2008-09-26  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Test for no inferior.
	(clone_breakpoint_location): New function, broken out from...
	(update_breakpoint_inferiors): ...here, also tweak conditions
	for adding a location.
	(insert_breakpoint_location): Don't count non-running inferiors.
	(remove_breakpoint): Set tmp_inf.
	(print_one_breakpoint_location): Add allflag arg, use to always
	show inf.
	(print_one_breakpoint): Add allflag arg.
	(do_captured_breakpoint_query): Fix caller.
	(breakpoint_1): Ditto.
	* exec.c (create_exec): Save full pathname as exec name.
	(find_exec_by_name): Use find_exec_by_substr.
	* fork-child.c (fork_inferior): Warn if exec not found for new
	inferior.

	2008-09-25  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.c (should_be_inserted): Don't insert in inferiors
	that are not running.
	(update_breakpoint_inferiors): New function.
	(insert_breakpoints): Call it.
	(insert_breakpoint_locations): Don't insert in inferiors that are
	not running.
	(set_raw_breakpoint_without_location): Set trigger set from
	current itset here...
	(set_raw_breakpoint): Instead of here. Also add default fillins
	for the location's inferior.
	(add_location_to_breakpoint): Similarly.
	(expand_sals_by_inferiors): New function.
	(breakpoint_re_set_one): Call it.
	(resolve_sal_pc): Don't set sal inferior.
	* breakpoint.h (struct breakpoint): Remove exec field, never used.
	* inferior.h (inferior_list): Declare.
	* inferior.c (inferior_list): Make public.
	(add_inferior_to_itset): Auto-add inferiors after exec's inferior.
	(first_inferior_in_set): Check for zero-length vector.
	* exec.c (xfer_memory): Use tmp_inf as inferior if set.
	* infcmd.c (focus_command): Improve user feedback.
	* linespec.c (build_canonical_line_spec): Record exec name as part
	of canonical spec.
	(symbol_found): Canonicalize specs more.
	(decode_indirect): Revert rewrite from 2008-09-14.
	(decode_sharp): Use find_exec_by_substr, better error messages.
	* minsyms.c (lookup_minimal_symbol_in_exec): New function.
	(lookup_minimal_symbol_in_exec_1): New function, body of
	lookup_minimal_symbol.
	* symtab.h (lookup_minimal_symbol_in_exec): Declare.
	* symtab.c (find_function_start_sal): Set inferior to use.
	(append_expanded_sal): Return pointer to the new sal.
	* remote.c (remote_xfer_memory): Better parms to ptid_build, remove
	debug print.
	(remote_xfer_partial): Ditto.

	2008-09-22  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (itset_member): Fix typo.

	2008-09-22  Stan Shebs  <stan@@codesourcery.com>

	* inferior.h (current_inf): Remove declaration.
	(tmp_inf): Declare.
	* inferior.c (current_inf): Remove.
	(tmp_inf): New global, hack to bypass passing inferior throughout
	target stack.
	(print_inferior): Don't report current_inf.
	(add_inferior_command): Don't use current_inf.
	(name_inferior_command): Use first inferior of current_itset.
	(update_itset): Handle NULL case.
	(add_inferior_itset): Recursively add all inferiors derived from
	an exec if the exec's own inferior is present.
	(first_inferior_in_set): New function.
	(free_inferior): Comment out until references cleared reliably.
	* infcmd.c (focus_command): Don't set current_inf.
	(get_inferior_args): Use first_inferior_in_set instead of
	current_inf.
	(set_inferior_args): Ditto.
	(set_inferior_args_vector): Ditto.
	(notice_args_set): Ditto.
	* breakpoint.c (insert_breakpoint_locations): Remove insertion test
	using current_inf, set tmp_inf.
	(reattach_breakpoints): Set tmp_inf.
	(bpstat_check_breakpoint_conditions): Test trigger set here...
	(bpstat_stop_status): ... instead of here.
	(bpstat_check_trigger_set): Add special case for exec's own
	inferior.
	(print_one_breakpoint_location): Also test for multiple inferiors
	before displaying location's inferior, flag trigger set with "i/t"
	instead of "focus".
	(check_duplicates): Pass location's inferior to...
	(check_duplicates_for): Add inferior arg and use.
	(set_raw_breakpoint): Override sal inferior with one from the
	trigger set.
	(add_location_to_breakpoint): Ditto.
	* remote.c (remote_xfer_memory): Switch inferiors if tmp_inf is
	set to something different from inferior_ptid.
	(remote_xfer_partial): Ditto.
	* top.c (execute_command): Always update the current itset.

	2008-09-19  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (set_inferior_exec): New function.
	(set_inferior_exec_command): New command.
	* inferior.h: Declare set_inferior_exec.
	* fork-child.c (fork_inferior): Set the inferior's exec.
	* remote.c (extended_remote_create_inferior_1): Ditto.
	gdb/doc/
	* gdb.texinfo (Debugging Multiple Programs): Describe set-exec.

	2008-09-18  Stan Shebs  <stan@@codesourcery.com>

	* target.c (target_resize_to_sections): Adjust execs' section
	tables too.

	2008-09-17  Stan Shebs  <stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Invoking GDB): Describe multiple program args.
	(File Options): Describe multi-program effects.
	(Multiple Programs): New section, multi-program debugging.
	(Forks): Rename section from "Processes".
	(Specify Location): Describe the #-syntax.
	(Variables): Describe the #-syntax.
	(Files): Describe add-file and add-exec-file.
	(Maintenance Commands): Describe maint print execs.

	2008-09-15  Stan Shebs  <stan@@codesourcery.com>

	* exec.c (addr_space_info_command): Don't try to display host address.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* c-exp.y: (yylex): Accept '#' in identifiers.
	* linespec.c (decode_sharp): New function.
	(decode_line_1): Use it for #-syntax.
	(decode_indirect): Rewrite to accept exec arg and iterate over
	inferiors.
	(struct d_i_data): New struct for inferior iteration.
	(decode_indirect_callback): New function.
	(decode_variable): Pass in exec, use in symbol lookup.

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* breakpoint.h (struct bp_location): Add inferior field instead
	of address space field.
	* breakpoint.c (insert_breakpoint_locations): Only insert in
	appropriate inferior.
	(bpstat_check_trigger_set): New function.
	(bpstat_stop_status): Call it, check location's inferior also.
	(print_one_breakpoint_location): Report location's inferior.
	(set_raw_breakpoint): Set location inferior, clear an experiment.
	(add_location_to_breakpoint): Ditto.
	(expand_line_sal_maybe): Check for non-NULL original function.
	(resolve_sal_pc): Set sal inferior.
	(clear_command): Be careful to not clear anything twice.
	* symtab.h: Update declarations of symbol lookups.
	(struct symtab_and_line): Change address space to inferior field.
	* symtab.c (init_sal): Clear inferior field.
	(append_expanded_sal): Set inferior.
	(lookup_symbol_in_language_1): New function.
	(lookup_symbol_in_language): Call it.
	(lookup_symbol_in_exec_in_language): New function.
	(lookup_symbol): Detect #-syntax and find exec to use.
	(lookup_symbol_aux): Add exec argument and use it.
	(lookup_symbol_aux_symtabs): Ditto.
	(lookup_symbol_aux_psymtabs): Ditto.
	(basic_lookup_symbol_nonlocal): Ditto.
	(lookup_symbol_static): Ditto.
	(lookup_symbol_global): Ditto.
	* ada-lang.c (cp_lookup_symbol_nonlocal): Ditto.
	* cp-support.h (cp_lookup_symbol_nonlocal): Ditto.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): Ditto.
	* language.h (struct language_defn): Ditto.
	* scm-valprint.c (scm_inferior_print): Add exec arg to
	lookup_symbol_global.
	* source.c (select_source_symtab): Use current_exec.
	* addrspace.h (struct addr_space): New field num.
	* exec.h (struct exec): New fields sections and sections_end.
	* exec.c (exec_file_attach_1): Set them from exec_ops, set
	inferior's address space name from exec.
	(find_exec_by_substr): New function.
	(build_section_table): Don't free old table.
	(print_section_info): Use exec's section table.
	(next_address_space_num): New global, numbering for address spaces.
	(new_address_space): Use it.
	(addr_space_info_command): Display it.
	* infcmd.c (set_current_exec): Set exec_ops section table.
	* inferior.h (update_itset): Declare.
	* inferior.c (add_inferior_silent): Set address space.
	(print_inferior): Display it.
	(number_of_inferiors): New function.
	(itset_member): New function.

	2008-09-04  Stan Shebs  <stan@@codesourcery.com>

	* corefile.c (close_exec_file): Remove #if 0 block.
	(validate_files): Use first_exec instead of exec_bfd.
	(get_exec_file): Ditto.
	* corelow.c (core_open): Ditto.
	* utils.c (string_to_core_addr): Ditto.
	* arch-utils.c (gdbarch_update_p): Ditto.
	* linux-thread-db.c (enable_thread_event): Ditto.
	(thread_db_get_thread_local_address ): Ditto.
	* exec.c (find_exec_by_name): Test short name also.
	(file_command): Set current exec.

	2008-09-03  Stan Shebs  <stan@@codesourcery.com>

	* inferior.c (add_threads_to_itset): Default to including all
	of an inferior's threads.

	2008-08-31  Stan Shebs  <stan@@codesourcery.com>

	Parsing for i/t sets.
	* inferior.h (struct itset_entry): New struct.
	(struct itset): Make thread lists be per-inferior, add parse state
	variables.
	* inferior.c: (add_inferior_command): Add error checking and
	confirmation.
	(remove_inferior_command): Update for itset restructuring.
	(new_itset): Don't pass in dynamic-ness, call parse_itset_spec.
	(update_itset): Similarly.
	(parse_itset_spec): New, parsing of itset spec.
	(parse_itset_list, parse_itset_range, etc): New.
	(make_itset_from_spec): Rewrite.
	(dump_itset): Rewrite to reflect itset structure.
	* infcmd.c (focus_command): Similarly.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	First part of multiprocess support.
	* Makefile.in (COMMON_OBS): Add inferior.o.
	* addrspace.h: New file.
	* breakpoints.h (struct bp_location): Add address space field.
	(struct breakpoint): Add trigger set and exec fields.
	* breakpoints.c (print_one_breakpoint_location): Display trigger
	set.
	(set_raw_breakpoint): Set trigger set from current itset.
	* corefile.c (reopen_exec_file): Rewrite for multiple execs.
	(get_exec_file): Add case for current_exec.
	* corelow.c (is_core_file): New function.
	(core_files_info): Pass additional arg to print_section_info.
	* exec.h (struct exec): New struct.
	* exec.c (execs): New global.
	(exec_bfd_mtime): Remove.
	(last_exec_created, current_exec, first_exec): New globals.
	(exec_close): Clear all exec objects.
	(exec_file_clear): Tweak user message.
	(exec_file_add): New function.
	(exec_file_attach_1): New function, body of exec_file_attach,
	plus new code to handle multiple execs.
	(exec_file_attach): Call it.
	(exec_file_update): New function.
	(create_exec, find_exec_by_name, number_of_execs): New functions.
	(exec_file_command): Rephrase query, set current exec.
	(add_exec_file_command): New command.
	(add_file_command): New command.
	(print_section_info): Add exec argument.
	(exec_files_info): Rewrite for multiple execs.
	(maintenance_print_execs): New function.
	(new_address_space): New function.
	(addr_space_info_command): New command.
	* gdbcore.h (exec_bfd_mtime): Remove decl.
	(exec_file_add): Declare.
	* infcmd.c: Include exec.h.
	(current_itset): New global.
	(set_current_exec): New function.
	(focus_command): New command.
	(get_inferior_args): Maybe get from the current inferior.
	(set_inferior_args): Also set in current inferior.
	(set_inferior_args_vector): Similarly.
	(notice_args_set): Similarly.
	(attach_command): Rephrase query.
	* inferior.h (struct inferior): New struct.
	(struct itset): New struct.
	* inferior.c: New file, management of multiple inferiors.
	* main.c (captured_main): Rewrite to allow multiple executables,
	pids, and corefiles on the command line.
	* maint.c (maintenance_info_sections): Rewrite for multiple execs.
	* objfiles.h (struct objfile): New field for exec.
	(ALL_OBJFILES_FOR_EXEC, ALL_PRIMARY_SYMTABS_FOR_EXEC,
	ALL_PSYMTABS_FOR_EXEC): New macros.
	* objfiles.c (allocate_objfile): Clear exec field.
	* solib.c (clear_solib): Use first_exec instead of exec_bfd.
	* source.c (select_source_symtab): Use ALL_OBJFILES_FOR_EXEC.
	(find_source_lines): Use mtime from exec.
	* symfile.c (syms_from_objfile): Don't clear objfile if multiple
	execs.
	(new_symfile_objfile): Get objfile's exec from last_exec_created.
	(symbol_file_clear): Rephrase messages.
	(reread_symbols): Update objfile's exec if necessary.
	* symmisc.c (dump_objfile): Dump objfile's exec also.
	(maintenance_print_objfiles): Report symfile_objfile.
	* symtab.h (struct symtab_and_line): Add address space field.
	* symtab.c (find_pc_sect_psymtab): Look for a plausible exec, and
	then use it.
	(lookup_symbol_aux_symtabs): Use current exec.
	(lookup_symbol_aux_symtabs): Ditto.
	(basic_lookup_transparent_type): Ditto.
	(find_pc_sect_symtab): Ditto.
	* target.h (print_section_info): Add arg to decl.
	* tui/tui-win.c: Rename "focus" command to "ffocus".

gdb/testsuite:

2008-11-20  Stan Shebs  <stan@@codesourcery.com>

	2008-09-14  Stan Shebs  <stan@@codesourcery.com>

	* gdb.gdb/selftest.exp: Update to reflect current sources.
	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* configure.ac (AC_OUTPUT): Add gdb.multi/Makefile.
	* configure: Regenerate.

	* gdb.multi/Makefile.in: New.
	* gdb.multi/hello.c, hangout.c, goodbye.c: New source files.
	* gdb.multi/base.exp: New file, basic multiprocess tests.

	2008-08-25  Stan Shebs  <stan@@codesourcery.com>

	* config/monitor.exp: Match on rephrased message.
	* gdb.base/attach.exp: Ditto.
	* gdb.base/default.exp: Ditto.
	* lib/gdb.exp: Ditto.
@
text
@a441 4
      /* Make sure the current i/t set is actually current and
	 accurate.  */
      update_itset (current_itset);

@


1.154.4.2
log
@2008-11-25  Pedro Alves  <pedro@@codesourcery.com>

	2008-11-25  Pedro Alves  <pedro@@codesourcery.com>

	* linux-fork.c (detach_fork): Delete declaration.
	(_initialize_linux_fork): Move "set detach-on-fork"
	command to ...
	* infrun.c (_initialize_infrun): ... here.
	* inferior.h (detach_fork): Declare.

	2008-11-10  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (read_ptid): If we don't know about any inferior yet,
	use the pid of magic_null_ptid.
	(remote_start_remote): Don't set inferior_ptid to magic_null_ptid
	here.

	2008-10-14  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (remote_start_remote): Mask async mode while collecting
	the initial event, use notice_new_inferior.

	2008-10-12  Pedro Alves  <pedro@@codesourcery.com>

	* infcmd.c (attach_command_post_wait): Set the inferior exec here.
	(attach_command): Don't set the inferior exec here.
	(notice_new_inferior): New.
	* inferior.h (notice_new_inferior): Declare.
	* remote.c (notice_new_inferiors): Add `stopping' argument.  Add
	the inferior before adding the threads.  Call notice_new_inferior.
	(record_currthread): Adjust.
	(remote_threads_info): Add the inferior before adding the thread.
	Call notice_new_inferior.

	2008-10-09  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (notice_new_inferiors): If there's only one exec, set
	it in the new inferior.
	(set_thread): If setting the thread failed, assume the thread has
	terminated.

	2008-09-17  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (delete_inferior_1): Free the inferior after freeing
	its threads.

	2008-09-16  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.h (discard_all_inferiors): Declare.
	* inferior.c (delete_inferior): Rename to...
	(delete_inferior_1): ...this.  Add 'silent' argument.  If this
	inferior is has pid not zero, delete its threads.
	(delete_inferior): New, as wrapper around delete_inferior_1.
	(delete_inferior_by_pid_1): Reimplement.
	(discard_all_inferiors): New.

	2008-09-15  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (extended_remote_attach_1): Don't set target_attach_no_wait.

	2008-09-15  Pedro Alves  <pedro@@codesourcery.com>

	* frame.c (get_current_frame, has_stack_frames): Check for
	null_ptid.
	* top.c (execute_command): Likewise.

	2008-08-29  Pedro Alves  <pedro@@codesourcery.com>

	* inferior.c (have_real_inferiors): New.
	* inferior.h (have_real_inferiors): Declare.
	* remote.c (extended_remote_mourn_1): Use it.
	* top.c (quit_target): Use it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (parse_stop_reply): Handle Y;exec.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* infcmd.c (struct exec_file_attach_wrapper_args): New.
	(exec_file_attach_wrapper): New.
	(attach_command_post_wait): If there's a sysroot, prepend it to
	the target reported exec file path.  Continue attaching to the
	inferior event if attaching to the exec file fails.

	* remote.c (remote_pid_to_exec_file): Rebustify.  Expect
	"QExecFile:PID;" in the reply.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (record_currthread): If setting the current thread to
	minus_one_ptid, don't pass that to the stub.
	(remote_parse_stop_reply): Handle 'Y' stop reply.
	(remote_wait_as): Likewise.  If remote process exited, invalidate
	the current thread.
	(remote_detach_pid): New.
	(remote_follow_fork): New.
	(init_remote_ops): Register it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (remote_pid_to_exec_file): New.
	(init_remote_ops): Register it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* infcmd.c (kill_if_already_running): If target supports
	multi-process, allow multi-runs.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* remote.c (extended_remote_create_inferior_1): Don't clear the
	thread list.
@
text
@d484 1
a484 3
  if (target_has_stack
      && !ptid_equal (inferior_ptid, null_ptid)
      && is_stopped (inferior_ptid))
@


1.153
log
@	Remove the attach_flag global, and make it per-inferior.

	* inferior.h (attach_flag): Delete.
	(inferior_process): Declare.
	* solib.c (update_solib_list): Adjust.
	* gnu-nat.c (gnu_create_inferior, gnu_attach): Adjust.
	* inf-ptrace.c (inf_ptrace_detach): Adjust.
	(inf_ptrace_files_info): Get it from the current inferior.
	* inf-ttrace.c (inf_ttrace_attach): Adjust.
	(inf_ttrace_files_info): Get it from the current
	inferior.
	* inflow.c (terminal_inferior, terminal_ours_1, set_sigint_trap)
	(clear_sigint_trap): Get it from the current process.
	* remote.c (extended_remote_attach_1)
	(extended_remote_create_inferior_1): Adjust.
	* top.c (quit_confirm, quit_target): Get it from the current inferior.
	* procfs.c (do_detach): Adjust.
	(procfs_wait): Get it from the event inferior.
	(procfs_files_info): Get it from the current inferior.
	* nto-procfs.c (procfs_files_info): Likewise.
	(procfs_attach): Adjust.  Set the attach_flag here.
	(do_attach): Don't set it here.
	(procfs_detach): Don't clear it.
	(procfs_mourn_inferior): Don't clear it.
	* solib-osf.c (osf_solib_create_inferior_hook): Adjust.
	* target.c (attach_flag): Delete.
	(generic_mourn_inferior): Don't clear it.
	* win32-nat.c (get_win32_debug_event): Get it from the event
	process.
	(do_initial_win32_stuff): Add attaching argument.  Set attach_flag
	in the inferior accordingly.
	(win32_attach): Don't set the attach_flag here.  Pass 1 to
	do_intial_win32_stuff.
	(win32_files_info): Get it from the current inferior.
	(win32_create_inferior): Dont clear attach_flag here.  Pass 0 to
	do_intial_win32_stuff.
@
text
@a1206 2
/* Helper routine for quit_force that requires error handling.  */

d1213 3
d1217 15
a1231 1
quit_target (void *arg)
d1233 2
a1234 1
  struct qt_args *qt = (struct qt_args *)arg;
d1236 2
a1237 1
  if (! ptid_equal (inferior_ptid, null_ptid) && target_has_execution)
d1239 1
a1239 1
      struct inferior *inf = current_inferior ();
d1241 1
a1241 1
        target_detach (qt->args, qt->from_tty);
d1243 1
a1243 1
        target_kill ();
d1246 13
@


1.152
log
@	* inferior.h (stop_bpstat): Delete.

	* breakpoint.h (bpstat_do_actions): Remove bpstat* argument.

	* breakpoint.c (bpstat_do_actions): Rename to ...
	(bpstat_do_actions_1): ... this.  Make static.  Change return type
	to int.  Return true if a breakpoint proceeded.
	(bpstat_do_actions): New, as wrapper around bpstat_do_actions_1.
	(delete_breakpoint): Don't reference the global stop_bpstat; it's
	gone.

	* gdbthread.h (struct thread_info): Add stop_bpstat.
	(save_infrun_state, load_infrun_state): Remove stop_bpstat
	argument.
	* thread.c (load_infrun_state, save_infrun_state): Remove
	stop_bpstat argument, and the code referencing it.

	* infcall.c: Include "gdbthread.h".
	(call_function_by_hand): Adjust.
	* exceptions.c: Include "gdbthread.h".
	(throw_exception): Adjust.
	* infcmd.c (stop_bpstat): Delete.
	(continue_command): In all-stop, set the ignore count on the
	thread that reported the stop.  In non-stop, set it on the current
	thread.
	(finish_command_continuation): Adjust.
	(program_info): Adjust.
	* infrun.c (clear_proceed_status): Adjust.
	(context_switch): Don't context-switch stop_bpstat.
	(handle_inferior_event): Adjust.
	(normal_stop): Adjust.
	(save_inferior_status, restore_inferior_status): Adjust.

	* inf-loop.c (inferior_event_handler): Remove parameter to
	bpstat_do_actions call.
	* top.c (command_loop): Remove parameter to bpstat_do_actions
	call.  Call it unconditionally.
	* event-top.c (command_handler): Ditto.
	* python/python.c (execute_gdb_command): Ditto.
@
text
@d1188 1
d1195 1
a1195 1
      else if (attach_flag)
d1222 2
a1223 1
      if (attach_flag)
@


1.151
log
@	* gdbthread.h: Add comments.
	* stack.c (get_selected_block): Return 0 on an exited thread.
	* top.c (execute_command): Check for is_stopped, not !is_running.
	* event-top.c (command_handler): Likewise.
@
text
@d537 4
a540 2
      /* Do any commands attached to breakpoint we stopped at.  */
      bpstat_do_actions (&stop_bpstat);
@


1.150
log
@	* target.h (pop_all_targets): Declare.
	* target.c (pop_all_targets): New.
	* top.c (quit_target): Pop all targets instead of just closing the
	current.
@
text
@d480 1
a480 1
  if (target_has_stack && !is_running (inferior_ptid))
@


1.149
log
@	* annotate.h (deprecated_annotate_starting_hook): Remove.
	(deprecated_annotate_stopped_hook): Remove.
	(deprecated_annotate_exited_hook): Remove.
	* Makefile.in (annotate.o): Depend on observer_h.
	* top.c (deprecated_delete_breakpoint_hook): Remove.
	(deprecated_create_breakpoint_hook): Likewise.
	(deprecated_modify_breakpoint_hook): Likewise.
	* interps.c (clear_interpreter_hooks): Update for removed hooks.
	* breakpoint.c (mention): Don't call removed hook.
	(delete_breakpoint): Likewise.
	(disable_breakpoint): Likewise.
	(do_enable_breakpoint): Likewise.
	* annotate.c: Include observer.h.
	(breakpoint_changed): Change type of argument.
	(_initialize_annotate): Register observers.
	(deprecated_annotate_starting_hook): Remove.
	(deprecated_annotate_stopped_hook): Remove.
	(deprecated_annotate_exited_hook): Remove.
	(annotate_starting): Update for hook removal.
	(annotate_stopped): Likewise.
	(annotate_exited): Likewise.
	* defs.h (deprecated_delete_breakpoint_hook): Remove.
	(deprecated_create_breakpoint_hook): Likewise.
	(deprecated_modify_breakpoint_hook): Likewise.
@
text
@d1225 3
a1227 2
  /* UDI wants this, to kill the TIP.  */
  target_close (&current_target, 1);
@


1.148
log
@	Allow all CLI command even if target is executing.
        * gdb/top.c (execute_command_1): Don't check if the inferiour
        is running.
@
text
@a248 7
/* Called as appropriate to notify the interface of the specified breakpoint
   conditions.  */

void (*deprecated_create_breakpoint_hook) (struct breakpoint * bpt);
void (*deprecated_delete_breakpoint_hook) (struct breakpoint * bpt);
void (*deprecated_modify_breakpoint_hook) (struct breakpoint * bpt);

@


1.147
log
@	Replace struct continuation_args by void* and per command structs.

	* top.c (execute_command): Remove unused arg1 and arg2 locals.

	* breakpoint.c (struct until_break_command_continuation_args):
	New.
	(until_break_command_continuation): Take a void* instead of a
	continuations_arg.  Adjust.
	(until_break_command): Adjust to use struct
	until_break_command_continuation_args instead of struct
	continuation_arg.

	* infcmd.c (struct step_1_continuation_args): New.
	(step_1_continuation): Take a void* instead of a
	continuations_arg.  Adjust to use struct step_1_continuation_args.
	(step_once): Adjust to use struct step_1_continuation_args.

	(struct finish_command_continuation_args): New.
	(finish_command_continuation): Take a void* instead of a
	continuations_arg.  Adjust to use struct
	finish_command_continuation_args.
	(finish_command): Adjust to use struct
	finish_command_continuation_args.
	(struct attach_command_continuation_args): New.
	(attach_command_continuation): Take a void* instead of a
	continuations_arg.  Adjust to use struct
	attach_command_continuation_args.
	(attach_command): Adjust to use struct
	attach_command_continuation_args.

	* defs.h (struct continuation_arg): Delete.
	(struct continuation): Replace the struct continuation_arg*
	parameter of continuation_hook by a void*.  Replace "arg_list"
	member by a new "args" member with void* type.
	(add_continuation, add_intermediate_continuation): Replace struct
	continuation_arg type usages by void* usages.

	* utils.c (add_continuation, do_all_continuations)
	(add_intermediate_continuation)
	(do_all_intermediate_continuations): Replace struct
	continuation_arg type usages by void* usages.  Pass "args" instead
	of "arg_list".
@
text
@a424 7
      /* If the target is running, we allow only a limited set of
	 commands.  */
      else if (target_can_async_p ()
	       && ((!non_stop && any_running ())
		   || (non_stop && is_running (inferior_ptid)))
	       && !get_cmd_async_ok (c))
	error (_("Cannot execute this command while the target is running."));
@


1.146
log
@	Exited threads.

	* thread.c (enum thread_state): New.
	(thread_state main_thread_running): Delete, in favor of...
	(thread_state main_thread_state): ... this.  Update throughout.
	(clear_thread_inferior_resources): New, split from free_thread.
	(free_thread): Call clear_thread_inferior_resources.
	(init_thread_list): Set main thread to stopped state.
	(add_thread_silent): Take care of PTID reuses.
	(delete_thread): If deleting inferior_ptid or a thread with
	refcount > 0, mark it as exited, but still keep it in the list.
	Only notify of thread exits, if we haven't done so yet.
	(iterate_over_threads): Make it safe to delete threads while
	iterating over them.
	(do_captured_list_thread_ids): Don't account for exited threads.
	(thread_alive): Check for the THREAD_EXITED state, and don't set
	ptid to -1 on exited threads.
	(set_running): Update to account for extra possible states.
	(is_thread_state): New.
	(is_stopped, is_exited): New.
	(is_running): Implement in terms of is_thread_state.
	(any_running): Update.
	(print_thread_info): Update.  Account for exited threads.  Don't
	warn about missed frame restoring here, its done in the cleanup.
	(switch_to_thread): Don't read from a thread that has gone.
	(restore_current_thread): In non-stop mode, do a full context
	switch.
	(restore_selected_frame): Add a frame_level argument.  Rewrite.
	(struct current_thread_cleanup): Add selected_frame_level and
	was_stopped members.
	(do_restore_current_thread_cleanup): Check if thread was stopped
	and still is, and if the target has registers, stack and memory
	before restoring the selected frame.  Don't delete the cleanup
	argument here.
	(restore_current_thread_cleanup_dtor): New.
	(make_cleanup_restore_current_thread): Remove all arguments.
	Rewrite.
	(thread_apply_all_command): Update.  Prune threads.
	(thread_apply_command): Update.
	(thread_command): Account for currently selected exited thread.
	(do_captured_thread_select): Check for a running thread.  Prune
	threads.
	(_initialize_thread): Make "info threads", "thread", "thread
	apply", and "thread apply all" appliable without a selected thread.
	* gdbthread.h (struct thread_info): Replace running_ by state_.
	Add refcount.
	(is_exited, is_stopped): Declare.
	(make_cleanup_restore_current_thread): Remove all arguments.
	* infrun.c: Include "event-top.h".
	(fetch_inferior_event): In non-stop mode, restore selected thread
	and frame after handling the event and running breakpoint
	commands.  Display GDB prompt if needed.
	(normal_stop): In non-stop mode, don't print thread switching
	notice.
	* cli/cli-decode.c (set_cmd_no_selected_thread_ok)
	(get_cmd_no_selected_thread_ok): New.
	* cli/cli-decode.h (CMD_NO_SELECTED_THREAD_OK): New.
	(set_cmd_no_selected_thread_ok, get_cmd_no_selected_thread_ok):
	Declare.
	* cli/cli-cmds.c: Set "pwd", "help", "info", "show" as
	no-selected-thread ok.
	* top.c (execute_command): Check for non no-selected-thread-ok
	commands.
	* linux-nat.c (struct saved_ptids, threads_to_delete)
	(record_dead_thread, prune_lwps): Delete.
	(exit_lwp): Unconditionally delete thread.
	(linux_nat_resume): Remove prune_lwps call.
	* infcmd.c (proceed_thread_callback): Check if !is_stopped instead
	of is_running.  Adjust to make_cleanup_restore_current_thread
	interface change.
	* mi/mi-main.c (mi_cmd_execute): Only allow a few commands if the
	selected thread has exited.
	* inf-loop.c (inferior_event_handler): Don't display the prompt
	here.
	* varobj.c (c_value_of_root): Update.
	* defs.h (make_cleanup_dtor): Declare.
	* utils.c (make_cleanup_dtor): New.

	* Makefile.in (infrun.o): Depend on $(event_top_h).
@
text
@a373 2
  struct continuation_arg *arg1;
  struct continuation_arg *arg2;
@


1.145
log
@	Per-thread commands.

	* gdbthread.h: Remove unneeded forward declarations.
	Include "inferior.h".
	(struct thread_info): Add continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi and stop_signal members.
	(save_infrun_state): Add continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi, stop_signal and stop_bpstat parameters.
	(load_infrun_state): Add continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi, stop_signal and stop_bpstat parameters.

	* thread.c (load_infrun_state): In non-stop mode, load
	continuations, intermediate_continuations, proceed_to_finish,
	step_over_calls, stop_step, step_multi and stop_signal.
	(save_infrun_state): Store continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi, stop_signal and stop_bpstat.
	(save_infrun_state): Store continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi, stop_signal and stop_bpstat.
	(free_thread): Clear The thread's stop_bpstat.

	* inferior.h (context_switch_to): Declare.

	* infrun.c (ecss): New global.
	(context_switch): Context switch continuations,
	intermediate_continuations, proceed_to_finish, step_over_calls,
	stop_step, step_multi, stop_signal and stop_bpstat.
	(wait_for_inferior): Use global ecss.
	(async_ecss, async_ecs): Delete.
	(fetch_inferior_event): Use global ecss.
	(context_switch_to): New.

	* top.c (execute_command): In non-stop, only check if the current
	thread is running, in all-stop, check if there's any thread
	running.

	* breakpoint.c (bpstat_remove_breakpoint): New.
	(bpstat_remove_breakpoint_callback): New.
	(delete_breakpoint): Clear the stop_bpstats of all threads.

	* mi/mi-main.c (mi_cmd_execute): In non-stop, only check if the
	current thread is running, in all-stop, check if there's any
	thread running.

	* Makefile.in (gdbthread_h): Depend on $(inferior_h).
@
text
@d365 2
d420 7
d428 5
a432 5
         commands. */
      if (target_can_async_p ()
  	  && ((!non_stop && any_running ())
  	      || (non_stop && is_running (inferior_ptid)))
	  && !get_cmd_async_ok (c))
@


1.144
log
@	Add "executing" property to threads.

	* inferior.h (target_executing): Delete.
	* gdbthread.h (struct thread_info): Add executing_ field.
	(set_executing, is_executing): New.
	* thread.c (main_thread_executing): New.
	(init_thread_list): Clear it and also main_thread_running.
	(is_running): Return false if target has no execution.
	(any_running, is_executing, set_executing): New.

	* top.c: Include "gdbthread.h".
	(target_executing): Delete.
	(execute_command): Replace target_executing check by any_running.
	* event-top.c: Include "gdbthread.h".
	(display_gdb_prompt, command_handler): Replace target_executing by
	is_running.
	* inf-loop.c: Include "gdbthread.h".  Don't mark as not executing
	here.  Replace target_executing by is_running.
	* infrun.c (handle_inferior_event): Mark all threads as
	not-executing.
	* linux-nat.c (linux_nat_resume): Don't mark thread as executing
	here.
	* stack.c (get_selected_block): Return null if inferior is
	executing.
	* target.c (target_resume): Mark resumed ptid as executing.
	* breakpoint.c (until_break_command): Replace target_executing
	check by is_executing.
	* remote.c (remote_async_resume): Don't mark inferior as executing
	here.
	* mi/mi-interp.c (mi_cmd_interpreter_exec): Replace target_executing
	by any_running.

	* mi/mi-main.c (mi_cmd_exec_interrupt, mi_cmd_execute)
	(mi_execute_async_cli_command): Replace target_executing by
	is_running.

	* frame.c (get_current_frame): Error out if the current thread is
	executing.
	(has_stack_frames): New.
	(get_selected_frame, deprecated_safe_get_selected_frame): Check
	has_stack_frames.

	* Makefile.in (event-top.o, frame.o, inf-loop.o, top.o): Depend on
	$(gdbthread_h).
@
text
@d421 2
a422 1
	  && any_running ()
@


1.143
log
@(print_gdb_version): Don't print final newline.
@
text
@d49 1
a184 6
/* Non-zero means the target is running. Note: this is different from
   saying that there is an active target and we are stopped at a
   breakpoint, for instance. This is a real indicator whether the
   target is off and running, which gdb is doing something else. */
int target_executing = 0;

d420 3
a422 1
      if (target_can_async_p () && target_executing && !get_cmd_async_ok (c))
d486 1
a486 1
  if (!target_executing && target_has_stack)
@


1.142
log
@2008-06-05  Vladimir Prus  <vladimir@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* acinclude.m4: Include ../config/acx.m4.
	* configure.ac: Use ACX_PKGVERSION and ACX_BUGURL.
	* configure, config.in: Regenerate.
	* main.c (print_gdb_help): Use REPORT_BUGS_TO for bug-reporting
	address.
	* top.c (print_gdb_version): Use PKGVERSION and REPORT_BUGS_TO.

doc:
2008-06-05  Vladimir Prus  <vladimir@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.ac: Include ../../config/acx.m4.  Use ACX_PKGVERSION
	and ACX_BUGURL.
	* configure: Regenerate.
	* Makefile.in (PKGVERSION, BUGURL_TEXI): Define.
	(GDBvn.texi): Define VERSION_PACKAGE, BUGURL and BUGURL_DEFAULT.
	* gdb.texinfo: Use VERSION_PACKAGE and BUGURL.  Remove
	mailing-list-specific text about bug reporting unless
	BUGURL_DEFAULT.

gdbserver:
2008-06-05  Vladimir Prus  <vladimir@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* acinclude.m4: Include ../../config/acx.m4.
	* configure.ac: Use ACX_PKGVERSION and ACX_BUGURL.
	* configure, config.in: Regenerate.
	* Makefile.in (gdbreplay$(EXEEXT)): Add version.o.
	* server.c (gdbserver_version): Print PKGVERSION.
	(gdbsrever_usage): Add stream parameter.  Print REPORT_BUGS_TO.
	(main): Adjust gdbserver_usage calls.
	* gdbreplay.c (version, host_name): Add declarations.
	(gdbreplay_version, gdbreplay_usage): New.
	(main): Accept --version and --help options.
@
text
@d1162 1
a1162 1
      fprintf_filtered (stream, "%s.\n", REPORT_BUGS_TO);
@


1.141
log
@        * top.c (command_line_handler_continuation): Remove.
        (execute_command): Do not install the above.
@
text
@d1128 1
a1128 1
  fprintf_filtered (stream, "GNU gdb %s\n", version);
d1157 7
@


1.140
log
@	* inf-loop.c (inferior_event_handler): Call bpstat_do_action,
	and catch all exceptions from it.
	* top.c (command_line_handler_continuation): Don't
	call bpstat_do_action here.
@
text
@a366 37
/* Do any commands attached to breakpoint we stopped at. Only if we
   are always running synchronously. Or if we have just executed a
   command that doesn't start the target.  */
static void
command_line_handler_continuation (struct continuation_arg *arg, int error)
{
  extern int display_time;
  extern int display_space;

  long time_at_cmd_start  = arg->data.longint;
  long space_at_cmd_start = arg->next->data.longint;

  if (error)
    return;

  if (display_time)
    {
      long cmd_time = get_run_time () - time_at_cmd_start;

      printf_unfiltered (_("Command execution time: %ld.%06ld\n"),
			 cmd_time / 1000000, cmd_time % 1000000);
    }
  if (display_space)
    {
#ifdef HAVE_SBRK
      char *lim = (char *) sbrk (0);
      long space_now = lim - lim_at_start;
      long space_diff = space_now - space_at_cmd_start;

      printf_unfiltered (_("Space used: %ld (%c%ld for this command)\n"),
			 space_now,
			 (space_diff >= 0 ? '+' : '-'),
			 space_diff);
#endif
    }
}

a499 18

  /* Set things up for this function to be compete later, once the
     execution has completed, if we are doing an execution command,
     otherwise, just go ahead and finish. */
  if (target_can_async_p () && target_executing)
    {
      arg1 =
	(struct continuation_arg *) xmalloc (sizeof (struct continuation_arg));
      arg2 =
	(struct continuation_arg *) xmalloc (sizeof (struct continuation_arg));
      arg1->next = arg2;
      arg2->next = NULL;     
      arg1->data.longint = time_at_cmd_start;
#ifdef HAVE_SBRK
      arg2->data.longint = space_at_cmd_start;
#endif
      add_continuation (command_line_handler_continuation, arg1);
    }
@


1.139
log
@	exec_cleanup murder.
	* breakpoint.c (until_break_command_continuation): Add
	the 'error' parameter.  Directly delete the breakoint as
	opposed to running cleanups.
	(until_break_command): Install continuation only
	after starting the target.  Don't use exec cleanups,
	use ordinary cleanups.  Discard cleanups is successfully
	started the target in async mode.
	(make_cleanup_delete_breakpoint): Remove.
	* breakpoint.h (make_cleanup_delete_breakpoint): Remove
	declaration.
	* defs.h (do_exec_cleanups, make_exec_cleanup): Remove
	declarations.
	(struct continations): Add the 'error' parameter to the
	continuation_hook field.
	(add_continuation, do_all_continuations)
	(add_intermediate_continuation)
	(do_all_intermediate_continuations): Add the 'error' parameter.
	* exceptions.c (throw_exception): Don't call do_exec_cleanups.
	* inf-loop.c (inferior_event_handler): Instead of calling
	discard_all_continuations, use do_all_continuations with 1 as
	'error' parameter.  Pass 0 as 'error' parameter in existing uses
	of discard_all_continuations.
	* infcmd.c (step_1): Do not use exec cleanup.  For async case, discard
	cleanups.
	(step_once): Install continuation only after resuming the target.
	(step_1_continuation): Disable longjmp breakpoint on error.
	(finish_command_continuation): Add the error parameter.  Delete
	the finish breakpoint directly, do not use cleanups.
	(finish_command): Do not use exec_cleanups. Always setup
	continuation.  For sync case, immediately run them.
	(attach_command_continuation): Add the error parameter.
	* infrun.c (fetch_inferior_event): Do not use exec cleanups to
	remove step_resume_breakpoint -- adjust delete it directly.
	* interps.c (interp_set): Adjust call to do_all_continations.
	* mi/mi-interp.c (mi_interpreter_exec_continuation): Do not
	do exec cleanups.
	* mi/mi-main.c (mi_cmd_target_select): Do not do exec
	cleanups.
	(mi_cmd_execute): Do not use exec_cleanup.
	(mi_execute_async_cli_command): Simplify the string concatenation
	logic.  Do no use exec cleanup.
	(mi_exec_async_cli_cmd_continuation): New parameter error.
	Free last_async_command.
	* top.c (command_line_handler_continuation): New parameter error.
	* utils.c (exec_cleanup_chain, make_exec_cleanup)
	(do_exec_cleanups): Remove.
	(add_continuation, do_all_continations)
	(add_intermediate_continuation)
	(do_all_intermediate_continuations): New parameter error.
@
text
@a381 2
  bpstat_do_actions (&stop_bpstat);

@


1.138
log
@	* cli/cli-decode.h (CMD_ASYNC_OK): New define.
	(set_cmd_async_ok, get_cmd_async_ok): Declare.
	* cli/cli-decode.c (set_cmd_async_ok): New function.
	(get_cmd_async_ok): New function.
	* cli/cli-cmds.c (init_cli_cmds): Mark "pwd", "help", "info", and
	"show" as async-ok.
	* top.c (execute_command): Use get_cmd_async_ok.
	* infcmd.c: Include cli/cli-decode.h.
	(_initialize_infcmd): Mark "interrupt" as async-ok.
	* Makefile.in (infcmd.o): Depend on cli_decode_h.
@
text
@d371 1
a371 1
command_line_handler_continuation (struct continuation_arg *arg)
d379 3
@


1.137
log
@Revert 2008-03-21 changes.
@
text
@d461 2
a462 7
      if (target_can_async_p () && target_executing)
	if (strcmp (c->name, "help") != 0
	    && strcmp (c->name, "pwd") != 0
	    && strcmp (c->name, "show") != 0
	    && strcmp (c->name, "info") != 0
	    && strcmp (c->name, "interrupt") != 0)
	  error (_("Cannot execute this command while the target is running."));
@


1.136
log
@	PR gdb/544
	Suggested by Jan Kratochvil:
	* top.c (gdb_rl_operate_and_get_next_completion): Call
	rl_redisplay_function.
	(gdb_rl_redisplay): New.
	(init_main): Set rl_redisplay_function.

	* gdb.cp/annota2.exp, gdb.cp/annota3.exp: Remove KFAIL for
	fixed PR gdb/544.
@
text
@d924 1
a924 1
  rl_redisplay_function ();
a958 23

/* Readline 5.2 and earlier do not block SIGINT while redrawing the prompt.
   This can lead to corrupted internal state.  As long as we do not require
   a newer readline version, compensate for it.  */
static void
gdb_rl_redisplay (void)
{
#if HAVE_SIGPROCMASK
  sigset_t sigint_set, sigint_oset;

  sigemptyset (&sigint_set);
  sigemptyset (&sigint_oset);
  sigaddset (&sigint_set, SIGINT);
  sigprocmask (SIG_BLOCK, &sigint_set, &sigint_oset);
#endif

  rl_redisplay ();

#if HAVE_SIGPROCMASK
  sigprocmask (SIG_SETMASK, &sigint_oset, (sigset_t *)NULL);
#endif
}

a1583 1
  rl_redisplay_function = gdb_rl_redisplay;
@


1.135
log
@	* top.c (quit_confirm): Warn that we will kill the program.

	* gdb.threads/killed.exp, gdb.threads/manythreads.exp,
	gdb.threads/staticthreads.exp: Update exit query.
@
text
@d924 1
a924 1
  rl_redisplay ();
d959 23
d1607 1
@


1.134
log
@	* top.c (execute_command): Fix uninitialized variable error.
@
text
@d1256 1
a1256 1
	s = "The program is running.  Exit anyway? ";
@


1.133
log
@	Async mode fixes.
        * Makefile.in (infcmd.o, inf-loop.o): Update dependencies.
        * breakpoint.c (bpstat_do_actions): In async mode,
        don't jump to top expecting stop_bpstat to be already
        updated.
        * event-loop.c (start_event_loop): Call async_enable_stdin
        on exception.
        * event-top.c (async_enable_stdin): Do nothing if sync_execution
        is not set.
        (command_handler): Do not setup continuation here.
        (command_line_handler_continuation): Move to...
        * top.c (command_line_handler_continuation): ... here.
        (execute_command): In async mode, register continuation.
        Don't check frame's language in running in async mode.
        * exceptions.c (throw_exception): Don't do exec_error_cleanups.
        * inf-loop.c (complete_execution): Inline into...
        (inferior_event_handler): ... here.  Clear target_executing before
        doing any cleanups.  Don't try to show prompt if the target was
        resumed.
        * infcmd.c (signal_command): Add support for async mode.
        (finish_command): Only add continuation if the target was
        successfully resumed.
        * remote.c (init_async_opts): Register to_get_thread_local_address
        handler.
        * mi/mi-interp.c (mi_cmd_interpreter_exec): Don't mess
        with sync_execution.
        * tui/tui-interp.c (tui_command_loop): Call async_enable_stdin
        on exception.
@
text
@d415 1
a415 1
  long time_at_cmd_start;
@


1.132
log
@	* top.c (simplified_command_loop): Remove.
@
text
@d367 36
d413 21
d530 1
a530 1
  if (target_has_stack)
d541 18
@


1.131
log
@	* top.c (execute_command): Disable break and stop
	commands in async mode.
@
text
@a556 35

/* Read commands from `instream' and execute them until end of file or
   error reading instream. This command loop doesnt care about any
   such things as displaying time and space usage. If the user asks
   for those, they won't work. */
void
simplified_command_loop (char *(*read_input_func) (char *),
			 void (*execute_command_func) (char *, int))
{
  struct cleanup *old_chain;
  char *command;
  int stdin_is_tty = ISATTY (stdin);

  while (instream && !feof (instream))
    {
      quit_flag = 0;
      if (instream == stdin && stdin_is_tty)
	reinitialize_more_filter ();
      old_chain = make_cleanup (null_cleanup, 0);

      /* Get a command-line. */
      command = (*read_input_func) (instream == stdin ?
				    get_prompt () : (char *) NULL);

      if (command == 0)
	return;

      (*execute_command_func) (command, instream == stdin);

      /* Do any commands attached to breakpoint we stopped at.  */
      bpstat_do_actions (&stop_bpstat);

      do_cleanups (old_chain);
    }
}
@


1.130
log
@	* top.c (execute_command): Enable break, info and interrupt
	commands in async mode.
@
text
@a407 2
	    && strcmp (c->name, "stop") != 0
	    && strcmp (c->name, "break") != 0
@


1.129
log
@	Updated copyright notices for most files.
@
text
@d408 4
a411 1
	    && strcmp (c->name, "stop") != 0)
@


1.128
log
@        * top.c (print_gdb_version): Update copyright year.
@
text
@d4 2
a5 2
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
   Free Software Foundation, Inc.
@


1.127
log
@* target.c (update_current_target): Inherit to_log_command.
* target.h (struct target_ops). Add to_log_command.
(target_log_command): New macro.
* top.c (execute_command): Call target_log_command() rather than
serial_log_command().
* monitor.c (init_base_monitor_ops): Initialize to_log_command.
* remote-m32r-sdi.c (init_m32r_ops): Likewise.
* remote-mips.c (_initialize_remote_mips): Likewise.
* remote.c (init_remote_ops): Likewise.
@
text
@d1150 1
a1150 1
  fprintf_filtered (stream, "Copyright (C) 2007 Free Software Foundation, Inc.\n");
@


1.126
log
@	* top.c (command_loop): Fix output for shrinkage.
@
text
@d388 1
a388 1
  serial_log_command (p);
@


1.125
log
@	* top.c (print_gdb_version): Fixed a string end-of-line compiler error.
@
text
@d548 1
a548 1
	  printf_unfiltered (_("Space used: %ld (%c%ld for this command)\n"),
d550 1
a550 1
			     (space_diff >= 0 ? '+' : '-'),
@


1.124
log
@	* top.c (print_gdb_version): Update for GPL version 3.

	* gdb.texinfo: Update the FSF's Back-Cover Text.
@
text
@d1160 1
a1160 1
There is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"
@


1.123
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d1158 4
a1161 4
GDB is free software, covered by the GNU General Public License, and you are\n\
welcome to change it and/or distribute copies of it under certain conditions.\n\
Type \"show copying\" to see the conditions.\n\
There is absolutely no warranty for GDB.  Type \"show warranty\" for details.\n");
@


1.122
log
@2007-08-08  Michael Snyder  <msnyder@@access-company.com>

	* top.c (command_line_input): Memory leak.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.121
log
@2007-07-01  Daniel Jacobowitz  <dan@@codesourcery.com>

	* top.c (gdb_readline_wrapper_line): Call rl_callback_handler_remove.
	(struct gdb_readline_wrapper_cleanup): Remove prompt_orig.
	(gdb_readline_wrapper_cleanup): Do not reset the prompt.
	(gdb_readline_wrapper): Do not save the prompt.  Pass our prompt
	to display_gdb_prompt.

2007-07-01  Nick Roberts  <nickrob@@snap.net.nz>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb.base/annota3.exp: Test for if construct.
@
text
@a1095 1
	  xfree (history_value);
d1097 1
@


1.120
log
@	* defs.h (deprecated_registers_changed_hook): Delete declaration.
	* interps.c (clear_interpreter_hooks): Do not clear
	deprecated_registers_changed_hook.
	* regcache.c (registers_changed): Do not call it.
	* top.c (deprecated_registers_changed_hook): Do not define it.
	* mi/mi-interp.c (mi_command_loop): Do not clear it.
	* tui/tui-hooks.c (tui_install_hooks): Do not install it.
	(tui_remove_hooks): Do not remove it.
	(tui_selected_frame_level_changed_hook): Check for negative level.
	Use get_selected_frame.
	(tui_registers_changed_hook): Deleted.
@
text
@d754 5
a763 1
    char *prompt_orig;
a772 1
  PROMPT (0) = cleanup->prompt_orig;
a795 2
  cleanup->prompt_orig = get_prompt ();
  PROMPT (0) = prompt;
d801 1
a801 1
  display_gdb_prompt (NULL);
@


1.119
log
@	* top.c (gdb_readline_wrapper_cleanup): Remove invalid assertion.
@
text
@a273 5
/* Called when the registers have changed, as a hint to a GUI
   to minimize window update. */

void (*deprecated_registers_changed_hook) (void);

@


1.118
log
@Copyright updates for 2007.
@
text
@a772 1
  gdb_assert (rl_already_prompted == 1);
@


1.117
log
@2007-01-03  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* Makefile.in (top.o): Update.
	* top.c (gdb_readline_wrapper_done, gdb_readline_wrapper_result)
	(saved_after_char_processing_hook, gdb_readline_wrapper_line)
	(struct gdb_readline_wrapper_cleanup, gdb_readline_wrapper_cleanup):
	New.
	(gdb_readline_wrapper): Rewrite to use asynchronous readline.

2007-01-03  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb.base/readline.exp: Set $TERM.  Test arrow keys in
	secondary prompts.
@
text
@d3 2
a4 2
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
@


1.116
log
@        Followed the Start of New Year Procedure:
        * ChangeLog-2006: New file, containing all the entries for 2006.
        * ChangeLog: Removed all 2006 entries, and changed the reference
        to the previous ChangeLog to point to ChangeLog 2006.
        * top.c (print_gdb_version): Update copyright year.
@
text
@d50 1
d716 1
a716 1
   gdb can use readline in both the synchronous and async modes during
d721 67
a787 4
   `define'), gdb just calls readline() directly, running it in
   synchronous mode.  So for operate-and-get-next to work in this
   situation, we have to switch the hooks around.  That is what
   gdb_readline_wrapper is for.  */
d791 18
a808 1
  /* Set the hook that works in this case.  */
d810 2
a811 4
    {
      rl_pre_input_hook = (Function *) after_char_processing_hook;
      after_char_processing_hook = NULL;
    }
d813 8
a820 1
  return readline (prompt);
@


1.115
log
@2006-07-21  Andrew Stubbs  <andrew.stubbs@@st.com>

	* cli/cli-cmds.c (source_verbose, trace_commands): New variables.
	(source_script): New function.
	(source_verbose_cleanup): New function.
	(source_command): Move old contents to source_script.
	Make function static. Parse -v option and call source_script.
	(init_cli_cmds): Update source command help.
	Add 'set trace-commands' command.
	* cli/cli-script.c (command_next_depth): New static variable.
	(suppress_next_print_command_trace): New static variable.
	(reset_command_nest_depth): New function.
	(print_command_trace): New function.
	(execute_control_command): Split the continue_control and break_control
	cases, add calls to print_command_trace and count the nest depth.
	(while_command): Set suppress_next_print_command_trace.
	(if_command): Likewise.
	* top.c (execute_command): Call print_command_trace.
	* cli/cli-cmds.h (source_verbose, trace_commands): New extern variables.
	(source_command): Change to source_script.
	* main.c (captued_main): Use source_script instead of source_command.
	* top.h (source_command): Change to source_script.
	* event-top.c (display_gdb_prompt): Call reset_command_nest_depth.
	* cli/cli-script.h (print_command_trace): Export.
	(reset_command_nest_depth): Likewise.

docs/
	* gdb.texinfo (Optional warnings and messages): Add
	'set/show trace-commands'.
	(Command files): Add '-v' to source command.

testsuite/
	* gdb.base/default.exp: Update source command error message.
	* gdb.base/help.exp: Update 'help source' message.
@
text
@d1071 1
a1071 1
  fprintf_filtered (stream, "Copyright (C) 2006 Free Software Foundation, Inc.\n");
@


1.114
log
@	* Makefile.in (utils.o): Update.
	* top.c (in_user_command): New.
	(command_line_input): Use input_from_terminal_p.
	(input_from_terminal_p): Don't check caution.  Handle
	stdin == NULL for Insight.
	* top.h (in_user_command, caution): New declarations.
	* utils.c: Include "top.h".
	(query, defaulted_query): Check caution here.  Move the call
	to input_from_terminal_p higher.
	* cli/cli-script.c (do_restore_user_call_depth): Only decrement
	the depth.  Update in_user_command if necessary.
	(execute_user_command): Don't clobber old_chain.  Set
	in_user_command.  Let do_restore_user_call_depth handle
	user_call_depth.
	(read_command_lines): Check whether to prompt before calling
	Insight hooks.
	* tui/tui-hooks.c (tui_query_hook): Remove newly unnecessary
	input_from_terminal_p check.
@
text
@d403 3
@


1.114.8.1
log
@2006-05-13    Changes based on Apple GDB (CVS repository 5th Sept 2005)

	* async-nat-inferior.c, async-nat-inferior.h,
	* async-nat-sigthread.c, async-nat-sigthread.h: New files

	* linux-nat.c: Include async-nat-inferior.h.
	(linux_nat_wait): Add extra argument.  If target_can_async_p
	do something completely different.

	* interps.h (interp_set, interp_set_quiet): New externs.

	* interps.c (interp_set): Make asynchronous.
	(interp_set_quiet): Don't make static.
	(current_interp_command_loop): Call functions with new arguments.

	* target.h (target_wait): Add extra argument.
	(gdb_override_async, gdb_set_async_override) New externs.
	(target_can_async_p): Make conditional on gdb_override_async.

	* target.c (gdb_override_async): New variable.
	(gdb_set_async_override, do_restore_target_async_mask):
	New functions.
	(debug_to_wait): Add extra argument.

	* linux-thread-db.c (thread_db_wait): Add extra argument.

	* wrapper.h (safe_execute_command): Declare structure.

	* top.c (*deprecated_target_wait_hook): Add extra argument.
	(read_command_file): Make asynchronous.

	* remote.c (remote_wait, remote_async_wait): Add extra argument.

	* infrun.c: Include event-top.h
	(wait_for_inferior, fetch_inferior_event): Add extra argument to
	target_wait.
	(proceed): Set target_executing = 0.
	(handle_inferior_event): Call async_disable_stdin if async.

	* inf-ptrace.c: Include inf-loop.h, async-nat-inferior.h.
	(inf_ptrace_him): Create a signal thread.
	(inf_ptrace_wait): Add extra argument to target_wait.

	* inf-loop.c (inferior_event_handler, complete_execution):
	Changes for asynchronous operation (copied verbatim).

	* inf-child.c: Include async-nat-inferior.h.
	(inf_child_target): Use methods async_terminal_inferior
	and async_terminal_ours.

	* i386-linux-nat.c: Include inf-loop.h, async-nat-inferior.h.
	(i386_linux_resume): Call gdb_process_events and then
	async methods.

	* exec.c: Include event-loop.h, async-nat-inferior.h.
	(async_file_handler, standard_async, standard_is_async_p)
	(standard_can_async_p): New functions.
	(init_exec_ops): Initialise above methods.

	* event-top.h (cli_command_loop): Make argument void*.

	* event-top.c (display_gdb_prompt, async_enable_stdin)
	(async_disable_stdin, handle_sigint, async_request_quit)
	(gdb_setup_readline, _initialize_event_loop):
	Changes for asynchronous operation (copied verbatim).
	(cli_command_loop): Make argument void*.

	* event-loop.h (gdb_client_data): Move typedef to defs.h.
	(gdb_create_event): Declare.
	(event_handler_func): Move typedef from event-loop.c.

	* event-loop.c (use_poll): Set to 0.
	(gdb_queue_event, gdb_create_event): New functions.
	(async_queue_event): Don't make static.
	(create_file_event): Use gdb_create_event.
	(gdb_event): Change component from int to void*.
	(process_event, handle_file_event, handle_timer_event):
	Change according to gdb_event.
	(event_handler_func): Move typedef to event-loop.c.

	* defs.h: (gdb_mi_run_status, event_loop_p): New externs.
	(gdb_client_data): Move typedef from event-loop.h.
	(*deprecated_command_loop_hook): Make argument void*.
	(*deprecated_target_wait_hook): Add argument.

	* cli-out.h (cli_quoted_out_new): Declare.

	* cli-out.c (cli_quoted_out_new): New function.
	Include mi/mi-console.h.

	* cli/cli-interp.c: Include inferior.h, mi/mi-console.h.
	(safe_execute_command): Make static.
	(cli_interpreter_resume, cli_interpreter_exec):
	Make asynchronous.
	(cli_quoted_interpreter_resume): New function.
	(_initialize_cli_interp): Add li_command_loop to procs.
	Initialize the console-quoted interpreter.

	* tui/tui-hooks.c (tui_target_wait_hook): Add extra argument.

	* mi/mi-main.h (mi_dont_register_continuation)
	(current_command_token,  mi_interp, mi_interpreter_exec_continuation)
	(mi_continuation_arg): New externs.
	(mi_setup_continuation_arg): Declare.

	* mi/mi-main.c: Include wrapper.h.
	(struct mi_continuation_arg): New structure.
	(mi_interpreter_exec_continuation): Move to mi-interp.c.
	(mi_execute_async_cli_command)
	(mi_exec_async_cli_cmd_continuation): Make asynchronous.
	(mi_setup_continuation_arg): New function.

	* mi/mi-interp.c (mi_interpreter_exec_continuation):
	Move from mi-main.c
	(mi_cmd_interpreter_exec): Switch interpreters.  Make
	asynchronous.
	(mi1_command_loop, mi2_command_loop, mi3_command_loop):
	Make argument void*.

	* Makefile.in (async_nat_inferior_h, async_nat_sigthread_h):
	New variables.
	(gdb$(EXEEXT), $(TUI)$(EXEEXT)): Link with libpthread.
	(async-nat-inferior.o, async-nat-sigthread.o): New rules.
	(COMMON_OBS): Add above object files.
	(exec.o, i386-linux-nat.o, inf-ptrace.o, linux-nat.o):
	Update dependencies.

2006-05-13  Nick Roberts  <nickrob@@snap.net.nz>

	* main.c: (event_loop_p): Re-instate variable.
	(captured_main): Re-instate async/noasync option.
	(print_gdb_help): Describe option again.

	* exec.c(init_exec_ops): Only initialise async methods with async
	option.

	* inf-ptrace.c (inf_ptrace_him): Only reate a signal thread with
	async option.

	* README.async, TODO.async, PROBLEMS.async: New files.
@
text
@d224 1
a224 1
void (*deprecated_command_loop_hook) (void *data);
d290 1
a290 2
				       struct target_waitstatus * status,
				       gdb_client_data client_data);
a357 20

  /* You can't run command files for gdb asynchronously.  If there
     were a "wait till done" gdb command that you could put in a
     command file, then this would make sense.  But otherwise things
     like:

     step
     print somevar

     won't work correctly.  So for command files, we temporarily force
     the target to run synchronously.  */

  if (target_can_async_p ()) 
    { 
      void *on;
      on = (void *)1;
      gdb_set_async_override (on); 
      make_cleanup (gdb_set_async_override, &on); 
    }

@


1.114.8.2
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a423 3
      /* If trace-commands is set then this will print this command.  */
      print_command_trace (p);

@


1.113
log
@	* NEWS: Mention native Windows support.
	* Makefile.in (gdb_select_h, ser_tcp_h): New.
	(ALLDEPFILES): Add ser-mingw.c.
	(event-loop.o, inflow.o, mingw-hdep.o, posix-hdep.o, ser-base.o)
	(ser-tcp.o, ser-unix.o): Update.
	(ser-mingw.o): New rule.
	* configure: Regenerated.
	* configure.ac: Add ser-mingw.o for mingw32.
	* ser-mingw.c: New file.
	* event-loop.c: Include "gdb_select.h".
	(gdb_select): Remove, moved to mingw-hdep.c and posix-hdep.c.
	* ser-base.c: Include "gdb_select.h".
	(ser_base_wait_for): Use gdb_select.
	* serial.c (serial_for_fd): New function.
	(serial_fdopen): Try "terminal" before "hardwire".  Initialize
	the allocated struct serial.
	(serial_wait_handle): New function.
	* serial.h (serial_for_fd, serial_wait_handle): New prototypes.
	(struct serial_ops) [USE_WIN32API]: Add wait_handle.
	* gdb_select.h: New file.
	* ser-tcp.c: Include "ser-tcp.h".  Remove unused "ser-unix.h" include.
	(net_close, net_read_prim, net_write_prim): Make global.
	(net_open): Likewise.  Pass an exception set to select.  Whitespace fix.
	Document why we can not use gdb_select.
	(_initialize_ser_tcp) [USE_WIN32API]: Do not register TCP support here.
	* ser-tcp.h: New file.
	* inflow.c (gdb_has_a_terminal): Don't initialize stdin_serial here.
	(handle_sigio): Use gdb_select.
	(initialize_stdin_serial): New function.
	* terminal.h (initialize_stdin_serial): New prototype.
	* top.c (gdb_init): Call initialize_stdin_serial.
	* mingw-hdep.c (gdb_select): New function, moved from gdb_select in
	event-loop.c.  Add exception condition support.  Use serial_for_fd
	and serial_wait_handle.  Fix timeout handling.
	* posix-hdep.c: Include "gdb_select.h".
	(gdb_select): New function.
	* remote-st.c (connect_command): Use gdb_select.
	* ser-unix.c: Include "gdb_select.h".
	(hardwire_send_break, wait_for): Use gdb_select.
@
text
@d115 4
d916 1
a916 1
      if (deprecated_readline_hook && instream == NULL)
d920 1
a920 1
      else if (command_editing_p && instream == stdin && ISATTY (instream))
d1204 2
a1205 2
/* Returns whether GDB is running on a terminal and whether the user
   desires that questions be asked of them on that terminal.  */
d1210 10
a1219 1
  return gdb_has_a_terminal () && (instream == stdin) & caution;
@


1.113.2.1
log
@	* configure.ac: Accept --with-versuffix and --with-bugurl.
	* configure: Regenerate.
	* Makefile.in: (VERSUFFIX_s, BUGURL_s): New.
	(GDB_FLAGS): Add -DVERSUFFIX and -DBUGURL.
	* top.c (print_gdb_version): Print VERSUFFIX and BUGURL.
@
text
@d1060 1
a1060 1
  fprintf_filtered (stream, "GNU gdb %s%s\n", version, VERSUFFIX);
a1088 9

  if (strlen (BUGURL))
    {
      fprintf_filtered (stream, 
                        _("\nFor bug reporting instructions, please see:\n"));
      fprintf_filtered (stream, "%s.\n", BUGURL);
    }


@


1.112
log
@	* top.c (control_level): Remove unused variable.
@
text
@d1553 2
@


1.111
log
@        * top.c: Add 2006 to list of copyright years in file header.
@
text
@a186 3
/* Level of control structure.  */
static int control_level;

@


1.110
log
@        * top.c (print_gdb_version): Update copyright year to 2006.
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
@


1.109
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d1067 1
a1067 1
  fprintf_filtered (stream, "Copyright (C) 2005 Free Software Foundation, Inc.\n");
@


1.108
log
@        * top.c (print_gdb_version): Update copyright year.
@
text
@d3 1
a3 1
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d1067 1
a1067 1
  fprintf_filtered (stream, "Copyright 2005 Free Software Foundation, Inc.\n");
@


1.107
log
@2005-11-07  Andrew Stubbs  <andrew.stubbs@@st.com>

	* main.h (return_child_result, return_child_result_value): Declare.
	* infrun.c: Include main.h.
	(print_stop_reason): Remove declaration of return_child_result_value.
	* top.c: Include main.h.
	(quit_force): Remove declarations of return_child_result_value and
	return_child_result.
	* Makefile.in (top.o, infrun.o): Add main.h to dependencies.
@
text
@d1067 1
a1067 1
  fprintf_filtered (stream, "Copyright 2004 Free Software Foundation, Inc.\n");
@


1.106
log
@2005-11-04  Andrew Stubbs  <andrew.stubbs@@st.com>

	* infrun.c (print_stop_reason): Set return_child_result_value on exit.
	* main.c (return_child_result): New variable.
	(return_child_result_value): Likewise.
	(captured_main): Add option --return-child-result.
	Replace call to target_detach and exit (in batch mode) with quit_force.
	(print_gdb_help): Add option --return-child-result.
	* top.c (quit_force): Return child result if appropriate.

docs/
	* gdb.texinfo (Choosing modes): Add --return-child-result.
@
text
@d49 1
a1180 1
  extern int return_child_result, return_child_result_value;
@


1.105
log
@* bsd-kvm.c (bsd_kvm_open): Properly cast sentinel in concat call.
* coffread.c (patch_type, process_coff_symbol): Likewise.
* corelow.c (core_open): Likewise.
* dwarf2read.c (dwarf_decode_lines, dwarf2_start_subfile):
* language.c (set_lang_str, set_type_str, set_range_str)
(set_case_str): Likewise.
* source.c (add_path, openp): Likewise.
* stabsread.c: Likewise.
* top.c (init_history): Likewise.
* utils.c (xfullpath): Likewise.
* value.c (lookup_internalvar): Likewise.
* cli/cli-cmds.c (cd_command): Likewise.
* cli/cli-dump.c (add_dump_command): Likewise.
@
text
@d1180 1
d1190 2
@


1.105.4.1
log
@2005-11-14  Andrew Stubbs  <andrew.stubbs@@st.com>

	* infrun.c: Include main.h.
	(print_stop_reason): Set return_child_result_value on exit.
	* main.c (return_child_result): New variable.
	(return_child_result_value): Likewise.
	(captured_main): Add option --return-child-result.
	Replace call to target_detach and exit (in batch mode) with quit_force.
	(print_gdb_help): Add option --return-child-result.
	* top.c: Include main.h.
	(quit_force): Return child result if appropriate.
	* main.h (return_child_result, return_child_result_value): Declare.
	* Makefile.in (top.o, infrun.o): Add main.h to dependencies.

doc/
	* gdb.texinfo (Choosing modes): Add --return-child-result.
@
text
@a48 1
#include "main.h"
a1188 2
  else if (return_child_result)
    exit_code = return_child_result_value;
@


1.105.4.2
log
@        * top.c (print_gdb_version): Update copyright year.
@
text
@d1067 1
a1067 1
  fprintf_filtered (stream, "Copyright 2005 Free Software Foundation, Inc.\n");
@


1.104
log
@
	* Makefile.in (go32-nat.o): Add $(top_h) to prerequisites.

	* go32-nat.c: Include top.h.  Update copyright years.
	(init_go32_ops): Override the default value of gdbinit[] with
	"gdb.ini".

	* cli/cli-cmds.c (init_cli_cmds): Use gdbinit[] instead of a
	compile-time literal string GDBINIT_FILENAME.

	* top.c (PATH_MAX): Define if not defined.
	(gdbinit): Declare with a constant size PATH_MAX.

	* config/i386/go32.mh (XM_FILE): Remove.

	* config/i386/xm-go32.h: Remove file.
@
text
@d1373 2
a1374 1
      history_filename = concat (current_directory, "/_gdb_history", NULL);
d1376 2
a1377 1
      history_filename = concat (current_directory, "/.gdb_history", NULL);
@


1.103
log
@2005-02-24  Andrew Cagney  <cagney@@gnu.org>

	Add show_VARIABLE functions, update add_setshow call.
	* varobj.c (_initialize_varobj, show_varobjdebug): Add and update.
	* valprint.c (_initialize_valprint, show_print_max)
	(show_stop_print_at_null, show_repeat_count_threshold)
	(show_prettyprint_structs, show_unionprint)
	(show_prettyprint_arrays, show_addressprint, show_input_radix)
	(show_output_radix): Ditto.
	* valops.c (_initialize_valops, show_overload_resolution): Ditto.
	* utils.c (initialize_utils, show_chars_per_line)
	(show_lines_per_page, show_demangle, show_pagination_enabled)
	(show_sevenbit_strings, show_asm_demangle): Ditto
	* tui/tui-win.c (_initialize_tui_win, show_tui_border_kind)
	(show_tui_border_mode, show_tui_active_border_mode): Ditto.
	* top.c (init_main, show_new_async_prompt)
	(show_async_command_editing_p, show_write_history_p)
	(show_history_size, show_history_filename, show_caution)
	(show_annotation_level, init_main): Ditto.
	* target.c (initialize_targets, show_targetdebug)
	(show_trust_readonly): Ditto.
	* symfile.c (_initialize_symfile, show_symbol_reloading)
	(show_ext_args, show_download_write_size)
	(show_debug_file_directory): Ditto.
	* source.c (_initialize_source, show_lines_to_list): Ditto.
	* solib.c (_initialize_solib, show_auto_solib_add)
	(show_solib_search_path): Ditto.
	* p-valprint.c (_initialize_pascal_valprint)
	(show_pascal_static_field_print): Ditto.
	* printcmd.c (_initialize_printcmd, show_max_symbolic_offset)
	(show_print_symbol_filename): Add and update.
	* parse.c (_initialize_parse, show_expressiondebug): Dito.
	* observer.c (_initialize_observer, show_observer_debug): Dito.
	* maint.c (_initialize_maint_cmds, show_watchdog)
	(show_maintenance_profile_p): Dito.
	* linux-nat.c (_initialize_linux_nat, show_debug_linux_nat): Dito.
	* infrun.c (_initialize_infrun, show_debug_infrun)
	(show_stop_on_solib_events, show_follow_fork_mode_string)
	(show_scheduler_mode, show_step_stop_if_no_debug): Ditto.
	* infcall.c (_initialize_infcall, show_coerce_float_to_double_p)
	(show_unwind_on_signal_p): Ditto.
	* gdbtypes.c (build_gdbtypes, show_opaque_type_resolution)
	(_initialize_gdbtypes, show_overload_debug): Ditto.
	* gdb-events.c, gdb-events.sh (_initialize_gdb_events)
	(show_gdb_events_debug): Ditto.
	* gdbarch.c, gdbarch.sh (show_gdbarch_debug)
	(_initialize_gdbarch): Ditto.
	* frame.c (_initialize_frame, show_backtrace_past_main)
	(show_backtrace_past_entry, show_backtrace_limit)
	(show_frame_debug): Ditto.
	* exec.c (_initialize_exec, show_write_files): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read)
	(show_dwarf2_max_cache_age): Ditto.
	* demangle.c (_initialize_demangler)
	(show_demangling_style_names): Ditto.
	* dcache.c (_initialize_dcache, show_dcache_enabled_p): Ditto.
	* cp-valprint.c (show_static_field_print)
	(_initialize_cp_valprint, show_vtblprint, show_objectprint): Ditto.
	* corefile.c (_initialize_core, show_gnutarget_string): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging)
	(show_logging_overwrite, show_logging_redirect)
	(show_logging_filename): Ditto.
	* cli/cli-cmds.c (show_info_verbose, show_history_expansion_p)
	(init_cli_cmds, show_baud_rate, show_remote_debug)
	(show_remote_timeout, show_max_user_call_depth): Ditto.
	* charset.c (show_host_charset_name, show_target_charset_name)
	(initialize_charset): Ditto.
	* breakpoint.c (show_can_use_hw_watchpoints)
	(show_pending_break_support, _initialize_breakpoint): Ditto.
@
text
@d74 8
d85 1
a85 1
char gdbinit[] = GDBINIT_FILENAME;
@


1.102
log
@2005-02-21  Andrew Cagney  <cagney@@gnu.org>

	Add more uses of add_setshow_string_cmd, add_setshow_integer_cmd,
	and add_setshow_string_noescape_cmd.
	* cli/cli-setshow.c (deprecated_show_value_hack): Do not print a
	NULL command's value.
	* kod.c, language.c, ocd.c, remote-e7000.c, remote-mips.c: Update.
	* remote-sds.c, remote.c, symfile.c, top.c: Update.
@
text
@d91 8
d666 1
d670 1
d672 1
d674 8
d683 8
d692 8
d1374 31
d1448 1
a1448 1
			  NULL, /* FIXME: i18n: */
d1464 1
a1464 1
			   NULL, /* FIXME: i18n: */
d1473 1
a1473 1
			   NULL, /* FIXME: i18n: */
d1481 1
a1481 1
			   NULL, /* FIXME: i18n: */
d1489 1
a1489 1
			    NULL, /* FIXME: i18n: */
d1496 1
a1496 1
			   NULL, /* FIXME: i18n: */
d1505 1
a1505 1
			    NULL, /* FIXME: i18n: */
d1514 1
a1514 1
			   NULL, /* FIXME: i18n: */
@


1.101
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_zinteger_cmd through out.  Re-sync gdbarch.sh
	and gdbarch.c.
	* breakpoint.c, frame.c, gdb-events.sh, gdbarch.sh: Update.
	* gdbtypes.c, infrun.c, linux-nat.c, maint.c, monitor.c: Update.
	* pa64solib.c, parse.c, remote-mips.c, ser-go32.c: Update.
	* serial.c, solib-frv.c, somsolib.c, target.c, top.c: Update.
	* varobj.c, cli/cli-cmds.c: Update.
	* gdbarch.c, gdb-events.c: Regenerate.
@
text
@d1377 7
a1383 5
  c = add_set_cmd ("prompt", class_support, var_string,
		   (char *) &new_async_prompt, "Set gdb's prompt",
		   &setlist);
  deprecated_add_show_from_set (c, &showlist);
  set_cmd_sfunc (c, set_async_prompt);
d1410 15
a1424 12
  c = add_set_cmd ("size", no_class, var_integer, (char *) &history_size,
		   "Set the size of the command history,\n\
ie. the number of previous commands to keep a record of.", &sethistlist);
  deprecated_add_show_from_set (c, &showhistlist);
  set_cmd_sfunc (c, set_history_size_command);

  c = add_set_cmd ("filename", no_class, var_filename,
		   (char *) &history_filename,
		   "Set the filename in which to record the command history\n\
(the list of previous commands of which a record is kept).", &sethistlist);
  set_cmd_completer (c, filename_completer);
  deprecated_add_show_from_set (c, &showhistlist);
@


1.100
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_boolean_command through out.  Delete #ifdef 0'ed
	code adding set/show boolean commands.
	* cp-valprint.c, dcache.c, exec.c, gdbtypes.c, infrun.c: Update.
	* monitor.c, p-valprint.c, pa64solib.c, printcmd.c: Update.
	* proc-api.c, remote-mips.c, remote.c, solib.c: Update.
	* somsolib.c, symfile.c, top.c, utils.c, valops.c: Update.
	* valprint.c, win32-nat.c, wince.c, xcoffsolib.c: Update.
	* cli/cli-cmds.c: Update.
@
text
@d1428 3
a1430 2
  c = add_set_cmd ("annotate", class_obscure, var_zinteger,
		   (char *) &annotation_level, "Set annotation_level.\n\
d1432 4
a1435 4
2 == output annotated suitably for use by programs that control GDB.",
		   &setlist);
  deprecated_add_show_from_set (c, &showlist);
  set_cmd_sfunc (c, set_async_annotation_level);
@


1.99
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d1388 4
a1391 2
  c = add_set_cmd ("editing", class_support, var_boolean, (char *) &async_command_editing_p,
		   "Set editing of command lines as they are typed.\n\
d1394 8
a1401 8
EMACS-like or VI-like commands like control-P or ESC.", &setlist);

  deprecated_add_show_from_set (c, &showlist);
  set_cmd_sfunc (c, set_async_editing_command);

  deprecated_add_show_from_set
    (add_set_cmd ("save", no_class, var_boolean, (char *) &write_history_p,
		  "Set saving of the history record on exit.\n\
d1403 4
a1406 2
Without an argument, saving is enabled.", &sethistlist),
     &showhistlist);
d1421 6
a1426 6
  deprecated_add_show_from_set
    (add_set_cmd ("confirm", class_support, var_boolean,
		  (char *) &caution,
		  "Set whether to confirm potentially dangerous operations.",
		  &setlist),
     &showlist);
d1436 8
a1443 5
  deprecated_add_show_from_set
    (add_set_cmd ("exec-done-display", class_support, var_boolean, (char *) &exec_done_display_p,
		  "Set notification of completion for asynchronous execution commands.\n\
Use \"on\" to enable the notification, and \"off\" to disable it.", &setlist),
     &showlist);
@


1.98
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d1383 2
a1384 1
  add_com ("dont-repeat", class_support, dont_repeat_command, "Don't repeat this command.\n\
d1386 1
a1386 1
hitting return.");
@


1.97
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d522 1
a522 1
	  printf_unfiltered ("Command execution time: %ld.%06ld\n",
d533 1
a533 1
	  printf_unfiltered ("Space used: %ld (%c%ld for this command)\n",
d1268 1
a1268 1
  printf_unfiltered ("\"set history\" must be followed by the name of a history subcommand.\n");
@


1.96
log
@2005-01-17  Andrew Cagney  <cagney@@gnu.org>

	* top.h (source_error, source_pre_error): Delete declaration.
	* cli/cli-script.c (source_error_allocated, source_error): Delete.
	(script_from_file, source_cleanup_lines): Do not manipulate
	source_error_allocated, error_pre_print and source_error.
	(struct source_cleanup_lines_args): Delete fields old_pre_error,
	and old_error_pre_print.
	* top.c (source_error_allocated, source_error)
	(source_pre_error): Delete.
	(command_line_input): Do not set error_pre_print.
	* event-top.c (command_line_handler): Do not set error_pre_print.
@
text
@d394 1
a394 1
	  error ("Cannot execute this command while the target is running.");
d430 1
a430 1
	error ("That is not a command, just a help topic.");
d726 1
a726 1
  error ("Erroneous arithmetic operation.");
d1261 1
a1261 1
      error ("History size must be non-negative");
@


1.95
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
a321 15
/* Buffer containing the error_pre_print used by the source stuff.
   Malloc'd.  */
/* NOTE 1999-04-29: This variable will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c */
/* static */ char *source_error;
static int source_error_allocated;

/* Something to glom on to the start of error_pre_print if source_file_name
   is set.  */
/* NOTE 1999-04-29: This variable will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c */
/* static */ char *source_pre_error;

d861 1
a861 9
	{
	  ++source_line_number;
	  sprintf (source_error,
		   "%s%s:%d: Error in sourced command file:\n",
		   source_pre_error,
		   source_file_name,
		   source_line_number);
	  error_pre_print = source_error;
	}
@


1.94
log
@* top.c (gdb_readline): Always accept "rn" as a line-ending.
* event-top.c (gdb_readline2): Likewise.
@
text
@d33 1
a58 2
#include <setjmp.h>

a292 283


/* One should use catch_errors rather than manipulating these
   directly.  */
#if defined(HAVE_SIGSETJMP)
#define SIGJMP_BUF		sigjmp_buf
#define SIGSETJMP(buf)		sigsetjmp((buf), 1)
#define SIGLONGJMP(buf,val)	siglongjmp((buf), (val))
#else
#define SIGJMP_BUF		jmp_buf
#define SIGSETJMP(buf)		setjmp(buf)
#define SIGLONGJMP(buf,val)	longjmp((buf), (val))
#endif

/* Where to go for throw_exception().  */
static SIGJMP_BUF *catch_return;

/* Return for reason REASON to the nearest containing catch_errors().  */

NORETURN void
throw_exception (enum return_reason reason)
{
  quit_flag = 0;
  immediate_quit = 0;

  /* Perhaps it would be cleaner to do this via the cleanup chain (not sure
     I can think of a reason why that is vital, though).  */
  bpstat_clear_actions (stop_bpstat);	/* Clear queued breakpoint commands */

  disable_current_display ();
  do_cleanups (ALL_CLEANUPS);
  if (target_can_async_p () && !target_executing)
    do_exec_cleanups (ALL_CLEANUPS);
  if (sync_execution)
    do_exec_error_cleanups (ALL_CLEANUPS);

  if (annotation_level > 1)
    switch (reason)
      {
      case RETURN_QUIT:
	annotate_quit ();
	break;
      case RETURN_ERROR:
	annotate_error ();
	break;
      }

  /* Jump to the containing catch_errors() call, communicating REASON
     to that call via setjmp's return value.  Note that REASON can't
     be zero, by definition in defs.h. */

  (NORETURN void) SIGLONGJMP (*catch_return, (int) reason);
}

/* Call FUNC() with args FUNC_UIOUT and FUNC_ARGS, catching any
   errors.  Set FUNC_CAUGHT to an ``enum return_reason'' if the
   function is aborted (using throw_exception() or zero if the
   function returns normally.  Set FUNC_VAL to the value returned by
   the function or 0 if the function was aborted.

   Must not be called with immediate_quit in effect (bad things might
   happen, say we got a signal in the middle of a memcpy to quit_return).
   This is an OK restriction; with very few exceptions immediate_quit can
   be replaced by judicious use of QUIT.

   MASK specifies what to catch; it is normally set to
   RETURN_MASK_ALL, if for no other reason than that the code which
   calls catch_errors might not be set up to deal with a quit which
   isn't caught.  But if the code can deal with it, it generally
   should be RETURN_MASK_ERROR, unless for some reason it is more
   useful to abort only the portion of the operation inside the
   catch_errors.  Note that quit should return to the command line
   fairly quickly, even if some further processing is being done.  */

/* MAYBE: cagney/1999-11-05: catch_errors() in conjunction with
   error() et.al. could maintain a set of flags that indicate the the
   current state of each of the longjmp buffers.  This would give the
   longjmp code the chance to detect a longjmp botch (before it gets
   to longjmperror()).  Prior to 1999-11-05 this wasn't possible as
   code also randomly used a SET_TOP_LEVEL macro that directly
   initialize the longjmp buffers. */

/* MAYBE: cagney/1999-11-05: Should the catch_errors and cleanups code
   be consolidated into a single file instead of being distributed
   between utils.c and top.c? */

static void
catcher (catch_exceptions_ftype *func,
	 struct ui_out *func_uiout,
	 void *func_args,
	 int *func_val,
	 enum return_reason *func_caught,
	 char *errstring,
	 char **gdberrmsg,
	 return_mask mask)
{
  SIGJMP_BUF *saved_catch;
  SIGJMP_BUF catch;
  struct cleanup *saved_cleanup_chain;
  char *saved_error_pre_print;
  char *saved_quit_pre_print;
  struct ui_out *saved_uiout;

  /* Return value from SIGSETJMP(): enum return_reason if error or
     quit caught, 0 otherwise. */
  int caught;

  /* Return value from FUNC(): Hopefully non-zero. Explicitly set to
     zero if an error quit was caught.  */
  int val;

  /* Override error/quit messages during FUNC. */

  saved_error_pre_print = error_pre_print;
  saved_quit_pre_print = quit_pre_print;

  if (mask & RETURN_MASK_ERROR)
    error_pre_print = errstring;
  if (mask & RETURN_MASK_QUIT)
    quit_pre_print = errstring;

  /* Override the global ``struct ui_out'' builder.  */

  saved_uiout = uiout;
  uiout = func_uiout;

  /* Prevent error/quit during FUNC from calling cleanups established
     prior to here. */

  saved_cleanup_chain = save_cleanups ();

  /* Call FUNC, catching error/quit events. */

  saved_catch = catch_return;
  catch_return = &catch;
  caught = SIGSETJMP (catch);
  if (!caught)
    val = (*func) (func_uiout, func_args);
  else
    {
      val = 0;
      /* If caller wants a copy of the low-level error message, make one.  
         This is used in the case of a silent error whereby the caller
         may optionally want to issue the message.  */
      if (gdberrmsg)
	*gdberrmsg = error_last_message ();
    }
  catch_return = saved_catch;

  /* FIXME: cagney/1999-11-05: A correct FUNC implementation will
     clean things up (restoring the cleanup chain) to the state they
     were just prior to the call.  Unfortunately, many FUNC's are not
     that well behaved.  This could be fixed by adding either a
     do_cleanups call (to cover the problem) or an assertion check to
     detect bad FUNCs code. */

  /* Restore the cleanup chain, the error/quit messages, and the uiout
     builder, to their original states. */

  restore_cleanups (saved_cleanup_chain);

  uiout = saved_uiout;

  if (mask & RETURN_MASK_QUIT)
    quit_pre_print = saved_quit_pre_print;
  if (mask & RETURN_MASK_ERROR)
    error_pre_print = saved_error_pre_print;

  /* Return normally if no error/quit event occurred or this catcher
     can handle this exception.  The caller analyses the func return
     values.  */

  if (!caught || (mask & RETURN_MASK (caught)))
    {
      *func_val = val;
      *func_caught = caught;
      return;
    }

  /* The caller didn't request that the event be caught, relay the
     event to the next containing catch_errors(). */

  throw_exception (caught);
}

int
catch_exceptions (struct ui_out *uiout,
		  catch_exceptions_ftype *func,
		  void *func_args,
		  char *errstring,
		  return_mask mask)
{
  int val;
  enum return_reason caught;
  catcher (func, uiout, func_args, &val, &caught, errstring, NULL, mask);
  gdb_assert (val >= 0);
  gdb_assert (caught <= 0);
  if (caught < 0)
    return caught;
  return val;
}

int
catch_exceptions_with_msg (struct ui_out *uiout,
		  	   catch_exceptions_ftype *func,
		  	   void *func_args,
		  	   char *errstring,
			   char **gdberrmsg,
		  	   return_mask mask)
{
  int val;
  enum return_reason caught;
  catcher (func, uiout, func_args, &val, &caught, errstring, gdberrmsg, mask);
  gdb_assert (val >= 0);
  gdb_assert (caught <= 0);
  if (caught < 0)
    return caught;
  return val;
}

struct catch_errors_args
{
  catch_errors_ftype *func;
  void *func_args;
};

static int
do_catch_errors (struct ui_out *uiout, void *data)
{
  struct catch_errors_args *args = data;
  return args->func (args->func_args);
}

int
catch_errors (catch_errors_ftype *func, void *func_args, char *errstring,
	      return_mask mask)
{
  int val;
  enum return_reason caught;
  struct catch_errors_args args;
  args.func = func;
  args.func_args = func_args;
  catcher (do_catch_errors, uiout, &args, &val, &caught, errstring, 
	   NULL, mask);
  if (caught != 0)
    return 0;
  return val;
}

struct captured_command_args
  {
    catch_command_errors_ftype *command;
    char *arg;
    int from_tty;
  };

static int
do_captured_command (void *data)
{
  struct captured_command_args *context = data;
  context->command (context->arg, context->from_tty);
  /* FIXME: cagney/1999-11-07: Technically this do_cleanups() call
     isn't needed.  Instead an assertion check could be made that
     simply confirmed that the called function correctly cleaned up
     after itself.  Unfortunately, old code (prior to 1999-11-04) in
     main.c was calling SET_TOP_LEVEL(), calling the command function,
     and then *always* calling do_cleanups().  For the moment we
     remain ``bug compatible'' with that old code..  */
  do_cleanups (ALL_CLEANUPS);
  return 1;
}

int
catch_command_errors (catch_command_errors_ftype * command,
		      char *arg, int from_tty, return_mask mask)
{
  struct captured_command_args args;
  args.command = command;
  args.arg = arg;
  args.from_tty = from_tty;
  return catch_errors (do_captured_command, &args, "", mask);
}

@


1.93
log
@2004-09-13  Andrew Cagney  <cagney@@gnu.org>

	Eliminate event_loop_p, always has the value 1.
	* defs.h (event_loop_p): Delete macro.
	* breakpoint.c (until_break_command): Simplify.
	* utils.c (prompt_for_continue): Simplify.
	* tracepoint.c (read_actions): Simplify.
	* top.c (throw_exception, execute_command, gdb_readline_wrapper)
	(gdb_rl_operate_and_get_next, command_line_input, get_prompt)
	(set_prompt, init_main): Simplify.
	(init_signals, disconnect): Delete, unused.
	* remote.c (remote_async_resume)
	(extended_remote_async_create_inferior): Simplify.
	* mi/mi-interp.c (mi_input): Delete, unused.
	(mi_interpreter_resume, mi_command_loop): Simplify.
	* interps.c (current_interp_command_loop): Simplify.
	* infrun.c (proceed): Simplify.
	* infcmd.c (run_command, continue_command, step_1, jump_command)
	(until_command, advance_command, finish_command)
	(interrupt_target_command): Simplify.
	* event-top.c (gdb_setup_readline, gdb_disable_readline): Simplify.
@
text
@a934 3
#ifndef CRLF_SOURCE_FILES
	break;
#else
a939 1
#endif
@


1.92
log
@* defs.h (deprecated_error_hook): Remove RETURN and ATTR_NORETURN
from declaration.
* top.c (deprecated_error_hook): Remove RETURN and ATTR_NORETURN
from definition.
@
text
@d325 1
a325 1
  if (event_loop_p && target_can_async_p () && !target_executing)
d327 1
a327 1
  if (event_loop_p && sync_execution)
a580 2
/* Just a little helper function for disconnect().  */

a591 9

static void
disconnect (int signo)
{
  catch_errors (quit_cover, NULL,
	      "Could not kill the program being debugged", RETURN_MASK_ALL);
  signal (SIGHUP, SIG_DFL);
  kill (getpid (), SIGHUP);
}
d688 1
a688 1
      if (event_loop_p && target_can_async_p () && target_executing)
d983 1
a983 1
  if (event_loop_p && after_char_processing_hook)
a1043 31
static void
init_signals (void)
{
  signal (SIGINT, request_quit);

  /* If SIGTRAP was set to SIG_IGN, then the SIG_IGN will get passed
     to the inferior and breakpoints will be ignored.  */
#ifdef SIGTRAP
  signal (SIGTRAP, SIG_DFL);
#endif

  /* If we initialize SIGQUIT to SIG_IGN, then the SIG_IGN will get
     passed to the inferior, which we don't want.  It would be
     possible to do a "signal (SIGQUIT, SIG_DFL)" after we fork, but
     on BSD4.3 systems using vfork, that can affect the
     GDB process as well as the inferior (the signal handling tables
     might be in memory, shared between the two).  Since we establish
     a handler for SIGQUIT, when we call exec it will set the signal
     to SIG_DFL for us.  */
  signal (SIGQUIT, do_nothing);
#ifdef SIGHUP
  if (signal (SIGHUP, do_nothing) != SIG_IGN)
    signal (SIGHUP, disconnect);
#endif
  signal (SIGFPE, float_handler);

#if defined(SIGWINCH) && defined(SIGWINCH_HANDLER)
  signal (SIGWINCH, SIGWINCH_HANDLER);
#endif
}

d1075 2
a1076 11
  if (event_loop_p)
    {
      /* Use the async hook.  */
      after_char_processing_hook = gdb_rl_operate_and_get_next_completion;
    }
  else
    {
      /* This hook only works correctly when we are using the
	 synchronous readline.  */
      rl_pre_input_hook = (Function *) gdb_rl_operate_and_get_next_completion;
    }
d1152 1
a1152 6
    {
      if (event_loop_p)
	signal (STOP_SIGNAL, handle_stop_sig);
      else
	signal (STOP_SIGNAL, stop_sig);
    }
d1366 1
a1366 4
  if (event_loop_p)
    return PROMPT (0);
  else
    return gdb_prompt_string;
d1377 1
a1377 4
  if (event_loop_p)
    PROMPT (0) = savestring (s, strlen (s));
  else
    gdb_prompt_string = savestring (s, strlen (s));
d1654 17
a1670 26
  /* If we are running the asynchronous version,
     we initialize the prompts differently. */
  if (!event_loop_p)
    {
      gdb_prompt_string = savestring (DEFAULT_PROMPT, strlen (DEFAULT_PROMPT));
    }
  else
    {
      /* initialize the prompt stack to a simple "(gdb) " prompt or to
         whatever the DEFAULT_PROMPT is. */
      the_prompts.top = 0;
      PREFIX (0) = "";
      PROMPT (0) = savestring (DEFAULT_PROMPT, strlen (DEFAULT_PROMPT));
      SUFFIX (0) = "";
      /* Set things up for annotation_level > 1, if the user ever decides
         to use it. */
      async_annotation_suffix = "prompt";
      /* Set the variable associated with the setshow prompt command. */
      new_async_prompt = savestring (PROMPT (0), strlen (PROMPT (0)));

      /* If gdb was started with --annotate=2, this is equivalent to
	 the user entering the command 'set annotate 2' at the gdb
	 prompt, so we need to do extra processing. */
      if (annotation_level > 1)
        set_async_annotation_level (NULL, 0, NULL);
    }
d1688 5
a1692 20
  /* The set prompt command is different depending whether or not the
     async version is run. NOTE: this difference is going to
     disappear as we make the event loop be the default engine of
     gdb. */
  if (!event_loop_p)
    {
      deprecated_add_show_from_set
	(add_set_cmd ("prompt", class_support, var_string,
		      (char *) &gdb_prompt_string, "Set gdb's prompt",
		      &setlist),
	 &showlist);
    }
  else
    {
      c = add_set_cmd ("prompt", class_support, var_string,
		       (char *) &new_async_prompt, "Set gdb's prompt",
		       &setlist);
      deprecated_add_show_from_set (c, &showlist);
      set_cmd_sfunc (c, set_async_prompt);
    }
d1698 2
a1699 17
  /* The set editing command is different depending whether or not the
     async version is run. NOTE: this difference is going to disappear
     as we make the event loop be the default engine of gdb. */
  if (!event_loop_p)
    {
      deprecated_add_show_from_set
	(add_set_cmd ("editing", class_support, var_boolean, (char *) &command_editing_p,
		      "Set editing of command lines as they are typed.\n\
Use \"on\" to enable the editing, and \"off\" to disable it.\n\
Without an argument, command line editing is enabled.  To edit, use\n\
EMACS-like or VI-like commands like control-P or ESC.", &setlist),
	 &showlist);
    }
  else
    {
      c = add_set_cmd ("editing", class_support, var_boolean, (char *) &async_command_editing_p,
		       "Set editing of command lines as they are typed.\n\
d1704 2
a1705 3
      deprecated_add_show_from_set (c, &showlist);
      set_cmd_sfunc (c, set_async_editing_command);
    }
d1734 2
a1735 8
  /* The set annotate command is different depending whether or not
     the async version is run. NOTE: this difference is going to
     disappear as we make the event loop be the default engine of
     gdb. */
  if (!event_loop_p)
    {
      c = add_set_cmd ("annotate", class_obscure, var_zinteger,
		       (char *) &annotation_level, "Set annotation_level.\n\
d1738 7
a1744 18
		       &setlist);
      c = deprecated_add_show_from_set (c, &showlist);
    }
  else
    {
      c = add_set_cmd ("annotate", class_obscure, var_zinteger,
		       (char *) &annotation_level, "Set annotation_level.\n\
0 == normal;     1 == fullname (for use when running under emacs)\n\
2 == output annotated suitably for use by programs that control GDB.",
		       &setlist);
      deprecated_add_show_from_set (c, &showlist);
      set_cmd_sfunc (c, set_async_annotation_level);
    }
  if (event_loop_p)
    {
      deprecated_add_show_from_set
	(add_set_cmd ("exec-done-display", class_support, var_boolean, (char *) &exec_done_display_p,
		      "Set notification of completion for asynchronous execution commands.\n\
d1746 1
a1746 2
	 &showlist);
    }
d1774 1
a1774 8
  /* The signal handling mechanism is different depending whether or
     not the async version is run. NOTE: in the future we plan to make
     the event loop be the default engine of gdb, and this difference
     will disappear. */
  if (event_loop_p)
    async_init_signals ();
  else
    init_signals ();
@


1.91
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d293 1
a293 1
NORETURN void (*deprecated_error_hook) (void) ATTR_NORETURN;
@


1.90
log
@2004-06-25  Andrew Cagney  <cagney@@gnu.org>

	* defs.h (deprecated_ui_loop_hook): Deprecated.
	* wince.c (child_wait): Update.
	* win32-nat.c (child_wait): Update.
	* v850ice.c (v850ice_wait): Update.
	* top.c (deprecated_ui_loop_hook): Update.
	* serial.h: Update.
	* ser-unix.c (do_hardwire_readchar, do_hardwire_readchar)
	(do_unix_readchar): Update.
	* ser-tcp.c (net_open): Update.
	* remote-sim.c (gdb_os_poll_quit): Update.
	* rdi-share/ardi.c (angel_RDI_ExecuteOrStep): Update.
@
text
@d1765 1
a1765 1
      add_show_from_set
d1776 1
a1776 1
      add_show_from_set (c, &showlist);
d1789 1
a1789 1
      add_show_from_set
d1805 1
a1805 1
      add_show_from_set (c, &showlist);
d1809 1
a1809 1
  add_show_from_set
d1819 1
a1819 1
  add_show_from_set (c, &showhistlist);
d1827 1
a1827 1
  add_show_from_set (c, &showhistlist);
d1829 1
a1829 1
  add_show_from_set
d1847 1
a1847 1
      c = add_show_from_set (c, &showlist);
d1856 1
a1856 1
      add_show_from_set (c, &showlist);
d1861 1
a1861 1
      add_show_from_set
@


1.89
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d202 1
a202 1
int (*ui_loop_hook) (int);
@


1.88
log
@2004-02-28  Andrew Cagney  <cagney@@redhat.com>

	* utils.c: Use "", instead of <>, to include readline.
	tui/tui-win.c, tui/tui.c, tui/tui-hooks.c: Ditto.
	* tracepoint.c, top.c, symmisc.c, symfile.c: Ditto.
	* source.c, solib.c, exec.c, event-top.c: Ditto.
	* corelow.c, completer.c, cli/cli-setshow.c: Ditto.
	* cli/cli-dump.c, cli/cli-cmds.c: Ditto.
	* Makefile.in: Update all dependencies.
	(readline_tilde_h, readline_history_h): Define.
	(readline_headers): Delete.
@
text
@d196 1
a196 1
void (*init_ui_hook) (char *argv0);
d207 1
a207 1
void (*command_loop_hook) (void);
d212 2
a213 2
void (*print_frame_info_listing_hook) (struct symtab * s, int line,
				       int stopline, int noerror);
d216 1
a216 1
int (*query_hook) (const char *, va_list);
d220 1
a220 1
void (*warning_hook) (const char *, va_list);
d222 15
a236 14
/* These three functions support getting lines of text from the user.  They
   are used in sequence.  First readline_begin_hook is called with a text
   string that might be (for example) a message for the user to type in a
   sequence of commands to be executed at a breakpoint.  If this function
   calls back to a GUI, it might take this opportunity to pop up a text
   interaction window with this message.  Next, readline_hook is called
   with a prompt that is emitted prior to collecting the user input.
   It can be called multiple times.  Finally, readline_end_hook is called
   to notify the GUI that we are done with the interaction window and it
   can close it. */

void (*readline_begin_hook) (char *, ...);
char *(*readline_hook) (char *);
void (*readline_end_hook) (void);
d241 3
a243 3
void (*create_breakpoint_hook) (struct breakpoint * bpt);
void (*delete_breakpoint_hook) (struct breakpoint * bpt);
void (*modify_breakpoint_hook) (struct breakpoint * bpt);
d248 2
a249 2
void (*attach_hook) (void);
void (*detach_hook) (void);
d254 1
a254 1
void (*interactive_hook) (void);
d259 1
a259 1
void (*registers_changed_hook) (void);
d264 1
a264 1
void (*register_changed_hook) (int regno);
d267 1
a267 1
void (*memory_changed_hook) (CORE_ADDR addr, int len);
d272 2
a273 2
ptid_t (*target_wait_hook) (ptid_t ptid,
                            struct target_waitstatus * status);
d278 2
a279 2
void (*call_command_hook) (struct cmd_list_element * c, char *cmd,
			   int from_tty);
d284 1
a284 1
void (*set_hook) (struct cmd_list_element * c);
d288 1
a288 1
void (*context_hook) (int id);
d293 1
a293 1
NORETURN void (*error_hook) (void) ATTR_NORETURN;
d741 2
a742 2
      else if (call_command_hook)
	call_command_hook (c, arg, from_tty & caution);
d1238 1
a1238 1
      if (readline_hook && instream == NULL)
d1240 1
a1240 1
	  rl = (*readline_hook) (local_prompt);
d1456 1
a1456 1
      if (init_ui_hook)
d1909 5
a1913 4
  /* Allow another UI to initialize. If the UI fails to initialize, and
     it wants GDB to revert to the CLI, it should clear init_ui_hook. */
  if (init_ui_hook)
    init_ui_hook (argv0);
@


1.87
log
@
2004-01-19  Jeff Johnston  <jjohnstn@@redhat.com>

        * linespec.c (decode_variable, symtab_from_filename):  Call
        error_silent with error message instead of throwing an exception
        directly.
        * defs.h (error_silent, error_output_message): Add prototypes.
        (catch_exceptions_with_msg): Ditto.
        * utils.c (error_silent, error_output_message): New functions.
        * top.c (catch_exceptions_with_msg): New function.
@
text
@d50 2
a51 2
#include <readline/readline.h>
#include <readline/history.h>
@


1.87.6.1
log
@Merge mainline to intercu branch.
@
text
@d50 2
a51 2
#include "readline/readline.h"
#include "readline/history.h"
@


1.87.6.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d196 1
a196 1
void (*deprecated_init_ui_hook) (char *argv0);
d202 1
a202 1
int (*deprecated_ui_loop_hook) (int);
d207 1
a207 1
void (*deprecated_command_loop_hook) (void);
d212 2
a213 2
void (*deprecated_print_frame_info_listing_hook) (struct symtab * s, int line,
						  int stopline, int noerror);
d216 1
a216 1
int (*deprecated_query_hook) (const char *, va_list);
d220 1
a220 1
void (*deprecated_warning_hook) (const char *, va_list);
d222 14
a235 15
/* These three functions support getting lines of text from the user.
   They are used in sequence.  First deprecated_readline_begin_hook is
   called with a text string that might be (for example) a message for
   the user to type in a sequence of commands to be executed at a
   breakpoint.  If this function calls back to a GUI, it might take
   this opportunity to pop up a text interaction window with this
   message.  Next, deprecated_readline_hook is called with a prompt
   that is emitted prior to collecting the user input.  It can be
   called multiple times.  Finally, deprecated_readline_end_hook is
   called to notify the GUI that we are done with the interaction
   window and it can close it.  */

void (*deprecated_readline_begin_hook) (char *, ...);
char *(*deprecated_readline_hook) (char *);
void (*deprecated_readline_end_hook) (void);
d240 3
a242 3
void (*deprecated_create_breakpoint_hook) (struct breakpoint * bpt);
void (*deprecated_delete_breakpoint_hook) (struct breakpoint * bpt);
void (*deprecated_modify_breakpoint_hook) (struct breakpoint * bpt);
d247 2
a248 2
void (*deprecated_attach_hook) (void);
void (*deprecated_detach_hook) (void);
d253 1
a253 1
void (*deprecated_interactive_hook) (void);
d258 1
a258 1
void (*deprecated_registers_changed_hook) (void);
d263 1
a263 1
void (*deprecated_register_changed_hook) (int regno);
d266 1
a266 1
void (*deprecated_memory_changed_hook) (CORE_ADDR addr, int len);
d271 2
a272 2
ptid_t (*deprecated_target_wait_hook) (ptid_t ptid,
				       struct target_waitstatus * status);
d277 2
a278 2
void (*deprecated_call_command_hook) (struct cmd_list_element * c, char *cmd,
				      int from_tty);
d283 1
a283 1
void (*deprecated_set_hook) (struct cmd_list_element * c);
d287 1
a287 1
void (*deprecated_context_hook) (int id);
d292 1
a292 1
void (*deprecated_error_hook) (void);
d324 1
a324 1
  if (target_can_async_p () && !target_executing)
d326 1
a326 1
  if (sync_execution)
d580 2
d593 9
d698 1
a698 1
      if (target_can_async_p () && target_executing)
d740 2
a741 2
      else if (deprecated_call_command_hook)
	deprecated_call_command_hook (c, arg, from_tty & caution);
d993 1
a993 1
  if (after_char_processing_hook)
d1054 31
d1116 11
a1126 2
  /* Use the async hook.  */
  after_char_processing_hook = gdb_rl_operate_and_get_next_completion;
d1202 6
a1207 1
    signal (STOP_SIGNAL, handle_stop_sig);
d1237 1
a1237 1
      if (deprecated_readline_hook && instream == NULL)
d1239 1
a1239 1
	  rl = (*deprecated_readline_hook) (local_prompt);
d1421 4
a1424 1
  return PROMPT (0);
d1435 4
a1438 1
  PROMPT (0) = savestring (s, strlen (s));
d1455 1
a1455 1
      if (deprecated_init_ui_hook)
d1715 26
a1740 17
  /* initialize the prompt stack to a simple "(gdb) " prompt or to
     whatever the DEFAULT_PROMPT is.  */
  the_prompts.top = 0;
  PREFIX (0) = "";
  PROMPT (0) = savestring (DEFAULT_PROMPT, strlen (DEFAULT_PROMPT));
  SUFFIX (0) = "";
  /* Set things up for annotation_level > 1, if the user ever decides
     to use it.  */
  async_annotation_suffix = "prompt";
  /* Set the variable associated with the setshow prompt command.  */
  new_async_prompt = savestring (PROMPT (0), strlen (PROMPT (0)));

  /* If gdb was started with --annotate=2, this is equivalent to the
     user entering the command 'set annotate 2' at the gdb prompt, so
     we need to do extra processing.  */
  if (annotation_level > 1)
    set_async_annotation_level (NULL, 0, NULL);
d1758 20
a1777 5
  c = add_set_cmd ("prompt", class_support, var_string,
		   (char *) &new_async_prompt, "Set gdb's prompt",
		   &setlist);
  deprecated_add_show_from_set (c, &showlist);
  set_cmd_sfunc (c, set_async_prompt);
d1783 17
a1799 2
  c = add_set_cmd ("editing", class_support, var_boolean, (char *) &async_command_editing_p,
		   "Set editing of command lines as they are typed.\n\
d1804 3
a1806 2
  deprecated_add_show_from_set (c, &showlist);
  set_cmd_sfunc (c, set_async_editing_command);
d1808 1
a1808 1
  deprecated_add_show_from_set
d1818 1
a1818 1
  deprecated_add_show_from_set (c, &showhistlist);
d1826 1
a1826 1
  deprecated_add_show_from_set (c, &showhistlist);
d1828 1
a1828 1
  deprecated_add_show_from_set
d1835 8
a1842 2
  c = add_set_cmd ("annotate", class_obscure, var_zinteger,
		   (char *) &annotation_level, "Set annotation_level.\n\
d1845 18
a1862 7
		   &setlist);
  deprecated_add_show_from_set (c, &showlist);
  set_cmd_sfunc (c, set_async_annotation_level);

  deprecated_add_show_from_set
    (add_set_cmd ("exec-done-display", class_support, var_boolean, (char *) &exec_done_display_p,
		  "Set notification of completion for asynchronous execution commands.\n\
d1864 2
a1865 1
     &showlist);
d1893 8
a1900 1
  async_init_signals ();
d1908 4
a1911 5
  /* Allow another UI to initialize. If the UI fails to initialize,
     and it wants GDB to revert to the CLI, it should clear
     deprecated_init_ui_hook.  */
  if (deprecated_init_ui_hook)
    deprecated_init_ui_hook (argv0);
@


1.86
log
@2004-01-02  Michael Chastain  <mec.gnu@@mindspring.com>

	* top.c (print_gdb_version): Update year to 2004.
@
text
@d386 1
d432 8
a439 1
    val = 0;
d487 19
a505 1
  catcher (func, uiout, func_args, &val, &caught, errstring, mask);
d535 2
a536 1
  catcher (do_catch_errors, uiout, &args, &val, &caught, errstring, mask);
@


1.85
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d1362 1
a1362 1
  fprintf_filtered (stream, "Copyright 2003 Free Software Foundation, Inc.\n");
@


1.84
log
@2003-11-06  Andrew Cagney  <cagney@@redhat.com>

	* valops.c (destructor_name_p): Replace STREQN with strncmp.
	* top.c (command_line_input): Ditto.
	* objc-exp.y (yylex): Ditto.
	* minsyms.c (prim_record_minimal_symbol_and_info): Ditto.
	* jv-exp.y (yylex): Ditto.
	* f-exp.y (yylex): Ditto.
	* event-top.c (command_line_handler): Ditto.
	* environ.c (get_in_environ): Ditto.
	(set_in_environ): Ditto.
	* dwarfread.c (handle_producer): Ditto.
	* dbxread.c (process_one_symbol): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* c-exp.y (yylex): Ditto.

2003-11-06  Andrew Cagney  <cagney@@redhat.com>

	* mi-cmd-var.c (mi_cmd_var_set_format): Replace STREQN with
	strncmp.
@
text
@d1378 1
a1378 1
  if (!STREQ (host_name, target_name))
@


1.83
log
@2003-11-05  Elena Zannoni  <ezannoni@@redhat.com>

       * top.c (execute_command): Fix broken logic for command execution
       while inferior is running in async mode.
@
text
@d1269 1
a1269 1
    && STREQN (linebuffer, "server ", SERVER_COMMAND_LENGTH);
@


1.82
log
@2003-10-22  Andrew Cagney  <cagney@@redhat.com>

	* target.c (target_close): New function.
	(debug_to_close): Use "target_close".
	(push_target): Use "target_close".
	(unpush_target): Use "target_close".
	(pop_target): Use "target_close".
	* target.h (struct target_ops): Add "to_xclose".
	(target_open): Delete macro.  Move comment to "to_open".
	(target_close): Replace macro with function that takes a target.
	* top.c (quit_target): Pass "current_target" to "target_close".
@
text
@d672 4
a675 4
	if (!strcmp (c->name, "help")
	    && !strcmp (c->name, "pwd")
	    && !strcmp (c->name, "show")
	    && !strcmp (c->name, "stop"))
@


1.81
log
@2003-10-10  Kei Sakamoto  <sakamoto.kei@@renesas.com>

	* NEWS: Replace "Hitachi" and "Mitsubishi" with "Renesas".
	* README: Ditto.
	* d10v-tdep.c: Ditto.
	* h8300-tdep.c: Ditto.
	* remote-e7000.c: Ditto.
	* remote-hms.c: Ditto.
	* ser-e7kpc.c: Ditto.
	* sh-stub.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* sh3-rom.c: Ditto.
	* sh64-tdep.c: Ditto.
	* top.c: Ditto.
	* wince.c: Ditto.
	* config/d10v/d10v.mt: Ditto.
	* config/sh/embed.mt: Ditto.
	* config/sh/linux.mt: Ditto.
	* config/sh/tm-linux.h: Ditto.
	* config/sh/tm-sh.h: Ditto.
	* config/sh/wince.mt: Ditto.
@
text
@d1464 1
a1464 1
  target_close (1);
@


1.80
log
@        * completer.h (get_gdb_completer_word_break_characters): Delete.
        * completer.c: include language.h.
        (gdb_completer_word_break_characters): Delete.
        (get_gdb_completer_word_break_characters): Delete.
        (location_completer): Use the word break characters of the current
        language.
        (complete_line): Likewise.
        (line_completion_function): Likewise.
        (skip_quoted_chars): Likewise.
        * Makefile.in (completer.o): Add dependency on language.h.
        * top.c (init_main): Set the readline word break characters
        to GDB's default word break characters.
@
text
@d150 1
a150 1
   Hitachi E7000 ICE didn't always respond in a timely manner.
@


1.79
log
@
2003-09-22  Jeff Johnston  <jjohnstn@@redhat.com>

        * top.c (quit_force): Fix indirect call to quit_target so
        a struct qt_args pointer is passed.
@
text
@d1722 1
a1722 2
  rl_completer_word_break_characters =
				 get_gdb_completer_word_break_characters ();
@


1.78
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d1481 1
d1492 3
d1496 1
a1496 1
  catch_errors (quit_target, args,
@


1.77
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@a1506 1
/* ARGSUSED */
a1591 1
/* ARGSUSED */
a1605 1
/* ARGSUSED */
a1612 1
/* ARGSUSED */
a1621 1
/* ARGSUSED */
@


1.76
log
@
2003-09-12  Jeff Johnston  <jjohnstn@@redhat.com>

        * top.c (quit_target): New static helper function.
        (quit_force): Moved code to quit_target().  Call quit_target()
        via catch_errors() to catch errors during quit.
@
text
@d643 2
a644 2
  register struct cmd_list_element *c;
  register enum language flang;
d1138 1
a1138 1
  register char *p;
@


1.75
log
@2003-08-16  Andrew Cagney  <cagney@@redhat.com>

	* NEWS: Mention that "set prompt-escape-char" was deleted.
	* top.c (get_prompt_1): Delete function.
	(gdb_prompt_escape):
	(init_main): Do not clear "gdb_prompt_escape".  Delete "set
	prompt-escape-char" command.
	(MAX_PROMPT_SIZE): Delete macro.
	(get_prompt): Simplify, do not call get_prompt_1.
@
text
@d1442 1
a1442 1
/* Quit without asking for confirmation.  */
d1444 1
a1444 2
void
quit_force (char *args, int from_tty)
d1446 3
a1448 1
  int exit_code = 0;
d1450 4
a1453 8
  /* An optional expression may be used to cause gdb to terminate with the 
     value of that expression. */
  if (args)
    {
      struct value *val = parse_and_eval (args);

      exit_code = (int) value_as_long (val);
    }
d1458 1
a1458 1
	target_detach (args, from_tty);
d1460 1
a1460 1
	target_kill ();
d1471 23
@


1.74
log
@2003-08-04  David Carlton  <carlton@@kealia.com>

	* charset.c (cached_iconv_convert): Add __FILE__ and __LINE__ args
	to internal_error call.
	* source.c (forward_search_command): Add "%s" format argument.
	(reverse_search_command): Ditto.
	* top.c (quit_confirm): Ditto.
	* cli/cli-setshow.c (do_setshow_command): Ditto.
	* cp-valprint.c (cp_print_class_method): Replace
	{f,}printf_{un,}filtered by {f,}puts_{un,}filtered.
	(cp_print_class_member): Ditto.
	* event-top.c (command_line_handler): Ditto.
	* linux-proc.c (linux_info_proc_cmd): Ditto.
	* p-typeprint.c (pascal_type_print_base): Ditto.
	* p-valprint.c (pascal_object_print_class_method): Ditto.
	(pascal_object_print_class_member): Ditto.
	* printcmd.c (print_scalar_formatted,printf_command): Ditto.
	* remote.c (remote_cisco_section_offsets): Ditto.
	* top.c (command_line_input): Ditto.
	* utils.c (vwarning,error_stream,quit): Ditto.
	* valprint.c (print_floating,print_binary_chars)
	(print_octal_chars,print_decimal_chars,print_hex_chars): Ditto.

2003-08-04  David Carlton  <carlton@@kealia.com>

	* mi-main.c (mi_error_last_message): Add "%s" second argument to
	xasprintf call.

2003-08-04  David Carlton  <carlton@@kealia.com>

	* generic/gdbtk.c (gdbtk_source_start_file): Add "%s" first
	argument to error call.
	(tk_command): Ditto.
	(view_command): Ditto.
@
text
@a1390 243
#define MAX_PROMPT_SIZE 256

/*
 * int get_prompt_1 (char * buf);
 *
 * Work-horse for get_prompt (called via catch_errors).
 * Argument is buffer to hold the formatted prompt.
 *
 * Returns: 1 for success (use formatted prompt)
 *          0 for failure (use gdb_prompt_string).
 */

static int gdb_prompt_escape;

static int
get_prompt_1 (void *data)
{
  char *formatted_prompt = data;
  char *local_prompt;

  if (event_loop_p)
    local_prompt = PROMPT (0);
  else
    local_prompt = gdb_prompt_string;


  if (gdb_prompt_escape == 0)
    {
      return 0;			/* do no formatting */
    }
  else
    /* formatted prompt */
    {
      char fmt[40], *promptp, *outp, *tmp;
      struct value *arg_val;
      DOUBLEST doubleval;
      LONGEST longval;
      CORE_ADDR addrval;

      int i, len;
      struct type *arg_type, *elt_type;

      promptp = local_prompt;
      outp = formatted_prompt;

      while (*promptp != '\0')
	{
	  int available = MAX_PROMPT_SIZE - (outp - formatted_prompt) - 1;

	  if (*promptp != gdb_prompt_escape)
	    {
	      if (available >= 1)	/* overflow protect */
		*outp++ = *promptp++;
	    }
	  else
	    {
	      /* GDB prompt string contains escape char.  Parse for arg.
	         Two consecutive escape chars followed by arg followed by
	         a comma means to insert the arg using a default format.
	         Otherwise a printf format string may be included between
	         the two escape chars.  eg:
	         %%foo, insert foo using default format
	         %2.2f%foo,     insert foo using "%2.2f" format
	         A mismatch between the format string and the data type
	         of "foo" is an error (which we don't know how to protect
	         against).  */

	      fmt[0] = '\0';	/* assume null format string */
	      if (promptp[1] == gdb_prompt_escape)	/* double esc char */
		{
		  promptp += 2;	/* skip past two escape chars. */
		}
	      else
		{
		  /* extract format string from between two esc chars */
		  i = 0;
		  do
		    {
		      fmt[i++] = *promptp++;	/* copy format string */
		    }
		  while (i < sizeof (fmt) - 1 &&
			 *promptp != gdb_prompt_escape &&
			 *promptp != '\0');

		  if (*promptp != gdb_prompt_escape)
		    error ("Syntax error at prompt position %d",
			   (int) (promptp - local_prompt));
		  else
		    {
		      promptp++;	/* skip second escape char */
		      fmt[i++] = '\0';	/* terminate the format string */
		    }
		}

	      arg_val = parse_to_comma_and_eval (&promptp);
	      if (*promptp == ',')
		promptp++;	/* skip past the comma */
	      arg_type = check_typedef (VALUE_TYPE (arg_val));
	      switch (TYPE_CODE (arg_type))
		{
		case TYPE_CODE_ARRAY:
		  elt_type = check_typedef (TYPE_TARGET_TYPE (arg_type));
		  if (TYPE_LENGTH (arg_type) > 0 &&
		      TYPE_LENGTH (elt_type) == 1 &&
		      TYPE_CODE (elt_type) == TYPE_CODE_INT)
		    {
		      int len = TYPE_LENGTH (arg_type);

		      if (VALUE_LAZY (arg_val))
			value_fetch_lazy (arg_val);
		      tmp = VALUE_CONTENTS (arg_val);

		      if (len > available)
			len = available;	/* overflow protect */

		      /* FIXME: how to protect GDB from crashing
		         from bad user-supplied format string? */
		      if (fmt[0] != 0)
			sprintf (outp, fmt, tmp);
		      else
			strncpy (outp, tmp, len);
		      outp[len] = '\0';
		    }
		  break;
		case TYPE_CODE_PTR:
		  elt_type = check_typedef (TYPE_TARGET_TYPE (arg_type));
		  addrval = value_as_address (arg_val);

		  if (TYPE_LENGTH (elt_type) == 1 &&
		      TYPE_CODE (elt_type) == TYPE_CODE_INT &&
		      addrval != 0)
		    {
		      /* display it as a string */
		      char *default_fmt = "%s";
		      char *tmp;
		      int err = 0;

		      /* Limiting the number of bytes that the following call
		         will read protects us from sprintf overflow later. */
		      i = target_read_string (addrval,	/* src */
					      &tmp,	/* dest */
					      available,	/* len */
					      &err);
		      if (err)	/* read failed */
			error ("%s on target_read", safe_strerror (err));

		      tmp[i] = '\0';	/* force-terminate string */
		      /* FIXME: how to protect GDB from crashing
		         from bad user-supplied format string? */
		      sprintf (outp, fmt[0] == 0 ? default_fmt : fmt,
			       tmp);
		      xfree (tmp);
		    }
		  else
		    {
		      /* display it as a pointer */
		      char *default_fmt = "0x%x";

		      /* FIXME: how to protect GDB from crashing
		         from bad user-supplied format string? */
		      if (available >= 16 /*? */ )	/* overflow protect */
			sprintf (outp, fmt[0] == 0 ? default_fmt : fmt,
				 (long) addrval);
		    }
		  break;
		case TYPE_CODE_FLT:
		  {
		    char *default_fmt = "%g";

		    doubleval = value_as_double (arg_val);
		    /* FIXME: how to protect GDB from crashing
		       from bad user-supplied format string? */
		    if (available >= 16 /*? */ )	/* overflow protect */
		      sprintf (outp, fmt[0] == 0 ? default_fmt : fmt,
			       (double) doubleval);
		    break;
		  }
		case TYPE_CODE_INT:
		  {
		    char *default_fmt = "%d";

		    longval = value_as_long (arg_val);
		    /* FIXME: how to protect GDB from crashing
		       from bad user-supplied format string? */
		    if (available >= 16 /*? */ )	/* overflow protect */
		      sprintf (outp, fmt[0] == 0 ? default_fmt : fmt,
			       (long) longval);
		    break;
		  }
		case TYPE_CODE_BOOL:
		  {
		    /* no default format for bool */
		    longval = value_as_long (arg_val);
		    if (available >= 8 /*? */ )		/* overflow protect */
		      {
			if (longval)
			  strcpy (outp, "<true>");
			else
			  strcpy (outp, "<false>");
		      }
		    break;
		  }
		case TYPE_CODE_ENUM:
		  {
		    /* no default format for enum */
		    longval = value_as_long (arg_val);
		    len = TYPE_NFIELDS (arg_type);
		    /* find enum name if possible */
		    for (i = 0; i < len; i++)
		      if (TYPE_FIELD_BITPOS (arg_type, i) == longval)
			break;	/* match -- end loop */

		    if (i < len)	/* enum name found */
		      {
			char *name = TYPE_FIELD_NAME (arg_type, i);

			strncpy (outp, name, available);
			/* in casel available < strlen (name), */
			outp[available] = '\0';
		      }
		    else
		      {
			if (available >= 16 /*? */ )	/* overflow protect */
			  sprintf (outp, "%ld", (long) longval);
		      }
		    break;
		  }
		case TYPE_CODE_VOID:
		  *outp = '\0';
		  break;	/* void type -- no output */
		default:
		  error ("bad data type at prompt position %d",
			 (int) (promptp - local_prompt));
		  break;
		}
	      outp += strlen (outp);
	    }
	}
      *outp++ = '\0';		/* terminate prompt string */
      return 1;
    }
}

d1394 2
a1395 7
  static char buf[MAX_PROMPT_SIZE];

  if (catch_errors (get_prompt_1, buf, "bad formatted prompt: ",
		    RETURN_MASK_ALL))
    {
      return &buf[0];		/* successful formatted prompt */
    }
d1397 1
a1397 7
    {
      /* Prompt could not be formatted.  */
      if (event_loop_p)
	return PROMPT (0);
      else
	return gdb_prompt_string;
    }
a1694 1
  gdb_prompt_escape = 0;	/* default to none.  */
a1732 7

  add_show_from_set
    (add_set_cmd ("prompt-escape-char", class_support, var_zinteger,
		  (char *) &gdb_prompt_escape,
		  "Set escape character for formatting of gdb's prompt",
		  &setlist),
     &showlist);
@


1.73
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* acinclude.m4 (gcc_AC_CHECK_DECL, (gcc_AC_CHECK_DECL): Stolen
	from GCC's acinclude.m4.
	* configure.in: Check for getopt's delcaration.
	* aclocal.m4, config.in, configure: Re-generate.
	* main.c (error_init): Delete declaration.
	* defs.h (error_init): Declare.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Make static.
	(rs6000_convert_from_func_ptr_addr): Make static.
	(_initialize_rs6000_tdep): Add declaration.
	* cli/cli-cmds.c (dont_repeat): Delete declaration.
	(show_commands, set_verbose, show_history): Delete declaration.
	* top.h (set_verbose): Add declaration.
	(show_history, set_history, show_commands): Add declaration.
	(do_restore_instream_cleanup): Add declaration.
	* objc-lang.c (specialcmp): Make static.
	(print_object_command): Make static.
	(find_objc_msgsend): Make static.
	(find_objc_msgcall_submethod_helper): Make static.
	(find_objc_msgcall_submethod): Make static.
	(_initialize_objc_language): Add declaration.
	(find_implementation_from_class): Make static.
	(find_implementation): Make static.
	* objc-exp.y (yylex): Delete lookup_struct_typedef declaration.
	* objc-lang.h (lookup_struct_typedef): Add declaration.
	* cli/cli-interp.c (_initialize_cli_interp): Add declaration.
	* cli/cli-script.c (clear_hook_in_cleanup): Make static.
	(do_restore_user_call_depth): Make static.
	(do_restore_instream_cleanup): Delete declaration.
	(dont_repeat): Delete declaration.
	* cli/cli-decode.c (add_abbrev_cmd): Delete function.
	* cli/cli-dump.c (_initialize_cli_dump): Add declaration.
	* reggroups.c (_initialize_reggroup): Add declaration.
	* cp-support.c (_initialize_cp_support): Add declaration.
	* cp-abi.c (_initialize_cp_abi): Add declaration.
	* hpacc-abi.c (_initialize_hpacc_abi): Add declaration.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Make static.
	(_initialize_gnu_v3_abi): Add declaration.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Make static.
	(_initialize_gnu_v2_abi): Add declaration.
	* frame-base.c (_initialize_frame_base): Add declaration.
	* doublest.c (floatformat_from_length): Make static.
	* frame-unwind.c (_initialize_frame_unwind): Add declaration.
	* frame.c (create_sentinel_frame): Make static.
	(_initialize_frame): Add declaration.
	* top.c (do_catch_errors): Make static.
	(gdb_rl_operate_and_get_next_completion): Make static.
	* typeprint.c: Include "typeprint.h".
	* sentinel-frame.c (sentinel_frame_prev_register): Make static.
	(sentinel_frame_this_id): Make static.
	* p-valprint.c (_initialize_pascal_valprint): Add declaration.
	* ui-out.c (make_cleanup_ui_out_begin_end): Delete function.
	* dwarf2-frame.c (dwarf2_frame_cache): Make static.
	* p-exp.y (push_current_type, pop_current_type): ISO C declaration.
	* dwarf2expr.h (dwarf_expr_context): ISO C declaration.
	* maint.c (maintenance_print_architecture): Make static.
	* signals/signals.c (_initialize_signals): Add declaration.
	* std-regs.c (_initialize_frame_reg): Add declaration.
	* jv-exp.y (push_variable): ISO C definition.
	(push_qualified_expression_name): Ditto.
	* memattr.c (_initialize_mem): Add declaration.
	* remote.c (remote_check_watch_resources): Make static.
	(remote_stopped_by_watchpoint): Make static.
	(remote_stopped_data_address): Make static.
	* d10v-tdep.c (nr_dmap_regs): Make static.
	(a0_regnum): Make static.
	(d10v_frame_unwind_cache): Make static.
	(d10v_frame_p): Make static.
	* osabi.c (show_osabi): Make static.
	(_initialize_gdb_osabi): Add extern declaration.
	* gdbtypes.c (make_qualified_type): Make static.
	(safe_parse_type): Make static.
	* macrocmd.c (_initialize_macrocmd): Add extern declaration.
	* macrotab.c (macro_bcache_free): Make static.
	* interps.c (interp_set_quiet): Make static.
	(interpreter_exec_cmd): Make static.
	* stack.h (select_frame_command): New file.
	* stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete function.
	(select_frame_command): Make global.
	* infcall.c: Include "infcall.h".
	* linespec.c: Include "linespec.h".
	* symfile.c (sections_overlap): Make static.
	* cp-support.h (cp_initialize_namespace): ISO C declaration.
	* charset.c (_initialize_charset): Add missing prototype.
	* regcache.c (init_legacy_regcache_descr): Make static.
	(do_regcache_xfree): Make static.
	(regcache_xfer_part): Make static.
	(_initialize_regcache): Add missing prototype.
	* breakpoint.c (parse_breakpoint_sals): Make static.
	(breakpoint_sals_to_pc): Make static.
	* interps.h (clear_interpreter_hooks): ISO C declaration.
	* Makefile.in (stack_h): Define.
	(stack.o, typeprint.o, mi-main.o): Update dependencies.
	(mi-cmd-stack.o, infcall.o, linespec.o): Update dependencies.

Index: mi/ChangeLog
2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-parse.c (_initialize_mi_parse): Delete function.
	* mi-main.c: Include "mi-main.h".
	* mi-interp.c (_initialize_mi_interp): Add declaration.
	* mi-cmd-stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete extern declaration.
	(mi_cmd_stack_select_frame): Replace select_frame_command_wrapper
	with select_frame_command.
@
text
@d1204 3
a1206 3
	  printf_unfiltered ("\n\032\032pre-");
	  printf_unfiltered (annotation_suffix);
	  printf_unfiltered ("\n");
d1225 3
a1227 3
	  printf_unfiltered ("\n\032\032post-");
	  printf_unfiltered (annotation_suffix);
	  printf_unfiltered ("\n");
d1689 1
a1689 1
      if (!query (s))
@


1.73.4.1
log
@
2003-09-12  Jeff Johnston  <jjohnstn@@redhat.com>

        * top.c (quit_target): New static helper function.
        (quit_force): Moved code to quit_target().  Call quit_target()
        via catch_errors() to catch errors during quit.
@
text
@d1696 1
a1696 1
/* Helper routine for quit_force that requires error handling.  */
d1698 2
a1699 1
struct qt_args
d1701 7
a1707 3
  char *args;
  int from_tty;
};
d1709 2
a1710 4
static int
quit_target (void *arg)
{
  struct qt_args *qt = (struct qt_args *)arg;
d1715 1
a1715 1
        target_detach (qt->args, qt->from_tty);
d1717 1
a1717 1
        target_kill ();
a1727 23

  return 0;
}

/* Quit without asking for confirmation.  */

void
quit_force (char *args, int from_tty)
{
  int exit_code = 0;

  /* An optional expression may be used to cause gdb to terminate with the 
     value of that expression. */
  if (args)
    {
      struct value *val = parse_and_eval (args);

      exit_code = (int) value_as_long (val);
    }

  /* We want to handle any quit errors and exit regardless.  */
  catch_errors (quit_target, args,
	        "Quitting: ", RETURN_MASK_ALL);
@


1.73.4.2
log
@
2003-09-22  Jeff Johnston  <jjohnstn@@redhat.com>

        Merge from mainline:
        2003-09-22  Jeff Johnston  <jjohnstn@@redhat.com>

        * top.c (quit_force): Fix indirect call to quit_target so
        a struct qt_args pointer is passed.
@
text
@a1734 1
  struct qt_args qt;
a1744 3
  qt.args = args;
  qt.from_tty = from_tty;

d1746 1
a1746 1
  catch_errors (quit_target, &qt,
@


1.72
log
@        * top.h (lim_at_start): Declare.
        * main.c (captured_main): Set it.
        * top.c (lim_at_start): Define.
        (command_loop): Use it instead of &environ.
        * event-top.c (command_handler): Likewise.

        * gdb.base/selftest.exp: Next over lim_at_start initialization.
@
text
@d493 1
a493 1
int
d1064 1
a1064 1
void
@


1.71
log
@2003-02-05  Jim Ingham <jingham@@apple.com>
            Keith Seitz  <keiths@@redhat.com>
            Elena Zannoni  <ezannoni@@redhat.com>
            Andrew Cagney  <ac131313@@redhat.com>

	* Makefile.in (SUBDIR_CLI_OBS): Add "cli-interp.o".
	(SUBDIR_CLI_SRCS): Add "cli/cli-interp.c".
	(SUBDIR_MI_OBS): Add "mi-interp.o".
	(SUBDIR_MI_SRCS): Add "mi/mi-interp.c".
	(SFILES): Add "interps.c".
	(COMMON_OBS): Add "interps.o".
	(interps_h, mi_main_h): Define.
	(interps.o, cli-interp.o, mi-interp.o): Add dependencies.
	(mi-main.o, main.o, event-top.o): Update dependencies.
	* cli/cli-interp.c: New file.
	* interps.h, interps.c: New files.
	* top.c: (gdb_init): Don't install the default interpreter, handed
	by captured_main.
	* main.c: Include "interps.h".
	(interpreter_p): Note that it should malloc'ed.
	(captured_command_loop): Call current_interp_command_loop.
	(captured_main): Initialize interpreter_p to INTERP_CONSOLE.  Use
	xfree and xstrdup when updating interpreter_p.  Install the
	default interpreter.  Add hack to stop mi1's copyright notice
	being encoded.
	* event-top.h (gdb_setup_readline): Declare.
	(gdb_disable_readline): Declare.
	* event-top.c: Include "interps.h".
	(display_gdb_prompt): Call current_interp_display_prompt_p.
	(gdb_setup_readline): Initialize gdb_stdout, gdb_stderr,
	gdb_stdlog, and gdb_stdtarg.
	(_initialize_event_loop): Don't call gdb_setup_readline.
	* cli-out.c (cli_out_set_stream): New function.
	* cli-out.h (cli_out_set_stream): Declare.
@
text
@d174 5
a789 1
	  extern char **environ;
d791 1
a791 2

	  space_at_cmd_start = (long) (lim - (char *) &environ);
a810 1
	  extern char **environ;
d812 1
a812 1
	  long space_now = lim - (char *) &environ;
@


1.71.24.1
log
@Snap const char * mess.
@
text
@d380 1
a380 1
	 const char *errstring,
d386 2
a387 2
  const char *saved_error_pre_print;
  const char *saved_quit_pre_print;
d469 1
a469 1
		  const char *errstring,
d496 1
a496 1
catch_errors (catch_errors_ftype *func, void *func_args, const char *errstring,
d511 5
a515 5
{
  catch_command_errors_ftype *command;
  const char *arg;
  int from_tty;
};
d535 1
a535 1
		      const char *arg, int from_tty, return_mask mask)
d636 1
a636 1
execute_command (const char *p, int from_tty)
d641 1
a641 1
  const char *line;
d659 1
a659 1
      const char *arg;
d1422 1
a1422 3
      char fmt[40];
      const char **promptp;
      char *outp, *tmp;
d1741 1
a1741 1
dont_repeat_command (const char *ignored, int from_tty)
d1827 1
a1827 2
set_history_size_command (const char *args, int from_tty,
			  struct cmd_list_element *c)
@


1.70
log
@2003-01-12  Michael Chastain  <mec@@shout.net>

	* top.c (print_gdb_version): Bump copyright year to 2003.
@
text
@a2126 15

  /* Install the default UI */
  if (!init_ui_hook)
    {
      uiout = cli_out_new (gdb_stdout);

      /* All the interpreters should have had a look at things by now.
	 Initialize the selected interpreter. */
      if (interpreter_p)
	{
	  fprintf_unfiltered (gdb_stderr, "Interpreter `%s' unrecognized.\n",
			      interpreter_p);
	  exit (1);
	}
    }
@


1.70.2.1
log
@Merge kseitz_interps-20020528-branch.
@
text
@a65 1
#include "interps.h"
d2129 3
a2131 3
  /* All the interpreters should have had a look at things by now.
     Initialize the selected interpreter. */
  {
d2133 9
a2141 22
    /* There will always be an interpreter.  Either the one specified
       by the user at start up or the console.  */

    struct gdb_interpreter *interp;
    if (interpreter_p == NULL)
      interpreter_p = xstrdup (GDB_INTERPRETER_CONSOLE);

    interp = gdb_interpreter_lookup (interpreter_p);

    if (interp == NULL)
      {
        fprintf_unfiltered (gdb_stderr, "Interpreter `%s' unrecognized.\n",
                            interpreter_p);
        exit (1);
      }
    if (!gdb_interpreter_set (interp))
      {
        fprintf_unfiltered (gdb_stderr, "Interpreter `%s' failed to initialize.\n",
                            interpreter_p);
        exit (1);
      }
  }
@


1.70.2.2
log
@2003-02-03  Andrew Cagney  <ac131313@@redhat.com>

	* top.c (gdb_init): Move interpreter init code from here ...
	* main.c (captured_main): ... to here.  Include "interps.h".
	(captured_main): Set interpreter_p to a default before parsing the
	options.
	* Makefile.in (main.o): Update dependencies.
@
text
@d2129 27
@


1.70.2.3
log
@Overhaul changelog entries.
@
text
@d66 1
d2128 1
@


1.69
log
@2002-12-08  Elena Zannoni  <ezannoni@@redhat.com>

	More cleanup from import of readline 4.3.
	* completer.h (complete_line, readline_line_completion_function):
	Update prototypes.
	(line_completion_function): Removed, not used outside of completer.c.
	* completer.c (readline_line_completion_function,
	complete_function, line_completion_function): Use const for first
	parameter.
	(line_completion_function): Make static.
	(filename_completer): filename_completion_function is now called
	rl_filename_completion_function
	* corelow.c: Include <readline/readline.h>.
	* exec.c: Ditto.
	* solib.c: Ditto.
	* source.c: Ditto.
	* symfile.c: Ditto.
	* symmisc.c: Ditto.
	* top.c (init_main): No need to coerce
	readline_line_completion_function anymore.
	* cli/cli-dump.c: Include <readline/readline.h>.
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d1360 1
a1360 1
  fprintf_filtered (stream, "Copyright 2002 Free Software Foundation, Inc.\n");
@


1.68
log
@2002-09-26  Andrew Cagney  <ac131313@@redhat.com>

	From Grace Sainsbury <graces@@redhat.com>:
	* Makefile.in (gdbtk-main.o): New target.
	(gdb.o): New target.
	(main_h): Define.
	(main.o): Update dependencies.
	(gdb$(EXEEXT)): Add gdb.o.
	(SUBDIR_GDBTK_SRCS): Add gdbtk-main.c.
	(SUBDIR_GDBTK_ALL, SUBDIR_GDBTK_UNINSTALL): Set.
	(SUBDIR_GDBTK_CLEAN): Set.
	(install-gdbtk): Install the insight binary.
	(uninstall-gdbtk): New target.
	(all-gdbtk, clean-gdbtk): New rule.
	* top.c (use_windows): Default to zero.
	* main.c: Include "main.h".
	(main): Delete.
	(struct captured_main_args): Delete.
	(gdb_main): New function.
	* main.h: New file.
	* gdb.c: New File.

2002-09-26  Andrew Cagney  <ac131313@@redhat.com>

	From Grace Sainsbury <graces@@redhat.com>:
	* generic/gdbtk-main.c: New file.
@
text
@d1955 1
a1955 1
  rl_completion_entry_function = (int (*)()) readline_line_completion_function;
@


1.68.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d150 1
a150 1
   Renesas E7000 ICE didn't always respond in a timely manner.
a173 5
/* Sbrk location on entry to main.  Used for statistics only.  */
#ifdef HAVE_SBRK
char *lim_at_start;
#endif

d488 1
a488 1
static int
d638 2
a639 2
  struct cmd_list_element *c;
  enum language flang;
d667 4
a670 4
	if (strcmp (c->name, "help") != 0
	    && strcmp (c->name, "pwd") != 0
	    && strcmp (c->name, "show") != 0
	    && strcmp (c->name, "stop") != 0)
d785 1
d787 2
a788 1
	  space_at_cmd_start = lim - lim_at_start;
d808 1
d810 1
a810 1
	  long space_now = lim - lim_at_start;
d1062 1
a1062 1
static void
d1136 1
a1136 1
  char *p;
d1202 3
a1204 3
	  puts_unfiltered ("\n\032\032pre-");
	  puts_unfiltered (annotation_suffix);
	  puts_unfiltered ("\n");
d1223 3
a1225 3
	  puts_unfiltered ("\n\032\032post-");
	  puts_unfiltered (annotation_suffix);
	  puts_unfiltered ("\n");
d1267 1
a1267 1
    && strncmp (linebuffer, "server ", SERVER_COMMAND_LENGTH) == 0;
d1360 1
a1360 1
  fprintf_filtered (stream, "Copyright 2003 Free Software Foundation, Inc.\n");
d1376 1
a1376 1
  if (strcmp (host_name, target_name) != 0)
d1389 243
d1635 7
a1641 2
  if (event_loop_p)
    return PROMPT (0);
d1643 7
a1649 1
    return gdb_prompt_string;
d1687 1
a1687 1
      if (!query ("%s", s))
d1694 1
a1694 1
/* Helper routine for quit_force that requires error handling.  */
d1696 2
a1697 1
struct qt_args
d1699 7
a1705 3
  char *args;
  int from_tty;
};
d1707 2
a1708 4
static int
quit_target (void *arg)
{
  struct qt_args *qt = (struct qt_args *)arg;
d1713 1
a1713 1
        target_detach (qt->args, qt->from_tty);
d1715 1
a1715 1
        target_kill ();
d1719 1
a1719 1
  target_close (&current_target, 1);
a1726 27
  return 0;
}

/* Quit without asking for confirmation.  */

void
quit_force (char *args, int from_tty)
{
  int exit_code = 0;
  struct qt_args qt;

  /* An optional expression may be used to cause gdb to terminate with the 
     value of that expression. */
  if (args)
    {
      struct value *val = parse_and_eval (args);

      exit_code = (int) value_as_long (val);
    }

  qt.args = args;
  qt.from_tty = from_tty;

  /* We want to handle any quit errors and exit regardless.  */
  catch_errors (quit_target, &qt,
	        "Quitting: ", RETURN_MASK_ALL);

d1739 1
d1825 1
d1840 1
d1848 1
d1858 1
d1947 1
d1955 3
a1957 2
  rl_completion_entry_function = readline_line_completion_function;
  rl_completer_word_break_characters = default_word_break_characters ();
d1987 7
d2127 15
@


1.68.2.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d1362 1
a1362 1
  fprintf_filtered (stream, "Copyright 2004 Free Software Foundation, Inc.\n");
@


1.68.2.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@a385 1
	 char **gdberrmsg,
d431 1
a431 8
    {
      val = 0;
      /* If caller wants a copy of the low-level error message, make one.  
         This is used in the case of a silent error whereby the caller
         may optionally want to issue the message.  */
      if (gdberrmsg)
	*gdberrmsg = error_last_message ();
    }
d479 1
a479 19
  catcher (func, uiout, func_args, &val, &caught, errstring, NULL, mask);
  gdb_assert (val >= 0);
  gdb_assert (caught <= 0);
  if (caught < 0)
    return caught;
  return val;
}

int
catch_exceptions_with_msg (struct ui_out *uiout,
		  	   catch_exceptions_ftype *func,
		  	   void *func_args,
		  	   char *errstring,
			   char **gdberrmsg,
		  	   return_mask mask)
{
  int val;
  enum return_reason caught;
  catcher (func, uiout, func_args, &val, &caught, errstring, gdberrmsg, mask);
d509 1
a509 2
  catcher (do_catch_errors, uiout, &args, &val, &caught, errstring, 
	   NULL, mask);
@


1.67
log
@2002-09-09  Elena Zannoni  <ezannoni@@redhat.com>

	From: Emmanuel Thome'  <thome@@lix.polytechnique.fr>
	* top.c (init_main): Set rl_terminal_name.
@
text
@d85 1
a85 1
int use_windows = 1;
@


1.67.2.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d85 1
a85 1
int use_windows = 0;
@


1.67.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d1955 1
a1955 1
  rl_completion_entry_function = readline_line_completion_function;
@


1.67.2.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d1360 1
a1360 1
  fprintf_filtered (stream, "Copyright 2003 Free Software Foundation, Inc.\n");
d2127 15
@


1.67.2.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a173 5
/* Sbrk location on entry to main.  Used for statistics only.  */
#ifdef HAVE_SBRK
char *lim_at_start;
#endif

d488 1
a488 1
static int
d785 1
d787 2
a788 1
	  space_at_cmd_start = lim - lim_at_start;
d808 1
d810 1
a810 1
	  long space_now = lim - lim_at_start;
d1062 1
a1062 1
static void
@


1.67.2.5
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d1204 3
a1206 3
	  puts_unfiltered ("\n\032\032pre-");
	  puts_unfiltered (annotation_suffix);
	  puts_unfiltered ("\n");
d1225 3
a1227 3
	  puts_unfiltered ("\n\032\032post-");
	  puts_unfiltered (annotation_suffix);
	  puts_unfiltered ("\n");
d1689 1
a1689 1
      if (!query ("%s", s))
@


1.67.2.6
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d643 2
a644 2
  struct cmd_list_element *c;
  enum language flang;
d1138 1
a1138 1
  char *p;
d1391 243
d1637 7
a1643 2
  if (event_loop_p)
    return PROMPT (0);
d1645 7
a1651 1
    return gdb_prompt_string;
d1696 1
a1696 1
/* Helper routine for quit_force that requires error handling.  */
d1698 2
a1699 1
struct qt_args
d1701 7
a1707 3
  char *args;
  int from_tty;
};
d1709 2
a1710 4
static int
quit_target (void *arg)
{
  struct qt_args *qt = (struct qt_args *)arg;
d1715 1
a1715 1
        target_detach (qt->args, qt->from_tty);
d1717 1
a1717 1
        target_kill ();
a1728 23
  return 0;
}

/* Quit without asking for confirmation.  */

void
quit_force (char *args, int from_tty)
{
  int exit_code = 0;

  /* An optional expression may be used to cause gdb to terminate with the 
     value of that expression. */
  if (args)
    {
      struct value *val = parse_and_eval (args);

      exit_code = (int) value_as_long (val);
    }

  /* We want to handle any quit errors and exit regardless.  */
  catch_errors (quit_target, args,
	        "Quitting: ", RETURN_MASK_ALL);

d1949 1
d1988 7
@


1.67.2.7
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d150 1
a150 1
   Renesas E7000 ICE didn't always respond in a timely manner.
d672 4
a675 4
	if (strcmp (c->name, "help") != 0
	    && strcmp (c->name, "pwd") != 0
	    && strcmp (c->name, "show") != 0
	    && strcmp (c->name, "stop") != 0)
d1269 1
a1269 1
    && strncmp (linebuffer, "server ", SERVER_COMMAND_LENGTH) == 0;
d1378 1
a1378 1
  if (strcmp (host_name, target_name) != 0)
d1464 1
a1464 1
  target_close (&current_target, 1);
a1480 1
  struct qt_args qt;
a1490 3
  qt.args = args;
  qt.from_tty = from_tty;

d1492 1
a1492 1
  catch_errors (quit_target, &qt,
d1507 1
d1593 1
d1608 1
d1616 1
d1626 1
d1723 2
a1724 1
  rl_completer_word_break_characters = default_word_break_characters ();
@


1.67.2.8
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
a385 1
	 char **gdberrmsg,
d431 1
a431 8
    {
      val = 0;
      /* If caller wants a copy of the low-level error message, make one.  
         This is used in the case of a silent error whereby the caller
         may optionally want to issue the message.  */
      if (gdberrmsg)
	*gdberrmsg = error_last_message ();
    }
d479 1
a479 19
  catcher (func, uiout, func_args, &val, &caught, errstring, NULL, mask);
  gdb_assert (val >= 0);
  gdb_assert (caught <= 0);
  if (caught < 0)
    return caught;
  return val;
}

int
catch_exceptions_with_msg (struct ui_out *uiout,
		  	   catch_exceptions_ftype *func,
		  	   void *func_args,
		  	   char *errstring,
			   char **gdberrmsg,
		  	   return_mask mask)
{
  int val;
  enum return_reason caught;
  catcher (func, uiout, func_args, &val, &caught, errstring, gdberrmsg, mask);
d509 1
a509 2
  catcher (do_catch_errors, uiout, &args, &val, &caught, errstring, 
	   NULL, mask);
d1362 1
a1362 1
  fprintf_filtered (stream, "Copyright 2004 Free Software Foundation, Inc.\n");
@


1.66
log
@* top.c (gdb_rl_operate_and_get_next): Make sure
operate-and-get-next functions correctly even when the history
list is completely filled.
@
text
@d1960 1
@


1.66.6.1
log
@2002-09-14  Elena Zannoni  <ezannoni@@redhat.com>

 	From: Emmanuel Thome'  <thome@@lix.polytechnique.fr>
 	* top.c (init_main): Set rl_terminal_name.
@
text
@a1959 1
  rl_terminal_name = getenv ("TERM");
@


1.66.6.2
log
@2002-09-28  Andrew Cagney  <ac131313@@redhat.com>

	Import from mainline:

	From Grace Sainsbury <graces@@redhat.com>:
	* Makefile.in (gdbtk-main.o): New target.
	(gdb.o): New target.
	(main_h): Define.
	(main.o): Update dependencies.
	(gdb$(EXEEXT)): Add gdb.o.
	(SUBDIR_GDBTK_SRCS): Add gdbtk-main.c.
	(SUBDIR_GDBTK_ALL, SUBDIR_GDBTK_UNINSTALL): Set.
	(SUBDIR_GDBTK_CLEAN): Set.
	(install-gdbtk): Install the insight binary.
	(uninstall-gdbtk): New target.
	(all-gdbtk, clean-gdbtk): New rule.
	* top.c (use_windows): Default to zero.
	* main.c: Include "main.h".
	(main): Delete.
	(struct captured_main_args): Delete.
	(gdb_main): New function.
	* main.h: New file.
	* gdb.c: New File.

Index: gdbtk/ChangeLog
2002-09-26  Andrew Cagney  <ac131313@@redhat.com>

	Import from mainline:

	From Grace Sainsbury <graces@@redhat.com>:
	* generic/gdbtk-main.c: New file.

Index: testsuite/gdb.gdbtk/ChangeLog
2002-09-28  Andrew Cagney  <ac131313@@redhat.com>

	Import from mainline:
	2002-09-26  Keith Seitz  <keiths@@redhat.com>
        * lib/insight-support.exp (gdbtk_start): Figure out where
        the insight executable is based on where gdb is. Use this
        executable to start insight instead of gdb.
@
text
@d85 1
a85 1
int use_windows = 0;
@


1.65
log
@	* defs.h (gdb_readline_wrapper): Declare.
	* utils.c (prompt_for_continue): Use gdb_readline_wrapper.
	* tracepoint.c (read_actions): Use gdb_readline_wrapper.
	* top.c (gdb_readline_wrapper): New function.
	(command_line_input): Use it.
@
text
@d1085 2
d1099 14
a1112 2
  /* Add 1 because we eventually want the next line.  */
  operate_saved_history = where_history () + 1;
@


1.64
log
@Fix some K&R isms.
@
text
@d950 23
d1200 1
a1200 1
	  rl = readline (local_prompt);
@


1.63
log
@2002-07-03  Martin M. Hunt  <hunt@@redhat.com>

	* top.c (execute_command): Use cmd_func() and cmd_func_p().

	* cli/cli-decode.c (cmd_func_p): New function.
	(cmd_func): New function.

	* command.h: Add cmd_func() and cmd_func_p().
@
text
@d1040 1
a1040 1
gdb_rl_operate_and_get_next_completion ()
@


1.62
log
@* findvar.c (extract_signed_integer): Cast printf argument
to suppress format warning.
(extract_unsigned_integer): Likewise.
* infcmd.c (registers_info): Likewise.
* top.c (get_prompt_1): Likewise.
* valops.c (value_assign): Likewise.
* valprint.c (print_decimal): Likewise.
@
text
@d706 1
a706 1
      else if (c->func == NULL)
d711 1
a711 1
	(*c->func) (c, arg, from_tty & caution);
@


1.62.4.1
log
@merge with trunk.
@
text
@d706 1
a706 1
      else if (!cmd_func_p (c))
d711 1
a711 1
	cmd_func (c, arg, from_tty & caution);
@


1.62.6.1
log
@Initial check-in of interpreter support from Apple. (Slightly massaged and
modified by me.)
@
text
@a65 1
#include "interps.h"
a388 1
  struct gdb_interpreter *saved_interp;
a410 1
  saved_interp = gdb_current_interpreter ();
d441 1
a441 18
  /*
    cases:
    1. interp1 calls using uiout1
    2. interp1 calls using uiout1 calls using uiout2
    3. interp1 calls using uiout1 calls interp2 using uiout2
    4. more?
    is it enough to note that the interpreter has changed and
    reset saved_uiout
   */
  if (gdb_current_interpreter () == saved_interp)
    uiout = saved_uiout;
  else
    {
      /* We've changed interpreters under this call.
	 Reset uiout to the current interpreter's uiout
	 and hope for the best. */
      uiout = gdb_interpreter_ui_out (NULL);
    }
d2091 3
a2093 6
  /* All the interpreters should have had a look at things by now.
     Initialize the selected interpreter. */
  {
    struct gdb_interpreter *interp;
    if (interpreter_p == NULL)
      interpreter_p = xstrdup (GDB_INTERPRETER_CONSOLE);
d2095 9
a2103 15
    interp = gdb_lookup_interpreter (interpreter_p);

    if (interp == NULL)
      {
        fprintf_unfiltered (gdb_stderr, "Interpreter `%s' unrecognized.\n",
                            interpreter_p);
        exit (1);
      }
    if (!gdb_set_interpreter (interp))
      {
        fprintf_unfiltered (gdb_stderr, "Interpreter `%s' failed to initialize.\n",
                            interpreter_p);
        exit (1);
      }
  }
@


1.62.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d726 1
a726 1
      else if (!cmd_func_p (c))
d731 1
a731 1
	cmd_func (c, arg, from_tty & caution);
d1060 1
a1060 1
gdb_rl_operate_and_get_next_completion (void)
@


1.62.6.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a969 23
/* This is like readline(), but it has some gdb-specific behavior.
   gdb can use readline in both the synchronous and async modes during
   a single gdb invocation.  At the ordinary top-level prompt we might
   be using the async readline.  That means we can't use
   rl_pre_input_hook, since it doesn't work properly in async mode.
   However, for a secondary prompt (" >", such as occurs during a
   `define'), gdb just calls readline() directly, running it in
   synchronous mode.  So for operate-and-get-next to work in this
   situation, we have to switch the hooks around.  That is what
   gdb_readline_wrapper is for.  */
char *
gdb_readline_wrapper (char *prompt)
{
  /* Set the hook that works in this case.  */
  if (event_loop_p && after_char_processing_hook)
    {
      rl_pre_input_hook = (Function *) after_char_processing_hook;
      after_char_processing_hook = NULL;
    }

  return readline (prompt);
}

d1197 1
a1197 1
	  rl = gdb_readline_wrapper (local_prompt);
@


1.62.6.4
log
@        * interps.c (_initialize_interpreter): Remove ability to set
        the interpreter. This could really undermine MI clients.
        * top.c (catcher): Don't worry about interpreter changes.
@
text
@d390 1
d413 1
d444 18
a461 1
  uiout = saved_uiout;
@


1.62.6.5
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a1085 2
  int where;

d1098 2
a1099 14
  /* Find the current line, and find the next line to use.  */
  where = where_history();

  /* FIXME: kettenis/20020817: max_input_history is renamed into
     history_max_entries in readline-4.2.  When we do a new readline
     import, we should probably change it here too, even though
     readline maintains backwards compatibility for now by still
     defining max_input_history.  */
  if ((history_is_stifled () && (history_length >= max_input_history)) ||
      (where >= history_length - 1))
    operate_saved_history = where;
  else
    operate_saved_history = where + 1;

@


1.62.6.6
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d86 1
a86 1
int use_windows = 0;
a1960 1
  rl_terminal_name = getenv ("TERM");
@


1.62.6.7
log
@2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* cli/cli-interp.c (_initialize_cli_interp): Call
	gdb_interpreter_new and gdb_interpreter_add.
	* top.c (gdb_init): Call gdb_interpreter_lookup.
	(gdb_init): Call gdb_interpreter_set.
	* interps.c (gdb_interpreter_new): Renamed from
	gdb_new_interpreter.
	(gdb_interpreter_add): Renamed from gdb_add_interpreter.
	(gdb_interpreter_set): Renamed from gdb_set_interpreter.
	(gdb_interpreter_lookup): Renamed from gdb_lookup_interpreter.
	(gdb_interpreter_current): Renamed from gdb_current_interpreter.
	Update all callers.
	* interps.h: Ditto.

2002-11-04  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-interp.c (mi_interpreter_resume): Ditto.
	(mi_cmd_interpreter_exec): Use gdb_interpreter_lookup.
	(_initialize_mi_interp): Use gdb_interpreter_new,
	gdb_interpreter_add.
	* mi-cmd-break.c (mi_cmd_break_insert): Use
	gdb_interpreter_current_is_named_p.
	(mi_cmd_break_watch): Ditto.
	* mi-events.c (mi_interp_stack_changed_hook): Ditto.
	(event_notify): Ditto.
	* mi-main.c (captured_mi_execute_command): Use
	gdb_interpreter_current_is_named_p.
	(mi_load_progress): Ditto.
@
text
@a2132 4

    /* There will always be an interpreter.  Either the one specified
       by the user at start up or the console.  */

d2137 1
a2137 1
    interp = gdb_interpreter_lookup (interpreter_p);
d2145 1
a2145 1
    if (!gdb_interpreter_set (interp))
@


1.61
log
@2002-03-27  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c (_initialize_breakpoint): Clean up help string.
	* infcmd.c (_initialize_infcmd): Ditto.
	* language.c (_initialize_language): Ditto.
	* symfile.c (_initialize_symfile): Ditto.
	* top.c (_init_main): Ditto.
	* cli/cli-cmds.c (init_cli_cmds): Ditto.
@
text
@d1438 1
a1438 1
			   promptp - local_prompt);
d1584 1
a1584 1
			 promptp - local_prompt);
@


1.60
log
@* command.h: Update copyright.
(struct cmd_list_element): Replace definition with opaque
declaration.
(enum cmd_types): Document that it will eventually be moved to
cli/cli-decode.h
(CMD_DEPRECATED, DEPRECATED_WARN_USER): Delete macros.
(MALLOCED_REPLACEMENT): Delete macro.
* Makefile.in (cli_decode_h): Add $(command_h).
(top.o, completer.o, maint.o): Add dependency on $(cli_decode_h).
* top.c: Include "cli/cli-decode.h".
* completer.c: Include "cli/cli-decode.h".
* maint.c: Include "cli/cli-decode.h".
* cli/cli-decode.h: Include "command.h".
(enum command_class): Delete.
(enum cmd_types): Comment out.
(enum cmd_auto_boolean): Delete.
(enum var_types): Delete.
@
text
@d1993 1
a1993 1
		   "Set the size of the command history, \n\
d2001 1
a2001 1
 (the list of previous commands of which a record is kept).", &sethistlist);
@


1.59
log
@* command.h: (execute_cmd_post_hook): Declare.
(execute_cmd_pre_hook): Declare.
* cli/cli-script.c (clear_hook_in_cleanup): New function.
(execute_cmd_post_hook, execute_cmd_pre_hook): New
functions. Execute pre/post hook while ensuring that afterwords
hook_in is cleared.
* top.c (execute_command): Use execute_cmd_post_hook, and
execute_cmd_pre_hook to execute pre/post commands.
* infrun.c (normal_stop): Pass stop_command and not pre_hook to
hook_stop_stub.
(hook_stop_stub): Call execute_cmd_pre_hook.
@
text
@d30 1
@


1.58
log
@* cli/cli-decode.c (set_cmd_completer): New function.
* command.h (set_cmd_completer): Declare.
* cli/cli-decode.h (set_cmd_completer): Ditto.

* breakpoint.c (_initialize_breakpoint): Use set_cmd_completer.
* cli/cli-cmds.c (init_cli_cmds): Ditto.
* win32-nat.c (_initialize_inftarg): Ditto.
* remote-rdi.c (_initialize_remote_rdi): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* hppa-tdep.c (_initialize_hppa_tdep): Ditto.
* source.c (_initialize_source): Ditto.
* exec.c (_initialize_exec): Ditto.
* solib.c (_initialize_solib): Ditto.
* top.c (init_main): Ditto.
* tracepoint.c (_initialize_tracepoint): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* printcmd.c (_initialize_printcmd): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
@
text
@d696 1
a696 6
      if ((c->hook_pre) && (!c->hook_in))
      {
        c->hook_in = 1; /* Prevent recursive hooking */
        execute_user_command (c->hook_pre, (char *) 0);
        c->hook_in = 0; /* Allow hook to work again once it is complete */
      }
d713 1
a713 6
      if ((c->hook_post) && (!c->hook_in))
      {
        c->hook_in = 1; /* Prevent recursive hooking */
        execute_user_command (c->hook_post, (char *) 0);
        c->hook_in = 0; /* allow hook to work again once it is complete */
      }
@


1.57
log
@* cli/cli-decode.c (cmd_cfunc_eq): New function.
* command.h (cmd_cfunc_eq): Declare.
* cli/cli-decode.h (cmd_cfunc_eq): Ditto.

* cli/cli-cmds.h (is_complete_command): Change parameter to a
``struct cmd_list_element *''.
* cli/cli-cmds.c (is_complete_command): Update.  Use
cmd_cfunc_eq.
* top.c (execute_command): Pass the command to
is_complete_command.
* tracepoint.c: Replace function.cfunc with cmd_cfunc_eq.
@
text
@d2011 1
a2011 1
  c->completer = filename_completer;
@


1.56
log
@* defs.h (throw_exception): Rename return_to_top_level.  Update
comments.
* utils.c (error_stream, internal_verror, quit): Ditto.
* top.c (throw_exception, catcher): Ditto.
* sparclet-rom.c (sparclet_load): Ditto.
* remote.c (interrupt_query, minitelnet): Ditto.
* remote-sds.c (interrupt_query): Ditto.
* remote-mips.c (mips_error, mips_kill): Ditto.
* ocd.c (interrupt_query): Ditto.
* monitor.c (monitor_interrupt_query): Ditto.
* m3-nat.c (suspend_all_threads, thread_resume_command): Ditto.
* target.h: Update comment.

* m3-nat.c, ocd.c, sparclet-rom.c: Update copyright.
@
text
@d687 1
a687 1
	  && !is_complete_command (c->function.cfunc))
@


1.55
log
@* cli/cli-decode.c (do_cfunc, set_cmd_cfunc): New functions.
(do_sfunc, set_cmd_sfunc): New functions.

* command.h (struct cmd_list_element): Add field func.
* cli/cli-decode.h (struct cmd_list_element): Ditto.
* command.h (set_cmd_sfunc, set_cmd_cfunc): Declare.
* cli/cli-decode.h: Ditto.

* cli/cli-decode.c (help_cmd): Test for func not cfunc/sfunc.
(help_all, help_cmd_list): Ditto.
(find_cmd, complete_on_cmdlist): Ditto.
* top.c (execute_command): Ditto.

* cli/cli-setshow.c (do_setshow_command): Call func instead of
function.sfunc.

* infcmd.c (notice_args_read): Fix function signature.

* cli/cli-cmds.c (init_cli_cmds): Use set_cmd_sfunc.
* cli/cli-decode.c (add_set_cmd): Ditto.
* utils.c (initialize_utils): Ditto.
* maint.c (_initialize_maint_cmds): Ditto.
* infrun.c (_initialize_infrun): Ditto.
* demangle.c (_initialize_demangler): Ditto.
* remote.c (add_packet_config_cmd): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* cris-tdep.c (_initialize_cris_tdep): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* kod.c (_initialize_kod): Ditto.
* valprint.c (_initialize_valprint): Ditto.
* top.c (init_main): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
* arm-tdep.c (_initialize_arm_tdep): Ditto.
* arch-utils.c (initialize_current_architecture): Ditto.
(_initialize_gdbarch_utils): Ditto.
* alpha-tdep.c (_initialize_alpha_tdep): Ditto.

* cli/cli-decode.c (add_cmd): Use set_cmd_cfunc.
* wince.c (_initialize_inftarg): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* language.c (_initialize_language): Ditto.
* arc-tdep.c (_initialize_arc_tdep): Ditto.
@
text
@d199 1
a199 1
   return_to_top_level.  */
d301 1
a301 1
/* Where to go for return_to_top_level.  */
d307 1
a307 1
return_to_top_level (enum return_reason reason)
d343 1
a343 1
   function is aborted (using return_to_top_level() or zero if the
d461 1
a461 1
  return_to_top_level (caught);
@


1.54
log
@s/NO_FUNCTION/NULL/
@
text
@d675 10
a684 1
      /* Clear off trailing whitespace, except for set and complete command.  */
d710 1
a710 1
      else if (c->function.cfunc == NULL)
d715 1
a715 1
	(*c->function.cfunc) (arg, from_tty & caution);
d1955 1
a1955 1
      c->function.sfunc = set_async_prompt;
d1991 1
a1991 1
      c->function.sfunc = set_async_editing_command;
d2005 1
a2005 1
  c->function.sfunc = set_history_size_command;
d2042 1
a2042 1
      c->function.sfunc = set_async_annotation_level;
@


1.53
log
@2002-01-20  Michael Chastain  <mec@@shout.net>

	* top.c (print_gdb_version): Bump copyright year to 2002.
@
text
@d701 1
a701 1
      else if (c->function.cfunc == NO_FUNCTION)
@


1.52
log
@Remove else clause to #if UI_OUT.
@
text
@d1323 1
a1323 1
  fprintf_filtered (stream, "Copyright 2001 Free Software Foundation, Inc.\n");
@


1.51
log
@Remove obsolete MacOS support.
@
text
@a62 1
#ifdef UI_OUT
a64 1
#endif
a2089 1
#ifdef UI_OUT
a2103 1
#endif
@


1.50
log
@	* NEWS: Updated.
	* event-loop.c (start_event_loop): Call
	after_char_processing_hook.
	* event-top.h (after_char_processing_hook): Declare.
	* event-top.c (rl_callback_read_char_wrapper): Call
	after_char_processing_hook.
	(after_char_processing_hook): New global.
	* top.c (operate_saved_history): New global.
	(gdb_rl_operate_and_get_next): New function.
	(init_main): Add the operate-and-get-next defun.
	(gdb_rl_operate_and_get_next_completion): New function.
@
text
@d2 4
a5 2
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
a894 5
      /* OBSOLETE #ifdef MPW */
      /* OBSOLETE          Move to a new line so the entered line doesn't have a prompt */
      /* OBSOLETE          on the front of it. */
      /* OBSOLETE       fputs_unfiltered ("\n", gdb_stdout); */
      /* OBSOLETE #endif  *//* MPW */
@


1.49
log
@	* top.c (gdb_init): Call init_ui_hook before initializing
	the default UI.
@
text
@d1038 46
d1928 4
@


1.48
log
@s/value_ptr/struct value */
@
text
@d185 4
a188 1
   command file.  */
d2040 5
a2060 3

  if (init_ui_hook)
    init_ui_hook (argv0);
@


1.47
log
@Don't print ``(MI_OUT)'' at startup.
@
text
@d1342 1
a1342 1
      value_ptr arg_val;
d1624 1
a1624 1
      value_ptr val = parse_and_eval (args);
@


1.46
log
@* value.h (value_as_address): Rename value_as_pointer.
* eval.c, findvar.c, gnu-v2-abi.c, gnu-v3-abi.c, jv-lang.c,
jv-valprint.c, printcmd.c, stack.c, top.c, valarith.c, valops.c,
values.c: Update.
@
text
@a1274 4
#ifdef MI_OUT
  /* Print it console style until a format is defined */
  fprintf_filtered (stream, "GNU gdb %s (MI_OUT)\n", version);
#else
a1275 1
#endif
@


1.45
log
@* defs.h (enum return_reason): Renumber so that all values are
negative.
(RETURN_MASK): Negate reason.
(catch_exception_ftype): Declare.
(catch_exceptions): Declare.
* top.c (catcher): New function, based on catch_errors.  Add in
parameter func_uiout and out parameters func_val, func_caught and
func_cleanup.  Change type of func to catch_exceptions_ftype.
Save/restore uiout.
(struct catch_errors_args): Define.
(do_catch_errors): New function.
(catch_errors): Rewrite, use do_catch_errors and catcher.
(catch_exceptions): New function, use catcher.
@
text
@d1439 1
a1439 1
		  addrval = value_as_pointer (arg_val);
@


1.44
log
@* event-top.c (async_stop_sig) [HAVE_SIGPROCMASK]: Some
gratuitious whitespace changes.
[!HAVE_SIGPROCMASK]: Call sigsetmask if HAVE_SIGSETMASK is defined.
* top.c: Remove redundant logic to define HAVE_SIGSETMASK.
(sigsetmask) Don't define macro.
(stop_sig) [HAVE_SIGPROCMASK]: Add bit of code snatched from
async_stop_sig from event-top.c.
[!HAVE_SIGPROCMASK]: Call sigsetmask if HAVE_SIGSETMASK is
defined.
* configure.in (AC_CHECK_FUNCS): Put functions in alphabetical
order.  Add sigsetmask.
(AC_FUNC_VFORK, AC_FUNC_ALLOCA): Reorder such that they're in
alphabetical order.
* config/xm-aix4.h, config/alpha/xm-alphalinux.h,
config/i386/xm-cygwin.h, config/rs6000/xm-rs6000.h
(HAVE_SIGSETMASK): Remove.
* aclocal.m4, config.in, configure
@
text
@d44 1
d338 5
a342 4
/* Call FUNC with arg ARGS, catching any errors.  If there is no
   error, return the value returned by FUNC.  If there is an error,
   print ERRSTRING, print the specific error message, then return
   zero.
d370 8
a377 3
int
catch_errors (catch_errors_ftype *func, void * args, char *errstring,
	      return_mask mask)
a380 1
  int val;
d384 1
d390 4
d404 5
d420 1
a420 1
    val = (*func) (args);
d432 2
a433 2
  /* Restore the cleanup chain and error/quit messages to their
     original states. */
d437 2
d444 10
a453 4
  /* Return normally if no error/quit event occurred. */

  if (!caught)
    return val;
d455 1
a455 1
  /* If the caller didn't request that the event be caught, relay the
d458 2
a459 2
  if (!(mask & RETURN_MASK (caught)))
    return_to_top_level (caught);
d461 16
a476 1
  /* Tell the caller that an event was caught.
d478 5
a482 2
     FIXME: nsd/2000-02-22: When MASK is RETURN_MASK_ALL, the caller
     can't tell what type of event occurred.
d484 6
a489 2
     A possible fix is to add a new interface, catch_event(), that
     returns enum return_reason after catching an error or a quit.
d491 13
a503 12
     When returning normally, i.e. without catching an error or a
     quit, catch_event() could return RETURN_NORMAL, which would be
     added to enum return_reason.  FUNC would return information
     exclusively via ARGS.

     Alternatively, normal catch_event() could return FUNC's return
     value.  The caller would need to be aware of potential overlap
     with enum return_reason, which could be publicly restricted to
     negative values to simplify return value processing in FUNC and
     in the caller. */

  return 0;
@


1.43
log
@* top.c (SIGSETJMP): Protect env argument with parentheses.
(SIGLONGJMP): Protect env argument with parentheses.
@
text
@a180 13
/* Some System V have job control but not sigsetmask(). */
#if !defined (HAVE_SIGSETMASK)
#if !defined (USG)
#define HAVE_SIGSETMASK 1
#else
#define HAVE_SIGSETMASK 0
#endif
#endif

#if 0 == (HAVE_SIGSETMASK)
#define sigsetmask(n)
#endif

d912 8
d921 1
@


1.42
log
@* defs.h (HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_LONG_DOUBLE_FORMAT, DOUBLEST)
(floatformat_to_doublest, floatformat_from_doublest)
(floatformat_is_negative, floatformat_is_nan)
(floatformat_mantissa, store_floating)
(extract_floating): Move declaration from here.
* doublest.h: To here.  New file.
* utils.c (get_field, floatformat_to_doublest, put_field)
(ldfrexp, floatformat_from_doublest, floatformat_is_negative)
(floatformat_is_nan, floatformat_mantissa)
(FLOATFORMAT_CHAR_BIT): Move from here.
* doublest.c: To here.  New file.
* findvar.c (store_floating, extract_floating): Move from here.
* doublest.c: To here.
* Makefile.in (SFILES): Add doublest.c.
(COMMON_OBS): Add doublest.o.
(doublest.o): Specify dependencies.
(doublest_h): Define.

* config/m88k/tm-m88k.h: Include "doublest.h".
* config/i960/tm-i960.h: Ditto.
* config/i386/tm-symmetry.h: Ditto.
* rs6000-tdep.c, valarith.c: Ditto.
* valprint.c, stabsread.c, sh-tdep.c: Ditto.
* ia64-tdep.c, i387-tdep.c, i386-tdep.c: Ditto.
* values.c, arm-tdep.c, arm-linux-tdep.c: Ditto.
* alpha-tdep.c, ax.h, expression.h: Ditto.
* sh-tdep.c, parse.c, top.c, value.h: Ditto.

* Makefile.in (arm-tdep.o): Add $(doublest_h).
(i386-tdep.o, i387-tdep.o, ia64-tdep.o): Ditto.
(rs6000-tdep.o, stabsread.o, valarith.o): Ditto.
(values.o, valprint.o, arm-linux-tdep.o): Ditto.
(alpha-tdep.o, ax_h, parse.o, top.o, value_h): Ditto.
(parser_defs_h): Ditto.
(expression_h): Add $(doublest_h) and $(symtab_h).
@
text
@d302 2
a303 2
#define SIGSETJMP(buf)		sigsetjmp(buf, 1)
#define SIGLONGJMP(buf,val)	siglongjmp(buf,val)
d307 1
a307 1
#define SIGLONGJMP(buf,val)	longjmp(buf,val)
@


1.41
log
@2001-07-17  Elena Zannoni  <ezannoni@@redhat.com>

	* top.c (catch_errors): Convert PTR to void * in parameters list.
	(quit_cover): Ditto.
@
text
@d43 1
@


1.41.2.1
log
@* top.c (SIGSETJMP): Protect env argument with parentheses.
(SIGLONGJMP): Protect env argument with parentheses.
@
text
@d301 2
a302 2
#define SIGSETJMP(buf)		sigsetjmp((buf), 1)
#define SIGLONGJMP(buf,val)	siglongjmp((buf), (val))
d306 1
a306 1
#define SIGLONGJMP(buf,val)	longjmp((buf), (val))
@


1.41.2.2
log
@Don't print ``(MI_OUT)'' during startup.
@
text
@d1231 4
d1236 1
@


1.41.2.3
log
@2002-01-20  Michael Chastain  <mec@@shout.net>

	* top.c (print_gdb_version): Bump copyright year to 2002.
@
text
@d1235 1
a1235 1
  fprintf_filtered (stream, "Copyright 2002 Free Software Foundation, Inc.\n");
@


1.40
log
@2001-07-16  Elena Zannoni  <ezannoni@@redhat.com>

        * top.c (show_commands): Remove extern decl of history_get, it's
	already in readline/history.h.
@
text
@d381 1
a381 1
catch_errors (catch_errors_ftype *func, PTR args, char *errstring,
d515 1
a515 1
quit_cover (PTR s)
@


1.39
log
@2001-07-16  Elena Zannoni  <ezannoni@@redhat.com>

        * top.c (is_complete_command, init_cmd_lists, init_cli_cmds,
        execute_user_command, do_setshow_command, get_prompt, init_proc,
        serial_log_command): Remove extern declarations.  Include
        cli/cli-cmds.h, cli/cli-script.h, cli/cli-setshow.h, serial.h.
        * gdbcmd.h (execute_user_command): Remove declaration, it's already
        in cli/cli-script.h.
        * command.h (do_setshow_command): Remove declaration, it's already
        in cli/cli-setshow.h.
        * infrun.c: Include "cli/cli-script.h" for execute_user_command.
        * Makefile.in (infrun.o): Update dependencies.
        (top.o): Ditto.
        * cli/cli-setshow.h: Add comment for do_setshow_command.
@
text
@a1644 2
extern HIST_ENTRY *history_get (int);

@


1.38
log
@2001-07-15  Elena Zannoni  <ezannoni@@redhat.com>

	* top.c (quit_cover, float_handler): Move definition up before use.
	(gdb_init): Move to end of file, to avoid calls to not yet defined
	functions.
	Delete prototypes.
@
text
@d25 3
d42 1
a63 16
/* From completer.c */

extern int is_complete_command (void (*func) (char *args, int from_tty));

/* From cli/cli-cmds.c */

extern void init_cmd_lists (void);

extern void init_cli_cmds (void);

extern void execute_user_command (struct cmd_list_element *c, char *args);

/* From cli/cli-setshow.c */

extern void do_setshow_command (char *, int, struct cmd_list_element *);

a113 1
extern char *get_prompt (void);	/* access function for prompt string */
a581 2
extern void init_proc (void);

a602 2
  /* FIXME: These should really be in an appropriate header file */
  extern void serial_log_command (const char *);
@


1.37
log
@2001-07-15  Elena Zannoni  <ezannoni@@redhat.com>

	* top.c (readline_line_completion_function, noop_completer): Move
 	from here...
	* completer.c (readline_line_completion_function, noop_completer):
 	...to here.
	* gdbcmd.h (readline_line_completion_function, noop_completer):
 	Move declarations from here...
	* completer.h (readline_line_completion_function, noop_completer):
 	...to here.
	* corefile.c: Include completer.h.
	* source.c: Ditto.
	* symfile.c: Ditto.
	* Makefile.in: Update dependencies.
@
text
@a75 41
/* Exported to CLI cli/cli-cmds.c. */

void set_verbose (char *, int, struct cmd_list_element *);

void show_history (char *, int);

void set_history (char *, int);

void show_commands (char *, int);

void do_restore_instream_cleanup (void *stream);

/* Prototypes for local functions */

static void dont_repeat_command (char *, int);

static void init_signals (void);

#ifdef STOP_SIGNAL
static void stop_sig (int);
#endif

static void init_main (void);

static void float_handler (int);

static void init_signals (void);

static void set_history_size_command (char *, int, struct cmd_list_element *);

static void do_nothing (int);

#ifdef SIGHUP
/* NOTE 1999-04-29: This function will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c */
/* static */ int quit_cover (PTR);

static void disconnect (int);
#endif

a521 9
static void
disconnect (int signo)
{
  catch_errors (quit_cover, NULL,
	      "Could not kill the program being debugged", RETURN_MASK_ALL);
  signal (SIGHUP, SIG_DFL);
  kill (getpid (), SIGHUP);
}

d535 9
a607 61
void
gdb_init (char *argv0)
{
  if (pre_init_ui_hook)
    pre_init_ui_hook ();

  /* Run the init function of each source file */

  getcwd (gdb_dirbuf, sizeof (gdb_dirbuf));
  current_directory = gdb_dirbuf;

#ifdef __MSDOS__
  /* Make sure we return to the original directory upon exit, come
     what may, since the OS doesn't do that for us.  */
  make_final_cleanup (do_chdir_cleanup, xstrdup (current_directory));
#endif

  init_cmd_lists ();		/* This needs to be done first */
  initialize_targets ();	/* Setup target_terminal macros for utils.c */
  initialize_utils ();		/* Make errors and warnings possible */
  initialize_all_files ();
  initialize_current_architecture ();
  init_cli_cmds();
  init_main ();			/* But that omits this file!  Do it now */

  /* The signal handling mechanism is different depending whether or
     not the async version is run. NOTE: in the future we plan to make
     the event loop be the default engine of gdb, and this difference
     will disappear. */
  if (event_loop_p)
    async_init_signals ();
  else
    init_signals ();

  /* We need a default language for parsing expressions, so simple things like
     "set width 0" won't fail if no language is explicitly set in a config file
     or implicitly set by reading an executable during startup. */
  set_language (language_c);
  expected_language = current_language;		/* don't warn about the change.  */

#ifdef UI_OUT
  /* Install the default UI */
  if (!init_ui_hook)
    {
      uiout = cli_out_new (gdb_stdout);

      /* All the interpreters should have had a look at things by now.
	 Initialize the selected interpreter. */
      if (interpreter_p)
	{
	  fprintf_unfiltered (gdb_stderr, "Interpreter `%s' unrecognized.\n",
			      interpreter_p);
	  exit (1);
	}
    }
#endif

  if (init_ui_hook)
    init_ui_hook (argv0);
}

d957 9
a1777 9
static void
float_handler (int signo)
{
  /* This message is based on ANSI C, section 4.7.  Note that integer
     divide by zero causes this, so "float" is a misnomer.  */
  signal (SIGFPE, float_handler);
  error ("Erroneous arithmetic operation.");
}

d1975 61
@


1.36
log
@	* utils.c (query): Remove tui hacks; tui must use the query_hook.
	* top.c (command_loop): Remove tui insert_mode hacks; don't call
	tuiCleanUp because this must be made with atexit by tui.
	* symfile.c (symbol_file_command): Remove call to TUIDO
	* stack.c (show_and_print_stack_frame_stub): Remove tui check;
	not necessary when using the selected frame hooks.
	(print_stack_frame_stub): Likewise.
	(print_frame_info_base): Likewise.
	(print_frame_info): Likewise.
	(up_silently_command): Likewise.
	(down_silently_command): Likewise.
	(show_stack_frame): Likewise for TUIDO.
	(select_frame): Likewise.
	(select_and_print_frame): Likewise.
	(stack_publish_stopped_with_no_frame): Remove.
	(select_and_maybe_print_frame): Remove.
	* main.c (captured_main): Remove tui_fileopen and tuiInit; tui
	must use the initialize ui hook.
	* infrun.c (normal_stop): Remove call to TUIDO; tui must use the
	selected frame hooks.
	* event-top.c (command_handler): Remove tui insert_mode hack.
	* defs.h: Remove TUIDO; Only include tui.h.
	* breakpoint.c (mention): Remove calls to TUIDO.
	(delete_breakpoint): Remove tui hacks; tui must install
	the breakpoint hooks.
@
text
@a97 2
static char *readline_line_completion_function (char *, int);

a1035 18
/* Functions that are used as part of the fancy command line editing.  */

/* This can be used for functions which don't want to complete on symbols
   but don't want to complete on anything else either.  */
/* ARGSUSED */
char **
noop_completer (char *text, char *prefix)
{
  return NULL;
}

/* Line completion interface function for readline.  */

static char *
readline_line_completion_function (char *text, int matches)
{
  return line_completion_function (text, matches, rl_line_buffer, rl_point);
}
@


1.35
log
@	* top.c (user_args): Remove unused declaration.
@
text
@a847 3
#if defined(TUI)
      extern int insert_mode;
#endif
a855 9
#if defined(TUI)
      /* A bit of paranoia: I want to make sure the "insert_mode" global
       * is clear except when it is being used for command-line editing
       * (see tuiIO.c, utils.c); otherwise normal output will
       * get messed up in the TUI. So clear it before/after
       * the command-line-input call. - RT
       */
      insert_mode = 0;
#endif
a859 3
#if defined(TUI)
      insert_mode = 0;
#endif
a1735 10

#if defined(TUI)
  /* tuiDo((TuiOpaqueFuncPtr)tuiCleanUp); */
  /* The above does not need to be inside a tuiDo(), since
   * it is not manipulating the curses screen, but rather,
   * it is tearing it down.
   */
  if (tui_version)
    tuiCleanUp ();
#endif
@


1.35.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d726 1
d1515 1
a1515 1
		  elt_type = check_typedef (ARRAY_ELEMENT_TYPE (arg_type));
d1620 1
a1620 1
		    len = ENUM_NUM_VALUES (arg_type);
d1623 1
a1623 1
		      if (ENUM_VALUE_VALUE (arg_type, i) == longval)
d1628 1
a1628 1
			const char *name = ENUM_VALUE_NAME (arg_type, i);
@


1.34
log
@Phase 1 of the ptid_t changes.
@
text
@a226 15
/* Structure for arguments to user defined functions.  */
#define MAXUSERARGS 10
struct user_args
  {
    struct user_args *next;
    struct
      {
	char *arg;
	int len;
      }
    a[MAXUSERARGS];
    int count;
  }
 *user_args;

@


1.33
log
@Obsolete MPW as host.
@
text
@d344 2
a345 1
int (*target_wait_hook) (int pid, struct target_waitstatus * status);
d1713 1
a1713 1
  if (inferior_pid != 0 && target_has_execution)
d1750 1
a1750 1
  if (inferior_pid != 0 && target_has_execution)
@


1.32
log
@2001-04-18  Martin M. Hunt  <hunt@@redhat.com>

	* top.c (gdb_init): Don't call cli_out_new() to
	create global uiout if init_ui_hook is set.  uiout will
	have to be initialized there.
@
text
@d1005 5
a1009 5
#ifdef MPW
      /* Move to a new line so the entered line doesn't have a prompt
         on the front of it. */
      fputs_unfiltered ("\n", gdb_stdout);
#endif /* MPW */
@


1.31
log
@2001-04-05  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        From  Jimmy Guo  <guo@@cup.hp.com>
        * top.c (init_main): set prompt if annotation_level>1,
        this is necessary when annotation_level is set to 2 via
        --annotate=2 command line option.
@
text
@d707 3
a709 2
  uiout = cli_out_new (gdb_stdout);
#endif
d711 8
a718 8
#ifdef UI_OUT
  /* All the interpreters should have had a look at things by now.
     Initialize the selected interpreter. */
  if (interpreter_p && !init_ui_hook)
    {
      fprintf_unfiltered (gdb_stderr, "Interpreter `%s' unrecognized.\n",
			  interpreter_p);
      exit (1);
d737 2
a738 2
extern void serial_log_command (const char *);

@


1.30
log
@	* top.c (init_main): Make `set history file name' complete on file
	names.
@
text
@d1999 6
@


1.29
log
@Update/correct copyright notices.
@
text
@d2084 6
a2089 5
  add_show_from_set
    (add_set_cmd ("filename", no_class, var_filename, (char *) &history_filename,
		  "Set the filename in which to record the command history\n\
 (the list of previous commands of which a record is kept).", &sethistlist),
     &showhistlist);
@


1.28
log
@* signals.h: Removed.
* event-top.c (#include <signal.h>): Changed from signals.h.
* inflow.c: Likewise.
* mac-xdep.c: Likewise.
* ser-pipe.c: Likewise.
* ser-tcp.c: Likewise.
* standalone.c: Likewise.
* top.c: Likewise.
* utils.c: Likewise.
* Makefile.in: Removed signals.h from dependencies.
@
text
@d2 2
a3 1
   Copyright 1986-2000 Free Software Foundation, Inc.
@


1.27
log
@2001-01-24  Fernando Nasser  <fnasser@@redhat.com>

	* top.c (print_gdb_version): Update Copyright year.
@
text
@d26 1
a26 1
#include "signals.h"
@


1.26
log
@2000-12-20  Fernando Nasser  <fnasser@@redhat.com>

        * Makefile.in (UIOUT_CFLAGS): New macro. CFLAGS needed for uiout code
        to be compiled.  Defines UI_OUT.
        (SUBDIR_MI_CFLAGS): Defines MI_OUT, not UI_OUT.
        (INTERNAL_WARN_CFLAGS): Also include UIOUT_CFLAGS.
        * configure.in (UIOUT_CFLAGS): New configuration variable.
        (--with-uiout): New configuration option.  Causes uiout code to
        be compiled, instead of the old *printf one.
        * configure: Regenerate.
        * top.c (print_gdb_version): Test for and print MI_OUT, not UI_OUT.
        * testsuite/lib/mi-support.exp (mi_gdb_start): Test for MI_OUT,
        not UI_OUT.
@
text
@d1397 1
a1397 1
  fprintf_filtered (stream, "Copyright 2000 Free Software Foundation, Inc.\n");
@


1.25
log
@Replace free() with xfree().
@
text
@d1388 1
a1388 1
#ifdef UI_OUT
d1390 1
a1390 1
  fprintf_filtered (stream, "GNU gdb %s (UI_OUT)\n", version);
@


1.24
log
@2000-12-01  Fernando Nasser  <fnasser@@redhat.com>

        * cli/cli-decode.c: New file. Handle lists of commands, their decoding
        and documentation.
        (add_cmd, deprecate_cmd, add_abbrev_cmd, add_alias_cmd, add_prefix_cmd,
        add_abbrev_prefix_cmd, not_just_help_class_command, empty_sfunc,
        add_set_cmd, add_set_enum_cmd, add_set_auto_boolean_cmd,
        add_show_from_set, delete_cmd, apropos_cmd, help_cmd, help_list,
        help_all, print_doc_line, help_cmd_list, find_cmd, lookup_cmd_1,
        undef_cmd_error, lookup_cmd, deprecated_cmd_warning,
        lookup_cmd_composition, complete_on_cmdlist, complete_on_enum):
        Moved here from command.c.
        (add_info, add_info_alias, add_com, add_com_alias): Moved here from
        top.c.
        * cli/cli-decode.h: Definitions/declarations for the above.
        * cli/cli-cmds.c: New file.  GDB CLI commands.
        (error_no_arg, info_command, show_command, help_command, show_version,
        quit_command, pwd_command, cd_command, echo_command, shell_escape,
        make_command, show_user, set_debug, show_debug, init_cmd_lists):
        Moved here from top.c.
        (apropos_command): Moved here from command.c.
        (complete_command, source_command): Moved here (part) from top.c.
        (is_complete_command): New function. Checks if a command is the
        "complete" command.
        (init_cli_cmds): New function. Add commands to the CLI (from code
        previously in top.c.
        * cli/cli-cmds.h: Definitions/declarations for the above.
        * cli/cli-script.c: New file. GDB CLI command scripting.
        (build_command_line, get_command_line, print_command_lines,
        print_command_line, execute_user_command, execute_control_command,
        while_command, if_command, arg_cleanup, setup_user_args, locate_arg,
        insert_args, realloc_body_list, read_next_line,
        recurse_read_control_structure, read_command_lines, free_command_lines,
        do_free_command_lines_cleanup, make_cleanup_free_command_lines,
        validate_comname, user_defined_command, define_command,
        document_command, source_cleanup_lines, do_fclose_cleanup,
        show_user_1): Moved here from top.c.
        (script_from_file): New function. Implements execution of a script
        contained in a file (part of code for the source_command() that used
        to exist in top.c).
        * cli/cli-script.h: Definitions/declarations for the above.
        * cli/cli-setshow.c: New file. Handle set and show GDB CLI commands.
        (parse_auto_binary_operation, parse_binary_operation,
        do_setshow_command, cmd_show_list): Moved here from command.c.
        * cli/cli-setshow.h: Definitions/declarations for the above.
        * top.c: Remove all CLI code, except the command loop.
        (gdb_init): Call init_cli_cmds().
        * command.c: Remove obsolete file.
        * command.h: Mark as DEPRECATED.
        * gdbcmd.h: Ditto.
        * call-cmds.h: Ditto.
        * Makefile.in (SFILES): Remove command.c.
        (COMMON_OBS): Remove command.o.
        (command.o): Remove obsolete target.
        (cli_decode_h, cli_cmds_h, cli_script_h, cli_setshow_h): New macros.
        Refer to CLI header files.
        (cli-decode.o, cli-cmds.o, cli-setshow.o, cli-script.o): New targets.
        (SUBDIR_CLI_OBS, SUBDIR_CLI_SRCS, SUBDIR_CLI_DEPS, SUBDIR_CLI_INITS,
        SUBDIR_CLI_LDFLAGS, SUBDIR_CLI_CFLAGS, SUBDIR_CLI_ALL, SUBDIR_CLI_CLEAN,
        SUBDIR_CLI_INSTALL, SUBDIR_CLI_UNINSTALL): New macros for new cli
        subdirectory.
        * configure.in (enable_gdbcli): New option. Include the CLI in the
        executable (cannot be disabled yet).
        (CONFIG_OBS, CONFIG_DEPS, CONFIG_SRCS, CONFIG_INITS, ENABLE_CFLAGS,
        CONFIG_ALL, CONFIG_CLEAN, CONFIG_INSTALL, CONFIG_UNINSTALL): Add
        the corresponding SUBDIR_CLI_* macros if CLI requested.
        * configure: Regenerate.
@
text
@d660 1
a660 1
  free (old_dir);
d1026 1
a1026 1
	  free (result);
d1278 1
a1278 1
      free (rl);		/* Allocated in readline.  */
d1326 1
a1326 1
	      free (history_value);
d1336 1
a1336 1
	  free (history_value);
d1577 1
a1577 1
		      free (tmp);
d1695 1
a1695 1
   free (prompt);
@


1.23
log
@2000-11-30  Fernando Nasser  <fnasser@@redhat.com>

        * linespec.h: New file. Declarations for linespec.c.
        * linespec.c, alpha-tdep.c, breakpoint.c, parse.c, source.c,
        symtab.c, tracepoint.c: Include the above.
        * completer.c: New file. Line completion stuff for GDB.
        (get_gdb_completer_word_break_characters,
        get_gdb_completer_quote_characters): New functions. Accessors for
        useful completer internal data.
        (filename_completer, line_completion_function, skip_quoted): Moved
        here from top.c.
        * completer.h: New file. Declarations for the above.
        * linespec.c (decode_line_1): Use
        get_gdb_completer_word_break_characters and
        get_gdb_completer_quote_characters.
        * top.c: Include completer.h.
        (filename_completer, line_completion_function, skip_quoted):
        Moved to completer.c.
        * corefile.c, exec.c, source.c, symfile.c, linespec.c: Include
        completer.h.
        * Makefile.in (SFILES): Add completer.c.
        (COMMON_OBS): Add completer.o.
        (completer.o): New target.
        (linespec.o, alpha-tdep.o, breakpoint.o, parse.o, source.o,
        symtab.o, tracepoint.o): Add linespec.h to dependencies list.
        (corefile.o, exec.o, source.o, symfile.o, linespec.o): Add completer.h
        to dependencies list.
@
text
@d59 3
a61 1
/* Prototypes for local functions */
d63 1
a63 1
static void dont_repeat_command (char *, int);
d65 1
a65 1
static void source_cleanup_lines (PTR);
d67 1
a67 1
static void user_defined_command (char *, int);
d69 1
a69 1
static void init_signals (void);
d71 1
a71 3
#ifdef STOP_SIGNAL
static void stop_sig (int);
#endif
d73 1
a73 1
static char *readline_line_completion_function (char *, int);
d75 1
a75 1
static void while_command (char *, int);
d77 1
a77 1
static void if_command (char *, int);
d79 1
a79 2
static struct command_line *build_command_line (enum command_control_type,
						char *);
d81 1
a81 2
static struct command_line *get_command_line (enum command_control_type,
					      char *);
d83 1
a83 1
static void realloc_body_list (struct command_line *, int);
d85 1
a85 1
static enum misc_command_type read_next_line (struct command_line **);
d87 1
a87 2
static enum command_control_type
recurse_read_control_structure (struct command_line *);
d89 1
a89 1
static struct cleanup *setup_user_args (char *);
d91 1
a91 1
static char *locate_arg (char *);
d93 3
a95 1
static char *insert_args (char *);
d97 1
a97 1
static void arg_cleanup (void *);
a100 2
static void init_cmd_lists (void);

a104 6
static void set_verbose (char *, int, struct cmd_list_element *);

static void show_history (char *, int);

static void set_history (char *, int);

a106 22
static void show_commands (char *, int);

static void echo_command (char *, int);

static void pwd_command (char *, int);

static void show_version (char *, int);

static void document_command (char *, int);

static void define_command (char *, int);

static void validate_comname (char *);

static void help_command (char *, int);

static void show_command (char *, int);

static void info_command (char *, int);

static void complete_command (char *, int);

a108 4
static void show_debug (char *, int);

static void set_debug (char *, int);

a117 4
static void do_restore_instream_cleanup (void *stream);

static struct cleanup *make_cleanup_free_command_lines (struct command_line **);

a143 82
/* Define all cmd_list_elements.  */

/* Chain containing all defined commands.  */

struct cmd_list_element *cmdlist;

/* Chain containing all defined info subcommands.  */

struct cmd_list_element *infolist;

/* Chain containing all defined enable subcommands. */

struct cmd_list_element *enablelist;

/* Chain containing all defined disable subcommands. */

struct cmd_list_element *disablelist;

/* Chain containing all defined toggle subcommands. */

struct cmd_list_element *togglelist;

/* Chain containing all defined stop subcommands. */

struct cmd_list_element *stoplist;

/* Chain containing all defined delete subcommands. */

struct cmd_list_element *deletelist;

/* Chain containing all defined "enable breakpoint" subcommands. */

struct cmd_list_element *enablebreaklist;

/* Chain containing all defined set subcommands */

struct cmd_list_element *setlist;

/* Chain containing all defined unset subcommands */

struct cmd_list_element *unsetlist;

/* Chain containing all defined show subcommands.  */

struct cmd_list_element *showlist;

/* Chain containing all defined \"set history\".  */

struct cmd_list_element *sethistlist;

/* Chain containing all defined \"show history\".  */

struct cmd_list_element *showhistlist;

/* Chain containing all defined \"unset history\".  */

struct cmd_list_element *unsethistlist;

/* Chain containing all defined maintenance subcommands. */

struct cmd_list_element *maintenancelist;

/* Chain containing all defined "maintenance info" subcommands. */

struct cmd_list_element *maintenanceinfolist;

/* Chain containing all defined "maintenance print" subcommands. */

struct cmd_list_element *maintenanceprintlist;

struct cmd_list_element *setprintlist;

struct cmd_list_element *showprintlist;

struct cmd_list_element *setdebuglist;

struct cmd_list_element *showdebuglist;

struct cmd_list_element *setchecklist;

struct cmd_list_element *showchecklist;

d632 1
a632 1
static void
d686 1
d724 2
a725 2
/* Allocate, initialize a new command line structure for one of the
   control commands (if/while).  */
d727 2
a728 2
static struct command_line *
build_command_line (enum command_control_type type, char *args)
d730 6
a735 1
  struct command_line *cmd;
d737 1
a737 2
  if (args == NULL)
    error ("if/while commands require arguments.\n");
d739 3
a741 3
  cmd = (struct command_line *) xmalloc (sizeof (struct command_line));
  cmd->next = NULL;
  cmd->control_type = type;
d743 3
a745 8
  cmd->body_count = 1;
  cmd->body_list
    = (struct command_line **) xmalloc (sizeof (struct command_line *)
					* cmd->body_count);
  memset (cmd->body_list, 0, sizeof (struct command_line *) * cmd->body_count);
  cmd->line = savestring (args, strlen (args));
  return cmd;
}
d747 1
a747 2
/* Build and return a new command structure for the control commands
   such as "if" and "while".  */
d749 3
a751 13
static struct command_line *
get_command_line (enum command_control_type type, char *arg)
{
  struct command_line *cmd;
  struct cleanup *old_chain = NULL;

  /* Allocate and build a new command line structure.  */
  cmd = build_command_line (type, arg);

  old_chain = make_cleanup_free_command_lines (&cmd);

  /* Read in the body of this command.  */
  if (recurse_read_control_structure (cmd) == invalid_control)
d753 2
a754 4
      warning ("error reading in control structure\n");
      do_cleanups (old_chain);
      return NULL;
    }
d756 1
a756 3
  discard_cleanups (old_chain);
  return cmd;
}
d758 8
a765 7
/* Recursively print a command (including full control structures).  */
#ifdef UI_OUT
void
print_command_lines (struct ui_out *uiout, struct command_line *cmd,
		     unsigned int depth)
{
  struct command_line *list;
d767 2
a768 3
  list = cmd;
  while (list)
    {
d770 4
a773 5
      if (depth)
	ui_out_spaces (uiout, 2 * depth);

      /* A simple command, print it and continue.  */
      if (list->control_type == simple_control)
d775 4
a778 4
	  ui_out_field_string (uiout, NULL, list->line);
	  ui_out_text (uiout, "\n");
	  list = list->next;
	  continue;
d781 7
a787 9
      /* loop_continue to jump to the start of a while loop, print it
         and continue. */
      if (list->control_type == continue_control)
	{
	  ui_out_field_string (uiout, NULL, "loop_continue");
	  ui_out_text (uiout, "\n");
	  list = list->next;
	  continue;
	}
d789 2
a790 8
      /* loop_break to break out of a while loop, print it and continue.  */
      if (list->control_type == break_control)
	{
	  ui_out_field_string (uiout, NULL, "loop_break");
	  ui_out_text (uiout, "\n");
	  list = list->next;
	  continue;
	}
d792 18
a809 52
      /* A while command.  Recursively print its subcommands and continue.  */
      if (list->control_type == while_control)
	{
	  ui_out_text (uiout, "while ");
	  ui_out_field_fmt (uiout, NULL, "while %s", list->line);
	  ui_out_text (uiout, "\n");
	  print_command_lines (uiout, *list->body_list, depth + 1);
	  ui_out_field_string (uiout, NULL, "end");
	  if (depth)
	    ui_out_spaces (uiout, 2 * depth);
	  ui_out_text (uiout, "end\n");
	  list = list->next;
	  continue;
	}

      /* An if command.  Recursively print both arms before continueing.  */
      if (list->control_type == if_control)
	{
	  ui_out_text (uiout, "if ");
	  ui_out_field_fmt (uiout, NULL, "if %s", list->line);
	  ui_out_text (uiout, "\n");
	  /* The true arm. */
	  print_command_lines (uiout, list->body_list[0], depth + 1);

	  /* Show the false arm if it exists.  */
	  if (list->body_count == 2)
	    {
	      if (depth)
		ui_out_spaces (uiout, 2 * depth);
	      ui_out_field_string (uiout, NULL, "else");
	      ui_out_text (uiout, "else\n");
	      print_command_lines (uiout, list->body_list[1], depth + 1);
	    }

	  ui_out_field_string (uiout, NULL, "end");
	  if (depth)
	    ui_out_spaces (uiout, 2 * depth);
	  ui_out_text (uiout, "end\n");
	  list = list->next;
	  continue;
	}

      /* ignore illegal command type and try next */
      list = list->next;
    }				/* while (list) */
}
#else
void
print_command_line (struct command_line *cmd, unsigned int depth,
		    struct ui_file *stream)
{
  unsigned int i;
a810 4
  if (depth)
    {
      for (i = 0; i < depth; i++)
	fputs_filtered ("  ", stream);
d813 2
a814 2
  /* A simple command, print it and return.  */
  if (cmd->control_type == simple_control)
d816 1
a816 29
      fputs_filtered (cmd->line, stream);
      fputs_filtered ("\n", stream);
      return;
    }

  /* loop_continue to jump to the start of a while loop, print it
     and return. */
  if (cmd->control_type == continue_control)
    {
      fputs_filtered ("loop_continue\n", stream);
      return;
    }

  /* loop_break to break out of a while loop, print it and return.  */
  if (cmd->control_type == break_control)
    {
      fputs_filtered ("loop_break\n", stream);
      return;
    }

  /* A while command.  Recursively print its subcommands before returning.  */
  if (cmd->control_type == while_control)
    {
      struct command_line *list;
      fputs_filtered ("while ", stream);
      fputs_filtered (cmd->line, stream);
      fputs_filtered ("\n", stream);
      list = *cmd->body_list;
      while (list)
d818 1
a818 2
	  print_command_line (list, depth + 1, stream);
	  list = list->next;
d820 1
d823 7
a829 2
  /* An if command.  Recursively print both arms before returning.  */
  if (cmd->control_type == if_control)
d831 4
a834 8
      fputs_filtered ("if ", stream);
      fputs_filtered (cmd->line, stream);
      fputs_filtered ("\n", stream);
      /* The true arm. */
      print_command_line (cmd->body_list[0], depth + 1, stream);

      /* Show the false arm if it exists.  */
      if (cmd->body_count == 2)
d836 2
a837 12
	  if (depth)
	    {
	      for (i = 0; i < depth; i++)
		fputs_filtered ("  ", stream);
	    }
	  fputs_filtered ("else\n", stream);
	  print_command_line (cmd->body_list[1], depth + 1, stream);
	}
      if (depth)
	{
	  for (i = 0; i < depth; i++)
	    fputs_filtered ("  ", stream);
a838 1
      fputs_filtered ("end\n", stream);
a840 1
#endif
d842 2
a843 1
/* Execute the command in CMD.  */
d845 2
a846 2
enum command_control_type
execute_control_command (struct command_line *cmd)
d848 9
a856 8
  struct expression *expr;
  struct command_line *current;
  struct cleanup *old_chain = 0;
  value_ptr val;
  value_ptr val_mark;
  int loop;
  enum command_control_type ret;
  char *new_line;
d858 1
a858 1
  switch (cmd->control_type)
d860 5
a864 9
    case simple_control:
      /* A simple command, execute it and return.  */
      new_line = insert_args (cmd->line);
      if (!new_line)
	return invalid_control;
      old_chain = make_cleanup (free_current_contents, &new_line);
      execute_command (new_line, 0);
      ret = cmd->control_type;
      break;
d866 4
a869 6
    case continue_control:
    case break_control:
      /* Return for "continue", and "break" so we can either
         continue the loop at the top, or break out.  */
      ret = cmd->control_type;
      break;
d871 18
a888 43
    case while_control:
      {
	/* Parse the loop control expression for the while statement.  */
	new_line = insert_args (cmd->line);
	if (!new_line)
	  return invalid_control;
	old_chain = make_cleanup (free_current_contents, &new_line);
	expr = parse_expression (new_line);
	make_cleanup (free_current_contents, &expr);

	ret = simple_control;
	loop = 1;

	/* Keep iterating so long as the expression is true.  */
	while (loop == 1)
	  {
	    int cond_result;

	    QUIT;

	    /* Evaluate the expression.  */
	    val_mark = value_mark ();
	    val = evaluate_expression (expr);
	    cond_result = value_true (val);
	    value_free_to_mark (val_mark);

	    /* If the value is false, then break out of the loop.  */
	    if (!cond_result)
	      break;

	    /* Execute the body of the while statement.  */
	    current = *cmd->body_list;
	    while (current)
	      {
		ret = execute_control_command (current);

		/* If we got an error, or a "break" command, then stop
		   looping.  */
		if (ret == invalid_control || ret == break_control)
		  {
		    loop = 0;
		    break;
		  }
d890 1
a890 4
		/* If we got a "continue" command, then restart the loop
		   at this point.  */
		if (ret == continue_control)
		  break;
d892 1
a892 874
		/* Get the next statement.  */
		current = current->next;
	      }
	  }

	/* Reset RET so that we don't recurse the break all the way down.  */
	if (ret == break_control)
	  ret = simple_control;

	break;
      }

    case if_control:
      {
	new_line = insert_args (cmd->line);
	if (!new_line)
	  return invalid_control;
	old_chain = make_cleanup (free_current_contents, &new_line);
	/* Parse the conditional for the if statement.  */
	expr = parse_expression (new_line);
	make_cleanup (free_current_contents, &expr);

	current = NULL;
	ret = simple_control;

	/* Evaluate the conditional.  */
	val_mark = value_mark ();
	val = evaluate_expression (expr);

	/* Choose which arm to take commands from based on the value of the
	   conditional expression.  */
	if (value_true (val))
	  current = *cmd->body_list;
	else if (cmd->body_count == 2)
	  current = *(cmd->body_list + 1);
	value_free_to_mark (val_mark);

	/* Execute commands in the given arm.  */
	while (current)
	  {
	    ret = execute_control_command (current);

	    /* If we got an error, get out.  */
	    if (ret != simple_control)
	      break;

	    /* Get the next statement in the body.  */
	    current = current->next;
	  }

	break;
      }

    default:
      warning ("Invalid control type in command structure.");
      return invalid_control;
    }

  if (old_chain)
    do_cleanups (old_chain);

  return ret;
}

/* "while" command support.  Executes a body of statements while the
   loop condition is nonzero.  */

static void
while_command (char *arg, int from_tty)
{
  struct command_line *command = NULL;

  control_level = 1;
  command = get_command_line (while_control, arg);

  if (command == NULL)
    return;

  execute_control_command (command);
  free_command_lines (&command);
}

/* "if" command support.  Execute either the true or false arm depending
   on the value of the if conditional.  */

static void
if_command (char *arg, int from_tty)
{
  struct command_line *command = NULL;

  control_level = 1;
  command = get_command_line (if_control, arg);

  if (command == NULL)
    return;

  execute_control_command (command);
  free_command_lines (&command);
}

/* Cleanup */
static void
arg_cleanup (void *ignore)
{
  struct user_args *oargs = user_args;
  if (!user_args)
    internal_error ("Internal error, arg_cleanup called with no user args.\n");

  user_args = user_args->next;
  free (oargs);
}

/* Bind the incomming arguments for a user defined command to
   $arg0, $arg1 ... $argMAXUSERARGS.  */

static struct cleanup *
setup_user_args (char *p)
{
  struct user_args *args;
  struct cleanup *old_chain;
  unsigned int arg_count = 0;

  args = (struct user_args *) xmalloc (sizeof (struct user_args));
  memset (args, 0, sizeof (struct user_args));

  args->next = user_args;
  user_args = args;

  old_chain = make_cleanup (arg_cleanup, 0/*ignored*/);

  if (p == NULL)
    return old_chain;

  while (*p)
    {
      char *start_arg;
      int squote = 0;
      int dquote = 0;
      int bsquote = 0;

      if (arg_count >= MAXUSERARGS)
	{
	  error ("user defined function may only have %d arguments.\n",
		 MAXUSERARGS);
	  return old_chain;
	}

      /* Strip whitespace.  */
      while (*p == ' ' || *p == '\t')
	p++;

      /* P now points to an argument.  */
      start_arg = p;
      user_args->a[arg_count].arg = p;

      /* Get to the end of this argument.  */
      while (*p)
	{
	  if (((*p == ' ' || *p == '\t')) && !squote && !dquote && !bsquote)
	    break;
	  else
	    {
	      if (bsquote)
		bsquote = 0;
	      else if (*p == '\\')
		bsquote = 1;
	      else if (squote)
		{
		  if (*p == '\'')
		    squote = 0;
		}
	      else if (dquote)
		{
		  if (*p == '"')
		    dquote = 0;
		}
	      else
		{
		  if (*p == '\'')
		    squote = 1;
		  else if (*p == '"')
		    dquote = 1;
		}
	      p++;
	    }
	}

      user_args->a[arg_count].len = p - start_arg;
      arg_count++;
      user_args->count++;
    }
  return old_chain;
}

/* Given character string P, return a point to the first argument ($arg),
   or NULL if P contains no arguments.  */

static char *
locate_arg (char *p)
{
  while ((p = strchr (p, '$')))
    {
      if (strncmp (p, "$arg", 4) == 0 && isdigit (p[4]))
	return p;
      p++;
    }
  return NULL;
}

/* Insert the user defined arguments stored in user_arg into the $arg
   arguments found in line, with the updated copy being placed into nline.  */

static char *
insert_args (char *line)
{
  char *p, *save_line, *new_line;
  unsigned len, i;

  /* First we need to know how much memory to allocate for the new line.  */
  save_line = line;
  len = 0;
  while ((p = locate_arg (line)))
    {
      len += p - line;
      i = p[4] - '0';

      if (i >= user_args->count)
	{
	  error ("Missing argument %d in user function.\n", i);
	  return NULL;
	}
      len += user_args->a[i].len;
      line = p + 5;
    }

  /* Don't forget the tail.  */
  len += strlen (line);

  /* Allocate space for the new line and fill it in.  */
  new_line = (char *) xmalloc (len + 1);
  if (new_line == NULL)
    return NULL;

  /* Restore pointer to beginning of old line.  */
  line = save_line;

  /* Save pointer to beginning of new line.  */
  save_line = new_line;

  while ((p = locate_arg (line)))
    {
      int i, len;

      memcpy (new_line, line, p - line);
      new_line += p - line;
      i = p[4] - '0';

      len = user_args->a[i].len;
      if (len)
	{
	  memcpy (new_line, user_args->a[i].arg, len);
	  new_line += len;
	}
      line = p + 5;
    }
  /* Don't forget the tail.  */
  strcpy (new_line, line);

  /* Return a pointer to the beginning of the new line.  */
  return save_line;
}

void
execute_user_command (struct cmd_list_element *c, char *args)
{
  register struct command_line *cmdlines;
  struct cleanup *old_chain;
  enum command_control_type ret;

  old_chain = setup_user_args (args);

  cmdlines = c->user_commands;
  if (cmdlines == 0)
    /* Null command */
    return;

  /* Set the instream to 0, indicating execution of a
     user-defined function.  */
  old_chain = make_cleanup (do_restore_instream_cleanup, instream);
  instream = (FILE *) 0;
  while (cmdlines)
    {
      ret = execute_control_command (cmdlines);
      if (ret != simple_control && ret != break_control)
	{
	  warning ("Error in control structure.\n");
	  break;
	}
      cmdlines = cmdlines->next;
    }
  do_cleanups (old_chain);
}

/* Execute the line P as a command.
   Pass FROM_TTY as second argument to the defining function.  */

void
execute_command (char *p, int from_tty)
{
  register struct cmd_list_element *c;
  register enum language flang;
  static int warned = 0;
  char *line;
  /* FIXME: These should really be in an appropriate header file */
extern void serial_log_command (const char *);

  free_all_values ();

  /* Force cleanup of any alloca areas if using C alloca instead of
     a builtin alloca.  */
  alloca (0);

  /* This can happen when command_line_input hits end of file.  */
  if (p == NULL)
    return;

  serial_log_command (p);

  while (*p == ' ' || *p == '\t')
    p++;
  if (*p)
    {
      char *arg;
      line = p;

      c = lookup_cmd (&p, cmdlist, "", 0, 1);

      /* If the target is running, we allow only a limited set of
         commands. */
      if (event_loop_p && target_can_async_p () && target_executing)
	if (!strcmp (c->name, "help")
	    && !strcmp (c->name, "pwd")
	    && !strcmp (c->name, "show")
	    && !strcmp (c->name, "stop"))
	  error ("Cannot execute this command while the target is running.");

      /* Pass null arg rather than an empty one.  */
      arg = *p ? p : 0;

      /* Clear off trailing whitespace, except for set and complete command.  */
      if (arg && c->type != set_cmd && c->function.cfunc != complete_command)
	{
	  p = arg + strlen (arg) - 1;
	  while (p >= arg && (*p == ' ' || *p == '\t'))
	    p--;
	  *(p + 1) = '\0';
	}

      /* If this command has been pre-hooked, run the hook first. */
      if ((c->hook_pre) && (!c->hook_in))
      {
        c->hook_in = 1; /* Prevent recursive hooking */
        execute_user_command (c->hook_pre, (char *) 0);
        c->hook_in = 0; /* Allow hook to work again once it is complete */
      }

      if (c->flags & DEPRECATED_WARN_USER)
	deprecated_cmd_warning (&line);

      if (c->class == class_user)
	execute_user_command (c, arg);
      else if (c->type == set_cmd || c->type == show_cmd)
	do_setshow_command (arg, from_tty & caution, c);
      else if (c->function.cfunc == NO_FUNCTION)
	error ("That is not a command, just a help topic.");
      else if (call_command_hook)
	call_command_hook (c, arg, from_tty & caution);
      else
	(*c->function.cfunc) (arg, from_tty & caution);
       
      /* If this command has been post-hooked, run the hook last. */
      if ((c->hook_post) && (!c->hook_in))
      {
        c->hook_in = 1; /* Prevent recursive hooking */
        execute_user_command (c->hook_post, (char *) 0);
        c->hook_in = 0; /* allow hook to work again once it is complete */
      }

    }

  /* Tell the user if the language has changed (except first time).  */
  if (current_language != expected_language)
    {
      if (language_mode == language_mode_auto)
	{
	  language_info (1);	/* Print what changed.  */
	}
      warned = 0;
    }

  /* Warn the user if the working language does not match the
     language of the current frame.  Only warn the user if we are
     actually running the program, i.e. there is a stack. */
  /* FIXME:  This should be cacheing the frame and only running when
     the frame changes.  */

  if (target_has_stack)
    {
      flang = get_frame_language ();
      if (!warned
	  && flang != language_unknown
	  && flang != current_language->la_language)
	{
	  printf_filtered ("%s\n", lang_frame_mismatch_warn);
	  warned = 1;
	}
    }
}

/* Read commands from `instream' and execute them
   until end of file or error reading instream.  */

void
command_loop (void)
{
  struct cleanup *old_chain;
  char *command;
  int stdin_is_tty = ISATTY (stdin);
  long time_at_cmd_start;
#ifdef HAVE_SBRK
  long space_at_cmd_start = 0;
#endif
  extern int display_time;
  extern int display_space;

  while (instream && !feof (instream))
    {
#if defined(TUI)
      extern int insert_mode;
#endif
      if (window_hook && instream == stdin)
	(*window_hook) (instream, get_prompt ());

      quit_flag = 0;
      if (instream == stdin && stdin_is_tty)
	reinitialize_more_filter ();
      old_chain = make_cleanup (null_cleanup, 0);

#if defined(TUI)
      /* A bit of paranoia: I want to make sure the "insert_mode" global
       * is clear except when it is being used for command-line editing
       * (see tuiIO.c, utils.c); otherwise normal output will
       * get messed up in the TUI. So clear it before/after
       * the command-line-input call. - RT
       */
      insert_mode = 0;
#endif
      /* Get a command-line. This calls the readline package. */
      command = command_line_input (instream == stdin ?
				    get_prompt () : (char *) NULL,
				    instream == stdin, "prompt");
#if defined(TUI)
      insert_mode = 0;
#endif
      if (command == 0)
	return;

      time_at_cmd_start = get_run_time ();

      if (display_space)
	{
#ifdef HAVE_SBRK
	  extern char **environ;
	  char *lim = (char *) sbrk (0);

	  space_at_cmd_start = (long) (lim - (char *) &environ);
#endif
	}

      execute_command (command, instream == stdin);
      /* Do any commands attached to breakpoint we stopped at.  */
      bpstat_do_actions (&stop_bpstat);
      do_cleanups (old_chain);

      if (display_time)
	{
	  long cmd_time = get_run_time () - time_at_cmd_start;

	  printf_unfiltered ("Command execution time: %ld.%06ld\n",
			     cmd_time / 1000000, cmd_time % 1000000);
	}

      if (display_space)
	{
#ifdef HAVE_SBRK
	  extern char **environ;
	  char *lim = (char *) sbrk (0);
	  long space_now = lim - (char *) &environ;
	  long space_diff = space_now - space_at_cmd_start;

	  printf_unfiltered ("Space used: %ld (%c%ld for this command)\n",
			     space_now,
			     (space_diff >= 0 ? '+' : '-'),
			     space_diff);
#endif
	}
    }
}

/* Read commands from `instream' and execute them until end of file or
   error reading instream. This command loop doesnt care about any
   such things as displaying time and space usage. If the user asks
   for those, they won't work. */
void
simplified_command_loop (char *(*read_input_func) (char *),
			 void (*execute_command_func) (char *, int))
{
  struct cleanup *old_chain;
  char *command;
  int stdin_is_tty = ISATTY (stdin);

  while (instream && !feof (instream))
    {
      quit_flag = 0;
      if (instream == stdin && stdin_is_tty)
	reinitialize_more_filter ();
      old_chain = make_cleanup (null_cleanup, 0);

      /* Get a command-line. */
      command = (*read_input_func) (instream == stdin ?
				    get_prompt () : (char *) NULL);

      if (command == 0)
	return;

      (*execute_command_func) (command, instream == stdin);

      /* Do any commands attached to breakpoint we stopped at.  */
      bpstat_do_actions (&stop_bpstat);

      do_cleanups (old_chain);
    }
}

/* Commands call this if they do not want to be repeated by null lines.  */

void
dont_repeat (void)
{
  if (server_command)
    return;

  /* If we aren't reading from standard input, we are saving the last
     thing read from stdin in line and don't want to delete it.  Null lines
     won't repeat here in any case.  */
  if (instream == stdin)
    *line = 0;
}

/* Read a line from the stream "instream" without command line editing.

   It prints PROMPT_ARG once at the start.
   Action is compatible with "readline", e.g. space for the result is
   malloc'd and should be freed by the caller.

   A NULL return means end of file.  */
char *
gdb_readline (char *prompt_arg)
{
  int c;
  char *result;
  int input_index = 0;
  int result_size = 80;

  if (prompt_arg)
    {
      /* Don't use a _filtered function here.  It causes the assumed
         character position to be off, since the newline we read from
         the user is not accounted for.  */
      fputs_unfiltered (prompt_arg, gdb_stdout);
#ifdef MPW
      /* Move to a new line so the entered line doesn't have a prompt
         on the front of it. */
      fputs_unfiltered ("\n", gdb_stdout);
#endif /* MPW */
      gdb_flush (gdb_stdout);
    }

  result = (char *) xmalloc (result_size);

  while (1)
    {
      /* Read from stdin if we are executing a user defined command.
         This is the right thing for prompt_for_continue, at least.  */
      c = fgetc (instream ? instream : stdin);

      if (c == EOF)
	{
	  if (input_index > 0)
	    /* The last line does not end with a newline.  Return it, and
	       if we are called again fgetc will still return EOF and
	       we'll return NULL then.  */
	    break;
	  free (result);
	  return NULL;
	}

      if (c == '\n')
#ifndef CRLF_SOURCE_FILES
	break;
#else
	{
	  if (input_index > 0 && result[input_index - 1] == '\r')
	    input_index--;
	  break;
	}
#endif

      result[input_index++] = c;
      while (input_index >= result_size)
	{
	  result_size *= 2;
	  result = (char *) xrealloc (result, result_size);
	}
    }

  result[input_index++] = '\0';
  return result;
}

/* Variables which control command line editing and history
   substitution.  These variables are given default values at the end
   of this file.  */
static int command_editing_p;
/* NOTE 1999-04-29: This variable will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c */
/* static */ int history_expansion_p;
static int write_history_p;
static int history_size;
static char *history_filename;

/* readline uses the word breaks for two things:
   (1) In figuring out where to point the TEXT parameter to the
   rl_completion_entry_function.  Since we don't use TEXT for much,
   it doesn't matter a lot what the word breaks are for this purpose, but
   it does affect how much stuff M-? lists.
   (2) If one of the matches contains a word break character, readline
   will quote it.  That's why we switch between
   gdb_completer_word_break_characters and
   gdb_completer_command_word_break_characters.  I'm not sure when
   we need this behavior (perhaps for funky characters in C++ symbols?).  */

/* Variables which are necessary for fancy command line editing.  */
char *gdb_completer_word_break_characters =
" \t\n!@@#$%^&*()+=|~`}{[]\"';:?/>.<,-";

/* When completing on command names, we remove '-' from the list of
   word break characters, since we use it in command names.  If the
   readline library sees one in any of the current completion strings,
   it thinks that the string needs to be quoted and automatically supplies
   a leading quote. */
char *gdb_completer_command_word_break_characters =
" \t\n!@@#$%^&*()+=|~`}{[]\"';:?/>.<,";

/* When completing on file names, we remove from the list of word
   break characters any characters that are commonly used in file
   names, such as '-', '+', '~', etc.  Otherwise, readline displays
   incorrect completion candidates.  */
char *gdb_completer_file_name_break_characters = " \t\n*|\"';:?/><";

/* Characters that can be used to quote completion strings.  Note that we
   can't include '"' because the gdb C parser treats such quoted sequences
   as strings. */
char *gdb_completer_quote_characters =
"'";

/* Functions that are used as part of the fancy command line editing.  */

/* This can be used for functions which don't want to complete on symbols
   but don't want to complete on anything else either.  */
/* ARGSUSED */
char **
noop_completer (char *text, char *prefix)
{
  return NULL;
}

/* Line completion interface function for readline.  */

static char *
readline_line_completion_function (char *text, int matches)
{
  return line_completion_function (text, matches, rl_line_buffer, rl_point);
}


#ifdef STOP_SIGNAL
static void
stop_sig (int signo)
{
#if STOP_SIGNAL == SIGTSTP
  signal (SIGTSTP, SIG_DFL);
  sigsetmask (0);
  kill (getpid (), SIGTSTP);
  signal (SIGTSTP, stop_sig);
#else
  signal (STOP_SIGNAL, stop_sig);
#endif
  printf_unfiltered ("%s", get_prompt ());
  gdb_flush (gdb_stdout);

  /* Forget about any previous command -- null line now will do nothing.  */
  dont_repeat ();
}
#endif /* STOP_SIGNAL */

/* Initialize signal handlers. */
static void
do_nothing (int signo)
{
  /* Under System V the default disposition of a signal is reinstated after
     the signal is caught and delivered to an application process.  On such
     systems one must restore the replacement signal handler if one wishes
     to continue handling the signal in one's program.  On BSD systems this
     is not needed but it is harmless, and it simplifies the code to just do
     it unconditionally. */
  signal (signo, do_nothing);
}

static void
init_signals (void)
{
  signal (SIGINT, request_quit);

  /* If SIGTRAP was set to SIG_IGN, then the SIG_IGN will get passed
     to the inferior and breakpoints will be ignored.  */
#ifdef SIGTRAP
  signal (SIGTRAP, SIG_DFL);
#endif

  /* If we initialize SIGQUIT to SIG_IGN, then the SIG_IGN will get
     passed to the inferior, which we don't want.  It would be
     possible to do a "signal (SIGQUIT, SIG_DFL)" after we fork, but
     on BSD4.3 systems using vfork, that can affect the
     GDB process as well as the inferior (the signal handling tables
     might be in memory, shared between the two).  Since we establish
     a handler for SIGQUIT, when we call exec it will set the signal
     to SIG_DFL for us.  */
  signal (SIGQUIT, do_nothing);
#ifdef SIGHUP
  if (signal (SIGHUP, do_nothing) != SIG_IGN)
    signal (SIGHUP, disconnect);
#endif
  signal (SIGFPE, float_handler);

#if defined(SIGWINCH) && defined(SIGWINCH_HANDLER)
  signal (SIGWINCH, SIGWINCH_HANDLER);
#endif
}

/* Read one line from the command input stream `instream'
   into the local static buffer `linebuffer' (whose current length
   is `linelength').
   The buffer is made bigger as necessary.
   Returns the address of the start of the line.

   NULL is returned for end of file.

   *If* the instream == stdin & stdin is a terminal, the line read
   is copied into the file line saver (global var char *line,
   length linesize) so that it can be duplicated.

   This routine either uses fancy command line editing or
   simple input as the user has requested.  */

char *
command_line_input (char *prompt_arg, int repeat, char *annotation_suffix)
{
  static char *linebuffer = 0;
  static unsigned linelength = 0;
  register char *p;
  char *p1;
  char *rl;
  char *local_prompt = prompt_arg;
  char *nline;
  char got_eof = 0;

  /* The annotation suffix must be non-NULL.  */
  if (annotation_suffix == NULL)
    annotation_suffix = "";

  if (annotation_level > 1 && instream == stdin)
    {
      local_prompt = alloca ((prompt_arg == NULL ? 0 : strlen (prompt_arg))
			     + strlen (annotation_suffix) + 40);
      if (prompt_arg == NULL)
	local_prompt[0] = '\0';
      else
	strcpy (local_prompt, prompt_arg);
      strcat (local_prompt, "\n\032\032");
      strcat (local_prompt, annotation_suffix);
      strcat (local_prompt, "\n");
    }

  if (linebuffer == 0)
    {
      linelength = 80;
      linebuffer = (char *) xmalloc (linelength);
    }

  p = linebuffer;

  /* Control-C quits instantly if typed while in this loop
     since it should not wait until the user types a newline.  */
  immediate_quit++;
#ifdef STOP_SIGNAL
  if (job_control)
    {
      if (event_loop_p)
	signal (STOP_SIGNAL, handle_stop_sig);
      else
	signal (STOP_SIGNAL, stop_sig);
    }
#endif

  while (1)
    {
      /* Make sure that all output has been output.  Some machines may let
         you get away with leaving out some of the gdb_flush, but not all.  */
      wrap_here ("");
      gdb_flush (gdb_stdout);
      gdb_flush (gdb_stderr);

      if (source_file_name != NULL)
	{
	  ++source_line_number;
	  sprintf (source_error,
		   "%s%s:%d: Error in sourced command file:\n",
		   source_pre_error,
		   source_file_name,
		   source_line_number);
	  error_pre_print = source_error;
	}

      if (annotation_level > 1 && instream == stdin)
	{
	  printf_unfiltered ("\n\032\032pre-");
	  printf_unfiltered (annotation_suffix);
	  printf_unfiltered ("\n");
	}

      /* Don't use fancy stuff if not talking to stdin.  */
      if (readline_hook && instream == NULL)
	{
	  rl = (*readline_hook) (local_prompt);
	}
      else if (command_editing_p && instream == stdin && ISATTY (instream))
	{
	  rl = readline (local_prompt);
	}
      else
	{
	  rl = gdb_readline (local_prompt);
	}

      if (annotation_level > 1 && instream == stdin)
	{
	  printf_unfiltered ("\n\032\032post-");
	  printf_unfiltered (annotation_suffix);
	  printf_unfiltered ("\n");
	}

      if (!rl || rl == (char *) EOF)
d894 3
a896 15
	  got_eof = 1;
	  break;
	}
      if (strlen (rl) + 1 + (p - linebuffer) > linelength)
	{
	  linelength = strlen (rl) + 1 + (p - linebuffer);
	  nline = (char *) xrealloc (linebuffer, linelength);
	  p += nline - linebuffer;
	  linebuffer = nline;
	}
      p1 = rl;
      /* Copy line.  Don't copy null at end.  (Leaves line alone
         if this was just a newline)  */
      while (*p1)
	*p++ = *p1++;
d898 1
a898 12
      free (rl);		/* Allocated in readline.  */

      if (p == linebuffer || *(p - 1) != '\\')
	break;

      p--;			/* Put on top of '\'.  */
      local_prompt = (char *) 0;
    }

#ifdef STOP_SIGNAL
  if (job_control)
    signal (STOP_SIGNAL, SIG_DFL);
d900 1
a900 1
  immediate_quit--;
d902 4
a905 2
  if (got_eof)
    return NULL;
d907 1
a907 23
#define SERVER_COMMAND_LENGTH 7
  server_command =
    (p - linebuffer > SERVER_COMMAND_LENGTH)
    && STREQN (linebuffer, "server ", SERVER_COMMAND_LENGTH);
  if (server_command)
    {
      /* Note that we don't set `line'.  Between this and the check in
         dont_repeat, this insures that repeating will still do the
         right thing.  */
      *p = '\0';
      return linebuffer + SERVER_COMMAND_LENGTH;
    }

  /* Do history expansion if that is wished.  */
  if (history_expansion_p && instream == stdin
      && ISATTY (instream))
    {
      char *history_value;
      int expanded;

      *p = '\0';		/* Insert null now.  */
      expanded = history_expand (linebuffer, &history_value);
      if (expanded)
d909 1
a909 2
	  /* Print the changes.  */
	  printf_unfiltered ("%s\n", history_value);
d911 2
a912 14
	  /* If there was an error, call this function again.  */
	  if (expanded < 0)
	    {
	      free (history_value);
	      return command_line_input (prompt_arg, repeat, annotation_suffix);
	    }
	  if (strlen (history_value) > linelength)
	    {
	      linelength = strlen (history_value) + 1;
	      linebuffer = (char *) xrealloc (linebuffer, linelength);
	    }
	  strcpy (linebuffer, history_value);
	  p = linebuffer + strlen (linebuffer);
	  free (history_value);
a913 1
    }
d915 7
a921 8
  /* If we just got an empty line, and that is supposed
     to repeat the previous command, return the value in the
     global buffer.  */
  if (repeat && p == linebuffer)
    return line;
  for (p1 = linebuffer; *p1 == ' ' || *p1 == '\t'; p1++);
  if (repeat && !*p1)
    return line;
d923 5
a927 23
  *p = 0;

  /* Add line to history if appropriate.  */
  if (instream == stdin
      && ISATTY (stdin) && *linebuffer)
    add_history (linebuffer);

  /* Note: lines consisting solely of comments are added to the command
     history.  This is useful when you type a command, and then
     realize you don't want to execute it quite yet.  You can comment
     out the command and then later fetch it from the value history
     and remove the '#'.  The kill ring is probably better, but some
     people are in the habit of commenting things out.  */
  if (*p1 == '#')
    *p1 = '\0';			/* Found a comment. */

  /* Save into global buffer if appropriate.  */
  if (repeat)
    {
      if (linelength > linesize)
	{
	  line = xrealloc (line, linelength);
	  linesize = linelength;
a928 2
      strcpy (line, linebuffer);
      return line;
a929 2

  return linebuffer;
a930 1

d932 7
a938 6
/* Expand the body_list of COMMAND so that it can hold NEW_LENGTH
   code bodies.  This is typically used when we encounter an "else"
   clause for an "if" command.  */

static void
realloc_body_list (struct command_line *command, int new_length)
d940 3
a942 2
  int n;
  struct command_line **body_list;
d944 6
a949 1
  n = command->body_count;
d951 3
a953 3
  /* Nothing to do?  */
  if (new_length <= n)
    return;
d955 2
a956 2
  body_list = (struct command_line **)
    xmalloc (sizeof (struct command_line *) * new_length);
d958 1
a958 1
  memcpy (body_list, command->body_list, sizeof (struct command_line *) * n);
d960 2
a961 4
  free (command->body_list);
  command->body_list = body_list;
  command->body_count = new_length;
}
d963 1
a963 88
/* Read one line from the input stream.  If the command is an "else" or
   "end", return such an indication to the caller.  */

static enum misc_command_type
read_next_line (struct command_line **command)
{
  char *p, *p1, *prompt_ptr, control_prompt[256];
  int i = 0;

  if (control_level >= 254)
    error ("Control nesting too deep!\n");

  /* Set a prompt based on the nesting of the control commands.  */
  if (instream == stdin || (instream == 0 && readline_hook != NULL))
    {
      for (i = 0; i < control_level; i++)
	control_prompt[i] = ' ';
      control_prompt[i] = '>';
      control_prompt[i + 1] = '\0';
      prompt_ptr = (char *) &control_prompt[0];
    }
  else
    prompt_ptr = NULL;

  p = command_line_input (prompt_ptr, instream == stdin, "commands");

  /* Not sure what to do here.  */
  if (p == NULL)
    return end_command;

  /* Strip leading and trailing whitespace.  */
  while (*p == ' ' || *p == '\t')
    p++;

  p1 = p + strlen (p);
  while (p1 != p && (p1[-1] == ' ' || p1[-1] == '\t'))
    p1--;

  /* Blanks and comments don't really do anything, but we need to
     distinguish them from else, end and other commands which can be
     executed.  */
  if (p1 == p || p[0] == '#')
    return nop_command;

  /* Is this the end of a simple, while, or if control structure?  */
  if (p1 - p == 3 && !strncmp (p, "end", 3))
    return end_command;

  /* Is the else clause of an if control structure?  */
  if (p1 - p == 4 && !strncmp (p, "else", 4))
    return else_command;

  /* Check for while, if, break, continue, etc and build a new command
     line structure for them.  */
  if (p1 - p > 5 && !strncmp (p, "while", 5))
    *command = build_command_line (while_control, p + 6);
  else if (p1 - p > 2 && !strncmp (p, "if", 2))
    *command = build_command_line (if_control, p + 3);
  else if (p1 - p == 10 && !strncmp (p, "loop_break", 10))
    {
      *command = (struct command_line *)
	xmalloc (sizeof (struct command_line));
      (*command)->next = NULL;
      (*command)->line = NULL;
      (*command)->control_type = break_control;
      (*command)->body_count = 0;
      (*command)->body_list = NULL;
    }
  else if (p1 - p == 13 && !strncmp (p, "loop_continue", 13))
    {
      *command = (struct command_line *)
	xmalloc (sizeof (struct command_line));
      (*command)->next = NULL;
      (*command)->line = NULL;
      (*command)->control_type = continue_control;
      (*command)->body_count = 0;
      (*command)->body_list = NULL;
    }
  else
    {
      /* A normal command.  */
      *command = (struct command_line *)
	xmalloc (sizeof (struct command_line));
      (*command)->next = NULL;
      (*command)->line = savestring (p, p1 - p);
      (*command)->control_type = simple_control;
      (*command)->body_count = 0;
      (*command)->body_list = NULL;
a964 3

  /* Nothing special.  */
  return ok_command;
d966 2
d969 2
a970 8
/* Recursively read in the control structures and create a command_line 
   structure from them.

   The parent_control parameter is the control structure in which the
   following commands are nested.  */

static enum command_control_type
recurse_read_control_structure (struct command_line *current_cmd)
d972 2
a973 4
  int current_body, i;
  enum misc_command_type val;
  enum command_control_type ret;
  struct command_line **body_ptr, *child_tail, *next;
d975 5
a979 95
  child_tail = NULL;
  current_body = 1;

  /* Sanity checks.  */
  if (current_cmd->control_type == simple_control)
    {
      error ("Recursed on a simple control type\n");
      return invalid_control;
    }

  if (current_body > current_cmd->body_count)
    {
      error ("Allocated body is smaller than this command type needs\n");
      return invalid_control;
    }

  /* Read lines from the input stream and build control structures.  */
  while (1)
    {
      dont_repeat ();

      next = NULL;
      val = read_next_line (&next);

      /* Just skip blanks and comments.  */
      if (val == nop_command)
	continue;

      if (val == end_command)
	{
	  if (current_cmd->control_type == while_control
	      || current_cmd->control_type == if_control)
	    {
	      /* Success reading an entire control structure.  */
	      ret = simple_control;
	      break;
	    }
	  else
	    {
	      ret = invalid_control;
	      break;
	    }
	}

      /* Not the end of a control structure.  */
      if (val == else_command)
	{
	  if (current_cmd->control_type == if_control
	      && current_body == 1)
	    {
	      realloc_body_list (current_cmd, 2);
	      current_body = 2;
	      child_tail = NULL;
	      continue;
	    }
	  else
	    {
	      ret = invalid_control;
	      break;
	    }
	}

      if (child_tail)
	{
	  child_tail->next = next;
	}
      else
	{
	  body_ptr = current_cmd->body_list;
	  for (i = 1; i < current_body; i++)
	    body_ptr++;

	  *body_ptr = next;

	}

      child_tail = next;

      /* If the latest line is another control structure, then recurse
         on it.  */
      if (next->control_type == while_control
	  || next->control_type == if_control)
	{
	  control_level++;
	  ret = recurse_read_control_structure (next);
	  control_level--;

	  if (ret != simple_control)
	    break;
	}
    }

  dont_repeat ();

  return ret;
d981 2
d984 3
a986 4
/* Read lines from the input stream and accumulate them in a chain of
   struct command_line's, which is then returned.  For input from a
   terminal, the special command "end" is used to mark the end of the
   input, and is not included in the returned chain of commands. */
d988 3
a990 4
#define END_MESSAGE "End with a line saying just \"end\"."

struct command_line *
read_command_lines (char *prompt_arg, int from_tty)
d992 4
a995 4
  struct command_line *head, *tail, *next;
  struct cleanup *old_chain;
  enum command_control_type ret;
  enum misc_command_type val;
d997 1
a997 7
  control_level = 0;
  if (readline_begin_hook)
    {
      /* Note - intentional to merge messages with no newline */
      (*readline_begin_hook) ("%s  %s\n", prompt_arg, END_MESSAGE);
    }
  else if (from_tty && input_from_terminal_p ())
d999 9
a1007 1
      printf_unfiltered ("%s\n%s\n", prompt_arg, END_MESSAGE);
d1011 1
a1011 2
  head = tail = NULL;
  old_chain = NULL;
d1015 3
a1017 1
      val = read_next_line (&next);
d1019 1
a1019 5
      /* Ignore blank lines or comments.  */
      if (val == nop_command)
	continue;

      if (val == end_command)
d1021 7
a1027 2
	  ret = simple_control;
	  break;
d1030 4
a1033 1
      if (val != ok_command)
d1035 2
a1036 1
	  ret = invalid_control;
d1039 1
d1041 2
a1042 2
      if (next->control_type == while_control
	  || next->control_type == if_control)
d1044 2
a1045 6
	  control_level++;
	  ret = recurse_read_control_structure (next);
	  control_level--;

	  if (ret == invalid_control)
	    break;
d1047 1
d1049 3
a1051 11
      if (tail)
	{
	  tail->next = next;
	}
      else
	{
	  head = next;
	  old_chain = make_cleanup_free_command_lines (&head);
	}
      tail = next;
    }
d1053 11
a1063 1
  dont_repeat ();
d1065 1
a1065 9
  if (head)
    {
      if (ret != invalid_control)
	{
	  discard_cleanups (old_chain);
	}
      else
	do_cleanups (old_chain);
    }
d1067 7
a1073 5
  if (readline_end_hook)
    {
      (*readline_end_hook) ();
    }
  return (head);
d1076 1
a1076 1
/* Free a chain of struct command_line's.  */
d1078 9
a1086 2
void
free_command_lines (struct command_line **lptr)
d1088 10
a1097 4
  register struct command_line *l = *lptr;
  register struct command_line *next;
  struct command_line **blist;
  int i;
d1099 2
a1100 13
  while (l)
    {
      if (l->body_count > 0)
	{
	  blist = l->body_list;
	  for (i = 0; i < l->body_count; i++, blist++)
	    free_command_lines (blist);
	}
      next = l->next;
      free (l->line);
      free ((PTR) l);
      l = next;
    }
d1102 1
d1104 1
d1106 1
a1106 1
do_free_command_lines_cleanup (void *arg)
d1108 7
a1114 1
  free_command_lines (arg);
d1117 2
a1118 2
static struct cleanup *
make_cleanup_free_command_lines (struct command_line **arg)
d1120 1
a1120 4
  return make_cleanup (do_free_command_lines_cleanup, arg);
}

/* Add an element to the list of info subcommands.  */
d1122 5
a1126 5
struct cmd_list_element *
add_info (char *name, void (*fun) (char *, int), char *doc)
{
  return add_cmd (name, no_class, fun, doc, &infolist);
}
d1128 14
a1141 1
/* Add an alias to the list of info subcommands.  */
d1143 3
a1145 4
struct cmd_list_element *
add_info_alias (char *name, char *oldname, int abbrev_flag)
{
  return add_alias_cmd (name, oldname, 0, abbrev_flag, &infolist);
d1147 6
d1154 1
a1154 2
/* The "info" command is defined as a prefix, with allow_unknown = 0.
   Therefore, its own definition is called only for "info" with no args.  */
d1156 3
a1158 7
/* ARGSUSED */
static void
info_command (char *arg, int from_tty)
{
  printf_unfiltered ("\"info\" must be followed by the name of an info command.\n");
  help_list (infolist, "info ", -1, gdb_stdout);
}
d1160 2
a1161 1
/* The "complete" command is used by Emacs to implement completion.  */
d1163 2
a1164 3
/* ARGSUSED */
static void
complete_command (char *arg, int from_tty)
d1166 8
a1173 3
  int i;
  int argpoint;
  char *completion;
d1175 3
a1177 1
  dont_repeat ();
d1179 12
a1190 3
  if (arg == NULL)
    arg = "";
  argpoint = strlen (arg);
d1192 1
a1192 3
  for (completion = line_completion_function (arg, i = 0, arg, argpoint);
       completion;
       completion = line_completion_function (arg, ++i, arg, argpoint))
d1194 2
a1195 2
      printf_unfiltered ("%s\n", completion);
      free (completion);
a1196 1
}
d1198 14
a1211 1
/* The "show" command with no arguments shows all the settings.  */
d1213 7
a1219 8
/* ARGSUSED */
static void
show_command (char *arg, int from_tty)
{
  cmd_show_list (showlist, from_tty, "");
}

/* Add an element to the list of commands.  */
d1221 10
a1230 6
struct cmd_list_element *
add_com (char *name, enum command_class class, void (*fun) (char *, int),
	 char *doc)
{
  return add_cmd (name, class, fun, doc, &cmdlist);
}
d1232 6
a1237 1
/* Add an alias or abbreviation command to the list of commands.  */
d1239 13
a1251 6
struct cmd_list_element *
add_com_alias (char *name, char *oldname, enum command_class class,
	       int abbrev_flag)
{
  return add_alias_cmd (name, oldname, class, abbrev_flag, &cmdlist);
}
d1253 6
a1258 5
void
error_no_arg (char *why)
{
  error ("Argument required (%s).", why);
}
d1260 17
a1276 2
/* Provide documentation on command or list given by COMMAND.  FROM_TTY
   is ignored.  */
d1278 1
a1278 11
/* ARGSUSED */
static void
help_command (char *command, int from_tty)
{
  help_cmd (command, gdb_stdout);
}

static void
validate_comname (char *comname)
{
  register char *p;
d1280 2
a1281 2
  if (comname == 0)
    error_no_arg ("name of command to define");
d1283 2
a1284 6
  p = comname;
  while (*p)
    {
      if (!isalnum (*p) && *p != '-' && *p != '_')
	error ("Junk in argument list: \"%s\"", p);
      p++;
a1285 1
}
d1287 5
a1291 5
/* This is just a placeholder in the command data structures.  */
static void
user_defined_command (char *ignore, int from_tty)
{
}
d1293 2
a1294 29
static void
define_command (char *comname, int from_tty)
{
#define MAX_TMPBUF 128   
  enum cmd_hook_type
    {
      CMD_NO_HOOK = 0,
      CMD_PRE_HOOK,
      CMD_POST_HOOK
    };
  register struct command_line *cmds;
  register struct cmd_list_element *c, *newc, *oldc, *hookc = 0;
  char *tem = comname;
  char *tem2; 
  char tmpbuf[MAX_TMPBUF];
  int  hook_type      = CMD_NO_HOOK;
  int  hook_name_size = 0;
   
#define	HOOK_STRING	"hook-"
#define	HOOK_LEN 5
#define HOOK_POST_STRING "hookpost-"
#define HOOK_POST_LEN    9

  validate_comname (comname);

  /* Look it up, and verify that we got an exact match.  */
  c = lookup_cmd (&tem, cmdlist, "", -1, 1);
  if (c && !STREQ (comname, c->name))
    c = 0;
d1296 5
a1300 1
  if (c)
d1302 5
a1306 75
      if (c->class == class_user || c->class == class_alias)
	tem = "Redefine command \"%s\"? ";
      else
	tem = "Really redefine built-in command \"%s\"? ";
      if (!query (tem, c->name))
	error ("Command \"%s\" not redefined.", c->name);
    }

  /* If this new command is a hook, then mark the command which it
     is hooking.  Note that we allow hooking `help' commands, so that
     we can hook the `stop' pseudo-command.  */

  if (!strncmp (comname, HOOK_STRING, HOOK_LEN))
    {
       hook_type      = CMD_PRE_HOOK;
       hook_name_size = HOOK_LEN;
    }
  else if (!strncmp (comname, HOOK_POST_STRING, HOOK_POST_LEN))
    {
      hook_type      = CMD_POST_HOOK;
      hook_name_size = HOOK_POST_LEN;
    }
   
  if (hook_type != CMD_NO_HOOK)
    {
      /* Look up cmd it hooks, and verify that we got an exact match.  */
      tem = comname + hook_name_size;
      hookc = lookup_cmd (&tem, cmdlist, "", -1, 0);
      if (hookc && !STREQ (comname + hook_name_size, hookc->name))
	hookc = 0;
      if (!hookc)
	{
	  warning ("Your new `%s' command does not hook any existing command.",
		   comname);
	  if (!query ("Proceed? "))
	    error ("Not confirmed.");
	}
    }

  comname = savestring (comname, strlen (comname));

  /* If the rest of the commands will be case insensitive, this one
     should behave in the same manner. */
  for (tem = comname; *tem; tem++)
    if (isupper (*tem))
      *tem = tolower (*tem);

  sprintf (tmpbuf, "Type commands for definition of \"%s\".", comname);
  cmds = read_command_lines (tmpbuf, from_tty);

  if (c && c->class == class_user)
    free_command_lines (&c->user_commands);

  newc = add_cmd (comname, class_user, user_defined_command,
		  (c && c->class == class_user)
		  ? c->doc : savestring ("User-defined.", 13), &cmdlist);
  newc->user_commands = cmds;

  /* If this new command is a hook, then mark both commands as being
     tied.  */
  if (hookc)
    {
      switch (hook_type)
        {
        case CMD_PRE_HOOK:
          hookc->hook_pre  = newc;  /* Target gets hooked.  */
          newc->hookee_pre = hookc; /* We are marked as hooking target cmd. */
          break;
        case CMD_POST_HOOK:
          hookc->hook_pre  = newc;  /* Target gets hooked.  */
          newc->hookee_pre = hookc; /* We are marked as hooking target cmd. */
          break;
        default:
          /* Should never come here as hookc would be 0. */
        }
a1307 1
}
d1309 6
a1314 7
static void
document_command (char *comname, int from_tty)
{
  struct command_line *doclines;
  register struct cmd_list_element *c;
  char *tem = comname;
  char tmpbuf[128];
d1316 6
a1321 1
  validate_comname (comname);
d1323 16
a1338 1
  c = lookup_cmd (&tem, cmdlist, "", 0, 1);
d1340 8
a1347 2
  if (c->class != class_user)
    error ("Command \"%s\" is built-in.", comname);
d1349 1
a1349 2
  sprintf (tmpbuf, "Type documentation for \"%s\".", comname);
  doclines = read_command_lines (tmpbuf, from_tty);
d1351 4
a1354 2
  if (c->doc)
    free (c->doc);
d1356 8
a1363 3
  {
    register struct command_line *cl1;
    register int len = 0;
d1365 11
a1375 2
    for (cl1 = doclines; cl1; cl1 = cl1->next)
      len += strlen (cl1->line) + 1;
d1377 1
a1377 12
    c->doc = (char *) xmalloc (len + 1);
    *c->doc = 0;

    for (cl1 = doclines; cl1; cl1 = cl1->next)
      {
	strcat (c->doc, cl1->line);
	if (cl1->next)
	  strcat (c->doc, "\n");
      }
  }

  free_command_lines (&doclines);
a1422 10

/* ARGSUSED */
static void
show_version (char *args, int from_tty)
{
  immediate_quit++;
  print_gdb_version (gdb_stdout);
  printf_filtered ("\n");
  immediate_quit--;
}
a1776 10
/* Handle the quit command.  */

void
quit_command (char *args, int from_tty)
{
  if (!quit_confirm ())
    error ("Not confirmed.");
  quit_force (args, from_tty);
}

a1787 229
pwd_command (char *args, int from_tty)
{
  if (args)
    error ("The \"pwd\" command does not take an argument: %s", args);
  getcwd (gdb_dirbuf, sizeof (gdb_dirbuf));

  if (!STREQ (gdb_dirbuf, current_directory))
    printf_unfiltered ("Working directory %s\n (canonically %s).\n",
		       current_directory, gdb_dirbuf);
  else
    printf_unfiltered ("Working directory %s.\n", current_directory);
}

void
cd_command (char *dir, int from_tty)
{
  int len;
  /* Found something other than leading repetitions of "/..".  */
  int found_real_path;
  char *p;

  /* If the new directory is absolute, repeat is a no-op; if relative,
     repeat might be useful but is more likely to be a mistake.  */
  dont_repeat ();

  if (dir == 0)
    error_no_arg ("new working directory");

  dir = tilde_expand (dir);
  make_cleanup (free, dir);

  if (chdir (dir) < 0)
    perror_with_name (dir);

#if defined(_WIN32) || defined(__MSDOS__)
  /* There's too much mess with DOSish names like "d:", "d:.",
     "d:./foo" etc.  Instead of having lots of special #ifdef'ed code,
     simply get the canonicalized name of the current directory.  */
  dir = getcwd (gdb_dirbuf, sizeof (gdb_dirbuf));
#endif

  len = strlen (dir);
  if (SLASH_P (dir[len - 1]))
    {
      /* Remove the trailing slash unless this is a root directory
         (including a drive letter on non-Unix systems).  */
      if (!(len == 1)		/* "/" */
#if defined(_WIN32) || defined(__MSDOS__)
	  && !(!SLASH_P (*dir) && ROOTED_P (dir) && len <= 3)	/* "d:/" */
#endif
	  )
	len--;
    }

  dir = savestring (dir, len);
  if (ROOTED_P (dir))
    current_directory = dir;
  else
    {
      if (SLASH_P (current_directory[strlen (current_directory) - 1]))
	current_directory = concat (current_directory, dir, NULL);
      else
	current_directory = concat (current_directory, SLASH_STRING, dir, NULL);
      free (dir);
    }

  /* Now simplify any occurrences of `.' and `..' in the pathname.  */

  found_real_path = 0;
  for (p = current_directory; *p;)
    {
      if (SLASH_P (p[0]) && p[1] == '.' && (p[2] == 0 || SLASH_P (p[2])))
	strcpy (p, p + 2);
      else if (SLASH_P (p[0]) && p[1] == '.' && p[2] == '.'
	       && (p[3] == 0 || SLASH_P (p[3])))
	{
	  if (found_real_path)
	    {
	      /* Search backwards for the directory just before the "/.."
	         and obliterate it and the "/..".  */
	      char *q = p;
	      while (q != current_directory && !SLASH_P (q[-1]))
		--q;

	      if (q == current_directory)
		/* current_directory is
		   a relative pathname ("can't happen"--leave it alone).  */
		++p;
	      else
		{
		  strcpy (q - 1, p + 3);
		  p = q - 1;
		}
	    }
	  else
	    /* We are dealing with leading repetitions of "/..", for example
	       "/../..", which is the Mach super-root.  */
	    p += 3;
	}
      else
	{
	  found_real_path = 1;
	  ++p;
	}
    }

  forget_cached_source_info ();

  if (from_tty)
    pwd_command ((char *) 0, 1);
}

struct source_cleanup_lines_args
{
  int old_line;
  char *old_file;
  char *old_pre_error;
  char *old_error_pre_print;
};

static void
source_cleanup_lines (PTR args)
{
  struct source_cleanup_lines_args *p =
  (struct source_cleanup_lines_args *) args;
  source_line_number = p->old_line;
  source_file_name = p->old_file;
  source_pre_error = p->old_pre_error;
  error_pre_print = p->old_error_pre_print;
}

/* ARGSUSED */
static void
do_fclose_cleanup (void *stream)
{
  fclose (stream);
}

void
source_command (char *args, int from_tty)
{
  FILE *stream;
  struct cleanup *old_cleanups;
  char *file = args;
  struct source_cleanup_lines_args old_lines;
  int needed_length;

  if (file == NULL)
    {
      error ("source command requires pathname of file to source.");
    }

  file = tilde_expand (file);
  old_cleanups = make_cleanup (free, file);

  stream = fopen (file, FOPEN_RT);
  if (!stream)
    {
      if (from_tty)
	perror_with_name (file);
      else
	return;
    }

  make_cleanup (do_fclose_cleanup, stream);

  old_lines.old_line = source_line_number;
  old_lines.old_file = source_file_name;
  old_lines.old_pre_error = source_pre_error;
  old_lines.old_error_pre_print = error_pre_print;
  make_cleanup (source_cleanup_lines, &old_lines);
  source_line_number = 0;
  source_file_name = file;
  source_pre_error = error_pre_print == NULL ? "" : error_pre_print;
  source_pre_error = savestring (source_pre_error, strlen (source_pre_error));
  make_cleanup (free, source_pre_error);
  /* This will get set every time we read a line.  So it won't stay "" for
     long.  */
  error_pre_print = "";

  needed_length = strlen (source_file_name) + strlen (source_pre_error) + 80;
  if (source_error_allocated < needed_length)
    {
      source_error_allocated *= 2;
      if (source_error_allocated < needed_length)
	source_error_allocated = needed_length;
      if (source_error == NULL)
	source_error = xmalloc (source_error_allocated);
      else
	source_error = xrealloc (source_error, source_error_allocated);
    }

  read_command_file (stream);

  do_cleanups (old_cleanups);
}

/* ARGSUSED */
static void
echo_command (char *text, int from_tty)
{
  char *p = text;
  register int c;

  if (text)
    while ((c = *p++) != '\0')
      {
	if (c == '\\')
	  {
	    /* \ at end of argument is used after spaces
	       so they won't be lost.  */
	    if (*p == 0)
	      return;

	    c = parse_escape (&p);
	    if (c >= 0)
	      printf_filtered ("%c", c);
	  }
	else
	  printf_filtered ("%c", c);
      }

  /* Force this output to appear now.  */
  wrap_here ("");
  gdb_flush (gdb_stdout);
}

/* ARGSUSED */
static void
d1798 1
a1798 1
static void
d1890 1
a1890 1
static void
d1898 1
a1898 1
static void
d1908 1
a1908 1
static void
a1936 39
static void
set_debug (char *arg, int from_tty)
{
  printf_unfiltered ("\"set debug\" must be followed by the name of a print subcommand.\n");
  help_list (setdebuglist, "set debug ", -1, gdb_stdout);
}

static void
show_debug (char *args, int from_tty)
{
  cmd_show_list (showdebuglist, from_tty, "");
}

static void
init_cmd_lists (void)
{
  cmdlist = NULL;
  infolist = NULL;
  enablelist = NULL;
  disablelist = NULL;
  togglelist = NULL;
  stoplist = NULL;
  deletelist = NULL;
  enablebreaklist = NULL;
  setlist = NULL;
  unsetlist = NULL;
  showlist = NULL;
  sethistlist = NULL;
  showhistlist = NULL;
  unsethistlist = NULL;
  maintenancelist = NULL;
  maintenanceinfolist = NULL;
  maintenanceprintlist = NULL;
  setprintlist = NULL;
  showprintlist = NULL;
  setchecklist = NULL;
  showchecklist = NULL;
}

d2008 3
a2010 2
  rl_completer_word_break_characters = gdb_completer_word_break_characters;
  rl_completer_quote_characters = gdb_completer_quote_characters;
a2012 38
  /* Define the classes of commands.
     They will appear in the help list in the reverse of this order.  */

  add_cmd ("internals", class_maintenance, NO_FUNCTION,
	   "Maintenance commands.\n\
Some gdb commands are provided just for use by gdb maintainers.\n\
These commands are subject to frequent change, and may not be as\n\
well documented as user commands.",
	   &cmdlist);
  add_cmd ("obscure", class_obscure, NO_FUNCTION, "Obscure features.", &cmdlist);
  add_cmd ("aliases", class_alias, NO_FUNCTION, "Aliases of other commands.", &cmdlist);
  add_cmd ("user-defined", class_user, NO_FUNCTION, "User-defined commands.\n\
The commands in this class are those defined by the user.\n\
Use the \"define\" command to define a command.", &cmdlist);
  add_cmd ("support", class_support, NO_FUNCTION, "Support facilities.", &cmdlist);
  if (!dbx_commands)
    add_cmd ("status", class_info, NO_FUNCTION, "Status inquiries.", &cmdlist);
  add_cmd ("files", class_files, NO_FUNCTION, "Specifying and examining files.", &cmdlist);
  add_cmd ("breakpoints", class_breakpoint, NO_FUNCTION, "Making program stop at certain points.", &cmdlist);
  add_cmd ("data", class_vars, NO_FUNCTION, "Examining data.", &cmdlist);
  add_cmd ("stack", class_stack, NO_FUNCTION, "Examining the stack.\n\
The stack is made up of stack frames.  Gdb assigns numbers to stack frames\n\
counting from zero for the innermost (currently executing) frame.\n\n\
At any time gdb identifies one frame as the \"selected\" frame.\n\
Variable lookups are done with respect to the selected frame.\n\
When the program being debugged stops, gdb selects the innermost frame.\n\
The commands below can be used to select other frames by number or address.",
	   &cmdlist);
  add_cmd ("running", class_run, NO_FUNCTION, "Running the program.", &cmdlist);

  add_com ("pwd", class_files, pwd_command,
	"Print working directory.  This is used for your program as well.");
  c = add_cmd ("cd", class_files, cd_command,
	       "Set working directory to DIR for debugger and program being debugged.\n\
The change does not take effect for the program being debugged\n\
until the next time it is started.", &cmdlist);
  c->completer = filename_completer;

a2040 38
  add_com ("echo", class_support, echo_command,
	   "Print a constant string.  Give string as argument.\n\
C escape sequences may be used in the argument.\n\
No newline is added at the end of the argument;\n\
use \"\\n\" if you want a newline to be printed.\n\
Since leading and trailing whitespace are ignored in command arguments,\n\
if you want to print some you must use \"\\\" before leading whitespace\n\
to be printed or after trailing whitespace.");
  add_com ("document", class_support, document_command,
	   "Document a user-defined command.\n\
Give command name as argument.  Give documentation on following lines.\n\
End with a line of just \"end\".");
  add_com ("define", class_support, define_command,
	   "Define a new command name.  Command name is argument.\n\
Definition appears on following lines, one command per line.\n\
End with a line of just \"end\".\n\
Use the \"document\" command to give documentation for the new command.\n\
Commands defined in this way may have up to ten arguments.");

#ifdef __STDC__
  c = add_cmd ("source", class_support, source_command,
	       "Read commands from a file named FILE.\n\
Note that the file \"" GDBINIT_FILENAME "\" is read automatically in this way\n\
when gdb is started.", &cmdlist);
#else
  /* Punt file name, we can't help it easily.  */
  c = add_cmd ("source", class_support, source_command,
	       "Read commands from a file named FILE.\n\
Note that the file \".gdbinit\" is read automatically in this way\n\
when gdb is started.", &cmdlist);
#endif
  c->completer = filename_completer;

  add_com ("quit", class_support, quit_command, "Exit gdb.");
  add_com ("help", class_support, help_command, "Print list of commands.");
  add_com_alias ("q", "quit", class_support, 1);
  add_com_alias ("h", "help", class_support, 1);

a2044 7
  c = add_set_cmd ("verbose", class_support, var_boolean, (char *) &info_verbose,
		   "Set ",
		   &setlist),
    add_show_from_set (c, &showlist);
  c->function.sfunc = set_verbose;
  set_verbose (NULL, 0, c);

a2069 13
  add_prefix_cmd ("history", class_support, set_history,
		  "Generic command for setting command history parameters.",
		  &sethistlist, "set history ", 0, &setlist);
  add_prefix_cmd ("history", class_support, show_history,
		  "Generic command for showing command history parameters.",
		  &showhistlist, "show history ", 0, &showlist);

  add_show_from_set
    (add_set_cmd ("expansion", no_class, var_boolean, (char *) &history_expansion_p,
		  "Set history expansion on command input.\n\
Without an argument, history expansion is enabled.", &sethistlist),
     &showhistlist);

a2095 67
  add_prefix_cmd ("info", class_info, info_command,
     "Generic command for showing things about the program being debugged.",
		  &infolist, "info ", 0, &cmdlist);
  add_com_alias ("i", "info", class_info, 1);

  add_com ("complete", class_obscure, complete_command,
	   "List the completions for the rest of the line as a command.");

  add_prefix_cmd ("show", class_info, show_command,
		  "Generic command for showing things about the debugger.",
		  &showlist, "show ", 0, &cmdlist);
  /* Another way to get at the same thing.  */
  add_info ("set", show_command, "Show all GDB settings.");

  add_cmd ("commands", no_class, show_commands,
	   "Show the history of commands you typed.\n\
You can supply a command number to start with, or a `+' to start after\n\
the previous command number shown.",
	   &showlist);

  add_cmd ("version", no_class, show_version,
	   "Show what version of GDB this is.", &showlist);

  add_com ("while", class_support, while_command,
	   "Execute nested commands WHILE the conditional expression is non zero.\n\
The conditional expression must follow the word `while' and must in turn be\n\
followed by a new line.  The nested commands must be entered one per line,\n\
and should be terminated by the word `end'.");

  add_com ("if", class_support, if_command,
	   "Execute nested commands once IF the conditional expression is non zero.\n\
The conditional expression must follow the word `if' and must in turn be\n\
followed by a new line.  The nested commands must be entered one per line,\n\
and should be terminated by the word 'else' or `end'.  If an else clause\n\
is used, the same rules apply to its nested commands as to the first ones.");

  /* If target is open when baud changes, it doesn't take effect until the
     next open (I think, not sure).  */
  add_show_from_set (add_set_cmd ("remotebaud", no_class,
				  var_zinteger, (char *) &baud_rate,
				  "Set baud rate for remote serial I/O.\n\
This value is used to set the speed of the serial port when debugging\n\
using remote targets.", &setlist),
		     &showlist);

  c = add_set_cmd ("remotedebug", no_class, var_zinteger,
		   (char *) &remote_debug,
		   "Set debugging of remote protocol.\n\
When enabled, each packet sent or received with the remote target\n\
is displayed.", &setlist);
  deprecate_cmd (c, "set debug remote");
  deprecate_cmd (add_show_from_set (c, &showlist), "show debug remote");

  add_show_from_set (add_set_cmd ("remote", no_class, var_zinteger,
				  (char *) &remote_debug,
				  "Set debugging of remote protocol.\n\
When enabled, each packet sent or received with the remote target\n\
is displayed.", &setdebuglist),
		     &showdebuglist);

  add_show_from_set (
		      add_set_cmd ("remotetimeout", no_class, var_integer, (char *) &remote_timeout,
				   "Set timeout limit to wait for target to respond.\n\
This value is used to set the time limit for gdb to wait for a response\n\
from the target.", &setlist),
		      &showlist);

a2126 7
  add_prefix_cmd ("debug", no_class, set_debug,
		  "Generic command for setting gdb debugging flags",
		  &setdebuglist, "set debug ", 0, &setlist);

  add_prefix_cmd ("debug", no_class, show_debug,
		  "Generic command for showing gdb debugging flags",
		  &showdebuglist, "show debug ", 0, &showlist);
@


1.22
log
@* remote.c (remote_write_bytes): Add default case to switch
initializing ``todo''. Ditto for ``nr_bytes''.
* top.c (catch_errors): Always initialize ``val''.
* solib.c (info_sharedlibrary_command): Handle bfd_get_arch_size
returning an unknown size.
* gdbtypes.c (count_virtual_fns): Always initialize ``vfuncs''.
* breakpoint.c (break_at_finish_at_depth_command_1): Initialise
extra_args to NULL.
(break_at_finish_command_1): Ditto.
@
text
@d35 1
a72 2
static char *line_completion_function (char *, int, char *, int);

a1833 349
/* Complete on filenames.  */
char **
filename_completer (char *text, char *word)
{
  /* From readline.  */
extern char *filename_completion_function (char *, int);
  int subsequent_name;
  char **return_val;
  int return_val_used;
  int return_val_alloced;

  return_val_used = 0;
  /* Small for testing.  */
  return_val_alloced = 1;
  return_val = (char **) xmalloc (return_val_alloced * sizeof (char *));

  subsequent_name = 0;
  while (1)
    {
      char *p;
      p = filename_completion_function (text, subsequent_name);
      if (return_val_used >= return_val_alloced)
	{
	  return_val_alloced *= 2;
	  return_val =
	    (char **) xrealloc (return_val,
				return_val_alloced * sizeof (char *));
	}
      if (p == NULL)
	{
	  return_val[return_val_used++] = p;
	  break;
	}
      /* We need to set subsequent_name to a non-zero value before the
	 continue line below, because otherwise, if the first file seen
	 by GDB is a backup file whose name ends in a `~', we will loop
	 indefinitely.  */
      subsequent_name = 1;
      /* Like emacs, don't complete on old versions.  Especially useful
         in the "source" command.  */
      if (p[strlen (p) - 1] == '~')
	continue;

      {
	char *q;
	if (word == text)
	  /* Return exactly p.  */
	  return_val[return_val_used++] = p;
	else if (word > text)
	  {
	    /* Return some portion of p.  */
	    q = xmalloc (strlen (p) + 5);
	    strcpy (q, p + (word - text));
	    return_val[return_val_used++] = q;
	    free (p);
	  }
	else
	  {
	    /* Return some of TEXT plus p.  */
	    q = xmalloc (strlen (p) + (text - word) + 5);
	    strncpy (q, word, text - word);
	    q[text - word] = '\0';
	    strcat (q, p);
	    return_val[return_val_used++] = q;
	    free (p);
	  }
      }
    }
#if 0
  /* There is no way to do this just long enough to affect quote inserting
     without also affecting the next completion.  This should be fixed in
     readline.  FIXME.  */
  /* Insure that readline does the right thing
     with respect to inserting quotes.  */
  rl_completer_word_break_characters = "";
#endif
  return return_val;
}

/* Here are some useful test cases for completion.  FIXME: These should
   be put in the test suite.  They should be tested with both M-? and TAB.

   "show output-" "radix"
   "show output" "-radix"
   "p" ambiguous (commands starting with p--path, print, printf, etc.)
   "p "  ambiguous (all symbols)
   "info t foo" no completions
   "info t " no completions
   "info t" ambiguous ("info target", "info terminal", etc.)
   "info ajksdlfk" no completions
   "info ajksdlfk " no completions
   "info" " "
   "info " ambiguous (all info commands)
   "p \"a" no completions (string constant)
   "p 'a" ambiguous (all symbols starting with a)
   "p b-a" ambiguous (all symbols starting with a)
   "p b-" ambiguous (all symbols)
   "file Make" "file" (word break hard to screw up here)
   "file ../gdb.stabs/we" "ird" (needs to not break word at slash)
 */

/* Generate completions one by one for the completer.  Each time we are
   called return another potential completion to the caller.
   line_completion just completes on commands or passes the buck to the
   command's completer function, the stuff specific to symbol completion
   is in make_symbol_completion_list.

   TEXT is the caller's idea of the "word" we are looking at.

   MATCHES is the number of matches that have currently been collected from
   calling this completion function.  When zero, then we need to initialize,
   otherwise the initialization has already taken place and we can just
   return the next potential completion string.

   LINE_BUFFER is available to be looked at; it contains the entire text
   of the line.  POINT is the offset in that line of the cursor.  You
   should pretend that the line ends at POINT.

   Returns NULL if there are no more completions, else a pointer to a string
   which is a possible completion, it is the caller's responsibility to
   free the string.  */

static char *
line_completion_function (char *text, int matches, char *line_buffer, int point)
{
  static char **list = (char **) NULL;	/* Cache of completions */
  static int index;		/* Next cached completion */
  char *output = NULL;
  char *tmp_command, *p;
  /* Pointer within tmp_command which corresponds to text.  */
  char *word;
  struct cmd_list_element *c, *result_list;

  if (matches == 0)
    {
      /* The caller is beginning to accumulate a new set of completions, so
         we need to find all of them now, and cache them for returning one at
         a time on future calls. */

      if (list)
	{
	  /* Free the storage used by LIST, but not by the strings inside.
	     This is because rl_complete_internal () frees the strings. */
	  free ((PTR) list);
	}
      list = 0;
      index = 0;

      /* Choose the default set of word break characters to break completions.
         If we later find out that we are doing completions on command strings
         (as opposed to strings supplied by the individual command completer
         functions, which can be any string) then we will switch to the
         special word break set for command strings, which leaves out the
         '-' character used in some commands.  */

      rl_completer_word_break_characters =
	gdb_completer_word_break_characters;

      /* Decide whether to complete on a list of gdb commands or on symbols. */
      tmp_command = (char *) alloca (point + 1);
      p = tmp_command;

      strncpy (tmp_command, line_buffer, point);
      tmp_command[point] = '\0';
      /* Since text always contains some number of characters leading up
         to point, we can find the equivalent position in tmp_command
         by subtracting that many characters from the end of tmp_command.  */
      word = tmp_command + point - strlen (text);

      if (point == 0)
	{
	  /* An empty line we want to consider ambiguous; that is, it
	     could be any command.  */
	  c = (struct cmd_list_element *) -1;
	  result_list = 0;
	}
      else
	{
	  c = lookup_cmd_1 (&p, cmdlist, &result_list, 1);
	}

      /* Move p up to the next interesting thing.  */
      while (*p == ' ' || *p == '\t')
	{
	  p++;
	}

      if (!c)
	{
	  /* It is an unrecognized command.  So there are no
	     possible completions.  */
	  list = NULL;
	}
      else if (c == (struct cmd_list_element *) -1)
	{
	  char *q;

	  /* lookup_cmd_1 advances p up to the first ambiguous thing, but
	     doesn't advance over that thing itself.  Do so now.  */
	  q = p;
	  while (*q && (isalnum (*q) || *q == '-' || *q == '_'))
	    ++q;
	  if (q != tmp_command + point)
	    {
	      /* There is something beyond the ambiguous
	         command, so there are no possible completions.  For
	         example, "info t " or "info t foo" does not complete
	         to anything, because "info t" can be "info target" or
	         "info terminal".  */
	      list = NULL;
	    }
	  else
	    {
	      /* We're trying to complete on the command which was ambiguous.
	         This we can deal with.  */
	      if (result_list)
		{
		  list = complete_on_cmdlist (*result_list->prefixlist, p,
					      word);
		}
	      else
		{
		  list = complete_on_cmdlist (cmdlist, p, word);
		}
	      /* Insure that readline does the right thing with respect to
	         inserting quotes.  */
	      rl_completer_word_break_characters =
		gdb_completer_command_word_break_characters;
	    }
	}
      else
	{
	  /* We've recognized a full command.  */

	  if (p == tmp_command + point)
	    {
	      /* There is no non-whitespace in the line beyond the command.  */

	      if (p[-1] == ' ' || p[-1] == '\t')
		{
		  /* The command is followed by whitespace; we need to complete
		     on whatever comes after command.  */
		  if (c->prefixlist)
		    {
		      /* It is a prefix command; what comes after it is
		         a subcommand (e.g. "info ").  */
		      list = complete_on_cmdlist (*c->prefixlist, p, word);

		      /* Insure that readline does the right thing
		         with respect to inserting quotes.  */
		      rl_completer_word_break_characters =
			gdb_completer_command_word_break_characters;
		    }
		  else if (c->enums)
		    {
		      list = complete_on_enum (c->enums, p, word);
		      rl_completer_word_break_characters =
			gdb_completer_command_word_break_characters;
		    }
		  else
		    {
		      /* It is a normal command; what comes after it is
		         completed by the command's completer function.  */
		      list = (*c->completer) (p, word);
		      if (c->completer == filename_completer)
			rl_completer_word_break_characters =
			  gdb_completer_file_name_break_characters;
		    }
		}
	      else
		{
		  /* The command is not followed by whitespace; we need to
		     complete on the command itself.  e.g. "p" which is a
		     command itself but also can complete to "print", "ptype"
		     etc.  */
		  char *q;

		  /* Find the command we are completing on.  */
		  q = p;
		  while (q > tmp_command)
		    {
		      if (isalnum (q[-1]) || q[-1] == '-' || q[-1] == '_')
			--q;
		      else
			break;
		    }

		  list = complete_on_cmdlist (result_list, q, word);

		  /* Insure that readline does the right thing
		     with respect to inserting quotes.  */
		  rl_completer_word_break_characters =
		    gdb_completer_command_word_break_characters;
		}
	    }
	  else
	    {
	      /* There is non-whitespace beyond the command.  */

	      if (c->prefixlist && !c->allow_unknown)
		{
		  /* It is an unrecognized subcommand of a prefix command,
		     e.g. "info adsfkdj".  */
		  list = NULL;
		}
	      else if (c->enums)
		{
		  list = complete_on_enum (c->enums, p, word);
		}
	      else
		{
		  /* It is a normal command.  */
		  list = (*c->completer) (p, word);
		  if (c->completer == filename_completer)
		    rl_completer_word_break_characters =
		      gdb_completer_file_name_break_characters;
		}
	    }
	}
    }

  /* If we found a list of potential completions during initialization then
     dole them out one at a time.  The vector of completions is NULL
     terminated, so after returning the last one, return NULL (and continue
     to do so) each time we are called after that, until a new list is
     available. */

  if (list)
    {
      output = list[index];
      if (output)
	{
	  index++;
	}
    }

#if 0
  /* Can't do this because readline hasn't yet checked the word breaks
     for figuring out whether to insert a quote.  */
  if (output == NULL)
    /* Make sure the word break characters are set back to normal for the
       next time that readline tries to complete something.  */
    rl_completer_word_break_characters =
      gdb_completer_word_break_characters;
#endif

  return (output);
}

a1841 34
/* Skip over a possibly quoted word (as defined by the quote characters
   and word break characters the completer uses).  Returns pointer to the
   location after the "word". */

char *
skip_quoted (char *str)
{
  char quote_char = '\0';
  char *scan;

  for (scan = str; *scan != '\0'; scan++)
    {
      if (quote_char != '\0')
	{
	  /* Ignore everything until the matching close quote char */
	  if (*scan == quote_char)
	    {
	      /* Found matching close quote. */
	      scan++;
	      break;
	    }
	}
      else if (strchr (gdb_completer_quote_characters, *scan))
	{
	  /* Found start of a quoted string. */
	  quote_char = *scan;
	}
      else if (strchr (gdb_completer_word_break_characters, *scan))
	{
	  break;
	}
    }
  return (scan);
}
a1842 1

@


1.21
log
@	* tracepoint.c (trace_find_tracepoint_command): Replace call to
	parse_and_eval_address with a call to parse_and_eval_long as
	we are evaluating an integer, not an address.
	* top.c (show_commands): Ditto.
@
text
@d608 2
@


1.20
log
@2000-11-06  Fernando Nasser  <fnasser@@cygnus.com>

        From  Steven Johnson  <sbjohnson@@ozemail.com.au>:

        This set of changes add "hookpost-" as an expansion on the original
        hooking of commands to GDB. A Hook may now be run "AFTER" execution of
        a command as well as before.

        * command.h (struct cmd_list_element): Changed elements hook and hookee
        to hook_pre and hookee_pre respectively. Added hook_post and hookee_post
        for the post hook command operation. Added hook_in so that an executing
        hook can be flagged to prevent recursion.
        * command.c (add_cmd): Changed initilization of cmd_list_element to
        reflect above changes.
        (delete_cmd): Remove both pre and post hooks.
        (help_cmd): Notify that the command has pre and/or post hooks.
        * infrun.c (normal_stop): Change references to hook_pre from hook.
        * top.c (execute_command): Run both pre and post hooks.
        (define_command): Allow definition of both pre and post hooks.
        The definition of pre-hooks is done as before, with the "hook-"
        prefix for backward compatibility.
@
text
@d3855 1
a3855 1
	num = (parse_and_eval_address (args) - history_base) - Hist_print / 2;
@


1.19
log
@Protoization.
@
text
@d1503 7
a1509 3
      /* If this command has been hooked, run the hook first. */
      if (c->hook)
	execute_user_command (c->hook, (char *) 0);
d1524 9
d3004 7
d3012 1
a3012 1
  register struct cmd_list_element *c, *newc, *hookc = 0;
d3014 5
a3018 1
  char tmpbuf[128];
d3021 2
d3047 11
d3059 1
a3059 1
      tem = comname + HOOK_LEN;
d3061 1
a3061 1
      if (hookc && !STREQ (comname + HOOK_LEN, hookc->name))
d3095 13
a3107 2
      hookc->hook = newc;	/* Target gets hooked.  */
      newc->hookee = hookc;	/* We are marked as hooking target cmd.  */
@


1.18
log
@
Corrected spelling errors in comments
@
text
@d1646 2
a1647 3
simplified_command_loop (read_input_func, execute_command_func)
     char *(*read_input_func) (char *);
     void (*execute_command_func) (char *, int);
d2873 1
a2873 4
add_info (name, fun, doc)
     char *name;
     void (*fun) (char *, int);
     char *doc;
d2934 2
a2935 5
add_com (name, class, fun, doc)
     char *name;
     enum command_class class;
     void (*fun) (char *, int);
     char *doc;
d2955 3
d2960 1
a2960 3
help_command (command, from_tty)
     char *command;
     int from_tty;		/* Ignored */
@


1.17
log
@* top.c (get_prompt_1), tracepoint.c (replace_comma): Update
function signatures so that they match catch_errors and
make_cleanup callbacks.
* tracepoint.c (encode_actions): Fix arguments passed to
stringify_collection_list.
@
text
@d567 1
a567 1
/* MAYBE: cagney/1999-11-05: Should the catch_erros and cleanups code
d610 1
a610 1
  /* FIXME: cagney/1999-11-05: A correct FUNC implementaton will
d612 1
a612 1
     were just prior to the call.  Unfortunatly, many FUNC's are not
d675 1
a675 1
     after its self.  Unfortunatly, old code (prior to 1999-11-04) in
@


1.16
log
@Protoization.
@
text
@d3182 1
a3182 1
get_prompt_1 (char *formatted_prompt)
d3184 1
@


1.15
log
@Replace command_loop_marker() with null_cleanup().
@
text
@d506 1
a506 2
return_to_top_level (reason)
     enum return_reason reason;
d572 2
a573 5
catch_errors (func, args, errstring, mask)
     catch_errors_ftype *func;
     PTR args;
     char *errstring;
     return_mask mask;
d699 1
a699 2
disconnect (signo)
     int signo;
d713 1
a713 2
quit_cover (s)
     PTR s;
d761 1
a761 2
read_command_file (stream)
     FILE *stream;
d785 1
a785 2
gdb_init (argv0)
     char *argv0;
d847 1
a847 3
build_command_line (type, args)
     enum command_control_type type;
     char *args;
d871 1
a871 3
get_command_line (type, arg)
     enum command_control_type type;
     char *arg;
d896 2
a897 4
print_command_lines (uiout, cmd, depth)
     struct ui_out *uiout;
     struct command_line *cmd;
     unsigned int depth;
d984 2
a985 4
print_command_line (cmd, depth, stream)
     struct command_line *cmd;
     unsigned int depth;
     struct ui_file *stream;
d1066 1
a1066 2
execute_control_command (cmd)
     struct command_line *cmd;
d1213 1
a1213 3
while_command (arg, from_tty)
     char *arg;
     int from_tty;
d1231 1
a1231 3
if_command (arg, from_tty)
     char *arg;
     int from_tty;
d1261 1
a1261 2
setup_user_args (p)
     char *p;
d1343 1
a1343 2
locate_arg (p)
     char *p;
d1358 1
a1358 2
insert_args (line)
     char *line;
d1418 1
a1418 3
execute_user_command (c, args)
     struct cmd_list_element *c;
     char *args;
d1452 1
a1452 3
execute_command (p, from_tty)
     char *p;
     int from_tty;
d1555 1
a1555 1
command_loop ()
d1680 1
a1680 1
dont_repeat ()
d1700 1
a1700 2
gdb_readline (prompt_arg)
     char *prompt_arg;
d1816 1
a1816 3
noop_completer (text, prefix)
     char *text;
     char *prefix;
d1823 1
a1823 3
filename_completer (text, word)
     char *text;
     char *word;
d1944 1
a1944 5
line_completion_function (text, matches, line_buffer, point)
     char *text;
     int matches;
     char *line_buffer;
     int point;
d2173 1
a2173 3
readline_line_completion_function (text, matches)
     char *text;
     int matches;
d2183 1
a2183 2
skip_quoted (str)
     char *str;
d2216 1
a2216 2
stop_sig (signo)
     int signo;
d2236 1
a2236 2
do_nothing (signo)
     int signo;
d2248 1
a2248 1
init_signals ()
d2294 1
a2294 4
command_line_input (prompt_arg, repeat, annotation_suffix)
     char *prompt_arg;
     int repeat;
     char *annotation_suffix;
d2516 1
a2516 3
realloc_body_list (command, new_length)
     struct command_line *command;
     int new_length;
d2541 1
a2541 2
read_next_line (command)
     struct command_line **command;
d2638 1
a2638 2
recurse_read_control_structure (current_cmd)
     struct command_line *current_cmd;
d2750 1
a2750 3
read_command_lines (prompt_arg, from_tty)
     char *prompt_arg;
     int from_tty;
d2837 1
a2837 2
free_command_lines (lptr)
     struct command_line **lptr;
d2885 1
a2885 4
add_info_alias (name, oldname, abbrev_flag)
     char *name;
     char *oldname;
     int abbrev_flag;
d2895 1
a2895 3
info_command (arg, from_tty)
     char *arg;
     int from_tty;
d2905 1
a2905 3
complete_command (arg, from_tty)
     char *arg;
     int from_tty;
d2930 1
a2930 3
show_command (arg, from_tty)
     char *arg;
     int from_tty;
d2950 2
a2951 5
add_com_alias (name, oldname, class, abbrev_flag)
     char *name;
     char *oldname;
     enum command_class class;
     int abbrev_flag;
d2957 1
a2957 2
error_no_arg (why)
     char *why;
d2972 1
a2972 2
validate_comname (comname)
     char *comname;
d2990 1
a2990 3
user_defined_command (ignore, from_tty)
     char *ignore;
     int from_tty;
d2995 1
a2995 3
define_command (comname, from_tty)
     char *comname;
     int from_tty;
d3070 1
a3070 3
document_command (comname, from_tty)
     char *comname;
     int from_tty;
d3113 1
a3113 2
print_gdb_version (stream)
     struct ui_file *stream;
d3157 1
a3157 3
show_version (args, from_tty)
     char *args;
     int from_tty;
d3182 1
a3182 2
get_prompt_1 (formatted_prompt)
     char *formatted_prompt;
d3410 1
a3410 1
get_prompt ()
d3430 1
a3430 2
set_prompt (s)
     char *s;
d3448 1
a3448 1
quit_confirm ()
d3474 1
a3474 3
quit_force (args, from_tty)
     char *args;
     int from_tty;
d3520 1
a3520 3
quit_command (args, from_tty)
     char *args;
     int from_tty;
d3531 1
a3531 1
input_from_terminal_p ()
d3538 1
a3538 3
pwd_command (args, from_tty)
     char *args;
     int from_tty;
d3552 1
a3552 3
cd_command (dir, from_tty)
     char *dir;
     int from_tty;
d3659 1
a3659 2
source_cleanup_lines (args)
     PTR args;
d3677 1
a3677 3
source_command (args, from_tty)
     char *args;
     int from_tty;
d3737 1
a3737 3
echo_command (text, from_tty)
     char *text;
     int from_tty;
d3767 1
a3767 3
dont_repeat_command (ignored, from_tty)
     char *ignored;
     int from_tty;
d3778 1
a3778 3
show_commands (args, from_tty)
     char *args;
     int from_tty;
d3855 1
a3855 4
set_history_size_command (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
d3870 1
a3870 3
set_history (args, from_tty)
     char *args;
     int from_tty;
d3878 1
a3878 3
show_history (args, from_tty)
     char *args;
     int from_tty;
d3888 1
a3888 4
set_verbose (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
d3908 1
a3908 2
float_handler (signo)
     int signo;
d3917 1
a3917 3
set_debug (arg, from_tty)
     char *arg;
     int from_tty;
d3924 1
a3924 3
show_debug (args, from_tty)
     char *args;
     int from_tty;
d3930 1
a3930 1
init_cmd_lists ()
d3962 1
a3962 1
init_history ()
d3993 1
a3993 1
init_main ()
@


1.14
log
@Eliminate PARAMS from function pointer declarations.
@
text
@a75 5
/* NOTE 1999-04-29: this function will be static again, after we make the
   event loop be the default command loop for gdb, and we merge
   event-top.c into this file, top.c */
/* static */ void command_loop_marker (void *);

a1578 9
/* ARGSUSED */
/* NOTE 1999-04-29: This function will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c */
/* static */ void
command_loop_marker (void *foo)
{
}

d1606 1
a1606 1
      old_chain = make_cleanup (command_loop_marker, 0);
d1687 1
a1687 1
      old_chain = make_cleanup (command_loop_marker, 0);
@


1.13
log
@PARAMS removal.
@
text
@d288 1
a288 1
void (*window_hook) PARAMS ((FILE *, char *));
d395 1
a395 1
void (*init_ui_hook) PARAMS ((char *argv0));
d401 1
a401 1
int (*ui_loop_hook) PARAMS ((int));
d406 1
a406 1
void (*command_loop_hook) PARAMS ((void));
d411 2
a412 2
void (*print_frame_info_listing_hook) PARAMS ((struct symtab * s, int line,
					       int stopline, int noerror));
d415 1
a415 1
int (*query_hook) PARAMS ((const char *, va_list));
d419 1
a419 1
void (*warning_hook) PARAMS ((const char *, va_list));
d432 3
a434 3
void (*readline_begin_hook) PARAMS ((char *,...));
char *(*readline_hook) PARAMS ((char *));
void (*readline_end_hook) PARAMS ((void));
d439 3
a441 3
void (*create_breakpoint_hook) PARAMS ((struct breakpoint * bpt));
void (*delete_breakpoint_hook) PARAMS ((struct breakpoint * bpt));
void (*modify_breakpoint_hook) PARAMS ((struct breakpoint * bpt));
d446 2
a447 2
void (*attach_hook) PARAMS ((void));
void (*detach_hook) PARAMS ((void));
d452 1
a452 1
void (*interactive_hook) PARAMS ((void));
d457 1
a457 1
void (*registers_changed_hook) PARAMS ((void));
d462 1
a462 1
void (*register_changed_hook) PARAMS ((int regno));
d465 1
a465 1
void (*memory_changed_hook) PARAMS ((CORE_ADDR addr, int len));
d470 1
a470 1
int (*target_wait_hook) PARAMS ((int pid, struct target_waitstatus * status));
d475 2
a476 2
void (*call_command_hook) PARAMS ((struct cmd_list_element * c, char *cmd,
				   int from_tty));
d485 1
a485 1
void (*context_hook) PARAMS ((int id));
d785 1
a785 1
void (*pre_init_ui_hook) PARAMS ((void));
d2942 1
a2942 1
     void (*fun) PARAMS ((char *, int));
d3016 1
a3016 1
     void (*fun) PARAMS ((char *, int));
@


1.12
log
@Eliminate make_cleanup_func from top.c
@
text
@d60 1
a60 1
static void dont_repeat_command PARAMS ((char *, int));
d62 1
a62 1
static void source_cleanup_lines PARAMS ((PTR));
d64 1
a64 1
static void user_defined_command PARAMS ((char *, int));
d66 1
a66 1
static void init_signals PARAMS ((void));
d69 1
a69 1
static void stop_sig PARAMS ((int));
d72 1
a72 1
static char *line_completion_function PARAMS ((char *, int, char *, int));
d74 1
a74 1
static char *readline_line_completion_function PARAMS ((char *, int));
d81 1
a81 1
static void while_command PARAMS ((char *, int));
d83 1
a83 1
static void if_command PARAMS ((char *, int));
d85 2
a86 2
static struct command_line *
  build_command_line PARAMS ((enum command_control_type, char *));
d88 2
a89 2
static struct command_line *
  get_command_line PARAMS ((enum command_control_type, char *));
d91 1
a91 1
static void realloc_body_list PARAMS ((struct command_line *, int));
d93 1
a93 1
static enum misc_command_type read_next_line PARAMS ((struct command_line **));
d96 1
a96 1
recurse_read_control_structure PARAMS ((struct command_line *));
d98 1
a98 1
static struct cleanup *setup_user_args PARAMS ((char *));
d100 1
a100 1
static char *locate_arg PARAMS ((char *));
d102 1
a102 1
static char *insert_args PARAMS ((char *));
d106 1
a106 1
static void init_main PARAMS ((void));
d108 1
a108 1
static void init_cmd_lists PARAMS ((void));
d110 1
a110 1
static void float_handler PARAMS ((int));
d112 1
a112 1
static void init_signals PARAMS ((void));
d114 1
a114 1
static void set_verbose PARAMS ((char *, int, struct cmd_list_element *));
d116 1
a116 1
static void show_history PARAMS ((char *, int));
d118 1
a118 1
static void set_history PARAMS ((char *, int));
d120 1
a120 2
static void set_history_size_command PARAMS ((char *, int,
					      struct cmd_list_element *));
d122 1
a122 1
static void show_commands PARAMS ((char *, int));
d124 1
a124 1
static void echo_command PARAMS ((char *, int));
d126 1
a126 1
static void pwd_command PARAMS ((char *, int));
d128 1
a128 1
static void show_version PARAMS ((char *, int));
d130 1
a130 1
static void document_command PARAMS ((char *, int));
d132 1
a132 1
static void define_command PARAMS ((char *, int));
d134 1
a134 1
static void validate_comname PARAMS ((char *));
d136 1
a136 1
static void help_command PARAMS ((char *, int));
d138 1
a138 1
static void show_command PARAMS ((char *, int));
d140 1
a140 1
static void info_command PARAMS ((char *, int));
d142 1
a142 1
static void complete_command PARAMS ((char *, int));
d144 1
a144 1
static void do_nothing PARAMS ((int));
d146 1
a146 1
static void show_debug PARAMS ((char *, int));
d148 1
a148 1
static void set_debug PARAMS ((char *, int));
d154 1
a154 1
/* static */ int quit_cover PARAMS ((PTR));
d156 1
a156 1
static void disconnect PARAMS ((int));
d295 1
a295 1
extern char *get_prompt PARAMS ((void));	/* access function for prompt string */
d373 1
a373 1
static void stop_sig PARAMS ((int));
d783 1
a783 1
extern void init_proc PARAMS ((void));
d1492 1
a1492 1
  extern void serial_log_command PARAMS ((const char *));
d1873 1
a1873 1
  extern char *filename_completion_function PARAMS ((char *, int));
d3899 1
a3899 1
  extern HIST_ENTRY *history_get PARAMS ((int));
@


1.11
log
@	* ax-gdb.c (agent_command): Remove now useless cast of
	`free_current_contents' when passed to `make_cleanup'.
	* coffread.c (coff_symfile_read): Ditto.
	* dwarf2read.c (dwarf2_add_member_fn, read_array_type): Ditto.
	(dwarf_decode_lines): Ditto.
	* eval.c (parse_and_eval_address, parse_and_eval_address_1): Ditto.
	(parse_and_eval, parse_to_comma_and_eval): Ditto.
	* parse.c (parse_exp_1): Ditto.
	* printcmd.c (print_command_1, output_command, set_command): Ditto.
	(x_command, print_frame_args, printf_command): Ditto.
	* top.c (execute_control_command): Ditto.
	* tracepoint.c (validate_actionline): Ditto.
	* typeprint.c (whatis_exp, ptype_command): Ditto.
	(maintenance_print_type): Ditto.
@
text
@d79 1
a79 1
/* static */ void command_loop_marker PARAMS ((int));
d104 1
a104 1
static void arg_cleanup PARAMS ((void));
d160 3
a162 1
static void source_cleanup PARAMS ((FILE *));
d765 1
a765 2
source_cleanup (stream)
     FILE *stream;
d778 1
a778 1
  cleanups = make_cleanup ((make_cleanup_func) source_cleanup, instream);
d788 9
d812 1
a812 1
  make_final_cleanup ((make_cleanup_func) chdir, strsave (current_directory));
d897 1
a897 1
  old_chain = make_cleanup ((make_cleanup_func) free_command_lines, &cmd);
d1274 1
a1274 1
arg_cleanup ()
d1301 1
a1301 1
  old_chain = make_cleanup ((make_cleanup_func) arg_cleanup, 0);
d1465 1
a1465 1
  old_chain = make_cleanup ((make_cleanup_func) source_cleanup, instream);
d1590 1
a1590 2
command_loop_marker (foo)
     int foo;
d1621 1
a1621 1
      old_chain = make_cleanup ((make_cleanup_func) command_loop_marker, 0);
d1702 1
a1702 1
      old_chain = make_cleanup ((make_cleanup_func) command_loop_marker, 0);
d2876 1
a2876 2
	  old_chain = make_cleanup ((make_cleanup_func) free_command_lines,
				    &head);
d2925 12
d3771 6
d3805 1
a3805 1
  make_cleanup ((make_cleanup_func) fclose, stream);
@


1.10
log
@	* top.c (gdb_completer_file_name_break_characters): New variable.
	(line_completion_function): When completing on file names, use
	gdb_completer_file_name_break_characters as word break
	characters for the readline library.
@
text
@d1097 1
a1097 2
      old_chain = make_cleanup ((make_cleanup_func) free_current_contents,
				&new_line);
d1115 1
a1115 2
	old_chain = make_cleanup ((make_cleanup_func) free_current_contents,
				  &new_line);
d1117 1
a1117 1
	make_cleanup ((make_cleanup_func) free_current_contents, &expr);
d1175 1
a1175 2
	old_chain = make_cleanup ((make_cleanup_func) free_current_contents,
				  &new_line);
d1178 1
a1178 1
	make_cleanup ((make_cleanup_func) free_current_contents, &expr);
@


1.9
log
@	* top.c (filename_completer): Set subsequent_name to 1 early on,
	to prevent an infinite loop if the first file in the directory is
	a backup file.
@
text
@d1836 6
d2131 3
d2180 3
@


1.9.2.1
log
@	* top.c (gdb_completer_file_name_break_characters): New variable.
	(line_completion_function): When completing on file names, use
	gdb_completer_file_name_break_characters as word break
	characters for the readline library.
@
text
@a1835 6
/* When completing on file names, we remove from the list of word
   break characters any characters that are commonly used in file
   names, such as '-', '+', '~', etc.  Otherwise, readline displays
   incorrect completion candidates.  */
char *gdb_completer_file_name_break_characters = " \t\n*|\"';:?/><";

a2124 3
		      if (c->completer == filename_completer)
			rl_completer_word_break_characters =
			  gdb_completer_file_name_break_characters;
a2170 3
		  if (c->completer == filename_completer)
		    rl_completer_word_break_characters =
		      gdb_completer_file_name_break_characters;
@


1.8
log
@Re-indent (almost).  Several cases where indent was getting it wrong
were omitted.
@
text
@d1890 5
a1923 1
      subsequent_name = 1;
@


1.7
log
@The set debug changes
@
text
@d480 1
a480 1
void (*set_hook) PARAMS ((struct cmd_list_element *c));
d489 1
a489 2
NORETURN void (*error_hook)
PARAMS ((void)) ATTR_NORETURN;
d542 1
a542 1
  (NORETURN void) SIGLONGJMP (*catch_return, (int)reason);
d692 1
a692 1
catch_command_errors (catch_command_errors_ftype *command,
d1506 1
a1506 1
      
d1529 1
a1529 1
      
d1535 1
a1535 1
      deprecated_cmd_warning (&line);
d3647 1
a3647 1
  if (SLASH_P (dir[len-1]))
d3650 2
a3651 2
	 (including a drive letter on non-Unix systems).  */
      if (!(len == 1) /* "/" */
d3653 1
a3653 1
	  && !(!SLASH_P (*dir) && ROOTED_P (dir) && len <= 3) /* "d:/" */
d3999 2
a4000 2
	char *arg;
	int from_tty;
d4002 2
a4003 3
	printf_unfiltered (
			"\"set debug\" must be followed by the name of a print subcommand.\n");
	help_list (setdebuglist, "set debug ", -1, gdb_stdout);
d4008 2
a4009 2
	char *args;
	int from_tty;
d4011 1
a4011 1
	          cmd_show_list (showdebuglist, from_tty, "");
d4068 2
a4069 2
    /* No leading dots in file names are allowed on MSDOS.  */
    history_filename = concat (current_directory, "/_gdb_history", NULL);
d4339 3
a4341 1
  c = add_set_cmd("remotedebug", no_class, var_zinteger, (char *) &remote_debug, "Set debugging of remote protocol.\n\
d4343 7
a4349 7
is displayed.",&setlist);
  deprecate_cmd(c,"set debug remote");
  deprecate_cmd(add_show_from_set(c,&showlist),"show debug remote");

  add_show_from_set (
  add_set_cmd ("remote", no_class, var_zinteger, (char *) &remote_debug,
	       "Set debugging of remote protocol.\n\
d4352 1
a4352 1
		      &showdebuglist);
d4392 7
a4398 3
	add_prefix_cmd("debug",no_class,set_debug, "Generic command for setting gdb debugging flags", &setdebuglist, "set debug ", 0, &setlist);

	add_prefix_cmd("debug",no_class,show_debug,"Generic command for showing gdb debugging flags", &showdebuglist, "show debug ", 0, &showlist);
@


1.6
log
@Bump copyright to 2000.
@
text
@d147 4
d262 4
d3997 18
a4014 1

d4341 6
d4348 1
a4348 1
  add_set_cmd ("remotedebug", no_class, var_zinteger, (char *) &remote_debug,
d4351 2
a4352 2
is displayed.", &setlist),
		      &showlist);
d4392 3
@


1.5
log
@2000-03-23  Fernando Nasser  <fnasser@@cygnus.com>

	From David Whedon <dwhedon@@gordian.com>

	* top.c (execute_command): Checks all commands beore executing
	to see if the user needs to be warned that the command is
	deprecated, warns user if appropriate.
	(add_info), (add_info_alias), (add_com) , (add_com_alias): Changed
	return values from void to struct cmd_list_element *.
	* command.c (lookup_cmd_1): Check aliases before following link
	in case user needs to be warned about a deprecated alias.
	(deprecate_cmd): new exported function for command deprecation,
	sets flags and posibly a replacement string.
	(deprecated_cmd_warning): New exported funciton to warn user about
	a deprecated command.
	(lookup_cmd_composition): New exported function that determines
	alias, prefix_command, and cmd based on a string.  This is useful
	is we want to full name of a command.
	* command.h : Added prototypes for deprecate_cmd,
	deprecated_warn_user and lookup_cmd_composition, added flags to
	the cmd_list_element structure, changed return values for
	add_com_* and add_info_* from void to cmd_list_element.
	* maint.c : (maintenance_deprecate): New function to deprecate a
	command.  This exists only so that the testsuite can deprecate
	commands at runtime and check the warning behavior.
	(maintenance_undeprecate) : New function, drops deprecated flags.
	(maintenance_do_deprecate): Actually does the (un)deprecation.
	(initialize_maint_cmds): Added the above new deprecate commands.
@
text
@d3176 1
a3176 1
  fprintf_filtered (stream, "Copyright 1998 Free Software Foundation, Inc.\n");
@


1.4
log
@	* top.c (SIGJMP_BUF, SIGSETJMP, SIGLONGJMP): Update comments.
	(error_return, quit_return): Merge into catch_return pointer.
	(return_to_top_level): Update comment.  Longjmp to *catch_errors,
	and communicate reason to catch_errors via setjmp return value.
	(catch_errors): Always catch both quit and error, and if a catch
	wasn't requested by caller, throw it to the next catch_error.
	Replace dual longjmp buffer memcpy with single pointer change.
	Add FIXME for possibly adding new interface to tell caller what
	event was caught.  Add extensive comments.
	* defs.h (enum return_reason): Reserve 0 for use as initial
	setjmp() return value.
	(RETURN_MASK): New public macro to generate RETURN_MASK_* from
	enum return_reason.
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR): Define using RETURN_MASK.
@
text
@d1477 1
d1498 2
a1499 1

d1522 1
a1522 1

d1527 3
d2900 1
a2900 1
void
d2906 1
a2906 1
  add_cmd (name, no_class, fun, doc, &infolist);
d2911 1
a2911 1
void
d2917 1
a2917 1
  add_alias_cmd (name, oldname, 0, abbrev_flag, &infolist);
d2973 1
a2973 1
void
d2980 1
a2980 1
  add_cmd (name, class, fun, doc, &cmdlist);
d2985 1
a2985 1
void
d2992 1
a2992 1
  add_alias_cmd (name, oldname, class, abbrev_flag, &cmdlist);
@


1.3
log
@Add mi/ and testsuite/gdb.mi/ subdirectories.
Add --enable-gdbmi option to configury.
Add mi rules to Makefile.in
Add mi conditional output to event-top.c infrun.c main.c top.c.
Add -i=mi option.
@
text
@d485 2
a486 2
/* Generally one should use catch_errors rather than manipulating these
   directly.  The exception is main().  */
d497 2
a498 4
/* Where to go for return_to_top_level (RETURN_ERROR).  */
static SIGJMP_BUF error_return;
/* Where to go for return_to_top_level (RETURN_QUIT).  */
static SIGJMP_BUF quit_return;
d500 1
a500 2
/* Return for reason REASON.  This generally gets back to the command
   loop, but can be caught via catch_errors.  */
d531 5
a535 2
  (NORETURN void) SIGLONGJMP
    (reason == RETURN_ERROR ? error_return : quit_return, 1);
a564 7
/* MAYBE: cagney/1999-11-05: Since the SET_TOP_LEVEL macro has been
   eliminated it is now possible to use the stack to directly store
   each longjmp buffer.  The global code would just need to update a
   pointer (onto the stack - ulgh!?) indicating the current longjmp
   buffers. It would certainly improve the performance of the longjmp
   code since the memcpy's would be eliminated. */

d576 2
a577 3
  SIGJMP_BUF saved_error;
  SIGJMP_BUF saved_quit;
  SIGJMP_BUF tmp_jmp;
d583 6
a588 1
  saved_cleanup_chain = save_cleanups ();
d593 1
a593 4
    {
      memcpy ((char *) saved_error, (char *) error_return, sizeof (SIGJMP_BUF));
      error_pre_print = errstring;
    }
d595 25
a619 23
    {
      memcpy (saved_quit, quit_return, sizeof (SIGJMP_BUF));
      quit_pre_print = errstring;
    }

  if (SIGSETJMP (tmp_jmp) == 0)
    {
      if (mask & RETURN_MASK_ERROR)
	memcpy (error_return, tmp_jmp, sizeof (SIGJMP_BUF));
      if (mask & RETURN_MASK_QUIT)
	memcpy (quit_return, tmp_jmp, sizeof (SIGJMP_BUF));
      val = (*func) (args);
      /* FIXME: cagney/1999-11-05: A correct FUNC implementaton will
         clean things up (restoring the cleanup chain) to the state
         they were just prior to the call.  Technically, this means
         that the below restore_cleanups call is redundant.
         Unfortunatly, many FUNC's are not that well behaved.
         restore_cleanups should either be replaced with a do_cleanups
         call (to cover the problem) or an assertion check to detect
         bad FUNCs code. */
    }
  else
    val = 0;
d623 2
d626 33
a658 10
    {
      memcpy (error_return, saved_error, sizeof (SIGJMP_BUF));
      error_pre_print = saved_error_pre_print;
    }
  if (mask & RETURN_MASK_QUIT)
    {
      memcpy (quit_return, saved_quit, sizeof (SIGJMP_BUF));
      quit_pre_print = saved_quit_pre_print;
    }
  return val;
@


1.2
log
@From JTC: Reduce default remote_timeout to two.  Flush defunct code.
@
text
@d804 11
@


1.1
log
@Initial revision
@
text
@d2 1
a2 2
   Copyright 1986, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 1998
   Free Software Foundation, Inc.
d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d33 1
a33 1
#include "terminal.h" /* For job_control.  */
a34 1
#include <setjmp.h>
d36 1
a45 3
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
d47 3
d53 4
a56 2

extern void initialize_utils PARAMS ((void));
d72 1
a72 1
static char * line_completion_function PARAMS ((char *, int, char *, int));
d74 1
a74 1
static char * readline_line_completion_function PARAMS ((char *, int));
d76 4
a79 1
static void command_loop_marker PARAMS ((int));
d86 1
a86 1
build_command_line PARAMS ((enum command_control_type, char *));
d89 1
a89 1
get_command_line PARAMS ((enum command_control_type, char *));
d98 1
a98 1
static struct cleanup * setup_user_args PARAMS ((char *));
d100 1
a100 1
static char * locate_arg PARAMS ((char *));
d102 1
a102 1
static char * insert_args PARAMS ((char *));
d148 4
a151 1
static int quit_cover PARAMS ((PTR));
d158 4
a161 4
/* If this definition isn't overridden by the header files, assume
   that isatty and fileno exist on this system.  */
#ifndef ISATTY
#define ISATTY(FP)	(isatty (fileno (FP)))
a177 12
/* Version number of GDB, as a string.  */

extern char *version;

/* Canonical host name as a string. */

extern char *host_name;

/* Canonical target name as a string. */

extern char *target_name;

d182 1
a182 1
int caution = 1;			/* Default is yes, sigh. */
a243 1
#if MAINTENANCE_CMDS
a244 1
#endif
a247 1
#if MAINTENANCE_CMDS
a248 1
#endif
a251 1
#if MAINTENANCE_CMDS
a252 1
#endif
d285 2
a286 1
static char *prompt;
d295 1
a295 1
   affects things like recording into the command history, comamnds
d311 19
a329 1
int remote_timeout = 20;	/* Set default to 20 */
d335 6
d347 11
a357 9
{
  struct user_args *next;
  struct
    {
      char *arg;
      int len;
    } a[MAXUSERARGS];
  int count;
} *user_args;
d387 6
a392 3
#ifdef __CYGWIN32__
void (*ui_loop_hook) PARAMS ((int));
#endif
a399 9
/* Called instead of fputs for all output.  */

void (*fputs_unfiltered_hook) PARAMS ((const char *linebuffer, GDB_FILE *stream));

/* Called when the target says something to the host, which may
   want to appear in a different window. */

void (*target_output_hook) PARAMS ((char *));

d402 1
a402 1
void (*print_frame_info_listing_hook) PARAMS ((struct symtab *s, int line,
a411 4
/* Called from gdb_flush to flush output.  */

void (*flush_hook) PARAMS ((GDB_FILE *stream));

d423 2
a424 2
void (*readline_begin_hook) PARAMS ((char *, ...));
char * (*readline_hook) PARAMS ((char *));
d430 9
a438 3
void (*create_breakpoint_hook) PARAMS ((struct breakpoint *bpt));
void (*delete_breakpoint_hook) PARAMS ((struct breakpoint *bpt));
void (*modify_breakpoint_hook) PARAMS ((struct breakpoint *bpt));
d452 1
a452 1
   that several registers have changed (see value_assign).*/
d461 1
a461 1
int (*target_wait_hook) PARAMS ((int pid, struct target_waitstatus *status));
d466 1
a466 1
void (*call_command_hook) PARAMS ((struct cmd_list_element *c, char *cmd,
d469 5
d481 15
a495 1
NORETURN void (*error_hook) PARAMS ((void)) ATTR_NORETURN;
a496 1

d498 1
a498 1
SIGJMP_BUF error_return;
d500 1
a500 1
SIGJMP_BUF quit_return;
d514 1
a514 1
  bpstat_clear_actions(stop_bpstat);	/* Clear queued breakpoint commands */
d518 4
d557 19
d597 1
a597 1
      memcpy ((char *)saved_error, (char *)error_return, sizeof (SIGJMP_BUF));
d613 8
d640 35
d680 1
a680 1
int signo;
d683 1
a683 1
		"Could not kill the program being debugged", RETURN_MASK_ALL);
d690 4
a693 1
static int
d697 3
a699 3
  caution = 0;		/* Throw caution to the wind -- we're exiting.
			   This prevents asking the user dumb questions.  */
  quit_command((char *)0, 0);
d705 4
a708 1
static int source_line_number;
d711 4
a714 1
static char *source_file_name;
d718 4
a721 1
static char *source_error;
d726 4
a729 1
static char *source_pre_error;
d771 9
a779 3
  init_cmd_lists ();	/* This needs to be done first */
  initialize_targets (); /* Setup target_terminal macros for utils.c */
  initialize_utils ();	/* Make errors and warnings possible */
d781 2
a782 2
  init_main ();		/* But that omits this file!  Do it now */
  init_signals ();
d784 8
a791 1
  init_proc ();
d797 6
a802 1
  expected_language = current_language;	/* don't warn about the change.  */
d821 1
a821 1
  cmd = (struct command_line *)xmalloc (sizeof (struct command_line));
d827 2
a828 2
    = (struct command_line **)xmalloc (sizeof (struct command_line *)
				       * cmd->body_count);
d863 91
d955 1
a955 1
print_command_line (cmd, depth)
d958 1
d965 1
a965 1
	fputs_filtered ("  ", gdb_stdout);
d971 2
a972 2
      fputs_filtered (cmd->line, gdb_stdout);
      fputs_filtered ("\n", gdb_stdout);
d980 1
a980 1
      fputs_filtered ("loop_continue\n", gdb_stdout);
d987 1
a987 1
      fputs_filtered ("loop_break\n", gdb_stdout);
d995 3
a997 3
      fputs_filtered ("while ", gdb_stdout);
      fputs_filtered (cmd->line, gdb_stdout);
      fputs_filtered ("\n", gdb_stdout);
d1001 1
a1001 1
	  print_command_line (list, depth + 1);
d1009 3
a1011 3
      fputs_filtered ("if ", gdb_stdout);
      fputs_filtered (cmd->line, gdb_stdout);
      fputs_filtered ("\n", gdb_stdout);
d1013 1
a1013 1
      print_command_line (cmd->body_list[0], depth + 1);
d1017 9
a1025 9
	  {
	    if (depth)
	      {
		for (i = 0; i < depth; i++)
		  fputs_filtered ("  ", gdb_stdout);
	      }
	    fputs_filtered ("else\n", gdb_stdout);
	    print_command_line (cmd->body_list[1], depth + 1);
	  }
d1029 1
a1029 1
	    fputs_filtered ("  ", gdb_stdout);
d1031 1
a1031 1
      fputs_filtered ("end\n", gdb_stdout);
d1034 1
d1058 2
a1059 2
      old_chain = make_cleanup ((make_cleanup_func) free_current_contents, 
                                &new_line);
d1067 1
a1067 1
	 continue the loop at the top, or break out.  */
d1077 2
a1078 2
	old_chain = make_cleanup ((make_cleanup_func) free_current_contents, 
                                  &new_line);
d1081 1
a1081 1
	
d1120 1
a1120 1
		
d1122 1
a1122 1
		current = current->next; 
d1138 2
a1139 2
	old_chain = make_cleanup ((make_cleanup_func) free_current_contents, 
                                  &new_line);
d1232 1
a1232 1
    fatal ("Internal error, arg_cleanup called with no user args.\n");
d1249 1
a1249 1
  args = (struct user_args *)xmalloc (sizeof (struct user_args));
d1354 1
a1354 1
      
d1368 1
a1368 1
  new_line = (char *)xmalloc (len + 1);
d1456 1
a1456 1
      return;
d1460 2
a1461 1
  while (*p == ' ' || *p == '\t') p++;
d1467 10
d1491 1
a1491 1
	execute_user_command (c->hook, (char *)0);
d1503 1
a1503 1
   }
d1507 6
a1512 3
  {
    if (language_mode == language_mode_auto) {
      language_info (1);	/* Print what changed.  */
a1513 2
    warned = 0;
  }
d1535 4
a1538 1
static void
d1566 1
a1566 1
	(*window_hook) (instream, prompt);
d1583 2
a1584 1
      command = command_line_input (instream == stdin ? prompt : (char *) NULL,
d1633 36
d1687 1
a1687 1
   It prints PRROMPT once at the start.
d1693 2
a1694 2
gdb_readline (prrompt)
     char *prrompt;
d1701 1
a1701 1
  if (prrompt)
d1704 3
a1706 3
	 character position to be off, since the newline we read from
	 the user is not accounted for.  */
      fputs_unfiltered (prrompt, gdb_stdout);
d1709 1
a1709 1
	 on the front of it. */
d1720 1
a1720 1
	 This is the right thing for prompt_for_continue, at least.  */
d1761 4
a1764 1
static int history_expansion_p;
d1782 1
a1782 1
  " \t\n!@@#$%^&*()+=|~`}{[]\"';:?/>.<,-";
d1790 1
a1790 1
  " \t\n!@@#$%^&*()+=|~`}{[]\"';:?/>.<,";
d1796 1
a1796 1
  "'";
d1847 1
a1847 1
	 in the "source" command.  */
d1908 1
a1908 1
   */
d1938 2
a1939 2
  static char **list = (char **)NULL;		/* Cache of completions */
  static int index;				/* Next cached completion */
d1949 2
a1950 2
	 we need to find all of them now, and cache them for returning one at
	 a time on future calls. */
d1956 1
a1956 1
	  free ((PTR)list);
d1962 5
a1966 5
	 If we later find out that we are doing completions on command strings
	 (as opposed to strings supplied by the individual command completer
	 functions, which can be any string) then we will switch to the
	 special word break set for command strings, which leaves out the
	 '-' character used in some commands.  */
d1969 1
a1969 1
	  gdb_completer_word_break_characters;
d1978 2
a1979 2
	 to point, we can find the equivalent position in tmp_command
	 by subtracting that many characters from the end of tmp_command.  */
d2018 4
a2021 4
		 command, so there are no possible completions.  For
		 example, "info t " or "info t foo" does not complete
		 to anything, because "info t" can be "info target" or
		 "info terminal".  */
d2027 1
a2027 1
		 This we can deal with.  */
d2038 1
a2038 1
		 inserting quotes.  */
d2058 1
a2058 1
			 a subcommand (e.g. "info ").  */
d2062 1
a2062 1
			 with respect to inserting quotes.  */
d2075 1
a2075 1
			 completed by the command's completer function.  */
d2201 1
a2202 1

d2206 1
a2206 1
int signo;
d2216 1
a2216 1
  printf_unfiltered ("%s", prompt);
d2227 1
a2227 1
int signo;
d2285 2
a2286 2
command_line_input (prrompt, repeat, annotation_suffix)
     char *prrompt;
d2295 1
a2295 1
  char *local_prompt = prrompt;
d2305 1
a2305 1
      local_prompt = alloca ((prrompt == NULL ? 0 : strlen (prrompt))
d2307 1
a2307 1
      if (prrompt == NULL)
d2310 1
a2310 1
	strcpy (local_prompt, prrompt);
d2329 6
a2334 1
    signal (STOP_SIGNAL, stop_sig);
d2340 1
a2340 1
	 you get away with leaving out some of the gdb_flush, but not all.  */
d2389 1
a2389 1
      if (strlen(rl) + 1 + (p - linebuffer) > linelength)
d2391 1
a2391 1
	  linelength = strlen(rl) + 1 + (p - linebuffer);
d2402 1
a2402 1
      free (rl);			/* Allocated in readline.  */
d2409 1
a2409 1
  }
d2423 1
a2423 1
      && STREQN (linebuffer, "server ", SERVER_COMMAND_LENGTH);
d2427 2
a2428 2
	 dont_repeat, this insures that repeating will still do the
	 right thing.  */
d2451 1
a2451 1
	      return command_line_input (prrompt, repeat, annotation_suffix);
d2459 1
a2459 1
	  p = linebuffer + strlen(linebuffer);
d2469 1
a2469 1
  for (p1 = linebuffer; *p1 == ' ' || *p1 == '\t'; p1++) ;
d2487 1
a2487 1
    *p1 = '\0';  /* Found a comment. */
d2552 2
a2553 2
      control_prompt[i+1] = '\0';
      prompt_ptr = (char *)&control_prompt[0];
d2577 1
a2577 1
      
d2622 1
a2622 1
  }
d2686 1
a2686 1
      
d2722 1
a2722 1
	 on it.  */
d2748 3
a2750 3
read_command_lines (prompt, from_tty)
char *prompt;
int from_tty;
d2757 1
d2761 1
a2761 1
      (*readline_begin_hook) ("%s  %s\n", prompt, END_MESSAGE);
d2765 1
a2765 1
      printf_unfiltered ("%s\n%s\n", prompt, END_MESSAGE);
d2802 1
a2802 1
      
d2810 2
a2811 2
	  old_chain = make_cleanup ((make_cleanup_func) free_command_lines, 
                                    &head);
d2839 1
a2839 1
      struct command_line **lptr;
d2856 1
a2856 1
      free ((PTR)l);
d2969 1
a2969 1
     int from_tty; /* Ignored */
d2986 1
a2986 1
      if (!isalnum(*p) && *p != '-' && *p != '_')
d3036 1
a3036 1
      tem = comname+HOOK_LEN;
d3038 1
a3038 1
      if (hookc && !STREQ (comname+HOOK_LEN, hookc->name))
d3054 2
a3055 1
    if (isupper(*tem)) *tem = tolower(*tem);
a3056 1
  control_level = 0;
d3064 2
a3065 2
	   (c && c->class == class_user)
	   ? c->doc : savestring ("User-defined.", 13), &cmdlist);
d3097 2
a3098 1
  if (c->doc) free (c->doc);
d3124 1
a3124 1
  GDB_FILE *stream;
d3130 4
d3135 1
d3178 3
a3180 2
/* xgdb calls this to reprint the usual GDB prompt.  Obsolete now that xgdb
   is obsolete.  */
d3182 15
a3196 2
void
print_prompt ()
d3198 223
a3420 2
  printf_unfiltered ("%s", prompt);
  gdb_flush (gdb_stdout);
a3422 2
/* This replaces the above for the frontends: it returns a pointer
   to the prompt. */
d3426 15
a3440 1
  return prompt;
d3449 7
a3455 4
  if (prompt != NULL)
    free (prompt);
*/
  prompt = savestring (s, strlen (s));
d3457 1
a3458 1

d3470 2
a3471 2
	 see if a GUI is running.  The `use_windows' variable doesn't
	 cut it.  */
d3479 1
a3479 1
      if (! query (s))
d3519 1
a3519 1
  do_final_cleanups(ALL_CLEANUPS);	/* Do any final cleanups before exiting */
d3528 1
a3528 1
    tuiCleanUp();
d3541 1
a3541 1
  if (! quit_confirm ())
d3561 2
a3562 1
  if (args) error ("The \"pwd\" command does not take an argument: %s", args);
d3567 1
a3567 1
	    current_directory, gdb_dirbuf);
d3595 7
d3603 14
a3616 2
  dir = savestring (dir, len - (len > 1 && SLASH_P(dir[len-1])));
  if (ROOTED_P(dir))
d3620 1
a3620 1
      if (SLASH_P (current_directory[0]) && current_directory[1] == '\0')
d3640 1
a3640 1
		 and obliterate it and the "/..".  */
d3642 1
a3642 1
	      while (q != current_directory && ! SLASH_P (q[-1]))
d3673 2
a3674 1
struct source_cleanup_lines_args {
d3686 1
a3686 1
    (struct source_cleanup_lines_args *)args;
d3715 6
a3720 4
    if (from_tty)
      perror_with_name (file);
    else
      return;
d3793 2
a3794 2
  *line = 0;		/* Can't call dont_repeat here because we're not
			   necessarily reading from stdin.  */
d3861 1
a3861 1
	      (history_get (history_base + offset))->line);
d3945 1
a3945 1
int signo;
d3952 1
a3953 1

a3970 1
#if MAINTENANCE_CMDS
a3973 1
#endif
d3987 1
a3987 1
init_history()
d4001 13
a4013 7
    history_filename = savestring (tmpenv, strlen(tmpenv));
  else if (!history_filename) {
    /* We include the current directory so that if the user changes
       directories the file written will be the same as the one
       that was read.  */
    history_filename = concat (current_directory, "/.gdb_history", NULL);
  }
d4022 21
a4042 5
#ifdef DEFAULT_PROMPT
  prompt = savestring (DEFAULT_PROMPT, strlen(DEFAULT_PROMPT));
#else
  prompt = savestring ("(gdb) ", 6);
#endif
d4086 1
a4086 1
	   "Print working directory.  This is used for your program as well.");
d4088 1
a4088 1
	   "Set working directory to DIR for debugger and program being debugged.\n\
d4093 21
d4115 4
a4118 3
    (add_set_cmd ("prompt", class_support, var_string, (char *)&prompt,
	   "Set gdb's prompt",
	   &setlist),
d4142 1
a4142 1
	   "Read commands from a file named FILE.\n\
d4148 1
a4148 1
	   "Read commands from a file named FILE.\n\
d4163 1
a4163 1
  c = add_set_cmd ("verbose", class_support, var_boolean, (char *)&info_verbose,
d4166 1
a4166 1
  add_show_from_set (c, &showlist);
d4170 8
a4177 3
  add_show_from_set
    (add_set_cmd ("editing", class_support, var_boolean, (char *)&command_editing_p,
	   "Set editing of command lines as they are typed.\n\
d4181 13
a4193 1
     &showlist);
d4203 2
a4204 2
    (add_set_cmd ("expansion", no_class, var_boolean, (char *)&history_expansion_p,
	   "Set history expansion on command input.\n\
d4209 2
a4210 2
    (add_set_cmd ("save", no_class, var_boolean, (char *)&write_history_p,
	   "Set saving of the history record on exit.\n\
d4215 1
a4215 1
  c = add_set_cmd ("size", no_class, var_integer, (char *)&history_size,
d4222 2
a4223 2
    (add_set_cmd ("filename", no_class, var_filename, (char *)&history_filename,
	   "Set the filename in which to record the command history\n\
d4229 1
a4229 1
		  (char *)&caution,
d4235 1
a4235 1
        "Generic command for showing things about the program being debugged.",
d4258 1
a4258 1
"Execute nested commands WHILE the conditional expression is non zero.\n\
d4264 1
a4264 1
"Execute nested commands once IF the conditional expression is non zero.\n\
d4273 1
a4273 1
				  var_zinteger, (char *)&baud_rate,
d4280 2
a4281 2
    add_set_cmd ("remotedebug", no_class, var_zinteger, (char *)&remote_debug,
		   "Set debugging of remote protocol.\n\
d4284 1
a4284 1
		     &showlist);
d4287 2
a4288 2
    add_set_cmd ("remotetimeout", no_class, var_integer, (char *)&remote_timeout,
		   "Set timeout limit to wait for target to respond.\n\
d4291 1
a4291 1
		     &showlist);
d4293 8
a4300 2
  c = add_set_cmd ("annotate", class_obscure, var_zinteger, 
		   (char *)&annotation_level, "Set annotation_level.\n\
d4303 21
a4323 2
		 &setlist);
  c = add_show_from_set (c, &showlist);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d35 1
d248 1
d250 1
d254 1
d256 1
d260 1
d262 1
d370 3
a372 6

/* This hook is called from within gdb's many mini-event loops which could
   steal control from a real user interface's event loop. It returns
   non-zero if the user is requesting a detach, zero otherwise. */

int (*ui_loop_hook) PARAMS ((int));
a2473 1
  control_level = 0; 
d2772 1
d3154 4
a3157 6
    {
      if (from_tty)
	perror_with_name (file);
      else
	return;
    }
d3408 1
d3412 1
@


1.1.1.3
log
@import gdb-1999-05-10
@
text
@a35 1
#include "event-loop.h"
d73 1
a73 10
/* NOTE 4/29/99: this function will be static again, after we make the
   event loop be the default command loop for gdb, and we merge
   event-top.c into this file, top.c */
/* static */ void command_loop_marker PARAMS ((int));

extern void set_async_editing_command PARAMS ((char *, int, struct cmd_list_element *));
 
extern void set_async_annotation_level PARAMS ((char *, int, struct cmd_list_element *));

extern void set_async_prompt PARAMS ((char *, int, struct cmd_list_element *));
d142 1
a142 4
/* NOTE 4/29/99: This function will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c */
/* static */ int quit_cover PARAMS ((PTR));
d589 1
a589 4
/* NOTE 4/29/99: This function will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c */
/* static */ int
d601 1
a601 4
/* NOTE 4/29/99: This variable will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c */
/* static */ int source_line_number;
d604 1
a604 4
/* NOTE 4/29/99: This variable will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c */
/* static */ char *source_file_name;
d608 1
a608 4
/* NOTE 4/29/99: This variable will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c */
/* static */ char *source_error;
d613 1
a613 4
/* NOTE 4/29/99: This variable will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c */
/* static */ char *source_pre_error;
d660 1
a660 9

  /* The signal handling mechanism is different depending whether or
     not the async version is run. NOTE: in the future we plan to make
     the event loop be the default engine of gdb, and this difference
     will disappear. */
  if (async_hook)
    async_init_signals ();
  else
    init_signals ();
d1296 1
a1296 4
/* NOTE 4/29/99: This function will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c */
/* static */ void
d1482 1
a1482 4
/* NOTE 4/29/99: This variable will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c */
/* static */ int history_expansion_p;
a3450 10
 /* from event-top.c */
  extern int async_command_editing_p;
  extern struct prompts the_prompts;
  extern char *async_annotation_suffix;
  extern char *new_async_prompt;

  /* If we are running the asynchronous version,
     we initialize the prompts differently. */
  if (!async_hook)
    {
d3452 1
a3452 1
      prompt = savestring (DEFAULT_PROMPT, strlen(DEFAULT_PROMPT));
d3454 1
a3454 1
      prompt = savestring ("(gdb) ", 6);
a3455 19
    }
  else
    {
      /* initialize the prompt stack to a simple "(gdb) " prompt or to
	 whatever the DEFULAT_PROMPT is. */
      the_prompts.top = 0;
      PREFIX(0) = "";
#ifdef DEFAULT_PROMPT
      PROMPT(0) = savestring (DEFAULT_PROMPT, strlen(DEFAULT_PROMPT));
#else
      PROMPT(0) = savestring ("(gdb) ", 6);
#endif
      SUFFIX(0) = "";
      /* Set things up for annotation_level > 1, if the user ever decides
	 to use it. */
      async_annotation_suffix = "prompt";
      /* Set the variable associated with the setshow prompt command. */
      new_async_prompt = savestring (PROMPT (0), strlen (PROMPT (0)));
    }
a3458 1
  async_command_editing_p = 1;
d3506 5
a3510 21
  /* The set prompt command is different depending whether or not the
     async version is run. NOTE: this difference is going to
     disappear as we make the event loop be the default engine of
     gdb. */
  if (!async_hook)
    {
      add_show_from_set
	(add_set_cmd ("prompt", class_support, var_string, (char *)&prompt,
		      "Set gdb's prompt",
		      &setlist),
	 &showlist);
    }
  else
    {
      c = add_set_cmd ("prompt", class_support, var_string, 
		      (char *)&new_async_prompt,
		      "Set gdb's prompt",
		       &setlist);
      add_show_from_set (c, &showlist);
      c->function.sfunc = set_async_prompt;
    }
d3561 3
a3563 8
  /* The set editing command is different depending whether or not the
     async version is run. NOTE: this difference is going to disappear
     as we make the event loop be the default engine of gdb. */
  if (!async_hook)
    {
      add_show_from_set
	(add_set_cmd ("editing", class_support, var_boolean, (char *)&command_editing_p,
		      "Set editing of command lines as they are typed.\n\
d3567 1
a3567 13
	 &showlist);
    }
  else
    {
      c = add_set_cmd ("editing", class_support, var_boolean, (char *)&async_command_editing_p,
		       "Set editing of command lines as they are typed.\n\
Use \"on\" to enable the editing, and \"off\" to disable it.\n\
Without an argument, command line editing is enabled.  To edit, use\n\
EMACS-like or VI-like commands like control-P or ESC.", &setlist);

      add_show_from_set (c, &showlist);
      c->function.sfunc = set_async_editing_command;
    }
d3667 2
a3668 17
  /* The set annotate command is different depending whether or not
     the async version is run. NOTE: this difference is going to
     disappear as we make the event loop be the default engine of
     gdb. */
  if (!async_hook)
    {
      c = add_set_cmd ("annotate", class_obscure, var_zinteger, 
		       (char *)&annotation_level, "Set annotation_level.\n\
0 == normal;     1 == fullname (for use when running under emacs)\n\
2 == output annotated suitably for use by programs that control GDB.",
		       &setlist);
      c = add_show_from_set (c, &showlist);
    }
  else
    {
      c = add_set_cmd ("annotate", class_obscure, var_zinteger, 
		       (char *)&annotation_level, "Set annotation_level.\n\
d3671 2
a3672 4
		       &setlist);     
      add_show_from_set (c, &showlist);
      c->function.sfunc = set_async_annotation_level;
    }
@


1.1.1.4
log
@import gdb-1999-0519
@
text
@d766 1
a766 1
print_command_line (cmd, depth, stream)
a768 1
     GDB_FILE *stream;
d775 1
a775 1
	fputs_filtered ("  ", stream);
d781 2
a782 2
      fputs_filtered (cmd->line, stream);
      fputs_filtered ("\n", stream);
d790 1
a790 1
      fputs_filtered ("loop_continue\n", stream);
d797 1
a797 1
      fputs_filtered ("loop_break\n", stream);
d805 3
a807 3
      fputs_filtered ("while ", stream);
      fputs_filtered (cmd->line, stream);
      fputs_filtered ("\n", stream);
d811 1
a811 1
	  print_command_line (list, depth + 1, stream);
d819 3
a821 3
      fputs_filtered ("if ", stream);
      fputs_filtered (cmd->line, stream);
      fputs_filtered ("\n", stream);
d823 1
a823 1
      print_command_line (cmd->body_list[0], depth + 1, stream);
d831 1
a831 1
		  fputs_filtered ("  ", stream);
d833 2
a834 2
	    fputs_filtered ("else\n", stream);
	    print_command_line (cmd->body_list[1], depth + 1, stream);
d839 1
a839 1
	    fputs_filtered ("  ", stream);
d841 1
a841 1
      fputs_filtered ("end\n", stream);
@


1.1.1.5
log
@import gdb-1999-05-25 snapshot
@
text
@d54 2
d74 1
a74 1
/* NOTE 1999-04-29: this function will be static again, after we make the
d79 6
d152 1
a152 1
/* NOTE 1999-04-29: This function will be static again, once we modify
d602 1
a602 1
/* NOTE 1999-04-29: This function will be static again, once we modify
d617 1
a617 1
/* NOTE 1999-04-29: This variable will be static again, once we modify
d623 1
a623 1
/* NOTE 1999-04-29: This variable will be static again, once we modify
d630 1
a630 1
/* NOTE 1999-04-29: This variable will be static again, once we modify
d638 1
a638 1
/* NOTE 1999-04-29: This variable will be static again, once we modify
d698 2
d1333 1
a1333 1
/* NOTE 1999-04-29: This function will be static again, once we modify
a1429 1

d1522 1
a1522 1
/* NOTE 1999-04-29: This variable will be static again, once we modify
@


1.1.1.6
log
@import gdb-1999-06-14 snapshot
@
text
@d293 1
a293 2
static char *gdb_prompt_string;		/* the global prompt string */
extern char *get_prompt PARAMS((void));	/* access function for prompt string */
d655 1
a655 1
  command_loop (); 
d685 1
a685 1
  if (async_p)
d688 1
a688 1
    init_signals (); 
a695 2
  /* All the interpreters should have had a look at things by now.
     Initialize the selected interpreter. */
d1354 1
a1354 1
	(*window_hook) (instream, get_prompt ());
d1371 1
a1371 2
      command = command_line_input (instream == stdin ? 
				    get_prompt () : (char *) NULL,
d1421 2367
@


1.1.1.7
log
@import gdb-1999-06-21 snapshot
@
text
@d36 1
a49 1
#include "event-loop.h"
a1424 2620

/* Commands call this if they do not want to be repeated by null lines.  */

void
dont_repeat ()
{
  if (server_command)
    return;

  /* If we aren't reading from standard input, we are saving the last
     thing read from stdin in line and don't want to delete it.  Null lines
     won't repeat here in any case.  */
  if (instream == stdin)
    *line = 0;
}

/* Read a line from the stream "instream" without command line editing.

   It prints PROMPT_ARG once at the start.
   Action is compatible with "readline", e.g. space for the result is
   malloc'd and should be freed by the caller.

   A NULL return means end of file.  */
char *
gdb_readline (prompt_arg)
     char *prompt_arg;
{
  int c;
  char *result;
  int input_index = 0;
  int result_size = 80;

  if (prompt_arg)
    {
      /* Don't use a _filtered function here.  It causes the assumed
	 character position to be off, since the newline we read from
	 the user is not accounted for.  */
      fputs_unfiltered (prompt_arg, gdb_stdout);
#ifdef MPW
      /* Move to a new line so the entered line doesn't have a prompt
	 on the front of it. */
      fputs_unfiltered ("\n", gdb_stdout);
#endif /* MPW */
      gdb_flush (gdb_stdout);
    }

  result = (char *) xmalloc (result_size);

  while (1)
    {
      /* Read from stdin if we are executing a user defined command.
	 This is the right thing for prompt_for_continue, at least.  */
      c = fgetc (instream ? instream : stdin);

      if (c == EOF)
	{
	  if (input_index > 0)
	    /* The last line does not end with a newline.  Return it, and
	       if we are called again fgetc will still return EOF and
	       we'll return NULL then.  */
	    break;
	  free (result);
	  return NULL;
	}

      if (c == '\n')
#ifndef CRLF_SOURCE_FILES
	break;
#else
	{
	  if (input_index > 0 && result[input_index - 1] == '\r')
	    input_index--;
	  break;
	}
#endif

      result[input_index++] = c;
      while (input_index >= result_size)
	{
	  result_size *= 2;
	  result = (char *) xrealloc (result, result_size);
	}
    }

  result[input_index++] = '\0';
  return result;
}

/* Variables which control command line editing and history
   substitution.  These variables are given default values at the end
   of this file.  */
static int command_editing_p;
/* NOTE 1999-04-29: This variable will be static again, once we modify
   gdb to use the event loop as the default command loop and we merge
   event-top.c into this file, top.c */
/* static */ int history_expansion_p;
static int write_history_p;
static int history_size;
static char *history_filename;

/* readline uses the word breaks for two things:
   (1) In figuring out where to point the TEXT parameter to the
   rl_completion_entry_function.  Since we don't use TEXT for much,
   it doesn't matter a lot what the word breaks are for this purpose, but
   it does affect how much stuff M-? lists.
   (2) If one of the matches contains a word break character, readline
   will quote it.  That's why we switch between
   gdb_completer_word_break_characters and
   gdb_completer_command_word_break_characters.  I'm not sure when
   we need this behavior (perhaps for funky characters in C++ symbols?).  */

/* Variables which are necessary for fancy command line editing.  */
char *gdb_completer_word_break_characters =
  " \t\n!@@#$%^&*()+=|~`}{[]\"';:?/>.<,-";

/* When completing on command names, we remove '-' from the list of
   word break characters, since we use it in command names.  If the
   readline library sees one in any of the current completion strings,
   it thinks that the string needs to be quoted and automatically supplies
   a leading quote. */
char *gdb_completer_command_word_break_characters =
  " \t\n!@@#$%^&*()+=|~`}{[]\"';:?/>.<,";

/* Characters that can be used to quote completion strings.  Note that we
   can't include '"' because the gdb C parser treats such quoted sequences
   as strings. */
char *gdb_completer_quote_characters =
  "'";

/* Functions that are used as part of the fancy command line editing.  */

/* This can be used for functions which don't want to complete on symbols
   but don't want to complete on anything else either.  */
/* ARGSUSED */
char **
noop_completer (text, prefix)
     char *text;
     char *prefix;
{
  return NULL;
}

/* Complete on filenames.  */
char **
filename_completer (text, word)
     char *text;
     char *word;
{
  /* From readline.  */
  extern char *filename_completion_function PARAMS ((char *, int));
  int subsequent_name;
  char **return_val;
  int return_val_used;
  int return_val_alloced;

  return_val_used = 0;
  /* Small for testing.  */
  return_val_alloced = 1;
  return_val = (char **) xmalloc (return_val_alloced * sizeof (char *));

  subsequent_name = 0;
  while (1)
    {
      char *p;
      p = filename_completion_function (text, subsequent_name);
      if (return_val_used >= return_val_alloced)
	{
	  return_val_alloced *= 2;
	  return_val =
	    (char **) xrealloc (return_val,
				return_val_alloced * sizeof (char *));
	}
      if (p == NULL)
	{
	  return_val[return_val_used++] = p;
	  break;
	}
      /* Like emacs, don't complete on old versions.  Especially useful
	 in the "source" command.  */
      if (p[strlen (p) - 1] == '~')
	continue;

      {
	char *q;
	if (word == text)
	  /* Return exactly p.  */
	  return_val[return_val_used++] = p;
	else if (word > text)
	  {
	    /* Return some portion of p.  */
	    q = xmalloc (strlen (p) + 5);
	    strcpy (q, p + (word - text));
	    return_val[return_val_used++] = q;
	    free (p);
	  }
	else
	  {
	    /* Return some of TEXT plus p.  */
	    q = xmalloc (strlen (p) + (text - word) + 5);
	    strncpy (q, word, text - word);
	    q[text - word] = '\0';
	    strcat (q, p);
	    return_val[return_val_used++] = q;
	    free (p);
	  }
      }
      subsequent_name = 1;
    }
#if 0
  /* There is no way to do this just long enough to affect quote inserting
     without also affecting the next completion.  This should be fixed in
     readline.  FIXME.  */
  /* Insure that readline does the right thing
     with respect to inserting quotes.  */
  rl_completer_word_break_characters = "";
#endif
  return return_val;
}

/* Here are some useful test cases for completion.  FIXME: These should
   be put in the test suite.  They should be tested with both M-? and TAB.

   "show output-" "radix"
   "show output" "-radix"
   "p" ambiguous (commands starting with p--path, print, printf, etc.)
   "p "  ambiguous (all symbols)
   "info t foo" no completions
   "info t " no completions
   "info t" ambiguous ("info target", "info terminal", etc.)
   "info ajksdlfk" no completions
   "info ajksdlfk " no completions
   "info" " "
   "info " ambiguous (all info commands)
   "p \"a" no completions (string constant)
   "p 'a" ambiguous (all symbols starting with a)
   "p b-a" ambiguous (all symbols starting with a)
   "p b-" ambiguous (all symbols)
   "file Make" "file" (word break hard to screw up here)
   "file ../gdb.stabs/we" "ird" (needs to not break word at slash)
   */

/* Generate completions one by one for the completer.  Each time we are
   called return another potential completion to the caller.
   line_completion just completes on commands or passes the buck to the
   command's completer function, the stuff specific to symbol completion
   is in make_symbol_completion_list.

   TEXT is the caller's idea of the "word" we are looking at.

   MATCHES is the number of matches that have currently been collected from
   calling this completion function.  When zero, then we need to initialize,
   otherwise the initialization has already taken place and we can just
   return the next potential completion string.

   LINE_BUFFER is available to be looked at; it contains the entire text
   of the line.  POINT is the offset in that line of the cursor.  You
   should pretend that the line ends at POINT.

   Returns NULL if there are no more completions, else a pointer to a string
   which is a possible completion, it is the caller's responsibility to
   free the string.  */

static char *
line_completion_function (text, matches, line_buffer, point)
     char *text;
     int matches;
     char *line_buffer;
     int point;
{
  static char **list = (char **)NULL;		/* Cache of completions */
  static int index;				/* Next cached completion */
  char *output = NULL;
  char *tmp_command, *p;
  /* Pointer within tmp_command which corresponds to text.  */
  char *word;
  struct cmd_list_element *c, *result_list;

  if (matches == 0)
    {
      /* The caller is beginning to accumulate a new set of completions, so
	 we need to find all of them now, and cache them for returning one at
	 a time on future calls. */

      if (list)
	{
	  /* Free the storage used by LIST, but not by the strings inside.
	     This is because rl_complete_internal () frees the strings. */
	  free ((PTR)list);
	}
      list = 0;
      index = 0;

      /* Choose the default set of word break characters to break completions.
	 If we later find out that we are doing completions on command strings
	 (as opposed to strings supplied by the individual command completer
	 functions, which can be any string) then we will switch to the
	 special word break set for command strings, which leaves out the
	 '-' character used in some commands.  */

      rl_completer_word_break_characters =
	  gdb_completer_word_break_characters;

      /* Decide whether to complete on a list of gdb commands or on symbols. */
      tmp_command = (char *) alloca (point + 1);
      p = tmp_command;

      strncpy (tmp_command, line_buffer, point);
      tmp_command[point] = '\0';
      /* Since text always contains some number of characters leading up
	 to point, we can find the equivalent position in tmp_command
	 by subtracting that many characters from the end of tmp_command.  */
      word = tmp_command + point - strlen (text);

      if (point == 0)
	{
	  /* An empty line we want to consider ambiguous; that is, it
	     could be any command.  */
	  c = (struct cmd_list_element *) -1;
	  result_list = 0;
	}
      else
	{
	  c = lookup_cmd_1 (&p, cmdlist, &result_list, 1);
	}

      /* Move p up to the next interesting thing.  */
      while (*p == ' ' || *p == '\t')
	{
	  p++;
	}

      if (!c)
	{
	  /* It is an unrecognized command.  So there are no
	     possible completions.  */
	  list = NULL;
	}
      else if (c == (struct cmd_list_element *) -1)
	{
	  char *q;

	  /* lookup_cmd_1 advances p up to the first ambiguous thing, but
	     doesn't advance over that thing itself.  Do so now.  */
	  q = p;
	  while (*q && (isalnum (*q) || *q == '-' || *q == '_'))
	    ++q;
	  if (q != tmp_command + point)
	    {
	      /* There is something beyond the ambiguous
		 command, so there are no possible completions.  For
		 example, "info t " or "info t foo" does not complete
		 to anything, because "info t" can be "info target" or
		 "info terminal".  */
	      list = NULL;
	    }
	  else
	    {
	      /* We're trying to complete on the command which was ambiguous.
		 This we can deal with.  */
	      if (result_list)
		{
		  list = complete_on_cmdlist (*result_list->prefixlist, p,
					      word);
		}
	      else
		{
		  list = complete_on_cmdlist (cmdlist, p, word);
		}
	      /* Insure that readline does the right thing with respect to
		 inserting quotes.  */
	      rl_completer_word_break_characters =
		gdb_completer_command_word_break_characters;
	    }
	}
      else
	{
	  /* We've recognized a full command.  */

	  if (p == tmp_command + point)
	    {
	      /* There is no non-whitespace in the line beyond the command.  */

	      if (p[-1] == ' ' || p[-1] == '\t')
		{
		  /* The command is followed by whitespace; we need to complete
		     on whatever comes after command.  */
		  if (c->prefixlist)
		    {
		      /* It is a prefix command; what comes after it is
			 a subcommand (e.g. "info ").  */
		      list = complete_on_cmdlist (*c->prefixlist, p, word);

		      /* Insure that readline does the right thing
			 with respect to inserting quotes.  */
		      rl_completer_word_break_characters =
			gdb_completer_command_word_break_characters;
		    }
		  else if (c->enums)
		    {
		      list = complete_on_enum (c->enums, p, word);
		      rl_completer_word_break_characters =
			gdb_completer_command_word_break_characters;
		    }
		  else
		    {
		      /* It is a normal command; what comes after it is
			 completed by the command's completer function.  */
		      list = (*c->completer) (p, word);
		    }
		}
	      else
		{
		  /* The command is not followed by whitespace; we need to
		     complete on the command itself.  e.g. "p" which is a
		     command itself but also can complete to "print", "ptype"
		     etc.  */
		  char *q;

		  /* Find the command we are completing on.  */
		  q = p;
		  while (q > tmp_command)
		    {
		      if (isalnum (q[-1]) || q[-1] == '-' || q[-1] == '_')
			--q;
		      else
			break;
		    }

		  list = complete_on_cmdlist (result_list, q, word);

		  /* Insure that readline does the right thing
		     with respect to inserting quotes.  */
		  rl_completer_word_break_characters =
		    gdb_completer_command_word_break_characters;
		}
	    }
	  else
	    {
	      /* There is non-whitespace beyond the command.  */

	      if (c->prefixlist && !c->allow_unknown)
		{
		  /* It is an unrecognized subcommand of a prefix command,
		     e.g. "info adsfkdj".  */
		  list = NULL;
		}
	      else if (c->enums)
		{
		  list = complete_on_enum (c->enums, p, word);
		}
	      else
		{
		  /* It is a normal command.  */
		  list = (*c->completer) (p, word);
		}
	    }
	}
    }

  /* If we found a list of potential completions during initialization then
     dole them out one at a time.  The vector of completions is NULL
     terminated, so after returning the last one, return NULL (and continue
     to do so) each time we are called after that, until a new list is
     available. */

  if (list)
    {
      output = list[index];
      if (output)
	{
	  index++;
	}
    }

#if 0
  /* Can't do this because readline hasn't yet checked the word breaks
     for figuring out whether to insert a quote.  */
  if (output == NULL)
    /* Make sure the word break characters are set back to normal for the
       next time that readline tries to complete something.  */
    rl_completer_word_break_characters =
      gdb_completer_word_break_characters;
#endif

  return (output);
}

/* Line completion interface function for readline.  */

static char *
readline_line_completion_function (text, matches)
     char *text;
     int matches;
{
  return line_completion_function (text, matches, rl_line_buffer, rl_point);
}

/* Skip over a possibly quoted word (as defined by the quote characters
   and word break characters the completer uses).  Returns pointer to the
   location after the "word". */

char *
skip_quoted (str)
     char *str;
{
  char quote_char = '\0';
  char *scan;

  for (scan = str; *scan != '\0'; scan++)
    {
      if (quote_char != '\0')
	{
	  /* Ignore everything until the matching close quote char */
	  if (*scan == quote_char)
	    {
	      /* Found matching close quote. */
	      scan++;
	      break;
	    }
	}
      else if (strchr (gdb_completer_quote_characters, *scan))
	{
	  /* Found start of a quoted string. */
	  quote_char = *scan;
	}
      else if (strchr (gdb_completer_word_break_characters, *scan))
	{
	  break;
	}
    }
  return (scan);
}


#ifdef STOP_SIGNAL
static void
stop_sig (signo)
int signo;
{
#if STOP_SIGNAL == SIGTSTP
  signal (SIGTSTP, SIG_DFL);
  sigsetmask (0);
  kill (getpid (), SIGTSTP);
  signal (SIGTSTP, stop_sig);
#else
  signal (STOP_SIGNAL, stop_sig);
#endif
  printf_unfiltered ("%s", get_prompt ());
  gdb_flush (gdb_stdout);

  /* Forget about any previous command -- null line now will do nothing.  */
  dont_repeat ();
}
#endif /* STOP_SIGNAL */

/* Initialize signal handlers. */
static void
do_nothing (signo)
int signo;
{
  /* Under System V the default disposition of a signal is reinstated after
     the signal is caught and delivered to an application process.  On such
     systems one must restore the replacement signal handler if one wishes
     to continue handling the signal in one's program.  On BSD systems this
     is not needed but it is harmless, and it simplifies the code to just do
     it unconditionally. */
  signal (signo, do_nothing);
}

static void
init_signals ()
{
  signal (SIGINT, request_quit);

  /* If SIGTRAP was set to SIG_IGN, then the SIG_IGN will get passed
     to the inferior and breakpoints will be ignored.  */
#ifdef SIGTRAP
  signal (SIGTRAP, SIG_DFL);
#endif

  /* If we initialize SIGQUIT to SIG_IGN, then the SIG_IGN will get
     passed to the inferior, which we don't want.  It would be
     possible to do a "signal (SIGQUIT, SIG_DFL)" after we fork, but
     on BSD4.3 systems using vfork, that can affect the
     GDB process as well as the inferior (the signal handling tables
     might be in memory, shared between the two).  Since we establish
     a handler for SIGQUIT, when we call exec it will set the signal
     to SIG_DFL for us.  */
  signal (SIGQUIT, do_nothing);
#ifdef SIGHUP
  if (signal (SIGHUP, do_nothing) != SIG_IGN)
    signal (SIGHUP, disconnect);
#endif
  signal (SIGFPE, float_handler);

#if defined(SIGWINCH) && defined(SIGWINCH_HANDLER)
  signal (SIGWINCH, SIGWINCH_HANDLER);
#endif
}

/* Read one line from the command input stream `instream'
   into the local static buffer `linebuffer' (whose current length
   is `linelength').
   The buffer is made bigger as necessary.
   Returns the address of the start of the line.

   NULL is returned for end of file.

   *If* the instream == stdin & stdin is a terminal, the line read
   is copied into the file line saver (global var char *line,
   length linesize) so that it can be duplicated.

   This routine either uses fancy command line editing or
   simple input as the user has requested.  */

char *
command_line_input (prompt_arg, repeat, annotation_suffix)
     char *prompt_arg;
     int repeat;
     char *annotation_suffix;
{
  static char *linebuffer = 0;
  static unsigned linelength = 0;
  register char *p;
  char *p1;
  char *rl;
  char *local_prompt = prompt_arg;
  char *nline;
  char got_eof = 0;

  /* The annotation suffix must be non-NULL.  */
  if (annotation_suffix == NULL)
    annotation_suffix = "";

  if (annotation_level > 1 && instream == stdin)
    {
      local_prompt = alloca ((prompt_arg == NULL ? 0 : strlen (prompt_arg))
			     + strlen (annotation_suffix) + 40);
      if (prompt_arg == NULL)
	local_prompt[0] = '\0';
      else
	strcpy (local_prompt, prompt_arg);
      strcat (local_prompt, "\n\032\032");
      strcat (local_prompt, annotation_suffix);
      strcat (local_prompt, "\n");
    }

  if (linebuffer == 0)
    {
      linelength = 80;
      linebuffer = (char *) xmalloc (linelength);
    }

  p = linebuffer;

  /* Control-C quits instantly if typed while in this loop
     since it should not wait until the user types a newline.  */
  immediate_quit++;
#ifdef STOP_SIGNAL
  if (job_control)
    {
      if (async_p)
	signal (STOP_SIGNAL, handle_stop_sig);
      else
	signal (STOP_SIGNAL, stop_sig);
    }
#endif

  while (1)
    {
      /* Make sure that all output has been output.  Some machines may let
	 you get away with leaving out some of the gdb_flush, but not all.  */
      wrap_here ("");
      gdb_flush (gdb_stdout);
      gdb_flush (gdb_stderr);

      if (source_file_name != NULL)
	{
	  ++source_line_number;
	  sprintf (source_error,
		   "%s%s:%d: Error in sourced command file:\n",
		   source_pre_error,
		   source_file_name,
		   source_line_number);
	  error_pre_print = source_error;
	}

      if (annotation_level > 1 && instream == stdin)
	{
	  printf_unfiltered ("\n\032\032pre-");
	  printf_unfiltered (annotation_suffix);
	  printf_unfiltered ("\n");
	}

      /* Don't use fancy stuff if not talking to stdin.  */
      if (readline_hook && instream == NULL)
	{
	  rl = (*readline_hook) (local_prompt);
	}
      else if (command_editing_p && instream == stdin && ISATTY (instream))
	{
	  rl = readline (local_prompt);
	}
      else
	{
	  rl = gdb_readline (local_prompt);
	}

      if (annotation_level > 1 && instream == stdin)
	{
	  printf_unfiltered ("\n\032\032post-");
	  printf_unfiltered (annotation_suffix);
	  printf_unfiltered ("\n");
	}

      if (!rl || rl == (char *) EOF)
	{
	  got_eof = 1;
	  break;
	}
      if (strlen(rl) + 1 + (p - linebuffer) > linelength)
	{
	  linelength = strlen(rl) + 1 + (p - linebuffer);
	  nline = (char *) xrealloc (linebuffer, linelength);
	  p += nline - linebuffer;
	  linebuffer = nline;
	}
      p1 = rl;
      /* Copy line.  Don't copy null at end.  (Leaves line alone
         if this was just a newline)  */
      while (*p1)
	*p++ = *p1++;

      free (rl);			/* Allocated in readline.  */

      if (p == linebuffer || *(p - 1) != '\\')
	break;

      p--;			/* Put on top of '\'.  */
      local_prompt = (char *) 0;
  }

#ifdef STOP_SIGNAL
  if (job_control)
    signal (STOP_SIGNAL, SIG_DFL);
#endif
  immediate_quit--;

  if (got_eof)
    return NULL;

#define SERVER_COMMAND_LENGTH 7
  server_command =
    (p - linebuffer > SERVER_COMMAND_LENGTH)
      && STREQN (linebuffer, "server ", SERVER_COMMAND_LENGTH);
  if (server_command)
    {
      /* Note that we don't set `line'.  Between this and the check in
	 dont_repeat, this insures that repeating will still do the
	 right thing.  */
      *p = '\0';
      return linebuffer + SERVER_COMMAND_LENGTH;
    }

  /* Do history expansion if that is wished.  */
  if (history_expansion_p && instream == stdin
      && ISATTY (instream))
    {
      char *history_value;
      int expanded;

      *p = '\0';		/* Insert null now.  */
      expanded = history_expand (linebuffer, &history_value);
      if (expanded)
	{
	  /* Print the changes.  */
	  printf_unfiltered ("%s\n", history_value);

	  /* If there was an error, call this function again.  */
	  if (expanded < 0)
	    {
	      free (history_value);
	      return command_line_input (prompt_arg, repeat, annotation_suffix);
	    }
	  if (strlen (history_value) > linelength)
	    {
	      linelength = strlen (history_value) + 1;
	      linebuffer = (char *) xrealloc (linebuffer, linelength);
	    }
	  strcpy (linebuffer, history_value);
	  p = linebuffer + strlen(linebuffer);
	  free (history_value);
	}
    }

  /* If we just got an empty line, and that is supposed
     to repeat the previous command, return the value in the
     global buffer.  */
  if (repeat && p == linebuffer)
    return line;
  for (p1 = linebuffer; *p1 == ' ' || *p1 == '\t'; p1++) ;
  if (repeat && !*p1)
    return line;

  *p = 0;

  /* Add line to history if appropriate.  */
  if (instream == stdin
      && ISATTY (stdin) && *linebuffer)
    add_history (linebuffer);

  /* Note: lines consisting solely of comments are added to the command
     history.  This is useful when you type a command, and then
     realize you don't want to execute it quite yet.  You can comment
     out the command and then later fetch it from the value history
     and remove the '#'.  The kill ring is probably better, but some
     people are in the habit of commenting things out.  */
  if (*p1 == '#')
    *p1 = '\0';  /* Found a comment. */

  /* Save into global buffer if appropriate.  */
  if (repeat)
    {
      if (linelength > linesize)
	{
	  line = xrealloc (line, linelength);
	  linesize = linelength;
	}
      strcpy (line, linebuffer);
      return line;
    }

  return linebuffer;
}


/* Expand the body_list of COMMAND so that it can hold NEW_LENGTH
   code bodies.  This is typically used when we encounter an "else"
   clause for an "if" command.  */

static void
realloc_body_list (command, new_length)
     struct command_line *command;
     int new_length;
{
  int n;
  struct command_line **body_list;

  n = command->body_count;

  /* Nothing to do?  */
  if (new_length <= n)
    return;

  body_list = (struct command_line **)
    xmalloc (sizeof (struct command_line *) * new_length);

  memcpy (body_list, command->body_list, sizeof (struct command_line *) * n);

  free (command->body_list);
  command->body_list = body_list;
  command->body_count = new_length;
}

/* Read one line from the input stream.  If the command is an "else" or
   "end", return such an indication to the caller.  */

static enum misc_command_type
read_next_line (command)
     struct command_line **command;
{
  char *p, *p1, *prompt_ptr, control_prompt[256];
  int i = 0;

  if (control_level >= 254)
    error ("Control nesting too deep!\n");

  /* Set a prompt based on the nesting of the control commands.  */
  if (instream == stdin || (instream == 0 && readline_hook != NULL))
    {
      for (i = 0; i < control_level; i++)
	control_prompt[i] = ' ';
      control_prompt[i] = '>';
      control_prompt[i+1] = '\0';
      prompt_ptr = (char *)&control_prompt[0];
    }
  else
    prompt_ptr = NULL;

  p = command_line_input (prompt_ptr, instream == stdin, "commands");

  /* Not sure what to do here.  */
  if (p == NULL)
    return end_command;

  /* Strip leading and trailing whitespace.  */
  while (*p == ' ' || *p == '\t')
    p++;

  p1 = p + strlen (p);
  while (p1 != p && (p1[-1] == ' ' || p1[-1] == '\t'))
    p1--;

  /* Blanks and comments don't really do anything, but we need to
     distinguish them from else, end and other commands which can be
     executed.  */
  if (p1 == p || p[0] == '#')
    return nop_command;
      
  /* Is this the end of a simple, while, or if control structure?  */
  if (p1 - p == 3 && !strncmp (p, "end", 3))
    return end_command;

  /* Is the else clause of an if control structure?  */
  if (p1 - p == 4 && !strncmp (p, "else", 4))
    return else_command;

  /* Check for while, if, break, continue, etc and build a new command
     line structure for them.  */
  if (p1 - p > 5 && !strncmp (p, "while", 5))
    *command = build_command_line (while_control, p + 6);
  else if (p1 - p > 2 && !strncmp (p, "if", 2))
    *command = build_command_line (if_control, p + 3);
  else if (p1 - p == 10 && !strncmp (p, "loop_break", 10))
    {
      *command = (struct command_line *)
	xmalloc (sizeof (struct command_line));
      (*command)->next = NULL;
      (*command)->line = NULL;
      (*command)->control_type = break_control;
      (*command)->body_count = 0;
      (*command)->body_list = NULL;
    }
  else if (p1 - p == 13 && !strncmp (p, "loop_continue", 13))
    {
      *command = (struct command_line *)
	xmalloc (sizeof (struct command_line));
      (*command)->next = NULL;
      (*command)->line = NULL;
      (*command)->control_type = continue_control;
      (*command)->body_count = 0;
      (*command)->body_list = NULL;
    }
  else
    {
      /* A normal command.  */
      *command = (struct command_line *)
	xmalloc (sizeof (struct command_line));
      (*command)->next = NULL;
      (*command)->line = savestring (p, p1 - p);
      (*command)->control_type = simple_control;
      (*command)->body_count = 0;
      (*command)->body_list = NULL;
  }

  /* Nothing special.  */
  return ok_command;
}

/* Recursively read in the control structures and create a command_line 
   structure from them.

   The parent_control parameter is the control structure in which the
   following commands are nested.  */

static enum command_control_type
recurse_read_control_structure (current_cmd)
     struct command_line *current_cmd;
{
  int current_body, i;
  enum misc_command_type val;
  enum command_control_type ret;
  struct command_line **body_ptr, *child_tail, *next;

  child_tail = NULL;
  current_body = 1;

  /* Sanity checks.  */
  if (current_cmd->control_type == simple_control)
    {
      error ("Recursed on a simple control type\n");
      return invalid_control;
    }

  if (current_body > current_cmd->body_count)
    {
      error ("Allocated body is smaller than this command type needs\n");
      return invalid_control;
    }

  /* Read lines from the input stream and build control structures.  */
  while (1)
    {
      dont_repeat ();

      next = NULL;
      val = read_next_line (&next);

      /* Just skip blanks and comments.  */
      if (val == nop_command)
	continue;

      if (val == end_command)
	{
	  if (current_cmd->control_type == while_control
	      || current_cmd->control_type == if_control)
	    {
	      /* Success reading an entire control structure.  */
	      ret = simple_control;
	      break;
	    }
	  else
	    {
	      ret = invalid_control;
	      break;
	    }
	}
      
      /* Not the end of a control structure.  */
      if (val == else_command)
	{
	  if (current_cmd->control_type == if_control
	      && current_body == 1)
	    {
	      realloc_body_list (current_cmd, 2);
	      current_body = 2;
	      child_tail = NULL;
	      continue;
	    }
	  else
	    {
	      ret = invalid_control;
	      break;
	    }
	}

      if (child_tail)
	{
	  child_tail->next = next;
	}
      else
	{
	  body_ptr = current_cmd->body_list;
	  for (i = 1; i < current_body; i++)
	    body_ptr++;

	  *body_ptr = next;

	}

      child_tail = next;

      /* If the latest line is another control structure, then recurse
	 on it.  */
      if (next->control_type == while_control
	  || next->control_type == if_control)
	{
	  control_level++;
	  ret = recurse_read_control_structure (next);
	  control_level--;

	  if (ret != simple_control)
	    break;
	}
    }

  dont_repeat ();

  return ret;
}

/* Read lines from the input stream and accumulate them in a chain of
   struct command_line's, which is then returned.  For input from a
   terminal, the special command "end" is used to mark the end of the
   input, and is not included in the returned chain of commands. */

#define END_MESSAGE "End with a line saying just \"end\"."

struct command_line *
read_command_lines (prompt_arg, from_tty)
     char *prompt_arg;
     int from_tty;
{
  struct command_line *head, *tail, *next;
  struct cleanup *old_chain;
  enum command_control_type ret;
  enum misc_command_type val;

  control_level = 0; 
  if (readline_begin_hook)
    {
      /* Note - intentional to merge messages with no newline */
      (*readline_begin_hook) ("%s  %s\n", prompt_arg, END_MESSAGE);
    }
  else if (from_tty && input_from_terminal_p ())
    {
      printf_unfiltered ("%s\n%s\n", prompt_arg, END_MESSAGE);
      gdb_flush (gdb_stdout);
    }

  head = tail = NULL;
  old_chain = NULL;

  while (1)
    {
      val = read_next_line (&next);

      /* Ignore blank lines or comments.  */
      if (val == nop_command)
	continue;

      if (val == end_command)
	{
	  ret = simple_control;
	  break;
	}

      if (val != ok_command)
	{
	  ret = invalid_control;
	  break;
	}

      if (next->control_type == while_control
	  || next->control_type == if_control)
	{
	  control_level++;
	  ret = recurse_read_control_structure (next);
	  control_level--;

	  if (ret == invalid_control)
	    break;
	}
      
      if (tail)
	{
	  tail->next = next;
	}
      else
	{
	  head = next;
	  old_chain = make_cleanup ((make_cleanup_func) free_command_lines, 
                                    &head);
	}
      tail = next;
    }

  dont_repeat ();

  if (head)
    {
      if (ret != invalid_control)
	{
	  discard_cleanups (old_chain);
	}
      else
	do_cleanups (old_chain);
    }

  if (readline_end_hook)
    {
      (*readline_end_hook) ();
    }
  return (head);
}

/* Free a chain of struct command_line's.  */

void
free_command_lines (lptr)
      struct command_line **lptr;
{
  register struct command_line *l = *lptr;
  register struct command_line *next;
  struct command_line **blist;
  int i;

  while (l)
    {
      if (l->body_count > 0)
	{
	  blist = l->body_list;
	  for (i = 0; i < l->body_count; i++, blist++)
	    free_command_lines (blist);
	}
      next = l->next;
      free (l->line);
      free ((PTR)l);
      l = next;
    }
}

/* Add an element to the list of info subcommands.  */

void
add_info (name, fun, doc)
     char *name;
     void (*fun) PARAMS ((char *, int));
     char *doc;
{
  add_cmd (name, no_class, fun, doc, &infolist);
}

/* Add an alias to the list of info subcommands.  */

void
add_info_alias (name, oldname, abbrev_flag)
     char *name;
     char *oldname;
     int abbrev_flag;
{
  add_alias_cmd (name, oldname, 0, abbrev_flag, &infolist);
}

/* The "info" command is defined as a prefix, with allow_unknown = 0.
   Therefore, its own definition is called only for "info" with no args.  */

/* ARGSUSED */
static void
info_command (arg, from_tty)
     char *arg;
     int from_tty;
{
  printf_unfiltered ("\"info\" must be followed by the name of an info command.\n");
  help_list (infolist, "info ", -1, gdb_stdout);
}

/* The "complete" command is used by Emacs to implement completion.  */

/* ARGSUSED */
static void
complete_command (arg, from_tty)
     char *arg;
     int from_tty;
{
  int i;
  int argpoint;
  char *completion;

  dont_repeat ();

  if (arg == NULL)
    arg = "";
  argpoint = strlen (arg);

  for (completion = line_completion_function (arg, i = 0, arg, argpoint);
       completion;
       completion = line_completion_function (arg, ++i, arg, argpoint))
    {
      printf_unfiltered ("%s\n", completion);
      free (completion);
    }
}

/* The "show" command with no arguments shows all the settings.  */

/* ARGSUSED */
static void
show_command (arg, from_tty)
     char *arg;
     int from_tty;
{
  cmd_show_list (showlist, from_tty, "");
}

/* Add an element to the list of commands.  */

void
add_com (name, class, fun, doc)
     char *name;
     enum command_class class;
     void (*fun) PARAMS ((char *, int));
     char *doc;
{
  add_cmd (name, class, fun, doc, &cmdlist);
}

/* Add an alias or abbreviation command to the list of commands.  */

void
add_com_alias (name, oldname, class, abbrev_flag)
     char *name;
     char *oldname;
     enum command_class class;
     int abbrev_flag;
{
  add_alias_cmd (name, oldname, class, abbrev_flag, &cmdlist);
}

void
error_no_arg (why)
     char *why;
{
  error ("Argument required (%s).", why);
}

/* ARGSUSED */
static void
help_command (command, from_tty)
     char *command;
     int from_tty; /* Ignored */
{
  help_cmd (command, gdb_stdout);
}

static void
validate_comname (comname)
     char *comname;
{
  register char *p;

  if (comname == 0)
    error_no_arg ("name of command to define");

  p = comname;
  while (*p)
    {
      if (!isalnum(*p) && *p != '-' && *p != '_')
	error ("Junk in argument list: \"%s\"", p);
      p++;
    }
}

/* This is just a placeholder in the command data structures.  */
static void
user_defined_command (ignore, from_tty)
     char *ignore;
     int from_tty;
{
}

static void
define_command (comname, from_tty)
     char *comname;
     int from_tty;
{
  register struct command_line *cmds;
  register struct cmd_list_element *c, *newc, *hookc = 0;
  char *tem = comname;
  char tmpbuf[128];
#define	HOOK_STRING	"hook-"
#define	HOOK_LEN 5

  validate_comname (comname);

  /* Look it up, and verify that we got an exact match.  */
  c = lookup_cmd (&tem, cmdlist, "", -1, 1);
  if (c && !STREQ (comname, c->name))
    c = 0;

  if (c)
    {
      if (c->class == class_user || c->class == class_alias)
	tem = "Redefine command \"%s\"? ";
      else
	tem = "Really redefine built-in command \"%s\"? ";
      if (!query (tem, c->name))
	error ("Command \"%s\" not redefined.", c->name);
    }

  /* If this new command is a hook, then mark the command which it
     is hooking.  Note that we allow hooking `help' commands, so that
     we can hook the `stop' pseudo-command.  */

  if (!strncmp (comname, HOOK_STRING, HOOK_LEN))
    {
      /* Look up cmd it hooks, and verify that we got an exact match.  */
      tem = comname+HOOK_LEN;
      hookc = lookup_cmd (&tem, cmdlist, "", -1, 0);
      if (hookc && !STREQ (comname+HOOK_LEN, hookc->name))
	hookc = 0;
      if (!hookc)
	{
	  warning ("Your new `%s' command does not hook any existing command.",
		   comname);
	  if (!query ("Proceed? "))
	    error ("Not confirmed.");
	}
    }

  comname = savestring (comname, strlen (comname));

  /* If the rest of the commands will be case insensitive, this one
     should behave in the same manner. */
  for (tem = comname; *tem; tem++)
    if (isupper(*tem)) *tem = tolower(*tem);

  sprintf (tmpbuf, "Type commands for definition of \"%s\".", comname);
  cmds = read_command_lines (tmpbuf, from_tty);

  if (c && c->class == class_user)
    free_command_lines (&c->user_commands);

  newc = add_cmd (comname, class_user, user_defined_command,
	   (c && c->class == class_user)
	   ? c->doc : savestring ("User-defined.", 13), &cmdlist);
  newc->user_commands = cmds;

  /* If this new command is a hook, then mark both commands as being
     tied.  */
  if (hookc)
    {
      hookc->hook = newc;	/* Target gets hooked.  */
      newc->hookee = hookc;	/* We are marked as hooking target cmd.  */
    }
}

static void
document_command (comname, from_tty)
     char *comname;
     int from_tty;
{
  struct command_line *doclines;
  register struct cmd_list_element *c;
  char *tem = comname;
  char tmpbuf[128];

  validate_comname (comname);

  c = lookup_cmd (&tem, cmdlist, "", 0, 1);

  if (c->class != class_user)
    error ("Command \"%s\" is built-in.", comname);

  sprintf (tmpbuf, "Type documentation for \"%s\".", comname);
  doclines = read_command_lines (tmpbuf, from_tty);

  if (c->doc) free (c->doc);

  {
    register struct command_line *cl1;
    register int len = 0;

    for (cl1 = doclines; cl1; cl1 = cl1->next)
      len += strlen (cl1->line) + 1;

    c->doc = (char *) xmalloc (len + 1);
    *c->doc = 0;

    for (cl1 = doclines; cl1; cl1 = cl1->next)
      {
	strcat (c->doc, cl1->line);
	if (cl1->next)
	  strcat (c->doc, "\n");
      }
  }

  free_command_lines (&doclines);
}

/* Print the GDB banner. */
void
print_gdb_version (stream)
  GDB_FILE *stream;
{
  /* From GNU coding standards, first line is meant to be easy for a
     program to parse, and is just canonical program name and version
     number, which starts after last space. */

  fprintf_filtered (stream, "GNU gdb %s\n", version);

  /* Second line is a copyright notice. */

  fprintf_filtered (stream, "Copyright 1998 Free Software Foundation, Inc.\n");

  /* Following the copyright is a brief statement that the program is
     free software, that users are free to copy and change it on
     certain conditions, that it is covered by the GNU GPL, and that
     there is no warranty. */

  fprintf_filtered (stream, "\
GDB is free software, covered by the GNU General Public License, and you are\n\
welcome to change it and/or distribute copies of it under certain conditions.\n\
Type \"show copying\" to see the conditions.\n\
There is absolutely no warranty for GDB.  Type \"show warranty\" for details.\n");

  /* After the required info we print the configuration information. */

  fprintf_filtered (stream, "This GDB was configured as \"");
  if (!STREQ (host_name, target_name))
    {
      fprintf_filtered (stream, "--host=%s --target=%s", host_name, target_name);
    }
  else
    {
      fprintf_filtered (stream, "%s", host_name);
    }
  fprintf_filtered (stream, "\".");
}

/* ARGSUSED */
static void
show_version (args, from_tty)
     char *args;
     int from_tty;
{
  immediate_quit++;
  print_gdb_version (gdb_stdout);
  printf_filtered ("\n");
  immediate_quit--;
}

/* get_prompt: access method for the GDB prompt string.  */

#define MAX_PROMPT_SIZE 256

/*
 * int get_prompt_1 (char * buf);
 *
 * Work-horse for get_prompt (called via catch_errors).
 * Argument is buffer to hold the formatted prompt.
 *
 * Returns: 1 for success (use formatted prompt)
 *          0 for failure (use gdb_prompt_string).
 */ 

static int gdb_prompt_escape;

static int
get_prompt_1 (formatted_prompt)
     char *formatted_prompt;
{
  char *local_prompt;

  if (async_p)
    local_prompt = PROMPT (0);
  else
    local_prompt = gdb_prompt_string;


  if (gdb_prompt_escape == 0)
    {
      return 0;		/* do no formatting */
    }
  else /* formatted prompt */
    {
      char   fmt[40], *promptp, *outp, *tmp;
      value_ptr arg_val;
      DOUBLEST  doubleval;
      LONGEST   longval;
      CORE_ADDR addrval;

      int i, len;
      struct type *arg_type, *elt_type;

      promptp = local_prompt;
      outp    = formatted_prompt;

      while (*promptp != '\0')
	{
	  int available = MAX_PROMPT_SIZE - (outp - formatted_prompt) - 1;

	  if (*promptp != gdb_prompt_escape)
	    {
	      if (available >= 1)			/* overflow protect */
		*outp++ = *promptp++;
	    }
	  else
	    {
	      /* GDB prompt string contains escape char.  Parse for arg.
		 Two consecutive escape chars followed by arg followed by
		 a comma means to insert the arg using a default format.
		 Otherwise a printf format string may be included between
		 the two escape chars.  eg:
		   %%foo,	insert foo using default format
		   %2.2f%foo,	insert foo using "%2.2f" format
		 A mismatch between the format string and the data type
		 of "foo" is an error (which we don't know how to protect
		 against).  */

	      fmt[0] = '\0';	/* assume null format string */
	      if (promptp[1] == gdb_prompt_escape)	/* double esc char */
		{
		  promptp += 2;	/* skip past two escape chars. */
		}
	      else
		{
		  /* extract format string from between two esc chars */
		  i = 0;
		  do {
		    fmt[i++] = *promptp++;	/* copy format string */
		  } while (i < sizeof (fmt) - 1 && 
			   *promptp != gdb_prompt_escape &&
			   *promptp != '\0');

		  if (*promptp != gdb_prompt_escape)
		    error ("Syntax error at prompt position %d",
			   promptp - local_prompt);
		  else
		    {
		      promptp++;	/* skip second escape char */
		      fmt[i++] = '\0';	/* terminate the format string */
		    }
		}

	      arg_val = parse_to_comma_and_eval (&promptp);
	      if (*promptp == ',')
		promptp++;		/* skip past the comma */
	      arg_type = check_typedef (VALUE_TYPE (arg_val));
	      switch (TYPE_CODE (arg_type)) 
		{
		case TYPE_CODE_ARRAY:
		  elt_type = check_typedef (TYPE_TARGET_TYPE (arg_type));
		  if (TYPE_LENGTH (arg_type) > 0  &&
		      TYPE_LENGTH (elt_type) == 1 &&
		      TYPE_CODE (elt_type) == TYPE_CODE_INT)
		    {
		      int len = TYPE_LENGTH (arg_type);

		      if (VALUE_LAZY (arg_val))
			value_fetch_lazy (arg_val);
		      tmp = VALUE_CONTENTS (arg_val);

		      if (len > available)
			len = available;		/* overflow protect */

		      /* FIXME: how to protect GDB from crashing
			 from bad user-supplied format string? */
		      if (fmt[0] != 0)
			sprintf (outp, fmt, tmp);
		      else
			strncpy (outp, tmp, len);
		      outp[len] = '\0';
		    }
		  break;
		case TYPE_CODE_PTR:
		  elt_type = check_typedef (TYPE_TARGET_TYPE (arg_type));
		  addrval = value_as_pointer (arg_val);

		  if (TYPE_LENGTH (elt_type) == 1 &&
		      TYPE_CODE   (elt_type) == TYPE_CODE_INT &&
		      addrval != 0)
		    {
		      /* display it as a string */
		      char *default_fmt = "%s";
		      char *tmp;
		      int err = 0;

		      /* Limiting the number of bytes that the following call
			 will read protects us from sprintf overflow later. */
		      i = target_read_string (addrval,		     /* src */
					      &tmp, 		     /* dest */
					      available, 	     /* len */
					      &err);
		      if (err)	/* read failed */
			error ("%s on target_read", safe_strerror (err));

		      tmp[i] = '\0';	/* force-terminate string */
		      /* FIXME: how to protect GDB from crashing
			 from bad user-supplied format string? */
		      sprintf (outp, fmt[0] == 0 ? default_fmt : fmt, 
			       tmp);
		      free (tmp);
		    }
		  else
		    {
		      /* display it as a pointer */
		      char *default_fmt = "0x%x";

		      /* FIXME: how to protect GDB from crashing
			 from bad user-supplied format string? */
		      if (available >= 16 /*?*/)	/* overflow protect */
			sprintf (outp, fmt[0] == 0 ? default_fmt : fmt,
				 (long) addrval);
		    }
		  break;
		case TYPE_CODE_FLT:
		  {
		    char *default_fmt = "%g";

		    doubleval = value_as_double (arg_val);
		    /* FIXME: how to protect GDB from crashing
		       from bad user-supplied format string? */
		    if (available >= 16 /*?*/)		/* overflow protect */
		      sprintf (outp, fmt[0] == 0 ? default_fmt : fmt,
			       (double) doubleval);
		    break;
		  }
		case TYPE_CODE_INT:
		  {
		    char *default_fmt = "%d";

		    longval = value_as_long (arg_val);
		    /* FIXME: how to protect GDB from crashing
		       from bad user-supplied format string? */
		    if (available >= 16 /*?*/)		/* overflow protect */
		      sprintf (outp, fmt[0] == 0 ? default_fmt : fmt,
			       (long) longval);
		    break;
		  }
		case TYPE_CODE_BOOL:
		  {
		    /* no default format for bool */
		    longval = value_as_long (arg_val);
		    if (available >= 8 /*?*/)		/* overflow protect */
		      {
			if (longval)
			  strcpy (outp, "<true>");
			else
			  strcpy (outp, "<false>");
		      }
		    break;
		  }
		case TYPE_CODE_ENUM:
		  {
		    /* no default format for enum */
		    longval = value_as_long (arg_val);
		    len = TYPE_NFIELDS (arg_type);
		    /* find enum name if possible */
		    for (i = 0; i < len; i++)
		      if (TYPE_FIELD_BITPOS (arg_type, i) == longval)
			break;		/* match -- end loop */

		    if (i < len)	/* enum name found */
		      {
			char *name = TYPE_FIELD_NAME (arg_type, i);

			strncpy (outp, name, available);
			/* in casel available < strlen (name), */
			outp[available] = '\0';
		      }
		    else
		      {
			if (available >= 16 /*?*/)	/* overflow protect */
			  sprintf (outp, "%d", (long) longval);
		      }
		    break;
		  }
		case TYPE_CODE_VOID:
		  *outp = '\0';
		  break;	/* void type -- no output */
		default:
		  error ("bad data type at prompt position %d",
			 promptp - local_prompt);
		  break;
		}
	      outp += strlen (outp);
	    }
	}
      *outp++ = '\0';		/* terminate prompt string */
      return 1;
    }
}

char *
get_prompt ()
{
  static char buf[MAX_PROMPT_SIZE];

  if (catch_errors (get_prompt_1, buf, "bad formatted prompt: ", 
		    RETURN_MASK_ALL))
    {
      return &buf[0];	/* successful formatted prompt */
    }
  else
    {
      /* Prompt could not be formatted.  */
      if (async_p)
	return PROMPT (0);
      else
	return gdb_prompt_string;
    }
}

void
set_prompt (s)
     char *s;
{
/* ??rehrauer: I don't know why this fails, since it looks as though
   assignments to prompt are wrapped in calls to savestring...
  if (prompt != NULL)
    free (prompt);
*/
  if (async_p)
    PROMPT (0) = savestring (s, strlen (s));
  else
    gdb_prompt_string = savestring (s, strlen (s));
}


/* If necessary, make the user confirm that we should quit.  Return
   non-zero if we should quit, zero if we shouldn't.  */

int
quit_confirm ()
{
  if (inferior_pid != 0 && target_has_execution)
    {
      char *s;

      /* This is something of a hack.  But there's no reliable way to
	 see if a GUI is running.  The `use_windows' variable doesn't
	 cut it.  */
      if (init_ui_hook)
	s = "A debugging session is active.\nDo you still want to close the debugger?";
      else if (attach_flag)
	s = "The program is running.  Quit anyway (and detach it)? ";
      else
	s = "The program is running.  Exit anyway? ";

      if (! query (s))
	return 0;
    }

  return 1;
}

/* Quit without asking for confirmation.  */

void
quit_force (args, from_tty)
     char *args;
     int from_tty;
{
  int exit_code = 0;

  /* An optional expression may be used to cause gdb to terminate with the 
     value of that expression. */
  if (args)
    {
      value_ptr val = parse_and_eval (args);

      exit_code = (int) value_as_long (val);
    }

  if (inferior_pid != 0 && target_has_execution)
    {
      if (attach_flag)
	target_detach (args, from_tty);
      else
	target_kill ();
    }

  /* UDI wants this, to kill the TIP.  */
  target_close (1);

  /* Save the history information if it is appropriate to do so.  */
  if (write_history_p && history_filename)
    write_history (history_filename);

  do_final_cleanups(ALL_CLEANUPS);	/* Do any final cleanups before exiting */

#if defined(TUI)
  /* tuiDo((TuiOpaqueFuncPtr)tuiCleanUp); */
  /* The above does not need to be inside a tuiDo(), since
   * it is not manipulating the curses screen, but rather,
   * it is tearing it down.
   */
  if (tui_version)
    tuiCleanUp();
#endif

  exit (exit_code);
}

/* Handle the quit command.  */

void
quit_command (args, from_tty)
     char *args;
     int from_tty;
{
  if (! quit_confirm ())
    error ("Not confirmed.");
  quit_force (args, from_tty);
}

/* Returns whether GDB is running on a terminal and whether the user
   desires that questions be asked of them on that terminal.  */

int
input_from_terminal_p ()
{
  return gdb_has_a_terminal () && (instream == stdin) & caution;
}

/* ARGSUSED */
static void
pwd_command (args, from_tty)
     char *args;
     int from_tty;
{
  if (args) error ("The \"pwd\" command does not take an argument: %s", args);
  getcwd (gdb_dirbuf, sizeof (gdb_dirbuf));

  if (!STREQ (gdb_dirbuf, current_directory))
    printf_unfiltered ("Working directory %s\n (canonically %s).\n",
	    current_directory, gdb_dirbuf);
  else
    printf_unfiltered ("Working directory %s.\n", current_directory);
}

void
cd_command (dir, from_tty)
     char *dir;
     int from_tty;
{
  int len;
  /* Found something other than leading repetitions of "/..".  */
  int found_real_path;
  char *p;

  /* If the new directory is absolute, repeat is a no-op; if relative,
     repeat might be useful but is more likely to be a mistake.  */
  dont_repeat ();

  if (dir == 0)
    error_no_arg ("new working directory");

  dir = tilde_expand (dir);
  make_cleanup (free, dir);

  if (chdir (dir) < 0)
    perror_with_name (dir);

  len = strlen (dir);
  dir = savestring (dir, len - (len > 1 && SLASH_P(dir[len-1])));
  if (ROOTED_P(dir))
    current_directory = dir;
  else
    {
      if (SLASH_P (current_directory[0]) && current_directory[1] == '\0')
	current_directory = concat (current_directory, dir, NULL);
      else
	current_directory = concat (current_directory, SLASH_STRING, dir, NULL);
      free (dir);
    }

  /* Now simplify any occurrences of `.' and `..' in the pathname.  */

  found_real_path = 0;
  for (p = current_directory; *p;)
    {
      if (SLASH_P (p[0]) && p[1] == '.' && (p[2] == 0 || SLASH_P (p[2])))
	strcpy (p, p + 2);
      else if (SLASH_P (p[0]) && p[1] == '.' && p[2] == '.'
	       && (p[3] == 0 || SLASH_P (p[3])))
	{
	  if (found_real_path)
	    {
	      /* Search backwards for the directory just before the "/.."
		 and obliterate it and the "/..".  */
	      char *q = p;
	      while (q != current_directory && ! SLASH_P (q[-1]))
		--q;

	      if (q == current_directory)
		/* current_directory is
		   a relative pathname ("can't happen"--leave it alone).  */
		++p;
	      else
		{
		  strcpy (q - 1, p + 3);
		  p = q - 1;
		}
	    }
	  else
	    /* We are dealing with leading repetitions of "/..", for example
	       "/../..", which is the Mach super-root.  */
	    p += 3;
	}
      else
	{
	  found_real_path = 1;
	  ++p;
	}
    }

  forget_cached_source_info ();

  if (from_tty)
    pwd_command ((char *) 0, 1);
}

struct source_cleanup_lines_args {
  int old_line;
  char *old_file;
  char *old_pre_error;
  char *old_error_pre_print;
};

static void
source_cleanup_lines (args)
     PTR args;
{
  struct source_cleanup_lines_args *p =
    (struct source_cleanup_lines_args *)args;
  source_line_number = p->old_line;
  source_file_name = p->old_file;
  source_pre_error = p->old_pre_error;
  error_pre_print = p->old_error_pre_print;
}

/* ARGSUSED */
void
source_command (args, from_tty)
     char *args;
     int from_tty;
{
  FILE *stream;
  struct cleanup *old_cleanups;
  char *file = args;
  struct source_cleanup_lines_args old_lines;
  int needed_length;

  if (file == NULL)
    {
      error ("source command requires pathname of file to source.");
    }

  file = tilde_expand (file);
  old_cleanups = make_cleanup (free, file);

  stream = fopen (file, FOPEN_RT);
  if (!stream)
    {
      if (from_tty)
	perror_with_name (file);
      else
	return;
    }

  make_cleanup ((make_cleanup_func) fclose, stream);

  old_lines.old_line = source_line_number;
  old_lines.old_file = source_file_name;
  old_lines.old_pre_error = source_pre_error;
  old_lines.old_error_pre_print = error_pre_print;
  make_cleanup (source_cleanup_lines, &old_lines);
  source_line_number = 0;
  source_file_name = file;
  source_pre_error = error_pre_print == NULL ? "" : error_pre_print;
  source_pre_error = savestring (source_pre_error, strlen (source_pre_error));
  make_cleanup (free, source_pre_error);
  /* This will get set every time we read a line.  So it won't stay "" for
     long.  */
  error_pre_print = "";

  needed_length = strlen (source_file_name) + strlen (source_pre_error) + 80;
  if (source_error_allocated < needed_length)
    {
      source_error_allocated *= 2;
      if (source_error_allocated < needed_length)
	source_error_allocated = needed_length;
      if (source_error == NULL)
	source_error = xmalloc (source_error_allocated);
      else
	source_error = xrealloc (source_error, source_error_allocated);
    }

  read_command_file (stream);

  do_cleanups (old_cleanups);
}

/* ARGSUSED */
static void
echo_command (text, from_tty)
     char *text;
     int from_tty;
{
  char *p = text;
  register int c;

  if (text)
    while ((c = *p++) != '\0')
      {
	if (c == '\\')
	  {
	    /* \ at end of argument is used after spaces
	       so they won't be lost.  */
	    if (*p == 0)
	      return;

	    c = parse_escape (&p);
	    if (c >= 0)
	      printf_filtered ("%c", c);
	  }
	else
	  printf_filtered ("%c", c);
      }

  /* Force this output to appear now.  */
  wrap_here ("");
  gdb_flush (gdb_stdout);
}

/* ARGSUSED */
static void
dont_repeat_command (ignored, from_tty)
     char *ignored;
     int from_tty;
{
  *line = 0;		/* Can't call dont_repeat here because we're not
			   necessarily reading from stdin.  */
}

/* Functions to manipulate command line editing control variables.  */

/* Number of commands to print in each call to show_commands.  */
#define Hist_print 10
static void
show_commands (args, from_tty)
     char *args;
     int from_tty;
{
  /* Index for history commands.  Relative to history_base.  */
  int offset;

  /* Number of the history entry which we are planning to display next.
     Relative to history_base.  */
  static int num = 0;

  /* The first command in the history which doesn't exist (i.e. one more
     than the number of the last command).  Relative to history_base.  */
  int hist_len;

  extern HIST_ENTRY *history_get PARAMS ((int));

  /* Print out some of the commands from the command history.  */
  /* First determine the length of the history list.  */
  hist_len = history_size;
  for (offset = 0; offset < history_size; offset++)
    {
      if (!history_get (history_base + offset))
	{
	  hist_len = offset;
	  break;
	}
    }

  if (args)
    {
      if (args[0] == '+' && args[1] == '\0')
	/* "info editing +" should print from the stored position.  */
	;
      else
	/* "info editing <exp>" should print around command number <exp>.  */
	num = (parse_and_eval_address (args) - history_base) - Hist_print / 2;
    }
  /* "show commands" means print the last Hist_print commands.  */
  else
    {
      num = hist_len - Hist_print;
    }

  if (num < 0)
    num = 0;

  /* If there are at least Hist_print commands, we want to display the last
     Hist_print rather than, say, the last 6.  */
  if (hist_len - num < Hist_print)
    {
      num = hist_len - Hist_print;
      if (num < 0)
	num = 0;
    }

  for (offset = num; offset < num + Hist_print && offset < hist_len; offset++)
    {
      printf_filtered ("%5d  %s\n", history_base + offset,
	      (history_get (history_base + offset))->line);
    }

  /* The next command we want to display is the next one that we haven't
     displayed yet.  */
  num += Hist_print;

  /* If the user repeats this command with return, it should do what
     "show commands +" does.  This is unnecessary if arg is null,
     because "show commands +" is not useful after "show commands".  */
  if (from_tty && args)
    {
      args[0] = '+';
      args[1] = '\0';
    }
}

/* Called by do_setshow_command.  */
/* ARGSUSED */
static void
set_history_size_command (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
{
  if (history_size == INT_MAX)
    unstifle_history ();
  else if (history_size >= 0)
    stifle_history (history_size);
  else
    {
      history_size = INT_MAX;
      error ("History size must be non-negative");
    }
}

/* ARGSUSED */
static void
set_history (args, from_tty)
     char *args;
     int from_tty;
{
  printf_unfiltered ("\"set history\" must be followed by the name of a history subcommand.\n");
  help_list (sethistlist, "set history ", -1, gdb_stdout);
}

/* ARGSUSED */
static void
show_history (args, from_tty)
     char *args;
     int from_tty;
{
  cmd_show_list (showhistlist, from_tty, "");
}

int info_verbose = 0;		/* Default verbose msgs off */

/* Called by do_setshow_command.  An elaborate joke.  */
/* ARGSUSED */
static void
set_verbose (args, from_tty, c)
     char *args;
     int from_tty;
     struct cmd_list_element *c;
{
  char *cmdname = "verbose";
  struct cmd_list_element *showcmd;

  showcmd = lookup_cmd_1 (&cmdname, showlist, NULL, 1);

  if (info_verbose)
    {
      c->doc = "Set verbose printing of informational messages.";
      showcmd->doc = "Show verbose printing of informational messages.";
    }
  else
    {
      c->doc = "Set verbosity.";
      showcmd->doc = "Show verbosity.";
    }
}

static void
float_handler (signo)
int signo;
{
  /* This message is based on ANSI C, section 4.7.  Note that integer
     divide by zero causes this, so "float" is a misnomer.  */
  signal (SIGFPE, float_handler);
  error ("Erroneous arithmetic operation.");
}


static void
init_cmd_lists ()
{
  cmdlist = NULL;
  infolist = NULL;
  enablelist = NULL;
  disablelist = NULL;
  togglelist = NULL;
  stoplist = NULL;
  deletelist = NULL;
  enablebreaklist = NULL;
  setlist = NULL;
  unsetlist = NULL;
  showlist = NULL;
  sethistlist = NULL;
  showhistlist = NULL;
  unsethistlist = NULL;
  maintenancelist = NULL;
  maintenanceinfolist = NULL;
  maintenanceprintlist = NULL;
  setprintlist = NULL;
  showprintlist = NULL;
  setchecklist = NULL;
  showchecklist = NULL;
}

/* Init the history buffer.  Note that we are called after the init file(s)
 * have been read so that the user can change the history file via his
 * .gdbinit file (for instance).  The GDBHISTFILE environment variable
 * overrides all of this.
 */

void
init_history()
{
  char *tmpenv;

  tmpenv = getenv ("HISTSIZE");
  if (tmpenv)
    history_size = atoi (tmpenv);
  else if (!history_size)
    history_size = 256;

  stifle_history (history_size);

  tmpenv = getenv ("GDBHISTFILE");
  if (tmpenv)
    history_filename = savestring (tmpenv, strlen(tmpenv));
  else if (!history_filename) {
    /* We include the current directory so that if the user changes
       directories the file written will be the same as the one
       that was read.  */
    history_filename = concat (current_directory, "/.gdb_history", NULL);
  }
  read_history (history_filename);
}

static void
init_main ()
{
  struct cmd_list_element *c;

  /* If we are running the asynchronous version,
     we initialize the prompts differently. */
  if (!async_p)
    {
#ifdef DEFAULT_PROMPT
      gdb_prompt_string = savestring (DEFAULT_PROMPT, strlen(DEFAULT_PROMPT));
#else
      gdb_prompt_string = savestring ("(gdb) ", 6);
#endif
    }
  else
    {
      /* initialize the prompt stack to a simple "(gdb) " prompt or to
	 whatever the DEFULAT_PROMPT is. */
      the_prompts.top = 0;
      PREFIX(0) = "";
#ifdef DEFAULT_PROMPT
      PROMPT(0) = savestring (DEFAULT_PROMPT, strlen(DEFAULT_PROMPT));
#else
      PROMPT(0) = savestring ("(gdb) ", 6);
#endif
      SUFFIX(0) = "";
      /* Set things up for annotation_level > 1, if the user ever decides
	 to use it. */
      async_annotation_suffix = "prompt";
      /* Set the variable associated with the setshow prompt command. */
      new_async_prompt = savestring (PROMPT (0), strlen (PROMPT (0)));
    }
  gdb_prompt_escape = 0;	/* default to none.  */

  /* Set the important stuff up for command editing.  */
  command_editing_p = 1;
  async_command_editing_p = 1;
  history_expansion_p = 0;
  write_history_p = 0;

  /* Setup important stuff for command line editing.  */
  rl_completion_entry_function = (int (*)()) readline_line_completion_function;
  rl_completer_word_break_characters = gdb_completer_word_break_characters;
  rl_completer_quote_characters = gdb_completer_quote_characters;
  rl_readline_name = "gdb";

  /* Define the classes of commands.
     They will appear in the help list in the reverse of this order.  */

  add_cmd ("internals", class_maintenance, NO_FUNCTION,
	   "Maintenance commands.\n\
Some gdb commands are provided just for use by gdb maintainers.\n\
These commands are subject to frequent change, and may not be as\n\
well documented as user commands.",
	   &cmdlist);
  add_cmd ("obscure", class_obscure, NO_FUNCTION, "Obscure features.", &cmdlist);
  add_cmd ("aliases", class_alias, NO_FUNCTION, "Aliases of other commands.", &cmdlist);
  add_cmd ("user-defined", class_user, NO_FUNCTION, "User-defined commands.\n\
The commands in this class are those defined by the user.\n\
Use the \"define\" command to define a command.", &cmdlist);
  add_cmd ("support", class_support, NO_FUNCTION, "Support facilities.", &cmdlist);
  if (!dbx_commands)
    add_cmd ("status", class_info, NO_FUNCTION, "Status inquiries.", &cmdlist);
  add_cmd ("files", class_files, NO_FUNCTION, "Specifying and examining files.", &cmdlist);
  add_cmd ("breakpoints", class_breakpoint, NO_FUNCTION, "Making program stop at certain points.", &cmdlist);
  add_cmd ("data", class_vars, NO_FUNCTION, "Examining data.", &cmdlist);
  add_cmd ("stack", class_stack, NO_FUNCTION, "Examining the stack.\n\
The stack is made up of stack frames.  Gdb assigns numbers to stack frames\n\
counting from zero for the innermost (currently executing) frame.\n\n\
At any time gdb identifies one frame as the \"selected\" frame.\n\
Variable lookups are done with respect to the selected frame.\n\
When the program being debugged stops, gdb selects the innermost frame.\n\
The commands below can be used to select other frames by number or address.",
	   &cmdlist);
  add_cmd ("running", class_run, NO_FUNCTION, "Running the program.", &cmdlist);

  add_com ("pwd", class_files, pwd_command,
	   "Print working directory.  This is used for your program as well.");
  c = add_cmd ("cd", class_files, cd_command,
	   "Set working directory to DIR for debugger and program being debugged.\n\
The change does not take effect for the program being debugged\n\
until the next time it is started.", &cmdlist);
  c->completer = filename_completer;

  /* The set prompt command is different depending whether or not the
     async version is run. NOTE: this difference is going to
     disappear as we make the event loop be the default engine of
     gdb. */
  if (!async_p)
    {
      add_show_from_set
	(add_set_cmd ("prompt", class_support, var_string, 
		      (char *) &gdb_prompt_string, "Set gdb's prompt",
		      &setlist),
	 &showlist);
    }
  else
    {
      c = add_set_cmd ("prompt", class_support, var_string, 
		      (char *)&new_async_prompt, "Set gdb's prompt",
		       &setlist);
      add_show_from_set (c, &showlist);
      c->function.sfunc = set_async_prompt;
    }

  add_show_from_set
    (add_set_cmd ("prompt-escape-char", class_support, var_zinteger, 
		  (char *) &gdb_prompt_escape,
		  "Set escape character for formatting of gdb's prompt",
		  &setlist),
     &showlist);

  add_com ("echo", class_support, echo_command,
	   "Print a constant string.  Give string as argument.\n\
C escape sequences may be used in the argument.\n\
No newline is added at the end of the argument;\n\
use \"\\n\" if you want a newline to be printed.\n\
Since leading and trailing whitespace are ignored in command arguments,\n\
if you want to print some you must use \"\\\" before leading whitespace\n\
to be printed or after trailing whitespace.");
  add_com ("document", class_support, document_command,
	   "Document a user-defined command.\n\
Give command name as argument.  Give documentation on following lines.\n\
End with a line of just \"end\".");
  add_com ("define", class_support, define_command,
	   "Define a new command name.  Command name is argument.\n\
Definition appears on following lines, one command per line.\n\
End with a line of just \"end\".\n\
Use the \"document\" command to give documentation for the new command.\n\
Commands defined in this way may have up to ten arguments.");

#ifdef __STDC__
  c = add_cmd ("source", class_support, source_command,
	   "Read commands from a file named FILE.\n\
Note that the file \"" GDBINIT_FILENAME "\" is read automatically in this way\n\
when gdb is started.", &cmdlist);
#else
  /* Punt file name, we can't help it easily.  */
  c = add_cmd ("source", class_support, source_command,
	   "Read commands from a file named FILE.\n\
Note that the file \".gdbinit\" is read automatically in this way\n\
when gdb is started.", &cmdlist);
#endif
  c->completer = filename_completer;

  add_com ("quit", class_support, quit_command, "Exit gdb.");
  add_com ("help", class_support, help_command, "Print list of commands.");
  add_com_alias ("q", "quit", class_support, 1);
  add_com_alias ("h", "help", class_support, 1);

  add_com ("dont-repeat", class_support, dont_repeat_command, "Don't repeat this command.\n\
Primarily used inside of user-defined commands that should not be repeated when\n\
hitting return.");

  c = add_set_cmd ("verbose", class_support, var_boolean, (char *)&info_verbose,
		   "Set ",
		   &setlist),
  add_show_from_set (c, &showlist);
  c->function.sfunc = set_verbose;
  set_verbose (NULL, 0, c);

  /* The set editing command is different depending whether or not the
     async version is run. NOTE: this difference is going to disappear
     as we make the event loop be the default engine of gdb. */
  if (!async_p)
    {
      add_show_from_set
	(add_set_cmd ("editing", class_support, var_boolean, (char *)&command_editing_p,
		      "Set editing of command lines as they are typed.\n\
Use \"on\" to enable the editing, and \"off\" to disable it.\n\
Without an argument, command line editing is enabled.  To edit, use\n\
EMACS-like or VI-like commands like control-P or ESC.", &setlist),
	 &showlist);
    }
  else
    {
      c = add_set_cmd ("editing", class_support, var_boolean, (char *)&async_command_editing_p,
		       "Set editing of command lines as they are typed.\n\
Use \"on\" to enable the editing, and \"off\" to disable it.\n\
Without an argument, command line editing is enabled.  To edit, use\n\
EMACS-like or VI-like commands like control-P or ESC.", &setlist);

      add_show_from_set (c, &showlist);
      c->function.sfunc = set_async_editing_command;
    }

  add_prefix_cmd ("history", class_support, set_history,
		  "Generic command for setting command history parameters.",
		  &sethistlist, "set history ", 0, &setlist);
  add_prefix_cmd ("history", class_support, show_history,
		  "Generic command for showing command history parameters.",
		  &showhistlist, "show history ", 0, &showlist);

  add_show_from_set
    (add_set_cmd ("expansion", no_class, var_boolean, (char *)&history_expansion_p,
	   "Set history expansion on command input.\n\
Without an argument, history expansion is enabled.", &sethistlist),
     &showhistlist);

  add_show_from_set
    (add_set_cmd ("save", no_class, var_boolean, (char *)&write_history_p,
	   "Set saving of the history record on exit.\n\
Use \"on\" to enable the saving, and \"off\" to disable it.\n\
Without an argument, saving is enabled.", &sethistlist),
     &showhistlist);

  c = add_set_cmd ("size", no_class, var_integer, (char *)&history_size,
		   "Set the size of the command history, \n\
ie. the number of previous commands to keep a record of.", &sethistlist);
  add_show_from_set (c, &showhistlist);
  c->function.sfunc = set_history_size_command;

  add_show_from_set
    (add_set_cmd ("filename", no_class, var_filename, (char *)&history_filename,
	   "Set the filename in which to record the command history\n\
 (the list of previous commands of which a record is kept).", &sethistlist),
     &showhistlist);

  add_show_from_set
    (add_set_cmd ("confirm", class_support, var_boolean,
		  (char *)&caution,
		  "Set whether to confirm potentially dangerous operations.",
		  &setlist),
     &showlist);

  add_prefix_cmd ("info", class_info, info_command,
        "Generic command for showing things about the program being debugged.",
		  &infolist, "info ", 0, &cmdlist);
  add_com_alias ("i", "info", class_info, 1);

  add_com ("complete", class_obscure, complete_command,
	   "List the completions for the rest of the line as a command.");

  add_prefix_cmd ("show", class_info, show_command,
		  "Generic command for showing things about the debugger.",
		  &showlist, "show ", 0, &cmdlist);
  /* Another way to get at the same thing.  */
  add_info ("set", show_command, "Show all GDB settings.");

  add_cmd ("commands", no_class, show_commands,
	   "Show the history of commands you typed.\n\
You can supply a command number to start with, or a `+' to start after\n\
the previous command number shown.",
	   &showlist);

  add_cmd ("version", no_class, show_version,
	   "Show what version of GDB this is.", &showlist);

  add_com ("while", class_support, while_command,
"Execute nested commands WHILE the conditional expression is non zero.\n\
The conditional expression must follow the word `while' and must in turn be\n\
followed by a new line.  The nested commands must be entered one per line,\n\
and should be terminated by the word `end'.");

  add_com ("if", class_support, if_command,
"Execute nested commands once IF the conditional expression is non zero.\n\
The conditional expression must follow the word `if' and must in turn be\n\
followed by a new line.  The nested commands must be entered one per line,\n\
and should be terminated by the word 'else' or `end'.  If an else clause\n\
is used, the same rules apply to its nested commands as to the first ones.");

  /* If target is open when baud changes, it doesn't take effect until the
     next open (I think, not sure).  */
  add_show_from_set (add_set_cmd ("remotebaud", no_class,
				  var_zinteger, (char *)&baud_rate,
				  "Set baud rate for remote serial I/O.\n\
This value is used to set the speed of the serial port when debugging\n\
using remote targets.", &setlist),
		     &showlist);

  add_show_from_set (
    add_set_cmd ("remotedebug", no_class, var_zinteger, (char *)&remote_debug,
		   "Set debugging of remote protocol.\n\
When enabled, each packet sent or received with the remote target\n\
is displayed.", &setlist),
		     &showlist);

  add_show_from_set (
    add_set_cmd ("remotetimeout", no_class, var_integer, (char *)&remote_timeout,
		   "Set timeout limit to wait for target to respond.\n\
This value is used to set the time limit for gdb to wait for a response\n\
from the target.", &setlist),
		     &showlist);

  /* The set annotate command is different depending whether or not
     the async version is run. NOTE: this difference is going to
     disappear as we make the event loop be the default engine of
     gdb. */
  if (!async_p)
    {
      c = add_set_cmd ("annotate", class_obscure, var_zinteger, 
		       (char *)&annotation_level, "Set annotation_level.\n\
0 == normal;     1 == fullname (for use when running under emacs)\n\
2 == output annotated suitably for use by programs that control GDB.",
		       &setlist);
      c = add_show_from_set (c, &showlist);
    }
  else
    {
      c = add_set_cmd ("annotate", class_obscure, var_zinteger, 
		       (char *)&annotation_level, "Set annotation_level.\n\
0 == normal;     1 == fullname (for use when running under emacs)\n\
2 == output annotated suitably for use by programs that control GDB.",
		       &setlist);     
      add_show_from_set (c, &showlist);
      c->function.sfunc = set_async_annotation_level;
    }
}
@


1.1.1.8
log
@import gdb-1999-06-28 snapshot
@
text
@d2 1
a2 1
   Copyright 1986, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d3773 1
@


1.1.1.9
log
@import gdb-1999-07-05 snapshot
@
text
@a324 6
/* Non-zero means the target is running. Note: this is different from
   saying that there is an active target and we are stopped at a
   breakpoint, for instance. This is a real indicator whether the
   target is off and running, which gdb is doing something else. */
int target_executing = 0;

d386 5
a488 2
  if (async_p && target_has_async)
    do_exec_cleanups (ALL_CLEANUPS);
a1268 10

      /* If the target is running, we allow only a limited set of
         commands. */
      if (async_p && target_has_async && target_executing)
	if (!strcmp (c->name, "help")
	    && !strcmp (c->name, "pwd")
	    && !strcmp (c->name, "show")
	    && !strcmp (c->name, "stop"))
	  error ("Cannot execute this command while the target is running.");

@


1.1.1.10
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d33 1
a33 1
#include "terminal.h"		/* For job_control.  */
d68 1
a68 1
static char *line_completion_function PARAMS ((char *, int, char *, int));
d70 1
a70 1
static char *readline_line_completion_function PARAMS ((char *, int));
d82 1
a82 1
  build_command_line PARAMS ((enum command_control_type, char *));
d85 1
a85 1
  get_command_line PARAMS ((enum command_control_type, char *));
d94 1
a94 1
static struct cleanup *setup_user_args PARAMS ((char *));
d96 1
a96 1
static char *locate_arg PARAMS ((char *));
d98 1
a98 1
static char *insert_args PARAMS ((char *));
d190 1
a190 1
int caution = 1;		/* Default is yes, sigh. */
d293 2
a294 2
static char *gdb_prompt_string;	/* the global prompt string */
extern char *get_prompt PARAMS ((void));	/* access function for prompt string */
d337 9
a345 11
  {
    struct user_args *next;
    struct
      {
	char *arg;
	int len;
      }
    a[MAXUSERARGS];
    int count;
  }
 *user_args;
d390 1
a390 1
void (*fputs_unfiltered_hook) PARAMS ((const char *linebuffer, GDB_FILE * stream));
d394 1
a394 1
void (*print_frame_info_listing_hook) PARAMS ((struct symtab * s, int line,
d406 1
a406 1
void (*flush_hook) PARAMS ((GDB_FILE * stream));
d419 2
a420 2
void (*readline_begin_hook) PARAMS ((char *,...));
char *(*readline_hook) PARAMS ((char *));
d426 3
a428 3
void (*create_breakpoint_hook) PARAMS ((struct breakpoint * bpt));
void (*delete_breakpoint_hook) PARAMS ((struct breakpoint * bpt));
void (*modify_breakpoint_hook) PARAMS ((struct breakpoint * bpt));
d442 1
a442 1
   that several registers have changed (see value_assign). */
d451 1
a451 1
int (*target_wait_hook) PARAMS ((int pid, struct target_waitstatus * status));
d456 1
a456 1
void (*call_command_hook) PARAMS ((struct cmd_list_element * c, char *cmd,
d466 2
a467 2
NORETURN void (*error_hook)
PARAMS ((void)) ATTR_NORETURN;
a468 1

d470 1
a470 1
     SIGJMP_BUF error_return;
d472 1
a472 1
     SIGJMP_BUF quit_return;
d477 2
a478 2
     NORETURN void
       return_to_top_level (reason)
d486 1
a486 1
  bpstat_clear_actions (stop_bpstat);	/* Clear queued breakpoint commands */
d548 1
a548 1
      memcpy ((char *) saved_error, (char *) error_return, sizeof (SIGJMP_BUF));
d588 1
a588 1
     int signo;
d591 1
a591 1
	      "Could not kill the program being debugged", RETURN_MASK_ALL);
d605 3
a607 3
  caution = 0;			/* Throw caution to the wind -- we're exiting.
				   This prevents asking the user dumb questions.  */
  quit_command ((char *) 0, 0);
d659 1
a659 1
  command_loop ();
d679 3
a681 3
  init_cmd_lists ();		/* This needs to be done first */
  initialize_targets ();	/* Setup target_terminal macros for utils.c */
  initialize_utils ();		/* Make errors and warnings possible */
d683 1
a683 1
  init_main ();			/* But that omits this file!  Do it now */
d692 1
a692 1
    init_signals ();
d698 1
a698 1
  expected_language = current_language;		/* don't warn about the change.  */
d719 1
a719 1
  cmd = (struct command_line *) xmalloc (sizeof (struct command_line));
d725 2
a726 2
    = (struct command_line **) xmalloc (sizeof (struct command_line *)
					* cmd->body_count);
d824 9
a832 9
	{
	  if (depth)
	    {
	      for (i = 0; i < depth; i++)
		fputs_filtered ("  ", stream);
	    }
	  fputs_filtered ("else\n", stream);
	  print_command_line (cmd->body_list[1], depth + 1, stream);
	}
d864 2
a865 2
      old_chain = make_cleanup ((make_cleanup_func) free_current_contents,
				&new_line);
d873 1
a873 1
         continue the loop at the top, or break out.  */
d883 2
a884 2
	old_chain = make_cleanup ((make_cleanup_func) free_current_contents,
				  &new_line);
d887 1
a887 1

d926 1
a926 1

d928 1
a928 1
		current = current->next;
d944 2
a945 2
	old_chain = make_cleanup ((make_cleanup_func) free_current_contents,
				  &new_line);
d1055 1
a1055 1
  args = (struct user_args *) xmalloc (sizeof (struct user_args));
d1160 1
a1160 1

d1174 1
a1174 1
  new_line = (char *) xmalloc (len + 1);
d1262 1
a1262 1
    return;
d1266 1
a1266 2
  while (*p == ' ' || *p == '\t')
    p++;
d1296 1
a1296 1
	execute_user_command (c->hook, (char *) 0);
d1308 1
a1308 1
    }
d1312 3
a1314 6
    {
      if (language_mode == language_mode_auto)
	{
	  language_info (1);	/* Print what changed.  */
	}
      warned = 0;
d1316 2
d1387 1
a1387 1
      command = command_line_input (instream == stdin ?
d1473 2
a1474 2
         character position to be off, since the newline we read from
         the user is not accounted for.  */
d1478 1
a1478 1
         on the front of it. */
d1489 1
a1489 1
         This is the right thing for prompt_for_continue, at least.  */
d1551 1
a1551 1
" \t\n!@@#$%^&*()+=|~`}{[]\"';:?/>.<,-";
d1559 1
a1559 1
" \t\n!@@#$%^&*()+=|~`}{[]\"';:?/>.<,";
d1565 1
a1565 1
"'";
d1616 1
a1616 1
         in the "source" command.  */
d1677 1
a1677 1
 */
d1707 2
a1708 2
  static char **list = (char **) NULL;	/* Cache of completions */
  static int index;		/* Next cached completion */
d1718 2
a1719 2
         we need to find all of them now, and cache them for returning one at
         a time on future calls. */
d1725 1
a1725 1
	  free ((PTR) list);
d1731 5
a1735 5
         If we later find out that we are doing completions on command strings
         (as opposed to strings supplied by the individual command completer
         functions, which can be any string) then we will switch to the
         special word break set for command strings, which leaves out the
         '-' character used in some commands.  */
d1738 1
a1738 1
	gdb_completer_word_break_characters;
d1747 2
a1748 2
         to point, we can find the equivalent position in tmp_command
         by subtracting that many characters from the end of tmp_command.  */
d1787 4
a1790 4
	         command, so there are no possible completions.  For
	         example, "info t " or "info t foo" does not complete
	         to anything, because "info t" can be "info target" or
	         "info terminal".  */
d1796 1
a1796 1
	         This we can deal with.  */
d1807 1
a1807 1
	         inserting quotes.  */
d1827 1
a1827 1
		         a subcommand (e.g. "info ").  */
d1831 1
a1831 1
		         with respect to inserting quotes.  */
d1844 1
a1844 1
		         completed by the command's completer function.  */
d1970 1
a1971 1

d1975 1
a1975 1
     int signo;
d1996 1
a1996 1
     int signo;
d2109 1
a2109 1
         you get away with leaving out some of the gdb_flush, but not all.  */
d2158 1
a2158 1
      if (strlen (rl) + 1 + (p - linebuffer) > linelength)
d2160 1
a2160 1
	  linelength = strlen (rl) + 1 + (p - linebuffer);
d2171 1
a2171 1
      free (rl);		/* Allocated in readline.  */
d2178 1
a2178 1
    }
d2192 1
a2192 1
    && STREQN (linebuffer, "server ", SERVER_COMMAND_LENGTH);
d2196 2
a2197 2
         dont_repeat, this insures that repeating will still do the
         right thing.  */
d2228 1
a2228 1
	  p = linebuffer + strlen (linebuffer);
d2238 1
a2238 1
  for (p1 = linebuffer; *p1 == ' ' || *p1 == '\t'; p1++);
d2256 1
a2256 1
    *p1 = '\0';			/* Found a comment. */
d2321 2
a2322 2
      control_prompt[i + 1] = '\0';
      prompt_ptr = (char *) &control_prompt[0];
d2346 1
a2346 1

d2391 1
a2391 1
    }
d2455 1
a2455 1

d2491 1
a2491 1
         on it.  */
d2526 1
a2526 1
  control_level = 0;
d2571 1
a2571 1

d2579 2
a2580 2
	  old_chain = make_cleanup ((make_cleanup_func) free_command_lines,
				    &head);
d2608 1
a2608 1
     struct command_line **lptr;
d2625 1
a2625 1
      free ((PTR) l);
d2738 1
a2738 1
     int from_tty;		/* Ignored */
d2755 1
a2755 1
      if (!isalnum (*p) && *p != '-' && *p != '_')
d2805 1
a2805 1
      tem = comname + HOOK_LEN;
d2807 1
a2807 1
      if (hookc && !STREQ (comname + HOOK_LEN, hookc->name))
d2823 1
a2823 2
    if (isupper (*tem))
      *tem = tolower (*tem);
d2832 2
a2833 2
		  (c && c->class == class_user)
		  ? c->doc : savestring ("User-defined.", 13), &cmdlist);
d2865 1
a2865 2
  if (c->doc)
    free (c->doc);
d2891 1
a2891 1
     GDB_FILE *stream;
d2952 1
a2952 1
 */
d2970 1
a2970 1
      return 0;			/* do no formatting */
d2972 1
a2972 2
  else
    /* formatted prompt */
d2974 1
a2974 1
      char fmt[40], *promptp, *outp, *tmp;
d2976 2
a2977 2
      DOUBLEST doubleval;
      LONGEST longval;
d2984 1
a2984 1
      outp = formatted_prompt;
d2992 1
a2992 1
	      if (available >= 1)	/* overflow protect */
d2998 9
a3006 9
	         Two consecutive escape chars followed by arg followed by
	         a comma means to insert the arg using a default format.
	         Otherwise a printf format string may be included between
	         the two escape chars.  eg:
	         %%foo, insert foo using default format
	         %2.2f%foo,     insert foo using "%2.2f" format
	         A mismatch between the format string and the data type
	         of "foo" is an error (which we don't know how to protect
	         against).  */
d3017 5
a3021 7
		  do
		    {
		      fmt[i++] = *promptp++;	/* copy format string */
		    }
		  while (i < sizeof (fmt) - 1 &&
			 *promptp != gdb_prompt_escape &&
			 *promptp != '\0');
d3035 1
a3035 1
		promptp++;	/* skip past the comma */
d3037 1
a3037 1
	      switch (TYPE_CODE (arg_type))
d3041 1
a3041 1
		  if (TYPE_LENGTH (arg_type) > 0 &&
d3052 1
a3052 1
			len = available;	/* overflow protect */
d3055 1
a3055 1
		         from bad user-supplied format string? */
d3068 1
a3068 1
		      TYPE_CODE (elt_type) == TYPE_CODE_INT &&
d3077 4
a3080 4
		         will read protects us from sprintf overflow later. */
		      i = target_read_string (addrval,	/* src */
					      &tmp,	/* dest */
					      available,	/* len */
d3087 2
a3088 2
		         from bad user-supplied format string? */
		      sprintf (outp, fmt[0] == 0 ? default_fmt : fmt,
d3098 2
a3099 2
		         from bad user-supplied format string? */
		      if (available >= 16 /*? */ )	/* overflow protect */
d3111 1
a3111 1
		    if (available >= 16 /*? */ )	/* overflow protect */
d3123 1
a3123 1
		    if (available >= 16 /*? */ )	/* overflow protect */
d3132 1
a3132 1
		    if (available >= 8 /*? */ )		/* overflow protect */
d3149 1
a3149 1
			break;	/* match -- end loop */
d3161 1
a3161 1
			if (available >= 16 /*? */ )	/* overflow protect */
d3187 1
a3187 1
  if (catch_errors (get_prompt_1, buf, "bad formatted prompt: ",
d3190 1
a3190 1
      return &buf[0];		/* successful formatted prompt */
d3208 3
a3210 3
   if (prompt != NULL)
   free (prompt);
 */
d3216 1
a3217 1

d3229 2
a3230 2
         see if a GUI is running.  The `use_windows' variable doesn't
         cut it.  */
d3238 1
a3238 1
      if (!query (s))
d3278 1
a3278 1
  do_final_cleanups (ALL_CLEANUPS);	/* Do any final cleanups before exiting */
d3287 1
a3287 1
    tuiCleanUp ();
d3300 1
a3300 1
  if (!quit_confirm ())
d3320 1
a3320 2
  if (args)
    error ("The \"pwd\" command does not take an argument: %s", args);
d3325 1
a3325 1
		       current_directory, gdb_dirbuf);
d3354 2
a3355 2
  dir = savestring (dir, len - (len > 1 && SLASH_P (dir[len - 1])));
  if (ROOTED_P (dir))
d3379 1
a3379 1
	         and obliterate it and the "/..".  */
d3381 1
a3381 1
	      while (q != current_directory && !SLASH_P (q[-1]))
d3412 1
a3412 2
struct source_cleanup_lines_args
{
d3424 1
a3424 1
  (struct source_cleanup_lines_args *) args;
d3531 2
a3532 2
  *line = 0;			/* Can't call dont_repeat here because we're not
				   necessarily reading from stdin.  */
d3599 1
a3599 1
		       (history_get (history_base + offset))->line);
d3683 1
a3683 1
     int signo;
d3690 1
a3691 1

d3725 1
a3725 1
init_history ()
d3739 7
a3745 8
    history_filename = savestring (tmpenv, strlen (tmpenv));
  else if (!history_filename)
    {
      /* We include the current directory so that if the user changes
         directories the file written will be the same as the one
         that was read.  */
      history_filename = concat (current_directory, "/.gdb_history", NULL);
    }
d3759 1
a3759 1
      gdb_prompt_string = savestring (DEFAULT_PROMPT, strlen (DEFAULT_PROMPT));
d3767 1
a3767 1
         whatever the DEFULAT_PROMPT is. */
d3769 1
a3769 1
      PREFIX (0) = "";
d3771 1
a3771 1
      PROMPT (0) = savestring (DEFAULT_PROMPT, strlen (DEFAULT_PROMPT));
d3773 1
a3773 1
      PROMPT (0) = savestring ("(gdb) ", 6);
d3775 1
a3775 1
      SUFFIX (0) = "";
d3777 1
a3777 1
         to use it. */
d3826 1
a3826 1
	"Print working directory.  This is used for your program as well.");
d3828 1
a3828 1
	       "Set working directory to DIR for debugger and program being debugged.\n\
d3840 1
a3840 1
	(add_set_cmd ("prompt", class_support, var_string,
d3847 2
a3848 2
      c = add_set_cmd ("prompt", class_support, var_string,
		       (char *) &new_async_prompt, "Set gdb's prompt",
d3855 1
a3855 1
    (add_set_cmd ("prompt-escape-char", class_support, var_zinteger,
d3882 1
a3882 1
	       "Read commands from a file named FILE.\n\
d3888 1
a3888 1
	       "Read commands from a file named FILE.\n\
d3903 1
a3903 1
  c = add_set_cmd ("verbose", class_support, var_boolean, (char *) &info_verbose,
d3906 1
a3906 1
    add_show_from_set (c, &showlist);
d3916 1
a3916 1
	(add_set_cmd ("editing", class_support, var_boolean, (char *) &command_editing_p,
d3925 1
a3925 1
      c = add_set_cmd ("editing", class_support, var_boolean, (char *) &async_command_editing_p,
d3943 2
a3944 2
    (add_set_cmd ("expansion", no_class, var_boolean, (char *) &history_expansion_p,
		  "Set history expansion on command input.\n\
d3949 2
a3950 2
    (add_set_cmd ("save", no_class, var_boolean, (char *) &write_history_p,
		  "Set saving of the history record on exit.\n\
d3955 1
a3955 1
  c = add_set_cmd ("size", no_class, var_integer, (char *) &history_size,
d3962 2
a3963 2
    (add_set_cmd ("filename", no_class, var_filename, (char *) &history_filename,
		  "Set the filename in which to record the command history\n\
d3969 1
a3969 1
		  (char *) &caution,
d3975 1
a3975 1
     "Generic command for showing things about the program being debugged.",
d3998 1
a3998 1
	   "Execute nested commands WHILE the conditional expression is non zero.\n\
d4004 1
a4004 1
	   "Execute nested commands once IF the conditional expression is non zero.\n\
d4013 1
a4013 1
				  var_zinteger, (char *) &baud_rate,
d4020 2
a4021 2
  add_set_cmd ("remotedebug", no_class, var_zinteger, (char *) &remote_debug,
	       "Set debugging of remote protocol.\n\
d4024 1
a4024 1
		      &showlist);
d4027 2
a4028 2
		      add_set_cmd ("remotetimeout", no_class, var_integer, (char *) &remote_timeout,
				   "Set timeout limit to wait for target to respond.\n\
d4031 1
a4031 1
		      &showlist);
d4039 2
a4040 2
      c = add_set_cmd ("annotate", class_obscure, var_zinteger,
		       (char *) &annotation_level, "Set annotation_level.\n\
d4048 2
a4049 2
      c = add_set_cmd ("annotate", class_obscure, var_zinteger,
		       (char *) &annotation_level, "Set annotation_level.\n\
d4052 1
a4052 1
		       &setlist);
@


1.1.1.11
log
@import gdb-1999-08-02 snapshot
@
text
@a682 6
#ifdef __MSDOS__
  /* Make sure we return to the original directory upon exit, come
     what may, since the OS doesn't do that for us.  */
  make_final_cleanup ((make_cleanup_func) chdir, strsave (current_directory));
#endif

a3364 7
#if defined(_WIN32) || defined(__MSDOS__)
  /* There's too much mess with DOSish names like "d:", "d:.",
     "d:./foo" etc.  Instead of having lots of special #ifdef'ed code,
     simply get the canonicalized name of the current directory.  */
  dir = getcwd (gdb_dirbuf, sizeof (gdb_dirbuf));
#endif

d3366 1
a3366 13
  if (SLASH_P (dir[len-1]))
    {
      /* Remove the trailing slash unless this is a root directory
	 (including a drive letter on non-Unix systems).  */
      if (!(len == 1) /* "/" */
#if defined(_WIN32) || defined(__MSDOS__)
	  && !(!SLASH_P (*dir) && ROOTED_P (dir) && len <= 3) /* "d:/" */
#endif
	  )
	len--;
    }

  dir = savestring (dir, len);
d3371 1
a3371 1
      if (SLASH_P (current_directory[strlen (current_directory) - 1]))
a3757 4
#ifdef __MSDOS__
    /* No leading dots in file names are allowed on MSDOS.  */
    history_filename = concat (current_directory, "/_gdb_history", NULL);
#else
a3758 1
#endif
@


1.1.1.12
log
@import gdb-1999-08-09 snapshot
@
text
@a447 3
/* Tell the GUI that the disassembly flavor has changed */
void (*disassembly_flavor_hook) PARAMS((char *args, int from_tty));

a461 5
/* Called after a `set' command has finished.  Is only run if the
   `set' command succeeded.  */

void (*set_hook) PARAMS ((struct cmd_list_element *c));

d1048 1
a1048 1
    internal_error ("Internal error, arg_cleanup called with no user args.\n");
d3811 1
a3811 1
         whatever the DEFAULT_PROMPT is. */
@


1.1.1.13
log
@import gdb-1999-08-16 snapshot
@
text
@d448 3
@


1.1.1.14
log
@import gdb-1999-08-30 snapshot
@
text
@d46 3
d155 4
a158 4
/* Default command line prompt.  This is overriden in some configs. */

#ifndef DEFAULT_PROMPT
#define DEFAULT_PROMPT	"(gdb) "
d3807 1
d3809 3
d3819 1
d3821 3
a4103 8
    }
  if (async_p)
    {
      add_show_from_set
	(add_set_cmd ("exec-done-display", class_support, var_boolean, (char *) &exec_done_display_p,
		      "Set notification of completion for asynchronous execution commands.\n\
Use \"on\" to enable the notification, and \"off\" to disable it.", &setlist),
	 &showlist);
@


1.1.1.15
log
@import gdb-1999-09-08 snapshot
@
text
@a36 1
#include "version.h"
d172 12
d3181 1
a3181 1
			  sprintf (outp, "%ld", (long) longval);
@


1.1.1.16
log
@import gdb-1999-09-21
@
text
@a48 1
#include "event-top.h"
@


1.1.1.17
log
@import gdb-1999-09-28 snapshot
@
text
@a419 6
/* Called as appropriate to notify the interface that we have attached
   to or detached from an already running process. */

void (*attach_hook) PARAMS ((void));
void (*detach_hook) PARAMS ((void));

d474 1
a474 1
return_to_top_level (reason)
d486 1
a486 1
  if (event_loop_p && target_can_async_p ())
a487 2
  if (event_loop_p && sync_execution)
    do_exec_error_cleanups (ALL_CLEANUPS);
d691 1
a691 1
  if (event_loop_p)
d1278 1
a1278 1
      if (event_loop_p && target_can_async_p () && target_executing)
d2103 1
a2103 1
      if (event_loop_p)
d2968 1
a2968 1
  if (event_loop_p)
d3204 1
a3204 1
      if (event_loop_p)
d3220 1
a3220 1
  if (event_loop_p)
d3792 1
a3792 1
  if (!event_loop_p)
d3865 1
a3865 1
  if (!event_loop_p)
d3941 1
a3941 1
  if (!event_loop_p)
d4065 1
a4065 1
  if (!event_loop_p)
d4084 1
a4084 1
  if (event_loop_p)
@


1.1.1.18
log
@import gdb-1999-10-04 snapshot
@
text
@d48 1
a48 1

@


1.1.1.19
log
@import gdb-1999-10-18 snapshot
@
text
@d394 4
@


1.1.1.20
log
@import gdb-1999-10-25 snapshot
@
text
@a688 1
  initialize_current_architecture ();
@


1.1.1.21
log
@import gdb-1999-11-08 snapshot
@
text
@a526 19
/* MAYBE: cagney/1999-11-05: catch_errors() in conjunction with
   error() et.al. could maintain a set of flags that indicate the the
   current state of each of the longjmp buffers.  This would give the
   longjmp code the chance to detect a longjmp botch (before it gets
   to longjmperror()).  Prior to 1999-11-05 this wasn't possible as
   code also randomly used a SET_TOP_LEVEL macro that directly
   initialize the longjmp buffers. */

/* MAYBE: cagney/1999-11-05: Since the SET_TOP_LEVEL macro has been
   eliminated it is now possible to use the stack to directly store
   each longjmp buffer.  The global code would just need to update a
   pointer (onto the stack - ulgh!?) indicating the current longjmp
   buffers. It would certainly improve the performance of the longjmp
   code since the memcpy's would be eliminated. */

/* MAYBE: cagney/1999-11-05: Should the catch_erros and cleanups code
   be consolidated into a single file instead of being distributed
   between utils.c and top.c? */

a563 8
      /* FIXME: cagney/1999-11-05: A correct FUNC implementaton will
         clean things up (restoring the cleanup chain) to the state
         they were just prior to the call.  Technically, this means
         that the below restore_cleanups call is redundant.
         Unfortunatly, many FUNC's are not that well behaved.
         restore_cleanups should either be replaced with a do_cleanups
         call (to cover the problem) or an assertion check to detect
         bad FUNCs code. */
a581 35

struct captured_command_args
  {
    catch_command_errors_ftype *command;
    char *arg;
    int from_tty;
  };

static int
do_captured_command (void *data)
{
  struct captured_command_args *context = data;
  context->command (context->arg, context->from_tty);
  /* FIXME: cagney/1999-11-07: Technically this do_cleanups() call
     isn't needed.  Instead an assertion check could be made that
     simply confirmed that the called function correctly cleaned up
     after its self.  Unfortunatly, old code (prior to 1999-11-04) in
     main.c was calling SET_TOP_LEVEL(), calling the command function,
     and then *always* calling do_cleanups().  For the moment we
     remain ``bug compatible'' with that old code..  */
  do_cleanups (ALL_CLEANUPS);
  return 1;
}

int
catch_command_errors (catch_command_errors_ftype *command,
		      char *arg, int from_tty, return_mask mask)
{
  struct captured_command_args args;
  args.command = command;
  args.arg = arg;
  args.from_tty = from_tty;
  return catch_errors (do_captured_command, &args, "", mask);
}

@


1.1.1.22
log
@import gdb-1999-12-06 snapshot
@
text
@d291 1
a291 1
   affects things like recording into the command history, commands
d475 1
a475 1
NORETURN void
@


1.1.1.23
log
@import gdb-1999-12-13 snapshot
@
text
@a47 1
#include <setjmp.h>
a466 12
/* Generally one should use catch_errors rather than manipulating these
   directly.  The exception is main().  */
#if defined(HAVE_SIGSETJMP)
#define SIGJMP_BUF		sigjmp_buf
#define SIGSETJMP(buf)		sigsetjmp(buf, 1)
#define SIGLONGJMP(buf,val)	siglongjmp(buf,val)
#else
#define SIGJMP_BUF		jmp_buf
#define SIGSETJMP(buf)		setjmp(buf)
#define SIGLONGJMP(buf,val)	longjmp(buf,val)
#endif

d468 1
a468 1
static SIGJMP_BUF error_return;
d470 1
a470 1
static SIGJMP_BUF quit_return;
d488 1
a488 1
  if (event_loop_p && target_can_async_p () && !target_executing)
@


1.1.1.24
log
@import gdb-2000-01-31 snapshot
@
text
@d379 4
@


1.1.1.25
log
@import gdb-2000-02-01 snapshot
@
text
@d2 2
a3 1
   Copyright 1986-2000 Free Software Foundation, Inc.
d843 1
a843 1
     struct ui_file *stream;
d2973 1
a2973 1
     struct ui_file *stream;
@


1.1.1.26
log
@import gdb-2000-02-02 snapshot
@
text
@a52 4
#ifdef UI_OUT
#include "ui-out.h"
#include "cli-out.h"
#endif
d777 2
a778 5
#ifdef UI_OUT
  /* Install the default UI */
  uiout = cli_out_new (gdb_stdout);
#endif

a837 91
#ifdef UI_OUT
void
print_command_lines (uiout, cmd, depth)
     struct ui_out *uiout;
     struct command_line *cmd;
     unsigned int depth;
{
  struct command_line *list;

  list = cmd;
  while (list)
    {

      if (depth)
	ui_out_spaces (uiout, 2 * depth);

      /* A simple command, print it and continue.  */
      if (list->control_type == simple_control)
	{
	  ui_out_field_string (uiout, NULL, list->line);
	  ui_out_text (uiout, "\n");
	  list = list->next;
	  continue;
	}

      /* loop_continue to jump to the start of a while loop, print it
         and continue. */
      if (list->control_type == continue_control)
	{
	  ui_out_field_string (uiout, NULL, "loop_continue");
	  ui_out_text (uiout, "\n");
	  list = list->next;
	  continue;
	}

      /* loop_break to break out of a while loop, print it and continue.  */
      if (list->control_type == break_control)
	{
	  ui_out_field_string (uiout, NULL, "loop_break");
	  ui_out_text (uiout, "\n");
	  list = list->next;
	  continue;
	}

      /* A while command.  Recursively print its subcommands and continue.  */
      if (list->control_type == while_control)
	{
	  ui_out_text (uiout, "while ");
	  ui_out_field_fmt (uiout, NULL, "while %s", list->line);
	  ui_out_text (uiout, "\n");
	  print_command_lines (uiout, *list->body_list, depth + 1);
	  ui_out_field_string (uiout, NULL, "end");
	  if (depth)
	    ui_out_spaces (uiout, 2 * depth);
	  ui_out_text (uiout, "end\n");
	  list = list->next;
	  continue;
	}

      /* An if command.  Recursively print both arms before continueing.  */
      if (list->control_type == if_control)
	{
	  ui_out_text (uiout, "if ");
	  ui_out_field_fmt (uiout, NULL, "if %s", list->line);
	  ui_out_text (uiout, "\n");
	  /* The true arm. */
	  print_command_lines (uiout, list->body_list[0], depth + 1);

	  /* Show the false arm if it exists.  */
	  if (list->body_count == 2)
	    {
	      if (depth)
		ui_out_spaces (uiout, 2 * depth);
	      ui_out_field_string (uiout, NULL, "else");
	      ui_out_text (uiout, "else\n");
	      print_command_lines (uiout, list->body_list[1], depth + 1);
	    }

	  ui_out_field_string (uiout, NULL, "end");
	  if (depth)
	    ui_out_spaces (uiout, 2 * depth);
	  ui_out_text (uiout, "end\n");
	  list = list->next;
	  continue;
	}

      /* ignore illegal command type and try next */
      list = list->next;
    }				/* while (list) */
}
#else
a917 1
#endif
a1516 35
/* Read commands from `instream' and execute them until end of file or
   error reading instream. This command loop doesnt care about any
   such things as displaying time and space usage. If the user asks
   for those, they won't work. */
void
simplified_command_loop (read_input_func, execute_command_func)
     char *(*read_input_func) (char *);
     void (*execute_command_func) (char *, int);
{
  struct cleanup *old_chain;
  char *command;
  int stdin_is_tty = ISATTY (stdin);

  while (instream && !feof (instream))
    {
      quit_flag = 0;
      if (instream == stdin && stdin_is_tty)
	reinitialize_more_filter ();
      old_chain = make_cleanup ((make_cleanup_func) command_loop_marker, 0);

      /* Get a command-line. */
      command = (*read_input_func) (instream == stdin ?
				    get_prompt () : (char *) NULL);

      if (command == 0)
	return;

      (*execute_command_func) (command, instream == stdin);

      /* Do any commands attached to breakpoint we stopped at.  */
      bpstat_do_actions (&stop_bpstat);

      do_cleanups (old_chain);
    }
}
a2977 4
#ifdef UI_OUT
  /* Print it console style until a format is defined */
  fprintf_filtered (stream, "GNU gdb %s (UI_OUT)\n", version);
#else
a2978 1
#endif
@


