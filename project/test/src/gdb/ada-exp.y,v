head	1.57;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.54
	gdb_7_6-2013-04-26-release:1.54
	gdb_7_6-branch:1.54.0.2
	gdb_7_6-2013-03-12-branchpoint:1.54
	gdb_7_5_1-2012-11-29-release:1.50
	gdb_7_5-2012-08-17-release:1.50
	gdb_7_5-branch:1.50.0.2
	gdb_7_5-2012-07-18-branchpoint:1.50
	gdb_7_4_1-2012-04-26-release:1.44.2.1
	gdb_7_4-2012-01-24-release:1.44.2.1
	gdb_7_4-branch:1.44.0.2
	gdb_7_4-2011-12-13-branchpoint:1.44
	gdb_7_3_1-2011-09-04-release:1.42
	gdb_7_3-2011-07-26-release:1.42
	gdb_7_3-branch:1.42.0.2
	gdb_7_3-2011-04-01-branchpoint:1.42
	gdb_7_2-2010-09-02-release:1.40
	gdb_7_2-branch:1.40.0.2
	gdb_7_2-2010-07-07-branchpoint:1.40
	gdb_7_1-2010-03-18-release:1.39
	gdb_7_1-branch:1.39.0.2
	gdb_7_1-2010-02-18-branchpoint:1.39
	gdb_7_0_1-2009-12-22-release:1.37
	gdb_7_0-2009-10-06-release:1.37
	gdb_7_0-branch:1.37.0.4
	gdb_7_0-2009-09-16-branchpoint:1.37
	arc-sim-20090309:1.24
	msnyder-checkpoint-072509-branch:1.37.0.2
	msnyder-checkpoint-072509-branchpoint:1.37
	arc-insight_6_8-branch:1.24.0.6
	arc-insight_6_8-branchpoint:1.24
	insight_6_8-branch:1.24.0.4
	insight_6_8-branchpoint:1.24
	reverse-20081226-branch:1.32.0.4
	reverse-20081226-branchpoint:1.32
	multiprocess-20081120-branch:1.32.0.2
	multiprocess-20081120-branchpoint:1.32
	reverse-20080930-branch:1.31.0.2
	reverse-20080930-branchpoint:1.31
	reverse-20080717-branch:1.28.0.4
	reverse-20080717-branchpoint:1.28
	msnyder-reverse-20080609-branch:1.28.0.2
	msnyder-reverse-20080609-branchpoint:1.28
	drow-reverse-20070409-branch:1.20.0.4
	drow-reverse-20070409-branchpoint:1.20
	gdb_6_8-2008-03-27-release:1.24
	gdb_6_8-branch:1.24.0.2
	gdb_6_8-2008-02-26-branchpoint:1.24
	gdb_6_7_1-2007-10-29-release:1.20
	gdb_6_7-2007-10-10-release:1.20
	gdb_6_7-branch:1.20.0.2
	gdb_6_7-2007-09-07-branchpoint:1.20
	insight_6_6-20070208-release:1.19
	gdb_6_6-2006-12-18-release:1.19
	gdb_6_6-branch:1.19.0.18
	gdb_6_6-2006-11-15-branchpoint:1.19
	insight_6_5-20061003-release:1.19
	gdb-csl-symbian-6_4_50_20060226-12:1.19
	gdb-csl-sourcerygxx-3_4_4-25:1.14
	nickrob-async-20060828-mergepoint:1.19
	gdb-csl-symbian-6_4_50_20060226-11:1.19
	gdb-csl-sourcerygxx-4_1-17:1.19
	gdb-csl-20060226-branch-local-2:1.19
	gdb-csl-sourcerygxx-4_1-14:1.19
	gdb-csl-sourcerygxx-4_1-13:1.19
	gdb-csl-sourcerygxx-4_1-12:1.19
	gdb-csl-sourcerygxx-3_4_4-21:1.19
	gdb_6_5-20060621-release:1.19
	gdb-csl-sourcerygxx-4_1-9:1.19
	gdb-csl-sourcerygxx-4_1-8:1.19
	gdb-csl-sourcerygxx-4_1-7:1.19
	gdb-csl-arm-2006q1-6:1.19
	gdb-csl-sourcerygxx-4_1-6:1.19
	gdb-csl-symbian-6_4_50_20060226-10:1.19
	gdb-csl-symbian-6_4_50_20060226-9:1.19
	gdb-csl-symbian-6_4_50_20060226-8:1.19
	gdb-csl-coldfire-4_1-11:1.19
	gdb-csl-sourcerygxx-3_4_4-19:1.19
	gdb-csl-coldfire-4_1-10:1.19
	gdb_6_5-branch:1.19.0.16
	gdb_6_5-2006-05-14-branchpoint:1.19
	gdb-csl-sourcerygxx-4_1-5:1.19
	nickrob-async-20060513-branch:1.19.0.14
	nickrob-async-20060513-branchpoint:1.19
	gdb-csl-sourcerygxx-4_1-4:1.19
	msnyder-reverse-20060502-branch:1.19.0.12
	msnyder-reverse-20060502-branchpoint:1.19
	gdb-csl-morpho-4_1-4:1.19
	gdb-csl-sourcerygxx-3_4_4-17:1.19
	readline_5_1-import-branch:1.19.0.10
	readline_5_1-import-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.19
	gdb-csl-symbian-20060226-branch:1.19.0.8
	gdb-csl-symbian-20060226-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.19
	msnyder-reverse-20060331-branch:1.19.0.6
	msnyder-reverse-20060331-branchpoint:1.19
	gdb-csl-available-20060303-branch:1.19.0.4
	gdb-csl-available-20060303-branchpoint:1.19
	gdb-csl-20060226-branch:1.19.0.2
	gdb-csl-20060226-branchpoint:1.19
	gdb_6_4-20051202-release:1.14
	msnyder-fork-checkpoint-branch:1.14.0.14
	msnyder-fork-checkpoint-branchpoint:1.14
	gdb-csl-gxxpro-6_3-branch:1.14.0.12
	gdb-csl-gxxpro-6_3-branchpoint:1.14
	gdb_6_4-branch:1.14.0.10
	gdb_6_4-2005-11-01-branchpoint:1.14
	gdb-csl-arm-20051020-branch:1.14.0.8
	gdb-csl-arm-20051020-branchpoint:1.14
	msnyder-tracepoint-checkpoint-branch:1.14.0.6
	msnyder-tracepoint-checkpoint-branchpoint:1.14
	gdb-csl-arm-20050325-2005-q1b:1.14
	gdb-csl-arm-20050325-2005-q1a:1.14
	csl-arm-20050325-branch:1.14.0.4
	csl-arm-20050325-branchpoint:1.14
	gdb-post-i18n-errorwarning-20050211:1.14
	gdb-pre-i18n-errorwarning-20050211:1.14
	gdb_6_3-20041109-release:1.14
	gdb_6_3-branch:1.14.0.2
	gdb_6_3-20041019-branchpoint:1.14
	drow_intercu-merge-20040921:1.12
	drow_intercu-merge-20040915:1.11
	jimb-gdb_6_2-e500-branch:1.11.0.6
	jimb-gdb_6_2-e500-branchpoint:1.11
	gdb_6_2-20040730-release:1.11
	gdb_6_2-branch:1.11.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.11
	gdb_6_1_1-20040616-release:1.8
	gdb_6_1-2004-04-05-release:1.8
	drow_intercu-merge-20040402:1.8
	drow_intercu-merge-20040327:1.8
	ezannoni_pie-20040323-branch:1.8.0.12
	ezannoni_pie-20040323-branchpoint:1.8
	cagney_tramp-20040321-mergepoint:1.8
	cagney_tramp-20040309-branch:1.8.0.10
	cagney_tramp-20040309-branchpoint:1.8
	gdb_6_1-branch:1.8.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.8
	drow_intercu-20040221-branch:1.8.0.6
	drow_intercu-20040221-branchpoint:1.8
	cagney_bfdfile-20040213-branch:1.8.0.4
	cagney_bfdfile-20040213-branchpoint:1.8
	drow-cplus-merge-20040208:1.8
	carlton_dictionary-20040126-merge:1.8
	cagney_bigcore-20040122-branch:1.8.0.2
	cagney_bigcore-20040122-branchpoint:1.8
	drow-cplus-merge-20040113:1.8
	drow-cplus-merge-20031224:1.8
	drow-cplus-merge-20031220:1.8
	carlton_dictionary-20031215-merge:1.8
	drow-cplus-merge-20031214:1.8
	carlton-dictionary-20031111-merge:1.7
	gdb_6_0-2003-10-04-release:1.7
	kettenis_sparc-20030918-branch:1.7.0.16
	kettenis_sparc-20030918-branchpoint:1.7
	carlton_dictionary-20030917-merge:1.7
	ezannoni_pie-20030916-branchpoint:1.7
	ezannoni_pie-20030916-branch:1.7.0.14
	cagney_x86i386-20030821-branch:1.7.0.12
	cagney_x86i386-20030821-branchpoint:1.7
	carlton_dictionary-20030805-merge:1.7
	carlton_dictionary-20030627-merge:1.7
	gdb_6_0-branch:1.7.0.10
	gdb_6_0-2003-06-23-branchpoint:1.7
	jimb-ppc64-linux-20030613-branch:1.7.0.8
	jimb-ppc64-linux-20030613-branchpoint:1.7
	cagney_convert-20030606-branch:1.7.0.6
	cagney_convert-20030606-branchpoint:1.7
	cagney_writestrings-20030508-branch:1.6.0.20
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.7.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.7
	carlton_dictionary-20030523-merge:1.7
	cagney_fileio-20030521-branch:1.7.0.2
	cagney_fileio-20030521-branchpoint:1.7
	kettenis_i386newframe-20030517-mergepoint:1.7
	jimb-ppc64-linux-20030509-branch:1.6.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.16
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.14
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.12
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.10
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.8
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.6
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.4
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.2
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.4
	interps-20030203-mergepoint:1.4
	interps-20030202-branch:1.4.0.8
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.6
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.3
	carlton_dictionary-20021115-merge:1.4
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.4
	drow-cplus-branch:1.4.0.4
	drow-cplus-branchpoint:1.4
	kseitz_interps-20020930-merge:1.4
	carlton_dictionary-20020927-merge:1.4
	carlton_dictionary-branch:1.4.0.2
	carlton_dictionary-20020920-branchpoint:1.4
	gdb_5_3-branch:1.3.0.2
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.4
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.2
	readline_4_3-import-branchpoint:1.2
	kseitz_interps-20020528-branch:1.1.0.4
	cagney_regbuf-20020515-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.57
date	2013.10.02.00.46.06;	author kseitz;	state Exp;
branches;
next	1.56;

1.56
date	2013.09.24.19.41.35;	author brobecke;	state Exp;
branches;
next	1.55;

1.55
date	2013.08.05.15.51.02;	author tromey;	state Exp;
branches;
next	1.54;

1.54
date	2013.03.05.21.15.34;	author devans;	state Exp;
branches;
next	1.53;

1.53
date	2013.01.21.18.13.11;	author tromey;	state Exp;
branches;
next	1.52;

1.52
date	2013.01.01.06.32.36;	author brobecke;	state Exp;
branches;
next	1.51;

1.51
date	2012.12.03.19.59.13;	author tromey;	state Exp;
branches;
next	1.50;

1.50
date	2012.04.18.06.46.45;	author jkratoch;	state Exp;
branches;
next	1.49;

1.49
date	2012.04.09.17.07.42;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2012.03.29.18.23.00;	author brobecke;	state Exp;
branches;
next	1.47;

1.47
date	2012.02.29.19.51.49;	author brobecke;	state Exp;
branches;
next	1.46;

1.46
date	2012.02.01.15.49.33;	author tromey;	state Exp;
branches;
next	1.45;

1.45
date	2012.01.04.08.16.55;	author brobecke;	state Exp;
branches;
next	1.44;

1.44
date	2011.12.11.02.27.24;	author ndreys;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2011.07.01.18.25.16;	author brobecke;	state Exp;
branches;
next	1.42;

1.42
date	2011.02.28.04.33.26;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2011.01.01.15.32.55;	author brobecke;	state Exp;
branches;
next	1.40;

1.40
date	2010.05.06.00.08.38;	author msnyder;	state Exp;
branches;
next	1.39;

1.39
date	2010.01.01.07.31.29;	author brobecke;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.06.21.27.59;	author muller;	state Exp;
branches;
next	1.37;

1.37
date	2009.04.14.19.04.24;	author muller;	state Exp;
branches;
next	1.36;

1.36
date	2009.03.24.02.08.23;	author brobecke;	state Exp;
branches;
next	1.35;

1.35
date	2009.03.18.08.51.10;	author nathan;	state Exp;
branches;
next	1.34;

1.34
date	2009.02.21.16.14.47;	author palves;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.03.05.57.50;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2008.10.25.02.16.39;	author palves;	state Exp;
branches;
next	1.31;

1.31
date	2008.09.11.14.09.37;	author uweigand;	state Exp;
branches;
next	1.30;

1.30
date	2008.09.11.14.08.33;	author uweigand;	state Exp;
branches;
next	1.29;

1.29
date	2008.08.19.10.10.39;	author hilfingr;	state Exp;
branches;
next	1.28;

1.28
date	2008.05.27.19.29.51;	author schwab;	state Exp;
branches;
next	1.27;

1.27
date	2008.05.22.17.00.07;	author uweigand;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.22.16.59.00;	author uweigand;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.19.15.49.14;	author uweigand;	state Exp;
branches;
next	1.24;

1.24
date	2008.01.04.19.46.28;	author brobecke;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.04.15.04.10;	author brobecke;	state Exp;
branches;
next	1.22;

1.22
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2007.12.21.11.50.11;	author brobecke;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.09.17.58.49;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2006.01.12.08.36.29;	author hilfingr;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.08.07.19.39;	author hilfingr;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.02.10.38.03;	author hilfingr;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.02.09.46.34;	author hilfingr;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.15.13.29.33;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.06.09.28.55;	author hilfingr;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.18.22.23.23;	author hilfingr;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.09.19.29.56;	author hilfingr;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.01.10.11.11;	author hilfingr;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.02.09.55.36;	author hilfingr;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.23.20.41.16;	author cagney;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	2003.05.14.17.43.15;	author ezannoni;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.25.21.36.15;	author carlton;	state Exp;
branches
	1.6.16.1;
next	1.5;

1.5
date	2003.02.20.00.01.04;	author carlton;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.19.13.59.26;	author brobecke;	state Exp;
branches
	1.4.2.1
	1.4.4.1;
next	1.3;

1.3
date	2002.09.03.02.45.56;	author thorpej;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.21.14.32.10;	author muller;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.04.15.28.47;	author aidan;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.44.2.1
date	2012.01.06.04.43.02;	author brobecke;	state Exp;
branches;
next	;

1.8.6.1
date	2004.09.16.17.00.51;	author drow;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2004.09.21.20.44.12;	author drow;	state Exp;
branches;
next	;

1.6.16.1
date	2003.05.18.09.43.56;	author kettenis;	state Exp;
branches;
next	;

1.4.2.1
date	2002.10.18.23.42.57;	author carlton;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2003.01.21.01.02.29;	author carlton;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2003.03.06.00.56.22;	author carlton;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2003.05.23.18.40.34;	author carlton;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2003.09.20.00.32.30;	author carlton;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2003.12.16.00.00.09;	author carlton;	state Exp;
branches;
next	;

1.4.4.1
date	2003.12.14.20.27.04;	author drow;	state Exp;
branches;
next	;

1.1.2.1
date	2002.06.15.16.42.49;	author cagney;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.06.21.16.46.50;	author cagney;	state Exp;
branches;
next	;

1.1.4.1
date	2002.06.20.01.31.59;	author kseitz;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.07.22.21.46.55;	author kseitz;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.10.01.00.46.00;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Constification of parse_linespec and fallout:
https://sourceware.org/ml/gdb-patches/2013-09/msg01017.html
https://sourceware.org/ml/gdb-patches/2013-09/msg01018.html
https://sourceware.org/ml/gdb-patches/2013-09/msg01019.html
https://sourceware.org/ml/gdb-patches/2013-09/msg01020.html
@
text
@/* YACC parser for Ada expressions, for GDB.
   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Parse an Ada expression from text in a string,
   and return the result as a  struct expression  pointer.
   That structure contains arithmetic operations in reverse polish,
   with constants represented by operations that are followed by special data.
   See expression.h for the details of the format.
   What is important here is that it can be built up sequentially
   during the process of parsing; the lower levels of the tree always
   come first in the result.

   malloc's and realloc's in this file are transformed to
   xmalloc and xrealloc respectively by the same sed command in the
   makefile that remaps any other malloc/realloc inserted by the parser
   generator.  Doing this with #defines and trying to control the interaction
   with include files (<malloc.h> and <stdlib.h> for example) just became
   too messy, particularly when such includes can be inserted at random
   times by the parser generator.  */

%{

#include "defs.h"
#include "gdb_string.h"
#include <ctype.h>
#include "expression.h"
#include "value.h"
#include "parser-defs.h"
#include "language.h"
#include "ada-lang.h"
#include "bfd.h" /* Required by objfiles.h.  */
#include "symfile.h" /* Required by objfiles.h.  */
#include "objfiles.h" /* For have_full_symbols and have_partial_symbols */
#include "frame.h"
#include "block.h"

#define parse_type builtin_type (parse_gdbarch)

/* Remap normal yacc parser interface names (yyparse, yylex, yyerror, etc),
   as well as gratuitiously global symbol names, so we can have multiple
   yacc generated parsers in gdb.  These are only the variables
   produced by yacc.  If other parser generators (bison, byacc, etc) produce
   additional global names that conflict at link time, then those parser
   generators need to be fixed instead of adding those names to this list.  */

/* NOTE: This is clumsy, especially since BISON and FLEX provide --prefix
   options.  I presume we are maintaining it to accommodate systems
   without BISON?  (PNH) */

#define	yymaxdepth ada_maxdepth
#define	yyparse	_ada_parse	/* ada_parse calls this after  initialization */
#define	yylex	ada_lex
#define	yyerror	ada_error
#define	yylval	ada_lval
#define	yychar	ada_char
#define	yydebug	ada_debug
#define	yypact	ada_pact
#define	yyr1	ada_r1
#define	yyr2	ada_r2
#define	yydef	ada_def
#define	yychk	ada_chk
#define	yypgo	ada_pgo
#define	yyact	ada_act
#define	yyexca	ada_exca
#define yyerrflag ada_errflag
#define yynerrs	ada_nerrs
#define	yyps	ada_ps
#define	yypv	ada_pv
#define	yys	ada_s
#define	yy_yys	ada_yys
#define	yystate	ada_state
#define	yytmp	ada_tmp
#define	yyv	ada_v
#define	yy_yyv	ada_yyv
#define	yyval	ada_val
#define	yylloc	ada_lloc
#define yyreds	ada_reds		/* With YYDEBUG defined */
#define yytoks	ada_toks		/* With YYDEBUG defined */
#define yyname	ada_name		/* With YYDEBUG defined */
#define yyrule	ada_rule		/* With YYDEBUG defined */
#define yyss	ada_yyss
#define yysslim	ada_yysslim
#define yyssp	ada_yyssp
#define yystacksize ada_yystacksize
#define yyvs	ada_yyvs
#define yyvsp	ada_yyvsp

#ifndef YYDEBUG
#define	YYDEBUG	1		/* Default to yydebug support */
#endif

#define YYFPRINTF parser_fprintf

struct name_info {
  struct symbol *sym;
  struct minimal_symbol *msym;
  struct block *block;
  struct stoken stoken;
};

static struct stoken empty_stoken = { "", 0 };

/* If expression is in the context of TYPE'(...), then TYPE, else
 * NULL.  */
static struct type *type_qualifier;

int yyparse (void);

static int yylex (void);

void yyerror (char *);

static void write_int (LONGEST, struct type *);

static void write_object_renaming (const struct block *, const char *, int,
				   const char *, int);

static struct type* write_var_or_type (const struct block *, struct stoken);

static void write_name_assoc (struct stoken);

static void write_exp_op_with_string (enum exp_opcode, struct stoken);

static struct block *block_lookup (struct block *, const char *);

static LONGEST convert_char_literal (struct type *, LONGEST);

static void write_ambiguous_var (const struct block *, char *, int);

static struct type *type_int (void);

static struct type *type_long (void);

static struct type *type_long_long (void);

static struct type *type_float (void);

static struct type *type_double (void);

static struct type *type_long_double (void);

static struct type *type_char (void);

static struct type *type_boolean (void);

static struct type *type_system_address (void);

%}

%union
  {
    LONGEST lval;
    struct {
      LONGEST val;
      struct type *type;
    } typed_val;
    struct {
      DOUBLEST dval;
      struct type *type;
    } typed_val_float;
    struct type *tval;
    struct stoken sval;
    struct block *bval;
    struct internalvar *ivar;
  }

%type <lval> positional_list component_groups component_associations
%type <lval> aggregate_component_list 
%type <tval> var_or_type

%token <typed_val> INT NULL_PTR CHARLIT
%token <typed_val_float> FLOAT
%token TRUEKEYWORD FALSEKEYWORD
%token COLONCOLON
%token <sval> STRING NAME DOT_ID 
%type <bval> block
%type <lval> arglist tick_arglist

%type <tval> save_qualifier

%token DOT_ALL

/* Special type cases, put in to allow the parser to distinguish different
   legal basetypes.  */
%token <sval> SPECIAL_VARIABLE

%nonassoc ASSIGN
%left _AND_ OR XOR THEN ELSE
%left '=' NOTEQUAL '<' '>' LEQ GEQ IN DOTDOT
%left '@@'
%left '+' '-' '&'
%left UNARY
%left '*' '/' MOD REM
%right STARSTAR ABS NOT

/* Artificial token to give NAME => ... and NAME | priority over reducing 
   NAME to <primary> and to give <primary>' priority over reducing <primary>
   to <simple_exp>. */
%nonassoc VAR

%nonassoc ARROW '|'

%right TICK_ACCESS TICK_ADDRESS TICK_FIRST TICK_LAST TICK_LENGTH
%right TICK_MAX TICK_MIN TICK_MODULUS
%right TICK_POS TICK_RANGE TICK_SIZE TICK_TAG TICK_VAL
 /* The following are right-associative only so that reductions at this
    precedence have lower precedence than '.' and '('.  The syntax still
    forces a.b.c, e.g., to be LEFT-associated.  */
%right '.' '(' '[' DOT_ID DOT_ALL

%token NEW OTHERS


%%

start   :	exp1
	;

/* Expressions, including the sequencing operator.  */
exp1	:	exp
	|	exp1 ';' exp
			{ write_exp_elt_opcode (BINOP_COMMA); }
	| 	primary ASSIGN exp   /* Extension for convenience */
			{ write_exp_elt_opcode (BINOP_ASSIGN); }
	;

/* Expressions, not including the sequencing operator.  */
primary :	primary DOT_ALL
			{ write_exp_elt_opcode (UNOP_IND); }
	;

primary :	primary DOT_ID
			{ write_exp_op_with_string (STRUCTOP_STRUCT, $2); }
	;

primary :	primary '(' arglist ')'
			{
			  write_exp_elt_opcode (OP_FUNCALL);
			  write_exp_elt_longcst ($3);
			  write_exp_elt_opcode (OP_FUNCALL);
		        }
	|	var_or_type '(' arglist ')'
			{
			  if ($1 != NULL)
			    {
			      if ($3 != 1)
				error (_("Invalid conversion"));
			      write_exp_elt_opcode (UNOP_CAST);
			      write_exp_elt_type ($1);
			      write_exp_elt_opcode (UNOP_CAST);
			    }
			  else
			    {
			      write_exp_elt_opcode (OP_FUNCALL);
			      write_exp_elt_longcst ($3);
			      write_exp_elt_opcode (OP_FUNCALL);
			    }
			}
	;

primary :	var_or_type '\'' save_qualifier { type_qualifier = $1; } 
		   '(' exp ')'
			{
			  if ($1 == NULL)
			    error (_("Type required for qualification"));
			  write_exp_elt_opcode (UNOP_QUAL);
			  write_exp_elt_type ($1);
			  write_exp_elt_opcode (UNOP_QUAL);
			  type_qualifier = $3;
			}
	;

save_qualifier : 	{ $$ = type_qualifier; }
	;

primary :
		primary '(' simple_exp DOTDOT simple_exp ')'
			{ write_exp_elt_opcode (TERNOP_SLICE); }
	|	var_or_type '(' simple_exp DOTDOT simple_exp ')'
			{ if ($1 == NULL) 
                            write_exp_elt_opcode (TERNOP_SLICE);
			  else
			    error (_("Cannot slice a type"));
			}
	;

primary :	'(' exp1 ')'	{ }
	;

/* The following rule causes a conflict with the type conversion
       var_or_type (exp)
   To get around it, we give '(' higher priority and add bridge rules for 
       var_or_type (exp, exp, ...)
       var_or_type (exp .. exp)
   We also have the action for  var_or_type(exp) generate a function call
   when the first symbol does not denote a type. */

primary :	var_or_type	%prec VAR
			{ if ($1 != NULL)
			    {
			      write_exp_elt_opcode (OP_TYPE);
			      write_exp_elt_type ($1);
			      write_exp_elt_opcode (OP_TYPE);
			    }
			}
	;

primary :	SPECIAL_VARIABLE /* Various GDB extensions */
			{ write_dollar_variable ($1); }
	;

primary :     	aggregate
        ;        

simple_exp : 	primary
	;

simple_exp :	'-' simple_exp    %prec UNARY
			{ write_exp_elt_opcode (UNOP_NEG); }
	;

simple_exp :	'+' simple_exp    %prec UNARY
			{ write_exp_elt_opcode (UNOP_PLUS); }
	;

simple_exp :	NOT simple_exp    %prec UNARY
			{ write_exp_elt_opcode (UNOP_LOGICAL_NOT); }
	;

simple_exp :    ABS simple_exp	   %prec UNARY
			{ write_exp_elt_opcode (UNOP_ABS); }
	;

arglist	:		{ $$ = 0; }
	;

arglist	:	exp
			{ $$ = 1; }
	|	NAME ARROW exp
			{ $$ = 1; }
	|	arglist ',' exp
			{ $$ = $1 + 1; }
	|	arglist ',' NAME ARROW exp
			{ $$ = $1 + 1; }
	;

primary :	'{' var_or_type '}' primary  %prec '.'
		/* GDB extension */
			{ 
			  if ($2 == NULL)
			    error (_("Type required within braces in coercion"));
			  write_exp_elt_opcode (UNOP_MEMVAL);
			  write_exp_elt_type ($2);
			  write_exp_elt_opcode (UNOP_MEMVAL);
			}
	;

/* Binary operators in order of decreasing precedence.  */

simple_exp 	: 	simple_exp STARSTAR simple_exp
			{ write_exp_elt_opcode (BINOP_EXP); }
	;

simple_exp	:	simple_exp '*' simple_exp
			{ write_exp_elt_opcode (BINOP_MUL); }
	;

simple_exp	:	simple_exp '/' simple_exp
			{ write_exp_elt_opcode (BINOP_DIV); }
	;

simple_exp	:	simple_exp REM simple_exp /* May need to be fixed to give correct Ada REM */
			{ write_exp_elt_opcode (BINOP_REM); }
	;

simple_exp	:	simple_exp MOD simple_exp
			{ write_exp_elt_opcode (BINOP_MOD); }
	;

simple_exp	:	simple_exp '@@' simple_exp	/* GDB extension */
			{ write_exp_elt_opcode (BINOP_REPEAT); }
	;

simple_exp	:	simple_exp '+' simple_exp
			{ write_exp_elt_opcode (BINOP_ADD); }
	;

simple_exp	:	simple_exp '&' simple_exp
			{ write_exp_elt_opcode (BINOP_CONCAT); }
	;

simple_exp	:	simple_exp '-' simple_exp
			{ write_exp_elt_opcode (BINOP_SUB); }
	;

relation :	simple_exp
	;

relation :	simple_exp '=' simple_exp
			{ write_exp_elt_opcode (BINOP_EQUAL); }
	;

relation :	simple_exp NOTEQUAL simple_exp
			{ write_exp_elt_opcode (BINOP_NOTEQUAL); }
	;

relation :	simple_exp LEQ simple_exp
			{ write_exp_elt_opcode (BINOP_LEQ); }
	;

relation :	simple_exp IN simple_exp DOTDOT simple_exp
			{ write_exp_elt_opcode (TERNOP_IN_RANGE); }
        |       simple_exp IN primary TICK_RANGE tick_arglist
			{ write_exp_elt_opcode (BINOP_IN_BOUNDS);
			  write_exp_elt_longcst ((LONGEST) $5);
			  write_exp_elt_opcode (BINOP_IN_BOUNDS);
			}
 	|	simple_exp IN var_or_type	%prec TICK_ACCESS
			{ 
			  if ($3 == NULL)
			    error (_("Right operand of 'in' must be type"));
			  write_exp_elt_opcode (UNOP_IN_RANGE);
		          write_exp_elt_type ($3);
		          write_exp_elt_opcode (UNOP_IN_RANGE);
			}
	|	simple_exp NOT IN simple_exp DOTDOT simple_exp
			{ write_exp_elt_opcode (TERNOP_IN_RANGE);
		          write_exp_elt_opcode (UNOP_LOGICAL_NOT);
			}
        |       simple_exp NOT IN primary TICK_RANGE tick_arglist
			{ write_exp_elt_opcode (BINOP_IN_BOUNDS);
			  write_exp_elt_longcst ((LONGEST) $6);
			  write_exp_elt_opcode (BINOP_IN_BOUNDS);
		          write_exp_elt_opcode (UNOP_LOGICAL_NOT);
			}
 	|	simple_exp NOT IN var_or_type	%prec TICK_ACCESS
			{ 
			  if ($4 == NULL)
			    error (_("Right operand of 'in' must be type"));
			  write_exp_elt_opcode (UNOP_IN_RANGE);
		          write_exp_elt_type ($4);
		          write_exp_elt_opcode (UNOP_IN_RANGE);
		          write_exp_elt_opcode (UNOP_LOGICAL_NOT);
			}
	;

relation :	simple_exp GEQ simple_exp
			{ write_exp_elt_opcode (BINOP_GEQ); }
	;

relation :	simple_exp '<' simple_exp
			{ write_exp_elt_opcode (BINOP_LESS); }
	;

relation :	simple_exp '>' simple_exp
			{ write_exp_elt_opcode (BINOP_GTR); }
	;

exp	:	relation
	|	and_exp
	|	and_then_exp
	|	or_exp
	|	or_else_exp
	|	xor_exp
	;

and_exp :
		relation _AND_ relation 
			{ write_exp_elt_opcode (BINOP_BITWISE_AND); }
	|	and_exp _AND_ relation
			{ write_exp_elt_opcode (BINOP_BITWISE_AND); }
	;

and_then_exp :
	       relation _AND_ THEN relation
			{ write_exp_elt_opcode (BINOP_LOGICAL_AND); }
	|	and_then_exp _AND_ THEN relation
			{ write_exp_elt_opcode (BINOP_LOGICAL_AND); }
        ;

or_exp :
		relation OR relation 
			{ write_exp_elt_opcode (BINOP_BITWISE_IOR); }
	|	or_exp OR relation
			{ write_exp_elt_opcode (BINOP_BITWISE_IOR); }
	;

or_else_exp :
	       relation OR ELSE relation
			{ write_exp_elt_opcode (BINOP_LOGICAL_OR); }
	|      or_else_exp OR ELSE relation
			{ write_exp_elt_opcode (BINOP_LOGICAL_OR); }
        ;

xor_exp :       relation XOR relation
			{ write_exp_elt_opcode (BINOP_BITWISE_XOR); }
	|	xor_exp XOR relation
			{ write_exp_elt_opcode (BINOP_BITWISE_XOR); }
        ;

/* Primaries can denote types (OP_TYPE).  In cases such as 
   primary TICK_ADDRESS, where a type would be invalid, it will be
   caught when evaluate_subexp in ada-lang.c tries to evaluate the
   primary, expecting a value.  Precedence rules resolve the ambiguity
   in NAME TICK_ACCESS in favor of shifting to form a var_or_type.  A
   construct such as aType'access'access will again cause an error when
   aType'access evaluates to a type that evaluate_subexp attempts to 
   evaluate. */
primary :	primary TICK_ACCESS
			{ write_exp_elt_opcode (UNOP_ADDR); }
	|	primary TICK_ADDRESS
			{ write_exp_elt_opcode (UNOP_ADDR);
			  write_exp_elt_opcode (UNOP_CAST);
			  write_exp_elt_type (type_system_address ());
			  write_exp_elt_opcode (UNOP_CAST);
			}
	|	primary TICK_FIRST tick_arglist
			{ write_int ($3, type_int ());
			  write_exp_elt_opcode (OP_ATR_FIRST); }
	|	primary TICK_LAST tick_arglist
			{ write_int ($3, type_int ());
			  write_exp_elt_opcode (OP_ATR_LAST); }
	| 	primary TICK_LENGTH tick_arglist
			{ write_int ($3, type_int ());
			  write_exp_elt_opcode (OP_ATR_LENGTH); }
        |       primary TICK_SIZE
			{ write_exp_elt_opcode (OP_ATR_SIZE); }
	|	primary TICK_TAG
			{ write_exp_elt_opcode (OP_ATR_TAG); }
        |       opt_type_prefix TICK_MIN '(' exp ',' exp ')'
			{ write_exp_elt_opcode (OP_ATR_MIN); }
        |       opt_type_prefix TICK_MAX '(' exp ',' exp ')'
			{ write_exp_elt_opcode (OP_ATR_MAX); }
	| 	opt_type_prefix TICK_POS '(' exp ')'
			{ write_exp_elt_opcode (OP_ATR_POS); }
	|	type_prefix TICK_VAL '(' exp ')'
			{ write_exp_elt_opcode (OP_ATR_VAL); }
	|	type_prefix TICK_MODULUS
			{ write_exp_elt_opcode (OP_ATR_MODULUS); }
	;

tick_arglist :			%prec '('
			{ $$ = 1; }
	| 	'(' INT ')'
			{ $$ = $2.val; }
	;

type_prefix :
                var_or_type
			{ 
			  if ($1 == NULL)
			    error (_("Prefix must be type"));
			  write_exp_elt_opcode (OP_TYPE);
			  write_exp_elt_type ($1);
			  write_exp_elt_opcode (OP_TYPE); }
	;

opt_type_prefix :
		type_prefix
	| 	/* EMPTY */
			{ write_exp_elt_opcode (OP_TYPE);
			  write_exp_elt_type (parse_type->builtin_void);
			  write_exp_elt_opcode (OP_TYPE); }
	;


primary	:	INT
			{ write_int ((LONGEST) $1.val, $1.type); }
	;

primary	:	CHARLIT
                  { write_int (convert_char_literal (type_qualifier, $1.val),
			       (type_qualifier == NULL) 
			       ? $1.type : type_qualifier);
		  }
	;

primary	:	FLOAT
			{ write_exp_elt_opcode (OP_DOUBLE);
			  write_exp_elt_type ($1.type);
			  write_exp_elt_dblcst ($1.dval);
			  write_exp_elt_opcode (OP_DOUBLE);
			}
	;

primary	:	NULL_PTR
			{ write_int (0, type_int ()); }
	;

primary	:	STRING
			{ 
			  write_exp_op_with_string (OP_STRING, $1);
			}
	;

primary :	TRUEKEYWORD
			{ write_int (1, type_boolean ()); }
        |	FALSEKEYWORD
			{ write_int (0, type_boolean ()); }
	;

primary	: 	NEW NAME
			{ error (_("NEW not implemented.")); }
	;

var_or_type:	NAME   	    %prec VAR
				{ $$ = write_var_or_type (NULL, $1); } 
	|	block NAME  %prec VAR
                                { $$ = write_var_or_type ($1, $2); }
	|       NAME TICK_ACCESS 
			{ 
			  $$ = write_var_or_type (NULL, $1);
			  if ($$ == NULL)
			    write_exp_elt_opcode (UNOP_ADDR);
			  else
			    $$ = lookup_pointer_type ($$);
			}
	|	block NAME TICK_ACCESS
			{ 
			  $$ = write_var_or_type ($1, $2);
			  if ($$ == NULL)
			    write_exp_elt_opcode (UNOP_ADDR);
			  else
			    $$ = lookup_pointer_type ($$);
			}
	;

/* GDB extension */
block   :       NAME COLONCOLON
			{ $$ = block_lookup (NULL, $1.ptr); }
	|	block NAME COLONCOLON
			{ $$ = block_lookup ($1, $2.ptr); }
	;

aggregate :
		'(' aggregate_component_list ')'  
			{
			  write_exp_elt_opcode (OP_AGGREGATE);
			  write_exp_elt_longcst ($2);
			  write_exp_elt_opcode (OP_AGGREGATE);
		        }
	;

aggregate_component_list :
		component_groups	 { $$ = $1; }
	|	positional_list exp
			{ write_exp_elt_opcode (OP_POSITIONAL);
			  write_exp_elt_longcst ($1);
			  write_exp_elt_opcode (OP_POSITIONAL);
			  $$ = $1 + 1;
			}
	|	positional_list component_groups
					 { $$ = $1 + $2; }
	;

positional_list :
		exp ','
			{ write_exp_elt_opcode (OP_POSITIONAL);
			  write_exp_elt_longcst (0);
			  write_exp_elt_opcode (OP_POSITIONAL);
			  $$ = 1;
			} 
	|	positional_list exp ','
			{ write_exp_elt_opcode (OP_POSITIONAL);
			  write_exp_elt_longcst ($1);
			  write_exp_elt_opcode (OP_POSITIONAL);
			  $$ = $1 + 1; 
			}
	;

component_groups:
		others			 { $$ = 1; }
	|	component_group		 { $$ = 1; }
	|	component_group ',' component_groups
					 { $$ = $3 + 1; }
	;

others 	:	OTHERS ARROW exp
			{ write_exp_elt_opcode (OP_OTHERS); }
	;

component_group :
		component_associations
			{
			  write_exp_elt_opcode (OP_CHOICES);
			  write_exp_elt_longcst ($1);
			  write_exp_elt_opcode (OP_CHOICES);
		        }
	;

/* We use this somewhat obscure definition in order to handle NAME => and
   NAME | differently from exp => and exp |.  ARROW and '|' have a precedence
   above that of the reduction of NAME to var_or_type.  By delaying 
   decisions until after the => or '|', we convert the ambiguity to a 
   resolved shift/reduce conflict. */
component_associations :
		NAME ARROW 
			{ write_name_assoc ($1); }
		    exp	{ $$ = 1; }
	|	simple_exp ARROW exp
			{ $$ = 1; }
	|	simple_exp DOTDOT simple_exp ARROW 
			{ write_exp_elt_opcode (OP_DISCRETE_RANGE);
			  write_exp_op_with_string (OP_NAME, empty_stoken);
			}
		    exp { $$ = 1; }
	|	NAME '|' 
		        { write_name_assoc ($1); }
		    component_associations  { $$ = $4 + 1; }
	|	simple_exp '|'  
	            component_associations  { $$ = $3 + 1; }
	|	simple_exp DOTDOT simple_exp '|'
			{ write_exp_elt_opcode (OP_DISCRETE_RANGE); }
		    component_associations  { $$ = $6 + 1; }
	;

/* Some extensions borrowed from C, for the benefit of those who find they
   can't get used to Ada notation in GDB.  */

primary	:	'*' primary		%prec '.'
			{ write_exp_elt_opcode (UNOP_IND); }
	|	'&' primary		%prec '.'
			{ write_exp_elt_opcode (UNOP_ADDR); }
	|	primary '[' exp ']'
			{ write_exp_elt_opcode (BINOP_SUBSCRIPT); }
	;

%%

/* yylex defined in ada-lex.c: Reads one token, getting characters */
/* through lexptr.  */

/* Remap normal flex interface names (yylex) as well as gratuitiously */
/* global symbol names, so we can have multiple flex-generated parsers */
/* in gdb.  */

/* (See note above on previous definitions for YACC.) */

#define yy_create_buffer ada_yy_create_buffer
#define yy_delete_buffer ada_yy_delete_buffer
#define yy_init_buffer ada_yy_init_buffer
#define yy_load_buffer_state ada_yy_load_buffer_state
#define yy_switch_to_buffer ada_yy_switch_to_buffer
#define yyrestart ada_yyrestart
#define yytext ada_yytext
#define yywrap ada_yywrap

static struct obstack temp_parse_space;

/* The following kludge was found necessary to prevent conflicts between */
/* defs.h and non-standard stdlib.h files.  */
#define qsort __qsort__dummy
#include "ada-lex.c"

int
ada_parse (void)
{
  lexer_init (yyin);		/* (Re-)initialize lexer.  */
  type_qualifier = NULL;
  obstack_free (&temp_parse_space, NULL);
  obstack_init (&temp_parse_space);

  return _ada_parse ();
}

void
yyerror (char *msg)
{
  error (_("Error in expression, near `%s'."), lexptr);
}

/* Emit expression to access an instance of SYM, in block BLOCK (if
 * non-NULL), and with :: qualification ORIG_LEFT_CONTEXT.  */
static void
write_var_from_sym (const struct block *orig_left_context,
		    const struct block *block,
		    struct symbol *sym)
{
  if (orig_left_context == NULL && symbol_read_needs_frame (sym))
    {
      if (innermost_block == 0
	  || contained_in (block, innermost_block))
	innermost_block = block;
    }

  write_exp_elt_opcode (OP_VAR_VALUE);
  write_exp_elt_block (block);
  write_exp_elt_sym (sym);
  write_exp_elt_opcode (OP_VAR_VALUE);
}

/* Write integer or boolean constant ARG of type TYPE.  */

static void
write_int (LONGEST arg, struct type *type)
{
  write_exp_elt_opcode (OP_LONG);
  write_exp_elt_type (type);
  write_exp_elt_longcst (arg);
  write_exp_elt_opcode (OP_LONG);
}

/* Write an OPCODE, string, OPCODE sequence to the current expression.  */
static void
write_exp_op_with_string (enum exp_opcode opcode, struct stoken token)
{
  write_exp_elt_opcode (opcode);
  write_exp_string (token);
  write_exp_elt_opcode (opcode);
}
  
/* Emit expression corresponding to the renamed object named 
 * designated by RENAMED_ENTITY[0 .. RENAMED_ENTITY_LEN-1] in the
 * context of ORIG_LEFT_CONTEXT, to which is applied the operations
 * encoded by RENAMING_EXPR.  MAX_DEPTH is the maximum number of
 * cascaded renamings to allow.  If ORIG_LEFT_CONTEXT is null, it
 * defaults to the currently selected block. ORIG_SYMBOL is the 
 * symbol that originally encoded the renaming.  It is needed only
 * because its prefix also qualifies any index variables used to index
 * or slice an array.  It should not be necessary once we go to the
 * new encoding entirely (FIXME pnh 7/20/2007).  */

static void
write_object_renaming (const struct block *orig_left_context,
		       const char *renamed_entity, int renamed_entity_len,
		       const char *renaming_expr, int max_depth)
{
  char *name;
  enum { SIMPLE_INDEX, LOWER_BOUND, UPPER_BOUND } slice_state;
  struct ada_symbol_info sym_info;

  if (max_depth <= 0)
    error (_("Could not find renamed symbol"));

  if (orig_left_context == NULL)
    orig_left_context = get_selected_block (NULL);

  name = obstack_copy0 (&temp_parse_space, renamed_entity, renamed_entity_len);
  ada_lookup_encoded_symbol (name, orig_left_context, VAR_DOMAIN, &sym_info);
  if (sym_info.sym == NULL)
    error (_("Could not find renamed variable: %s"), ada_decode (name));
  else if (SYMBOL_CLASS (sym_info.sym) == LOC_TYPEDEF)
    /* We have a renaming of an old-style renaming symbol.  Don't
       trust the block information.  */
    sym_info.block = orig_left_context;

  {
    const char *inner_renamed_entity;
    int inner_renamed_entity_len;
    const char *inner_renaming_expr;

    switch (ada_parse_renaming (sym_info.sym, &inner_renamed_entity,
				&inner_renamed_entity_len,
				&inner_renaming_expr))
      {
      case ADA_NOT_RENAMING:
	write_var_from_sym (orig_left_context, sym_info.block, sym_info.sym);
	break;
      case ADA_OBJECT_RENAMING:
	write_object_renaming (sym_info.block,
			       inner_renamed_entity, inner_renamed_entity_len,
			       inner_renaming_expr, max_depth - 1);
	break;
      default:
	goto BadEncoding;
      }
  }

  slice_state = SIMPLE_INDEX;
  while (*renaming_expr == 'X')
    {
      renaming_expr += 1;

      switch (*renaming_expr) {
      case 'A':
        renaming_expr += 1;
        write_exp_elt_opcode (UNOP_IND);
        break;
      case 'L':
	slice_state = LOWER_BOUND;
	/* FALLTHROUGH */
      case 'S':
	renaming_expr += 1;
	if (isdigit (*renaming_expr))
	  {
	    char *next;
	    long val = strtol (renaming_expr, &next, 10);
	    if (next == renaming_expr)
	      goto BadEncoding;
	    renaming_expr = next;
	    write_exp_elt_opcode (OP_LONG);
	    write_exp_elt_type (type_int ());
	    write_exp_elt_longcst ((LONGEST) val);
	    write_exp_elt_opcode (OP_LONG);
	  }
	else
	  {
	    const char *end;
	    char *index_name;
	    struct ada_symbol_info index_sym_info;

	    end = strchr (renaming_expr, 'X');
	    if (end == NULL)
	      end = renaming_expr + strlen (renaming_expr);

	    index_name =
	      obstack_copy0 (&temp_parse_space, renaming_expr,
			     end - renaming_expr);
	    renaming_expr = end;

	    ada_lookup_encoded_symbol (index_name, NULL, VAR_DOMAIN,
				       &index_sym_info);
	    if (index_sym_info.sym == NULL)
	      error (_("Could not find %s"), index_name);
	    else if (SYMBOL_CLASS (index_sym_info.sym) == LOC_TYPEDEF)
	      /* Index is an old-style renaming symbol.  */
	      index_sym_info.block = orig_left_context;
	    write_var_from_sym (NULL, index_sym_info.block,
				index_sym_info.sym);
	  }
	if (slice_state == SIMPLE_INDEX)
	  {
	    write_exp_elt_opcode (OP_FUNCALL);
	    write_exp_elt_longcst ((LONGEST) 1);
	    write_exp_elt_opcode (OP_FUNCALL);
	  }
	else if (slice_state == LOWER_BOUND)
	  slice_state = UPPER_BOUND;
	else if (slice_state == UPPER_BOUND)
	  {
	    write_exp_elt_opcode (TERNOP_SLICE);
	    slice_state = SIMPLE_INDEX;
	  }
	break;

      case 'R':
	{
	  struct stoken field_name;
	  const char *end;
	  char *buf;

	  renaming_expr += 1;

	  if (slice_state != SIMPLE_INDEX)
	    goto BadEncoding;
	  end = strchr (renaming_expr, 'X');
	  if (end == NULL)
	    end = renaming_expr + strlen (renaming_expr);
	  field_name.length = end - renaming_expr;
	  buf = malloc (end - renaming_expr + 1);
	  field_name.ptr = buf;
	  strncpy (buf, renaming_expr, end - renaming_expr);
	  buf[end - renaming_expr] = '\000';
	  renaming_expr = end;
	  write_exp_op_with_string (STRUCTOP_STRUCT, field_name);
	  break;
	}

      default:
	goto BadEncoding;
      }
    }
  if (slice_state == SIMPLE_INDEX)
    return;

 BadEncoding:
  error (_("Internal error in encoding of renaming declaration"));
}

static struct block*
block_lookup (struct block *context, const char *raw_name)
{
  const char *name;
  struct ada_symbol_info *syms;
  int nsyms;
  struct symtab *symtab;

  if (raw_name[0] == '\'')
    {
      raw_name += 1;
      name = raw_name;
    }
  else
    name = ada_encode (raw_name);

  nsyms = ada_lookup_symbol_list (name, context, VAR_DOMAIN, &syms);
  if (context == NULL
      && (nsyms == 0 || SYMBOL_CLASS (syms[0].sym) != LOC_BLOCK))
    symtab = lookup_symtab (name);
  else
    symtab = NULL;

  if (symtab != NULL)
    return BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), STATIC_BLOCK);
  else if (nsyms == 0 || SYMBOL_CLASS (syms[0].sym) != LOC_BLOCK)
    {
      if (context == NULL)
	error (_("No file or function \"%s\"."), raw_name);
      else
	error (_("No function \"%s\" in specified context."), raw_name);
    }
  else
    {
      if (nsyms > 1)
	warning (_("Function name \"%s\" ambiguous here"), raw_name);
      return SYMBOL_BLOCK_VALUE (syms[0].sym);
    }
}

static struct symbol*
select_possible_type_sym (struct ada_symbol_info *syms, int nsyms)
{
  int i;
  int preferred_index;
  struct type *preferred_type;
	  
  preferred_index = -1; preferred_type = NULL;
  for (i = 0; i < nsyms; i += 1)
    switch (SYMBOL_CLASS (syms[i].sym))
      {
      case LOC_TYPEDEF:
	if (ada_prefer_type (SYMBOL_TYPE (syms[i].sym), preferred_type))
	  {
	    preferred_index = i;
	    preferred_type = SYMBOL_TYPE (syms[i].sym);
	  }
	break;
      case LOC_REGISTER:
      case LOC_ARG:
      case LOC_REF_ARG:
      case LOC_REGPARM_ADDR:
      case LOC_LOCAL:
      case LOC_COMPUTED:
	return NULL;
      default:
	break;
      }
  if (preferred_type == NULL)
    return NULL;
  return syms[preferred_index].sym;
}

static struct type*
find_primitive_type (char *name)
{
  struct type *type;
  type = language_lookup_primitive_type_by_name (parse_language,
						 parse_gdbarch,
						 name);
  if (type == NULL && strcmp ("system__address", name) == 0)
    type = type_system_address ();

  if (type != NULL)
    {
      /* Check to see if we have a regular definition of this
	 type that just didn't happen to have been read yet.  */
      struct symbol *sym;
      char *expanded_name = 
	(char *) alloca (strlen (name) + sizeof ("standard__"));
      strcpy (expanded_name, "standard__");
      strcat (expanded_name, name);
      sym = ada_lookup_symbol (expanded_name, NULL, VAR_DOMAIN, NULL);
      if (sym != NULL && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
	type = SYMBOL_TYPE (sym);
    }

  return type;
}

static int
chop_selector (char *name, int end)
{
  int i;
  for (i = end - 1; i > 0; i -= 1)
    if (name[i] == '.' || (name[i] == '_' && name[i+1] == '_'))
      return i;
  return -1;
}

/* If NAME is a string beginning with a separator (either '__', or
   '.'), chop this separator and return the result; else, return
   NAME.  */

static char *
chop_separator (char *name)
{
  if (*name == '.')
   return name + 1;

  if (name[0] == '_' && name[1] == '_')
    return name + 2;

  return name;
}

/* Given that SELS is a string of the form (<sep><identifier>)*, where
   <sep> is '__' or '.', write the indicated sequence of
   STRUCTOP_STRUCT expression operators. */
static void
write_selectors (char *sels)
{
  while (*sels != '\0')
    {
      struct stoken field_name;
      char *p = chop_separator (sels);
      sels = p;
      while (*sels != '\0' && *sels != '.' 
	     && (sels[0] != '_' || sels[1] != '_'))
	sels += 1;
      field_name.length = sels - p;
      field_name.ptr = p;
      write_exp_op_with_string (STRUCTOP_STRUCT, field_name);
    }
}

/* Write a variable access (OP_VAR_VALUE) to ambiguous encoded name
   NAME[0..LEN-1], in block context BLOCK, to be resolved later.  Writes
   a temporary symbol that is valid until the next call to ada_parse.
   */
static void
write_ambiguous_var (const struct block *block, char *name, int len)
{
  struct symbol *sym =
    obstack_alloc (&temp_parse_space, sizeof (struct symbol));
  memset (sym, 0, sizeof (struct symbol));
  SYMBOL_DOMAIN (sym) = UNDEF_DOMAIN;
  SYMBOL_LINKAGE_NAME (sym) = obstack_copy0 (&temp_parse_space, name, len);
  SYMBOL_LANGUAGE (sym) = language_ada;

  write_exp_elt_opcode (OP_VAR_VALUE);
  write_exp_elt_block (block);
  write_exp_elt_sym (sym);
  write_exp_elt_opcode (OP_VAR_VALUE);
}

/* A convenient wrapper around ada_get_field_index that takes
   a non NUL-terminated FIELD_NAME0 and a FIELD_NAME_LEN instead
   of a NUL-terminated field name.  */

static int
ada_nget_field_index (const struct type *type, const char *field_name0,
                      int field_name_len, int maybe_missing)
{
  char *field_name = alloca ((field_name_len + 1) * sizeof (char));

  strncpy (field_name, field_name0, field_name_len);
  field_name[field_name_len] = '\0';
  return ada_get_field_index (type, field_name, maybe_missing);
}

/* If encoded_field_name is the name of a field inside symbol SYM,
   then return the type of that field.  Otherwise, return NULL.

   This function is actually recursive, so if ENCODED_FIELD_NAME
   doesn't match one of the fields of our symbol, then try to see
   if ENCODED_FIELD_NAME could not be a succession of field names
   (in other words, the user entered an expression of the form
   TYPE_NAME.FIELD1.FIELD2.FIELD3), in which case we evaluate
   each field name sequentially to obtain the desired field type.
   In case of failure, we return NULL.  */

static struct type *
get_symbol_field_type (struct symbol *sym, char *encoded_field_name)
{
  char *field_name = encoded_field_name;
  char *subfield_name;
  struct type *type = SYMBOL_TYPE (sym);
  int fieldno;

  if (type == NULL || field_name == NULL)
    return NULL;
  type = check_typedef (type);

  while (field_name[0] != '\0')
    {
      field_name = chop_separator (field_name);

      fieldno = ada_get_field_index (type, field_name, 1);
      if (fieldno >= 0)
        return TYPE_FIELD_TYPE (type, fieldno);

      subfield_name = field_name;
      while (*subfield_name != '\0' && *subfield_name != '.' 
	     && (subfield_name[0] != '_' || subfield_name[1] != '_'))
	subfield_name += 1;

      if (subfield_name[0] == '\0')
        return NULL;

      fieldno = ada_nget_field_index (type, field_name,
                                      subfield_name - field_name, 1);
      if (fieldno < 0)
        return NULL;

      type = TYPE_FIELD_TYPE (type, fieldno);
      field_name = subfield_name;
    }

  return NULL;
}

/* Look up NAME0 (an unencoded identifier or dotted name) in BLOCK (or 
   expression_block_context if NULL).  If it denotes a type, return
   that type.  Otherwise, write expression code to evaluate it as an
   object and return NULL. In this second case, NAME0 will, in general,
   have the form <name>(.<selector_name>)*, where <name> is an object
   or renaming encoded in the debugging data.  Calls error if no
   prefix <name> matches a name in the debugging data (i.e., matches
   either a complete name or, as a wild-card match, the final 
   identifier).  */

static struct type*
write_var_or_type (const struct block *block, struct stoken name0)
{
  int depth;
  char *encoded_name;
  int name_len;

  if (block == NULL)
    block = expression_context_block;

  encoded_name = ada_encode (name0.ptr);
  name_len = strlen (encoded_name);
  encoded_name = obstack_copy0 (&temp_parse_space, encoded_name, name_len);
  for (depth = 0; depth < MAX_RENAMING_CHAIN_LENGTH; depth += 1)
    {
      int tail_index;
      
      tail_index = name_len;
      while (tail_index > 0)
	{
	  int nsyms;
	  struct ada_symbol_info *syms;
	  struct symbol *type_sym;
	  struct symbol *renaming_sym;
	  const char* renaming;
	  int renaming_len;
	  const char* renaming_expr;
	  int terminator = encoded_name[tail_index];

	  encoded_name[tail_index] = '\0';
	  nsyms = ada_lookup_symbol_list (encoded_name, block,
					  VAR_DOMAIN, &syms);
	  encoded_name[tail_index] = terminator;

	  /* A single symbol may rename a package or object. */

	  /* This should go away when we move entirely to new version.
	     FIXME pnh 7/20/2007. */
	  if (nsyms == 1)
	    {
	      struct symbol *ren_sym =
		ada_find_renaming_symbol (syms[0].sym, syms[0].block);

	      if (ren_sym != NULL)
		syms[0].sym = ren_sym;
	    }

	  type_sym = select_possible_type_sym (syms, nsyms);

	  if (type_sym != NULL)
	    renaming_sym = type_sym;
	  else if (nsyms == 1)
	    renaming_sym = syms[0].sym;
	  else 
	    renaming_sym = NULL;

	  switch (ada_parse_renaming (renaming_sym, &renaming,
				      &renaming_len, &renaming_expr))
	    {
	    case ADA_NOT_RENAMING:
	      break;
	    case ADA_PACKAGE_RENAMING:
	    case ADA_EXCEPTION_RENAMING:
	    case ADA_SUBPROGRAM_RENAMING:
	      {
		char *new_name
		  = obstack_alloc (&temp_parse_space,
				   renaming_len + name_len - tail_index + 1);
		strncpy (new_name, renaming, renaming_len);
		strcpy (new_name + renaming_len, encoded_name + tail_index);
		encoded_name = new_name;
		name_len = renaming_len + name_len - tail_index;
		goto TryAfterRenaming;
	      }	
	    case ADA_OBJECT_RENAMING:
	      write_object_renaming (block, renaming, renaming_len, 
				     renaming_expr, MAX_RENAMING_CHAIN_LENGTH);
	      write_selectors (encoded_name + tail_index);
	      return NULL;
	    default:
	      internal_error (__FILE__, __LINE__,
			      _("impossible value from ada_parse_renaming"));
	    }

	  if (type_sym != NULL)
	    {
              struct type *field_type;
              
              if (tail_index == name_len)
                return SYMBOL_TYPE (type_sym);

              /* We have some extraneous characters after the type name.
                 If this is an expression "TYPE_NAME.FIELD0.[...].FIELDN",
                 then try to get the type of FIELDN.  */
              field_type
                = get_symbol_field_type (type_sym, encoded_name + tail_index);
              if (field_type != NULL)
                return field_type;
	      else 
		error (_("Invalid attempt to select from type: \"%s\"."),
                       name0.ptr);
	    }
	  else if (tail_index == name_len && nsyms == 0)
	    {
	      struct type *type = find_primitive_type (encoded_name);

	      if (type != NULL)
		return type;
	    }

	  if (nsyms == 1)
	    {
	      write_var_from_sym (block, syms[0].block, syms[0].sym);
	      write_selectors (encoded_name + tail_index);
	      return NULL;
	    }
	  else if (nsyms == 0) 
	    {
	      struct bound_minimal_symbol msym
		= ada_lookup_simple_minsym (encoded_name);
	      if (msym.minsym != NULL)
		{
		  write_exp_msymbol (msym);
		  /* Maybe cause error here rather than later? FIXME? */
		  write_selectors (encoded_name + tail_index);
		  return NULL;
		}

	      if (tail_index == name_len
		  && strncmp (encoded_name, "standard__", 
			      sizeof ("standard__") - 1) == 0)
		error (_("No definition of \"%s\" found."), name0.ptr);

	      tail_index = chop_selector (encoded_name, tail_index);
	    } 
	  else
	    {
	      write_ambiguous_var (block, encoded_name, tail_index);
	      write_selectors (encoded_name + tail_index);
	      return NULL;
	    }
	}

      if (!have_full_symbols () && !have_partial_symbols () && block == NULL)
	error (_("No symbol table is loaded.  Use the \"file\" command."));
      if (block == expression_context_block)
	error (_("No definition of \"%s\" in current context."), name0.ptr);
      else
	error (_("No definition of \"%s\" in specified context."), name0.ptr);
      
    TryAfterRenaming: ;
    }

  error (_("Could not find renamed symbol \"%s\""), name0.ptr);

}

/* Write a left side of a component association (e.g., NAME in NAME =>
   exp).  If NAME has the form of a selected component, write it as an
   ordinary expression.  If it is a simple variable that unambiguously
   corresponds to exactly one symbol that does not denote a type or an
   object renaming, also write it normally as an OP_VAR_VALUE.
   Otherwise, write it as an OP_NAME.

   Unfortunately, we don't know at this point whether NAME is supposed
   to denote a record component name or the value of an array index.
   Therefore, it is not appropriate to disambiguate an ambiguous name
   as we normally would, nor to replace a renaming with its referent.
   As a result, in the (one hopes) rare case that one writes an
   aggregate such as (R => 42) where R renames an object or is an
   ambiguous name, one must write instead ((R) => 42). */
   
static void
write_name_assoc (struct stoken name)
{
  if (strchr (name.ptr, '.') == NULL)
    {
      struct ada_symbol_info *syms;
      int nsyms = ada_lookup_symbol_list (name.ptr, expression_context_block,
					  VAR_DOMAIN, &syms);
      if (nsyms != 1 || SYMBOL_CLASS (syms[0].sym) == LOC_TYPEDEF)
	write_exp_op_with_string (OP_NAME, name);
      else
	write_var_from_sym (NULL, syms[0].block, syms[0].sym);
    }
  else
    if (write_var_or_type (NULL, name) != NULL)
      error (_("Invalid use of type."));
}

/* Convert the character literal whose ASCII value would be VAL to the
   appropriate value of type TYPE, if there is a translation.
   Otherwise return VAL.  Hence, in an enumeration type ('A', 'B'),
   the literal 'A' (VAL == 65), returns 0.  */

static LONGEST
convert_char_literal (struct type *type, LONGEST val)
{
  char name[7];
  int f;

  if (type == NULL)
    return val;
  type = check_typedef (type);
  if (TYPE_CODE (type) != TYPE_CODE_ENUM)
    return val;

  xsnprintf (name, sizeof (name), "QU%02x", (int) val);
  for (f = 0; f < TYPE_NFIELDS (type); f += 1)
    {
      if (strcmp (name, TYPE_FIELD_NAME (type, f)) == 0)
	return TYPE_FIELD_ENUMVAL (type, f);
    }
  return val;
}

static struct type *
type_int (void)
{
  return parse_type->builtin_int;
}

static struct type *
type_long (void)
{
  return parse_type->builtin_long;
}

static struct type *
type_long_long (void)
{
  return parse_type->builtin_long_long;
}

static struct type *
type_float (void)
{
  return parse_type->builtin_float;
}

static struct type *
type_double (void)
{
  return parse_type->builtin_double;
}

static struct type *
type_long_double (void)
{
  return parse_type->builtin_long_double;
}

static struct type *
type_char (void)
{
  return language_string_char_type (parse_language, parse_gdbarch);
}

static struct type *
type_boolean (void)
{
  return parse_type->builtin_bool;
}

static struct type *
type_system_address (void)
{
  struct type *type 
    = language_lookup_primitive_type_by_name (parse_language,
					      parse_gdbarch,
					      "system__address");
  return  type != NULL ? type : parse_type->builtin_data_ptr;
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_ada_exp;

void
_initialize_ada_exp (void)
{
  obstack_init (&temp_parse_space);
}
@


1.56
log
@Delete unused ada-exp.y:string_to_operator

This function appears to have been unused since 2004.

gdb/ChangeLog:

        * ada-exp.y (string_to_operator): Delete.
        (dummy_string_to_ada_operator): Delete.
@
text
@d139 1
a139 1
static struct block *block_lookup (struct block *, char *);
d955 2
d965 4
a968 3
	  field_name.ptr = malloc (end - renaming_expr + 1);
	  strncpy (field_name.ptr, renaming_expr, end - renaming_expr);
	  field_name.ptr[end - renaming_expr] = '\000';
d986 1
a986 1
block_lookup (struct block *context, char *raw_name)
d988 1
a988 1
  char *name;
@


1.55
log
@remove msymbol_objfile

This is another patch in my ongoing series to "split" objfile to share
more read-only data across inferiors.  See

    http://sourceware.org/gdb/wiki/ObjfileSplitting

When symbols are finally shared, there will be no back-link from the
symbol to its containing objfile, because there may be more than one
such objfile.  So, all such back-links must be removed.

One hidden back-link is the msymbol_objfile function.  Since
(eventually) a symbol may appear in more than one objfile, trying to
look up the objfile given just a symbol cannot work.

This patch removes msymbol_objfile in favor of using a bound minimal
symbol.  It introduces a new function to make this conversion simpler
in some spots.

The bonus of this patch is that using msymbol_objfile is slower than
simply looking up the owning objfile in the first place.

Built and regtested on x86-64 Fedora 18.

	* ada-exp.y (write_var_or_type): Use bound_minimal_symbol.
	* ada-lang.c (ada_lookup_simple_minsym): Return
	bound_minimal_symbol.
	* ada-lang.h (ada_lookup_simple_minsym): Update.
	* c-exp.y (variable): Use lookup_bound_minimal_symbol.
	* f-exp.y (variable): Use lookup_bound_minimal_symbol.
	* go-exp.y (variable): Use lookup_bound_minimal_symbol.
	* jv-exp.y (push_expression_name): Use lookup_bound_minimal_symbol.
	* m2-exp.y (variable): Use lookup_bound_minimal_symbol.
	* minsyms.c (msymbol_objfile): Remove.
	(lookup_minimal_symbol_internal): New function, from
	lookup_minimal_symbol.
	(lookup_minimal_symbol): Rewrite using
	lookup_minimal_symbol_internal.
	(lookup_bound_minimal_symbol): New function.
	* minsyms.h (msymbol_objfile): Remove.
	(lookup_bound_minimal_symbol): Declare.
	* p-exp.y (variable): Use lookup_bound_minimal_symbol.
	* parse.c (write_exp_msymbol): Change parameter to a
	bound_minimal_symbol.
	(write_dollar_variable): Use lookup_bound_minimal_symbol.
	* parser-defs.h (write_exp_msymbol): Update.
	* printcmd.c (address_info): Use lookup_bound_minimal_symbol.
	* symfile.c (simple_read_overlay_table): Use
	lookup_bound_minimal_symbol.
	* symtab.c (skip_prologue_sal): Don't use msymbol_objfile.
	(search_symbols): Likewise.
	(print_msymbol_info): Take a bound_minimal_symbol argument.
	(symtab_symbol_info, rbreak_command): Update.
	* symtab.h (struct symbol_search) <msymbol>: Change type
	to bound_minimal_symbol.
	* valops.c (find_function_in_inferior): Use
	lookup_bound_minimal_symbol.
	* value.c (value_fn_field): Use lookup_bound_minimal_symbol.
@
text
@a127 2
static struct stoken string_to_operator (struct stoken);

a786 28
/* The operator name corresponding to operator symbol STRING (adds
   quotes and maps to lower-case).  Destroys the previous contents of
   the array pointed to by STRING.ptr.  Error if STRING does not match
   a valid Ada operator.  Assumes that STRING.ptr points to a
   null-terminated string and that, if STRING is a valid operator
   symbol, the array pointed to by STRING.ptr contains at least
   STRING.length+3 characters.  */

static struct stoken
string_to_operator (struct stoken string)
{
  int i;

  for (i = 0; ada_opname_table[i].encoded != NULL; i += 1)
    {
      if (string.length == strlen (ada_opname_table[i].decoded)-2
	  && strncasecmp (string.ptr, ada_opname_table[i].decoded+1,
			  string.length) == 0)
	{
	  strncpy (string.ptr, ada_opname_table[i].decoded,
		   string.length+2);
	  string.length += 2;
	  return string;
	}
    }
  error (_("Invalid operator symbol `%s'"), string.ptr);
}

a1505 9

/* FIXME: hilfingr/2004-10-05: Hack to remove warning.  The function
   string_to_operator is supposed to be used for cases where one
   calls an operator function with prefix notation, as in 
   "+" (a, b), but at some point, this code seems to have gone
   missing. */

struct stoken (*dummy_string_to_ada_operator) (struct stoken) 
     = string_to_operator;
@


1.54
log
@	* ada-lang.c (ada_lookup_symbol_list_worker): New function, contents
	of old ada_lookup_symbol_list.  In !full_search case, don't
	search superblocks.
	(ada_lookup_symbol_list): Delete arg full_search, all callers
	updated.  Call ada_lookup_symbol_list_worker.
	(ada_iterate_over_symbols): Call ada_lookup_symbol_list_worker.
	* ada-lang.h (ada_lookup_symbol_list): Update.
	* language.h (language_defn): Update comment for
	la_iterate_over_symbols.
	* linespec.c (iterate_over_file_blocks): New function.
	(iterate_over_all_matching_symtabs): Call it.
	(lookup_prefix_sym): Ditto.
	(get_current_search_block): New function.
	(get_search_block): Delete.
	(find_label_symbols): Call get_current_search_block.
	(add_matching_symbols_to_info): Call iterate_over_file_blocks.
	* symtab.c (iterate_over_symbols): Don't search superblocks.
@
text
@d1372 1
a1372 1
	      struct minimal_symbol *msym 
d1374 1
a1374 1
	      if (msym != NULL)
@


1.53
log
@	* symfile.h (obsavestring): Don't declare.
	* symfile.c (obsavestring): Remove.
	* ada-exp.y: Use obstack_copy0, not obsavestring.
	* ada-lang.c: Use obstack_copy0, not obsavestring.
	* coffread.c: Use obstack_copy0, not obsavestring.
	* cp-namespace.c: Use obstack_copy0, not obsavestring.
	* dbxread.c: Use obstack_copy0, not obsavestring.
	* dwarf2read.c: Use obstack_copy0, not obsavestring.
	* jit.c: Use obstack_copy0, not obsavestring.
	* mdebugread.c: Use obstack_copy0, not obsavestring.
	* psymtab.c: Use obstack_copy0, not obsavestring.
	* stabsread.c: Use obstack_copy0, not obsavestring.
	* xcoffread.c: Use obstack_copy0, not obsavestring.
@
text
@d1028 1
a1028 1
  nsyms = ada_lookup_symbol_list (name, context, VAR_DOMAIN, &syms, 1);
d1285 1
a1285 1
					  VAR_DOMAIN, &syms, 1);
d1433 1
a1433 1
					  VAR_DOMAIN, &syms, 1);
@


1.52
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d883 1
a883 1
  name = obsavestring (renamed_entity, renamed_entity_len, &temp_parse_space);
d952 2
a953 2
	      obsavestring (renaming_expr, end - renaming_expr,
			    &temp_parse_space);
d1169 1
a1169 1
  SYMBOL_LINKAGE_NAME (sym) = obsavestring (name, len, &temp_parse_space);
d1266 1
a1266 1
  encoded_name = obsavestring (encoded_name, name_len, &temp_parse_space);
@


1.51
log
@	* ada-exp.y (write_object_renaming, write_var_or_type)
	(write_ambiguous_var, write_var_from_sym): Make blocks const.
	* ada-lang.c (replace_operator_with_call)
	(find_old_style_renaming_symbol): Make blocks const.
	* ada-lang.h (ada_find_renaming_symbol): Update.
	(struct ada_symbol_info) <block>: Now const.
	* breakpoint.c (watch_command_1): Update.
	* breakpoint.h (struct watchpoint) <exp_valid_block,
	cond_exp_valid_block>: Now const.
	* c-exp.y (classify_inner_name, classify_name): Make block
	argument const.
	* expprint.c (print_subexp_standard) <OP_VAR_VALUE>: Make 'b'
	const.
	* expression.h (innermost_block, parse_exp_1): Update.
	(union exp_element) <block>: Now const.
	* gdbtypes.c (lookup_template_type, lookup_enum, lookup_union)
	(lookup_struct): Make block argument const.
	* gdbtypes.h (lookup_template_type): Update.
	* go-exp.y (classify_name, classify_packaged_name)
	(package_name_p): Make block argument const.
	* objc-lang.c (lookup_struct_typedef): Make block argument const.
	* objc-lang.h (lookup_struct_typedef): Update.
	* parse.c (parse_exp_in_context, parse_exp_1)
	(write_exp_elt_block): Make block arguments const.
	(expression_context_block, innermost_block): Now const.
	* parser-defs.h (write_exp_elt_block): Update.
	(expression_context_block, innermost_block, block_found): Now
	const.
	* printcmd.c (struct display) <block>: Now const.
	* symtab.h (lookup_struct, lookup_union, lookup_enum): Update.
	* valops.c (address_of_variable): Make block argument const.
	* value.h (value_of_variable): Update.
	* varobj.c (struct varobj_root) <valid_block>: Now const.
@
text
@d2 1
a2 2
   Copyright (C) 1986, 1989-1991, 1993-1994, 1997, 2000, 2003-2004,
   2007-2012 Free Software Foundation, Inc.
@


1.50
log
@gdb/
	PR symtab/7259:
	* ada-exp.y (convert_char_literal): Use TYPE_FIELD_ENUMVAL.
	* ada-lang.c (ada_discrete_type_high_bound)
	(ada_discrete_type_low_bound): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(ada_identical_enum_types_p): Use TYPE_FIELD_ENUMVAL.
	(pos_atr, value_val_atr): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* ada-typeprint.c (print_enum_type): Change variable lastval to LONGEST.
	Use TYPE_FIELD_ENUMVAL.
	* ada-valprint.c (print_optional_low_bound, ada_print_scalar)
	(ada_val_print_1): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* c-typeprint.c (c_type_print_base): Move variable lastval to inner
	block, change it to LONGEST.  Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* coffread.c (coff_read_enum_type): Use SET_FIELD_ENUMVAL.
	* dwarf2read.c (process_enumeration_scope): Likewise.
	* gdb-gdb.py (TypeFlagsPrinter): Use field.enumval instead of
	field.bitpos.
	(class StructMainTypePrettyPrinter): Support also
	FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.c (get_discrete_bounds): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(recursive_dump_type): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(copy_type_recursive): Support also FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.h (enum field_loc_kind): New FIELD_LOC_KIND_ENUMVAL.
	(struct main_type.flds_bnds.fields.loc): Adjust bitpos comment.  New
	field enumval.
	(struct main_type.flds_bnds.bields): Adjust loc_kind and bitsize to
	accommodate enumval.
	(struct call_site): Adjust loc_kind to accommodate enumval.
	(FIELD_ENUMVAL, FIELD_ENUMVAL_LVAL, SET_FIELD_ENUMVAL)
	(TYPE_FIELD_ENUMVAL): New macros.
	* m2-typeprint.c (m2_enum): Use TYPE_FIELD_ENUMVAL.
	* mdebugread.c (parse_symbol): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* python/lib/gdb/printing.py (class FlagEnumerationPrinter): Use
	enumval.
	* python/lib/gdb/types.py (make_enum_dict): Likewise.
	* python/py-type.c (convert_field): New variable addrstring.  Use
	TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(check_types_equal): Support also FIELD_LOC_KIND_ENUMVAL.
	* stabsread.c (read_enum_type): Use SET_FIELD_ENUMVAL.
	* typepint.c (print_type_scalar): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* valprint.c (generic_val_print): Likewise.

gdb/testsuite/
	PR symtab/7259:
	* gdb.base/enumval.c: New test case.
	* gdb.base/enumval.exp: New test case.
	* gdb.python/py-type.exp (test_enums): Use field.enumval instead of
	field.bitpos.
@
text
@d133 1
a133 1
static void write_object_renaming (struct block *, const char *, int,
d136 1
a136 1
static struct type* write_var_or_type (struct block *, struct stoken);
d146 1
a146 1
static void write_ambiguous_var (struct block *, char *, int);
d821 2
a822 2
write_var_from_sym (struct block *orig_left_context,
		    struct block *block,
d870 1
a870 1
write_object_renaming (struct block *orig_left_context,
d1164 1
a1164 1
write_ambiguous_var (struct block *block, char *name, int len)
d1256 1
a1256 1
write_var_or_type (struct block *block, struct stoken name0)
@


1.49
log
@* ada-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* c-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* cp-name-parser.y (yyss, yysslim, yyssp, yystacksize, yyvs)
(yyvsp): New defines.
* f-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* jv-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* m2-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* objc-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
* p-exp.y (yyss, yysslim, yyssp, yystacksize, yyvs, yyvsp): New
defines.
@
text
@d1466 1
a1466 1
	return TYPE_FIELD_BITPOS (type, f);
@


1.48
log
@Make ada_lookup_encoded_symbol "return" a struct ada_symbol_info

This makes ada_lookup_encoded_symbol more consistent with other functions
such as ada_lookup_symbol_list, and also makes it clearer in the code
using that function that symbol and block are related.

gdb/ChangeLog:

        * ada-lang.c (ada_lookup_encoded_symbol): Now returns void.
        Replace block_found argument by symbol_info.  Adjust
        implementation accordingly.  Add function documentation.
        (ada_lookup_symbol): Adjust to new ada_lookup_encoded_symbol.
        Fix documentation.
        * ada-lang.h (ada_lookup_encoded_symbol): Update declaration.
        * ada-exp.y (write_object_renaming): Adjust to new
        ada_lookup_encoded_symbol API.
@
text
@d97 6
@


1.47
log
@ada-lang.c:ada_find_renaming_symbol minor improvement.

This is a minor improvement in ada_find_renaming_symbol: What we were
doing was going from a symbol, get its name, and then search for
renamings.  But if the original symbol was already itself a renaming,
then we'd look the symbol up again to return it.  Since we had the
symbol in the first place, we shouldn't need to look it up again.

This is what this patch does: Modify ada_find_renaming_symbol to
take a symbol instead of the symbol's (linkage) name, and then updates
the one caller.

gdb/ChangeLog:

        * ada-lang.h (ada_find_renaming_symbol): Replace parameter
        "name" with "struct symbol *name_sym".
        * ada-exp.y (write_var_or_type): Update call to
        ada_find_renaming_symbol.
        * ada-lang.c (ada_find_renaming_symbol): Replace parameter
        "name" with "struct symbol *name_sym". Adjust Implementation
        accordingly.  Adjust the function documentation.
@
text
@d870 1
a870 2
  struct symbol *sym;
  struct block *block;
d879 2
a880 3
  sym = ada_lookup_encoded_symbol (name, orig_left_context, VAR_DOMAIN, 
				   &block);
  if (sym == NULL)
d882 1
a882 1
  else if (SYMBOL_CLASS (sym) == LOC_TYPEDEF)
d885 1
a885 1
    block = orig_left_context;
d892 1
a892 1
    switch (ada_parse_renaming (sym, &inner_renamed_entity, 
d897 1
a897 1
	write_var_from_sym (orig_left_context, block, sym);
d900 1
a900 1
	write_object_renaming (block,
d940 1
a940 1
	    struct symbol *index_sym;
d951 3
a953 3
	    index_sym = ada_lookup_encoded_symbol (index_name, NULL,
						   VAR_DOMAIN, &block);
	    if (index_sym == NULL)
d955 1
a955 1
	    else if (SYMBOL_CLASS (index_sym) == LOC_TYPEDEF)
d957 3
a959 2
	      block = orig_left_context;
	    write_var_from_sym (NULL, block, index_sym);
@


1.46
log
@	* ada-lang.c (resolve_subexp): Update.
	(ada_lookup_symbol_list): Add 'full_search' argument.
	(ada_iterate_over_symbols): Pass 0 as full_search argument to
	ada_lookup_symbol_list.
	(ada_lookup_encoded_symbol): Update.
	(get_var_value): Update.
	* ada-exp.y (block_lookup): Update.
	(write_var_or_type): Update.
	(write_name_assoc): Update.
	* ada-lang.h (ada_lookup_symbol_list): Update.
@
text
@d1291 1
a1291 2
		ada_find_renaming_symbol (SYMBOL_LINKAGE_NAME (syms[0].sym), 
					  syms[0].block);
@


1.45
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1024 1
a1024 1
  nsyms = ada_lookup_symbol_list (name, context, VAR_DOMAIN, &syms);
d1281 1
a1281 1
					  VAR_DOMAIN, &syms);
d1430 1
a1430 1
					  VAR_DOMAIN, &syms);
@


1.44
log
@* ada-exp.y (write_var_or_type): Rename nested `renaming' to
`ren_sym'(-Wshadow).
@
text
@d2 2
a3 2
   Copyright (C) 1986, 1989, 1990, 1991, 1993, 1994, 1997, 2000, 2003, 2004,
   2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.44.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright (C) 1986, 1989-1991, 1993-1994, 1997, 2000, 2003-2004,
   2007-2012 Free Software Foundation, Inc.
@


1.43
log
@handle character-based enumeration typedefs

Consider the following type:

   type Char_Enum_Type is ('A', 'B', 'C', 'D');

If the compiler generates a Char_Enum_Type typedef in the debugging
information, the debugger fails in the following case:

   (gdb) p Char_Enum_Type'('B')
   $1 = 66

For our type, the underlying value of 'B' is actually 1, not 66
(ASCII 'B').  We are failing this case because we were not handling
typedef to enum types before.  This patch fixes this.

gdb/ChangeLog:

        * ada-exp.y (convert_char_literal): Handle typedef types.

gdb/testsuite/ChangeLog:

        * gdb.ada/char_enum: New testcase.
@
text
@d1290 1
a1290 1
	      struct symbol *renaming =
d1294 2
a1295 2
	      if (renaming != NULL)
		syms[0].sym = renaming;
@


1.42
log
@add FALLTHROUGH comment in ada-exp.y:write_object_renaming

gdb/ChangeLog:

 	From Michael Snyder  <msnyder@@vmware.com>
 	* ada-exp.y (write_object_renaming): Add FALLTHROUGH comment.
@
text
@d1452 1
a1452 1
  if (type == NULL || TYPE_CODE (type) != TYPE_CODE_ENUM)
d1454 4
@


1.41
log
@run copyright.sh for 2011.
@
text
@d923 1
@


1.40
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* c-exp.y (parse_string_or_char): Delete unused variable.
	(c_lex): Delete unused variable.
	* cp-name-parser.y (cpname_lex): Delete unused variable.
	* ada-exp.y (find_primitive_type): Delete unused variable.
	(write_var_or_type): Delete unused variable.
	* jv-exp.y (java_parse): Delete unused variable.
	(push_expression_name): Delete unused variable.
	* p-exp.y (pascal_lex): Delete unused variable.
@
text
@d3 1
a3 1
   2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.39
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a1093 1
      int ntypes;
a1367 1
	      int i;
@


1.38
log
@	ARI fix: OP eol rule.
	* ada-exp.y (block_lookup): Avoid operator at end of line.
	* aix-thread.c (pd_enable): Idem.
	* alpha-tdep.c (alpha_next_pc): Idem.
	* arm-tdep.c (arm_skip_prologue, arm_scan_prologue): Idem.
	(condition_true, coff_sym_is_thumb): Idem.
@
text
@d3 1
a3 1
   2007, 2008, 2009 Free Software Foundation, Inc.
@


1.37
log
@	ARI fix: sprintf rule.
	* ada-exp.y (convert_char_literal): Replace sprintf by xsnprintf.
	* ada-lang.c (add_angle_brackets): Use xstrprintf.
	(ada_decode): Replace sprintf by xsnprintf.
	(find_old_style_renaming_symbol): Ditto.
	(ada_to_fixed_type_1, ada_enum_name): Ditto.
@
text
@d1024 2
a1025 2
  if (context == NULL &&
      (nsyms == 0 || SYMBOL_CLASS (syms[0].sym) != LOC_BLOCK))
@


1.36
log
@        * ada-exp.y (get_symbol_field_type): Make sure to resolve typedefs
        before looking up the fields inside our struct type.
@
text
@d1455 1
a1455 1
  sprintf (name, "QU%02x", (int) val);
@


1.35
log
@	* Makefile.in: Update license to GPLv3.
	* ada-exp.y: Update license to GPLv3.
	* ada-lex.l: Update license to GPLv3.
	* c-exp.y: Update license to GPLv3.
	* cp-name-parser.y: Update license to GPLv3.
	* darwin-nat-info.c: Update license to GPLv3.
	* f-exp.y: Update license to GPLv3.
	* gdb_thread_db.h: Update license to GPLv3.
	* hppanbsd-nat.c: Update license to GPLv3.
	* hppanbsd-tdep.c: Update license to GPLv3.
	* hppaobsd-tdep.c: Update license to GPLv3.
	* jv-exp.y: Update license to GPLv3.
	* m2-exp.y: Update license to GPLv3.
	* objc-exp.y: Update license to GPLv3.
	* p-exp.y: Update license to GPLv3.
	* reply_mig_hack.awk: Update license to GPLv3.
	* reverse.c: Update license to GPLv3.
	* xtensa-xtregs.c: Update license to GPLv3.
@
text
@d1210 1
@


1.34
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d5 1
a5 1
This file is part of GDB.
d7 12
a18 14
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
@


1.33
log
@        Updated copyright notices for most files.
@
text
@d1523 3
@


1.32
log
@	* ada-exp.y (write_object_renaming): Use malloc instead of
	xmalloc.
	* p-exp.y (pop_current_type): Use free instead of xfree.
@
text
@d3 1
a3 1
   2007, 2008 Free Software Foundation, Inc.
@


1.31
log
@	* expression.h (struct expression): New member GDBARCH.
	* parse.c (parse_exp_in_context): Initialize it.
	* parser-def.h (parse_gdbarch, parse_language): New macros.

	* ada-exp.y (parse_type): New macro.
	Replace builtin_type_ macros by using parse_type.
	Replace current_language by parse_language.
	* ada-lex.l (processInt): Replace current_gdbarch by parse_gdbarch.
	Replace builtin_type_ macros.

	* c-exp.y (parse_type): New macro.
	Replace builtin_type_ macros by using parse_type.
	(parse_number): Replace current_gdbarch by parse_gdbarch.
	(yylex): Replace current_language by parse_language.

	* f-exp.y (parse_type, parse_f_type): New macros.
	Replace builtin_type_ macros by using parse_{f_,}type.
	(parse_number): Replace current_gdbarch by parse_gdbarch.
	(yylex): Replace current_language by parse_language.

	* jv-exp.y (parse_type): New macro.
	(parse_number): Replace builtin_type_ macros by using parse_type.

	* m2-exp.y (parse_type, parse_m2_type): New macros.
	Replace builtin_type_ macros by using parse_{m2_,}type.

	* objc-exp.y (parse_type): New macro.
	Replace builtin_type_ macros by using parse_type.
	(parse_number): Replace current_gdbarch by parse_gdbarch.
	(yylex): Replace current_language by parse_language.

	* p-exp.y (parse_type): New macro.
	Replace builtin_type_ macros by using parse_type.
	(parse_number): Replace current_gdbarch by parse_gdbarch.
	(yylex): Replace current_language by parse_language.
@
text
@d990 1
a990 1
	  field_name.ptr = xmalloc (end - renaming_expr + 1);
@


1.30
log
@	* parser-defs.h (write_exp_msymbol): Remove TEXT_SYMBOL_TYPE
	and DATA_SYMBOL_TYPE arguments.
	* parse.c (write_exp_msymbol): Remove TEXT_SYMBOL_TYPE and
	DATA_SYMBOL_TYPE arguments.  Replace use of builtin_type_CORE_ADDR.
	(write_dollar_variable): Update call.

	* ada-exp.y (write_var_or_type): Update call.
	* c-exp.y: Likewise.
	* f-exp.y: Likewise.
	* jv-exp.y: Likewise.
	* m2-exp.y: Likewise.
	* objc-exp.y: Likewise.
	* p-exp.y: Likewise.
@
text
@d55 2
d576 1
a576 1
			  write_exp_elt_type (builtin_type_void);
d1086 2
a1087 2
  type = language_lookup_primitive_type_by_name (current_language,
						 current_gdbarch,
d1468 1
a1468 1
  return builtin_type_int;
d1474 1
a1474 1
  return builtin_type_long;
d1480 1
a1480 1
  return builtin_type_long_long;
d1486 1
a1486 1
  return builtin_type_float;
d1492 1
a1492 1
  return builtin_type_double;
d1498 1
a1498 1
  return builtin_type_long_double;
d1504 1
a1504 1
  return language_string_char_type (current_language, current_gdbarch);
d1510 1
a1510 1
  return builtin_type_bool;
d1517 2
a1518 2
    = language_lookup_primitive_type_by_name (current_language,
					      current_gdbarch, 
d1520 1
a1520 1
  return  type != NULL ? type : lookup_pointer_type (builtin_type_void);
@


1.29
log
@* ada-lang.c (discrete_type_high_bound,discrete_type_low_bound): Change
API to return LONGEST values rather than struct values.
(ada_evaluate_subexp): Change to use new API of discrete_type_low_bound
and discrete_type_high_bound.
(to_fixed_range_type): Create a range type in cases where
argument is base type and its limits are representable as ints.
(ada_is_modular_type): Correct so that base type must be integral.
* ada-lex.l (TRUEKEYWORD,FALSEKEYWORD): Make 'true' and 'false'
keywords when they appear alone, since we are phasing out
direct representation of these identifiers in ebugging data.
* ada-exp.y: Define 'true' and 'false' as primaries.
(type_boolean): New function.
(type_int,type_long,type_long_long,type_floattype_double)
(type_long_double): Remove uses of current_gdbarch for consistency
with type_boolean.
(write_int): Change comment to indicate that it might write boolean
constant as well.
* ada-typeprint.c (ada_print_type): Print '(false, true)' for boolean
type, since will no longer be represented as enumerated type in
debugging data.
* ada-valprint.c (print_optional_low_bound): Handle boolean case
as well.
@
text
@d1373 1
a1373 2
		  write_exp_msymbol (msym, lookup_function_type (type_int ()),
				     type_int ());
@


1.28
log
@	* symtab.h (enum address_class): Remove LOC_REGPARM and
	LOC_COMPUTED_ARG.
	(struct symbol): Add is_argument.
	(SYMBOL_IS_ARGUMENT): Define.

	* ada-lang.c (ada_add_block_symbols): Use SYMBOL_IS_ARGUMENT.
	* buildsym.c (finish_block): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals)
	(print_frame_arg_vars): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (add_local_symbols): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.

	* coffread.c (process_coff_symbol): Set SYMBOL_IS_ARGUMENT.
	* dwarf2read.c (new_symbol): Likewise.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.

	* ada-exp.y (select_possible_type_sym): Don't handle LOC_REGPARM
	and LOC_COMPUTED_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* eval.c (evaluate_subexp_for_address): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* printcmd.c (address_info): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* tracepoint.c (collect_symbol, scope_info): Likewise.

testsuite/:
	* gdb.base/frame-args.exp: Handle arguments that are optimized
	out.
@
text
@d156 2
d185 1
d608 6
d832 1
a832 1
/* Write integer constant ARG of type TYPE.  */
d1467 1
a1467 1
  return builtin_type (current_gdbarch)->builtin_int;
d1473 1
a1473 1
  return builtin_type (current_gdbarch)->builtin_long;
d1479 1
a1479 1
  return builtin_type (current_gdbarch)->builtin_long_long;
d1485 1
a1485 1
  return builtin_type (current_gdbarch)->builtin_float;
d1491 1
a1491 1
  return builtin_type (current_gdbarch)->builtin_double;
d1497 1
a1497 1
  return builtin_type (current_gdbarch)->builtin_long_double;
d1507 6
@


1.27
log
@	* symtab.h (enum address_class): Remove LOC_BASEREG and
	LOC_BASEREG_ARG.
	(struct symbol): Remove "basereg" member of "aux_value" union.
	(SYMBOL_BASEREG): Remove.

	* ada-exp.y (select_possible_type_sym): Do not handle LOC_BASEREG
	or LOC_BASEREG_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	(ada_add_block_symbols): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* buildsym.c (finish_block): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.
	* printcmd.c (address_info): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals): Likewise.
	(print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (collect_symbol, add_local_symbols): Likewise.
	(scope_info): Likewise.
@
text
@a1058 1
      case LOC_REGPARM:
a1061 1
      case LOC_COMPUTED_ARG:
@


1.26
log
@	* symtab.h (enum address_class): Remove LOC_LOCAL_ARG.

	* ada-exp.y (select_possible_type_sym): Do not handle LOC_LOCAL_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	(ada_add_block_symbols): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* buildsyms.c (finish_block): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.
	* printcmd.c (address_info): Likewise.
	* stack.c (print_frame_args, print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (collect_symbol, add_local_symbols): Likewise.
	(scope_info): Likewise.
@
text
@a1061 2
      case LOC_BASEREG:
      case LOC_BASEREG_ARG:
@


1.25
log
@	* language.h (struct language_defn): Remove SYMTAB parameter from
	la_lookup_symbol_nonlocal callback function pointer.

	* ada-lang.h (ada_lookup_encoded_symbol): Remove SYMTAB parameter.
	(ada_lookup_encoded_symbol): Likewise.
	* ada-lang.c (ada_lookup_encoded_symbol): Remove SYMTAB parameter.
	Always call fixup_symbol_section.
	(ada_lookup_symbol): Remove SYMTAB parameter.
	(ada_lookup_symbol_nonlocal): Likewise.
	* ada-exp.y (write_object_renaming): Update.
	(find_primitive_type): Likewise.

	* cp-support.h (cp_lookup_symbol_nonlocal): Remove SYMTAB parameter.
	(cp_lookup_symbol_namespace): Likewise.
	* cp-namespace.c (lookup_namespace_scope): Remove SYMTAB parameter.
	(lookup_symbol_file): Likewise.
	(lookup_possible_namespace_symbol): Likewise.
	(cp_lookup_symbol_nonlocal): Likewise.
	(cp_lookup_symbol_namespace): Likewise.
	(cp_lookup_nested_type): Update.

	* scm-valprint.c (scm_inferior_print): Update.
	* valops.c (value_maybe_namespace_elt): Update.

	* solist.h (struct target_so_ops): Remove SYMTAB parameter from
	lookup_lib_global_symbol callback function pointer.
	(solib_global_lookup): Remove SYMTAB parameter.
	* solib.c (solib_global_lookup): Remove SYMTAB parameter.
	* solib-svr4.c (elf_lookup_lib_symbol): Likewise.

	* symtab.h (basic_lookup_symbol_nonlocal): Remove SYMTAB parameter.
	(lookup_symbol_static): Likewise.
	(lookup_symbol_global): Likewise.
	(lookup_symbol_aux_block): Likewise.
	(lookup_global_symbol_from_objfile): Likewise.
	* symtab.c (lookup_symbol_aux): Remove SYMTAB parameter.
	(lookup_symbol_aux_local): Likewise.
	(lookup_symbol_aux_block): Likewise.
	(lookup_symbol_aux_symtabs): Likewise.
	(lookup_symbol_aux_psymtabs): Likewise.
	(lookup_global_symbol_from_objfile): Likewise.
	(basic_lookup_symbol_nonlocal): Likewise.
	(lookup_symbol_static): Likewise.
	(lookup_symbol_global): Likewise.

	(lookup_symbol_in_language): Do not pass SYMTAB to lookup_symbol_aux.
@
text
@a1061 1
      case LOC_LOCAL_ARG:
@


1.24
log
@        * ada-exp.y: Allow '{type} ADDRESS' notation on left of assignment.
@
text
@d872 1
a872 1
				   &block, NULL);
d944 1
a944 2
						   VAR_DOMAIN, &block,
						   NULL);
d1096 1
a1096 1
      sym = ada_lookup_symbol (expanded_name, NULL, VAR_DOMAIN, NULL, NULL);
@


1.23
log
@        * ada-exp.y (chop_separator): New function.
        (write_selectors): Rewrite to re-use chop_separator.
        (ada_nget_field_index, get_symbol_field_type): New functions.
        (write_var_or_type): Add support for "ptype TYPENAME.FIELD"
        expressions.
@
text
@d356 1
a356 1
simple_exp :	'{' var_or_type '}' simple_exp  %prec '.'
@


1.22
log
@	Updated copyright notices for most files.
@
text
@d1115 16
d1140 2
a1141 4
      char *p;
      while (*sels == '_' || *sels == '.')
	sels += 1;
      p = sels;
d1171 64
d1333 12
a1344 6
	      struct type *type = SYMBOL_TYPE (type_sym);

	      if (TYPE_CODE (type) == TYPE_CODE_VOID)
		error (_("`%s' matches only void type name(s)"), name0.ptr);
	      else if (tail_index == name_len)
		return type;
d1346 2
a1347 1
		error (_("Invalid attempt to select from type: \"%s\"."), name0.ptr);
@


1.21
log
@        * ada-lang.h (ada_renaming_category): New enumerated type.
        (ada_lookup_encoded_symbol): Declare.
        (ada_parse_renaming): Declare.
        (ada_renaming_type,ada_is_object_renaming)
        (ada_simple_renamed_entity): Delete declarations.
        * ada-lang.c (ada_parse_renaming): New function to concentrate
        extraction of information from renaming symbols.
        (parse_old_style_renaming): New function to concentrate
        extraction of old-style (purely type-based) renaming information.
        (renaming_is_visible): Rename to...
        (old_renaming_is_invisible): Rename and change sense of
        renaming_is_visible.
        (remove_out_of_scope_renamings): Rename to...
        (remove_irrelevant_renamings): Renames remove_out_of_scope_renamings
        and augments with additional logic to handle cases where the same
        object renaming is encoded both as a reference variable and an
        encoded renaming.
        (ada_renaming_type,ada_is_object_renaming)
        (ada_simple_renamed_entity): Delete definitions.
        (ada_lookup_encoded_symbol): New function factored out of
        ada_lookup_symbol.
        (ada_lookup_symbol): Reimplement to call ada_lookup_encoded_symbol.
        (wild_match): Don't reject perfect match of prefix.
        (ada_find_renaming_symbol): Factor old-style renaming logic into
        find_old_style_renaming_symbol.
        (find_old_style_renaming_symbol): New name for content of old
        ada_find_renaming_symbol.
        (ada_prefer_type): Reimplement not to use ada_renaming_type.
        * ada-exp.y (write_object_renaming): Change interface.  Reimplement
        to use new arguments and ada_parse_renaming.
        Correct blocks used to find array index.
        (write_var_or_type): Reimplement to use ada_parse_renaming.
@
text
@d3 1
a3 1
   2007 Free Software Foundation, Inc.
@


1.20
log
@Copyright updates for 2007.
@
text
@d127 2
a128 1
static void write_object_renaming (struct block *, struct symbol *, int);
d843 11
a853 4
/* Emit expression corresponding to the renamed object designated by
 * the type RENAMING, which must be the referent of an object renaming
 * type, in the context of ORIG_LEFT_CONTEXT.  MAX_DEPTH is the maximum
 * number of cascaded renamings to allow.  */
d855 3
a857 2
write_object_renaming (struct block *orig_left_context, 
		       struct symbol *renaming, int max_depth)
a858 4
  const char *qualification = SYMBOL_LINKAGE_NAME (renaming);
  const char *simple_tail;
  const char *expr = TYPE_FIELD_NAME (SYMBOL_TYPE (renaming), 0);
  const char *suffix;
d860 1
d862 1
a862 1
  enum { SIMPLE_INDEX, LOWER_BOUND, UPPER_BOUND } slice_state;
a866 2
  /* if orig_left_context is null, then use the currently selected
     block; otherwise we might fail our symbol lookup below.  */
d870 3
a872 23
  for (simple_tail = qualification + strlen (qualification);
       simple_tail != qualification; simple_tail -= 1)
    {
      if (*simple_tail == '.')
	{
	  simple_tail += 1;
	  break;
	}
      else if (strncmp (simple_tail, "__", 2) == 0)
	{
	  simple_tail += 2;
	  break;
	}
    }

  suffix = strstr (expr, "___XE");
  if (suffix == NULL)
    goto BadEncoding;

  name = (char *) obstack_alloc (&temp_parse_space, suffix - expr + 1);
  strncpy (name, expr, suffix-expr);
  name[suffix-expr] = '\000';
  sym = lookup_symbol (name, orig_left_context, VAR_DOMAIN, 0, NULL);
d875 26
a900 4
  if (ada_is_object_renaming (sym))
    write_object_renaming (orig_left_context, sym, max_depth-1);
  else
    write_var_from_sym (orig_left_context, block_found, sym);
a901 1
  suffix += 5;
d903 1
a903 1
  while (*suffix == 'X')
d905 1
a905 1
      suffix += 1;
d907 1
a907 1
      switch (*suffix) {
d909 1
a909 1
        suffix += 1;
d915 2
a916 2
	suffix += 1;
	if (isdigit (*suffix))
d919 2
a920 2
	    long val = strtol (suffix, &next, 10);
	    if (next == suffix)
d922 1
a922 1
	    suffix = next;
a931 1
	    int index_len;
d934 1
a934 1
	    end = strchr (suffix, 'X');
d936 1
a936 1
	      end = suffix + strlen (suffix);
d938 8
a945 11
	    index_len = simple_tail - qualification + 2 + (suffix - end) + 1;
	    index_name
	      = (char *) obstack_alloc (&temp_parse_space, index_len);
	    memset (index_name, '\000', index_len);
	    strncpy (index_name, qualification, simple_tail - qualification);
	    index_name[simple_tail - qualification] = '\000';
	    strncat (index_name, suffix, suffix-end);
	    suffix = end;

	    index_sym =
	      lookup_symbol (index_name, NULL, VAR_DOMAIN, 0, NULL);
d948 4
a951 1
	    write_var_from_sym (NULL, block_found, sym);
d972 1
a972 1
	  suffix += 1;
d976 1
a976 1
	  end = strchr (suffix, 'X');
d978 6
a983 6
	    end = suffix + strlen (suffix);
	  field_name.length = end - suffix;
	  field_name.ptr = xmalloc (end - suffix + 1);
	  strncpy (field_name.ptr, suffix, end - suffix);
	  field_name.ptr[end - suffix] = '\000';
	  suffix = end;
d996 1
a996 2
  error (_("Internal error in encoding of renaming declaration: %s"),
	 SYMBOL_LINKAGE_NAME (renaming));
d1191 4
d1204 3
a1206 1
	  if (nsyms == 1 && !ada_is_object_renaming (syms[0].sym))
d1208 1
a1208 1
	      struct symbol *renaming_sym =
d1212 2
a1213 2
	      if (renaming_sym != NULL)
		syms[0].sym = renaming_sym;
d1217 36
a1258 24
	      else if (ada_is_object_renaming (type_sym))
		{
		  write_object_renaming (block, type_sym, 
					 MAX_RENAMING_CHAIN_LENGTH);
		  write_selectors (encoded_name + tail_index);
		  return NULL;
		}
	      else if (ada_renaming_type (SYMBOL_TYPE (type_sym)) != NULL)
		{
		  int result;
		  char *renaming = ada_simple_renamed_entity (type_sym);
		  int renaming_len = strlen (renaming);

		  char *new_name
		    = obstack_alloc (&temp_parse_space,
				     renaming_len + name_len - tail_index 
				     + 1);
		  strcpy (new_name, renaming);
		  xfree (renaming);
		  strcpy (new_name + renaming_len, encoded_name + tail_index);
		  encoded_name = new_name;
		  name_len = renaming_len + name_len - tail_index;
		  goto TryAfterRenaming;
		}
@


1.19
log
@* ada-exp.y (yyerror): Change message to ignore the argument, avoiding
translation problems.
* ada-lang.c (ada_value_struct_elt): Change interface and handling
of errors to avoid translation problem (and less than optimal error
messages).
(ada_value_tag, ada_tag_name_1, ada_tag_name_2,	ada_evaluate_subexp):
Use new interface to ada_value_struct_elt.
* ada_lang.h (ada_value_struct_elt): Update declaration to new
interface.

* ChangeLog: remove reference to ada-tasks.c from entry of
2006-01-07.
@
text
@d2 2
a3 2
   Copyright (C) 1986, 1989, 1990, 1991, 1993, 1994, 1997, 2000, 2003, 
   2004 Free Software Foundation, Inc.
@


1.18
log
@* ada-exp.y, ada-lex.l, ada-typeprint.c: I18n markup.
* ada-tasks.c, ada-lang.c: I18n markup.
Editorial: change "can not" => "cannot" throughout.
@
text
@d771 1
a771 1
  error (_("A %s in expression, near `%s'."), (msg ? msg : _("error")), lexptr);
@


1.17
log
@	* ada-exp.y (syntax definitions,write_var_or_type,write_name_assoc):
	Change several uses of "illegal" to "invalid".
@
text
@d255 1
a255 1
				error ("Invalid conversion");
d273 1
a273 1
			    error ("Type required for qualification");
d291 1
a291 1
			    error ("Cannot slice a type");
d359 1
a359 1
			    error ("Type required within braces in coercion");
d429 1
a429 1
			    error ("Right operand of 'in' must be type");
d447 1
a447 1
			    error ("Right operand of 'in' must be type");
d560 1
a560 1
			    error ("Prefix must be type");
d605 1
a605 1
			{ error ("NEW not implemented."); }
d771 1
a771 1
  error ("A %s in expression, near `%s'.", (msg ? msg : "error"), lexptr);
d799 1
a799 1
  error ("Invalid operator symbol `%s'", string.ptr);
d859 1
a859 1
    error ("Could not find renamed symbol");
d890 1
a890 1
    error ("Could not find renamed variable: %s", ada_decode (name));
d946 1
a946 1
	      error ("Could not find %s", index_name);
d992 1
a992 1
  error ("Internal error in encoding of renaming declaration: %s",
d1024 1
a1024 1
	error ("No file or function \"%s\".", raw_name);
d1026 1
a1026 1
	error ("No function \"%s\" in specified context.", raw_name);
d1031 1
a1031 1
	warning ("Function name \"%s\" ambiguous here", raw_name);
d1213 1
a1213 1
		error ("`%s' matches only void type name(s)", name0.ptr);
d1241 1
a1241 1
		error ("Invalid attempt to select from type: \"%s\".", name0.ptr);
d1274 1
a1274 1
		error ("No definition of \"%s\" found.", name0.ptr);
d1287 1
a1287 1
	error ("No symbol table is loaded.  Use the \"file\" command.");
d1289 1
a1289 1
	error ("No definition of \"%s\" in current context.", name0.ptr);
d1291 1
a1291 1
	error ("No definition of \"%s\" in specified context.", name0.ptr);
d1296 1
a1296 1
  error ("Could not find renamed symbol \"%s\"", name0.ptr);
d1330 1
a1330 1
      error ("Invalid use of type.");
@


1.16
log
@	* ada-exp.y: Considerable reorganization to move functionality
	from ada-lex.l to here, where it is logically more appropriate.
	The original reason, however, was to prevent premature name
	lookups for selector names in record aggregates.
	(BLOCKNAME, TYPENAME, OBJECT_RENAMING): Remove; lexer now returns
	NAME for all of these.
	(VAR): New artificial token to clarify precedence rules.
	(OTHERS): New lexeme.
	(empty_stoken): New symbol.
	(%union): Remove ssym, voidval.
	(%type): Remove <voidval> type declarations.
	(syntax definitions): Add aggregates.
	Remove distinction between NAME, TYPENAME, BLOCKNAME, OBJECT_RENAMING.
	Rename some non-terminals to be closer to reference manual usage.
	Tighten up expression syntax to disallow certain non-Ada
	constructions such as X and then Y or else Z.
	(ada_parse): Remove initialization of left_block_context.
	(write_var_from_name): Remove.
	(write_var_or_type): New function, containing previous code from
	defunct write_var_from_name and name_lookup.
	(block_lookup): New function, moved from ada-lex.l
	(select_possible_type_sym): New function, factored out of
	name_lookup, which used to be in ada-lex.l.
	(find_primitive_type): Ditto.
	(chop_selector): Ditto.
	(write_ambiguous_var): New function, factored out of defunct
	write_var_from_name.
	(write_selectors): New function.
	(write_name_assoc): New function.
	(write_exp_op_with_string): New function.

	* ada-lex.l (processId): Change interface to return stoken.
	(tempbuf, resize_tempbuf, tempbuf_size, tempbuf_len): Remove.
	(block_lookup, name_lookup): Remove.  Functionality moved to
	ada-exp.y.
	(state IN_STRING): Remove.
	(rules): Handle string escapes in processString.
	Add 'others' token.
	Return all NAMEs, BLOCKNAMEs, OBJECT_RENAMINGs, TYPENAMEs in
	yylval.sval (as simple strings).
	All name look-ups now handled in ada-exp.y.
	Introduce "::" (COLONCOLON) token and return as separate token.
	(processId): Change return convention.  Comment.
	Leave leading "'" in place.
	(processString): New function.
	(find_dot_all): Add note to comment.
	Fix problem that allowed match only at the end.

	* ada-lang.c: Introduce aggregates.
	(find_struct_field): Add new parameter to count fields skipped, and
	allow other output parameters to be NULL.
	(value_tag_from_contents_and_address, ada_value_struct_elt): Use
	new find_struct_field.
	(ada_index_struct_field, assign_aggregate, ada_is_array_type)
	(num_visible_fields, ada_index_struct_field_1, ada_index_struct_field)
	(num_component_specs, assign_component, assign_aggregate):
	(aggregate_assign_from_choices,aggregate_assign_positional)
	(aggregate_assign_others,add_component_interval):
	New functions.
	(ada_evaluate_subexp): Declare.
	Add aggregate-related operators.
	(ada_forward_operator_length): Declare.
	(resolve_subexp): Add cases for new aggregate operators and OP_NAME.
	Consolidate Ada operators, using ada_forward_operator_length.
	(ada_search_struct_field): Search in forward order.
	(ADA_OPERATORS): Add new aggregate operators.
	(ada_operator_length, ada_op_name, ada_forward_operator_length)
	(ada_dump_subexp_body, ada_print_subexp): Handle new aggregate
	operators and OP_NAME.
	(ada_type_of_array): Use longest_to_int.
	(value_assign_to_component): New function.
	(ada_forward_operator_length, ada_op_name, ada_dump_subexp_body):
	Add OP_NAME case.
	(ada_forward_operator_length, ada_dump_subexp_body):
	Add OP_STRING case.

	* ada-lang.h (enum ada_operator): Add OP_AGGREGATE, OP_OTHERS,
	OP_CHOICES, OP_DISCRETE_RANGE, OP_POSITIONAL.
@
text
@d255 1
a255 1
				error ("Illegal conversion");
d510 1
a510 1
   primary TICK_ADDRESS, where a type would be illegal, it will be
d1241 1
a1241 1
		error ("Illegal attempt to select from type: \"%s\".", name0.ptr);
d1330 1
a1330 1
      error ("Illegal use of type.");
@


1.15
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d111 2
d129 7
a135 1
static void write_var_from_name (struct block *, struct name_info);
d139 2
d156 1
a171 2
    struct name_info ssym;
    int voidval;
a173 1

d176 3
a178 2
%type <voidval> exp exp1 simple_exp start variable
%type <tval> type
d182 2
a183 13
%token <tval> TYPENAME
%token <bval> BLOCKNAME

/* Both NAME and TYPENAME tokens represent symbols in the input,
   and both convey their data as strings.
   But a TYPENAME is a string that happens to be defined as a typedef
   or builtin type name (such as int or char)
   and a NAME is any other symbol.
   Contexts where this distinction is not important can use the
   nonterminal "name", which matches either NAME or TYPENAME.  */

%token <sval> STRING
%token <ssym> NAME DOT_ID OBJECT_RENAMING
d203 11
a216 3
%right TICK_ACCESS TICK_ADDRESS TICK_FIRST TICK_LAST TICK_LENGTH
%right TICK_MAX TICK_MIN TICK_MODULUS
%right TICK_POS TICK_RANGE TICK_SIZE TICK_TAG TICK_VAL
d219 1
a219 1
%token ARROW NEW
a224 3
	|	type	{ write_exp_elt_opcode (OP_TYPE);
			  write_exp_elt_type ($1);
 			  write_exp_elt_opcode (OP_TYPE); }
d231 2
d236 1
a236 1
simple_exp :	simple_exp DOT_ALL
d240 2
a241 5
simple_exp :	simple_exp DOT_ID
			{ write_exp_elt_opcode (STRUCTOP_STRUCT);
			  write_exp_string ($2.stoken);
			  write_exp_elt_opcode (STRUCTOP_STRUCT);
			  }
d244 1
a244 1
simple_exp :	simple_exp '(' arglist ')'
d250 1
a250 3
	;

simple_exp :	type '(' exp ')'
d252 14
a265 3
			  write_exp_elt_opcode (UNOP_CAST);
			  write_exp_elt_type ($1);
			  write_exp_elt_opcode (UNOP_CAST);
d269 2
a270 1
simple_exp :	type '\'' save_qualifier { type_qualifier = $1; } '(' exp ')'
d272 2
d284 2
a285 2
simple_exp :
		simple_exp '(' exp DOTDOT exp ')'
d287 6
d295 1
a295 1
simple_exp :	'(' exp1 ')'	{ }
d298 16
a313 1
simple_exp :	variable
d316 1
a316 1
simple_exp:	SPECIAL_VARIABLE /* Various GDB extensions */
d320 2
a321 2
exp	: 	simple_exp
	;
d323 1
a323 2
exp	: 	exp ASSIGN exp   /* Extension for convenience */
			{ write_exp_elt_opcode (BINOP_ASSIGN); }
d326 1
a326 1
exp	:	'-' exp    %prec UNARY
d330 1
a330 1
exp	:	'+' exp    %prec UNARY
d334 1
a334 1
exp     :	NOT exp    %prec UNARY
d338 1
a338 1
exp	:       ABS exp	   %prec UNARY
d347 1
a347 1
	|	any_name ARROW exp
d351 1
a351 1
	|	arglist ',' any_name ARROW exp
d355 1
a355 1
exp	:	'{' type '}' exp  %prec '.'
d357 4
a360 1
			{ write_exp_elt_opcode (UNOP_MEMVAL);
d368 1
a368 1
exp 	: 	exp STARSTAR exp
d372 1
a372 1
exp	:	exp '*' exp
d376 1
a376 1
exp	:	exp '/' exp
d380 1
a380 1
exp	:	exp REM exp /* May need to be fixed to give correct Ada REM */
d384 1
a384 1
exp	:	exp MOD exp
d388 1
a388 1
exp	:	exp '@@' exp	/* GDB extension */
d392 1
a392 1
exp	:	exp '+' exp
d396 1
a396 1
exp	:	exp '&' exp
d400 1
a400 1
exp	:	exp '-' exp
d404 4
a407 1
exp	:	exp '=' exp
d411 1
a411 1
exp	:	exp NOTEQUAL exp
d415 1
a415 1
exp	:	exp LEQ exp
d419 1
a419 1
exp	:	exp IN exp DOTDOT exp
d421 1
a421 1
        |       exp IN exp TICK_RANGE tick_arglist
d426 5
a430 2
 	|	exp IN TYPENAME		%prec TICK_ACCESS
			{ write_exp_elt_opcode (UNOP_IN_RANGE);
d434 1
a434 1
	|	exp NOT IN exp DOTDOT exp
d438 1
a438 1
        |       exp NOT IN exp TICK_RANGE tick_arglist
d444 5
a448 2
 	|	exp NOT IN TYPENAME	%prec TICK_ACCESS
			{ write_exp_elt_opcode (UNOP_IN_RANGE);
d455 1
a455 1
exp	:	exp GEQ exp
d459 1
a459 1
exp	:	exp '<' exp
d463 1
a463 1
exp	:	exp '>' exp
d467 12
a478 1
exp     :	exp _AND_ exp  /* Fix for Ada elementwise AND.  */
d480 1
a480 1
        ;
d482 4
a485 1
exp     :       exp _AND_ THEN exp	%prec _AND_
d489 2
a490 1
exp     :	exp OR exp     /* Fix for Ada elementwise OR */
d492 3
a494 1
        ;
d496 4
a499 1
exp     :       exp OR ELSE exp
d503 3
a505 1
exp     :       exp XOR exp    /* Fix for Ada elementwise XOR */
d509 9
a517 1
simple_exp :	simple_exp TICK_ACCESS
d519 1
a519 1
	|	simple_exp TICK_ADDRESS
d525 1
a525 1
	|	simple_exp TICK_FIRST tick_arglist
d528 1
a528 1
	|	simple_exp TICK_LAST tick_arglist
d531 1
a531 1
	| 	simple_exp TICK_LENGTH tick_arglist
d534 1
a534 1
        |       simple_exp TICK_SIZE
d536 1
a536 1
	|	simple_exp TICK_TAG
a543 9
	|	type_prefix TICK_FIRST tick_arglist
			{ write_int ($3, type_int ());
			  write_exp_elt_opcode (OP_ATR_FIRST); }
	|	type_prefix TICK_LAST tick_arglist
			{ write_int ($3, type_int ());
			  write_exp_elt_opcode (OP_ATR_LAST); }
	| 	type_prefix TICK_LENGTH tick_arglist
			{ write_int ($3, type_int ());
			  write_exp_elt_opcode (OP_ATR_LENGTH); }
d557 5
a561 2
		TYPENAME
			{ write_exp_elt_opcode (OP_TYPE);
d575 1
a575 1
exp	:	INT
d579 1
a579 1
exp	:	CHARLIT
d586 1
a586 1
exp	:	FLOAT
d594 1
a594 1
exp	:	NULL_PTR
d598 1
a598 1
exp	:	STRING
d600 1
a600 3
			  write_exp_elt_opcode (OP_STRING);
			  write_exp_string ($1);
			  write_exp_elt_opcode (OP_STRING);
d604 1
a604 1
exp	: 	NEW TYPENAME
d608 48
a655 9
variable:	NAME   		{ write_var_from_name (NULL, $1); }
	|	block NAME  	/* GDB extension */
                                { write_var_from_name ($1, $2); }
	|	OBJECT_RENAMING 
		    { write_object_renaming (NULL, $1.sym, 
				             MAX_RENAMING_CHAIN_LENGTH); }
	|	block OBJECT_RENAMING
		    { write_object_renaming ($1, $2.sym, 
					     MAX_RENAMING_CHAIN_LENGTH); }
d658 21
a678 4
any_name :	NAME 		{ }
        |       TYPENAME	{ }
        |       OBJECT_RENAMING	{ }
        ;
d680 2
a681 4
block	:	BLOCKNAME  /* GDB extension */
			{ $$ = $1; }
	|	block BLOCKNAME /* GDB extension */
			{ $$ = $2; }
d684 8
d693 25
a717 7
type	:	TYPENAME	{ $$ = $1; }
	|	block TYPENAME  { $$ = $2; }
	| 	TYPENAME TICK_ACCESS
				{ $$ = lookup_pointer_type ($1); }
	|	block TYPENAME TICK_ACCESS
				{ $$ = lookup_pointer_type ($2); }
        ;
d722 1
a722 1
exp	:	'*' exp		%prec '.'
d724 1
a724 1
	|	'&' exp		%prec '.'
d726 1
a726 1
	|	exp '[' exp ']'
a760 1
  left_block_context = NULL;
a821 36
/* Emit expression to access an instance of NAME in :: context
 * ORIG_LEFT_CONTEXT.  If no unique symbol for NAME has been found,
 * output a dummy symbol (good to the next call of ada_parse) for NAME
 * in the UNDEF_DOMAIN, for later resolution by ada_resolve.  */
static void
write_var_from_name (struct block *orig_left_context,
		     struct name_info name)
{
  if (name.msym != NULL)
    {
      write_exp_msymbol (name.msym,
			 lookup_function_type (type_int ()),
			 type_int ());
    }
  else if (name.sym == NULL)
    {
      /* Multiple matches: record name and starting block for later
         resolution by ada_resolve.  */
      char *encoded_name = ada_encode (name.stoken.ptr);
      struct symbol *sym =
	obstack_alloc (&temp_parse_space, sizeof (struct symbol));
      memset (sym, 0, sizeof (struct symbol));
      SYMBOL_DOMAIN (sym) = UNDEF_DOMAIN;
      SYMBOL_LINKAGE_NAME (sym)
	= obsavestring (encoded_name, strlen (encoded_name), &temp_parse_space);
      SYMBOL_LANGUAGE (sym) = language_ada;

      write_exp_elt_opcode (OP_VAR_VALUE);
      write_exp_elt_block (name.block);
      write_exp_elt_sym (sym);
      write_exp_elt_opcode (OP_VAR_VALUE);
    }
  else
    write_var_from_sym (orig_left_context, name.block, name.sym);
}

d833 9
d980 1
a980 3
	  write_exp_elt_opcode (STRUCTOP_STRUCT);
	  write_exp_string (field_name);
	  write_exp_elt_opcode (STRUCTOP_STRUCT);
d996 337
d1337 1
a1420 1

@


1.14
log
@2004-10-15  Andrew Cagney  <cagney@@gnu.org>

	* ada-exp.y, ada-lex.l: Use xmalloc and xrealloc through out.
	* inf-ptrace.c: Include "gdb_wait.h" instead of <wait.h>.
	* Makefile.in (.y.c, .l.c): Don't replace xmalloc with xxmalloc.
	Update dependencies.
@
text
@d19 2
a20 1
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
@


1.13
log
@2004-10-06  Paul N. Hilfinger  <Hilfinger@@gnat.com>

* Makefile.in (.l.c): Do conversions of names of alloc and free
functions that are done for .y.c files, plus special one
for yy_flex_realloc.  Also, correct missing-file tests here.
* ada-lex.l (malloc, free): Remove macros.
(resize_tempbuf): Use "realloc"; rely on sed changes to convert to
xrealloc.
(ada_flex_use): Dummy definition to remove warnings about unused
functions.
* ada-exp.y (dummy_string_to_ada_operator): Temporary definition
to suppress warning.
@
text
@d855 1
a855 1
	  field_name.ptr = (char *) malloc (end - suffix + 1);
@


1.12
log
@* ada-exp.y (type_int): New function to add layer of abstraction
around references to expression types.
(type_long): Ditto.
(type_long_long): Ditto.
(type_float): Ditto.
(type_double): Ditto.
(type_long_double): Ditto.
(type_char): Ditto.
(type_system_address): Ditto.
(simple_exp): Use type_* functions in place of builtin_*
variables.
(exp): Ditto.
(write_var_from_name): Ditto.
(write_object_renaming): Ditto.
* ada-lang.c (ada_create_fundamental_type): Remove redundant
declaration.
(build_ada_types): Remove, replacing with...
(ada_language_arch_info): New function to initialize primitive
type vector in language_arch_info.
(ada_array_length): Remove use of builtin_type_ada_int.
(value_pos_atr): Ditto.
(ada_evaluate_subexp): Ditto.
(builtin_type_ada_int, builtin_type_ada_short, builtin_type_ada_long,
builtin_type_ada_long_long, builtin_type_ada_char,
builtin_type_ada_float, builtin_type_ada_double,
builtin_type_ada_long_double, builtin_type_ada_natural,
builtin_type_ada_positive, builtin_type_ada_system_address): Remove.
(ada_builtin_types): Remove.
(ada_language_defn): Remove entries for la_builtin_type_vector and
string_char_type and use ada_language_arch_info.
(_initialize_ada_language): Do type-vector initialization along
the lines of c-lang.c.
(ada_create_fundamental_type): Break up line.
(ada_dump_symtab): Remove unused function.
(enum ada_primitive_types): Define.
* ada-lang.h (builtin_type_ada_int, builtin_type_ada_short,
builtin_type_ada_long,builtin_type_ada_long_long,builtin_type_ada_char,
builtin_type_ada_float, builtin_type_ada_double,
builtin_type_ada_long_double, builtin_type_ada_natural,
builtin_type_ada_positive, builtin_type_ada_system_address): Remove.
* ada-lex.l: Use type_* functions in place of builtin_* variables.
(processInt): Ditto.
(processReal): Ditto.
(name_lookup): Ditto.
* ada-typeprint.c (print_range): Use builtin_type_int, not
builtin_type_ada_int.
@
text
@d955 10
@


1.11
log
@Remove ARI problems:

* ada-exp.y (write_var_from_sym): Reformat to put operator at
beginning of line.

* ada-lang.c (MAX_OF_SIZE): Rename max_of_size.
Add comment.
Add comment concerning MAX_OF_TYPE and MIN_OF_TYPE.
(MIN_OF_SIZE): Rename min_of_size.  Add comment.
(UMAX_OF_SIZE): Renmae umax_of_size.  Add comment.
(UMIN_OF_SIZE): Remove.
(max_of_type): New function to replace orphan macro in gdbtypes.h
(min_of_type): Ditto.
(discrete_type_high_bound): Use max_of_type.
(discrete_type_low_bound): Use min_of_type.
(possible_user_operator_p): Move operator to beginning of line.
(ada_is_variant_part): Ditto.
(ensure_lval): Rewrite to avoid deprecated operations.
(ada_finish_decode_line_1): Use gdbarch_convert_from_func_ptr_addr
rather than adding DEPRECATED_FUNCTION_START_OFFSET.
(ada_enum_name): Remove assignments in 'if' statements.
(build_ada_types): Add gdbarch parameter.
(_initialize_ada_language): Replace deprecated_register_gdbarch_swap
with gdbarch_data_register_post_init.
Use add_setshow_uinteger_cmd rather than add_set_cmd and
add_show_from_set.

* ada-valprint.c (inspect_it): Remove declaration.
(repeat_count_threshold): Remove declaration.
(ada_print_floating): Remove assignments in 'if' statements.
(print_str): Move operator to beginning of line.
@
text
@d129 16
d445 1
a445 1
			  write_exp_elt_type (builtin_type_ada_system_address);
d449 1
a449 1
			{ write_int ($3, builtin_type_int);
d452 1
a452 1
			{ write_int ($3, builtin_type_int);
d455 1
a455 1
			{ write_int ($3, builtin_type_int);
d468 1
a468 1
			{ write_int ($3, builtin_type_int);
d471 1
a471 1
			{ write_int ($3, builtin_type_int);
d474 1
a474 1
			{ write_int ($3, builtin_type_int);
d524 1
a524 1
			{ write_int (0, builtin_type_int); }
d685 2
a686 2
			 lookup_function_type (builtin_type_int),
			 builtin_type_int);
d798 1
a798 1
	    write_exp_elt_type (builtin_type_ada_int);
d898 52
@


1.10
log
@Address complaints from gdb_ari.sh:

* ada-exp.y: Include gdb_string.h rather than string.h.
(convert_char_literal): Reformat declaration.
* ada-lang.h: Include opaque struct declaration for struct frame_info.
* ada-lex.l: Change use of free to xfree (the macro would do so
anyway, but this is harmless).
Include gdb_string.h rather than string.h.
* ada-valprint.c (ada_val_print_stub): Change PTR => void*.

* ada-lang.c (parse): Remove K&Rism in parameter list.
(is_name_suffix): Correct Linux => GNU/Linux in comment.
@
text
@d647 2
a648 2
      if (innermost_block == 0 ||
	  contained_in (block, innermost_block))
@


1.9
log
@ada-exp.y: Synchronize with current ACT sources.
ada-lang.c: Ditto.
ada-lang.h: Ditto.
ada-lex.l: Ditto.
ada-tasks.c: Ditto.
ada-typeprint.c: Ditto.
ada-valprint.c: Ditto.
@
text
@d41 1
a41 1
#include <string.h>
d128 1
a128 2
static LONGEST
convert_char_literal (struct type *, LONGEST);
@


1.8
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_command): Replace STREQ with strcmp.
	* defs.h (DEPRECATED_STREQN): Rename STREQN.
	(DEPRECATED_STREQ): Rename STREQ.
	* ada-exp.y, ada-lang.c, ada-lex.l, coffread.c: Update.
	* config/mips/tm-irix5.h, config/mips/tm-irix6.h: Update.
	* config/mips/tm-mipsv4.h, config/sparc/tm-sun4sol2.h: Update.
	* dbxread.c, dwarf2read.c, dwarfread.c, environ.c: Update.
	* eval.c, exec.c, f-lang.c, hppa-tdep.c, hpread.c: Update.
	* jv-exp.y, language.c, m2-exp.y, mcore-rom.c: Update.
	* mdebugread.c, mipsread.c, objc-exp.y, objfiles.c: Update.
	* p-exp.y, p-typeprint.c, p-valprint.c, rs6000-nat.c: Update.
	* source.c, sparc-tdep.c, stack.c, target.c: Update.
@
text
@d2 2
a3 2
   Copyright (C) 1986, 1989, 1990, 1991, 1993, 1994, 1997, 2000, 2003
   Free Software Foundation, Inc.
d37 1
a37 1
   
d59 1
a59 1
   generators need to be fixed instead of adding those names to this list. */
d61 1
a61 1
/* NOTE: This is clumsy, especially since BISON and FLEX provide --prefix  
d72 7
a78 7
#define	yypact	ada_pact	
#define	yyr1	ada_r1			
#define	yyr2	ada_r2			
#define	yydef	ada_def		
#define	yychk	ada_chk		
#define	yypgo	ada_pgo		
#define	yyact	ada_act		
d104 3
a106 3
  struct symbol* sym;
  struct minimal_symbol* msym;
  struct block* block;
d111 2
a112 2
 * NULL. */
static struct type* type_qualifier;
d122 1
a122 5
static void write_attribute_call0 (enum ada_attribute);

static void write_attribute_call1 (enum ada_attribute, LONGEST);

static void write_attribute_calln (enum ada_attribute, int);
d124 1
a124 1
static void write_object_renaming (struct block*, struct symbol*);
d126 1
a126 1
static void write_var_from_name (struct block*, struct name_info);
d129 2
a130 2
convert_char_literal (struct type*, LONGEST);
%} 
d168 1
a168 1
%token <sval> STRING 
d170 1
a170 1
%type <bval> block 
d179 1
a179 3
%token <lval> LAST REGNAME

%token <ivar> INTERNAL_VARIABLE
d189 3
a191 3
 /* The following are right-associative only so that reductions at this 
    precedence have lower precedence than '.' and '('. The syntax still 
    forces a.b.c, e.g., to be LEFT-associated. */
d222 1
a222 1
			  write_exp_elt_opcode (STRUCTOP_STRUCT); 
d238 1
a238 1
			  write_exp_elt_opcode (UNOP_CAST); 
d244 1
a244 2
			  /*			  write_exp_elt_opcode (UNOP_QUAL); */
			  /* FIXME: UNOP_QUAL should be defined in expression.h */
d246 1
a246 2
			  /* write_exp_elt_opcode (UNOP_QUAL); */
			  /* FIXME: UNOP_QUAL should be defined in expression.h */
d262 1
a262 1
simple_exp :	variable	
d265 2
a266 5
simple_exp:	REGNAME /* GDB extension */
			{ write_exp_elt_opcode (OP_REGISTER);
			  write_exp_elt_longcst ((LONGEST) $1);
			  write_exp_elt_opcode (OP_REGISTER); 
			}
a268 8
simple_exp:	INTERNAL_VARIABLE /* GDB extension */
			{ write_exp_elt_opcode (OP_INTERNALVAR);
			  write_exp_elt_intern ($1);
			  write_exp_elt_opcode (OP_INTERNALVAR); 
			}
	;


a271 7
simple_exp:	LAST
			{ write_exp_elt_opcode (OP_LAST);
			  write_exp_elt_longcst ((LONGEST) $1);
			  write_exp_elt_opcode (OP_LAST); 
			 }
	;

d309 1
a309 1
			  write_exp_elt_opcode (UNOP_MEMVAL); 
d364 1
a364 3
                        { /*write_exp_elt_opcode (TERNOP_MBR); */ }
                          /* FIXME: TERNOP_MBR should be defined in
			     expression.h */
d366 1
a366 2
                        { /*write_exp_elt_opcode (BINOP_MBR); */
			  /* FIXME: BINOP_MBR should be defined in expression.h */
d368 1
a368 1
			  /*write_exp_elt_opcode (BINOP_MBR); */
d371 1
a371 2
                        { /*write_exp_elt_opcode (UNOP_MBR); */
			  /* FIXME: UNOP_QUAL should be defined in expression.h */			  
d373 1
a373 2
			  /*		          write_exp_elt_opcode (UNOP_MBR); */
			  /* FIXME: UNOP_MBR should be defined in expression.h */			  
d376 2
a377 3
                        { /*write_exp_elt_opcode (TERNOP_MBR); */
			  /* FIXME: TERNOP_MBR should be defined in expression.h */			  			  
		          write_exp_elt_opcode (UNOP_LOGICAL_NOT); 
d380 1
a380 2
                        { /* write_exp_elt_opcode (BINOP_MBR); */
			  /* FIXME: BINOP_MBR should be defined in expression.h */
d382 2
a383 3
			  /*write_exp_elt_opcode (BINOP_MBR);*/
			  /* FIXME: BINOP_MBR should be defined in expression.h */			  
		          write_exp_elt_opcode (UNOP_LOGICAL_NOT); 
d386 1
a386 2
                        { /*write_exp_elt_opcode (UNOP_MBR);*/
			  /* FIXME: UNOP_MBR should be defined in expression.h */			  
d388 2
a389 3
			  /*		          write_exp_elt_opcode (UNOP_MBR);*/
			  /* FIXME: UNOP_MBR should be defined in expression.h */			  			  
		          write_exp_elt_opcode (UNOP_LOGICAL_NOT); 
d405 1
a405 1
exp     :	exp _AND_ exp  /* Fix for Ada elementwise AND. */
d417 1
a417 1
exp     :       exp OR ELSE exp        
d434 2
a435 1
			{ write_attribute_call1 (ATR_FIRST, $3); }
d437 2
a438 1
			{ write_attribute_call1 (ATR_LAST, $3); }
d440 4
a443 3
			{ write_attribute_call1 (ATR_LENGTH, $3); }
        |       simple_exp TICK_SIZE 
			{ write_attribute_call0 (ATR_SIZE); }
d445 1
a445 1
			{ write_attribute_call0 (ATR_TAG); }
d447 1
a447 1
			{ write_attribute_calln (ATR_MIN, 2); }
d449 1
a449 1
			{ write_attribute_calln (ATR_MAX, 2); }
d451 1
a451 1
			{ write_attribute_calln (ATR_POS, 1); }
d453 2
a454 1
			{ write_attribute_call1 (ATR_FIRST, $3); }
d456 2
a457 1
			{ write_attribute_call1 (ATR_LAST, $3); }
d459 2
a460 1
			{ write_attribute_call1 (ATR_LENGTH, $3); }
d462 3
a464 3
			{ write_attribute_calln (ATR_VAL, 1); }
	|	type_prefix TICK_MODULUS 
			{ write_attribute_call0 (ATR_MODULUS); }
d482 1
a482 1
	| 	/* EMPTY */     
d487 1
a487 1
		
d490 1
a490 5
			{ write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_type ($1.type);
			  write_exp_elt_longcst ((LONGEST)($1.val));
			  write_exp_elt_opcode (OP_LONG); 
			}
d494 4
a497 9
			{ write_exp_elt_opcode (OP_LONG);
			  if (type_qualifier == NULL) 
			    write_exp_elt_type ($1.type);
			  else
			    write_exp_elt_type (type_qualifier);
			  write_exp_elt_longcst 
			    (convert_char_literal (type_qualifier, $1.val));
			  write_exp_elt_opcode (OP_LONG); 
			}
d499 1
a499 1
			      
d504 1
a504 1
			  write_exp_elt_opcode (OP_DOUBLE); 
d509 1
a509 5
			{ write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_type (builtin_type_int);
			  write_exp_elt_longcst ((LONGEST)(0));
			  write_exp_elt_opcode (OP_LONG); 
			 }
d513 5
a517 24
			{ /* Ada strings are converted into array constants 
			     a lower bound of 1.  Thus, the array upper bound 
			     is the string length. */
			  char *sp = $1.ptr; int count;
			  if ($1.length == 0) 
			    { /* One dummy character for the type */
			      write_exp_elt_opcode (OP_LONG);
			      write_exp_elt_type (builtin_type_ada_char);
			      write_exp_elt_longcst ((LONGEST)(0));
			      write_exp_elt_opcode (OP_LONG);
			    }
			  for (count = $1.length; count > 0; count -= 1)
			    {
			      write_exp_elt_opcode (OP_LONG);
			      write_exp_elt_type (builtin_type_ada_char);
			      write_exp_elt_longcst ((LONGEST)(*sp));
			      sp += 1;
			      write_exp_elt_opcode (OP_LONG);
			    }
			  write_exp_elt_opcode (OP_ARRAY);
			  write_exp_elt_longcst ((LONGEST) 1);
			  write_exp_elt_longcst ((LONGEST) ($1.length));
			  write_exp_elt_opcode (OP_ARRAY); 
			 }
d527 6
a532 3
	|	OBJECT_RENAMING { write_object_renaming (NULL, $1.sym); }
	|	block OBJECT_RENAMING 
				{ write_object_renaming ($1, $2.sym); }
d549 1
a549 1
	| 	TYPENAME TICK_ACCESS 
d556 1
a556 1
   can't get used to Ada notation in GDB. */
d586 2
d594 1
a594 1
ada_parse ()
d596 1
a596 1
  lexer_init (yyin);		/* (Re-)initialize lexer. */
d599 3
a601 1
  
d606 1
a606 2
yyerror (msg)
     char *msg;
d611 1
a611 1
/* The operator name corresponding to operator symbol STRING (adds 
d617 1
a617 1
   STRING.length+3 characters. */ 
d620 1
a620 2
string_to_operator (string)
     struct stoken string;
d624 1
a624 1
  for (i = 0; ada_opname_table[i].mangled != NULL; i += 1)
d626 2
a627 2
      if (string.length == strlen (ada_opname_table[i].demangled)-2
	  && strncasecmp (string.ptr, ada_opname_table[i].demangled+1,
d630 1
a630 1
	  strncpy (string.ptr, ada_opname_table[i].demangled,
d640 1
a640 1
 * non-NULL), and with :: qualification ORIG_LEFT_CONTEXT. */
d642 3
a644 4
write_var_from_sym (orig_left_context, block, sym)
     struct block* orig_left_context;
     struct block* block;
     struct symbol* sym;
d654 1
a654 3
  /* We want to use the selected frame, not another more inner frame
     which happens to be in the same block */
  write_exp_elt_block (NULL);
d659 4
a662 1
/* Emit expression to access an instance of NAME. */
d664 2
a665 3
write_var_from_name (orig_left_context, name)
     struct block* orig_left_context;
     struct name_info name;
d669 1
a669 1
      write_exp_msymbol (name.msym, 
d673 1
a673 1
  else if (name.sym == NULL) 
d675 12
a686 4
      /* Multiple matches: record name and starting block for later 
         resolution by ada_resolve. */
      /*      write_exp_elt_opcode (OP_UNRESOLVED_VALUE); */
      /* FIXME: OP_UNRESOLVED_VALUE should be defined in expression.h */      
d688 2
a689 4
      /*      write_exp_elt_name (name.stoken.ptr); */
      /* FIXME: write_exp_elt_name should be defined in defs.h, located in parse.c */      
      /*      write_exp_elt_opcode (OP_UNRESOLVED_VALUE); */
      /* FIXME: OP_UNRESOLVED_VALUE should be defined in expression.h */      
d695 1
a695 16
/* Write a call on parameterless attribute ATR.  */

static void
write_attribute_call0 (atr)
     enum ada_attribute atr;
{
  /*  write_exp_elt_opcode (OP_ATTRIBUTE); */
  /* FIXME: OP_ATTRIBUTE should be defined in expression.h */      
  write_exp_elt_longcst ((LONGEST) 0);
  write_exp_elt_longcst ((LONGEST) atr);
  /*  write_exp_elt_opcode (OP_ATTRIBUTE); */
  /* FIXME: OP_ATTRIBUTE should be defined in expression.h */      
}

/* Write a call on an attribute ATR with one constant integer
 * parameter. */
d698 1
a698 3
write_attribute_call1 (atr, arg)
     enum ada_attribute atr;
     LONGEST arg;
d701 1
a701 1
  write_exp_elt_type (builtin_type_int);
d704 1
a704 10
  /*write_exp_elt_opcode (OP_ATTRIBUTE);*/
  /* FIXME: OP_ATTRIBUTE should be defined in expression.h */
  write_exp_elt_longcst ((LONGEST) 1);
  write_exp_elt_longcst ((LONGEST) atr);
  /*write_exp_elt_opcode (OP_ATTRIBUTE);*/
  /* FIXME: OP_ATTRIBUTE should be defined in expression.h */        
}  

/* Write a call on an attribute ATR with N parameters, whose code must have
 * been generated previously. */
d706 1
a706 14
static void
write_attribute_calln (atr, n)
     enum ada_attribute atr;
     int n;
{
  /*write_exp_elt_opcode (OP_ATTRIBUTE);*/
  /* FIXME: OP_ATTRIBUTE should be defined in expression.h */      
  write_exp_elt_longcst ((LONGEST) n);
  write_exp_elt_longcst ((LONGEST) atr);
  /*  write_exp_elt_opcode (OP_ATTRIBUTE);*/
  /* FIXME: OP_ATTRIBUTE should be defined in expression.h */        
}  

/* Emit expression corresponding to the renamed object designated by 
d708 2
a709 1
 * type, in the context of ORIG_LEFT_CONTEXT (?). */
d711 2
a712 3
write_object_renaming (orig_left_context, renaming)
     struct block* orig_left_context;
     struct symbol* renaming;
d714 6
a719 6
  const char* qualification = DEPRECATED_SYMBOL_NAME (renaming);
  const char* simple_tail;
  const char* expr = TYPE_FIELD_NAME (SYMBOL_TYPE (renaming), 0);
  const char* suffix;
  char* name;
  struct symbol* sym;
d722 3
d726 1
a726 1
     block, otherwise we might fail our symbol lookup below */
d730 1
a730 1
  for (simple_tail = qualification + strlen (qualification); 
d737 2
a738 2
	} 
      else if (DEPRECATED_STREQN (simple_tail, "__", 2))
d749 1
a749 4
  name = (char*) malloc (suffix - expr + 1);
  /*  add_name_string_cleanup (name); */
  /* FIXME: add_name_string_cleanup should be defined in
     parser-defs.h, implemented in parse.c */    
d753 6
a758 5
  /*  if (sym == NULL) 
    error ("Could not find renamed variable: %s", ada_demangle (name));
  */
  /* FIXME: ada_demangle should be defined in defs.h, implemented in ada-lang.c */  
  write_var_from_sym (orig_left_context, block_found, sym);
d762 1
a762 1
  while (*suffix == 'X') 
d767 4
d775 1
a775 1
	if (isdigit (*suffix)) 
d777 1
a777 1
	    char* next;
d779 1
a779 1
	    if (next == suffix) 
d786 1
a786 1
	  } 
d789 2
a790 2
	    const char* end;
	    char* index_name;
d792 1
a792 1
	    struct symbol* index_sym;
d795 1
a795 1
	    if (end == NULL) 
d797 1
a797 1
	    
d799 2
a800 1
	    index_name = (char*) malloc (index_len);
a801 3
	    /*	    add_name_string_cleanup (index_name);*/
	    /* FIXME: add_name_string_cleanup should be defined in
	       parser-defs.h, implemented in parse.c */    	    
d807 1
a807 1
	    index_sym = 
d814 1
a814 1
	  { 
d831 1
a831 1
	  const char* end;
d833 1
a833 1
	  
d837 1
a837 1
	  if (end == NULL) 
d840 1
a840 1
	  field_name.ptr = (char*) malloc (end - suffix + 1);
d846 1
a846 1
	  write_exp_elt_opcode (STRUCTOP_STRUCT); 	  
d849 1
a849 1
	  
d859 1
a859 1
	 DEPRECATED_SYMBOL_NAME (renaming));
d864 2
a865 2
   Otherwise return VAL.  Hence, in an enumeration type ('A', 'B'), 
   the literal 'A' (VAL == 65), returns 0. */
d867 1
a867 1
convert_char_literal (struct type* type, LONGEST val)
d875 1
a875 1
  for (f = 0; f < TYPE_NFIELDS (type); f += 1) 
d877 1
a877 1
      if (DEPRECATED_STREQ (name, TYPE_FIELD_NAME (type, f)))
d882 6
@


1.8.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 2
a3 2
   Copyright (C) 1986, 1989, 1990, 1991, 1993, 1994, 1997, 2000, 2003, 
   2004 Free Software Foundation, Inc.
d37 1
a37 1

d41 1
a41 1
#include "gdb_string.h"
d59 1
a59 1
   generators need to be fixed instead of adding those names to this list.  */
d61 1
a61 1
/* NOTE: This is clumsy, especially since BISON and FLEX provide --prefix
d72 7
a78 7
#define	yypact	ada_pact
#define	yyr1	ada_r1
#define	yyr2	ada_r2
#define	yydef	ada_def
#define	yychk	ada_chk
#define	yypgo	ada_pgo
#define	yyact	ada_act
d104 3
a106 3
  struct symbol *sym;
  struct minimal_symbol *msym;
  struct block *block;
d111 2
a112 2
 * NULL.  */
static struct type *type_qualifier;
d122 5
a126 1
static void write_int (LONGEST, struct type *);
d128 1
a128 1
static void write_object_renaming (struct block *, struct symbol *, int);
d130 1
a130 1
static void write_var_from_name (struct block *, struct name_info);
d132 3
a134 2
static LONGEST convert_char_literal (struct type *, LONGEST);
%}
d172 1
a172 1
%token <sval> STRING
d174 1
a174 1
%type <bval> block
d183 3
a185 1
%token <sval> SPECIAL_VARIABLE
d195 3
a197 3
 /* The following are right-associative only so that reductions at this
    precedence have lower precedence than '.' and '('.  The syntax still
    forces a.b.c, e.g., to be LEFT-associated.  */
d228 1
a228 1
			  write_exp_elt_opcode (STRUCTOP_STRUCT);
d244 1
a244 1
			  write_exp_elt_opcode (UNOP_CAST);
d250 2
a251 1
			  write_exp_elt_opcode (UNOP_QUAL);
d253 2
a254 1
			  write_exp_elt_opcode (UNOP_QUAL);
d270 1
a270 1
simple_exp :	variable
d273 12
a284 2
simple_exp:	SPECIAL_VARIABLE /* Various GDB extensions */
			{ write_dollar_variable ($1); }
d287 1
d291 7
d335 1
a335 1
			  write_exp_elt_opcode (UNOP_MEMVAL);
d390 3
a392 1
			{ write_exp_elt_opcode (TERNOP_IN_RANGE); }
d394 2
a395 1
			{ write_exp_elt_opcode (BINOP_IN_BOUNDS);
d397 1
a397 1
			  write_exp_elt_opcode (BINOP_IN_BOUNDS);
d400 2
a401 1
			{ write_exp_elt_opcode (UNOP_IN_RANGE);
d403 2
a404 1
		          write_exp_elt_opcode (UNOP_IN_RANGE);
d407 3
a409 2
			{ write_exp_elt_opcode (TERNOP_IN_RANGE);
		          write_exp_elt_opcode (UNOP_LOGICAL_NOT);
d412 2
a413 1
			{ write_exp_elt_opcode (BINOP_IN_BOUNDS);
d415 3
a417 2
			  write_exp_elt_opcode (BINOP_IN_BOUNDS);
		          write_exp_elt_opcode (UNOP_LOGICAL_NOT);
d420 2
a421 1
			{ write_exp_elt_opcode (UNOP_IN_RANGE);
d423 3
a425 2
		          write_exp_elt_opcode (UNOP_IN_RANGE);
		          write_exp_elt_opcode (UNOP_LOGICAL_NOT);
d441 1
a441 1
exp     :	exp _AND_ exp  /* Fix for Ada elementwise AND.  */
d453 1
a453 1
exp     :       exp OR ELSE exp
d470 1
a470 2
			{ write_int ($3, builtin_type_int);
			  write_exp_elt_opcode (OP_ATR_FIRST); }
d472 1
a472 2
			{ write_int ($3, builtin_type_int);
			  write_exp_elt_opcode (OP_ATR_LAST); }
d474 3
a476 4
			{ write_int ($3, builtin_type_int);
			  write_exp_elt_opcode (OP_ATR_LENGTH); }
        |       simple_exp TICK_SIZE
			{ write_exp_elt_opcode (OP_ATR_SIZE); }
d478 1
a478 1
			{ write_exp_elt_opcode (OP_ATR_TAG); }
d480 1
a480 1
			{ write_exp_elt_opcode (OP_ATR_MIN); }
d482 1
a482 1
			{ write_exp_elt_opcode (OP_ATR_MAX); }
d484 1
a484 1
			{ write_exp_elt_opcode (OP_ATR_POS); }
d486 1
a486 2
			{ write_int ($3, builtin_type_int);
			  write_exp_elt_opcode (OP_ATR_FIRST); }
d488 1
a488 2
			{ write_int ($3, builtin_type_int);
			  write_exp_elt_opcode (OP_ATR_LAST); }
d490 1
a490 2
			{ write_int ($3, builtin_type_int);
			  write_exp_elt_opcode (OP_ATR_LENGTH); }
d492 3
a494 3
			{ write_exp_elt_opcode (OP_ATR_VAL); }
	|	type_prefix TICK_MODULUS
			{ write_exp_elt_opcode (OP_ATR_MODULUS); }
d512 1
a512 1
	| 	/* EMPTY */
d517 1
a517 1

d520 5
a524 1
			{ write_int ((LONGEST) $1.val, $1.type); }
d528 9
a536 4
                  { write_int (convert_char_literal (type_qualifier, $1.val),
			       (type_qualifier == NULL) 
			       ? $1.type : type_qualifier);
		  }
d538 1
a538 1

d543 1
a543 1
			  write_exp_elt_opcode (OP_DOUBLE);
d548 5
a552 1
			{ write_int (0, builtin_type_int); }
d556 24
a579 5
			{ 
			  write_exp_elt_opcode (OP_STRING);
			  write_exp_string ($1);
			  write_exp_elt_opcode (OP_STRING);
			}
d589 3
a591 6
	|	OBJECT_RENAMING 
		    { write_object_renaming (NULL, $1.sym, 
				             MAX_RENAMING_CHAIN_LENGTH); }
	|	block OBJECT_RENAMING
		    { write_object_renaming ($1, $2.sym, 
					     MAX_RENAMING_CHAIN_LENGTH); }
d608 1
a608 1
	| 	TYPENAME TICK_ACCESS
d615 1
a615 1
   can't get used to Ada notation in GDB.  */
a644 2
static struct obstack temp_parse_space;

d651 1
a651 1
ada_parse (void)
d653 1
a653 1
  lexer_init (yyin);		/* (Re-)initialize lexer.  */
d656 1
a656 3
  obstack_free (&temp_parse_space, NULL);
  obstack_init (&temp_parse_space);

d661 2
a662 1
yyerror (char *msg)
d667 1
a667 1
/* The operator name corresponding to operator symbol STRING (adds
d673 1
a673 1
   STRING.length+3 characters.  */
d676 2
a677 1
string_to_operator (struct stoken string)
d681 1
a681 1
  for (i = 0; ada_opname_table[i].encoded != NULL; i += 1)
d683 2
a684 2
      if (string.length == strlen (ada_opname_table[i].decoded)-2
	  && strncasecmp (string.ptr, ada_opname_table[i].decoded+1,
d687 1
a687 1
	  strncpy (string.ptr, ada_opname_table[i].decoded,
d697 1
a697 1
 * non-NULL), and with :: qualification ORIG_LEFT_CONTEXT.  */
d699 4
a702 3
write_var_from_sym (struct block *orig_left_context,
		    struct block *block,
		    struct symbol *sym)
d706 2
a707 2
      if (innermost_block == 0
	  || contained_in (block, innermost_block))
d712 3
a714 1
  write_exp_elt_block (block);
d719 1
a719 4
/* Emit expression to access an instance of NAME in :: context
 * ORIG_LEFT_CONTEXT.  If no unique symbol for NAME has been found,
 * output a dummy symbol (good to the next call of ada_parse) for NAME
 * in the UNDEF_DOMAIN, for later resolution by ada_resolve.  */
d721 3
a723 2
write_var_from_name (struct block *orig_left_context,
		     struct name_info name)
d727 1
a727 1
      write_exp_msymbol (name.msym,
d731 1
a731 1
  else if (name.sym == NULL)
d733 4
a736 12
      /* Multiple matches: record name and starting block for later
         resolution by ada_resolve.  */
      char *encoded_name = ada_encode (name.stoken.ptr);
      struct symbol *sym =
	obstack_alloc (&temp_parse_space, sizeof (struct symbol));
      memset (sym, 0, sizeof (struct symbol));
      SYMBOL_DOMAIN (sym) = UNDEF_DOMAIN;
      SYMBOL_LINKAGE_NAME (sym)
	= obsavestring (encoded_name, strlen (encoded_name), &temp_parse_space);
      SYMBOL_LANGUAGE (sym) = language_ada;

      write_exp_elt_opcode (OP_VAR_VALUE);
d738 4
a741 2
      write_exp_elt_sym (sym);
      write_exp_elt_opcode (OP_VAR_VALUE);
d747 1
a747 1
/* Write integer constant ARG of type TYPE.  */
d750 18
a767 1
write_int (LONGEST arg, struct type *type)
d770 1
a770 1
  write_exp_elt_type (type);
d773 23
a795 1
}
d797 1
a797 1
/* Emit expression corresponding to the renamed object designated by
d799 1
a799 2
 * type, in the context of ORIG_LEFT_CONTEXT.  MAX_DEPTH is the maximum
 * number of cascaded renamings to allow.  */
d801 3
a803 2
write_object_renaming (struct block *orig_left_context, 
		       struct symbol *renaming, int max_depth)
d805 6
a810 6
  const char *qualification = SYMBOL_LINKAGE_NAME (renaming);
  const char *simple_tail;
  const char *expr = TYPE_FIELD_NAME (SYMBOL_TYPE (renaming), 0);
  const char *suffix;
  char *name;
  struct symbol *sym;
a812 3
  if (max_depth <= 0)
    error ("Could not find renamed symbol");

d814 1
a814 1
     block; otherwise we might fail our symbol lookup below.  */
d818 1
a818 1
  for (simple_tail = qualification + strlen (qualification);
d825 2
a826 2
	}
      else if (strncmp (simple_tail, "__", 2) == 0)
d837 4
a840 1
  name = (char *) obstack_alloc (&temp_parse_space, suffix - expr + 1);
d844 5
a848 6
  if (sym == NULL)
    error ("Could not find renamed variable: %s", ada_decode (name));
  if (ada_is_object_renaming (sym))
    write_object_renaming (orig_left_context, sym, max_depth-1);
  else
    write_var_from_sym (orig_left_context, block_found, sym);
d852 1
a852 1
  while (*suffix == 'X')
a856 4
      case 'A':
        suffix += 1;
        write_exp_elt_opcode (UNOP_IND);
        break;
d861 1
a861 1
	if (isdigit (*suffix))
d863 1
a863 1
	    char *next;
d865 1
a865 1
	    if (next == suffix)
d872 1
a872 1
	  }
d875 2
a876 2
	    const char *end;
	    char *index_name;
d878 1
a878 1
	    struct symbol *index_sym;
d881 1
a881 1
	    if (end == NULL)
d883 1
a883 1

d885 1
a885 2
	    index_name
	      = (char *) obstack_alloc (&temp_parse_space, index_len);
d887 3
d895 1
a895 1
	    index_sym =
d902 1
a902 1
	  {
d919 1
a919 1
	  const char *end;
d921 1
a921 1

d925 1
a925 1
	  if (end == NULL)
d928 1
a928 1
	  field_name.ptr = (char *) malloc (end - suffix + 1);
d934 1
a934 1
	  write_exp_elt_opcode (STRUCTOP_STRUCT);
d937 1
a937 1

d947 1
a947 1
	 SYMBOL_LINKAGE_NAME (renaming));
d952 2
a953 2
   Otherwise return VAL.  Hence, in an enumeration type ('A', 'B'),
   the literal 'A' (VAL == 65), returns 0.  */
d955 1
a955 1
convert_char_literal (struct type *type, LONGEST val)
d963 1
a963 1
  for (f = 0; f < TYPE_NFIELDS (type); f += 1)
d965 1
a965 1
      if (strcmp (name, TYPE_FIELD_NAME (type, f)) == 0)
a969 6

void
_initialize_ada_exp (void)
{
  obstack_init (&temp_parse_space);
}
@


1.8.6.2
log
@Merge from mainline.
@
text
@a128 16

static struct type *type_int (void);

static struct type *type_long (void);

static struct type *type_long_long (void);

static struct type *type_float (void);

static struct type *type_double (void);

static struct type *type_long_double (void);

static struct type *type_char (void);

static struct type *type_system_address (void);
d429 1
a429 1
			  write_exp_elt_type (type_system_address ());
d433 1
a433 1
			{ write_int ($3, type_int ());
d436 1
a436 1
			{ write_int ($3, type_int ());
d439 1
a439 1
			{ write_int ($3, type_int ());
d452 1
a452 1
			{ write_int ($3, type_int ());
d455 1
a455 1
			{ write_int ($3, type_int ());
d458 1
a458 1
			{ write_int ($3, type_int ());
d508 1
a508 1
			{ write_int (0, type_int ()); }
d669 2
a670 2
			 lookup_function_type (type_int ()),
			 type_int ());
d782 1
a782 1
	    write_exp_elt_type (type_int ());
a881 52
static struct type *
type_int (void)
{
  return builtin_type (current_gdbarch)->builtin_int;
}

static struct type *
type_long (void)
{
  return builtin_type (current_gdbarch)->builtin_long;
}

static struct type *
type_long_long (void)
{
  return builtin_type (current_gdbarch)->builtin_long_long;
}

static struct type *
type_float (void)
{
  return builtin_type (current_gdbarch)->builtin_float;
}

static struct type *
type_double (void)
{
  return builtin_type (current_gdbarch)->builtin_double;
}

static struct type *
type_long_double (void)
{
  return builtin_type (current_gdbarch)->builtin_long_double;
}

static struct type *
type_char (void)
{
  return language_string_char_type (current_language, current_gdbarch);
}

static struct type *
type_system_address (void)
{
  struct type *type 
    = language_lookup_primitive_type_by_name (current_language,
					      current_gdbarch, 
					      "system__address");
  return  type != NULL ? type : lookup_pointer_type (builtin_type_void);
}

@


1.7
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@d826 1
a826 1
      else if (STREQN (simple_tail, "__", 2))
d965 1
a965 1
      if (STREQ (name, TYPE_FIELD_NAME (type, f)))
@


1.6
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d843 1
a843 1
  sym = lookup_symbol (name, orig_left_context, VAR_NAMESPACE, 0, NULL);
d896 1
a896 1
	      lookup_symbol (index_name, NULL, VAR_NAMESPACE, 0, NULL);
@


1.6.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d843 1
a843 1
  sym = lookup_symbol (name, orig_left_context, VAR_DOMAIN, 0, NULL);
d896 1
a896 1
	      lookup_symbol (index_name, NULL, VAR_DOMAIN, 0, NULL);
@


1.5
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add block.c.
	(block_h): New.
	(COMMON_OBS): Add block.o.
	(block.o): New.
	(x86-64-tdep.o): Add $(block_h).
	(values.o, valops.o, tracepoint.o, symtab.o, symmisc.o, symfile.o)
	(stack.o, printcmd.o, p-exp.tab.o, parse.o, objfiles.o)
	(objc-exp.tab.o, objc-lang.o, nlmread.o, mips-tdep.o, mdebugread.o)
	(m2-exp.tab.o, linespec.o, jv-lang.o, jv-exp.tab.o, infcmd.o)
	(f-valprint.o, findvar.o, f-exp.tab.o, expprint.o, coffread.o)
	(c-exp.tab.o, buildsym.o, breakpoint.o, blockframe.o, ax-gdb.o)
	(alpha-tdep.o, ada-lang.o, ada-exp.tab.o, mi-cmd-stack.o): Ditto.
	* value.h: Add opaque declaration for struct block.
	* parser-defs.h, objc-lang.h, buildsym.h, breakpoint.h: Ditto.
	* ada-lang.h: Ditto.
	* x86-64-tdep.c: #include "block.h"
	* values.c, valops.c, tracepoint.c, symtab.c, symmisc.c: Ditto.
	* symfile.c, stack.c, printcmd.c, p-exp.y, parse.c: Ditto.
	* objfiles.c, objc-exp.y, objc-lang.c, nlmread.c: Ditto.
	* mips-tdep.c, mdebugread.c, m2-exp.y, linespec.c: Ditto.
	* jv-lang.c, jv-exp.y, infcmd.c, f-valprint.c: Ditto.
	* findvar.c, f-exp.y, expprint.c, coffread.c, c-exp.y: Ditto.
	* buildsym.c, breakpoint.c, blockframe.c, ax-gdb.c: Ditto.
	* alpha-tdep.c, ada-lang.c, ada-exp.y: Ditto.
	* blockframe.c (blockvector_for_pc_sect): Move to "block.c".
	(blockvector_for_pc, block_for_pc_sect, block_for_pc): Ditto.
	* symtab.c (block_function): Ditto.
	(contained_in): Ditto.
	* frame.h: Move block_for_pc and block_for_pc_sect declarations to
	block.h.  Add opaque declaration for struct block.
	* symtab.h: Move block_function and contained_in declarations to
	block.h.  Add opaque declarations for struct block, struct
	blockvector.
	(struct block): Move to block.h.
	(struct blockvector): Ditto.
	(BLOCK_START, BLOCK_END, BLOCK_FUNCTION, BLOCK_SUPERBLOCK)
	(BLOCK_GCC_COMPILED, BLOCK_HASHTABLE, BLOCK_NSYMS, BLOCK_SYM)
	(BLOCK_BUCKETS, BLOCK_BUCKET, BLOCK_HASHTABLE_SIZE)
	(ALL_BLOCK_SYMBOLS, BLOCK_SHOULD_SORT, BLOCKVECTOR_NBLOCKS)
	(BLOCKVECTOR_BLOCK, GLOBAL_BLOCK, STATIC_BLOCK, FIRST_LOCAL_BLOCK):
	Ditto.
	* block.c: New file.
	* block.h: New file.

2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@d2 1
a2 1
   Copyright (C) 1986, 1989, 1990, 1991, 1993, 1994, 1997, 2000
d805 1
a805 1
  const char* qualification = SYMBOL_NAME (renaming);
d947 1
a947 1
	 SYMBOL_NAME (renaming));
@


1.4
log
@       * ada-exp.y: Add missing semicolons to end rules. Fixes a
       bison 1.35 warning.
@
text
@d52 1
@


1.4.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright (C) 1986, 1989, 1990, 1991, 1993, 1994, 1997, 2000, 2003
a51 1
#include "block.h"
d804 1
a804 1
  const char* qualification = DEPRECATED_SYMBOL_NAME (renaming);
d825 1
a825 1
      else if (DEPRECATED_STREQN (simple_tail, "__", 2))
d842 1
a842 1
  sym = lookup_symbol (name, orig_left_context, VAR_DOMAIN, 0, NULL);
d895 1
a895 1
	      lookup_symbol (index_name, NULL, VAR_DOMAIN, 0, NULL);
d946 1
a946 1
	 DEPRECATED_SYMBOL_NAME (renaming));
d964 1
a964 1
      if (DEPRECATED_STREQ (name, TYPE_FIELD_NAME (type, f)))
@


1.4.2.1
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a44 1
#include "block.h"
@


1.4.2.2
log
@2003-01-20  David Carlton  <carlton@@math.stanford.edu>

	* p-exp.y: Add block to OP_FUNCALL.
	* objc-exp.y: Add block to OP_FUNCALL.
	* m2-exp.y: Add block to OP_FUNCALL.
	* c-exp.y: Add block to OP_FUNCALL.
	* ada-exp.y: Add block to OP_FUNCALL.
	(write_object_renaming): Ditto.
	* parse.c (length_of_subexp): Split off OP_FUNCALL.
	(prefixify_subexp): Ditto.
	* expprint.c (print_subexp): Change offset for OP_FUNCALL.
	(dump_subexp): Ditto.
	* eval.c (evaluate_subexp_standard): Change offset for
	OP_FUNCALL.
	* ada-lang.c (ada_resolve_subexp): Add comment on OP_FUNCALL.
	(replace_operator_with_call): Add block to OP_FUNCALL.
	(ada_evaluate_subexp): Change offset for OP_FUNCALL.
	* expression.h (exp_opcode): Change comments before OP_FUNCALL and
	OP_F77_UNDETERMINED_ARGLIST.

2003-01-14  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (search_symbols): Add comment.
	(lookup_symbol_aux_using): Function name should start line.
	(lookup_symbol_aux_using_loop): Ditto.
	(lookup_block_symbol): Add comment.

2003-01-13  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (read_structure_scope): Add comment.
	(add_partial_structure): Ditto.
	* symtab.c (lookup_transparent_type): Add comment.
@
text
@a235 1
			  write_exp_elt_block (expression_context_block);
a904 1
	    write_exp_elt_block (expression_context_block);
@


1.4.2.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d2 1
a2 1
   Copyright (C) 1986, 1989, 1990, 1991, 1993, 1994, 1997, 2000, 2003
d45 1
a52 1
#include "block.h"
d806 1
a806 1
  const char* qualification = DEPRECATED_SYMBOL_NAME (renaming);
d949 1
a949 1
	 DEPRECATED_SYMBOL_NAME (renaming));
@


1.4.2.4
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d844 1
a844 1
  sym = lookup_symbol (name, orig_left_context, VAR_DOMAIN, 0, NULL);
d897 1
a897 1
	      lookup_symbol (index_name, NULL, VAR_DOMAIN, 0, NULL);
@


1.4.2.5
log
@2003-09-19  David Carlton  <carlton@@kealia.com>

	* expression.h (enum exp_opcode): Revert to mainline's OP_FUNCALL,
	OP_SCOPE.
	* ada-exp.y, m2-exp.y, objc-exp.y, p-exp.y: Ditto.
	* jv-exp.y (push_qualified_expression_name): Ditto.
	* ada-lang.c (ada_resolve_subexp, replace_operator_with_call)
	(ada_evaluate_subexp): Ditto.
	* eval.c (evaluate_subexp_standard): Ditto.
	* expprint.c (print_subexp, dump_subexp): Ditto.
	* parse.c (length_of_subexp, prefixify_subexp): Ditto.
	* c-exp.y: Ditto, and add comment.
	* cp-support.c (make_symbol_overload_list): Delete 'block'
	argument; change calls to make_symbol_overload_list_using
	appropriately.
	(make_symbol_overload_list_using): Delete 'block' argument;
	replace it by get_selected_block (0).
	* cp-support.h: Delete 'block' argument from
	make_symbol_overload_list.
	* valops.c (find_overload_match): Delete 'block' argument, and
	update calls using it.
	(find_oload_champ_namespace, find_oload_champ_namespace_loop)
	(value_aggregate_elt, value_struct_elt_for_reference)
	(value_namespace_elt): Ditto.
	(value_maybe_namespace_elt): Delete 'block' argument, and use
	get_selected_block (0) instead.
	* value.h: Delete 'block' argument from value_struct_elt,
	value_find_oload.
@
text
@d236 1
d906 1
@


1.4.2.6
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d826 1
a826 1
      else if (DEPRECATED_STREQN (simple_tail, "__", 2))
d965 1
a965 1
      if (DEPRECATED_STREQ (name, TYPE_FIELD_NAME (type, f)))
@


1.3
log
@* ada-exp.y (yyname, yyrule): Remap global variables that appear
when YYDEBUG is set to 1.
* c-exp.y: Likewise.
* f-exp.y: Likewise.
* jv-exp.y: Likewise.
* m2-exp.y: Likewise.
* p-exp.y: Likewise.
@
text
@d259 1
d536 1
a536 1

d552 1
@


1.2
log
@2002-06-19  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* parse.c (parse_fprintf): New function used to avoid calls to
	fprintf in bison parser generated debug code.
	* parser-defs.h: Declaration of new parse_fprintf function.
	* ada-exp.y, c-exp.y, f-exp.y, jv-exp.y, m2-exp.y, p-exp.y:
	Set YYDEBUG to 1 by default.
	Set YYFPRINTF as parse_fprintf.
@
text
@d93 2
@


1.1
log
@Add base ada language files
@
text
@d95 1
a95 1
#define	YYDEBUG	0		/* Default to no yydebug support */
d97 2
@


1.1.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@@


1.1.4.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d95 1
a95 1
#define	YYDEBUG	1		/* Default to yydebug support */
a96 2

#define YYFPRINTF parser_fprintf
@


1.1.4.3
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a92 2
#define yyname	ada_name		/* With YYDEBUG defined */
#define yyrule	ada_rule		/* With YYDEBUG defined */
a256 1
	;
d533 1
a533 1
	;
a548 1
	;
@


1.1.2.1
log
@merge from trunk
@
text
@@


1.1.2.2
log
@More merging.
@
text
@d95 1
a95 1
#define	YYDEBUG	1		/* Default to yydebug support */
a96 2

#define YYFPRINTF parser_fprintf
@


