head	1.29;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.24.2.2
	gdb_7_6-2013-04-26-release:1.24.2.2
	gdb_7_6-branch:1.24.0.2
	gdb_7_6-2013-03-12-branchpoint:1.24
	gdb_7_5_1-2012-11-29-release:1.17
	gdb_7_5-2012-08-17-release:1.17
	gdb_7_5-branch:1.17.0.2
	gdb_7_5-2012-07-18-branchpoint:1.17
	gdb_7_4_1-2012-04-26-release:1.16.2.1
	gdb_7_4-2012-01-24-release:1.16.2.1
	gdb_7_4-branch:1.16.0.2
	gdb_7_4-2011-12-13-branchpoint:1.16
	gdb_7_3_1-2011-09-04-release:1.15
	gdb_7_3-2011-07-26-release:1.15
	gdb_7_3-branch:1.15.0.2
	gdb_7_3-2011-04-01-branchpoint:1.15
	gdb_7_2-2010-09-02-release:1.13
	gdb_7_2-branch:1.13.0.2
	gdb_7_2-2010-07-07-branchpoint:1.13
	gdb_7_1-2010-03-18-release:1.12
	gdb_7_1-branch:1.12.0.2
	gdb_7_1-2010-02-18-branchpoint:1.12
	gdb_7_0_1-2009-12-22-release:1.11
	gdb_7_0-2009-10-06-release:1.11
	gdb_7_0-branch:1.11.0.4
	gdb_7_0-2009-09-16-branchpoint:1.11
	arc-sim-20090309:1.7
	msnyder-checkpoint-072509-branch:1.11.0.2
	msnyder-checkpoint-072509-branchpoint:1.11
	arc-insight_6_8-branch:1.7.0.16
	arc-insight_6_8-branchpoint:1.7
	insight_6_8-branch:1.7.0.14
	insight_6_8-branchpoint:1.7
	reverse-20081226-branch:1.7.0.12
	reverse-20081226-branchpoint:1.7
	multiprocess-20081120-branch:1.7.0.10
	multiprocess-20081120-branchpoint:1.7
	reverse-20080930-branch:1.7.0.8
	reverse-20080930-branchpoint:1.7
	reverse-20080717-branch:1.7.0.6
	reverse-20080717-branchpoint:1.7
	msnyder-reverse-20080609-branch:1.7.0.4
	msnyder-reverse-20080609-branchpoint:1.7
	drow-reverse-20070409-branch:1.4.0.2
	drow-reverse-20070409-branchpoint:1.4
	gdb_6_8-2008-03-27-release:1.7
	gdb_6_8-branch:1.7.0.2
	gdb_6_8-2008-02-26-branchpoint:1.7
	gdb_6_7_1-2007-10-29-release:1.6
	gdb_6_7-2007-10-10-release:1.6
	gdb_6_7-branch:1.6.0.2
	gdb_6_7-2007-09-07-branchpoint:1.6
	insight_6_6-20070208-release:1.3
	gdb_6_6-2006-12-18-release:1.3
	gdb_6_6-branch:1.3.0.18
	gdb_6_6-2006-11-15-branchpoint:1.3
	insight_6_5-20061003-release:1.3
	gdb-csl-symbian-6_4_50_20060226-12:1.3
	gdb-csl-sourcerygxx-3_4_4-25:1.2
	nickrob-async-20060828-mergepoint:1.3
	gdb-csl-symbian-6_4_50_20060226-11:1.3
	gdb-csl-sourcerygxx-4_1-17:1.3
	gdb-csl-20060226-branch-local-2:1.3
	gdb-csl-sourcerygxx-4_1-14:1.3
	gdb-csl-sourcerygxx-4_1-13:1.3
	gdb-csl-sourcerygxx-4_1-12:1.3
	gdb-csl-sourcerygxx-3_4_4-21:1.3
	gdb_6_5-20060621-release:1.3
	gdb-csl-sourcerygxx-4_1-9:1.3
	gdb-csl-sourcerygxx-4_1-8:1.3
	gdb-csl-sourcerygxx-4_1-7:1.3
	gdb-csl-arm-2006q1-6:1.3
	gdb-csl-sourcerygxx-4_1-6:1.3
	gdb-csl-symbian-6_4_50_20060226-10:1.3
	gdb-csl-symbian-6_4_50_20060226-9:1.3
	gdb-csl-symbian-6_4_50_20060226-8:1.3
	gdb-csl-coldfire-4_1-11:1.3
	gdb-csl-sourcerygxx-3_4_4-19:1.3
	gdb-csl-coldfire-4_1-10:1.3
	gdb_6_5-branch:1.3.0.16
	gdb_6_5-2006-05-14-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-5:1.3
	nickrob-async-20060513-branch:1.3.0.14
	nickrob-async-20060513-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-4:1.3
	msnyder-reverse-20060502-branch:1.3.0.12
	msnyder-reverse-20060502-branchpoint:1.3
	gdb-csl-morpho-4_1-4:1.3
	gdb-csl-sourcerygxx-3_4_4-17:1.3
	readline_5_1-import-branch:1.3.0.10
	readline_5_1-import-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.3
	gdb-csl-symbian-20060226-branch:1.3.0.8
	gdb-csl-symbian-20060226-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.3
	msnyder-reverse-20060331-branch:1.3.0.6
	msnyder-reverse-20060331-branchpoint:1.3
	gdb-csl-available-20060303-branch:1.3.0.4
	gdb-csl-available-20060303-branchpoint:1.3
	gdb-csl-20060226-branch:1.3.0.2
	gdb-csl-20060226-branchpoint:1.3
	gdb_6_4-20051202-release:1.2
	msnyder-fork-checkpoint-branch:1.2.0.12
	msnyder-fork-checkpoint-branchpoint:1.2
	gdb-csl-gxxpro-6_3-branch:1.2.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.2
	gdb_6_4-branch:1.2.0.8
	gdb_6_4-2005-11-01-branchpoint:1.2
	gdb-csl-arm-20051020-branch:1.2.0.6
	gdb-csl-arm-20051020-branchpoint:1.2
	msnyder-tracepoint-checkpoint-branch:1.2.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.2
	gdb-csl-arm-20050325-2005-q1b:1.2
	gdb-csl-arm-20050325-2005-q1a:1.2
	csl-arm-20050325-branch:1.2.0.2
	csl-arm-20050325-branchpoint:1.2
	gdb-post-i18n-errorwarning-20050211:1.2
	gdb-pre-i18n-errorwarning-20050211:1.2
	gdb_6_3-20041109-release:1.1
	gdb_6_3-branch:1.1.0.56
	gdb_6_3-20041019-branchpoint:1.1
	drow_intercu-merge-20040921:1.1
	drow_intercu-merge-20040915:1.1
	jimb-gdb_6_2-e500-branch:1.1.0.58
	jimb-gdb_6_2-e500-branchpoint:1.1
	gdb_6_2-20040730-release:1.1
	gdb_6_2-branch:1.1.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.1
	gdb_6_1_1-20040616-release:1.1
	gdb_6_1-2004-04-05-release:1.1
	drow_intercu-merge-20040402:1.1
	drow_intercu-merge-20040327:1.1
	ezannoni_pie-20040323-branch:1.1.0.52
	ezannoni_pie-20040323-branchpoint:1.1
	cagney_tramp-20040321-mergepoint:1.1
	cagney_tramp-20040309-branch:1.1.0.50
	cagney_tramp-20040309-branchpoint:1.1
	gdb_6_1-branch:1.1.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.1
	drow_intercu-20040221-branch:1.1.0.46
	drow_intercu-20040221-branchpoint:1.1
	cagney_bfdfile-20040213-branch:1.1.0.44
	cagney_bfdfile-20040213-branchpoint:1.1
	drow-cplus-merge-20040208:1.1
	carlton_dictionary-20040126-merge:1.1
	cagney_bigcore-20040122-branch:1.1.0.42
	cagney_bigcore-20040122-branchpoint:1.1
	drow-cplus-merge-20040113:1.1
	drow-cplus-merge-20031224:1.1
	drow-cplus-merge-20031220:1.1
	carlton_dictionary-20031215-merge:1.1
	drow-cplus-branch:1.1.0.40
	drow-cplus-merge-20031214:1.1
	carlton-dictionary-20031111-merge:1.1
	gdb_6_0-2003-10-04-release:1.1
	kettenis_sparc-20030918-branch:1.1.0.38
	kettenis_sparc-20030918-branchpoint:1.1
	carlton_dictionary-20030917-merge:1.1
	ezannoni_pie-20030916-branchpoint:1.1
	ezannoni_pie-20030916-branch:1.1.0.36
	cagney_x86i386-20030821-branch:1.1.0.34
	cagney_x86i386-20030821-branchpoint:1.1
	carlton_dictionary-20030805-merge:1.1
	carlton_dictionary-20030627-merge:1.1
	gdb_6_0-branch:1.1.0.32
	gdb_6_0-2003-06-23-branchpoint:1.1
	jimb-ppc64-linux-20030613-branch:1.1.0.30
	jimb-ppc64-linux-20030613-branchpoint:1.1
	cagney_convert-20030606-branch:1.1.0.28
	cagney_convert-20030606-branchpoint:1.1
	cagney_writestrings-20030508-branch:1.1.0.26
	cagney_writestrings-20030508-branchpoint:1.1
	jimb-ppc64-linux-20030528-branch:1.1.0.24
	jimb-ppc64-linux-20030528-branchpoint:1.1
	carlton_dictionary-20030523-merge:1.1
	cagney_fileio-20030521-branch:1.1.0.22
	cagney_fileio-20030521-branchpoint:1.1
	kettenis_i386newframe-20030517-mergepoint:1.1
	jimb-ppc64-linux-20030509-branch:1.1.0.20
	jimb-ppc64-linux-20030509-branchpoint:1.1
	kettenis_i386newframe-20030504-mergepoint:1.1
	carlton_dictionary-20030430-merge:1.1
	kettenis_i386newframe-20030419-branch:1.1.0.18
	kettenis_i386newframe-20030419-branchpoint:1.1
	carlton_dictionary-20030416-merge:1.1
	cagney_frameaddr-20030409-mergepoint:1.1
	kettenis_i386newframe-20030406-branch:1.1.0.16
	kettenis_i386newframe-20030406-branchpoint:1.1
	cagney_frameaddr-20030403-branchpoint:1.1
	cagney_frameaddr-20030403-branch:1.1.0.14
	cagney_framebase-20030330-mergepoint:1.1
	cagney_framebase-20030326-branch:1.1.0.12
	cagney_framebase-20030326-branchpoint:1.1
	cagney_lazyid-20030317-branch:1.1.0.10
	cagney_lazyid-20030317-branchpoint:1.1
	kettenis-i386newframe-20030316-mergepoint:1.1
	offbyone-20030313-branch:1.1.0.8
	offbyone-20030313-branchpoint:1.1
	kettenis-i386newframe-20030308-branch:1.1.0.6
	kettenis-i386newframe-20030308-branchpoint:1.1
	carlton_dictionary-branch:1.1.0.4
	carlton_dictionary-20030305-merge:1.1
	cagney_offbyone-20030303-branch:1.1.0.2
	cagney_offbyone-20030303-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.29
date	2013.04.19.15.33.29;	author palves;	state Exp;
branches;
next	1.28;

1.28
date	2013.04.08.19.59.08;	author tromey;	state Exp;
branches;
next	1.27;

1.27
date	2013.04.01.12.53.01;	author aristovski;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.27.09.47.41;	author palves;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.26.18.40.46;	author palves;	state Exp;
branches;
next	1.24;

1.24
date	2013.03.04.15.09.46;	author corinna;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2013.01.01.06.32.40;	author brobecke;	state Exp;
branches;
next	1.22;

1.22
date	2012.12.13.17.08.07;	author muller;	state Exp;
branches;
next	1.21;

1.21
date	2012.12.13.15.11.36;	author palves;	state Exp;
branches;
next	1.20;

1.20
date	2012.12.13.14.58.26;	author muller;	state Exp;
branches;
next	1.19;

1.19
date	2012.12.13.10.44.45;	author muller;	state Exp;
branches;
next	1.18;

1.18
date	2012.11.07.20.10.13;	author palves;	state Exp;
branches;
next	1.17;

1.17
date	2012.01.04.08.17.00;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.04.14.04.06;	author ro;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2011.01.01.15.32.58;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2010.12.31.22.59.52;	author msnyder;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.05.23.44.19;	author msnyder;	state Exp;
branches;
next	1.12;

1.12
date	2010.01.01.07.31.30;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.05.22.02.39;	author palves;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.09.09.33.31;	author ktietz;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.08.20.53.32;	author ktietz;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2007.08.23.18.08.27;	author brobecke;	state Exp;
branches;
next	1.5;

1.5
date	2007.07.17.12.51.41;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.29.17.53.26;	author ibr;	state Exp;
branches;
next	1.1;

1.1
date	2003.02.20.03.12.46;	author cgf;	state Exp;
branches
	1.1.4.1
	1.1.40.1;
next	;

1.24.2.1
date	2013.03.27.09.57.50;	author palves;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2013.03.27.09.58.57;	author palves;	state Exp;
branches;
next	;

1.16.2.1
date	2012.01.06.04.43.06;	author brobecke;	state Exp;
branches;
next	;

1.1.4.1
date	2003.03.06.00.56.24;	author carlton;	state Exp;
branches;
next	;

1.1.40.1
date	2003.12.14.20.27.08;	author drow;	state Exp;
branches;
next	;


desc
@@


1.29
log
@-Wpointer-sign: coff-pe-read.c: treat strings in PE/COFF data as char *.

A couple places take a pointer to the middle of some raw section
buffer and treat them as strings.  Add casts to char * as appropriate,
fixing -Wpointer-sign warnings.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* coff-pe-read.c (read_pe_exported_syms): Handle strings as char.
@
text
@/* Read the export table symbols from a portable executable and
   convert to internal format, for GDB. Used as a last resort if no
   debugging symbols recognized.

   Copyright (C) 2003-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Contributed by Raoul M. Gough (RaoulGough@@yahoo.co.uk).  */

#include "defs.h"

#include "coff-pe-read.h"

#include "bfd.h"
#include "gdbtypes.h"

#include "command.h"
#include "gdbcmd.h"
#include "symtab.h"
#include "symfile.h"
#include "objfiles.h"
#include "common/common-utils.h"
#include "coff/internal.h"

#include <ctype.h>

/* Internal section information */

/* Coff PE read debugging flag:
   default value is 0,
   value 1 outputs problems encountered while parsing PE file,
   value above 1 also lists all generated minimal symbols.  */
static unsigned int debug_coff_pe_read;

struct read_pe_section_data
{
  CORE_ADDR vma_offset;		/* Offset to loaded address of section.  */
  unsigned long rva_start;	/* Start offset within the pe.  */
  unsigned long rva_end;	/* End offset within the pe.  */
  enum minimal_symbol_type ms_type;	/* Type to assign symbols in
					   section.  */
  char *section_name;		/* Recorded section name.  */
};

#define IMAGE_SCN_CNT_CODE 0x20
#define IMAGE_SCN_CNT_INITIALIZED_DATA 0x40
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA 0x80
#define PE_SECTION_INDEX_TEXT     0
#define PE_SECTION_INDEX_DATA     1
#define PE_SECTION_INDEX_BSS      2
#define PE_SECTION_TABLE_SIZE     3
#define PE_SECTION_INDEX_INVALID -1

/* Get the index of the named section in our own array, which contains
   text, data and bss in that order.  Return PE_SECTION_INDEX_INVALID
   if passed an unrecognised section name.  */

static int
read_pe_section_index (const char *section_name)
{
  if (strcmp (section_name, ".text") == 0)
    {
      return PE_SECTION_INDEX_TEXT;
    }

  else if (strcmp (section_name, ".data") == 0)
    {
      return PE_SECTION_INDEX_DATA;
    }

  else if (strcmp (section_name, ".bss") == 0)
    {
      return PE_SECTION_INDEX_BSS;
    }

  else
    {
      return PE_SECTION_INDEX_INVALID;
    }
}

/* Get the index of the named section in our own full arrayi.
   text, data and bss in that order.  Return PE_SECTION_INDEX_INVALID
   if passed an unrecognised section name.  */

static int
get_pe_section_index (const char *section_name,
		      struct read_pe_section_data *sections,
		      int nb_sections)
{
  int i;

  for (i = 0; i < nb_sections; i++)
    if (strcmp (sections[i].section_name, section_name) == 0)
      return i;
  return PE_SECTION_INDEX_INVALID;
}

/* Structure used by get_section_vmas function below
   to access section_data array and the size of the array
   stored in nb_sections field.  */
struct pe_sections_info
{
  int nb_sections;
  struct read_pe_section_data *sections;
};

/* Record the virtual memory address of a section.  */

static void
get_section_vmas (bfd *abfd, asection *sectp, void *context)
{
  struct pe_sections_info *data = context;
  struct read_pe_section_data *sections = data->sections;
  int sectix = get_pe_section_index (sectp->name, sections,
				     data->nb_sections);

  if (sectix != PE_SECTION_INDEX_INVALID)
    {
      /* Data within the section start at rva_start in the pe and at
         bfd_get_section_vma() within memory.  Store the offset.  */

      sections[sectix].vma_offset
	= bfd_get_section_vma (abfd, sectp) - sections[sectix].rva_start;
    }
}

/* Create a minimal symbol entry for an exported symbol.
   SYM_NAME contains the exported name or NULL if exported by ordinal,
   FUNC_RVA contains the Relative Virtual Address of the symbol,
   ORDINAL is the ordinal index value of the symbol,
   SECTION_DATA contains information about the section in which the
   symbol is declared,
   DLL_NAME is the internal name of the DLL file,
   OBJFILE is the objfile struct of DLL_NAME.  */

static void
add_pe_exported_sym (const char *sym_name,
		     unsigned long func_rva,
		     int ordinal,
		     const struct read_pe_section_data *section_data,
		     const char *dll_name, struct objfile *objfile)
{
  char *qualified_name, *bare_name;
  /* Add the stored offset to get the loaded address of the symbol.  */
  CORE_ADDR vma = func_rva + section_data->vma_offset;

  /* Generate a (hopefully unique) qualified name using the first part
     of the dll name, e.g. KERNEL32!AddAtomA.  This matches the style
     used by windbg from the "Microsoft Debugging Tools for Windows".  */

  if (sym_name == NULL || *sym_name == '\0')
    bare_name = xstrprintf ("#%d", ordinal);
  else
    bare_name = xstrdup (sym_name);

  qualified_name = xstrprintf ("%s!%s", dll_name, bare_name);

  if ((section_data->ms_type == mst_unknown) && debug_coff_pe_read)
    fprintf_unfiltered (gdb_stdlog , _("Unknown section type for \"%s\""
			" for entry \"%s\" in dll \"%s\"\n"),
			section_data->section_name, sym_name, dll_name);

  prim_record_minimal_symbol (qualified_name, vma,
			      section_data->ms_type, objfile);

  /* Enter the plain name as well, which might not be unique.  */
  prim_record_minimal_symbol (bare_name, vma, section_data->ms_type, objfile);
  if (debug_coff_pe_read > 1)
    fprintf_unfiltered (gdb_stdlog, _("Adding exported symbol \"%s\""
			" in dll \"%s\"\n"), sym_name, dll_name);
  xfree (qualified_name);
  xfree (bare_name);
}

/* Create a minimal symbol entry for an exported forward symbol.
   Return 1 if the forwarded function was found 0 otherwise.
   SYM_NAME contains the exported name or NULL if exported by ordinal,
   FORWARD_DLL_NAME is the name of the DLL in which the target symobl resides,
   FORWARD_FUNC_NAME is the name of the target symbol in that DLL,
   ORDINAL is the ordinal index value of the symbol,
   DLL_NAME is the internal name of the DLL file,
   OBJFILE is the objfile struct of DLL_NAME.  */

static int
add_pe_forwarded_sym (const char *sym_name, const char *forward_dll_name,
		      const char *forward_func_name, int ordinal,
		      const char *dll_name, struct objfile *objfile)
{
  CORE_ADDR vma;
  struct bound_minimal_symbol msymbol;
  enum minimal_symbol_type msymtype;
  char *qualified_name, *bare_name;
  int forward_dll_name_len = strlen (forward_dll_name);
  int forward_func_name_len = strlen (forward_func_name);
  int forward_len = forward_dll_name_len + forward_func_name_len + 2;
  char *forward_qualified_name = alloca (forward_len);

  xsnprintf (forward_qualified_name, forward_len, "%s!%s", forward_dll_name,
	     forward_func_name);


  msymbol = lookup_minimal_symbol_and_objfile (forward_qualified_name);

  if (!msymbol.minsym)
    {
      int i;

      for (i = 0; i < forward_dll_name_len; i++)
	forward_qualified_name[i] = tolower (forward_qualified_name[i]);
      msymbol = lookup_minimal_symbol_and_objfile (forward_qualified_name);
    }

  if (!msymbol.minsym)
    {
      if (debug_coff_pe_read)
	fprintf_unfiltered (gdb_stdlog, _("Unable to find function \"%s\" in"
			    " dll \"%s\", forward of \"%s\" in dll \"%s\"\n"),
			    forward_func_name, forward_dll_name, sym_name,
			    dll_name);
      return 0;
    }

  if (debug_coff_pe_read > 1)
    fprintf_unfiltered (gdb_stdlog, _("Adding forwarded exported symbol"
			" \"%s\" in dll \"%s\", pointing to \"%s\"\n"),
			sym_name, dll_name, forward_qualified_name);

  vma = SYMBOL_VALUE_ADDRESS (msymbol.minsym);
  msymtype = MSYMBOL_TYPE (msymbol.minsym);

  /* Generate a (hopefully unique) qualified name using the first part
     of the dll name, e.g. KERNEL32!AddAtomA.  This matches the style
     used by windbg from the "Microsoft Debugging Tools for Windows".  */

  if (sym_name == NULL || *sym_name == '\0')
    bare_name = xstrprintf ("#%d", ordinal);
  else
    bare_name = xstrdup (sym_name);

  qualified_name = xstrprintf ("%s!%s", dll_name, bare_name);

  prim_record_minimal_symbol (qualified_name, vma, msymtype, objfile);

  /* Enter the plain name as well, which might not be unique.  */
  prim_record_minimal_symbol (bare_name, vma, msymtype, objfile);
  xfree (qualified_name);
  xfree (bare_name);

  return 1;
}

/* Truncate a dll_name at the last dot character.  */

static void
read_pe_truncate_name (char *dll_name)
{
  char *last_point = strrchr (dll_name, '.');

  if (last_point != NULL)
    *last_point = '\0';
}

/* Low-level support functions, direct from the ld module pe-dll.c.  */
static unsigned int
pe_get16 (bfd *abfd, int where)
{
  unsigned char b[2];

  bfd_seek (abfd, (file_ptr) where, SEEK_SET);
  bfd_bread (b, (bfd_size_type) 2, abfd);
  return b[0] + (b[1] << 8);
}

static unsigned int
pe_get32 (bfd *abfd, int where)
{
  unsigned char b[4];

  bfd_seek (abfd, (file_ptr) where, SEEK_SET);
  bfd_bread (b, (bfd_size_type) 4, abfd);
  return b[0] + (b[1] << 8) + (b[2] << 16) + (b[3] << 24);
}

static unsigned int
pe_as16 (void *ptr)
{
  unsigned char *b = ptr;

  return b[0] + (b[1] << 8);
}

static unsigned int
pe_as32 (void *ptr)
{
  unsigned char *b = ptr;

  return b[0] + (b[1] << 8) + (b[2] << 16) + (b[3] << 24);
}

/* Read the (non-debug) export symbol table from a portable
   executable.  Code originally lifted from the ld function
   pe_implied_import_dll in pe-dll.c.  */

void
read_pe_exported_syms (struct objfile *objfile)
{
  bfd *dll = objfile->obfd;
  unsigned long nbnormal, nbforward;
  unsigned long pe_header_offset, opthdr_ofs, num_entries, i;
  unsigned long export_opthdrrva, export_opthdrsize;
  unsigned long export_rva, export_size, nsections, secptr, expptr;
  unsigned long exp_funcbase;
  unsigned char *expdata, *erva;
  unsigned long name_rvas, ordinals, nexp, ordbase;
  char *dll_name = (char *) dll->filename;
  int otherix = PE_SECTION_TABLE_SIZE;
  int is_pe64 = 0;
  int is_pe32 = 0;

  /* Array elements are for text, data and bss in that order
     Initialization with RVA_START > RVA_END guarantees that
     unused sections won't be matched.  */
  struct read_pe_section_data *section_data;
  struct pe_sections_info pe_sections_info;

  struct cleanup *back_to = make_cleanup (null_cleanup, 0);

  char const *target = bfd_get_target (objfile->obfd);

  section_data = xzalloc (PE_SECTION_TABLE_SIZE
			 * sizeof (struct read_pe_section_data));

  make_cleanup (free_current_contents, &section_data);

  for (i=0; i < PE_SECTION_TABLE_SIZE; i++)
    {
      section_data[i].vma_offset = 0;
      section_data[i].rva_start = 1;
      section_data[i].rva_end = 0;
    };
  section_data[PE_SECTION_INDEX_TEXT].ms_type = mst_text;
  section_data[PE_SECTION_INDEX_TEXT].section_name = ".text";
  section_data[PE_SECTION_INDEX_DATA].ms_type = mst_data;
  section_data[PE_SECTION_INDEX_DATA].section_name = ".data";
  section_data[PE_SECTION_INDEX_BSS].ms_type = mst_bss;
  section_data[PE_SECTION_INDEX_BSS].section_name = ".bss";

  is_pe64 = (strcmp (target, "pe-x86-64") == 0
	     || strcmp (target, "pei-x86-64") == 0);
  is_pe32 = (strcmp (target, "pe-i386") == 0
	     || strcmp (target, "pei-i386") == 0
	     || strcmp (target, "pe-arm-wince-little") == 0
	     || strcmp (target, "pei-arm-wince-little") == 0);
  if (!is_pe32 && !is_pe64)
    {
      /* This is not a recognized PE format file.  Abort now, because
	 the code is untested on anything else.  *FIXME* test on
	 further architectures and loosen or remove this test.  */
      do_cleanups (back_to);
      return;
    }

  /* Get pe_header, optional header and numbers of export entries.  */
  pe_header_offset = pe_get32 (dll, 0x3c);
  opthdr_ofs = pe_header_offset + 4 + 20;
  if (is_pe64)
    num_entries = pe_get32 (dll, opthdr_ofs + 108);
  else
    num_entries = pe_get32 (dll, opthdr_ofs + 92);

  if (num_entries < 1)		/* No exports.  */
    {
      do_cleanups (back_to);
      return;
    }
  if (is_pe64)
    {
      export_opthdrrva = pe_get32 (dll, opthdr_ofs + 112);
      export_opthdrsize = pe_get32 (dll, opthdr_ofs + 116);
    }
  else
    {
      export_opthdrrva = pe_get32 (dll, opthdr_ofs + 96);
      export_opthdrsize = pe_get32 (dll, opthdr_ofs + 100);
    }
  nsections = pe_get16 (dll, pe_header_offset + 4 + 2);
  secptr = (pe_header_offset + 4 + 20 +
	    pe_get16 (dll, pe_header_offset + 4 + 16));
  expptr = 0;
  export_size = 0;

  /* Get the rva and size of the export section.  */
  for (i = 0; i < nsections; i++)
    {
      char sname[8];
      unsigned long secptr1 = secptr + 40 * i;
      unsigned long vaddr = pe_get32 (dll, secptr1 + 12);
      unsigned long vsize = pe_get32 (dll, secptr1 + 16);
      unsigned long fptr = pe_get32 (dll, secptr1 + 20);

      bfd_seek (dll, (file_ptr) secptr1, SEEK_SET);
      bfd_bread (sname, (bfd_size_type) sizeof (sname), dll);

      if ((strcmp (sname, ".edata") == 0)
	  || (vaddr <= export_opthdrrva && export_opthdrrva < vaddr + vsize))
	{
	  if (strcmp (sname, ".edata") != 0)
	    {
	      if (debug_coff_pe_read)
		fprintf_unfiltered (gdb_stdlog, _("Export RVA for dll "
				    "\"%s\" is in section \"%s\"\n"),
				    dll_name, sname);
	    }
	  else if (export_opthdrrva != vaddr && debug_coff_pe_read)
	    fprintf_unfiltered (gdb_stdlog, _("Wrong value of export RVA"
				" for dll \"%s\": 0x%lx instead of 0x%lx\n"),
				dll_name, export_opthdrrva, vaddr);
	  expptr = fptr + (export_opthdrrva - vaddr);
	  break;
	}
    }

  export_rva = export_opthdrrva;
  export_size = export_opthdrsize;

  if (export_size == 0)
    {
      /* Empty export table.  */
      do_cleanups (back_to);
      return;
    }

  /* Scan sections and store the base and size of the relevant
     sections.  */
  for (i = 0; i < nsections; i++)
    {
      unsigned long secptr1 = secptr + 40 * i;
      unsigned long vsize = pe_get32 (dll, secptr1 + 8);
      unsigned long vaddr = pe_get32 (dll, secptr1 + 12);
      unsigned long characteristics = pe_get32 (dll, secptr1 + 36);
      char sec_name[SCNNMLEN + 1];
      int sectix;

      bfd_seek (dll, (file_ptr) secptr1 + 0, SEEK_SET);
      bfd_bread (sec_name, (bfd_size_type) SCNNMLEN, dll);
      sec_name[SCNNMLEN] = '\0';

      sectix = read_pe_section_index (sec_name);

      if (sectix != PE_SECTION_INDEX_INVALID)
	{
	  section_data[sectix].rva_start = vaddr;
	  section_data[sectix].rva_end = vaddr + vsize;
	}
      else
	{
	  char *name;

	  section_data = xrealloc (section_data, (otherix + 1)
				   * sizeof (struct read_pe_section_data));
	  name = xstrdup (sec_name);
	  section_data[otherix].section_name = name;
	  make_cleanup (xfree, name);
	  section_data[otherix].rva_start = vaddr;
	  section_data[otherix].rva_end = vaddr + vsize;
	  section_data[otherix].vma_offset = 0;
	  if (characteristics & IMAGE_SCN_CNT_CODE)
	    section_data[otherix].ms_type = mst_text;
	  else if (characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA)
	    section_data[otherix].ms_type = mst_data;
	  else if (characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA)
	    section_data[otherix].ms_type = mst_bss;
	  else
	    section_data[otherix].ms_type = mst_unknown;
	  otherix++;
	}
    }

  expdata = (unsigned char *) xmalloc (export_size);
  make_cleanup (xfree, expdata);

  bfd_seek (dll, (file_ptr) expptr, SEEK_SET);
  bfd_bread (expdata, (bfd_size_type) export_size, dll);
  erva = expdata - export_rva;

  nexp = pe_as32 (expdata + 24);
  name_rvas = pe_as32 (expdata + 32);
  ordinals = pe_as32 (expdata + 36);
  ordbase = pe_as32 (expdata + 16);
  exp_funcbase = pe_as32 (expdata + 28);

  /* Use internal dll name instead of full pathname.  */
  dll_name = (char *) (pe_as32 (expdata + 12) + erva);

  pe_sections_info.nb_sections = otherix;
  pe_sections_info.sections = section_data;

  bfd_map_over_sections (dll, get_section_vmas, &pe_sections_info);

  /* Adjust the vma_offsets in case this PE got relocated. This
     assumes that *all* sections share the same relocation offset
     as the text section.  */
  for (i = 0; i < otherix; i++)
    {
      section_data[i].vma_offset
	+= ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
    }

  /* Truncate name at first dot. Should maybe also convert to all
     lower case for convenience on Windows.  */
  read_pe_truncate_name (dll_name);

  if (debug_coff_pe_read)
    fprintf_unfiltered (gdb_stdlog, _("DLL \"%s\" has %ld export entries,"
			" base=%ld\n"), dll_name, nexp, ordbase);
  nbforward = 0;
  nbnormal = 0;
  /* Iterate through the list of symbols.  */
  for (i = 0; i < nexp; i++)
    {
      /* Pointer to the names vector.  */
      unsigned long name_rva = pe_as32 (erva + name_rvas + i * 4);
      /* Retrieve ordinal value.  */

      unsigned long ordinal = pe_as16 (erva + ordinals + i * 2);


      /* Pointer to the function address vector.  */
      /* This is relatived to ordinal value. */
      unsigned long func_rva = pe_as32 (erva + exp_funcbase +
                                        ordinal * 4);

      /* Find this symbol's section in our own array.  */
      int sectix = 0;
      int section_found = 0;

      /* First handle forward cases.  */
      if (func_rva >= export_rva && func_rva < export_rva + export_size)
	{
	  char *forward_name = (char *) (erva + func_rva);
	  char *funcname = (char *) (erva + name_rva);
	  char *forward_dll_name = forward_name;
	  char *forward_func_name = forward_name;
	  char *sep = strrchr (forward_name, '.');

	  if (sep)
	    {
	      int len = (int) (sep - forward_name);

	      forward_dll_name = alloca (len + 1);
	      strncpy (forward_dll_name, forward_name, len);
	      forward_dll_name[len] = '\0';
	      forward_func_name = ++sep;
	    }
	  if (add_pe_forwarded_sym (funcname, forward_dll_name,
				    forward_func_name, ordinal,
				    dll_name, objfile) != 0)
	    ++nbforward;
	  continue;
	}

      for (sectix = 0; sectix < otherix; ++sectix)
	{
	  if ((func_rva >= section_data[sectix].rva_start)
	      && (func_rva < section_data[sectix].rva_end))
	    {
	      char *sym_name = (char *) (erva + name_rva);

	      section_found = 1;
	      add_pe_exported_sym (sym_name, func_rva, ordinal,
				   section_data + sectix, dll_name, objfile);
	      ++nbnormal;
	      break;
	    }
	}
      if (!section_found)
	{
	  char *funcname = (char *) (erva + name_rva);

	  if (name_rva == 0)
	    {
	      add_pe_exported_sym (NULL, func_rva, ordinal,
				   section_data, dll_name, objfile);
	      ++nbnormal;
	    }
	  else if (debug_coff_pe_read)
	    fprintf_unfiltered (gdb_stdlog, _("Export name \"%s\" ord. %lu,"
				" RVA 0x%lx in dll \"%s\" not handled\n"),
				funcname, ordinal, func_rva, dll_name);
	}
    }

  if (debug_coff_pe_read)
    fprintf_unfiltered (gdb_stdlog, _("Finished reading \"%s\", exports %ld,"
			" forwards %ld, total %ld/%ld.\n"), dll_name, nbnormal,
			nbforward, nbnormal + nbforward, nexp);
  /* Discard expdata and section_data.  */
  do_cleanups (back_to);
}

/* Extract from ABFD the offset of the .text section.
   This offset is mainly related to the offset within the file.
   The value was previously expected to be 0x1000 for all files,
   but some Windows OS core DLLs seem to use 0x10000 section alignement
   which modified the return value of that function.
   Still return default 0x1000 value if ABFD is NULL or
   if '.text' section is not found, but that should not happen...  */

#define DEFAULT_COFF_PE_TEXT_SECTION_OFFSET 0x1000

CORE_ADDR
pe_text_section_offset (struct bfd *abfd)

{
  unsigned long pe_header_offset, i;
  unsigned long nsections, secptr;
  int is_pe64 = 0;
  int is_pe32 = 0;
  char const *target;

  if (!abfd)
    return DEFAULT_COFF_PE_TEXT_SECTION_OFFSET;

  target = bfd_get_target (abfd);

  is_pe64 = (strcmp (target, "pe-x86-64") == 0
	     || strcmp (target, "pei-x86-64") == 0);
  is_pe32 = (strcmp (target, "pe-i386") == 0
	     || strcmp (target, "pei-i386") == 0
	     || strcmp (target, "pe-arm-wince-little") == 0
	     || strcmp (target, "pei-arm-wince-little") == 0);

  if (!is_pe32 && !is_pe64)
    {
      /* This is not a recognized PE format file.  Abort now, because
	 the code is untested on anything else.  *FIXME* test on
	 further architectures and loosen or remove this test.  */
      return DEFAULT_COFF_PE_TEXT_SECTION_OFFSET;
    }

  /* Get pe_header, optional header and numbers of sections.  */
  pe_header_offset = pe_get32 (abfd, 0x3c);
  nsections = pe_get16 (abfd, pe_header_offset + 4 + 2);
  secptr = (pe_header_offset + 4 + 20 +
	    pe_get16 (abfd, pe_header_offset + 4 + 16));

  /* Get the rva and size of the export section.  */
  for (i = 0; i < nsections; i++)
    {
      char sname[SCNNMLEN + 1];
      unsigned long secptr1 = secptr + 40 * i;
      unsigned long vaddr = pe_get32 (abfd, secptr1 + 12);

      bfd_seek (abfd, (file_ptr) secptr1, SEEK_SET);
      bfd_bread (sname, (bfd_size_type) SCNNMLEN, abfd);
      sname[SCNNMLEN] = '\0';
      if (strcmp (sname, ".text") == 0)
	return vaddr;
    }

  return DEFAULT_COFF_PE_TEXT_SECTION_OFFSET;
}

/* Implements "show debug coff_pe_read" command.  */

static void
show_debug_coff_pe_read (struct ui_file *file, int from_tty,
			 struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("Coff PE read debugging is %s.\n"), value);
}

/* Provide a prototype to silence -Wmissing-prototypes.  */

void _initialize_coff_pe_read (void);

/* Adds "Set/show debug coff_pe_read" commands.  */

void
_initialize_coff_pe_read (void)
{
  add_setshow_zuinteger_cmd ("coff-pe-read", class_maintenance,
			     &debug_coff_pe_read,
			     _("Set coff PE read debugging."),
			     _("Show coff PE read debugging."),
			     _("When set, debugging messages for coff reading "
			       "of exported symbols are displayed."),
			     NULL, show_debug_coff_pe_read,
			     &setdebuglist, &showdebuglist);
}
@


1.28
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@d508 1
a508 1
  dll_name = pe_as32 (expdata + 12) + erva;
d582 2
d585 1
a585 2
	      add_pe_exported_sym (erva + name_rva,
				   func_rva, ordinal,
@


1.27
log
@	Fix coff-pe-read.c to compile with Wunused.

	* coff-pe-read.c (add_pe_exported_sym): Remove unused 'dll_name_len'.
	(add_pe_forwarded_sym): Remove unused 'section', 'dll_name_len'.
	(read_pe_exported_syms): Remove unused 'exportix'.
	(pe_text_section_offset): Remove unused 'opthdr_ofs', 'num_entries',
	'export_rva', 'export_size', 'expptr', 'exp_funcbase', 'expdata',
	'erva', 'name_rvas', 'ordinals', 'nexp', 'ordbase', 'dll_name'.

	Reference: http://sourceware.org/ml/gdb-patches/2013-03/msg01081.html
@
text
@d205 1
a205 2
  struct objfile *forward_objfile;
  struct minimal_symbol *msymbol;
d217 1
a217 2
  msymbol = lookup_minimal_symbol_and_objfile (forward_qualified_name,
					       &forward_objfile);
d219 1
a219 1
  if (!msymbol)
d225 1
a225 2
      msymbol = lookup_minimal_symbol_and_objfile (forward_qualified_name,
						   &forward_objfile);
d228 1
a228 1
  if (!msymbol)
d243 2
a244 2
  vma = SYMBOL_VALUE_ADDRESS (msymbol);
  msymtype = MSYMBOL_TYPE (msymbol);
@


1.26
log
@Rename "set debug coff_pe_read" command to "set debug coff-pe-read".

Hyphens are much more common than underscores in command names.

gdb/
2013-03-27  Pedro Alves  <palves@@redhat.com>

	* coff-pe-read.c (_initialize_coff_pe_read): Rename "set debug
	coff_pe_read" command to "set debug coff-pe-read".
@
text
@a160 1
  int dll_name_len = strlen (dll_name);
a206 1
  short section;
a207 1
  int dll_name_len = strlen (dll_name);
a246 1
  section = SYMBOL_SECTION (msymbol);
a334 1
  int exportix = -1;
a436 1
	  exportix = i;
d632 2
a633 6
  unsigned long pe_header_offset, opthdr_ofs, num_entries, i;
  unsigned long export_rva, export_size, nsections, secptr, expptr;
  unsigned long exp_funcbase;
  unsigned char *expdata, *erva;
  unsigned long name_rvas, ordinals, nexp, ordbase;
  char *dll_name;
a659 1
  opthdr_ofs = pe_header_offset + 4 + 20;
@


1.25
log
@Make "set/show debug coff_pe_read" a zuinteger instead of uinteger.

Being a uinteger means you can't disable debug output after enabling it...

  (gdb) show debug coff_pe_read
  Coff PE read debugging is 0.
  (gdb) set debug coff_pe_read 0
  (gdb) show debug coff_pe_read
  Coff PE read debugging is unlimited.
  (gdb)

gdb/
2013-03-26  Pedro Alves  <palves@@redhat.com>

	* coff-pe-read.c (_initialize_coff_pe_read): Make the command
	zuinteger instead of uinteger.
@
text
@d710 1
a710 1
  add_setshow_zuinteger_cmd ("coff_pe_read", class_maintenance,
@


1.24
log
@	* coff-pe-read.c (read_pe_exported_syms): Don't return without
	calling do_cleanup.
@
text
@d710 8
a717 8
  add_setshow_uinteger_cmd ("coff_pe_read", class_maintenance,
			    &debug_coff_pe_read,
			    _("Set coff PE read debugging."),
			    _("Show coff PE read debugging."),
			    _("When set, debugging messages for coff reading "
			      "of exported symbols are displayed."),
			    NULL, show_debug_coff_pe_read,
			    &setdebuglist, &showdebuglist);
@


1.24.2.1
log
@Make "set/show debug coff_pe_read" a zuinteger instead of uinteger.

Being a uinteger means you can't disable debug output after enabling it...

  (gdb) show debug coff_pe_read
  Coff PE read debugging is 0.
  (gdb) set debug coff_pe_read 0
  (gdb) show debug coff_pe_read
  Coff PE read debugging is unlimited.
  (gdb)

gdb/
2013-03-27  Pedro Alves  <palves@@redhat.com>

	* coff-pe-read.c (_initialize_coff_pe_read): Make the command
	zuinteger instead of uinteger.
@
text
@d710 8
a717 8
  add_setshow_zuinteger_cmd ("coff_pe_read", class_maintenance,
			     &debug_coff_pe_read,
			     _("Set coff PE read debugging."),
			     _("Show coff PE read debugging."),
			     _("When set, debugging messages for coff reading "
			       "of exported symbols are displayed."),
			     NULL, show_debug_coff_pe_read,
			     &setdebuglist, &showdebuglist);
@


1.24.2.2
log
@Rename "set debug coff_pe_read" command to "set debug coff-pe-read".

Hyphens are much more common than underscores in command names.

gdb/
2013-03-27  Pedro Alves  <palves@@redhat.com>

	* coff-pe-read.c (_initialize_coff_pe_read): Rename "set debug
	coff_pe_read" command to "set debug coff-pe-read".
@
text
@d710 1
a710 1
  add_setshow_zuinteger_cmd ("coff-pe-read", class_maintenance,
@


1.23
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d382 1
d396 1
d453 1
@


1.22
log
@	* coff-pe-read.c (pe_text_section_offset): Increase size of sname
	local variable and zero terminate it to avoid possible problems
	in strcmp.
@
text
@d5 1
a5 1
   Copyright (C) 2003, 2007-2012 Free Software Foundation, Inc.
@


1.21
log
@2012-12-13  Pedro Alves  <palves@@redhat.com>

	* coff-pe-read.c: Include coff/internal.h.
	(read_pe_exported_syms): Use SCNNMLEN instead of hardcoded 8.
	Null terminate buffer explicitly instead of memset the whole
	buffer.
@
text
@d675 1
a675 1
      char sname[8];
d680 2
a681 1
      bfd_bread (sname, (bfd_size_type) 8, abfd);
@


1.20
log
@	* coff-pe-read.c (IMAGE_SCN_CNT_TEXT, IMAGE_SCN_CNT_INITIALIZED_DATA)
	(IMAGE_SCN_CNT_UNINITIALIZED_DATA): Remove useless checks
	for already defined macros.
@
text
@d37 1
d462 1
a462 1
      char sec_name[9];
a464 1
      memset (sec_name, 0, sizeof (sec_name));
d466 2
a467 1
      bfd_bread (sec_name, (bfd_size_type) 8, dll);
@


1.19
log
@	* coff-pe-read.h (pe_text_section_offset): Declare new function.
	* coff-pe-read.c (debug_coff_pe_read): New static variable.
	(struct read_pe_section_data): Add section_name field.
	(IMAGE_SCN_CNT_CODE): New macro, if not already defined.
	(IMAGE_SCN_CNT_INITIALIZED_DATA): Ditto.
	(IMAGE_SCN_CNT_UNINITIALIZED_DATA): Ditto.
	(get_pe_section_index): New function.
	(struct pe_sections_info): New type.
	(get_section_vmas): Use new struct pe_sections_info.
	(add_pe_exported_sym): Handle unnamed exported function.
	(add_pe_forwarded_sym): New function.
	(read_pe_truncate_name): Truncate at last dot.
	(pe_as16): New function.
	(read_pe_exported_syms): Use ordinal of function to
	retrieve correct RVA address of function and handle
	forwarded symbol.
	(pe_text_section_offset): New function.
	(show_debug_coff_pe_read): New function.
	(_initialize_coff_pe_read): New function adding
	'set/show debug coff_pe_read' commands.

	* windows-tdep.c (windows_xfer_shared_library): Use
	pe_text_section_offset function instead of possibly wrong
	0x1000 constant for .text sextion offset.
@
text
@d58 3
a60 9
#ifndef IMAGE_SCN_CNT_CODE
# define IMAGE_SCN_CNT_CODE 0x20
#endif
#ifndef IMAGE_SCN_CNT_INITIALIZED_DATA
# define IMAGE_SCN_CNT_INITIALIZED_DATA 0x40
#endif
#ifndef IMAGE_SCN_CNT_UNINITIALIZED_DATA
# define IMAGE_SCN_CNT_UNINITIALIZED_DATA 0x80
#endif
@


1.18
log
@2012-11-07  Pedro Alves  <palves@@redhat.com>

	* arm-tdep.c: Make defs.h be the first include.
	* coff-pe-read.c: Ditto.
	* gnu-nat.c: Ditto.
	* go32-nat.c: Ditto.
	* i386-nat.c: Ditto.
	* ppcnbsd-nat.c: Ditto.
	* ada-varobj.h: Don't include defs.h.
	* i386-darwin-tdep.h: Ditto.
	* i386-nat.h: Ditto.
@
text
@d31 2
d36 3
d42 6
d55 1
d58 9
d101 26
d132 4
a135 2
  struct read_pe_section_data *sections = context;
  int sectix = read_pe_section_index (sectp->name);
d147 8
a154 1
/* Create a minimal symbol entry for an exported symbol.  */
d157 1
a157 1
add_pe_exported_sym (char *sym_name,
d159 1
d163 1
d165 6
d172 32
a203 1
  CORE_ADDR vma = func_rva + section_data->vma_offset;
d205 10
a214 1
  char *qualified_name = 0;
d216 41
d262 4
a265 1
  qualified_name = xmalloc (dll_name_len + strlen (sym_name) + 2);
d267 1
a267 3
  strncpy (qualified_name, dll_name, dll_name_len);
  qualified_name[dll_name_len] = '!';
  strcpy (qualified_name + dll_name_len + 1, sym_name);
d269 1
a269 2
  prim_record_minimal_symbol (qualified_name,
			      vma, section_data->ms_type, objfile);
d271 2
d274 1
d276 1
a276 3
  /* Enter the plain name as well, which might not be unique.  */
  prim_record_minimal_symbol (sym_name, vma, 
			      section_data->ms_type, objfile);
d279 1
a279 1
/* Truncate a dll_name at the first dot character.  */
d284 1
a284 6
  while (*dll_name)
    {
      if ((*dll_name) == '.')
	{
	  *dll_name = '\0';	/* truncates and causes loop exit.  */
	}
d286 2
a287 5
      else
	{
	  ++dll_name;
	}
    }
d312 8
d335 1
d337 1
d342 3
a344 1
  char *dll_name;
d349 1
a349 1
     Initialization with start_rva > end_rva guarantees that
d351 2
a352 5
  struct read_pe_section_data section_data[PE_SECTION_TABLE_SIZE]
    = { {0, 1, 0, mst_text},
  {0, 1, 0, mst_data},
  {0, 1, 0, mst_bss}
  };
d354 1
a354 1
  struct cleanup *back_to = 0;
d358 18
a381 1

a401 1

d404 2
a405 2
      export_rva = pe_get32 (dll, opthdr_ofs + 112);
      export_size = pe_get32 (dll, opthdr_ofs + 116);
d409 2
a410 2
      export_rva = pe_get32 (dll, opthdr_ofs + 96);
      export_size = pe_get32 (dll, opthdr_ofs + 100);
d416 1
d428 1
a428 1
      bfd_bread (sname, (bfd_size_type) 8, dll);
d430 2
a431 1
      if (vaddr <= export_rva && vaddr + vsize > export_rva)
d433 13
a445 3
	  expptr = fptr + (export_rva - vaddr);
	  if (export_rva + export_size > vaddr + vsize)
	    export_size = vsize - (export_rva - vaddr);
d450 3
d466 1
d470 1
a470 1
      sec_name[8] = '\0';
d481 22
d506 1
a506 1
  back_to = make_cleanup (xfree, expdata);
d521 4
a524 1
  bfd_map_over_sections (dll, get_section_vmas, section_data);
d529 1
a529 1
  for (i = 0; i < PE_SECTION_TABLE_SIZE; i++)
d539 5
d549 4
d555 3
a557 1
      unsigned long func_rva = pe_as32 (erva + exp_funcbase + i * 4);
d561 14
d576 13
a588 1
      for (sectix = 0; sectix < PE_SECTION_TABLE_SIZE; ++sectix)
d593 1
d595 1
a595 1
				   func_rva,
d597 1
d601 15
d618 5
a622 1
  /* Discard expdata.  */
d625 95
@


1.17
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d24 2
a27 1
#include "defs.h"
@


1.16
log
@	* coff-pe-read.c: Include defs.h before bfd.h.
@
text
@d5 1
a5 2
   Copyright (C) 2003, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.16.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d5 2
a6 1
   Copyright (C) 2003, 2007-2012 Free Software Foundation, Inc.
@


1.15
log
@run copyright.sh for 2011.
@
text
@d27 1
a28 2

#include "defs.h"
@


1.14
log
@2010-12-31  Michael Snyder  <msnyder@@vmware.com>

	* charset.c: Comment cleanup and long line wrapping.
	* charset.h: Ditto.
	* c-lang.c: Ditto.
	* c-lang.h: Ditto.
	* coff-pe-read.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* complaints.c: Ditto.
	* complaints.h: Ditto.
	* completer.c: Ditto.
	* completer.h: Ditto.
	* corefile.c: Ditto.
	* corelow.c: Ditto.
	* core-regset.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-abi.h: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cp-support.h: Ditto.
	* cp-valprint.c: Ditto.
	* cp-typeprint.c: Ditto.
	* c-valprint.c: Ditto.
@
text
@d5 2
a6 1
   Copyright (C) 2003, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.13
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* elfread.c (elf_symtab_read): Delete unused variable.
	(find_separate_debug_file_by_buildid): Delete unused variables.
	(elf_symfile_read): Delete unused variable.

	* coffread.c (coff_symfile_read): Delete unused variables.

	* coff-pe-read.c (add_pe_exported_sym): Delete unused variable.
	(read_pe_exported_syms): Delete unused variable.

	* stabsread.c (define_symbol): Delete unused variable.

	* dwarf2read.c (read_type_comp_unit_head): Delete unused variable.
	(process_psymtab_comp_unit): Delete unused variable.
	(dwarf2_build_psymtabs_hard): Delete unused variable.
	(load_partial_comp_unit): Delete unused variable.
	(create_all_comp_units): Delete unused variable.
	(scan_partial_symbols): Delete unused variable.
	(add_partial_symbol): Delete unused variable.
	(add_partial_namespace): Delete unused variable.
	(add_partial_enumeration): Delete unused variable.
	(load_full_comp_unit): Delete unused variable.
	(process_full_comp_unit): Delete unused variable.
	(read_file_scope): Delete unused variable.
	(read_type_unit_scope): Delete unused variable.
	(process_structure_scope): Delete unused variable.
	(process_enumeration_scope): Delete unused variable.
	(read_tag_ptr_to_member_type): Delete unused variable.
	(read_typedef): Delete unused variable.
	(read_partial_die): Delete unused variable.
	(decode_locdesc): Delete unused variable.
	(zeroed_partial_die): Delete unused global variable.
@
text
@d22 1
a22 1
   Contributed by Raoul M. Gough (RaoulGough@@yahoo.co.uk). */
d39 5
a43 4
  CORE_ADDR vma_offset;		/* Offset to loaded address of section. */
  unsigned long rva_start;	/* Start offset within the pe. */
  unsigned long rva_end;	/* End offset within the pe. */
  enum minimal_symbol_type ms_type;	/* Type to assign symbols in section. */
d53 2
a54 2
   text, data and bss in that order. Return PE_SECTION_INDEX_INVALID
   if passed an unrecognised section name. */
d80 1
a80 1
/* Record the virtual memory address of a section. */
d91 1
a91 1
         bfd_get_section_vma() within memory. Store the offset. */
d98 1
a98 1
/* Create a minimal symbol entry for an exported symbol. */
d106 1
a106 1
  /* Add the stored offset to get the loaded address of the symbol. */
d114 2
a115 2
     of the dll name, e.g. KERNEL32!AddAtomA. This matches the style
     used by windbg from the "Microsoft Debugging Tools for Windows". */
d128 3
a130 2
  /* Enter the plain name as well, which might not be unique. */
  prim_record_minimal_symbol (sym_name, vma, section_data->ms_type, objfile);
d133 1
a133 1
/* Truncate a dll_name at the first dot character. */
d142 1
a142 1
	  *dll_name = '\0';	/* truncates and causes loop exit. */
d152 1
a152 1
/* Low-level support functions, direct from the ld module pe-dll.c. */
d182 2
a183 2
   executable. Code originally lifted from the ld function
   pe_implied_import_dll in pe-dll.c. */
d200 1
a200 1
     unused sections won't be matched. */
d222 1
a222 1
	 further architectures and loosen or remove this test. */
d277 1
a277 1
      /* Empty export table. */
d281 2
a282 1
  /* Scan sections and store the base and size of the relevant sections. */
d317 1
a317 1
  /* Use internal dll name instead of full pathname. */
d324 1
a324 1
     as the text section. */
d332 1
a332 1
     lower case for convenience on Windows. */
d344 1
a344 1
      /* Find this symbol's section in our own array. */
d360 1
a360 1
  /* discard expdata. */
@


1.12
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a110 1
  int count;
a284 1
      unsigned long flags = pe_get32 (dll, secptr1 + 36);
@


1.11
log
@	* coff-pe-read.c (read_pe_exported_syms): Recognize
	"pe-arm-wince-little" and "pei-arm-wince-little" bfd targets as PE
	targets.
@
text
@d5 1
a5 1
   Copyright (C) 2003, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.10
log
@2009-01-09  Kai Tietz  <kai.tietz@@onevision.com>

        * coff-pe-read.c (read_pe_exported_syms): Fix typo.
@
text
@d210 7
a216 4
  is_pe64 = ((strcmp (target, "pe-x86-64") == 0)
             || (strcmp (target, "pei-x86-64") == 0));
  is_pe32 = ((strcmp (target, "pe-i386") == 0)
             || (strcmp (target, "pei-i386") == 0));
d219 3
a221 3
      /* This is not an i386 format file. Abort now, because the code
         is untested on anything else. *FIXME* test on further
         architectures and loosen or remove this test. */
@


1.9
log
@2009-01-08  Kai Tietz  <kai.tietz@@onevision.com>

	* coff-pe-read.c (read_pe_exported_syms): Enable read of PE+
	export directory.
@
text
@d226 1
a226 1
    num_entries = pe_get32 (dll, opthdr_ofs + 108;
@


1.8
log
@        Updated copyright notices for most files.
@
text
@d194 2
d210 5
a214 1
  if ((strcmp (target, "pe-i386") != 0) && (strcmp (target, "pei-i386") != 0))
d225 4
a228 1
  num_entries = pe_get32 (dll, opthdr_ofs + 92);
d235 10
a244 2
  export_rva = pe_get32 (dll, opthdr_ofs + 96);
  export_size = pe_get32 (dll, opthdr_ofs + 100);
@


1.7
log
@	Updated copyright notices for most files.
@
text
@d5 1
a5 1
   Copyright (C) 2003, 2007, 2008 Free Software Foundation, Inc.
@


1.6
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d5 1
a5 1
   Copyright (C) 2003, 2007 Free Software Foundation, Inc.
@


1.5
log
@2007-07-17  Pedro Alves  <pedro_alves@@portugalmail.pt>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* config/i386/cygwin.mt (TDEPFILES): Add solib-target.o.
	* coff-pe-read.c (read_pe_exported_syms): Delete verbose
	printf.
	* NEWS: Mention gdbserver DLL support.

	* gdb.base/unload.c (dlopen, dlsym, dlclose, dlerror): Define
	for __WIN32__.
	(SHLIB_NAME): Delete definition.  Always pass dlerror to fprintf.
	* gdb.base/unload.exp: Use shared library test routines.

	* inferiors.c (all_dlls, dlls_changed, get_dll): New.
	(add_thread): Minor cleanups.
	(clear_inferiors): Move lower in the file.  Clear the DLL
	list.
	(free_one_dll, match_dll, loaded_dll, unloaded_dll, clear_list): New.
	* remote-utils.c (prepare_resume_reply): Check dlls_changed.
	(xml_escape_text): New.
	* server.c (handle_query): Handle qXfer:libraries:read.  Report it
	for qSupported.
	(handle_v_cont): Report errors.
	(gdbserver_version): Update.
	(main): Correct size of own_buf.  Do not report initial DLL events.
	* server.h (struct dll_info, all_dlls, dlls_changed, loaded_dll)
	(unloaded_dll, xml_escape_text): New.
	* win32-low.c (enum target_waitkind): Update comments.
	(win32_add_one_solib, get_image_name, winapi_EnumProcessModules)
	(winapi_GetModuleInformation, winapi_GetModuleFileNameExA)
	(win32_EnumProcessModules, win32_GetModuleInformation)
	(win32_GetModuleFileNameExA, load_psapi, psapi_get_dll_name)
	(winapi_CreateToolhelp32Snapshot, winapi_Module32First)
	(winapi_Module32Next, win32_CreateToolhelp32Snapshot)
	(win32_Module32First, win32_Module32Next, load_toolhelp)
	(toolhelp_get_dll_name, handle_load_dll, handle_unload_dll): New.
	(get_child_debug_event): Handle DLL events.
	(win32_wait): Likewise.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.
@


1.4
log
@Copyright updates for 2007.
@
text
@a311 3
  printf_filtered (_("Minimal symbols from %s..."), dll_name);
  wrap_here ("");

@


1.3
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d5 1
a5 1
   Copyright (C) 2003 Free Software Foundation, Inc.
@


1.2
log
@2005-01-29  Baurzhan Ismagulov  <ibr@@radix50.net>

	* ax-gdb.c, ax-general.c, bcache.c, bfd-target.c, bsd-kvm.c,
	* buildsym.c, c-lang.c, c-typeprint.c, c-valprint.c, charset.c,
	* coff-pe-read.c, coffread.c, complaints.c, copying.c: I18n markup.
@
text
@d5 1
a5 1
   Copyright 2003 Free Software Foundation, Inc.
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.
@


1.1
log
@* coff-pe-read.c: New file - support reading of minimal symbols from a portable
executable using the export table.
* coff-pe-read.h: New file.
* coffread.c: Include coff-pe-read.h.
(coff_symtab_read): Call read_pe_exported_syms iff no recognized debugging
symbols found.
* Makefile.in (SFILES): Add coff-pe-read.o.
(coff_pe_read_h): Define.
(COMMON_OBS): Add coff-pe-read.o.
(coffread.o): Add coff_pe_read_h dependency.
(coff-pe-read.o): New target.
@
text
@d312 1
a312 1
  printf_filtered ("Minimal symbols from %s...", dll_name);
@


1.1.40.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.1.4.1
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@@

