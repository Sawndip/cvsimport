head	1.63;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.61
	gdb_7_6-2013-04-26-release:1.61
	gdb_7_6-branch:1.61.0.2
	gdb_7_6-2013-03-12-branchpoint:1.61
	gdb_7_5_1-2012-11-29-release:1.59
	gdb_7_5-2012-08-17-release:1.59
	gdb_7_5-branch:1.59.0.2
	gdb_7_5-2012-07-18-branchpoint:1.59
	gdb_7_4_1-2012-04-26-release:1.50.2.1
	gdb_7_4-2012-01-24-release:1.50.2.1
	gdb_7_4-branch:1.50.0.2
	gdb_7_4-2011-12-13-branchpoint:1.50
	gdb_7_3_1-2011-09-04-release:1.49
	gdb_7_3-2011-07-26-release:1.49
	gdb_7_3-branch:1.49.0.2
	gdb_7_3-2011-04-01-branchpoint:1.49
	gdb_7_2-2010-09-02-release:1.44
	gdb_7_2-branch:1.44.0.2
	gdb_7_2-2010-07-07-branchpoint:1.44
	gdb_7_1-2010-03-18-release:1.35
	gdb_7_1-branch:1.35.0.2
	gdb_7_1-2010-02-18-branchpoint:1.35
	gdb_7_0_1-2009-12-22-release:1.33
	gdb_7_0-2009-10-06-release:1.33
	gdb_7_0-branch:1.33.0.4
	gdb_7_0-2009-09-16-branchpoint:1.33
	arc-sim-20090309:1.26
	msnyder-checkpoint-072509-branch:1.33.0.2
	msnyder-checkpoint-072509-branchpoint:1.33
	arc-insight_6_8-branch:1.26.0.6
	arc-insight_6_8-branchpoint:1.26
	insight_6_8-branch:1.26.0.4
	insight_6_8-branchpoint:1.26
	reverse-20081226-branch:1.31.0.6
	reverse-20081226-branchpoint:1.31
	multiprocess-20081120-branch:1.31.0.4
	multiprocess-20081120-branchpoint:1.31
	reverse-20080930-branch:1.31.0.2
	reverse-20080930-branchpoint:1.31
	reverse-20080717-branch:1.29.0.4
	reverse-20080717-branchpoint:1.29
	msnyder-reverse-20080609-branch:1.29.0.2
	msnyder-reverse-20080609-branchpoint:1.29
	drow-reverse-20070409-branch:1.23.0.2
	drow-reverse-20070409-branchpoint:1.23
	gdb_6_8-2008-03-27-release:1.26
	gdb_6_8-branch:1.26.0.2
	gdb_6_8-2008-02-26-branchpoint:1.26
	gdb_6_7_1-2007-10-29-release:1.24
	gdb_6_7-2007-10-10-release:1.24
	gdb_6_7-branch:1.24.0.2
	gdb_6_7-2007-09-07-branchpoint:1.24
	insight_6_6-20070208-release:1.21
	gdb_6_6-2006-12-18-release:1.21
	gdb_6_6-branch:1.21.0.18
	gdb_6_6-2006-11-15-branchpoint:1.21
	insight_6_5-20061003-release:1.21
	gdb-csl-symbian-6_4_50_20060226-12:1.21
	gdb-csl-sourcerygxx-3_4_4-25:1.20
	nickrob-async-20060828-mergepoint:1.21
	gdb-csl-symbian-6_4_50_20060226-11:1.21
	gdb-csl-sourcerygxx-4_1-17:1.21
	gdb-csl-20060226-branch-local-2:1.21
	gdb-csl-sourcerygxx-4_1-14:1.21
	gdb-csl-sourcerygxx-4_1-13:1.21
	gdb-csl-sourcerygxx-4_1-12:1.21
	gdb-csl-sourcerygxx-3_4_4-21:1.21
	gdb_6_5-20060621-release:1.21
	gdb-csl-sourcerygxx-4_1-9:1.21
	gdb-csl-sourcerygxx-4_1-8:1.21
	gdb-csl-sourcerygxx-4_1-7:1.21
	gdb-csl-arm-2006q1-6:1.21
	gdb-csl-sourcerygxx-4_1-6:1.21
	gdb-csl-symbian-6_4_50_20060226-10:1.21
	gdb-csl-symbian-6_4_50_20060226-9:1.21
	gdb-csl-symbian-6_4_50_20060226-8:1.21
	gdb-csl-coldfire-4_1-11:1.21
	gdb-csl-sourcerygxx-3_4_4-19:1.21
	gdb-csl-coldfire-4_1-10:1.21
	gdb_6_5-branch:1.21.0.16
	gdb_6_5-2006-05-14-branchpoint:1.21
	gdb-csl-sourcerygxx-4_1-5:1.21
	nickrob-async-20060513-branch:1.21.0.14
	nickrob-async-20060513-branchpoint:1.21
	gdb-csl-sourcerygxx-4_1-4:1.21
	msnyder-reverse-20060502-branch:1.21.0.12
	msnyder-reverse-20060502-branchpoint:1.21
	gdb-csl-morpho-4_1-4:1.21
	gdb-csl-sourcerygxx-3_4_4-17:1.21
	readline_5_1-import-branch:1.21.0.10
	readline_5_1-import-branchpoint:1.21
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.21
	gdb-csl-symbian-20060226-branch:1.21.0.8
	gdb-csl-symbian-20060226-branchpoint:1.21
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.21
	msnyder-reverse-20060331-branch:1.21.0.6
	msnyder-reverse-20060331-branchpoint:1.21
	gdb-csl-available-20060303-branch:1.21.0.4
	gdb-csl-available-20060303-branchpoint:1.21
	gdb-csl-20060226-branch:1.21.0.2
	gdb-csl-20060226-branchpoint:1.21
	gdb_6_4-20051202-release:1.20
	msnyder-fork-checkpoint-branch:1.20.0.10
	msnyder-fork-checkpoint-branchpoint:1.20
	gdb-csl-gxxpro-6_3-branch:1.20.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.20
	gdb_6_4-branch:1.20.0.6
	gdb_6_4-2005-11-01-branchpoint:1.20
	gdb-csl-arm-20051020-branch:1.20.0.4
	gdb-csl-arm-20051020-branchpoint:1.20
	msnyder-tracepoint-checkpoint-branch:1.20.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.20
	gdb-csl-arm-20050325-2005-q1b:1.19
	gdb-csl-arm-20050325-2005-q1a:1.19
	csl-arm-20050325-branch:1.19.0.2
	csl-arm-20050325-branchpoint:1.19
	gdb-post-i18n-errorwarning-20050211:1.14
	gdb-pre-i18n-errorwarning-20050211:1.13
	gdb_6_3-20041109-release:1.13
	gdb_6_3-branch:1.13.0.4
	gdb_6_3-20041019-branchpoint:1.13
	drow_intercu-merge-20040921:1.13
	drow_intercu-merge-20040915:1.13
	jimb-gdb_6_2-e500-branch:1.13.0.6
	jimb-gdb_6_2-e500-branchpoint:1.13
	gdb_6_2-20040730-release:1.13
	gdb_6_2-branch:1.13.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.13
	gdb_6_1_1-20040616-release:1.12
	gdb_6_1-2004-04-05-release:1.12
	drow_intercu-merge-20040402:1.12
	drow_intercu-merge-20040327:1.12
	ezannoni_pie-20040323-branch:1.12.0.10
	ezannoni_pie-20040323-branchpoint:1.12
	cagney_tramp-20040321-mergepoint:1.12
	cagney_tramp-20040309-branch:1.12.0.8
	cagney_tramp-20040309-branchpoint:1.12
	gdb_6_1-branch:1.12.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.12
	drow_intercu-20040221-branch:1.12.0.4
	drow_intercu-20040221-branchpoint:1.12
	cagney_bfdfile-20040213-branch:1.12.0.2
	cagney_bfdfile-20040213-branchpoint:1.12
	drow-cplus-merge-20040208:1.12
	carlton_dictionary-20040126-merge:1.11
	cagney_bigcore-20040122-branch:1.11.0.2
	cagney_bigcore-20040122-branchpoint:1.11
	drow-cplus-merge-20040113:1.11
	drow-cplus-merge-20031224:1.11
	drow-cplus-merge-20031220:1.11
	carlton_dictionary-20031215-merge:1.10
	drow-cplus-merge-20031214:1.10
	carlton-dictionary-20031111-merge:1.9
	gdb_6_0-2003-10-04-release:1.5.4.1
	kettenis_sparc-20030918-branch:1.9.0.4
	kettenis_sparc-20030918-branchpoint:1.9
	carlton_dictionary-20030917-merge:1.9
	ezannoni_pie-20030916-branchpoint:1.9
	ezannoni_pie-20030916-branch:1.9.0.2
	cagney_x86i386-20030821-branch:1.7.0.2
	cagney_x86i386-20030821-branchpoint:1.7
	carlton_dictionary-20030805-merge:1.7
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.4
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_convert-20030606-branch:1.3.0.10
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.8
	cagney_writestrings-20030508-branchpoint:1.3
	jimb-ppc64-linux-20030528-branch:1.3.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.4
	cagney_fileio-20030521-branchpoint:1.3
	kettenis_i386newframe-20030517-mergepoint:1.3
	jimb-ppc64-linux-20030509-branch:1.3.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.3
	kettenis_i386newframe-20030504-mergepoint:1.3
	carlton_dictionary-20030430-merge:1.3
	kettenis_i386newframe-20030419-branch:1.2.0.2
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.1
	kettenis_i386newframe-20030406-branch:1.1.0.24
	kettenis_i386newframe-20030406-branchpoint:1.1
	cagney_frameaddr-20030403-branchpoint:1.1
	cagney_frameaddr-20030403-branch:1.1.0.22
	cagney_framebase-20030330-mergepoint:1.1
	cagney_framebase-20030326-branch:1.1.0.20
	cagney_framebase-20030326-branchpoint:1.1
	cagney_lazyid-20030317-branch:1.1.0.18
	cagney_lazyid-20030317-branchpoint:1.1
	kettenis-i386newframe-20030316-mergepoint:1.1
	offbyone-20030313-branch:1.1.0.16
	offbyone-20030313-branchpoint:1.1
	kettenis-i386newframe-20030308-branch:1.1.0.14
	kettenis-i386newframe-20030308-branchpoint:1.1
	carlton_dictionary-20030305-merge:1.1
	cagney_offbyone-20030303-branch:1.1.0.12
	cagney_offbyone-20030303-branchpoint:1.1
	carlton_dictionary-20030207-merge:1.1
	interps-20030203-mergepoint:1.1
	interps-20030202-branch:1.1.0.10
	interps-20030202-branchpoint:1.1
	cagney-unwind-20030108-branch:1.1.0.8
	cagney-unwind-20030108-branchpoint:1.1
	carlton_dictionary-20021223-merge:1.1
	carlton_dictionary-20021115-merge:1.1
	kseitz_interps-20021105-merge:1.1
	kseitz_interps-20021103-merge:1.1
	drow-cplus-merge-20021020:1.1
	drow-cplus-merge-20021025:1.1
	carlton_dictionary-20021025-merge:1.1
	carlton_dictionary-20021011-merge:1.1
	drow-cplus-branch:1.1.0.6
	drow-cplus-branchpoint:1.1
	kseitz_interps-20020528-branch:1.1.0.4
	kseitz_interps-20020930-merge:1.1
	carlton_dictionary-20020927-merge:1.1
	carlton_dictionary-branch:1.1.0.2
	carlton_dictionary-20020920-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.63
date	2013.08.20.16.30.20;	author devans;	state Exp;
branches;
next	1.62;

1.62
date	2013.04.15.17.30.35;	author tromey;	state Exp;
branches;
next	1.61;

1.61
date	2013.01.01.06.32.40;	author brobecke;	state Exp;
branches;
next	1.60;

1.60
date	2012.11.12.17.30.05;	author tromey;	state Exp;
branches;
next	1.59;

1.59
date	2012.05.18.21.02.47;	author sergiodj;	state Exp;
branches;
next	1.58;

1.58
date	2012.05.10.19.50.07;	author tromey;	state Exp;
branches;
next	1.57;

1.57
date	2012.04.05.18.50.27;	author kseitz;	state Exp;
branches;
next	1.56;

1.56
date	2012.03.15.16.32.16;	author tromey;	state Exp;
branches;
next	1.55;

1.55
date	2012.03.15.15.43.11;	author tromey;	state Exp;
branches;
next	1.54;

1.54
date	2012.02.07.04.48.18;	author devans;	state Exp;
branches;
next	1.53;

1.53
date	2012.01.10.19.29.12;	author jkratoch;	state Exp;
branches;
next	1.52;

1.52
date	2012.01.06.03.34.46;	author sergiodj;	state Exp;
branches;
next	1.51;

1.51
date	2012.01.04.08.17.00;	author brobecke;	state Exp;
branches;
next	1.50;

1.50
date	2011.08.18.16.17.37;	author kseitz;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2011.02.26.02.07.07;	author msnyder;	state Exp;
branches;
next	1.48;

1.48
date	2011.02.18.19.10.46;	author jkratoch;	state Exp;
branches;
next	1.47;

1.47
date	2011.01.05.22.22.47;	author msnyder;	state Exp;
branches;
next	1.46;

1.46
date	2011.01.01.15.32.59;	author brobecke;	state Exp;
branches;
next	1.45;

1.45
date	2010.12.31.22.59.52;	author msnyder;	state Exp;
branches;
next	1.44;

1.44
date	2010.06.25.16.16.44;	author uweigand;	state Exp;
branches;
next	1.43;

1.43
date	2010.06.07.17.51.03;	author swagiaal;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.07.16.11.31;	author swagiaal;	state Exp;
branches;
next	1.41;

1.41
date	2010.06.02.15.31.30;	author swagiaal;	state Exp;
branches;
next	1.40;

1.40
date	2010.05.13.23.53.32;	author msnyder;	state Exp;
branches;
next	1.39;

1.39
date	2010.05.07.14.46.26;	author swagiaal;	state Exp;
branches;
next	1.38;

1.38
date	2010.05.07.01.12.12;	author msnyder;	state Exp;
branches;
next	1.37;

1.37
date	2010.03.10.18.20.06;	author tromey;	state Exp;
branches;
next	1.36;

1.36
date	2010.03.09.18.09.07;	author kseitz;	state Exp;
branches;
next	1.35;

1.35
date	2010.01.01.07.31.30;	author brobecke;	state Exp;
branches;
next	1.34;

1.34
date	2009.09.21.19.46.43;	author kseitz;	state Exp;
branches;
next	1.33;

1.33
date	2009.07.07.17.25.11;	author swagiaal;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.31;

1.31
date	2008.09.13.23.37.05;	author tromey;	state Exp;
branches;
next	1.30;

1.30
date	2008.08.21.18.14.38;	author drow;	state Exp;
branches;
next	1.29;

1.29
date	2008.05.19.15.50.09;	author uweigand;	state Exp;
branches;
next	1.28;

1.28
date	2008.05.07.12.43.54;	author drow;	state Exp;
branches;
next	1.27;

1.27
date	2008.03.28.19.52.23;	author aristovski;	state Exp;
branches;
next	1.26;

1.26
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.22.14.37.36;	author drow;	state Exp;
branches;
next	1.24;

1.24
date	2007.08.23.18.08.27;	author brobecke;	state Exp;
branches;
next	1.23;

1.23
date	2007.01.21.16.55.49;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.26.21.56.46;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.11.02.24.22;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2005.02.15.15.49.08;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.14.18.10.07;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.12.00.39.18;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.11.18.13.48;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.11.04.05.45;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.06.19.29.30;	author jjohnstn;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.02.20.44.52;	author carlton;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2003.12.16.19.27.11;	author carlton;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.05.04.25.09;	author chastain;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.14.16.32.12;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.11.19.49.17;	author carlton;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.30.16.23.29;	author carlton;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.30.16.21.16;	author carlton;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.12.15.33.45;	author carlton;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2003.06.08.18.27.13;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.23.23.45.23;	author carlton;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	2003.04.15.23.07.11;	author carlton;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2002.09.14.02.09.39;	author drow;	state Exp;
branches
	1.1.2.1
	1.1.4.1
	1.1.6.1;
next	;

1.50.2.1
date	2012.01.06.04.43.06;	author brobecke;	state Exp;
branches;
next	;

1.12.4.1
date	2004.09.16.17.00.59;	author drow;	state Exp;
branches;
next	;

1.5.4.1
date	2003.06.30.16.26.38;	author carlton;	state Exp;
branches;
next	;

1.3.8.1
date	2003.06.03.20.54.33;	author cagney;	state Exp;
branches;
next	;

1.2.2.1
date	2003.05.04.11.37.40;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	2002.10.09.23.08.10;	author carlton;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.10.11.21.56.48;	author carlton;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.10.15.00.20.32;	author carlton;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.10.15.23.59.21;	author carlton;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2002.10.25.23.49.53;	author carlton;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2002.11.21.01.04.21;	author carlton;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2002.11.22.01.16.13;	author carlton;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2002.11.23.00.42.54;	author carlton;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2002.11.24.18.47.18;	author carlton;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2002.12.19.01.03.06;	author carlton;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2003.01.07.01.28.23;	author carlton;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	2003.02.01.01.17.22;	author carlton;	state Exp;
branches;
next	1.1.2.13;

1.1.2.13
date	2003.02.12.23.37.09;	author carlton;	state Exp;
branches;
next	1.1.2.14;

1.1.2.14
date	2003.02.20.23.54.58;	author carlton;	state Exp;
branches;
next	1.1.2.15;

1.1.2.15
date	2003.02.22.01.33.13;	author carlton;	state Exp;
branches;
next	1.1.2.16;

1.1.2.16
date	2003.03.06.00.56.26;	author carlton;	state Exp;
branches;
next	1.1.2.17;

1.1.2.17
date	2003.03.11.01.01.10;	author carlton;	state Exp;
branches;
next	1.1.2.18;

1.1.2.18
date	2003.04.16.19.56.51;	author carlton;	state Exp;
branches;
next	1.1.2.19;

1.1.2.19
date	2003.04.18.18.10.48;	author carlton;	state Exp;
branches;
next	1.1.2.20;

1.1.2.20
date	2003.04.30.23.11.31;	author carlton;	state Exp;
branches;
next	1.1.2.21;

1.1.2.21
date	2003.06.27.21.49.51;	author carlton;	state Exp;
branches;
next	1.1.2.22;

1.1.2.22
date	2003.08.05.17.13.04;	author carlton;	state Exp;
branches;
next	1.1.2.23;

1.1.2.23
date	2003.09.20.00.32.31;	author carlton;	state Exp;
branches;
next	1.1.2.24;

1.1.2.24
date	2003.12.16.00.00.25;	author carlton;	state Exp;
branches;
next	;

1.1.4.1
date	2002.10.01.00.46.06;	author kseitz;	state Exp;
branches;
next	;

1.1.6.1
date	2002.10.22.19.59.36;	author carlton;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2002.11.22.17.15.55;	author carlton;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2003.12.14.20.27.10;	author drow;	state Exp;
branches;
next	1.1.6.4;

1.1.6.4
date	2003.12.20.18.16.48;	author drow;	state Exp;
branches;
next	1.1.6.5;

1.1.6.5
date	2004.01.04.22.42.41;	author drow;	state Exp;
branches;
next	1.1.6.6;

1.1.6.6
date	2004.01.13.18.18.03;	author drow;	state Exp;
branches;
next	1.1.6.7;

1.1.6.7
date	2004.01.13.18.30.52;	author drow;	state Exp;
branches;
next	1.1.6.8;

1.1.6.8
date	2004.02.09.19.43.35;	author drow;	state Exp;
branches;
next	;


desc
@@


1.63
log
@	* blockframe.c: Remove #include "psymtab.h".
	* cp-support.c: Ditto.
	* source.c: Ditto.
	* stack.c: Ditto.
@
text
@/* Helper routines for C++ support in GDB.
   Copyright (C) 2002-2013 Free Software Foundation, Inc.

   Contributed by MontaVista Software.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "cp-support.h"
#include "gdb_string.h"
#include "demangle.h"
#include "gdb_assert.h"
#include "gdbcmd.h"
#include "dictionary.h"
#include "objfiles.h"
#include "frame.h"
#include "symtab.h"
#include "block.h"
#include "complaints.h"
#include "gdbtypes.h"
#include "exceptions.h"
#include "expression.h"
#include "value.h"
#include "cp-abi.h"

#include "safe-ctype.h"

#define d_left(dc) (dc)->u.s_binary.left
#define d_right(dc) (dc)->u.s_binary.right

/* Functions related to demangled name parsing.  */

static unsigned int cp_find_first_component_aux (const char *name,
						 int permissive);

static void demangled_name_complaint (const char *name);

/* Functions/variables related to overload resolution.  */

static int sym_return_val_size = -1;
static int sym_return_val_index;
static struct symbol **sym_return_val;

static void overload_list_add_symbol (struct symbol *sym,
				      const char *oload_name);

static void make_symbol_overload_list_using (const char *func_name,
					     const char *namespace);

static void make_symbol_overload_list_qualified (const char *func_name);

/* The list of "maint cplus" commands.  */

struct cmd_list_element *maint_cplus_cmd_list = NULL;

/* The actual commands.  */

static void maint_cplus_command (char *arg, int from_tty);
static void first_component_command (char *arg, int from_tty);

/* A list of typedefs which should not be substituted by replace_typedefs.  */
static const char * const ignore_typedefs[] =
  {
    "std::istream", "std::iostream", "std::ostream", "std::string"
  };

static void
  replace_typedefs (struct demangle_parse_info *info,
		    struct demangle_component *ret_comp,
		    canonicalization_ftype *finder,
		    void *data);

/* A convenience function to copy STRING into OBSTACK, returning a pointer
   to the newly allocated string and saving the number of bytes saved in LEN.

   It does not copy the terminating '\0' byte!  */

static char *
copy_string_to_obstack (struct obstack *obstack, const char *string,
			long *len)
{
  *len = strlen (string);
  return obstack_copy (obstack, string, *len);
}

/* A cleanup wrapper for cp_demangled_name_parse_free.  */

static void
do_demangled_name_parse_free_cleanup (void *data)
{
  struct demangle_parse_info *info = (struct demangle_parse_info *) data;

  cp_demangled_name_parse_free (info);
}

/* Create a cleanup for C++ name parsing.  */

struct cleanup *
make_cleanup_cp_demangled_name_parse_free (struct demangle_parse_info *info)
{
  return make_cleanup (do_demangled_name_parse_free_cleanup, info);
}

/* Return 1 if STRING is clearly already in canonical form.  This
   function is conservative; things which it does not recognize are
   assumed to be non-canonical, and the parser will sort them out
   afterwards.  This speeds up the critical path for alphanumeric
   identifiers.  */

static int
cp_already_canonical (const char *string)
{
  /* Identifier start character [a-zA-Z_].  */
  if (!ISIDST (string[0]))
    return 0;

  /* These are the only two identifiers which canonicalize to other
     than themselves or an error: unsigned -> unsigned int and
     signed -> int.  */
  if (string[0] == 'u' && strcmp (&string[1], "nsigned") == 0)
    return 0;
  else if (string[0] == 's' && strcmp (&string[1], "igned") == 0)
    return 0;

  /* Identifier character [a-zA-Z0-9_].  */
  while (ISIDNUM (string[1]))
    string++;

  if (string[1] == '\0')
    return 1;
  else
    return 0;
}

/* Inspect the given RET_COMP for its type.  If it is a typedef,
   replace the node with the typedef's tree.

   Returns 1 if any typedef substitutions were made, 0 otherwise.  */

static int
inspect_type (struct demangle_parse_info *info,
	      struct demangle_component *ret_comp,
	      canonicalization_ftype *finder,
	      void *data)
{
  int i;
  char *name;
  struct symbol *sym;
  volatile struct gdb_exception except;

  /* Copy the symbol's name from RET_COMP and look it up
     in the symbol table.  */
  name = (char *) alloca (ret_comp->u.s_name.len + 1);
  memcpy (name, ret_comp->u.s_name.s, ret_comp->u.s_name.len);
  name[ret_comp->u.s_name.len] = '\0';

  /* Ignore any typedefs that should not be substituted.  */
  for (i = 0; i < ARRAY_SIZE (ignore_typedefs); ++i)
    {
      if (strcmp (name, ignore_typedefs[i]) == 0)
	return 0;
    }

  sym = NULL;
  TRY_CATCH (except, RETURN_MASK_ALL)
  {
    sym = lookup_symbol (name, 0, VAR_DOMAIN, 0);
  }

  if (except.reason >= 0 && sym != NULL)
    {
      struct type *otype = SYMBOL_TYPE (sym);

      if (finder != NULL)
	{
	  const char *new_name = (*finder) (otype, data);

	  if (new_name != NULL)
	    {
	      ret_comp->u.s_name.s = new_name;
	      ret_comp->u.s_name.len = strlen (new_name);
	      return 1;
	    }

	  return 0;
	}

      /* If the type is a typedef, replace it.  */
      if (TYPE_CODE (otype) == TYPE_CODE_TYPEDEF)
	{
	  long len;
	  int is_anon;
	  struct type *type;
	  struct demangle_parse_info *i;
	  struct ui_file *buf;

	  /* Get the real type of the typedef.  */
	  type = check_typedef (otype);

	  is_anon = (TYPE_TAG_NAME (type) == NULL
		     && (TYPE_CODE (type) == TYPE_CODE_ENUM
			 || TYPE_CODE (type) == TYPE_CODE_STRUCT
			 || TYPE_CODE (type) == TYPE_CODE_UNION));
	  if (is_anon)
	    {
	      struct type *last = otype;

	      /* Find the last typedef for the type.  */
	      while (TYPE_TARGET_TYPE (last) != NULL
		     && (TYPE_CODE (TYPE_TARGET_TYPE (last))
			 == TYPE_CODE_TYPEDEF))
		last = TYPE_TARGET_TYPE (last);

	      /* If there is only one typedef for this anonymous type,
		 do not substitute it.  */
	      if (type == otype)
		return 0;
	      else
		/* Use the last typedef seen as the type for this
		   anonymous type.  */
		type = last;
	    }

	  buf = mem_fileopen ();
	  TRY_CATCH (except, RETURN_MASK_ERROR)
	  {
	    type_print (type, "", buf, -1);
	  }

	  /* If type_print threw an exception, there is little point
	     in continuing, so just bow out gracefully.  */
	  if (except.reason < 0)
	    {
	      ui_file_delete (buf);
	      return 0;
	    }

	  name = ui_file_obsavestring (buf, &info->obstack, &len);
	  ui_file_delete (buf);

	  /* Turn the result into a new tree.  Note that this
	     tree will contain pointers into NAME, so NAME cannot
	     be free'd until all typedef conversion is done and
	     the final result is converted into a string.  */
	  i = cp_demangled_name_to_comp (name, NULL);
	  if (i != NULL)
	    {
	      /* Merge the two trees.  */
	      cp_merge_demangle_parse_infos (info, ret_comp, i);

	      /* Replace any newly introduced typedefs -- but not
		 if the type is anonymous (that would lead to infinite
		 looping).  */
	      if (!is_anon)
		replace_typedefs (info, ret_comp, finder, data);
	    }
	  else
	    {
	      /* This shouldn't happen unless the type printer has
		 output something that the name parser cannot grok.
		 Nonetheless, an ounce of prevention...

		 Canonicalize the name again, and store it in the
		 current node (RET_COMP).  */
	      char *canon = cp_canonicalize_string_no_typedefs (name);

	      if (canon != NULL)
		{
		  /* Copy the canonicalization into the obstack and
		     free CANON.  */
		  name = copy_string_to_obstack (&info->obstack, canon, &len);
		  xfree (canon);
		}

	      ret_comp->u.s_name.s = name;
	      ret_comp->u.s_name.len = len;
	    }

	  return 1;
	}
    }

  return 0;
}

/* Replace any typedefs appearing in the qualified name
   (DEMANGLE_COMPONENT_QUAL_NAME) represented in RET_COMP for the name parse
   given in INFO.  */

static void
replace_typedefs_qualified_name (struct demangle_parse_info *info,
				 struct demangle_component *ret_comp,
				 canonicalization_ftype *finder,
				 void *data)
{
  long len;
  char *name;
  struct ui_file *buf = mem_fileopen ();
  struct demangle_component *comp = ret_comp;

  /* Walk each node of the qualified name, reconstructing the name of
     this element.  With every node, check for any typedef substitutions.
     If a substitution has occurred, replace the qualified name node
     with a DEMANGLE_COMPONENT_NAME node representing the new, typedef-
     substituted name.  */
  while (comp->type == DEMANGLE_COMPONENT_QUAL_NAME)
    {
      if (d_left (comp)->type == DEMANGLE_COMPONENT_NAME)
	{
	  struct demangle_component new;

	  ui_file_write (buf, d_left (comp)->u.s_name.s,
			 d_left (comp)->u.s_name.len);
	  name = ui_file_obsavestring (buf, &info->obstack, &len);
	  new.type = DEMANGLE_COMPONENT_NAME;
	  new.u.s_name.s = name;
	  new.u.s_name.len = len;
	  if (inspect_type (info, &new, finder, data))
	    {
	      char *n, *s;
	      long slen;

	      /* A typedef was substituted in NEW.  Convert it to a
		 string and replace the top DEMANGLE_COMPONENT_QUAL_NAME
		 node.  */

	      ui_file_rewind (buf);
	      n = cp_comp_to_string (&new, 100);
	      if (n == NULL)
		{
		  /* If something went astray, abort typedef substitutions.  */
		  ui_file_delete (buf);
		  return;
		}

	      s = copy_string_to_obstack (&info->obstack, n, &slen);
	      xfree (n);

	      d_left (ret_comp)->type = DEMANGLE_COMPONENT_NAME;
	      d_left (ret_comp)->u.s_name.s = s;
	      d_left (ret_comp)->u.s_name.len = slen;
	      d_right (ret_comp) = d_right (comp);
	      comp = ret_comp;
	      continue;
	    }
	}
      else
	{
	  /* The current node is not a name, so simply replace any
	     typedefs in it.  Then print it to the stream to continue
	     checking for more typedefs in the tree.  */
	  replace_typedefs (info, d_left (comp), finder, data);
	  name = cp_comp_to_string (d_left (comp), 100);
	  if (name == NULL)
	    {
	      /* If something went astray, abort typedef substitutions.  */
	      ui_file_delete (buf);
	      return;
	    }
	  fputs_unfiltered (name, buf);
	  xfree (name);
	}

      ui_file_write (buf, "::", 2);
      comp = d_right (comp);
    }

  /* If the next component is DEMANGLE_COMPONENT_NAME, save the qualified
     name assembled above and append the name given by COMP.  Then use this
     reassembled name to check for a typedef.  */

  if (comp->type == DEMANGLE_COMPONENT_NAME)
    {
      ui_file_write (buf, comp->u.s_name.s, comp->u.s_name.len);
      name = ui_file_obsavestring (buf, &info->obstack, &len);

      /* Replace the top (DEMANGLE_COMPONENT_QUAL_NAME) node
	 with a DEMANGLE_COMPONENT_NAME node containing the whole
	 name.  */
      ret_comp->type = DEMANGLE_COMPONENT_NAME;
      ret_comp->u.s_name.s = name;
      ret_comp->u.s_name.len = len;
      inspect_type (info, ret_comp, finder, data);
    }
  else
    replace_typedefs (info, comp, finder, data);

  ui_file_delete (buf);
}


/* A function to check const and volatile qualifiers for argument types.

   "Parameter declarations that differ only in the presence
   or absence of `const' and/or `volatile' are equivalent."
   C++ Standard N3290, clause 13.1.3 #4.  */

static void
check_cv_qualifiers (struct demangle_component *ret_comp)
{
  while (d_left (ret_comp) != NULL
	 && (d_left (ret_comp)->type == DEMANGLE_COMPONENT_CONST
	     || d_left (ret_comp)->type == DEMANGLE_COMPONENT_VOLATILE))
    {
      d_left (ret_comp) = d_left (d_left (ret_comp));
    }
}

/* Walk the parse tree given by RET_COMP, replacing any typedefs with
   their basic types.  */

static void
replace_typedefs (struct demangle_parse_info *info,
		  struct demangle_component *ret_comp,
		  canonicalization_ftype *finder,
		  void *data)
{
  if (ret_comp)
    {
      if (finder != NULL
	  && (ret_comp->type == DEMANGLE_COMPONENT_NAME
	      || ret_comp->type == DEMANGLE_COMPONENT_QUAL_NAME
	      || ret_comp->type == DEMANGLE_COMPONENT_TEMPLATE
	      || ret_comp->type == DEMANGLE_COMPONENT_BUILTIN_TYPE))
	{
	  char *local_name = cp_comp_to_string (ret_comp, 10);

	  if (local_name != NULL)
	    {
	      struct symbol *sym;
	      volatile struct gdb_exception except;

	      sym = NULL;
	      TRY_CATCH (except, RETURN_MASK_ALL)
		{
		  sym = lookup_symbol (local_name, 0, VAR_DOMAIN, 0);
		}
	      xfree (local_name);

	      if (except.reason >= 0 && sym != NULL)
		{
		  struct type *otype = SYMBOL_TYPE (sym);
		  const char *new_name = (*finder) (otype, data);

		  if (new_name != NULL)
		    {
		      ret_comp->type = DEMANGLE_COMPONENT_NAME;
		      ret_comp->u.s_name.s = new_name;
		      ret_comp->u.s_name.len = strlen (new_name);
		      return;
		    }
		}
	    }
	}

      switch (ret_comp->type)
	{
	case DEMANGLE_COMPONENT_ARGLIST:
	  check_cv_qualifiers (ret_comp);
	  /* Fall through */

	case DEMANGLE_COMPONENT_FUNCTION_TYPE:
	case DEMANGLE_COMPONENT_TEMPLATE:
	case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:
	case DEMANGLE_COMPONENT_TYPED_NAME:
	  replace_typedefs (info, d_left (ret_comp), finder, data);
	  replace_typedefs (info, d_right (ret_comp), finder, data);
	  break;

	case DEMANGLE_COMPONENT_NAME:
	  inspect_type (info, ret_comp, finder, data);
	  break;

	case DEMANGLE_COMPONENT_QUAL_NAME:
	  replace_typedefs_qualified_name (info, ret_comp, finder, data);
	  break;

	case DEMANGLE_COMPONENT_LOCAL_NAME:
	case DEMANGLE_COMPONENT_CTOR:
	case DEMANGLE_COMPONENT_ARRAY_TYPE:
	case DEMANGLE_COMPONENT_PTRMEM_TYPE:
	  replace_typedefs (info, d_right (ret_comp), finder, data);
	  break;

	case DEMANGLE_COMPONENT_CONST:
	case DEMANGLE_COMPONENT_RESTRICT:
	case DEMANGLE_COMPONENT_VOLATILE:
	case DEMANGLE_COMPONENT_VOLATILE_THIS:
	case DEMANGLE_COMPONENT_CONST_THIS:
	case DEMANGLE_COMPONENT_RESTRICT_THIS:
	case DEMANGLE_COMPONENT_POINTER:
	case DEMANGLE_COMPONENT_REFERENCE:
	  replace_typedefs (info, d_left (ret_comp), finder, data);
	  break;

	default:
	  break;
	}
    }
}

/* Parse STRING and convert it to canonical form, resolving any typedefs.
   If parsing fails, or if STRING is already canonical, return NULL.
   Otherwise return the canonical form.  The return value is allocated via
   xmalloc.  If FINDER is not NULL, then type components are passed to
   FINDER to be looked up.  DATA is passed verbatim to FINDER.  */

char *
cp_canonicalize_string_full (const char *string,
			     canonicalization_ftype *finder,
			     void *data)
{
  char *ret;
  unsigned int estimated_len;
  struct demangle_parse_info *info;

  ret = NULL;
  estimated_len = strlen (string) * 2;
  info = cp_demangled_name_to_comp (string, NULL);
  if (info != NULL)
    {
      /* Replace all the typedefs in the tree.  */
      replace_typedefs (info, info->tree, finder, data);

      /* Convert the tree back into a string.  */
      ret = cp_comp_to_string (info->tree, estimated_len);
      gdb_assert (ret != NULL);

      /* Free the parse information.  */
      cp_demangled_name_parse_free (info);

      /* Finally, compare the original string with the computed
	 name, returning NULL if they are the same.  */
      if (strcmp (string, ret) == 0)
	{
	  xfree (ret);
	  return NULL;
	}
    }

  return ret;
}

/* Like cp_canonicalize_string_full, but always passes NULL for
   FINDER.  */

char *
cp_canonicalize_string_no_typedefs (const char *string)
{
  return cp_canonicalize_string_full (string, NULL, NULL);
}

/* Parse STRING and convert it to canonical form.  If parsing fails,
   or if STRING is already canonical, return NULL.  Otherwise return
   the canonical form.  The return value is allocated via xmalloc.  */

char *
cp_canonicalize_string (const char *string)
{
  struct demangle_parse_info *info;
  unsigned int estimated_len;
  char *ret;

  if (cp_already_canonical (string))
    return NULL;

  info = cp_demangled_name_to_comp (string, NULL);
  if (info == NULL)
    return NULL;

  estimated_len = strlen (string) * 2;
  ret = cp_comp_to_string (info->tree, estimated_len);
  cp_demangled_name_parse_free (info);

  if (ret == NULL)
    {
      warning (_("internal error: string \"%s\" failed to be canonicalized"),
	       string);
      return NULL;
    }

  if (strcmp (string, ret) == 0)
    {
      xfree (ret);
      return NULL;
    }

  return ret;
}

/* Convert a mangled name to a demangle_component tree.  *MEMORY is
   set to the block of used memory that should be freed when finished
   with the tree.  DEMANGLED_P is set to the char * that should be
   freed when finished with the tree, or NULL if none was needed.
   OPTIONS will be passed to the demangler.  */

static struct demangle_parse_info *
mangled_name_to_comp (const char *mangled_name, int options,
		      void **memory, char **demangled_p)
{
  char *demangled_name;
  struct demangle_parse_info *info;

  /* If it looks like a v3 mangled name, then try to go directly
     to trees.  */
  if (mangled_name[0] == '_' && mangled_name[1] == 'Z')
    {
      struct demangle_component *ret;

      ret = cplus_demangle_v3_components (mangled_name,
					  options, memory);
      if (ret)
	{
	  info = cp_new_demangle_parse_info ();
	  info->tree = ret;
	  *demangled_p = NULL;
	  return info;
	}
    }

  /* If it doesn't, or if that failed, then try to demangle the
     name.  */
  demangled_name = gdb_demangle (mangled_name, options);
  if (demangled_name == NULL)
   return NULL;
  
  /* If we could demangle the name, parse it to build the component
     tree.  */
  info = cp_demangled_name_to_comp (demangled_name, NULL);

  if (info == NULL)
    {
      xfree (demangled_name);
      return NULL;
    }

  *demangled_p = demangled_name;
  return info;
}

/* Return the name of the class containing method PHYSNAME.  */

char *
cp_class_name_from_physname (const char *physname)
{
  void *storage = NULL;
  char *demangled_name = NULL, *ret;
  struct demangle_component *ret_comp, *prev_comp, *cur_comp;
  struct demangle_parse_info *info;
  int done;

  info = mangled_name_to_comp (physname, DMGL_ANSI,
			       &storage, &demangled_name);
  if (info == NULL)
    return NULL;

  done = 0;
  ret_comp = info->tree;

  /* First strip off any qualifiers, if we have a function or
     method.  */
  while (!done)
    switch (ret_comp->type)
      {
      case DEMANGLE_COMPONENT_CONST:
      case DEMANGLE_COMPONENT_RESTRICT:
      case DEMANGLE_COMPONENT_VOLATILE:
      case DEMANGLE_COMPONENT_CONST_THIS:
      case DEMANGLE_COMPONENT_RESTRICT_THIS:
      case DEMANGLE_COMPONENT_VOLATILE_THIS:
      case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
        ret_comp = d_left (ret_comp);
        break;
      default:
	done = 1;
	break;
      }

  /* If what we have now is a function, discard the argument list.  */
  if (ret_comp->type == DEMANGLE_COMPONENT_TYPED_NAME)
    ret_comp = d_left (ret_comp);

  /* If what we have now is a template, strip off the template
     arguments.  The left subtree may be a qualified name.  */
  if (ret_comp->type == DEMANGLE_COMPONENT_TEMPLATE)
    ret_comp = d_left (ret_comp);

  /* What we have now should be a name, possibly qualified.
     Additional qualifiers could live in the left subtree or the right
     subtree.  Find the last piece.  */
  done = 0;
  prev_comp = NULL;
  cur_comp = ret_comp;
  while (!done)
    switch (cur_comp->type)
      {
      case DEMANGLE_COMPONENT_QUAL_NAME:
      case DEMANGLE_COMPONENT_LOCAL_NAME:
	prev_comp = cur_comp;
        cur_comp = d_right (cur_comp);
        break;
      case DEMANGLE_COMPONENT_TEMPLATE:
      case DEMANGLE_COMPONENT_NAME:
      case DEMANGLE_COMPONENT_CTOR:
      case DEMANGLE_COMPONENT_DTOR:
      case DEMANGLE_COMPONENT_OPERATOR:
      case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
	done = 1;
	break;
      default:
	done = 1;
	cur_comp = NULL;
	break;
      }

  ret = NULL;
  if (cur_comp != NULL && prev_comp != NULL)
    {
      /* We want to discard the rightmost child of PREV_COMP.  */
      *prev_comp = *d_left (prev_comp);
      /* The ten is completely arbitrary; we don't have a good
	 estimate.  */
      ret = cp_comp_to_string (ret_comp, 10);
    }

  xfree (storage);
  xfree (demangled_name);
  cp_demangled_name_parse_free (info);
  return ret;
}

/* Return the child of COMP which is the basename of a method,
   variable, et cetera.  All scope qualifiers are discarded, but
   template arguments will be included.  The component tree may be
   modified.  */

static struct demangle_component *
unqualified_name_from_comp (struct demangle_component *comp)
{
  struct demangle_component *ret_comp = comp, *last_template;
  int done;

  done = 0;
  last_template = NULL;
  while (!done)
    switch (ret_comp->type)
      {
      case DEMANGLE_COMPONENT_QUAL_NAME:
      case DEMANGLE_COMPONENT_LOCAL_NAME:
        ret_comp = d_right (ret_comp);
        break;
      case DEMANGLE_COMPONENT_TYPED_NAME:
        ret_comp = d_left (ret_comp);
        break;
      case DEMANGLE_COMPONENT_TEMPLATE:
	gdb_assert (last_template == NULL);
	last_template = ret_comp;
	ret_comp = d_left (ret_comp);
	break;
      case DEMANGLE_COMPONENT_CONST:
      case DEMANGLE_COMPONENT_RESTRICT:
      case DEMANGLE_COMPONENT_VOLATILE:
      case DEMANGLE_COMPONENT_CONST_THIS:
      case DEMANGLE_COMPONENT_RESTRICT_THIS:
      case DEMANGLE_COMPONENT_VOLATILE_THIS:
      case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
        ret_comp = d_left (ret_comp);
        break;
      case DEMANGLE_COMPONENT_NAME:
      case DEMANGLE_COMPONENT_CTOR:
      case DEMANGLE_COMPONENT_DTOR:
      case DEMANGLE_COMPONENT_OPERATOR:
      case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
	done = 1;
	break;
      default:
	return NULL;
	break;
      }

  if (last_template)
    {
      d_left (last_template) = ret_comp;
      return last_template;
    }

  return ret_comp;
}

/* Return the name of the method whose linkage name is PHYSNAME.  */

char *
method_name_from_physname (const char *physname)
{
  void *storage = NULL;
  char *demangled_name = NULL, *ret;
  struct demangle_component *ret_comp;
  struct demangle_parse_info *info;

  info = mangled_name_to_comp (physname, DMGL_ANSI,
			       &storage, &demangled_name);
  if (info == NULL)
    return NULL;

  ret_comp = unqualified_name_from_comp (info->tree);

  ret = NULL;
  if (ret_comp != NULL)
    /* The ten is completely arbitrary; we don't have a good
       estimate.  */
    ret = cp_comp_to_string (ret_comp, 10);

  xfree (storage);
  xfree (demangled_name);
  cp_demangled_name_parse_free (info);
  return ret;
}

/* If FULL_NAME is the demangled name of a C++ function (including an
   arg list, possibly including namespace/class qualifications),
   return a new string containing only the function name (without the
   arg list/class qualifications).  Otherwise, return NULL.  The
   caller is responsible for freeing the memory in question.  */

char *
cp_func_name (const char *full_name)
{
  char *ret;
  struct demangle_component *ret_comp;
  struct demangle_parse_info *info;

  info = cp_demangled_name_to_comp (full_name, NULL);
  if (!info)
    return NULL;

  ret_comp = unqualified_name_from_comp (info->tree);

  ret = NULL;
  if (ret_comp != NULL)
    ret = cp_comp_to_string (ret_comp, 10);

  cp_demangled_name_parse_free (info);
  return ret;
}

/* DEMANGLED_NAME is the name of a function, including parameters and
   (optionally) a return type.  Return the name of the function without
   parameters or return type, or NULL if we can not parse the name.  */

char *
cp_remove_params (const char *demangled_name)
{
  int done = 0;
  struct demangle_component *ret_comp;
  struct demangle_parse_info *info;
  char *ret = NULL;

  if (demangled_name == NULL)
    return NULL;

  info = cp_demangled_name_to_comp (demangled_name, NULL);
  if (info == NULL)
    return NULL;

  /* First strip off any qualifiers, if we have a function or method.  */
  ret_comp = info->tree;
  while (!done)
    switch (ret_comp->type)
      {
      case DEMANGLE_COMPONENT_CONST:
      case DEMANGLE_COMPONENT_RESTRICT:
      case DEMANGLE_COMPONENT_VOLATILE:
      case DEMANGLE_COMPONENT_CONST_THIS:
      case DEMANGLE_COMPONENT_RESTRICT_THIS:
      case DEMANGLE_COMPONENT_VOLATILE_THIS:
      case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
        ret_comp = d_left (ret_comp);
        break;
      default:
	done = 1;
	break;
      }

  /* What we have now should be a function.  Return its name.  */
  if (ret_comp->type == DEMANGLE_COMPONENT_TYPED_NAME)
    ret = cp_comp_to_string (d_left (ret_comp), 10);

  cp_demangled_name_parse_free (info);
  return ret;
}

/* Here are some random pieces of trivia to keep in mind while trying
   to take apart demangled names:

   - Names can contain function arguments or templates, so the process
     has to be, to some extent recursive: maybe keep track of your
     depth based on encountering <> and ().

   - Parentheses don't just have to happen at the end of a name: they
     can occur even if the name in question isn't a function, because
     a template argument might be a type that's a function.

   - Conversely, even if you're trying to deal with a function, its
     demangled name might not end with ')': it could be a const or
     volatile class method, in which case it ends with "const" or
     "volatile".

   - Parentheses are also used in anonymous namespaces: a variable
     'foo' in an anonymous namespace gets demangled as "(anonymous
     namespace)::foo".

   - And operator names can contain parentheses or angle brackets.  */

/* FIXME: carlton/2003-03-13: We have several functions here with
   overlapping functionality; can we combine them?  Also, do they
   handle all the above considerations correctly?  */


/* This returns the length of first component of NAME, which should be
   the demangled name of a C++ variable/function/method/etc.
   Specifically, it returns the index of the first colon forming the
   boundary of the first component: so, given 'A::foo' or 'A::B::foo'
   it returns the 1, and given 'foo', it returns 0.  */

/* The character in NAME indexed by the return value is guaranteed to
   always be either ':' or '\0'.  */

/* NOTE: carlton/2003-03-13: This function is currently only intended
   for internal use: it's probably not entirely safe when called on
   user-generated input, because some of the 'index += 2' lines in
   cp_find_first_component_aux might go past the end of malformed
   input.  */

unsigned int
cp_find_first_component (const char *name)
{
  return cp_find_first_component_aux (name, 0);
}

/* Helper function for cp_find_first_component.  Like that function,
   it returns the length of the first component of NAME, but to make
   the recursion easier, it also stops if it reaches an unexpected ')'
   or '>' if the value of PERMISSIVE is nonzero.  */

/* Let's optimize away calls to strlen("operator").  */

#define LENGTH_OF_OPERATOR 8

static unsigned int
cp_find_first_component_aux (const char *name, int permissive)
{
  unsigned int index = 0;
  /* Operator names can show up in unexpected places.  Since these can
     contain parentheses or angle brackets, they can screw up the
     recursion.  But not every string 'operator' is part of an
     operater name: e.g. you could have a variable 'cooperator'.  So
     this variable tells us whether or not we should treat the string
     'operator' as starting an operator.  */
  int operator_possible = 1;

  for (;; ++index)
    {
      switch (name[index])
	{
	case '<':
	  /* Template; eat it up.  The calls to cp_first_component
	     should only return (I hope!) when they reach the '>'
	     terminating the component or a '::' between two
	     components.  (Hence the '+ 2'.)  */
	  index += 1;
	  for (index += cp_find_first_component_aux (name + index, 1);
	       name[index] != '>';
	       index += cp_find_first_component_aux (name + index, 1))
	    {
	      if (name[index] != ':')
		{
		  demangled_name_complaint (name);
		  return strlen (name);
		}
	      index += 2;
	    }
	  operator_possible = 1;
	  break;
	case '(':
	  /* Similar comment as to '<'.  */
	  index += 1;
	  for (index += cp_find_first_component_aux (name + index, 1);
	       name[index] != ')';
	       index += cp_find_first_component_aux (name + index, 1))
	    {
	      if (name[index] != ':')
		{
		  demangled_name_complaint (name);
		  return strlen (name);
		}
	      index += 2;
	    }
	  operator_possible = 1;
	  break;
	case '>':
	case ')':
	  if (permissive)
	    return index;
	  else
	    {
	      demangled_name_complaint (name);
	      return strlen (name);
	    }
	case '\0':
	case ':':
	  return index;
	case 'o':
	  /* Operator names can screw up the recursion.  */
	  if (operator_possible
	      && strncmp (name + index, "operator",
			  LENGTH_OF_OPERATOR) == 0)
	    {
	      index += LENGTH_OF_OPERATOR;
	      while (ISSPACE(name[index]))
		++index;
	      switch (name[index])
		{
		  /* Skip over one less than the appropriate number of
		     characters: the for loop will skip over the last
		     one.  */
		case '<':
		  if (name[index + 1] == '<')
		    index += 1;
		  else
		    index += 0;
		  break;
		case '>':
		case '-':
		  if (name[index + 1] == '>')
		    index += 1;
		  else
		    index += 0;
		  break;
		case '(':
		  index += 1;
		  break;
		default:
		  index += 0;
		  break;
		}
	    }
	  operator_possible = 0;
	  break;
	case ' ':
	case ',':
	case '.':
	case '&':
	case '*':
	  /* NOTE: carlton/2003-04-18: I'm not sure what the precise
	     set of relevant characters are here: it's necessary to
	     include any character that can show up before 'operator'
	     in a demangled name, and it's safe to include any
	     character that can't be part of an identifier's name.  */
	  operator_possible = 1;
	  break;
	default:
	  operator_possible = 0;
	  break;
	}
    }
}

/* Complain about a demangled name that we don't know how to parse.
   NAME is the demangled name in question.  */

static void
demangled_name_complaint (const char *name)
{
  complaint (&symfile_complaints,
	     "unexpected demangled name '%s'", name);
}

/* If NAME is the fully-qualified name of a C++
   function/variable/method/etc., this returns the length of its
   entire prefix: all of the namespaces and classes that make up its
   name.  Given 'A::foo', it returns 1, given 'A::B::foo', it returns
   4, given 'foo', it returns 0.  */

unsigned int
cp_entire_prefix_len (const char *name)
{
  unsigned int current_len = cp_find_first_component (name);
  unsigned int previous_len = 0;

  while (name[current_len] != '\0')
    {
      gdb_assert (name[current_len] == ':');
      previous_len = current_len;
      /* Skip the '::'.  */
      current_len += 2;
      current_len += cp_find_first_component (name + current_len);
    }

  return previous_len;
}

/* Overload resolution functions.  */

/* Test to see if SYM is a symbol that we haven't seen corresponding
   to a function named OLOAD_NAME.  If so, add it to the current
   completion list.  */

static void
overload_list_add_symbol (struct symbol *sym,
			  const char *oload_name)
{
  int newsize;
  int i;
  char *sym_name;

  /* If there is no type information, we can't do anything, so
     skip.  */
  if (SYMBOL_TYPE (sym) == NULL)
    return;

  /* skip any symbols that we've already considered.  */
  for (i = 0; i < sym_return_val_index; ++i)
    if (strcmp (SYMBOL_LINKAGE_NAME (sym),
		SYMBOL_LINKAGE_NAME (sym_return_val[i])) == 0)
      return;

  /* Get the demangled name without parameters */
  sym_name = cp_remove_params (SYMBOL_NATURAL_NAME (sym));
  if (!sym_name)
    return;

  /* skip symbols that cannot match */
  if (strcmp (sym_name, oload_name) != 0)
    {
      xfree (sym_name);
      return;
    }

  xfree (sym_name);

  /* We have a match for an overload instance, so add SYM to the
     current list of overload instances */
  if (sym_return_val_index + 3 > sym_return_val_size)
    {
      newsize = (sym_return_val_size *= 2) * sizeof (struct symbol *);
      sym_return_val = (struct symbol **)
	xrealloc ((char *) sym_return_val, newsize);
    }
  sym_return_val[sym_return_val_index++] = sym;
  sym_return_val[sym_return_val_index] = NULL;
}

/* Return a null-terminated list of pointers to function symbols that
   are named FUNC_NAME and are visible within NAMESPACE.  */

struct symbol **
make_symbol_overload_list (const char *func_name,
			   const char *namespace)
{
  struct cleanup *old_cleanups;
  const char *name;

  sym_return_val_size = 100;
  sym_return_val_index = 0;
  sym_return_val = xmalloc ((sym_return_val_size + 1) *
			    sizeof (struct symbol *));
  sym_return_val[0] = NULL;

  old_cleanups = make_cleanup (xfree, sym_return_val);

  make_symbol_overload_list_using (func_name, namespace);

  if (namespace[0] == '\0')
    name = func_name;
  else
    {
      char *concatenated_name
	= alloca (strlen (namespace) + 2 + strlen (func_name) + 1);
      strcpy (concatenated_name, namespace);
      strcat (concatenated_name, "::");
      strcat (concatenated_name, func_name);
      name = concatenated_name;
    }

  make_symbol_overload_list_qualified (name);

  discard_cleanups (old_cleanups);

  return sym_return_val;
}

/* Add all symbols with a name matching NAME in BLOCK to the overload
   list.  */

static void
make_symbol_overload_list_block (const char *name,
                                 const struct block *block)
{
  struct block_iterator iter;
  struct symbol *sym;

  for (sym = block_iter_name_first (block, name, &iter);
       sym != NULL;
       sym = block_iter_name_next (name, &iter))
    overload_list_add_symbol (sym, name);
}

/* Adds the function FUNC_NAME from NAMESPACE to the overload set.  */

static void
make_symbol_overload_list_namespace (const char *func_name,
                                     const char *namespace)
{
  const char *name;
  const struct block *block = NULL;

  if (namespace[0] == '\0')
    name = func_name;
  else
    {
      char *concatenated_name
	= alloca (strlen (namespace) + 2 + strlen (func_name) + 1);

      strcpy (concatenated_name, namespace);
      strcat (concatenated_name, "::");
      strcat (concatenated_name, func_name);
      name = concatenated_name;
    }

  /* Look in the static block.  */
  block = block_static_block (get_selected_block (0));
  if (block)
    make_symbol_overload_list_block (name, block);

  /* Look in the global block.  */
  block = block_global_block (block);
  if (block)
    make_symbol_overload_list_block (name, block);

}

/* Search the namespace of the given type and namespace of and public
   base types.  */

static void
make_symbol_overload_list_adl_namespace (struct type *type,
                                         const char *func_name)
{
  char *namespace;
  const char *type_name;
  int i, prefix_len;

  while (TYPE_CODE (type) == TYPE_CODE_PTR
	 || TYPE_CODE (type) == TYPE_CODE_REF
         || TYPE_CODE (type) == TYPE_CODE_ARRAY
         || TYPE_CODE (type) == TYPE_CODE_TYPEDEF)
    {
      if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)
	type = check_typedef(type);
      else
	type = TYPE_TARGET_TYPE (type);
    }

  type_name = TYPE_NAME (type);

  if (type_name == NULL)
    return;

  prefix_len = cp_entire_prefix_len (type_name);

  if (prefix_len != 0)
    {
      namespace = alloca (prefix_len + 1);
      strncpy (namespace, type_name, prefix_len);
      namespace[prefix_len] = '\0';

      make_symbol_overload_list_namespace (func_name, namespace);
    }

  /* Check public base type */
  if (TYPE_CODE (type) == TYPE_CODE_CLASS)
    for (i = 0; i < TYPE_N_BASECLASSES (type); i++)
      {
	if (BASETYPE_VIA_PUBLIC (type, i))
	  make_symbol_overload_list_adl_namespace (TYPE_BASECLASS (type,
								   i),
						   func_name);
      }
}

/* Adds the overload list overload candidates for FUNC_NAME found
   through argument dependent lookup.  */

struct symbol **
make_symbol_overload_list_adl (struct type **arg_types, int nargs,
                               const char *func_name)
{
  int i;

  gdb_assert (sym_return_val_size != -1);

  for (i = 1; i <= nargs; i++)
    make_symbol_overload_list_adl_namespace (arg_types[i - 1],
					     func_name);

  return sym_return_val;
}

/* Used for cleanups to reset the "searched" flag in case of an
   error.  */

static void
reset_directive_searched (void *data)
{
  struct using_direct *direct = data;
  direct->searched = 0;
}

/* This applies the using directives to add namespaces to search in,
   and then searches for overloads in all of those namespaces.  It
   adds the symbols found to sym_return_val.  Arguments are as in
   make_symbol_overload_list.  */

static void
make_symbol_overload_list_using (const char *func_name,
				 const char *namespace)
{
  struct using_direct *current;
  const struct block *block;

  /* First, go through the using directives.  If any of them apply,
     look in the appropriate namespaces for new functions to match
     on.  */

  for (block = get_selected_block (0);
       block != NULL;
       block = BLOCK_SUPERBLOCK (block))
    for (current = block_using (block);
	current != NULL;
	current = current->next)
      {
	/* Prevent recursive calls.  */
	if (current->searched)
	  continue;

        /* If this is a namespace alias or imported declaration ignore
	   it.  */
        if (current->alias != NULL || current->declaration != NULL)
          continue;

        if (strcmp (namespace, current->import_dest) == 0)
	  {
	    /* Mark this import as searched so that the recursive call
	       does not search it again.  */
	    struct cleanup *old_chain;
	    current->searched = 1;
	    old_chain = make_cleanup (reset_directive_searched,
				      current);

	    make_symbol_overload_list_using (func_name,
					     current->import_src);

	    current->searched = 0;
	    discard_cleanups (old_chain);
	  }
      }

  /* Now, add names for this namespace.  */
  make_symbol_overload_list_namespace (func_name, namespace);
}

/* This does the bulk of the work of finding overloaded symbols.
   FUNC_NAME is the name of the overloaded function we're looking for
   (possibly including namespace info).  */

static void
make_symbol_overload_list_qualified (const char *func_name)
{
  struct symtab *s;
  struct objfile *objfile;
  const struct block *b, *surrounding_static_block = 0;

  /* Look through the partial symtabs for all symbols which begin by
     matching FUNC_NAME.  Make sure we read that symbol table in.  */

  ALL_OBJFILES (objfile)
  {
    if (objfile->sf)
      objfile->sf->qf->expand_symtabs_for_function (objfile, func_name);
  }

  /* Search upwards from currently selected frame (so that we can
     complete on local vars.  */

  for (b = get_selected_block (0); b != NULL; b = BLOCK_SUPERBLOCK (b))
    make_symbol_overload_list_block (func_name, b);

  surrounding_static_block = block_static_block (get_selected_block (0));

  /* Go through the symtabs and check the externs and statics for
     symbols which match.  */

  ALL_PRIMARY_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
    make_symbol_overload_list_block (func_name, b);
  }

  ALL_PRIMARY_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
    /* Don't do this block twice.  */
    if (b == surrounding_static_block)
      continue;
    make_symbol_overload_list_block (func_name, b);
  }
}

/* Lookup the rtti type for a class name.  */

struct type *
cp_lookup_rtti_type (const char *name, struct block *block)
{
  struct symbol * rtti_sym;
  struct type * rtti_type;

  rtti_sym = lookup_symbol (name, block, STRUCT_DOMAIN, NULL);

  if (rtti_sym == NULL)
    {
      warning (_("RTTI symbol not found for class '%s'"), name);
      return NULL;
    }

  if (SYMBOL_CLASS (rtti_sym) != LOC_TYPEDEF)
    {
      warning (_("RTTI symbol for class '%s' is not a type"), name);
      return NULL;
    }

  rtti_type = SYMBOL_TYPE (rtti_sym);

  switch (TYPE_CODE (rtti_type))
    {
    case TYPE_CODE_CLASS:
      break;
    case TYPE_CODE_NAMESPACE:
      /* chastain/2003-11-26: the symbol tables often contain fake
	 symbols for namespaces with the same name as the struct.
	 This warning is an indication of a bug in the lookup order
	 or a bug in the way that the symbol tables are populated.  */
      warning (_("RTTI symbol for class '%s' is a namespace"), name);
      return NULL;
    default:
      warning (_("RTTI symbol for class '%s' has bad type"), name);
      return NULL;
    }

  return rtti_type;
}

/* A wrapper for bfd_demangle.  */

char *
gdb_demangle (const char *name, int options)
{
  return bfd_demangle (NULL, name, options);
}

/* Don't allow just "maintenance cplus".  */

static  void
maint_cplus_command (char *arg, int from_tty)
{
  printf_unfiltered (_("\"maintenance cplus\" must be followed "
		       "by the name of a command.\n"));
  help_list (maint_cplus_cmd_list,
	     "maintenance cplus ",
	     -1, gdb_stdout);
}

/* This is a front end for cp_find_first_component, for unit testing.
   Be careful when using it: see the NOTE above
   cp_find_first_component.  */

static void
first_component_command (char *arg, int from_tty)
{
  int len;  
  char *prefix; 

  if (!arg)
    return;

  len = cp_find_first_component (arg);
  prefix = alloca (len + 1);

  memcpy (prefix, arg, len);
  prefix[len] = '\0';

  printf_unfiltered ("%s\n", prefix);
}

extern initialize_file_ftype _initialize_cp_support; /* -Wmissing-prototypes */


/* Implement "info vtbl".  */

static void
info_vtbl_command (char *arg, int from_tty)
{
  struct value *value;

  value = parse_and_eval (arg);
  cplus_print_vtable (value);
}

void
_initialize_cp_support (void)
{
  add_prefix_cmd ("cplus", class_maintenance,
		  maint_cplus_command,
		  _("C++ maintenance commands."),
		  &maint_cplus_cmd_list,
		  "maintenance cplus ",
		  0, &maintenancelist);
  add_alias_cmd ("cp", "cplus",
		 class_maintenance, 1,
		 &maintenancelist);

  add_cmd ("first_component",
	   class_maintenance,
	   first_component_command,
	   _("Print the first class/namespace component of NAME."),
	   &maint_cplus_cmd_list);

  add_info ("vtbl", info_vtbl_command,
	    _("Show the virtual function table for a C++ object.\n\
Usage: info vtbl EXPRESSION\n\
Evaluate EXPRESSION and display the virtual function table for the\n\
resulting object."));
}
@


1.62
log
@	PR c++/11990:
	* c-lang.c (cplus_language_defn): Use gdb_demangle.
	* c-typeprint.c (c_type_print_base): Use gdb_demangle.
	* cp-support.c (mangled_name_to_comp): Use gdb_demangle.
	(gdb_demangle): New function.
	* cp-support.h (gdb_demangle): Declare.
	* dwarf2read.c (dwarf2_physname, fixup_partial_die)
	(dwarf2_name): Use gdb_demangle.
	* gdbtypes.c (check_stub_method): Use gdb_demangle.
	* gnu-v3-abi.c (gnuv3_rtti_type): Strip @@plt and version
	suffixes from name.
	(gnuv3_print_method_ptr): Use gdb_demangle.
	* jv-lang.c (java_demangle): Use gdb_demangle.
	* jv-typeprint.c (java_type_print_base): Use gdb_demangle.
	* language.c (unk_lang_demangle): Use gdb_demangle.
	* symtab.c (symbol_find_demangled_name)
	(demangle_for_lookup): Use gdb_demangle.
@
text
@a40 2
#include "psymtab.h"

@


1.61
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d638 1
a638 1
  demangled_name = cplus_demangle (mangled_name, options);
d1479 8
@


1.60
log
@	* cp-support.c (inspect_type,
	replace_typedefs_qualified_name, replace_typedefs): Add
	finder, data arguments.  Call as needed.
	(cp_canonicalize_string_full): New function.
	(cp_canonicalize_string_no_typedefs): Rewrite.
	* cp-support.h (canonicalization_ftype): New typedef.
	(cp_canonicalize_string_full): Declare.
@
text
@d2 1
a2 1
   Copyright (C) 2002-2005, 2007-2012 Free Software Foundation, Inc.
@


1.59
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d84 3
a86 1
		    struct demangle_component *ret_comp);
d157 3
a159 1
	      struct demangle_component *ret_comp)
d189 14
d270 1
a270 1
		replace_typedefs (info, ret_comp);
d307 3
a309 1
				 struct demangle_component *ret_comp)
d333 1
a333 1
	  if (inspect_type (info, &new))
d367 1
a367 1
	  replace_typedefs (info, d_left (comp));
d378 1
d398 1
a398 1
      inspect_type (info, ret_comp);
d401 1
a401 1
    replace_typedefs (info, comp);
d429 3
a431 1
		  struct demangle_component *ret_comp)
d435 36
d481 2
a482 2
	  replace_typedefs (info, d_left (ret_comp));
	  replace_typedefs (info, d_right (ret_comp));
d486 1
a486 1
	  inspect_type (info, ret_comp);
d490 1
a490 1
	  replace_typedefs_qualified_name (info, ret_comp);
d497 1
a497 1
	  replace_typedefs (info, d_right (ret_comp));
d508 1
a508 1
	  replace_typedefs (info, d_left (ret_comp));
d520 2
a521 1
   xmalloc.  */
d524 3
a526 1
cp_canonicalize_string_no_typedefs (const char *string)
d538 1
a538 1
      replace_typedefs (info, info->tree);
d559 9
@


1.58
log
@	* tracepoint.c (scope_info): Update.
	* symtab.c (lookup_block_symbol, iterate_over_symbols)
	(find_pc_sect_symtab, search_symbols)
	(default_make_symbol_completion_list_break_on)
	(make_file_symbol_completion_list): Update.
	* symmisc.c (dump_symtab_1): Update.
	* stack.c (print_frame_args, iterate_over_block_locals)
	(print_frame_labels, iterate_over_block_arg_vars): Update.
	* python/py-block.c (block_object) <dict>: Remove.
	<block>: New field.
	<iter>: Change type.
	(blpy_iter): Update.
	(blpy_block_syms_iternext): Update.
	* psymtab.c (map_block): Use block iterators.
	* objfiles.c (objfile_relocate1): Use ALL_DICT_SYMBOLS.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* mdebugread.c (parse_symbol, mylookup_symbol): Update.
	* infrun.c (check_exception_resume): Update.
	* cp-support.c (make_symbol_overload_list_block): Update.
	* coffread.c (patch_opaque_types): Update.
	* buildsym.c (finish_block, end_symtab): Use ALL_DICT_SYMBOLS.
	* block.h (struct block_iterator): New.
	(block_iterator_first, block_iterator_next, block_iter_name_first)
	(block_iter_name_next, block_iter_match_first)
	(block_iter_match_next): Declare.
	(ALL_BLOCK_SYMBOLS): Redefine.
	* block.c (block_iterator_first, block_iterator_next)
	(block_iter_name_first, block_iter_name_next)
	(block_iter_match_first, block_iter_match_next): New functions.
	* ada-lang.c (ada_add_block_symbols)
	(ada_make_symbol_completion_list): Use block iterator.
@
text
@a1322 1
  struct symbol *sym;
a1325 2
  struct dict_iterator iter;
  const struct dictionary *dict;
@


1.57
log
@linespec rewrite:
	* linespec.c (decode_compound): Remove.
	(enum offset_relative_sign): New enum.
	(struct line_offset): New struct.
	(struct linespec): New struct.
	(struct linespec_state): Move file_symtabs,
	user_filename, and user_function into struct linespec.
	Make result an anonymous struct holding vectors of
	symbolp and minsym_and_objfile_d.
	Add language member.
	(enum ls_token_type): New enum.
	(linespec_keywords): New array.
	(struct ls_token): New struct.
	(struct ls_parser): New struct.
	(linespec_lexer_lex_number): New function.
	(linespec_lexer_lex_keyword): New function.
	(is_ada_operator): New function.
	(skip_quote_char): New function.
	(copy_token_string): New function.
	(is_closing_quote_enclosed): New function.
	(find_parameter_list_end): New function.
	(linespec_lexer_lex_string): New function.
	(linespec_lexer_lex_one): New function.
	(linespec_lexer_consume_token): New function.
	(linespec_lexer_peek_token): New function.
	(cplusplus_error): Remove unused function.
	(find_methods): Update comment.
	(find_toplevel_char): Return const.
	(is_objc_method_format): Remove unused function.
	(find_toplevel_string): New function.
	(is_linespec_boundary): Remove.
	(symbol_not_found_error): New function.
	(find_method_overload_end): Remove function.
	(unexpected_linespec_error): New function.
	(keep_name_info): Remove.
	(linespec_parse_line_offset): New function.
	(linespec_parse_basic): New function.
	(canonicalize_linespec): New function.
	(decode_line_internal): Remove.
	(create_sals_line_offset): New function adapted from
	decode_all_digits.
	(convert_linespec_to_sals): New function.
	(parse_linespec): New function.
	(linespec_parser_new): New function.
	(linespec_state_destructor): Change parameter type to
	struct linespec_state *.
	Add language parameter.
	Remove freeing of moved members.
	(linespec_parser_delete): New function.
	(decode_line_full): Use parse_linespec and linespec_parser_new.
	(decode_line_1): Likewise.
	(decode_indirect): Rename to ...
	(linespec_expression_to_pc): ... this and rewrite
	to simply find CORE_ADDR, storing this result for later
	conversion to SALs.
	(locate_first_half): Remove.
	(deocde_objc): Add parameter LS.
	Initialize new struct collect_info members.
	Handle minimal symbols, too.
	(decode_compound): Delete.
	(lookup_prefix_sym): Rewrite.
	(compare_msymbols): New function.
	(find_method): Rewrite.
	Do not call cplusplus_error.
	(symtabs_from_filename): Rewrite.
	(collect_function_symbols): Delete.
	(find_function_symbols): Rewrite without ARGPTR-style
	processing.
	(decode_all_digits): Delete. (Rewritten as create_sals_line_offset.)
	(decode_dollar): Adapted and renamed to ...
	(linespec_parse_variable): ... this.
	(find_linespec_symbols): New function.
	(decode_label): Adapted and renamed to ...
	(find_label_symbols): ... this.
	(decode_digits_list_mode): Add and use LS argument.
	(decode_digits_ordinary): Likewise.
	(collect_symbols): Do not collect SALs, just symbols and msymbols.
	If in list mode, allow any symbol class.  Otherwise, only
	permit LOC_BLOCK symbols.
	(minsym_found): Update comments.
	(search_minsyms_for_name): Do not convert the matching symbol
	into a SAL.  Simply push the symbol and objfile into the
	result vector.
	(decode_variable): Delete. Contents adapted into
	find_linespec_symbols.

	* cp-support.c (SKIP_SPACE): Remove.
	(operator_tokens): Remove unused global.
	(cp_validate_operator): Remove.
	* cp-support.h (cp_validate_operator): Remove declaration.

	* gdb.base/advance.exp: Update error message for
	"advance malformed" test.
	* gdb.base/break.exp: Likewise for "breakpoint with
	trailing garbage" test.
	* gdb.base/hbreak2.exp: Likewise for "hardware breakpoint
	with trailing garbage" test.
	* gdb.base/jump.exp: Likewise for "jump with trailing
	argument junk" test.
	* gdb.base/sepdebug.exp: Likewise for "breakpoint with
	trailng garbage" test.
	* gdb.base/until.exp: Likewise for "malformed until" test.
	* gdb.cp/ovldbreak.exp: Create the breakpoint table
	for "breakpoint info (after setting on all)".
	* gdb.cp/userdef.exp: Remove quoting for "break A2::operator+"
	tests.
	* gdb.cp/cplabel.cc: New file.
	* gdb.cp/cplabel.exp: New test.
	* gdb.linespec/ls-errs.c: New file.
	* gdb.linespec/ls-errs.exp: New test.
@
text
@d1143 1
a1143 1
  struct dict_iterator iter;
d1146 1
a1146 3
  const struct dictionary *dict = BLOCK_DICT (block);

  for (sym = dict_iter_name_first (dict, name, &iter);
d1148 1
a1148 1
       sym = dict_iter_name_next (name, &iter))
@


1.56
log
@	* NEWS: Mention "info vtbl", not "info vtable".
	* cp-support.c (info_vtbl_command): Fix comment.
	(_initialize_cp_support): Fix text.
@
text
@a75 13
/* Operator validation.
   NOTE: Multi-byte operators (usually the assignment variety
   operator) must appear before the single byte version, i.e., "+="
   before "+".  */
static const char *operator_tokens[] =
  {
    "++", "+=", "+", "->*", "->", "--", "-=", "-", "*=", "*",
    "/=", "/", "%=", "%", "!=", "==", "!", "&&", "<<=", "<<",
    ">>=", ">>", "<=", "<", ">=", ">", "~", "&=", "&", "|=",
    "||", "|", "^=", "^", "=", "()", "[]", ",", "new", "delete"
    /* new[] and delete[] require special whitespace handling */
  };

a1448 104
#define SKIP_SPACE(P)				\
  do						\
  {						\
    while (*(P) == ' ' || *(P) == '\t')		\
      ++(P);					\
  }						\
  while (0)

/* Returns the length of the operator name or 0 if INPUT does not
   point to a valid C++ operator.  INPUT should start with
   "operator".  */
int
cp_validate_operator (const char *input)
{
  int i;
  char *copy;
  const char *p;
  struct expression *expr;
  struct value *val;
  volatile struct gdb_exception except;

  p = input;

  if (strncmp (p, "operator", 8) == 0)
    {
      int valid = 0;

      p += 8;
      SKIP_SPACE (p);
      for (i = 0;
	   i < sizeof (operator_tokens) / sizeof (operator_tokens[0]);
	   ++i)
	{
	  int length = strlen (operator_tokens[i]);

	  /* By using strncmp here, we MUST have operator_tokens
	     ordered!  See additional notes where operator_tokens is
	     defined above.  */
	  if (strncmp (p, operator_tokens[i], length) == 0)
	    {
	      const char *op = p;

	      valid = 1;
	      p += length;

	      if (strncmp (op, "new", 3) == 0
		  || strncmp (op, "delete", 6) == 0)
		{

		  /* Special case: new[] and delete[].  We must be
		     careful to swallow whitespace before/in "[]".  */
		  SKIP_SPACE (p);

		  if (*p == '[')
		    {
		      ++p;
		      SKIP_SPACE (p);
		      if (*p == ']')
			++p;
		      else
			valid = 0;
		    }
		}

	      if (valid)
		return (p - input);
	    }
	}

      /* Check input for a conversion operator.  */

      /* Skip past base typename.  */
      while (*p != '*' && *p != '&' && *p != 0 && *p != ' ')
	++p;
      SKIP_SPACE (p);

      /* Add modifiers '*' / '&'.  */
      while (*p == '*' || *p == '&')
	{
	  ++p;
	  SKIP_SPACE (p);
	}

      /* Check for valid type.  [Remember: input starts with 
	 "operator".]  */
      copy = savestring (input + 8, p - input - 8);
      expr = NULL;
      val = NULL;
      TRY_CATCH (except, RETURN_MASK_ALL)
	{
	  expr = parse_expression (copy);
	  val = evaluate_type (expr);
	}

      xfree (copy);
      if (expr)
	xfree (expr);

      if (val != NULL && value_type (val) != NULL)
	return (p - input);
    }

  return 0;
}
@


1.55
log
@	* gnu-v3-abi.c (struct value_and_voffset): New.
	(hash_value_and_voffset, eq_value_and_voffset)
	(compare_value_and_voffset, compute_vtable_size)
	(print_one_vtable, gnuv3_print_vtable): New functions.
	(init_gnuv3_ops): Initialize 'print_vtable' field.
	* cp-support.c (info_vtbl_command): New function.
	(_initialize_cp_support): Add "info vtbl".
	* cp-abi.h (cplus_print_vtable): Declare.
	(struct cp_abi_ops) <print_vtable>: New field.
	* cp-abi.c (cplus_print_vtable): New function.
	* NEWS: Update.
gdb/testsuite
	* gdb.cp/virtfunc.exp (make_one_vtable_result): New proc.
	(test_info_vtbl): Likewise.
	(do_tests): Call test_info_vtbl.
	* gdb.cp/virtfunc.cc (va): New global.
gdb/doc
	* gdb.texinfo (Debugging C Plus Plus): Document "info vtbl".
@
text
@d1567 1
a1567 1
/* Implement "info vtable".  */
d1598 1
a1598 1
	    _("Show the vtable for a C++ object.\n\
@


1.54
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@d37 1
d1567 11
d1596 6
@


1.53
log
@gdb/
	Fix regression after libiberty/ update for GCC PR 6057 and others.
	* c-exp.y (operator) <OPERATOR DELETE>
	(operator) <OPERATOR DELETE '[' ']'>: Add trailing space.
	* cp-name-parser.y (fill_comp, make_operator, make_dtor)
	(make_builtin_type, make_name): New variable i, add gdb_assert.
	(operator) <OPERATOR NEW>: Update ARGS to 3.
	(operator) <OPERATOR DELETE>: Add trailing space.
	(operator) <OPERATOR NEW '[' ']'>: Update ARGS to 3.
	(operator) <OPERATOR DELETE '[' ']'>: Add trailing space.
	* cp-support.c (cp_canonicalize_string): Check NULL from
	cp_comp_to_string, call warning and return.
@
text
@d1208 1
a1208 1
  char *type_name;
@


1.52
log
@2012-01-06  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* ada-lang.c (ada_exception_name_addr): Add `volatile' keyword
	before `struct gdb_exception'.
	* breakpoint.c (update_global_location_list_nothrow)
	(update_breakpoint_locations, enable_breakpoint_disp): Likewise.
	* cp-abi.c (value_rtti_type): Likewise.
	* cp-support.c (cp_validate_operator): Likewise.
	* infrun.c (insert_exception_resume_breakpoint)
	(check_exception_resume, keep_going): Likewise.
	* mi-interp.c (mi_breakpoint_created)
	(mi_breakpoint_modified): Likewise.
	* rs6000-aix-tdep.c (rs6000_convert_from_func_ptr_addr): Likewise.
	* solib-ia64-hpux.c (ia64_hpux_at_dld_breakpoint_p)
	(ia64_hpux_handle_dld_breakpoint_1): Likewise.
@
text
@d531 7
@


1.51
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1473 1
a1473 1
  struct gdb_exception except;
@


1.50
log
@	PR c++/12266
	* cp-name-parser.y (struct demangle_info): Remove unused
	member PREV.
	(d_grab): Likewise.
	(allocate_info): Change return type to struct demangle_info *.
	Always allocate a new demangle_info.
	Remove unused PREV pointer.
	(cp_new_demangle_parse_info): New function.
	(cp_demangled_name_parse_free): New function.
	(do_demangled_name_parse_free_cleanup): New function.
	(make_cleanup_cp_demangled_name_parse_free): New function.
	(cp_demangled_name_to_comp): Change return type to
	struct demangle_parse_info *.
	Allocate a new storage for each call.
	(main): Update usage for cp_demangled_name_to_comp
	API change.
	* cp-support.h (struct demangle_parse_info): New structure.
	(cp_demangled_name_to_comp): Update API change for
	return type.
	(cp_new_demangle_parse_info): Declare.
	(make_cleanup_cp_demangled_name_parse_free): New declaration.
	(cp_demangled_name_parse_free): Declare.
	* cp-support.c (cp_canonicalize_string): Update API
	change for cp_demangled_name_to_comp.
	(mangled_name_to_comp): Likewise.
	Return struct demangle_parse_info, too.
	(cp_class_name_from_physname): Update mangled_name_to_comp
	API change.
	(method_name_from_physname): Likewise.
	(cp_func_name): Update API change for cp_demangled_name_to_comp.
	(cp_remove_params): Likewise.
	* python/py-type.c (typy_legacy_template_argument): Likewise.

	* cp-support.h (cp_canonicalize_string_no_typedefs): Declare.
	(cp_merge_demangle_parse_infos): Declare.
	* cp-support.c (ignore_typedefs): New file global.
	(copy_string_to_obstack): New function.
	(inspect_type): New function.
	(replace_typedefs): New function.
	(replace_typedefs_qualified_name): New function.
	(cp_canonicalize_string_no_typedefs): New function.
	* cp-name-parser.y (cp_merge_demangle_parse_infos): New function.
	(cp_new_demangle__parse_info): Allocate and initialize the obstack.
	* linespec.c (find_methods): Use cp_canonicalize_string_no_typedefs
	instead of cp_canonicalize_string.
	(find_method): Likewise.
	(decode_compound): Before looking up the name, call
	cp_canonicalize_string_no_typedefs.
	(decode_variable): Likewise.
@
text
@d2 1
a2 2
   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.50.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright (C) 2002-2005, 2007-2012 Free Software Foundation, Inc.
@


1.49
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@d89 41
d161 349
d517 1
a517 1
  struct demangle_component *ret_comp;
d524 2
a525 2
  ret_comp = cp_demangled_name_to_comp (string, NULL);
  if (ret_comp == NULL)
d529 2
a530 1
  ret = cp_comp_to_string (ret_comp, estimated_len);
d547 1
a547 1
static struct demangle_component *
a550 1
  struct demangle_component *ret;
d552 1
d558 2
d564 2
d567 1
a567 1
	  return ret;
d579 1
a579 1
  ret = cp_demangled_name_to_comp (demangled_name, NULL);
d581 1
a581 1
  if (ret == NULL)
d588 1
a588 1
  return ret;
d599 1
d602 3
a604 3
  ret_comp = mangled_name_to_comp (physname, DMGL_ANSI,
				   &storage, &demangled_name);
  if (ret_comp == NULL)
d608 1
d677 2
a678 2
  if (demangled_name)
    xfree (demangled_name);
d748 1
d750 3
a752 3
  ret_comp = mangled_name_to_comp (physname, DMGL_ANSI,
				   &storage, &demangled_name);
  if (ret_comp == NULL)
d755 1
a755 1
  ret_comp = unqualified_name_from_comp (ret_comp);
d764 2
a765 2
  if (demangled_name)
    xfree (demangled_name);
d780 1
d782 2
a783 2
  ret_comp = cp_demangled_name_to_comp (full_name, NULL);
  if (!ret_comp)
d786 1
a786 1
  ret_comp = unqualified_name_from_comp (ret_comp);
d792 1
d805 1
d811 2
a812 2
  ret_comp = cp_demangled_name_to_comp (demangled_name, NULL);
  if (ret_comp == NULL)
d816 1
d838 1
@


1.48
log
@gdb/
	* cp-support.c (make_symbol_overload_list_namespace): Do not call
	make_symbol_overload_list_block with NULL BLOCK.
	* valarith.c (unop_user_defined_p): Resolve also TYPE_CODE_TYPEDEF.

gdb/testsuite/
	* gdb.cp/typedef-operator.exp: New file.
	* gdb.cp/typedef-operator.cc: New file.
@
text
@d840 1
a840 1
/* Adds the the overload list overload candidates for FUNC_NAME found
@


1.47
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d781 2
a782 1
  make_symbol_overload_list_block (name, block);
d786 2
a787 1
  make_symbol_overload_list_block (name, block);
@


1.46
log
@run copyright.sh for 2011.
@
text
@d1019 2
a1020 1
  printf_unfiltered (_("\"maintenance cplus\" must be followed by the name of a command.\n"));
@


1.45
log
@2010-12-31  Michael Snyder  <msnyder@@vmware.com>

	* charset.c: Comment cleanup and long line wrapping.
	* charset.h: Ditto.
	* c-lang.c: Ditto.
	* c-lang.h: Ditto.
	* coff-pe-read.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* complaints.c: Ditto.
	* complaints.h: Ditto.
	* completer.c: Ditto.
	* completer.h: Ditto.
	* corefile.c: Ditto.
	* corelow.c: Ditto.
	* core-regset.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-abi.h: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cp-support.h: Ditto.
	* cp-valprint.c: Ditto.
	* cp-typeprint.c: Ditto.
	* c-valprint.c: Ditto.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010
@


1.44
log
@	* cp-support.c (reset_directive_searched): New function.
	(make_symbol_overload_list_using): Prevent recursive calls.
@
text
@d77 3
a79 2
   NOTE: Multi-byte operators (usually the assignment variety operator)
   must appear before the single byte version, i.e., "+=" before "+".  */
d82 4
a85 4
    "++", "+=", "+", "->*", "->", "--", "-=", "-", "*=", "*", "/=", "/",
    "%=", "%", "!=", "==", "!", "&&", "<<=", "<<", ">>=", ">>",
    "<=", "<", ">=", ">", "~", "&=", "&", "|=", "||", "|", "^=", "^",
    "=", "()", "[]", ",", "new", "delete"
d150 5
a154 5
/* Convert a mangled name to a demangle_component tree.  *MEMORY is set to the
   block of used memory that should be freed when finished with the tree. 
   DEMANGLED_P is set to the char * that should be freed when finished with
   the tree, or NULL if none was needed.  OPTIONS will be passed to the
   demangler.  */
d167 2
a168 1
      ret = cplus_demangle_v3_components (mangled_name, options, memory);
d176 2
a177 1
  /* If it doesn't, or if that failed, then try to demangle the name.  */
d182 2
a183 1
  /* If we could demangle the name, parse it to build the component tree.  */
d206 2
a207 2
  ret_comp = mangled_name_to_comp (physname, DMGL_ANSI, &storage,
				   &demangled_name);
d213 2
a214 1
  /* First strip off any qualifiers, if we have a function or method.  */
d241 3
a243 3
  /* What we have now should be a name, possibly qualified.  Additional
     qualifiers could live in the left subtree or the right subtree.  Find
     the last piece.  */
d274 2
a275 1
      /* The ten is completely arbitrary; we don't have a good estimate.  */
d285 4
a288 3
/* Return the child of COMP which is the basename of a method, variable,
   et cetera.  All scope qualifiers are discarded, but template arguments
   will be included.  The component tree may be modified.  */
d352 2
a353 2
  ret_comp = mangled_name_to_comp (physname, DMGL_ANSI, &storage,
				   &demangled_name);
d361 2
a362 1
    /* The ten is completely arbitrary; we don't have a good estimate.  */
d562 2
a563 1
	      && strncmp (name + index, "operator", LENGTH_OF_OPERATOR) == 0)
d653 1
a653 1
   completion list. */
d656 2
a657 1
overload_list_add_symbol (struct symbol *sym, const char *oload_name)
d663 2
a664 1
  /* If there is no type information, we can't do anything, so skip */
d668 1
a668 1
  /* skip any symbols that we've already considered. */
d688 2
a689 2
  /* We have a match for an overload instance, so add SYM to the current list
   * of overload instances */
d693 2
a694 1
      sym_return_val = (struct symbol **) xrealloc ((char *) sym_return_val, newsize);
d789 2
a790 2
/* Search the namespace of the given type and namespace of and public base
 types.  */
d800 2
a801 1
  while (TYPE_CODE (type) == TYPE_CODE_PTR || TYPE_CODE (type) == TYPE_CODE_REF
d832 2
a833 1
	  make_symbol_overload_list_adl_namespace (TYPE_BASECLASS (type, i),
d838 2
a839 2
/* Adds the the overload list overload candidates for FUNC_NAME found through
   argument dependent lookup.  */
d850 2
a851 1
    make_symbol_overload_list_adl_namespace (arg_types[i - 1], func_name);
d856 2
a857 1
/* Used for cleanups to reset the "searched" flag in case of an error.  */
d893 2
a894 1
        /* If this is a namespace alias or imported declaration ignore it.  */
d900 2
a901 2
	    /* Mark this import as searched so that the recursive call does
	       not search it again.  */
d904 2
a905 1
	    old_chain = make_cleanup (reset_directive_searched, current);
d907 2
a908 1
	    make_symbol_overload_list_using (func_name, current->import_src);
d933 2
a934 2
  /* Look through the partial symtabs for all symbols which begin
     by matching FUNC_NAME.  Make sure we read that symbol table in. */
d971 1
a971 1
/* Lookup the rtti type for a class name. */
d1020 3
a1022 1
  help_list (maint_cplus_cmd_list, "maintenance cplus ", -1, gdb_stdout);
d1058 2
a1059 1
   point to a valid C++ operator.  INPUT should start with "operator".  */
d1078 2
a1079 1
      for (i = 0; i < sizeof (operator_tokens) / sizeof (operator_tokens[0]);
d1084 3
a1086 2
	  /* By using strncmp here, we MUST have operator_tokens ordered!
	     See additional notes where operator_tokens is defined above.  */
d1098 2
a1099 2
		  /* Special case: new[] and delete[].  We must be careful
		     to swallow whitespace before/in "[]".  */
d1120 1
a1120 1
      /* Skip past base typename */
d1125 1
a1125 1
      /* Add modifiers '*'/'&' */
d1157 13
a1169 6
  add_prefix_cmd ("cplus", class_maintenance, maint_cplus_command,
		  _("C++ maintenance commands."), &maint_cplus_cmd_list,
		  "maintenance cplus ", 0, &maintenancelist);
  add_alias_cmd ("cp", "cplus", class_maintenance, 1, &maintenancelist);

  add_cmd ("first_component", class_maintenance, first_component_command,
@


1.43
log
@Fix operator doubly nested namespace search.

2010-06-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	* cp-support.c (make_symbol_overload_list_namespace): Only search
	static and global blocks.
	(make_symbol_overload_list_block): New function.
	(make_symbol_overload_list): Separate namespace search from block
	search.
	(make_symbol_overload_list_qualified): Use
	make_symbol_overload_list_block.
@
text
@d841 9
d859 1
a859 1
  const struct using_direct *current;
d873 4
d882 12
a893 1
          make_symbol_overload_list_using (func_name, current->import_src);
@


1.42
log
@Test and support all cpp operator types.

2010-06-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	* value.h: Created oload_search_type enum.
	(find_overload_match): Use oload_search_type enum.
	* valops.c (find_overload_match): Support combined member and
	non-member search.
	* eval.c (evaluate_subexp_standard): Calls to
	find_overload_match now use oload_search_type enum.
	(oload_method_static): Verify index is a proper value.
	* valarith.c (value_user_defined_cpp_op): Search for and handle
	both member and non-member operators.
	(value_user_defined_cpp_op): New function.
	(value_user_defined_op): New function.
	(value_x_unop): Use value_user_defined_op.
	(value_x_binop): Ditto.
	* cp-support.c (make_symbol_overload_list_using): Added block
	iteration.
	Add check for namespace aliases and imported declarations.

2010-06-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/koenig.exp: Test for ADL operators.
	* gdb.cp/koenig.cc: Added ADL operators.
	* gdb.cp/operator.exp: New test.
	* gdb.cp/operator.cc: New test.
@
text
@d696 1
d708 14
d727 18
d751 3
d755 1
a755 1
    make_symbol_overload_list_qualified (func_name);
d764 1
a764 1
      make_symbol_overload_list_qualified (concatenated_name);
d766 9
d903 1
a903 10
    {
      dict = BLOCK_DICT (b);

      for (sym = dict_iter_name_first (dict, func_name, &iter);
	   sym;
	   sym = dict_iter_name_next (func_name, &iter))
	{
	  overload_list_add_symbol (sym, func_name);
	}
    }
d914 1
a914 8
    dict = BLOCK_DICT (b);

    for (sym = dict_iter_name_first (dict, func_name, &iter);
	 sym;
	 sym = dict_iter_name_next (func_name, &iter))
    {
      overload_list_add_symbol (sym, func_name);
    }
d924 1
a924 8
    dict = BLOCK_DICT (b);

    for (sym = dict_iter_name_first (dict, func_name, &iter);
	 sym;
	 sym = dict_iter_name_next (func_name, &iter))
    {
      overload_list_add_symbol (sym, func_name);
    }
@


1.41
log
@Fix ADL anonymous name crash.

2010-06-02  Sami Wagiaalla  <swagiaal@@redhat.com>

	* cp-support.c (make_symbol_overload_list_adl_namespace): Handle
	anonymous type case.

2010-06-02  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/koenig.exp: Added new test case.
	* gdb.cp/koenig.cc: Ditto.
@
text
@d806 1
d812 14
a825 10
  for (current = block_using (get_selected_block (0));
       current != NULL;
       current = current->next)
    {
      if (strcmp (namespace, current->import_dest) == 0)
	{
	  make_symbol_overload_list_using (func_name,
					   current->import_src);
	}
    }
@


1.40
log
@2010-05-13  Michael Snyder  <msnyder@@vmware.com>

	* charset.c: White space.
	* c-lang.c: White space.
	* cli-out.c: White space.
	* coffread.c: White space.
	* complaints.c: White space.
	* completer.c: White space.
	* corefile.c: White space.
	* corelow.c: White space.
	* cp-abi.c: White space.
	* cp-namespace.c: White space.
	* cp-support.c: White space.
	* cp-valprint.c: White space.
	* c-typeprint.c: White space.
	* c-valprint.c: White space.
@
text
@d755 3
@


1.39
log
@Add ADL support

2010-05-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR C++/7943:
	* valops.c (find_overload_match): Handle fsym == NULL case.
	Add int no_adl argument.
	(find_oload_champ_namespace_loop): Call make_symbol_overload_list_adl
	when appropriate.
	Add int no_adl argument.
	(find_oload_champ_namespace): 	Add int no_adl argument.
	* parse.c (operator_length_standard): Return length for OP_ADL_FUNC
	expression.
	* expprint.c (op_name_standard): Added string for OP_ADL_FUNC case.
	* eval.c (evaluate_subexp_standard): Added OP_ADL_FUNC case.
	Evaluate arguments and use them to perform ADL lookup.
	Pass no_adl argument to find_overload_match.
	Disable adl lookup when evaluating a fully qualified OP_FUNCALL.
	* cp-support.h: Added prototype for
	make_symbol_overload_list_namespace.
	* cp-support.c (make_symbol_overload_list_namespace): New function.
	(make_symbol_overload_list_adl_namespace): New function.
	(make_symbol_overload_list_adl): New function.
	(make_symbol_overload_list_using): Moved code to add function to
	overload set to make_symbol_overload_list_namespace.
	* c-exp.y: create UNKNOWN_CPP_NAME token.
	Add parse rule for ADL functions.
	(classify_name): Recognize an UNKNOWN_CPP_NAME.

2010-05-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/koenig.exp: New test.
	* gdb.cp/koenig.cc: New test program.
@
text
@a717 1

d724 1
d999 1
a1000 1

d1006 1
d1012 1
@


1.38
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* frame-unwind.c (frame_unwind_find_by_frame):
	Delete unused variable.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Delete unused variable.
	* cp-support.c (mangled_name_to_comp): Delete unused variable.
	(method_name_from_physname): Delete unused variable.
	(cp_func_name): Delete unused variable.
	(cp_validate_operator): Delete unused variable.
	* cp-namespace.c (cp_scan_for_anonymous_namespaces):
	Delete unused variable.
	* trad-frame.c (trad_frame_get_prev_register):
	Delete unused variable.
	* tramp-frame.c (tramp_frame_cache): Delete unused variable.
@
text
@d55 1
a55 1
static int sym_return_val_size;
d712 81
d820 1
a820 14
  
  if (namespace[0] == '\0')
    {
      make_symbol_overload_list_qualified (func_name);
    }
  else
    {
      char *concatenated_name
	= alloca (strlen (namespace) + 2 + strlen (func_name) + 1);
      strcpy (concatenated_name, namespace);
      strcat (concatenated_name, "::");
      strcat (concatenated_name, func_name);
      make_symbol_overload_list_qualified (concatenated_name);
    }
@


1.37
log
@gdb
	* xcoffread.c: Include psymtab.h.
	(xcoff_sym_fns): Update.
	* symtab.h (struct partial_symbol): Remove.
	(PSYMBOL_DOMAIN, PSYMBOL_CLASS): Remove.
	(struct partial_symtab): Remove.
	(PSYMTAB_TO_SYMTAB): Remove.
	(lookup_partial_symbol, lookup_partial_symtab, find_pc_psymtab)
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): Declare.
	(find_pc_psymtab, find_pc_sect_psymbol, psymtab_to_symtab)
	(find_main_psymtab): Remove.
	(find_main_filename): Declare.
	(fixup_psymbol_section): Remove.
	(fixup_section): Declare.
	* symtab.c: Include psymtab.h.
	(lookup_symtab): Use lookup_symtab method.
	(lookup_partial_symtab): Remove.
	(find_pc_sect_psymtab_closer): Remove.
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): New function.
	(find_pc_psymtab, find_pc_sect_psymbol, find_pc_psymbol): Remove.
	(fixup_section): No longer static.
	(fixup_psymbol_section): Remove.
	(lookup_symbol_aux): Use lookup_symbol_aux_quick.
	(lookup_global_symbol_from_objfile): Likewise.
	(lookup_symbol_aux_psymtabs): Remove.
	(lookup_symbol_aux_quick): New function.
	(lookup_symbol_global): Use lookup_symbol_aux_quick.
	(lookup_partial_symbol): Remove.
	(basic_lookup_transparent_type_quick): New function.
	(basic_lookup_transparent_type): Use it.
	(find_main_psymtab): Remove.
	(find_main_filename): New function.
	(find_pc_sect_symtab): Use find_pc_sect_symtab method.
	(find_line_symtab): Use expand_symtabs_with_filename method.
	(output_partial_symbol_filename): New function.
	(sources_info): Use map_partial_symbol_filenames.
	(struct search_symbols_data): New type.
	(search_symbols_file_matches): New function.
	(search_symbols_name_matches): Likewise.
	(search_symbols): Use expand_symtabs_matching method.
	(struct add_name_data): Rename from add_macro_name_data.
	(add_macro_name): Update.
	(add_partial_symbol_name): New function.
	(default_make_symbol_completion_list): Use
	map_partial_symbol_names.
	(struct add_partial_symbol_name): New type.
	(maybe_add_partial_symtab_filename): New function.
	(make_source_files_completion_list): Use
	map_partial_symbol_filenames.
	(expand_line_sal): Use expand_symtabs_with_filename method.
	* symmisc.c: Include psymtab.h.
	(print_objfile_statistics): Use print_stats method.
	(dump_objfile): Use dump method.
	(dump_psymtab, maintenance_print_psymbols)
	(maintenance_info_psymtabs, maintenance_check_symtabs)
	(extend_psymbol_list): Remove.
	* symfile.h (struct quick_symbol_functions): New struct.
	(struct sym_fns) <qf>: New field.
	(sort_pst_symbols): Remove.
	(increment_reading_symtab): Declare.
	* symfile.c: Include psymtab.h.
	(compare_psymbols, sort_pst_symbols): Remove.
	(psymtab_to_symtab): Remove.
	(increment_reading_symtab): New function.
	(symbol_file_add_with_addrs_or_offsets): Use expand_all_symtabs
	method.
	(set_initial_language): Use find_main_filename.
	(allocate_psymtab, discard_psymtab, cashier_psymtab): Remove.
	(free_named_symtabs): Remove unused code.
	(start_psymtab_common, add_psymbol_to_bcache)
	(append_psymbol_to_list, add_psymbol_to_list, init_psymbol_list):
	Remove.
	* stack.c: Include psymtab.h, symfile.h.
	(backtrace_command_1): Use find_pc_sect_symtab_via_partial.
	* source.h (psymtab_to_fullname): Don't declare.
	* source.c: Include psymtab.h.
	(select_source_symtab): Use find_last_source_symtab method.
	(forget_cached_source_info): Use forget_cached_source_info
	method.
	(find_and_open_source): No longer static.
	(psymtab_to_fullname): Remove.
	* somread.c: Include psymtab.h.
	(som_sym_fns): Update.
	* psympriv.h: New file.
	* psymtab.h: New file.
	* psymtab.c: New file.
	* objfiles.h: (ALL_OBJFILE_PSYMTABS): Remove.
	(ALL_PSYMTABS, ALL_PSPACE_PSYMTABS): Likewise.
	* objfiles.c: Include psymtab.h.
	(objfile_relocate1): Use relocate method.
	(objfile_has_partial_symbols): Use has_symbols method.
	* mipsread.c: Include psymtab.h.
	(ecoff_sym_fns): Update.
	* mi/mi-cmd-file.c: Include psymtab.h.
	(print_partial_file_name): New function.
	(mi_cmd_file_list_exec_source_files): Use
	map_partial_symbol_filenames.
	* mdebugread.c: Include psympriv.h.
	* machoread.c: Include psympriv.h.
	(macho_sym_fns): Update.
	* m2-exp.y (yylex): Use lookup_symtab.
	* elfread.c: Include psympriv.h.
	(elf_sym_fns): Update.
	* dwarf2read.c: Include psympriv.h.
	* dbxread.c: Include psympriv.h.
	(aout_sym_fns): Update.
	* cp-support.c: Include psymtab.h.
	(read_in_psymtabs): Remove.
	(make_symbol_overload_list_qualified): Use
	expand_symtabs_for_function method.
	* coffread.c: Include psympriv.h.
	(coff_sym_fns): Update.
	* blockframe.c: Include psymtab.h.
	(find_pc_partial_function): Use find_pc_sect_symtab method.
	* ada-lang.h (ada_update_initial_language): Update.
	* ada-lang.c: Include psymtab.h.
	(ada_update_initial_language): Remove 'main_pst' argument.
	(ada_lookup_partial_symbol): Remove.
	(struct ada_psym_data): New type.
	(ada_add_psyms): New function.
	(ada_add_non_local_symbols): Use map_ada_symtabs method.
	(struct add_partial_datum): New type.
	(ada_add_partial_symbol_completions): New function.
	(ada_make_symbol_completion_list): Use map_partial_symbol_names.
	(ada_exception_support_info_sniffer): Update.
	* Makefile.in (SFILES): Add psymtab.c.
	(COMMON_OBS): Add psymtab.o.
	(HFILES_NO_SRCDIR): Add psymtab.h, psympriv.h.
gdb/doc
	* gdbint.texinfo (Symbol Handling): Update.
@
text
@a160 1
  int len;
a343 1
  int done;
a373 1
  int done;
a924 1
  struct cleanup *old_chain;
@


1.36
log
@dwarf2_physname patchset:

	Based on work from Daniel Jacobowitz  <dan@@codesourcery.com>
	* c-typeprint.c (cp_type_print_method_args): For non-static methods,
	print out const or volatile qualifiers, too.
	(c_type_print_args): Add parameters show_artificial and language.
	Skip artificial parameters when requested.
	Use the appropriate language printer.
	(c_type_print_varspec): Tell c_type_print_args to skip artificial
	parameters and pass language_c.
	* dwarf2read.c (die_list): New file global.
	(struct partial_die_info): Update comments for name field.
	(pdi_needs_namespace): Renamed to ...
	(die_needs_namespace): ... this. Rewrite.
	(dwarf2_linkage_name): Remove.
	(add_partial_symbol): Do not predicate the call to
	partial_die_full_name based on pdi_needs_namespace.
	Remove call to cp_check_possible_namespace_symbols and associated
	outdated comments.
	(guess_structure_name): Do not inspect child subprogram DIEs.
	(dwarf2_fullname): Update comments.
	Use die_needs_namespace to assist in computing the name.
	(read_func_scope): Use dwarf2_name to get the DIE's name.
	Use dwarf2_physname to get the "linkage name" of the DIE.
	(dwarf2_add_member_field): Use dwarf2_physname instead of
	dwarf2_linkage_name.
	(read_structure_type): For structs and classes, set TYPE_NAME, too.
	(determine_class): Remove.
	(read_partial_die): Ignore DW_AT_MIPS_linkage_name for all languages
	except Ada.
	(new_symbol): Unconditionally call dwarf2_name.
	Compute the "linkage name" using dwarf2_physname.
	Use dwarf2_name instead of dwarf2_full_name for enumerator DIEs.
	When determining to scan for anonymous C++ namespaces, ignore
	the linkage name.
	(dwarf2_physname): New function.
	(dwarf2_full_name): Move content to new function and call
	that.
	(dwarf2_compute_name): "New" function.
	(_initialize_dwarf2_read): Initialize die_list.
	* gnu-v3-eabi.c (gnu_v3_find_method_in): Remove unused variable
	physname.
	(gnu_v3_print_method_ptr): Use the physname for virtual methods
	without a demangled name.
	Print out type information for non-virtual methods.
        * linespec.c (decode_line_1): Force ANY string using "::" (or
	"." for java) to use decode_compound, and clean up any stray quoting.
        If we found a file symtab, re-evaluate whether the remainder is_quoted.
        (decode_compound): Stop consuming at an open parenthesis.
        Keep template parameters.
        Keep any overload information.
        Keep keywords like "const".
        Remove paren_pointer.
        Move is_quoted check from set_flags to here.
        Remove #if 0 code from 2000. Ten years is long enough.
        (find_method): Before comparing symbol names, canonicalize the string
        from the user.
        If a specific overload is requested, find it. Otherwise throw an error.
	(find_method_overload_end): New function.
	(set_flags): Remove.
        (decode_compound): Assume that parentheses are matched.
        It's a lot easier.
	* symtab.c (symbol_find_demangled_name): Add DMGL_VERBOSE flag
	to cplus_demangle.
	* linespec.c (decode_line_1): Keep important keywords like
	"const" and "volatile".
	* symtab.h (SYMBOL_CPLUS_DEMANGLED_NAME): Remove.
	* typeprint.h (c_type_print_args): Add declaration.
	* ui-file.c (do_ui_file_obsavestring): New function.
	(ui_file_obsavestring): New function.
	* ui-file.h (ui_file_obsavestring): Add declaration.
	* valops.c (find_overload_match): Resolve the object to
	a non-pointer type.
	If the object is a data member, search the object for the member
	and return with staticp set.
	Use SYMBOL_NATURAL_NAME instead of SYMBOL_CPLUS_DEMANGLED_NAME.
	Do not attempt to extract a function name from non-function types.
	If the extracted function name and the original name are the same,
	we don't have a C++ method.

	From Jan Kratochvil  <jan.kratochvil@@redhat.com>:
    	* dwarf2read.c (new_symbol <DW_TAG_enumerator>): Call dwarf2_full_name.

	* ada-lang.c (ada_lookup_symbol): Remove linkage_name parameters
	and arguments from symbol lookups.
	* ax-gdb.c (gen_expr): Likewise.
	* cp-namespace.c (cp_lookup_symbol_nonlocal, lookup_namespace_scope,
	cp_lookup_symbol_namespace, lookup_symbol_file, lookup_nested_type,
	lookup_possible_namespace_symbol): Likewise.
	* cp-support.c (read_in_psymtabs): Likewise.
	* cp-support.h (cp_lookup_symbol_nonlocal): Likewise.
	* language.h (la_lookup_symbol_nonlocal): Likewise.
	* scm-valprint.c (scm_inferior_print): Likewise.
	* solib-darwin.c (darwin_relocate_section_addresses): Likewise.
	* solib-svr.c (elf_lookup_lib): Likewise.
	* solib.c (show_auto_solib_add): Likewise.
	* solist.h (lookup_lib_global, solib_global_lookup): Likewise.
	* symmisc.c (maintenance_check_symtabs): Likewise.
	* symtab.c (lookup_symbol_in_language, lookup_symbol_aux,
	lookup_symbol_aux_local, lookup_symbol_aux_block,
	lookup_symbol_from_objfile, lookup_symbol_aux_symtabs,
	lookup_symbol_aux_psymtabs,basic_lookup_symbol_nonlocal,
	lookup_symbol_static, lookup_symbol_global, symbol_matches_domain,
	basic_lookup_transparent_type, find_main_psymtab,
	lookup_block_symbol): Likewise.
	* symtab.h (basic_lookp_symbol_nonlocal, lookup_symbol_static,
	lookup_symbol_global, lookup_symbol_aux_block,
	lookup_symbol_partial_symbol, lookup_block_symbol,
	lookup_global_symbol, value_maybe_namespace_elt): Likewise.
@
text
@d41 2
a66 2
static void read_in_psymtabs (const char *oload_name);

d775 5
a779 1
  read_in_psymtabs (func_name);
a832 22
/* Look through the partial symtabs for all symbols which begin
   by matching FUNC_NAME.  Make sure we read that symbol table in. */

static void
read_in_psymtabs (const char *func_name)
{
  struct partial_symtab *ps;
  struct objfile *objfile;

  ALL_PSYMTABS (objfile, ps)
  {
    if (ps->readin)
      continue;

    if ((lookup_partial_symbol (ps, func_name, 1, VAR_DOMAIN)
	 != NULL)
	|| (lookup_partial_symbol (ps, func_name, 0, VAR_DOMAIN)
	    != NULL))
      psymtab_to_symtab (ps);
  }
}

@


1.35
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d843 1
a843 1
    if ((lookup_partial_symbol (ps, func_name, NULL, 1, VAR_DOMAIN)
d845 1
a845 1
	|| (lookup_partial_symbol (ps, func_name, NULL, 0, VAR_DOMAIN)
@


1.34
log
@	* cp-support.h (cp_validate_operator): Declare new function.
	* cp-support.c (cp_validate_operator): New function.
	* linespec.c (decode_compound): For C++ check for a valid operator.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009
@


1.33
log
@2009-07-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	* cp-support.h (struct using_direct): Rename members inner and
	outer to import_src, and import_dest respectively.
	* cp-namespace.c (cp_add_using_directive): Update.
	(cp_add_using): Update.
	(cp_copy_usings): Update.
	(cp_lookup_symbol_namespace): Update.
	(cp_scan_for_anonymous_namespaces): Update.
	* cp-support.c (make_symbol_overload_list_using): Update.
	* cp-support.h (cp_add_using_directive, cp_add_using): Rename
	arguments from inner and outer to src and dest respectively.
	* cp-namespace.c (cp_add_using_directive): Ditto.
	(cp_add_using): Ditto.
@
text
@d35 3
d76 12
d927 101
@


1.32
log
@        Updated copyright notices for most files.
@
text
@d719 1
a719 1
      if (strcmp (namespace, current->outer) == 0)
d722 1
a722 1
					   current->inner);
@


1.31
log
@	* varobj.c (varobj_set_display_format): Use xfree.
	* tracepoint.c (stringify_collection_list): Use xfree.
	* remote-fileio.c (remote_fileio_reset): Use xfree.
	* mipsread.c (read_alphacoff_dynamic_symtab): Use xfree.
	* dfp.c (decimal_from_floating): Use xfree, xstrprintf.  Don't use
	asprintf.
	* cp-support.c (mangled_name_to_comp): Use xfree.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008
@


1.30
log
@	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME.
	* blockframe.c (find_pc_partial_function): Likewise.
	* buildsym.c (find_symbol_in_list): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* coffread.c (patch_opaque_types, process_coff_symbol): Likewise.
	(coff_read_enum_type): Likewise.  Use SYMBOL_SET_LINKAGE_NAME.
	* cp-support.c (cp_remove_params): Renamed from remove_params and
	made global.
	(overload_list_add_symbol): Update call to remove_params.
	* cp-support.h (cp_remove_params): Declare.
	* dwarf2read.c (process_enumeration_scope): Use SYMBOL_LINKAGE_NAME.
	(dwarf2_const_value): Use SYMBOL_PRINT_NAME.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* f-valprint.c (info_common_command, there_is_a_visible_common_named):
	Use SYMBOL_LINKAGE_NAME to find symbols and SYMBOL_PRINT_NAME
	for messages.
	* findvar.c (read_var_value): Use SYMBOL_LINKAGE_NAME.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa_hpux_skip_trampoline_code): Use SYMBOL_LINKAGE_NAME to find
	symbols and SYMBOL_PRINT_NAME for messages.
	* jv-lang.c (add_class_symbol): Use SYMBOL_SET_LINKAGE_NAME.
	* linespec.c (decode_line_2): Use SYMBOL_LINKAGE_NAME.
	* mdebugread.c (parse_symbol): Use SYMBOL_LINKAGE_NAME and
	SYMBOL_SET_LINKAGE_NAME.
	(mylookup_symbol): Use SYMBOL_LINKAGE_NAME.
	* minsyms.c (add_minsym_to_demangled_hash_table): Use
	SYMBOL_SEARCH_NAME.
	(lookup_minimal_symbol): Use SYMBOL_LINKAGE_NAME or
	SYMBOL_MATCHES_SEARCH_NAME, depending on the pass.
	* objfiles.h (ALL_OBJFILE_MSYMBOLS): Use SYMBOL_LINKAGE_NAME.
	* printcmd.c (build_address_symbolic): Use SYMBOL_LINKAGE_NAME.
	(address_info): Use SYMBOL_PRINT_NAME for messages and
	SYMBOL_LINKAGE_NAME for lookups.
	* sol-thread.c (info_cb): Use SYMBOL_PRINT_NAME for messages.
	* stabsread.c (patch_block_stabs, define_symbol)
	(read_type, read_enum_type, common_block_end)
	(cleanup_undefined_types_1, scan_file_globals): Use
	SYMBOL_LINKAGE_NAME, SYMBOL_SET_LINKAGE_NAME, ALL_OBJFILE_MSYMBOLS,
	and SYMBOL_PRINT_NAME.
	* stack.c (print_frame_args): Use SYMBOL_LINKAGE_NAME.
	(print_frame, frame_info): Use SYMBOL_PRINT_NAME for output.  Use
	cp_remove_params instead of cplus_demangle.
	(print_block_frame_labels, print_frame_arg_vars): Use
	SYMBOL_LINKAGE_NAME.
	* symmisc.c (dump_msymbols): Use ALL_OBJFILE_MSYMBOLS and
	SYMBOL_LINKAGE_NAME.
	(dump_symtab_1, print_symbol, print_partial_symbols)
	(maintenance_check_symtabs): Use SYMBOL_LINKAGE_NAME.
	* symtab.h (DEPRECATED_SYMBOL_NAME): Delete.
	(SYMBOL_SET_LINKAGE_NAME): New.
	(SYMBOL_SET_NAMES): Add a comment.
	* tracepoint.c (set_traceframe_context, validate_actionline)
	(collect_symbol, scope_info): Use SYMBOL_LINKAGE_NAME for
	lookups and SYMBOL_PRINT_NAME for output.
	* typeprint.c (typedef_print): Use SYMBOL_LINKAGE_NAME.
	* xcoffread.c (process_xcoff_symbol): Use SYMBOL_SET_LINKAGE_NAME.
@
text
@d170 1
a170 1
      free (demangled_name);
@


1.29
log
@	* symtab.h (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	* symtab.c (lookup_symbol_in_language): Remove SYMTAB parameter.
	(lookup_symbol): Likewise.
	(search_symbols): Update.

	* linespec.c (find_methods, collect_methods): Update.
	(add_matching_methods, add_constructors): Update.
	(decode_compound, decode_dollar, decode_variable): Update.
	(lookup_prefix_sym): Update.

	(symbol_found): Remove SYM_SYMTAB parameter.
	Use SYMBOL_SYMTAB (sym) instead.

	* gdbtypes.c (lookup_typename): Update.
	(lookup_struct, lookup_union, lookup_enum): Update.
	(lookup_template_type): Update.
	(check_typedef): Update.
	* language.c (lang_bool_type): Update.
	* mdebugread.c (parse_procedure): Update.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* parse.c (write_dollar_variable): Update.
	* printcmd.c (address_info): Update.
	* source.c (select_source_symtab): Update.
	* stack.c (print_frame_args, print_frame_arg_vars): Update.
	* valops.c (find_function_in_inferior): Update.
	(value_struct_elt_for_reference): Update.
	* value.c (value_static_field, value_fn_field): Update.

	* alpha-mdebug-tdep.c (find_proc_desc): Update.
	* arm-tdep.c (arm_skip_prologue): Update.
	* mt-tdep.c (mt_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Update.

	* ada-lang.h (struct ada_symbol_info): Remove SYMTAB member.
	* ada-lang.c (ada_add_block_symbols): Remove SYMTAB parameter.
	(add_defn_to_vec): Likewise.
	(ada_add_block_symbols): Likewise.
	(lookup_cached_symbol, cache_symbol): Likewise.
	(standard_lookup): Update.
	(ada_lookup_symbol_list): Update.

	* c-valprint.c (c_val_print): Update.
	* cp-support.c (cp_lookup_rtti_type): Update.
	* jv-lang.c (java_lookup_class, get_java_object_type): Update.
	* objc-lang.c (lookup_struct_typedef, find_imps): Update.
	* p-valprint.c (pascal_val_print): Update.
	* scm-lang.c (scm_lookup_name): Update.

	* c-exp.y: Update.
	* f-exp.y: Update.
	* jv-exp.y: Update.
	* m2-exp.y: Update.
	* objc-exp.y: Update.
	* p-exp.y: Update.
@
text
@d380 2
a381 2
static char *
remove_params (const char *demangled_name)
d652 1
a652 1
  sym_name = remove_params (SYMBOL_NATURAL_NAME (sym));
@


1.28
log
@	* cp-support.c (mangled_name_to_comp): Initialize storage.
	(unqualified_name_from_comp): Likewise.
@
text
@d844 1
a844 1
  rtti_sym = lookup_symbol (name, block, STRUCT_DOMAIN, NULL, NULL);
@


1.27
log
@* cp-support.c (first_component_command): Return if no arguments.
@
text
@d183 1
a183 1
  void *storage;
d327 1
a327 1
  void *storage;
@


1.26
log
@	Updated copyright notices for most files.
@
text
@d895 8
a902 2
  int len = cp_find_first_component (arg);
  char *prefix = alloca (len + 1);
@


1.25
log
@	* cp-support.c: Include "safe-ctype.h".
	(cp_already_canonical): New function.
	(cp_canonicalize_string): Use it.  Return NULL for already canonical
	strings.
	(mangled_name_to_comp): Update call to cp_demangled_name_to_comp.
	(cp_func_name, remove_params): Likewise.
	(cp_find_first_component_aux): Use ISSPACE.
	* cp-support.h (cp_demangled_name_to_comp): Correct comment.  Remove
	MEMORY_P argument.
	* cp-name-parser.y (ALLOC_CHUNK): Define.
	(struct demangle_info): Add PREV and NEXT.  Increase the size of
	COMPS.
	(d_grab): Convert to a function.
	(allocate_info): Rewrite.
	(cp_demangled_name_to_comp): Remove MEMORY argument.  Do not use
	strlen.  Update call to allocate_info.  Do not free it on failure.
	(main): Update calls to cp_demangled_name_to_comp.
	* Makefile.in (cp-support.o): Update.
@
text
@d2 2
a3 1
   Copyright (C) 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.24
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@a21 1
#include <ctype.h>
d35 2
d72 30
a101 2
/* Return the canonicalized form of STRING, or NULL if STRING can not be
   parsed.  The return value is allocated via xmalloc.
d103 3
a105 3
   drow/2005-03-07: Should we also return NULL for things that trivially do
   not require any change?  e.g. simple identifiers.  This could be more
   efficient.  */
a109 1
  void *storage;
d111 1
a112 1
  int len = strlen (string);
d114 2
a115 1
  len = len + len / 8;
d117 1
a117 1
  ret_comp = cp_demangled_name_to_comp (string, &storage, NULL);
d121 2
a122 1
  ret = cp_comp_to_string (ret_comp, len);
d124 5
a128 1
  xfree (storage);
d165 1
a165 1
  ret = cp_demangled_name_to_comp (demangled_name, memory, NULL);
a357 1
  void *storage;
d362 1
a362 1
  ret_comp = cp_demangled_name_to_comp (full_name, &storage, NULL);
a371 1
  xfree (storage);
a383 1
  void *storage;
d389 1
a389 1
  ret_comp = cp_demangled_name_to_comp (demangled_name, &storage, NULL);
a414 1
  xfree (storage);
d544 1
a544 1
	      while (isspace(name[index]))
@


1.23
log
@	* objfiles.h (ALL_PRIMARY_SYMTABS): Define.

	* ada-lang.c (symtab_for_sym, ada_lookup_symbol_list)
	(ada_lookup_symbol): Use ALL_PRIMARY_SYMTABS.
	* cp-support.c (make_symbol_overload_list_qualified): Likewise.
	* symtab.c (lookup_symbol_aux_block, lookup_symbol_aux_symtabs)
	(basic_lookup_transparent_type, find_pc_sect_symtab, search_symbols)
	(make_symbol_completion_list): Likewise.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.22
log
@Copyright updates for 2007.
@
text
@d753 1
a753 1
  ALL_SYMTABS (objfile, s)
d767 1
a767 1
  ALL_SYMTABS (objfile, s)
@


1.21
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
@


1.20
log
@	* cp-support.c (cp_class_name_from_physname): Rewrite.
	(unqualified_name_from_comp): New function, broken out from
	method_name_from_physname.  Correct handling for typed names
	and templates.
	(method_name_from_physname): Use unqualified_name_from_comp.
	(cp_func_name, remove_params): Move earlier in the file.  Add
	better comments.  Use the component tree to parse the name.
	(_initialize_cp_support): Remove stray whitespace.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.19
log
@	* Makefile.in (SFILES): Add cp-names.y.
	(libiberty_h, safe_ctype_h): New.
	(YYFILES): Add cp-names.c.
	(YYOBJ): Add cp-names.o.
	(test-cp-names.o, test-cp-names$(EXEEXT), cp-names.o): New rules.
	(clean): Remove test-cp-names$(EXEEXT).
	(local-maintainer-clean): Remove cp-names.c.
	* cp-names.y: New file.
	* cp-support.c (find_last_component): Delete.
	(d_left, d_right): Define.
	(cp_canonicalize_string, mangled_name_to_comp): New functions.
	(cp_class_name_from_physname, method_name_from_physname): Rewrite
	to use mangled_name_to_comp.
	* cp-support.h (cp_canonicalize_string, cp_demangled_name_to_comp)
	(cp_comp_to_string): New prototypes.
	* config/djgpp/fnchange.lst: Add cp-names.c.
@
text
@a53 2
static char *remove_params (const char *demangled_name);

d152 1
a152 1
  struct demangle_component *ret_comp, *prev_comp;
d161 2
a162 1
  prev_comp = NULL;
a165 9
      case DEMANGLE_COMPONENT_TYPED_NAME:
	prev_comp = NULL;
        ret_comp = d_right (ret_comp);
        break;
      case DEMANGLE_COMPONENT_QUAL_NAME:
      case DEMANGLE_COMPONENT_LOCAL_NAME:
	prev_comp = ret_comp;
        ret_comp = d_right (ret_comp);
        break;
a172 1
	prev_comp = NULL;
d175 29
a204 1
      case DEMANGLE_COMPONENT_TEMPLATE:
d213 1
a213 2
	prev_comp = NULL;
	ret_comp = NULL;
d218 1
a218 1
  if (prev_comp != NULL)
d220 1
d223 1
a223 1
      ret = cp_comp_to_string (prev_comp, 10);
d232 3
a234 1
/* Return the name of the method whose linkage name is PHYSNAME.  */
d236 2
a237 2
char *
method_name_from_physname (const char *physname)
d239 1
a239 3
  void *storage;
  char *demangled_name = NULL, *ret;
  struct demangle_component *ret_comp;
a241 5
  ret_comp = mangled_name_to_comp (physname, DMGL_ANSI, &storage,
				   &demangled_name);
  if (ret_comp == NULL)
    return NULL;

d243 1
d249 2
d252 1
a252 1
        ret_comp = d_right (ret_comp);
d254 5
a268 1
      case DEMANGLE_COMPONENT_TEMPLATE:
d276 1
a276 2
	done = 1;
	ret_comp = NULL;
d280 26
d317 73
a598 28
/* If FULL_NAME is the demangled name of a C++ function (including an
   arg list, possibly including namespace/class qualifications),
   return a new string containing only the function name (without the
   arg list/class qualifications).  Otherwise, return NULL.  The
   caller is responsible for freeing the memory in question.  */

char *
cp_func_name (const char *full_name)
{
  const char *previous_component = full_name;
  const char *next_component;

  if (!full_name)
    return NULL;

  for (next_component = (previous_component
			 + cp_find_first_component (previous_component));
       *next_component == ':';
       next_component = (previous_component
			 + cp_find_first_component (previous_component)))
    {
      /* Skip '::'.  */
      previous_component = next_component + 2;
    }

  return remove_params (previous_component);
}

a600 42
static char *
remove_params (const char *demangled_name)
{
  const char *argp;
  char *new_name;
  int depth;

  if (demangled_name == NULL)
    return NULL;

  /* First find the end of the arg list.  */
  argp = strrchr (demangled_name, ')');
  if (argp == NULL)
    return NULL;

  /* Back up to the beginning.  */
  depth = 1;

  while (argp-- > demangled_name)
    {
      if (*argp == ')')
	depth ++;
      else if (*argp == '(')
	{
	  depth --;

	  if (depth == 0)
	    break;
	}
    }
  if (depth != 0)
    internal_error (__FILE__, __LINE__,
		    _("bad demangled name %s\n"), demangled_name);
  while (argp[-1] == ' ' && argp > demangled_name)
    argp --;

  new_name = xmalloc (argp - demangled_name + 1);
  memcpy (new_name, demangled_name, argp - demangled_name);
  new_name[argp - demangled_name] = '\0';
  return new_name;
}

a887 1
		  
@


1.18
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d2 1
a2 1
   Copyright 2002, 2003 Free Software Foundation, Inc.
d38 3
a42 2
static const char *find_last_component (const char *name);

d75 2
a76 2
/* Here are some random pieces of trivia to keep in mind while trying
   to take apart demangled names:
d78 3
a80 3
   - Names can contain function arguments or templates, so the process
     has to be, to some extent recursive: maybe keep track of your
     depth based on encountering <> and ().
d82 7
a88 8
   - Parentheses don't just have to happen at the end of a name: they
     can occur even if the name in question isn't a function, because
     a template argument might be a type that's a function.

   - Conversely, even if you're trying to deal with a function, its
     demangled name might not end with ')': it could be a const or
     volatile class method, in which case it ends with "const" or
     "volatile".
d90 1
a90 3
   - Parentheses are also used in anonymous namespaces: a variable
     'foo' in an anonymous namespace gets demangled as "(anonymous
     namespace)::foo".
d92 3
a94 1
   - And operator names can contain parentheses or angle brackets.  */
d96 1
a96 3
/* FIXME: carlton/2003-03-13: We have several functions here with
   overlapping functionality; can we combine them?  Also, do they
   handle all the above considerations correctly?  */
d98 1
a98 3
/* Find the last component of the demangled C++ name NAME.  NAME
   must be a method name including arguments, in order to correctly
   locate the last component.
d100 2
a101 2
   This function return a pointer to the first colon before the
   last component, or NULL if the name had only one component.  */
d103 25
a127 5
static const char *
find_last_component (const char *name)
{
  const char *p;
  int depth;
d129 7
a135 9
  /* Functions can have local classes, so we need to find the
     beginning of the last argument list, not the end of the first
     one.  */
  p = name + strlen (name) - 1;
  while (p > name && *p != ')')
    p--;

  if (p == name)
    return NULL;
d137 1
a137 5
  /* P now points at the `)' at the end of the argument list.  Walk
     back to the beginning.  */
  p--;
  depth = 1;
  while (p > name && depth > 0)
d139 2
a140 5
      if (*p == '<' || *p == '(')
	depth--;
      else if (*p == '>' || *p == ')')
	depth++;
      p--;
d143 2
a144 10
  if (p == name)
    return NULL;

  while (p > name && *p != ':')
    p--;

  if (p == name || p == name + 1 || p[-1] != ':')
    return NULL;

  return p - 1;
d152 8
a159 6
  char *ret = NULL;
  const char *end;
  int depth = 0;
  char *demangled_name = cplus_demangle (physname, DMGL_ANSI | DMGL_PARAMS);

  if (demangled_name == NULL)
d162 50
a211 9
  end = find_last_component (demangled_name);
  if (end != NULL)
    {
      ret = xmalloc (end - demangled_name + 1);
      memcpy (ret, demangled_name, end - demangled_name);
      ret[end - demangled_name] = '\0';
    }

  xfree (demangled_name);
d220 63
a282 4
  char *ret = NULL;
  const char *end;
  int depth = 0;
  char *demangled_name = cplus_demangle (physname, DMGL_ANSI | DMGL_PARAMS);
d284 4
a287 2
  if (demangled_name == NULL)
    return NULL;
d289 3
a291 5
  end = find_last_component (demangled_name);
  if (end != NULL)
    {
      char *args;
      int len;
d293 1
a293 2
      /* Skip "::".  */
      end = end + 2;
d295 3
a297 15
      /* Find the argument list, if any.  */
      args = strchr (end, '(');
      if (args == NULL)
	len = strlen (end + 2);
      else
	{
	  args --;
	  while (*args == ' ')
	    args --;
	  len = args - end + 1;
	}
      ret = xmalloc (len + 1);
      memcpy (ret, end, len);
      ret[len] = 0;
    }
a298 3
  xfree (demangled_name);
  return ret;
}
@


1.17
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d749 1
a749 1
		  "C++ maintenance commands.", &maint_cplus_cmd_list,
@


1.16
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d754 1
a754 1
	   "Print the first class/namespace component of NAME.",
@


1.15
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d723 1
a723 1
  printf_unfiltered ("\"maintenance cplus\" must be followed by the name of a command.\n");
@


1.14
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d459 1
a459 1
		    "bad demangled name %s\n", demangled_name);
@


1.13
log
@
2004-07-06  Jeff Johnston <jjohnstn@@redhat.com>

        * language.h (struct_language_defn): Add new function pointer:
        la_class_name_from_physname.  Also add new prototype for
        language_class_name_from_physname.
        * language.c (language_class_name_from_physname): New function.
        (unk_lang_class_name): Ditto.
        (unknown_language_defn, auto_language_defn): Change
        to add unk_lang_class_name function pointer for
        la_class_name_from_physname.
        (local_language_defn): Ditto.
        * dwarf2read.c (guess_structure_name): Change to call
        language_class_name_from_physname.
        (determine_class_name): Ditto.
        * cp-support.c (class_name_from_physname): Renamed.
        (cp_class_name_from_physname): New name of function.
        * cp-support.h: Ditto.
        * c-lang.c (c_language_defn): Change to add NULL
        for class_name_from_physname function pointer.
        (cplus_language_defn): Change to add cp_class_name_from_physname.
        * jv-lang.c (java_class_name_physname): New function.
        (java_find_last_component): New static routine.
        (java_language_defn): Add java_class_name_from_physname pointer.
        * ada-lang.c (ada_language_defn): Change to add NULL
        for class_name_from_physname function pointer.
        * f-lang.c (f_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * scm-lang.c (scm_language_defn): Ditto.
@
text
@d687 1
a687 1
      warning ("RTTI symbol not found for class '%s'", name);
d693 1
a693 1
      warning ("RTTI symbol for class '%s' is not a type", name);
d708 1
a708 1
      warning ("RTTI symbol for class '%s' is a namespace", name);
d711 1
a711 1
      warning ("RTTI symbol for class '%s' has bad type", name);
@


1.12
log
@2004-02-02  David Carlton  <carlton@@kealia.com>

	* valops.c (enum oload_classification): New.
	(find_overload_match): Break implementation into separate
	functions; delete #if 0'd code; look for symbols within
	namespaces.
	(find_oload_champ_namespace,find_oload_champ_namespace_loop)
	(find_oload_champ,oload_method_static,classify_oload_match): New.
	* cp-support.h: Add declaration for cp_func_name; update
	declaration for make_symbol_overload_list.
	* cp-support.c (cp_func_name): New.
	(overload_list_add_symbol): Fix comment, use
	SYMBOL_LINKAGE_NAME and SYMBOL_NATURAL_NAME.
	(make_symbol_overload_list): Take a function name and a namespace
	instead of a symbol; change implementation.
	(make_symbol_overload_list_using): New.
	(make_symbol_overload_list_qualified, read_in_psymtabs): New.

2004-02-02  David Carlton  <carlton@@kealia.com>

	* gdb.cp/overload.exp: Add overloadNamespace tests.
	* gdb.cp/overload.cc (dummyClass, dummyInstance): New.
	(overloadNamespace, XXX): New.
	(main): Call XXX::marker2.
@
text
@d151 1
a151 1
class_name_from_physname (const char *physname)
@


1.12.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d151 1
a151 1
cp_class_name_from_physname (const char *physname)
@


1.11
log
@2003-12-16  David Carlton  <carlton@@kealia.com>

	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS.
	(method_name_from_physname): Ditto.
@
text
@d55 9
a63 1
static void overload_list_add_symbol (struct symbol *sym, char *oload_name);
d397 28
d469 3
a471 3
/*  Test to see if the symbol specified by SYMNAME (which is already
   demangled for C++ symbols) matches SYM_TEXT in the first SYM_TEXT_LEN
   characters.  If so, add it to the current completion list. */
d474 1
a474 1
overload_list_add_symbol (struct symbol *sym, char *oload_name)
d486 2
a487 1
    if (!strcmp (DEPRECATED_SYMBOL_NAME (sym), DEPRECATED_SYMBOL_NAME (sym_return_val[i])))
d491 1
a491 1
  sym_name = remove_params (SYMBOL_DEMANGLED_NAME (sym));
d516 1
a516 4
 * match name of the supplied symbol FSYM.
 * This is used in finding all overloaded instances of a function name.
 * This has been modified from make_symbol_completion_list.  */

d519 2
a520 1
make_symbol_overload_list (struct symbol *fsym)
d522 21
a542 10
  struct symbol *sym;
  struct symtab *s;
  struct partial_symtab *ps;
  struct objfile *objfile;
  struct block *b, *surrounding_static_block = 0;
  struct dict_iterator iter;
  /* The name we are completing on. */
  char *oload_name = NULL;
  /* Length of name.  */
  int oload_name_len = 0;
d544 5
a548 1
  /* Look for the symbol we are supposed to complete on.  */
d550 7
a556 2
  oload_name = remove_params (SYMBOL_DEMANGLED_NAME (fsym));
  if (!oload_name)
d558 6
a563 4
      sym_return_val_size = 1;
      sym_return_val = (struct symbol **) xmalloc (2 * sizeof (struct symbol *));
      sym_return_val[0] = fsym;
      sym_return_val[1] = NULL;
d565 14
a578 1
      return sym_return_val;
d580 1
a580 6
  oload_name_len = strlen (oload_name);

  sym_return_val_size = 100;
  sym_return_val_index = 0;
  sym_return_val = (struct symbol **) xmalloc ((sym_return_val_size + 1) * sizeof (struct symbol *));
  sym_return_val[0] = NULL;
d582 3
a584 2
  /* Read in all partial symtabs containing a partial symbol named
     OLOAD_NAME.  */
d586 9
a594 3
  ALL_PSYMTABS (objfile, ps)
  {
    struct partial_symbol **psym;
d596 2
a597 4
    /* If the psymtab's been read in we'll get it when we search
       through the blockvector.  */
    if (ps->readin)
      continue;
d599 1
a599 6
    if ((lookup_partial_symbol (ps, oload_name, NULL, 1, VAR_DOMAIN)
	 != NULL)
	|| (lookup_partial_symbol (ps, oload_name, NULL, 0, VAR_DOMAIN)
	    != NULL))
      PSYMTAB_TO_SYMTAB (ps);
  }
d606 1
a606 4
      if (!BLOCK_SUPERBLOCK (b))
	{
	  surrounding_static_block = b;		/* For elimination of dups */
	}
d608 3
a610 4
      /* Also catch fields of types defined in this places which match our
         text string.  Only complete on types visible from current context. */

      ALL_BLOCK_SYMBOLS (b, iter, sym)
d612 1
a612 1
	  overload_list_add_symbol (sym, oload_name);
d616 2
d625 8
a632 4
    ALL_BLOCK_SYMBOLS (b, iter, sym)
      {
	overload_list_add_symbol (sym, oload_name);
      }
d642 8
a649 4
    ALL_BLOCK_SYMBOLS (b, iter, sym)
      {
	overload_list_add_symbol (sym, oload_name);
      }
d651 10
d662 4
a665 1
  xfree (oload_name);
d667 6
a672 1
  return (sym_return_val);
@


1.10
log
@2003-12-04  Michael Chastain  <mec.gnu@@mindspring.com>

	Partial fix for PR c++/1465.
	Fix for PR c++/1377.
	* cp-support.h (cp_lookup_rtti_type): New function.
	* cp-support.c (cp_lookup_rtti_type): New function.
	* gnu-v2-abi.c: Update copyright years.
	(gnuv2_rtti_type): Call cp_lookup_rtti_type.
	* gnu-v3-abi.c: Update copyright years.
	(gnuv3_rtti_type): Call cp_lookup_rtti_type.
@
text
@d148 1
a148 1
  char *demangled_name = cplus_demangle (physname, DMGL_ANSI);
d173 1
a173 1
  char *demangled_name = cplus_demangle (physname, DMGL_ANSI);
@


1.9
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d36 1
d586 42
@


1.8
log
@2003-09-11  David Carlton  <carlton@@kealia.com>

	* gdbtypes.h: Add TYPE_CODE_NAMESPACE.
	* gdbtypes.c (init_type): Handle TYPE_CODE_NAMESPACE.
	(recursive_dump_type): Ditto.
	* printcmd.c (print_formatted): Ditto.
	* typeprint.c (print_type_scalar): Ditto.
	* c-typeprint.c (c_type_print_varspec_prefix): Ditto.
	(c_type_print_varspec_suffix, c_type_print_base): Ditto.
	* cp-support.h: Declare cp_check_possible_namespace_symbols,
	maint_cplus_cmd_list.
	* cp-support.c: Make maint_cplus_cmd_list extern.
	* cp-namespace.c: Include objfiles.h, gdbtypes.h, dictionary.h,
	command.h.
	(lookup_symbol_file): Look in possible namespace blocks when
	appropriate.
	(initialize_namespace_symtab): New.
	(get_possible_namespace_block, free_namespace_block)
	(check_possible_namespace_symbols)
	(check_possible_namespace_symbols_loop)
	(check_one_possible_namespace_symbol)
	(lookup_possible_namespace_symbol, maintenance_cplus_namespace)
	(_initialize_cp_namespace): Ditto.
	* block.h: Declare allocate_block.
	* block.c (allocate_block): New.
	* jv-lang.c (get_java_class_symtab): Allocate blocks via
	allocate_block.
	* symfile.h: Update declaration of add_psymbol_to_list.
	* symfile.c (add_psymbol_to_list): Return the partial symbol in
	question.
	* dwarf2read.c (dwarf2_build_psymtabs_hard): Add argument to
	scan_partial_symbols_call.
	(scan_partial_symbols): Add NAMESPACE argument; update calls to
	helper functions.
	(add_partial_symbol): If necessary, scan mangled names for names
	of namespaces.
	(add_partial_namespace): Add NAMESPACE argument; generate partial
	symbols associated  to namespaces.
	(add_partial_enumeration): Add NAMESPACE argument.
	(new_symbol): Allow namespace syms.
	(read_namespace): Generate namespace syms.
	* objfiles.h: Add opaque declaration of struct symtab.
	(struct objfile): Add cp_namespace_symtab member.
	* objfiles.c (allocate_objfile): Set
	objfile->cp_namespace_symtab.
	* Makefile.in (cp-namespace.o): Depend on objfiles_h, gdbtypes_h,
	dictionary_h, command_h.

2003-09-11  David Carlton  <carlton@@kealia.com>

	* gdb.c++/namespace.exp: Add tests for namespace types.
	* gdb.c++/maint.exp (test_help): Test 'help maint cp namespace'.
	(test_namespace): New.
@
text
@d486 5
a490 5
  register struct symbol *sym;
  register struct symtab *s;
  register struct partial_symtab *ps;
  register struct objfile *objfile;
  register struct block *b, *surrounding_static_block = 0;
@


1.7
log
@Fix indentation of previous commit.
@
text
@d58 1
a58 1
static struct cmd_list_element *maint_cplus_cmd_list = NULL;
@


1.6
log
@2003-06-30  David Carlton  <carlton@@kealia.com>

	Band-aid for PR c++/1245.
	* Makefile.in (cp-support.o): Depend on complaints_h.
	* cp-support.c: Include complaints.h.  Add declaration for
	find_last_component.
	(cp_find_first_component): Separate code into
	cp_find_first_component_aux.
	(cp_find_first_component_aux): Call demangled_name_complaint.
	(demangled_name_complaint): New.

2003-06-30  David Carlton  <carlton@@kealia.com>

	* gdb.c++/maint.exp (test_invalid_name): New.
	(test_first_component): Add tests for invalid names.
@
text
@d290 1
a290 1
	      return index;
@


1.5
log
@2003-06-12  David Carlton  <carlton@@bactrian.org>

	* symtab.h: Delete declaration of make_symbol_overload_list.
	Add declaration of lookup_partial_symbol.
	* symtab.c (remove_params): Move to cp-support.c.
	(overload_list_add_symbol, make_symbol_overload_list)
	(sym_return_val_size, sym_return_val_index): Ditto.
	(lookup_partial_symbol): Make extern.
	* cp-support.h: Add declaration of make_symbol_overload_list.
	* cp-support.c: Include dictionary.h, objfiles.h, frame.h,
	symtab.h, and block.h.
	(remove_params): Move here from symtab.c.
	(overload_list_add_symbol, make_symbol_overload_list)
	(sym_return_val_size, sym_return_val_index): Ditto.
	* valops.c: Include cp-support.h.
	* Makefile.in (cp-support.o): Depend on dictionary_h, objfiles_h,
	frame_h, and block_h.
	(valops.o): Depend on cp_support_h.
@
text
@d35 10
d212 2
a213 3
/* Well, that's what it should do when called externally, but to make
   the recursion easier, it also stops if it reaches an unexpected ')'
   or '>'.  */
d217 14
a230 2
   user-generated input, because some of the 'index += 2' lines might
   go past the end of malformed input.  */
d236 2
a237 2
unsigned int
cp_find_first_component (const char *name)
d258 1
a258 1
	  for (index += cp_find_first_component (name + index);
d260 1
a260 1
	       index += cp_find_first_component (name + index))
d262 5
a266 1
	      gdb_assert (name[index] == ':');
d274 1
a274 1
	  for (index += cp_find_first_component (name + index);
d276 1
a276 1
	       index += cp_find_first_component (name + index))
d278 5
a282 1
	      gdb_assert (name[index] == ':');
d289 7
d352 10
@


1.5.4.1
log
@2003-06-30  David Carlton  <carlton@@kealia.com>

	Band-aid for PR c++/1245.
	* Makefile.in (cp-support.o): Depend on complaints_h.
	* cp-support.c: Include complaints.h.  Add declaration for
	find_last_component.
	(cp_find_first_component): Separate code into
	cp_find_first_component_aux.
	(cp_find_first_component_aux): Call demangled_name_complaint.
	(demangled_name_complaint): New.

2003-06-30  David Carlton  <carlton@@kealia.com>

	* gdb.c++/maint.exp (test_invalid_name): New.
	(test_first_component): Add tests for invalid names.
@
text
@a34 10
#include "complaints.h"

/* Functions related to demangled name parsing.  */

static const char *find_last_component (const char *name);

static unsigned int cp_find_first_component_aux (const char *name,
						 int permissive);

static void demangled_name_complaint (const char *name);
d202 3
a204 2
/* The character in NAME indexed by the return value is guaranteed to
   always be either ':' or '\0'.  */
d208 2
a209 14
   user-generated input, because some of the 'index += 2' lines in
   cp_find_first_component_aux might go past the end of malformed
   input.  */

unsigned int
cp_find_first_component (const char *name)
{
  return cp_find_first_component_aux (name, 0);
}

/* Helper function for cp_find_first_component.  Like that function,
   it returns the length of the first component of NAME, but to make
   the recursion easier, it also stops if it reaches an unexpected ')'
   or '>' if the value of PERMISSIVE is nonzero.  */
d215 2
a216 2
static unsigned int
cp_find_first_component_aux (const char *name, int permissive)
d237 1
a237 1
	  for (index += cp_find_first_component_aux (name + index, 1);
d239 1
a239 1
	       index += cp_find_first_component_aux (name + index, 1))
d241 1
a241 5
	      if (name[index] != ':')
		{
		  demangled_name_complaint (name);
		  return strlen (name);
		}
d249 1
a249 1
	  for (index += cp_find_first_component_aux (name + index, 1);
d251 1
a251 1
	       index += cp_find_first_component_aux (name + index, 1))
d253 1
a253 5
	      if (name[index] != ':')
		{
		  demangled_name_complaint (name);
		  return strlen (name);
		}
a259 7
	  if (permissive)
	    return index;
	  else
	    {
	      demangled_name_complaint (name);
	      return strlen (name);
	    }
a315 10
}

/* Complain about a demangled name that we don't know how to parse.
   NAME is the demangled name in question.  */

static void
demangled_name_complaint (const char *name)
{
  complaint (&symfile_complaints,
	     "unexpected demangled name '%s'", name);
@


1.4
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* acinclude.m4 (gcc_AC_CHECK_DECL, (gcc_AC_CHECK_DECL): Stolen
	from GCC's acinclude.m4.
	* configure.in: Check for getopt's delcaration.
	* aclocal.m4, config.in, configure: Re-generate.
	* main.c (error_init): Delete declaration.
	* defs.h (error_init): Declare.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Make static.
	(rs6000_convert_from_func_ptr_addr): Make static.
	(_initialize_rs6000_tdep): Add declaration.
	* cli/cli-cmds.c (dont_repeat): Delete declaration.
	(show_commands, set_verbose, show_history): Delete declaration.
	* top.h (set_verbose): Add declaration.
	(show_history, set_history, show_commands): Add declaration.
	(do_restore_instream_cleanup): Add declaration.
	* objc-lang.c (specialcmp): Make static.
	(print_object_command): Make static.
	(find_objc_msgsend): Make static.
	(find_objc_msgcall_submethod_helper): Make static.
	(find_objc_msgcall_submethod): Make static.
	(_initialize_objc_language): Add declaration.
	(find_implementation_from_class): Make static.
	(find_implementation): Make static.
	* objc-exp.y (yylex): Delete lookup_struct_typedef declaration.
	* objc-lang.h (lookup_struct_typedef): Add declaration.
	* cli/cli-interp.c (_initialize_cli_interp): Add declaration.
	* cli/cli-script.c (clear_hook_in_cleanup): Make static.
	(do_restore_user_call_depth): Make static.
	(do_restore_instream_cleanup): Delete declaration.
	(dont_repeat): Delete declaration.
	* cli/cli-decode.c (add_abbrev_cmd): Delete function.
	* cli/cli-dump.c (_initialize_cli_dump): Add declaration.
	* reggroups.c (_initialize_reggroup): Add declaration.
	* cp-support.c (_initialize_cp_support): Add declaration.
	* cp-abi.c (_initialize_cp_abi): Add declaration.
	* hpacc-abi.c (_initialize_hpacc_abi): Add declaration.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Make static.
	(_initialize_gnu_v3_abi): Add declaration.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Make static.
	(_initialize_gnu_v2_abi): Add declaration.
	* frame-base.c (_initialize_frame_base): Add declaration.
	* doublest.c (floatformat_from_length): Make static.
	* frame-unwind.c (_initialize_frame_unwind): Add declaration.
	* frame.c (create_sentinel_frame): Make static.
	(_initialize_frame): Add declaration.
	* top.c (do_catch_errors): Make static.
	(gdb_rl_operate_and_get_next_completion): Make static.
	* typeprint.c: Include "typeprint.h".
	* sentinel-frame.c (sentinel_frame_prev_register): Make static.
	(sentinel_frame_this_id): Make static.
	* p-valprint.c (_initialize_pascal_valprint): Add declaration.
	* ui-out.c (make_cleanup_ui_out_begin_end): Delete function.
	* dwarf2-frame.c (dwarf2_frame_cache): Make static.
	* p-exp.y (push_current_type, pop_current_type): ISO C declaration.
	* dwarf2expr.h (dwarf_expr_context): ISO C declaration.
	* maint.c (maintenance_print_architecture): Make static.
	* signals/signals.c (_initialize_signals): Add declaration.
	* std-regs.c (_initialize_frame_reg): Add declaration.
	* jv-exp.y (push_variable): ISO C definition.
	(push_qualified_expression_name): Ditto.
	* memattr.c (_initialize_mem): Add declaration.
	* remote.c (remote_check_watch_resources): Make static.
	(remote_stopped_by_watchpoint): Make static.
	(remote_stopped_data_address): Make static.
	* d10v-tdep.c (nr_dmap_regs): Make static.
	(a0_regnum): Make static.
	(d10v_frame_unwind_cache): Make static.
	(d10v_frame_p): Make static.
	* osabi.c (show_osabi): Make static.
	(_initialize_gdb_osabi): Add extern declaration.
	* gdbtypes.c (make_qualified_type): Make static.
	(safe_parse_type): Make static.
	* macrocmd.c (_initialize_macrocmd): Add extern declaration.
	* macrotab.c (macro_bcache_free): Make static.
	* interps.c (interp_set_quiet): Make static.
	(interpreter_exec_cmd): Make static.
	* stack.h (select_frame_command): New file.
	* stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete function.
	(select_frame_command): Make global.
	* infcall.c: Include "infcall.h".
	* linespec.c: Include "linespec.h".
	* symfile.c (sections_overlap): Make static.
	* cp-support.h (cp_initialize_namespace): ISO C declaration.
	* charset.c (_initialize_charset): Add missing prototype.
	* regcache.c (init_legacy_regcache_descr): Make static.
	(do_regcache_xfree): Make static.
	(regcache_xfer_part): Make static.
	(_initialize_regcache): Add missing prototype.
	* breakpoint.c (parse_breakpoint_sals): Make static.
	(breakpoint_sals_to_pc): Make static.
	* interps.h (clear_interpreter_hooks): ISO C declaration.
	* Makefile.in (stack_h): Define.
	(stack.o, typeprint.o, mi-main.o): Update dependencies.
	(mi-cmd-stack.o, infcall.o, linespec.o): Update dependencies.

Index: mi/ChangeLog
2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-parse.c (_initialize_mi_parse): Delete function.
	* mi-main.c: Include "mi-main.h".
	* mi-interp.c (_initialize_mi_interp): Add declaration.
	* mi-cmd-stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete extern declaration.
	(mi_cmd_stack_select_frame): Replace select_frame_command_wrapper
	with select_frame_command.
@
text
@d30 15
d341 198
@


1.3
log
@2003-04-23  David Carlton  <carlton@@bactrian.org>

	* cp-support.c (cp_find_first_component): Accept 'operator' in
	more locations.

2003-04-23  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/maint.exp (test_first_component): Add tests for
	'operator' in more locations.
@
text
@d352 2
@


1.3.8.1
log
@Snap const char * mess.
@
text
@d37 2
a38 2
static void maint_cplus_command (const char *arg, int from_tty);
static void first_component_command (const char *arg, int from_tty);
d330 1
a330 1
maint_cplus_command (const char *arg, int from_tty)
d341 1
a341 1
first_component_command (const char *arg, int from_tty)
@


1.2
log
@2003-04-15  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add cp-namespace.c.
	(COMMON_OBS): Add cp-namespace.o.
	(block.o): Depend on gdb_obstack_h and cp_support_h.
	(buildsym.o): Depend on cp_support_h.
	(cp-namespace.o): New.
	(cp-support.o): Depend on gdb_string_h, demangle_h, gdb_assert_h,
	gdb_obstack_h, symtab_h, symfile_h, and gdbcmd_h.
	(dwarf2read.o): Depend on cp_support_h.
	* jv-lang.c (get_java_class_symtab): Set BLOCK_NAMESPACE.
	* dwarf2read.c (process_die): Set processing_has_namespace_info,
	processing_current_namespace.
	(read_namespace): Update processing_current_namespace; check for
	anonymous namespaces.
	(dwarf2_name): New function.
	(dwarf2_extension): Ditto.
	* cp-support.h: Update copyright, contributors.
	Add inclusion guards.
	Add opaque declaration for structs obstack, block, symbol.
	(struct using_direct): New struct.
	Add declarations for cp_find_first_component,
	cp_entire_prefix_len, processing_has_namespace_info,
	processing_current_namespace, cp_is_anonymous,
	cp_add_using_directive, cp_initialize_namespace,
	cp_finalize_namespace, cp_set_block_scope,
	cp_scan_for_anonymous_namespaces.
	* cp-namespace.c: New file.
	* cp-support.c: Update copyright.
	Include ctype.h, gdb_assert.h, gdbcmd.h.
	New variable maint_cplus_cmd_list.
	(cp_find_first_component): New function.
	(cp_entire_prefix_len, maint_cplus_command)
	(first_component_command, _initialize_cp_support): Ditto.
	* buildsym.c: Include cp-support.h.
	New variable using_list.
	(add_symbol_to_list): Check for anonymous namespaces.
	(finish_block): Set block's scope.
	(start_symtab): Initialize C++ namespace support.
	(end_symtab): Finalize C++ namespace support.
	* block.h: Add opaque declarations for structs
	block_namespace_info, using_direct, and obstack.
	Add declarations for block_set_scope and block_set_using.
	(struct block): Add 'language_specific' member.
	(BLOCK_NAMESPACE): New macro.
	* block.c: Include gdb_obstack.h and cp-support.h.
	(struct block_namespace_info): New struct.
	(block_set_scope): New function.
	(block_set_using, block_initialize_namespace): Ditto.

2003-04-15  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/maint.exp: New file.
@
text
@d60 1
a60 10
   - And operator names can contain parentheses or angle brackets.
     Fortunately, I _think_ that operator names can only occur in a
     fairly restrictive set of locations (in particular, they have be
     at depth 0, don't they?).  */

/* NOTE: carlton/2003-02-21: Daniel Jacobowitz came up with an example
   where operator names don't occur at depth 0.  Sigh.  (It involved a
   template argument that was a pointer: I hadn't realized that was
   possible.)  Handling such edge cases does not seem like a
   high-priority problem to me.  */
a202 4
  /* Names like 'operator<<' screw up the recursion, so let's
     special-case them.  I _hope_ they can only occur at the start of
     a component.  */

d204 7
a210 29

  if (strncmp (name, "operator", LENGTH_OF_OPERATOR) == 0)
    {
      index += LENGTH_OF_OPERATOR;
      while (isspace(name[index]))
	++index;
      switch (name[index])
	{
	case '<':
	  if (name[index + 1] == '<')
	    index += 2;
	  else
	    index += 1;
	  break;
	case '>':
	case '-':
	  if (name[index + 1] == '>')
	    index += 2;
	  else
	    index += 1;
	  break;
	case '(':
	  index += 2;
	  break;
	default:
	  index += 1;
	  break;
	}
    }
d229 1
d241 1
d248 48
d297 1
@


1.2.2.1
log
@Merge from mainline.
@
text
@d60 10
a69 1
   - And operator names can contain parentheses or angle brackets.  */
d212 4
d217 29
a245 7
  /* Operator names can show up in unexpected places.  Since these can
     contain parentheses or angle brackets, they can screw up the
     recursion.  But not every string 'operator' is part of an
     operater name: e.g. you could have a variable 'cooperator'.  So
     this variable tells us whether or not we should treat the string
     'operator' as starting an operator.  */
  int operator_possible = 1;
a263 1
	  operator_possible = 1;
a274 1
	  operator_possible = 1;
a280 48
	case 'o':
	  /* Operator names can screw up the recursion.  */
	  if (operator_possible
	      && strncmp (name + index, "operator", LENGTH_OF_OPERATOR) == 0)
	    {
	      index += LENGTH_OF_OPERATOR;
	      while (isspace(name[index]))
		++index;
	      switch (name[index])
		{
		  /* Skip over one less than the appropriate number of
		     characters: the for loop will skip over the last
		     one.  */
		case '<':
		  if (name[index + 1] == '<')
		    index += 1;
		  else
		    index += 0;
		  break;
		case '>':
		case '-':
		  if (name[index + 1] == '>')
		    index += 1;
		  else
		    index += 0;
		  break;
		case '(':
		  index += 1;
		  break;
		default:
		  index += 0;
		  break;
		}
	    }
	  operator_possible = 0;
	  break;
	case ' ':
	case ',':
	case '.':
	case '&':
	case '*':
	  /* NOTE: carlton/2003-04-18: I'm not sure what the precise
	     set of relevant characters are here: it's necessary to
	     include any character that can show up before 'operator'
	     in a demangled name, and it's safe to include any
	     character that can't be part of an identifier's name.  */
	  operator_possible = 1;
	  break;
a281 1
	  operator_possible = 0;
@


1.1
log
@        * gdbtypes.c (check_stub_method): Make static.
        (check_stub_method_group): New function.
        * gdbtypes.h: Update prototypes.
        * cp-support.c: New file.
        * cp-support.h: New file.

        * stabsread.c: Include "cp-abi.h" and "cp-support.h".
        (update_method_name_from_physname): New function.
        (read_member_functions): Correct method names for operators
        and v3 constructors/destructors.  Separate v2 constructors and
        destructors.
        * Makefile.in (stabsread.o): Update dependencies.
        (SFILES): Add cp-support.c.
        (COMMON_OBS): Add cp-support.o.
        (cp_support_h, cp-support.o): Add.

        * cp-valprint.c (cp_print_class_method): Call
        check_stub_method_group instead of check_stub_method.  Remove
        extraneous QUITs.
        * p-valprint.c (pascal_object_print_class_method): Likewise.
        * valops.c (search_struct_method): Likewise.
        (find_method_list, value_struct_elt_for_reference): Likewise.
@
text
@d2 1
a2 1
   Copyright 2002 Free Software Foundation, Inc.
d24 1
d28 46
d188 160
@


1.1.6.1
log
@2002-10-22  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (buildsym.o): Depend on $(gdb_assert_h) and
	$(cp_support_h).
	(cp-support.o): Fix dependencies and add $(gdb_obstack_h) and
	$(gdb_assert_h).
	(symtab.o): Depend on $(cp_support_h).
	* symtab.h: Add opaque declaration for struct using_direct_node.
	(struct block): Add member 'language_specific'.
	(BLOCK_USING): New macro.
	* symtab.c: #include "cp-support.h"
	(lookup_symbol_aux): Call lookup_symbol_aux_nonlocal and
	lookup_symbol_aux_using when appropriate.
	(lookup_symbol_aux_nonlocal): New function.
	(lookup_symbol_aux_using): New function.
	(lookup_symbol_aux_using_loop): New function.
	* symfile.h: Add opaque declaration for struct obstack.
	Declare obsavestring to take a const char *.
	* symfile.c (obsavestring): Make first argument a const char *.
	* jv-lang.c (get_java_class_symtab): Initialize BLOCK_USING.
	* dwarf2read.c: New variable current_namespace.
	(scan_partial_symbols): Handle DW_TAG_namespace.
	(psymtab_to_symtab_1): Initialize current_namespace.
	(process_die): Handle DW_TAG_namespace,
	DW_TAG_imported_declaration, DW_TAG_imported_module.
	(read_namespace): New function.
	(dwarf2_name): New function.
	(dwarf2_extension): New function.
	(dwarf_tag_name): Add DWARF 3 names.
	(dwarf_attr_name): Ditto.
	(dwarf_type_encoding_name): Ditto.
	* cp-support.h: Opaque declaration for struct obstack.
	(struct using_direct): New struct.
	(struct using_direct_node): New struct.
	Add declarations for cp_add_using_obstack, cp_add_using_xmalloc,
	cp_copy_usings, cp_free_usings,	cp_find_first_component.
	* cp-support.c: #include "gdb_obstack.h", "gdb_assert.h".
	Comment on demangled name pitfalls.
	(cp_add_using_obstack): New function.
	(cp_add_using_xmalloc): New function.
	(cp_copy_usings): New function.
	(cp_free_usings): New function.
	(cp_find_first_component): New function.
	* buildsym.h: Declare processing_has_namespace_info.
	Declare add_using_directive.
	* buildsym.c: #include "gdb_assert.h", "cp-support.h".
	Change comment after #include "symfile.h".
	New variable using_list.
	(add_symbol_to_list): Scan for anonymous namespaces when
	appropriate.
	(scan_for_anonymous_namespaces): New function.
	(add_using_directive): New function.
	(start_symtab): Initialize processing_has_namespace_info,
	using_list.
	(end_symtab): Copy using_list into block.
	(copy_usings_to_obstack): New function.
	(finish_block): Set BLOCK_USING in general case and in C++
	function case.

2002-10-22  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Add tests involving namespaces
	  starting from C.
	* gdb.c++/namespace.cc: Add namespaces with names starting
	  from C and their contents.
@
text
@a26 30
#include "gdb_obstack.h"
#include "gdb_assert.h"

/* Here are some random pieces of trivia to keep in mind while trying
   to take apart demangled names:

   - Names can contain function arguments or templates, so the process
     has to be, to some extent recursive: maybe keep track of your
     depth based on encountering <> and ().

   - Parentheses don't just have to happen at the end of a name: they
     can occur even if the name in question isn't a function, because
     a template argument might be a type that's a function.

   - Conversely, even if you're trying to deal with a function, its
     demangled name might not end with ')': it could be a const (or
     volatile, I suppose) class method, in which case it ends with
     "const".

   - Parentheses are also used in anonymous namespaces: a variable
     'foo' in an anonymous namespace gets demangled as "(anonymous
     namespace)::foo".

   - And operator names can contain parentheses or angle brackets.
     Fortunately, I _think_ that operator names can only occur in a
     fairly restrictive set of locations (in particular, they have be
     at depth 0, don't they?).  */

/* FIXME: carlton/2002-10-09: Do all the functions here handle all the
   above considerations correctly?  */
a140 171
}

/* This allocates a new using_direct structure initialized to contain
   NAME, OUTER_LENGTH, and INNER_LENGTH, and puts it at the beginning
   of the linked list given by NEXT.  It returns the resulting struct
   using_direct_node.  All memory is allocated using OBSTACK.  */

struct using_direct_node *
cp_add_using_obstack (const char *name,
		      unsigned short outer_length,
		      unsigned short inner_length,
		      struct using_direct_node *next,
		      struct obstack *obstack)
{
  struct using_direct *current
    = obstack_alloc (obstack, sizeof (struct using_direct));
  struct using_direct_node *retval
    = obstack_alloc (obstack, sizeof (struct using_direct_node));

  gdb_assert (outer_length < inner_length);

  current->name = name;
  current->outer_length = outer_length;
  current->inner_length = inner_length;
  retval->current = current;
  retval->next = next;

  return retval;
}

/* Same as cp_add_using, except that it uses xmalloc instead of
   obstacks.  */

struct using_direct_node *
cp_add_using_xmalloc (const char *name,
		      unsigned short outer_length,
		      unsigned short inner_length,
		      struct using_direct_node *next)
{
  struct using_direct *current = xmalloc (sizeof (struct using_direct));
  struct using_direct_node *retval
    = xmalloc (sizeof (struct using_direct_node));

  gdb_assert (outer_length < inner_length);

  current->name = name;
  current->outer_length = outer_length;
  current->inner_length = inner_length;
  retval->current = current;
  retval->next = next;

  return retval;
}

/* This copies the using_direct_nodes in TOCOPY, using xmalloc, and
   sticks them onto a list ending in TAIL.  (It doesn't copy the
   using_directs, just the using_direct_nodes.)  */

struct using_direct_node *
cp_copy_usings (struct using_direct_node *tocopy,
		struct using_direct_node *tail)
{
  struct using_direct_node *new_node;
  
  if (tocopy == NULL)
    return tail;

  new_node = xmalloc (sizeof (struct using_direct_node));
  new_node->current = tocopy->current;
  new_node->next = cp_copy_usings (tocopy->next, tail);

  return new_node;
}

/* This xfree's all the using_direct_nodes in USING (but not their
   using_directs!)  */
void
cp_free_usings (struct using_direct_node *using)
{
  struct using_direct_node *next;

  if (using != NULL)
    {
      for (next = using->next; next;
	   using = next, next = next->next)
	xfree (using);
      
      xfree (using);
    }
}


/* This returns the first component of NAME, which should be the
   demangled name of a C++ variable/function/method/etc.
   Specifically, it returns a pointer to the first colon forming the
   boundary of the first component: so, given 'A::foo' or 'A::B::foo'
   it returns a pointer to the first :, and given 'foo', it returns a
   pointer to the trailing '\0'.  */

/* Well, that's what it should do when called externally, but to make
   the recursion easier, it also stops if it reaches an unexpected ')'
   or '>'.  */

/* Let's optimize away calls to strlen("operator").  */

#define LENGTH_OF_OPERATOR 8

const char *
cp_find_first_component (const char *name)
{
  /* Names like 'operator<<' screw up the recursion, so let's
     special-case them.  I _hope_ they can only occur at the start of
     a component.  */

  if (strncmp (name, "operator", LENGTH_OF_OPERATOR) == 0)
    {
      name += LENGTH_OF_OPERATOR;
      switch (*name)
	{
	case '<':
	  if (name[1] == '<')
	    name += 2;
	  else
	    name += 1;
	  break;
	case '>':
	case '-':
	  if (name[1] == '>')
	    name +=2;
	  else
	    name += 1;
	  break;
	case '(':
	  name += 2;
	  break;
	default:
	  name += 1;
	  break;
	}
    }

  for (;; ++name)
    {
      switch (*name)
	{
	case '<':
	  /* Template; eat it up.  The calls to cp_first_component
	     should only return (I hope!) when they reach the '>'
	     terminating the component or a '::' between two
	     components.  (Hence the '+ 2'.)  */
	  for (name = cp_find_first_component (name + 1);
	       *name != '>';
	       name = cp_find_first_component (name + 2))
	    gdb_assert (*name == ':');
	  break;
	case '(':
	  /* Similar comment as to '<'.  */
	  for (name = cp_find_first_component (name + 1);
	       *name != ')';
	       name = cp_find_first_component (name + 2))
	    gdb_assert (*name == ':');
	  break;
	case '>':
	case ')':
	case '\0':
	case ':':
	  return name;
	default:
	  break;
	}
    }
@


1.1.6.2
log
@2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h: Add opaque declarations for struct namespace_info and
	struct obstack.
	(struct block): The language_specific stuff is now a struct
	namespace_info rather than a struct using_direct_node.
	(BLOCK_NAMESPACE): New macro.
	Delete macro BLOCK_USING.
	Add declarations for block_using, block_all_usings,
	block_set_using, block_scope, block_set_scope.
	* symtab.c: #include "gdb_assert.h"
	(lookup_symbol_aux): Move minsym stuff inside
	lookup_symbol_aux_nonlocal, and always do global search via
	lookup_symbol_aux_using.
	(lookup_symbol_aux_nonlocal): Do minsym search.
	(lookup_symbol_aux_using): Calculate usings via block_all_usings;
	handle namespace scope.
	(lookup_symbol_aux_using_loop): New function, not to be confused
	with the previous function of the same name.  (Sorry about that.)
	(lookup_symbol_namespace): Renamed from
	lookup_symbol_aux_using_loop.
	(lookup_symbol_aux_minsyms): Add block_index argument, delete
	is_a_field_of_this argument, and only check either global or
	static symbols rather than both of them.
	(block_using): New function.
	(block_all_usings): New function.
	(block_set_using): New function.
	(block_scope): New function.
	(block_set_scope): New function.
	(block_initialize_namespace): New function.
	* jv-lang.c (get_java_class_symtab): BLOCK_NAMESPACE instead of
	BLOCK_USING.
	* dwarf2read.c: Delete variable current_namespace, and replace its
	uses by processing_current_namespace (from buildsym.h).
	(scan_partial_symbols): Allow empty pdi.name if we're
	reading a namespace.
	* cp-support.h (struct namespace_info): New struct.
	* cp-support.c: Add comment.
	* buildsym.h: New variable processing_current_namespace.
	* buildsym.c (add_symbol_to_list): Do fast search for
	"(anonymous namespace)".
	(scan_for_anonymous_namespaces): Delete FIXME.  Convert for loop
	into a clearer while loop.
	(finish_block): Replace BLOCK_USING by BLOCK_NAMESPACE.
	(finish_block): Set block_scope of function blocks rather than
	generating using directives that would have a similar effect.
	(end_symtab): Set using via block_set_using rather than
	BLOCK_USING.
	* Makefile.in (symtab.o): Depend on gdb_assert_h.
@
text
@a54 6
/* NOTE: carlton/2002-10-25: Daniel Jacobowitz came up with an example
   where operator names don't occur at depth 0.  Sigh.  (It involved a
   template argument that was a pointer: I hadn't realized that was
   possible.)  Handling such edge cases does not seem like a
   high-priority problem to me.  */

@


1.1.6.3
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 2002, 2003 Free Software Foundation, Inc.
a23 1
#include <ctype.h>
d27 1
a28 36
#include "gdbcmd.h"
#include "dictionary.h"
#include "objfiles.h"
#include "frame.h"
#include "symtab.h"
#include "block.h"
#include "complaints.h"
#include "gdbtypes.h"

/* Functions related to demangled name parsing.  */

static const char *find_last_component (const char *name);

static unsigned int cp_find_first_component_aux (const char *name,
						 int permissive);

static void demangled_name_complaint (const char *name);

/* Functions/variables related to overload resolution.  */

static int sym_return_val_size;
static int sym_return_val_index;
static struct symbol **sym_return_val;

static char *remove_params (const char *demangled_name);

static void overload_list_add_symbol (struct symbol *sym, char *oload_name);

/* The list of "maint cplus" commands.  */

struct cmd_list_element *maint_cplus_cmd_list = NULL;

/* The actual commands.  */

static void maint_cplus_command (char *arg, int from_tty);
static void first_component_command (char *arg, int from_tty);
d42 3
a44 3
     demangled name might not end with ')': it could be a const or
     volatile class method, in which case it ends with "const" or
     "volatile".
d50 10
a59 1
   - And operator names can contain parentheses or angle brackets.  */
d61 2
a62 3
/* FIXME: carlton/2003-03-13: We have several functions here with
   overlapping functionality; can we combine them?  Also, do they
   handle all the above considerations correctly?  */
d179 4
a182 8
/* This returns the length of first component of NAME, which should be
   the demangled name of a C++ variable/function/method/etc.
   Specifically, it returns the index of the first colon forming the
   boundary of the first component: so, given 'A::foo' or 'A::B::foo'
   it returns the 1, and given 'foo', it returns 0.  */

/* The character in NAME indexed by the return value is guaranteed to
   always be either ':' or '\0'.  */
d184 6
a189 8
/* NOTE: carlton/2003-03-13: This function is currently only intended
   for internal use: it's probably not entirely safe when called on
   user-generated input, because some of the 'index += 2' lines in
   cp_find_first_component_aux might go past the end of malformed
   input.  */

unsigned int
cp_find_first_component (const char *name)
d191 4
a194 7
  return cp_find_first_component_aux (name, 0);
}

/* Helper function for cp_find_first_component.  Like that function,
   it returns the length of the first component of NAME, but to make
   the recursion easier, it also stops if it reaches an unexpected ')'
   or '>' if the value of PERMISSIVE is nonzero.  */
d196 1
a196 1
/* Let's optimize away calls to strlen("operator").  */
d198 5
a202 13
#define LENGTH_OF_OPERATOR 8

static unsigned int
cp_find_first_component_aux (const char *name, int permissive)
{
  unsigned int index = 0;
  /* Operator names can show up in unexpected places.  Since these can
     contain parentheses or angle brackets, they can screw up the
     recursion.  But not every string 'operator' is part of an
     operater name: e.g. you could have a variable 'cooperator'.  So
     this variable tells us whether or not we should treat the string
     'operator' as starting an operator.  */
  int operator_possible = 1;
d204 1
a204 104
  for (;; ++index)
    {
      switch (name[index])
	{
	case '<':
	  /* Template; eat it up.  The calls to cp_first_component
	     should only return (I hope!) when they reach the '>'
	     terminating the component or a '::' between two
	     components.  (Hence the '+ 2'.)  */
	  index += 1;
	  for (index += cp_find_first_component_aux (name + index, 1);
	       name[index] != '>';
	       index += cp_find_first_component_aux (name + index, 1))
	    {
	      if (name[index] != ':')
		{
		  demangled_name_complaint (name);
		  return strlen (name);
		}
	      index += 2;
	    }
	  operator_possible = 1;
	  break;
	case '(':
	  /* Similar comment as to '<'.  */
	  index += 1;
	  for (index += cp_find_first_component_aux (name + index, 1);
	       name[index] != ')';
	       index += cp_find_first_component_aux (name + index, 1))
	    {
	      if (name[index] != ':')
		{
		  demangled_name_complaint (name);
		  return strlen (name);
		}
	      index += 2;
	    }
	  operator_possible = 1;
	  break;
	case '>':
	case ')':
	  if (permissive)
	    return index;
	  else
	    {
	      demangled_name_complaint (name);
	      return strlen (name);
	    }
	case '\0':
	case ':':
	  return index;
	case 'o':
	  /* Operator names can screw up the recursion.  */
	  if (operator_possible
	      && strncmp (name + index, "operator", LENGTH_OF_OPERATOR) == 0)
	    {
	      index += LENGTH_OF_OPERATOR;
	      while (isspace(name[index]))
		++index;
	      switch (name[index])
		{
		  /* Skip over one less than the appropriate number of
		     characters: the for loop will skip over the last
		     one.  */
		case '<':
		  if (name[index + 1] == '<')
		    index += 1;
		  else
		    index += 0;
		  break;
		case '>':
		case '-':
		  if (name[index + 1] == '>')
		    index += 1;
		  else
		    index += 0;
		  break;
		case '(':
		  index += 1;
		  break;
		default:
		  index += 0;
		  break;
		}
	    }
	  operator_possible = 0;
	  break;
	case ' ':
	case ',':
	case '.':
	case '&':
	case '*':
	  /* NOTE: carlton/2003-04-18: I'm not sure what the precise
	     set of relevant characters are here: it's necessary to
	     include any character that can show up before 'operator'
	     in a demangled name, and it's safe to include any
	     character that can't be part of an identifier's name.  */
	  operator_possible = 1;
	  break;
	default:
	  operator_possible = 0;
	  break;
	}
    }
d207 2
a208 2
/* Complain about a demangled name that we don't know how to parse.
   NAME is the demangled name in question.  */
d210 5
a214 2
static void
demangled_name_complaint (const char *name)
d216 3
a218 9
  complaint (&symfile_complaints,
	     "unexpected demangled name '%s'", name);
}

/* If NAME is the fully-qualified name of a C++
   function/variable/method/etc., this returns the length of its
   entire prefix: all of the namespaces and classes that make up its
   name.  Given 'A::foo', it returns 1, given 'A::B::foo', it returns
   4, given 'foo', it returns 0.  */
d220 1
a220 5
unsigned int
cp_entire_prefix_len (const char *name)
{
  unsigned int current_len = cp_find_first_component (name);
  unsigned int previous_len = 0;
d222 5
a226 8
  while (name[current_len] != '\0')
    {
      gdb_assert (name[current_len] == ':');
      previous_len = current_len;
      /* Skip the '::'.  */
      current_len += 2;
      current_len += cp_find_first_component (name + current_len);
    }
d228 1
a228 1
  return previous_len;
d231 3
a233 1
/* Overload resolution functions.  */
d235 3
a237 2
static char *
remove_params (const char *demangled_name)
d239 4
a242 3
  const char *argp;
  char *new_name;
  int depth;
d244 3
a246 2
  if (demangled_name == NULL)
    return NULL;
d248 1
a248 30
  /* First find the end of the arg list.  */
  argp = strrchr (demangled_name, ')');
  if (argp == NULL)
    return NULL;

  /* Back up to the beginning.  */
  depth = 1;

  while (argp-- > demangled_name)
    {
      if (*argp == ')')
	depth ++;
      else if (*argp == '(')
	{
	  depth --;

	  if (depth == 0)
	    break;
	}
    }
  if (depth != 0)
    internal_error (__FILE__, __LINE__,
		    "bad demangled name %s\n", demangled_name);
  while (argp[-1] == ' ' && argp > demangled_name)
    argp --;

  new_name = xmalloc (argp - demangled_name + 1);
  memcpy (new_name, demangled_name, argp - demangled_name);
  new_name[argp - demangled_name] = '\0';
  return new_name;
d251 4
a254 6
/*  Test to see if the symbol specified by SYMNAME (which is already
   demangled for C++ symbols) matches SYM_TEXT in the first SYM_TEXT_LEN
   characters.  If so, add it to the current completion list. */

static void
overload_list_add_symbol (struct symbol *sym, char *oload_name)
d256 1
a256 24
  int newsize;
  int i;
  char *sym_name;

  /* If there is no type information, we can't do anything, so skip */
  if (SYMBOL_TYPE (sym) == NULL)
    return;

  /* skip any symbols that we've already considered. */
  for (i = 0; i < sym_return_val_index; ++i)
    if (!strcmp (DEPRECATED_SYMBOL_NAME (sym), DEPRECATED_SYMBOL_NAME (sym_return_val[i])))
      return;

  /* Get the demangled name without parameters */
  sym_name = remove_params (SYMBOL_DEMANGLED_NAME (sym));
  if (!sym_name)
    return;

  /* skip symbols that cannot match */
  if (strcmp (sym_name, oload_name) != 0)
    {
      xfree (sym_name);
      return;
    }
d258 1
a258 5
  xfree (sym_name);

  /* We have a match for an overload instance, so add SYM to the current list
   * of overload instances */
  if (sym_return_val_index + 3 > sym_return_val_size)
d260 5
a264 2
      newsize = (sym_return_val_size *= 2) * sizeof (struct symbol *);
      sym_return_val = (struct symbol **) xrealloc ((char *) sym_return_val, newsize);
a265 2
  sym_return_val[sym_return_val_index++] = sym;
  sym_return_val[sym_return_val_index] = NULL;
a267 4
/* Return a null-terminated list of pointers to function symbols that
 * match name of the supplied symbol FSYM.
 * This is used in finding all overloaded instances of a function name.
 * This has been modified from make_symbol_completion_list.  */
d269 6
d276 3
a278 13
struct symbol **
make_symbol_overload_list (struct symbol *fsym)
{
  struct symbol *sym;
  struct symtab *s;
  struct partial_symtab *ps;
  struct objfile *objfile;
  struct block *b, *surrounding_static_block = 0;
  struct dict_iterator iter;
  /* The name we are completing on. */
  char *oload_name = NULL;
  /* Length of name.  */
  int oload_name_len = 0;
d280 1
a280 1
  /* Look for the symbol we are supposed to complete on.  */
d282 1
a282 7
  oload_name = remove_params (SYMBOL_DEMANGLED_NAME (fsym));
  if (!oload_name)
    {
      sym_return_val_size = 1;
      sym_return_val = (struct symbol **) xmalloc (2 * sizeof (struct symbol *));
      sym_return_val[0] = fsym;
      sym_return_val[1] = NULL;
d284 6
a289 27
      return sym_return_val;
    }
  oload_name_len = strlen (oload_name);

  sym_return_val_size = 100;
  sym_return_val_index = 0;
  sym_return_val = (struct symbol **) xmalloc ((sym_return_val_size + 1) * sizeof (struct symbol *));
  sym_return_val[0] = NULL;

  /* Read in all partial symtabs containing a partial symbol named
     OLOAD_NAME.  */

  ALL_PSYMTABS (objfile, ps)
  {
    struct partial_symbol **psym;

    /* If the psymtab's been read in we'll get it when we search
       through the blockvector.  */
    if (ps->readin)
      continue;

    if ((lookup_partial_symbol (ps, oload_name, NULL, 1, VAR_DOMAIN)
	 != NULL)
	|| (lookup_partial_symbol (ps, oload_name, NULL, 0, VAR_DOMAIN)
	    != NULL))
      PSYMTAB_TO_SYMTAB (ps);
  }
d291 1
a291 4
  /* Search upwards from currently selected frame (so that we can
     complete on local vars.  */

  for (b = get_selected_block (0); b != NULL; b = BLOCK_SUPERBLOCK (b))
d293 2
a294 1
      if (!BLOCK_SUPERBLOCK (b))
d296 19
a314 1
	  surrounding_static_block = b;		/* For elimination of dups */
d316 1
d318 3
a320 4
      /* Also catch fields of types defined in this places which match our
         text string.  Only complete on types visible from current context. */

      ALL_BLOCK_SYMBOLS (b, iter, sym)
d322 24
a345 1
	  overload_list_add_symbol (sym, oload_name);
a347 114

  /* Go through the symtabs and check the externs and statics for
     symbols which match.  */

  ALL_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
    ALL_BLOCK_SYMBOLS (b, iter, sym)
      {
	overload_list_add_symbol (sym, oload_name);
      }
  }

  ALL_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
    /* Don't do this block twice.  */
    if (b == surrounding_static_block)
      continue;
    ALL_BLOCK_SYMBOLS (b, iter, sym)
      {
	overload_list_add_symbol (sym, oload_name);
      }
  }

  xfree (oload_name);

  return (sym_return_val);
}

/* Lookup the rtti type for a class name. */

struct type *
cp_lookup_rtti_type (const char *name, struct block *block)
{
  struct symbol * rtti_sym;
  struct type * rtti_type;

  rtti_sym = lookup_symbol (name, block, STRUCT_DOMAIN, NULL, NULL);

  if (rtti_sym == NULL)
    {
      warning ("RTTI symbol not found for class '%s'", name);
      return NULL;
    }

  if (SYMBOL_CLASS (rtti_sym) != LOC_TYPEDEF)
    {
      warning ("RTTI symbol for class '%s' is not a type", name);
      return NULL;
    }

  rtti_type = SYMBOL_TYPE (rtti_sym);

  switch (TYPE_CODE (rtti_type))
    {
    case TYPE_CODE_CLASS:
      break;
    case TYPE_CODE_NAMESPACE:
      /* chastain/2003-11-26: the symbol tables often contain fake
	 symbols for namespaces with the same name as the struct.
	 This warning is an indication of a bug in the lookup order
	 or a bug in the way that the symbol tables are populated.  */
      warning ("RTTI symbol for class '%s' is a namespace", name);
      return NULL;
    default:
      warning ("RTTI symbol for class '%s' has bad type", name);
      return NULL;
    }

  return rtti_type;
}

/* Don't allow just "maintenance cplus".  */

static  void
maint_cplus_command (char *arg, int from_tty)
{
  printf_unfiltered ("\"maintenance cplus\" must be followed by the name of a command.\n");
  help_list (maint_cplus_cmd_list, "maintenance cplus ", -1, gdb_stdout);
}

/* This is a front end for cp_find_first_component, for unit testing.
   Be careful when using it: see the NOTE above
   cp_find_first_component.  */

static void
first_component_command (char *arg, int from_tty)
{
  int len = cp_find_first_component (arg);
  char *prefix = alloca (len + 1);

  memcpy (prefix, arg, len);
  prefix[len] = '\0';

  printf_unfiltered ("%s\n", prefix);
}

extern initialize_file_ftype _initialize_cp_support; /* -Wmissing-prototypes */

void
_initialize_cp_support (void)
{
  add_prefix_cmd ("cplus", class_maintenance, maint_cplus_command,
		  "C++ maintenance commands.", &maint_cplus_cmd_list,
		  "maintenance cplus ", 0, &maintenancelist);
  add_alias_cmd ("cp", "cplus", class_maintenance, 1, &maintenancelist);

  add_cmd ("first_component", class_maintenance, first_component_command,
	   "Print the first class/namespace component of NAME.",
	   &maint_cplus_cmd_list);
		  
@


1.1.6.4
log
@Merge from mainline.
@
text
@d148 1
a148 1
  char *demangled_name = cplus_demangle (physname, DMGL_ANSI | DMGL_PARAMS);
d173 1
a173 1
  char *demangled_name = cplus_demangle (physname, DMGL_ANSI | DMGL_PARAMS);
@


1.1.6.5
log
@	* Makefile.in (cp_names_h): Remove.
	(cp_demangle_h): New.
	(cp-names.tab.o, cp-names-main.tab.o): Use $(cp_demangle_h) and
	remove $(cp_names_h).
	(cp-support.o): Use $(cp_demangle_h).
	* cp-names.y: Don't include cp-names.h.
	(cp_comp_to_string): Export.
	(cp_canonicalize_string): Move to cp-support.c.
	(demangled_name_to_comp, mangled_name_to_comp): New functions.
	* cp-support.c: Include "cp-demangle.h".
	(cp_canonicalize_string): New function, moved from cp-names.y and
	updated.
	(class_name_from_physname, method_name_from_physname): Rewritten.
	(find_last_component): Removed.
	* cp-support.h: Add new opaque types and prototypes.
	* dwarf2read.c: Don't include cp-names.h.
	* cp-names.h: Remove file.
@
text
@d2 1
a2 1
   Copyright 2002, 2003, 2004 Free Software Foundation, Inc.
a37 3
#define IN_GDB
#include "cp-demangle.h"

d66 25
a90 2
/* Return the canonicalized form of STRING, or NULL if STRING can not be
   parsed.  */
d92 3
a94 2
/* FIXME: Should we also return NULL for things that trivially do not require
   any change?  i.e. alphanumeric strings.  */
d96 5
a100 2
char *
cp_canonicalize_string (const char *string)
d102 12
a113 4
  struct d_info *di;
  struct d_comp *ret_comp;
  char *ret;
  int len = strlen (string);
d115 12
a126 1
  len = len + len / 8;
d128 1
a128 2
  ret_comp = demangled_name_to_comp (string, &di);
  if (ret_comp == NULL)
d131 2
a132 1
  ret = cp_comp_to_string (ret_comp, len);
d134 2
a135 1
  cp_v3_d_free_info (di);
d137 1
a137 1
  return ret;
d145 4
a148 4
  struct d_info *di;
  char *demangled_name, *ret;
  struct d_comp *ret_comp, *prev_comp;
  int done;
d150 1
a150 2
  ret_comp = mangled_name_to_comp (physname, DMGL_ANSI, &di, &demangled_name);
  if (ret_comp == NULL)
d153 2
a154 41
  done = 0;
  prev_comp = NULL;
  while (!done)
    switch (ret_comp->type)
      {
      case D_COMP_TYPED_NAME:
	prev_comp = NULL;
        ret_comp = d_right (ret_comp);
        break;
      case D_COMP_QUAL_NAME:
      case D_COMP_LOCAL_NAME:
	prev_comp = ret_comp;
        ret_comp = d_right (ret_comp);
        break;
      case D_COMP_CONST:
      case D_COMP_RESTRICT:
      case D_COMP_VOLATILE:
      case D_COMP_CONST_THIS:
      case D_COMP_RESTRICT_THIS:
      case D_COMP_VOLATILE_THIS:
      case D_COMP_VENDOR_TYPE_QUAL:
	prev_comp = NULL;
        ret_comp = d_left (ret_comp);
        break;
      case D_COMP_NAME:
      case D_COMP_TEMPLATE:
      case D_COMP_CTOR:
      case D_COMP_DTOR:
      case D_COMP_OPERATOR:
      case D_COMP_EXTENDED_OPERATOR:
	done = 1;
	break;
      default:
	done = 1;
	prev_comp = NULL;
	ret_comp = NULL;
	break;
      }

  ret = NULL;
  if (prev_comp != NULL)
d156 3
a158 3
      *prev_comp = *d_left (prev_comp);
      /* The ten is completely arbitrary; we don't have a good estimate.  */
      ret = cp_comp_to_string (prev_comp, 10);
a160 1
  cp_v3_d_free_info (di);
d170 4
a173 4
  struct d_info *di;
  char *demangled_name, *ret;
  struct d_comp *ret_comp;
  int done;
d175 1
a175 2
  ret_comp = mangled_name_to_comp (physname, DMGL_ANSI, &di, &demangled_name);
  if (ret_comp == NULL)
d178 24
a201 36
  done = 0;
  while (!done)
    switch (ret_comp->type)
      {
      case D_COMP_QUAL_NAME:
      case D_COMP_LOCAL_NAME:
      case D_COMP_TYPED_NAME:
        ret_comp = d_right (ret_comp);
        break;
      case D_COMP_CONST:
      case D_COMP_RESTRICT:
      case D_COMP_VOLATILE:
      case D_COMP_CONST_THIS:
      case D_COMP_RESTRICT_THIS:
      case D_COMP_VOLATILE_THIS:
      case D_COMP_VENDOR_TYPE_QUAL:
        ret_comp = d_left (ret_comp);
        break;
      case D_COMP_NAME:
      case D_COMP_TEMPLATE:
      case D_COMP_CTOR:
      case D_COMP_DTOR:
      case D_COMP_OPERATOR:
      case D_COMP_EXTENDED_OPERATOR:
	done = 1;
	break;
      default:
	done = 1;
	ret_comp = NULL;
	break;
      }

  ret = NULL;
  if (ret_comp != NULL)
    /* The ten is completely arbitrary; we don't have a good estimate.  */
    ret = cp_comp_to_string (ret_comp, 10);
a202 1
  cp_v3_d_free_info (di);
a205 27

/* Here are some random pieces of trivia to keep in mind while trying
   to take apart demangled names:

   - Names can contain function arguments or templates, so the process
     has to be, to some extent recursive: maybe keep track of your
     depth based on encountering <> and ().

   - Parentheses don't just have to happen at the end of a name: they
     can occur even if the name in question isn't a function, because
     a template argument might be a type that's a function.

   - Conversely, even if you're trying to deal with a function, its
     demangled name might not end with ')': it could be a const or
     volatile class method, in which case it ends with "const" or
     "volatile".

   - Parentheses are also used in anonymous namespaces: a variable
     'foo' in an anonymous namespace gets demangled as "(anonymous
     namespace)::foo".

   - And operator names can contain parentheses or angle brackets.  */

/* FIXME: carlton/2003-03-13: We have several functions here with
   overlapping functionality; can we combine them?  Also, do they
   handle all the above considerations correctly?  */

@


1.1.6.6
log
@	* cp-names.y: Don't include "cp-demangle.h".  Convert all references
	to d_info, d_comp, and D_COMP_* to demangle_info, demangle_component,
	and DEMANGLE_COMPONENT_*.  Convert all calls to cp_v3_d_* functions
	to new wrapper functions.  Add precedences for VOID and ')'.
	(struct demangle_info): New type.
	(d_grab, d_left, d_right): New macros.
	(fill_comp, make_empty, make_operator, make_dtor, make_builtin_type)
	(make_name): New wrapper functions.
	(function_args): Remove D_PRINT_VOID test.
	(function_arglist): Handle '(' VOID ')'.
	(allocate_info): New function.
	(demangled_name_to_comp): Use it.  Call free.
	(mangled_name_to_comp): Use cplus_demangle_v3_components.
	(cp_print, main): Use fputs instead of puts.
	* cp-support.c (cp_canonicalize_string, class_name_from_physname)
	(method_name_from_physname): Remove calls to cp_v3_d_free_info.
	Test demangled_name before freeing it.
@
text
@d91 1
a91 1
  xfree (di);
d102 1
a102 1
  char *demangled_name = NULL, *ret;
d157 2
a158 3
  xfree (di);
  if (demangled_name)
    xfree (demangled_name);
d168 1
a168 1
  char *demangled_name = NULL, *ret;
d213 2
a214 3
  xfree (di);
  if (demangled_name)
    xfree (demangled_name);
@


1.1.6.7
log
@	* Makefile.in (cp_demangle_h): Remove.
	(libiberty_h): Add.
	(cp-names.tab.o, cp-names-main.tab.o, cp-support.o): Update
	dependencies.
	* cp-support.c: Don't include "cp-demangle.h".
	(d_left, d_right): New macros.
	(cp_canonicalize_string, class_name_from_physname,
	method_name_from_physname): Fix types and component names.
	* cp-support.h (demangled_name_to_comp, mangled_name_to_comp)
	(cp_comp_to_string): Update prototypes.
@
text
@d38 2
a39 2
#define d_left(dc) (dc)->u.s_binary.left
#define d_right(dc) (dc)->u.s_binary.right
d78 2
a79 2
  void *storage;
  struct demangle_component *ret_comp;
d85 1
a85 1
  ret_comp = demangled_name_to_comp (string, &storage);
d91 1
a91 1
  xfree (storage);
d101 1
a101 1
  void *storage;
d103 1
a103 1
  struct demangle_component *ret_comp, *prev_comp;
d106 1
a106 2
  ret_comp = mangled_name_to_comp (physname, DMGL_ANSI, &storage,
				   &demangled_name);
d115 1
a115 1
      case DEMANGLE_COMPONENT_TYPED_NAME:
d119 2
a120 2
      case DEMANGLE_COMPONENT_QUAL_NAME:
      case DEMANGLE_COMPONENT_LOCAL_NAME:
d124 7
a130 7
      case DEMANGLE_COMPONENT_CONST:
      case DEMANGLE_COMPONENT_RESTRICT:
      case DEMANGLE_COMPONENT_VOLATILE:
      case DEMANGLE_COMPONENT_CONST_THIS:
      case DEMANGLE_COMPONENT_RESTRICT_THIS:
      case DEMANGLE_COMPONENT_VOLATILE_THIS:
      case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
d134 6
a139 6
      case DEMANGLE_COMPONENT_NAME:
      case DEMANGLE_COMPONENT_TEMPLATE:
      case DEMANGLE_COMPONENT_CTOR:
      case DEMANGLE_COMPONENT_DTOR:
      case DEMANGLE_COMPONENT_OPERATOR:
      case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
d157 1
a157 1
  xfree (storage);
d168 1
a168 1
  void *storage;
d170 1
a170 1
  struct demangle_component *ret_comp;
d173 1
a173 2
  ret_comp = mangled_name_to_comp (physname, DMGL_ANSI, &storage,
				   &demangled_name);
d181 3
a183 3
      case DEMANGLE_COMPONENT_QUAL_NAME:
      case DEMANGLE_COMPONENT_LOCAL_NAME:
      case DEMANGLE_COMPONENT_TYPED_NAME:
d186 7
a192 7
      case DEMANGLE_COMPONENT_CONST:
      case DEMANGLE_COMPONENT_RESTRICT:
      case DEMANGLE_COMPONENT_VOLATILE:
      case DEMANGLE_COMPONENT_CONST_THIS:
      case DEMANGLE_COMPONENT_RESTRICT_THIS:
      case DEMANGLE_COMPONENT_VOLATILE_THIS:
      case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
d195 6
a200 6
      case DEMANGLE_COMPONENT_NAME:
      case DEMANGLE_COMPONENT_TEMPLATE:
      case DEMANGLE_COMPONENT_CTOR:
      case DEMANGLE_COMPONENT_DTOR:
      case DEMANGLE_COMPONENT_OPERATOR:
      case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
d214 1
a214 1
  xfree (storage);
@


1.1.6.8
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d58 1
a58 9
static void overload_list_add_symbol (struct symbol *sym,
				      const char *oload_name);

static void make_symbol_overload_list_using (const char *func_name,
					     const char *namespace);

static void make_symbol_overload_list_qualified (const char *func_name);

static void read_in_psymtabs (const char *oload_name);
a430 28
/* If FULL_NAME is the demangled name of a C++ function (including an
   arg list, possibly including namespace/class qualifications),
   return a new string containing only the function name (without the
   arg list/class qualifications).  Otherwise, return NULL.  The
   caller is responsible for freeing the memory in question.  */

char *
cp_func_name (const char *full_name)
{
  const char *previous_component = full_name;
  const char *next_component;

  if (!full_name)
    return NULL;

  for (next_component = (previous_component
			 + cp_find_first_component (previous_component));
       *next_component == ':';
       next_component = (previous_component
			 + cp_find_first_component (previous_component)))
    {
      /* Skip '::'.  */
      previous_component = next_component + 2;
    }

  return remove_params (previous_component);
}

d475 3
a477 3
/* Test to see if SYM is a symbol that we haven't seen corresponding
   to a function named OLOAD_NAME.  If so, add it to the current
   completion list. */
d480 1
a480 1
overload_list_add_symbol (struct symbol *sym, const char *oload_name)
d492 1
a492 2
    if (strcmp (SYMBOL_LINKAGE_NAME (sym),
		SYMBOL_LINKAGE_NAME (sym_return_val[i])) == 0)
d496 1
a496 1
  sym_name = remove_params (SYMBOL_NATURAL_NAME (sym));
d521 4
a524 1
   are named FUNC_NAME and are visible within NAMESPACE.  */
d527 1
a527 2
make_symbol_overload_list (const char *func_name,
			   const char *namespace)
d529 10
a538 7
  struct cleanup *old_cleanups;

  sym_return_val_size = 100;
  sym_return_val_index = 0;
  sym_return_val = xmalloc ((sym_return_val_size + 1) *
			    sizeof (struct symbol *));
  sym_return_val[0] = NULL;
d540 1
a540 1
  old_cleanups = make_cleanup (xfree, sym_return_val);
d542 7
a548 17
  make_symbol_overload_list_using (func_name, namespace);

  discard_cleanups (old_cleanups);

  return sym_return_val;
}

/* This applies the using directives to add namespaces to search in,
   and then searches for overloads in all of those namespaces.  It
   adds the symbols found to sym_return_val.  Arguments are as in
   make_symbol_overload_list.  */

static void
make_symbol_overload_list_using (const char *func_name,
				 const char *namespace)
{
  const struct using_direct *current;
d550 1
a550 13
  /* First, go through the using directives.  If any of them apply,
     look in the appropriate namespaces for new functions to match
     on.  */

  for (current = block_using (get_selected_block (0));
       current != NULL;
       current = current->next)
    {
      if (strcmp (namespace, current->outer) == 0)
	{
	  make_symbol_overload_list_using (func_name,
					   current->inner);
	}
d552 1
d554 4
a557 16
  /* Now, add names for this namespace.  */
  
  if (namespace[0] == '\0')
    {
      make_symbol_overload_list_qualified (func_name);
    }
  else
    {
      char *concatenated_name
	= alloca (strlen (namespace) + 2 + strlen (func_name) + 1);
      strcpy (concatenated_name, namespace);
      strcat (concatenated_name, "::");
      strcat (concatenated_name, func_name);
      make_symbol_overload_list_qualified (concatenated_name);
    }
}
d559 2
a560 3
/* This does the bulk of the work of finding overloaded symbols.
   FUNC_NAME is the name of the overloaded function we're looking for
   (possibly including namespace info).  */
d562 3
a564 9
static void
make_symbol_overload_list_qualified (const char *func_name)
{
  struct symbol *sym;
  struct symtab *s;
  struct objfile *objfile;
  const struct block *b, *surrounding_static_block = 0;
  struct dict_iterator iter;
  const struct dictionary *dict;
d566 4
a569 2
  /* Look through the partial symtabs for all symbols which begin
     by matching FUNC_NAME.  Make sure we read that symbol table in. */
d571 6
a576 1
  read_in_psymtabs (func_name);
d583 4
a586 1
      dict = BLOCK_DICT (b);
d588 4
a591 3
      for (sym = dict_iter_name_first (dict, func_name, &iter);
	   sym;
	   sym = dict_iter_name_next (func_name, &iter))
d593 1
a593 1
	  overload_list_add_symbol (sym, func_name);
a596 2
  surrounding_static_block = block_static_block (get_selected_block (0));

d604 4
a607 8
    dict = BLOCK_DICT (b);

    for (sym = dict_iter_name_first (dict, func_name, &iter);
	 sym;
	 sym = dict_iter_name_next (func_name, &iter))
    {
      overload_list_add_symbol (sym, func_name);
    }
d617 4
a620 8
    dict = BLOCK_DICT (b);

    for (sym = dict_iter_name_first (dict, func_name, &iter);
	 sym;
	 sym = dict_iter_name_next (func_name, &iter))
    {
      overload_list_add_symbol (sym, func_name);
    }
a621 1
}
d623 1
a623 2
/* Look through the partial symtabs for all symbols which begin
   by matching FUNC_NAME.  Make sure we read that symbol table in. */
d625 1
a625 17
static void
read_in_psymtabs (const char *func_name)
{
  struct partial_symtab *ps;
  struct objfile *objfile;

  ALL_PSYMTABS (objfile, ps)
  {
    if (ps->readin)
      continue;

    if ((lookup_partial_symbol (ps, func_name, NULL, 1, VAR_DOMAIN)
	 != NULL)
	|| (lookup_partial_symbol (ps, func_name, NULL, 0, VAR_DOMAIN)
	    != NULL))
      psymtab_to_symtab (ps);
  }
@


1.1.2.1
log
@2002-10-09  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Comment out cp_find_last_component and
	cp_locate_arguments.
	Add comments warning about pitfals involving demangled names.
	* buildsym.c (finish_block): Grab the namespace names from the
	front instead of from the back.
	* Makefile.in (cp-support.o): Depend on gdb_assert_h.
	* cp-support.c: #include "gdb_assert.h"
	* cp-support.h: Declare cp_find_first_component.
	* cp-support.c (cp_find_first_component): New function.
	* buildsym.c (finish_block): Don't add namespace using stuff
	unless there's a demangled name to work with.
	(finish_block): Delete unused variable 'j'.
	(finish_block): Move declaration of iter earlier to pacify GCC.

2002-10-08  David Carlton  <carlton@@math.stanford.edu>

	* symfile.c (obsavestring): Make first argument a const char *.
	* symfile.h: Add opaque declaration for 'struct obstack'.
	Make obsavestring take a const char * as its first argument.
	* Makefile.in (cp-support.o): Correct dependencies.
	* cp-support.h: Declare cp_add_using.
	* cp-support.c: #include "gdb_obstack.h"
	(cp_add_using): New function.
	* Makefile.in (buildsym.o): Depend on $(cp_support_h).
	* buildsym.c (finish_block): Add 'using' directives for
	functions.
	#include "cp-support.h"
	* cp-support.h: Add function declarations.
	* cp-support.c (cp_locate_arguments): New function.
	(cp_find_last_component): New function.
	* symtab.h (struct block): Add comment.
@
text
@a26 30
#include "gdb_obstack.h"
#include "gdb_assert.h"

/* Here are some random pieces of trivia to keep in mind while trying
   to take apart demangled names:

   - Names can contain function arguments or templates, so the process
     has to be, to some extent recursive: maybe keep track of your
     depth based on encountering <> and ().

   - Parentheses don't just have to happen at the end of a name: they
     can occur even if the name in question isn't a function, because
     a template argument might be a type that's a function.

   - Conversely, even if you're trying to deal with a function, its
     demangled name might not end with ')': it could be a const (or
     volatile, I suppose) class method, in which case it ends with
     "const".

   - Parentheses are also used in anonymous namespaces: a variable
     'foo' in an anonymous namespace gets demangled as "(anonymous
     namespace)::foo".

   - And operator names can contain parentheses or angle brackets.
     Fortunately, I _think_ that operator names can only occur in a
     fairly restrictive set of locations (in particular, they have be
     at depth 0, don't they?).  */

/* FIXME: carlton/2002-10-09: Do all the functions here handle all the
   above considerations correctly?  */
a140 209
}

#if 0

/* FIXME: carlton/2002-10-09: cp_locate_arguments and
   cp_find_last_component are broken: they don't deal with operator<<
   and the like.  Oops.  I decided to fix this by starting from the
   front, leading to cp_find_first_component (which may or may not be
   correct...); if I don't find other uses for cp_locate_arguments and
   cp_find_last_component soon, I'll delete them.  */

/* Given a name that may or may not be the demangled name of a
   function or method, this returns a pointer to the last character
   that isn't part of the arguments, if there are any.  I.e. given a
   pointer to "foo", it returns a pointer to the trailing '\0'; given
   a pointer to "C::foo() const", it returns a pointer to the '('.  */

const char *
cp_locate_arguments (const char *name)
{
/* NOTE: carlton/2002-10-08: we search from the front rather than from
   the back to avoid getting screwed up by the 'const' on the end.
   ARGSOK says when a parenthesis should be the start of the arguments
   to a function: otherwise, we get screwed up by 'A::(anonymous
   namespace)::foo' and its ilk.  */

  const char *current = name;
  const char *end = name + strlen(name);
  /* The nesting depth.  */
  int depth = 0;
  /* Might a parenthesis be the start of arguments?  */
  int argsok = 0;

  while (current < end)
    {
      switch (*current)
	{
	case '(':
	  if (depth == 0 && argsok)
	    return current;
	  ++depth;
	  argsok = 0;
	  break;
	case '<':
	  ++depth;
	  argsok = 0;
	  break;
	case ')':
	case '>':
	  --depth;
	  argsok = 1;
	  break;
	case ':':
	  argsok = 0;
	  break;
	default:
	  argsok = 1;
	  break;
	}
      ++current;
    }

  return current;
}

/* Given pointers FIRST and LAST such that [FIRST,LAST) is a substring
   of a demangled name, not including the arguments (i.e. call
   cp_locate_arguments first!), this returns a pointer to the
   beginning of the end of the last component.  For example, given
   either "A::B::C::foo" or "foo", it returns a pointer to 'f'.  */

/* FIXME: carlton/2002-10-08: This overlaps dreadfully with
   find_last_component.  Sigh.  */

const char *
cp_find_last_component (const char *first, const char *last)
{
  const char *current;
  int depth;

  for (current = last - 1, depth = 0;
       current >= first;
       --current)
    {
      switch (*current)
	{
	case '(':
	case '<':
	  --depth;
	  break;
	case ')':
	case '>':
	  ++depth;
	  break;
	case ':':
	  if (depth == 0)
	    return current + 1;
	  break;
	default:
	  break;
	}
    }

  return first;
}

#endif /* 0 */

/* This allocates a new using_data structure initialized to contain
   OUTER and INNER, and puts it at the beginning of the linked list
   given by NEXT.  It returns the resulting struct using_data_node.
   All memory is allocated using OBSTACK.  */
struct using_data_node *
cp_add_using (const char *outer, const char *inner,
	      struct using_data_node *next,
	      struct obstack *obstack)
{
  struct using_data *current
    = obstack_alloc (obstack, sizeof (struct using_data));
  struct using_data_node *retval
    = obstack_alloc (obstack, sizeof (struct using_data_node));

  current->outer = outer;
  current->inner = inner;
  retval->current = current;
  retval->next = next;

  return retval;
}

/* This returns the first component of NAME, which should be the
   demangled name of a C++ variable/function/method/etc.
   Specifically, it returns a pointer to the first colon forming the
   boundary of the first component: so, given 'A::foo' or 'A::B::foo'
   it returns a pointer to the first :, and given 'foo', it returns a
   pointer to the trailing '\0'.  */

/* Well, that's what it should do when called externally, but to make
   the recursion easier, it also stops if it reaches an unexpected ')'
   or '>'.  */

/* Let's optimize away calls to strlen("operator").  */

#define LENGTH_OF_OPERATOR 8

const char *
cp_find_first_component (const char *name)
{
  /* Names like 'operator<<' screw up the recursion, so let's
     special-case them.  I _hope_ they can only occur at the start of
     a component.  */

  if (strncmp (name, "operator", LENGTH_OF_OPERATOR) == 0)
    {
      name += LENGTH_OF_OPERATOR;
      switch (*name)
	{
	case '<':
	  if (name[1] == '<')
	    name += 2;
	  else
	    name += 1;
	  break;
	case '>':
	case '-':
	  if (name[1] == '>')
	    name +=2;
	  else
	    name += 1;
	  break;
	case '(':
	  name += 2;
	  break;
	default:
	  name += 1;
	  break;
	}
    }

  for (;; ++name)
    {
      switch (*name)
	{
	case '<':
	  /* Template; eat it up.  The calls to cp_first_component
	     should only return (I hope!) when they reach the '>'
	     terminating the component or a '::' between two
	     components.  (Hence the '+ 2'.)  */
	  for (name = cp_find_first_component (name + 1);
	       *name != '>';
	       name = cp_find_first_component (name + 2))
	    gdb_assert (*name == ':');
	  break;
	case '(':
	  /* Similar comment as to '<'.  */
	  for (name = cp_find_first_component (name + 1);
	       *name != ')';
	       name = cp_find_first_component (name + 2))
	    gdb_assert (*name == ':');
	  break;
	case '>':
	case ')':
	case '\0':
	case ':':
	  return name;
	default:
	  break;
	}
    }
@


1.1.2.2
log
@2002-10-11  David Carlton  <carlton@@math.stanford.edu>

	* jv-lang.c (get_java_class_symtab): Initialize BLOCK_USING (bl)
	to NULL.
	* cp-support.c: Change all uses of 'struct using_data' and 'struct
	using_data_node' to 'struct using_direct' and 'struct
	using_direct_node'.
	(cp_free_usings): Fix loop.
	* symtab.c: Ditto.
	* symtab.h: Ditto
	* cp-support.h: Delete declarations for commented-out functions.
	Rename 'struct using_data' and 'struct using_data_node' to 'struct
	using_direct' and 'struct using_direct_node'.
	* cp-support.c: Delete commented-out functions.

2002-10-10  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_using_loop): New function.
	(lookup_symbol_aux_nonlocal): New function.
	(lookup_symbol_aux): Call lookup_symbol_aux_nonlocal instead of
	lookup_symbol_aux_symtabs and lookup_symbol_aux_psymtabs.

	* Makefile.in (symtab.o): Depend on $(cp_support_h).

	* symtab.c: #include "cp-support.h"

	* cp-support.h: Declare cp_copy_usings, cp_free_usings.

	* cp-support.c (cp_free_usings): New function.
	(cp_copy_usings): New function.

	* symtab.c (lookup_symbol_aux): Call lookup_symbol_aux_using to
	apply using directives.
	(lookup_symbol_aux_using): New function.

2002-10-11  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Add tests from within C::D::marker2.
	* gdb.c++/namespace.cc: Add namespace C and its contents.
@
text
@d173 14
a186 4
/* This allocates a new using_direct structure initialized to contain
   OUTER and INNER, and puts it at the beginning of the linked list
   given by NEXT.  It returns the resulting struct using_direct_node.
   All memory is allocated using OBSTACK.  */
d188 2
a189 4
struct using_direct_node *
cp_add_using (const char *outer, const char *inner,
	      struct using_direct_node *next,
	      struct obstack *obstack)
d191 12
a202 4
  struct using_direct *current
    = obstack_alloc (obstack, sizeof (struct using_direct));
  struct using_direct_node *retval
    = obstack_alloc (obstack, sizeof (struct using_direct_node));
d204 28
a231 4
  current->outer = outer;
  current->inner = inner;
  retval->current = current;
  retval->next = next;
d233 1
a233 1
  return retval;
d236 5
a240 14
/* This copies the using_direct_nodes in TOCOPY, using xmalloc, and
   sticks them onto a list ending in TAIL.  */
struct using_direct_node *
cp_copy_usings (struct using_direct_node *tocopy,
		struct using_direct_node *tail)
{
  struct using_direct_node *new_node;
  
  if (tocopy == NULL)
    return tail;

  new_node = xmalloc (sizeof (struct using_direct_node));
  new_node->current = tocopy->current;
  new_node->next = cp_copy_usings (tocopy->next, tail);
d242 2
a243 2
  return new_node;
}
d245 2
a246 4
/* This xfree's all the using_direct_nodes in USING (but not their
   using_directs!)  */
void
cp_free_usings (struct using_direct_node *using)
d248 2
a249 1
  struct using_direct_node *next;
d251 3
a253 1
  if (using != NULL)
d255 17
a271 5
      for (next = using->next; next;
	   using = next, next = next->next)
	xfree (using);
      
      xfree (using);
d273 2
d277 23
@


1.1.2.3
log
@2002-10-14  David Carlton  <carlton@@math.stanford.edu>

	* buildsym.c (add_using_directive): Rewrite to match new version
	of struct using_direct.
	(finish_block): Ditto.

	* symtab.c (lookup_symbol_aux_using_loop): Add 'prefix_len'
	argument; rewrite to match new version of struct using_direct.

	* cp-support.h: Update declaration for cp_add_using.

	* cp-support.c (cp_add_using): Rewrite to match new version of
	struct using_direct.

	* cp-support.h (struct using_direct): Rewrite struct.

	* buildsym.h: Declaration for add_using_directive.

	* buildsym.c: New variable 'using_list'.
	(start_symtab): Initialize using_list.
	(end_symtab): Initialize BLOCK_USING of STATIC_BLOCK.
	(scan_for_anonymous_namespaces): New function.
	(add_symbol_to_list): In C++ case, look for anonymous namespaces.
	(add_using_directive): New function.
@
text
@d174 3
a176 3
   NAME, OUTER_LENGTH, and INNER_LENGTH, and puts it at the beginning
   of the linked list given by NEXT.  It returns the resulting struct
   using_direct_node.  All memory is allocated using OBSTACK.  */
d179 1
a179 3
cp_add_using (const char *name,
	      unsigned short outer_length,
	      unsigned short inner_length,
d188 2
a189 5
  gdb_assert (outer_length < inner_length);

  current->name = name;
  current->outer_length = outer_length;
  current->inner_length = inner_length;
a197 1

@


1.1.2.4
log
@2002-10-15  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_using_loop): prefix_len should be <=
	outer_length.
	(lookup_symbol_aux_using_loop): Don't skip colons in rest_of_outer
	if we've used all of outer.
	* cp-support.h: Rename declaration of cp_add_using to
	cp_add_using_obstack.
	* cp-support.c (cp_add_using_obstack): Rename from cp_add_using.
	* buildsym.h: Rename arguments in declaration of
	add_using_directive.
	* buildsym.c (add_using_directive): Finish definition, rename
	arguments.
	* cp-support.h: Add declaration for cp_add_using_xmalloc.
	* cp-support.c (cp_add_using_xmalloc): New function.
	* buildsym.c (copy_usings_to_obstack): New function.
	(end_symtab): Set STATIC_BLOCK's BLOCK_USING using
	copy_usings_to_obstack.

2002-10-15  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Add anonymous namespace tests.
	* gdb.c++/namespace.cc: Add anonymous namespaces.
@
text
@d179 5
a183 5
cp_add_using_obstack (const char *name,
		      unsigned short outer_length,
		      unsigned short inner_length,
		      struct using_direct_node *next,
		      struct obstack *obstack)
a200 24
/* Same as cp_add_using, except that it uses xmalloc instead of
   obstacks.  */

struct using_direct_node *
cp_add_using_xmalloc (const char *name,
		      unsigned short outer_length,
		      unsigned short inner_length,
		      struct using_direct_node *next)
{
  struct using_direct *current = xmalloc (sizeof (struct using_direct));
  struct using_direct_node *retval
    = xmalloc (sizeof (struct using_direct_node));

  gdb_assert (outer_length < inner_length);

  current->name = name;
  current->outer_length = outer_length;
  current->inner_length = inner_length;
  retval->current = current;
  retval->next = next;

  return retval;
}

d202 1
a202 2
   sticks them onto a list ending in TAIL.  (It doesn't copy the
   using_directs, just the using_direct_nodes.)  */
@


1.1.2.5
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@a54 6
/* NOTE: carlton/2002-10-25: Daniel Jacobowitz came up with an example
   where operator names don't occur at depth 0.  Sigh.  (It involved a
   template argument that was a pointer: I hadn't realized that was
   possible.)  Handling such edge cases does not seem like a
   high-priority problem to me.  */

@


1.1.2.6
log
@2002-11-20  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (scan_partial_symbols): Move lowpc, highpc initial
	and final setting to dwarf2_build_psymtabs_hard.
	(dwarf2_build_psymtabs_hard): Set lowpc, highpc outside of
	scan_partial_symbols.
	(scan_partial_symbols): Handle namespaces by calling ourself
	recursively.
	* Makefile.in (cp-support.o): Depend on gdbcmd_h.
	* cp-support.c (_initialize_cp_support): New function.
	(maintenance_print_namespace): New function.
	#include "gdbcmd.h"
	* cp-support.h: Add opaque declaration for 'struct symbol'.
	* symfile.h: Add comment saying that you must first include
	symtab.h.
	* Makefile.in (cp-support.o): Depend on dictionary_h.
	* cp-support.c: #include "dictionary.h"
	* gdbtypes.h: Add TYPE_CODE_NAMESPACE to enum type_code.
	* cp-support.h: Add declaration for cp_check_namespace_symbol.
	* Makefile.in (cp-support.o): Depend on gdbtypes_h.
	* cp-support.c: New variable namespace_objfile.
	(get_namespace_objfile): New function.
	(cp_check_namespace_symbol): New function.
	#include "gdbtypes.h"
	* Makefile.in (cp-support.o): Depend on symfile_h, symtab_h,
	block_h, objfiles_h.
	* cp-support.c: Add declaration for find_last_component.
	#include "symfile.h", "symtab.h", "block.h", "objfiles.h".
	New variable namespace_block.
	(get_namespace_block): New function.
	(free_namespace_block): New function.
@
text
@a28 26
#include "symtab.h"
#include "symfile.h"
#include "block.h"
#include "objfiles.h"
#include "gdbtypes.h"
#include "dictionary.h"
#include "gdbcmd.h"

static const char *find_last_component (const char *name);

/* This block exists only to store symbols associated to namespaces.
   Normally, try to avoid accessing it directly: instead, use
   get_namespace_block if you can.  Similarly with
   namespace_objfile.  */

static struct block *namespace_block = NULL;

static struct objfile *namespace_objfile = NULL;

static struct block *get_namespace_block (void);

static struct objfile *get_namespace_objfile (void);

static void free_namespace_block (struct symtab *symtab);

static void maintenance_print_namespace (char *args, int from_tty);
a347 133
}

/* Locate the namespace_block, allocating it if necessary.  */

static struct block *
get_namespace_block (void)
{
  if (namespace_block == NULL)
    {
      struct objfile *objfile = get_namespace_objfile ();
      struct symtab *namespace_symtab;
      struct blockvector *bv;
      struct block *bl;

      namespace_symtab = allocate_symtab ("<C++-namespaces>", objfile);
      namespace_symtab->language = language_cplus;
      namespace_symtab->free_code = free_nothing;
      namespace_symtab->dirname = NULL;

      bv = obstack_alloc (&objfile->symbol_obstack,
			  sizeof (struct blockvector));
      BLOCKVECTOR_NBLOCKS (bv) = 1;
      BLOCKVECTOR (namespace_symtab) = bv;
      
      /* Allocate dummy STATIC_BLOCK. */
      bl = obstack_alloc (&objfile->symbol_obstack, sizeof (struct block));
      BLOCK_START (bl) = 0;
      BLOCK_END (bl) = 0;
      BLOCK_FUNCTION (bl) = NULL;
      BLOCK_SUPERBLOCK (bl) = NULL;
      BLOCK_DICT (bl) = dict_create_linear (&objfile->symbol_obstack,
					    NULL);
      BLOCK_NAMESPACE (bl) = NULL;
      BLOCK_GCC_COMPILED (bl) = 0;
      BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK) = bl;

      /* Allocate GLOBAL_BLOCK.  */
      bl = (struct block *)
	obstack_alloc (&objfile->symbol_obstack, sizeof (struct block));
      *bl = *BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
      BLOCK_DICT (bl) = dict_create_linear_expandable ();
      BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK) = bl;
      namespace_symtab->free_func = free_namespace_block;

      namespace_block = bl;
    }

  return namespace_block;
}

/* Free the dictionary associated to the namespace block.  */

static void
free_namespace_block (struct symtab *symtab)
{
  gdb_assert (namespace_block != NULL);
  dict_free (BLOCK_DICT (namespace_block));
  namespace_block = NULL;
  namespace_objfile = NULL;
}

/* Locate the namespace objfile, allocating it if necessary.  */

static struct objfile *
get_namespace_objfile (void)
{
  if (namespace_objfile == NULL)
    {
      namespace_objfile = allocate_objfile (NULL, 0);
    }

  return namespace_objfile;
}

/* Check to see if there's already a namespace symbol corresponding to
   the initial substring of NAME whose length is LEN; if there isn't
   one, allocate one and add it to the namespace symtab.  Return the
   symbol in question.  */

struct symbol *
cp_check_namespace_symbol (const char *name, int len)
{
  struct objfile *objfile = get_namespace_objfile ();
  char *name_copy = obsavestring (name, len, &objfile->symbol_obstack);
  const struct block *block = get_namespace_block ();
  struct symbol *sym = lookup_block_symbol (block, name_copy,
					    NULL, VAR_NAMESPACE);

  if (sym == NULL)
    {
      struct type *type = alloc_type (objfile);
      INIT_CPLUS_SPECIFIC (type);
      TYPE_TAG_NAME (type) = obsavestring (name, len, &objfile->type_obstack);
      TYPE_CODE (type) = TYPE_CODE_NAMESPACE;
      TYPE_LENGTH (type) = 0;
      
      sym = obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol));
      memset (sym, 0, sizeof (struct symbol));
      SYMBOL_LANGUAGE (sym) = language_cplus;
      SYMBOL_NAME (sym) = name_copy;
      SYMBOL_CLASS (sym) = LOC_TYPEDEF;
      SYMBOL_TYPE (sym) = type;
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;

      dict_add_symbol (BLOCK_DICT (block), sym);
    }
  else
    {
      obstack_free (&objfile->symbol_obstack, name_copy);
    }

  return sym;
}

static void
maintenance_print_namespace (char *args, int from_tty)
{
  const struct block *block = get_namespace_block ();
  struct dict_iterator iter;
  struct symbol *sym;

  ALL_BLOCK_SYMBOLS (block, iter, sym)
    {
      printf_unfiltered ("%s\n", SYMBOL_BEST_NAME (sym));
    }
}

void
_initialize_cp_support (void)
{
  add_cmd ("namespace", class_maintenance, maintenance_print_namespace,
	   "Print the list of current known C++ namespaces.",
	   &maintenanceprintlist);
@


1.1.2.7
log
@2002-11-21  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c (get_namespace_objfile): Set
	namespace_objfile->name.
	* dwarf2read.c (scan_partial_symbols): Allow empty pdi.name if
	we're reading a namespace.
	* Makefile.in (dwarf2read.o): Depend on cp_support_h.
	* dwarf2read.c (scan_partial_symbols): Add 'namespace' arg.
	(dwarf2_build_psymtabs_hard): Update call to
	scan_partial_symbols.
	(add_partial_namespace): New function.
	(scan_partial_symbols): Call add_partial_namespace.
	#include "cp-support.h"
	* cp-support.c: Add me to contributors.
	* cp-support.h: Ditto.
	* buildsym.c (scan_for_anonymous_namespaces): Convert for loop
	into a clearer while loop.
	(finish_block): Ditto.
@
text
@d4 1
a4 2
   Contributed by MontaVista Software and by David Carlton, Stanford
   University.
a442 1
      namespace_objfile->name = "<C++-namespaces>";
@


1.1.2.8
log
@2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (examine_compound_token): Rewrite as switch
	statement, and add FIXME comment.
	* frame.h: Make arg of block_innermost_frame const.
	* blockframe.c (block_innermost_frame): Make arg const.
	* block.h: Make args to block_function, contained_in const.
	* block.c (block_function): Make arg const.
	(contained_in): Ditto.
	* value.h: Make arg of symbol_read_needs_frame const.
	* findvar.c (symbol_read_needs_frame): Make arg const.
	* symtab.h: Make first arg of symbol_demangled_name const.
	* symtab.c (symbol_demangled_name): Make arg const.
	* value.h: Make first arg of read_var_value const.
	* findvar.c (read_var_value): Make first arg const.
	* Makefile.in (valops.o): Depend on cp_support_h.
	* valops.c: #include "cp-support.h"
	* symtab.h: Add FIXME about name of namespace_enum.
	Add opaque declaration of struct using_direct_node.
	* symtab.c (lookup_symbol_namespace): Make extern; rename args.
	* symtab.h: Declare lookup_symbol_namespace.
	* valops.c (value_struct_elt_for_reference): Make 'name' a const
	char *.
	(value_namespace_elt): New function.
	* expprint.c (print_subexp): Ditto.
	(dump_subexp): Ditto.
	* parse.c (length_of_subexp): Ditto.
	(prefixify_subexp): Ditto.
	* expression.h: Update comment to reflect the block in OP_SCOPE.
	* c-exp.y: Set block in OP_SCOPE expression.
	* jv-exp.y (push_qualified_expression_name): Put a NULL block in
	OP_SCOPE expression.
	* objc-exp.y: Ditto.
	* p-exp.y: Ditto.
	* eval.c (evaluate_subexp_standard): Handle OP_SCOPE via
	value_aggregate_elt.
	* value.h: Add declaration for value_aggregate_elt; delete
	declaration for value_struct_elt_for_reference.
	* valops.c (value_aggregate_elt): New function.
	(value_struct_elt_for_reference): Make static.  Don't check type
	of curtype.
	* c-exp.y: Accept TYPE_CODE_NAMESPACE in qualified_name.
	* cp-support.c (cp_check_namespace_symbol): Set TYPE_NAME (type).

2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change a couple of tests to not use
	single quotes.
@
text
@a468 1
      TYPE_NAME (type) = TYPE_TAG_NAME (type);
@


1.1.2.9
log
@2002-11-24  David Carlton  <carlton@@bactrian.org>

	* Makefile.in (c-typeprint.o): Depend on gdb_assert_h.
	* c-typeprint.c: #include "gdb_assert.h"
	* gdbtypes.c (recursive_dump_type): Handle TYPE_CODE_NAMESPACE.
	* c-typeprint.c (c_type_print_varspec_prefix): Ditto.
	(c_type_print_varspec_suffix): Ditto.
	(c_type_print_base): Ditto.
	* typeprint.c (print_type_scalar): Ditto.
	* printcmd.c (print_formatted): Ditto.
	* language.c (structured_type): Ditto.
	* cp-support.c (cp_check_namespace_symbol): Allocate type via
	init_type.
	* gdbtypes.c (init_type): Handle TYPE_CODE_NAMESPACE.
	* valops.c (value_namespace_elt): Handle sym == NULL.

2002-11-24  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/namespace.exp: Eliminate some of the single quotes, and
	duplicate some of the single quote tests without the quotes.
	Change "print E::ce" test.
	Add some ptype <namespace> tests.
	* carlton_runnamespace: Use different files for compiler with and
	without debug info.
@
text
@d466 7
a472 4
      struct type *type = init_type (TYPE_CODE_NAMESPACE, 0, 0,
				     name_copy, objfile);
      TYPE_TAG_NAME (type) = TYPE_NAME (type);

@


1.1.2.10
log
@2002-12-18  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_file): Call
	cp_lookup_possible_namespace_symbol.
	* dwarf2read.c (add_partial_symbol): Sometimes check for possible
	namespace symbols.
	* cp-support.c (maintenance_print_namespace): Handle
	possible_namespace_block, too.
	(cp_lookup_possible_namespace_symbol): New function.
	* cp-support.h: Declare cp_check_possible_namespace_symbols,
	cp_lookup_possible_namespace_symbol.
	* cp-support.c (check_one_possible_namespace_symbol): New
	function.
	(cp_check_possible_namespace_symbols): New function.
	(check_possible_namespace_symbols_loop): New function.
	* symfile.h: Update declaration for add_psymbol_to_list.
	* symfile.c (psymbol_init_demangled_name): New function.
	(add_psymbol_to_list): Change SYMBOL_INIT_LANGUAGE_SPECIFIC to
	psymbol_init_demangled_name.
	(add_psymbol_to_list): Return a const struct psymbol *.
	* Makefile.in (dwarf2read.o): Don't depend on bcache_h.
	* dwarf2read.c: Don't #include "bcache.h"
	* cp-support.c (get_namespace_block): Allocate blocks via
	allocate_block.
	(initialize_namespace_blocks): New function.
	New variable possible_namespace_block.
	(get_namespace_block): Call initialize_namespace_blocks.
	(free_namespace_blocks): Rename from free_namespace_block; handle
	possible_namespace_block, too.
	(get_possible_namespace_block): New function.
	* jv-lang.c (get_java_class_symtab): Ditto.
	* block.c (allocate_block): New function.
	* block.h: Declare allocate_block.
@
text
@d43 1
a43 1
   possible_namespace_block and namespace_objfile.  */
a46 2
static struct block *possible_namespace_block = NULL;

a48 2
static void initialize_namespace_blocks (void);

a50 2
static struct block *get_possible_namespace_block (void);

d53 1
a53 7
static void free_namespace_blocks (struct symtab *symtab);

static int check_one_possible_namespace_symbol (const char *name,
						int len);

static int check_possible_namespace_symbols_loop (const char *name,
						  int len);
d377 1
a377 50
/* Allocate everything necessary for namespace_block and
   possible_namespace_block.  */

static void
initialize_namespace_blocks (void)
{
  struct objfile *objfile = get_namespace_objfile ();
  struct symtab *namespace_symtab;
  struct blockvector *bv;
  struct block *bl;

  namespace_symtab = allocate_symtab ("<C++-namespaces>", objfile);
  namespace_symtab->language = language_cplus;
  namespace_symtab->free_code = free_nothing;
  namespace_symtab->dirname = NULL;

  /* 2 = 3 blocks (global = namespace_block, static = NULL,
     possible_namespace_block) - 1 block that's always part of struct
     blockvector.  */
  bv = obstack_alloc (&objfile->symbol_obstack,
		      sizeof (struct blockvector)
		      + 2 * sizeof (struct block *));
  BLOCKVECTOR_NBLOCKS (bv) = 3;
  BLOCKVECTOR (namespace_symtab) = bv;
  
  /* Allocate dummy STATIC_BLOCK. */
  bl = allocate_block (&objfile->symbol_obstack);
  BLOCK_DICT (bl) = dict_create_linear (&objfile->symbol_obstack,
					NULL);
  BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK) = bl;

  /* Allocate GLOBAL_BLOCK, which is namespace_block.  */
  bl = allocate_block (&objfile->symbol_obstack);
  BLOCK_DICT (bl) = dict_create_linear_expandable ();
  BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK) = bl;
  namespace_block = bl;

  /* Allocate possible_namespace_block; we put it where the first
     local block will live, though I don't think there's any need to
     pretend that it's actually a local block (e.g. by setting
     BLOCK_SUPERBLOCK appropriately).  */
  bl = allocate_block (&objfile->symbol_obstack);
  BLOCK_DICT (bl) = dict_create_linear_expandable ();
  BLOCKVECTOR_BLOCK (bv, 2) = bl;
  possible_namespace_block = bl;

  namespace_symtab->free_func = free_namespace_blocks;
}

/* Locate namespace_block, allocating it if necessary.  */
d383 38
a420 1
    initialize_namespace_blocks ();
a424 11
/* Locate possible_namespace_block, allocating it if necessary.  */

static struct block *
get_possible_namespace_block (void)
{
  if (namespace_block == NULL)
    initialize_namespace_blocks ();

  return possible_namespace_block;
}

d428 1
a428 1
free_namespace_blocks (struct symtab *symtab)
a432 2
  dict_free (BLOCK_DICT (possible_namespace_block));
  possible_namespace_block = NULL;
a487 99
/* The next few functions deal with "possible namespace symbols".
   These are symbols that claim to be associated to namespaces,
   whereas in fact we don't know if the object of that name is a
   namespace or a class.  So don't trust them until you've searched
   through all the global symbols to see if there's a class of that
   name or not.  */

/* FIXME: carlton/2002-12-18: This concept is a hack.  But it seems to
   be the easiest way to deal with our desire for namespace symbols,
   given the commonness of compilers that don't generate debugging
   info for them.  Once such compilers are more common, we should
   delete all the possible namespace stuff.  */

/* Check to see if there's already a possible namespace symbol whose
   name is the initial substring of NAME of length LEN.  If not,
   create one and return 0; otherwise, return 1.  */

static int
check_one_possible_namespace_symbol (const char *name, int len)
{
  struct objfile *objfile = get_namespace_objfile ();
  char *name_copy = obsavestring (name, len, &objfile->symbol_obstack);
  const struct block *block = get_possible_namespace_block ();
  struct symbol *sym = lookup_block_symbol (block, name_copy,
					    NULL, VAR_NAMESPACE);

  if (sym == NULL)
    {
      struct type *type = init_type (TYPE_CODE_NAMESPACE, 0, 0,
				     name_copy, objfile);
      TYPE_TAG_NAME (type) = TYPE_NAME (type);

      sym = obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol));
      memset (sym, 0, sizeof (struct symbol));
      SYMBOL_LANGUAGE (sym) = language_cplus;
      SYMBOL_NAME (sym) = name_copy;
      SYMBOL_CLASS (sym) = LOC_TYPEDEF;
      SYMBOL_TYPE (sym) = type;
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;

      dict_add_symbol (BLOCK_DICT (block), sym);
      return 0;
    }
  else
    {
      obstack_free (&objfile->symbol_obstack, name_copy);
      return 1;
    }
}

/* This is a helper loop for cp_check_possible_namespace_symbols; it
   ensures that there are namespace symbols for all namespaces that
   are initial substrings of NAME of length LEN.  It returns 1 if a
   previous loop had already created the shortest such symbol and 0
   otherwise.  */

static int
check_possible_namespace_symbols_loop (const char *name, int len)
{
  if (name[len] == ':')
    {
      const char *next_name = cp_find_first_component (name + len + 2);
      int done = check_possible_namespace_symbols_loop (name,
							next_name - name);

      if (!done)
	{
	  done = check_one_possible_namespace_symbol (name, len);
	}
      return done;
    }
  else
    return 0;
}

/* Ensure that there are symbols in possible_namespace_block for all
   initial substrings of NAME that look like namespaces or
   classes.  */

void
cp_check_possible_namespace_symbols (const char *name)
{
  check_possible_namespace_symbols_loop (name,
					 cp_find_first_component (name)
					 - name);
}

/* Look up a symbol in possible_namespace_block named NAME.  Note that
   there's no corresponding function for regular namespace symbols:
   those get searched via the normal search of all global blocks in
   lookup_symbol.  */

struct symbol *
cp_lookup_possible_namespace_symbol (const char *name)
{
  return lookup_block_symbol (get_possible_namespace_block (),
			      name, NULL, VAR_NAMESPACE);
}

d491 1
a491 3
  const struct block *namespace_block = get_namespace_block ();
  const struct block *possible_namespace_block
    = get_possible_namespace_block ();
d495 1
a495 7
  printf_unfiltered ("Definite namespaces:\n");
  ALL_BLOCK_SYMBOLS (namespace_block, iter, sym)
    {
      printf_unfiltered ("%s\n", SYMBOL_BEST_NAME (sym));
    }
  printf_unfiltered ("Possible namespaces:\n");
  ALL_BLOCK_SYMBOLS (possible_namespace_block, iter, sym)
@


1.1.2.11
log
@2003-01-06  David Carlton  <carlton@@math.stanford.edu>

	* config/djgpp/fnchange.lst: Mention
	testsuite/gdb.c++/namespace1.cc.
	* cp-support.h: Declare cp_lookup_namespace_symbol.
	* cp-support.c (cp_lookup_namespace_symbol): New function.
	(cp_check_namespace_symbol): Call cp_lookup_namespace_symbol.
	(cp_lookup_possible_namespace_symbol): Update comment.
	* symtab.c (lookup_symbol_aux_file): Add 'anonymous_namespace'
	argument.
	(lookup_symbol_namespace): Call lookup_symbol_aux_file with new
	argument.
	* cp-support.h: Declare cp_is_anonymous.
	* cp-support.c (cp_is_anonymous): New function.
	* buildsym.c (add_symbol_to_list): Don't test for anonymous
	namespace mention here.
	(scan_for_anonymous_namespaces): Test for it here, instead.
	* symtab.c (lookup_symbol_aux_minsyms): Delete.
	(lookup_symbol_aux_nonlocal): Don't call
	lookup_symbol_aux_minsyms.

2003-01-06  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Test anonymous namespaces and multiple
	files.
	* gdb.c++/namespace1.cc: Add anonymous namespaces.
@
text
@d497 3
a499 1
  struct symbol *sym = cp_lookup_namespace_symbol (name_copy);
d515 1
a515 1
      dict_add_symbol (BLOCK_DICT (get_namespace_block ()), sym);
a524 9
/* Look for a symbol in namespace_block named NAME.  */

struct symbol *
cp_lookup_namespace_symbol (const char *name)
{
  return lookup_block_symbol (get_namespace_block (), name, NULL,
			      VAR_NAMESPACE);
}

d612 4
a615 1
/* Look for a symbol in possible_namespace_block named NAME.  */
a642 18
}

/* Test whether or not the initial substring of NAMESPACE_NAME of
   length NAMESPACE_LEN mentions an anonymous namespace.
   NAMESPACE_NAME must be a NULL-terminated string.  If NAMESPACE_LEN
   is -1, search the entire string.  */

int
cp_is_anonymous (const char *namespace_name, int namespace_len)
{
  const char *location = strstr (namespace_name, "(anonymous namespace)");

  if (location == NULL)
    return 0;
  else if (namespace_len == -1)
    return 1;
  else
    return (location - namespace_name) < namespace_len;
@


1.1.2.12
log
@2003-01-31  David Carlton  <carlton@@math.stanford.edu>

	From Jim Blandy  <jimb@@redhat.com>:

	Use a single, consistent representation for an empty minimal
	symbol table in an objfile.
	* objfiles.c (terminate_minimal_symbol_table): New function.
	(allocate_objfile): Call it.
	* objfiles.h (terminate_minimal_symbol_table): New declaration.
	(ALL_MSYMBOLS): No need to test whether (objfile)->msymbols is
	non-NULL.
	* minsyms.c (lookup_minimal_symbol_by_pc_section): To see whether
	objfile has minimal symbols, compare minimal_symbol_count to zero,
	instead of comparing msymbols with NULL.
	* objfiles.c (have_minimal_symbols): Same.
	* solib-sunos.c (solib_add_common_symbols): Call
	terminate_minimal_symbol_table.
	* symfile.c (reread_symbols): Same.

	* objfiles.h: Revert patch from 2003-01-27, to be replaced by
	similar patch from Jim Blandy.
	* objfiles.c (objfile_relocate): Ditto.
	* i386-linux-tdep.c (find_minsym_and_objfile): Ditto.
	* arm-linux-tdep.c (find_minsym_and_objfile): Ditto.
	* gdbtypes.h: Delete INTEGER_COERCION_BADNESS,
	FLOAT_COERCION_BADNESS.
	* gdbtypes.c (rank_one_type): Replace all uses of
	INTEGER_COERCION_BADNESS by INTEGER_CONVERSION_BADNESS.
	* valops.c (find_overload_match): Call cp_func_name.
	* cp-support.h: Declare cp_func_name.
	* cp-support.c (cp_func_name): New function.

2003-01-30  David Carlton  <carlton@@math.stanford.edu>

	* valops.c (find_overload_match): Move code into
	find_oload_champ_namespace.
	(find_oload_champ_namespace): New function, which immediately gets
	eviscerated and turned into a call to
	find_oload_champ_namespace_loop.
	(find_oload_champ_namespace_loop): New function.
	* symtab.c (make_symbol_overload_list): Move entire body into
	make_symbol_overload_list_qualified.
	(make_symbol_overload_list_qualified): New.
	(read_in_psymtabs): New.
	(make_symbol_overload_list_qualified): Rewrite.
	(make_symbol_overload_list_using): New.
	(lookup_symbol_namespace): Use alloca, not xmalloc.
	(make_symbol_overload_list): Put some memory management stuff back
	in.
@
text
@a666 26
/* If FULL_NAME is the demangled name of a C++ function (including an
   arg list, possibly including namespace/class qualifications),
   return a new string containing only the function name (without the
   arg list/class qualifications).  Otherwise, return NULL.  Caller is
   responsible for freeing the memory in question.  */

char *
cp_func_name (const char *full_name)
{
  const char *previous_component = full_name;
  const char *next_component;

  if (!full_name)
    return NULL;

  for (next_component = cp_find_first_component (previous_component);
       *next_component == ':';
       next_component = cp_find_first_component (previous_component))
    {
      /* Skip '::'.  */
      previous_component = next_component + 2;
    }

  return remove_params (previous_component);
}

@


1.1.2.13
log
@2003-02-12  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (examine_compound_token): Call decode_namespace.
	(decode_namespace): New function.
	* cp-support.c (cp_find_first_component): Return the offset, not a
	pointer.
	(check_possible_namespace_symbols_loop): Update call to
	cp_find_first_component.
	(cp_check_possible_namespace_symbols): Ditto.
	(cp_func_name): Ditto.
	* buildsym.c (scan_for_anonymous_namespaces): Ditto.
	(finish_block): Ditto.
	* linespec.c (examine_compound_token): Ditto.
	* symtab.c (lookup_symbol_aux_using_loop): Ditto.
	* valops.c (find_oload_champ_namespace_loop): Ditto.
	* cp-support.h: Declare cp_find_first_component to return an int.
	* Makefile.in (linespec.o): cp_support_h.
	* linespec.c (symtab_from_filename): Rename from handle_filename.
	(decode_line_1): Call symtab_from_filename instead of
	handle_filename.
	(locate_compound_sym): Rename from locate_class_sym.  Search in
	such a way that we find namespace symbols, too.
	(examine_compound_token): Call locate_class_sym instead of
	locate_compound_sym.
	(locate_compound_sym): Add NAMESPACE arg.
	(examine_compound_token): New arg to locate_compound_sym.
	Handle TYPE_CODE_NAMESPACE.
	#include "cp-support.hp"
@
text
@d323 2
a324 2
int
cp_find_first_component (const char *const name)
a329 2
  int index = 0;

d332 2
a333 2
      index += LENGTH_OF_OPERATOR;
      switch (name[index])
d336 2
a337 2
	  if (name[index + 1] == '<')
	    index += 2;
d339 1
a339 1
	    index += 1;
d343 2
a344 2
	  if (name[index + 1] == '>')
	    index += 2;
d346 1
a346 1
	    index += 1;
d349 1
a349 1
	  index += 2;
d352 1
a352 1
	  index += 1;
d357 1
a357 1
  for (;; ++index)
d359 1
a359 1
      switch (name[index])
d366 4
a369 8
	  index += 1;
	  for (index += cp_find_first_component (name + index);
	       name[index] != '>';
	       index += cp_find_first_component (name + index))
	    {
	      gdb_assert (name[index] == ':');
	      index += 2;
	    }
d373 4
a376 8
	  index += 1;
	  for (index += cp_find_first_component (name + index);
	       name[index] != ')';
	       index += cp_find_first_component (name + index))
	    {
	      gdb_assert (name[index] == ':');
	      index += 2;
	    }
d382 1
a382 1
	  return index;
d593 3
a595 5
      int done;
      int next_len = len + 2;

      next_len += cp_find_first_component (name + next_len);
      done = check_possible_namespace_symbols_loop (name, next_len);
a600 1

d615 2
a616 1
					 cp_find_first_component (name));
d682 1
a682 2
  for (next_component = (previous_component
			 + cp_find_first_component (previous_component));
d684 1
a684 2
       next_component = (previous_component
			 + cp_find_first_component (previous_component)))
@


1.1.2.14
log
@2003-02-19  David Carlton  <carlton@@math.stanford.edu>

	* mdebugread.c (new_block): Add 'function' arg.
	(parse_symbol): New arg to new_block.
	(new_symtab): Ditto.
	(fixup_sigtramp): Ditto.
	* cp-support.c (initialize_namespace_blocks): Use
	dict_hashed_expandable instead of dict_linear_expandable.
	* jv-lang.c (get_java_class_symtab): Ditto.
	* dictionary.c (enum dict_type): Add DICT_HASHED_EXPANDABLE.
	(struct dictionary_hashed_expandable): New.
	(struct dictionary): Add hashed_expandable member.
	(DICT_EXPANDABLE_INITIAL_CAPACITY): Rename from
	DICT_LINEAR_EXPANDABLE_INITIAL_CAPACITY.
	(dict_create_linear_expandable): Use
	DICT_EXPANDABLE_INITIAL_CAPACITY.
	(dict_linear_vtbl): New.
	(dict_create_hashed_expandable): New.
	(add_symbol_hashed_expandable): New.
	(dict_create_hashed): Move code into insert_symbol_hashed.
	(insert_symbol_hashed): New.
	(expand_hashtable): New.
	* dictionary.h: Declare dict_create_hashed_expandable.
@
text
@d432 1
a432 1
  BLOCK_DICT (bl) = dict_create_hashed_expandable ();
d441 1
a441 1
  BLOCK_DICT (bl) = dict_create_hashed_expandable ();
@


1.1.2.15
log
@2003-02-21  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (locate_compound_sym): Update call to
	lookup_symbol_namespace.
	* symtab.c (make_symbol_overload_list): Delete namespace_len
	argument.
	* symtab.h: Update declaration for make_symbol_overload_list.
	* valops.c (find_oload_champ_namespace_loop): New format for
	make_symbol_overload_list.
	* symtab.c (lookup_symbol_namespace): Delete namespace_len
	argument.
	(lookup_symbol_aux_using_loop): Update call to
	lookup_symbol_namespace.
	(make_symbol_overload_list_using): Delete namespace_len argument.
	* linespec.c (decode_namespace): Update call to
	lookup_symbol_namespace.
	* valops.c (value_namespace_elt): Ditto.
	* symtab.c (lookup_nested_type): Ditto.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* block.c (block_all_usings): Delete.
	(block_using): Make static.
	(block_using_iterator_next): New using_direct format.
	(block_using_iterator_first): Ditto.
	* buildsym.c (scan_for_anonymous_namespaces): Rename variables.
	(add_using_directive): New using functions.
	(end_symtab): Use cp_copy_usings.
	(copy_usings_to_obstack): Delete.
	* block.c: Tweak initial comment.
	(struct namespace_info): Move here.
	(block_initialize_namespace): Set scope to NULL!
	* block.h: Add compilation guards.
	Reorder and update declarations.
	* cp-support.c (cp_find_first_component): Return unsigned int.
	(cp_entire_prefix_len): New.
	(cp_add_using_obstack): Delete.
	(cp_add_using_xmalloc): Delete.
	(cp_copy_usings): Rewrite.
	(cp_free_usings): Delete.
	(cp_add_using): New.
	(cp_is_anonymous): Delete second argument.
	(xstrndup): New.
	* cp-support.h: Add compilation guards.
	Update declarations.
	* coffread.c: New variable coff_source_file.
	(coff_start_symtab): Use coff_source_file.
	(complete_symtab): Ditto.
	(coff_end_symtab): Ditto.
	(coff_symtab_read): Ditto.
	* dbxread.c (find_stab_function_addr): Const fix.
	* buildsym.h: Const fix.
	* buildsym.c (start_symtab): Const fix.
	(start_subfile): Ditto.
	* cp-support.c (cp_add_using_xmalloc): Copy name.
	* dwarf2read.c (read_namespace): Loop through extensions
	correctly.
	(read_file_scope): Const fix.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(read_typedef): Ditto.
	* buildsym.c (finish_block): Update comments and simplify code
	when setting scope.
	* buildsym.h: Add opaque declaration of 'struct block'.
	Change comment before processing_current_prefix.
	* arm-tdep.c (arm_gdbarch_init): Add break; after default:.
@
text
@d2 1
a2 1
   Copyright 2002, 2003 Free Software Foundation, Inc.
d4 2
a5 1
   Contributed by MontaVista Software and Stanford University.
d28 1
a29 1
#include "gdb_obstack.h"
a37 2
static char *xstrndup (const char *string, size_t len);

d81 3
a83 3
     demangled name might not end with ')': it could be a const or
     volatile class method, in which case it ends with "const" or
     "volatile".
d218 93
a310 3
/* This returns the length of first component of NAME, which should be
   the demangled name of a C++ variable/function/method/etc.
   Specifically, it returns the index of the first colon forming the
d312 2
a313 1
   it returns the 1, and given 'foo', it returns 0.  */
d323 2
a324 2
unsigned int
cp_find_first_component (const char *name)
d330 1
a330 1
  unsigned int index = 0;
a398 78
/* If NAME is the fully-qualified name of a C++
   function/variable/method/etc., this returns the length of its
   entire prefix: all of the namespaces and classes that make up its
   name.  Given 'A::foo', it returns 1, given 'A::B::foo', it returns
   4, given 'foo', it returns 0.  */

unsigned int cp_entire_prefix_len (const char *name)
{
  unsigned int current_len = cp_find_first_component (name);
  unsigned int previous_len = 0;

  while (name[current_len] != '\0')
    {
      gdb_assert (name[current_len] == ':');
      previous_len = current_len;
      /* Skip the '::'.  */
      current_len += 2;
      current_len += cp_find_first_component (name + current_len);
    }

  return previous_len;
}

/* Create a new struct using direct whose inner namespace is the
   initial substring of NAME of leng INNER_LEN and whose outer
   namespace is the initial substring of NAME of length OUTER_LENGTH.
   Set its next member in the linked list to NEXT; allocate all memory
   using xmalloc.  It copies the strings, so NAME can be a temporary
   string.  */

struct using_direct *
cp_add_using (const char *name,
	      unsigned int inner_len,
	      unsigned int outer_len,
	      struct using_direct *next)
{
  struct using_direct *retval;

  gdb_assert (outer_len < inner_len);

  retval = xmalloc (sizeof (struct using_direct));
  retval->inner = xstrndup (name, inner_len);
  retval->outer = xstrndup (name, outer_len);
  retval->next = next;

  return retval;
}

/* Make a copy of the using directives in the list pointed to by
   USING, using OBSTACK to allocate memory.  Free all memory pointed
   to by USING via xfree.  */

extern struct using_direct *
cp_copy_usings (struct using_direct *using,
		struct obstack *obstack)
{
  if (using == NULL)
    {
      return NULL;
    }
  else
    {
      struct using_direct *retval
	= obstack_alloc (obstack, sizeof (struct using_direct));
      retval->inner = obsavestring (using->inner, strlen (using->inner),
				    obstack);
      retval->outer = obsavestring (using->outer, strlen (using->outer),
				    obstack);
      retval->next = cp_copy_usings (using->next, obstack);

      xfree (using->inner);
      xfree (using->outer);
      xfree (using);

      return retval;
    }
}

d661 4
a664 2
/* Test whether or not NAMESPACE looks like it mentions an anonymous
   namespace; return nonzero if so.  */
d667 1
a667 1
cp_is_anonymous (const char *namespace)
d669 1
a669 3
  return (strstr (namespace, "(anonymous namespace)")
	  != NULL);
}
d671 6
a676 12
/* Create a copy of the initial substring of STRING of length LEN.
   Allocate memory via xmalloc.  */

static char *
xstrndup (const char *string, size_t len)
{
  char *retval = xmalloc (len + 1);

  strncpy (retval, string, len);
  retval[len] = '\0';

  return retval;
@


1.1.2.16
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d506 1
a506 1
      DEPRECATED_SYMBOL_NAME (sym) = name_copy;
d565 1
a565 1
      DEPRECATED_SYMBOL_NAME (sym) = name_copy;
d640 1
a640 1
      printf_unfiltered ("%s\n", SYMBOL_PRINT_NAME (sym));
d645 1
a645 1
      printf_unfiltered ("%s\n", SYMBOL_PRINT_NAME (sym));
@


1.1.2.17
log
@2003-03-10  David Carlton  <carlton@@math.stanford.edu>

	* buildsym.c (scan_for_anonymous_namespaces): Allow
	"{anonymous}".
	* cp-support.c (cp_is_anonymous): Scan for "{anonymous}".
@
text
@d650 1
a650 2
   namespace; return 1 if it mentions "(anonymous namespace)", 2 if it
   mentions "{anonymous}", and 0 otherwise.  */
d655 2
a656 6
  if (strstr (namespace, "(anonymous namespace)") != NULL)
    return 1;
  else if (strstr (namespace, "{anonymous}") != NULL)
    return 2;
  else
    return 0;
@


1.1.2.18
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a23 1
#include <ctype.h>
d37 1
a37 8
/* The list of "maint cplus" commands.  */

static struct cmd_list_element *maint_cplus_cmd_list = NULL;

/* The actual commands.  */

static void maint_cplus_command (char *arg, int from_tty);
static void first_component_command (char *arg, int from_tty);
d95 1
a95 1
/* NOTE: carlton/2003-02-21: Daniel Jacobowitz came up with an example
d101 2
a102 3
/* FIXME: carlton/2003-03-13: We have several functions here with
   overlapping functionality; can we combine them?  Also, do they
   handle all the above considerations correctly?  */
a228 5
/* NOTE: carlton/2003-03-13: This function is currently only intended
   for internal use: it's probably not entirely safe when called on
   user-generated input, because some of the 'index += 2' lines might
   go past the end of malformed input.  */

a244 2
      while (isspace(name[index]))
	++index;
d315 1
a315 2
unsigned int
cp_entire_prefix_len (const char *name)
d332 55
d649 29
a705 25
/* Don't allow just "maintenance cplus".  */

static  void
maint_cplus_command (char *arg, int from_tty)
{
  printf_unfiltered ("\"maintenance cplus\" must be followed by the name of a command.\n");
  help_list (maint_cplus_cmd_list, "maintenance cplus ", -1, gdb_stdout);
}

/* This is a front end for cp_find_first_component, for unit testing.
   Be careful when using it: see the NOTE above
   cp_find_first_component.  */

static void
first_component_command (char *arg, int from_tty)
{
  int len = cp_find_first_component (arg);
  char *prefix = alloca (len + 1);

  memcpy (prefix, arg, len);
  prefix[len] = '\0';

  printf_unfiltered ("%s\n", prefix);
}

a708 8
  add_prefix_cmd ("cplus", class_maintenance, maint_cplus_command,
		  "C++ maintenance commands.", &maint_cplus_cmd_list,
		  "maintenance cplus ", 0, &maintenancelist);
  add_alias_cmd ("cp", "cplus", class_maintenance, 1, &maintenancelist);

  add_cmd ("first_component", class_maintenance, first_component_command,
	   "Print the first class/namespace component of NAME.",
	   &maint_cplus_cmd_list);
@


1.1.2.19
log
@2003-04-18  David Carlton  <carlton@@bactrian.org>

	* mdebugread.c (parse_symbol): Move up declaration of 'iter'.
	* dwarf2read.c (add_partial_namespace): Move up declaration of
	'full_name'.
	* cp-support.c (cp_find_first_component): Accept 'operator' in
	more locations.

2003-04-18  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/maint.exp (test_first_component): Add tests for
	'operator' in more locations.
@
text
@d98 10
a107 1
   - And operator names can contain parentheses or angle brackets.  */
d250 4
d255 29
a283 7
  /* Operator names can show up in unexpected places.  Since these can
     contain parentheses or angle brackets, they can screw up the
     recursion.  But not every string 'operator' is part of an
     operater name: e.g. you could have a variable 'cooperator'.  So
     this variable tells us whether or not we should treat the string
     'operator' as starting an operator.  */
  int operator_possible = 1;
a301 1
	  operator_possible = 1;
a312 1
	  operator_possible = 1;
a318 48
	case 'o':
	  /* Operator names can screw up the recurson.  */
	  if (operator_possible
	      && strncmp (name + index, "operator", LENGTH_OF_OPERATOR) == 0)
	    {
	      index += LENGTH_OF_OPERATOR;
	      while (isspace(name[index]))
		++index;
	      switch (name[index])
		{
		  /* Skip over one less than the appropriate number of
		     characters: the for loop will skip over the last
		     one.  */
		case '<':
		  if (name[index + 1] == '<')
		    index += 1;
		  else
		    index += 0;
		  break;
		case '>':
		case '-':
		  if (name[index + 1] == '>')
		    index += 1;
		  else
		    index += 0;
		  break;
		case '(':
		  index += 1;
		  break;
		default:
		  index += 0;
		  break;
		}
	    }
	  operator_possible = 0;
	  break;
	case ' ':
	case ',':
	case '.':
	case '&':
	case '*':
	  /* NOTE: carlton/2003-04-18: I'm not sure what the precise
	     set of relevant characters are here: it's necessary to
	     include any character that can show up before 'operator'
	     in a demangled name, and it's safe to include any
	     character that can't be part of an identifier's name.  */
	  operator_possible = 1;
	  break;
a319 1
	  operator_possible = 0;
@


1.1.2.20
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* Makefile.in (cp-namespace.o): Update dependencies.
	(cp-support.o): Ditto.
	* cp-support.h: Declare maint_cplus_cmd_list.
	* cp-namespace.c: Move variables namespace_block,
	possible_namespace_block, namespace_objfile here from
	cp-support.c.
	Move functions initialize_namespace_blocks, get_namespace_block,
	get_possible_namespace_block, free_namespace_blocks,
	check_one_possible_namespace_symbol,
	check_possible_namespace_symbols_loop, maintenance_print_namespace
	here from cp-support.c.
	Include objfiles.h, gdbtypes.h, dictionary.h, gdbcmd.h.
	* cp-namespace.c (_initialize_cp_namespace): New.
	(maintenance_cplus_namespace): Rename from
	maintenance_print_namespace.
	* cp-support.c (cp_find_first_component): Fix typo in comment.
	(_initialize_cp_support): Don't add 'maint print
	namespace'.
	Make maint_cplus_cmd_list extern.
	Prune includes.

2003-04-30  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/maint.exp (test_help): Refactor, and add test for maint
	cp namespace.
	(test_namespace): New.
@
text
@d4 1
a4 1
   Contributed by MontaVista Software.
d29 1
d31 5
d40 1
a40 1
struct cmd_list_element *maint_cplus_cmd_list = NULL;
d49 29
d287 1
a287 1
	  /* Operator names can screw up the recursion.  */
d365 262
d691 3
@


1.1.2.21
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a30 22
#include "dictionary.h"
#include "objfiles.h"
#include "frame.h"
#include "symtab.h"
#include "block.h"

/* Functions/variables related to overload resolution.  */

static int sym_return_val_size;
static int sym_return_val_index;
static struct symbol **sym_return_val;

static void overload_list_add_symbol (struct symbol *sym,
				      const char *oload_name);

static void make_symbol_overload_list_using (const char *func_name,
					     const char *namespace,
					     const struct block *block);

static void make_symbol_overload_list_qualified (const char *func_name);

static void read_in_psymtabs (const char *oload_name);
a357 272
/* Overload resolution functions.  */

char *
remove_params (const char *demangled_name)
{
  const char *argp;
  char *new_name;
  int depth;

  if (demangled_name == NULL)
    return NULL;

  /* First find the end of the arg list.  */
  argp = strrchr (demangled_name, ')');
  if (argp == NULL)
    return NULL;

  /* Back up to the beginning.  */
  depth = 1;

  while (argp-- > demangled_name)
    {
      if (*argp == ')')
	depth ++;
      else if (*argp == '(')
	{
	  depth --;

	  if (depth == 0)
	    break;
	}
    }
  if (depth != 0)
    internal_error (__FILE__, __LINE__,
		    "bad demangled name %s\n", demangled_name);
  while (argp[-1] == ' ' && argp > demangled_name)
    argp --;

  new_name = xmalloc (argp - demangled_name + 1);
  memcpy (new_name, demangled_name, argp - demangled_name);
  new_name[argp - demangled_name] = '\0';
  return new_name;
}

/* Helper routine for make_symbol_completion_list.  */

static int sym_return_val_size;
static int sym_return_val_index;
static struct symbol **sym_return_val;

/*  Test to see if the symbol specified by SYMNAME (which is already
   demangled for C++ symbols) matches SYM_TEXT in the first SYM_TEXT_LEN
   characters.  If so, add it to the current completion list. */

static void
overload_list_add_symbol (struct symbol *sym, const char *oload_name)
{
  int newsize;
  int i;
  char *sym_name;

  /* If there is no type information, we can't do anything, so skip */
  if (SYMBOL_TYPE (sym) == NULL)
    return;

  /* skip any symbols that we've already considered. */
  for (i = 0; i < sym_return_val_index; ++i)
    if (!strcmp (DEPRECATED_SYMBOL_NAME (sym), DEPRECATED_SYMBOL_NAME (sym_return_val[i])))
      return;

  /* Get the demangled name without parameters */
  sym_name = remove_params (SYMBOL_DEMANGLED_NAME (sym));
  if (!sym_name)
    return;

  /* skip symbols that cannot match */
  if (strcmp (sym_name, oload_name) != 0)
    {
      xfree (sym_name);
      return;
    }

  xfree (sym_name);

  /* We have a match for an overload instance, so add SYM to the current list
   * of overload instances */
  if (sym_return_val_index + 3 > sym_return_val_size)
    {
      newsize = (sym_return_val_size *= 2) * sizeof (struct symbol *);
      sym_return_val = (struct symbol **) xrealloc ((char *) sym_return_val, newsize);
    }
  sym_return_val[sym_return_val_index++] = sym;
  sym_return_val[sym_return_val_index] = NULL;
}

/* Return a null-terminated list of pointers to function symbols that
   match name of the supplied symbol FSYM and that occur within the
   namespace given by the initial substring of NAMESPACE_NAME of
   length NAMESPACE_LEN.  Apply using directives from BLOCK.  This is
   used in finding all overloaded instances of a function name.  This
   has been modified from make_symbol_completion_list.  */

/* FIXME: carlton/2003-01-30: Should BLOCK be here?  Maybe it's better
   to use get_selected_block (0).  */

struct symbol **
make_symbol_overload_list (const char *func_name,
			   const char *namespace,
			   const struct block *block)
{
  struct cleanup *old_cleanups;

  sym_return_val_size = 100;
  sym_return_val_index = 0;
  sym_return_val = xmalloc ((sym_return_val_size + 1) *
			    sizeof (struct symbol *));
  sym_return_val[0] = NULL;

  old_cleanups = make_cleanup (xfree, sym_return_val);

  make_symbol_overload_list_using (func_name, namespace,
				   block);

  discard_cleanups (old_cleanups);

  return sym_return_val;
}

/* This applies the using directives to add namespaces to search in,
   and then searches for overloads in all of those namespaces.  It
   adds the symbols found to sym_return_val.  Arguments are as in
   make_symbol_overload_list.  */

static void
make_symbol_overload_list_using (const char *func_name,
				 const char *namespace,
				 const struct block *block)
{
  const struct using_direct *current;

  /* First, go through the using directives.  If any of them apply,
     look in the appropriate namespaces for new functions to match
     on.  */

  for (current = block_using (block);
       current != NULL;
       current = current->next)
    {
      if (strcmp (namespace, current->outer) == 0)
	{
	  make_symbol_overload_list_using (func_name,
					   current->inner,
					   block);
	}
    }

  /* Now, add names for this namespace.  */
  
  if (namespace[0] == '\0')
    {
      make_symbol_overload_list_qualified (func_name);
    }
  else
    {
      char *concatenated_name
	= alloca (strlen (namespace) + 2 + strlen (func_name) + 1);
      strcpy (concatenated_name, namespace);
      strcat (concatenated_name, "::");
      strcat (concatenated_name, func_name);
      make_symbol_overload_list_qualified (concatenated_name);
    }
}

/* This does the bulk of the work of finding overloaded symbols.
   FUNC_NAME is the name of the overloaded function we're looking for
   (possibly including namespace info); NEW_LIST is 1 if we should
   allocate a new list of overloads and 0 if we should continue using
   the same old list.  */

static void
make_symbol_overload_list_qualified (const char *func_name)
{
  struct symbol *sym;
  struct symtab *s;
  struct objfile *objfile;
  const struct block *b, *surrounding_static_block = 0;
  struct dict_iterator iter;
  const struct dictionary *dict;

  /* Look through the partial symtabs for all symbols which begin
     by matching FUNC_NAME.  Make sure we read that symbol table in. */

  read_in_psymtabs (func_name);

  /* Search upwards from currently selected frame (so that we can
     complete on local vars.  */

  for (b = get_selected_block (0); b != NULL; b = BLOCK_SUPERBLOCK (b))
    {
      dict = BLOCK_DICT (b);

      for (sym = dict_iter_name_first (dict, func_name, &iter);
	   sym;
	   sym = dict_iter_name_next (func_name, &iter))
	{
	  overload_list_add_symbol (sym, func_name);
	}
    }

  surrounding_static_block = block_static_block (get_selected_block (0));

  /* Go through the symtabs and check the externs and statics for
     symbols which match.  */

  /* FIXME: carlton/2003-01-30: Why are we checking all the statics?
     Also, this shouldn't check all the globals if there's an
     anonymous namespace involved somewhere.  */

  ALL_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), GLOBAL_BLOCK);
    dict = BLOCK_DICT (b);

    for (sym = dict_iter_name_first (dict, func_name, &iter);
	 sym;
	 sym = dict_iter_name_next (func_name, &iter))
    {
      overload_list_add_symbol (sym, func_name);
    }
  }

  ALL_SYMTABS (objfile, s)
  {
    QUIT;
    b = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), STATIC_BLOCK);
    /* Don't do this block twice.  */
    if (b == surrounding_static_block)
      continue;
    dict = BLOCK_DICT (b);

    for (sym = dict_iter_name_first (dict, func_name, &iter);
	 sym;
	 sym = dict_iter_name_next (func_name, &iter))
    {
      overload_list_add_symbol (sym, func_name);
    }
  }
}

/* Look through the partial symtabs for all symbols which begin
   by matching FUNC_NAME.  Make sure we read that symbol table in. */

static void
read_in_psymtabs (const char *func_name)
{
  struct partial_symtab *ps;
  struct objfile *objfile;

  ALL_PSYMTABS (objfile, ps)
  {
    if (ps->readin)
      continue;

    if ((lookup_partial_symbol (ps, func_name, NULL, 1, VAR_DOMAIN)
	 != NULL)
	|| (lookup_partial_symbol (ps, func_name, NULL, 0, VAR_DOMAIN)
	    != NULL))
      psymtab_to_symtab (ps);
  }
}

a381 2

extern initialize_file_ftype _initialize_cp_support; /* -Wmissing-prototypes */
@


1.1.2.22
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a35 10
#include "complaints.h"

/* Functions related to demangled name parsing.  */

static const char *find_last_component (const char *name);

static unsigned int cp_find_first_component_aux (const char *name,
						 int permissive);

static void demangled_name_complaint (const char *name);
d212 3
a214 2
/* The character in NAME indexed by the return value is guaranteed to
   always be either ':' or '\0'.  */
d218 2
a219 14
   user-generated input, because some of the 'index += 2' lines in
   cp_find_first_component_aux might go past the end of malformed
   input.  */

unsigned int
cp_find_first_component (const char *name)
{
  return cp_find_first_component_aux (name, 0);
}

/* Helper function for cp_find_first_component.  Like that function,
   it returns the length of the first component of NAME, but to make
   the recursion easier, it also stops if it reaches an unexpected ')'
   or '>' if the value of PERMISSIVE is nonzero.  */
d225 2
a226 2
static unsigned int
cp_find_first_component_aux (const char *name, int permissive)
d247 1
a247 1
	  for (index += cp_find_first_component_aux (name + index, 1);
d249 1
a249 1
	       index += cp_find_first_component_aux (name + index, 1))
d251 1
a251 5
	      if (name[index] != ':')
		{
		  demangled_name_complaint (name);
		  return strlen (name);
		}
d259 1
a259 1
	  for (index += cp_find_first_component_aux (name + index, 1);
d261 1
a261 1
	       index += cp_find_first_component_aux (name + index, 1))
d263 1
a263 5
	      if (name[index] != ':')
		{
		  demangled_name_complaint (name);
		  return strlen (name);
		}
a269 7
	  if (permissive)
	    return index;
	  else
	    {
	      demangled_name_complaint (name);
	      return strlen (name);
	    }
a325 10
}

/* Complain about a demangled name that we don't know how to parse.
   NAME is the demangled name in question.  */

static void
demangled_name_complaint (const char *name)
{
  complaint (&symfile_complaints,
	     "unexpected demangled name '%s'", name);
@


1.1.2.23
log
@2003-09-19  David Carlton  <carlton@@kealia.com>

	* expression.h (enum exp_opcode): Revert to mainline's OP_FUNCALL,
	OP_SCOPE.
	* ada-exp.y, m2-exp.y, objc-exp.y, p-exp.y: Ditto.
	* jv-exp.y (push_qualified_expression_name): Ditto.
	* ada-lang.c (ada_resolve_subexp, replace_operator_with_call)
	(ada_evaluate_subexp): Ditto.
	* eval.c (evaluate_subexp_standard): Ditto.
	* expprint.c (print_subexp, dump_subexp): Ditto.
	* parse.c (length_of_subexp, prefixify_subexp): Ditto.
	* c-exp.y: Ditto, and add comment.
	* cp-support.c (make_symbol_overload_list): Delete 'block'
	argument; change calls to make_symbol_overload_list_using
	appropriately.
	(make_symbol_overload_list_using): Delete 'block' argument;
	replace it by get_selected_block (0).
	* cp-support.h: Delete 'block' argument from
	make_symbol_overload_list.
	* valops.c (find_overload_match): Delete 'block' argument, and
	update calls using it.
	(find_oload_champ_namespace, find_oload_champ_namespace_loop)
	(value_aggregate_elt, value_struct_elt_for_reference)
	(value_namespace_elt): Ditto.
	(value_maybe_namespace_elt): Delete 'block' argument, and use
	get_selected_block (0) instead.
	* value.h: Delete 'block' argument from value_struct_elt,
	value_find_oload.
@
text
@d57 2
a58 1
					     const char *namespace);
d528 3
d533 2
a534 1
			   const char *namespace)
d546 2
a547 1
  make_symbol_overload_list_using (func_name, namespace);
d561 2
a562 1
				 const char *namespace)
d570 1
a570 1
  for (current = block_using (get_selected_block (0));
d577 2
a578 1
					   current->inner);
@


1.1.2.24
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@a36 1
#include "gdbtypes.h"
d156 1
a156 1
  char *demangled_name = cplus_demangle (physname, DMGL_ANSI | DMGL_PARAMS);
d181 1
a181 1
  char *demangled_name = cplus_demangle (physname, DMGL_ANSI | DMGL_PARAMS);
a687 43
}

/* Lookup the rtti type for a class name. */

struct type *
cp_lookup_rtti_type (const char *name, struct block *block)
{
  struct symbol * rtti_sym;
  struct type * rtti_type;

  rtti_sym = lookup_symbol (name, block, STRUCT_DOMAIN, NULL, NULL);

  if (rtti_sym == NULL)
    {
      warning ("RTTI symbol not found for class '%s'", name);
      return NULL;
    }

  if (SYMBOL_CLASS (rtti_sym) != LOC_TYPEDEF)
    {
      warning ("RTTI symbol for class '%s' is not a type", name);
      return NULL;
    }

  rtti_type = SYMBOL_TYPE (rtti_sym);

  switch (TYPE_CODE (rtti_type))
    {
    case TYPE_CODE_CLASS:
      break;
    case TYPE_CODE_NAMESPACE:
      /* chastain/2003-11-26: the symbol tables often contain fake
	 symbols for namespaces with the same name as the struct.
	 This warning is an indication of a bug in the lookup order
	 or a bug in the way that the symbol tables are populated.  */
      warning ("RTTI symbol for class '%s' is a namespace", name);
      return NULL;
    default:
      warning ("RTTI symbol for class '%s' has bad type", name);
      return NULL;
    }

  return rtti_type;
@


1.1.4.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@@

