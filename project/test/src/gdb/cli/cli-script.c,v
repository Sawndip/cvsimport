head	1.84;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.80
	gdb_7_6-2013-04-26-release:1.80
	gdb_7_6-branch:1.80.0.2
	gdb_7_6-2013-03-12-branchpoint:1.80
	gdb_7_5_1-2012-11-29-release:1.75
	gdb_7_5-2012-08-17-release:1.75
	gdb_7_5-branch:1.75.0.2
	gdb_7_5-2012-07-18-branchpoint:1.75
	gdb_7_4_1-2012-04-26-release:1.72.2.1
	gdb_7_4-2012-01-24-release:1.72.2.1
	gdb_7_4-branch:1.72.0.2
	gdb_7_4-2011-12-13-branchpoint:1.72
	gdb_7_3_1-2011-09-04-release:1.68
	gdb_7_3-2011-07-26-release:1.68
	gdb_7_3-branch:1.68.0.2
	gdb_7_3-2011-04-01-branchpoint:1.68
	gdb_7_2-2010-09-02-release:1.63
	gdb_7_2-branch:1.63.0.2
	gdb_7_2-2010-07-07-branchpoint:1.63
	gdb_7_1-2010-03-18-release:1.57
	gdb_7_1-branch:1.57.0.2
	gdb_7_1-2010-02-18-branchpoint:1.57
	gdb_7_0_1-2009-12-22-release:1.53
	gdb_7_0-2009-10-06-release:1.53
	gdb_7_0-branch:1.53.0.2
	gdb_7_0-2009-09-16-branchpoint:1.53
	arc-sim-20090309:1.45
	msnyder-checkpoint-072509-branch:1.52.0.2
	msnyder-checkpoint-072509-branchpoint:1.52
	arc-insight_6_8-branch:1.45.0.10
	arc-insight_6_8-branchpoint:1.45
	insight_6_8-branch:1.45.0.8
	insight_6_8-branchpoint:1.45
	reverse-20081226-branch:1.48.0.4
	reverse-20081226-branchpoint:1.48
	multiprocess-20081120-branch:1.48.0.2
	multiprocess-20081120-branchpoint:1.48
	reverse-20080930-branch:1.47.0.2
	reverse-20080930-branchpoint:1.47
	reverse-20080717-branch:1.45.0.6
	reverse-20080717-branchpoint:1.45
	msnyder-reverse-20080609-branch:1.45.0.4
	msnyder-reverse-20080609-branchpoint:1.45
	drow-reverse-20070409-branch:1.40.0.2
	drow-reverse-20070409-branchpoint:1.40
	gdb_6_8-2008-03-27-release:1.45
	gdb_6_8-branch:1.45.0.2
	gdb_6_8-2008-02-26-branchpoint:1.45
	gdb_6_7_1-2007-10-29-release:1.44
	gdb_6_7-2007-10-10-release:1.44
	gdb_6_7-branch:1.44.0.2
	gdb_6_7-2007-09-07-branchpoint:1.44
	insight_6_6-20070208-release:1.38
	gdb_6_6-2006-12-18-release:1.38
	gdb_6_6-branch:1.38.0.2
	gdb_6_6-2006-11-15-branchpoint:1.38
	insight_6_5-20061003-release:1.35
	gdb-csl-symbian-6_4_50_20060226-12:1.32
	gdb-csl-sourcerygxx-3_4_4-25:1.31
	nickrob-async-20060828-mergepoint:1.38
	gdb-csl-symbian-6_4_50_20060226-11:1.32
	gdb-csl-sourcerygxx-4_1-17:1.32
	gdb-csl-20060226-branch-local-2:1.32
	gdb-csl-sourcerygxx-4_1-14:1.32
	gdb-csl-sourcerygxx-4_1-13:1.32
	gdb-csl-sourcerygxx-4_1-12:1.32
	gdb-csl-sourcerygxx-3_4_4-21:1.32
	gdb_6_5-20060621-release:1.35
	gdb-csl-sourcerygxx-4_1-9:1.32
	gdb-csl-sourcerygxx-4_1-8:1.32
	gdb-csl-sourcerygxx-4_1-7:1.32
	gdb-csl-arm-2006q1-6:1.32
	gdb-csl-sourcerygxx-4_1-6:1.32
	gdb-csl-symbian-6_4_50_20060226-10:1.32
	gdb-csl-symbian-6_4_50_20060226-9:1.32
	gdb-csl-symbian-6_4_50_20060226-8:1.32
	gdb-csl-coldfire-4_1-11:1.32
	gdb-csl-sourcerygxx-3_4_4-19:1.32
	gdb-csl-coldfire-4_1-10:1.32
	gdb_6_5-branch:1.35.0.8
	gdb_6_5-2006-05-14-branchpoint:1.35
	gdb-csl-sourcerygxx-4_1-5:1.32
	nickrob-async-20060513-branch:1.35.0.6
	nickrob-async-20060513-branchpoint:1.35
	gdb-csl-sourcerygxx-4_1-4:1.32
	msnyder-reverse-20060502-branch:1.35.0.4
	msnyder-reverse-20060502-branchpoint:1.35
	gdb-csl-morpho-4_1-4:1.32
	gdb-csl-sourcerygxx-3_4_4-17:1.32
	readline_5_1-import-branch:1.35.0.2
	readline_5_1-import-branchpoint:1.35
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.32
	gdb-csl-symbian-20060226-branch:1.32.0.6
	gdb-csl-symbian-20060226-branchpoint:1.32
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.32
	msnyder-reverse-20060331-branch:1.33.0.2
	msnyder-reverse-20060331-branchpoint:1.33
	gdb-csl-available-20060303-branch:1.32.0.4
	gdb-csl-available-20060303-branchpoint:1.32
	gdb-csl-20060226-branch:1.32.0.2
	gdb-csl-20060226-branchpoint:1.32
	gdb_6_4-20051202-release:1.30.6.1
	msnyder-fork-checkpoint-branch:1.31.0.4
	msnyder-fork-checkpoint-branchpoint:1.31
	gdb-csl-gxxpro-6_3-branch:1.31.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.31
	gdb_6_4-branch:1.30.0.6
	gdb_6_4-2005-11-01-branchpoint:1.30
	gdb-csl-arm-20051020-branch:1.30.0.4
	gdb-csl-arm-20051020-branchpoint:1.30
	msnyder-tracepoint-checkpoint-branch:1.30.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.30
	gdb-csl-arm-20050325-2005-q1b:1.28
	gdb-csl-arm-20050325-2005-q1a:1.28
	csl-arm-20050325-branch:1.28.0.2
	csl-arm-20050325-branchpoint:1.28
	gdb-post-i18n-errorwarning-20050211:1.27
	gdb-pre-i18n-errorwarning-20050211:1.26
	gdb_6_3-20041109-release:1.24
	gdb_6_3-branch:1.24.0.2
	gdb_6_3-20041019-branchpoint:1.24
	drow_intercu-merge-20040921:1.24
	drow_intercu-merge-20040915:1.24
	jimb-gdb_6_2-e500-branch:1.23.0.6
	jimb-gdb_6_2-e500-branchpoint:1.23
	gdb_6_2-20040730-release:1.23
	gdb_6_2-branch:1.23.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.23
	gdb_6_1_1-20040616-release:1.22
	gdb_6_1-2004-04-05-release:1.22
	drow_intercu-merge-20040402:1.22
	drow_intercu-merge-20040327:1.22
	ezannoni_pie-20040323-branch:1.22.0.6
	ezannoni_pie-20040323-branchpoint:1.22
	cagney_tramp-20040321-mergepoint:1.22
	cagney_tramp-20040309-branch:1.22.0.4
	cagney_tramp-20040309-branchpoint:1.22
	gdb_6_1-branch:1.22.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.22
	drow_intercu-20040221-branch:1.21.0.6
	drow_intercu-20040221-branchpoint:1.21
	cagney_bfdfile-20040213-branch:1.21.0.4
	cagney_bfdfile-20040213-branchpoint:1.21
	drow-cplus-merge-20040208:1.21
	carlton_dictionary-20040126-merge:1.21
	cagney_bigcore-20040122-branch:1.21.0.2
	cagney_bigcore-20040122-branchpoint:1.21
	drow-cplus-merge-20040113:1.21
	drow-cplus-merge-20031224:1.21
	drow-cplus-merge-20031220:1.20
	carlton_dictionary-20031215-merge:1.20
	drow-cplus-merge-20031214:1.20
	carlton-dictionary-20031111-merge:1.20
	gdb_6_0-2003-10-04-release:1.17
	kettenis_sparc-20030918-branch:1.18.0.6
	kettenis_sparc-20030918-branchpoint:1.18
	carlton_dictionary-20030917-merge:1.18
	ezannoni_pie-20030916-branchpoint:1.18
	ezannoni_pie-20030916-branch:1.18.0.4
	cagney_x86i386-20030821-branch:1.18.0.2
	cagney_x86i386-20030821-branchpoint:1.18
	carlton_dictionary-20030805-merge:1.18
	carlton_dictionary-20030627-merge:1.17
	gdb_6_0-branch:1.17.0.4
	gdb_6_0-2003-06-23-branchpoint:1.17
	jimb-ppc64-linux-20030613-branch:1.17.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.17
	cagney_convert-20030606-branch:1.16.0.26
	cagney_convert-20030606-branchpoint:1.16
	cagney_writestrings-20030508-branch:1.16.0.24
	cagney_writestrings-20030508-branchpoint:1.16
	jimb-ppc64-linux-20030528-branch:1.16.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.16
	carlton_dictionary-20030523-merge:1.16
	cagney_fileio-20030521-branch:1.16.0.20
	cagney_fileio-20030521-branchpoint:1.16
	kettenis_i386newframe-20030517-mergepoint:1.16
	jimb-ppc64-linux-20030509-branch:1.16.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.16
	kettenis_i386newframe-20030504-mergepoint:1.16
	carlton_dictionary-20030430-merge:1.16
	kettenis_i386newframe-20030419-branch:1.16.0.16
	kettenis_i386newframe-20030419-branchpoint:1.16
	carlton_dictionary-20030416-merge:1.16
	cagney_frameaddr-20030409-mergepoint:1.16
	kettenis_i386newframe-20030406-branch:1.16.0.14
	kettenis_i386newframe-20030406-branchpoint:1.16
	cagney_frameaddr-20030403-branchpoint:1.16
	cagney_frameaddr-20030403-branch:1.16.0.12
	cagney_framebase-20030330-mergepoint:1.16
	cagney_framebase-20030326-branch:1.16.0.10
	cagney_framebase-20030326-branchpoint:1.16
	cagney_lazyid-20030317-branch:1.16.0.8
	cagney_lazyid-20030317-branchpoint:1.16
	kettenis-i386newframe-20030316-mergepoint:1.16
	offbyone-20030313-branch:1.16.0.6
	offbyone-20030313-branchpoint:1.16
	kettenis-i386newframe-20030308-branch:1.16.0.4
	kettenis-i386newframe-20030308-branchpoint:1.16
	carlton_dictionary-20030305-merge:1.16
	cagney_offbyone-20030303-branch:1.16.0.2
	cagney_offbyone-20030303-branchpoint:1.16
	carlton_dictionary-20030207-merge:1.16
	interps-20030203-mergepoint:1.15
	interps-20030202-branch:1.15.0.2
	interps-20030202-branchpoint:1.15
	cagney-unwind-20030108-branch:1.14.0.8
	cagney-unwind-20030108-branchpoint:1.14
	carlton_dictionary-20021223-merge:1.14
	gdb_5_3-2002-12-12-release:1.14
	carlton_dictionary-20021115-merge:1.14
	kseitz_interps-20021105-merge:1.14
	kseitz_interps-20021103-merge:1.14
	drow-cplus-merge-20021020:1.14
	drow-cplus-merge-20021025:1.14
	carlton_dictionary-20021025-merge:1.14
	carlton_dictionary-20021011-merge:1.14
	drow-cplus-branch:1.14.0.6
	drow-cplus-branchpoint:1.14
	kseitz_interps-20020930-merge:1.14
	carlton_dictionary-20020927-merge:1.14
	carlton_dictionary-branch:1.14.0.4
	carlton_dictionary-20020920-branchpoint:1.14
	gdb_5_3-branch:1.14.0.2
	gdb_5_3-2002-09-04-branchpoint:1.14
	kseitz_interps-20020829-merge:1.14
	cagney_sysregs-20020825-branch:1.13.0.4
	cagney_sysregs-20020825-branchpoint:1.13
	readline_4_3-import-branch:1.13.0.2
	readline_4_3-import-branchpoint:1.13
	gdb_5_2_1-2002-07-23-release:1.10
	kseitz_interps-20020528-branch:1.12.0.6
	kseitz_interps-20020528-branchpoint:1.12
	cagney_regbuf-20020515-branch:1.12.0.4
	cagney_regbuf-20020515-branchpoint:1.12
	jimb-macro-020506-branch:1.12.0.2
	jimb-macro-020506-branchpoint:1.12
	gdb_5_2-2002-04-29-release:1.10
	gdb_5_2-branch:1.10.0.2
	gdb_5_2-2002-03-03-branchpoint:1.10
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.8
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.6
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.4
	gdb_5_1-2001-07-29-branchpoint:1.7
	dberlin-typesystem-branch:1.7.0.2
	dberlin-typesystem-branchpoint:1.7
	gdb-post-ptid_t-2001-05-03:1.6
	gdb-pre-ptid_t-2001-05-03:1.6
	insight-precleanup-2001-01-01:1.2;
locks; strict;
comment	@ * @;


1.84
date	2013.08.01.09.09.58;	author aburgess;	state Exp;
branches;
next	1.83;

1.83
date	2013.05.30.17.36.29;	author tromey;	state Exp;
branches;
next	1.82;

1.82
date	2013.05.30.16.31.33;	author tromey;	state Exp;
branches;
next	1.81;

1.81
date	2013.03.13.18.34.54;	author palves;	state Exp;
branches;
next	1.80;

1.80
date	2013.02.12.19.03.55;	author palves;	state Exp;
branches;
next	1.79;

1.79
date	2013.01.01.06.32.54;	author brobecke;	state Exp;
branches;
next	1.78;

1.78
date	2012.12.18.19.24.40;	author tromey;	state Exp;
branches;
next	1.77;

1.77
date	2012.11.20.22.51.05;	author muller;	state Exp;
branches;
next	1.76;

1.76
date	2012.08.28.14.08.42;	author qiyao;	state Exp;
branches;
next	1.75;

1.75
date	2012.05.08.18.49.42;	author eliz;	state Exp;
branches;
next	1.74;

1.74
date	2012.01.24.20.56.33;	author jkratoch;	state Exp;
branches;
next	1.73;

1.73
date	2012.01.04.08.17.17;	author brobecke;	state Exp;
branches;
next	1.72;

1.72
date	2011.09.02.16.56.30;	author palves;	state Exp;
branches
	1.72.2.1;
next	1.71;

1.71
date	2011.08.04.19.10.13;	author palves;	state Exp;
branches;
next	1.70;

1.70
date	2011.06.27.19.21.50;	author tromey;	state Exp;
branches;
next	1.69;

1.69
date	2011.04.04.18.13.05;	author tromey;	state Exp;
branches;
next	1.68;

1.68
date	2011.03.04.18.20.43;	author msnyder;	state Exp;
branches;
next	1.67;

1.67
date	2011.03.03.00.14.00;	author msnyder;	state Exp;
branches;
next	1.66;

1.66
date	2011.01.06.00.57.02;	author msnyder;	state Exp;
branches;
next	1.65;

1.65
date	2011.01.01.15.33.20;	author brobecke;	state Exp;
branches;
next	1.64;

1.64
date	2010.12.29.02.11.04;	author msnyder;	state Exp;
branches;
next	1.63;

1.63
date	2010.05.17.19.28.12;	author msnyder;	state Exp;
branches;
next	1.62;

1.62
date	2010.05.05.21.32.56;	author msnyder;	state Exp;
branches;
next	1.61;

1.61
date	2010.04.07.16.54.39;	author devans;	state Exp;
branches;
next	1.60;

1.60
date	2010.03.28.18.00.56;	author palves;	state Exp;
branches;
next	1.59;

1.59
date	2010.03.23.21.32.27;	author vprus;	state Exp;
branches;
next	1.58;

1.58
date	2010.03.02.21.46.28;	author tromey;	state Exp;
branches;
next	1.57;

1.57
date	2010.01.01.10.58.56;	author jkratoch;	state Exp;
branches;
next	1.56;

1.56
date	2010.01.01.10.57.43;	author jkratoch;	state Exp;
branches;
next	1.55;

1.55
date	2010.01.01.07.31.47;	author brobecke;	state Exp;
branches;
next	1.54;

1.54
date	2009.11.18.20.42.38;	author vprus;	state Exp;
branches;
next	1.53;

1.53
date	2009.08.03.12.26.37;	author vprus;	state Exp;
branches;
next	1.52;

1.52
date	2009.05.23.16.17.18;	author jkratoch;	state Exp;
branches;
next	1.51;

1.51
date	2009.02.25.02.14.23;	author teawater;	state Exp;
branches;
next	1.50;

1.50
date	2009.01.14.20.40.07;	author drow;	state Exp;
branches;
next	1.49;

1.49
date	2009.01.03.05.57.54;	author brobecke;	state Exp;
branches;
next	1.48;

1.48
date	2008.10.28.15.22.13;	author tromey;	state Exp;
branches;
next	1.47;

1.47
date	2008.08.16.20.36.29;	author bauermann;	state Exp;
branches;
next	1.46;

1.46
date	2008.08.06.19.41.32;	author bauermann;	state Exp;
branches;
next	1.45;

1.45
date	2008.01.01.22.53.14;	author drow;	state Exp;
branches
	1.45.10.1;
next	1.44;

1.44
date	2007.08.23.18.08.47;	author brobecke;	state Exp;
branches;
next	1.43;

1.43
date	2007.08.21.13.35.00;	author drow;	state Exp;
branches;
next	1.42;

1.42
date	2007.07.03.01.23.01;	author drow;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.28.21.48.54;	author msnyder;	state Exp;
branches;
next	1.40;

1.40
date	2007.01.27.12.30.46;	author eliz;	state Exp;
branches;
next	1.39;

1.39
date	2007.01.09.17.59.00;	author drow;	state Exp;
branches;
next	1.38;

1.38
date	2006.08.10.16.06.25;	author ams;	state Exp;
branches;
next	1.37;

1.37
date	2006.07.21.14.46.53;	author ams;	state Exp;
branches;
next	1.36;

1.36
date	2006.06.21.10.49.16;	author ams;	state Exp;
branches;
next	1.35;

1.35
date	2006.04.07.13.31.15;	author ams;	state Exp;
branches
	1.35.6.1;
next	1.34;

1.34
date	2006.03.30.16.51.20;	author drow;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.29.22.53.33;	author drow;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.17.22.40.17;	author eliz;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.15.12.03.07;	author ams;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.26.14.57.22;	author cagney;	state Exp;
branches
	1.30.2.1
	1.30.6.1;
next	1.29;

1.29
date	2005.04.26.05.03.39;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2005.02.11.18.13.55;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2005.02.11.04.06.10;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2005.01.17.16.17.36;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2005.01.16.21.20.05;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.10.23.12.11;	author jsm;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.21.23.52.21;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.25.15.57.42;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.22.03.43.19;	author jimb;	state Exp;
branches
	1.21.6.1;
next	1.20;

1.20
date	2003.09.21.01.26.46;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.20.17.50.28;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.05.02.44.50;	author cagney;	state Exp;
branches
	1.18.4.1;
next	1.17;

1.17
date	2003.06.08.18.27.14;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.07.00.27.31;	author cagney;	state Exp;
branches
	1.16.24.1;
next	1.15;

1.15
date	2003.01.18.15.55.53;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.27.01.09.09;	author msnyder;	state Exp;
branches
	1.14.4.1
	1.14.6.1;
next	1.13;

1.13
date	2002.07.30.13.45.14;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.12.22.31.23;	author dhoward;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	2002.03.17.19.53.39;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.17.22.15.18;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.25.22.24.39;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.13.22.42.23;	author jsmith;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.17.15.16.12;	author fnasser;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.13.22.29.14;	author fnasser;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.06.08.21.19;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.08.06.03.54;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.31.00.50.01;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.15.01.01.51;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.01.18.01.38;	author fnasser;	state Exp;
branches;
next	;

1.72.2.1
date	2012.01.06.04.43.32;	author brobecke;	state Exp;
branches;
next	;

1.45.10.1
date	2009.09.11.04.45.47;	author amylaar;	state Exp;
branches;
next	;

1.35.6.1
date	2006.08.28.07.48.47;	author nickrob;	state Exp;
branches;
next	1.35.6.2;

1.35.6.2
date	2006.09.14.02.22.49;	author nickrob;	state Exp;
branches;
next	;

1.30.2.1
date	2005.06.03.14.39.44;	author msnyder;	state Exp;
branches;
next	;

1.30.6.1
date	2005.11.16.12.44.11;	author ams;	state Exp;
branches;
next	;

1.21.6.1
date	2004.03.27.17.37.55;	author drow;	state Exp;
branches;
next	1.21.6.2;

1.21.6.2
date	2004.09.16.17.01.27;	author drow;	state Exp;
branches;
next	;

1.18.4.1
date	2004.03.23.20.41.49;	author ezannoni;	state Exp;
branches;
next	;

1.16.24.1
date	2003.06.03.20.54.41;	author cagney;	state Exp;
branches;
next	;

1.14.4.1
date	2003.02.07.19.17.54;	author carlton;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2003.06.27.21.50.14;	author carlton;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2003.08.05.17.13.16;	author carlton;	state Exp;
branches;
next	1.14.4.4;

1.14.4.4
date	2003.11.11.23.51.02;	author carlton;	state Exp;
branches;
next	1.14.4.5;

1.14.4.5
date	2004.01.26.19.11.35;	author carlton;	state Exp;
branches;
next	;

1.14.6.1
date	2003.12.14.20.27.34;	author drow;	state Exp;
branches;
next	1.14.6.2;

1.14.6.2
date	2003.12.24.22.08.39;	author drow;	state Exp;
branches;
next	;

1.12.6.1
date	2002.08.09.18.34.28;	author kseitz;	state Exp;
branches;
next	1.12.6.2;

1.12.6.2
date	2002.08.30.22.52.46;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.84
log
@Remove error_pre_print and quit_pre_print.

  http://sourceware.org/ml/gdb-patches/2013-07/msg00844.html

gdb/ChangeLog

        * cli/cli-script.c (script_from_file): Remove use of
        error_pre_print.
        * main.c (captured_main): Remove use of error_pre_print and
        quit_pre_print.
        * utils.c (error_pre_print, quit_pre_print): Remove.
        * utils.h (error_pre_print, quit_pre_print): Likewise.
@
text
@/* GDB CLI command scripting.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "value.h"
#include "language.h"		/* For value_true */
#include <ctype.h>

#include "ui-out.h"
#include "gdb_string.h"
#include "exceptions.h"
#include "top.h"
#include "breakpoint.h"
#include "cli/cli-cmds.h"
#include "cli/cli-decode.h"
#include "cli/cli-script.h"
#include "gdb_assert.h"

#include "python/python.h"
#include "interps.h"

/* Prototypes for local functions.  */

static enum command_control_type
recurse_read_control_structure (char * (*read_next_line_func) (void),
				struct command_line *current_cmd,
				void (*validator)(char *, void *),
				void *closure);

static char *insert_args (char *line);

static struct cleanup * setup_user_args (char *p);

static char *read_next_line (void);

/* Level of control structure when reading.  */
static int control_level;

/* Level of control structure when executing.  */
static int command_nest_depth = 1;

/* This is to prevent certain commands being printed twice.  */
static int suppress_next_print_command_trace = 0;

/* Structure for arguments to user defined functions.  */
#define MAXUSERARGS 10
struct user_args
  {
    struct user_args *next;
    /* It is necessary to store a malloced copy of the command line to
       ensure that the arguments are not overwritten before they are
       used.  */
    char *command;
    struct
      {
	char *arg;
	int len;
      }
    a[MAXUSERARGS];
    int count;
  }
 *user_args;


/* Allocate, initialize a new command line structure for one of the
   control commands (if/while).  */

static struct command_line *
build_command_line (enum command_control_type type, char *args)
{
  struct command_line *cmd;

  if (args == NULL && (type == if_control || type == while_control))
    error (_("if/while commands require arguments."));
  gdb_assert (args != NULL);

  cmd = (struct command_line *) xmalloc (sizeof (struct command_line));
  cmd->next = NULL;
  cmd->control_type = type;

  cmd->body_count = 1;
  cmd->body_list
    = (struct command_line **) xmalloc (sizeof (struct command_line *)
					* cmd->body_count);
  memset (cmd->body_list, 0, sizeof (struct command_line *) * cmd->body_count);
  cmd->line = xstrdup (args);

  return cmd;
}

/* Build and return a new command structure for the control commands
   such as "if" and "while".  */

struct command_line *
get_command_line (enum command_control_type type, char *arg)
{
  struct command_line *cmd;
  struct cleanup *old_chain = NULL;

  /* Allocate and build a new command line structure.  */
  cmd = build_command_line (type, arg);

  old_chain = make_cleanup_free_command_lines (&cmd);

  /* Read in the body of this command.  */
  if (recurse_read_control_structure (read_next_line, cmd, 0, 0)
      == invalid_control)
    {
      warning (_("Error reading in canned sequence of commands."));
      do_cleanups (old_chain);
      return NULL;
    }

  discard_cleanups (old_chain);
  return cmd;
}

/* Recursively print a command (including full control structures).  */

void
print_command_lines (struct ui_out *uiout, struct command_line *cmd,
		     unsigned int depth)
{
  struct command_line *list;

  list = cmd;
  while (list)
    {
      if (depth)
	ui_out_spaces (uiout, 2 * depth);

      /* A simple command, print it and continue.  */
      if (list->control_type == simple_control)
	{
	  ui_out_field_string (uiout, NULL, list->line);
	  ui_out_text (uiout, "\n");
	  list = list->next;
	  continue;
	}

      /* loop_continue to jump to the start of a while loop, print it
         and continue. */
      if (list->control_type == continue_control)
	{
	  ui_out_field_string (uiout, NULL, "loop_continue");
	  ui_out_text (uiout, "\n");
	  list = list->next;
	  continue;
	}

      /* loop_break to break out of a while loop, print it and
	 continue.  */
      if (list->control_type == break_control)
	{
	  ui_out_field_string (uiout, NULL, "loop_break");
	  ui_out_text (uiout, "\n");
	  list = list->next;
	  continue;
	}

      /* A while command.  Recursively print its subcommands and
	 continue.  */
      if (list->control_type == while_control
	  || list->control_type == while_stepping_control)
	{
	  /* For while-stepping, the line includes the 'while-stepping'
	     token.  See comment in process_next_line for explanation.
	     Here, take care not print 'while-stepping' twice.  */
	  if (list->control_type == while_control)
	    ui_out_field_fmt (uiout, NULL, "while %s", list->line);
	  else
	    ui_out_field_string (uiout, NULL, list->line);
	  ui_out_text (uiout, "\n");
	  print_command_lines (uiout, *list->body_list, depth + 1);
	  if (depth)
	    ui_out_spaces (uiout, 2 * depth);
	  ui_out_field_string (uiout, NULL, "end");
	  ui_out_text (uiout, "\n");
	  list = list->next;
	  continue;
	}

      /* An if command.  Recursively print both arms before
	 continueing.  */
      if (list->control_type == if_control)
	{
	  ui_out_field_fmt (uiout, NULL, "if %s", list->line);
	  ui_out_text (uiout, "\n");
	  /* The true arm.  */
	  print_command_lines (uiout, list->body_list[0], depth + 1);

	  /* Show the false arm if it exists.  */
	  if (list->body_count == 2)
	    {
	      if (depth)
		ui_out_spaces (uiout, 2 * depth);
	      ui_out_field_string (uiout, NULL, "else");
	      ui_out_text (uiout, "\n");
	      print_command_lines (uiout, list->body_list[1], depth + 1);
	    }

	  if (depth)
	    ui_out_spaces (uiout, 2 * depth);
	  ui_out_field_string (uiout, NULL, "end");
	  ui_out_text (uiout, "\n");
	  list = list->next;
	  continue;
	}

      /* A commands command.  Print the breakpoint commands and
	 continue.  */
      if (list->control_type == commands_control)
	{
	  if (*(list->line))
	    ui_out_field_fmt (uiout, NULL, "commands %s", list->line);
	  else
	    ui_out_field_string (uiout, NULL, "commands");
	  ui_out_text (uiout, "\n");
	  print_command_lines (uiout, *list->body_list, depth + 1);
	  if (depth)
	    ui_out_spaces (uiout, 2 * depth);
	  ui_out_field_string (uiout, NULL, "end");
	  ui_out_text (uiout, "\n");
	  list = list->next;
	  continue;
	}

      if (list->control_type == python_control)
	{
	  ui_out_field_string (uiout, NULL, "python");
	  ui_out_text (uiout, "\n");
	  /* Don't indent python code at all.  */
	  print_command_lines (uiout, *list->body_list, 0);
	  if (depth)
	    ui_out_spaces (uiout, 2 * depth);
	  ui_out_field_string (uiout, NULL, "end");
	  ui_out_text (uiout, "\n");
	  list = list->next;
	  continue;
	}

      /* Ignore illegal command type and try next.  */
      list = list->next;
    }				/* while (list) */
}

/* Handle pre-post hooks.  */

static void
clear_hook_in_cleanup (void *data)
{
  struct cmd_list_element *c = data;

  c->hook_in = 0; /* Allow hook to work again once it is complete.  */
}

void
execute_cmd_pre_hook (struct cmd_list_element *c)
{
  if ((c->hook_pre) && (!c->hook_in))
    {
      struct cleanup *cleanups = make_cleanup (clear_hook_in_cleanup, c);
      c->hook_in = 1; /* Prevent recursive hooking.  */
      execute_user_command (c->hook_pre, (char *) 0);
      do_cleanups (cleanups);
    }
}

void
execute_cmd_post_hook (struct cmd_list_element *c)
{
  if ((c->hook_post) && (!c->hook_in))
    {
      struct cleanup *cleanups = make_cleanup (clear_hook_in_cleanup, c);

      c->hook_in = 1; /* Prevent recursive hooking.  */
      execute_user_command (c->hook_post, (char *) 0);
      do_cleanups (cleanups);
    }
}

/* Execute the command in CMD.  */
static void
do_restore_user_call_depth (void * call_depth)
{	
  int *depth = call_depth;

  (*depth)--;
  if ((*depth) == 0)
    in_user_command = 0;
}


void
execute_user_command (struct cmd_list_element *c, char *args)
{
  struct command_line *cmdlines;
  struct cleanup *old_chain;
  enum command_control_type ret;
  static int user_call_depth = 0;
  extern unsigned int max_user_call_depth;

  cmdlines = c->user_commands;
  if (cmdlines == 0)
    /* Null command */
    return;

  old_chain = setup_user_args (args);

  if (++user_call_depth > max_user_call_depth)
    error (_("Max user call depth exceeded -- command aborted."));

  make_cleanup (do_restore_user_call_depth, &user_call_depth);

  /* Set the instream to 0, indicating execution of a
     user-defined function.  */
  make_cleanup (do_restore_instream_cleanup, instream);
  instream = (FILE *) 0;

  /* Also set the global in_user_command, so that NULL instream is
     not confused with Insight.  */
  in_user_command = 1;

  make_cleanup_restore_integer (&interpreter_async);
  interpreter_async = 0;

  command_nest_depth++;
  while (cmdlines)
    {
      ret = execute_control_command (cmdlines);
      if (ret != simple_control && ret != break_control)
	{
	  warning (_("Error executing canned sequence of commands."));
	  break;
	}
      cmdlines = cmdlines->next;
    }
  command_nest_depth--;
  do_cleanups (old_chain);
}

/* This function is called every time GDB prints a prompt.  It ensures
   that errors and the like do not confuse the command tracing.  */

void
reset_command_nest_depth (void)
{
  command_nest_depth = 1;

  /* Just in case.  */
  suppress_next_print_command_trace = 0;
}

/* Print the command, prefixed with '+' to represent the call depth.
   This is slightly complicated because this function may be called
   from execute_command and execute_control_command.  Unfortunately
   execute_command also prints the top level control commands.
   In these cases execute_command will call execute_control_command
   via while_command or if_command.  Inner levels of 'if' and 'while'
   are dealt with directly.  Therefore we can use these functions
   to determine whether the command has been printed already or not.  */
void
print_command_trace (const char *cmd)
{
  int i;

  if (suppress_next_print_command_trace)
    {
      suppress_next_print_command_trace = 0;
      return;
    }

  if (!source_verbose && !trace_commands)
    return;

  for (i=0; i < command_nest_depth; i++)
    printf_filtered ("+");

  printf_filtered ("%s\n", cmd);
}

enum command_control_type
execute_control_command (struct command_line *cmd)
{
  struct expression *expr;
  struct command_line *current;
  struct cleanup *old_chain = make_cleanup (null_cleanup, 0);
  struct value *val;
  struct value *val_mark;
  int loop;
  enum command_control_type ret;
  char *new_line;

  /* Start by assuming failure, if a problem is detected, the code
     below will simply "break" out of the switch.  */
  ret = invalid_control;

  switch (cmd->control_type)
    {
    case simple_control:
      /* A simple command, execute it and return.  */
      new_line = insert_args (cmd->line);
      if (!new_line)
	break;
      make_cleanup (free_current_contents, &new_line);
      execute_command (new_line, 0);
      ret = cmd->control_type;
      break;

    case continue_control:
      print_command_trace ("loop_continue");

      /* Return for "continue", and "break" so we can either
         continue the loop at the top, or break out.  */
      ret = cmd->control_type;
      break;

    case break_control:
      print_command_trace ("loop_break");

      /* Return for "continue", and "break" so we can either
         continue the loop at the top, or break out.  */
      ret = cmd->control_type;
      break;

    case while_control:
      {
	int len = strlen (cmd->line) + 7;
	char *buffer = alloca (len);

	xsnprintf (buffer, len, "while %s", cmd->line);
	print_command_trace (buffer);

	/* Parse the loop control expression for the while statement.  */
	new_line = insert_args (cmd->line);
	if (!new_line)
	  break;
	make_cleanup (free_current_contents, &new_line);
	expr = parse_expression (new_line);
	make_cleanup (free_current_contents, &expr);

	ret = simple_control;
	loop = 1;

	/* Keep iterating so long as the expression is true.  */
	while (loop == 1)
	  {
	    int cond_result;

	    QUIT;

	    /* Evaluate the expression.  */
	    val_mark = value_mark ();
	    val = evaluate_expression (expr);
	    cond_result = value_true (val);
	    value_free_to_mark (val_mark);

	    /* If the value is false, then break out of the loop.  */
	    if (!cond_result)
	      break;

	    /* Execute the body of the while statement.  */
	    current = *cmd->body_list;
	    while (current)
	      {
		command_nest_depth++;
		ret = execute_control_command (current);
		command_nest_depth--;

		/* If we got an error, or a "break" command, then stop
		   looping.  */
		if (ret == invalid_control || ret == break_control)
		  {
		    loop = 0;
		    break;
		  }

		/* If we got a "continue" command, then restart the loop
		   at this point.  */
		if (ret == continue_control)
		  break;

		/* Get the next statement.  */
		current = current->next;
	      }
	  }

	/* Reset RET so that we don't recurse the break all the way down.  */
	if (ret == break_control)
	  ret = simple_control;

	break;
      }

    case if_control:
      {
	int len = strlen (cmd->line) + 4;
	char *buffer = alloca (len);

	xsnprintf (buffer, len, "if %s", cmd->line);
	print_command_trace (buffer);

	new_line = insert_args (cmd->line);
	if (!new_line)
	  break;
	make_cleanup (free_current_contents, &new_line);
	/* Parse the conditional for the if statement.  */
	expr = parse_expression (new_line);
	make_cleanup (free_current_contents, &expr);

	current = NULL;
	ret = simple_control;

	/* Evaluate the conditional.  */
	val_mark = value_mark ();
	val = evaluate_expression (expr);

	/* Choose which arm to take commands from based on the value
	   of the conditional expression.  */
	if (value_true (val))
	  current = *cmd->body_list;
	else if (cmd->body_count == 2)
	  current = *(cmd->body_list + 1);
	value_free_to_mark (val_mark);

	/* Execute commands in the given arm.  */
	while (current)
	  {
	    command_nest_depth++;
	    ret = execute_control_command (current);
	    command_nest_depth--;

	    /* If we got an error, get out.  */
	    if (ret != simple_control)
	      break;

	    /* Get the next statement in the body.  */
	    current = current->next;
	  }

	break;
      }
    case commands_control:
      {
	/* Breakpoint commands list, record the commands in the
	   breakpoint's command list and return.  */
	new_line = insert_args (cmd->line);
	if (!new_line)
	  break;
	make_cleanup (free_current_contents, &new_line);
	ret = commands_from_control_command (new_line, cmd);
	break;
      }
    case python_control:
      {
	eval_python_from_control_command (cmd);
	ret = simple_control;
	break;
      }

    default:
      warning (_("Invalid control type in canned commands structure."));
      break;
    }

  do_cleanups (old_chain);

  return ret;
}

/* Like execute_control_command, but first set
   suppress_next_print_command_trace.  */

enum command_control_type
execute_control_command_untraced (struct command_line *cmd)
{
  suppress_next_print_command_trace = 1;
  return execute_control_command (cmd);
}


/* "while" command support.  Executes a body of statements while the
   loop condition is nonzero.  */

static void
while_command (char *arg, int from_tty)
{
  struct command_line *command = NULL;
  struct cleanup *old_chain;

  control_level = 1;
  command = get_command_line (while_control, arg);

  if (command == NULL)
    return;

  old_chain = make_cleanup_restore_integer (&interpreter_async);
  interpreter_async = 0;

  execute_control_command_untraced (command);
  free_command_lines (&command);

  do_cleanups (old_chain);
}

/* "if" command support.  Execute either the true or false arm depending
   on the value of the if conditional.  */

static void
if_command (char *arg, int from_tty)
{
  struct command_line *command = NULL;
  struct cleanup *old_chain;

  control_level = 1;
  command = get_command_line (if_control, arg);

  if (command == NULL)
    return;

  old_chain = make_cleanup_restore_integer (&interpreter_async);
  interpreter_async = 0;

  execute_control_command_untraced (command);
  free_command_lines (&command);

  do_cleanups (old_chain);
}

/* Cleanup */
static void
arg_cleanup (void *ignore)
{
  struct user_args *oargs = user_args;

  if (!user_args)
    internal_error (__FILE__, __LINE__,
		    _("arg_cleanup called with no user args.\n"));

  user_args = user_args->next;
  xfree (oargs->command);
  xfree (oargs);
}

/* Bind the incomming arguments for a user defined command to
   $arg0, $arg1 ... $argMAXUSERARGS.  */

static struct cleanup *
setup_user_args (char *p)
{
  struct user_args *args;
  struct cleanup *old_chain;
  unsigned int arg_count = 0;

  args = (struct user_args *) xmalloc (sizeof (struct user_args));
  memset (args, 0, sizeof (struct user_args));

  args->next = user_args;
  user_args = args;

  old_chain = make_cleanup (arg_cleanup, 0/*ignored*/);

  if (p == NULL)
    return old_chain;

  user_args->command = p = xstrdup (p);

  while (*p)
    {
      char *start_arg;
      int squote = 0;
      int dquote = 0;
      int bsquote = 0;

      if (arg_count >= MAXUSERARGS)
	error (_("user defined function may only have %d arguments."),
	       MAXUSERARGS);

      /* Strip whitespace.  */
      while (*p == ' ' || *p == '\t')
	p++;

      /* P now points to an argument.  */
      start_arg = p;
      user_args->a[arg_count].arg = p;

      /* Get to the end of this argument.  */
      while (*p)
	{
	  if (((*p == ' ' || *p == '\t')) && !squote && !dquote && !bsquote)
	    break;
	  else
	    {
	      if (bsquote)
		bsquote = 0;
	      else if (*p == '\\')
		bsquote = 1;
	      else if (squote)
		{
		  if (*p == '\'')
		    squote = 0;
		}
	      else if (dquote)
		{
		  if (*p == '"')
		    dquote = 0;
		}
	      else
		{
		  if (*p == '\'')
		    squote = 1;
		  else if (*p == '"')
		    dquote = 1;
		}
	      p++;
	    }
	}

      user_args->a[arg_count].len = p - start_arg;
      arg_count++;
      user_args->count++;
    }
  return old_chain;
}

/* Given character string P, return a point to the first argument
   ($arg), or NULL if P contains no arguments.  */

static char *
locate_arg (char *p)
{
  while ((p = strchr (p, '$')))
    {
      if (strncmp (p, "$arg", 4) == 0
	  && (isdigit (p[4]) || p[4] == 'c'))
	return p;
      p++;
    }
  return NULL;
}

/* Insert the user defined arguments stored in user_arg into the $arg
   arguments found in line, with the updated copy being placed into
   nline.  */

static char *
insert_args (char *line)
{
  char *p, *save_line, *new_line;
  unsigned len, i;

  /* If we are not in a user-defined function, treat $argc, $arg0, et
     cetera as normal convenience variables.  */
  if (user_args == NULL)
    return xstrdup (line);

  /* First we need to know how much memory to allocate for the new
     line.  */
  save_line = line;
  len = 0;
  while ((p = locate_arg (line)))
    {
      len += p - line;
      i = p[4] - '0';

      if (p[4] == 'c')
	{
	  /* $argc.  Number will be <=10.  */
	  len += user_args->count == 10 ? 2 : 1;
	}
      else if (i >= user_args->count)
	{
	  error (_("Missing argument %d in user function."), i);
	  return NULL;
	}
      else
	{
	  len += user_args->a[i].len;
	}
      line = p + 5;
    }

  /* Don't forget the tail.  */
  len += strlen (line);

  /* Allocate space for the new line and fill it in.  */
  new_line = (char *) xmalloc (len + 1);
  if (new_line == NULL)
    return NULL;

  /* Restore pointer to beginning of old line.  */
  line = save_line;

  /* Save pointer to beginning of new line.  */
  save_line = new_line;

  while ((p = locate_arg (line)))
    {
      int i, len;

      memcpy (new_line, line, p - line);
      new_line += p - line;

      if (p[4] == 'c')
	{
	  gdb_assert (user_args->count >= 0 && user_args->count <= 10);
	  if (user_args->count == 10)
	    {
	      *(new_line++) = '1';
	      *(new_line++) = '0';
	    }
	  else
	    *(new_line++) = user_args->count + '0';
	}
      else
	{
	  i = p[4] - '0';
	  len = user_args->a[i].len;
	  if (len)
	    {
	      memcpy (new_line, user_args->a[i].arg, len);
	      new_line += len;
	    }
	}
      line = p + 5;
    }
  /* Don't forget the tail.  */
  strcpy (new_line, line);

  /* Return a pointer to the beginning of the new line.  */
  return save_line;
}


/* Expand the body_list of COMMAND so that it can hold NEW_LENGTH
   code bodies.  This is typically used when we encounter an "else"
   clause for an "if" command.  */

static void
realloc_body_list (struct command_line *command, int new_length)
{
  int n;
  struct command_line **body_list;

  n = command->body_count;

  /* Nothing to do?  */
  if (new_length <= n)
    return;

  body_list = (struct command_line **)
    xmalloc (sizeof (struct command_line *) * new_length);

  memcpy (body_list, command->body_list, sizeof (struct command_line *) * n);
  memset (body_list + n, 0, sizeof (struct command_line *) * (new_length - n));

  xfree (command->body_list);
  command->body_list = body_list;
  command->body_count = new_length;
}

/* Read next line from stdout.  Passed to read_command_line_1 and
   recurse_read_control_structure whenever we need to read commands
   from stdout.  */

static char *
read_next_line (void)
{
  char *prompt_ptr, control_prompt[256];
  int i = 0;

  if (control_level >= 254)
    error (_("Control nesting too deep!"));

  /* Set a prompt based on the nesting of the control commands.  */
  if (instream == stdin || (instream == 0 && deprecated_readline_hook != NULL))
    {
      for (i = 0; i < control_level; i++)
	control_prompt[i] = ' ';
      control_prompt[i] = '>';
      control_prompt[i + 1] = '\0';
      prompt_ptr = (char *) &control_prompt[0];
    }
  else
    prompt_ptr = NULL;

  return command_line_input (prompt_ptr, instream == stdin, "commands");
}

/* Process one input line.  If the command is an "end", return such an
   indication to the caller.  If PARSE_COMMANDS is true, strip leading
   whitespace (trailing whitespace is always stripped) in the line,
   attempt to recognize GDB control commands, and also return an
   indication if the command is an "else" or a nop.

   Otherwise, only "end" is recognized.  */

static enum misc_command_type
process_next_line (char *p, struct command_line **command, int parse_commands,
		   void (*validator)(char *, void *), void *closure)
{
  char *p_end;
  char *p_start;
  int not_handled = 0;

  /* Not sure what to do here.  */
  if (p == NULL)
    return end_command;

  /* Strip trailing whitespace.  */
  p_end = p + strlen (p);
  while (p_end > p && (p_end[-1] == ' ' || p_end[-1] == '\t'))
    p_end--;

  p_start = p;
  /* Strip leading whitespace.  */
  while (p_start < p_end && (*p_start == ' ' || *p_start == '\t'))
    p_start++;

  /* 'end' is always recognized, regardless of parse_commands value.
     We also permit whitespace before end and after.  */
  if (p_end - p_start == 3 && !strncmp (p_start, "end", 3))
    return end_command;
  
  if (parse_commands)
    {
      /* If commands are parsed, we skip initial spaces.  Otherwise,
	 which is the case for Python commands and documentation
	 (see the 'document' command), spaces are preserved.  */
      p = p_start;

      /* Blanks and comments don't really do anything, but we need to
	 distinguish them from else, end and other commands which can
	 be executed.  */
      if (p_end == p || p[0] == '#')
	return nop_command;

      /* Is the else clause of an if control structure?  */
      if (p_end - p == 4 && !strncmp (p, "else", 4))
	return else_command;

      /* Check for while, if, break, continue, etc and build a new
	 command line structure for them.  */
      if ((p_end - p >= 14 && !strncmp (p, "while-stepping", 14))
	  || (p_end - p >= 8 && !strncmp (p, "stepping", 8))
	  || (p_end - p >= 2 && !strncmp (p, "ws", 2)))
	{
	  /* Because validate_actionline and encode_action lookup
	     command's line as command, we need the line to
	     include 'while-stepping'.

	     For 'ws' alias, the command will have 'ws', not expanded
	     to 'while-stepping'.  This is intentional -- we don't
	     really want frontend to send a command list with 'ws',
	     and next break-info returning command line with
	     'while-stepping'.  This should work, but might cause the
	     breakpoint to be marked as changed while it's actually
	     not.  */
	  *command = build_command_line (while_stepping_control, p);
	}
      else if (p_end - p > 5 && !strncmp (p, "while", 5))
	{
	  char *first_arg;

	  first_arg = p + 5;
	  while (first_arg < p_end && isspace (*first_arg))
	    first_arg++;
	  *command = build_command_line (while_control, first_arg);
	}
      else if (p_end - p > 2 && !strncmp (p, "if", 2))
	{
	  char *first_arg;

	  first_arg = p + 2;
	  while (first_arg < p_end && isspace (*first_arg))
	    first_arg++;
	  *command = build_command_line (if_control, first_arg);
	}
      else if (p_end - p >= 8 && !strncmp (p, "commands", 8))
	{
	  char *first_arg;

	  first_arg = p + 8;
	  while (first_arg < p_end && isspace (*first_arg))
	    first_arg++;
	  *command = build_command_line (commands_control, first_arg);
	}
      else if (p_end - p == 6 && !strncmp (p, "python", 6))
	{
	  /* Note that we ignore the inline "python command" form
	     here.  */
	  *command = build_command_line (python_control, "");
	}
      else if (p_end - p == 10 && !strncmp (p, "loop_break", 10))
	{
	  *command = (struct command_line *)
	    xmalloc (sizeof (struct command_line));
	  (*command)->next = NULL;
	  (*command)->line = NULL;
	  (*command)->control_type = break_control;
	  (*command)->body_count = 0;
	  (*command)->body_list = NULL;
	}
      else if (p_end - p == 13 && !strncmp (p, "loop_continue", 13))
	{
	  *command = (struct command_line *)
	    xmalloc (sizeof (struct command_line));
	  (*command)->next = NULL;
	  (*command)->line = NULL;
	  (*command)->control_type = continue_control;
	  (*command)->body_count = 0;
	  (*command)->body_list = NULL;
	}
      else
	not_handled = 1;
    }

  if (!parse_commands || not_handled)
    {
      /* A normal command.  */
      *command = (struct command_line *)
	xmalloc (sizeof (struct command_line));
      (*command)->next = NULL;
      (*command)->line = savestring (p, p_end - p);
      (*command)->control_type = simple_control;
      (*command)->body_count = 0;
      (*command)->body_list = NULL;
    }

  if (validator)
    {
      volatile struct gdb_exception ex;

      TRY_CATCH (ex, RETURN_MASK_ALL)
	{
	  validator ((*command)->line, closure);
	}
      if (ex.reason < 0)
	{
	  xfree (*command);
	  throw_exception (ex);
	}
    }

  /* Nothing special.  */
  return ok_command;
}

/* Recursively read in the control structures and create a
   command_line structure from them.  Use read_next_line_func to
   obtain lines of the command.  */

static enum command_control_type
recurse_read_control_structure (char * (*read_next_line_func) (void),
				struct command_line *current_cmd,
				void (*validator)(char *, void *),
				void *closure)
{
  int current_body, i;
  enum misc_command_type val;
  enum command_control_type ret;
  struct command_line **body_ptr, *child_tail, *next;

  child_tail = NULL;
  current_body = 1;

  /* Sanity checks.  */
  if (current_cmd->control_type == simple_control)
    error (_("Recursed on a simple control type."));

  if (current_body > current_cmd->body_count)
    error (_("Allocated body is smaller than this command type needs."));

  /* Read lines from the input stream and build control structures.  */
  while (1)
    {
      dont_repeat ();

      next = NULL;
      val = process_next_line (read_next_line_func (), &next, 
			       current_cmd->control_type != python_control,
			       validator, closure);

      /* Just skip blanks and comments.  */
      if (val == nop_command)
	continue;

      if (val == end_command)
	{
	  if (current_cmd->control_type == while_control
	      || current_cmd->control_type == while_stepping_control
	      || current_cmd->control_type == if_control
	      || current_cmd->control_type == python_control
	      || current_cmd->control_type == commands_control)
	    {
	      /* Success reading an entire canned sequence of commands.  */
	      ret = simple_control;
	      break;
	    }
	  else
	    {
	      ret = invalid_control;
	      break;
	    }
	}

      /* Not the end of a control structure.  */
      if (val == else_command)
	{
	  if (current_cmd->control_type == if_control
	      && current_body == 1)
	    {
	      realloc_body_list (current_cmd, 2);
	      current_body = 2;
	      child_tail = NULL;
	      continue;
	    }
	  else
	    {
	      ret = invalid_control;
	      break;
	    }
	}

      if (child_tail)
	{
	  child_tail->next = next;
	}
      else
	{
	  body_ptr = current_cmd->body_list;
	  for (i = 1; i < current_body; i++)
	    body_ptr++;

	  *body_ptr = next;

	}

      child_tail = next;

      /* If the latest line is another control structure, then recurse
         on it.  */
      if (next->control_type == while_control
	  || next->control_type == while_stepping_control
	  || next->control_type == if_control
	  || next->control_type == python_control
	  || next->control_type == commands_control)
	{
	  control_level++;
	  ret = recurse_read_control_structure (read_next_line_func, next,
						validator, closure);
	  control_level--;

	  if (ret != simple_control)
	    break;
	}
    }

  dont_repeat ();

  return ret;
}

static void
restore_interp (void *arg)
{
  interp_set_temp (interp_name ((struct interp *)arg));
}

/* Read lines from the input stream and accumulate them in a chain of
   struct command_line's, which is then returned.  For input from a
   terminal, the special command "end" is used to mark the end of the
   input, and is not included in the returned chain of commands.

   If PARSE_COMMANDS is true, strip leading whitespace (trailing whitespace
   is always stripped) in the line and attempt to recognize GDB control
   commands.  Otherwise, only "end" is recognized.  */

#define END_MESSAGE "End with a line saying just \"end\"."

struct command_line *
read_command_lines (char *prompt_arg, int from_tty, int parse_commands,
		    void (*validator)(char *, void *), void *closure)
{
  struct command_line *head;

  if (from_tty && input_from_terminal_p ())
    {
      if (deprecated_readline_begin_hook)
	{
	  /* Note - intentional to merge messages with no newline.  */
	  (*deprecated_readline_begin_hook) ("%s  %s\n", prompt_arg,
					     END_MESSAGE);
	}
      else
	{
	  printf_unfiltered ("%s\n%s\n", prompt_arg, END_MESSAGE);
	  gdb_flush (gdb_stdout);
	}
    }


  /* Reading commands assumes the CLI behavior, so temporarily
     override the current interpreter with CLI.  */
  if (current_interp_named_p (INTERP_CONSOLE))
    head = read_command_lines_1 (read_next_line, parse_commands,
				 validator, closure);
  else
    {
      struct interp *old_interp = interp_set_temp (INTERP_CONSOLE);
      struct cleanup *old_chain = make_cleanup (restore_interp, old_interp);

      head = read_command_lines_1 (read_next_line, parse_commands,
				   validator, closure);
      do_cleanups (old_chain);
    }

  if (deprecated_readline_end_hook && from_tty && input_from_terminal_p ())
    {
      (*deprecated_readline_end_hook) ();
    }
  return (head);
}

/* Act the same way as read_command_lines, except that each new line is
   obtained using READ_NEXT_LINE_FUNC.  */

struct command_line *
read_command_lines_1 (char * (*read_next_line_func) (void), int parse_commands,
		      void (*validator)(char *, void *), void *closure)
{
  struct command_line *head, *tail, *next;
  struct cleanup *old_chain = make_cleanup (null_cleanup, NULL);
  enum command_control_type ret;
  enum misc_command_type val;

  control_level = 0;
  head = tail = NULL;

  while (1)
    {
      dont_repeat ();
      val = process_next_line (read_next_line_func (), &next, parse_commands,
			       validator, closure);

      /* Ignore blank lines or comments.  */
      if (val == nop_command)
	continue;

      if (val == end_command)
	{
	  ret = simple_control;
	  break;
	}

      if (val != ok_command)
	{
	  ret = invalid_control;
	  break;
	}

      if (next->control_type == while_control
	  || next->control_type == if_control
	  || next->control_type == python_control
	  || next->control_type == commands_control
	  || next->control_type == while_stepping_control)
	{
	  control_level++;
	  ret = recurse_read_control_structure (read_next_line_func, next,
						validator, closure);
	  control_level--;

	  if (ret == invalid_control)
	    break;
	}

      if (tail)
	{
	  tail->next = next;
	}
      else
	{
	  head = next;
	  make_cleanup_free_command_lines (&head);
	}
      tail = next;
    }

  dont_repeat ();

  if (ret != invalid_control)
    discard_cleanups (old_chain);
  else
    do_cleanups (old_chain);

  return head;
}

/* Free a chain of struct command_line's.  */

void
free_command_lines (struct command_line **lptr)
{
  struct command_line *l = *lptr;
  struct command_line *next;
  struct command_line **blist;
  int i;

  while (l)
    {
      if (l->body_count > 0)
	{
	  blist = l->body_list;
	  for (i = 0; i < l->body_count; i++, blist++)
	    free_command_lines (blist);
	}
      next = l->next;
      xfree (l->line);
      xfree (l);
      l = next;
    }
  *lptr = NULL;
}

static void
do_free_command_lines_cleanup (void *arg)
{
  free_command_lines (arg);
}

struct cleanup *
make_cleanup_free_command_lines (struct command_line **arg)
{
  return make_cleanup (do_free_command_lines_cleanup, arg);
}

struct command_line *
copy_command_lines (struct command_line *cmds)
{
  struct command_line *result = NULL;

  if (cmds)
    {
      result = (struct command_line *) xmalloc (sizeof (struct command_line));

      result->next = copy_command_lines (cmds->next);
      result->line = xstrdup (cmds->line);
      result->control_type = cmds->control_type;
      result->body_count = cmds->body_count;
      if (cmds->body_count > 0)
        {
          int i;

          result->body_list = (struct command_line **)
            xmalloc (sizeof (struct command_line *) * cmds->body_count);

          for (i = 0; i < cmds->body_count; i++)
            result->body_list[i] = copy_command_lines (cmds->body_list[i]);
        }
      else
        result->body_list = NULL;
    }

  return result;
}

/* Validate that *COMNAME is a valid name for a command.  Return the
   containing command list, in case it starts with a prefix command.
   The prefix must already exist.  *COMNAME is advanced to point after
   any prefix, and a NUL character overwrites the space after the
   prefix.  */

static struct cmd_list_element **
validate_comname (char **comname)
{
  struct cmd_list_element **list = &cmdlist;
  char *p, *last_word;

  if (*comname == 0)
    error_no_arg (_("name of command to define"));

  /* Find the last word of the argument.  */
  p = *comname + strlen (*comname);
  while (p > *comname && isspace (p[-1]))
    p--;
  while (p > *comname && !isspace (p[-1]))
    p--;
  last_word = p;

  /* Find the corresponding command list.  */
  if (last_word != *comname)
    {
      struct cmd_list_element *c;
      char saved_char;
      const char *tem = *comname;

      /* Separate the prefix and the command.  */
      saved_char = last_word[-1];
      last_word[-1] = '\0';

      c = lookup_cmd (&tem, cmdlist, "", 0, 1);
      if (c->prefixlist == NULL)
	error (_("\"%s\" is not a prefix command."), *comname);

      list = c->prefixlist;
      last_word[-1] = saved_char;
      *comname = last_word;
    }

  p = *comname;
  while (*p)
    {
      if (!isalnum (*p) && *p != '-' && *p != '_')
	error (_("Junk in argument list: \"%s\""), p);
      p++;
    }

  return list;
}

/* This is just a placeholder in the command data structures.  */
static void
user_defined_command (char *ignore, int from_tty)
{
}

static void
define_command (char *comname, int from_tty)
{
#define MAX_TMPBUF 128   
  enum cmd_hook_type
    {
      CMD_NO_HOOK = 0,
      CMD_PRE_HOOK,
      CMD_POST_HOOK
    };
  struct command_line *cmds;
  struct cmd_list_element *c, *newc, *hookc = 0, **list;
  char *tem, *comfull;
  const char *tem_c;
  char tmpbuf[MAX_TMPBUF];
  int  hook_type      = CMD_NO_HOOK;
  int  hook_name_size = 0;
   
#define	HOOK_STRING	"hook-"
#define	HOOK_LEN 5
#define HOOK_POST_STRING "hookpost-"
#define HOOK_POST_LEN    9

  comfull = comname;
  list = validate_comname (&comname);

  /* Look it up, and verify that we got an exact match.  */
  tem_c = comname;
  c = lookup_cmd (&tem_c, *list, "", -1, 1);
  if (c && strcmp (comname, c->name) != 0)
    c = 0;

  if (c)
    {
      int q;

      if (c->class == class_user || c->class == class_alias)
	q = query (_("Redefine command \"%s\"? "), c->name);
      else
	q = query (_("Really redefine built-in command \"%s\"? "), c->name);
      if (!q)
	error (_("Command \"%s\" not redefined."), c->name);
    }

  /* If this new command is a hook, then mark the command which it
     is hooking.  Note that we allow hooking `help' commands, so that
     we can hook the `stop' pseudo-command.  */

  if (!strncmp (comname, HOOK_STRING, HOOK_LEN))
    {
       hook_type      = CMD_PRE_HOOK;
       hook_name_size = HOOK_LEN;
    }
  else if (!strncmp (comname, HOOK_POST_STRING, HOOK_POST_LEN))
    {
      hook_type      = CMD_POST_HOOK;
      hook_name_size = HOOK_POST_LEN;
    }
   
  if (hook_type != CMD_NO_HOOK)
    {
      /* Look up cmd it hooks, and verify that we got an exact match.  */
      tem_c = comname + hook_name_size;
      hookc = lookup_cmd (&tem_c, *list, "", -1, 0);
      if (hookc && strcmp (comname + hook_name_size, hookc->name) != 0)
	hookc = 0;
      if (!hookc)
	{
	  warning (_("Your new `%s' command does not "
		     "hook any existing command."),
		   comfull);
	  if (!query (_("Proceed? ")))
	    error (_("Not confirmed."));
	}
    }

  comname = xstrdup (comname);

  /* If the rest of the commands will be case insensitive, this one
     should behave in the same manner.  */
  for (tem = comname; *tem; tem++)
    if (isupper (*tem))
      *tem = tolower (*tem);

  xsnprintf (tmpbuf, sizeof (tmpbuf),
	     "Type commands for definition of \"%s\".", comfull);
  cmds = read_command_lines (tmpbuf, from_tty, 1, 0, 0);

  if (c && c->class == class_user)
    free_command_lines (&c->user_commands);

  newc = add_cmd (comname, class_user, user_defined_command,
		  (c && c->class == class_user)
		  ? c->doc : xstrdup ("User-defined."), list);
  newc->user_commands = cmds;

  /* If this new command is a hook, then mark both commands as being
     tied.  */
  if (hookc)
    {
      switch (hook_type)
        {
        case CMD_PRE_HOOK:
          hookc->hook_pre  = newc;  /* Target gets hooked.  */
          newc->hookee_pre = hookc; /* We are marked as hooking target cmd.  */
          break;
        case CMD_POST_HOOK:
          hookc->hook_post  = newc;  /* Target gets hooked.  */
          newc->hookee_post = hookc; /* We are marked as hooking
					target cmd.  */
          break;
        default:
          /* Should never come here as hookc would be 0.  */
	  internal_error (__FILE__, __LINE__, _("bad switch"));
        }
    }
}

static void
document_command (char *comname, int from_tty)
{
  struct command_line *doclines;
  struct cmd_list_element *c, **list;
  const char *tem;
  char *comfull;
  char tmpbuf[128];

  comfull = comname;
  list = validate_comname (&comname);

  tem = comname;
  c = lookup_cmd (&tem, *list, "", 0, 1);

  if (c->class != class_user)
    error (_("Command \"%s\" is built-in."), comfull);

  xsnprintf (tmpbuf, sizeof (tmpbuf), "Type documentation for \"%s\".",
	     comfull);
  doclines = read_command_lines (tmpbuf, from_tty, 0, 0, 0);

  if (c->doc)
    xfree (c->doc);

  {
    struct command_line *cl1;
    int len = 0;

    for (cl1 = doclines; cl1; cl1 = cl1->next)
      len += strlen (cl1->line) + 1;

    c->doc = (char *) xmalloc (len + 1);
    *c->doc = 0;

    for (cl1 = doclines; cl1; cl1 = cl1->next)
      {
	strcat (c->doc, cl1->line);
	if (cl1->next)
	  strcat (c->doc, "\n");
      }
  }

  free_command_lines (&doclines);
}

struct source_cleanup_lines_args
{
  int old_line;
  const char *old_file;
};

static void
source_cleanup_lines (void *args)
{
  struct source_cleanup_lines_args *p =
    (struct source_cleanup_lines_args *) args;

  source_line_number = p->old_line;
  source_file_name = p->old_file;
}

/* Used to implement source_command.  */

void
script_from_file (FILE *stream, const char *file)
{
  struct cleanup *old_cleanups;
  struct source_cleanup_lines_args old_lines;

  if (stream == NULL)
    internal_error (__FILE__, __LINE__, _("called with NULL file pointer!"));

  old_lines.old_line = source_line_number;
  old_lines.old_file = source_file_name;
  old_cleanups = make_cleanup (source_cleanup_lines, &old_lines);
  source_line_number = 0;
  source_file_name = file;

  {
    volatile struct gdb_exception e;

    TRY_CATCH (e, RETURN_MASK_ERROR)
      {
	read_command_file (stream);
      }
    switch (e.reason)
      {
      case 0:
	break;
      case RETURN_ERROR:
	/* Re-throw the error, but with the file name information
	   prepended.  */
	throw_error (e.error,
		     _("%s:%d: Error in sourced command file:\n%s"),
		     source_file_name, source_line_number, e.message);
      default:
	internal_error (__FILE__, __LINE__, _("bad reason"));
      }
  }

  do_cleanups (old_cleanups);
}

/* Print the definition of user command C to STREAM.  Or, if C is a
   prefix command, show the definitions of all user commands under C
   (recursively).  PREFIX and NAME combined are the name of the
   current command.  */
void
show_user_1 (struct cmd_list_element *c, const char *prefix, const char *name,
	     struct ui_file *stream)
{
  struct command_line *cmdlines;

  if (c->prefixlist != NULL)
    {
      char *prefixname = c->prefixname;

      for (c = *c->prefixlist; c != NULL; c = c->next)
	if (c->class == class_user || c->prefixlist != NULL)
	  show_user_1 (c, prefixname, c->name, gdb_stdout);
      return;
    }

  cmdlines = c->user_commands;
  if (!cmdlines)
    return;
  fprintf_filtered (stream, "User command \"%s%s\":\n", prefix, name);

  print_command_lines (current_uiout, cmdlines, 1);
  fputs_filtered ("\n", stream);
}



initialize_file_ftype _initialize_cli_script;

void
_initialize_cli_script (void)
{
  add_com ("document", class_support, document_command, _("\
Document a user-defined command.\n\
Give command name as argument.  Give documentation on following lines.\n\
End with a line of just \"end\"."));
  add_com ("define", class_support, define_command, _("\
Define a new command name.  Command name is argument.\n\
Definition appears on following lines, one command per line.\n\
End with a line of just \"end\".\n\
Use the \"document\" command to give documentation for the new command.\n\
Commands defined in this way may have up to ten arguments."));

  add_com ("while", class_support, while_command, _("\
Execute nested commands WHILE the conditional expression is non zero.\n\
The conditional expression must follow the word `while' and must in turn be\n\
followed by a new line.  The nested commands must be entered one per line,\n\
and should be terminated by the word `end'."));

  add_com ("if", class_support, if_command, _("\
Execute nested commands once IF the conditional expression is non zero.\n\
The conditional expression must follow the word `if' and must in turn be\n\
followed by a new line.  The nested commands must be entered one per line,\n\
and should be terminated by the word 'else' or `end'.  If an else clause\n\
is used, the same rules apply to its nested commands as to the first ones."));
}
@


1.83
log
@fix cli-script.c

read_command_lines_1 had some (IMNSHO) spaghetti-ish code for cleanup
handling.  This makes the code much simpler to understand, by
introducing an outer cleanup.

This is another case where a stylistic change for the checker is also
nice for the reader.

	* cli/cli-script.c (read_command_lines_1): Use a null cleanup
	for 'old_chain'.  Do not check 'head' before processing
	cleanups.
@
text
@a1638 3
  /* This will get set every time we read a line.  So it won't stay ""
     for long.  */
  error_pre_print = "";
@


1.82
log
@remove erroneous return from setup_user_args

This fixes setup_user_args to drop a useless and confusing "return".

	* cli/cli-script.c (setup_user_args): Don't return after error.
@
text
@d1249 1
a1249 1
  struct cleanup *old_chain;
a1254 1
  old_chain = NULL;
d1300 1
a1300 1
	  old_chain = make_cleanup_free_command_lines (&head);
d1307 4
a1310 9
  if (head)
    {
      if (ret != invalid_control)
	{
	  discard_cleanups (old_chain);
	}
      else
	do_cleanups (old_chain);
    }
@


1.81
log
@Constify strings in tracepoint.c, lookup_cmd and the completers.

This is sort of a continuation of Keith's parse_exp_1 constification
patch.  It started out by undoing these bits:

  @@@@ -754,9 +754,12 @@@@ validate_actionline (char **line, struct
   	  tmp_p = p;
   	  for (loc = t->base.loc; loc; loc = loc->next)
   	    {
  -	      p = tmp_p;
  -	      exp = parse_exp_1 (&p, loc->address,
  +	      const char *q;
  +
  +	      q = tmp_p;
  +	      exp = parse_exp_1 (&q, loc->address,
   				 block_for_pc (loc->address), 1);
  +	      p = (char *) q;

and progressively making more things const upwards, fixing fallout,
rinse repeat, until GDB built again (--enable-targets=all).

That ended up constifying lookup_cmd/add_cmd and (lots of) friends,
and the completers.

I didn't try to constify the command hooks themselves, because I know
upfront there are commands that write to the command string argument,
and I think I managed to stop at a nice non-hacky split point already.

I think the only non-really-super-obvious changes are
tracepoint.c:validate_actionline, and tracepoint.c:trace_dump_actions.

The rest is just mostly about 'char *' => 'const char *', 'char **'=>
'const char **', and the occasional (e.g., deprecated_cmd_warning)
case of 'char **'=> 'const char *', where/when I noticed that nothing
actually cares about the pointer to pointer output.

Tested on x86_64 Fedora 17, native and gdbserver.

gdb/
2013-03-13  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (struct add_partial_datum) <text, text0, word>: Make
	fields const.
	(ada_make_symbol_completion_list): Make "text0" parameter const.
	* ax-gdb.c (agent_eval_command_one): Make "exp" parameter const.
	* breakpoint.c (condition_completer): Make "text" and "word"
	parameters const.  Adjust.
	(check_tracepoint_command): Adjust to validate_actionline
	prototype change.
	(catch_syscall_completer): Make "text" and "word" parameters
	const.
	* cli/cli-cmds.c (show_user): Make "comname" local const.
	(valid_command_p): Make "command" parameter const.
	(alias_command): Make "alias_prefix" and "command_prefix" locals
	const.
	* cli/cli-decode.c (add_cmd): Make "name" parameter const.
	(add_alias_cmd): Make "name" and "oldname" parameters const.
	Adjust.  No longer make copy of OLDNAME.
	(add_prefix_cmd, add_abbrev_prefix_cmd, add_set_or_show_cmd)
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_unlimited_cmd, add_setshow_zuinteger_cmd)
	(delete_cmd, add_info, add_info_alias, add_com, add_com_alias):
	Make "name" parameter const.
	(help_cmd): Rename "command" parameter to "arg".  New const local
	"command".
	(find_cmd): Make "command" parameter const.
	(lookup_cmd_1): Make "text" parameter pointer to const.  Adjust to
	deprecated_cmd_warning prototype change.
	(undef_cmd_error): Make "cmdtype" parameter const.
	(lookup_cmd): Make "line" parameter const.
	(deprecated_cmd_warning): Change type of "text" parameter to
	pointer to const char, from pointer to pointer to char.  Adjust.
	(lookup_cmd_composition): Make "text" parameter const.
	(complete_on_cmdlist, complete_on_enum): Make "text" and "word"
	parameters const.
	* cli/cli-decode.h (struct cmd_list_element) <name>: Make field
	const.
	* cli/cli-script.c (validate_comname): Make "tem" local const.
	(define_command): New const local "tem_c".  Use it in calls to
	lookup_cmd.
	(document_command): Make "tem" and "comfull" locals const.
	(show_user_1): Make "prefix" and "name" parameters const.
	* cli-script.h (show_user_1): Make "prefix" and "name" parameters
	const.
	* command.h (add_cmd, add_alias_cmd, add_prefix_cmd)
	(add_abbrev_prefix_cmd, completer_ftype, lookup_cmd, lookup_cmd_1)
	(deprecated_cmd_warning, lookup_cmd_composition, add_com)
	(add_com_alias, add_info, add_info_alias, complete_on_cmdlist)
	(complete_on_enum, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_cmd, add_setshow_zuinteger_unlimited_cmd):
	Change prototypes, constifying strings.
	* completer.c (noop_completer, filename_completer): Make "text"
	and "prefix" parameters const.
	(location_completer, expression_completer)
	(complete_line_internal): Make "text" and "prefix" parameters
	const and adjust.
	(command_completer, signal_completer): Make "text" and "prefix"
	parameters const.
	* completer.h (noop_completer, filename_completer)
	(expression_completer, location_completer, command_completer)
	(signal_completer): Change prototypes.
	* corefile.c (complete_set_gnutarget): Make "text" and "word"
	parameters const.
	* cp-abi.c (cp_abi_completer): Likewise.
	* expression.h (parse_expression_for_completion): Change
	prototype.
	* f-lang.c (f_make_symbol_completion_list): Make "text" and "word"
	parameters const.
	* infcmd.c (_initialize_infcmd): Make "cmd_name" local const.
	* infrun.c (handle_completer): Make "text" and "word" parameters
	const.
	* interps.c (interpreter_completer): Make "text" and "word"
	parameters const.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Make "text" and "word"
	parameters const.
	* parse.c (parse_exp_1): Move const hack to parse_exp_in_context.
	(parse_exp_in_context): Rename to ...
	(parse_exp_in_context_1): ... this.
	(parse_exp_in_context): Reimplement, with const hack from
	parse_exp_1.
	(parse_expression_for_completion): Make "string" parameter const.
	* printcmd.c (decode_format): Make "string_ptr" parameter pointer
	to pointer to const char.  Adjust.
	(print_command_1): Make "exp" parameter const.
	(output_command): Rename to ...
	(output_command_const): ... this.  Make "exp" parameter const.
	(output_command): Reimplement.
	(x_command): Adjust.
	(display_command): Rename "exp" parameter to "arg".  New "exp"
	local, const version of "arg".
	* python/py-auto-load.c (gdbpy_initialize_auto_load): Make
	"cmd_name" local const.
	* python/py-cmd.c (cmdpy_destroyer): Cast const away in xfree
	call.
	(cmdpy_completer): Make "text" and "word" parameters const.
	(gdbpy_parse_command_name): Make "prefix_text2" local const.
	* python/py-param.c (add_setshow_generic): Make "tmp_name" local
	const.
	* remote.c (_initialize_remote): Make "cmd_name" local const.
	* symtab.c (language_search_unquoted_string): Make "text" and "p"
	parameters const.  Adjust.
	(completion_list_add_fields): Make "sym_text", "text" and "word"
	parameters const.
	(struct add_name_data) <sym_text, text, word>: Make fields const.
	(default_make_symbol_completion_list_break_on): Make "text" and
	"word" parameters const.  Adjust locals.
	(default_make_symbol_completion_list)
	(make_symbol_completion_list, make_symbol_completion_type)
	(make_symbol_completion_list_fn): Make "text" and "word"
	parameters const.
	(make_file_symbol_completion_list): Make "text", "word" and
	"srcfile" parameters const.  Adjust locals.
	(add_filename_to_list): Make "text" and "word" parameters const.
	(struct add_partial_filename_data) <text, word>: Make fields
	const.
	(make_source_files_completion_list): Make "text" and "word"
	parameters const.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_type enum type_code)
	(make_symbol_completion_list_fn make_file_symbol_completion_list)
	(make_source_files_completion_list): Change prototype.
	* top.c (execute_command): Adjust to pass pointer to pointer to
	const char to lookup_cmd, and to deprecated_cmd_warning prototype
	change.
	(set_verbose): Make "cmdname" local const.
	* tracepoint.c (decode_agent_options): Make "exp" parameter const,
	and adjust.
	(validate_actionline): Make "line" parameter a pointer to const
	char, and adjust.
	(encode_actions_1): Make "action_exp" local const, and adjust.
	(encode_actions): Adjust.
	(replace_comma): Delete.
	(trace_dump_actions): Make "action_exp" and "next_comma" locals
	const, and adjust.  Don't frob the action string while splitting
	it at commas.  Instead, make a copy of each split substring in
	turn.
	(trace_dump_command): Adjust to validate_actionline prototype
	change.
	* tracepoint.h (decode_agent_options, decode_agent_options)
	(encode_actions, validate_actionline): Change prototypes.
	* valprint.h (output_command): Delete declaration.
	(output_command_const): Declare.
	* value.c (function_destroyer): Cast const away in xfree call.
@
text
@d692 2
a693 5
	{
	  error (_("user defined function may only have %d arguments."),
		 MAXUSERARGS);
	  return old_chain;
	}
@


1.80
log
@Consistent use of (C) after "Copyright".

While writing the previous patch, I noticed that we're not consistent
with the (C) in the copyright header.  The maintainers manual prefers
having it, though also says it's optional.  We have over 10x more
files with (C) than without in gdb's code, so I spent a few minutes
grepping and fixing.  Funny enough, the testsuite has it backwards.
I'll leave that for another time.

gdb/
2013-02-12  Pedro Alves  <palves@@redhat.com>

	* amd64-darwin-tdep.c: Add (C) after Copyright.
	* cli/cli-cmds.h: Ditto.
	* cli/cli-decode.c: Ditto.
	* cli/cli-decode.h: Ditto.
	* cli/cli-dump.c: Ditto.
	* cli/cli-dump.h: Ditto.
	* cli/cli-interp.c: Ditto.
	* cli/cli-logging.c: Ditto.
	* cli/cli-script.c: Ditto.
	* cli/cli-script.h: Ditto.
	* cli/cli-setshow.c: Ditto.
	* cli/cli-setshow.h: Ditto.
	* cli/cli-utils.c: Ditto.
	* cli/cli-utils.h: Ditto.
	* config/alpha/nm-osf3.h: Ditto.
	* config/djgpp/djconfig.sh: Ditto.
	* config/i386/nm-fbsd.h: Ditto.
	* config/i386/nm-i386gnu.h: Ditto.
	* config/nm-linux.h: Ditto.
	* config/nm-nto.h: Ditto.
	* config/rs6000/nm-rs6000.h: Ditto.
	* config/sparc/nm-sol2.h: Ditto.
	* darwin-nat-info.c: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* gdb-demangle.h: Ditto.
	* i386-darwin-nat.c: Ditto.
	* i386-darwin-tdep.c: Ditto.
	* linux-fork.h: Ditto.
	* m32c-tdep.c: Ditto.
	* microblaze-linux-tdep.c: Ditto.
	* microblaze-rom.c: Ditto.
	* microblaze-tdep.c: Ditto.
	* microblaze-tdep.h: Ditto.
	* mips-linux-tdep.h: Ditto.
	* ppc-ravenscar-thread.c: Ditto.
	* ppc-ravenscar-thread.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* sparc-ravenscar-thread.c: Ditto.
	* sparc-ravenscar-thread.h: Ditto.
	* tilegx-linux-tdep.c: Ditto.
	* unwind_stop_reasons.def: Ditto.
	* windows-nat.h: Ditto.
	* xtensa-linux-tdep.c: Ditto.
	* xtensa-xtregs.c: Ditto.
	* regformats/regdat.sh: Ditto.
	* regformats/regdef.h: Ditto.

gdb/gdbserver/
2013-02-12  Pedro Alves  <palves@@redhat.com>

	* linux-xtensa-low.c: Ditto.
	* xtensa-xtregs.c: Ditto.
@
text
@d1419 2
a1420 1
      char saved_char, *tem = *comname;
d1465 1
d1479 2
a1480 2
  tem = comname;
  c = lookup_cmd (&tem, *list, "", -1, 1);
d1514 2
a1515 2
      tem = comname + hook_name_size;
      hookc = lookup_cmd (&tem, *list, "", -1, 0);
d1575 2
a1576 1
  char *tem, *comfull;
d1682 1
a1682 1
show_user_1 (struct cmd_list_element *c, char *prefix, char *name,
@


1.79
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d3 1
a3 1
   Copyright (c) 1986-2013 Free Software Foundation, Inc.
@


1.78
log
@	* cli/cli-cmds.c (_initialize_cli_cmds): Remove "document",
	"define", "while", and "if" commands.
	* cli/cli-script.c (while_command, if_command, define_command)
	(document_command): Now static.
	(_initialize_cli_script): New function.
	* cli/cli-script.h (while_command, if_command, define_command)
	(document_command): Don't declare.
@
text
@d3 1
a3 1
   Copyright (c) 1986-2002, 2004-2012 Free Software Foundation, Inc.
@


1.77
log
@	ARI fixes: sprintf rule.
	Replace sprintf function calls for char arrays by
	calls to xsnprintf calls.
	* arm-tdep.c (arm_push_dummy_call): Replace sprintf by xsnprintf.
	(arm_dwarf_reg_to_regnum, arm_return_value): Ditto.
	(arm_neon_quad_read, arm_pseudo_read): Ditto.
	(arm_neon_quad_write, arm_pseudo_write): Ditto.
	* breakpoint.c (condition_completer): Ditto.
	(create_tracepoint_from_upload): Ditto.
	* dwarf2read.c (file_full_name): Ditto.
	* gcore.c (gcore_command): Ditto.
	* gnu-nat.c (proc_string, gnu_pid_to_str): Ditto.
	* go32-nat.c (go32_sysinfo): Ditto.
	* interps.c (interp_set): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	* ppc-linux-nat.c (fetch_register, store_register): Ditto.
	* remote-m32r-sdi.c (m32r_open): Ditto.
	* sol-thread.c (td_err_string): Ditto.
	(td_state_string, solaris_pid_to_str): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	* cli/cli-script.c (execute_control_command): Ditto.
	(define_command, document_command): Ditto.
	* tui/tui-io.c (tui_rl_display_match_list): Ditto.
	* tui/tui-stack.c (tui_make_status_line): Ditto.
	* tui/tui-win.c (tui_update_gdb_sizes): Ditto.
@
text
@d601 1
a601 1
void
d625 1
a625 1
void
d1451 1
a1451 1
void
d1568 1
a1568 1
void
d1703 31
@


1.76
log
@gdb/
	* cli/cli-cmds.c (max_user_call_depth): Add 'unsigned'.
	(init_cmds): Call add_setshow_uinteger_cmd for command
	'max-user-call-depth'.
	* cli/cli-script.c (execute_user_command): Add 'unsigned' to the
	declaration of 'max_user_call_depth'.
	* frame.c (backtrace_limit): Add 'unsigned'.
	(_initialize_frame): Call add_setshow_uinteger_cmd for command
	'limit'.
	* remote.c (remoteaddresssize): Add 'unsigned'.
	(remote_address_masked): Change local var 'address_size' to
	'unsigned'.
	(_initialize_remote): Call add_setshow_uinteger_cmd for
	'remoteaddresssize'.
	* top.c (history_size): Add 'unsigned'.
	(show_commands): Change local variables to 'unsigned'.
	(set_history_size_command): Don't check history_size is negative.
	Adjust the condition to call unstifle_history and set history_size
	to UNIT_MAX.
@
text
@d444 2
a445 1
	char *buffer = alloca (strlen (cmd->line) + 7);
d447 1
a447 1
	sprintf (buffer, "while %s", cmd->line);
d513 2
a514 1
	char *buffer = alloca (strlen (cmd->line) + 4);
d516 1
a516 1
	sprintf (buffer, "if %s", cmd->line);
d1534 2
a1535 1
  sprintf (tmpbuf, "Type commands for definition of \"%s\".", comfull);
d1585 2
a1586 1
  sprintf (tmpbuf, "Type documentation for \"%s\".", comfull);
@


1.75
log
@Display the ">" prompt in interactive mode while reading canned
commands, even when the current interpreter is MI.

 interps.c (interp_set_temp): New function.
 interps.h (interp_set_temp): Add prototype.
 cli/cli-script.c (restore_interp): New cleanup function.
 (read_command_lines): Temporarily override the current interpreter
 with CLI and arrange for restoring the original one.
@
text
@d317 1
a317 1
  extern int max_user_call_depth;
@


1.74
log
@gdb/
	Code cleanup.
	* cli/cli-cmds.c (source_script_from_stream): Never fclose STREAM.
	Update the function comment for it.
	(source_script_with_search): Call make_cleanup_fclose for STREAM.
	* cli/cli-script.c (script_from_file): Do not call make_cleanup_fclose
	for STREAM.
@
text
@d1181 6
d1219 15
a1233 2
  head = read_command_lines_1 (read_next_line, parse_commands,
			       validator, closure);
@


1.73
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@a1616 2
  old_cleanups = make_cleanup_fclose (stream);

d1619 1
a1619 1
  make_cleanup (source_cleanup_lines, &old_lines);
@


1.72
log
@2011-09-02  Pedro Alves  <pedro@@codesourcery.com>

	* top.c: Include interps.h.
	(execute_command): If the target can async, but the interpreter is
	in sync mode, synchronously wait for the command to finish before
	returning.
	(execute_command_to_string): Force the interpreter to sync mode.
	* infrun.c: Include interps.h.
	(fetch_inferior_event): Don't restore the prompt yet if the
	interpreter is in sync mode.
	* interps.c (interpreter_async): New global.
	* interps.h (interpreter_async): Declare.
	* inf-loop.c: Include interps.h.
	(inferior_event_handler): Don't print the language change or run
	breakpoint commands yet if the interpreter in is sync mode.
	* main.c (captured_command_loop): Flip the interpreter to async
	mode.
	* cli/cli-script.c: Include interps.h.
	(execute_user_command, while_command, if_command): Force the
	interpreter to sync mode.
	* python/python.c: Include interps.h.
	(python_command, execute_gdb_command): Force the interpreter to
	sync mode.
@
text
@d3 1
a3 3
   Copyright (c) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011 Free Software Foundation, Inc.
@


1.72.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (c) 1986-2002, 2004-2012 Free Software Foundation, Inc.
@


1.71
log
@2011-08-04  Pedro Alves  <pedro@@codesourcery.com>

	* ui-out.h (uiout): Rename to ...
	(current_uiout): ... this.
	* ui-out.c (uiout): Rename to ...
	(current_uiout): ... this.
	* ada-lang.c (print_it_exception, print_one_exception)
	(print_mention_exception): Adjust.
	* breakpoint.c (watchpoint_check): Adjust.
	(print_breakpoint_location, print_one_breakpoint, breakpoint_1)
	(default_collect_info, watchpoints_info, print_one_catch_fork)
	(print_one_catch_vfork, print_one_catch_syscall)
	(print_one_catch_exec, mention, print_it_ranged_breakpoint)
	(print_one_ranged_breakpoint, print_mention_ranged_breakpoint)
	(print_it_watchpoint, print_mention_watchpoint)
	(print_it_masked_watchpoint, print_mention_masked_watchpoint)
	(print_it_exception_catchpoint, print_one_exception_catchpoint)
	(print_mention_exception_catchpoint, say_where, bkpt_print_it)
	(bkpt_print_mention, momentary_bkpt_print_it)
	(tracepoint_print_mention, update_static_tracepoint)
	(tracepoints_info, save_breakpoints): Adjust.
	* cli-out.c (field_separator): Adjust.
	* cp-abi.c (list_cp_abis, show_cp_abi_cmd): Adjust.
	* exceptions.c (catch_exceptions_with_msg, catch_errors): Adjust.
	* frame.c (get_current_frame): Adjust.
	* infcmd.c (run_command_1, print_return_value): Adjust.
	* inferior.c (inferior_command, info_inferiors_command): Adjust.
	* infrun.c (print_end_stepping_range_reason): Adjust.
	(print_signal_exited_reason, print_exited_reason): Adjust.
	(print_signal_received_reason, print_no_history_reason): Adjust.
	* interps.c (interp_set): Adjust.
	* osdata.c (info_osdata_command): Adjust.
	* progspace.c (maintenance_info_program_spaces_command): Adjust.
	* remote-fileio.c (remote_fileio_request): Adjust.
	* remote.c (show_remote_cmd): Adjust.
	* solib.c (info_sharedlibrary_command): Adjust.
	* source.c (print_source_lines_base): Adjust.
	* stack.c (print_stack_frame): Adjust.
	(do_gdb_disassembly, print_frame_info, print_frame): Adjust.
	* symfile-mem.c (add_vsyscall_page): Adjust.
	* symfile.c (load_progress, generic_load)
	(print_transfer_performance): Adjust.
	* thread.c (info_threads_command, restore_selected_frame)
	(thread_command): Adjust.
	* top.c (make_cleanup_restore_ui_file): Adjust.
	* tracepoint.c (tvariables_info_1, trace_status_mi, tfind_1)
	(print_one_static_tracepoint_marker): Adjust.
	* cli/cli-cmds.c (print_disassembly): Adjust.
	* cli/cli-decode.c (print_doc_line): Adjust.
	* cli/cli-interp.c (safe_execute_command): Adjust.
	* cli/cli-logging.c (set_logging_redirect, pop_output_files)
	(handle_redirections): Adjust.
	* cli/cli-script.c (show_user_1): Adjust.
	* cli/cli-setshow.c (do_setshow_command, cmd_show_list): Adjust.
	* mi/mi-cmd-break.c (breakpoint_notify): Adjust.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Adjust.
	* mi/mi-cmd-env.c (mi_cmd_env_pwd, mi_cmd_env_path)
	(mi_cmd_env_dir): Adjust.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(print_partial_file_name, mi_cmd_file_list_exec_source_files): Adjust.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_depth, mi_cmd_stack_list_args)
	(list_args_or_locals): Adjust.
	* mi/mi-cmd-var.c (print_varobj, mi_cmd_var_create)
	(mi_cmd_var_delete, mi_cmd_var_set_format, mi_cmd_var_set_frozen)
	(mi_cmd_var_show_format, mi_cmd_var_info_num_children)
	(mi_cmd_var_list_children, mi_cmd_var_info_type)
	(mi_cmd_var_info_path_expression, mi_cmd_var_info_expression)
	(mi_cmd_var_show_attributes, mi_cmd_var_evaluate_expression)
	(mi_cmd_var_assign, mi_cmd_var_update, varobj_update_one): Adjust.
	* mi/mi-interp.c (mi_on_normal_stop): Adjust.
	* mi/mi-main.c (mi_cmd_gdb_exit, mi_cmd_thread_select)
	(mi_cmd_thread_list_ids, mi_cmd_thread_info, print_one_inferior)
	(list_available_thread_groups, mi_cmd_list_thread_groups)
	(mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers)
	(mi_cmd_data_list_register_values, get_register)
	(mi_cmd_data_evaluate_expression, mi_cmd_data_read_memory)
	(mi_cmd_data_read_memory_bytes, mi_cmd_list_features)
	(mi_cmd_list_target_features, mi_cmd_add_inferior)
	(mi_execute_command, mi_load_progress): Adjust.
	* mi/mi-symbol-cmds.c (mi_cmd_symbol_list_lines): Adjust.
	* python/py-auto-load.c (print_script, info_auto_load_scripts):
	Adjust.
	* python/py-breakpoint.c (bppy_get_commands): Adjust.
	* tui/tui-interp.c (tui_command_loop): Adjust.
	* tui/tui-io.c (tui_setup_io, tui_initialize_io): Adjust.
@
text
@d38 1
d342 3
d605 1
d613 3
d618 2
d629 1
d637 3
d642 2
@


1.70
log
@	* valops.c (find_overload_match): Call do_cleanups before early
	return.
	* top.c (execute_command): Call do_cleanups before early return.
	(command_loop): Likewise.
	* stack.c (backtrace_command): Make a null cleanup early.  Don't
	conditionally call do_cleanups.
	* python/py-value.c (TRY_CATCH): Move cleanup handling into
	TRY_CATCH.
	* python/py-breakpoint.c (gdbpy_breakpoint_has_py_cond): Rearrange
	so cleanups are always run.
	* mi/mi-cmd-var.c (mi_cmd_var_delete): Reset old_cleanups.
	* findcmd.c (parse_find_args): Call do_cleanups on early return
	path.
	* dbxread.c (elfstab_build_psymtabs): Make a null cleanup early.
	Don't conditionally call do_cleanups.
	* cli/cli-script.c (execute_user_command): Initialize 'old_chain'
	later.
@
text
@d1664 1
a1664 1
  print_command_lines (uiout, cmdlines, 1);
@


1.69
log
@	* cli/cli-interp.c (struct captured_execute_command_args):
	Remove.
	(do_captured_execute_command): Remove.
	(safe_execute_command): Use TRY_CATCH.
	* cli/cli-script.c (struct wrapped_read_command_file_args):
	Remove.
	(wrapped_read_command_file): Remove.
	(script_from_file): Use TRY_CATCH.
	* exceptions.c (catch_exception): Remove.
	* exceptions.h (catch_exception): Remove.
	(deprecated_throw_reason): Update comment.
	* mi/mi-main.c (captured_mi_execute_command): Change 'data'
	argument to 'context'.
	(mi_execute_command): Use TRY_CATCH.
	* remote.c (struct start_remote_args): Remove.
	(remote_start_remote): Update; change arguments.
	(remote_open_1): Use TRY_CATCH.
@
text
@a319 2
  old_chain = setup_user_args (args);

d325 2
@


1.68
log
@2011-03-04  Michael Snyder  <msnyder@@vmware.com>

	Reverting this patch:
	* cli/cli-script.c (script_from_file): Add break for lint.
@
text
@a1591 13
struct wrapped_read_command_file_args
{
  FILE *stream;
};

static void
wrapped_read_command_file (struct ui_out *uiout, void *data)
{
  struct wrapped_read_command_file_args *args = data;

  read_command_file (args->stream);
}

d1615 1
a1615 2
    struct gdb_exception e;
    struct wrapped_read_command_file_args args;
d1617 4
a1620 3
    args.stream = stream;
    e = catch_exception (uiout, wrapped_read_command_file, &args,
			 RETURN_MASK_ERROR);
@


1.67
log
@2011-03-02  Michael Snyder  <msnyder@@vmware.com>

	* cli/cli-script.c (script_from_file): Add break for lint.
@
text
@a1643 1
	break;	/* lint */
@


1.66
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* cli/cli-cmds.c: Shorten lines of >= 80 columns.
	* cli/cli-decode.c: Ditto.
	* cli/cli-dump.c: Ditto.
	* cli/cli-logging.c: Ditto.
	* cli/cli-script.c: Ditto.
	* cli/cli-setshow.c: Ditto.
	* common/signals.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-disas.c: Ditto.
	* mi/mi-cmd-stack.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-cmds.c: Ditto.
	* mi/mi-common.h: Ditto.
	* mi/mi-console.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
	* osf-share/cma_attr.c: Ditto.
	* osf-share/cma_deb_core.h: Ditto.
	* osf-share/cma_debug_client.h: Ditto.
	* osf-share/cma_handle.h: Ditto.
	* osf-share/cma_mutex.h: Ditto.
	* osf-share/cma_stack_int.h: Ditto.
	* osf-share/cma_tcb_defs.h: Ditto.
	* python/py-auto-load.c: Ditto.
	* python/py-breakpoint.c: Ditto.
	* python/py-cmd.c: Ditto.
	* python/py-frame.c: Ditto.
	* python/py-objfile.c: Ditto.
	* python/py-param.c: Ditto.
	* python/py-progspace.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-value.c: Ditto.
	* python/python-internal.h: Ditto.
	* python/python.c: Ditto.
	* tui/tui-data.c: Ditto.
	* tui/tui-disasm.c: Ditto.
	* tui/tui-hooks.c: Ditto.
	* tui/tui-io.c: Ditto.
	* tui/tui-layout.c: Ditto.
	* tui/tui-regs.c: Ditto.
	* tui/tui-source.c: Ditto.
	* tui/tui-stack.c: Ditto.
	* tui/tui-win.c: Ditto.
	* tui/tui-windata.c: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d1644 1
@


1.65
log
@run copyright.sh for 2011.
@
text
@d1189 2
a1190 1
	  (*deprecated_readline_begin_hook) ("%s  %s\n", prompt_arg, END_MESSAGE);
d1483 2
a1484 1
	  warning (_("Your new `%s' command does not hook any existing command."),
d1522 2
a1523 1
          newc->hookee_post = hookc; /* We are marked as hooking target cmd.  */
@


1.64
log
@2010-12-28  Michael Snyder  <msnyder@@vmware.com>

	* command.h: Comment clean-up.
	* cli/cli-cmds.c: Ditto.
	* cli/cli-cmds.h: Ditto.
	* cli/cli-decode.c: Ditto.
	* cli/cli-decode.h: Ditto.
	* cli/cli-dump.c: Ditto.
	* cli/cli-interp.c: Ditto.
	* cli/cli-logging.c: Ditto.
	* cli/cli-script.c: Ditto.
	* cli/cli-setshow.c: Ditto.
	* cli/cli-setshow.h: Ditto.
@
text
@d5 1
a5 1
   2009, 2010 Free Software Foundation, Inc.
@


1.63
log
@2010-05-17  Michael Snyder  <msnyder@@vmware.com>

	* cli/cli-cmds.c: White space.
	* cli/cli-decode.c: White space.
	* cli/cli-dump.c: White space.
	* cli/cli-interp.c: White space.
	* cli/cli-logging.c: White space.
	* cli/cli-script.c: White space.
	* cli/cli-setshow.c: White space.
@
text
@d39 1
a39 1
/* Prototypes for local functions */
d68 2
a69 1
       ensure that the arguments are not overwritten before they are used.  */
d168 2
a169 1
      /* loop_break to break out of a while loop, print it and continue.  */
d178 2
a179 1
      /* A while command.  Recursively print its subcommands and continue.  */
d183 3
a185 3
	  /* For while-stepping, the line includes the 'while-stepping' token.
	     See comment in process_next_line for explanation.  Here,
	     take care not print 'while-stepping' twice.  */
d200 2
a201 1
      /* An if command.  Recursively print both arms before continueing.  */
d206 1
a206 1
	  /* The true arm. */
d227 2
a228 1
      /* A commands command.  Print the breakpoint commands and continue.  */
d259 1
a259 1
      /* ignore illegal command type and try next */
d271 1
a271 1
  c->hook_in = 0; /* Allow hook to work again once it is complete */
d280 1
a280 1
      c->hook_in = 1; /* Prevent recursive hooking */
d293 1
a293 1
      c->hook_in = 1; /* Prevent recursive hooking */
d356 2
a357 2
/* This function is called every time GDB prints a prompt.
   It ensures that errors and the like to not confuse the command tracing.  */
d530 2
a531 2
	/* Choose which arm to take commands from based on the value of the
	   conditional expression.  */
d557 2
a558 2
	/* Breakpoint commands list, record the commands in the breakpoint's
	   command list and return.  */
d584 1
a584 1
   suppress_next_print_command_trace.   */
d729 2
a730 2
/* Given character string P, return a point to the first argument ($arg),
   or NULL if P contains no arguments.  */
d746 2
a747 1
   arguments found in line, with the updated copy being placed into nline.  */
d760 2
a761 1
  /* First we need to know how much memory to allocate for the new line.  */
d893 6
a898 5
/* Process one input line.  If the command is an "end",
   return such an indication to the caller.  If PARSE_COMMANDS is true,
   strip leading whitespace (trailing whitespace is always stripped)
   in the line, attempt to recognize GDB control commands, and also
   return an indication if the command is an "else" or a nop.
d923 1
a923 1
  /* 'end' is always recognized, regardless of parse_commands value. 
d930 1
a930 1
      /* If commands are parsed, we skip initial spaces. Otherwise,
d936 2
a937 2
	 distinguish them from else, end and other commands which can be
	 executed.  */
d945 2
a946 2
      /* Check for while, if, break, continue, etc and build a new command
	 line structure for them.  */
d956 1
a956 1
	     to 'while-stepping'. This is intentional -- we don't
d958 4
a961 3
	     and next break-info returning command line with 'while-stepping'.
	     This should work, but might cause the breakpoint to be marked as
	     changed while it's actually not.  */
d1052 3
a1054 5
/* Recursively read in the control structures and create a command_line 
   structure from them.  Use read_next_line_func to obtain lines of
   the command.

*/
d1188 1
a1188 1
	  /* Note - intentional to merge messages with no newline */
d1492 1
a1492 1
     should behave in the same manner. */
d1516 1
a1516 1
          newc->hookee_pre = hookc; /* We are marked as hooking target cmd. */
d1520 1
a1520 1
          newc->hookee_post = hookc; /* We are marked as hooking target cmd. */
d1523 1
a1523 1
          /* Should never come here as hookc would be 0. */
d1602 1
a1602 1
/* Used to implement source_command */
d1620 2
a1621 2
  /* This will get set every time we read a line.  So it won't stay "" for
     long.  */
@


1.62
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* cli-dump.c (dump_memory_to_file): Delete unused variable.
	(restore_binary_file): Delete unused variable.
	* cli-decode.c (deprecated_cmd_warning): Delete unused variables.
	* cli-script.c (define_command): Delete unused variables.
	(recurse_read_control_structure): Delete unused variable.
	(script_from_file): Delete unused variable.
	* cli-cmds.c (complete_command): Delete unused variable.
	(disassemble_command): Delete unused variable.
@
text
@a144 1

d265 1
d287 1
d298 2
a299 1
  int * depth = call_depth;
d438 1
d506 1
d630 1
d816 4
a819 4
	  {
	    memcpy (new_line, user_args->a[i].arg, len);
	    new_line += len;
	  }
d958 1
d967 1
d976 1
d1027 1
d1442 1
d1576 2
a1577 1
  (struct source_cleanup_lines_args *) args;
d1591 1
d1620 1
d1655 1
@


1.61
log
@	* top.c (source_file_name): Make const char *.
	* top.h (source_file_name): Update.
	* cli/cli-script.c (source_cleanup_lines_args): Make old_file
	const char *.
	(script_from_file): Change `file' arg to const char *.
	* cli/cli-script.h (script_from_file): Update.
@
text
@a1049 1
  char *p;
d1410 2
a1411 2
  struct cmd_list_element *c, *newc, *oldc, *hookc = 0, **list;
  char *tem, *tem2, *comfull;
a1589 1
  int needed_length;
@


1.60
log
@        gdb/
        * cli/cli-script.c (process_next_line): Handle 'stepping'.

	gdb/testsuite/
	* gdb.trace/while-dyn.exp (executable): New variable.
	(binfile): Use it.
	(test_while_stepping): New function.  Move most tests here.  Call
	it once for each of the while-stepping, stepping and ws aliases.
@
text
@d1560 1
a1560 1
  char *old_file;
d1587 1
a1587 1
script_from_file (FILE *stream, char *file)
@


1.59
log
@	Unify actions and commands

	* defs.h (read_command_lines, read_command_lines_1): New
	parameters validator and closure.
	* tracepoint.h (struct action_line): Remove.
	* breakpoint.h (struct breakpoint): Remove the 'actions'
	field.
	* defs.h (enum command_control_type): New value
	while_stepping_control.
	(struct command_line): Add comments.
	* breakpoint.c (breakoint_is_tracepoint): New.
	(breakpoint_set_commands): For tracepoints,
	verify the commands are permissible.
	(check_tracepoint_commands): New.
	(commands_command): Require that each new line is validated using
	check_tracepoint_command, if we set commands for a tracepoint.
	(create_tracepoint_from_upload): Likewise.
	(print_one_breakpoint_location): Remove the code to print
	actions specifically.
	(tracepoint_save_command): Relay to print_command_lines.
	* cli/cli-script.c (process_next_line): New parameters validator
	and closure. Handle 'while-stepping'. Call validator if not null.
	(read_command_lines, read_command_lines1): Likewise.
	(recurse_read_control_structure): New parameters validator and
	closure. Handle while_stepping_control.
	(print_command_lines): Handle while-stepping.
	(get_command_line, define_command, document_command): Adjust.
	* remote.c (remote_download_tracepoint): Adjust.
	* tracepoint.c (make_cleanup_free_actions, read_actions)
	(free_actions, do_free_actions_cleanup): Remove.
	(trace_actions_command): Use read_command_lines.
	(validate_actionline): Use error in one place.
	(encode_actions_1): New, extracted from...
	(encode_actions): ...this. Also use cleanups for exception
	safety.
	(trace_dump_command): Adjust.
	* mi/mi-cmd-break (mi_cmd_break_commands): Validate commands if
	it's tracepoint.
@
text
@d935 2
a936 1
	  || (p_end -p >= 2 && !strncmp (p, "ws", 2)))
@


1.58
log
@	* mi/mi-cmd-break.c (mi_read_next_line): Add missing 'void'.
	* defs.h (read_command_lines_1): Add missing 'void'.
	* cli/cli-script.c (recurse_read_control_structure): Add missing
	'void'.
	(read_next_line): Likewise.
	(read_command_lines_1): Likewise.
@
text
@d43 3
a45 1
				struct command_line *current_cmd);
d122 2
a123 1
  if (recurse_read_control_structure (read_next_line, cmd) == invalid_control)
d178 2
a179 1
      if (list->control_type == while_control)
d181 7
a187 1
	  ui_out_field_fmt (uiout, NULL, "while %s", list->line);
d889 2
a890 1
process_next_line (char *p, struct command_line **command, int parse_commands)
d934 16
a949 1
      if (p_end - p > 5 && !strncmp (p, "while", 5))
d1015 14
d1041 3
a1043 1
				struct command_line *current_cmd)
d1068 2
a1069 1
			       current_cmd->control_type != python_control);
d1078 1
d1131 1
d1137 2
a1138 1
	  ret = recurse_read_control_structure (read_next_line_func, next);
d1163 2
a1164 1
read_command_lines (char *prompt_arg, int from_tty, int parse_commands)
d1182 2
a1183 1
  head = read_command_lines_1 (read_next_line, parse_commands);
d1196 2
a1197 1
read_command_lines_1 (char * (*read_next_line_func) (void), int parse_commands)
d1211 2
a1212 1
      val = process_next_line (read_next_line_func (), &next, parse_commands);
d1233 2
a1234 1
	  || next->control_type == commands_control)
d1237 2
a1238 1
	  ret = recurse_read_control_structure (read_next_line_func, next);
d1481 1
a1481 1
  cmds = read_command_lines (tmpbuf, from_tty, 1);
d1530 1
a1530 1
  doclines = read_command_lines (tmpbuf, from_tty, 0);
@


1.57
log
@gdb/
	* cli/cli-script.c (process_next_line): Rename p1 as p_end and p2 as
	p_start.  Change != comparisons to > and < comparisons.
@
text
@d42 1
a42 1
recurse_read_control_structure (char * (*read_next_line_func) (), 
d49 1
a49 1
static char *read_next_line ();
d848 1
a848 1
read_next_line ()
d1000 1
a1000 1
recurse_read_control_structure (char * (*read_next_line_func) (), 
d1148 1
a1148 1
read_command_lines_1 (char * (*read_next_line_func) (), int parse_commands)
@


1.56
log
@gdb/
	* cli/cli-script.c (process_next_line): Check P2 overrun.
@
text
@d881 2
a882 2
  char *p1;
  char *p2;
d890 3
a892 3
  p1 = p + strlen (p);
  while (p1 != p && (p1[-1] == ' ' || p1[-1] == '\t'))
    p1--;
d894 1
a894 1
  p2 = p;
d896 2
a897 2
  while (p2 != p1 && (*p2 == ' ' || *p2 == '\t'))
    p2++;
d901 1
a901 1
  if (p1 - p2 == 3 && !strncmp (p2, "end", 3))
d909 1
a909 1
      p = p2;
d914 1
a914 1
      if (p1 == p || p[0] == '#')
d918 1
a918 1
      if (p1 - p == 4 && !strncmp (p, "else", 4))
d923 1
a923 1
      if (p1 - p > 5 && !strncmp (p, "while", 5))
d927 1
a927 1
	  while (first_arg < p1 && isspace (*first_arg))
d931 1
a931 1
      else if (p1 - p > 2 && !strncmp (p, "if", 2))
d935 1
a935 1
	  while (first_arg < p1 && isspace (*first_arg))
d939 1
a939 1
      else if (p1 - p >= 8 && !strncmp (p, "commands", 8))
d943 1
a943 1
	  while (first_arg < p1 && isspace (*first_arg))
d947 1
a947 1
      else if (p1 - p == 6 && !strncmp (p, "python", 6))
d953 1
a953 1
      else if (p1 - p == 10 && !strncmp (p, "loop_break", 10))
d963 1
a963 1
      else if (p1 - p == 13 && !strncmp (p, "loop_continue", 13))
d983 1
a983 1
      (*command)->line = savestring (p, p1 - p);
@


1.55
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d896 1
a896 1
  while (*p2 == ' ' || *p2 == '\t')
@


1.54
log
@	* cli/cli-script.c (process_next_line): Recognize 'end'
	even when the line has leading space and we're not parsing
	commands.
@
text
@d5 1
a5 1
   2009 Free Software Foundation, Inc.
@


1.53
log
@	Refactor reading of commands

	* defs.h (read_command_lines_1): Declare.
	* cli/cli-script.c (read_next_line): Only return string,
	do not process.
	(process_next_line): New, extracted from read_next_line.
	(recurse_read_control_structure): Take a function pointer to the
	read function.
	(get_command_line) Pass the read_next_line as reader function
	into recurse_read_control_structure.
	(read_command_lines_1): New, extracted from...
	(read_command_lines): ...here.
@
text
@d882 1
a888 7
  if (parse_commands)
    {
      /* Strip leading whitespace.  */
      while (*p == ' ' || *p == '\t')
	p++;
    }

d894 8
a901 2
  /* Is this the end of a simple, while, or if control structure?  */
  if (p1 - p == 3 && !strncmp (p, "end", 3))
d903 1
a903 1

d906 5
@


1.52
log
@gdb/
	Replace the savestring calls by xstrdup calls where possible.
	* breakpoint.c (condition_command, set_raw_breakpoint)
	(create_catchpoint, update_breakpoint_locations): Replace the
	savestring calls by xstrdup calls where possible.
	* buildsym.c (start_subfile, patch_subfile_names, record_debugformat)
	(record_producer): Likewise.
	* coffread.c (coff_start_symtab, complete_symtab): Likewise.
	* corefile.c (set_gnutarget): Likewise.
	* dbxread.c (add_new_header_file): Likewise.
	* demangle.c (set_demangling_command, set_demangling_style): Likewise.
	* event-top.c (push_prompt, pop_prompt, command_line_handler)
	(set_async_prompt): Likewise.
	* infcmd.c (set_inferior_io_terminal, attach_command_post_wait):
	Likewise.
	* language.c (set_language_command, _initialize_language): Likewise.
	* linespec.c (decode_line_2): Likewise.
	* rs6000-nat.c (add_vmap): Likewise.
	* top.c (set_prompt, init_history, init_main): Likewise.
	* tracepoint.c (stringify_collection_list): Likewise.
	* varobj.c (varobj_create): Remove variable expr_len.  Replace the
	savestring calls by xstrdup calls where possible.
	(value_of_root, c_name_of_variable, c_describe_child): Replace the
	savestring calls by xstrdup calls where possible.
	* xcoffread.c (complete_symtab): Likewise.
	* cli/cli-script.c (build_command_line, define_command): Likewise.
	* cli/cli-setshow.c (do_setshow_command): Likewise.
@
text
@d42 2
a43 1
	recurse_read_control_structure (struct command_line *current_cmd);
d49 2
d120 1
a120 1
  if (recurse_read_control_structure (cmd) == invalid_control)
d843 3
a845 6
/* Read one line from the input stream.  If the command is an "end",
   return such an indication to the caller.  If PARSE_COMMANDS is true,
   strip leading whitespace (trailing whitespace is always stripped)
   in the line, attempt to recognize GDB control commands, and also
   return an indication if the command is an "else" or a nop.
   Otherwise, only "end" is recognized.  */
d847 2
a848 2
static enum misc_command_type
read_next_line (struct command_line **command, int parse_commands)
d850 1
a850 1
  char *p, *p1, *prompt_ptr, control_prompt[256];
a851 1
  int not_handled = 0;
d868 15
a882 1
  p = command_line_input (prompt_ptr, instream == stdin, "commands");
d989 2
a990 1
   structure from them.
d992 1
a992 2
   The parent_control parameter is the control structure in which the
   following commands are nested.  */
d995 2
a996 1
recurse_read_control_structure (struct command_line *current_cmd)
d1002 1
d1020 2
a1021 1
      val = read_next_line (&next, current_cmd->control_type != python_control);
d1087 1
a1087 1
	  ret = recurse_read_control_structure (next);
d1114 1
a1114 6
  struct command_line *head, *tail, *next;
  struct cleanup *old_chain;
  enum command_control_type ret;
  enum misc_command_type val;

  control_level = 0;
d1130 21
d1157 1
a1157 1
      val = read_next_line (&next, parse_commands);
d1181 1
a1181 1
	  ret = recurse_read_control_structure (next);
d1212 1
a1212 5
  if (deprecated_readline_end_hook && from_tty && input_from_terminal_p ())
    {
      (*deprecated_readline_end_hook) ();
    }
  return (head);
@


1.51
log
@2009-02-25  Hui Zhu  <teawater@@gmail.com>

	* cli/cli-script.c (define_command): Add _() to query.
	* gnu-nat.c (inf_validate_task_sc): Ditto.
	* infcmd.c (kill_if_already_running): Ditto.
	(jump_command): Ditto.
	(attach_command): Ditto.
	* inflow.c (kill_command): Ditto.
	* infrun.c (handle_command): Ditto.
	* maint.c (maintenance_dump_me): Ditto.
	* memattr.c (mem_delete_command): Ditto.
	* monitor.c (monitor_interrupt_query): Ditto.
	* nto-procfs.c (interrupt_query): Ditto.
	* printcmd.c (undisplay_command): Ditto.
	* remote-mips.c (mips_kill): Ditto.
	* remote.c (interrupt_query): Ditto.
	* solib-irix.c (irix_open_symbol_file_object): Ditto.
	* solib-osf.c (osf_open_symbol_file_object): Ditto.
	* solib-pa64.c (pa64_open_symbol_file_object): Ditto.
	* solib-som.c (som_open_symbol_file_object): Ditto.
	* solib-svr4.c (open_symbol_file_object): Ditto.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Ditto.
	* target.c (kill_or_be_killed): Ditto.
	* tracepoint.c (delete_trace_command): Ditto.
	* top.c (quit_confirm): Add _() to s that will be used
	in query.
@
text
@d97 1
a97 1
  cmd->line = savestring (args, strlen (args));
d1387 1
a1387 1
  comname = savestring (comname, strlen (comname));
d1403 1
a1403 1
		  ? c->doc : savestring ("User-defined.", 13), list);
@


1.50
log
@	* NEWS: Document "define" for prefixed commands.
	* cli/cli-cmds.c (show_user): Update calls to show_user_1.  Call
	show_user_1 for prefix commands.
	* cli/cli-decode.c (help_cmd_list): Recurse for "help user-defined".
	* cli/cli-script.c (validate_comname): Rewrite to handle prefix
	commands.  Return the containing command list.
	(define_command, document_command): Update to handle prefix commands.
	(show_user_1): Add prefix and name arguments.  Handle prefix
	commands.
	* cli/cli-script.h (show_user_1): Update prototype.

	doc/
	* gdb.texinfo (Define, Hooks): Document prefix command support.

	testsuite/
	* gdb.base/define.exp: Test defining and hooking prefix commands.
	* gdb.python/python.exp: Update test for "show user" output.
@
text
@d1382 1
a1382 1
	  if (!query ("Proceed? "))
@


1.49
log
@        Updated copyright notices for most files.
@
text
@a47 2
static void validate_comname (char *);

d1255 8
a1262 2
static void
validate_comname (char *comname)
d1264 2
a1265 1
  char *p;
d1267 1
a1267 1
  if (comname == 0)
d1270 28
a1297 1
  p = comname;
d1304 2
d1325 2
a1326 3
  struct cmd_list_element *c, *newc, *oldc, *hookc = 0;
  char *tem = comname;
  char *tem2; 
d1336 2
a1337 1
  validate_comname (comname);
d1340 2
a1341 1
  c = lookup_cmd (&tem, cmdlist, "", -1, 1);
d1375 1
a1375 1
      hookc = lookup_cmd (&tem, cmdlist, "", -1, 0);
d1381 1
a1381 1
		   comname);
d1395 1
a1395 1
  sprintf (tmpbuf, "Type commands for definition of \"%s\".", comname);
d1403 1
a1403 1
		  ? c->doc : savestring ("User-defined.", 13), &cmdlist);
d1431 2
a1432 2
  struct cmd_list_element *c;
  char *tem = comname;
d1435 2
a1436 1
  validate_comname (comname);
d1438 2
a1439 1
  c = lookup_cmd (&tem, cmdlist, "", 0, 1);
d1442 1
a1442 1
    error (_("Command \"%s\" is built-in."), comname);
d1444 1
a1444 1
  sprintf (tmpbuf, "Type documentation for \"%s\".", comname);
d1545 4
d1550 2
a1551 1
show_user_1 (struct cmd_list_element *c, struct ui_file *stream)
d1555 9
d1567 1
a1567 3
  fputs_filtered ("User command ", stream);
  fputs_filtered (c->name, stream);
  fputs_filtered (":\n", stream);
@


1.48
log
@	* cli/cli-script.c (do_fclose_cleanup): Remove.
	(script_from_file): Use make_cleanup_fclose.
	* xml-tdesc.c (do_cleanup_fclose): Remove.
	(fetch_xml_from_file): Use make_cleanup_fclose.
	* tracepoint.c (tracepoint_save_command): Use
	make_cleanup_fclose.  Always free pathname.
	* source.c (print_source_lines_base): Use make_cleanup_fclose.
	* remote.c (fclose_cleanup): Remove.
	(remote_file_put): Use make_cleanup_fclose.
	(remote_file_get): Likewise.
	* linux-nat.c (linux_nat_find_memory_regions): Use
	make_cleanup_fclose.
	(linux_nat_info_proc_cmd): Likewise.
	(linux_proc_pending_signals): Likewise.
	* fbsd-nat.c (fbsd_find_memory_regions): Use make_cleanup_fclose.
	Free file name.
	* cli/cli-dump.c (do_fclose_cleanup): Remove.
	(make_cleanup_fclose): Remove.
	* defs.h (make_cleanup_fclose): Declare.
	* utils.c (do_fclose_cleanup): New function.
	(make_cleanup_fclose): Likewise.
@
text
@d4 2
a5 2
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008
   Free Software Foundation, Inc.
@


1.47
log
@gdb/
2008-08-16  Vladimir Prus  <vladimir@@codesourcery.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* cli-script.c (read_next_line): Add parse_commands argument.
	(recurse_read_control_structure): Adapt to new read_next_line
	signature.
	(read_command_lines): Add parse_commands argument.
	(define_command): Adapt to new read_command_lines signature.
	(document_command): Likewise.
	* breakpoint.c (commands_command): Likewise.
	* defs.h (read_command_lines): Adjust function prototype.

testsuite/
2008-08-16  Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* gdb.base/define.exp: Test indented command documentation.
	* gdb.python/python.exp: Test indented multi-line command.
@
text
@a1448 6
static void
do_fclose_cleanup (void *stream)
{
  fclose (stream);
}

d1473 1
a1473 1
  old_cleanups = make_cleanup (do_fclose_cleanup, stream);
@


1.46
log
@Initial python support.

gdb/
2008-08-06  Vladimir Prus  <vladimir@@codesourcery.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>
	    Doug Evans  <dje@@google.com>

	* Makefile.in (SUBDIR_PYTHON_OBS, SUBDIR_PYTHON_SRCS,
	SUBDIR_PYTHON_DEPS, SUBDIR_PYTHON_LDFLAGS, SUBDIR_PYTHON_CFLAGS,
	PYTHON_CFLAGS): New.
	(python_h, python_internal_h): New.
	(cli-script.o): Depend on python.h
	(python.o, python-utils.o): New.
	* cli/cli-script.c (print_command_lines): Handle python_control.
	(execute_control_command): Handle python_control.
	(execute_control_command_untraced): New function.
	(while_command): Call execute_control_command_untraced.
	(if_command): Likewise.
	(get_command_line): Remove static attribute.
	(read_next_line): Handle "python".
	(recurse_read_control_structure): Handle python_control.
	(read_command_lines): Handle python_control.
	Include python.h.
	* cli/cli-script.h (get_command_line): Add prototype.
	(execute_control_command_untraced): Likewise.
	* configure.ac: Add --with-python.
	* defs.h (enum command_control_type) <python_control>: New
	constant.
	* python/python-internal.h: New file.
	* python/python.c: New file.
	* python/python.h: New file.
	* python/python-utils.c: New file.
	* NEWS: Mention Python scripting support and its new commands.

gdb/doc/
2008-08-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Extending GDB): New chapter.
	(Sequences): Demoted chapter, now a section under the new
	Extending GDB chapter.
	(Python): New section.

gdb/testsuite/
2008-08-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.python/python.exp: New file.
@
text
@d842 6
a847 2
/* Read one line from the input stream.  If the command is an "else" or
   "end", return such an indication to the caller.  */
d850 1
a850 1
read_next_line (struct command_line **command)
d854 1
d877 6
a882 3
  /* Strip leading and trailing whitespace.  */
  while (*p == ' ' || *p == '\t')
    p++;
d884 1
a888 6
  /* Blanks and comments don't really do anything, but we need to
     distinguish them from else, end and other commands which can be
     executed.  */
  if (p1 == p || p[0] == '#')
    return nop_command;

d893 1
a893 37
  /* Is the else clause of an if control structure?  */
  if (p1 - p == 4 && !strncmp (p, "else", 4))
    return else_command;

  /* Check for while, if, break, continue, etc and build a new command
     line structure for them.  */
  if (p1 - p > 5 && !strncmp (p, "while", 5))
    {
      char *first_arg;
      first_arg = p + 5;
      while (first_arg < p1 && isspace (*first_arg))
        first_arg++;
      *command = build_command_line (while_control, first_arg);
    }
  else if (p1 - p > 2 && !strncmp (p, "if", 2))
    {
      char *first_arg;
      first_arg = p + 2;
      while (first_arg < p1 && isspace (*first_arg))
        first_arg++;
      *command = build_command_line (if_control, first_arg);
    }
  else if (p1 - p >= 8 && !strncmp (p, "commands", 8))
    {
      char *first_arg;
      first_arg = p + 8;
      while (first_arg < p1 && isspace (*first_arg))
        first_arg++;
      *command = build_command_line (commands_control, first_arg);
    }
  else if (p1 - p == 6 && !strncmp (p, "python", 6))
    {
      /* Note that we ignore the inline "python command" form
	 here.  */
      *command = build_command_line (python_control, "");
    }
  else if (p1 - p == 10 && !strncmp (p, "loop_break", 10))
d895 64
a958 7
      *command = (struct command_line *)
	xmalloc (sizeof (struct command_line));
      (*command)->next = NULL;
      (*command)->line = NULL;
      (*command)->control_type = break_control;
      (*command)->body_count = 0;
      (*command)->body_list = NULL;
d960 2
a961 11
  else if (p1 - p == 13 && !strncmp (p, "loop_continue", 13))
    {
      *command = (struct command_line *)
	xmalloc (sizeof (struct command_line));
      (*command)->next = NULL;
      (*command)->line = NULL;
      (*command)->control_type = continue_control;
      (*command)->body_count = 0;
      (*command)->body_list = NULL;
    }
  else
d1007 1
a1007 1
      val = read_next_line (&next);
d1089 5
a1093 1
   input, and is not included in the returned chain of commands. */
d1098 1
a1098 1
read_command_lines (char *prompt_arg, int from_tty)
d1127 1
a1127 1
      val = read_next_line (&next);
d1361 1
a1361 1
  cmds = read_command_lines (tmpbuf, from_tty);
d1408 1
a1408 1
  doclines = read_command_lines (tmpbuf, from_tty);
@


1.45
log
@	Updated copyright notices for most files.
@
text
@d37 2
d107 1
a107 1
static struct command_line *
d230 14
d546 6
d563 11
d588 1
a588 2
  suppress_next_print_command_trace = 1;
  execute_control_command (command);
d606 1
a606 2
  suppress_next_print_command_trace = 1;
  execute_control_command (command);
d920 6
d1002 1
d1054 1
d1128 1
@


1.45.10.1
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@a289 1
  {
a290 5
// begin ARC
   /* If there are no user commands to be executed, execute the
      callback function instead.  */
    c->func(c, NULL, 0);
// end ARC
a291 1
  }
@


1.44
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d4 1
a4 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007
@


1.43
log
@2007-08-21  Chris Smith  <chris.smith@@st.com>

	* cli/cli-script.c (read_command_lines): Call dont_repeat for each
	line.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.42
log
@	* target-descriptions.c (tdesc_create_reg): Do not set reg->type
	to NULL.

	* cli/cli-script.c (build_command_line): Update NULL check.
@
text
@d1070 1
@


1.41
log
@2007-06-28  Michael Snyder  <msnyder@@access-company.com>

	* cli/cli-script.c (build_command_line): Add null pointer guard
	(Coverity).
@
text
@d88 1
d99 1
a99 2
  if (args != NULL)
    cmd->line = savestring (args, strlen (args));
@


1.40
log
@	* cli/cli-script.c: Include breakpoint.h.
	(build_command_line): Require arguments only for if and while commands.
	(get_command_line, execute_user_command, execute_control_command):
	Fix wording of warning messages.
	(print_command_lines): Print breakpoint commands.
	(execute_control_command): Call commands_from_control_command to
	handle the `commands' command inside a body of a flow-control command.
	(read_next_line): Recognize the `commands' command and build a
	command line structure for it.
	(recurse_read_control_structure, read_command_lines): Handle
	`commands' similarly to `if' and `while'.

	* breakpoint.c (get_number_trailer): Document the special meaning
	of NULL as the first argument PP.
	(commands_from_control_command): New function.

	* breakpoint.h (commands_from_control_command): Add prototype.

	* defs.h (commands_control): New enumerated value for enum
	command_control_type.
@
text
@d98 3
a100 1
  cmd->line = savestring (args, strlen (args));
@


1.39
log
@Copyright updates for 2007.
@
text
@d33 1
d86 1
a86 1
  if (args == NULL)
d119 1
a119 1
      warning (_("Error reading in control structure."));
d211 17
d313 1
a313 1
	  warning (_("Error in control structure."));
d519 11
d532 1
a532 1
      warning (_("Invalid control type in command structure."));
d881 8
d964 2
a965 1
	      || current_cmd->control_type == if_control)
d967 1
a967 1
	      /* Success reading an entire control structure.  */
d1015 2
a1016 1
	  || next->control_type == if_control)
d1087 2
a1088 1
	  || next->control_type == if_control)
@


1.38
log
@2006-08-10  Andrew Stubbs  <andrew.stubbs@@st.com>

gdb/
	* cli/cli-script.c (execute_user_command): Update command_next_depth
	on user-command call.

gdb/testsuite
	* gdb.base/trace-commands.exp: New file.
@
text
@d3 2
a4 2
   Copyright (c) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2006
@


1.37
log
@2006-07-21  Andrew Stubbs  <andrew.stubbs@@st.com>

	* cli/cli-cmds.c (source_verbose, trace_commands): New variables.
	(source_script): New function.
	(source_verbose_cleanup): New function.
	(source_command): Move old contents to source_script.
	Make function static. Parse -v option and call source_script.
	(init_cli_cmds): Update source command help.
	Add 'set trace-commands' command.
	* cli/cli-script.c (command_next_depth): New static variable.
	(suppress_next_print_command_trace): New static variable.
	(reset_command_nest_depth): New function.
	(print_command_trace): New function.
	(execute_control_command): Split the continue_control and break_control
	cases, add calls to print_command_trace and count the nest depth.
	(while_command): Set suppress_next_print_command_trace.
	(if_command): Likewise.
	* top.c (execute_command): Call print_command_trace.
	* cli/cli-cmds.h (source_verbose, trace_commands): New extern variables.
	(source_command): Change to source_script.
	* main.c (captued_main): Use source_script instead of source_command.
	* top.h (source_command): Change to source_script.
	* event-top.c (display_gdb_prompt): Call reset_command_nest_depth.
	* cli/cli-script.h (print_command_trace): Export.
	(reset_command_nest_depth): Likewise.

docs/
	* gdb.texinfo (Optional warnings and messages): Add
	'set/show trace-commands'.
	(Command files): Add '-v' to source command.

testsuite/
	* gdb.base/default.exp: Update source command error message.
	* gdb.base/help.exp: Update 'help source' message.
@
text
@d289 1
d300 1
@


1.36
log
@2006-06-21  Andrew Stubbs  <andrew.stubbs@@st.com>

        * cli/cli-script.c (realloc_body_list): Zero new parts of body_list.
@
text
@d49 1
a49 1
/* Level of control structure.  */
d52 6
d302 40
d371 7
d379 2
d388 4
d424 1
d426 1
d455 4
d485 1
d487 1
d524 1
d543 1
@


1.35
log
@2006-04-07  Andrew Stubbs  <andrew.stubbs@@st.com>

gdb/
	* cli/cli-script.c (struct user_args): Add command field.
	(arg_cleanup): Free command string.
	(setup_user_args): Copy the command line before relying on it.

gdb/testsuite/
	* gdb.base/commands.exp (recursive_source_test): New test.
@
text
@d704 1
@


1.35.6.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d49 1
a49 1
/* Level of control structure when reading.  */
a51 6
/* Level of control structure when executing.  */
static int command_nest_depth = 1;

/* This is to prevent certain commands being printed twice.  */
static int suppress_next_print_command_trace = 0;

a282 1
  command_nest_depth++;
a292 1
  command_nest_depth--;
a295 40
/* This function is called every time GDB prints a prompt.
   It ensures that errors and the like to not confuse the command tracing.  */

void
reset_command_nest_depth (void)
{
  command_nest_depth = 1;

  /* Just in case.  */
  suppress_next_print_command_trace = 0;
}

/* Print the command, prefixed with '+' to represent the call depth.
   This is slightly complicated because this function may be called
   from execute_command and execute_control_command.  Unfortunately
   execute_command also prints the top level control commands.
   In these cases execute_command will call execute_control_command
   via while_command or if_command.  Inner levels of 'if' and 'while'
   are dealt with directly.  Therefore we can use these functions
   to determine whether the command has been printed already or not.  */
void
print_command_trace (const char *cmd)
{
  int i;

  if (suppress_next_print_command_trace)
    {
      suppress_next_print_command_trace = 0;
      return;
    }

  if (!source_verbose && !trace_commands)
    return;

  for (i=0; i < command_nest_depth; i++)
    printf_filtered ("+");

  printf_filtered ("%s\n", cmd);
}

a324 7
      print_command_trace ("loop_continue");

      /* Return for "continue", and "break" so we can either
         continue the loop at the top, or break out.  */
      ret = cmd->control_type;
      break;

a325 2
      print_command_trace ("loop_break");

a332 4
	char *buffer = alloca (strlen (cmd->line) + 7);
	sprintf (buffer, "while %s", cmd->line);
	print_command_trace (buffer);

a364 1
		command_nest_depth++;
a365 1
		command_nest_depth--;
a393 4
	char *buffer = alloca (strlen (cmd->line) + 4);
	sprintf (buffer, "if %s", cmd->line);
	print_command_trace (buffer);

a419 1
	    command_nest_depth++;
a420 1
	    command_nest_depth--;
a456 1
  suppress_next_print_command_trace = 1;
a474 1
  suppress_next_print_command_trace = 1;
a703 1
  memset (body_list + n, 0, sizeof (struct command_line *) * (new_length - n));
@


1.35.6.2
log
@(execute_control_command): Import stuff for
breakpoint commands from Apple's code.
@
text
@a37 3
extern void mi_interpreter_exec_bp_cmd (char *command, 
					char **argv, int argc);

d368 1
a368 26

      /* Control commands are only run when we are doing console
       interpreter commands (either a breakpoint command, or a
       while command in the command line.  In the mi interpreter
       we need to use the mi interpreter-exec command to get all
       the output right.

       FIXME: Two things - 
         1) We should have a way of specifying (at least for
         breakpoint commands) what interpreter they are meant
         for.
         2) We should have a generic route to another interpreter
         command which we can use here, rather than having to 
         special case interpreters as we do here. */

      if (ui_out_is_mi_like_p (uiout))
	{
	  char *argv[2];
	  int argc = 2;
	  argv[0] = "console";
	  argv[1] = new_line;
	  mi_interpreter_exec_bp_cmd (new_line, argv, argc);
	}
      else
	execute_command (new_line, 0);

@


1.34
log
@gdb/
	* cli/cli-script.c (insert_args): Handle NULL user_args.
gdb/testsuite/
	* gdb.base/commands.exp (stray_arg0_test): New test.
@
text
@d57 3
d489 1
d514 2
@


1.33
log
@	* Makefile.in (utils.o): Update.
	* top.c (in_user_command): New.
	(command_line_input): Use input_from_terminal_p.
	(input_from_terminal_p): Don't check caution.  Handle
	stdin == NULL for Insight.
	* top.h (in_user_command, caution): New declarations.
	* utils.c: Include "top.h".
	(query, defaulted_query): Check caution here.  Move the call
	to input_from_terminal_p higher.
	* cli/cli-script.c (do_restore_user_call_depth): Only decrement
	the depth.  Update in_user_command if necessary.
	(execute_user_command): Don't clobber old_chain.  Set
	in_user_command.  Let do_restore_user_call_depth handle
	user_call_depth.
	(read_command_lines): Check whether to prompt before calling
	Insight hooks.
	* tui/tui-hooks.c (tui_query_hook): Remove newly unnecessary
	input_from_terminal_p check.
@
text
@d596 5
@


1.32
log
@
	* cli/cli-utils.h:
	* cli/cli-utils.c:
	* cli/cli-setshow.h:
	* cli/cli-setshow.c:
	* cli/cli-script.h:
	* cli/cli-script.c:
	* cli/cli-logging.c:
	* cli/cli-interp.c:
	* cli/cli-dump.h:
	* cli/cli-dump.c:
	* cli/cli-decode.h:
	* cli/cli-decode.c:
	* cli/cli-cmds.h:
	* cli/cli-cmds.c: Add (c) after Copyright.  Update FSF address.
@
text
@d4 2
a5 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005 Free
   Software Foundation, Inc.
d244 3
a246 3
  /* We will be returning_to_top_level() at this point, so we want to
     reset our depth. */
  (*depth) = 0;
d269 1
a269 1
  old_chain = make_cleanup (do_restore_user_call_depth, &user_call_depth);
d273 1
a273 1
  old_chain = make_cleanup (do_restore_instream_cleanup, instream);
d275 5
a290 2

  user_call_depth--;
d926 2
a927 1
  if (deprecated_readline_begin_hook)
d929 10
a938 7
      /* Note - intentional to merge messages with no newline */
      (*deprecated_readline_begin_hook) ("%s  %s\n", prompt_arg, END_MESSAGE);
    }
  else if (from_tty && input_from_terminal_p ())
    {
      printf_unfiltered ("%s\n%s\n", prompt_arg, END_MESSAGE);
      gdb_flush (gdb_stdout);
d999 1
a999 1
  if (deprecated_readline_end_hook)
@


1.31
log
@2005-11-15  Andrew Stubbs  <andrew.stubbs@@st.com>

	* cli/cli-script.c: Include gdb_assert.h.
	(locate_arg): Detect $argc.
	(insert_args): Substitute $argc.
	* Makefile.in (cli-script.o): Add dependency on gdb_assert.h.

doc/
	* gdb.texinfo (User-defined commands): Add $argc. Add missing 'end'.
	Change @@var{$arg0 to @@code{$arg0.
@
text
@d3 1
a3 1
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.30
log
@2005-04-26  Andrew Cagney  <cagney@@gnu.org>

	* remote.c (remote_open_1): Move "ex"'s declaration to where it is
	used.
	(remote_get_thread_local_address): Use throw_error, include a
	printed string.
	* linux-thread-db.c (thread_db_get_thread_local_address): Ditto.
	* dwarf2loc.c (dwarf_expr_tls_address): Ditto.
	* cli/cli-script.c (script_from_file): Mark up throw_error message.
	* linespec.c (symtab_from_filename, decode_variable): Ditto.
@
text
@d36 1
d576 2
a577 1
      if (strncmp (p, "$arg", 4) == 0 && isdigit (p[4]))
d601 6
a606 1
      if (i >= user_args->count)
d611 4
a614 1
      len += user_args->a[i].len;
a637 1
      i = p[4] - '0';
d639 12
a650 2
      len = user_args->a[i].len;
      if (len)
d652 7
a658 2
	  memcpy (new_line, user_args->a[i].arg, len);
	  new_line += len;
@


1.30.6.1
log
@2005-11-16  Andrew Stubbs  <andrew.stubbs@@st.com>

	* NEWS (6.4): Mention $argc.
	* cli/cli-script.c: Include gdb_assert.h.
	(locate_arg): Detect $argc.
	(insert_args): Substitute $argc.
	* Makefile.in (cli-script.o): Add dependency on gdb_assert.h.

doc/
	* gdb.texinfo (User-defined commands): Add $argc. Add missing 'end'.
	Change @@var{$arg0 to @@code{$arg0.
@
text
@a35 1
#include "gdb_assert.h"
d575 1
a575 2
      if (strncmp (p, "$arg", 4) == 0
	  && (isdigit (p[4]) || p[4] == 'c'))
d599 1
a599 6
      if (p[4] == 'c')
	{
	  /* $argc.  Number will be <=10.  */
	  len += user_args->count == 10 ? 2 : 1;
	}
      else if (i >= user_args->count)
d604 1
a604 4
      else
	{
	  len += user_args->a[i].len;
	}
d628 1
d630 2
a631 12
      if (p[4] == 'c')
	{
	  gdb_assert (user_args->count >= 0 && user_args->count <= 10);
	  if (user_args->count == 10)
	    {
	      *(new_line++) = '1';
	      *(new_line++) = '0';
	    }
	  else
	    *(new_line++) = user_args->count + '0';
	}
      else
d633 2
a634 7
	  i = p[4] - '0';
	  len = user_args->a[i].len;
	  if (len)
	  {
	    memcpy (new_line, user_args->a[i].arg, len);
	    new_line += len;
	  }
@


1.30.2.1
log
@2005-06-03  Michael Snyder  <msnyder@@redhat.com>

	* defs.h (noisy_command, quiet_command): New command types
	to be interpreted by cli-script.c.  Turn on and off 'from_tty'
	output.
	* cli/cli-script.c (noisy_command, quiet_command): Interpret
	new pseudo-commands for user-defined scripts (which otherwise
	will frequently produce no output).
@
text
@a247 1
static int from_tty;
a273 1
  from_tty = 0;
a306 10
    case noisy_control:
      from_tty = 1;
      ret = simple_control;
      break;

    case quiet_control:
      from_tty = 0;
      ret = simple_control;
      break;

d313 1
a313 1
      execute_command (new_line, from_tty);
a741 23
  /* Is this a request for noisy output (a la "from_tty")?  */
  else if (p1 - p == 5 && !strncmp (p, "noisy", 5))
    {
      *command = (struct command_line *)
	xmalloc (sizeof (struct command_line));
      (*command)->next = NULL;
      (*command)->line = NULL;
      (*command)->control_type = noisy_control;
      (*command)->body_count = 0;
      (*command)->body_list = NULL;
    }
  /* Is this a request to stop noisy output (a la "from_tty")?  */
  else if ((p1 - p == 5 && !strncmp (p, "quiet", 5)) ||
	   (p1 - p == 6 && !strncmp (p, "silent", 6)))
    {
      *command = (struct command_line *)
	xmalloc (sizeof (struct command_line));
      (*command)->next = NULL;
      (*command)->line = NULL;
      (*command)->control_type = quiet_control;
      (*command)->body_count = 0;
      (*command)->body_list = NULL;
    }
a812 10
      else if (val == noisy_command)
	{
	  ret = noisy_control;
	  break;
	}
      else if (val == quiet_command)
	{
	  ret = quiet_control;
	  break;
	}
a919 10
      else if (val == noisy_command)
	{
	  ret = noisy_control;
	  break;
	}
      else if (val == quiet_command)
	{
	  ret = quiet_control;
	  break;
	}
@


1.29
log
@2005-04-26  Andrew Cagney  <cagney@@gnu.org>

	Rename 'struct exception' to 'struct gdb_exception'.
	* wrapper.c: Update.
	* varobj.c: Update.
	* tui/tui-interp.c: Update.
	* remote.c: Update.
	* mi/mi-main.c: Update.
	* mi/mi-interp.c: Update.
	* linux-thread-db.c: Update.
	* interps.h: Update.
	* interps.c: Update.
	* exceptions.h: Update.
	* exceptions.c: Update.
	* dwarf2loc.c: Update.
	* cli/cli-interp.c: Update.
	* cli/cli-script.c: Update.
	* breakpoint.c: Update.
@
text
@d1289 2
a1290 1
	throw_error (e.error, "%s:%d: Error in sourced command file:\n%s",
@


1.28
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d1277 1
a1277 1
    struct exception e;
@


1.27
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d479 1
a479 1
		    "arg_cleanup called with no user args.\n");
d1049 1
a1049 1
    error_no_arg ("name of command to define");
d1100 1
a1100 1
	q = query ("Redefine command \"%s\"? ", c->name);
d1102 1
a1102 1
	q = query ("Really redefine built-in command \"%s\"? ", c->name);
d1173 1
a1173 1
	  internal_error (__FILE__, __LINE__, "bad switch");
d1263 1
a1263 3
    {
      internal_error (__FILE__, __LINE__, "called with NULL file pointer!");
    }
d1292 1
a1292 1
	internal_error (__FILE__, __LINE__, "bad reason");
@


1.26
log
@2005-01-17  Andrew Cagney  <cagney@@gnu.org>

	* top.h (source_error, source_pre_error): Delete declaration.
	* cli/cli-script.c (source_error_allocated, source_error): Delete.
	(script_from_file, source_cleanup_lines): Do not manipulate
	source_error_allocated, error_pre_print and source_error.
	(struct source_cleanup_lines_args): Delete fields old_pre_error,
	and old_error_pre_print.
	* top.c (source_error_allocated, source_error)
	(source_pre_error): Delete.
	(command_line_input): Do not set error_pre_print.
	* event-top.c (command_line_handler): Do not set error_pre_print.
@
text
@d76 1
a76 1
    error ("if/while commands require arguments.\n");
d108 1
a108 1
      warning ("error reading in control structure\n");
d266 1
a266 1
    error ("Max user call depth exceeded -- command aborted\n");
d279 1
a279 1
	  warning ("Error in control structure.\n");
d427 1
a427 1
      warning ("Invalid control type in command structure.");
d515 1
a515 1
	  error ("user defined function may only have %d arguments.\n",
d601 1
a601 1
	  error ("Missing argument %d in user function.\n", i);
d682 1
a682 1
    error ("Control nesting too deep!\n");
d797 1
a797 4
    {
      error ("Recursed on a simple control type\n");
      return invalid_control;
    }
d800 1
a800 4
    {
      error ("Allocated body is smaller than this command type needs\n");
      return invalid_control;
    }
d1055 1
a1055 1
	error ("Junk in argument list: \"%s\"", p);
d1104 1
a1104 1
	error ("Command \"%s\" not redefined.", c->name);
d1131 1
a1131 1
	  warning ("Your new `%s' command does not hook any existing command.",
d1134 1
a1134 1
	    error ("Not confirmed.");
d1191 1
a1191 1
    error ("Command \"%s\" is built-in.", comname);
@


1.25
log
@2005-01-16  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-script.c: Include "exceptions.h".
	(struct wrapped_read_command_file_args): Define.
	(wrapped_read_command_file): New function.
	(script_from_file): Replace direct call to read_command_file by
	one wrapped by an exception handler.
	* exceptions.c (throw_it): Free the old message after creating the
	new.
	* Makefile.in: Update dependencies.

Index: testsuite/ChangeLog
2005-01-16  Andrew Cagney  <cagney@@gnu.org>

	* gdb.base/source.exp: Delete KFAIL gdb/1846, simplify.
@
text
@a50 3
/* Source command state variable. */
static int source_error_allocated;

a1229 2
  char *old_pre_error;
  char *old_error_pre_print;
a1238 2
  source_pre_error = p->old_pre_error;
  error_pre_print = p->old_error_pre_print;
a1276 2
  old_lines.old_pre_error = source_pre_error;
  old_lines.old_error_pre_print = error_pre_print;
a1279 3
  source_pre_error = error_pre_print == NULL ? "" : error_pre_print;
  source_pre_error = savestring (source_pre_error, strlen (source_pre_error));
  make_cleanup (xfree, source_pre_error);
a1283 12
  needed_length = strlen (source_file_name) + strlen (source_pre_error) + 80;
  if (source_error_allocated < needed_length)
    {
      source_error_allocated *= 2;
      if (source_error_allocated < needed_length)
	source_error_allocated = needed_length;
      if (source_error == NULL)
	source_error = xmalloc (source_error_allocated);
      else
	source_error = xrealloc (source_error, source_error_allocated);
    }

d1297 2
a1298 4
	throw_error (e.error, "%s%s:%d: Error in sourced command file:\n%s",
		     source_pre_error, source_file_name,
		     source_line_number,
		     e.message);
@


1.24
log
@[gdb/ChangeLog]
2004-09-10  Jason Molenda  (jmolenda@@apple.com)

        * cli/cli-script.c (read_next_line): Accept zero or more whitespace
        chars after 'if' or 'while' commands in user-defined commands.

[gdb/testsuite/ChangeLog]
2004-09-10  Jason Molenda  (jmolenda@@apple.com)

        * gdb.base/define.exp: Two new tests to verify zero space chars
        after 'if' and 'while' commands in a user-defined command is correctly
        parsed.

Approved here:
http://sources.redhat.com/ml/gdb-patches/2004-09/msg00160.html
http://sources.redhat.com/ml/gdb-patches/2004-09/msg00157.html
@
text
@d4 2
a5 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004 Free Software
   Foundation, Inc.
d31 1
a31 1

d1254 12
d1308 21
a1328 1
  read_command_file (stream);
@


1.23
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software
d730 7
a736 1
    *command = build_command_line (while_control, p + 6);
d738 7
a744 1
    *command = build_command_line (if_control, p + 3);
@


1.22
log
@2004-02-25  Andrew Cagney  <cagney@@redhat.com>

	PR cli/1566.  Problem found, and fix suggested by David Allan.
	* cli/cli-script.c (execute_control_command): Unconditionally
	install a cleanup.  Default "ret" to "invalid_control".  Use
	"break" instead of "return" to escape from the switch.
@
text
@d688 1
a688 1
  if (instream == stdin || (instream == 0 && readline_hook != NULL))
d896 1
a896 1
  if (readline_begin_hook)
d899 1
a899 1
      (*readline_begin_hook) ("%s  %s\n", prompt_arg, END_MESSAGE);
d965 1
a965 1
  if (readline_end_hook)
d967 1
a967 1
      (*readline_end_hook) ();
@


1.21
log
@* breakpoint.c (bpstat_do_actions): To ensure that
clear_proceed_status doesn't free the command tree we're
evaluating out from under us, zero the bpstat's pointer to it, and
take care of freeing it ourselves.
* cli/cli-script.c (make_cleanup_free_command_lines): Make this
function externally visible.
* cli/cli-script.h (make_cleanup_free_command_lines): New
declaration.
@
text
@d297 1
a297 1
  struct cleanup *old_chain = 0;
d304 4
d314 2
a315 2
	return invalid_control;
      old_chain = make_cleanup (free_current_contents, &new_line);
d332 2
a333 2
	  return invalid_control;
	old_chain = make_cleanup (free_current_contents, &new_line);
d392 2
a393 2
	  return invalid_control;
	old_chain = make_cleanup (free_current_contents, &new_line);
d431 1
a431 1
      return invalid_control;
d434 1
a434 2
  if (old_chain)
    do_cleanups (old_chain);
@


1.21.6.1
log
@Merge mainline to intercu branch.
@
text
@d297 1
a297 1
  struct cleanup *old_chain = make_cleanup (null_cleanup, 0);
a303 4
  /* Start by assuming failure, if a problem is detected, the code
     below will simply "break" out of the switch.  */
  ret = invalid_control;

d310 2
a311 2
	break;
      make_cleanup (free_current_contents, &new_line);
d328 2
a329 2
	  break;
	make_cleanup (free_current_contents, &new_line);
d388 2
a389 2
	  break;
	make_cleanup (free_current_contents, &new_line);
d427 1
a427 1
      break;
d430 2
a431 1
  do_cleanups (old_chain);
@


1.21.6.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d4 1
a4 1
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004 Free Software
d688 1
a688 1
  if (instream == stdin || (instream == 0 && deprecated_readline_hook != NULL))
d730 1
a730 7
    {
      char *first_arg;
      first_arg = p + 5;
      while (first_arg < p1 && isspace (*first_arg))
        first_arg++;
      *command = build_command_line (while_control, first_arg);
    }
d732 1
a732 7
    {
      char *first_arg;
      first_arg = p + 2;
      while (first_arg < p1 && isspace (*first_arg))
        first_arg++;
      *command = build_command_line (if_control, first_arg);
    }
d896 1
a896 1
  if (deprecated_readline_begin_hook)
d899 1
a899 1
      (*deprecated_readline_begin_hook) ("%s  %s\n", prompt_arg, END_MESSAGE);
d965 1
a965 1
  if (deprecated_readline_end_hook)
d967 1
a967 1
      (*deprecated_readline_end_hook) ();
@


1.20
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@a38 3
static struct cleanup *
	make_cleanup_free_command_lines (struct command_line **arg);

d1001 1
a1001 1
static struct cleanup *
@


1.19
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* cli/cli-script.c: Remove "register" attributes.
	* config/pa/tm-hppa.h: Ditto.
	* cli/cli-decode.c: Ditto.
	* cli/cli-cmds.c: Ditto.
@
text
@a1235 1
/* ARGSUSED */
@


1.18
log
@2003-08-04  Andrew Cagney  <cagney@@redhat.com>

	* monitor.h (monitor_dump_reg_block): Remove ATTR_FORMAT.
	* cli/cli-script.c (define_command): Call query directly, instead
	of passing it a buffer.
	* ocd.c (ocd_error): Pass error a constant format string.
	* remote-mips.c (mips_error): Use fputs_filtered.
@
text
@d258 1
a258 1
  register struct command_line *cmdlines;
d977 2
a978 2
  register struct command_line *l = *lptr;
  register struct command_line *next;
d1043 1
a1043 1
  register char *p;
d1073 2
a1074 2
  register struct command_line *cmds;
  register struct cmd_list_element *c, *newc, *oldc, *hookc = 0;
d1179 1
a1179 1
  register struct cmd_list_element *c;
d1197 2
a1198 2
    register struct command_line *cl1;
    register int len = 0;
d1293 1
a1293 1
  register struct command_line *cmdlines;
@


1.18.4.1
log
@merge mainline changes into branch
@
text
@d39 3
d258 1
a258 1
  struct command_line *cmdlines;
d300 1
a300 1
  struct cleanup *old_chain = make_cleanup (null_cleanup, 0);
a306 4
  /* Start by assuming failure, if a problem is detected, the code
     below will simply "break" out of the switch.  */
  ret = invalid_control;

d313 2
a314 2
	break;
      make_cleanup (free_current_contents, &new_line);
d331 2
a332 2
	  break;
	make_cleanup (free_current_contents, &new_line);
d391 2
a392 2
	  break;
	make_cleanup (free_current_contents, &new_line);
d430 1
a430 1
      break;
d433 2
a434 1
  do_cleanups (old_chain);
d977 2
a978 2
  struct command_line *l = *lptr;
  struct command_line *next;
d1004 1
a1004 1
struct cleanup *
d1043 1
a1043 1
  char *p;
d1073 2
a1074 2
  struct command_line *cmds;
  struct cmd_list_element *c, *newc, *oldc, *hookc = 0;
d1179 1
a1179 1
  struct cmd_list_element *c;
d1197 2
a1198 2
    struct command_line *cl1;
    int len = 0;
d1236 1
d1293 1
a1293 1
  struct command_line *cmdlines;
@


1.17
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* acinclude.m4 (gcc_AC_CHECK_DECL, (gcc_AC_CHECK_DECL): Stolen
	from GCC's acinclude.m4.
	* configure.in: Check for getopt's delcaration.
	* aclocal.m4, config.in, configure: Re-generate.
	* main.c (error_init): Delete declaration.
	* defs.h (error_init): Declare.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Make static.
	(rs6000_convert_from_func_ptr_addr): Make static.
	(_initialize_rs6000_tdep): Add declaration.
	* cli/cli-cmds.c (dont_repeat): Delete declaration.
	(show_commands, set_verbose, show_history): Delete declaration.
	* top.h (set_verbose): Add declaration.
	(show_history, set_history, show_commands): Add declaration.
	(do_restore_instream_cleanup): Add declaration.
	* objc-lang.c (specialcmp): Make static.
	(print_object_command): Make static.
	(find_objc_msgsend): Make static.
	(find_objc_msgcall_submethod_helper): Make static.
	(find_objc_msgcall_submethod): Make static.
	(_initialize_objc_language): Add declaration.
	(find_implementation_from_class): Make static.
	(find_implementation): Make static.
	* objc-exp.y (yylex): Delete lookup_struct_typedef declaration.
	* objc-lang.h (lookup_struct_typedef): Add declaration.
	* cli/cli-interp.c (_initialize_cli_interp): Add declaration.
	* cli/cli-script.c (clear_hook_in_cleanup): Make static.
	(do_restore_user_call_depth): Make static.
	(do_restore_instream_cleanup): Delete declaration.
	(dont_repeat): Delete declaration.
	* cli/cli-decode.c (add_abbrev_cmd): Delete function.
	* cli/cli-dump.c (_initialize_cli_dump): Add declaration.
	* reggroups.c (_initialize_reggroup): Add declaration.
	* cp-support.c (_initialize_cp_support): Add declaration.
	* cp-abi.c (_initialize_cp_abi): Add declaration.
	* hpacc-abi.c (_initialize_hpacc_abi): Add declaration.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Make static.
	(_initialize_gnu_v3_abi): Add declaration.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Make static.
	(_initialize_gnu_v2_abi): Add declaration.
	* frame-base.c (_initialize_frame_base): Add declaration.
	* doublest.c (floatformat_from_length): Make static.
	* frame-unwind.c (_initialize_frame_unwind): Add declaration.
	* frame.c (create_sentinel_frame): Make static.
	(_initialize_frame): Add declaration.
	* top.c (do_catch_errors): Make static.
	(gdb_rl_operate_and_get_next_completion): Make static.
	* typeprint.c: Include "typeprint.h".
	* sentinel-frame.c (sentinel_frame_prev_register): Make static.
	(sentinel_frame_this_id): Make static.
	* p-valprint.c (_initialize_pascal_valprint): Add declaration.
	* ui-out.c (make_cleanup_ui_out_begin_end): Delete function.
	* dwarf2-frame.c (dwarf2_frame_cache): Make static.
	* p-exp.y (push_current_type, pop_current_type): ISO C declaration.
	* dwarf2expr.h (dwarf_expr_context): ISO C declaration.
	* maint.c (maintenance_print_architecture): Make static.
	* signals/signals.c (_initialize_signals): Add declaration.
	* std-regs.c (_initialize_frame_reg): Add declaration.
	* jv-exp.y (push_variable): ISO C definition.
	(push_qualified_expression_name): Ditto.
	* memattr.c (_initialize_mem): Add declaration.
	* remote.c (remote_check_watch_resources): Make static.
	(remote_stopped_by_watchpoint): Make static.
	(remote_stopped_data_address): Make static.
	* d10v-tdep.c (nr_dmap_regs): Make static.
	(a0_regnum): Make static.
	(d10v_frame_unwind_cache): Make static.
	(d10v_frame_p): Make static.
	* osabi.c (show_osabi): Make static.
	(_initialize_gdb_osabi): Add extern declaration.
	* gdbtypes.c (make_qualified_type): Make static.
	(safe_parse_type): Make static.
	* macrocmd.c (_initialize_macrocmd): Add extern declaration.
	* macrotab.c (macro_bcache_free): Make static.
	* interps.c (interp_set_quiet): Make static.
	(interpreter_exec_cmd): Make static.
	* stack.h (select_frame_command): New file.
	* stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete function.
	(select_frame_command): Make global.
	* infcall.c: Include "infcall.h".
	* linespec.c: Include "linespec.h".
	* symfile.c (sections_overlap): Make static.
	* cp-support.h (cp_initialize_namespace): ISO C declaration.
	* charset.c (_initialize_charset): Add missing prototype.
	* regcache.c (init_legacy_regcache_descr): Make static.
	(do_regcache_xfree): Make static.
	(regcache_xfer_part): Make static.
	(_initialize_regcache): Add missing prototype.
	* breakpoint.c (parse_breakpoint_sals): Make static.
	(breakpoint_sals_to_pc): Make static.
	* interps.h (clear_interpreter_hooks): ISO C declaration.
	* Makefile.in (stack_h): Define.
	(stack.o, typeprint.o, mi-main.o): Update dependencies.
	(mi-cmd-stack.o, infcall.o, linespec.o): Update dependencies.

Index: mi/ChangeLog
2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-parse.c (_initialize_mi_parse): Delete function.
	* mi-main.c: Include "mi-main.h".
	* mi-interp.c (_initialize_mi_interp): Add declaration.
	* mi-cmd-stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete extern declaration.
	(mi_cmd_stack_select_frame): Replace select_frame_command_wrapper
	with select_frame_command.
@
text
@d1095 1
d1097 1
a1097 1
	tem = "Redefine command \"%s\"? ";
d1099 2
a1100 2
	tem = "Really redefine built-in command \"%s\"? ";
      if (!query (tem, c->name))
@


1.16
log
@2003-02-06  Andrew Cagney  <ac131313@@redhat.com>

	* linux-proc.c: Include "gdb_stat.h" instead of <sys/stat.h>.
	* cp-valprint.c (cp_print_value_fields): Eliminate STREQN.
	* jv-typeprint.c (java_type_print_base): Ditto.
	* typeprint.c (typedef_print): Eliminate STREQ.
	* cli/cli-script.c (define_command, define_command): Ditto.
	* main.c (captured_main): Ditto.
	* values.c (lookup_internalvar): Ditto.
	* utils.c (safe_strerror, parse_escape): Eliminate assignment
	within `if' conditional.
	* linespec.c (decode_line_2): Ditto.
	* cli/cli-dump.c (bfd_openr_with_cleanup): Ditto.
	(bfd_openw_with_cleanup): Ditto.

Index: mi/ChangeLog
2003-02-06  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Include "gdb_stat.h" instead of <sys/stat.h>.
@
text
@a36 6
/* From gdb/top.c */

extern void dont_repeat (void);

extern void do_restore_instream_cleanup (void *stream);

d213 1
a213 1
void
d245 1
a245 1
void
@


1.16.24.1
log
@Snap const char * mess.
@
text
@d55 1
a55 1
static void validate_comname (const char *);
d83 1
a83 1
build_command_line (enum command_control_type type, const char *args)
d449 1
a449 1
while_command (const char *arg, int from_tty)
d467 1
a467 1
if_command (const char *arg, int from_tty)
d1047 1
a1047 1
validate_comname (const char *comname)
d1049 1
a1049 1
  const char *p;
d1065 1
a1065 1
user_defined_command (const char *ignore, int from_tty)
d1070 1
a1070 1
define_command (const char *comname, int from_tty)
d1181 1
a1181 1
document_command (const char *comname, int from_tty)
d1185 1
a1185 1
  const char *tem = comname;
d1226 2
a1227 2
  const char *old_pre_error;
  const char *old_error_pre_print;
@


1.15
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@d1096 1
a1096 1
  if (c && !STREQ (comname, c->name))
d1129 1
a1129 1
      if (hookc && !STREQ (comname + hook_name_size, hookc->name))
@


1.14
log
@2002-08-26  Joel Brobecker  <brobecker@@gnat.com>

	* cli/cli-script.c (copy_command_lines): New function.
	* defs.h (copy_command_lines): Export.
	* testsuite/gdb.base/commands.exp: New tests for commands
	attached to a temporary breakpoint, and for commands that
	delete the breakpoint they are attached to.

2002-08-26  Michael Snyder  <msnyder@@redhat.com>

	* breakpoint.c (bpstat_stop_status): Instead of copying the
	pointer to the breakpoint commands struct, make a new copy
	of the struct and point to that.
	(bpstat_clear): Free the commands struct.
	(bpstat_clear_actions): Free the commands struct.
	(bpstat_do_actions): Free the command actions.  Also execute
	the local cleanups, instead of deleting them.
	(delete_breakpoint): Leave the commands field of the bpstat
	chain alone -- it will be freed later.
@
text
@d1231 1
a1231 1
source_cleanup_lines (PTR args)
@


1.14.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d37 6
d219 1
a219 1
static void
d251 1
a251 1
static void
d264 1
a264 1
  struct command_line *cmdlines;
d983 2
a984 2
  struct command_line *l = *lptr;
  struct command_line *next;
d1049 1
a1049 1
  char *p;
d1079 2
a1080 2
  struct command_line *cmds;
  struct cmd_list_element *c, *newc, *oldc, *hookc = 0;
d1096 1
a1096 1
  if (c && strcmp (comname, c->name) != 0)
a1100 1
      int q;
d1102 1
a1102 1
	q = query ("Redefine command \"%s\"? ", c->name);
d1104 2
a1105 2
	q = query ("Really redefine built-in command \"%s\"? ", c->name);
      if (!q)
d1129 1
a1129 1
      if (hookc && strcmp (comname + hook_name_size, hookc->name) != 0)
d1184 1
a1184 1
  struct cmd_list_element *c;
d1202 2
a1203 2
    struct command_line *cl1;
    int len = 0;
d1231 1
a1231 1
source_cleanup_lines (void *args)
d1241 1
d1298 1
a1298 1
  struct command_line *cmdlines;
@


1.14.6.2
log
@Merge from mainline.
@
text
@d39 3
d1004 1
a1004 1
struct cleanup *
@


1.14.4.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d1096 1
a1096 1
  if (c && strcmp (comname, c->name) != 0)
d1129 1
a1129 1
      if (hookc && strcmp (comname + hook_name_size, hookc->name) != 0)
d1231 1
a1231 1
source_cleanup_lines (void *args)
@


1.14.4.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d37 6
d219 1
a219 1
static void
d251 1
a251 1
static void
@


1.14.4.3
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a1094 1
      int q;
d1096 1
a1096 1
	q = query ("Redefine command \"%s\"? ", c->name);
d1098 2
a1099 2
	q = query ("Really redefine built-in command \"%s\"? ", c->name);
      if (!q)
@


1.14.4.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d258 1
a258 1
  struct command_line *cmdlines;
d977 2
a978 2
  struct command_line *l = *lptr;
  struct command_line *next;
d1043 1
a1043 1
  char *p;
d1073 2
a1074 2
  struct command_line *cmds;
  struct cmd_list_element *c, *newc, *oldc, *hookc = 0;
d1179 1
a1179 1
  struct cmd_list_element *c;
d1197 2
a1198 2
    struct command_line *cl1;
    int len = 0;
d1236 1
d1293 1
a1293 1
  struct command_line *cmdlines;
@


1.14.4.5
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d39 3
d1004 1
a1004 1
struct cleanup *
@


1.13
log
@2002-07-30  Andrew Cagney  <ac131313@@redhat.com>

* symtab.h: Replace #include "gdb_obstack.h" with opaque
declaration.
* cli/cli-cmds.c, cli/cli-script.c: Include "gdb_string.h".
* gnu-v3-abi.c, arc-tdep.c, cli/cli-decode.c: Ditto.
* avr-tdep.c, mon960-rom.c, i960-tdep.c: Ditto.
* arch-utils.c, cli/cli-setshow.c: Unconditionally include
"gdb_string.h".
* Makefile.in (cli-script.o, cli-cmds.o): Update dependencies.
(gnu-v3-abi.o, cli-setshow.o, i960-tdep.o): Ditto.
(cli-decode.o, mi-cmd-var.o, mi-cmd-disas.o): Ditto.
(avr-tdep.o, mon960-rom.o): Ditto.
(aout_stabs_gnu_h): Define.
(symtab_h): Remove $(gdb_obstack_h).
@
text
@d1015 30
@


1.12
log
@2002-04-12  Don Howard  <dhoward@@redhat.com>

	* cli/cli-cmds.c (init_cli_cmds): Add new user settable value:
	max_user_call_depth.
	(init_cmd_lists): Initialize the new value;
	* cli/cli-script.c (execute_user_command): Limit the call depth of
	user defined commands.  This avoids a core-dump when user commands
	are infinitly recursive.
@
text
@d30 1
@


1.12.6.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a29 1
#include "gdb_string.h"
@


1.12.6.2
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a1014 30

struct command_line *
copy_command_lines (struct command_line *cmds)
{
  struct command_line *result = NULL;

  if (cmds)
    {
      result = (struct command_line *) xmalloc (sizeof (struct command_line));

      result->next = copy_command_lines (cmds->next);
      result->line = xstrdup (cmds->line);
      result->control_type = cmds->control_type;
      result->body_count = cmds->body_count;
      if (cmds->body_count > 0)
        {
          int i;

          result->body_list = (struct command_line **)
            xmalloc (sizeof (struct command_line *) * cmds->body_count);

          for (i = 0; i < cmds->body_count; i++)
            result->body_list[i] = copy_command_lines (cmds->body_list[i]);
        }
      else
        result->body_list = NULL;
    }

  return result;
}
@


1.11
log
@* command.h: (execute_cmd_post_hook): Declare.
(execute_cmd_pre_hook): Declare.
* cli/cli-script.c (clear_hook_in_cleanup): New function.
(execute_cmd_post_hook, execute_cmd_pre_hook): New
functions. Execute pre/post hook while ensuring that afterwords
hook_in is cleared.
* top.c (execute_command): Use execute_cmd_post_hook, and
execute_cmd_pre_hook to execute pre/post commands.
* infrun.c (normal_stop): Pass stop_command and not pre_hook to
hook_stop_stub.
(hook_stop_stub): Call execute_cmd_pre_hook.
@
text
@d250 9
d266 2
d276 5
d296 2
@


1.10
log
@Remove else clause to #if UI_OUT.
@
text
@d216 33
@


1.9
log
@* cli/cli-script.c (execute_control_command): Replace value_ptr
with a struct value pointer.
* ch-lang.c (evaluate_subexp_chill): Ditto.
* printcmd.c (printf_command): Ditto.
* tracepoint.c (set_traceframe_context): Ditto.
(encode_actions): Ditto.
* eval.c (evaluate_subexp_standard): Ditto.
@
text
@d2 4
a5 2
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
a28 1
#ifdef UI_OUT
a29 1
#endif
d129 1
a129 1
#ifdef UI_OUT
a214 80
#else
void
print_command_line (struct command_line *cmd, unsigned int depth,
		    struct ui_file *stream)
{
  unsigned int i;

  if (depth)
    {
      for (i = 0; i < depth; i++)
	fputs_filtered ("  ", stream);
    }

  /* A simple command, print it and return.  */
  if (cmd->control_type == simple_control)
    {
      fputs_filtered (cmd->line, stream);
      fputs_filtered ("\n", stream);
      return;
    }

  /* loop_continue to jump to the start of a while loop, print it
     and return. */
  if (cmd->control_type == continue_control)
    {
      fputs_filtered ("loop_continue\n", stream);
      return;
    }

  /* loop_break to break out of a while loop, print it and return.  */
  if (cmd->control_type == break_control)
    {
      fputs_filtered ("loop_break\n", stream);
      return;
    }

  /* A while command.  Recursively print its subcommands before returning.  */
  if (cmd->control_type == while_control)
    {
      struct command_line *list;
      fputs_filtered ("while ", stream);
      fputs_filtered (cmd->line, stream);
      fputs_filtered ("\n", stream);
      list = *cmd->body_list;
      while (list)
	{
	  print_command_line (list, depth + 1, stream);
	  list = list->next;
	}
    }

  /* An if command.  Recursively print both arms before returning.  */
  if (cmd->control_type == if_control)
    {
      fputs_filtered ("if ", stream);
      fputs_filtered (cmd->line, stream);
      fputs_filtered ("\n", stream);
      /* The true arm. */
      print_command_line (cmd->body_list[0], depth + 1, stream);

      /* Show the false arm if it exists.  */
      if (cmd->body_count == 2)
	{
	  if (depth)
	    {
	      for (i = 0; i < depth; i++)
		fputs_filtered ("  ", stream);
	    }
	  fputs_filtered ("else\n", stream);
	  print_command_line (cmd->body_list[1], depth + 1, stream);
	}
      if (depth)
	{
	  for (i = 0; i < depth; i++)
	    fputs_filtered ("  ", stream);
	}
      fputs_filtered ("end\n", stream);
    }
}
#endif
a1224 1
#ifdef UI_OUT
a1226 8
#else
  while (cmdlines)
    {
      print_command_line (cmdlines, 4, stream);
      cmdlines = cmdlines->next;
    }
  fputs_filtered ("\n", stream);
#endif
@


1.8
log
@gdb/ChangeLog
2001-12-13  Jackie Smith Cashion  <jsmith@@redhat.com>

	* cli/cli-script.c (print_command_lines): Remove extra
	"if", "else", "while", and "end" from show user output.

testsuite/ChangeLog
2001-12-13  Jackie Smith Cashion  <jsmith@@redhat.com>

        * gdb.base/commands.exp (user_defined_command_test): Make "show user"
        test expect string more specific.
@
text
@d335 2
a336 2
  value_ptr val;
  value_ptr val_mark;
@


1.7
log
@2001-06-17  Fernando Nasser  <fnasser@@redhat.com>

	From 2001-06-15  Eirik Fuller  <eirik@@hackrat.com>
	* cli/cli-script.c (free_command_lines): Reset list pointer.
@
text
@a173 1
	  ui_out_text (uiout, "while ");
a176 1
	  ui_out_field_string (uiout, NULL, "end");
d179 2
a180 1
	  ui_out_text (uiout, "end\n");
a187 1
	  ui_out_text (uiout, "if ");
d199 1
a199 1
	      ui_out_text (uiout, "else\n");
a202 1
	  ui_out_field_string (uiout, NULL, "end");
d205 2
a206 1
	  ui_out_text (uiout, "end\n");
@


1.6
log
@2001-03-13  Fernando Nasser  <fnasser@@redhat.com>

	From Steven Johnson <sjohnson@@neurizon.net>
	* cli/cli-script.c (define_command): Fix setting of post hooks.
@
text
@d1031 1
@


1.5
log
@Update/correct copyright notices.
@
text
@d1169 2
a1170 2
          hookc->hook_pre  = newc;  /* Target gets hooked.  */
          newc->hookee_pre = hookc; /* We are marked as hooking target cmd. */
@


1.4
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d2 2
a3 1
   Copyright 1986-2000, 2001 Free Software Foundation, Inc.
@


1.3
log
@* cli/cli-script.c (define_command): Check for a bad hook value in
switch statement.
@
text
@d2 1
a2 1
   Copyright 1986-2000 Free Software Foundation, Inc.
d516 2
a517 1
    internal_error ("Internal error, arg_cleanup called with no user args.\n");
d1173 1
a1173 1
	  internal_error ("%s:%d: bad switch", __FILE__, __LINE__);
d1257 1
a1257 1
      internal_error ("called with NULL file pointer!");
@


1.2
log
@Replace free() with xfree().
@
text
@d1172 1
@


1.1
log
@2000-12-01  Fernando Nasser  <fnasser@@redhat.com>

        * cli/cli-decode.c: New file. Handle lists of commands, their decoding
        and documentation.
        (add_cmd, deprecate_cmd, add_abbrev_cmd, add_alias_cmd, add_prefix_cmd,
        add_abbrev_prefix_cmd, not_just_help_class_command, empty_sfunc,
        add_set_cmd, add_set_enum_cmd, add_set_auto_boolean_cmd,
        add_show_from_set, delete_cmd, apropos_cmd, help_cmd, help_list,
        help_all, print_doc_line, help_cmd_list, find_cmd, lookup_cmd_1,
        undef_cmd_error, lookup_cmd, deprecated_cmd_warning,
        lookup_cmd_composition, complete_on_cmdlist, complete_on_enum):
        Moved here from command.c.
        (add_info, add_info_alias, add_com, add_com_alias): Moved here from
        top.c.
        * cli/cli-decode.h: Definitions/declarations for the above.
        * cli/cli-cmds.c: New file.  GDB CLI commands.
        (error_no_arg, info_command, show_command, help_command, show_version,
        quit_command, pwd_command, cd_command, echo_command, shell_escape,
        make_command, show_user, set_debug, show_debug, init_cmd_lists):
        Moved here from top.c.
        (apropos_command): Moved here from command.c.
        (complete_command, source_command): Moved here (part) from top.c.
        (is_complete_command): New function. Checks if a command is the
        "complete" command.
        (init_cli_cmds): New function. Add commands to the CLI (from code
        previously in top.c.
        * cli/cli-cmds.h: Definitions/declarations for the above.
        * cli/cli-script.c: New file. GDB CLI command scripting.
        (build_command_line, get_command_line, print_command_lines,
        print_command_line, execute_user_command, execute_control_command,
        while_command, if_command, arg_cleanup, setup_user_args, locate_arg,
        insert_args, realloc_body_list, read_next_line,
        recurse_read_control_structure, read_command_lines, free_command_lines,
        do_free_command_lines_cleanup, make_cleanup_free_command_lines,
        validate_comname, user_defined_command, define_command,
        document_command, source_cleanup_lines, do_fclose_cleanup,
        show_user_1): Moved here from top.c.
        (script_from_file): New function. Implements execution of a script
        contained in a file (part of code for the source_command() that used
        to exist in top.c).
        * cli/cli-script.h: Definitions/declarations for the above.
        * cli/cli-setshow.c: New file. Handle set and show GDB CLI commands.
        (parse_auto_binary_operation, parse_binary_operation,
        do_setshow_command, cmd_show_list): Moved here from command.c.
        * cli/cli-setshow.h: Definitions/declarations for the above.
        * top.c: Remove all CLI code, except the command loop.
        (gdb_init): Call init_cli_cmds().
        * command.c: Remove obsolete file.
        * command.h: Mark as DEPRECATED.
        * gdbcmd.h: Ditto.
        * call-cmds.h: Ditto.
        * Makefile.in (SFILES): Remove command.c.
        (COMMON_OBS): Remove command.o.
        (command.o): Remove obsolete target.
        (cli_decode_h, cli_cmds_h, cli_script_h, cli_setshow_h): New macros.
        Refer to CLI header files.
        (cli-decode.o, cli-cmds.o, cli-setshow.o, cli-script.o): New targets.
        (SUBDIR_CLI_OBS, SUBDIR_CLI_SRCS, SUBDIR_CLI_DEPS, SUBDIR_CLI_INITS,
        SUBDIR_CLI_LDFLAGS, SUBDIR_CLI_CFLAGS, SUBDIR_CLI_ALL, SUBDIR_CLI_CLEAN,
        SUBDIR_CLI_INSTALL, SUBDIR_CLI_UNINSTALL): New macros for new cli
        subdirectory.
        * configure.in (enable_gdbcli): New option. Include the CLI in the
        executable (cannot be disabled yet).
        (CONFIG_OBS, CONFIG_DEPS, CONFIG_SRCS, CONFIG_INITS, ENABLE_CFLAGS,
        CONFIG_ALL, CONFIG_CLEAN, CONFIG_INSTALL, CONFIG_UNINSTALL): Add
        the corresponding SUBDIR_CLI_* macros if CLI requested.
        * configure: Regenerate.
@
text
@d519 1
a519 1
  free (oargs);
d704 1
a704 1
  free (command->body_list);
d1025 2
a1026 2
      free (l->line);
      free ((PTR) l);
d1195 1
a1195 1
    free (c->doc);
d1269 1
a1269 1
  make_cleanup (free, source_pre_error);
@

