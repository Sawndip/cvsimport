head	1.120;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.116
	gdb_7_6-2013-04-26-release:1.116
	gdb_7_6-branch:1.116.0.2
	gdb_7_6-2013-03-12-branchpoint:1.116
	gdb_7_5_1-2012-11-29-release:1.106.2.1
	gdb_7_5-2012-08-17-release:1.106
	gdb_7_5-branch:1.106.0.2
	gdb_7_5-2012-07-18-branchpoint:1.106
	gdb_7_4_1-2012-04-26-release:1.99.2.1
	gdb_7_4-2012-01-24-release:1.99.2.1
	gdb_7_4-branch:1.99.0.2
	gdb_7_4-2011-12-13-branchpoint:1.99
	gdb_7_3_1-2011-09-04-release:1.93
	gdb_7_3-2011-07-26-release:1.93
	gdb_7_3-branch:1.93.0.2
	gdb_7_3-2011-04-01-branchpoint:1.93
	gdb_7_2-2010-09-02-release:1.89
	gdb_7_2-branch:1.89.0.2
	gdb_7_2-2010-07-07-branchpoint:1.89
	gdb_7_1-2010-03-18-release:1.86
	gdb_7_1-branch:1.86.0.2
	gdb_7_1-2010-02-18-branchpoint:1.86
	gdb_7_0_1-2009-12-22-release:1.84
	gdb_7_0-2009-10-06-release:1.84
	gdb_7_0-branch:1.84.0.2
	gdb_7_0-2009-09-16-branchpoint:1.84
	arc-sim-20090309:1.63
	msnyder-checkpoint-072509-branch:1.82.0.2
	msnyder-checkpoint-072509-branchpoint:1.82
	arc-insight_6_8-branch:1.63.0.6
	arc-insight_6_8-branchpoint:1.63
	insight_6_8-branch:1.63.0.4
	insight_6_8-branchpoint:1.63
	reverse-20081226-branch:1.73.0.2
	reverse-20081226-branchpoint:1.73
	multiprocess-20081120-branch:1.71.0.4
	multiprocess-20081120-branchpoint:1.71
	reverse-20080930-branch:1.71.0.2
	reverse-20080930-branchpoint:1.71
	reverse-20080717-branch:1.67.0.2
	reverse-20080717-branchpoint:1.67
	msnyder-reverse-20080609-branch:1.65.0.2
	msnyder-reverse-20080609-branchpoint:1.65
	drow-reverse-20070409-branch:1.60.0.2
	drow-reverse-20070409-branchpoint:1.60
	gdb_6_8-2008-03-27-release:1.63
	gdb_6_8-branch:1.63.0.2
	gdb_6_8-2008-02-26-branchpoint:1.63
	gdb_6_7_1-2007-10-29-release:1.62
	gdb_6_7-2007-10-10-release:1.62
	gdb_6_7-branch:1.62.0.2
	gdb_6_7-2007-09-07-branchpoint:1.62
	insight_6_6-20070208-release:1.59
	gdb_6_6-2006-12-18-release:1.59
	gdb_6_6-branch:1.59.0.2
	gdb_6_6-2006-11-15-branchpoint:1.59
	insight_6_5-20061003-release:1.58
	gdb-csl-symbian-6_4_50_20060226-12:1.58
	gdb-csl-sourcerygxx-3_4_4-25:1.55
	nickrob-async-20060828-mergepoint:1.58
	gdb-csl-symbian-6_4_50_20060226-11:1.58
	gdb-csl-sourcerygxx-4_1-17:1.58
	gdb-csl-20060226-branch-local-2:1.58
	gdb-csl-sourcerygxx-4_1-14:1.58
	gdb-csl-sourcerygxx-4_1-13:1.58
	gdb-csl-sourcerygxx-4_1-12:1.58
	gdb-csl-sourcerygxx-3_4_4-21:1.58
	gdb_6_5-20060621-release:1.58
	gdb-csl-sourcerygxx-4_1-9:1.58
	gdb-csl-sourcerygxx-4_1-8:1.58
	gdb-csl-sourcerygxx-4_1-7:1.58
	gdb-csl-arm-2006q1-6:1.58
	gdb-csl-sourcerygxx-4_1-6:1.58
	gdb-csl-symbian-6_4_50_20060226-10:1.58
	gdb-csl-symbian-6_4_50_20060226-9:1.58
	gdb-csl-symbian-6_4_50_20060226-8:1.58
	gdb-csl-coldfire-4_1-11:1.58
	gdb-csl-sourcerygxx-3_4_4-19:1.58
	gdb-csl-coldfire-4_1-10:1.58
	gdb_6_5-branch:1.58.0.16
	gdb_6_5-2006-05-14-branchpoint:1.58
	gdb-csl-sourcerygxx-4_1-5:1.58
	nickrob-async-20060513-branch:1.58.0.14
	nickrob-async-20060513-branchpoint:1.58
	gdb-csl-sourcerygxx-4_1-4:1.58
	msnyder-reverse-20060502-branch:1.58.0.12
	msnyder-reverse-20060502-branchpoint:1.58
	gdb-csl-morpho-4_1-4:1.58
	gdb-csl-sourcerygxx-3_4_4-17:1.58
	readline_5_1-import-branch:1.58.0.10
	readline_5_1-import-branchpoint:1.58
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.58
	gdb-csl-symbian-20060226-branch:1.58.0.8
	gdb-csl-symbian-20060226-branchpoint:1.58
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.58
	msnyder-reverse-20060331-branch:1.58.0.6
	msnyder-reverse-20060331-branchpoint:1.58
	gdb-csl-available-20060303-branch:1.58.0.4
	gdb-csl-available-20060303-branchpoint:1.58
	gdb-csl-20060226-branch:1.58.0.2
	gdb-csl-20060226-branchpoint:1.58
	gdb_6_4-20051202-release:1.55
	msnyder-fork-checkpoint-branch:1.55.0.10
	msnyder-fork-checkpoint-branchpoint:1.55
	gdb-csl-gxxpro-6_3-branch:1.55.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.55
	gdb_6_4-branch:1.55.0.6
	gdb_6_4-2005-11-01-branchpoint:1.55
	gdb-csl-arm-20051020-branch:1.55.0.4
	gdb-csl-arm-20051020-branchpoint:1.55
	msnyder-tracepoint-checkpoint-branch:1.55.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.55
	gdb-csl-arm-20050325-2005-q1b:1.54
	gdb-csl-arm-20050325-2005-q1a:1.54
	csl-arm-20050325-branch:1.54.0.2
	csl-arm-20050325-branchpoint:1.54
	gdb-post-i18n-errorwarning-20050211:1.46
	gdb-pre-i18n-errorwarning-20050211:1.45
	gdb_6_3-20041109-release:1.41
	gdb_6_3-branch:1.41.0.2
	gdb_6_3-20041019-branchpoint:1.41
	drow_intercu-merge-20040921:1.41
	drow_intercu-merge-20040915:1.41
	jimb-gdb_6_2-e500-branch:1.37.0.6
	jimb-gdb_6_2-e500-branchpoint:1.37
	gdb_6_2-20040730-release:1.37
	gdb_6_2-branch:1.37.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.37
	gdb_6_1_1-20040616-release:1.35
	gdb_6_1-2004-04-05-release:1.35
	drow_intercu-merge-20040402:1.35
	drow_intercu-merge-20040327:1.35
	ezannoni_pie-20040323-branch:1.35.0.10
	ezannoni_pie-20040323-branchpoint:1.35
	cagney_tramp-20040321-mergepoint:1.35
	cagney_tramp-20040309-branch:1.35.0.8
	cagney_tramp-20040309-branchpoint:1.35
	gdb_6_1-branch:1.35.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.35
	drow_intercu-20040221-branch:1.35.0.4
	drow_intercu-20040221-branchpoint:1.35
	cagney_bfdfile-20040213-branch:1.35.0.2
	cagney_bfdfile-20040213-branchpoint:1.35
	drow-cplus-merge-20040208:1.34
	carlton_dictionary-20040126-merge:1.34
	cagney_bigcore-20040122-branch:1.34.0.2
	cagney_bigcore-20040122-branchpoint:1.34
	drow-cplus-merge-20040113:1.34
	drow-cplus-merge-20031224:1.34
	drow-cplus-merge-20031220:1.34
	carlton_dictionary-20031215-merge:1.34
	drow-cplus-merge-20031214:1.34
	carlton-dictionary-20031111-merge:1.34
	gdb_6_0-2003-10-04-release:1.31.4.1
	kettenis_sparc-20030918-branch:1.32.0.6
	kettenis_sparc-20030918-branchpoint:1.32
	carlton_dictionary-20030917-merge:1.32
	ezannoni_pie-20030916-branchpoint:1.32
	ezannoni_pie-20030916-branch:1.32.0.4
	cagney_x86i386-20030821-branch:1.32.0.2
	cagney_x86i386-20030821-branchpoint:1.32
	carlton_dictionary-20030805-merge:1.31
	carlton_dictionary-20030627-merge:1.31
	gdb_6_0-branch:1.31.0.4
	gdb_6_0-2003-06-23-branchpoint:1.31
	jimb-ppc64-linux-20030613-branch:1.31.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.31
	cagney_convert-20030606-branch:1.30.0.26
	cagney_convert-20030606-branchpoint:1.30
	cagney_writestrings-20030508-branch:1.30.0.24
	cagney_writestrings-20030508-branchpoint:1.30
	jimb-ppc64-linux-20030528-branch:1.30.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.30
	carlton_dictionary-20030523-merge:1.30
	cagney_fileio-20030521-branch:1.30.0.20
	cagney_fileio-20030521-branchpoint:1.30
	kettenis_i386newframe-20030517-mergepoint:1.30
	jimb-ppc64-linux-20030509-branch:1.30.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.30
	kettenis_i386newframe-20030504-mergepoint:1.30
	carlton_dictionary-20030430-merge:1.30
	kettenis_i386newframe-20030419-branch:1.30.0.16
	kettenis_i386newframe-20030419-branchpoint:1.30
	carlton_dictionary-20030416-merge:1.30
	cagney_frameaddr-20030409-mergepoint:1.30
	kettenis_i386newframe-20030406-branch:1.30.0.14
	kettenis_i386newframe-20030406-branchpoint:1.30
	cagney_frameaddr-20030403-branchpoint:1.30
	cagney_frameaddr-20030403-branch:1.30.0.12
	cagney_framebase-20030330-mergepoint:1.30
	cagney_framebase-20030326-branch:1.30.0.10
	cagney_framebase-20030326-branchpoint:1.30
	cagney_lazyid-20030317-branch:1.30.0.8
	cagney_lazyid-20030317-branchpoint:1.30
	kettenis-i386newframe-20030316-mergepoint:1.30
	offbyone-20030313-branch:1.30.0.6
	offbyone-20030313-branchpoint:1.30
	kettenis-i386newframe-20030308-branch:1.30.0.4
	kettenis-i386newframe-20030308-branchpoint:1.30
	carlton_dictionary-20030305-merge:1.30
	cagney_offbyone-20030303-branch:1.30.0.2
	cagney_offbyone-20030303-branchpoint:1.30
	carlton_dictionary-20030207-merge:1.28
	interps-20030203-mergepoint:1.28
	interps-20030202-branch:1.28.0.14
	interps-20030202-branchpoint:1.28
	cagney-unwind-20030108-branch:1.28.0.12
	cagney-unwind-20030108-branchpoint:1.28
	carlton_dictionary-20021223-merge:1.28
	gdb_5_3-2002-12-12-release:1.28
	carlton_dictionary-20021115-merge:1.28
	kseitz_interps-20021105-merge:1.28
	kseitz_interps-20021103-merge:1.28
	drow-cplus-merge-20021020:1.28
	drow-cplus-merge-20021025:1.28
	carlton_dictionary-20021025-merge:1.28
	carlton_dictionary-20021011-merge:1.28
	drow-cplus-branch:1.28.0.10
	drow-cplus-branchpoint:1.28
	kseitz_interps-20020930-merge:1.28
	carlton_dictionary-20020927-merge:1.28
	carlton_dictionary-branch:1.28.0.8
	carlton_dictionary-20020920-branchpoint:1.28
	gdb_5_3-branch:1.28.0.6
	gdb_5_3-2002-09-04-branchpoint:1.28
	kseitz_interps-20020829-merge:1.28
	cagney_sysregs-20020825-branch:1.28.0.4
	cagney_sysregs-20020825-branchpoint:1.28
	readline_4_3-import-branch:1.28.0.2
	readline_4_3-import-branchpoint:1.28
	gdb_5_2_1-2002-07-23-release:1.14
	kseitz_interps-20020528-branch:1.20.0.6
	kseitz_interps-20020528-branchpoint:1.20
	cagney_regbuf-20020515-branch:1.20.0.4
	cagney_regbuf-20020515-branchpoint:1.20
	jimb-macro-020506-branch:1.20.0.2
	jimb-macro-020506-branchpoint:1.20
	gdb_5_2-2002-04-29-release:1.14
	gdb_5_2-branch:1.14.0.2
	gdb_5_2-2002-03-03-branchpoint:1.14
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	cygnus_cvs_20020108_pre:1.10
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.8
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.6
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.4
	gdb_5_1-2001-07-29-branchpoint:1.7
	dberlin-typesystem-branch:1.7.0.2
	dberlin-typesystem-branchpoint:1.7
	gdb-post-ptid_t-2001-05-03:1.7
	gdb-pre-ptid_t-2001-05-03:1.7
	insight-precleanup-2001-01-01:1.5;
locks; strict;
comment	@ * @;


1.120
date	2013.10.01.23.52.45;	author devans;	state Exp;
branches;
next	1.119;

1.119
date	2013.04.24.14.29.17;	author mbilal;	state Exp;
branches;
next	1.118;

1.118
date	2013.04.10.15.11.12;	author palves;	state Exp;
branches;
next	1.117;

1.117
date	2013.03.13.18.34.54;	author palves;	state Exp;
branches;
next	1.116;

1.116
date	2013.03.05.14.23.23;	author qiyao;	state Exp;
branches;
next	1.115;

1.115
date	2013.02.14.03.39.42;	author qiyao;	state Exp;
branches;
next	1.114;

1.114
date	2013.02.12.19.03.55;	author palves;	state Exp;
branches;
next	1.113;

1.113
date	2013.01.14.21.03.54;	author tromey;	state Exp;
branches;
next	1.112;

1.112
date	2013.01.01.06.32.54;	author brobecke;	state Exp;
branches;
next	1.111;

1.111
date	2012.12.05.23.23.22;	author muller;	state Exp;
branches;
next	1.110;

1.110
date	2012.11.20.21.02.35;	author vapier;	state Exp;
branches;
next	1.109;

1.109
date	2012.09.17.08.42.10;	author qiyao;	state Exp;
branches;
next	1.108;

1.108
date	2012.08.27.16.47.15;	author jkratoch;	state Exp;
branches;
next	1.107;

1.107
date	2012.08.09.12.53.43;	author qiyao;	state Exp;
branches;
next	1.106;

1.106
date	2012.06.13.15.47.16;	author tromey;	state Exp;
branches
	1.106.2.1;
next	1.105;

1.105
date	2012.06.13.15.41.23;	author tromey;	state Exp;
branches;
next	1.104;

1.104
date	2012.04.25.21.56.01;	author devans;	state Exp;
branches;
next	1.103;

1.103
date	2012.04.25.20.55.47;	author devans;	state Exp;
branches;
next	1.102;

1.102
date	2012.04.25.18.58.57;	author devans;	state Exp;
branches;
next	1.101;

1.101
date	2012.01.28.18.08.21;	author jkratoch;	state Exp;
branches;
next	1.100;

1.100
date	2012.01.04.08.17.17;	author brobecke;	state Exp;
branches;
next	1.99;

1.99
date	2011.11.15.05.06.33;	author devans;	state Exp;
branches
	1.99.2.1;
next	1.98;

1.98
date	2011.10.09.22.21.42;	author devans;	state Exp;
branches;
next	1.97;

1.97
date	2011.09.08.17.20.43;	author devans;	state Exp;
branches;
next	1.96;

1.96
date	2011.08.04.19.10.13;	author palves;	state Exp;
branches;
next	1.95;

1.95
date	2011.07.05.04.34.57;	author bauermann;	state Exp;
branches;
next	1.94;

1.94
date	2011.04.19.18.04.08;	author tromey;	state Exp;
branches;
next	1.93;

1.93
date	2011.03.12.22.59.24;	author msnyder;	state Exp;
branches;
next	1.92;

1.92
date	2011.01.06.00.57.02;	author msnyder;	state Exp;
branches;
next	1.91;

1.91
date	2011.01.01.15.33.20;	author brobecke;	state Exp;
branches;
next	1.90;

1.90
date	2010.12.29.02.11.04;	author msnyder;	state Exp;
branches;
next	1.89;

1.89
date	2010.05.17.19.28.12;	author msnyder;	state Exp;
branches;
next	1.88;

1.88
date	2010.05.05.21.32.56;	author msnyder;	state Exp;
branches;
next	1.87;

1.87
date	2010.04.26.18.37.13;	author tromey;	state Exp;
branches;
next	1.86;

1.86
date	2010.01.01.07.31.46;	author brobecke;	state Exp;
branches;
next	1.85;

1.85
date	2009.10.06.22.47.20;	author muller;	state Exp;
branches;
next	1.84;

1.84
date	2009.08.13.14.56.19;	author palves;	state Exp;
branches;
next	1.83;

1.83
date	2009.08.07.20.44.15;	author tromey;	state Exp;
branches;
next	1.82;

1.82
date	2009.06.19.15.49.35;	author tromey;	state Exp;
branches;
next	1.81;

1.81
date	2009.06.19.15.47.09;	author tromey;	state Exp;
branches;
next	1.80;

1.80
date	2009.06.08.15.45.39;	author muller;	state Exp;
branches;
next	1.79;

1.79
date	2009.05.12.16.51.13;	author palves;	state Exp;
branches;
next	1.78;

1.78
date	2009.03.25.21.42.34;	author palves;	state Exp;
branches;
next	1.77;

1.77
date	2009.02.06.21.33.59;	author bauermann;	state Exp;
branches;
next	1.76;

1.76
date	2009.01.23.18.47.45;	author palves;	state Exp;
branches;
next	1.75;

1.75
date	2009.01.14.20.40.07;	author drow;	state Exp;
branches;
next	1.74;

1.74
date	2009.01.03.05.57.54;	author brobecke;	state Exp;
branches;
next	1.73;

1.73
date	2008.12.12.17.58.48;	author tromey;	state Exp;
branches;
next	1.72;

1.72
date	2008.12.10.01.05.15;	author tromey;	state Exp;
branches;
next	1.71;

1.71
date	2008.08.30.01.54.11;	author devans;	state Exp;
branches;
next	1.70;

1.70
date	2008.08.29.23.52.34;	author devans;	state Exp;
branches;
next	1.69;

1.69
date	2008.07.30.01.10.17;	author tromey;	state Exp;
branches;
next	1.68;

1.68
date	2008.07.26.10.23.56;	author vprus;	state Exp;
branches;
next	1.67;

1.67
date	2008.07.11.11.07.39;	author palves;	state Exp;
branches;
next	1.66;

1.66
date	2008.07.04.22.30.19;	author muller;	state Exp;
branches;
next	1.65;

1.65
date	2008.05.03.23.24.17;	author bauermann;	state Exp;
branches;
next	1.64;

1.64
date	2008.04.17.00.25.01;	author tromey;	state Exp;
branches;
next	1.63;

1.63
date	2008.01.01.22.53.14;	author drow;	state Exp;
branches;
next	1.62;

1.62
date	2007.08.23.18.08.47;	author brobecke;	state Exp;
branches;
next	1.61;

1.61
date	2007.08.01.20.26.31;	author msnyder;	state Exp;
branches;
next	1.60;

1.60
date	2007.01.09.17.59.00;	author drow;	state Exp;
branches;
next	1.59;

1.59
date	2006.10.31.11.45.41;	author vprus;	state Exp;
branches;
next	1.58;

1.58
date	2005.12.17.22.40.17;	author eliz;	state Exp;
branches;
next	1.57;

1.57
date	2005.12.06.22.13.14;	author msnyder;	state Exp;
branches;
next	1.56;

1.56
date	2005.11.25.11.45.49;	author ams;	state Exp;
branches;
next	1.55;

1.55
date	2005.05.26.20.49.02;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2005.02.21.17.14.03;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2005.02.21.07.15.48;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2005.02.21.03.25.56;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2005.02.18.20.57.16;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2005.02.17.17.11.04;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2005.02.17.15.00.36;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2005.02.17.13.49.56;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2005.02.16.17.20.59;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2005.02.11.04.06.10;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2005.02.10.17.32.53;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2005.02.09.23.15.01;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2005.01.05.15.43.50;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2004.10.30.17.10.14;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2004.07.30.17.55.47;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2004.07.28.19.42.01;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2004.07.28.17.26.27;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2004.07.26.14.53.06;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.07.21.36.34;	author jsm;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.07.13.35.52;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2004.02.10.19.08.15;	author cagney;	state Exp;
branches
	1.35.4.1;
next	1.34;

1.34
date	2003.11.08.00.13.03;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2003.09.20.17.50.28;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2003.08.09.15.10.09;	author cagney;	state Exp;
branches
	1.32.4.1;
next	1.31;

1.31
date	2003.06.08.18.27.14;	author cagney;	state Exp;
branches
	1.31.4.1;
next	1.30;

1.30
date	2003.02.14.20.36.58;	author ezannoni;	state Exp;
branches
	1.30.24.1;
next	1.29;

1.29
date	2003.02.14.13.58.06;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.30.13.45.14;	author cagney;	state Exp;
branches
	1.28.8.1
	1.28.10.1;
next	1.27;

1.27
date	2002.07.03.17.35.21;	author hunt;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.26.20.58.17;	author tromey;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.25.05.39.18;	author tromey;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.15.22.05.33;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.15.21.07.59;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.15.19.54.26;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.15.18.45.32;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.12.22.44.18;	author msnyder;	state Exp;
branches
	1.20.4.1
	1.20.6.1;
next	1.19;

1.19
date	2002.03.24.00.24.35;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.23.17.38.13;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.19.02.19.17;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.18.02.26.32;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.06.06.28.35;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.23.20.12.13;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.05.04.37.23;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.02.00.56.36;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.17.22.15.18;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.20.18.35.30;	author law;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.30.16.16.16;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.01.21.38.05;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.06.08.21.19;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.19.08.01.47;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.01.01.51;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.06.23.53.03;	author fnasser;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.06.23.27.41;	author fnasser;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.06.23.12.12;	author fnasser;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.01.18.01.38;	author fnasser;	state Exp;
branches;
next	;

1.106.2.1
date	2012.08.27.16.47.32;	author jkratoch;	state Exp;
branches;
next	;

1.99.2.1
date	2012.01.06.04.43.32;	author brobecke;	state Exp;
branches;
next	;

1.35.4.1
date	2004.09.16.17.01.27;	author drow;	state Exp;
branches;
next	;

1.32.4.1
date	2004.03.23.20.41.49;	author ezannoni;	state Exp;
branches;
next	;

1.31.4.1
date	2003.08.09.15.10.35;	author cagney;	state Exp;
branches;
next	;

1.30.24.1
date	2003.06.03.20.54.41;	author cagney;	state Exp;
branches;
next	;

1.28.8.1
date	2003.03.06.00.56.34;	author carlton;	state Exp;
branches;
next	1.28.8.2;

1.28.8.2
date	2003.06.27.21.50.14;	author carlton;	state Exp;
branches;
next	1.28.8.3;

1.28.8.3
date	2003.09.17.21.28.37;	author carlton;	state Exp;
branches;
next	1.28.8.4;

1.28.8.4
date	2003.11.11.23.51.02;	author carlton;	state Exp;
branches;
next	;

1.28.10.1
date	2003.12.14.20.27.34;	author drow;	state Exp;
branches;
next	;

1.20.4.1
date	2002.06.21.16.19.37;	author cagney;	state Exp;
branches;
next	1.20.4.2;

1.20.4.2
date	2002.06.25.20.02.43;	author cagney;	state Exp;
branches;
next	1.20.4.3;

1.20.4.3
date	2002.06.28.23.23.25;	author cagney;	state Exp;
branches;
next	1.20.4.4;

1.20.4.4
date	2002.07.03.18.43.59;	author cagney;	state Exp;
branches;
next	;

1.20.6.1
date	2002.06.20.01.33.41;	author kseitz;	state Exp;
branches;
next	1.20.6.2;

1.20.6.2
date	2002.07.22.21.47.05;	author kseitz;	state Exp;
branches;
next	1.20.6.3;

1.20.6.3
date	2002.08.09.18.34.28;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.120
log
@	* cli/cli-decode.c: Remove unnecessary inclusion of tui/tui.h.
@
text
@/* Handle lists of commands, their decoding and documentation, for GDB.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "symtab.h"
#include <ctype.h>
#include "gdb_regex.h"
#include "gdb_string.h"
#include "completer.h"
#include "ui-out.h"
#include "cli/cli-cmds.h"
#include "cli/cli-decode.h"
#include "gdb_assert.h"

/* Prototypes for local functions.  */

static void undef_cmd_error (const char *, const char *);

static struct cmd_list_element *delete_cmd (const char *name,
					    struct cmd_list_element **list,
					    struct cmd_list_element **prehook,
					    struct cmd_list_element **prehookee,
					    struct cmd_list_element **posthook,
					    struct cmd_list_element **posthookee);

static struct cmd_list_element *find_cmd (const char *command,
					  int len,
					  struct cmd_list_element *clist,
					  int ignore_help_classes,
					  int *nfound);

static void help_all (struct ui_file *stream);

/* Look up a command whose 'prefixlist' is KEY.  Return the command if found,
   otherwise return NULL.  */

static struct cmd_list_element *
lookup_cmd_for_prefixlist (struct cmd_list_element **key,
			   struct cmd_list_element *list)
{
  struct cmd_list_element *p = NULL;

  for (p = list; p != NULL; p = p->next)
    {
      struct cmd_list_element *q;

      if (p->prefixlist == NULL)
	continue;
      else if (p->prefixlist == key)
	return p;

      q = lookup_cmd_for_prefixlist (key, *(p->prefixlist));
      if (q != NULL)
	return q;
    }

  return NULL;
}

static void
set_cmd_prefix (struct cmd_list_element *c, struct cmd_list_element **list)
{
  struct cmd_list_element *p;

  /* Check to see if *LIST contains any element other than C.  */
  for (p = *list; p != NULL; p = p->next)
    if (p != c)
      break;

  if (p == NULL)
    {
      /* *SET_LIST only contains SET.  */
      p = lookup_cmd_for_prefixlist (list, setlist);

      c->prefix = p ? (p->cmd_pointer ? p->cmd_pointer : p) : p;
    }
  else
    c->prefix = p->prefix;
}

static void
print_help_for_command (struct cmd_list_element *c, char *prefix, int recurse,
			struct ui_file *stream);


/* Set the callback function for the specified command.  For each both
   the commands callback and func() are set.  The latter set to a
   bounce function (unless cfunc / sfunc is NULL that is).  */

static void
do_cfunc (struct cmd_list_element *c, char *args, int from_tty)
{
  c->function.cfunc (args, from_tty); /* Ok.  */
}

void
set_cmd_cfunc (struct cmd_list_element *cmd, cmd_cfunc_ftype *cfunc)
{
  if (cfunc == NULL)
    cmd->func = NULL;
  else
    cmd->func = do_cfunc;
  cmd->function.cfunc = cfunc; /* Ok.  */
}

static void
do_sfunc (struct cmd_list_element *c, char *args, int from_tty)
{
  c->function.sfunc (args, from_tty, c); /* Ok.  */
}

void
set_cmd_sfunc (struct cmd_list_element *cmd, cmd_sfunc_ftype *sfunc)
{
  if (sfunc == NULL)
    cmd->func = NULL;
  else
    cmd->func = do_sfunc;
  cmd->function.sfunc = sfunc; /* Ok.  */
}

int
cmd_cfunc_eq (struct cmd_list_element *cmd,
	      void (*cfunc) (char *args, int from_tty))
{
  return cmd->func == do_cfunc && cmd->function.cfunc == cfunc;
}

void
set_cmd_context (struct cmd_list_element *cmd, void *context)
{
  cmd->context = context;
}

void *
get_cmd_context (struct cmd_list_element *cmd)
{
  return cmd->context;
}

enum cmd_types
cmd_type (struct cmd_list_element *cmd)
{
  return cmd->type;
}

void
set_cmd_completer (struct cmd_list_element *cmd, completer_ftype *completer)
{
  cmd->completer = completer; /* Ok.  */
}

/* Add element named NAME.
   Space for NAME and DOC must be allocated by the caller.
   CLASS is the top level category into which commands are broken down
   for "help" purposes.
   FUN should be the function to execute the command;
   it will get a character string as argument, with leading
   and trailing blanks already eliminated.

   DOC is a documentation string for the command.
   Its first line should be a complete sentence.
   It should start with ? for a command that is an abbreviation
   or with * for a command that most users don't need to know about.

   Add this command to command list *LIST.

   Returns a pointer to the added command (not necessarily the head 
   of *LIST).  */

struct cmd_list_element *
add_cmd (const char *name, enum command_class class, void (*fun) (char *, int),
	 char *doc, struct cmd_list_element **list)
{
  struct cmd_list_element *c
    = (struct cmd_list_element *) xmalloc (sizeof (struct cmd_list_element));
  struct cmd_list_element *p, *iter;

  /* Turn each alias of the old command into an alias of the new
     command.  */
  c->aliases = delete_cmd (name, list, &c->hook_pre, &c->hookee_pre,
			   &c->hook_post, &c->hookee_post);
  for (iter = c->aliases; iter; iter = iter->alias_chain)
    iter->cmd_pointer = c;
  if (c->hook_pre)
    c->hook_pre->hookee_pre = c;
  if (c->hookee_pre)
    c->hookee_pre->hook_pre = c;
  if (c->hook_post)
    c->hook_post->hookee_post = c;
  if (c->hookee_post)
    c->hookee_post->hook_post = c;

  if (*list == NULL || strcmp ((*list)->name, name) >= 0)
    {
      c->next = *list;
      *list = c;
    }
  else
    {
      p = *list;
      while (p->next && strcmp (p->next->name, name) <= 0)
	{
	  p = p->next;
	}
      c->next = p->next;
      p->next = c;
    }

  c->name = name;
  c->class = class;
  set_cmd_cfunc (c, fun);
  set_cmd_context (c, NULL);
  c->doc = doc;
  c->flags = 0;
  c->replacement = NULL;
  c->pre_show_hook = NULL;
  c->hook_in = 0;
  c->prefixlist = NULL;
  c->prefixname = NULL;
  c->allow_unknown = 0;
  c->prefix = NULL;
  c->abbrev_flag = 0;
  set_cmd_completer (c, make_symbol_completion_list_fn);
  c->destroyer = NULL;
  c->type = not_set_cmd;
  c->var = NULL;
  c->var_type = var_boolean;
  c->enums = NULL;
  c->user_commands = NULL;
  c->cmd_pointer = NULL;
  c->alias_chain = NULL;

  return c;
}

/* Deprecates a command CMD.
   REPLACEMENT is the name of the command which should be used in
   place of this command, or NULL if no such command exists.

   This function does not check to see if command REPLACEMENT exists
   since gdb may not have gotten around to adding REPLACEMENT when
   this function is called.

   Returns a pointer to the deprecated command.  */

struct cmd_list_element *
deprecate_cmd (struct cmd_list_element *cmd, char *replacement)
{
  cmd->flags |= (CMD_DEPRECATED | DEPRECATED_WARN_USER);

  if (replacement != NULL)
    cmd->replacement = replacement;
  else
    cmd->replacement = NULL;

  return cmd;
}

struct cmd_list_element *
add_alias_cmd (const char *name, const char *oldname, enum command_class class,
	       int abbrev_flag, struct cmd_list_element **list)
{
  const char *tmp;
  struct cmd_list_element *old;
  struct cmd_list_element *c;

  tmp = oldname;
  old = lookup_cmd (&tmp, *list, "", 1, 1);

  if (old == 0)
    {
      struct cmd_list_element *prehook, *prehookee, *posthook, *posthookee;
      struct cmd_list_element *aliases = delete_cmd (name, list,
						     &prehook, &prehookee,
						     &posthook, &posthookee);

      /* If this happens, it means a programmer error somewhere.  */
      gdb_assert (!aliases && !prehook && !prehookee
		  && !posthook && ! posthookee);
      return 0;
    }

  c = add_cmd (name, class, NULL, old->doc, list);

  /* If OLD->DOC can be freed, we should make another copy.  */
  if ((old->flags & DOC_ALLOCATED) != 0)
    {
      c->doc = xstrdup (old->doc);
      c->flags |= DOC_ALLOCATED;
    }
  /* NOTE: Both FUNC and all the FUNCTIONs need to be copied.  */
  c->func = old->func;
  c->function = old->function;
  c->prefixlist = old->prefixlist;
  c->prefixname = old->prefixname;
  c->allow_unknown = old->allow_unknown;
  c->abbrev_flag = abbrev_flag;
  c->cmd_pointer = old;
  c->alias_chain = old->aliases;
  old->aliases = c;

  set_cmd_prefix (c, list);
  return c;
}

/* Like add_cmd but adds an element for a command prefix: a name that
   should be followed by a subcommand to be looked up in another
   command list.  PREFIXLIST should be the address of the variable
   containing that list.  */

struct cmd_list_element *
add_prefix_cmd (const char *name, enum command_class class,
		void (*fun) (char *, int),
		char *doc, struct cmd_list_element **prefixlist,
		char *prefixname, int allow_unknown,
		struct cmd_list_element **list)
{
  struct cmd_list_element *c = add_cmd (name, class, fun, doc, list);
  struct cmd_list_element *p;

  c->prefixlist = prefixlist;
  c->prefixname = prefixname;
  c->allow_unknown = allow_unknown;

  if (list == &cmdlist)
    c->prefix = NULL;
  else
    set_cmd_prefix (c, list);

  /* Update the field 'prefix' of each cmd_list_element in *PREFIXLIST.  */
  for (p = *prefixlist; p != NULL; p = p->next)
    p->prefix = c;

  return c;
}

/* Like add_prefix_cmd but sets the abbrev_flag on the new command.  */

struct cmd_list_element *
add_abbrev_prefix_cmd (const char *name, enum command_class class,
		       void (*fun) (char *, int), char *doc,
		       struct cmd_list_element **prefixlist, char *prefixname,
		       int allow_unknown, struct cmd_list_element **list)
{
  struct cmd_list_element *c = add_cmd (name, class, fun, doc, list);

  c->prefixlist = prefixlist;
  c->prefixname = prefixname;
  c->allow_unknown = allow_unknown;
  c->abbrev_flag = 1;
  return c;
}

/* This is an empty "cfunc".  */
void
not_just_help_class_command (char *args, int from_tty)
{
}

/* This is an empty "sfunc".  */
static void empty_sfunc (char *, int, struct cmd_list_element *);

static void
empty_sfunc (char *args, int from_tty, struct cmd_list_element *c)
{
}

/* Add element named NAME to command list LIST (the list for set/show
   or some sublist thereof).
   TYPE is set_cmd or show_cmd.
   CLASS is as in add_cmd.
   VAR_TYPE is the kind of thing we are setting.
   VAR is address of the variable being controlled by this command.
   DOC is the documentation string.  */

static struct cmd_list_element *
add_set_or_show_cmd (const char *name,
		     enum cmd_types type,
		     enum command_class class,
		     var_types var_type,
		     void *var,
		     char *doc,
		     struct cmd_list_element **list)
{
  struct cmd_list_element *c = add_cmd (name, class, NULL, doc, list);

  gdb_assert (type == set_cmd || type == show_cmd);
  c->type = type;
  c->var_type = var_type;
  c->var = var;
  /* This needs to be something besides NULL so that this isn't
     treated as a help class.  */
  set_cmd_sfunc (c, empty_sfunc);
  return c;
}

/* Add element named NAME to both the command SET_LIST and SHOW_LIST.
   CLASS is as in add_cmd.  VAR_TYPE is the kind of thing we are
   setting.  VAR is address of the variable being controlled by this
   command.  SET_FUNC and SHOW_FUNC are the callback functions (if
   non-NULL).  SET_DOC, SHOW_DOC and HELP_DOC are the documentation
   strings.  PRINT the format string to print the value.  SET_RESULT
   and SHOW_RESULT, if not NULL, are set to the resulting command
   structures.  */

static void
add_setshow_cmd_full (const char *name,
		      enum command_class class,
		      var_types var_type, void *var,
		      const char *set_doc, const char *show_doc,
		      const char *help_doc,
		      cmd_sfunc_ftype *set_func,
		      show_value_ftype *show_func,
		      struct cmd_list_element **set_list,
		      struct cmd_list_element **show_list,
		      struct cmd_list_element **set_result,
		      struct cmd_list_element **show_result)
{
  struct cmd_list_element *set;
  struct cmd_list_element *show;
  char *full_set_doc;
  char *full_show_doc;

  if (help_doc != NULL)
    {
      full_set_doc = xstrprintf ("%s\n%s", set_doc, help_doc);
      full_show_doc = xstrprintf ("%s\n%s", show_doc, help_doc);
    }
  else
    {
      full_set_doc = xstrdup (set_doc);
      full_show_doc = xstrdup (show_doc);
    }
  set = add_set_or_show_cmd (name, set_cmd, class, var_type, var,
			     full_set_doc, set_list);
  set->flags |= DOC_ALLOCATED;

  if (set_func != NULL)
    set_cmd_sfunc (set, set_func);

  set_cmd_prefix (set, set_list);

  show = add_set_or_show_cmd (name, show_cmd, class, var_type, var,
			      full_show_doc, show_list);
  show->flags |= DOC_ALLOCATED;
  show->show_value_func = show_func;

  if (set_result != NULL)
    *set_result = set;
  if (show_result != NULL)
    *show_result = show;
}

/* Add element named NAME to command list LIST (the list for set or
   some sublist thereof).  CLASS is as in add_cmd.  ENUMLIST is a list
   of strings which may follow NAME.  VAR is address of the variable
   which will contain the matching string (from ENUMLIST).  */

void
add_setshow_enum_cmd (const char *name,
		      enum command_class class,
		      const char *const *enumlist,
		      const char **var,
		      const char *set_doc,
		      const char *show_doc,
		      const char *help_doc,
		      cmd_sfunc_ftype *set_func,
		      show_value_ftype *show_func,
		      struct cmd_list_element **set_list,
		      struct cmd_list_element **show_list)
{
  struct cmd_list_element *c;

  add_setshow_cmd_full (name, class, var_enum, var,
			set_doc, show_doc, help_doc,
			set_func, show_func,
			set_list, show_list,
			&c, NULL);
  c->enums = enumlist;
}

const char * const auto_boolean_enums[] = { "on", "off", "auto", NULL };

/* Add an auto-boolean command named NAME to both the set and show
   command list lists.  CLASS is as in add_cmd.  VAR is address of the
   variable which will contain the value.  DOC is the documentation
   string.  FUNC is the corresponding callback.  */
void
add_setshow_auto_boolean_cmd (const char *name,
			      enum command_class class,
			      enum auto_boolean *var,
			      const char *set_doc, const char *show_doc,
			      const char *help_doc,
			      cmd_sfunc_ftype *set_func,
			      show_value_ftype *show_func,
			      struct cmd_list_element **set_list,
			      struct cmd_list_element **show_list)
{
  struct cmd_list_element *c;

  add_setshow_cmd_full (name, class, var_auto_boolean, var,
			set_doc, show_doc, help_doc,
			set_func, show_func,
			set_list, show_list,
			&c, NULL);
  c->enums = auto_boolean_enums;
}

/* Add element named NAME to both the set and show command LISTs (the
   list for set/show or some sublist thereof).  CLASS is as in
   add_cmd.  VAR is address of the variable which will contain the
   value.  SET_DOC and SHOW_DOC are the documentation strings.  */
void
add_setshow_boolean_cmd (const char *name, enum command_class class, int *var,
			 const char *set_doc, const char *show_doc,
			 const char *help_doc,
			 cmd_sfunc_ftype *set_func,
			 show_value_ftype *show_func,
			 struct cmd_list_element **set_list,
			 struct cmd_list_element **show_list)
{
  static const char *boolean_enums[] = { "on", "off", NULL };
  struct cmd_list_element *c;

  add_setshow_cmd_full (name, class, var_boolean, var,
			set_doc, show_doc, help_doc,
			set_func, show_func,
			set_list, show_list,
			&c, NULL);
  c->enums = boolean_enums;
}

/* Add element named NAME to both the set and show command LISTs (the
   list for set/show or some sublist thereof).  */
void
add_setshow_filename_cmd (const char *name, enum command_class class,
			  char **var,
			  const char *set_doc, const char *show_doc,
			  const char *help_doc,
			  cmd_sfunc_ftype *set_func,
			  show_value_ftype *show_func,
			  struct cmd_list_element **set_list,
			  struct cmd_list_element **show_list)
{
  struct cmd_list_element *set_result;

  add_setshow_cmd_full (name, class, var_filename, var,
			set_doc, show_doc, help_doc,
			set_func, show_func,
			set_list, show_list,
			&set_result, NULL);
  set_cmd_completer (set_result, filename_completer);
}

/* Add element named NAME to both the set and show command LISTs (the
   list for set/show or some sublist thereof).  */
void
add_setshow_string_cmd (const char *name, enum command_class class,
			char **var,
			const char *set_doc, const char *show_doc,
			const char *help_doc,
			cmd_sfunc_ftype *set_func,
			show_value_ftype *show_func,
			struct cmd_list_element **set_list,
			struct cmd_list_element **show_list)
{
  add_setshow_cmd_full (name, class, var_string, var,
			set_doc, show_doc, help_doc,
			set_func, show_func,
			set_list, show_list,
			NULL, NULL);
}

/* Add element named NAME to both the set and show command LISTs (the
   list for set/show or some sublist thereof).  */
struct cmd_list_element *
add_setshow_string_noescape_cmd (const char *name, enum command_class class,
				 char **var,
				 const char *set_doc, const char *show_doc,
				 const char *help_doc,
				 cmd_sfunc_ftype *set_func,
				 show_value_ftype *show_func,
				 struct cmd_list_element **set_list,
				 struct cmd_list_element **show_list)
{
  struct cmd_list_element *set_cmd;

  add_setshow_cmd_full (name, class, var_string_noescape, var,
			set_doc, show_doc, help_doc,
			set_func, show_func,
			set_list, show_list,
			&set_cmd, NULL);
  return set_cmd;
}

/* Add element named NAME to both the set and show command LISTs (the
   list for set/show or some sublist thereof).  */
void
add_setshow_optional_filename_cmd (const char *name, enum command_class class,
				   char **var,
				   const char *set_doc, const char *show_doc,
				   const char *help_doc,
				   cmd_sfunc_ftype *set_func,
				   show_value_ftype *show_func,
				   struct cmd_list_element **set_list,
				   struct cmd_list_element **show_list)
{
  struct cmd_list_element *set_result;
 
  add_setshow_cmd_full (name, class, var_optional_filename, var,
			set_doc, show_doc, help_doc,
			set_func, show_func,
			set_list, show_list,
			&set_result, NULL);
		
  set_cmd_completer (set_result, filename_completer);

}

/* Completes on literal "unlimited".  Used by integer commands that
   support a special "unlimited" value.  */

static VEC (char_ptr) *
integer_unlimited_completer (struct cmd_list_element *ignore,
			     const char *text, const char *word)
{
  static const char * const keywords[] =
    {
      "unlimited",
      NULL,
    };

  return complete_on_enum (keywords, text, word);
}

/* Add element named NAME to both the set and show command LISTs (the
   list for set/show or some sublist thereof).  CLASS is as in
   add_cmd.  VAR is address of the variable which will contain the
   value.  SET_DOC and SHOW_DOC are the documentation strings.  This
   function is only used in Python API.  Please don't use it elsewhere.  */
void
add_setshow_integer_cmd (const char *name, enum command_class class,
			 int *var,
			 const char *set_doc, const char *show_doc,
			 const char *help_doc,
			 cmd_sfunc_ftype *set_func,
			 show_value_ftype *show_func,
			 struct cmd_list_element **set_list,
			 struct cmd_list_element **show_list)
{
  struct cmd_list_element *set;

  add_setshow_cmd_full (name, class, var_integer, var,
			set_doc, show_doc, help_doc,
			set_func, show_func,
			set_list, show_list,
			&set, NULL);

  set_cmd_completer (set, integer_unlimited_completer);
}

/* Add element named NAME to both the set and show command LISTs (the
   list for set/show or some sublist thereof).  CLASS is as in
   add_cmd.  VAR is address of the variable which will contain the
   value.  SET_DOC and SHOW_DOC are the documentation strings.  */
void
add_setshow_uinteger_cmd (const char *name, enum command_class class,
			  unsigned int *var,
			  const char *set_doc, const char *show_doc,
			  const char *help_doc,
			  cmd_sfunc_ftype *set_func,
			  show_value_ftype *show_func,
			  struct cmd_list_element **set_list,
			  struct cmd_list_element **show_list)
{
  struct cmd_list_element *set;

  add_setshow_cmd_full (name, class, var_uinteger, var,
			set_doc, show_doc, help_doc,
			set_func, show_func,
			set_list, show_list,
			&set, NULL);

  set_cmd_completer (set, integer_unlimited_completer);
}

/* Add element named NAME to both the set and show command LISTs (the
   list for set/show or some sublist thereof).  CLASS is as in
   add_cmd.  VAR is address of the variable which will contain the
   value.  SET_DOC and SHOW_DOC are the documentation strings.  */
void
add_setshow_zinteger_cmd (const char *name, enum command_class class,
			  int *var,
			  const char *set_doc, const char *show_doc,
			  const char *help_doc,
			  cmd_sfunc_ftype *set_func,
			  show_value_ftype *show_func,
			  struct cmd_list_element **set_list,
			  struct cmd_list_element **show_list)
{
  add_setshow_cmd_full (name, class, var_zinteger, var,
			set_doc, show_doc, help_doc,
			set_func, show_func,
			set_list, show_list,
			NULL, NULL);
}

void
add_setshow_zuinteger_unlimited_cmd (const char *name,
				     enum command_class class,
				     int *var,
				     const char *set_doc,
				     const char *show_doc,
				     const char *help_doc,
				     cmd_sfunc_ftype *set_func,
				     show_value_ftype *show_func,
				     struct cmd_list_element **set_list,
				     struct cmd_list_element **show_list)
{
  struct cmd_list_element *set;

  add_setshow_cmd_full (name, class, var_zuinteger_unlimited, var,
			set_doc, show_doc, help_doc,
			set_func, show_func,
			set_list, show_list,
			&set, NULL);

  set_cmd_completer (set, integer_unlimited_completer);
}

/* Add element named NAME to both the set and show command LISTs (the
   list for set/show or some sublist thereof).  CLASS is as in
   add_cmd.  VAR is address of the variable which will contain the
   value.  SET_DOC and SHOW_DOC are the documentation strings.  */
void
add_setshow_zuinteger_cmd (const char *name, enum command_class class,
			   unsigned int *var,
			   const char *set_doc, const char *show_doc,
			   const char *help_doc,
			   cmd_sfunc_ftype *set_func,
			   show_value_ftype *show_func,
			   struct cmd_list_element **set_list,
			   struct cmd_list_element **show_list)
{
  add_setshow_cmd_full (name, class, var_zuinteger, var,
			set_doc, show_doc, help_doc,
			set_func, show_func,
			set_list, show_list,
			NULL, NULL);
}

/* Remove the command named NAME from the command list.  Return the
   list commands which were aliased to the deleted command.  If the
   command had no aliases, return NULL.  The various *HOOKs are set to
   the pre- and post-hook commands for the deleted command.  If the
   command does not have a hook, the corresponding out parameter is
   set to NULL.  */

static struct cmd_list_element *
delete_cmd (const char *name, struct cmd_list_element **list,
	    struct cmd_list_element **prehook,
	    struct cmd_list_element **prehookee,
	    struct cmd_list_element **posthook,
	    struct cmd_list_element **posthookee)
{
  struct cmd_list_element *iter;
  struct cmd_list_element **previous_chain_ptr;
  struct cmd_list_element *aliases = NULL;

  *prehook = NULL;
  *prehookee = NULL;
  *posthook = NULL;
  *posthookee = NULL;
  previous_chain_ptr = list;

  for (iter = *previous_chain_ptr; iter; iter = *previous_chain_ptr)
    {
      if (strcmp (iter->name, name) == 0)
	{
	  if (iter->destroyer)
	    iter->destroyer (iter, iter->context);
	  if (iter->hookee_pre)
	    iter->hookee_pre->hook_pre = 0;
	  *prehook = iter->hook_pre;
	  *prehookee = iter->hookee_pre;
	  if (iter->hookee_post)
	    iter->hookee_post->hook_post = 0;
	  if (iter->doc && (iter->flags & DOC_ALLOCATED) != 0)
	    xfree (iter->doc);
	  *posthook = iter->hook_post;
	  *posthookee = iter->hookee_post;

	  /* Update the link.  */
	  *previous_chain_ptr = iter->next;

	  aliases = iter->aliases;

	  /* If this command was an alias, remove it from the list of
	     aliases.  */
	  if (iter->cmd_pointer)
	    {
	      struct cmd_list_element **prevp = &iter->cmd_pointer->aliases;
	      struct cmd_list_element *a = *prevp;

	      while (a != iter)
		{
		  prevp = &a->alias_chain;
		  a = *prevp;
		}
	      *prevp = iter->alias_chain;
	    }

	  xfree (iter);

	  /* We won't see another command with the same name.  */
	  break;
	}
      else
	previous_chain_ptr = &iter->next;
    }

  return aliases;
}

/* Shorthands to the commands above.  */

/* Add an element to the list of info subcommands.  */

struct cmd_list_element *
add_info (const char *name, void (*fun) (char *, int), char *doc)
{
  return add_cmd (name, no_class, fun, doc, &infolist);
}

/* Add an alias to the list of info subcommands.  */

struct cmd_list_element *
add_info_alias (const char *name, char *oldname, int abbrev_flag)
{
  return add_alias_cmd (name, oldname, 0, abbrev_flag, &infolist);
}

/* Add an element to the list of commands.  */

struct cmd_list_element *
add_com (const char *name, enum command_class class, void (*fun) (char *, int),
	 char *doc)
{
  return add_cmd (name, class, fun, doc, &cmdlist);
}

/* Add an alias or abbreviation command to the list of commands.  */

struct cmd_list_element *
add_com_alias (const char *name, const char *oldname, enum command_class class,
	       int abbrev_flag)
{
  return add_alias_cmd (name, oldname, class, abbrev_flag, &cmdlist);
}

/* Recursively walk the commandlist structures, and print out the
   documentation of commands that match our regex in either their
   name, or their documentation.
*/
void 
apropos_cmd (struct ui_file *stream, 
	     struct cmd_list_element *commandlist,
	     struct re_pattern_buffer *regex, char *prefix)
{
  struct cmd_list_element *c;
  int returnvalue;

  /* Walk through the commands.  */
  for (c=commandlist;c;c=c->next)
    {
      returnvalue = -1; /* Needed to avoid double printing.  */
      if (c->name != NULL)
	{
	  /* Try to match against the name.  */
	  returnvalue = re_search (regex, c->name, strlen(c->name),
				   0, strlen (c->name), NULL);
	  if (returnvalue >= 0)
	    {
	      print_help_for_command (c, prefix, 
				      0 /* don't recurse */, stream);
	    }
	}
      if (c->doc != NULL && returnvalue < 0)
	{
	  /* Try to match against documentation.  */
	  if (re_search(regex,c->doc,strlen(c->doc),0,strlen(c->doc),NULL) >=0)
	    {
	      print_help_for_command (c, prefix, 
				      0 /* don't recurse */, stream);
	    }
	}
      /* Check if this command has subcommands and is not an
	 abbreviation.  We skip listing subcommands of abbreviations
	 in order to avoid duplicates in the output.  */
      if (c->prefixlist != NULL && !c->abbrev_flag)
	{
	  /* Recursively call ourselves on the subcommand list,
	     passing the right prefix in.  */
	  apropos_cmd (stream,*c->prefixlist,regex,c->prefixname);
	}
    }
}

/* This command really has to deal with two things:
   1) I want documentation on *this string* (usually called by
      "help commandname").

   2) I want documentation on *this list* (usually called by giving a
      command that requires subcommands.  Also called by saying just
      "help".)

   I am going to split this into two seperate comamnds, help_cmd and
   help_list.  */

void
help_cmd (char *arg, struct ui_file *stream)
{
  struct cmd_list_element *c;
  const char *command = arg;

  if (!command)
    {
      help_list (cmdlist, "", all_classes, stream);
      return;
    }

  if (strcmp (command, "all") == 0)
    {
      help_all (stream);
      return;
    }

  c = lookup_cmd (&command, cmdlist, "", 0, 0);

  if (c == 0)
    return;

  /* There are three cases here.
     If c->prefixlist is nonzero, we have a prefix command.
     Print its documentation, then list its subcommands.

     If c->func is non NULL, we really have a command.  Print its
     documentation and return.

     If c->func is NULL, we have a class name.  Print its
     documentation (as if it were a command) and then set class to the
     number of this class so that the commands in the class will be
     listed.  */

  fputs_filtered (c->doc, stream);
  fputs_filtered ("\n", stream);

  if (c->prefixlist == 0 && c->func != NULL)
    return;
  fprintf_filtered (stream, "\n");

  /* If this is a prefix command, print it's subcommands.  */
  if (c->prefixlist)
    help_list (*c->prefixlist, c->prefixname, all_commands, stream);

  /* If this is a class name, print all of the commands in the class.  */
  if (c->func == NULL)
    help_list (cmdlist, "", c->class, stream);

  if (c->hook_pre || c->hook_post)
    fprintf_filtered (stream,
                      "\nThis command has a hook (or hooks) defined:\n");

  if (c->hook_pre)
    fprintf_filtered (stream,
                      "\tThis command is run after  : %s (pre hook)\n",
                    c->hook_pre->name);
  if (c->hook_post)
    fprintf_filtered (stream,
                      "\tThis command is run before : %s (post hook)\n",
                    c->hook_post->name);
}

/*
 * Get a specific kind of help on a command list.
 *
 * LIST is the list.
 * CMDTYPE is the prefix to use in the title string.
 * CLASS is the class with which to list the nodes of this list (see
 * documentation for help_cmd_list below),  As usual, ALL_COMMANDS for
 * everything, ALL_CLASSES for just classes, and non-negative for only things
 * in a specific class.
 * and STREAM is the output stream on which to print things.
 * If you call this routine with a class >= 0, it recurses.
 */
void
help_list (struct cmd_list_element *list, char *cmdtype,
	   enum command_class class, struct ui_file *stream)
{
  int len;
  char *cmdtype1, *cmdtype2;

  /* If CMDTYPE is "foo ", CMDTYPE1 gets " foo" and CMDTYPE2 gets "foo sub".
   */
  len = strlen (cmdtype);
  cmdtype1 = (char *) alloca (len + 1);
  cmdtype1[0] = 0;
  cmdtype2 = (char *) alloca (len + 4);
  cmdtype2[0] = 0;
  if (len)
    {
      cmdtype1[0] = ' ';
      strncpy (cmdtype1 + 1, cmdtype, len - 1);
      cmdtype1[len] = 0;
      strncpy (cmdtype2, cmdtype, len - 1);
      strcpy (cmdtype2 + len - 1, " sub");
    }

  if (class == all_classes)
    fprintf_filtered (stream, "List of classes of %scommands:\n\n", cmdtype2);
  else
    fprintf_filtered (stream, "List of %scommands:\n\n", cmdtype2);

  help_cmd_list (list, class, cmdtype, (int) class >= 0, stream);

  if (class == all_classes)
    {
      fprintf_filtered (stream, "\n\
Type \"help%s\" followed by a class name for a list of commands in ",
			cmdtype1);
      wrap_here ("");
      fprintf_filtered (stream, "that class.");

      fprintf_filtered (stream, "\n\
Type \"help all\" for the list of all commands.");
    }

  fprintf_filtered (stream, "\nType \"help%s\" followed by %scommand name ",
		    cmdtype1, cmdtype2);
  wrap_here ("");
  fputs_filtered ("for ", stream);
  wrap_here ("");
  fputs_filtered ("full ", stream);
  wrap_here ("");
  fputs_filtered ("documentation.\n", stream);
  fputs_filtered ("Type \"apropos word\" to search "
		  "for commands related to \"word\".\n", stream);
  fputs_filtered ("Command name abbreviations are allowed if unambiguous.\n",
		  stream);
}

static void
help_all (struct ui_file *stream)
{
  struct cmd_list_element *c;
  int seen_unclassified = 0;

  for (c = cmdlist; c; c = c->next)
    {
      if (c->abbrev_flag)
        continue;
      /* If this is a class name, print all of the commands in the
	 class.  */

      if (c->func == NULL)
	{
	  fprintf_filtered (stream, "\nCommand class: %s\n\n", c->name);
	  help_cmd_list (cmdlist, c->class, "", 1, stream);
	}
    }

  /* While it's expected that all commands are in some class,
     as a safety measure, we'll print commands outside of any
     class at the end.  */

  for (c = cmdlist; c; c = c->next)
    {
      if (c->abbrev_flag)
        continue;

      if (c->class == no_class)
	{
	  if (!seen_unclassified)
	    {
	      fprintf_filtered (stream, "\nUnclassified commands\n\n");
	      seen_unclassified = 1;
	    }
	  print_help_for_command (c, "", 1, stream);
	}
    }

}

/* Print only the first line of STR on STREAM.  */
void
print_doc_line (struct ui_file *stream, char *str)
{
  static char *line_buffer = 0;
  static int line_size;
  char *p;

  if (!line_buffer)
    {
      line_size = 80;
      line_buffer = (char *) xmalloc (line_size);
    }

  /* Keep printing '.' or ',' not followed by a whitespace for embedded strings
     like '.gdbinit'.  */
  p = str;
  while (*p && *p != '\n'
	 && ((*p != '.' && *p != ',') || (p[1] && !isspace (p[1]))))
    p++;
  if (p - str > line_size - 1)
    {
      line_size = p - str + 1;
      xfree (line_buffer);
      line_buffer = (char *) xmalloc (line_size);
    }
  strncpy (line_buffer, str, p - str);
  line_buffer[p - str] = '\0';
  if (islower (line_buffer[0]))
    line_buffer[0] = toupper (line_buffer[0]);
  fputs_filtered (line_buffer, stream);
}

/* Print one-line help for command C.
   If RECURSE is non-zero, also print one-line descriptions
   of all prefixed subcommands.  */
static void
print_help_for_command (struct cmd_list_element *c, char *prefix, int recurse,
			struct ui_file *stream)
{
  fprintf_filtered (stream, "%s%s -- ", prefix, c->name);
  print_doc_line (stream, c->doc);
  fputs_filtered ("\n", stream);
  
  if (recurse
      && c->prefixlist != 0
      && c->abbrev_flag == 0)
    /* Subcommands of a prefix command typically have 'all_commands'
       as class.  If we pass CLASS to recursive invocation,
       most often we won't see anything.  */
    help_cmd_list (*c->prefixlist, all_commands, c->prefixname, 1, stream);
}

/*
 * Implement a help command on command list LIST.
 * RECURSE should be non-zero if this should be done recursively on
 * all sublists of LIST.
 * PREFIX is the prefix to print before each command name.
 * STREAM is the stream upon which the output should be written.
 * CLASS should be:
 *      A non-negative class number to list only commands in that
 * class.
 *      ALL_COMMANDS to list all commands in list.
 *      ALL_CLASSES  to list all classes in list.
 *
 *   Note that RECURSE will be active on *all* sublists, not just the
 * ones selected by the criteria above (ie. the selection mechanism
 * is at the low level, not the high-level).
 */
void
help_cmd_list (struct cmd_list_element *list, enum command_class class,
	       char *prefix, int recurse, struct ui_file *stream)
{
  struct cmd_list_element *c;

  for (c = list; c; c = c->next)
    {      
      if (c->abbrev_flag == 0
	  && (class == all_commands
	      || (class == all_classes && c->func == NULL)
	      || (class == c->class && c->func != NULL)))
	{
	  print_help_for_command (c, prefix, recurse, stream);
	}
      else if (c->abbrev_flag == 0 && recurse
	       && class == class_user && c->prefixlist != NULL)
	/* User-defined commands may be subcommands.  */
	help_cmd_list (*c->prefixlist, class, c->prefixname, 
		       recurse, stream);
    }
}


/* Search the input clist for 'command'.  Return the command if
   found (or NULL if not), and return the number of commands
   found in nfound.  */

static struct cmd_list_element *
find_cmd (const char *command, int len, struct cmd_list_element *clist,
	  int ignore_help_classes, int *nfound)
{
  struct cmd_list_element *found, *c;

  found = (struct cmd_list_element *) NULL;
  *nfound = 0;
  for (c = clist; c; c = c->next)
    if (!strncmp (command, c->name, len)
	&& (!ignore_help_classes || c->func))
      {
	found = c;
	(*nfound)++;
	if (c->name[len] == '\0')
	  {
	    *nfound = 1;
	    break;
	  }
      }
  return found;
}

static int
find_command_name_length (const char *text)
{
  const char *p = text;

  /* Treating underscores as part of command words is important
     so that "set args_foo()" doesn't get interpreted as
     "set args _foo()".  */
  /* Some characters are only used for TUI specific commands.
     However, they are always allowed for the sake of consistency.

     The XDB compatibility characters are only allowed when using the
     right mode because they clash with other GDB commands -
     specifically '/' is used as a suffix for print, examine and
     display.

     Note that this is larger than the character set allowed when
     creating user-defined commands.  */

  /* Recognize '!' as a single character command so that, e.g., "!ls"
     works as expected.  */
  if (*p == '!')
    return 1;

  while (isalnum (*p) || *p == '-' || *p == '_'
	 /* Characters used by TUI specific commands.  */
	 || *p == '+' || *p == '<' || *p == '>' || *p == '$'
	 /* Characters used for XDB compatibility.  */
	 || (xdb_commands && (*p == '/' || *p == '?')))
    p++;

  return p - text;
}

/* Return TRUE if NAME is a valid user-defined command name.
   This is a stricter subset of all gdb commands,
   see find_command_name_length.  */

int
valid_user_defined_cmd_name_p (const char *name)
{
  const char *p;

  if (*name == '\0')
    return FALSE;

  /* Alas "42" is a legitimate user-defined command.
     In the interests of not breaking anything we preserve that.  */

  for (p = name; *p != '\0'; ++p)
    {
      if (isalnum (*p)
	  || *p == '-'
	  || *p == '_')
	; /* Ok.  */
      else
	return FALSE;
    }

  return TRUE;
}

/* This routine takes a line of TEXT and a CLIST in which to start the
   lookup.  When it returns it will have incremented the text pointer past
   the section of text it matched, set *RESULT_LIST to point to the list in
   which the last word was matched, and will return a pointer to the cmd
   list element which the text matches.  It will return NULL if no match at
   all was possible.  It will return -1 (cast appropriately, ick) if ambigous
   matches are possible; in this case *RESULT_LIST will be set to point to
   the list in which there are ambiguous choices (and *TEXT will be set to
   the ambiguous text string).

   If the located command was an abbreviation, this routine returns the base
   command of the abbreviation.

   It does no error reporting whatsoever; control will always return
   to the superior routine.

   In the case of an ambiguous return (-1), *RESULT_LIST will be set to point
   at the prefix_command (ie. the best match) *or* (special case) will be NULL
   if no prefix command was ever found.  For example, in the case of "info a",
   "info" matches without ambiguity, but "a" could be "args" or "address", so
   *RESULT_LIST is set to the cmd_list_element for "info".  So in this case
   RESULT_LIST should not be interpeted as a pointer to the beginning of a
   list; it simply points to a specific command.  In the case of an ambiguous
   return *TEXT is advanced past the last non-ambiguous prefix (e.g.
   "info t" can be "info types" or "info target"; upon return *TEXT has been
   advanced past "info ").

   If RESULT_LIST is NULL, don't set *RESULT_LIST (but don't otherwise
   affect the operation).

   This routine does *not* modify the text pointed to by TEXT.

   If IGNORE_HELP_CLASSES is nonzero, ignore any command list elements which
   are actually help classes rather than commands (i.e. the function field of
   the struct cmd_list_element is NULL).  */

struct cmd_list_element *
lookup_cmd_1 (const char **text, struct cmd_list_element *clist,
	      struct cmd_list_element **result_list, int ignore_help_classes)
{
  char *command;
  int len, tmp, nfound;
  struct cmd_list_element *found, *c;
  const char *line = *text;

  while (**text == ' ' || **text == '\t')
    (*text)++;

  /* Identify the name of the command.  */
  len = find_command_name_length (*text);

  /* If nothing but whitespace, return 0.  */
  if (len == 0)
    return 0;

  /* *text and p now bracket the first command word to lookup (and
     it's length is len).  We copy this into a local temporary.  */


  command = (char *) alloca (len + 1);
  memcpy (command, *text, len);
  command[len] = '\0';

  /* Look it up.  */
  found = 0;
  nfound = 0;
  found = find_cmd (command, len, clist, ignore_help_classes, &nfound);

  /* We didn't find the command in the entered case, so lower case it
     and search again.  */
  if (!found || nfound == 0)
    {
      for (tmp = 0; tmp < len; tmp++)
	{
	  char x = command[tmp];

	  command[tmp] = isupper (x) ? tolower (x) : x;
	}
      found = find_cmd (command, len, clist, ignore_help_classes, &nfound);
    }

  /* If nothing matches, we have a simple failure.  */
  if (nfound == 0)
    return 0;

  if (nfound > 1)
    {
      if (result_list != NULL)
	/* Will be modified in calling routine
	   if we know what the prefix command is.  */
	*result_list = 0;
      return CMD_LIST_AMBIGUOUS;	/* Ambiguous.  */
    }

  /* We've matched something on this list.  Move text pointer forward.  */

  *text += len;

  if (found->cmd_pointer)
    {
      /* We drop the alias (abbreviation) in favor of the command it
       is pointing to.  If the alias is deprecated, though, we need to
       warn the user about it before we drop it.  Note that while we
       are warning about the alias, we may also warn about the command
       itself and we will adjust the appropriate DEPRECATED_WARN_USER
       flags.  */
      
      if (found->flags & DEPRECATED_WARN_USER)
	deprecated_cmd_warning (line);
      found = found->cmd_pointer;
    }
  /* If we found a prefix command, keep looking.  */

  if (found->prefixlist)
    {
      c = lookup_cmd_1 (text, *found->prefixlist, result_list,
			ignore_help_classes);
      if (!c)
	{
	  /* Didn't find anything; this is as far as we got.  */
	  if (result_list != NULL)
	    *result_list = clist;
	  return found;
	}
      else if (c == CMD_LIST_AMBIGUOUS)
	{
	  /* We've gotten this far properly, but the next step is
	     ambiguous.  We need to set the result list to the best
	     we've found (if an inferior hasn't already set it).  */
	  if (result_list != NULL)
	    if (!*result_list)
	      /* This used to say *result_list = *found->prefixlist.
	         If that was correct, need to modify the documentation
	         at the top of this function to clarify what is
	         supposed to be going on.  */
	      *result_list = found;
	  return c;
	}
      else
	{
	  /* We matched!  */
	  return c;
	}
    }
  else
    {
      if (result_list != NULL)
	*result_list = clist;
      return found;
    }
}

/* All this hair to move the space to the front of cmdtype */

static void
undef_cmd_error (const char *cmdtype, const char *q)
{
  error (_("Undefined %scommand: \"%s\".  Try \"help%s%.*s\"."),
	 cmdtype,
	 q,
	 *cmdtype ? " " : "",
	 (int) strlen (cmdtype) - 1,
	 cmdtype);
}

/* Look up the contents of *LINE as a command in the command list LIST.
   LIST is a chain of struct cmd_list_element's.
   If it is found, return the struct cmd_list_element for that command
   and update *LINE to point after the command name, at the first argument.
   If not found, call error if ALLOW_UNKNOWN is zero
   otherwise (or if error returns) return zero.
   Call error if specified command is ambiguous,
   unless ALLOW_UNKNOWN is negative.
   CMDTYPE precedes the word "command" in the error message.

   If INGNORE_HELP_CLASSES is nonzero, ignore any command list
   elements which are actually help classes rather than commands (i.e.
   the function field of the struct cmd_list_element is 0).  */

struct cmd_list_element *
lookup_cmd (const char **line, struct cmd_list_element *list, char *cmdtype,
	    int allow_unknown, int ignore_help_classes)
{
  struct cmd_list_element *last_list = 0;
  struct cmd_list_element *c;

  /* Note: Do not remove trailing whitespace here because this
     would be wrong for complete_command.  Jim Kingdon  */

  if (!*line)
    error (_("Lack of needed %scommand"), cmdtype);

  c = lookup_cmd_1 (line, list, &last_list, ignore_help_classes);

  if (!c)
    {
      if (!allow_unknown)
	{
	  char *q;
	  int len = find_command_name_length (*line);

	  q = (char *) alloca (len + 1);
	  strncpy (q, *line, len);
	  q[len] = '\0';
	  undef_cmd_error (cmdtype, q);
	}
      else
	return 0;
    }
  else if (c == CMD_LIST_AMBIGUOUS)
    {
      /* Ambigous.  Local values should be off prefixlist or called
         values.  */
      int local_allow_unknown = (last_list ? last_list->allow_unknown :
				 allow_unknown);
      char *local_cmdtype = last_list ? last_list->prefixname : cmdtype;
      struct cmd_list_element *local_list =
	(last_list ? *(last_list->prefixlist) : list);

      if (local_allow_unknown < 0)
	{
	  if (last_list)
	    return last_list;	/* Found something.  */
	  else
	    return 0;		/* Found nothing.  */
	}
      else
	{
	  /* Report as error.  */
	  int amb_len;
	  char ambbuf[100];

	  for (amb_len = 0;
	       ((*line)[amb_len] && (*line)[amb_len] != ' '
		&& (*line)[amb_len] != '\t');
	       amb_len++)
	    ;

	  ambbuf[0] = 0;
	  for (c = local_list; c; c = c->next)
	    if (!strncmp (*line, c->name, amb_len))
	      {
		if (strlen (ambbuf) + strlen (c->name) + 6
		    < (int) sizeof ambbuf)
		  {
		    if (strlen (ambbuf))
		      strcat (ambbuf, ", ");
		    strcat (ambbuf, c->name);
		  }
		else
		  {
		    strcat (ambbuf, "..");
		    break;
		  }
	      }
	  error (_("Ambiguous %scommand \"%s\": %s."), local_cmdtype,
		 *line, ambbuf);
	  return 0;		/* lint */
	}
    }
  else
    {
      if (c->type == set_cmd && **line != '\0' && !isspace (**line))
        error (_("Argument must be preceded by space."));

      /* We've got something.  It may still not be what the caller
         wants (if this command *needs* a subcommand).  */
      while (**line == ' ' || **line == '\t')
	(*line)++;

      if (c->prefixlist && **line && !c->allow_unknown)
	undef_cmd_error (c->prefixname, *line);

      /* Seems to be what he wants.  Return it.  */
      return c;
    }
  return 0;
}

/* We are here presumably because an alias or command in TEXT is
   deprecated and a warning message should be generated.  This
   function decodes TEXT and potentially generates a warning message
   as outlined below.
   
   Example for 'set endian big' which has a fictitious alias 'seb'.
   
   If alias wasn't used in TEXT, and the command is deprecated:
   "warning: 'set endian big' is deprecated." 
   
   If alias was used, and only the alias is deprecated:
   "warning: 'seb' an alias for the command 'set endian big' is deprecated."
   
   If alias was used and command is deprecated (regardless of whether
   the alias itself is deprecated:
   
   "warning: 'set endian big' (seb) is deprecated."

   After the message has been sent, clear the appropriate flags in the
   command and/or the alias so the user is no longer bothered.
   
*/
void
deprecated_cmd_warning (const char *text)
{
  struct cmd_list_element *alias = NULL;
  struct cmd_list_element *prefix_cmd = NULL;
  struct cmd_list_element *cmd = NULL;

  if (!lookup_cmd_composition (text, &alias, &prefix_cmd, &cmd))
    /* Return if text doesn't evaluate to a command.  */
    return;

  if (!((alias ? (alias->flags & DEPRECATED_WARN_USER) : 0)
      || (cmd->flags & DEPRECATED_WARN_USER) ) ) 
    /* Return if nothing is deprecated.  */
    return;
  
  printf_filtered ("Warning:");
  
  if (alias && !(cmd->flags & CMD_DEPRECATED))
    printf_filtered (" '%s', an alias for the", alias->name);
    
  printf_filtered (" command '");
  
  if (prefix_cmd)
    printf_filtered ("%s", prefix_cmd->prefixname);
  
  printf_filtered ("%s", cmd->name);

  if (alias && (cmd->flags & CMD_DEPRECATED))
    printf_filtered ("' (%s) is deprecated.\n", alias->name);
  else
    printf_filtered ("' is deprecated.\n"); 
  

  /* If it is only the alias that is deprecated, we want to indicate
     the new alias, otherwise we'll indicate the new command.  */

  if (alias && !(cmd->flags & CMD_DEPRECATED))
    {
      if (alias->replacement)
	printf_filtered ("Use '%s'.\n\n", alias->replacement);
      else
	printf_filtered ("No alternative known.\n\n");
     }  
  else
    {
      if (cmd->replacement)
	printf_filtered ("Use '%s'.\n\n", cmd->replacement);
      else
	printf_filtered ("No alternative known.\n\n");
    }

  /* We've warned you, now we'll keep quiet.  */
  if (alias)
    alias->flags &= ~DEPRECATED_WARN_USER;
  
  cmd->flags &= ~DEPRECATED_WARN_USER;
}


/* Look up the contents of LINE as a command in the command list 'cmdlist'.
   Return 1 on success, 0 on failure.
   
   If LINE refers to an alias, *alias will point to that alias.
   
   If LINE is a postfix command (i.e. one that is preceded by a prefix
   command) set *prefix_cmd.
   
   Set *cmd to point to the command LINE indicates.
   
   If any of *alias, *prefix_cmd, or *cmd cannot be determined or do not 
   exist, they are NULL when we return.
   
*/
int
lookup_cmd_composition (const char *text,
                      struct cmd_list_element **alias,
                      struct cmd_list_element **prefix_cmd, 
                      struct cmd_list_element **cmd)
{
  char *command;
  int len, tmp, nfound;
  struct cmd_list_element *cur_list;
  struct cmd_list_element *prev_cmd;

  *alias = NULL;
  *prefix_cmd = NULL;
  *cmd = NULL;
  
  cur_list = cmdlist;
  
  while (1)
    { 
      /* Go through as many command lists as we need to,
	 to find the command TEXT refers to.  */
      
      prev_cmd = *cmd;
      
      while (*text == ' ' || *text == '\t')
	(text)++;
      
      /* Identify the name of the command.  */
      len = find_command_name_length (text);
      
      /* If nothing but whitespace, return.  */
      if (len == 0)
	return 0;
      
      /* Text is the start of the first command word to lookup (and
	 it's length is len).  We copy this into a local temporary.  */
      
      command = (char *) alloca (len + 1);
      memcpy (command, text, len);
      command[len] = '\0';
      
      /* Look it up.  */
      *cmd = 0;
      nfound = 0;
      *cmd = find_cmd (command, len, cur_list, 1, &nfound);
      
      /* We didn't find the command in the entered case, so lower case
	 it and search again.
      */
      if (!*cmd || nfound == 0)
	{
	  for (tmp = 0; tmp < len; tmp++)
	    {
	      char x = command[tmp];

	      command[tmp] = isupper (x) ? tolower (x) : x;
	    }
	  *cmd = find_cmd (command, len, cur_list, 1, &nfound);
	}
      
      if (*cmd == CMD_LIST_AMBIGUOUS)
	{
	  return 0;              /* ambiguous */
	}
      
      if (*cmd == NULL)
	return 0;                /* nothing found */
      else
	{
	  if ((*cmd)->cmd_pointer)
	    {
	      /* cmd was actually an alias, we note that an alias was
		 used (by assigning *alais) and we set *cmd.  */
	      *alias = *cmd;
	      *cmd = (*cmd)->cmd_pointer;
	    }
	  *prefix_cmd = prev_cmd;
	}
      if ((*cmd)->prefixlist)
	cur_list = *(*cmd)->prefixlist;
      else
	return 1;
      
      text += len;
    }
}

/* Helper function for SYMBOL_COMPLETION_FUNCTION.  */

/* Return a vector of char pointers which point to the different
   possible completions in LIST of TEXT.

   WORD points in the same buffer as TEXT, and completions should be
   returned relative to this position.  For example, suppose TEXT is
   "foo" and we want to complete to "foobar".  If WORD is "oo", return
   "oobar"; if WORD is "baz/foo", return "baz/foobar".  */

VEC (char_ptr) *
complete_on_cmdlist (struct cmd_list_element *list,
		     const char *text, const char *word,
		     int ignore_help_classes)
{
  struct cmd_list_element *ptr;
  VEC (char_ptr) *matchlist = NULL;
  int textlen = strlen (text);
  int pass;
  int saw_deprecated_match = 0;

  /* We do one or two passes.  In the first pass, we skip deprecated
     commands.  If we see no matching commands in the first pass, and
     if we did happen to see a matching deprecated command, we do
     another loop to collect those.  */
  for (pass = 0; matchlist == 0 && pass < 2; ++pass)
    {
      for (ptr = list; ptr; ptr = ptr->next)
	if (!strncmp (ptr->name, text, textlen)
	    && !ptr->abbrev_flag
	    && (!ignore_help_classes || ptr->func
		|| ptr->prefixlist))
	  {
	    char *match;

	    if (pass == 0)
	      {
		if ((ptr->flags & CMD_DEPRECATED) != 0)
		  {
		    saw_deprecated_match = 1;
		    continue;
		  }
	      }

	    match = (char *) xmalloc (strlen (word) + strlen (ptr->name) + 1);
	    if (word == text)
	      strcpy (match, ptr->name);
	    else if (word > text)
	      {
		/* Return some portion of ptr->name.  */
		strcpy (match, ptr->name + (word - text));
	      }
	    else
	      {
		/* Return some of text plus ptr->name.  */
		strncpy (match, word, text - word);
		match[text - word] = '\0';
		strcat (match, ptr->name);
	      }
	    VEC_safe_push (char_ptr, matchlist, match);
	  }
      /* If we saw no matching deprecated commands in the first pass,
	 just bail out.  */
      if (!saw_deprecated_match)
	break;
    }

  return matchlist;
}

/* Helper function for SYMBOL_COMPLETION_FUNCTION.  */

/* Return a vector of char pointers which point to the different
   possible completions in CMD of TEXT.

   WORD points in the same buffer as TEXT, and completions should be
   returned relative to this position.  For example, suppose TEXT is "foo"
   and we want to complete to "foobar".  If WORD is "oo", return
   "oobar"; if WORD is "baz/foo", return "baz/foobar".  */

VEC (char_ptr) *
complete_on_enum (const char *const *enumlist,
		  const char *text, const char *word)
{
  VEC (char_ptr) *matchlist = NULL;
  int textlen = strlen (text);
  int i;
  const char *name;

  for (i = 0; (name = enumlist[i]) != NULL; i++)
    if (strncmp (name, text, textlen) == 0)
      {
	char *match;

	match = (char *) xmalloc (strlen (word) + strlen (name) + 1);
	if (word == text)
	  strcpy (match, name);
	else if (word > text)
	  {
	    /* Return some portion of name.  */
	    strcpy (match, name + (word - text));
	  }
	else
	  {
	    /* Return some of text plus name.  */
	    strncpy (match, word, text - word);
	    match[text - word] = '\0';
	    strcat (match, name);
	  }
	VEC_safe_push (char_ptr, matchlist, match);
      }

  return matchlist;
}


/* Check function pointer.  */
int
cmd_func_p (struct cmd_list_element *cmd)
{
  return (cmd->func != NULL);
}


/* Call the command function.  */
void
cmd_func (struct cmd_list_element *cmd, char *args, int from_tty)
{
  if (cmd_func_p (cmd))
    (*cmd->func) (cmd, args, from_tty);
  else
    error (_("Invalid command"));
}
@


1.119
log
@2013-04-24  Muhammad Bilal  <mbilal@@codesourcery.com>

	PR gdb/10462
	* cli/cli-decode.c (lookup_command): Show an error if there is no space
	before argument.

2013-04-24  Muhammad Bilal  <mbilal@@codesourcery.com>

	PR gdb/10462
	* gdb.base/setshow.exp: Add test case.
@
text
@a24 1

a26 5

#ifdef TUI
#include "tui/tui.h"		/* For tui_active et al.  */
#endif

@


1.118
log
@Accept "set foo unlimited" in integer/uinteger/zuinteger_unlimited commands.

Currently, several commands take "0" or "-1" to mean "unlimited".

"show" knows when to print "unlimited":

 (gdb) show height
 Number of lines gdb thinks are in a page is 45.
 (gdb) set height 0
 (gdb) show height
 Number of lines gdb thinks are in a page is unlimited.

However, the user can't herself specify "unlimited" directly:

 (gdb) set height unlimited
 No symbol table is loaded.  Use the "file" command.
 (gdb)

This patch addresses that, by adjusting the set handler for all
integer/uinteger/zuinteger_unlimited commands to accept literal
"unlimited".  It also installs a completer.  Presently, we complete on
symbols by default, and at
<http://sourceware.org/ml/gdb-patches/2013-03/msg00864.html> I've
shown a WIP prototype that tried to keep that half working in these
commands.  In the end, it turned out to be more complicated than
justifiable, IMO.  It's super rare to want to pass the value of a
variable/symbol in the program to a GDB set/show knob.  That'll still
work, it's just that we won't assist with completion anymore.  This
patch just sticks with the simple, and completes on "unlimited", and
nothing else.  This simplification means that

  "set he<tab><tab>"

is all it takes to get to:

  "set height unlimited"

The patch then goes through all integer/uinteger/zuinteger_unlimited
commands in the tree, and updates both the online help and the manual
to mention that "unlimited" is accepted in addition to 0/-1.  In the
cases where the command had no online help text at all, this adds it.
I've tried to make the texts read in a way that "unlimited" is
suggested before "0" or "-1" is.

Tested on x86_64 Fedora 17.

gdb/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* cli/cli-decode.c (integer_unlimited_completer): New function.
	(add_setshow_integer_cmd, add_setshow_uinteger_cmd)
	(add_setshow_zuinteger_unlimited_cmd): Install the "unlimited"
	completer.
	* cli/cli-setshow.c: Include "cli/cli-utils.h".
	(is_unlimited_literal): New function.
	(do_set_command): Handle literal "unlimited" arguments.
	* frame.c (_initialize_frame) <set backtrace limit>: Document
	"unlimited".
	* printcmd.c (_initialize_printcmd) <set print
	max-symbolic-offset>: Add help text.
	* record-full.c (_initialize_record_full) <set record full
	insn-number-max>: Likewise.
	* record.c (_initialize_record) <set record
	instruction-history-size, set record function-call-history-size>:
	Add help text.
	* ser-tcp.c (_initialize_ser_tcp) <set tcp connect-timeout>: Add
	help text.
	* tracepoint.c (_initialize_tracepoint) <set trace-buffer-size>:
	Likewise.
	* source.c (_initialize_source) <set listsize>: Add help text.
	* utils.c (initialize_utils) <set height, set width>: Likewise.
	<set pagination>: Mention "set height unlimited".
	* valprint.c (_initialize_valprint) <set print elements, set print
	repeats>: Document "unlimited".

gdb/doc/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* gdb.texinfo (Process Record and Replay): Document that "set
	record full insn-number-max", "set record
	instruction-history-size" and "set record
	function-call-history-size" accept "unlimited".
	(Backtrace): Document that "set backtrace limit" accepts
	"unlimited".
	(List): Document that "set listsize" accepts "unlimited".
	(Print Settings)" Document that "set print max-symbolic-offset",
	"set print elements" and "set print repeats" accept "unlimited".
	(Starting and Stopping Trace Experiments): Document that "set
	trace-buffer-size" accepts "unlimited".
	(Remote Configuration): Document that "set tcp connect-timeout"
	accepts "unlimited".
	(Command History): Document that "set history size" accepts
	"unlimited".
	(Screen Size): Document that "set height" and "set width" accepts
	"unlimited".  Adjust "set pagination"'s description to suggest
	"set height unlimited" instead of "set height 0".

gdb/testsuite/
2013-04-10  Pedro Alves  <palves@@redhat.com>

	* gdb.base/completion.exp: Test "set height", "set listsize" and
	"set trace-buffer-size" completion.
	* gdb.base/setshow.exp: Test "set height unlimited".
	* gdb.trace/trace-buffer-size.exp: Test "set trace-buffer-size
	unlimited".
@
text
@d1559 3
@


1.117
log
@Constify strings in tracepoint.c, lookup_cmd and the completers.

This is sort of a continuation of Keith's parse_exp_1 constification
patch.  It started out by undoing these bits:

  @@@@ -754,9 +754,12 @@@@ validate_actionline (char **line, struct
   	  tmp_p = p;
   	  for (loc = t->base.loc; loc; loc = loc->next)
   	    {
  -	      p = tmp_p;
  -	      exp = parse_exp_1 (&p, loc->address,
  +	      const char *q;
  +
  +	      q = tmp_p;
  +	      exp = parse_exp_1 (&q, loc->address,
   				 block_for_pc (loc->address), 1);
  +	      p = (char *) q;

and progressively making more things const upwards, fixing fallout,
rinse repeat, until GDB built again (--enable-targets=all).

That ended up constifying lookup_cmd/add_cmd and (lots of) friends,
and the completers.

I didn't try to constify the command hooks themselves, because I know
upfront there are commands that write to the command string argument,
and I think I managed to stop at a nice non-hacky split point already.

I think the only non-really-super-obvious changes are
tracepoint.c:validate_actionline, and tracepoint.c:trace_dump_actions.

The rest is just mostly about 'char *' => 'const char *', 'char **'=>
'const char **', and the occasional (e.g., deprecated_cmd_warning)
case of 'char **'=> 'const char *', where/when I noticed that nothing
actually cares about the pointer to pointer output.

Tested on x86_64 Fedora 17, native and gdbserver.

gdb/
2013-03-13  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (struct add_partial_datum) <text, text0, word>: Make
	fields const.
	(ada_make_symbol_completion_list): Make "text0" parameter const.
	* ax-gdb.c (agent_eval_command_one): Make "exp" parameter const.
	* breakpoint.c (condition_completer): Make "text" and "word"
	parameters const.  Adjust.
	(check_tracepoint_command): Adjust to validate_actionline
	prototype change.
	(catch_syscall_completer): Make "text" and "word" parameters
	const.
	* cli/cli-cmds.c (show_user): Make "comname" local const.
	(valid_command_p): Make "command" parameter const.
	(alias_command): Make "alias_prefix" and "command_prefix" locals
	const.
	* cli/cli-decode.c (add_cmd): Make "name" parameter const.
	(add_alias_cmd): Make "name" and "oldname" parameters const.
	Adjust.  No longer make copy of OLDNAME.
	(add_prefix_cmd, add_abbrev_prefix_cmd, add_set_or_show_cmd)
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_unlimited_cmd, add_setshow_zuinteger_cmd)
	(delete_cmd, add_info, add_info_alias, add_com, add_com_alias):
	Make "name" parameter const.
	(help_cmd): Rename "command" parameter to "arg".  New const local
	"command".
	(find_cmd): Make "command" parameter const.
	(lookup_cmd_1): Make "text" parameter pointer to const.  Adjust to
	deprecated_cmd_warning prototype change.
	(undef_cmd_error): Make "cmdtype" parameter const.
	(lookup_cmd): Make "line" parameter const.
	(deprecated_cmd_warning): Change type of "text" parameter to
	pointer to const char, from pointer to pointer to char.  Adjust.
	(lookup_cmd_composition): Make "text" parameter const.
	(complete_on_cmdlist, complete_on_enum): Make "text" and "word"
	parameters const.
	* cli/cli-decode.h (struct cmd_list_element) <name>: Make field
	const.
	* cli/cli-script.c (validate_comname): Make "tem" local const.
	(define_command): New const local "tem_c".  Use it in calls to
	lookup_cmd.
	(document_command): Make "tem" and "comfull" locals const.
	(show_user_1): Make "prefix" and "name" parameters const.
	* cli-script.h (show_user_1): Make "prefix" and "name" parameters
	const.
	* command.h (add_cmd, add_alias_cmd, add_prefix_cmd)
	(add_abbrev_prefix_cmd, completer_ftype, lookup_cmd, lookup_cmd_1)
	(deprecated_cmd_warning, lookup_cmd_composition, add_com)
	(add_com_alias, add_info, add_info_alias, complete_on_cmdlist)
	(complete_on_enum, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_string_noescape_cmd)
	(add_setshow_optional_filename_cmd, add_setshow_integer_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd)
	(add_setshow_zuinteger_cmd, add_setshow_zuinteger_unlimited_cmd):
	Change prototypes, constifying strings.
	* completer.c (noop_completer, filename_completer): Make "text"
	and "prefix" parameters const.
	(location_completer, expression_completer)
	(complete_line_internal): Make "text" and "prefix" parameters
	const and adjust.
	(command_completer, signal_completer): Make "text" and "prefix"
	parameters const.
	* completer.h (noop_completer, filename_completer)
	(expression_completer, location_completer, command_completer)
	(signal_completer): Change prototypes.
	* corefile.c (complete_set_gnutarget): Make "text" and "word"
	parameters const.
	* cp-abi.c (cp_abi_completer): Likewise.
	* expression.h (parse_expression_for_completion): Change
	prototype.
	* f-lang.c (f_make_symbol_completion_list): Make "text" and "word"
	parameters const.
	* infcmd.c (_initialize_infcmd): Make "cmd_name" local const.
	* infrun.c (handle_completer): Make "text" and "word" parameters
	const.
	* interps.c (interpreter_completer): Make "text" and "word"
	parameters const.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Make "text" and "word"
	parameters const.
	* parse.c (parse_exp_1): Move const hack to parse_exp_in_context.
	(parse_exp_in_context): Rename to ...
	(parse_exp_in_context_1): ... this.
	(parse_exp_in_context): Reimplement, with const hack from
	parse_exp_1.
	(parse_expression_for_completion): Make "string" parameter const.
	* printcmd.c (decode_format): Make "string_ptr" parameter pointer
	to pointer to const char.  Adjust.
	(print_command_1): Make "exp" parameter const.
	(output_command): Rename to ...
	(output_command_const): ... this.  Make "exp" parameter const.
	(output_command): Reimplement.
	(x_command): Adjust.
	(display_command): Rename "exp" parameter to "arg".  New "exp"
	local, const version of "arg".
	* python/py-auto-load.c (gdbpy_initialize_auto_load): Make
	"cmd_name" local const.
	* python/py-cmd.c (cmdpy_destroyer): Cast const away in xfree
	call.
	(cmdpy_completer): Make "text" and "word" parameters const.
	(gdbpy_parse_command_name): Make "prefix_text2" local const.
	* python/py-param.c (add_setshow_generic): Make "tmp_name" local
	const.
	* remote.c (_initialize_remote): Make "cmd_name" local const.
	* symtab.c (language_search_unquoted_string): Make "text" and "p"
	parameters const.  Adjust.
	(completion_list_add_fields): Make "sym_text", "text" and "word"
	parameters const.
	(struct add_name_data) <sym_text, text, word>: Make fields const.
	(default_make_symbol_completion_list_break_on): Make "text" and
	"word" parameters const.  Adjust locals.
	(default_make_symbol_completion_list)
	(make_symbol_completion_list, make_symbol_completion_type)
	(make_symbol_completion_list_fn): Make "text" and "word"
	parameters const.
	(make_file_symbol_completion_list): Make "text", "word" and
	"srcfile" parameters const.  Adjust locals.
	(add_filename_to_list): Make "text" and "word" parameters const.
	(struct add_partial_filename_data) <text, word>: Make fields
	const.
	(make_source_files_completion_list): Make "text" and "word"
	parameters const.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_type enum type_code)
	(make_symbol_completion_list_fn make_file_symbol_completion_list)
	(make_source_files_completion_list): Change prototype.
	* top.c (execute_command): Adjust to pass pointer to pointer to
	const char to lookup_cmd, and to deprecated_cmd_warning prototype
	change.
	(set_verbose): Make "cmdname" local const.
	* tracepoint.c (decode_agent_options): Make "exp" parameter const,
	and adjust.
	(validate_actionline): Make "line" parameter a pointer to const
	char, and adjust.
	(encode_actions_1): Make "action_exp" local const, and adjust.
	(encode_actions): Adjust.
	(replace_comma): Delete.
	(trace_dump_actions): Make "action_exp" and "next_comma" locals
	const, and adjust.  Don't frob the action string while splitting
	it at commas.  Instead, make a copy of each split substring in
	turn.
	(trace_dump_command): Adjust to validate_actionline prototype
	change.
	* tracepoint.h (decode_agent_options, decode_agent_options)
	(encode_actions, validate_actionline): Change prototypes.
	* valprint.h (output_command): Delete declaration.
	(output_command_const): Declare.
	* value.c (function_destroyer): Cast const away in xfree call.
@
text
@d641 16
d672 2
d678 3
a680 1
			NULL, NULL);
d697 2
d703 3
a705 1
			NULL, NULL);
d741 2
d747 3
a749 1
			NULL, NULL);
@


1.116
log
@gdb/
	* cli/cli-decode.c (add_setshow_zuinteger_unlimited_cmd): Change
	parameter VAR's type from "unsigned int" to "int".
	* command.h (var_zuinteger_unlimited): Update its comments.
	(add_setshow_zuinteger_unlimited_cmd): Update the declaration.
@
text
@d37 1
a37 1
static void undef_cmd_error (char *, char *);
d39 1
a39 1
static struct cmd_list_element *delete_cmd (char *name,
d46 1
a46 1
static struct cmd_list_element *find_cmd (char *command,
d192 1
a192 1
add_cmd (char *name, enum command_class class, void (*fun) (char *, int),
d281 1
a281 1
add_alias_cmd (char *name, char *oldname, enum command_class class,
d284 1
a284 3
  /* Must do this since lookup_cmd tries to side-effect its first
     arg.  */
  char *copied_name;
d288 2
a289 3
  copied_name = (char *) alloca (strlen (oldname) + 1);
  strcpy (copied_name, oldname);
  old = lookup_cmd (&copied_name, *list, "", 1, 1);
d333 1
a333 1
add_prefix_cmd (char *name, enum command_class class,
d361 1
a361 1
add_abbrev_prefix_cmd (char *name, enum command_class class,
d398 1
a398 1
add_set_or_show_cmd (char *name,
d428 1
a428 1
add_setshow_cmd_full (char *name,
d481 1
a481 1
add_setshow_enum_cmd (char *name,
d510 1
a510 1
add_setshow_auto_boolean_cmd (char *name,
d535 1
a535 1
add_setshow_boolean_cmd (char *name, enum command_class class, int *var,
d557 1
a557 1
add_setshow_filename_cmd (char *name, enum command_class class,
d579 1
a579 1
add_setshow_string_cmd (char *name, enum command_class class,
d598 1
a598 1
add_setshow_string_noescape_cmd (char *name, enum command_class class,
d620 1
a620 1
add_setshow_optional_filename_cmd (char *name, enum command_class class,
d647 1
a647 1
add_setshow_integer_cmd (char *name, enum command_class class,
d668 1
a668 1
add_setshow_uinteger_cmd (char *name, enum command_class class,
d689 1
a689 1
add_setshow_zinteger_cmd (char *name, enum command_class class,
d706 1
a706 1
add_setshow_zuinteger_unlimited_cmd (char *name,
d729 1
a729 1
add_setshow_zuinteger_cmd (char *name, enum command_class class,
d753 1
a753 1
delete_cmd (char *name, struct cmd_list_element **list,
d823 1
a823 1
add_info (char *name, void (*fun) (char *, int), char *doc)
d831 1
a831 1
add_info_alias (char *name, char *oldname, int abbrev_flag)
d839 1
a839 1
add_com (char *name, enum command_class class, void (*fun) (char *, int),
d848 1
a848 1
add_com_alias (char *name, char *oldname, enum command_class class,
d914 1
a914 1
help_cmd (char *command, struct ui_file *stream)
d917 1
d1185 1
a1185 1
find_cmd (char *command, int len, struct cmd_list_element *clist,
d1306 1
a1306 1
lookup_cmd_1 (char **text, struct cmd_list_element *clist,
d1312 1
a1312 1
  char *line = *text;
d1377 1
a1377 1
	deprecated_cmd_warning (&line);
d1424 1
a1424 1
undef_cmd_error (char *cmdtype, char *q)
d1449 1
a1449 1
lookup_cmd (char **line, struct cmd_list_element *list, char *cmdtype,
d1545 1
a1545 1
/* We are here presumably because an alias or command in *TEXT is
d1547 1
a1547 1
   function decodes *TEXT and potentially generates a warning message
d1552 1
a1552 1
   If alias wasn't used in *TEXT, and the command is deprecated:
d1568 1
a1568 1
deprecated_cmd_warning (char **text)
d1574 1
a1574 1
  if (!lookup_cmd_composition (*text, &alias, &prefix_cmd, &cmd))
d1642 1
a1642 1
lookup_cmd_composition (char *text,
d1739 2
a1740 1
complete_on_cmdlist (struct cmd_list_element *list, char *text, char *word,
d1810 1
a1810 2
		  char *text,
		  char *word)
@


1.115
log
@gdb/
	* cli/cli-decode.c (help_cmd): Remove the declaration of
	"cmdlist".
	(help_all): Likewise.
@
text
@d711 1
a711 1
				     unsigned int *var,
@


1.114
log
@Consistent use of (C) after "Copyright".

While writing the previous patch, I noticed that we're not consistent
with the (C) in the copyright header.  The maintainers manual prefers
having it, though also says it's optional.  We have over 10x more
files with (C) than without in gdb's code, so I spent a few minutes
grepping and fixing.  Funny enough, the testsuite has it backwards.
I'll leave that for another time.

gdb/
2013-02-12  Pedro Alves  <palves@@redhat.com>

	* amd64-darwin-tdep.c: Add (C) after Copyright.
	* cli/cli-cmds.h: Ditto.
	* cli/cli-decode.c: Ditto.
	* cli/cli-decode.h: Ditto.
	* cli/cli-dump.c: Ditto.
	* cli/cli-dump.h: Ditto.
	* cli/cli-interp.c: Ditto.
	* cli/cli-logging.c: Ditto.
	* cli/cli-script.c: Ditto.
	* cli/cli-script.h: Ditto.
	* cli/cli-setshow.c: Ditto.
	* cli/cli-setshow.h: Ditto.
	* cli/cli-utils.c: Ditto.
	* cli/cli-utils.h: Ditto.
	* config/alpha/nm-osf3.h: Ditto.
	* config/djgpp/djconfig.sh: Ditto.
	* config/i386/nm-fbsd.h: Ditto.
	* config/i386/nm-i386gnu.h: Ditto.
	* config/nm-linux.h: Ditto.
	* config/nm-nto.h: Ditto.
	* config/rs6000/nm-rs6000.h: Ditto.
	* config/sparc/nm-sol2.h: Ditto.
	* darwin-nat-info.c: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* gdb-demangle.h: Ditto.
	* i386-darwin-nat.c: Ditto.
	* i386-darwin-tdep.c: Ditto.
	* linux-fork.h: Ditto.
	* m32c-tdep.c: Ditto.
	* microblaze-linux-tdep.c: Ditto.
	* microblaze-rom.c: Ditto.
	* microblaze-tdep.c: Ditto.
	* microblaze-tdep.h: Ditto.
	* mips-linux-tdep.h: Ditto.
	* ppc-ravenscar-thread.c: Ditto.
	* ppc-ravenscar-thread.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* sparc-ravenscar-thread.c: Ditto.
	* sparc-ravenscar-thread.h: Ditto.
	* tilegx-linux-tdep.c: Ditto.
	* unwind_stop_reasons.def: Ditto.
	* windows-nat.h: Ditto.
	* xtensa-linux-tdep.c: Ditto.
	* xtensa-xtregs.c: Ditto.
	* regformats/regdat.sh: Ditto.
	* regformats/regdef.h: Ditto.

gdb/gdbserver/
2013-02-12  Pedro Alves  <palves@@redhat.com>

	* linux-xtensa-low.c: Ditto.
	* xtensa-xtregs.c: Ditto.
@
text
@a919 1
  extern struct cmd_list_element *cmdlist;
a1050 1
  extern struct cmd_list_element *cmdlist;
@


1.113
log
@	* cli/cli-decode.c (add_setshow_string_noescape_cmd): Return the
	set command.
	* command.h (add_setshow_string_noescape_cmd): Update.
	* corefile.c (set_gnutarget_command): Remove trailing whitespace.
	(complete_set_gnutarget): New function.
	(_initialize_core): Set the "set gnutarget" completer.
gdb/testsuite
	* gdb.base/completion.exp: Add "set gnutarget" test.
@
text
@d3 1
a3 1
   Copyright (c) 1986-2013 Free Software Foundation, Inc.
@


1.112
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d600 1
a600 1
void
d610 2
d616 2
a617 1
			NULL, NULL);
@


1.111
log
@	Avoid memory leaks on struct cmd_list_element.doc field.
	* cli/cli-decode.c (add_alias_cmd): Make a copy of doc field
	if flags contains DOC_ALLOCATED.
	(add_setshow_cmd_full): Add DOC_ALLOCATED to set and show
	flags.
	(delete_cmd): Handle DOC_ALLOCATED flag.
	* cli/cli-decode.h (DOC_ALLOCATED): New macro for use
	in flags filed of struct cmd_list_element.
	(struct cmd_list_element): Document new flag item.
@
text
@d3 1
a3 2
   Copyright (c) 1986, 1989-1991, 1998, 2000-2002, 2004, 2007-2012 Free
   Software Foundation, Inc.
@


1.110
log
@gdb: include help aliases in help command completion

There are a bunch of aliases that get used with help, but the current
command completion logic does not include those when doing completions.

Since the framework is already mostly in place, extend complete_on_cmdlist
slightly to pass down the ignore_help_classes flag like is done with the
existing lookup command logic.

Now you can do:
	(gdb) help use<tab>
and get back:
	(gdb) help user-defined

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d309 7
d461 2
d470 1
d782 2
@


1.109
log
@gdb/
	* cli/cli-decode.c (add_setshow_zuinteger_unlimited_cmd): New.
	Update comment to add_setshow_integer_cmd.
	* cli/cli-setshow.c (do_set_command): Handle case
	'var_zuinteger_unlimited'.
	(do_show_command): Likewise.
	* cli/cli-cmds.c (init_cmds): Call add_setshow_zuinteger_unlimited_cmd
	for command 'remotetimeout'.
	* command.h (enum var_types): New zuinteger_unlimited.  Update comment
	to var_integer.
	* source.c (_initialize_source): Call add_setshow_zuinteger_unlimited_cmd
	for command 'set listsize'.

gdb/doc/
	* gdb.texinfo (List): Describe the meaning of 0 and -1 in
	'set listsize'.

gdb/testsuite/
	* gdb.base/list.exp (set_listsize): Don't set arg to "unlimited"
	when it is less than 0.
@
text
@d1729 2
a1730 1
complete_on_cmdlist (struct cmd_list_element *list, char *text, char *word)
d1747 1
a1747 1
	    && (ptr->func
@


1.108
log
@gdb/
	* cli/cli-decode.c (print_doc_line): Keep skipping '.' and ',' not
	followed by a whitespace.
@
text
@d635 2
a636 1
   value.  SET_DOC and SHOW_DOC are the documentation strings.  */
d696 19
@


1.107
log
@gdb/

	* cli/cli-decode.c (set_cmd_prefix): New.
	(lookup_cmd_for_prefixlist): New.
	(add_prefix_cmd): Call set_cmd_prefix and update field 'prefix'
	of each cmd_list_element in *prefixlist.
	(add_setshow_cmd_full): set_cmd_prefix.
	(add_alias_cmd): Likewise.
	* cli/cli-decode.h (struct cmd_list_element) <prefix>: New field.
	Declare 'auto_boolean_enums'.
	* cli/cli-setshow.c: Include "observer.h".
	(notify_command_param_changed_p): New.
	(add_setshow_auto_boolean_cmd): Move auto_boolean_enums out.
	Remove 'static'.
	(do_setshow_command): Split it to ...
	(do_set_command, do_show_command): ... them.  New.
	(do_set_command): Call observer_notify_command_param_changed if
	notify_command_param_changed_p returns true.
	(cmd_show_list): Caller update.
	* auto-load.c (set_auto_load_cmd): Likewise.
	* remote.c (show_remote_cmd): Likewise.
	* cli/cli-setshow.h: Update declarations.
	* top.c (execute_command): Call do_set_command and do_show_command.

	* NEWS: Mention new MI notification.
	* mi/mi-interp.c: Declare mi_command_param_changed.
	(mi_interpreter_init): Attach mi_command_param_changed to
	observer command_param_changed.
	(mi_command_param_changed): New.
	Remove mi_suppress_breakpoint_notifications.
	Define global variable mi_suppress_notification.
	(mi_breakpoint_created): Update.
	(mi_breakpoint_deleted): Likewise.
	(mi_breakpoint_modified): Likewise.
	* mi/mi-main.c (mi_cmd_execute): Likewise.  Check command
	'gdb-set' and set mi_suppress_notification.
	* mi/mi-main.h: (mi_suppress_notification): New struct.

gdb/doc/

	* observer.texi: New observer command_param_changed.
	* gdb.texinfo (GDB/MI Async Records): Doc for '=cmd-param-changed'.

gdb/testsuite/

	* gdb.mi/mi-cmd-param-changed.exp: New.
	* gdb.mi/mi-cli.exp: Update for MI notification "=cmd-param-changed".
	* gdb.mi/mi-var-rtti.exp, gdb.mi/mi2-cli.exp: Likewise.
	* gdb.mi/mi2-prompt.exp: Likewise.
@
text
@d1071 2
d1074 2
a1075 1
  while (*p && *p != '\n' && *p != '.' && *p != ',')
@


1.106
log
@	* ada-lang.c (ada_make_symbol_completion_list): Return a VEC.
	* breakpoint.c (catch_syscall_completer): Return a VEC.
	* cli/cli-cmds.c (complete_command): Update.
	* cli/cli-decode.c (complete_on_cmdlist): Return a VEC.
	(complete_on_enum): Likewise.
	* command.h: Include gdb_vecs.h.
	(completer_ftype): Change return type.
	(complete_on_cmdlist, complete_on_enum): Likewise.
	* completer.c (noop_completer, filename_completer)
	(location_completer): Return a VEC.
	(add_struct_fields): Remove 'nextp' argument.  Change 'output'
	to a VEC.
	(expression_completer, complete_line_internal, complete_line)
	(command_completer): Return a VEC.
	(gdb_completion_word_break_characters, line_completion_function):
	Update.
	* completer.h: Include gdb_vecs.h.
	(complete_line, noop_completer, filename_completer)
	(expression_completer, location_completer, command_completer):
	Update.
	* f-lang.c (f_word_break_characters): Return a VEC.
	* interps.c (interpreter_completer): Return a VEC.
	* language.h (struct language_defn)
	<la_make_symbol_completion_list>: Return a VEC.
	* python/py-cmd.c (cmdpy_completer): Return a VEC.
	* symtab.c (free_completion_list): Take a VEC.
	(return_val_size, return_val_index): Remove.
	(return_val): Now a VEC.
	(completion_list_add_name): Update.
	(default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_list_fn, make_file_symbol_completion_list):
	Return a VEC.
	(add_filename_to_list): Update.
	(struct add_partial_filename_data) <list_used, list_alloced>: Remove.
	<list>: Now a VEC.
	(maybe_add_partial_symtab_filename): Update.
	(make_source_files_completion_list): Return a VEC.
	* symtab.h (default_make_symbol_completion_list_break_on)
	(default_make_symbol_completion_list, make_symbol_completion_list)
	(make_symbol_completion_list_fn, make_file_symbol_completion_list)
	(make_source_files_completion_list): Update.
@
text
@d55 47
d243 1
d319 2
d337 1
d342 10
d456 3
d497 2
a513 1
  static const char *auto_boolean_enums[] = { "on", "off", "auto", NULL };
@


1.106.2.1
log
@gdb/
	* cli/cli-decode.c (print_doc_line): Keep skipping '.' and ',' not
	followed by a whitespace.
@
text
@a1005 2
  /* Keep printing '.' or ',' not followed by a whitespace for embedded strings
     like '.gdbinit'.  */
d1007 1
a1007 2
  while (*p && *p != '\n'
	 && ((*p != '.' && *p != ',') || (p[1] && !isspace (p[1]))))
@


1.105
log
@	* breakpoint.c (add_catch_command): Use completer_ftype.
	* breakpoint.h: Include command.h.
	(add_catch_command): Use completer_ftype.
	* cli/cli-decode.c (set_cmd_completer): Use completer_ftype.
	* cli/cli-decode.h (struct cmd_list_element) <completer>:
	Use completer_ftype.
	* command.h (completer_ftype): New typedef.
	(set_cmd_completer): Use it.
	* python/py-cmd.c (struct cmdpy_completer) <completer>: Use
	completer_ftype.
@
text
@d1640 1
a1640 1
char **
d1644 1
a1644 3
  char **matchlist;
  int sizeof_matchlist;
  int matches;
a1648 4
  sizeof_matchlist = 10;
  matchlist = (char **) xmalloc (sizeof_matchlist * sizeof (char *));
  matches = 0;

d1653 1
a1653 1
  for (pass = 0; matches == 0 && pass < 2; ++pass)
d1661 2
d1672 1
a1672 10
	    if (matches == sizeof_matchlist)
	      {
		sizeof_matchlist *= 2;
		matchlist = (char **) xrealloc ((char *) matchlist,
						(sizeof_matchlist
						 * sizeof (char *)));
	      }

	    matchlist[matches] = (char *)
	      xmalloc (strlen (word) + strlen (ptr->name) + 1);
d1674 1
a1674 1
	      strcpy (matchlist[matches], ptr->name);
d1678 1
a1678 1
		strcpy (matchlist[matches], ptr->name + (word - text));
d1683 3
a1685 3
		strncpy (matchlist[matches], word, text - word);
		matchlist[matches][text - word] = '\0';
		strcat (matchlist[matches], ptr->name);
d1687 1
a1687 1
	    ++matches;
a1694 12
  if (matches == 0)
    {
      xfree (matchlist);
      matchlist = 0;
    }
  else
    {
      matchlist = (char **) xrealloc ((char *) matchlist, ((matches + 1)
							* sizeof (char *)));
      matchlist[matches] = (char *) 0;
    }

d1708 1
a1708 1
char **
d1713 1
a1713 3
  char **matchlist;
  int sizeof_matchlist;
  int matches;
a1717 4
  sizeof_matchlist = 10;
  matchlist = (char **) xmalloc (sizeof_matchlist * sizeof (char *));
  matches = 0;

d1721 1
a1721 7
	if (matches == sizeof_matchlist)
	  {
	    sizeof_matchlist *= 2;
	    matchlist = (char **) xrealloc ((char *) matchlist,
					    (sizeof_matchlist
					     * sizeof (char *)));
	  }
d1723 1
a1723 2
	matchlist[matches] = (char *)
	  xmalloc (strlen (word) + strlen (name) + 1);
d1725 1
a1725 1
	  strcpy (matchlist[matches], name);
d1729 1
a1729 1
	    strcpy (matchlist[matches], name + (word - text));
d1734 3
a1736 3
	    strncpy (matchlist[matches], word, text - word);
	    matchlist[matches][text - word] = '\0';
	    strcat (matchlist[matches], name);
d1738 1
a1738 1
	++matches;
a1740 12
  if (matches == 0)
    {
      xfree (matchlist);
      matchlist = 0;
    }
  else
    {
      matchlist = (char **) xrealloc ((char *) matchlist, ((matches + 1)
							   * sizeof (char *)));
      matchlist[matches] = (char *) 0;
    }

@


1.104
log
@	* cli/cli-decode.c (print_doc_line): Use stream instead of
	current_uiout.
@
text
@d122 1
a122 3
set_cmd_completer (struct cmd_list_element *cmd,
		   char **(*completer) (struct cmd_list_element *self,
					char *text, char *word))
@


1.103
log
@back out previous change
@
text
@d1021 1
a1021 1
  ui_out_text (current_uiout, line_buffer);
@


1.102
log
@	* cli/cli-decode.c (print_doc_line): Use stream instead of
	current_uiout.
@
text
@d1021 1
a1021 1
  ui_out_text (stream, line_buffer);
@


1.101
log
@gdb/
	Code cleanup: Make 1440 bytes of data segment read-only.
	* arch-utils.c (endian_enum): Make it const char *const [].
	* arm-tdep.c (fp_model_strings, arm_abi_strings, arm_mode_strings):
	Likewise.
	* breakpoint.c (always_inserted_enums): Likewise.
	* cli/cli-cmds.c (script_ext_enums): Likewise.
	* cli/cli-decode.c (add_setshow_enum_cmd, complete_on_enum): Make the
	enumlist parameter const char *const *.
	* cli/cli-decode.h (struct cmd_list_element): Make the enums field
	const char *const *.
	* command.h (complete_on_enum, add_setshow_enum_cmd): Make the enumlist
	parameter const char *const *.
	* cris-tdep.c (cris_modes): Make it const char *const [].
	* filesystem.c (target_file_system_kinds): Likewise.
	* i386-tdep.c (valid_flavors, valid_conventions): Likewise.
	* infrun.c (follow_fork_mode_kind_names, follow_exec_mode_names)
	(can_use_displaced_stepping_enum, scheduler_enums)
	(exec_direction_names): Likewise.
	* language.c (_initialize_language): Make the type_or_range_names and
	case_sensitive_names variables const char *const [].
	* mips-tdep.c (mips_abi_strings): Make it const char *const [].
	* python/python.c (python_excp_enums): Likewise.
	* remote.c (interrupt_sequence_modes): Likewise.
	* rs6000-tdep.c (powerpc_vector_strings): Likewise.
	* serial.c (logbase_enums): Likewise.
	* sh-tdep.c (sh_cc_enum): Likewise.
	* stack.c (print_frame_arguments_choices, print_entry_values_choices):
	Likewise.
	* symtab.c (multiple_symbols_modes): Likewise.
	* tui/tui-win.c (tui_border_kind_enums, tui_border_mode_enums):
	Likewise.
	* utils.c (internal_problem_modes): Likewise.
@
text
@d1021 1
a1021 1
  ui_out_text (current_uiout, line_buffer);
@


1.100
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d415 1
a415 1
		      const char *enumlist[],
d1736 1
a1736 1
complete_on_enum (const char *enumlist[],
@


1.99
log
@	Make "!" an alias for "shell".
	* NEWS: Add mention.
	* cli/cli-cmds.c (init_cli_cmds): Remove xdb_commands condition on
	adding "!" command, always add it.
	* cli/cli-decode.c (find_command_name_length): Recognize "!" as a
	command of length one.

	doc/
	* gdb.texinfo (Shell Commands): Document "!".

	testsuite/
	* gdb.base/shell.exp: New file.
@
text
@d3 2
a4 2
   Copyright (c) 1986, 1989, 1990, 1991, 1998, 2000, 2001, 2002, 2004, 2007,
   2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.99.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 2
   Copyright (c) 1986, 1989-1991, 1998, 2000-2002, 2004, 2007-2012 Free
   Software Foundation, Inc.
@


1.98
log
@	Add new "alias" command.
	* NEWS: Mention new command.
	* command.h (valid_user_defined_cmd_name_p): Declare.
	* defs.h (make_cleanup_dyn_string_delete): Declare.
	* utils.c: #include "dyn-string.h".
	(do_dyn_string_delete, make_cleanup_dyn_string_delete): New functions.
	* cli/cli-cmds.c: #include "dyn-string.h".
	(argv_to_dyn_string, valid_command_p, alias_command): New functions.
	(init_cli_cmds): Add new command.
	* cli/cli-decode.c (valid_user_defined_cmd_name_p): New function.

	doc/
	* gdb.texinfo (Extending GDB): Document alias command.

	testsuite/
	* gdb.base/alias.exp: Add tests for alias command.
@
text
@d1130 5
d1139 1
a1139 1
	 || (xdb_commands && (*p == '!' || *p == '/' || *p == '?')))
@


1.97
log
@	* cli/cli-decode.c (add_cmd): Add comment.
@
text
@a128 1

d1140 28
@


1.96
log
@2011-08-04  Pedro Alves  <pedro@@codesourcery.com>

	* ui-out.h (uiout): Rename to ...
	(current_uiout): ... this.
	* ui-out.c (uiout): Rename to ...
	(current_uiout): ... this.
	* ada-lang.c (print_it_exception, print_one_exception)
	(print_mention_exception): Adjust.
	* breakpoint.c (watchpoint_check): Adjust.
	(print_breakpoint_location, print_one_breakpoint, breakpoint_1)
	(default_collect_info, watchpoints_info, print_one_catch_fork)
	(print_one_catch_vfork, print_one_catch_syscall)
	(print_one_catch_exec, mention, print_it_ranged_breakpoint)
	(print_one_ranged_breakpoint, print_mention_ranged_breakpoint)
	(print_it_watchpoint, print_mention_watchpoint)
	(print_it_masked_watchpoint, print_mention_masked_watchpoint)
	(print_it_exception_catchpoint, print_one_exception_catchpoint)
	(print_mention_exception_catchpoint, say_where, bkpt_print_it)
	(bkpt_print_mention, momentary_bkpt_print_it)
	(tracepoint_print_mention, update_static_tracepoint)
	(tracepoints_info, save_breakpoints): Adjust.
	* cli-out.c (field_separator): Adjust.
	* cp-abi.c (list_cp_abis, show_cp_abi_cmd): Adjust.
	* exceptions.c (catch_exceptions_with_msg, catch_errors): Adjust.
	* frame.c (get_current_frame): Adjust.
	* infcmd.c (run_command_1, print_return_value): Adjust.
	* inferior.c (inferior_command, info_inferiors_command): Adjust.
	* infrun.c (print_end_stepping_range_reason): Adjust.
	(print_signal_exited_reason, print_exited_reason): Adjust.
	(print_signal_received_reason, print_no_history_reason): Adjust.
	* interps.c (interp_set): Adjust.
	* osdata.c (info_osdata_command): Adjust.
	* progspace.c (maintenance_info_program_spaces_command): Adjust.
	* remote-fileio.c (remote_fileio_request): Adjust.
	* remote.c (show_remote_cmd): Adjust.
	* solib.c (info_sharedlibrary_command): Adjust.
	* source.c (print_source_lines_base): Adjust.
	* stack.c (print_stack_frame): Adjust.
	(do_gdb_disassembly, print_frame_info, print_frame): Adjust.
	* symfile-mem.c (add_vsyscall_page): Adjust.
	* symfile.c (load_progress, generic_load)
	(print_transfer_performance): Adjust.
	* thread.c (info_threads_command, restore_selected_frame)
	(thread_command): Adjust.
	* top.c (make_cleanup_restore_ui_file): Adjust.
	* tracepoint.c (tvariables_info_1, trace_status_mi, tfind_1)
	(print_one_static_tracepoint_marker): Adjust.
	* cli/cli-cmds.c (print_disassembly): Adjust.
	* cli/cli-decode.c (print_doc_line): Adjust.
	* cli/cli-interp.c (safe_execute_command): Adjust.
	* cli/cli-logging.c (set_logging_redirect, pop_output_files)
	(handle_redirections): Adjust.
	* cli/cli-script.c (show_user_1): Adjust.
	* cli/cli-setshow.c (do_setshow_command, cmd_show_list): Adjust.
	* mi/mi-cmd-break.c (breakpoint_notify): Adjust.
	* mi/mi-cmd-disas.c (mi_cmd_disassemble): Adjust.
	* mi/mi-cmd-env.c (mi_cmd_env_pwd, mi_cmd_env_path)
	(mi_cmd_env_dir): Adjust.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(print_partial_file_name, mi_cmd_file_list_exec_source_files): Adjust.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_depth, mi_cmd_stack_list_args)
	(list_args_or_locals): Adjust.
	* mi/mi-cmd-var.c (print_varobj, mi_cmd_var_create)
	(mi_cmd_var_delete, mi_cmd_var_set_format, mi_cmd_var_set_frozen)
	(mi_cmd_var_show_format, mi_cmd_var_info_num_children)
	(mi_cmd_var_list_children, mi_cmd_var_info_type)
	(mi_cmd_var_info_path_expression, mi_cmd_var_info_expression)
	(mi_cmd_var_show_attributes, mi_cmd_var_evaluate_expression)
	(mi_cmd_var_assign, mi_cmd_var_update, varobj_update_one): Adjust.
	* mi/mi-interp.c (mi_on_normal_stop): Adjust.
	* mi/mi-main.c (mi_cmd_gdb_exit, mi_cmd_thread_select)
	(mi_cmd_thread_list_ids, mi_cmd_thread_info, print_one_inferior)
	(list_available_thread_groups, mi_cmd_list_thread_groups)
	(mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers)
	(mi_cmd_data_list_register_values, get_register)
	(mi_cmd_data_evaluate_expression, mi_cmd_data_read_memory)
	(mi_cmd_data_read_memory_bytes, mi_cmd_list_features)
	(mi_cmd_list_target_features, mi_cmd_add_inferior)
	(mi_execute_command, mi_load_progress): Adjust.
	* mi/mi-symbol-cmds.c (mi_cmd_symbol_list_lines): Adjust.
	* python/py-auto-load.c (print_script, info_auto_load_scripts):
	Adjust.
	* python/py-breakpoint.c (bppy_get_commands): Adjust.
	* tui/tui-interp.c (tui_command_loop): Adjust.
	* tui/tui-io.c (tui_setup_io, tui_initialize_io): Adjust.
@
text
@d131 1
@


1.95
log
@gdb/
	* ada-lang.c: Fix typos.
	* amd64-tdep.c: Likewise.
	* breakpoint.c: Likewise.
	* cli/cli-decode.c: Likewise.
	* findcmd.c: Likewise.
	* inline-frame.c: Likewise.
	* mi/mi-main.c: Likewise.
	* minsyms.c: Likewise.
	* monitor.c: Likewise.
	* monitor.h: Likewise.
	* prologue-value.c: Likewise.
	* reverse.c: Likewise.
	* s390-tdep.c: Likewise.

gdb/testsuite/
	* gdb.base/call-sc.c: Likewise.
	* gdb.base/ifelse.exp: Likewise.
	* gdb.base/structs.c: Likewise.

gdb/doc/
	* gdb.texinfo: Likewise.
@
text
@d1021 1
a1021 1
  ui_out_text (uiout, line_buffer);
@


1.94
log
@gdb
	* windows-tdep.c (windows_xfer_shared_library):
	* windows-nat.c (get_module_name, windows_make_so):
	* v850-tdep.c (v850_handle_pushm):
	* utils.c (null_cleanup, gdb_realpath):
	* ui-out.c (get_next_header):
	* tracepoint.c (clear_traceframe_info):
	* symtab.c (lookup_symtab):
	* serial.h (struct serial_ops):
	* mipsread.c (read_alphacoff_dynamic_symtab):
	* infcmd.c (print_return_value):
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address):
	* f-exp.y (parse_number):
	* exceptions.c (catch_exceptions):
	* dummy-frame.c (dummy_frame_this_id):
	* defs.h (struct cleanup):
	* breakpoint.c (disable_breakpoints_in_unloaded_shlib):
	* arm-tdep.c (arm_push_dummy_call):
	* amd64-tdep.h (amd64_collect_xsave):
	* amd64-tdep.c (amd64_collect_xsave):
	* alpha-tdep.c (alpha_heuristic_frame_unwind_cache):
	* README (typing): Remove duplicate words.
	* cli/cli-decode.c (lookup_cmd_composition): Add comma.
	* infrun.c (siginfo_value_read): Fix typo.
	* solib-frv.c (frv_fdpic_find_global_pointer): Likewise.
	* top.c (source_line_number): Add comma.
gdb/doc
	* gdbint.texinfo (Register Information Functions): Remove
	duplicate "the".
	* gdb.texinfo (Emacs): Remove duplicate "to".
	(GDB/MI Variable Objects): Remove duplicate "the".
	(General Query Packets): Likewise.
gdb/testsuite
	* gdb.mi/mi-nsmoribund.exp:
	* gdb.hp/gdb.objdbg/objdbg01.exp:
	* gdb.base/structs.exp (test_struct_returns):
	* gdb.base/call-sc.exp (test_scalar_returns):
	* gdb.base/bigcore.exp: Remove duplicate words.
gdb/gdbserver
	* win32-low.c (handle_load_dll): Remove duplicate "the".
@
text
@d1503 1
a1503 1
   If LINE is a postfix command (i.e. one that is preceeded by a prefix
@


1.93
log
@2011-03-11  Michael Snyder  <msnyder@@vmware.com>

	* cli/cli-decode.h (CMD_LIST_AMBIGUOUS): Define.
	* cli/cli-decode.c (lookup_cmd_1): Use CMD_LIST_AMBIGUOUS.
	(lookup_cmd): Test for CMD_LIST_AMBIGUOUS.
	* completer.c (complete_line_internal): Use CMD_LIST_AMBIGUOUS.
	* top.c (set_verbose): Use CMD_LIST_AMBIGUOUS.
@
text
@d1531 1
a1531 1
      /* Go through as many command lists as we need to 
@


1.92
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* cli/cli-cmds.c: Shorten lines of >= 80 columns.
	* cli/cli-decode.c: Ditto.
	* cli/cli-dump.c: Ditto.
	* cli/cli-logging.c: Ditto.
	* cli/cli-script.c: Ditto.
	* cli/cli-setshow.c: Ditto.
	* common/signals.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-disas.c: Ditto.
	* mi/mi-cmd-stack.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-cmds.c: Ditto.
	* mi/mi-common.h: Ditto.
	* mi/mi-console.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
	* osf-share/cma_attr.c: Ditto.
	* osf-share/cma_deb_core.h: Ditto.
	* osf-share/cma_debug_client.h: Ditto.
	* osf-share/cma_handle.h: Ditto.
	* osf-share/cma_mutex.h: Ditto.
	* osf-share/cma_stack_int.h: Ditto.
	* osf-share/cma_tcb_defs.h: Ditto.
	* python/py-auto-load.c: Ditto.
	* python/py-breakpoint.c: Ditto.
	* python/py-cmd.c: Ditto.
	* python/py-frame.c: Ditto.
	* python/py-objfile.c: Ditto.
	* python/py-param.c: Ditto.
	* python/py-progspace.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-value.c: Ditto.
	* python/python-internal.h: Ditto.
	* python/python.c: Ditto.
	* tui/tui-data.c: Ditto.
	* tui/tui-disasm.c: Ditto.
	* tui/tui-hooks.c: Ditto.
	* tui/tui-io.c: Ditto.
	* tui/tui-layout.c: Ditto.
	* tui/tui-regs.c: Ditto.
	* tui/tui-source.c: Ditto.
	* tui/tui-stack.c: Ditto.
	* tui/tui-win.c: Ditto.
	* tui/tui-windata.c: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d1231 1
a1231 1
      return (struct cmd_list_element *) -1;	/* Ambiguous.  */
d1264 1
a1264 1
      else if (c == (struct cmd_list_element *) -1)
d1349 1
a1349 1
  else if (c == (struct cmd_list_element *) -1)
d1572 1
a1572 1
      if (*cmd == (struct cmd_list_element *) -1)
@


1.91
log
@run copyright.sh for 2011.
@
text
@d282 2
a283 1
add_prefix_cmd (char *name, enum command_class class, void (*fun) (char *, int),
d1382 2
a1383 1
		if (strlen (ambbuf) + strlen (c->name) + 6 < (int) sizeof ambbuf)
d1756 1
a1756 1
							* sizeof (char *)));
@


1.90
log
@2010-12-28  Michael Snyder  <msnyder@@vmware.com>

	* command.h: Comment clean-up.
	* cli/cli-cmds.c: Ditto.
	* cli/cli-cmds.h: Ditto.
	* cli/cli-decode.c: Ditto.
	* cli/cli-decode.h: Ditto.
	* cli/cli-dump.c: Ditto.
	* cli/cli-interp.c: Ditto.
	* cli/cli-logging.c: Ditto.
	* cli/cli-script.c: Ditto.
	* cli/cli-setshow.c: Ditto.
	* cli/cli-setshow.h: Ditto.
@
text
@d4 1
a4 1
   2008, 2009, 2010 Free Software Foundation, Inc.
@


1.89
log
@2010-05-17  Michael Snyder  <msnyder@@vmware.com>

	* cli/cli-cmds.c: White space.
	* cli/cli-decode.c: White space.
	* cli/cli-dump.c: White space.
	* cli/cli-interp.c: White space.
	* cli/cli-logging.c: White space.
	* cli/cli-script.c: White space.
	* cli/cli-setshow.c: White space.
@
text
@d31 1
a31 1
#include "tui/tui.h"		/* For tui_active et.al.   */
d36 1
a36 1
/* Prototypes for local functions */
d142 1
a142 1
   Add this command to command list *LIST.  
d145 1
a145 1
   of *LIST). */
d213 2
a214 2
   REPLACEMENT is the name of the command which should be used in place
   of this command, or NULL if no such command exists.
d217 2
a218 2
   since gdb may not have gotten around to adding REPLACEMENT when this
   function is called.
d239 2
a240 1
  /* Must do this since lookup_cmd tries to side-effect its first arg */
d276 4
a279 4
/* Like add_cmd but adds an element for a command prefix:
   a name that should be followed by a subcommand to be looked up
   in another command list.  PREFIXLIST should be the address
   of the variable containing that list.  */
d295 1
a295 1
/* Like add_prefix_cmd but sets the abbrev_flag on the new command. */
d723 1
a723 1
/* Shorthands to the commands above. */
d764 2
a765 1
apropos_cmd (struct ui_file *stream, struct cmd_list_element *commandlist,
d771 1
a771 1
  /* Walk through the commands */
d774 1
a774 1
      returnvalue = -1; /*Needed to avoid double printing*/
d777 1
a777 1
	  /* Try to match against the name*/
d788 1
a788 1
	  /* Try to match against documentation */
d795 3
a797 4
      /* Check if this command has subcommands and is not an abbreviation.
	 We skip listing subcommands of abbreviations in order to avoid
	 duplicates in the output.
       */
d801 1
a801 2
	     passing the right prefix in.
	  */
d808 9
a816 9
 *     1) I want documentation on *this string* (usually called by
 * "help commandname").
 *     2) I want documentation on *this list* (usually called by
 * giving a command that requires subcommands.  Also called by saying
 * just "help".)
 *
 *   I am going to split this into two seperate comamnds, help_cmd and
 * help_list. 
 */
d860 1
a860 1
  /* If this is a prefix command, print it's subcommands */
d864 1
a864 1
  /* If this is a class name, print all of the commands in the class */
d901 2
a902 1
  /* If CMDTYPE is "foo ", CMDTYPE1 gets " foo" and CMDTYPE2 gets "foo sub"  */
d945 1
a945 1
		  "for commands related to \"word\".\n", stream);		    
d961 2
a962 1
      /* If this is a class name, print all of the commands in the class */
d1025 1
a1025 1
   of all prefixed subcommands. */
d1039 1
a1039 1
       most often we won't see anything. */
d1077 2
a1078 1
	help_cmd_list (*c->prefixlist, class, c->prefixname, recurse, stream);
d1085 1
a1085 1
   found in nfound */
d1118 11
a1128 7
  /* Some characters are only used for TUI specific commands. However, they
     are always allowed for the sake of consistency.
     The XDB compatibility characters are only allowed when using the right
     mode because they clash with other GDB commands - specifically '/' is
     used as a suffix for print, examine and display.
     Note that this is larger than the character set allowed when creating
     user-defined commands.  */
d1195 1
a1195 1
     it's length is len).  We copy this into a local temporary */
d1207 2
a1208 4
  /* 
     ** We didn't find the command in the entered case, so lower case it
     ** and search again.
   */
d1233 1
a1233 1
  /* We've matched something on this list.  Move text pointer forward. */
d1239 2
a1240 2
      /* We drop the alias (abbreviation) in favor of the command it is
       pointing to.  If the alias is deprecated, though, we need to
d1244 1
a1244 1
       flags */
d1265 2
a1266 2
	  /* We've gotten this far properly, but the next step
	     is ambiguous.  We need to set the result list to the best
d1270 1
a1270 1
	      /* This used to say *result_list = *found->prefixlist
d1272 2
a1273 2
	         at the top of this function to clarify what is supposed
	         to be going on.  */
d1414 4
a1417 4
/* We are here presumably because an alias or command in *TEXT is 
   deprecated and a warning message should be generated.  This function
   decodes *TEXT and potentially generates a warning message as outlined
   below.
d1427 2
a1428 2
   If alias was used and command is deprecated (regardless of whether the
   alias itself is deprecated:
d1444 1
a1444 1
    /* return if text doesn't evaluate to a command */
d1449 1
a1449 1
    /* return if nothing is deprecated */
d1470 2
a1471 2
  /* If it is only the alias that is deprecated, we want to indicate the
     new alias, otherwise we'll indicate the new command.  */
d1488 1
a1488 1
  /* We've warned you, now we'll keep quiet */
d1496 1
a1496 2

/* Look up the contents of LINE as a command in the command list 'cmdlist'. 
d1530 1
a1530 1
	 to find the command TEXT refers to. */
d1556 2
a1557 2
      /* We didn't find the command in the entered case, so lower case it
	 and search again.
d1581 2
a1582 2
	      /* cmd was actually an alias, we note that an alias was used 
		 (by assigning *alais) and we set *cmd.  */
d1600 1
a1600 1
   possible completions in LIST of TEXT.  
d1603 2
a1604 2
   returned relative to this position.  For example, suppose TEXT is "foo"
   and we want to complete to "foobar".  If WORD is "oo", return
d1693 1
a1693 1
   possible completions in CMD of TEXT.  
d1762 1
a1762 1
/* check function pointer */
d1770 1
a1770 1
/* call the command function */
@


1.88
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* cli-dump.c (dump_memory_to_file): Delete unused variable.
	(restore_binary_file): Delete unused variable.
	* cli-decode.c (deprecated_cmd_warning): Delete unused variables.
	* cli-script.c (define_command): Delete unused variables.
	(recurse_read_control_structure): Delete unused variable.
	(script_from_file): Delete unused variable.
	* cli-cmds.c (complete_command): Delete unused variable.
	(disassemble_command): Delete unused variable.
@
text
@d152 1
a152 1
  = (struct cmd_list_element *) xmalloc (sizeof (struct cmd_list_element));
d243 1
d254 1
d287 1
d303 1
d343 1
d424 1
d450 1
d474 1
d496 1
d764 1
a764 1
			 struct re_pattern_buffer *regex, char *prefix)
d768 1
d776 2
a777 1
	  returnvalue=re_search(regex,c->name,strlen(c->name),0,strlen(c->name),NULL);
d1209 1
d1351 1
a1351 1
      (last_list ? *(last_list->prefixlist) : list);
d1465 2
a1466 2
  /* if it is only the alias that is deprecated, we want to indicate the
     new alias, otherwise we'll indicate the new command */
d1471 1
a1471 1
      printf_filtered ("Use '%s'.\n\n", alias->replacement);
d1473 1
a1473 1
      printf_filtered ("No alternative known.\n\n");
d1478 1
a1478 1
      printf_filtered ("Use '%s'.\n\n", cmd->replacement);
d1480 1
a1480 1
      printf_filtered ("No alternative known.\n\n");
d1516 1
d1526 1
a1526 1
       to find the command TEXT refers to. */
d1531 1
a1531 1
      (text)++;
d1540 2
a1541 2
      /* text is the start of the first command word to lookup (and
       it's length is len).  We copy this into a local temporary */
d1553 1
a1553 1
       and search again.
d1556 9
a1564 8
      {
        for (tmp = 0; tmp < len; tmp++)
          {
            char x = command[tmp];
            command[tmp] = isupper (x) ? tolower (x) : x;
          }
        *cmd = find_cmd (command, len, cur_list, 1, &nfound);
      }
d1567 3
a1569 3
      {
        return 0;              /* ambiguous */
      }
d1572 1
a1572 1
      return 0;                /* nothing found */
d1574 10
a1583 11
      {
        if ((*cmd)->cmd_pointer)
          {
            /* cmd was actually an alias, we note that an alias was used 
               (by assigning *alais) and we set *cmd. 
             */
            *alias = *cmd;
            *cmd = (*cmd)->cmd_pointer;
          }
        *prefix_cmd = prev_cmd;
      }
d1585 1
a1585 1
      cur_list = *(*cmd)->prefixlist;
d1587 1
a1587 1
      return 1;
@


1.87
log
@gdb
	* cli/cli-decode.c (complete_on_cmdlist): Make two passes over the
	command list.
gdb/testsuite
	* gdb.base/completion.exp: Add tests for completion and deprecated
	commands.
@
text
@a1424 2
  struct cmd_list_element *c;
  char *type;
@


1.86
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d1600 2
d1607 52
a1658 32
  for (ptr = list; ptr; ptr = ptr->next)
    if (!strncmp (ptr->name, text, textlen)
	&& !ptr->abbrev_flag
	&& (ptr->func
	    || ptr->prefixlist))
      {
	if (matches == sizeof_matchlist)
	  {
	    sizeof_matchlist *= 2;
	    matchlist = (char **) xrealloc ((char *) matchlist,
					    (sizeof_matchlist
					     * sizeof (char *)));
	  }

	matchlist[matches] = (char *)
	  xmalloc (strlen (word) + strlen (ptr->name) + 1);
	if (word == text)
	  strcpy (matchlist[matches], ptr->name);
	else if (word > text)
	  {
	    /* Return some portion of ptr->name.  */
	    strcpy (matchlist[matches], ptr->name + (word - text));
	  }
	else
	  {
	    /* Return some of text plus ptr->name.  */
	    strncpy (matchlist[matches], word, text - word);
	    matchlist[matches][text - word] = '\0';
	    strcat (matchlist[matches], ptr->name);
	  }
	++matches;
      }
@


1.85
log
@	ARI fix: OP eol rule.
	* blockframe.c (find_pc_partial_function): Avoid operator at end of
	line.
	* buildsym.c (find_symbol_in_list): Idem.
	(start_subfile, patch_subfile_names): Idem.
	* c-exp.y (variable, yylex): Idem.
	* c-typeprint.c (c_print_type, c_type_print_base): Idem.
	* c-valprint.c (c_val_print): Idem.
	* coffread.c (patch_opaque_types, process_coff_symbol): Idem.
	* corelow.c (core_open): Idem.
	* cris-tdep.c (move_reg_to_mem_movem_op): Idem.
	* cli/cli-decode.c (help_cmd_list, find_command_name_length): Idem.
@
text
@d4 1
a4 1
   2008, 2009 Free Software Foundation, Inc.
@


1.84
log
@	Revert 2009-08-07 changes for PR gdb/8869:

	* language.c (set_language_command): Strip whitespace.
	(set_type_command): Likewise.
	(set_range_command): Likewise.

	* language.c (language_completer): New function.
	(range_or_type_completer): New function.
	(case_completer): New function.
	(_initialize_language): Set completers.
	* cli/cli-decode.c (add_setshow_string_cmd): Return the "set"
	command.
	(add_setshow_string_noescape_cmd): Likewise.
	(add_setshow_integer_cmd): Likewise.
	(add_setshow_uinteger_cmd): Likewise.
	(add_setshow_zinteger_cmd): Likewise.
	(add_setshow_zuinteger_cmd): Likewise.
	* command.h (add_setshow_string_cmd,
	add_setshow_string_noescape_cmd, add_setshow_uinteger_cmd,
	add_setshow_zinteger_cmd, add_setshow_zuinteger_cmd): Update.
@
text
@d1054 4
a1057 4
      if (c->abbrev_flag == 0 &&
	  (class == all_commands
	   || (class == all_classes && c->func == NULL)
	   || (class == c->class && c->func != NULL)))
d1111 1
a1111 1
  while (isalnum (*p) || *p == '-' || *p == '_' ||
d1113 1
a1113 1
	 *p == '+' || *p == '<' || *p == '>' || *p == '$' ||
d1115 1
a1115 1
	 (xdb_commands && (*p == '!' || *p == '/' || *p == '?')))
@


1.83
log
@	PR gdb/8869:
	* language.c (language_completer): New function.
	(range_or_type_completer): New function.
	(case_completer): New function.
	(_initialize_language): Set completers.
	* cli/cli-decode.c (add_setshow_string_cmd): Return the "set"
	command.
	(add_setshow_string_noescape_cmd): Likewise.
	(add_setshow_integer_cmd): Likewise.
	(add_setshow_uinteger_cmd): Likewise.
	(add_setshow_zinteger_cmd): Likewise.
	(add_setshow_zuinteger_cmd): Likewise.
	* command.h (add_setshow_string_cmd,
	add_setshow_string_noescape_cmd, add_setshow_uinteger_cmd,
	add_setshow_zinteger_cmd, add_setshow_zuinteger_cmd): Update.
@
text
@d497 2
a498 3
   list for set/show or some sublist thereof).  Return the new "set"
   command.  */
struct cmd_list_element *
a507 1
  struct cmd_list_element *cmd;
d512 1
a512 2
			&cmd, NULL);
  return cmd;
d516 2
a517 3
   list for set/show or some sublist thereof).  Return the new "set"
   command.  */
struct cmd_list_element *
a526 1
  struct cmd_list_element *cmd;
d531 1
a531 2
			&cmd, NULL);
  return cmd;
d561 2
a562 3
   value.  SET_DOC and SHOW_DOC are the documentation strings.  Return
   the new "set" command.  */
struct cmd_list_element *
a571 1
  struct cmd_list_element *cmd;
d576 1
a576 2
			&cmd, NULL);
  return cmd;
d582 2
a583 3
   value.  SET_DOC and SHOW_DOC are the documentation strings.  Return
   the new "set" command.  */
struct cmd_list_element *
a592 1
  struct cmd_list_element *cmd;
d597 1
a597 2
			&cmd, NULL);
  return cmd;
d603 2
a604 3
   value.  SET_DOC and SHOW_DOC are the documentation strings.  Return
   the new "set" command.  */
struct cmd_list_element *
a613 1
  struct cmd_list_element *cmd;
d618 1
a618 2
			&cmd, NULL);
  return cmd;
d624 2
a625 3
   value.  SET_DOC and SHOW_DOC are the documentation strings.  Return
   the new "set" command.  */
struct cmd_list_element *
a634 1
  struct cmd_list_element *cmd;
d639 1
a639 2
			&cmd, NULL);
  return cmd;
@


1.82
log
@2009-06-19  Samuel Bronson  <naesten@@gmail.com>

	PR cli/9930:
	* cli/cli-decode.c (apropos_cmd): Skip traversing abbreviations
	for prefix commands to avoid duplicates in the output.
@
text
@d497 3
a499 2
   list for set/show or some sublist thereof).  */
void
d509 1
d514 2
a515 1
			NULL, NULL);
d519 3
a521 2
   list for set/show or some sublist thereof).  */
void
d531 1
d536 2
a537 1
			NULL, NULL);
d567 3
a569 2
   value.  SET_DOC and SHOW_DOC are the documentation strings.  */
void
d579 1
d584 2
a585 1
			NULL, NULL);
d591 3
a593 2
   value.  SET_DOC and SHOW_DOC are the documentation strings.  */
void
d603 1
d608 2
a609 1
			NULL, NULL);
d615 3
a617 2
   value.  SET_DOC and SHOW_DOC are the documentation strings.  */
void
d627 1
d632 2
a633 1
			NULL, NULL);
d639 3
a641 2
   value.  SET_DOC and SHOW_DOC are the documentation strings.  */
void
d651 1
d656 2
a657 1
			NULL, NULL);
@


1.81
log
@2009-06-19  Samuel Bronson  <naesten@@gmail.com>

	PR cli/9930:
	* cli/cli-decode.c (apropos_cmd): Fix avoidance of double
	printing.
@
text
@d782 5
a786 2
      /* Check if this command has subcommands */
      if (c->prefixlist != NULL)
@


1.80
log
@	* cli/cli-decode.c (add_alias_cmd): Correct assertion.
@
text
@d758 1
a758 1
  int returnvalue=1; /*Needed to avoid double printing*/
d762 1
d773 1
a773 1
      if (c->doc != NULL && returnvalue != 0)
@


1.79
log
@gdb/
2009-05-12  Pedro Alves  <pedro@@codesourcery.com>

	* cli/cli-decode.c (deprecated_add_set_cmd): Delete.
	* command.h (deprecated_add_set_cmd): Delete declaration.
	* gnu-nat.c (_initialize_gnu_nat): Replace 'maint gnu-debug' with
	'set debug gnu-nat' and 'show debug gnu-nat'.
	* i386-nat.c (_initialize_i386_nat): Replace 'maint
	show-debug-registers' with 'maint set show-debug-registers' and
	'maint show show-debug-registers'.
	* mips-linux-nat.c (_initialize_mips_linux_nat): Replace 'maint
	show-debug-registers' with 'maint set show-debug-registers' and
	'maint show show-debug-registers'.

gdb/doc/
2009-05-12  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo: Document 'set/show debug gnu-nat'.  Replace 'maint
	show-debug-regs' docs by 'maint set show-debug-regs' and 'maint
	show show-debug-regs' docs.
@
text
@d254 1
a254 1
      gdb_assert (!aliases && !prehook && prehookee
@


1.78
log
@	* infrun.c (normal_stop): Use has_stack_frames instead of
	target_has_stack.
	* mi/mi-main.c (mi_execute_command): Avoid calling inferior_thread
	when there is no thread selected.
	(mi_cmd_execute): Don't special case commands that can run without
	a valid selected thread.
	* top.c (execute_command): Don't special case commands that can
	run without a valid selected thread.  Use has_stack_frames.
	* infcmd.c (ensure_valid_thread): New.
	(continue_1, step_1, jump_command, signal_command): Use it.
	(detach_command): Error out if there's no selected thread/inferior.
	* thread.c (print_thread_info): Allow having no thread selected.
	(switch_to_thread): Don't read the PC if there is no current thread.
	(do_restore_current_thread_cleanup): Don't record the current
	frame if there is no current thread.
	(make_cleanup_restore_current_thread): Don't read frame info if
	there is no selected thread.
	(_initialize_thread): Don't mark commands as
	"no_selected_thread_ok".
	* frame.c (get_current_frame): Error out if there is no valid
	selected thread.
	(has_stack_frames): Return false if there is no valid
	selected thread.
	* cli/cli-cmds.c (init_cli_cmds): Don't mark commands as
	"no_selected_thread_ok".
	* cli/cli-decode.c (set_cmd_no_selected_thread_ok)
	(get_cmd_no_selected_thread_ok): Delete.
	* cli/cli-decode.h (CMD_NO_SELECTED_THREAD_OK): Delete.
	(set_cmd_no_selected_thread_ok, get_cmd_no_selected_thread_ok):
	Delete declaration.
	* stack.c (get_selected_block): Use has_stack_frames.
@
text
@a399 11
struct cmd_list_element *
deprecated_add_set_cmd (char *name,
			enum command_class class,
			var_types var_type,
			void *var,
			char *doc,
			struct cmd_list_element **list)
{
  return add_set_or_show_cmd (name, set_cmd, class, var_type, var, doc, list);
}

@


1.77
log
@gdb/
2009-02-06  Tom Tromey  <tromey@@redhat.com>

	* Makefile.in (SUBDIR_PYTHON_OBS): Add python-cmd.o.
	(SUBDIR_PYTHON_SRCS): Add python-cmd.c.
	(python-cmd.o): New target.
	* cli/cli-decode.c (set_cmd_completer): Add self parameter to
	completer prototype.
	(add_cmd): Initialize destroyer member of cmd_list_element. Use
	make_symbol_completion_list_fn as completer.
	(delete_cmd): Call destroyer if one is set.
	* cli/cli-decode.h (cmd_list_element): Add cmd parameter to
	completer member.  Add destroyer member.
	(set_cmd_completer): Add self parameter to
	completer prototype.
	* command.h (set_cmd_completer): Add cmd parameter to
	completer prototype.
	* completer.c (noop_completer, filename_completer,
	location_completer, expression_completer, command_completer): Adapt
	to new completer prototype.
	(complete_line_internal): Pass new parameter to completer function.
	* completer.h (noop_completer, filename_completer,
	location_completer, expression_completer, command_completer): Adapt
	prototypes to new completer prototype.
	* interps.c (interpreter_completer): Adapt to new completer
	prototype.
	* python/python-cmd.c: New file.
	* python/python-internal.h (gdbpy_initialize_commands): Add
	prototype.
	(gdbpy_doc_cst): Add forward declaration.
	* python/python.c (gdbpy_doc_cst): Declare.
	(_initialize_python): Call gdbpy_initialize_commands.  Initialize
	gdbpy_doc_cst.
	* symtab.c (make_symbol_completion_list_fn): New function.
	* symtab.h (make_symbol_completion_list_fn): Add prototype.

gdb/doc/
2009-02-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Python API): Add entry for Commands In Python.
	(Commands In Python): New node.

gdb/testsuite/
2009-02-06  Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* gdb.python/python-cmd.exp: New file.
@
text
@a114 12
void
set_cmd_no_selected_thread_ok (struct cmd_list_element *cmd)
{
  cmd->flags |= CMD_NO_SELECTED_THREAD_OK;
}

int
get_cmd_no_selected_thread_ok (struct cmd_list_element *cmd)
{
  return cmd->flags & CMD_NO_SELECTED_THREAD_OK;
}

@


1.76
log
@2009-01-23  Pedro Alves  <pedro@@codesourcery.com>

	* cli/cli-decode.c (add_setshow_zuinteger_cmd): New.
	* cli/cli-setshow.c (do_setshow_command): Handle it.
	* command.h (enum var_types): Add var_zuinteger.
	(add_setshow_zuinteger_cmd): Declare.

	* valprint.c (_initialize_valprint): Change the set input-radix
	and set output-radix commands to zuinteger type.

2009-01-23  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.base/radix.exp: Add tests to ensure that that set
	input-radix 0 and set output-radix 0 are really rejected.
@
text
@d135 2
a136 1
		   char **(*completer) (char *text, char *word))
d211 2
a212 1
  set_cmd_completer (c, make_symbol_completion_list);
d693 2
@


1.75
log
@	* NEWS: Document "define" for prefixed commands.
	* cli/cli-cmds.c (show_user): Update calls to show_user_1.  Call
	show_user_1 for prefix commands.
	* cli/cli-decode.c (help_cmd_list): Recurse for "help user-defined".
	* cli/cli-script.c (validate_comname): Rewrite to handle prefix
	commands.  Return the containing command list.
	(define_command, document_command): Update to handle prefix commands.
	(show_user_1): Add prefix and name arguments.  Handle prefix
	commands.
	* cli/cli-script.h (show_user_1): Update prototype.

	doc/
	* gdb.texinfo (Define, Hooks): Document prefix command support.

	testsuite/
	* gdb.base/define.exp: Test defining and hooking prefix commands.
	* gdb.python/python.exp: Update test for "show user" output.
@
text
@d642 21
@


1.74
log
@        Updated copyright notices for most files.
@
text
@d1055 4
@


1.73
log
@gdb
	PR cli/2563:
	* cli/cli-decode.c (delete_cmd): Add hook-related out parameters.
	(add_cmd): Update.  Install hooks into new command.
	(add_alias_cmd): Update.
gdb/testsuite
	* gdb.base/commands.exp (redefine_hook_test): New proc.
	Call it.
@
text
@d4 1
a4 1
   2008 Free Software Foundation, Inc.
@


1.72
log
@gdb
	PR gdb/1815:
	* cli/cli-decode.c (delete_cmd): Forward declare.
	(delete_cmd): Now static.  Change return type.  Remove command
	from alias chain.  Rewrite.
	(add_cmd): Initialize new fields.  Update cmd_pointer on all
	aliases.
	(add_alias_cmd): Put command on alias chain.
	* command.h (delete_cmd): Don't declare.
	* cli/cli-decode.h (delete_cmd): Don't declare.
	(struct cmd_list_element) <aliases, alias_chain>: New fields.
gdb/testsuite
	* gdb.base/commands.exp (redefine_backtrace_test): New proc.
	Call it.
@
text
@d41 5
a45 1
					    struct cmd_list_element **list);
d168 2
a169 1
  c->aliases = delete_cmd (name, list);
d172 8
a204 2
  c->hook_pre  = NULL;
  c->hook_post = NULL;
a215 2
  c->hookee_pre = NULL;
  c->hookee_post = NULL;
d259 4
a262 1
      struct cmd_list_element *aliases = delete_cmd (name, list);
d264 2
a265 1
      gdb_assert (!aliases);
d644 4
a647 1
   command had no aliases, return NULL.  */
d650 5
a654 1
delete_cmd (char *name, struct cmd_list_element **list)
d660 4
d672 2
d676 2
@


1.71
log
@revert previous change, like interpreting English is obvious ...
@
text
@d40 3
d160 1
a160 1
  struct cmd_list_element *p;
d162 5
a166 1
  delete_cmd (name, list);
d208 1
d250 3
a252 1
      delete_cmd (name, list);
d265 2
d629 3
a631 1
/* Remove the command named NAME from the command list.  */
d633 1
a633 1
void
d636 5
a640 2
  struct cmd_list_element *c;
  struct cmd_list_element *p;
d642 1
a642 1
  while (*list && strcmp ((*list)->name, name) == 0)
d644 34
a677 7
      if ((*list)->hookee_pre)
      (*list)->hookee_pre->hook_pre = 0;   /* Hook slips out of its mouth */
      if ((*list)->hookee_post)
      (*list)->hookee_post->hook_post = 0; /* Hook slips out of its bottom  */
      p = (*list)->next;
      xfree (* list);
      *list = p;
d680 1
a680 17
  if (*list)
    for (c = *list; c->next;)
      {
	if (strcmp (c->next->name, name) == 0)
	  {
          if (c->next->hookee_pre)
            c->next->hookee_pre->hook_pre = 0; /* hooked cmd gets away.  */
          if (c->next->hookee_post)
            c->next->hookee_post->hook_post = 0; /* remove post hook */
                                               /* :( no fishing metaphore */
	    p = c->next->next;
	    xfree (c->next);
	    c->next = p;
	  }
	else
	  c = c->next;
      }
@


1.70
log
@	* cli/cli-decode.c (help_cmd): Fix thinko in pre/post hook help output.
@
text
@d801 1
a801 1
                      "\tThis command is run before : %s (pre hook)\n",
d805 1
a805 1
                      "\tThis command is run after  : %s (post hook)\n",
@


1.69
log
@	* cli/cli-decode.c (lookup_cmd_1): Use memcpy.
	(lookup_cmd_composition): Likewise.
@
text
@d800 2
a801 2
    fprintf_filtered (stream, 
                      "\tThis command is run after  : %s (pre hook)\n",
d804 2
a805 2
    fprintf_filtered (stream, 
                      "\tThis command is run before : %s (post hook)\n",
a1675 2


@


1.68
log
@	Kill cmd_async_ok.
        * cli/cli-decode.h (CMD_ASYNC_OK, set_cmd_async_ok)
        (get_cmd_async_ok): Remove.
        * cli/cli-decode.c (set_cmd_async_ok, get_cmd_async_ok): Remove.
        * cli/cli-cmds.c (init_cli_cmds): Don't use set_cmd_async_ok.
        * infcmd.c (_initialize_infcmd): Likewise.
        * thread.c (_initialize_thread): Likewise.
@
text
@d1115 1
a1115 5
  for (tmp = 0; tmp < len; tmp++)
    {
      char x = (*text)[tmp];
      command[tmp] = x;
    }
d1467 1
a1467 5
      for (tmp = 0; tmp < len; tmp++)
      {
        char x = text[tmp];
        command[tmp] = x;
      }
@


1.67
log
@	Exited threads.

	* thread.c (enum thread_state): New.
	(thread_state main_thread_running): Delete, in favor of...
	(thread_state main_thread_state): ... this.  Update throughout.
	(clear_thread_inferior_resources): New, split from free_thread.
	(free_thread): Call clear_thread_inferior_resources.
	(init_thread_list): Set main thread to stopped state.
	(add_thread_silent): Take care of PTID reuses.
	(delete_thread): If deleting inferior_ptid or a thread with
	refcount > 0, mark it as exited, but still keep it in the list.
	Only notify of thread exits, if we haven't done so yet.
	(iterate_over_threads): Make it safe to delete threads while
	iterating over them.
	(do_captured_list_thread_ids): Don't account for exited threads.
	(thread_alive): Check for the THREAD_EXITED state, and don't set
	ptid to -1 on exited threads.
	(set_running): Update to account for extra possible states.
	(is_thread_state): New.
	(is_stopped, is_exited): New.
	(is_running): Implement in terms of is_thread_state.
	(any_running): Update.
	(print_thread_info): Update.  Account for exited threads.  Don't
	warn about missed frame restoring here, its done in the cleanup.
	(switch_to_thread): Don't read from a thread that has gone.
	(restore_current_thread): In non-stop mode, do a full context
	switch.
	(restore_selected_frame): Add a frame_level argument.  Rewrite.
	(struct current_thread_cleanup): Add selected_frame_level and
	was_stopped members.
	(do_restore_current_thread_cleanup): Check if thread was stopped
	and still is, and if the target has registers, stack and memory
	before restoring the selected frame.  Don't delete the cleanup
	argument here.
	(restore_current_thread_cleanup_dtor): New.
	(make_cleanup_restore_current_thread): Remove all arguments.
	Rewrite.
	(thread_apply_all_command): Update.  Prune threads.
	(thread_apply_command): Update.
	(thread_command): Account for currently selected exited thread.
	(do_captured_thread_select): Check for a running thread.  Prune
	threads.
	(_initialize_thread): Make "info threads", "thread", "thread
	apply", and "thread apply all" appliable without a selected thread.
	* gdbthread.h (struct thread_info): Replace running_ by state_.
	Add refcount.
	(is_exited, is_stopped): Declare.
	(make_cleanup_restore_current_thread): Remove all arguments.
	* infrun.c: Include "event-top.h".
	(fetch_inferior_event): In non-stop mode, restore selected thread
	and frame after handling the event and running breakpoint
	commands.  Display GDB prompt if needed.
	(normal_stop): In non-stop mode, don't print thread switching
	notice.
	* cli/cli-decode.c (set_cmd_no_selected_thread_ok)
	(get_cmd_no_selected_thread_ok): New.
	* cli/cli-decode.h (CMD_NO_SELECTED_THREAD_OK): New.
	(set_cmd_no_selected_thread_ok, get_cmd_no_selected_thread_ok):
	Declare.
	* cli/cli-cmds.c: Set "pwd", "help", "info", "show" as
	no-selected-thread ok.
	* top.c (execute_command): Check for non no-selected-thread-ok
	commands.
	* linux-nat.c (struct saved_ptids, threads_to_delete)
	(record_dead_thread, prune_lwps): Delete.
	(exit_lwp): Unconditionally delete thread.
	(linux_nat_resume): Remove prune_lwps call.
	* infcmd.c (proceed_thread_callback): Check if !is_stopped instead
	of is_running.  Adjust to make_cleanup_restore_current_thread
	interface change.
	* mi/mi-main.c (mi_cmd_execute): Only allow a few commands if the
	selected thread has exited.
	* inf-loop.c (inferior_event_handler): Don't display the prompt
	here.
	* varobj.c (c_value_of_root): Update.
	* defs.h (make_cleanup_dtor): Declare.
	* utils.c (make_cleanup_dtor): New.

	* Makefile.in (infrun.o): Depend on $(event_top_h).
@
text
@a108 12
set_cmd_async_ok (struct cmd_list_element *cmd)
{
  cmd->flags |= CMD_ASYNC_OK;
}

int
get_cmd_async_ok (struct cmd_list_element *cmd)
{
  return cmd->flags & CMD_ASYNC_OK;
}

void
@


1.66
log
@	* cli/cli-decode.c (add_setshow_optional_filename_cmd): Set
	completer for set to filename_completer.
	NEWS: Mention it.
@
text
@d120 12
@


1.65
log
@2008-05-03  Luis Machado  <luisgpm@@br.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* cli/cli-decode.c (lookup_cmd_1): Fix indentation.
	* doublest.c (convert_typed_floating): Fix typo in comment.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame-unwind.h (frame_sniffer_ftype): Likewise.
	* frame.c (frame_unwind_address_in_block): Likewise.
	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): Likewise.
	* symtab.h (struct symbol): Likewise.
	* tramp-frame.h (struct trad_frame_cache): Likewise.
	* value.c (allocate_repeat_value): Likewise.
@
text
@d542 2
d548 4
a551 1
			NULL, NULL);
@


1.64
log
@	* cli/cli-decode.h (CMD_ASYNC_OK): New define.
	(set_cmd_async_ok, get_cmd_async_ok): Declare.
	* cli/cli-decode.c (set_cmd_async_ok): New function.
	(get_cmd_async_ok): New function.
	* cli/cli-cmds.c (init_cli_cmds): Mark "pwd", "help", "info", and
	"show" as async-ok.
	* top.c (execute_command): Use get_cmd_async_ok.
	* infcmd.c: Include cli/cli-decode.h.
	(_initialize_infcmd): Mark "interrupt" as async-ok.
	* Makefile.in (infcmd.o): Depend on cli_decode_h.
@
text
@d1163 1
a1163 1
      deprecated_cmd_warning (&line);
@


1.63
log
@	Updated copyright notices for most files.
@
text
@d108 12
@


1.62
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d3 2
a4 2
   Copyright (c) 1986, 1989, 1990, 1991, 1998, 2000, 2001, 2002, 2004, 2007
   Free Software Foundation, Inc.
@


1.61
log
@2007-08-01  Michael Snyder  <msnyder@@access-company.com>

	* cli/cli-decode.c (lookup_cmd): Check for null earlier, to
	avoid dereference in lookup_cmd_1.
@
text
@d8 1
a8 1
   the Free Software Foundation; either version 2 of the License, or
d17 1
a17 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.60
log
@Copyright updates for 2007.
@
text
@d1229 1
a1229 2
  struct cmd_list_element *c =
  lookup_cmd_1 (line, list, &last_list, ignore_help_classes);
d1234 5
d1243 7
a1249 12
	  if (!*line)
	    error (_("Lack of needed %scommand"), cmdtype);
	  else
	    {
	      char *q;
	      int len = find_command_name_length (*line);

	      q = (char *) alloca (len + 1);
	      strncpy (q, *line, len);
	      q[len] = '\0';
	      undef_cmd_error (cmdtype, q);
	    }
@


1.59
log
@Improve "help all".
@
text
@d3 2
a4 2
   Copyright (c) 1986, 1989, 1990, 1991, 1998, 2000, 2001, 2002, 2004 Free
   Software Foundation, Inc.
@


1.58
log
@
	* cli/cli-utils.h:
	* cli/cli-utils.c:
	* cli/cli-setshow.h:
	* cli/cli-setshow.c:
	* cli/cli-script.h:
	* cli/cli-script.c:
	* cli/cli-logging.c:
	* cli/cli-interp.c:
	* cli/cli-dump.h:
	* cli/cli-dump.c:
	* cli/cli-decode.h:
	* cli/cli-decode.c:
	* cli/cli-cmds.h:
	* cli/cli-cmds.c: Add (c) after Copyright.  Update FSF address.
@
text
@d49 5
d695 2
a696 8
	      /* Stolen from help_cmd_list. We don't directly use
	       * help_cmd_list because it doesn't let us print out
	       * single commands
	       */
	      fprintf_filtered (stream, "%s%s -- ", prefix, c->name);
	      print_doc_line (stream, c->doc);
	      fputs_filtered ("\n", stream);
	      returnvalue=0; /*Set this so we don't print it again.*/
d704 2
a705 7
	      /* Stolen from help_cmd_list. We don't directly use
	       * help_cmd_list because it doesn't let us print out
	       * single commands
	       */
	      fprintf_filtered (stream, "%s%s -- ", prefix, c->name);
	      print_doc_line (stream, c->doc);
	      fputs_filtered ("\n", stream);
d842 3
d855 2
d866 1
a871 4
      /* If this is a prefix command, print it's subcommands */
      if (c->prefixlist)
        help_cmd_list (*c->prefixlist, all_commands, c->prefixname, 0, stream);
    
d873 6
a878 2
      else if (c->func == NULL)
        help_cmd_list (cmdlist, c->class, "", 0, stream);
d880 21
d933 20
d976 1
a976 1
    {
d982 1
a982 3
	  fprintf_filtered (stream, "%s%s -- ", prefix, c->name);
	  print_doc_line (stream, c->doc);
	  fputs_filtered ("\n", stream);
a983 4
      if (recurse
	  && c->prefixlist != 0
	  && c->abbrev_flag == 0)
	help_cmd_list (*c->prefixlist, class, c->prefixname, 1, stream);
@


1.57
log
@2005-12-06  Michael Snyder  <msnyder@@redhat.com>

	* cli/cli-decode.c (add_setshow_string_cmd): Indent.
	(add_setshow_integer_cmd): Indent.
@
text
@d3 1
a3 1
   Copyright 1986, 1989, 1990, 1991, 1998, 2000, 2001, 2002, 2004 Free
d18 2
a19 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.56
log
@2005-11-25  Andrew Stubbs  <andrew.stubbs@@st.com>

	* cli-decode.c (find_command_name_length): New function.
	(lookup_cmd_1): Replace loop reading command name with
	find_command_name_length().
	(lookup_cmd): Likewise.
	(lookup_cmd_composition): Likewise.
@
text
@d481 7
a487 7
			  char **var,
			  const char *set_doc, const char *show_doc,
			  const char *help_doc,
			  cmd_sfunc_ftype *set_func,
			  show_value_ftype *show_func,
			  struct cmd_list_element **set_list,
			  struct cmd_list_element **show_list)
d541 6
a546 6
			  const char *set_doc, const char *show_doc,
			  const char *help_doc,
			  cmd_sfunc_ftype *set_func,
			  show_value_ftype *show_func,
			  struct cmd_list_element **set_list,
			  struct cmd_list_element **show_list)
@


1.55
log
@2005-05-26  Andrew Cagney  <cagney@@gnu.org>

	* command.h (add_setshow_integer_cmd): Make VAR an integer.
	* cli/cli-decode.c (add_setshow_integer_cmd): Update to match.
	* valops.c (value_string): Add a cast.
	* eval.c (evaluate_subexp_standard): Use gdb_byte for byte buffers.
	* breakpoint.c (re_enable_breakpoints_in_shlibs): Use gdb_byte for
	byte buffers.
	* target.h (struct target_ops): For to_insert_hw_breakpoint and
	to_remove_hw_breakpoint use gdb_byte for byte buffer parameters.
	* breakpoint.h (struct bp_location): Make shadow_contents a
	gdb_byte buffer.
	* cli/cli-setshow.c (do_setshow_command): Fix cast.
	* cli/cli-dump.c (restore_section_callback)
	(restore_binary_file): Use gdb_byte for byte buffers.
	* proc-service.c (ps_ptwrite, ps_ptread, ps_pdwrite): Fix casts.
	(ps_xfer_memory): Use gdb_byte for byte buffers.
	* tracepoint.c (mem2hex): Use gdb_byte for byte buffers, and char
	for string buffers.
	* ser-tcp.c (net_open): Make len a socklen_t.
@
text
@d980 25
d1045 1
a1045 1
  char *p, *command;
d1053 2
a1054 14
  /* Treating underscores as part of command words is important
     so that "set args_foo()" doesn't get interpreted as
     "set args _foo()".  */
  /* NOTE: cagney/2003-02-13 The `tui_active' was previously
     `tui_version'.  */
  for (p = *text;
       *p && (isalnum (*p) || *p == '-' || *p == '_' ||
#if defined(TUI)
	      (tui_active &&
	       (*p == '+' || *p == '<' || *p == '>' || *p == '$')) ||
#endif
	      (xdb_commands && (*p == '!' || *p == '/' || *p == '?')));
       p++)
    ;
d1057 1
a1057 1
  if (p == *text)
a1059 2
  len = p - *text;

d1106 1
a1106 1
  *text = p;
d1208 2
a1209 1
	      char *p = *line, *q;
d1211 3
a1213 6
	      while (isalnum (*p) || *p == '-')
		p++;

	      q = (char *) alloca (p - *line + 1);
	      strncpy (q, *line, p - *line);
	      q[p - *line] = '\0';
d1391 1
a1391 1
  char *p, *command;
d1411 2
a1412 14
      /* Treating underscores as part of command words is important
       so that "set args_foo()" doesn't get interpreted as
       "set args _foo()".  */
      /* NOTE: cagney/2003-02-13 The `tui_active' was previously
	 `tui_version'.  */
      for (p = text;
         *p && (isalnum (*p) || *p == '-' || *p == '_' ||
#if defined(TUI)
                (tui_active &&
                 (*p == '+' || *p == '<' || *p == '>' || *p == '$')) ||
#endif
                (xdb_commands && (*p == '!' || *p == '/' || *p == '?')));
         p++)
      ;
d1415 2
a1416 4
      if (p == text)
      return 0;
      
      len = p - text;
d1418 1
a1418 1
      /* text and p now bracket the first command word to lookup (and
d1471 1
a1471 1
      text = p;
@


1.54
log
@2005-02-21  Andrew Cagney  <cagney@@gnu.org>

	* command.h (deprecated_add_set_cmd): Rename add_set_cmd.
	* cli/cli-decode.h (add_set_cmd): Delete declaration.
	* cli/cli-decode.c (deprecated_add_set_cmd): Rename add_set_cmd.
	* i386-nat.c (_initialize_i386_nat): Update call.
	* valprint.c (_initialize_valprint): Update comment.
	* gnu-nat.c (_initialize_gnu_nat): Update call.
@
text
@d540 1
a540 1
			  unsigned int *var,
@


1.53
log
@2005-02-21  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_set_enum_cmd): Delete function.
	(deprecated_add_show_from_set): Delete function.
	* command.h (add_set_enum_cmd): Delete declaration.
	(deprecated_add_show_from_set): Delete declaration.
	* cli/cli-decode.h (add_set_enum_cmd): Delete declaration.
	(deprecated_add_show_from_set): Delete declaration.
	* arm-tdep.c (_initialize_arm_tdep): Update comment.
	* kod.c (kod_set_os): Simplify.
	* infrun.c (set_schedlock_func): Simplify.
	* cli/cli-dump.c (add_dump_command): Update comment.
@
text
@d371 6
a376 6
add_set_cmd (char *name,
	     enum command_class class,
	     var_types var_type,
	     void *var,
	     char *doc,
	     struct cmd_list_element **list)
@


1.52
log
@2005-02-20  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_optional_filename_cmd): New
	function.
	* cli/cli-setshow.c (deprecated_show_value_hack)
	(do_setshow_command): Handle var_optional_filename.
	* command.h (enum var_types): Add var_optional_filename.
	(add_setshow_optional_filename_cmd): Declare.
	* infcmd.c (notice_args_read): Use.
@
text
@a380 23
/* Add element named NAME to command list LIST (the list for set
   or some sublist thereof).
   CLASS is as in add_cmd.
   ENUMLIST is a list of strings which may follow NAME.
   VAR is address of the variable which will contain the matching string
   (from ENUMLIST).
   DOC is the documentation string.  */

struct cmd_list_element *
add_set_enum_cmd (char *name,
		  enum command_class class,
		  const char *enumlist[],
		  const char **var,
		  char *doc,
		  struct cmd_list_element **list)
{
  struct cmd_list_element *c
  = add_set_cmd (name, class, var_enum, var, doc, list);
  c->enums = enumlist;

  return c;
}

a596 27
/* Where SETCMD has already been added, add the corresponding show
   command to LIST and return a pointer to the added command (not
   necessarily the head of LIST).  */
/* NOTE: cagney/2002-03-17: The original version of
   deprecated_add_show_from_set used memcpy() to clone `set' into
   `show'.  This meant that in addition to all the needed fields (var,
   name, et.al.) some unnecessary fields were copied (namely the
   callback function).  The function explictly copies relevant fields.
   For a `set' and `show' command to share the same callback, the
   caller must set both explicitly.  */
struct cmd_list_element *
deprecated_add_show_from_set (struct cmd_list_element *setcmd,
			      struct cmd_list_element **list)
{
  char *doc;
  const static char setstring[] = "Set ";

  /* Create a doc string by replacing "Set " at the start of the
     `set'' command's doco with "Show ".  */
  gdb_assert (strncmp (setcmd->doc, setstring, sizeof (setstring) - 1) == 0);
  doc = concat ("Show ", setcmd->doc + sizeof (setstring) - 1, NULL);

  /* Insert the basic command.  */
  return add_set_or_show_cmd (setcmd->name, show_cmd, setcmd->class,
			      setcmd->var_type, setcmd->var, doc, list);
}

@


1.51
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_integer_cmd): New function.
	* command.h (add_setshow_integer_cmd): Declare.
	* cli/cli-cmds.c: Update.
@
text
@d539 19
@


1.50
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_filename_cmd): Set the completer
	to filename_completer.
	* solib.c (_initialize_solib, reload_shared_libraries): Use
	add_setshow_filename_cmd.
	* serial.c (_initialize_serial): Ditto.
	* remote-utils.c (_initialize_sr_support): Ditto.
@
text
@d543 21
@


1.49
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* command.h (fprint_setshow_ftype): Delete.
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* complaints.c, cris-tdep.c, dwarf2read.c, frame.c: Update.
	* hppa-tdep.c, infcall.c, m32r-rom.c, maint.c: Update.
	* mips-tdep.c, nto-tdep.c, observer.c, remote-rdi.c: Update
	* remote.c, target.c, cli/cli-logging.c: Update.
@
text
@d26 1
a26 1

d491 1
d496 2
a497 1
			NULL, NULL);
@


1.48
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* command.h (fprint_setshow_ftype): Delete.
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* complaints.c, cris-tdep.c, dwarf2read.c, frame.c: Update.
	* hppa-tdep.c, infcall.c, m32r-rom.c, maint.c: Update.
	* mips-tdep.c, nto-tdep.c, observer.c, remote-rdi.c: Update
	* remote.c, target.c, cli/cli-logging.c: Update.
@
text
@d518 19
@


1.47
log
@2005-02-16  Andrew Cagney  <cagney@@gnu.org>

	Merge setshow print and show parameters.
	* command.h (show_value_ftype): Define.
	(deprecated_show_value_hack): Declare.
	(add_setshow_enum_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_filename_cmd)
	(add_setshow_string_cmd, add_setshow_uinteger_cmd)
	(add_setshow_zinteger_cmd): Change type of show_func to
	show_value_ftype.
	* cli/cli-decode.h (struct cmd_list_element): Replace
	fprint_setshow with show_value_func.
	* cli/cli-decode.c (add_setshow_cmd_full): Update show_func
	parameter.  Set show_value_func.  Do not set cmd_sfunc.
	(add_setshow_enum_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_filename_cmd)
	(add_setshow_string_cmd, add_setshow_uinteger_cmd)
	(add_setshow_zinteger_cmd): Update.
	* complaints.c (complaints_show_value): Replace
	fprint_setshow_complaints.
	(_initialize_complaints): Update.
	* mips-tdep.c (show_mask_address): Update.
	* arm-tdep.c (show_fp_model): Update.
	* cli/cli-setshow.c (do_setshow_command): Call show_value_func
	instead of fprint_setshow.  Use deprecated_show_value_hack.
	(deprecated_show_value_hack): New function.
	* remote.c (add_packet_config_cmd, show_remote_cmd):
	(show_remote_protocol_P_packet_cmd)
	(show_remote_protocol_P_packet_cmd)
	(show_remote_protocol_Z_access_wp_packet_cmd)
	(show_remote_protocol_Z_hardware_bp_packet_cmd)
	(show_remote_protocol_Z_packet_cmd)
	(show_remote_protocol_Z_read_wp_packet_cmd)
	(show_remote_protocol_Z_software_bp_packet_cmd)
	(show_remote_protocol_Z_write_wp_packet_cmd)
	(show_remote_protocol_binary_download_cmd)
	(show_remote_protocol_p_packet_cmd)
	(show_remote_protocol_qPart_auxv_packet_cmd)
	(show_remote_protocol_qSymbol_packet_cmd)
	(show_remote_protocol_vcont_packet_cmd): Update.
@
text
@a333 1
		      fprint_setshow_ftype *fprint_setshow,
a416 1
		      fprint_setshow_ftype *fprint_setshow,
a424 1
			fprint_setshow,
a440 1
			      fprint_setshow_ftype *fprint_setshow,
d449 1
a449 1
			set_doc, show_doc, help_doc, fprint_setshow,
a463 1
			 fprint_setshow_ftype *fprint_setshow,
d472 1
a472 1
			set_doc, show_doc, help_doc, fprint_setshow,
a485 1
			  fprint_setshow_ftype *fprint_setshow,
d492 1
a492 1
			set_doc, show_doc, help_doc, fprint_setshow,
a504 1
			fprint_setshow_ftype *fprint_setshow,
d511 1
a511 1
			set_doc, show_doc, help_doc, fprint_setshow,
a525 1
			  fprint_setshow_ftype *fprint_setshow,
d532 1
a532 1
			set_doc, show_doc, help_doc, fprint_setshow,
a546 1
			  fprint_setshow_ftype *fprint_setshow,
d553 1
a553 1
			set_doc, show_doc, help_doc, fprint_setshow,
@


1.46
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d336 1
a336 1
		      cmd_sfunc_ftype *show_func,
d363 1
a363 4
  show->fprint_setshow = fprint_setshow;

  if (show_func != NULL)
    set_cmd_sfunc (show, show_func);
d420 1
a420 1
		      cmd_sfunc_ftype *show_func,
d446 1
a446 1
			      cmd_sfunc_ftype *show_func,
d470 1
a470 1
			 cmd_sfunc_ftype *show_func,
d493 1
a493 1
			  cmd_sfunc_ftype *show_func,
d513 1
a513 1
			  cmd_sfunc_ftype *show_func,
d535 1
a535 1
			  cmd_sfunc_ftype *show_func,
d557 1
a557 1
			  cmd_sfunc_ftype *show_func,
@


1.45
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_enum_cmd, add_setshow_cmd_full)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Replace
	print string parameter with fprint_setshow function.
	* command.h (fprint_setshow_ftype): Define.  Update declarations.
	* cli/cli-setshow.c (do_setshow_command): When fprint_setshow is
	available, use that.
	* cli/cli-decode.h (struct cmd_list_element): Add field
	fprint_setshow.
	* complaints.c (fprint_setshow_complaints): New function.
	(_initialize_complaints): Pass to add_setshow_zinteger_cmd.
	* hppa-tdep.c (_initialize_hppa_tdep): Replace "print" parameter
	with NULL.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* cris-tdep.c (_initialize_cris_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* target.c (initialize_targets): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* breakpoint.c (_initialize_breakpoint): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
@
text
@d1157 1
a1157 1
  error ("Undefined %scommand: \"%s\".  Try \"help%s%.*s\".",
d1195 1
a1195 1
	    error ("Lack of needed %scommand", cmdtype);
d1257 1
a1257 1
	  error ("Ambiguous %scommand \"%s\": %s.", local_cmdtype,
d1639 1
a1639 1
    error ("Invalid command");
@


1.44
log
@2005-02-09  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_enum_cmd): Drop set_result and
	show_result parameters.
	* mips-tdep.c (_initialize_mips_tdep): Update calls.
	* command.h: Update declaration.
	* arm-tdep.c (_initialize_arm_tdep, _initialize_arm_tdep): Update
	calls.
@
text
@d333 2
a334 1
		      const char *help_doc, const char *print,
d363 2
d421 1
a421 1
		      const char *print,
d429 2
a430 1
			set_doc, show_doc, help_doc, print,
d446 2
a447 1
			      const char *help_doc, const char *print,
d456 1
a456 1
			set_doc, show_doc, help_doc, print,
d470 2
a471 1
			 const char *help_doc, const char *print,
d480 1
a480 1
			set_doc, show_doc, help_doc, print,
d493 2
a494 1
			  const char *help_doc, const char *print,
d501 1
a501 1
			set_doc, show_doc, help_doc, print,
d513 2
a514 1
			  const char *help_doc, const char *print,
d521 1
a521 1
			set_doc, show_doc, help_doc, print,
d535 2
a536 1
			  const char *help_doc, const char *print,
d543 1
a543 1
			set_doc, show_doc, help_doc, print,
d557 2
a558 1
			  const char *help_doc, const char *print,
d565 1
a565 1
			set_doc, show_doc, help_doc, print,
@


1.43
log
@2005-01-05  Baurjan Ismagulov  <ibr@@ata.cs.hun.edu.tr>

	Committed by Andrew Cagney.
	* ada-valprint.c, aix-thread.c, alpha-nat.c: I18n markup.
	* alphabsd-nat.c, alphanbsd-tdep.c, amd64-linux-nat.c: I18n markup.
	* amd64-tdep.c,	amd64bsd-nat.c, amd64fbsd-nat.c: I18n markup.
	* arch-utils.c, arm-linux-nat.c, arm-tdep.c: I18n markup.
	* armnbsd-nat.c, armnbsd-tdep.c, auxv.c, avr-tdep.c: I18n markup.
	* aix-thread.c (_initialize_aix_thread): Get rid of the
	deprecated_add_show_from_set call.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* command.h (add_setshow_enum_cmd): Add arguments for returning
	new list elements.
	* cli/cli-decode.c (add_setshow_enum_cmd): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Modify calls to
	add_setshow_enum_cmd.
@
text
@d422 1
a422 3
		      struct cmd_list_element **show_list,
		      struct cmd_list_element **set_result,
		      struct cmd_list_element **show_result)
d429 1
a429 1
			&c, show_result);
a430 2
  if (set_result)
    *set_result = c;
@


1.42
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_enum_cmd): New function.
	* command.h (add_setshow_enum_cmd): Declare.
	* mips-tdep.c (_initialize_mips_tdep): Use add_setshow_enum_cmd.
@
text
@d422 3
a424 1
		      struct cmd_list_element **show_list)
d431 1
a431 1
			&c, NULL);
d433 2
d1302 1
a1302 1
 
@


1.41
log
@2004-07-30  Andrew Cagney  <cagney@@gnu.org>

	* complaints.c (_initialize_complaints): Pass NULL to
	add_setshow_zinteger_cmd for help_doc.
	* cli/cli-decode.c (add_setshow_cmd_full): Handle a NULL help_doc.
@
text
@d405 28
@


1.40
log
@2004-07-28  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd): Delete function.
	(add_setshow_cmd_full): Make static.
	* command.h (add_setshow_cmd, add_setshow_cmd_full): Delete.
	(add_setshow_filename_cmd, add_setshow_string_cmd): Declare.
	* cli/cli-decode.c (add_setshow_filename_cmd)
	(add_setshow_string_cmd): New functions.
	* nto-tdep.c (_initialize_nto_tdep): Update.  Fix parameters.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* m32r-rom.c (_initialize_m32r_rom): Update.  Update copyright.
	* cli/cli-logging.c (_initialize_cli_logging): Update.
	* complaints.c (_initialize_complaints): Update.
	* remote.c (_initialize_remote): Update.
@
text
@d343 13
a355 2
  char *full_set_doc = xstrprintf ("%s\n%s", set_doc, help_doc);
  char *full_show_doc = xstrprintf ("%s\n%s", show_doc, help_doc);
@


1.39
log
@2004-07-28  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_zinteger_cmd)
	(add_setshow_cmd, add_setshow_auto_boolean_cmd)
	(add_setshow_boolean_cmd, add_setshow_cmd_full): Add help_doc and
	print parameters.  Make string parameters constant.
	* command.h: Update.  Update copyright.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* complaints.c (_initialize_complaints): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* target.c (initialize_targets): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* d10v-tdep.c (_initialize_d10v_tdep): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
@
text
@d328 1
a328 1
void
a359 22
/* Add element named NAME to both the command SET_LIST and SHOW_LIST.
   CLASS is as in add_cmd.  VAR_TYPE is the kind of thing we are
   setting.  VAR is address of the variable being controlled by this
   command.  SET_FUNC and SHOW_FUNC are the callback functions (if
   non-NULL).  SET_DOC and SHOW_DOC are the documentation strings.  */

void
add_setshow_cmd (char *name,
		 enum command_class class,
		 var_types var_type, void *var,
		 const char *set_doc, const char *show_doc,
		 const char *help_doc, const char *print,
		 cmd_sfunc_ftype *set_func, cmd_sfunc_ftype *show_func,
		 struct cmd_list_element **set_list,
		 struct cmd_list_element **show_list)
{
  add_setshow_cmd_full (name, class, var_type, var,
			set_doc, show_doc, help_doc, print,
			set_func, show_func, set_list, show_list,
			NULL, NULL);
}

d443 38
@


1.38
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d3 1
a3 1
   Copyright 1986, 1989, 1990, 1991, 1998, 2000, 2001, 2002 Free
d323 4
a326 3
   non-NULL).  SET_DOC and SHOW_DOC are the documentation strings.
   SET_RESULT and SHOW_RESULT, if not NULL, are set to the resulting
   command structures.  */
d332 4
a335 2
		      char *set_doc, char *show_doc,
		      cmd_sfunc_ftype *set_func, cmd_sfunc_ftype *show_func,
d343 2
d346 1
a346 1
			     set_doc, set_list);
d350 1
a350 1
			      show_doc, show_list);
d370 2
a371 1
		 char *set_doc, char *show_doc,
d376 2
a377 1
  add_setshow_cmd_full (name, class, var_type, var, set_doc, show_doc,
d424 2
a425 1
			      char *set_doc, char *show_doc,
d434 2
a435 1
			set_doc, show_doc, set_func, show_func,
d446 3
a448 3
add_setshow_boolean_cmd (char *name,
			 enum command_class class,
			 int *var, char *set_doc, char *show_doc,
d457 1
a457 1
			set_doc, show_doc,
d469 4
a472 3
add_setshow_uinteger_cmd (char *name,
			  enum command_class class,
			  unsigned int *var, char *set_doc, char *show_doc,
d479 1
a479 1
			set_doc, show_doc,
d490 4
a493 3
add_setshow_zinteger_cmd (char *name,
			  enum command_class class,
			  int *var, char *set_doc, char *show_doc,
d500 1
a500 1
			set_doc, show_doc,
@


1.37
log
@2004-05-07  Jason Molenda  (jmolenda@@apple.com)

        * cli/cli-decode.c: Fix "SHOW_DOR" comment typeos.
@
text
@d498 7
a504 7
/* NOTE: cagney/2002-03-17: The original version of add_show_from_set
   used memcpy() to clone `set' into `show'.  This meant that in
   addition to all the needed fields (var, name, et.al.) some
   unnecessary fields were copied (namely the callback function).  The
   function explictly copies relevant fields.  For a `set' and `show'
   command to share the same callback, the caller must set both
   explicitly.  */
d506 2
a507 2
add_show_from_set (struct cmd_list_element *setcmd,
		   struct cmd_list_element **list)
@


1.36
log
@2004-05-07  Andrew Cagney  <cagney@@redhat.com>

	* cli/cli-decode.c (add_setshow_zinteger_cmd): New function.
	* command.h (add_setshow_zinteger_cmd): Declare.
@
text
@d435 1
a435 1
   value.  SET_DOC and SHOW_DOR are the documentation strings.  */
d458 1
a458 1
   value.  SET_DOC and SHOW_DOR are the documentation strings.  */
d478 1
a478 1
   value.  SET_DOC and SHOW_DOR are the documentation strings.  */
@


1.35
log
@2004-02-10  Andrew Cagney  <cagney@@redhat.com>

	* defs.h: Do not include "tui.h".
	* gdb_curses.h: New file.
	* tui/tui-hooks.h: New file.
	* tui/tui.h (tui_update_all_exec_infos): Delete declaration.
	(tui_install_hooks, tui_remove_hooks): Delete declarations.
	(tui_initialize_io): Delete declaration.
	(tui_initialize_readline: Delete redundant declaration.
	(struct tui_point): Delete definition.
	* tui/tui-data.h (struct tui_point): Define.
	* cli/cli-decode.c [TUI]: Include "tui/tui.h".
	* utils.c: Include "tui/tui.h".
	* tui/tui-data.h: Include "tui/tui.h" and "gdb_curses.h".
	* printcmd.c [TUI]: Include "tui/tui.h".
	* cli/cli-cmds.c [TUI]: Include "tui/tui.h".
	* tui/tui-command.c: Include "gdb_curses.h".
	* tui/tui.c, tui/tui-winsource.c, tui/tui-wingeneral.c: Ditto.
	* tui/tui-windata.c, tui/tui-win.c, tui/tui-stack.c: Ditto.
	* tui/tui-source.c, tui/tui-regs.c, tui/tui-layout.c: Ditto.
	* tui/tui-io.c, tui/tui-disasm.c, tui/tui-data.c: : Ditto.
	* tui/tui-hooks.c: Include "tui-hooks.h" and "gdb_curses.h".
	* Makefile.in: Update all dependencies.
	(tui_hooks_h, gdb_curses_h): Define.
	(SUBDIR_TUI_CFLAGS): Remove -I${srcdir}/tui.
@
text
@d475 20
@


1.35.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   Copyright 1986, 1989, 1990, 1991, 1998, 2000, 2001, 2002, 2004 Free
d323 3
a325 4
   non-NULL).  SET_DOC, SHOW_DOC and HELP_DOC are the documentation
   strings.  PRINT the format string to print the value.  SET_RESULT
   and SHOW_RESULT, if not NULL, are set to the resulting command
   structures.  */
d327 1
a327 1
static void
d331 2
a332 4
		      const char *set_doc, const char *show_doc,
		      const char *help_doc, const char *print,
		      cmd_sfunc_ftype *set_func,
		      cmd_sfunc_ftype *show_func,
a339 13
  char *full_set_doc;
  char *full_show_doc;

  if (help_doc != NULL)
    {
      full_set_doc = xstrprintf ("%s\n%s", set_doc, help_doc);
      full_show_doc = xstrprintf ("%s\n%s", show_doc, help_doc);
    }
  else
    {
      full_set_doc = xstrdup (set_doc);
      full_show_doc = xstrdup (show_doc);
    }
d341 1
a341 1
			     full_set_doc, set_list);
d345 1
a345 1
			      full_show_doc, show_list);
d355 20
d417 1
a417 2
			      const char *set_doc, const char *show_doc,
			      const char *help_doc, const char *print,
d426 1
a426 2
			set_doc, show_doc, help_doc, print,
			set_func, show_func,
d435 1
a435 1
   value.  SET_DOC and SHOW_DOC are the documentation strings.  */
d437 3
a439 3
add_setshow_boolean_cmd (char *name, enum command_class class, int *var,
			 const char *set_doc, const char *show_doc,
			 const char *help_doc, const char *print,
d448 1
a448 1
			set_doc, show_doc, help_doc, print,
a455 38
   list for set/show or some sublist thereof).  */
void
add_setshow_filename_cmd (char *name, enum command_class class,
			  char **var,
			  const char *set_doc, const char *show_doc,
			  const char *help_doc, const char *print,
			  cmd_sfunc_ftype *set_func,
			  cmd_sfunc_ftype *show_func,
			  struct cmd_list_element **set_list,
			  struct cmd_list_element **show_list)
{
  add_setshow_cmd_full (name, class, var_filename, var,
			set_doc, show_doc, help_doc, print,
			set_func, show_func,
			set_list, show_list,
			NULL, NULL);
}

/* Add element named NAME to both the set and show command LISTs (the
   list for set/show or some sublist thereof).  */
void
add_setshow_string_cmd (char *name, enum command_class class,
			  char **var,
			  const char *set_doc, const char *show_doc,
			  const char *help_doc, const char *print,
			  cmd_sfunc_ftype *set_func,
			  cmd_sfunc_ftype *show_func,
			  struct cmd_list_element **set_list,
			  struct cmd_list_element **show_list)
{
  add_setshow_cmd_full (name, class, var_string, var,
			set_doc, show_doc, help_doc, print,
			set_func, show_func,
			set_list, show_list,
			NULL, NULL);
}

/* Add element named NAME to both the set and show command LISTs (the
d458 1
a458 1
   value.  SET_DOC and SHOW_DOC are the documentation strings.  */
d460 3
a462 4
add_setshow_uinteger_cmd (char *name, enum command_class class,
			  unsigned int *var,
			  const char *set_doc, const char *show_doc,
			  const char *help_doc, const char *print,
d469 1
a469 22
			set_doc, show_doc, help_doc, print,
			set_func, show_func,
			set_list, show_list,
			NULL, NULL);
}

/* Add element named NAME to both the set and show command LISTs (the
   list for set/show or some sublist thereof).  CLASS is as in
   add_cmd.  VAR is address of the variable which will contain the
   value.  SET_DOC and SHOW_DOC are the documentation strings.  */
void
add_setshow_zinteger_cmd (char *name, enum command_class class,
			  int *var,
			  const char *set_doc, const char *show_doc,
			  const char *help_doc, const char *print,
			  cmd_sfunc_ftype *set_func,
			  cmd_sfunc_ftype *show_func,
			  struct cmd_list_element **set_list,
			  struct cmd_list_element **show_list)
{
  add_setshow_cmd_full (name, class, var_zinteger, var,
			set_doc, show_doc, help_doc, print,
d478 7
a484 7
/* NOTE: cagney/2002-03-17: The original version of
   deprecated_add_show_from_set used memcpy() to clone `set' into
   `show'.  This meant that in addition to all the needed fields (var,
   name, et.al.) some unnecessary fields were copied (namely the
   callback function).  The function explictly copies relevant fields.
   For a `set' and `show' command to share the same callback, the
   caller must set both explicitly.  */
d486 2
a487 2
deprecated_add_show_from_set (struct cmd_list_element *setcmd,
			      struct cmd_list_element **list)
@


1.34
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@d32 4
@


1.33
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* cli/cli-script.c: Remove "register" attributes.
	* config/pa/tm-hppa.h: Ditto.
	* cli/cli-decode.c: Ditto.
	* cli/cli-cmds.c: Ditto.
@
text
@d506 1
a506 1
  while (*list && STREQ ((*list)->name, name))
d520 1
a520 1
	if (STREQ (c->next->name, name))
@


1.32
log
@2003-08-09  Andrew Cagney  <cagney@@redhat.com>

	Fix GDB PR cli/926.
	* cli/cli-decode.c (add_setshow_uinteger_cmd): New function.
	* command.h (add_setshow_uinteger_cmd): Declare.
	* frame.c (set_backtrace_cmd): New function.
	(show_backtrace_cmd): New function.
	* frame.c (_initialize_frame): Replace "set/show
	backtrace-below-main" with "set/show backtrace past-main".  Add
	command "set/show backtrace limit".
	(backtrace_past_main): Rename "backtrace_below_main".
	(backtrace_limit): New variable.
	(get_prev_frame): Update.  Check the backtrace_limit.

2003-08-09  Andrew Cagney  <cagney@@redhat.com>

	* gdb.texinfo (Backtrace): Replace "set/show backtrace-below-main"
	with "set/show backtrace past-main" and "set/show backtrace
	limit".

Index: doc/gdb.texinfo
===================================================================
RCS file: /cvs/src/src/gdb/doc/gdb.texinfo,v
retrieving revision 1.174
diff -u -r1.174 gdb.texinfo
--- doc/gdb.texinfo	8 Aug 2003 01:58:00 -0000	1.174
+++ doc/gdb.texinfo	9 Aug 2003 14:57:10 -0000
@@@@ -3922,27 +3922,40 @@@@
 value, indicating that your program has stopped at the beginning of the
 code for line @@code{993} of @@code{builtin.c}.

-@@kindex set backtrace-below-main
-@@kindex show backtrace-below-main
+@@kindex set backtrace past-main
+@@kindex show backtrace past-main
+@@kindex set backtrace limit
+@@kindex show backtrace limit

-Most programs have a standard entry point---a place where system libraries
-and startup code transition into user code.  For C this is @@code{main}.
-When @@value{GDBN} finds the entry function in a backtrace it will terminate
-the backtrace, to avoid tracing into highly system-specific (and generally
-uninteresting) code.  If you need to examine the startup code, then you can
-change this behavior.
+Most programs have a standard user entry point---a place where system
+libraries and startup code transition into user code.  For C this is
+@@code{main}.  When @@value{GDBN} finds the entry function in a backtrace
+it will terminate the backtrace, to avoid tracing into highly
+system-specific (and generally uninteresting) code.
+
+If you need to examine the startup code, or limit the number of levels
+in a backtrace, you can change this behavior:

 @@table @@code
-@@item set backtrace-below-main off
+@@item set backtrace past-main
+@@itemx set backtrace past-main on
+Backtraces will continue past the user entry point.
+
+@@item set backtrace past-main off
 Backtraces will stop when they encounter the user entry point.  This is the
 default.

-@@item set backtrace-below-main
-@@itemx set backtrace-below-main on
-Backtraces will continue past the user entry point to the top of the stack.
+@@item show backtrace past-main
+Display the current user entry point backtrace policy.
+
+@@item set backtrace limit @@var{n}
+@@itemx set backtrace limit 0
+@@cindex backtrace limit
+Limit the backtrace to @@var{n} levels.  A value of zero means
+unlimited.

-@@item show backtrace-below-main
-Display the current backtrace policy.
+@@item show backtrace limit
+Display the current limit on backtrace levels.
 @@end table

 @@node Selection
@
text
@d136 1
a136 1
  register struct cmd_list_element *c
d215 2
a216 2
  register struct cmd_list_element *old;
  register struct cmd_list_element *c;
d250 1
a250 1
  register struct cmd_list_element *c = add_cmd (name, class, fun, doc, list);
d265 1
a265 1
  register struct cmd_list_element *c = add_cmd (name, class, fun, doc, list);
d503 1
a503 1
  register struct cmd_list_element *c;
d580 1
a580 1
  register struct cmd_list_element *c;
d789 1
a789 1
  register char *p;
d833 1
a833 1
  register struct cmd_list_element *c;
@


1.32.4.1
log
@merge mainline changes into branch
@
text
@a31 4
#ifdef TUI
#include "tui/tui.h"		/* For tui_active et.al.   */
#endif

d136 1
a136 1
  struct cmd_list_element *c
d215 2
a216 2
  struct cmd_list_element *old;
  struct cmd_list_element *c;
d250 1
a250 1
  struct cmd_list_element *c = add_cmd (name, class, fun, doc, list);
d265 1
a265 1
  struct cmd_list_element *c = add_cmd (name, class, fun, doc, list);
d503 1
a503 1
  struct cmd_list_element *c;
d506 1
a506 1
  while (*list && strcmp ((*list)->name, name) == 0)
d520 1
a520 1
	if (strcmp (c->next->name, name) == 0)
d580 1
a580 1
  struct cmd_list_element *c;
d789 1
a789 1
  char *p;
d833 1
a833 1
  struct cmd_list_element *c;
@


1.31
log
@2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* acinclude.m4 (gcc_AC_CHECK_DECL, (gcc_AC_CHECK_DECL): Stolen
	from GCC's acinclude.m4.
	* configure.in: Check for getopt's delcaration.
	* aclocal.m4, config.in, configure: Re-generate.
	* main.c (error_init): Delete declaration.
	* defs.h (error_init): Declare.
	* rs6000-tdep.c (rs6000_fetch_pointer_argument): Make static.
	(rs6000_convert_from_func_ptr_addr): Make static.
	(_initialize_rs6000_tdep): Add declaration.
	* cli/cli-cmds.c (dont_repeat): Delete declaration.
	(show_commands, set_verbose, show_history): Delete declaration.
	* top.h (set_verbose): Add declaration.
	(show_history, set_history, show_commands): Add declaration.
	(do_restore_instream_cleanup): Add declaration.
	* objc-lang.c (specialcmp): Make static.
	(print_object_command): Make static.
	(find_objc_msgsend): Make static.
	(find_objc_msgcall_submethod_helper): Make static.
	(find_objc_msgcall_submethod): Make static.
	(_initialize_objc_language): Add declaration.
	(find_implementation_from_class): Make static.
	(find_implementation): Make static.
	* objc-exp.y (yylex): Delete lookup_struct_typedef declaration.
	* objc-lang.h (lookup_struct_typedef): Add declaration.
	* cli/cli-interp.c (_initialize_cli_interp): Add declaration.
	* cli/cli-script.c (clear_hook_in_cleanup): Make static.
	(do_restore_user_call_depth): Make static.
	(do_restore_instream_cleanup): Delete declaration.
	(dont_repeat): Delete declaration.
	* cli/cli-decode.c (add_abbrev_cmd): Delete function.
	* cli/cli-dump.c (_initialize_cli_dump): Add declaration.
	* reggroups.c (_initialize_reggroup): Add declaration.
	* cp-support.c (_initialize_cp_support): Add declaration.
	* cp-abi.c (_initialize_cp_abi): Add declaration.
	* hpacc-abi.c (_initialize_hpacc_abi): Add declaration.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Make static.
	(_initialize_gnu_v3_abi): Add declaration.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Make static.
	(_initialize_gnu_v2_abi): Add declaration.
	* frame-base.c (_initialize_frame_base): Add declaration.
	* doublest.c (floatformat_from_length): Make static.
	* frame-unwind.c (_initialize_frame_unwind): Add declaration.
	* frame.c (create_sentinel_frame): Make static.
	(_initialize_frame): Add declaration.
	* top.c (do_catch_errors): Make static.
	(gdb_rl_operate_and_get_next_completion): Make static.
	* typeprint.c: Include "typeprint.h".
	* sentinel-frame.c (sentinel_frame_prev_register): Make static.
	(sentinel_frame_this_id): Make static.
	* p-valprint.c (_initialize_pascal_valprint): Add declaration.
	* ui-out.c (make_cleanup_ui_out_begin_end): Delete function.
	* dwarf2-frame.c (dwarf2_frame_cache): Make static.
	* p-exp.y (push_current_type, pop_current_type): ISO C declaration.
	* dwarf2expr.h (dwarf_expr_context): ISO C declaration.
	* maint.c (maintenance_print_architecture): Make static.
	* signals/signals.c (_initialize_signals): Add declaration.
	* std-regs.c (_initialize_frame_reg): Add declaration.
	* jv-exp.y (push_variable): ISO C definition.
	(push_qualified_expression_name): Ditto.
	* memattr.c (_initialize_mem): Add declaration.
	* remote.c (remote_check_watch_resources): Make static.
	(remote_stopped_by_watchpoint): Make static.
	(remote_stopped_data_address): Make static.
	* d10v-tdep.c (nr_dmap_regs): Make static.
	(a0_regnum): Make static.
	(d10v_frame_unwind_cache): Make static.
	(d10v_frame_p): Make static.
	* osabi.c (show_osabi): Make static.
	(_initialize_gdb_osabi): Add extern declaration.
	* gdbtypes.c (make_qualified_type): Make static.
	(safe_parse_type): Make static.
	* macrocmd.c (_initialize_macrocmd): Add extern declaration.
	* macrotab.c (macro_bcache_free): Make static.
	* interps.c (interp_set_quiet): Make static.
	(interpreter_exec_cmd): Make static.
	* stack.h (select_frame_command): New file.
	* stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete function.
	(select_frame_command): Make global.
	* infcall.c: Include "infcall.h".
	* linespec.c: Include "linespec.h".
	* symfile.c (sections_overlap): Make static.
	* cp-support.h (cp_initialize_namespace): ISO C declaration.
	* charset.c (_initialize_charset): Add missing prototype.
	* regcache.c (init_legacy_regcache_descr): Make static.
	(do_regcache_xfree): Make static.
	(regcache_xfer_part): Make static.
	(_initialize_regcache): Add missing prototype.
	* breakpoint.c (parse_breakpoint_sals): Make static.
	(breakpoint_sals_to_pc): Make static.
	* interps.h (clear_interpreter_hooks): ISO C declaration.
	* Makefile.in (stack_h): Define.
	(stack.o, typeprint.o, mi-main.o): Update dependencies.
	(mi-cmd-stack.o, infcall.o, linespec.o): Update dependencies.

Index: mi/ChangeLog
2003-06-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-parse.c (_initialize_mi_parse): Delete function.
	* mi-main.c: Include "mi-main.h".
	* mi-interp.c (_initialize_mi_interp): Add declaration.
	* mi-cmd-stack.c: Include "stack.h".
	(select_frame_command_wrapper): Delete extern declaration.
	(mi_cmd_stack_select_frame): Replace select_frame_command_wrapper
	with select_frame_command.
@
text
@d451 20
@


1.31.4.1
log
@2003-08-09  Andrew Cagney  <cagney@@redhat.com>

	Fix GDB PR cli/926.
	* cli/cli-decode.c (add_setshow_uinteger_cmd): New function.
	* command.h (add_setshow_uinteger_cmd): Declare.
	* frame.c (set_backtrace_cmd): New function.
	(show_backtrace_cmd): New function.
	* frame.c (_initialize_frame): Replace "set/show
	backtrace-below-main" with "set/show backtrace past-main".  Add
	command "set/show backtrace limit".
	(backtrace_past_main): Rename "backtrace_below_main".
	(backtrace_limit): New variable.
	(get_prev_frame): Update.  Check the backtrace_limit.

2003-08-09  Andrew Cagney  <cagney@@redhat.com>

	* gdb.texinfo (Backtrace): Replace "set/show backtrace-below-main"
	with "set/show backtrace past-main" and "set/show backtrace
	limit".

Index: doc/gdb.texinfo
===================================================================
RCS file: /cvs/src/src/gdb/doc/gdb.texinfo,v
retrieving revision 1.174
diff -u -r1.174 gdb.texinfo
--- doc/gdb.texinfo	8 Aug 2003 01:58:00 -0000	1.174
+++ doc/gdb.texinfo	9 Aug 2003 14:57:10 -0000
@@@@ -3922,27 +3922,40 @@@@
 value, indicating that your program has stopped at the beginning of the
 code for line @@code{993} of @@code{builtin.c}.

-@@kindex set backtrace-below-main
-@@kindex show backtrace-below-main
+@@kindex set backtrace past-main
+@@kindex show backtrace past-main
+@@kindex set backtrace limit
+@@kindex show backtrace limit

-Most programs have a standard entry point---a place where system libraries
-and startup code transition into user code.  For C this is @@code{main}.
-When @@value{GDBN} finds the entry function in a backtrace it will terminate
-the backtrace, to avoid tracing into highly system-specific (and generally
-uninteresting) code.  If you need to examine the startup code, then you can
-change this behavior.
+Most programs have a standard user entry point---a place where system
+libraries and startup code transition into user code.  For C this is
+@@code{main}.  When @@value{GDBN} finds the entry function in a backtrace
+it will terminate the backtrace, to avoid tracing into highly
+system-specific (and generally uninteresting) code.
+
+If you need to examine the startup code, or limit the number of levels
+in a backtrace, you can change this behavior:

 @@table @@code
-@@item set backtrace-below-main off
+@@item set backtrace past-main
+@@itemx set backtrace past-main on
+Backtraces will continue past the user entry point.
+
+@@item set backtrace past-main off
 Backtraces will stop when they encounter the user entry point.  This is the
 default.

-@@item set backtrace-below-main
-@@itemx set backtrace-below-main on
-Backtraces will continue past the user entry point to the top of the stack.
+@@item show backtrace past-main
+Display the current user entry point backtrace policy.
+
+@@item set backtrace limit @@var{n}
+@@itemx set backtrace limit 0
+@@cindex backtrace limit
+Limit the backtrace to @@var{n} levels.  A value of zero means
+unlimited.

-@@item show backtrace-below-main
-Display the current backtrace policy.
+@@item show backtrace limit
+Display the current limit on backtrace levels.
 @@end table

 @@node Selection
@
text
@a450 20
/* Add element named NAME to both the set and show command LISTs (the
   list for set/show or some sublist thereof).  CLASS is as in
   add_cmd.  VAR is address of the variable which will contain the
   value.  SET_DOC and SHOW_DOR are the documentation strings.  */
void
add_setshow_uinteger_cmd (char *name,
			  enum command_class class,
			  unsigned int *var, char *set_doc, char *show_doc,
			  cmd_sfunc_ftype *set_func,
			  cmd_sfunc_ftype *show_func,
			  struct cmd_list_element **set_list,
			  struct cmd_list_element **show_list)
{
  add_setshow_cmd_full (name, class, var_uinteger, var,
			set_doc, show_doc,
			set_func, show_func,
			set_list, show_list,
			NULL, NULL);
}

@


1.30
log
@2003-02-14  Elena Zannoni  <ezannoni@@redhat.com>

        From Brian Ford  <ford@@vss.fsi.com>

	* cli/cli-decode.c (lookup_cmd_composition) [TUI]: Properly
	conditionalize tui_active test.
	(lookup_cmd_1): Ditto.
@
text
@a185 14
/* Same as above, except that the abbrev_flag is set. */
/* Note: Doesn't seem to be used anywhere currently. */

struct cmd_list_element *
add_abbrev_cmd (char *name, enum command_class class, void (*fun) (char *, int),
		char *doc, struct cmd_list_element **list)
{
  register struct cmd_list_element *c
  = add_cmd (name, class, fun, doc, list);

  c->abbrev_flag = 1;
  return c;
}

@


1.30.24.1
log
@Snap const char * mess.
@
text
@d133 2
a134 3
add_cmd (const char *name, enum command_class class,
	 void (*fun) (const char *, int),
	 const char *doc, struct cmd_list_element **list)
d190 1
a190 2
add_abbrev_cmd (char *name, enum command_class class,
		void (*fun) (const char *, int),
d224 1
a224 1
add_alias_cmd (const char *name, const char *oldname, enum command_class class,
d228 1
a228 1
  const char *copied_name;
d259 3
a261 4
add_prefix_cmd (const char *name, enum command_class class,
		void (*fun) (const char *, int),
		const char *doc, struct cmd_list_element **prefixlist,
		const char *prefixname, int allow_unknown,
d310 1
a310 1
add_set_or_show_cmd (const char *name,
d315 1
a315 1
		     const char *doc,
d386 1
a386 1
add_set_cmd (const char *name,
d390 1
a390 1
	     const char *doc,
d405 1
a405 1
add_set_enum_cmd (const char *name,
d409 1
a409 1
		  const char *doc,
d495 1
a495 1
delete_cmd (const char *name, struct cmd_list_element **list)
d535 1
a535 1
add_info (const char *name, void (*fun) (char *, int), const char *doc)
d543 1
a543 1
add_info_alias (const char *name, const char *oldname, int abbrev_flag)
d551 2
a552 2
add_com (const char *name, enum command_class class, void (*fun) (char *, int),
	 const char *doc)
d560 1
a560 1
add_com_alias (const char *name, const char *oldname, enum command_class class,
d572 1
a572 1
	     struct re_pattern_buffer *regex, const char *prefix)
d708 1
a708 1
help_list (struct cmd_list_element *list, const char *cmdtype,
d779 1
a779 1
print_doc_line (struct ui_file *stream, const char *str)
d783 1
a783 1
  const char *p;
d825 1
a825 1
	       const char *prefix, int recurse, struct ui_file *stream)
d1049 1
a1049 1
undef_cmd_error (const char *cmdtype, char *q)
d1112 1
a1112 1
      const char *local_cmdtype = last_list ? last_list->prefixname : cmdtype;
@


1.29
log
@2003-02-14  Andrew Cagney  <ac131313@@redhat.com>

	* main.c (tui_version): Delete variable.
	(captured_main): When --tui, set interpreter_p to "tui" instead of
	enabling tui_version.
	* printcmd.c (display_command) [TUI]: Test tui_active instead of
	tui_version.
	* cli/cli-decode.c (lookup_cmd_composition): Ditto.
	* cli/cli-cmds.c (disassemble_command): Ditto.
	* defs.h (tui_version): Delete declaration.
	* Makefile.in (SUBDIR_TUI_SRCS): Add "tui/tui-interp.c".
	(tui-interp.o): Add rules.
	(SUBDIR_TUI_OBS): Add "tui-interp.o".

Index: tui/ChangeLog
2003-02-14  Andrew Cagney  <ac131313@@redhat.com>

	* tui.c (tui_enable, tui_disable): Don't modify tui_version.
	(tui_is_window_visible, tui_get_command_dimension): Test
	tui_active instead of tui_version.
	* tuiData.h (tui_version): Delete declaration.
	* tui-hooks.c (tui_init_hook, tui_event_loop): Delete function,
	moved to "tui-interp.c".
	(tui_exit, tui_command_loop): Ditto.
	(_initialize_tui): Don't initialize init_ui_hook.  Initialize
	target_new_objfile_hook.
	* tui-interp.c: New file.
@
text
@d930 1
d933 1
d1304 1
d1307 1
@


1.28
log
@2002-07-30  Andrew Cagney  <ac131313@@redhat.com>

* symtab.h: Replace #include "gdb_obstack.h" with opaque
declaration.
* cli/cli-cmds.c, cli/cli-script.c: Include "gdb_string.h".
* gnu-v3-abi.c, arc-tdep.c, cli/cli-decode.c: Ditto.
* avr-tdep.c, mon960-rom.c, i960-tdep.c: Ditto.
* arch-utils.c, cli/cli-setshow.c: Unconditionally include
"gdb_string.h".
* Makefile.in (cli-script.o, cli-cmds.o): Update dependencies.
(gnu-v3-abi.o, cli-setshow.o, i960-tdep.o): Ditto.
(cli-decode.o, mi-cmd-var.o, mi-cmd-disas.o): Ditto.
(avr-tdep.o, mon960-rom.o): Ditto.
(aout_stabs_gnu_h): Define.
(symtab_h): Remove $(gdb_obstack_h).
@
text
@d926 2
d930 1
a930 1
	      (tui_version &&
d1298 2
d1302 1
a1302 1
                (tui_version &&
@


1.28.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d136 1
a136 1
  struct cmd_list_element *c
d186 14
d229 2
a230 2
  struct cmd_list_element *old;
  struct cmd_list_element *c;
d264 1
a264 1
  struct cmd_list_element *c = add_cmd (name, class, fun, doc, list);
d279 1
a279 1
  struct cmd_list_element *c = add_cmd (name, class, fun, doc, list);
a464 20
/* Add element named NAME to both the set and show command LISTs (the
   list for set/show or some sublist thereof).  CLASS is as in
   add_cmd.  VAR is address of the variable which will contain the
   value.  SET_DOC and SHOW_DOR are the documentation strings.  */
void
add_setshow_uinteger_cmd (char *name,
			  enum command_class class,
			  unsigned int *var, char *set_doc, char *show_doc,
			  cmd_sfunc_ftype *set_func,
			  cmd_sfunc_ftype *show_func,
			  struct cmd_list_element **set_list,
			  struct cmd_list_element **show_list)
{
  add_setshow_cmd_full (name, class, var_uinteger, var,
			set_doc, show_doc,
			set_func, show_func,
			set_list, show_list,
			NULL, NULL);
}

d497 1
a497 1
  struct cmd_list_element *c;
d500 1
a500 1
  while (*list && strcmp ((*list)->name, name) == 0)
d514 1
a514 1
	if (strcmp (c->next->name, name) == 0)
d574 1
a574 1
  struct cmd_list_element *c;
d783 1
a783 1
  char *p;
d827 1
a827 1
  struct cmd_list_element *c;
a925 2
  /* NOTE: cagney/2003-02-13 The `tui_active' was previously
     `tui_version'.  */
d928 1
a928 2
#if defined(TUI)
	      (tui_active &&
a929 1
#endif
a1295 2
      /* NOTE: cagney/2003-02-13 The `tui_active' was previously
	 `tui_version'.  */
d1298 1
a1298 2
#if defined(TUI)
                (tui_active &&
a1299 1
#endif
@


1.28.8.1
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@a925 2
  /* NOTE: cagney/2003-02-13 The `tui_active' was previously
     `tui_version'.  */
d928 1
a928 2
#if defined(TUI)
	      (tui_active &&
a929 1
#endif
a1295 2
      /* NOTE: cagney/2003-02-13 The `tui_active' was previously
	 `tui_version'.  */
d1298 1
a1298 2
#if defined(TUI)
                (tui_active &&
a1299 1
#endif
@


1.28.8.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d186 14
@


1.28.8.3
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a450 20
/* Add element named NAME to both the set and show command LISTs (the
   list for set/show or some sublist thereof).  CLASS is as in
   add_cmd.  VAR is address of the variable which will contain the
   value.  SET_DOC and SHOW_DOR are the documentation strings.  */
void
add_setshow_uinteger_cmd (char *name,
			  enum command_class class,
			  unsigned int *var, char *set_doc, char *show_doc,
			  cmd_sfunc_ftype *set_func,
			  cmd_sfunc_ftype *show_func,
			  struct cmd_list_element **set_list,
			  struct cmd_list_element **show_list)
{
  add_setshow_cmd_full (name, class, var_uinteger, var,
			set_doc, show_doc,
			set_func, show_func,
			set_list, show_list,
			NULL, NULL);
}

@


1.28.8.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d136 1
a136 1
  struct cmd_list_element *c
d215 2
a216 2
  struct cmd_list_element *old;
  struct cmd_list_element *c;
d250 1
a250 1
  struct cmd_list_element *c = add_cmd (name, class, fun, doc, list);
d265 1
a265 1
  struct cmd_list_element *c = add_cmd (name, class, fun, doc, list);
d503 1
a503 1
  struct cmd_list_element *c;
d506 1
a506 1
  while (*list && strcmp ((*list)->name, name) == 0)
d520 1
a520 1
	if (strcmp (c->next->name, name) == 0)
d580 1
a580 1
  struct cmd_list_element *c;
d789 1
a789 1
  char *p;
d833 1
a833 1
  struct cmd_list_element *c;
@


1.27
log
@2002-07-03  Martin M. Hunt  <hunt@@redhat.com>

	* top.c (execute_command): Use cmd_func() and cmd_func_p().

	* cli/cli-decode.c (cmd_func_p): New function.
	(cmd_func): New function.

	* command.h: Add cmd_func() and cmd_func_p().
@
text
@d25 1
@


1.26
log
@	* command.h (add_setshow_cmd): Declare.
	(add_setshow_cmd_full): Declare.
	* cli/cli-decode.c (add_setshow_cmd): No longer static.  Now
	returns void.  Use add_setshow_cmd_full.
	(add_setshow_cmd_full): New function.
	(add_setshow_auto_boolean_cmd): Use add_setshow_cmd_full.
	(add_setshow_boolean_cmd): Likewise.
@
text
@d1508 20
@


1.25
log
@	* cli/cli-decode.c (add_show_from_set): Fixed typo in comment.
	* target.c (initialize_targets): Fixed typo in
	trust-readonly-sections `show' documentation.
@
text
@d332 3
a334 1
   non-NULL).  SET_DOC and SHOW_DOC are the documentation strings.  */
d336 10
a345 8
static struct cmd_list_element *
add_setshow_cmd (char *name,
		 enum command_class class,
		 var_types var_type, void *var,
		 char *set_doc, char *show_doc,
		 cmd_sfunc_ftype *set_func, cmd_sfunc_ftype *show_func,
		 struct cmd_list_element **set_list,
		 struct cmd_list_element **show_list)
d357 25
a381 3
  /* The caller often wants to modify set to include info like an
     enumeration.  */
  return set;
d434 4
a437 3
  c = add_setshow_cmd (name, class, var_auto_boolean, var,
		       set_doc, show_doc, set_func, show_func,
		       set_list, show_list);
d456 5
a460 4
  c = add_setshow_cmd (name, class, var_boolean, var,
		       set_doc, show_doc,
		       set_func, show_func,
		       set_list, show_list);
@


1.24
log
@* command.h (add_setshow_auto_boolean_cmd): Replace
add_set_auto_boolean_cmd.
* cli/cli-decode.c (add_setshow_auto_boolean_cmd): Replace
add_set_auto_boolean_cmd.
* cli/cli-decode.h (add_set_auto_boolean_cmd): Delete declaration.
* mips-tdep.c (_initialize_mips_tdep): Update ``set mips
mask-address'' command.
(show_mask_address): Add cmd parameter.
* remote.c (add_packet_config_cmd): Update.  Change type of
set_func and show_func to cmd_sfunc_ftype.
(_initialize_remote): Update `set remote Z-packet'
(show_remote_protocol_qSymbol_packet_cmd): Add cmd parameter.
(show_remote_protocol_e_packet_cmd): Ditto.
(show_remote_protocol_E_packet_cmd): Ditto.
(show_remote_protocol_P_packet_cmd): Ditto.
(show_remote_protocol_Z_software_bp_packet_cmd): Ditto.
(show_remote_protocol_Z_hardware_bp_packet_cmd): Ditto.
(show_remote_protocol_Z_write_wp_packet_cmd): Ditto.
(show_remote_protocol_Z_read_wp_packet_cmd): Ditto.
(show_remote_protocol_Z_access_wp_packet_cmd): Ditto.
(show_remote_protocol_Z_packet_cmd): Ditto.
(show_remote_protocol_binary_download_cmd): Ditto.
(show_remote_cmd): Pass NULL to all of above.
@
text
@d440 1
a440 1
   used memcpy() to clone `set' into `show'.  This ment that in
@


1.23
log
@* cli/cli-decode.c (add_setshow_boolean_cmd): Replace
add_set_boolean_cmd.
(add_setshow_cmd): New function.
* command.h (add_setshow_boolean_cmd): Replace
add_set_boolean_cmd.
* remote-rdi.c (_initialize_remote_rdi): Update ``set rdiheartbeat''
and ``set rdiromatzero''.
* maint.c (_initialize_maint_cmds): Update commented out code.
* cli/cli-decode.h (add_set_boolean_cmd): Delete declaration.
* target.c (initialize_targets): Update `set
trust-readonly-sections'.
* remote.c (_initialize_remote): Update `set remotebreak'.
@
text
@d392 13
a404 11
/* Add element named NAME to command list LIST (the list for set
   or some sublist thereof).
   CLASS is as in add_cmd.
   VAR is address of the variable which will contain the value.
   DOC is the documentation string.  */
struct cmd_list_element *
add_set_auto_boolean_cmd (char *name,
			  enum command_class class,
			  enum auto_boolean *var,
			  char *doc,
			  struct cmd_list_element **list)
d408 3
a410 1
  c = add_set_cmd (name, class, var_auto_boolean, var, doc, list);
a411 1
  return c;
@


1.22
log
@* cli/cli-decode.c (set_cmd_cfunc): Update.
(set_cmd_sfunc): Update.
* command.h (cmd_cfunc_ftype, cmd_sfunc_ftype): Declare.
(set_cmd_sfunc, set_cmd_cfunc): Update.
* cli/cli-decode.h: Update.
@
text
@d328 29
d411 12
a422 11
/* Add element named NAME to command list LIST (the list for set
   or some sublist thereof).
   CLASS is as in add_cmd.
   VAR is address of the variable which will contain the value.
   DOC is the documentation string.  */
struct cmd_list_element *
add_set_boolean_cmd (char *name,
		     enum command_class class,
		     int *var,
		     char *doc,
		     struct cmd_list_element **list)
d426 4
a429 1
  c = add_set_cmd (name, class, var_boolean, var, doc, list);
a430 1
  return c;
@


1.21
log
@* defs.h (auto_boolean): Declare enum.
* command.h (cmd_auto_boolean): Delete enum.
* mips-tdep.c (mask_address_var): Update.
(mips_mask_address_p): Update.
(show_mask_address): Update.
* remote.c (struct packet_config): Update.
(update_packet_config): Update.
(show_packet_config_cmd): Update.
(packet_ok): Update.
(add_packet_config_cmd): Update.
(_initialize_remote):
* command.h: Update.
* cli/cli-setshow.c (parse_auto_binary_operation): Update.
(do_setshow_command): Update.
* cli/cli-decode.c (add_set_auto_boolean_cmd): Update.
* cli/cli-decode.h: Update.
@
text
@d56 1
a56 2
set_cmd_cfunc (struct cmd_list_element *cmd,
	       void (*cfunc) (char *args, int from_tty))
d72 1
a72 3
set_cmd_sfunc (struct cmd_list_element *cmd,
	       void (*sfunc) (char *args, int from_tty,
			      struct cmd_list_element * c))
@


1.20
log
@2002-04-12  Michael Snyder  <msnyder@@redhat.com>

	* cli/cli-decode.c (help_list): Allow long lines to wrap.
@
text
@d374 1
a374 1
			  enum cmd_auto_boolean *var,
@


1.20.4.1
log
@Merge with trunk.
@
text
@d56 2
a57 1
set_cmd_cfunc (struct cmd_list_element *cmd, cmd_cfunc_ftype *cfunc)
d73 3
a75 1
set_cmd_sfunc (struct cmd_list_element *cmd, cmd_sfunc_ftype *sfunc)
a330 29
/* Add element named NAME to both the command SET_LIST and SHOW_LIST.
   CLASS is as in add_cmd.  VAR_TYPE is the kind of thing we are
   setting.  VAR is address of the variable being controlled by this
   command.  SET_FUNC and SHOW_FUNC are the callback functions (if
   non-NULL).  SET_DOC and SHOW_DOC are the documentation strings.  */

static struct cmd_list_element *
add_setshow_cmd (char *name,
		 enum command_class class,
		 var_types var_type, void *var,
		 char *set_doc, char *show_doc,
		 cmd_sfunc_ftype *set_func, cmd_sfunc_ftype *show_func,
		 struct cmd_list_element **set_list,
		 struct cmd_list_element **show_list)
{
  struct cmd_list_element *set;
  struct cmd_list_element *show;
  set = add_set_or_show_cmd (name, set_cmd, class, var_type, var,
			     set_doc, set_list);
  if (set_func != NULL)
    set_cmd_sfunc (set, set_func);
  show = add_set_or_show_cmd (name, show_cmd, class, var_type, var,
			      show_doc, show_list);
  if (show_func != NULL)
    set_cmd_sfunc (show, show_func);
  /* The caller often wants to modify set to include info like an
     enumeration.  */
  return set;
}
d366 11
a376 13
/* Add an auto-boolean command named NAME to both the set and show
   command list lists.  CLASS is as in add_cmd.  VAR is address of the
   variable which will contain the value.  DOC is the documentation
   string.  FUNC is the corresponding callback.  */
void
add_setshow_auto_boolean_cmd (char *name,
			      enum command_class class,
			      enum auto_boolean *var,
			      char *set_doc, char *show_doc,
			      cmd_sfunc_ftype *set_func,
			      cmd_sfunc_ftype *show_func,
			      struct cmd_list_element **set_list,
			      struct cmd_list_element **show_list)
d380 1
a380 3
  c = add_setshow_cmd (name, class, var_auto_boolean, var,
		       set_doc, show_doc, set_func, show_func,
		       set_list, show_list);
d382 1
d385 11
a395 12
/* Add element named NAME to both the set and show command LISTs (the
   list for set/show or some sublist thereof).  CLASS is as in
   add_cmd.  VAR is address of the variable which will contain the
   value.  SET_DOC and SHOW_DOR are the documentation strings.  */
void
add_setshow_boolean_cmd (char *name,
			 enum command_class class,
			 int *var, char *set_doc, char *show_doc,
			 cmd_sfunc_ftype *set_func,
			 cmd_sfunc_ftype *show_func,
			 struct cmd_list_element **set_list,
			 struct cmd_list_element **show_list)
d399 1
a399 4
  c = add_setshow_cmd (name, class, var_boolean, var,
		       set_doc, show_doc,
		       set_func, show_func,
		       set_list, show_list);
d401 1
@


1.20.4.2
log
@merge with trunk
@
text
@d440 1
a440 1
   used memcpy() to clone `set' into `show'.  This meant that in
@


1.20.4.3
log
@merge with trunk.
@
text
@d332 1
a332 3
   non-NULL).  SET_DOC and SHOW_DOC are the documentation strings.
   SET_RESULT and SHOW_RESULT, if not NULL, are set to the resulting
   command structures.  */
d334 8
a341 10
void
add_setshow_cmd_full (char *name,
		      enum command_class class,
		      var_types var_type, void *var,
		      char *set_doc, char *show_doc,
		      cmd_sfunc_ftype *set_func, cmd_sfunc_ftype *show_func,
		      struct cmd_list_element **set_list,
		      struct cmd_list_element **show_list,
		      struct cmd_list_element **set_result,
		      struct cmd_list_element **show_result)
d353 3
a355 25

  if (set_result != NULL)
    *set_result = set;
  if (show_result != NULL)
    *show_result = show;
}

/* Add element named NAME to both the command SET_LIST and SHOW_LIST.
   CLASS is as in add_cmd.  VAR_TYPE is the kind of thing we are
   setting.  VAR is address of the variable being controlled by this
   command.  SET_FUNC and SHOW_FUNC are the callback functions (if
   non-NULL).  SET_DOC and SHOW_DOC are the documentation strings.  */

void
add_setshow_cmd (char *name,
		 enum command_class class,
		 var_types var_type, void *var,
		 char *set_doc, char *show_doc,
		 cmd_sfunc_ftype *set_func, cmd_sfunc_ftype *show_func,
		 struct cmd_list_element **set_list,
		 struct cmd_list_element **show_list)
{
  add_setshow_cmd_full (name, class, var_type, var, set_doc, show_doc,
			set_func, show_func, set_list, show_list,
			NULL, NULL);
d408 3
a410 4
  add_setshow_cmd_full (name, class, var_auto_boolean, var,
			set_doc, show_doc, set_func, show_func,
			set_list, show_list,
			&c, NULL);
d429 4
a432 5
  add_setshow_cmd_full (name, class, var_boolean, var,
			set_doc, show_doc,
			set_func, show_func,
			set_list, show_list,
			&c, NULL);
@


1.20.4.4
log
@merge with trunk.
@
text
@a1507 20

/* check function pointer */
int
cmd_func_p (struct cmd_list_element *cmd)
{
  return (cmd->func != NULL);
}


/* call the command function */
void
cmd_func (struct cmd_list_element *cmd, char *args, int from_tty)
{
  if (cmd_func_p (cmd))
    (*cmd->func) (cmd, args, from_tty);
  else
    error ("Invalid command");
}


@


1.20.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d56 2
a57 1
set_cmd_cfunc (struct cmd_list_element *cmd, cmd_cfunc_ftype *cfunc)
d73 3
a75 1
set_cmd_sfunc (struct cmd_list_element *cmd, cmd_sfunc_ftype *sfunc)
a330 29
/* Add element named NAME to both the command SET_LIST and SHOW_LIST.
   CLASS is as in add_cmd.  VAR_TYPE is the kind of thing we are
   setting.  VAR is address of the variable being controlled by this
   command.  SET_FUNC and SHOW_FUNC are the callback functions (if
   non-NULL).  SET_DOC and SHOW_DOC are the documentation strings.  */

static struct cmd_list_element *
add_setshow_cmd (char *name,
		 enum command_class class,
		 var_types var_type, void *var,
		 char *set_doc, char *show_doc,
		 cmd_sfunc_ftype *set_func, cmd_sfunc_ftype *show_func,
		 struct cmd_list_element **set_list,
		 struct cmd_list_element **show_list)
{
  struct cmd_list_element *set;
  struct cmd_list_element *show;
  set = add_set_or_show_cmd (name, set_cmd, class, var_type, var,
			     set_doc, set_list);
  if (set_func != NULL)
    set_cmd_sfunc (set, set_func);
  show = add_set_or_show_cmd (name, show_cmd, class, var_type, var,
			      show_doc, show_list);
  if (show_func != NULL)
    set_cmd_sfunc (show, show_func);
  /* The caller often wants to modify set to include info like an
     enumeration.  */
  return set;
}
d366 11
a376 13
/* Add an auto-boolean command named NAME to both the set and show
   command list lists.  CLASS is as in add_cmd.  VAR is address of the
   variable which will contain the value.  DOC is the documentation
   string.  FUNC is the corresponding callback.  */
void
add_setshow_auto_boolean_cmd (char *name,
			      enum command_class class,
			      enum auto_boolean *var,
			      char *set_doc, char *show_doc,
			      cmd_sfunc_ftype *set_func,
			      cmd_sfunc_ftype *show_func,
			      struct cmd_list_element **set_list,
			      struct cmd_list_element **show_list)
d380 1
a380 3
  c = add_setshow_cmd (name, class, var_auto_boolean, var,
		       set_doc, show_doc, set_func, show_func,
		       set_list, show_list);
d382 1
d385 11
a395 12
/* Add element named NAME to both the set and show command LISTs (the
   list for set/show or some sublist thereof).  CLASS is as in
   add_cmd.  VAR is address of the variable which will contain the
   value.  SET_DOC and SHOW_DOR are the documentation strings.  */
void
add_setshow_boolean_cmd (char *name,
			 enum command_class class,
			 int *var, char *set_doc, char *show_doc,
			 cmd_sfunc_ftype *set_func,
			 cmd_sfunc_ftype *show_func,
			 struct cmd_list_element **set_list,
			 struct cmd_list_element **show_list)
d399 1
a399 4
  c = add_setshow_cmd (name, class, var_boolean, var,
		       set_doc, show_doc,
		       set_func, show_func,
		       set_list, show_list);
d401 1
@


1.20.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d332 1
a332 3
   non-NULL).  SET_DOC and SHOW_DOC are the documentation strings.
   SET_RESULT and SHOW_RESULT, if not NULL, are set to the resulting
   command structures.  */
d334 8
a341 10
void
add_setshow_cmd_full (char *name,
		      enum command_class class,
		      var_types var_type, void *var,
		      char *set_doc, char *show_doc,
		      cmd_sfunc_ftype *set_func, cmd_sfunc_ftype *show_func,
		      struct cmd_list_element **set_list,
		      struct cmd_list_element **show_list,
		      struct cmd_list_element **set_result,
		      struct cmd_list_element **show_result)
d353 3
a355 25

  if (set_result != NULL)
    *set_result = set;
  if (show_result != NULL)
    *show_result = show;
}

/* Add element named NAME to both the command SET_LIST and SHOW_LIST.
   CLASS is as in add_cmd.  VAR_TYPE is the kind of thing we are
   setting.  VAR is address of the variable being controlled by this
   command.  SET_FUNC and SHOW_FUNC are the callback functions (if
   non-NULL).  SET_DOC and SHOW_DOC are the documentation strings.  */

void
add_setshow_cmd (char *name,
		 enum command_class class,
		 var_types var_type, void *var,
		 char *set_doc, char *show_doc,
		 cmd_sfunc_ftype *set_func, cmd_sfunc_ftype *show_func,
		 struct cmd_list_element **set_list,
		 struct cmd_list_element **show_list)
{
  add_setshow_cmd_full (name, class, var_type, var, set_doc, show_doc,
			set_func, show_func, set_list, show_list,
			NULL, NULL);
d408 3
a410 4
  add_setshow_cmd_full (name, class, var_auto_boolean, var,
			set_doc, show_doc, set_func, show_func,
			set_list, show_list,
			&c, NULL);
d429 4
a432 5
  add_setshow_cmd_full (name, class, var_boolean, var,
			set_doc, show_doc,
			set_func, show_func,
			set_list, show_list,
			&c, NULL);
d440 1
a440 1
   used memcpy() to clone `set' into `show'.  This meant that in
a1478 20


/* check function pointer */
int
cmd_func_p (struct cmd_list_element *cmd)
{
  return (cmd->func != NULL);
}


/* call the command function */
void
cmd_func (struct cmd_list_element *cmd, char *args, int from_tty)
{
  if (cmd_func_p (cmd))
    (*cmd->func) (cmd, args, from_tty);
  else
    error ("Invalid command");
}

@


1.20.6.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a24 1
#include "gdb_string.h"
@


1.19
log
@* cli/cli-decode.c: Include "gdb_assert.h".
(add_set_or_show_cmd): New static function.
(add_set_cmd): Rewrite.  Use add_set_or_show_cmd.
(add_show_from_set): Rewrite. Use add_set_or_show_cmd.  Don't copy
all fields, such as func, from the set command.
@
text
@d676 7
a682 3
    fprintf_filtered (stream, "\n\
Type \"help%s\" followed by a class name for a list of commands in that class.",
		      cmdtype1);
d684 1
a684 3
  fprintf_filtered (stream, "\n\
Type \"help%s\" followed by %scommand name for full documentation.\n\
Command name abbreviations are allowed if unambiguous.\n",
d686 8
@


1.18
log
@* defs.h (error): Add printf format attribute.
* thread-db.c (thread_from_lwp): Fix error format string.
* stack.c (parse_frame_specification): Ditto.
* cli/cli-decode.c (undef_cmd_error): Ditto.
* scm-lang.c (scm_lookup_name): Ditto.
* tracepoint.c (trace_error): Ditto.
* remote-utils.c (usage): Ditto.
* remote.c (compare_sections_command): Ditto.
Fix PR gdb/328.
@
text
@d31 2
d303 1
a303 1
/* Add element named NAME to command list LIST (the list for set
d305 1
d311 21
d340 1
a340 9
  struct cmd_list_element *c = add_cmd (name, class, NULL, doc, list);

  c->type = set_cmd;
  c->var_type = var_type;
  c->var = var;
  /* This needs to be something besides NULL so that this isn't
     treated as a help class.  */
  set_cmd_sfunc (c, empty_sfunc);
  return c;
d405 1
a405 1
   command to LIST and return a pointer to the added command (not 
d407 7
d418 2
a419 30
  struct cmd_list_element *showcmd =
  (struct cmd_list_element *) xmalloc (sizeof (struct cmd_list_element));
  struct cmd_list_element *p;

  memcpy (showcmd, setcmd, sizeof (struct cmd_list_element));
  delete_cmd (showcmd->name, list);
  showcmd->type = show_cmd;

  /* Replace "set " at start of docstring with "show ".  */
  if (setcmd->doc[0] == 'S' && setcmd->doc[1] == 'e'
      && setcmd->doc[2] == 't' && setcmd->doc[3] == ' ')
    showcmd->doc = concat ("Show ", setcmd->doc + 4, NULL);
  else
    fprintf_unfiltered (gdb_stderr, "GDB internal error: Bad docstring for set command\n");

  if (*list == NULL || strcmp ((*list)->name, showcmd->name) >= 0)
    {
      showcmd->next = *list;
      *list = showcmd;
    }
  else
    {
      p = *list;
      while (p->next && strcmp (p->next->name, showcmd->name) <= 0)
	{
	  p = p->next;
	}
      showcmd->next = p->next;
      p->next = showcmd;
    }
d421 8
a428 1
  return showcmd;
@


1.17
log
@* command.h (struct cmd_list_element): Add field context.
(set_cmd_context, get_cmd_context): Declare.
* cli/cli-decode.h: Ditto.
* cli/cli-decode.c (get_cmd_context): New function.
(set_cmd_context): New function.
(add_cmd): Initialize context.
Part of fixing PR gdb/145 and PR gdb/146.
@
text
@d978 1
a978 1
	 strlen (cmdtype) - 1,
@


1.16
log
@* cli/cli-decode.c (cmd_type): New function.
* command.h (cmd_type): Declare.
* infrun.c (set_schedlock_func): Call function cmd_type.
* kod.c (kod_set_os): Call cmd_type.
* cris-tdep.c (cris_version_update): Use function cmd_type.
(cris_mode_update, cris_abi_update): Ditto.
@
text
@d89 12
d161 1
@


1.15
log
@* cli/cli-decode.c (set_cmd_completer): New function.
* command.h (set_cmd_completer): Declare.
* cli/cli-decode.h (set_cmd_completer): Ditto.

* breakpoint.c (_initialize_breakpoint): Use set_cmd_completer.
* cli/cli-cmds.c (init_cli_cmds): Ditto.
* win32-nat.c (_initialize_inftarg): Ditto.
* remote-rdi.c (_initialize_remote_rdi): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* hppa-tdep.c (_initialize_hppa_tdep): Ditto.
* source.c (_initialize_source): Ditto.
* exec.c (_initialize_exec): Ditto.
* solib.c (_initialize_solib): Ditto.
* top.c (init_main): Ditto.
* tracepoint.c (_initialize_tracepoint): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* printcmd.c (_initialize_printcmd): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
@
text
@d89 6
@


1.14
log
@* cli/cli-decode.c (cmd_cfunc_eq): New function.
* command.h (cmd_cfunc_eq): Declare.
* cli/cli-decode.h (cmd_cfunc_eq): Ditto.

* cli/cli-cmds.h (is_complete_command): Change parameter to a
``struct cmd_list_element *''.
* cli/cli-cmds.c (is_complete_command): Update.  Use
cmd_cfunc_eq.
* top.c (execute_command): Pass the command to
is_complete_command.
* tracepoint.c: Replace function.cfunc with cmd_cfunc_eq.
@
text
@d89 7
d154 1
a154 1
  c->completer = make_symbol_completion_list;
@


1.13
log
@* cli/cli-decode.c (do_cfunc, set_cmd_cfunc): New functions.
(do_sfunc, set_cmd_sfunc): New functions.

* command.h (struct cmd_list_element): Add field func.
* cli/cli-decode.h (struct cmd_list_element): Ditto.
* command.h (set_cmd_sfunc, set_cmd_cfunc): Declare.
* cli/cli-decode.h: Ditto.

* cli/cli-decode.c (help_cmd): Test for func not cfunc/sfunc.
(help_all, help_cmd_list): Ditto.
(find_cmd, complete_on_cmdlist): Ditto.
* top.c (execute_command): Ditto.

* cli/cli-setshow.c (do_setshow_command): Call func instead of
function.sfunc.

* infcmd.c (notice_args_read): Fix function signature.

* cli/cli-cmds.c (init_cli_cmds): Use set_cmd_sfunc.
* cli/cli-decode.c (add_set_cmd): Ditto.
* utils.c (initialize_utils): Ditto.
* maint.c (_initialize_maint_cmds): Ditto.
* infrun.c (_initialize_infrun): Ditto.
* demangle.c (_initialize_demangler): Ditto.
* remote.c (add_packet_config_cmd): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* cris-tdep.c (_initialize_cris_tdep): Ditto.
* proc-api.c (_initialize_proc_api): Ditto.
* kod.c (_initialize_kod): Ditto.
* valprint.c (_initialize_valprint): Ditto.
* top.c (init_main): Ditto.
* infcmd.c (_initialize_infcmd): Ditto.
* corefile.c (_initialize_core): Ditto.
* arm-tdep.c (_initialize_arm_tdep): Ditto.
* arch-utils.c (initialize_current_architecture): Ditto.
(_initialize_gdbarch_utils): Ditto.
* alpha-tdep.c (_initialize_alpha_tdep): Ditto.

* cli/cli-decode.c (add_cmd): Use set_cmd_cfunc.
* wince.c (_initialize_inftarg): Ditto.
* symfile.c (_initialize_symfile): Ditto.
* mips-tdep.c (_initialize_mips_tdep): Ditto.
* language.c (_initialize_language): Ditto.
* arc-tdep.c (_initialize_arc_tdep): Ditto.
@
text
@d82 7
@


1.12
log
@s/NO_FUNCTION/NULL/
@
text
@d43 40
d128 1
a128 1
  c->function.cfunc = fun;
d208 4
a211 1
  c = add_cmd (name, class, old->function.cfunc, old->doc, list);
d290 1
a290 1
  c->function.sfunc = empty_sfunc;
d562 2
a563 2
     If c->function is nonzero, we really have a command.
     Print its documentation and return.
d565 4
a568 4
     If c->function is zero, we have a class name.
     Print its documentation (as if it were a command)
     and then set class to the number of this class
     so that the commands in the class will be listed.  */
d573 1
a573 1
  if (c->prefixlist == 0 && c->function.cfunc != NULL)
d582 1
a582 1
  if (c->function.cfunc == NULL)
d666 1
a666 1
      else if (c->function.cfunc == NULL)
d727 2
a728 2
	   || (class == all_classes && c->function.cfunc == NULL)
	   || (class == c->class && c->function.cfunc != NULL)))
d756 1
a756 1
	&& (!ignore_help_classes || c->function.cfunc))
d1287 1
a1287 1
	&& (ptr->function.cfunc
@


1.11
log
@Remove else clause to #if UI_OUT.
@
text
@d240 1
a240 2
  struct cmd_list_element *c
  = add_cmd (name, class, NO_FUNCTION, doc, list);
d245 1
a245 1
  /* This needs to be something besides NO_FUNCTION so that this isn't
@


1.10
log
@	* cli/cli-decode.c (add_cmd): Initialize pre_show_hook in
	the new command.
@
text
@d2 3
a4 2
   Copyright 1986, 1989, 1990, 1991, 1998, 2000, 2001
   Free Software Foundation, Inc.
a25 1
#ifdef UI_OUT
a26 1
#endif
a655 1
#ifdef UI_OUT
a656 3
#else
  fputs_filtered (line_buffer, stream);
#endif
@


1.9
log
@* cli/cli-decode.c (add_set_boolean_cmd): Define.
* cli/cli-decode.h (add_set_boolean_cmd): Declare.
* command.h (add_set_boolean_cmd): Ditto.
* remote.c (_initialize_remote): Use add_set_boolean_cmd for "set
remotebreak"
@
text
@d93 1
@


1.8
log
@Make GDB use libiberty regex implementation.
* gdb_regex.h: Normalize protection against multiple inclusion.
Include "xregex.h" instead of "gnu-regex.h".
* cli/cli-cmds.c: Include "gdb_regex.h" instead of "gnu-regex.h".
* cli/cli-decode.c: Likewise.
* Makefile.in (REGEX): Remove.
(GDB_CFLAGS): Remove reference to gnu-regex.h in comment.
(ADD_FILES, ADD_DEPS): Remove $(REGEX).
(POSSLIBS): Remove.
(TAGFILES_NO_SRCDIR): Remove $(POSSLIBS).
(irix5-nat.o, solib.o, solib-svr4.o, source.o, symtab.o,
xcoffsolib.o, cli-decode.o, cli-cmd.o): Replace gnu-regex.h with
gdb_regex.h in list of dependencies.
(gnu-regex.o): Remove rule.
* gnu-regex.c, gnu-regex.h: Remove files.
@
text
@d294 19
@


1.7
log
@Update/correct copyright notices.
@
text
@d23 1
a23 1
#include "gnu-regex.h"
@


1.6
log
@Replace STRCMP with strcmp()
@
text
@d2 2
a3 1
   Copyright 1986, 1989, 1990, 1991, 1998, 2000 Free Software Foundation, Inc.
@


1.5
log
@Replace free() with xfree().
@
text
@d70 1
a70 1
  if (*list == NULL || STRCMP ((*list)->name, name) >= 0)
d78 1
a78 1
      while (p->next && STRCMP (p->next->name, name) <= 0)
d315 1
a315 1
  if (*list == NULL || STRCMP ((*list)->name, showcmd->name) >= 0)
d323 1
a323 1
      while (p->next && STRCMP (p->next->name, showcmd->name) <= 0)
@


1.4
log
@2000-12-06  Fernando Nasser  <fnasser@@redhat.com>

	* cli/cli-decode.c (add_abbrev_cmd): Reinstate. Add comment saying
	that is not currently used.
@
text
@d349 1
a349 1
      free ((PTR) * list);
d364 1
a364 1
	    free ((PTR) c->next);
d629 1
a629 1
      free ((PTR) line_buffer);
d1261 1
a1261 1
      free ((PTR) matchlist);
d1332 1
a1332 1
      free ((PTR) matchlist);
@


1.3
log
@2000-12-06  Fernando Nasser  <fnasser@@redhat.com>

	* cli/cli-decode.c (lookup_cmd): Change disabled code into comment.
@
text
@d112 13
a147 18


/* Same as above, except that the abbrev_flag is set. */

#if 0				/* Currently unused */

struct cmd_list_element *
add_abbrev_cmd (char *name, enum command_class class, void (*fun) (char *, int),
		char *doc, struct cmd_list_element **list)
{
  register struct cmd_list_element *c
  = add_cmd (name, class, fun, doc, list);

  c->abbrev_flag = 1;
  return c;
}

#endif
@


1.2
log
@2000-12-06  Fernando Nasser  <fnasser@@redhat.com>

	* cli/cli-decode.c (lookup_cmd): Remove old stale copy of this routine
	which was not being used for quite some time.
@
text
@a916 3
#if 0
  /* This is wrong for complete_command.  */
  char *ptr = (*line) + strlen (*line) - 1;
d918 2
a919 5
  /* Clear off trailing whitespace.  */
  while (ptr >= *line && (*ptr == ' ' || *ptr == '\t'))
    ptr--;
  *(ptr + 1) = '\0';
#endif
@


1.1
log
@2000-12-01  Fernando Nasser  <fnasser@@redhat.com>

        * cli/cli-decode.c: New file. Handle lists of commands, their decoding
        and documentation.
        (add_cmd, deprecate_cmd, add_abbrev_cmd, add_alias_cmd, add_prefix_cmd,
        add_abbrev_prefix_cmd, not_just_help_class_command, empty_sfunc,
        add_set_cmd, add_set_enum_cmd, add_set_auto_boolean_cmd,
        add_show_from_set, delete_cmd, apropos_cmd, help_cmd, help_list,
        help_all, print_doc_line, help_cmd_list, find_cmd, lookup_cmd_1,
        undef_cmd_error, lookup_cmd, deprecated_cmd_warning,
        lookup_cmd_composition, complete_on_cmdlist, complete_on_enum):
        Moved here from command.c.
        (add_info, add_info_alias, add_com, add_com_alias): Moved here from
        top.c.
        * cli/cli-decode.h: Definitions/declarations for the above.
        * cli/cli-cmds.c: New file.  GDB CLI commands.
        (error_no_arg, info_command, show_command, help_command, show_version,
        quit_command, pwd_command, cd_command, echo_command, shell_escape,
        make_command, show_user, set_debug, show_debug, init_cmd_lists):
        Moved here from top.c.
        (apropos_command): Moved here from command.c.
        (complete_command, source_command): Moved here (part) from top.c.
        (is_complete_command): New function. Checks if a command is the
        "complete" command.
        (init_cli_cmds): New function. Add commands to the CLI (from code
        previously in top.c.
        * cli/cli-cmds.h: Definitions/declarations for the above.
        * cli/cli-script.c: New file. GDB CLI command scripting.
        (build_command_line, get_command_line, print_command_lines,
        print_command_line, execute_user_command, execute_control_command,
        while_command, if_command, arg_cleanup, setup_user_args, locate_arg,
        insert_args, realloc_body_list, read_next_line,
        recurse_read_control_structure, read_command_lines, free_command_lines,
        do_free_command_lines_cleanup, make_cleanup_free_command_lines,
        validate_comname, user_defined_command, define_command,
        document_command, source_cleanup_lines, do_fclose_cleanup,
        show_user_1): Moved here from top.c.
        (script_from_file): New function. Implements execution of a script
        contained in a file (part of code for the source_command() that used
        to exist in top.c).
        * cli/cli-script.h: Definitions/declarations for the above.
        * cli/cli-setshow.c: New file. Handle set and show GDB CLI commands.
        (parse_auto_binary_operation, parse_binary_operation,
        do_setshow_command, cmd_show_list): Moved here from command.c.
        * cli/cli-setshow.h: Definitions/declarations for the above.
        * top.c: Remove all CLI code, except the command loop.
        (gdb_init): Call init_cli_cmds().
        * command.c: Remove obsolete file.
        * command.h: Mark as DEPRECATED.
        * gdbcmd.h: Ditto.
        * call-cmds.h: Ditto.
        * Makefile.in (SFILES): Remove command.c.
        (COMMON_OBS): Remove command.o.
        (command.o): Remove obsolete target.
        (cli_decode_h, cli_cmds_h, cli_script_h, cli_setshow_h): New macros.
        Refer to CLI header files.
        (cli-decode.o, cli-cmds.o, cli-setshow.o, cli-script.o): New targets.
        (SUBDIR_CLI_OBS, SUBDIR_CLI_SRCS, SUBDIR_CLI_DEPS, SUBDIR_CLI_INITS,
        SUBDIR_CLI_LDFLAGS, SUBDIR_CLI_CFLAGS, SUBDIR_CLI_ALL, SUBDIR_CLI_CLEAN,
        SUBDIR_CLI_INSTALL, SUBDIR_CLI_UNINSTALL): New macros for new cli
        subdirectory.
        * configure.in (enable_gdbcli): New option. Include the CLI in the
        executable (cannot be disabled yet).
        (CONFIG_OBS, CONFIG_DEPS, CONFIG_SRCS, CONFIG_INITS, ENABLE_CFLAGS,
        CONFIG_ALL, CONFIG_CLEAN, CONFIG_INSTALL, CONFIG_UNINSTALL): Add
        the corresponding SUBDIR_CLI_* macros if CLI requested.
        * configure: Regenerate.
@
text
@a1213 137



#if 0
/* Look up the contents of *LINE as a command in the command list LIST.
   LIST is a chain of struct cmd_list_element's.
   If it is found, return the struct cmd_list_element for that command
   and update *LINE to point after the command name, at the first argument.
   If not found, call error if ALLOW_UNKNOWN is zero
   otherwise (or if error returns) return zero.
   Call error if specified command is ambiguous,
   unless ALLOW_UNKNOWN is negative.
   CMDTYPE precedes the word "command" in the error message.  */

struct cmd_list_element *
lookup_cmd (char **line, struct cmd_list_element *list, char *cmdtype,
	    int allow_unknown)
{
  register char *p;
  register struct cmd_list_element *c, *found;
  int nfound;
  char ambbuf[100];
  char *processed_cmd;
  int i, cmd_len;

  /* Skip leading whitespace.  */

  while (**line == ' ' || **line == '\t')
    (*line)++;

  /* Clear out trailing whitespace.  */

  p = *line + strlen (*line);
  while (p != *line && (p[-1] == ' ' || p[-1] == '\t'))
    p--;
  *p = 0;

  /* Find end of command name.  */

  p = *line;
  while (*p == '-' || isalnum (*p))
    p++;

  /* Look up the command name.
     If exact match, keep that.
     Otherwise, take command abbreviated, if unique.  Note that (in my
     opinion) a null string does *not* indicate ambiguity; simply the
     end of the argument.  */

  if (p == *line)
    {
      if (!allow_unknown)
	error ("Lack of needed %scommand", cmdtype);
      return 0;
    }

  /* Copy over to a local buffer, converting to lowercase on the way.
     This is in case the command being parsed is a subcommand which
     doesn't match anything, and that's ok.  We want the original
     untouched for the routine of the original command.  */

  processed_cmd = (char *) alloca (p - *line + 1);
  for (cmd_len = 0; cmd_len < p - *line; cmd_len++)
    {
      char x = (*line)[cmd_len];
      if (isupper (x))
	processed_cmd[cmd_len] = tolower (x);
      else
	processed_cmd[cmd_len] = x;
    }
  processed_cmd[cmd_len] = '\0';

  /* Check all possibilities in the current command list.  */
  found = 0;
  nfound = 0;
  for (c = list; c; c = c->next)
    {
      if (!strncmp (processed_cmd, c->name, cmd_len))
	{
	  found = c;
	  nfound++;
	  if (c->name[cmd_len] == 0)
	    {
	      nfound = 1;
	      break;
	    }
	}
    }

  /* Report error for undefined command name.  */

  if (nfound != 1)
    {
      if (nfound > 1 && allow_unknown >= 0)
	{
	  ambbuf[0] = 0;
	  for (c = list; c; c = c->next)
	    if (!strncmp (processed_cmd, c->name, cmd_len))
	      {
		if (strlen (ambbuf) + strlen (c->name) + 6 < sizeof ambbuf)
		  {
		    if (strlen (ambbuf))
		      strcat (ambbuf, ", ");
		    strcat (ambbuf, c->name);
		  }
		else
		  {
		    strcat (ambbuf, "..");
		    break;
		  }
	      }
	  error ("Ambiguous %scommand \"%s\": %s.", cmdtype,
		 processed_cmd, ambbuf);
	}
      else if (!allow_unknown)
	error ("Undefined %scommand: \"%s\".", cmdtype, processed_cmd);
      return 0;
    }

  /* Skip whitespace before the argument.  */

  while (*p == ' ' || *p == '\t')
    p++;
  *line = p;

  if (found->prefixlist && *p)
    {
      c = lookup_cmd (line, *found->prefixlist, found->prefixname,
		      found->allow_unknown);
      if (c)
	return c;
    }

  return found;
}
#endif

@

